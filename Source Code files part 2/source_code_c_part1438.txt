tic callback from hash table iterator to delete a CPageObject

Parameters:
    pvObj       CPageObject* to delete passed as void*

Returns:
    iccContinue
===================================================================*/
IteratorCallbackCode CPageComponentManager::DeletePageObjectCB
(
void *pvObj,
void *,
void *
)
    {
    Assert(pvObj);
    CPageObject *pObj = reinterpret_cast<CPageObject *>(pvObj);
    delete pObj;
    return iccContinue;
    }

/*===================================================================
CPageComponentManager::Init

Sets collection scope (to page)
Initializes hash tables

Parameters:
    CHitObj *pHitObj        this page

Returns:
    HRESULT
===================================================================*/
HRESULT CPageComponentManager::Init
(
CHitObj *pHitObj
)
    {
    HRESULT hr;

    // Init hash table of Page Objects
    hr = m_htidPageObjects.Init(HT_PAGE_OBJECTS_BUCKETS_MAX);
    if (FAILED(hr))
        return hr;

    // remember pHitObj
    m_pHitObj = pHitObj;

    return S_OK;
    }

/*===================================================================
CPageComponentManager::OnStartPage

Adds new page object. Ignores objects withount page info
(OnEndPage is done for all objects at the end of page)

Parameters:
    CComponentObject  *pCompObj     object to do OnStartPage
    CScriptingContext *pContext     arg to OnStart
    COnPageInfo *pOnPageInfo        pre-queried ids (optional)
    BOOL        *pfStarted          returned flag

Returns:
    HRESULT
===================================================================*/
HRESULT CPageComponentManager::OnStartPage
(
CComponentObject  *pCompObj,
CScriptingContext *pContext,
const COnPageInfo *pOnPageInfo,
BOOL              *pfStarted
)
    {
    IDispatch  *pDisp = pCompObj->m_pDisp;
    HRESULT hr = S_OK;

    if(pDisp == NULL)
        {
        Assert(pCompObj->m_dwGIPCookie != NULL_GIP_COOKIE);
        // try to restore from cookie
        hr = g_GIPAPI.Get
            (
            pCompObj->m_dwGIPCookie,
            IID_IDispatch,
            (void **)&pDisp
            );

        if (FAILED(hr))
            return hr;
        }
	else
		pDisp->AddRef();

    Assert(pDisp);

    Assert(pfStarted);
    *pfStarted = FALSE;

    // check if onpageinfo passed and the methods aren't defined
    if (pOnPageInfo && !pOnPageInfo->FHasAnyMethod())
		{
		pDisp->Release();
        return S_OK;
		}

    // check if already in the PageObject Hash
    if (m_htidPageObjects.FindObject((DWORD_PTR)pDisp) == S_OK)
        {
		pDisp->Release();
        return S_OK;
        }

    COnPageInfo OnPageInfo;

    if (pOnPageInfo)
        {
        OnPageInfo = *pOnPageInfo;
        }
    else
        {
        // dynamically create OnPageInfo if not passed
        if (Glob(fExceptionCatchEnable))
            {
            TRY
                hr = QueryOnPageInfo(pDisp, &OnPageInfo);
            CATCH(nExcept)
                HandleErrorMissingFilename(IDE_SCRIPT_OBJ_ONPAGE_QI_FAILED,
                                           m_pHitObj,
                                           TRUE,
                                           pCompObj->GetName(),
                                           nExcept);
                hr = nExcept;
            END_TRY
            }
        else
            {
            hr = QueryOnPageInfo(pDisp, &OnPageInfo);
            }

        if (FAILED(hr))
            {
			pDisp->Release();
            return hr;
            }

        // check if any of the methods is defined
        if (!OnPageInfo.FHasAnyMethod())
            {
			pDisp->Release();
            return S_OK;
            }
        }

    // create object
    CPageObject *pPageObj = new CPageObject;
    if (!pPageObj)
        {
		pDisp->Release();
        return E_OUTOFMEMORY;
        }

    // init LinkElem
    hr = pPageObj->Init(pDisp, OnPageInfo);   // this eats our previous AddRef()
    if (SUCCEEDED(hr))
        {
        // add to hash table
        hr = m_htidPageObjects.AddObject((DWORD_PTR)pDisp, pPageObj);
        }

    // cleanup if failed
    if (FAILED(hr) && pPageObj)
        {
        pDisp->Release();   // Init failed, so remove our AddRef()
        delete pPageObj;
        return hr;
        }

    *pfStarted = TRUE;

    return pPageObj->InvokeMethod
        (
        ONPAGEINFO_ONSTARTPAGE,
        pContext,
        m_pHitObj
        );
    }

/*===================================================================
PageComponentManager::OnEndPageAllObjects

Does OnEndPage() for all objects that need it
(OnStartPage() is on demand basis)

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CPageComponentManager::OnEndPageAllObjects()
    {
    HRESULT hrGlobal = S_OK;

    m_htidPageObjects.IterateObjects
        (
        OnEndPageObjectCB,
        m_pHitObj,
        &hrGlobal
        );

    return hrGlobal;
    }

/*===================================================================
CPageComponentManager::OnEndPageObjectCB

Static callback from hash table iterator to execute OnEndPage
for a CPageObject

Parameters:
    pvObj       CPageObject* to delete passed as void*

Returns:
    iccContinue
===================================================================*/
IteratorCallbackCode CPageComponentManager::OnEndPageObjectCB
(
void *pvObj,
void *pvHitObj,
void *pvhr
)
    {
    Assert(pvObj);
    Assert(pvHitObj);
    Assert(pvhr);

    CPageObject *pObj = reinterpret_cast<CPageObject *>(pvObj);

    HRESULT hr = pObj->InvokeMethod
        (
        ONPAGEINFO_ONENDPAGE,
        NULL,
        reinterpret_cast<CHitObj *>(pvHitObj)
        );

    if (FAILED(hr))
        *(reinterpret_cast<HRESULT *>(pvhr)) = hr;

    return iccContinue;
    }

/*===================================================================
CPageComponentManager::GetPageCollection

Queries HitObj for the Page's Component Collection

Parameters:
    CComponentCollection **ppCollection (out)

Returns:
    HRESULT
===================================================================*/
HRESULT CPageComponentManager::GetPageCollection
(
CComponentCollection **ppCollection
)
    {
    Assert(m_pHitObj);

    *ppCollection = NULL;

    return m_pHitObj->GetPageComponentCollection(ppCollection);
    }

/*===================================================================
CPageComponentManager::GetSessionCollection

Queries HitObj for the Session's Component Collection

Parameters:
    CComponentCollection **ppCollection (out)

Returns:
    HRESULT
===================================================================*/
HRESULT CPageComponentManager::GetSessionCollection
(
CComponentCollection **ppCollection
)
    {
    Assert(m_pHitObj);

    *ppCollection = NULL;

    return m_pHitObj->GetSessionComponentCollection(ppCollection);
    }

/*===================================================================
CPageComponentManager::GetApplnCollection

Queries HitObj for the Application's Component Collection

Parameters:
    CComponentCollection **ppCollection (out)

Returns:
    HRESULT
===================================================================*/
HRESULT CPageComponentManager::GetApplnCollection
(
CComponentCollection **ppCollection
)
    {
    Assert(m_pHitObj);

    *ppCollection = NULL;

    return m_pHitObj->GetApplnComponentCollection(ppCollection);
    }

/*===================================================================
CPageComponentManager::GetCollectionByScope

Gets the collection corresponding to the scope

Parameters:
    CompScope              csScope      (in) desired scope
    CComponentCollection **ppCollection (out)

Returns:
    HRESULT
===================================================================*/
HRESULT CPageComponentManager::GetCollectionByScope
(
CompScope scScope,
CComponentCollection **ppCollection
)
    {
    HRESULT hr = S_OK;

    switch (scScope)
        {
        case csPage:
            hr = GetPageCollection(ppCollection);
            break;
        case csSession:
            hr = GetSessionCollection(ppCollection);
            break;
        case csAppln:
            hr = GetApplnCollection(ppCollection);
            break;
        default:
            hr = E_UNEXPECTED;
            break;
        }

    if (FAILED(hr))
        *ppCollection = NULL;
    else if (*ppCollection == NULL)
        hr = E_POINTER; // to make sure we fail if no collection
    return hr;
    }

/*===================================================================
CPageComponentManager::FindScopedComponentByName

Finds object by name. Searches multiple collections if
the scope is unknown.
Internal private method used in GetScoped...()

Parameters:
    CompScope             csScope       Scope (could be csUnknown)
    LPWSTR                pwszName      Object name
    DWORD                 cbName        name length
    BOOL                  fProperty     TRUE = property,
                                        FALSE = tagged

    CComponentObject     **ppObj        (out) Object found
    CComponentCollection **ppCollection (out) Collection where found
                                              (optional)

Returns:
    HRESULT
        (S_FALSE if no error - not found)
===================================================================*/
HRESULT CPageComponentManager::FindScopedComponentByName
(
CompScope csScope,
LPWSTR pwszName,
DWORD  cbName,
BOOL   fProperty,
CComponentObject **ppObj,
CComponentCollection **ppCollection
)
    {
    int cMaxTry = (csScope == csUnknown) ? 3 : 1;
    int cTry = 0;
    *ppObj = NULL;

    while (*ppObj == NULL && cTry < cMaxTry)
        {
        HRESULT hr = S_OK;
        CComponentCollection *pCollection = NULL;

        switch (++cTry)
            {
            case 1: // page (or explicit scope) first
                if (csScope == csUnknown)
                    hr = GetPageCollection(&pCollection);
                else  // explicit scope
                    hr = GetCollectionByScope(csScope, &pCollection);
                break;
            case 2: // session
                hr = GetSessionCollection(&pCollection);
                break;
            case 3: // application
                hr = GetApplnCollection(&pCollection);
                break;
            }
        if (FAILED(hr) || !pCollection)
            continue;   // couldn't get the collection

        Assert(cbName == (wcslen(pwszName) * sizeof(WCHAR)));

        // find the object
        if (fProperty)
            {
            hr = pCollection->FindComponentPropertyByName
                (
                pwszName,
                cbName,
                ppObj
                );
            }
        else
            {
            hr = pCollection->FindComponentObjectByName
                (
                pwszName,
                cbName,
                ppObj
                );
            }

        if (hr != S_OK)
            *ppObj = NULL;

        // remember where found
        if (*ppObj && ppCollection)
            *ppCollection = pCollection;
        }

    return (*ppObj ? S_OK : S_FALSE);
    }

/*===================================================================
CPageComponentManager::AddScopedTagged

Adds a tagged object to the collection. Does not instantiate it yet.

Parameters:
    CompScope csScope      Object scope (which collection)
    LPWSTR    pwszName     Object name
    CLSID    &ClsId        Class ID
    CompModel cmModel      Object model

Returns:
    HRESULT
===================================================================*/
HRESULT CPageComponentManager::AddScopedTagged
(
CompScope csScope,
LPWSTR    pwszName,
const CLSID &ClsId,
CompModel cmModel
)
    {
    CComponentCollection *pCollection;
    HRESULT hr = GetCollectionByScope(csScope, &pCollection);
    if (FAILED(hr))
        return hr;
    return pCollection->AddTagged(pwszName, ClsId, cmModel);
    }

/*===================================================================
CPageComponentManager::AddScopedProperty

Adds a property object to the collection.
If property with the same name exists, it changes the value

Parameters:
    CompScope          csScope    Object scope (which collection)
    LPWSTR             pwszName   Object name
    VARIANT            pVariant   Property value
    CComponentObject **ppObj      [out] Property object could
                                        be NULL if not requested

Returns:
    HRESULT
===================================================================*/
HRESULT CPageComponentManager::AddScopedProperty
(
CompScope csScope,
LPWSTR pwszName,
VARIANT *pVariant,
CComponentObject **ppObj
)
    {
    CComponentCollection *pCollection;
    HRESULT hr = GetCollectionByScope(csScope, &pCollection);
    if (FAILED(hr))
        {
        if (ppObj)
            *ppObj = NULL;
        return hr;
        }
    return pCollection->AddProperty(pwszName, pVariant, ppObj);
    }

/*===================================================================
CPageComponentManager::AddScopedUnnamedInstantiated

Server.CreateObject
Also does OnStartPage (adds created pDisp as CPageObject)

Parameters:
    csScope     Object scope (which collection)
    ClsId       Class ID
    cmModel     Object model
    pOnPageInfo DispIds for OnStartPage/OnEndPage (can be NULL)
    ppObj       [out] Object Added

Returns:
    HRESULT
===================================================================*/
HRESULT CPageComponentManager::AddScopedUnnamedInstantiated
(
CompScope csScope,
const CLSID &ClsId,
CompModel cmModel,
COnPageInfo *pOnPageInfo,
CComponentObject **ppObj
)
    {
    CComponentCollection *pCollection;
    HRESULT hr = GetCollectionByScope(csScope, &pCollection);
    if (FAILED(hr))
        return hr;
    hr = pCollection->AddUnnamed(ClsId, cmModel, ppObj);
    if (FAILED(hr))
        return hr;

    CComponentObject *pObj = *ppObj;

    // remember passed OnPageInfo
    if (pOnPageInfo)
        {
        pObj->m_OnPageInfo = *pOnPageInfo;
        pObj->m_fOnPageInfoCached = TRUE;
        }

    // create it
    hr = pObj->Instantiate(m_pHitObj);
    if (FAILED(hr))
        return hr;

    // add to pointer cash
    pCollection->AddComponentToPtrHash(pObj);

    // add as page object when needed
    if (csScope == csPage
        && (pObj->m_pDisp || (pObj->m_dwGIPCookie != NULL_GIP_COOKIE))
        && m_pHitObj && m_pHitObj->FIsBrowserRequest())
        {
        BOOL fStarted = FALSE;

        hr = OnStartPage
            (
            pObj,
            m_pHitObj->PScriptingContextGet(),
            pObj->GetCachedOnPageInfo(),
            &fStarted
            );

        if (fStarted)
            pObj->m_fOnPageStarted = TRUE;
        }

    return hr;
    }

/*===================================================================
CPageComponentManager::GetScopedObjectInstantiated

Finds component object (tagged) by name.
Scope could be csUnknown.
Instantiates tagged objects.
Also does OnStartPage (adds created pDisp as CPageObject)

Parameters:
    CompScope          csScope        Scope (could be csUnknown)
    LPWSTR             pwszName       Object name
    DWORD              cbName         Object name length (in bytes)
    CComponentObject **ppObj          Object found
    BOOL              *pfNewInstance  [out] TRUE if just instantiated

Returns:
    HRESULT
===================================================================*/
HRESULT CPageComponentManager::GetScopedObjectInstantiated
(
CompScope csScope,
LPWSTR pwszName,
DWORD  cbName,
CComponentObject **ppObj,
BOOL *pfNewInstance
)
    {
    HRESULT hr;

    Assert(pfNewInstance);
    *pfNewInstance = FALSE;

    CComponentCollection *pCollection;
    hr = FindScopedComponentByName
        (
        csScope,
        pwszName,
        cbName,
        FALSE,
        ppObj,
        &pCollection
        );
    if (FAILED(hr))
        return hr;

    CComponentObject *pObj = *ppObj;
    if (!pObj)   // not failed, but not found either
        return TYPE_E_ELEMENTNOTFOUND;

    if (pObj->m_ctType != ctTagged)
        return S_OK;

    // For tagged only - instantiate and do OnStartPage()

    // For application level objects instantiation must be
    // done within critical section

    BOOL fApplnLocked = FALSE;

    Assert(m_pHitObj);

    if (!pObj->m_fInstantiatedTagged &&          // uninstantiated
        pObj->m_csScope == csAppln   &&          // application scope
        m_pHitObj->PAppln()->FFirstRequestRun()) // after GLOBAL.ASA
        {
        // Lock
        m_pHitObj->PAppln()->Lock();

        // check if the object is still uninstantiated
        if (!pObj->m_fInstantiatedTagged)
            {
            // yes, still uninstantiated - keep the lock
            fApplnLocked = TRUE;
            }
        else
            {
            // object instantiated while we waited - don't keep lock
            m_pHitObj->PAppln()->UnLock();
            }
        }

    // Instantiate tagged if needed
    if (!pObj->m_fInstantiatedTagged)
        {
        if (pObj->m_csScope == csAppln)
            {
            // For applicatin scoped objects, instantiate from MTA
            hr = CallMTACallback
                (
                CPageComponentManager::InstantiateObjectFromMTA,
                pObj,
                m_pHitObj
                );
            }
        else
            {
            hr = pObj->Instantiate(m_pHitObj);
            }

        if (SUCCEEDED(hr))
            {
            // keep count
            pCollection->m_cInstTagged++;
            // add to pointer cash
            pCollection->AddComponentToPtrHash(pObj);
            // return flag
            *pfNewInstance = TRUE;
            }

        // Flag as instantiated even if failed
        pObj->m_fInstantiatedTagged = TRUE;
        }

    // Remove the lock kept while instantiating appln level object
    if (fApplnLocked)
        m_pHitObj->PAppln()->UnLock();

    // Return if [instantiation] failed
    if (FAILED(hr))
        {
        *ppObj = NULL;
        return hr;
        }

    // Add as page object when needed
    if (pObj->m_csScope != csAppln
        && (pObj->m_pDisp || (pObj->m_dwGIPCookie != NULL_GIP_COOKIE))
        && m_pHitObj && m_pHitObj->FIsBrowserRequest())
        {
        BOOL fStarted;
        OnStartPage     // don't care if failed
            (
            pObj,
            m_pHitObj->PScriptingContextGet(),
            pObj->GetCachedOnPageInfo(),
            &fStarted
            );
        }

    return hr;
    }

/*===================================================================
CPageComponentManager::InstantiateObjectFromMTA

Static callback called by CallMTACallback() to
instantiate aplication scoped objects

Parameters:
    void *pvObj       ComponentObject
    void *pvHitObj    HitObj

Returns:
    HRESULT
===================================================================*/
HRESULT __stdcall CPageComponentManager::InstantiateObjectFromMTA
(
void *pvObj,
void *pvHitObj
)
    {
    Assert(pvHitObj);
    Assert(pvObj);

    CHitObj *pHitObj = (CHitObj *)pvHitObj;
    CComponentObject *pObj = (CComponentObject *)pvObj;

    return pObj->Instantiate(pHitObj);
    }

/*===================================================================
CPageComponentManager::GetScopedProperty

Find property component by name.
Also does OnStartPage (adds created pDisp as CPageObject)

Parameters:
    CompScope          csScope      Scope (could not be csUnknown)
    LPWSTR             pwszName     Object name
    CComponentObject **ppObj        Object found

Returns:
    HRESULT
===================================================================*/
HRESULT CPageComponentManager::GetScopedProperty
(
CompScope csScope,
LPWSTR pwszName,
CComponentObject **ppObj
)
    {
    HRESULT hr;

    hr = FindScopedComponentByName
        (
        csScope,
        pwszName,
        CbWStr(pwszName),
        TRUE,
        ppObj
        );
    if (FAILED(hr))
        return hr;

    CComponentObject *pObj = *ppObj;
    if (!pObj)   // not failed, but not found either
        return TYPE_E_ELEMENTNOTFOUND;

    // Add as page object if IDispatch * is there
    // as VT_DISPATCH property
    if (pObj->m_csScope != csAppln
        && (pObj->m_pDisp || (pObj->m_dwGIPCookie != NULL_GIP_COOKIE))
        && m_pHitObj && m_pHitObj->FIsBrowserRequest())
        {
        BOOL fStarted;
        hr = OnStartPage
            (
            pObj,
            m_pHitObj->PScriptingContextGet(),
            pObj->GetCachedOnPageInfo(),
            &fStarted
            );
        }

    return hr;
    }

/*===================================================================
CPageComponentManager::FindAnyScopeComponentByIUnknown

Find component by its IUnknown *.

Parameters:
    IUnknown          *pUnk    find by this pointer
    CComponentObject **ppObj   found object

Returns:
    HRESULT
        (S_FALSE if no error - not found)
===================================================================*/
HRESULT CPageComponentManager::FindAnyScopeComponentByIUnknown
(
IUnknown *pUnk,
CComponentObject **ppObj
)
    {
    int cTry = 0;
    *ppObj = NULL;

    while (*ppObj == NULL && cTry < 3)
        {
        HRESULT hr = S_OK;
        CComponentCollection *pCollection = NULL;

        switch (++cTry)
            {
            case 1: // page first
                hr = GetPageCollection(&pCollection);
                break;
            case 2: // session
                hr = GetSessionCollection(&pCollection);
                break;
            case 3: // application
                hr = GetApplnCollection(&pCollection);
                break;
            }
        if (FAILED(hr) || !pCollection)
            continue;   // couldn't get the collection

        // find the object
        hr = pCollection->FindComponentByIUnknownPtr(pUnk, ppObj);
        if (hr != S_OK)
            *ppObj = NULL;
        }

    return (*ppObj ? S_OK : S_FALSE);
    }

/*===================================================================
CPageComponentManager::FindAnyScopeComponentByIDispatch

Find component by its IDispatch *.
Uses FindAnyScopeComponentByIUnknown.

Parameters:
    IDispatch         *pDisp   find by this pointer
    CComponentObject **ppObj   found object

Returns:
    HRESULT
        (S_FALSE if no error - not found)
===================================================================*/
HRESULT CPageComponentManager::FindAnyScopeComponentByIDispatch
(
IDispatch *pDisp,
CComponentObject **ppObj
)
    {
    IUnknown *pUnk = NULL;
    HRESULT hr = pDisp->QueryInterface(IID_IUnknown, (void **)&pUnk);

    if (SUCCEEDED(hr) && !pUnk)
        hr = E_FAIL;

    if (FAILED(hr))
        {
        *ppObj = NULL;
        return hr;
        }

    return FindAnyScopeComponentByIUnknown(pUnk, ppObj);
    }

/*===================================================================
CPageComponentManager::FindComponentWithoutContext

The same as FindAnyScopeComponentByIDispatch -
    but static - gets context from Viper

Uses FindAnyScopeComponentByIUnknown.

Parameters:
    IDispatch         *pDisp   find by this pointer
    CComponentObject **ppObj   found object

Returns:
    HRESULT
        (S_FALSE if no error - not found)
===================================================================*/
HRESULT CPageComponentManager::FindComponentWithoutContext
(
IDispatch *pDisp,
CComponentObject **ppObj
)
    {
    // Get HitObj from Viper Context
    CHitObj *pHitObj = NULL;
    ViperGetHitObjFromContext(&pHitObj);
    if (!pHitObj)
        return E_FAIL;

    // Get page component manager
    CPageComponentManager *pPCM = pHitObj->PPageComponentManager();
    if (!pPCM)
        return E_FAIL;

    // Call the page component manager to find the object
    return pPCM->FindAnyScopeComponentByIUnknown(pDisp, ppObj);
    }

/*===================================================================
CPageComponentManager::RemoveComponent

Remove component -- the early release logic

Parameters:
    IDispatch         *pDisp   find by this pointer
    CComponentObject **ppObj   found object

Returns:
    HRESULT
===================================================================*/
 HRESULT CPageComponentManager::RemoveComponent
 (
 CComponentObject *pObj
 )
    {
    Assert(pObj);

    CComponentCollection *pCollection;
    HRESULT hr = GetCollectionByScope(pObj->m_csScope, &pCollection);
    if (FAILED(hr))
        return hr;

    return pCollection->RemoveComponent(pObj);
    }

/*===================================================================
  C  C o m p o n e n t  I t e r a t o r
===================================================================*/

/*===================================================================
CComponentIterator::CComponentIterator

CComponentIterator constructor

Parameters:
    CHitObj *pHitObj    page to init with (optional)

Returns:
===================================================================*/
CComponentIterator::CComponentIterator(CHitObj *pHitObj)
    : m_fInited(FALSE), m_fFinished(FALSE), m_pHitObj(NULL),
      m_pLastObj(NULL), m_csLastScope(csUnknown)
    {
    if (pHitObj)
        Init(pHitObj);
    }

/*===================================================================
CComponentIterator::~CComponentIterator

CComponentIterator destructor

Parameters:

Returns:
===================================================================*/
CComponentIterator::~CComponentIterator()
    {
    }

/*===================================================================
CComponentIterator::Init

Start iterating

Parameters:
    CHitObj *pHitObj    page

Returns:
    HRESULT
===================================================================*/
HRESULT CComponentIterator::Init
(
CHitObj *pHitObj
)
    {
    Assert(pHitObj);
    pHitObj->AssertValid();

    m_pHitObj = pHitObj;
    m_fInited = TRUE;
    m_fFinished = FALSE;

    m_pLastObj = NULL;
    m_csLastScope = csUnknown;

    return S_OK;
    }

/*===================================================================
CComponentIterator::WStrNextComponentName

The iteration function

Parameters:

Returns:
    Next component name or NULL if done
===================================================================*/
LPWSTR CComponentIterator::WStrNextComponentName()
    {
    Assert(m_fInited);

    if (m_fFinished)
        return NULL;

    Assert(m_pHitObj);

    CompScope csScope = m_csLastScope;
    CComponentObject *pObj = m_pLastObj ?
        static_cast<CComponentObject *>(m_pLastObj->m_pNext) : NULL;

    while (!m_fFinished)
        {
        // try the current scope

        if (pObj)
            {
            Assert(pObj->m_ctType == ctTagged);
            Assert(pObj->GetName());

            m_pLastObj = pObj;
            m_csLastScope = csScope;
            return pObj->GetName();
            }

        // couldn't find in the current scope - try next scope
        CComponentCollection *pCol = NULL;

        switch (csScope)
            {
            case csUnknown:
                csScope = csPage;
                m_pHitObj->GetPageComponentCollection(&pCol);
                break;
            case csPage:
                csScope = csSession;
                m_pHitObj->GetSessionComponentCollection(&pCol);
                break;
            case csSession:
                csScope = csAppln;
                m_pHitObj->GetApplnComponentCollection(&pCol);
                break;
            case csAppln:
            default:
                csScope = csUnknown;
                m_fFinished = TRUE;
                break;
            }

        // start at the beginning of the new collection

        if (pCol)
            pObj = static_cast<CComponentObject *>(pCol->m_htTaggedObjects.Head());
        }

    // finished
    return NULL;
    }

/*===================================================================
  C  V a r i a n t s I t e r a t o r
===================================================================*/

/*===================================================================
CVariantsIterator::CVariantsIterator

CVariantsIterator constructor by application

Parameters:
    CAppln  *pAppln       collection to init with
    DWORD    ctCollType   type of components to list iteration

Returns:
===================================================================*/
CVariantsIterator::CVariantsIterator
(
CAppln *pAppln,
DWORD ctColType
)
    : m_pCompColl(NULL), m_pAppln(NULL), m_pSession(NULL)
    {
    Assert(pAppln);
    pAppln->AddRef();

    m_cRefs = 1;
    m_pCompColl = pAppln->PCompCol();
    m_pAppln = pAppln;
    m_ctColType = ctColType;
    m_dwIndex = 0;
    }

/*===================================================================
CVariantsIterator::CVariantsIterator

CVariantsIterator constructor by session

Parameters:
    CSession *pSession        collection to init with
    DWORD     ctCollType      type of components to list iteration

Returns:
===================================================================*/
CVariantsIterator::CVariantsIterator
(
CSession *pSession,
DWORD ctColType
)
    : m_pCompColl(NULL), m_pAppln(NULL), m_pSession(NULL)
    {
    Assert(pSession);
    pSession->AddRef();

    m_cRefs = 1;
    m_pCompColl = pSession->PCompCol();
    m_ctColType = ctColType;
    m_pSession = pSession;
    m_dwIndex = 0;
    }

/*===================================================================
CVariantsIterator::~CVariantsIterator

CVariantsIterator destructor

Parameters:

Returns:
===================================================================*/
CVariantsIterator::~CVariantsIterator()
    {
    if (m_pSession)
        m_pSession->Release();
    if (m_pAppln)
        m_pAppln->Release();
    }

/*===================================================================
CVariantsIterator::QueryInterface

CVariantsIterator QI

Parameters:
    GUID&    iid
    VOID **  ppvObj

Returns: HRESULT
===================================================================*/
STDMETHODIMP CVariantsIterator::QueryInterface
(
const GUID &iid,
void **ppvObj
)
    {
    if (iid == IID_IUnknown || iid == IID_IEnumVARIANT)
        {
        AddRef();
        *ppvObj = this;
        return S_OK;
        }

    *ppvObj = NULL;
    return E_NOINTERFACE;
    }

/*===================================================================
CVariantsIterator::AddRef

CVariantsIterator AddRef

Parameters:

Returns: ULONG
===================================================================*/
STDMETHODIMP_(ULONG) CVariantsIterator::AddRef()
    {
    return ++m_cRefs;
    }

/*===================================================================
CVariantsIterator::Release

CVariantsIterator Release

Parameters:

Returns:
===================================================================*/
STDMETHODIMP_(ULONG) CVariantsIterator::Release()
    {
    if (--m_cRefs > 0)
        return m_cRefs;

    delete this;
    return 0;
    }

/*===================================================================
CVariantsIterator::Clone

CVariantsIterator Clone

Parameters:

Returns:
===================================================================*/
STDMETHODIMP CVariantsIterator::Clone
(
IEnumVARIANT **ppEnumReturn
)
    {
    CVariantsIterator *pNewIterator = NULL;
    if (m_pSession)
        {
        pNewIterator = new CVariantsIterator(m_pSession, m_ctColType);
        }
    else if (m_pAppln)
        {
        pNewIterator = new CVariantsIterator(m_pAppln, m_ctColType);
        }
    else
        {
        Assert(FALSE);  // better be either Appln or Session
        return E_FAIL;
        }

    if (pNewIterator == NULL)
        return E_OUTOFMEMORY;

    // new iterator should point to same location as this.
    pNewIterator->m_dwIndex = m_dwIndex;

    *ppEnumReturn = pNewIterator;
    return S_OK;
    }

/*===================================================================
CVariantsIterator::Next

CVariantsIterator Next

Parameters:

Returns:
===================================================================*/
STDMETHODIMP CVariantsIterator::Next
(
unsigned long cElementsRequested,
VARIANT *rgVariant,
unsigned long *pcElementsFetched
)
    {
    // give a valid pointer value to 'pcElementsFetched'
    unsigned long cElementsFetched;
    if (pcElementsFetched == NULL)
        pcElementsFetched = &cElementsFetched;

    if (cElementsRequested == 0)
        {
        if (pcElementsFetched)
            *pcElementsFetched = 0;
        return S_OK;
        }

    DWORD cMax = 0;
    if (m_ctColType == ctTagged)
        {
        cMax = m_pCompColl ? m_pCompColl->m_cAllTagged : 0;
        }
    else if (m_ctColType == ctProperty)
        {
        cMax = m_pCompColl ? m_pCompColl->m_cProperties : 0;
        }
    else
        {
        // Should always be either tagged object or property
        Assert(FALSE);
        return E_FAIL;
        }

    // Loop through the collection until either we reach the end or
    // cElements becomes zero
    //
    unsigned long cElements = cElementsRequested;
    *pcElementsFetched = 0;

    while (cElements > 0 && m_dwIndex < cMax)
        {
        LPWSTR pwszName = NULL;

        if (m_pAppln) 
            m_pAppln->Lock();

        m_pCompColl->GetNameByIndex(m_ctColType, ++m_dwIndex, &pwszName);

        if (!pwszName) {
            if (m_pAppln)
                m_pAppln->UnLock();
            continue;
        }

        BSTR bstrT = SysAllocString(pwszName);

        if (m_pAppln)
            m_pAppln->UnLock();

        if (!bstrT)
            return E_OUTOFMEMORY;

        V_VT(rgVariant) = VT_BSTR;
        V_BSTR(rgVariant) = bstrT;
		++rgVariant;

        --cElements;
        ++(*pcElementsFetched);
        }

    // initialize the remaining variants
    while (cElements-- > 0)
        VariantInit(rgVariant++);

    return (*pcElementsFetched == cElementsRequested)? S_OK : S_FALSE;
    }

/*===================================================================
CVariantsIterator::Skip

CVariantsIterator Skip

Parameters:

Returns:
===================================================================*/
STDMETHODIMP CVariantsIterator::Skip
(
unsigned long cElements
)
    {
    /* Adjust the index by cElements or
     * until we hit the max element
     */
    DWORD cMax = 0;

    // We iterate over different arrays depending on the collection type
    if (m_ctColType == ctTagged)
        {
        cMax = m_pCompColl ? m_pCompColl->m_cAllTagged : 0;
        }
    else if (m_ctColType == ctProperty)
        {
        cMax = m_pCompColl ? m_pCompColl->m_cProperties : 0;
        }
    else
        {
        // Should always be either tagged object or property
        Assert(FALSE);
        return E_FAIL;
        }

	m_dwIndex += cElements;
    return (m_dwIndex < cMax)? S_OK : S_FALSE;
    }

/*===================================================================
CVariantsIterator::Reset

CVariantsIterator Reset

Parameters:

Returns:
===================================================================*/
STDMETHODIMP CVariantsIterator::Reset()
    {
    m_dwIndex = 0;
    return NO_ERROR;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\compcol.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Component Collection

File: Compcol.h

Owner: DmitryR

This is the Component Collection header file.

Component collection replaces:  (used in:)
COleVar, COleVarList            (HitObj, Session, Application)
CObjectCover                    (HitObj, Server, Session)
VariantLink HasTable            (Session, Application)
===================================================================*/

#ifndef COMPCOL_H
#define COMPCOL_H

/*===================================================================
  Special OLE stuff
===================================================================*/

#include "gip.h"

/*===================================================================
  Misc declarations
===================================================================*/

#include "hashing.h"
#include "idhash.h"
#include "dbllink.h"
#include "util.h"
#include "viperint.h"
#include "memcls.h"

// Forward declarations
class CHitObj;
class CAppln;
class CSession;
class CScriptingContext;

// Component Types
#define CompType    DWORD
#define ctUnknown   0x00000000  // (Used as UnInitialized state)
#define ctTagged    0x00000001  // Created by <OBJECT ...> tag
#define ctProperty  0x00000002  // Created with Session("xxx") =
#define ctUnnamed   0x00000004  // Created with Server.CreateObject()

// Scope levels 
#define CompScope   DWORD
#define csUnknown   0x00000000
#define csAppln     0x00000001
#define csSession   0x00000002
#define csPage      0x00000004

// COM threading models
#define CompModel   DWORD
#define cmUnknown   0x00000000
#define cmSingle    0x00000001
#define cmApartment 0x00000002
#define cmFree      0x00000004
#define cmBoth      0x00000008

/*===================================================================
  Utility Functions Prototypes
===================================================================*/

HRESULT CompModelFromCLSID
    (
    const CLSID &ClsId, 
    CompModel *pcmModel = NULL, 
    BOOL *pfInProc = NULL
    );

BOOL FIsIntrinsic(IDispatch *pdisp);

inline BOOL FIsIntrinsic(VARIANT *pVar)
    {
    if (V_VT(pVar) != VT_DISPATCH)
        return FALSE;
    return FIsIntrinsic(V_DISPATCH(pVar));
    }

/*===================================================================
  OnPageInfo struct used to cache ids of OnStartPage()/OnEndPage()
===================================================================*/

#define ONPAGEINFO_ONSTARTPAGE      0
#define ONPAGEINFO_ONENDPAGE        1
#define ONPAGE_METHODS_MAX          ONPAGEINFO_ONENDPAGE+1

struct COnPageInfo
    {
    DISPID m_rgDispIds[ONPAGE_METHODS_MAX];

    BOOL FHasAnyMethod() const;
    };

inline BOOL COnPageInfo::FHasAnyMethod() const
    {
#if (ONPAGE_METHODS_MAX == 2)
    // fast implementation for the real case
    return
        (
        m_rgDispIds[0] != DISPID_UNKNOWN ||
        m_rgDispIds[1] != DISPID_UNKNOWN
        );
#else
    for (int i = 0; i < ONPAGE_METHODS_MAX; i++)
        {
        if (m_rgDispIds[i] != DISPID_UNKNOWN)
            return TRUE;
        }
    return FALSE;
#endif
    }

/*===================================================================
  Component object stores information about a single object
  Each component object belongs to a component collection
  Component objects are linked into a list, also
  tagged objects are hashed by name, and
  properties are hashed by name, and
  all instantiated objects are hashed by IUnknown*
===================================================================*/
class CComponentObject : public CLinkElem
    {

friend class CComponentCollection;
friend class CPageComponentManager;
friend class CComponentIterator;

private:
    // properties
	CompScope   m_csScope : 4;	// Scope
    CompType    m_ctType  : 4;  // Component Object Type
	CompModel	m_cmModel : 4;  // Threading behavior (from Registry)

	DWORD       m_fAgile : 1;   // Agile?

	// flag to indicate if OnPageInfo was queried
	DWORD       m_fOnPageInfoCached : 1;
	// flag: on-start-page done, waiting to do on-end-page
	DWORD       m_fOnPageStarted : 1;

	// flag to avoid multiple unsuccessful attempts to instantiate
	DWORD       m_fFailedToInstantiate : 1;
	// flag to mark instantiated (or tried to inst.) tagged objects
	DWORD       m_fInstantiatedTagged : 1;

	// flag to mark the object in pointer cache
	DWORD       m_fInPtrCache : 1;

    // variant filled with value?
	DWORD       m_fVariant : 1;

    // name was allocated (longer than the default buffer)?
	DWORD       m_fNameAllocated : 1;

	// pointers to object and type info
	IDispatch   *m_pDisp;		// Dispatch interface pointer
	IUnknown    *m_pUnknown;	// IUnknown interface pointer

    union
    {
	CLSID		m_ClsId;	// Class id (for tagged and unnamed)
	VARIANT     m_Variant;  // Variant (for properties)
    };
    
	// For objects that use OLE cookie API
	DWORD       m_dwGIPCookie;

	// cached OnPageInfo
	COnPageInfo m_OnPageInfo;

	// pointer to connect objects into link list
	CComponentObject *m_pCompNext;  // Next object in the link list.
    CComponentObject *m_pCompPrev;  // Prev object in the link list.

    // buffer for names that fit in (36 bytes = 17 unicode chars + '\0')
	BYTE        m_rgbNameBuffer[36];

private:
    // constructor is private! (not for outside use)
    CComponentObject
        (
        CompScope csScope, 
        CompType  ctType,
        CompModel cmModel
        );
    ~CComponentObject();

    // Initializes CLinkElem portion
    HRESULT Init(LPWSTR pwszName, DWORD cbName);

    // Releases all interface pointers (used by clear)
    HRESULT ReleaseAll();

    // Clears out data (releases all) leaving link alone
    HRESULT Clear();
    
    // Create instance if not there already
	HRESULT Instantiate(CHitObj *pHitObj);
	HRESULT TryInstantiate(CHitObj *pHitObj);
	
    // Set value from variant
    HRESULT SetPropertyValue(VARIANT *);

    // Convert Object to be GIP cookie
    HRESULT ConvertToGIPCookie();
    
    // Get and cache the ids for OnStart methods
    HRESULT GetOnPageInfo();

public:
    // functions to get the COM object (internally resolve cookies)
    HRESULT GetAddRefdIDispatch(IDispatch **ppdisp);
    HRESULT GetAddRefdIUnknown(IUnknown **ppunk);
    HRESULT GetVariant(VARIANT *pVar);  // not for GIP cookies

    // Check if the unnamed page level object object 
    // can be removed without waiting till the end of request
    inline BOOL FEarlyReleaseAllowed() const;
    
    // public inlines to access the object's properties
    // these are the only methods available from outside
    inline LPWSTR GetName();
    
    inline CompScope GetScope() const;
    inline CompType  GetType()  const;
    inline CompModel GetModel() const;
    inline BOOL      FAgile()   const;

    // Retrieve the cached ids
    inline const COnPageInfo *GetCachedOnPageInfo() const;

public:
#ifdef DBG
	void AssertValid() const;
#else
	void AssertValid() const {}
#endif

    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };

inline LPWSTR CComponentObject::GetName()
    {
    return (LPWSTR)m_pKey; 
    }

inline CompScope CComponentObject::GetScope() const
    {
    return m_csScope;
    }
    
inline CompType CComponentObject::GetType() const
    {
    return m_ctType; 
    }

inline CompType CComponentObject::GetModel() const
    {
    return m_cmModel; 
    }

inline BOOL CComponentObject::FAgile() const
    {
    return m_fAgile;
    }

inline const COnPageInfo *CComponentObject::GetCachedOnPageInfo() const
    {
    return m_fOnPageInfoCached ? &m_OnPageInfo : NULL;
    }

inline BOOL CComponentObject::FEarlyReleaseAllowed() const
    {
    return (!m_fOnPageStarted   &&  // no need to do on-end-page
            !m_fInPtrCache      &&  // no need to search by pointer
            m_csScope == csPage &&  // page scoped
            m_ctType == ctUnnamed); // created with Server.CreateObject()
    }

/*===================================================================
  Component collection is a manager of various types of component
  objects:
    1) Tagged objects (<OBJECT...>) (instantiated or not)
    2) Session("xxx") and Application("xxx") properties
    3) Unnamed objects (Server.CreateObject())
  It hashes added objects as needed (some by name, IUnkn *, etc.)

  The idea is to isolate the above issues from outside as much
  as possible.

  Component collections exist under session, application, hitobj
===================================================================*/
class CComponentCollection
    {
    
friend class CPageComponentManager;
friend class CComponentIterator;
friend class CVariantsIterator;

private:
    CompScope m_csScope : 4;          // scope (page, session, appln)
    DWORD     m_fUseTaggedArray : 1;  // remember tagged objects array?
    DWORD     m_fUsePropArray   : 1;  // remember properties array?
    DWORD     m_fHasComProperties : 1; // any property VARIANTs that could be objects
    
    // hash table (by name) of tagged objects
    CHashTableStr m_htTaggedObjects;     
    
    // hash table (by name) of properties (4)
    CHashTableStr m_htProperties;
    
    // hash table (by IUnknown *) of all instances
    CIdHashTable m_htidIUnknownPtrs;

    // Pointer to the component objects link list
	CComponentObject *m_pCompFirst;  // First object in link list.

	// Array of pointers to static objects to speed lookup by index
	CPtrArray m_rgpvTaggedObjects;

	// Array of pointers to properties to speed lookup by index
	CPtrArray m_rgpvProperties;

    // Various object counts in the collection
    USHORT m_cAllTagged;         // all tagged objects
    USHORT m_cInstTagged;        // instanciated tagged objects
    USHORT m_cProperties;        // all properties
    USHORT m_cUnnamed;           // number of unnamed objects
    
    // Add/remove object to the component objects link list
    HRESULT AddComponentToList(CComponentObject *pObj);
    HRESULT RemoveComponentFromList(CComponentObject *pObj);
    
    // Add named object to the proper hash table by name
    HRESULT AddComponentToNameHash
        (
        CComponentObject *pObj, 
        LPWSTR pwszName,
        DWORD  cbName
        );
    
    // Add named object to the IUnkown * hash table
    HRESULT AddComponentToPtrHash(CComponentObject *pObj);

    // Find by name (for tagged)
    HRESULT FindComponentObjectByName
        (
        LPWSTR pwszName,
        DWORD  cbName,
        CComponentObject **ppObj
        );
        
    // Find by name (for properties)
    HRESULT FindComponentPropertyByName
        (
        LPWSTR pwszName, 
        DWORD  cbName,
        CComponentObject **ppObj
        );

    // Find by IUnknown*
    HRESULT FindComponentByIUnknownPtr
        (
        IUnknown *pUnk,
        CComponentObject **ppObj
        );

    // Fill in the arrays for access by index for the first time
    HRESULT StartUsingTaggedObjectsArray();
    HRESULT StartUsingPropertiesArray();

public:
    // Add various kinds of objects to the collection
    // They are also used by 
    //      CPageComponentManager AddScoped...()
    
    HRESULT AddTagged
        (
        LPWSTR pwszName, 
        const CLSID &clsid, 
        CompModel cmModel
        );
        
    HRESULT AddProperty
        (
        LPWSTR pwszName,
        VARIANT *pVariant,
        CComponentObject **ppObj = NULL
        );

    HRESULT AddUnnamed
        (
        const CLSID &clsid, 
        CompModel cmModel, 
        CComponentObject **ppObj
        );

    HRESULT GetTagged
        (
        LPWSTR pwszName,
        CComponentObject **ppObj
        );

    HRESULT GetProperty
        (
        LPWSTR pwszName,
        CComponentObject **ppObj
        );

    HRESULT GetNameByIndex
        (
        CompType ctType,
        int index,
        LPWSTR *ppwszName
        );

    HRESULT RemoveComponent(CComponentObject *pObj);
    
    HRESULT RemoveProperty(LPWSTR pwszName);
    
    HRESULT RemoveAllProperties();

    CComponentCollection();
    ~CComponentCollection();

    HRESULT Init(CompScope csScope);
    HRESULT UnInit();

    BOOL FHasStateInfo() const;    // TRUE when state-full
    BOOL FHasObjects() const;      // TRUE when contains objects

    DWORD GetPropertyCount() const;
    DWORD GetTaggedObjectCount() const;

public:
#ifdef DBG
	void AssertValid() const;
#else
	void AssertValid() const {}
#endif

    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };

inline BOOL CComponentCollection::FHasStateInfo() const
    {
    return ((m_cAllTagged + m_cProperties + m_cUnnamed) > 0);
    }

inline BOOL CComponentCollection::FHasObjects() const
    {
    return (m_cInstTagged > 0 || m_cUnnamed > 0 ||
            (m_cProperties > 0 && m_fHasComProperties));
    }

inline DWORD CComponentCollection::GetPropertyCount() const
    {
    return m_cProperties;
    }

inline DWORD CComponentCollection::GetTaggedObjectCount() const
    {
    return m_cAllTagged;
    }

inline HRESULT CComponentCollection::AddComponentToList
(
CComponentObject *pObj
)
    {
    pObj->m_pCompNext = m_pCompFirst;
    pObj->m_pCompPrev = NULL;
    if (m_pCompFirst)
        m_pCompFirst->m_pCompPrev = pObj;
    m_pCompFirst = pObj;
    return S_OK;
    }

inline HRESULT CComponentCollection::RemoveComponentFromList
(
CComponentObject *pObj
)
    {
    if (pObj->m_pCompPrev)
        pObj->m_pCompPrev->m_pCompNext = pObj->m_pCompNext;
    if (pObj->m_pCompNext)
        pObj->m_pCompNext->m_pCompPrev = pObj->m_pCompPrev;
    if (m_pCompFirst == pObj)
        m_pCompFirst = pObj->m_pCompNext;
    pObj->m_pCompPrev = pObj->m_pCompNext = NULL;
    return S_OK;
    }

/*===================================================================
  A page object controls calls to OnStartPage(), OnEndPage().
  Page objects are used by CPageComponentManager
  They are hashed using IDispatch * to avoid multiple OnStartPage()
  calls for the same object.
===================================================================*/
class CPageObject
    {

friend class CPageComponentManager;

private:
	IDispatch   *m_pDisp;		       // Dispatch interface pointer
	COnPageInfo  m_OnPageInfo;         // cached OnPageInfo

    DWORD        m_fStartPageCalled : 1;
    DWORD        m_fEndPageCalled : 1;
	
private: // the only access is using CPageComponentManager
    CPageObject();
    ~CPageObject();

    HRESULT	Init(IDispatch *pDisp, const COnPageInfo &OnPageInfo);

    // Invoke OnStartPage or OnEndPage
    HRESULT InvokeMethod
        (
        DWORD iMethod, 
        CScriptingContext *pContext, 
        CHitObj *pHitObj
        );
    HRESULT TryInvokeMethod     // used by InvokeMethod
        (                       // inside TRY CATCH
        DISPID     DispId,
        BOOL       fOnStart, 
        IDispatch *pDispContext,
        CHitObj   *pHitObj
        );

public:
#ifdef DBG
	void AssertValid() const;
#else
	void AssertValid() const {}
#endif

    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };
    
/*===================================================================
  Page component manager provides access to component collections
  for page, session, application level.
  It is associated with a HitObj.

  It also takes care of covering (OnStartPage(), OnEndPage()).
===================================================================*/
class CPageComponentManager
    {
private:
    // hashtable of page objects hashed by IDispatch *
    CIdHashTable m_htidPageObjects;

    // hit object (this page)
    CHitObj *m_pHitObj;

    // hash table iterator callbacks
    static IteratorCallbackCode DeletePageObjectCB(void *pvObj, void *, void *);
    static IteratorCallbackCode OnEndPageObjectCB(void *pvObj, void *pvHitObj, void *pvhr);

private:
    // collections related to page, session and application
    HRESULT GetPageCollection(CComponentCollection **ppCollection);
    HRESULT GetSessionCollection(CComponentCollection **ppCollection);
    HRESULT GetApplnCollection(CComponentCollection **ppCollection);
    
    HRESULT GetCollectionByScope
        (
        CompScope csScope, 
        CComponentCollection **ppCollection
        );

    // find objectc in any of the related collections 
    // (internal private method)
    HRESULT FindScopedComponentByName
        (
        CompScope csScope, 
        LPWSTR pwszName,
        DWORD  cbName,
        BOOL fProperty,
        CComponentObject **ppObj, 
        CComponentCollection **ppCollection = NULL
        );

    static HRESULT __stdcall InstantiateObjectFromMTA
        (
        void *pvObj,
        void *pvHitObj
        );

public:
    CPageComponentManager();
    ~CPageComponentManager();

    HRESULT Init(CHitObj *pHitObj);
    
    // OnStartPage processing for an object that need it
    // (OnEndPage is done for all objects at the end of page)
    HRESULT OnStartPage
        (
        CComponentObject  *pCompObj,
        CScriptingContext *pContext,
        const COnPageInfo *pOnPageInfo,
        BOOL *pfStarted
        );

    // request OnEndPage() for all objects that need it
    // (OnStartPage() is done on demand on per-object basis)
    HRESULT OnEndPageAllObjects();

    // Add various kinds of objects. Objects get added to the
    // right collection depending on scope argument
    
    HRESULT AddScopedTagged
        (
        CompScope csScope, 
        LPWSTR pwszName, 
        const CLSID &clsid,
        CompModel cmModel
        );
        
    HRESULT AddScopedProperty
        (
        CompScope csScope, 
        LPWSTR pwszName, 
        VARIANT *pVariant,
        CComponentObject **ppObj = NULL
        );

    // Server.CreateObject
    HRESULT AddScopedUnnamedInstantiated
        (
        CompScope csScope, 
        const CLSID &clsid, 
        CompModel cmModel,
        COnPageInfo *pOnPageInfo,
        CComponentObject **ppObj
        );

    // Get component object (tagged) by name. 
    // Scope could be csUnknown
    HRESULT GetScopedObjectInstantiated
        (
        CompScope csScope, 
        LPWSTR pwszName, 
        DWORD  cbName,
        CComponentObject **ppObj,
        BOOL *pfNewInstance
        );

    // Get component property by name. Scope could be csUnknown
    HRESULT GetScopedProperty
        (
        CompScope csScope, 
        LPWSTR pwszName, 
        CComponentObject **ppObj
        );

    // Find component by IUnknown * (or IDispatch *).
    HRESULT FindAnyScopeComponentByIUnknown
        (
        IUnknown *pUnk, 
        CComponentObject **ppObj
        );
    HRESULT FindAnyScopeComponentByIDispatch
        (
        IDispatch *pDisp, 
        CComponentObject **ppObj
        );
    // The same - but static - gets context from Viper
    static HRESULT FindComponentWithoutContext
        (
        IDispatch *pDisp, 
        CComponentObject **ppObj
        );

    // Remove component -- the early release logic
    HRESULT RemoveComponent(CComponentObject *pObj);

public:
#ifdef DBG
	void AssertValid() const;
#else
	void AssertValid() const {}
#endif

    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };

// Component iterator is used to go through component names
// all the HitObj - reletated object across collections
// Needed for scripting

class CComponentIterator
    {
private:
    CHitObj *m_pHitObj;
    
    DWORD     m_fInited : 1;
    DWORD     m_fFinished : 1;
    
    CompScope m_csLastScope : 4;
    
    CComponentObject *m_pLastObj;

public:    
    CComponentIterator(CHitObj *pHitObj = NULL);
    ~CComponentIterator();

    HRESULT Init(CHitObj *pHitObj);
    LPWSTR  WStrNextComponentName();
    };

 // Variant Iterator is used to go through Property or Tagged object
 // names in a component collection. Needed for scripting

class CVariantsIterator : public IEnumVARIANT
	{
public:
	CVariantsIterator(CAppln *, DWORD);
	CVariantsIterator(CSession *, DWORD);
	~CVariantsIterator();

	HRESULT Init();

	// The Big Three

	STDMETHODIMP			QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	// standard methods for iterators

	STDMETHODIMP	Clone(IEnumVARIANT **ppEnumReturn);
	STDMETHODIMP	Next(unsigned long cElements, VARIANT *rgVariant, unsigned long *pcElementsFetched);
	STDMETHODIMP	Skip(unsigned long cElements);
	STDMETHODIMP	Reset();

private:
	ULONG m_cRefs;							// reference count
	CComponentCollection 	*m_pCompColl;	// collection we are iterating over
	DWORD					m_dwIndex;		// current position for iteration
	CAppln					*m_pAppln;		// application (to clone iterator and Lock())
	CSession				*m_pSession;	// session (to clone iterator)
	DWORD					m_ctColType;	// type of collection
	
    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};

#endif // COMPCOL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\context.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: ScriptingContext object

File: Context.h

Owner: SteveBr

This file contains the header info for defining the Context object.
Note: This was largely stolen from Kraig Brocjschmidt's Inside OLE2
second edition, chapter 14 Beeper v5.
===================================================================*/

#ifndef SCRIPTING_CONTEXT_H
#define SCRIPTING_CONTEXT_H

#include "debug.h"
#include "util.h"

#include "request.h"
#include "response.h"
#include "server.h"

#include "asptlb.h"
#include "memcls.h"

/*===================================================================
  C S c r i p t i n g C o n t e x t
===================================================================*/

class CScriptingContext : public IScriptingContextImpl
	{
private:
	// Ref count
	ULONG m_cRef; 	    

    // Intrinsics
	IApplicationObject *m_pAppln;
	ISessionObject     *m_pSession;
	IRequest           *m_pRequest;
	IResponse          *m_pResponse;
	IServer            *m_pServer;
	
	// Interface to indicate that we support ErrorInfo reporting
	CSupportErrorInfo m_ImpISuppErr;

public:
	CScriptingContext() 
	    {
	    Assert(FALSE); // Default constructor should not be used
	    }
	
	CScriptingContext
	    (
	    IApplicationObject *pAppln,
        ISessionObject     *pSession,
        IRequest           *pRequest,
        IResponse          *pResponse,
        IServer            *pServer
        );

	~CScriptingContext();
        
	// Non-delegating object IUnknown
	
	STDMETHODIMP		 QueryInterface(REFIID, PPVOID);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

	// IScriptingContext implementation
	
	STDMETHODIMP get_Request(IRequest **ppRequest);
	STDMETHODIMP get_Response(IResponse **ppResponse);
	STDMETHODIMP get_Server(IServer **ppServer);
	STDMETHODIMP get_Session(ISessionObject **ppSession);
	STDMETHODIMP get_Application(IApplicationObject **ppApplication);

    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};

#endif // SCRIPTING_CONTEXT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\dbgcxt.cpp ===
/*==============================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

File:			dbgcxt.cpp
Maintained by:	DGottner
Component:		Implementation of IDebugDocumentContext for CTemplates
==============================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "dbgcxt.h"
#include "perfdata.h"
#include "memchk.h"

// {5FA45A6C-AB8A-11d0-8EBA-00C04FC34DCC}
const GUID IID_IDenaliTemplateDocumentContext = 
	{ 0x5fa45a6c, 0xab8a, 0x11d0, { 0x8e, 0xba, 0x0, 0xc0, 0x4f, 0xc3, 0x4d, 0xcc } };

// {3AED94BE-ED79-11d0-8F34-00C04FC34DCC}
static const GUID IID_IDenaliIncFileDocumentContext = 
	{ 0x3aed94be, 0xed79, 0x11d0, { 0x8f, 0x34, 0x0, 0xc0, 0x4f, 0xc3, 0x4d, 0xcc } };


/*
 *
 * C T e m p l a t e D o c u m e n t C o n t e x t
 *
 */

/*	============================================================================
	CTemplateDocumentContext::CTemplateDocumentContext
	Constructor
*/
CTemplateDocumentContext::CTemplateDocumentContext
(
CTemplate *pTemplate,
ULONG cchSourceOffset,
ULONG cchText,
IActiveScriptDebug *pDebugScript,
ULONG idEngine,
ULONG cchTargetOffset
)
	{
	Assert (pTemplate != NULL);

	m_pTemplate       = pTemplate;
	m_idEngine        = idEngine;
	m_pDebugScript    = pDebugScript;
	m_cchSourceOffset = cchSourceOffset;
	m_cchTargetOffset = cchTargetOffset;
	m_cchText         = cchText;
	m_cRefs           = 1;

	m_pTemplate->AddRef();

	if (m_pDebugScript)
		{
		m_pDebugScript->AddRef();

		// If they passed in a script, then they must also pass in target offset & engine ID
		Assert (m_idEngine != -1);
		Assert (m_cchTargetOffset != -1);
		}
	}

/*	============================================================================
	CTemplateDocumentContext::~CTemplateDocumentContext
	Destructor
*/
CTemplateDocumentContext::~CTemplateDocumentContext
(
)
	{
	m_pTemplate->Release();

	if (m_pDebugScript)
		m_pDebugScript->Release();
	}

/*	============================================================================
	CTemplateDocumentContext::QueryInterface

	NOTE: QueryInterface here is also used by CTemplate to determine if an
		  arbitrary document context is ours.
*/
HRESULT CTemplateDocumentContext::QueryInterface
(
const GUID &	guid,
void **			ppvObj
)
	{
	if (guid == IID_IUnknown ||
		guid == IID_IDebugDocumentContext ||
		guid == IID_IDenaliTemplateDocumentContext)
		{
		*ppvObj = this;
		AddRef();
		return S_OK;
		}
	else
		{
		*ppvObj = NULL;
		return E_NOINTERFACE;
		}
	}

/*	============================================================================
	CTemplateDocumentContext::AddRef
	CTemplateDocumentContext::Release

	NOTE: Don't know if these need to be protected with Interlocked(In|De)crement.
*/
ULONG CTemplateDocumentContext::AddRef()
	{
	InterlockedIncrement(&m_cRefs);
	return m_cRefs;
	}

ULONG CTemplateDocumentContext::Release()
	{
	if (InterlockedDecrement(&m_cRefs) == 0)
		{
		delete this;
		return 0;
		}

	return m_cRefs;
	}

/*	============================================================================
	CTemplateDocumentContext::GetDocument
	Return the document.
*/
HRESULT CTemplateDocumentContext::GetDocument
(
/* [out] */ IDebugDocument **ppDebugDocument
)
	{
#ifndef PERF_DISABLE
    g_PerfData.Incr_DEBUGDOCREQ();
#endif
	return m_pTemplate->QueryInterface(IID_IDebugDocument, reinterpret_cast<void **>(ppDebugDocument));
	}

/*	============================================================================
	CTemplateDocumentContext::EnumCodeContexts
	Convert document offset to script offset and enumerate code contexts
*/

HRESULT CTemplateDocumentContext::EnumCodeContexts
(
/* [out] */ IEnumDebugCodeContexts **ppEnumerator
)
	{
	if (! m_pTemplate->FIsValid())
		return E_FAIL;

	if (m_pDebugScript == NULL)
		{
		// Convert offset
		m_pTemplate->GetTargetOffset(m_pTemplate->GetSourceFileName(), m_cchSourceOffset, &m_idEngine, &m_cchTargetOffset);

		// See if the script ran and template is holding onto it
		CActiveScriptEngine *pScriptEngine = m_pTemplate->GetActiveScript(m_idEngine);
		if (pScriptEngine)
			{
			if (FAILED(pScriptEngine->GetActiveScript()->QueryInterface(IID_IActiveScriptDebug, reinterpret_cast<void **>(&m_pDebugScript))))
				{
				pScriptEngine->Release();
				return E_FAIL;
				}

			pScriptEngine->IsBeingDebugged();
			pScriptEngine->Release();
			}

		// Script may be still running ("stop" statement case)
		if (m_pDebugScript == NULL)
			m_pDebugScript = g_ScriptManager.GetDebugScript(m_pTemplate, m_idEngine);

		// This is probably a bug...
		if (m_pDebugScript == NULL)		// don't have a running script to match this
			return E_FAIL;

		// No need for AddRef(); m_pDebugScript called funtions that AddRef'ed
		}

	return m_pDebugScript->EnumCodeContextsOfPosition(
												m_idEngine, 
												m_cchTargetOffset,
												m_cchText,
												ppEnumerator);
	}

/*
 *
 * C I n c F i l e E n u m C o d e C o n t e x t s
 *
 *
 * For an include file, the corresponding code contexts are the union
 * of all appropriate code contexts in all template objects that are using
 * the include file.  This special enumerator implements the union.
 */
class CIncFileEnumCodeContexts : public IEnumDebugCodeContexts
	{
private:
	CIncFileDocumentContext *	m_pContext;				// context we are providing enumeration for
	IEnumDebugCodeContexts *	m_pEnumCodeContexts;	// Current code context enumerator
	LONG						m_cRefs;				// reference count
	int							m_iTemplate;			// index of current template

	IEnumDebugCodeContexts *GetEnumerator(int *piTemplate);	// Get enumerator for a template

public:
	CIncFileEnumCodeContexts(CIncFileDocumentContext *pIncFileDocumentContext);
	~CIncFileEnumCodeContexts();

	// IUnknown methods

	virtual HRESULT STDMETHODCALLTYPE QueryInterface(const GUID &guid, void **ppvObj);
	virtual ULONG STDMETHODCALLTYPE AddRef();
	virtual ULONG STDMETHODCALLTYPE Release();

	// IEnumDebugCodeContexts methods

	virtual HRESULT STDMETHODCALLTYPE Next(ULONG celt, IDebugCodeContext **pscc, ULONG *pceltFetched);
	virtual HRESULT STDMETHODCALLTYPE Skip(ULONG celt);
	virtual HRESULT STDMETHODCALLTYPE Reset(void);
	virtual HRESULT STDMETHODCALLTYPE Clone(IEnumDebugCodeContexts **ppescc);
	};
        
/*	============================================================================
	CIncFileEnumCodeContexts::CIncFileEnumCodeContexts
	Constructor
*/
CIncFileEnumCodeContexts::CIncFileEnumCodeContexts
(
CIncFileDocumentContext *pDocumentContext
)
	{
	m_pContext = pDocumentContext;
	m_pContext->AddRef();
	m_cRefs = 1;
	Reset();
	}

/*	============================================================================
	CIncFileEnumCodeContexts::~CIncFileEnumCodeContexts
	Destructor
*/
CIncFileEnumCodeContexts::~CIncFileEnumCodeContexts()
	{
	m_pContext->Release();
	if (m_pEnumCodeContexts)
		m_pEnumCodeContexts->Release();
	}

/*	============================================================================
	CIncFileEnumCodeContexts::GetEnumerator
	Get a code context enumerator for the current script engine

	Side Effects:
		piTemplate is incremented to point to the next available template
		(piTemplate is really an "iteration cookie" -- don't think of it as an index)
*/
IEnumDebugCodeContexts *CIncFileEnumCodeContexts::GetEnumerator
(
int *piTemplate
)
	{
	// Get a template from the array - may need to retry if template contains compiler errors
	CTemplate *pTemplate;
	do
		{
		// GetTemplate returns NULL when array index is out of range (which is when iteration is exhaused)
		pTemplate = m_pContext->m_pIncFile->GetTemplate((*piTemplate)++);
		if (pTemplate == NULL)
			return NULL;
		}  
	while (! pTemplate->FIsValid());

	// If we got this far, we got one of the users of this include file.  Convert the offset
	ULONG idEngine, cchTargetOffset;
	pTemplate->GetTargetOffset(m_pContext->m_pIncFile->GetIncFileName(), m_pContext->m_cchSourceOffset, &idEngine, &cchTargetOffset);

	// Now we have the engine ID, see if template is holding onto corresponding engine
	IActiveScriptDebug *pDebugScriptEngine = NULL;
	CActiveScriptEngine *pScriptEngine = pTemplate->GetActiveScript(idEngine);
	if (pScriptEngine)
		{
		if (FAILED(pScriptEngine->GetActiveScript()->QueryInterface(IID_IActiveScriptDebug, reinterpret_cast<void **>(&pDebugScriptEngine))))
			{
			pScriptEngine->Release();
			return NULL;
			}

		pScriptEngine->IsBeingDebugged();
		pScriptEngine->Release();
		}

	// If we could not get the engine that way, the script is likely still in the running state
	if (pDebugScriptEngine == NULL)
		pDebugScriptEngine = g_ScriptManager.GetDebugScript(pTemplate, idEngine);

	// This is probably a bug...
	if (pDebugScriptEngine == NULL)		// don't have a running script to match this
		return NULL;

	IEnumDebugCodeContexts *pEnumerator;
	HRESULT hrGotEnum = pDebugScriptEngine->EnumCodeContextsOfPosition(
																idEngine, 
																cchTargetOffset,
																m_pContext->m_cchText,
																&pEnumerator);


	pDebugScriptEngine->Release();
	return SUCCEEDED(hrGotEnum)? pEnumerator : NULL;
	}

/*	============================================================================
	CIncFileEnumCodeContexts::QueryInterface
*/
HRESULT CIncFileEnumCodeContexts::QueryInterface
(
const GUID &	guid,
void **			ppvObj
)
	{
	if (guid == IID_IUnknown || guid == IID_IEnumDebugCodeContexts)
		{
		*ppvObj = this;
		AddRef();
		return S_OK;
		}
	else
		{
		*ppvObj = NULL;
		return E_NOINTERFACE;
		}
	}

/*	============================================================================
	CIncFileEnumCodeContexts::AddRef
	CIncFileEnumCodeContexts::Release

	NOTE: Don't know if these need to be protected with Interlocked(In|De)crement.
*/
ULONG CIncFileEnumCodeContexts::AddRef()
	{
	InterlockedIncrement(&m_cRefs);
	return m_cRefs;
	}

ULONG CIncFileEnumCodeContexts::Release()
	{
	if (InterlockedDecrement(&m_cRefs) == 0)
		{
		delete this;
		return 0;
		}

	return m_cRefs;
	}

/*	============================================================================
	CIncFileEnumCodeContexts::Clone

	Clone this iterator (standard method)
*/
HRESULT CIncFileEnumCodeContexts::Clone
(
IEnumDebugCodeContexts **ppEnumClone
)
	{
	CIncFileEnumCodeContexts *pClone = new CIncFileEnumCodeContexts(m_pContext);
	if (pClone == NULL)
		return E_OUTOFMEMORY;

	// new iterator should point to same location as this.
	pClone->m_iTemplate = m_iTemplate;
	pClone->m_pEnumCodeContexts = m_pEnumCodeContexts;
	if (m_pEnumCodeContexts)
		m_pEnumCodeContexts->AddRef();

	*ppEnumClone = pClone;
	return S_OK;
	}

/*	============================================================================
	CIncFileEnumCodeContexts::Next

	Get next value (standard method)

	To rehash standard OLE semantics:

		We get the next "cElements" from the collection and store them
		in "rgVariant" which holds at least "cElements" items.  On
		return "*pcElementsFetched" contains the actual number of elements
		stored.  Returns S_FALSE if less than "cElements" were stored, S_OK
		otherwise.
*/
HRESULT CIncFileEnumCodeContexts::Next
(
unsigned long cElementsRequested,
IDebugCodeContext **ppCodeContexts,
unsigned long *pcElementsFetched
)
	{
	// give a valid pointer value to 'pcElementsFetched'
	//
	unsigned long cLocalElementsFetched;
	if (pcElementsFetched == NULL)
		pcElementsFetched = &cLocalElementsFetched;

	// Initialize things
	//
	unsigned long cElements = cElementsRequested;
	*pcElementsFetched = 0;

	// Loop over all templates until we fill the ppCodeContext array or we've exhausted the collection
	//   (when m_pEnumCodeContexts is NULL that means we are done)
	//
	while (cElements > 0 && m_pEnumCodeContexts)
		{
		// Fetch as many contexts as we can from the current iterator
		unsigned long cElementsFetched;
		HRESULT hrEnum = m_pEnumCodeContexts->Next(cElements, ppCodeContexts, &cElementsFetched);
		if (FAILED(hrEnum))
			return hrEnum;

		// If iterator did not fill entire array, advance to next one
		if (cElementsFetched < cElements)
			{
			// Advance - first release the current iterator
			m_pEnumCodeContexts->Release();
			m_pEnumCodeContexts = GetEnumerator(&m_iTemplate);
			}

		*pcElementsFetched += cElementsFetched;
        ppCodeContexts += cElementsFetched;
		cElements -= cElementsFetched;
		}

	// initialize the remaining structures
	while (cElements-- > 0)
		*ppCodeContexts++ = NULL;

	return (*pcElementsFetched == cElementsRequested)? S_OK : S_FALSE;
	}

/*	============================================================================
	CIncFileEnumCodeContexts::Skip

	Skip items (standard method)

	To rehash standard OLE semantics:

		We skip over the next "cElements" from the collection.
		Returns S_FALSE if less than "cElements" were skipped, S_OK
		otherwise.
*/
HRESULT CIncFileEnumCodeContexts::Skip(unsigned long cElements)
	{
	/* Loop through the collection until either we reach the end or
	 * cElements becomes zero.  Since the iteration logic is
	 * so complex, we do not repeat it here.
	 */
	HRESULT hrElementFetched = S_OK;
	while (cElements > 0 && hrElementFetched == S_OK)
		{
		IDebugCodeContext *pCodeContext;
		hrElementFetched = Next(1, &pCodeContext, NULL);
		pCodeContext->Release();
		--cElements;
		}

	return (cElements == 0)? S_OK : S_FALSE;
	}

/*	============================================================================
	CIncFileEnumCodeContexts::Reset

	Reset the iterator (standard method)
*/
HRESULT CIncFileEnumCodeContexts::Reset()
	{
	m_iTemplate = 0;
	m_pEnumCodeContexts = GetEnumerator(&m_iTemplate);
	return S_OK;
	}

/*
 *
 * C I n c F i l e D o c u m e n t C o n t e x t
 *
 */

/*	============================================================================
	CIncFileDocumentContext::CIncFileDocumentContext
	Constructor
*/
CIncFileDocumentContext::CIncFileDocumentContext
(
CIncFile *pIncFile,
ULONG cchSourceOffset,
ULONG cchText
)
	{
	Assert (pIncFile != NULL);

	m_pIncFile        = pIncFile;
	m_cchSourceOffset = cchSourceOffset;
	m_cchText         = cchText;
	m_cRefs           = 1;

	m_pIncFile->AddRef();
	}

/*	============================================================================
	CIncFileDocumentContext::~CIncFileDocumentContext
	Destructor
*/
CIncFileDocumentContext::~CIncFileDocumentContext
(
)
	{
	m_pIncFile->Release();
	}

/*	============================================================================
	CIncFileDocumentContext::QueryInterface

	NOTE: QueryInterface here is also used by CIncFile to determine if an
		  arbitrary document context is ours.
*/
HRESULT CIncFileDocumentContext::QueryInterface
(
const GUID &	guid,
void **			ppvObj
)
	{
	if (guid == IID_IUnknown ||
		guid == IID_IDebugDocumentContext ||
		guid == IID_IDenaliIncFileDocumentContext)
		{
		*ppvObj = this;
		AddRef();
		return S_OK;
		}
	else
		{
		*ppvObj = NULL;
		return E_NOINTERFACE;
		}
	}

/*	============================================================================
	CIncFileDocumentContext::AddRef
	CIncFileDocumentContext::Release

	NOTE: Don't know if these need to be protected with Interlocked(In|De)crement.
*/
ULONG CIncFileDocumentContext::AddRef()
	{
	InterlockedIncrement(&m_cRefs);
	return m_cRefs;
	}

ULONG CIncFileDocumentContext::Release()
	{
	if (InterlockedDecrement(&m_cRefs) == 0)
		{
		delete this;
		return 0;
		}

	return m_cRefs;
	}

/*	============================================================================
	CIncFileDocumentContext::GetDocument
	Return the document.
*/
HRESULT CIncFileDocumentContext::GetDocument
(
/* [out] */ IDebugDocument **ppDebugDocument
)
	{
#ifndef PERF_DISABLE
    g_PerfData.Incr_DEBUGDOCREQ();
#endif
	return m_pIncFile->QueryInterface(IID_IDebugDocument, reinterpret_cast<void **>(ppDebugDocument));
	}

/*	============================================================================
	CIncFileDocumentContext::EnumCodeContexts
	Convert document offset to script offset and enumerate code contexts
*/
HRESULT CIncFileDocumentContext::EnumCodeContexts
(
/* [out] */ IEnumDebugCodeContexts **ppEnumerator
)
	{
	if ((*ppEnumerator = new CIncFileEnumCodeContexts(this)) == NULL)
		return E_OUTOFMEMORY;

	return S_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\cookies.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Request, Response objects

File: cookies.h

Owner: DGottner

This file contains the definiton of the CCookie class, which
contains all of the state for an HTTP cookie
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "asptlb.h"
#include "dispatch.h"
#include "hashing.h"
#include "memcls.h"

class CCookie;

// Type for an object-destroyed callback
typedef void (*PFNDESTROYED)(void);



/* C C o o k i e P a i r
 *
 * Implements a name/value pair in the Cookie dictionary
 */
class CCookiePair : public CLinkElem
	{
public:
	char *m_szValue;
	BOOL m_fDuplicate;		// TRUE if we have a strdup'ed copy of m_pKey, m_szValue

	HRESULT Init(const char *szKey, const char *szValue, BOOL fDuplicate = FALSE);

	CCookiePair();
	~CCookiePair();
	};
	

/*
 * C C o o k i e S u p p o r t E r r
 *
 * Implements ISupportErrorInfo for the CCookie class. The CSupportError class
 * is not adequate because it will only report a max of one interface which
 * supports error info. (We have two)
 */
class CCookieSupportErr : public ISupportErrorInfo
	{
private:
	CCookie *	m_pCookie;

public:
	CCookieSupportErr(CCookie *pCookie);

	// IUnknown members that delegate to m_pCookie
	//
	STDMETHODIMP		 QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

	// ISupportErrorInfo members
	//
	STDMETHODIMP InterfaceSupportsErrorInfo(const GUID &);
	};



/*
 * C W r i t e C o o k i e
 *
 * Implements IWriteCookie which is the interface that Response.Cookies
 * returns.
 */
class CWriteCookie : public IWriteCookieImpl
	{
private:
	CCookie *			m_pCookie;

public:
	CWriteCookie(CCookie *);

	// The Big Three
	//
	STDMETHODIMP		 	QueryInterface(const IID &rIID, void **ppvObj);
	STDMETHODIMP_(ULONG) 	AddRef();
	STDMETHODIMP_(ULONG) 	Release();

	// IWriteCookie implementation
	//
	STDMETHODIMP	put_Item(VARIANT varKey, BSTR bstrValue);
	STDMETHODIMP	put_Expires(DATE dtExpires);
	STDMETHODIMP	put_Domain(BSTR bstrDomain);
	STDMETHODIMP	put_Path(BSTR bstrPath);
	STDMETHODIMP	put_Secure(VARIANT_BOOL fSecure);
	STDMETHODIMP	get_HasKeys(VARIANT_BOOL *pfHasKeys);
	STDMETHODIMP	get__NewEnum(IUnknown **ppEnum);
	};



/*
 * C R e a d C o o k i e
 *
 * Implements IReadCookie which is the interface that Request.Cookies
 * returns.
 */
class CReadCookie : public IReadCookieImpl
	{
private:
	CCookie *			m_pCookie;

public:
	CReadCookie(CCookie *);

	// The Big Three
	//
	STDMETHODIMP		 	QueryInterface(const IID &rIID, void **ppvObj);
	STDMETHODIMP_(ULONG) 	AddRef();
	STDMETHODIMP_(ULONG) 	Release();

	// IReadCookie implementation
	//
	STDMETHODIMP			get_Item(VARIANT i, VARIANT *pVariantReturn);
	STDMETHODIMP			get_HasKeys(VARIANT_BOOL *pfHasKeys);
	STDMETHODIMP			get__NewEnum(IUnknown **ppEnumReturn);
	STDMETHODIMP			get_Count(int *pcValues);
	STDMETHODIMP			get_Key(VARIANT VarKey, VARIANT *pvar);
	};



/*
 * C C o o k i e
 *
 * Implements CCookie, which is the object stored in the Request.Cookies
 * dictionary.
 */
class CCookie : public IUnknown
	{
	friend class CWriteCookie;
	friend class CReadCookie;
	friend class CCookieIterator;

protected:
	ULONG				m_cRefs;			// reference count
	PFNDESTROYED		m_pfnDestroy;		// To call on closure

private:
	CWriteCookie		m_WriteCookieInterface;		// implementation of IWriteCookie
	CReadCookie			m_ReadCookieInterface;		// implementation of IStringList
	CCookieSupportErr	m_CookieSupportErrorInfo;	// implementation of ISupportErrorInfo

	CIsapiReqInfo *                 m_pIReq;        // pointer to CIsapiReqInfo for this cookie
    UINT                            m_lCodePage;    // code page used for UNICODE conversions
	char *							m_szValue;	    // value of cookie when not a dictionary
	CHashTableMBStr					m_mpszValues;	// dictionary of values for the cookie
	time_t							m_tExpires;		// date & time when cookie expires
	char *							m_szDomain;		// Cookie's domain
	CHAR *							m_szPath;		// Cookie's path (If UNICODE, stored as UTF-8)
	VARIANT_BOOL					m_fSecure:1;	// does cookie require security?
	BOOL							m_fDirty:1;		// does cookie need to be sent?
	BOOL							m_fDuplicate:1;	// does cookie contain dynamically allocated string?

public:
	CCookie(CIsapiReqInfo *, UINT  lCodePage, IUnknown * = NULL, PFNDESTROYED = NULL);
	~CCookie();

	HRESULT AddValue(char *szValue, BOOL fDuplicate = FALSE);
	HRESULT AddKeyAndValue(char *szKey, char *szValue, BOOL fDuplicate = FALSE);

	size_t GetHTTPCookieSize();				// return information on how big a buffer should be
	char * GetHTTPCookie(char *szBuffer);	// return the cookie value HTTP encoded

	size_t GetCookieHeaderSize(const char *szName);				// return buffer size needed for Set-Cookie header
	char *GetCookieHeader(const char *szName, char *szBuffer);	// return cookie header

	BOOL IsDirty() { return m_fDirty; }

	HRESULT		Init();

	// The Big Three
	//
	STDMETHODIMP		 	QueryInterface(const GUID &Iid, void **ppvObj);
	STDMETHODIMP_(ULONG) 	AddRef();
	STDMETHODIMP_(ULONG) 	Release();

	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};



/*
 * C C o o k i e I t e r a t o r
 *
 * IEnumVariant implementation for Cookie dictionaries
 */

class CCookieIterator : public IEnumVARIANT
	{
public:
	CCookieIterator(CCookie *pCookie);
	~CCookieIterator();

	// The Big Three

	STDMETHODIMP			QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	// standard methods for iterators

	STDMETHODIMP	Clone(IEnumVARIANT **ppEnumReturn);
	STDMETHODIMP	Next(unsigned long cElements, VARIANT *rgVariant, unsigned long *pcElementsFetched);
	STDMETHODIMP	Skip(unsigned long cElements);
	STDMETHODIMP	Reset();

private:
	ULONG m_cRefs;					// reference count
	CCookie *m_pCookie;				// pointer to iteratee
	CCookiePair *m_pCurrent;		// pointer to current item
	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\cookies.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Request, Response objects

File: cookies.cpp

Owner: DGottner

This file contains the code for the implementation of the 
Request.Cookies and Response.Cookies collections.
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "objbase.h"
#include "cookies.h"
#include "memchk.h"

#pragma warning (disable: 4355)  // ignore: "'this' used in base member init



/*------------------------------------------------------------------
 * C C o o k i e S u p p o r t E r r
 */

/*===================================================================
CCookieSupportErr::CCookieSupportErr

constructor
===================================================================*/

CCookieSupportErr::CCookieSupportErr(CCookie *pCookie)
	{
	m_pCookie = pCookie;
	}



/*===================================================================
CCookieSupportErr::QueryInterface
CCookieSupportErr::AddRef
CCookieSupportErr::Release

Delegating IUnknown members for CCookieSupportErr object.
===================================================================*/

STDMETHODIMP CCookieSupportErr::QueryInterface(const IID &idInterface, void **ppvObj)
	{
	return m_pCookie->QueryInterface(idInterface, ppvObj);
	}

STDMETHODIMP_(ULONG) CCookieSupportErr::AddRef()
	{
	return m_pCookie->AddRef();
	}

STDMETHODIMP_(ULONG) CCookieSupportErr::Release()
	{
	return m_pCookie->Release();
	}



/*===================================================================
CCookieSupportErr::InterfaceSupportsErrorInfo

Report back to OA about which interfaces we support that return
error information
===================================================================*/

STDMETHODIMP CCookieSupportErr::InterfaceSupportsErrorInfo(const GUID &idInterface)
	{
	if (idInterface == IID_IDispatch || idInterface == IID_IWriteCookie || idInterface == IID_IReadCookie)
		return S_OK;

	return S_FALSE;
	}



/*------------------------------------------------------------------
 * C W r i t e C o o k i e
 */

/*===================================================================
CWriteCookie::CWriteCookie

constructor
===================================================================*/

CWriteCookie::CWriteCookie(CCookie *pCookie)
	{
	m_pCookie = pCookie;
	CDispatch::Init(IID_IWriteCookie);
	}



/*===================================================================
CWriteCookie::QueryInterface
CWriteCookie::AddRef
CWriteCookie::Release

Delegating IUnknown members for CWriteCookie object.
===================================================================*/

STDMETHODIMP CWriteCookie::QueryInterface(const IID &idInterface, void **ppvObj)
	{
	// Bug 85953 Trap IDispatch before it gets to the core object
	if (idInterface == IID_IUnknown || 
		idInterface == IID_IWriteCookie ||
		idInterface == IID_IDispatch)
		{
		*ppvObj = this;
		static_cast<IUnknown *>(*ppvObj)->AddRef();
		return S_OK;
		}
	else
		return m_pCookie->QueryInterface(idInterface, ppvObj);
	}

STDMETHODIMP_(ULONG) CWriteCookie::AddRef()
	{
	return m_pCookie->AddRef();
	}

STDMETHODIMP_(ULONG) CWriteCookie::Release()
	{
	return m_pCookie->Release();
	}



/*===================================================================
CWriteCookie::put_Item

Set the primary value for a cookie.
===================================================================*/

STDMETHODIMP CWriteCookie::put_Item(VARIANT varKey, BSTR bstrValue)
	{
	char            *szKey;		// ascii value of the key
    CWCharToMBCS    convValue;
    CWCharToMBCS    convKey;

	// Bug 122589: Don't crash when "bstrValue" is NULL
	if (bstrValue == NULL)
		return E_FAIL;

	// Initialize things
	//
	VARIANT *pvarKey = &varKey;
	HRESULT hrReturn = S_OK;

	// BUG 937: VBScript passes VT_VARIANT|VT_BYREF when passing obect
	//          produced by IEnumVariant
	//
	// Use VariantResolveDispatch which will:
	//
	//     *  Copy BYREF variants for us using VariantCopyInd
	//     *  handle E_OUTOFMEMORY for us
	//     *  get the default value from an IDispatch, which seems
	//        like an appropriate conversion.
	//
	VARIANT varKeyCopy;
	VariantInit(&varKeyCopy);
	if (V_VT(pvarKey) != VT_BSTR)
		{
		if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
			goto LExit;

		pvarKey = &varKeyCopy;
		}

	switch (V_VT(pvarKey))
		{
	case VT_BSTR:
		break;

	case VT_ERROR:
		if (V_ERROR(pvarKey) == DISP_E_PARAMNOTFOUND)
			{
			if (m_pCookie->m_szValue == NULL)	// current value is a dictionary
				{
				CCookiePair *pNukePair = static_cast<CCookiePair *>(m_pCookie->m_mpszValues.Head());
				while (pNukePair != NULL)
					{
					CCookiePair *pNext = static_cast<CCookiePair *>(pNukePair->m_pNext);
					delete pNukePair;
					pNukePair = pNext;
					}

				m_pCookie->m_mpszValues.ReInit();
				}
			else								// no dictionary value
				if (m_pCookie->m_fDuplicate)
					free(m_pCookie->m_szValue);
            if (FAILED(hrReturn = convValue.Init(bstrValue,m_pCookie->m_lCodePage))) {
                goto LExit;
            }
			m_pCookie->m_szValue = NULL;
			m_pCookie->AddValue(convValue.GetString(), TRUE);
			m_pCookie->m_fDirty = TRUE;
			goto LExit;
			}

		// Other error, FALL THROUGH to wrong type case

	default:
		ExceptionId(IID_IWriteCookie, IDE_COOKIE, IDE_EXPECTING_STR);
		hrReturn = E_FAIL;
		goto LExit;
		}

	// don't allow empty keys in the cookie
	//
    
    if (V_BSTR(pvarKey)) {

        if (FAILED(hrReturn = convKey.Init(V_BSTR(pvarKey),m_pCookie->m_lCodePage))) {
            goto LExit;
        }
        else {
            szKey = convKey.GetString();
        }
    }
    else {
		szKey = "";
    }

	if (*szKey == '\0')
		{
		ExceptionId(IID_IWriteCookie, IDE_COOKIE, IDE_COOKIE_EMPTY_DICT);
		hrReturn = E_FAIL;
		goto LExit;
		}

	// we're changing a dictionary value, so first trash the primary value
	//
	if (m_pCookie->m_fDuplicate)
		free(m_pCookie->m_szValue);

    if (FAILED(hrReturn = convValue.Init(bstrValue,m_pCookie->m_lCodePage))) {
        goto LExit;
    }

	m_pCookie->m_szValue = NULL;
	m_pCookie->AddKeyAndValue(szKey, convValue.GetString(), TRUE);
	m_pCookie->m_fDirty = TRUE;

LExit:
	VariantClear(&varKeyCopy);
	return hrReturn;
	}



/*===================================================================
CWriteCookie::put_Expires

Set the expires attribute for a cookie.
===================================================================*/

STDMETHODIMP CWriteCookie::put_Expires(DATE dtExpires)
	{
	if (FAILED(VariantDateToCTime(dtExpires, &m_pCookie->m_tExpires)))
		{
		ExceptionId(IID_IWriteCookie, IDE_COOKIE, IDE_COOKIE_BAD_EXPIRATION);
		return E_FAIL;
		}

	m_pCookie->m_fDirty = TRUE;
	return S_OK;
	}



/*===================================================================
CWriteCookie::put_Domain

Set the domain attribute for a cookie.
===================================================================*/

STDMETHODIMP CWriteCookie::put_Domain(BSTR bstrDomain)
	{
    CWCharToMBCS    convDomain;
    HRESULT         hr = S_OK;

    if (FAILED(hr = convDomain.Init(bstrDomain,m_pCookie->m_lCodePage)));

    else {
        if (m_pCookie->m_szDomain)
            free(m_pCookie->m_szDomain);
	    m_pCookie->m_szDomain = convDomain.GetString(TRUE);
	    m_pCookie->m_fDirty = TRUE;
    }

	return hr;
	}



/*===================================================================
CWriteCookie::put_Path

Set the path attribute for a cookie.
===================================================================*/

STDMETHODIMP CWriteCookie::put_Path(BSTR bstrPath) 
{
    HRESULT         hr = S_OK;

    CWCharToMBCS    convPath;

    if (FAILED(hr = convPath.Init(bstrPath,m_pCookie->m_lCodePage)));

    else {
		
        if (m_pCookie->m_szPath)
            free(m_pCookie->m_szPath);
	    m_pCookie->m_szPath = convPath.GetString(TRUE);
        if (m_pCookie->m_szPath == NULL)
            hr = E_OUTOFMEMORY;
    }

    if (SUCCEEDED(hr))
        m_pCookie->m_fDirty = TRUE;

	return hr;
}

/*===================================================================
CWriteCookie::put_Secure

Set the secure attribute for a cookie.
===================================================================*/

STDMETHODIMP CWriteCookie::put_Secure(VARIANT_BOOL fSecure)
	{
	m_pCookie->m_fSecure = fSecure;
	m_pCookie->m_fDirty = TRUE;

	return S_OK;
	}



/*===================================================================
CWriteCookie::get_HasKeys

Return True if the cookie contains keys, False if it is a simple
value
===================================================================*/

STDMETHODIMP CWriteCookie::get_HasKeys(VARIANT_BOOL *pfHasKeys)
	{
	*pfHasKeys = ( m_pCookie->m_mpszValues.Count() > 0 ? VARIANT_TRUE : VARIANT_FALSE);
	return S_OK;
	}



/*===================================================================
CWriteCookie::get__NewEnum

Return an enumerator object.

ReadCookie and WriteCookie use the same iterator object.
To reduce useless redundancy, deletage to IReadCookie.
The IReadCookie enumerator will likely be used much more
frequently than the IWriteCookie iterator, so we pay the
overhead of delegation in this function.
===================================================================*/

STDMETHODIMP CWriteCookie::get__NewEnum(IUnknown **ppEnumReturn)
	{
	IReadCookie *pReadCookie;
	if (FAILED(QueryInterface(IID_IReadCookie, reinterpret_cast<void **>(&pReadCookie))))
		{
		Assert (FALSE);		// expect success!
		return E_FAIL;
		}

	HRESULT hrNewEnum = pReadCookie->get__NewEnum(ppEnumReturn);

	pReadCookie->Release();
	return hrNewEnum;
	}



/*------------------------------------------------------------------
 * C R e a d C o o k i e
 */

/*===================================================================
CReadCookie::CReadCookie

constructor
===================================================================*/

CReadCookie::CReadCookie(CCookie *pCookie)
	{
	m_pCookie = pCookie;
	CDispatch::Init(IID_IReadCookie);
	}



/*===================================================================
CReadCookie::QueryInterface
CReadCookie::AddRef
CReadCookie::Release

Delegating IUnknown members for CReadCookie object.
===================================================================*/

STDMETHODIMP CReadCookie::QueryInterface(const IID &idInterface, void **ppvObj)
	{
	// Bug 85953 Trap IDispatch before it gets to the core object
	if (idInterface == IID_IUnknown || 
		idInterface == IID_IReadCookie ||
		idInterface == IID_IDispatch)
		{
		*ppvObj = this;
		static_cast<IUnknown *>(*ppvObj)->AddRef();
		return S_OK;
		}
	else
		return m_pCookie->QueryInterface(idInterface, ppvObj);
	}

STDMETHODIMP_(ULONG) CReadCookie::AddRef()
	{
	return m_pCookie->AddRef();
	}

STDMETHODIMP_(ULONG) CReadCookie::Release()
	{
	return m_pCookie->Release();
	}



/*===================================================================
CReadCookie::get_Item

Retrieve a value in the cookie dictionary.
===================================================================*/

STDMETHODIMP CReadCookie::get_Item(VARIANT varKey, VARIANT *pvarReturn)
	{
	char            *szKey;			// ascii version of the key
	CCookiePair     *pPair = NULL;	// name and value of cookie in the dictionary
    CWCharToMBCS    convKey;

    STACK_BUFFER( tempCookie, 128 );

	// Initialize things
	//
	VariantInit(pvarReturn);
	VARIANT *pvarKey = &varKey;
	HRESULT hrReturn = S_OK;

	// BUG 937: VBScript passes VT_VARIANT|VT_BYREF when passing obect
	//          produced by IEnumVariant
	//
	// Use VariantResolveDispatch which will:
	//
	//     *  Copy BYREF variants for us using VariantCopyInd
	//     *  handle E_OUTOFMEMORY for us
	//     *  get the default value from an IDispatch, which seems
	//        like an appropriate conversion.
	//
	VARIANT varKeyCopy;
	VariantInit(&varKeyCopy);
	DWORD vt = V_VT(pvarKey);

	if ((V_VT(pvarKey) != VT_BSTR) && (vt != VT_I2) && (vt != VT_I4))
		{
		if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
			goto LExit;

		pvarKey = &varKeyCopy;
		}
	vt = V_VT(pvarKey);

	switch (vt)
		{
	// Bug 95201 support all numberic sub-types
	case VT_I1:  case VT_I2:               case VT_I8:
	case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
	case VT_R4:  case VT_R8:
		// Coerce all integral types to VT_I4
		if (FAILED(hrReturn = VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
			goto LExit;

		// fallthru to VT_I4

	case VT_I4:
	case VT_BSTR:
		break;
	
	case VT_ERROR:
		if (V_ERROR(pvarKey) == DISP_E_PARAMNOTFOUND)
			{
			V_VT(pvarReturn) = VT_BSTR;
	
			// simple value, URLEncoding NOT a good idea in this case
			if (m_pCookie->m_szValue)
				{
               	BSTR bstrT;
               	if (FAILED(SysAllocStringFromSz(m_pCookie->m_szValue, 0, &bstrT,m_pCookie->m_lCodePage)))
            		{
					ExceptionId(IID_IReadCookie, IDE_COOKIE, IDE_OOM);
					hrReturn = E_FAIL;
					goto LExit;
            		}
		        V_BSTR(pvarReturn) = bstrT;
				}			
			// dictionary value, must URLEncode to prevent '&', '=' from being misinterpreted
			else
				{
				int cbHTTPCookie = m_pCookie->GetHTTPCookieSize();
				if (cbHTTPCookie > REQUEST_ALLOC_MAX)
					{
					ExceptionId(IID_IReadCookie, IDE_COOKIE, IDE_STACK_OVERFLOW);
					hrReturn = E_FAIL;
					goto LExit;
					}

                if (tempCookie.Resize(cbHTTPCookie) == FALSE) {
					ExceptionId(IID_IReadCookie, IDE_COOKIE, IDE_OOM);
                    hrReturn = E_OUTOFMEMORY;
                    goto LExit;
                }
				char *szHTTPCookie = static_cast<char *>(tempCookie.QueryPtr());
				m_pCookie->GetHTTPCookie(szHTTPCookie);
	
               	BSTR bstrT;
               	if (FAILED(SysAllocStringFromSz(szHTTPCookie, 0, &bstrT,m_pCookie->m_lCodePage)))
            		{
					ExceptionId(IID_IReadCookie, IDE_COOKIE, IDE_OOM);
					hrReturn = E_FAIL;
					goto LExit;
            		}
		        V_BSTR(pvarReturn) = bstrT;
				}

			goto LExit;
			}

	default:
		ExceptionId(IID_IReadCookie, IDE_COOKIE, IDE_EXPECTING_STR);
		hrReturn = E_FAIL;
		goto LExit;
		}

	if (vt == VT_BSTR)
		{
		// convert the key to ANSI
        if (V_BSTR(pvarKey)) {
            if (FAILED(hrReturn = convKey.Init(V_BSTR(pvarKey),m_pCookie->m_lCodePage))) {
                goto LExit;
            }
            else {
                szKey = convKey.GetString();
            }
        }
        else {
			szKey = "";
        }

		// Look up the key in the Cookie.
		pPair = static_cast<CCookiePair *>(m_pCookie->m_mpszValues.FindElem(szKey, strlen(szKey)));
		}
	else 
		{
		// Look up item by index
		int iCount;

		iCount = V_I4(pvarKey);

		if ((iCount < 1) || 
			(m_pCookie->m_mpszValues.Count() == 0) ||
			(iCount > (int) m_pCookie->m_mpszValues.Count() ))
			{
			hrReturn = E_FAIL;
			ExceptionId(IID_IReadCookie, IDE_COOKIE, IDE_BAD_ARRAY_INDEX);
			goto LExit;
			}

		pPair = static_cast<CCookiePair *>(m_pCookie->m_mpszValues.Head());
		while((iCount > 1) && (pPair != NULL)) 
			{
			pPair = static_cast<CCookiePair *>(pPair->m_pNext);
			iCount--;
			}
		}

	if (pPair)
		{
       	BSTR bstrT;
       	if (FAILED(SysAllocStringFromSz(pPair->m_szValue, 0, &bstrT,m_pCookie->m_lCodePage)))
    		{
			ExceptionId(IID_IReadCookie, IDE_COOKIE, IDE_OOM);
			hrReturn = E_FAIL;
			goto LExit;
    		}
		V_VT(pvarReturn) = VT_BSTR;
		V_BSTR(pvarReturn) = bstrT;
		}

LExit:
	VariantClear(&varKeyCopy);
	return hrReturn;
	}



/*===================================================================
CReadCookie::get_HasKeys

Return True if the cookie contains keys, False if it is a simple
value
===================================================================*/

STDMETHODIMP CReadCookie::get_HasKeys(VARIANT_BOOL *pfHasKeys)
	{
	*pfHasKeys = (m_pCookie->m_mpszValues.Count() > 0 ? VARIANT_TRUE : VARIANT_FALSE);
	return S_OK;
	}

/*===================================================================
CReadCookie::get__NewEnum

Return an enumerator object.
===================================================================*/

STDMETHODIMP CReadCookie::get__NewEnum(IUnknown **ppEnumReturn)
	{
	*ppEnumReturn = NULL;

	CCookieIterator *pIterator = new CCookieIterator(m_pCookie);
	if (pIterator == NULL)
		{
		ExceptionId(IID_IReadCookie, IDE_COOKIE, IDE_OOM);
		return E_OUTOFMEMORY;
		}

	*ppEnumReturn = pIterator;
	return S_OK;
	}

/*===================================================================
CReadCookie::get_Count

Parameters:
	pcValues - count is stored in *pcValues.  Set to 0 if this
		cookie is not multi-valued.
===================================================================*/
STDMETHODIMP CReadCookie::get_Count(int *pcValues)
	{
	*pcValues = m_pCookie->m_mpszValues.Count();
	return S_OK;
	}

/*===================================================================
CReadCookie::get_Key

Function called from DispInvoke to get keys from a multi-valued
Cookie collection.

Parameters:
	vKey		VARIANT [in], which parameter to get the key of
	pvarReturn	VARIANT *, [out] value of the requested parameter

Returns:
	S_OK on success, E_FAIL on failure.
===================================================================*/
STDMETHODIMP CReadCookie::get_Key(VARIANT varKey, VARIANT *pvarReturn)
	{
	char            *szKey;			// ascii version of the key
	CCookiePair     *pPair = NULL;	// name and value of cookie in the dictionary
    CWCharToMBCS    convKey;

    STACK_BUFFER( tempCookie, 128);

	// Initialize things
	//
	VariantInit(pvarReturn);
	VARIANT *pvarKey = &varKey;
	HRESULT hrReturn = S_OK;

	// BUG 937: VBScript passes VT_VARIANT|VT_BYREF when passing obect
	//          produced by IEnumVariant
	//
	// Use VariantResolveDispatch which will:
	//
	//     *  Copy BYREF variants for us using VariantCopyInd
	//     *  handle E_OUTOFMEMORY for us
	//     *  get the default value from an IDispatch, which seems
	//        like an appropriate conversion.
	//
	VARIANT varKeyCopy;
	VariantInit(&varKeyCopy);
	DWORD vt = V_VT(pvarKey);

	if ((V_VT(pvarKey) != VT_BSTR) && (vt != VT_I2) && (vt != VT_I4))
		{
		if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
			goto LExit;

		pvarKey = &varKeyCopy;
		}
	vt = V_VT(pvarKey);

	switch (vt)
		{
	// Bug 95201 support all numberic sub-types
	case VT_I1:  case VT_I2:               case VT_I8:
	case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
	case VT_R4:  case VT_R8:
		// Coerce all integral types to VT_I4
		if (FAILED(hrReturn = VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
			goto LExit;

		// fallthru to VT_I4

	case VT_I4:
	case VT_BSTR:
		break;
	
	case VT_ERROR:
		if (V_ERROR(pvarKey) == DISP_E_PARAMNOTFOUND)
			{
			V_VT(pvarReturn) = VT_BSTR;
	
			// simple value, URLEncoding NOT a good idea in this case
			if (m_pCookie->m_szValue)
				{
               	BSTR bstrT;
               	if (FAILED(SysAllocStringFromSz(m_pCookie->m_szValue, 0, &bstrT,m_pCookie->m_lCodePage)))
            		{
					ExceptionId(IID_IReadCookie, IDE_COOKIE, IDE_OOM);
					hrReturn = E_FAIL;
					goto LExit;
            		}
		        V_BSTR(pvarReturn) = bstrT;
				}			
			// dictionary value, must URLEncode to prevent '&', '=' from being misinterpreted
			else
				{
				int cbHTTPCookie = m_pCookie->GetHTTPCookieSize();
				if (cbHTTPCookie > REQUEST_ALLOC_MAX)
					{
					ExceptionId(IID_IReadCookie, IDE_COOKIE, IDE_STACK_OVERFLOW);
					hrReturn = E_FAIL;
					goto LExit;
					}

                if (tempCookie.Resize(cbHTTPCookie) == FALSE) {
					ExceptionId(IID_IReadCookie, IDE_COOKIE, IDE_OOM);
                    hrReturn = E_OUTOFMEMORY;
                    goto LExit;
                }
				char *szHTTPCookie = static_cast<char *>(tempCookie.QueryPtr());
				m_pCookie->GetHTTPCookie(szHTTPCookie);
	
               	BSTR bstrT;
               	if (FAILED(SysAllocStringFromSz(szHTTPCookie, 0, &bstrT, m_pCookie->m_lCodePage)))
            		{
					ExceptionId(IID_IReadCookie, IDE_COOKIE, IDE_OOM);
					hrReturn = E_FAIL;
					goto LExit;
            		}
		        V_BSTR(pvarReturn) = bstrT;
				}

			goto LExit;
			}

	default:
		ExceptionId(IID_IReadCookie, IDE_COOKIE, IDE_EXPECTING_STR);
		hrReturn = E_FAIL;
		goto LExit;
		}

	if (vt == VT_BSTR)
		{
		// convert the key to ANSI
        if (V_BSTR(pvarKey)) {
            if (FAILED(hrReturn = convKey.Init(V_BSTR(pvarKey),m_pCookie->m_lCodePage))) {
                goto LExit;
            }
            else {
                szKey = convKey.GetString();
            }
        }
        else {
			szKey = "";
        }

		// Look up the key in the Cookie.
		pPair = static_cast<CCookiePair *>(m_pCookie->m_mpszValues.FindElem(szKey, strlen(szKey)));
		}
	else 
		{
		// Look up item by index
		int iCount;
		
		iCount = V_I4(pvarKey);

		if ((iCount < 1) || 
			(m_pCookie->m_mpszValues.Count() == 0) ||
			(iCount > (int) m_pCookie->m_mpszValues.Count() ))
			{
			hrReturn = E_FAIL;
			ExceptionId(IID_IReadCookie, IDE_COOKIE, IDE_BAD_ARRAY_INDEX);
			goto LExit;
			}

		pPair = static_cast<CCookiePair *>(m_pCookie->m_mpszValues.Head());
		while((iCount > 1) && (pPair != NULL)) 
			{
			pPair = static_cast<CCookiePair *>(pPair->m_pNext);
			iCount--;
			}
		}

	if (pPair)
		{
		// Create a BSTR containing the key for this variant
    	BSTR bstrT;
        SysAllocStringFromSz((CHAR *)pPair->m_pKey, 0, &bstrT, m_pCookie->m_lCodePage);
		if (!bstrT)
			return E_OUTOFMEMORY;
		V_VT(pvarReturn) = VT_BSTR;
		V_BSTR(pvarReturn) = bstrT;
    	}

LExit:
	VariantClear(&varKeyCopy);
	return hrReturn;
	}


/*------------------------------------------------------------------
 * C C o o k i e
 */

/*===================================================================
CCookie::CCookie

constructor
===================================================================*/

CCookie::CCookie(CIsapiReqInfo   *pIReq, UINT lCodePage, IUnknown *pUnkOuter, PFNDESTROYED pfnDestroy)
	: m_WriteCookieInterface(this),
	  m_ReadCookieInterface(this),
	  m_CookieSupportErrorInfo(this)
	{
	m_szValue    = NULL;
	m_tExpires  = -1;
	m_szDomain   = NULL;
	m_szPath     = NULL;
	m_fSecure    = FALSE;
	m_fDirty     = FALSE;
	m_fDuplicate = FALSE;
	m_pfnDestroy = pfnDestroy;
	m_pIReq      = pIReq;
    m_lCodePage  = lCodePage;
	m_cRefs      = 1;
	}



/*===================================================================
CCookie::~CCookie

Destructor
===================================================================*/

CCookie::~CCookie()
	{
	CCookiePair *pNukePair = static_cast<CCookiePair *>(m_mpszValues.Head());
	while (pNukePair != NULL)
		{
		CCookiePair *pNext = static_cast<CCookiePair *>(pNukePair->m_pNext);
		delete pNukePair;
		pNukePair = pNext;
		}

	m_mpszValues.UnInit();
	
	if (m_fDuplicate)
		free(m_szValue);
	
	if (m_szDomain) free(m_szDomain);
	if (m_szPath) free(m_szPath);
	}



/*===================================================================
CCookie::Init

initialize the cookie. This initializes the cookie's value hashing
table
===================================================================*/

HRESULT CCookie::Init()
{
    HRESULT     hr = S_OK;
    TCHAR       pathInfo[MAX_PATH];
#if UNICODE
    CWCharToMBCS  convStr;
#endif

    if (FAILED(hr = m_mpszValues.Init(7)));

    // it would be nice if we could use the application path from the metabase,
    // but because of case sensitivity issues, we can't.  The safest bet is
    // to use the request's path info up to the length of the application's
    // pathinfo.

    else if (FAILED(hr=FindApplicationPath(m_pIReq, pathInfo, sizeof(pathInfo))));

#if UNICODE
    else if (FAILED(hr = convStr.Init(m_pIReq->QueryPszPathInfo(), m_lCodePage, _tcslen(pathInfo))));

    else {

        m_szPath = convStr.GetString(TRUE);
    }
#else
    else {

        int cchPathInfo = _tcslen(pathInfo);
        
        if (!(m_szPath = (char *)malloc(cchPathInfo+1))) {
            hr = E_OUTOFMEMORY;
        }
        else {
            memcpy(m_szPath, pathInfo, cchPathInfo+1);
        }
    }
#endif

    return hr;
}



/*===================================================================
CCookie::QueryInterface
CCookie::AddRef
CCookie::Release

IUnknown members for CCookie object.

Note on CCookie::QueryInterface: The Query for IDispatch is
ambiguous because it can either refer to IReadCookie or
IWriteCookie.  To resolve this, we resolve requests for IDispatch
to IReadCookie.  The rationale for this is that the code in
request.cpp calls QueryInterface for a generic IDispatch pointer
(because the collection is heterogenous)  The Response.Cookies
collection is homogeneous and so only calls QueryInterface for
IWriteCookie.
===================================================================*/

STDMETHODIMP CCookie::QueryInterface(const IID &idInterface, void **ppvObj)
	{
	if (idInterface == IID_IUnknown)
		*ppvObj = this;

	else if (idInterface == IID_IReadCookie || idInterface == IID_IDispatch)
		*ppvObj = &m_ReadCookieInterface;

	else if (idInterface == IID_IWriteCookie)
		*ppvObj = &m_WriteCookieInterface;

	else if (idInterface == IID_ISupportErrorInfo)
		*ppvObj = &m_CookieSupportErrorInfo;

	else
		*ppvObj = NULL;

	if (*ppvObj != NULL)
		{
		static_cast<IUnknown *>(*ppvObj)->AddRef();
		return S_OK;
		}

	return ResultFromScode(E_NOINTERFACE);
	}


STDMETHODIMP_(ULONG) CCookie::AddRef()
	{
	return ++m_cRefs;
	}


STDMETHODIMP_(ULONG) CCookie::Release(void)
	{
	if (--m_cRefs != 0)
		return m_cRefs;

	if (m_pfnDestroy != NULL)
		(*m_pfnDestroy)();

	delete this;
	return 0;
	}



/*===================================================================
CCookie::AddValue

Set the cookie's primary value. One you set the primary value,
you can't reset it.
===================================================================*/

HRESULT CCookie::AddValue(char *szValue, BOOL fDuplicate)
	{
	if (m_szValue != NULL)		// cookie already is marked as single-valued
		return E_FAIL;

	if (m_mpszValues.Count() != 0)	// cookie already has a value
		return E_FAIL;

	if (fDuplicate)
		{
		char *szNew = (char *)malloc(strlen(szValue) + 1);
		if (szNew == NULL)
			return E_OUTOFMEMORY;

		m_szValue = strcpy(szNew, szValue);
		}
	else
		m_szValue = szValue;

	m_fDuplicate = fDuplicate;
	return S_OK;
	}



/*===================================================================
CCookie::AddKeyAndValue

Add a key and value pair to the Cookie's dictionary. It fails
if the cookie has a primary value already set. It will overwrite
the value if the key already exists.
===================================================================*/

HRESULT CCookie::AddKeyAndValue(char *szKey, char *szValue, BOOL fDuplicate)
	{
	if (m_szValue != NULL)
		return E_FAIL;

	delete static_cast<CCookiePair *>(m_mpszValues.DeleteElem(szKey, strlen(szKey)));

	CCookiePair *pCookiePair = new CCookiePair;
	if (pCookiePair == NULL)
		return E_OUTOFMEMORY;

	if (FAILED(pCookiePair->Init(szKey, szValue, fDuplicate)))
		return E_FAIL;

	m_mpszValues.AddElem(pCookiePair);

	return S_OK;
	}




/*===================================================================
CCookie::GetHTTPCookieSize

Return the number of bytes required for the expansion of the HTTP_COOKIE variable
===================================================================*/

size_t CCookie::GetHTTPCookieSize()
	{
	if (m_szValue)
		return URLEncodeLen(m_szValue);

	else
		{
		int cbValue = 1;
		CCookiePair *pPair = static_cast<CCookiePair *>(m_mpszValues.Head());
		while (pPair)
			{
			// Add size of the URL Encoded key, a character for the '=', and a
			// character for the '&' or the NUL terminator.  URLEncodeLen
			// returns the size + 1, so the two calls to URLEncodeLen() add the
			// two characters we need.
			//
			cbValue += URLEncodeLen(reinterpret_cast<char *>(pPair->m_pKey)) + URLEncodeLen(pPair->m_szValue);
			pPair = static_cast<CCookiePair *>(pPair->m_pNext);
			}

		return cbValue;
		}
	}


/*===================================================================
CCookie::GetHTTPCookie

Return the URL Encoded value a single cookie

Parameters:
	szBuffer -  pointer to the destination buffer to store the
				URL encoded value

Returns:
	Returns a pointer to the terminating NUL character.
===================================================================*/

char *CCookie::GetHTTPCookie(char *szBuffer)
	{
	if (m_szValue)
		return URLEncode(szBuffer, m_szValue);

	else
		{
		char *szDest = szBuffer;
		*szDest = '\0';

		CCookiePair *pPair = static_cast<CCookiePair *>(m_mpszValues.Head());
		while (pPair)
			{
			// Write <name>=<value> string
			szDest = URLEncode(szDest, reinterpret_cast<char *>(pPair->m_pKey));
			*szDest++ = '=';
			szDest = URLEncode(szDest, pPair->m_szValue);

			// Advance
			pPair = static_cast<CCookiePair *>(pPair->m_pNext);

			// Append '&' if there's another one following
			if (pPair)
				*szDest++ = '&';
			}

		Assert (*szDest == '\0');	// make sure we are nul-terminated
		return szDest;
		}
	}



/*===================================================================
CCookie::GetCookieHeaderSize

Return the number of bytes required to allocate for the "Set-Cookie" header.

Parameters:
	szName - the name of the cookie (the size of the name is added to the value)

Returns:
	Returns 0 if *this does not contain a cookie value.
===================================================================*/

size_t CCookie::GetCookieHeaderSize(const char *szName)
	{
	int cbCookie = sizeof "Set-Cookie: ";		// initialize and add NUL terminator now

	// Add size of the URL Encoded name, a character for the '=', and the size
	// of the URL Encoded cookie value.  URLEncodeLen, and GetHttpCookieSize
	// compensate for the NUL terminator, so we actually SUBTRACT 1. (-2 for
	// these two function calls, +1 for the '=' sign
	//
	cbCookie += URLEncodeLen(szName) + GetHTTPCookieSize() - 1;
	
	if (m_tExpires != -1)
		cbCookie += (sizeof "; expires=") + DATE_STRING_SIZE - 1;

	// BUG 250 - DBCS External
	// ASP does not URLEncode the domain and path attributes, which was noticed
	// during localizaiton.
	//
	// NOTE: URLEncodeLen and sizeof both add a space for the nul terminator,
	//       so we subtract 2 to compensate.
	//
	if (m_szDomain)
		cbCookie += (sizeof "; domain=") + DBCSEncodeLen(m_szDomain) - 2;

	cbCookie += (sizeof "; path=") + DBCSEncodeLen(m_szPath) - 2;

	if (m_fSecure)
		cbCookie += (sizeof "; secure") - 1;
	
	return cbCookie;
	}



/*===================================================================
CCookie::GetCookieHeader

Construct the appropriate "Set-Cookie" header for a cookie.

Parameters:
	szName - the name of the cookie (the size of the name is added to the value)

Returns:
	Returns 0 if *this does not contain a cookie value.
===================================================================*/

char *CCookie::GetCookieHeader(const char *szName, char *szBuffer)
{
	// write out the cookie name and value
	//
	char *szDest = strcpyExA(szBuffer, "Set-Cookie: ");
	szDest = URLEncode(szDest, szName);
	szDest = strcpyExA(szDest, "=");
	szDest = GetHTTPCookie(szDest);
	
	if (m_tExpires != -1) {
		char szExpires[DATE_STRING_SIZE];
		CTimeToStringGMT(&m_tExpires, szExpires, TRUE);

		szDest = strcpyExA(szDest, "; expires=");
		szDest = strcpyExA(szDest, szExpires);
    }

	if (m_szDomain) {
		szDest = strcpyExA(szDest, "; domain=");
		szDest = DBCSEncode(szDest, m_szDomain);
    }

	szDest = strcpyExA(szDest, "; path=");
	szDest = DBCSEncode(szDest, m_szPath);

	if (m_fSecure)
		szDest = strcpyExA(szDest, "; secure");

	return szDest;
	}



/*------------------------------------------------------------------
 * C C o o k i e P a i r
 */

/*===================================================================
CCookiePair::CCookiePair

constructor
===================================================================*/

CCookiePair::CCookiePair()
	{
	m_fDuplicate = FALSE;
	m_szValue = NULL;
	}



/*===================================================================
CCookiePair::Init

Initialize the cookie pair with a key and a value.  Optionally,
it will copy the strings as well.
===================================================================*/

HRESULT CCookiePair::Init(const char *szKey, const char *szValue, BOOL fDuplicate)
	{
	m_fDuplicate = fDuplicate;
	if (fDuplicate)
		{
		char *szNewKey = (char *)malloc(strlen(szKey) + 1);
		if (szNewKey == NULL)
			return E_OUTOFMEMORY;
		
		char *szNewValue = (char *)malloc(strlen(szValue) + 1);
		if (szNewValue == NULL)
			{
			free(szNewKey);
			return E_OUTOFMEMORY;
			}
		
		if (FAILED(CLinkElem::Init(strcpy(szNewKey, szKey), strlen(szKey))))
			{
			free(szNewKey);
			free(szNewValue);
			return E_FAIL;
			}
	
		m_szValue = strcpy(szNewValue, szValue);
		}
	else
		{
		if (FAILED(CLinkElem::Init(const_cast<char *>(szKey), strlen(szKey))))
			return E_FAIL;
	
		m_szValue = const_cast<char *>(szValue);
		}
	
	return S_OK;
	}



/*===================================================================
CCookiePair::~CCookiePair

destructor
===================================================================*/

CCookiePair::~CCookiePair()
	{
	if (m_fDuplicate)
		{
		if (m_pKey) free(m_pKey);
		if (m_szValue) free(m_szValue);
		}
	}



/*------------------------------------------------------------------
 * C C o o k i e I t e r a t o r
 */

/*===================================================================
CCookieIterator::CCookieIterator

Constructor
===================================================================*/

CCookieIterator::CCookieIterator(CCookie *pCookie)
	{
	m_pCookie	= pCookie;
	m_pCurrent  = static_cast<CCookiePair *>(m_pCookie->m_mpszValues.Head());
	m_cRefs		= 1;

	m_pCookie->AddRef();
	}



/*===================================================================
CCookieIterator::CCookieIterator

Destructor
===================================================================*/

CCookieIterator::~CCookieIterator()
	{
	m_pCookie->Release();
	}



/*===================================================================
CCookieIterator::QueryInterface
CCookieIterator::AddRef
CCookieIterator::Release

IUnknown members for CServVarsIterator object.
===================================================================*/

STDMETHODIMP CCookieIterator::QueryInterface(REFIID iid, void **ppvObj)
	{
	if (iid == IID_IUnknown || iid == IID_IEnumVARIANT)
		{
		AddRef();
		*ppvObj = this;
		return S_OK;
		}

	*ppvObj = NULL;
	return E_NOINTERFACE;
	}


STDMETHODIMP_(ULONG) CCookieIterator::AddRef()
	{
	return ++m_cRefs;
	}


STDMETHODIMP_(ULONG) CCookieIterator::Release()
	{
	if (--m_cRefs > 0)
		return m_cRefs;

	delete this;
	return 0;
	}



/*===================================================================
CCookieIterator::Clone

Clone this iterator (standard method)
===================================================================*/

STDMETHODIMP CCookieIterator::Clone(IEnumVARIANT **ppEnumReturn)
	{
	CCookieIterator *pNewIterator = new CCookieIterator(m_pCookie);
	if (pNewIterator == NULL)
		return E_OUTOFMEMORY;

	// new iterator should point to same location as this.
	pNewIterator->m_pCurrent = m_pCurrent;

	*ppEnumReturn = pNewIterator;
	return S_OK;
	}



/*===================================================================
CCookieIterator::Next

Get next value (standard method)

To rehash standard OLE semantics:

	We get the next "cElements" from the collection and store them
	in "rgVariant" which holds at least "cElements" items.  On
	return "*pcElementsFetched" contains the actual number of elements
	stored.  Returns S_FALSE if less than "cElements" were stored, S_OK
	otherwise.
===================================================================*/

STDMETHODIMP CCookieIterator::Next(unsigned long cElementsRequested, VARIANT *rgVariant, unsigned long *pcElementsFetched)
	{
	// give a valid pointer value to 'pcElementsFetched'
	//
	unsigned long cElementsFetched;
	if (pcElementsFetched == NULL)
		pcElementsFetched = &cElementsFetched;

	// Loop through the collection until either we reach the end or
	// cElements becomes zero
	//
	unsigned long cElements = cElementsRequested;
	*pcElementsFetched = 0;

	while (cElements > 0 && m_pCurrent != NULL)
		{
       	BSTR bstrT;
       	if (FAILED(SysAllocStringFromSz(reinterpret_cast<char *>(m_pCurrent->m_pKey), 0, &bstrT, m_pCookie->m_lCodePage)))
			return E_OUTOFMEMORY;
		V_VT(rgVariant) = VT_BSTR;
        V_BSTR(rgVariant) = bstrT;

		++rgVariant;
		--cElements;
		++*pcElementsFetched;
		m_pCurrent = static_cast<CCookiePair *>(m_pCurrent->m_pNext);
		}

	// initialize the remaining variants
	//
	while (cElements-- > 0)
		VariantInit(rgVariant++);

	return (*pcElementsFetched == cElementsRequested)? S_OK : S_FALSE;
	}



/*===================================================================
CCookieIterator::Skip

Skip items (standard method)

To rehash standard OLE semantics:

	We skip over the next "cElements" from the collection.
	Returns S_FALSE if less than "cElements" were skipped, S_OK
	otherwise.
===================================================================*/

STDMETHODIMP CCookieIterator::Skip(unsigned long cElements)
	{
	/* Loop through the collection until either we reach the end or
	 * cElements becomes zero
	 */
	while (cElements > 0 && m_pCurrent != NULL)
		{
		--cElements;
		m_pCurrent = static_cast<CCookiePair *>(m_pCurrent->m_pNext);
		}

	return (cElements == 0)? S_OK : S_FALSE;
	}



/*===================================================================
CCookieIterator::Reset

Reset the iterator (standard method)
===================================================================*/

STDMETHODIMP CCookieIterator::Reset()
	{
	m_pCurrent = static_cast<CCookiePair *>(m_pCookie->m_mpszValues.Head());
	return S_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\dbgprop.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Thu May 22 14:24:06 1997
 */
/* Compiler settings for dbgprop.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"
#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __dbgprop_h__
#define __dbgprop_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IDebugProperty_FWD_DEFINED__
#define __IDebugProperty_FWD_DEFINED__
typedef interface IDebugProperty IDebugProperty;
#endif 	/* __IDebugProperty_FWD_DEFINED__ */


#ifndef __IEnumDebugPropertyInfo_FWD_DEFINED__
#define __IEnumDebugPropertyInfo_FWD_DEFINED__
typedef interface IEnumDebugPropertyInfo IEnumDebugPropertyInfo;
#endif 	/* __IEnumDebugPropertyInfo_FWD_DEFINED__ */


#ifndef __IDebugExtendedProperty_FWD_DEFINED__
#define __IDebugExtendedProperty_FWD_DEFINED__
typedef interface IDebugExtendedProperty IDebugExtendedProperty;
#endif 	/* __IDebugExtendedProperty_FWD_DEFINED__ */


#ifndef __IEnumDebugExtendedPropertyInfo_FWD_DEFINED__
#define __IEnumDebugExtendedPropertyInfo_FWD_DEFINED__
typedef interface IEnumDebugExtendedPropertyInfo IEnumDebugExtendedPropertyInfo;
#endif 	/* __IEnumDebugExtendedPropertyInfo_FWD_DEFINED__ */


#ifndef __IPerPropertyBrowsing2_FWD_DEFINED__
#define __IPerPropertyBrowsing2_FWD_DEFINED__
typedef interface IPerPropertyBrowsing2 IPerPropertyBrowsing2;
#endif 	/* __IPerPropertyBrowsing2_FWD_DEFINED__ */


#ifndef __IDebugPropertyEnumType_All_FWD_DEFINED__
#define __IDebugPropertyEnumType_All_FWD_DEFINED__
typedef interface IDebugPropertyEnumType_All IDebugPropertyEnumType_All;
#endif 	/* __IDebugPropertyEnumType_All_FWD_DEFINED__ */


#ifndef __IDebugPropertyEnumType_Locals_FWD_DEFINED__
#define __IDebugPropertyEnumType_Locals_FWD_DEFINED__
typedef interface IDebugPropertyEnumType_Locals IDebugPropertyEnumType_Locals;
#endif 	/* __IDebugPropertyEnumType_Locals_FWD_DEFINED__ */


#ifndef __IDebugPropertyEnumType_Arguments_FWD_DEFINED__
#define __IDebugPropertyEnumType_Arguments_FWD_DEFINED__
typedef interface IDebugPropertyEnumType_Arguments IDebugPropertyEnumType_Arguments;
#endif 	/* __IDebugPropertyEnumType_Arguments_FWD_DEFINED__ */


#ifndef __IDebugPropertyEnumType_LocalsPlusArgs_FWD_DEFINED__
#define __IDebugPropertyEnumType_LocalsPlusArgs_FWD_DEFINED__
typedef interface IDebugPropertyEnumType_LocalsPlusArgs IDebugPropertyEnumType_LocalsPlusArgs;
#endif 	/* __IDebugPropertyEnumType_LocalsPlusArgs_FWD_DEFINED__ */


#ifndef __IDebugPropertyEnumType_Registers_FWD_DEFINED__
#define __IDebugPropertyEnumType_Registers_FWD_DEFINED__
typedef interface IDebugPropertyEnumType_Registers IDebugPropertyEnumType_Registers;
#endif 	/* __IDebugPropertyEnumType_Registers_FWD_DEFINED__ */


/* header files for imported files */
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_dbgprop_0000
 * at Thu May 22 14:24:06 1997
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 







typedef /* [public] */ 
enum __MIDL___MIDL_itf_dbgprop_0000_0001
    {	OBJECT_ATTRIB_NO_ATTRIB	= 0,
	OBJECT_ATTRIB_NO_NAME	= 0x1,
	OBJECT_ATTRIB_NO_TYPE	= 0x2,
	OBJECT_ATTRIB_NO_VALUE	= 0x4,
	OBJECT_ATTRIB_VALUE_IS_INVALID	= 0x8,
	OBJECT_ATTRIB_VALUE_IS_OBJECT	= 0x10,
	OBJECT_ATTRIB_VALUE_IS_ENUM	= 0x20,
	OBJECT_ATTRIB_VALUE_IS_CUSTOM	= 0x40,
	OBJECT_ATTRIB_OBJECT_IS_EXPANDABLE	= 0x70,
	OBJECT_ATTRIB_VALUE_HAS_CODE	= 0x80,
	OBJECT_ATTRIB_TYPE_IS_OBJECT	= 0x100,
	OBJECT_ATTRIB_TYPE_HAS_CODE	= 0x200,
	OBJECT_ATTRIB_TYPE_IS_EXPANDABLE	= 0x100,
	OBJECT_ATTRIB_SLOT_IS_CATEGORY	= 0x400,
	OBJECT_ATTRIB_VALUE_READONLY	= 0x800,
	OBJECT_ATTRIB_ACCESS_PUBLIC	= 0x1000,
	OBJECT_ATTRIB_ACCESS_PRIVATE	= 0x2000,
	OBJECT_ATTRIB_ACCESS_PROTECTED	= 0x4000,
	OBJECT_ATTRIB_ACCESS_FINAL	= 0x8000,
	OBJECT_ATTRIB_STORAGE_GLOBAL	= 0x10000,
	OBJECT_ATTRIB_STORAGE_STATIC	= 0x20000,
	OBJECT_ATTRIB_STORAGE_FIELD	= 0x40000,
	OBJECT_ATTRIB_STORAGE_VIRTUAL	= 0x80000,
	OBJECT_ATTRIB_TYPE_IS_CONSTANT	= 0x100000,
	OBJECT_ATTRIB_TYPE_IS_SYNCHRONIZED	= 0x200000,
	OBJECT_ATTRIB_TYPE_IS_VOLATILE	= 0x400000,
	OBJECT_ATTRIB_HAS_EXTENDED_ATTRIBS	= 0x800000,
	OBJECT_ATTRIB_IS_CLASS	= 0x1000000,
	OBJECT_ATTRIB_IS_FUNCTION	= 0x2000000,
	OBJECT_ATTRIB_IS_VARIABLE	= 0x4000000,
	OBJECT_ATTRIB_IS_PROPERTY	= 0x8000000,
	OBJECT_ATTRIB_IS_MACRO	= 0x10000000,
	OBJECT_ATTRIB_IS_TYPE	= 0x20000000,
	OBJECT_ATTRIB_IS_INHERITED	= 0x40000000,
	OBJECT_ATTRIB_IS_INTERFACE	= 0x80000000
    }	OBJECT_ATTRIB_FLAGS;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_dbgprop_0000_0002
    {	PROP_INFO_NAME	= 0x1,
	PROP_INFO_TYPE	= 0x2,
	PROP_INFO_VALUE	= 0x4,
	PROP_INFO_FULLNAME	= 0x20,
	PROP_INFO_ATTRIBUTES	= 0x8,
	PROP_INFO_DEBUGPROP	= 0x10,
	PROP_INFO_AUTOEXPAND	= 0x8000000
    }	PROP_INFO_FLAGS;

#define	PROP_INFO_STANDARD	( PROP_INFO_NAME | PROP_INFO_TYPE | PROP_INFO_VALUE | PROP_INFO_ATTRIBUTES )

#define	PROP_INFO_ALL	( PROP_INFO_NAME | PROP_INFO_TYPE | PROP_INFO_VALUE | PROP_INFO_FULLNAME | PROP_INFO_ATTRIBUTES | PROP_INFO_DEBUGPROP )

typedef struct  tagDebugPropertyInfo
    {
    DWORD m_dwValidFields;
    BSTR m_bstrName;
    BSTR m_bstrType;
    BSTR m_bstrValue;
    BSTR m_bstrFullName;
    DWORD m_dwAttrib;
    IDebugProperty __RPC_FAR *m_pDebugProp;
    }	DebugPropertyInfo;

typedef /* [public] */ 
enum __MIDL___MIDL_itf_dbgprop_0000_0003
    {	EX_PROP_INFO_ID	= 0x100,
	EX_PROP_INFO_NTYPE	= 0x200,
	EX_PROP_INFO_NVALUE	= 0x400,
	EX_PROP_INFO_LOCKBYTES	= 0x800,
	EX_PROP_INFO_DEBUGEXTPROP	= 0x1000
    }	EX_PROP_INFO_FLAGS;

typedef struct  tagExtendedDebugPropertyInfo
    {
    DWORD m_dwValidFields;
    LPOLESTR m_bstrName;
    LPOLESTR m_bstrType;
    LPOLESTR m_bstrValue;
    LPOLESTR m_bstrFullName;
    DWORD m_dwAttrib;
    IDebugProperty __RPC_FAR *m_pDebugProp;
    DWORD m_nDISPID;
    DWORD m_nType;
    VARIANT m_varValue;
    ILockBytes __RPC_FAR *m_plbValue;
    IDebugExtendedProperty __RPC_FAR *m_pDebugExtProp;
    }	ExtendedDebugPropertyInfo;



extern RPC_IF_HANDLE __MIDL_itf_dbgprop_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_dbgprop_0000_v0_0_s_ifspec;

#ifndef __IDebugProperty_INTERFACE_DEFINED__
#define __IDebugProperty_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDebugProperty
 * at Thu May 22 14:24:06 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IDebugProperty;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51973C50-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugProperty : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE GetPropertyInfo( 
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ DebugPropertyInfo __RPC_FAR *pPropertyInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetExtendedInfo( 
            /* [in] */ ULONG cInfos,
            /* [size_is][in] */ GUID __RPC_FAR *rgguidExtendedInfo,
            /* [size_is][out] */ VARIANT __RPC_FAR *rgvar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValueAsString( 
            /* [in] */ LPCOLESTR pszValue,
            /* [in] */ UINT nRadix) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumMembers( 
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [in] */ REFIID refiid,
            /* [out] */ IEnumDebugPropertyInfo __RPC_FAR *__RPC_FAR *ppepi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetParent( 
            /* [out] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppDebugProp) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugPropertyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugProperty __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugProperty __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugProperty __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyInfo )( 
            IDebugProperty __RPC_FAR * This,
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ DebugPropertyInfo __RPC_FAR *pPropertyInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetExtendedInfo )( 
            IDebugProperty __RPC_FAR * This,
            /* [in] */ ULONG cInfos,
            /* [size_is][in] */ GUID __RPC_FAR *rgguidExtendedInfo,
            /* [size_is][out] */ VARIANT __RPC_FAR *rgvar);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetValueAsString )( 
            IDebugProperty __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszValue,
            /* [in] */ UINT nRadix);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumMembers )( 
            IDebugProperty __RPC_FAR * This,
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [in] */ REFIID refiid,
            /* [out] */ IEnumDebugPropertyInfo __RPC_FAR *__RPC_FAR *ppepi);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParent )( 
            IDebugProperty __RPC_FAR * This,
            /* [out] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppDebugProp);
        
        END_INTERFACE
    } IDebugPropertyVtbl;

    interface IDebugProperty
    {
        CONST_VTBL struct IDebugPropertyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugProperty_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugProperty_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugProperty_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugProperty_GetPropertyInfo(This,dwFieldSpec,nRadix,pPropertyInfo)	\
    (This)->lpVtbl -> GetPropertyInfo(This,dwFieldSpec,nRadix,pPropertyInfo)

#define IDebugProperty_GetExtendedInfo(This,cInfos,rgguidExtendedInfo,rgvar)	\
    (This)->lpVtbl -> GetExtendedInfo(This,cInfos,rgguidExtendedInfo,rgvar)

#define IDebugProperty_SetValueAsString(This,pszValue,nRadix)	\
    (This)->lpVtbl -> SetValueAsString(This,pszValue,nRadix)

#define IDebugProperty_EnumMembers(This,dwFieldSpec,nRadix,refiid,ppepi)	\
    (This)->lpVtbl -> EnumMembers(This,dwFieldSpec,nRadix,refiid,ppepi)

#define IDebugProperty_GetParent(This,ppDebugProp)	\
    (This)->lpVtbl -> GetParent(This,ppDebugProp)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IDebugProperty_RemoteGetPropertyInfo_Proxy( 
    IDebugProperty __RPC_FAR * This,
    /* [in] */ DWORD dwFieldSpec,
    /* [in] */ UINT nRadix,
    /* [out] */ DWORD __RPC_FAR *dwValidFields,
    /* [out] */ BSTR __RPC_FAR *pbstrName,
    /* [out] */ BSTR __RPC_FAR *pbstrType,
    /* [out] */ BSTR __RPC_FAR *pbstrValue,
    /* [out] */ BSTR __RPC_FAR *pbstrFullName,
    /* [out] */ DWORD __RPC_FAR *pdwAttrib,
    /* [unique][out][in] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppDebugProperty);


void __RPC_STUB IDebugProperty_RemoteGetPropertyInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProperty_GetExtendedInfo_Proxy( 
    IDebugProperty __RPC_FAR * This,
    /* [in] */ ULONG cInfos,
    /* [size_is][in] */ GUID __RPC_FAR *rgguidExtendedInfo,
    /* [size_is][out] */ VARIANT __RPC_FAR *rgvar);


void __RPC_STUB IDebugProperty_GetExtendedInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProperty_SetValueAsString_Proxy( 
    IDebugProperty __RPC_FAR * This,
    /* [in] */ LPCOLESTR pszValue,
    /* [in] */ UINT nRadix);


void __RPC_STUB IDebugProperty_SetValueAsString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProperty_EnumMembers_Proxy( 
    IDebugProperty __RPC_FAR * This,
    /* [in] */ DWORD dwFieldSpec,
    /* [in] */ UINT nRadix,
    /* [in] */ REFIID refiid,
    /* [out] */ IEnumDebugPropertyInfo __RPC_FAR *__RPC_FAR *ppepi);


void __RPC_STUB IDebugProperty_EnumMembers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugProperty_GetParent_Proxy( 
    IDebugProperty __RPC_FAR * This,
    /* [out] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppDebugProp);


void __RPC_STUB IDebugProperty_GetParent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugProperty_INTERFACE_DEFINED__ */


#ifndef __IEnumDebugPropertyInfo_INTERFACE_DEFINED__
#define __IEnumDebugPropertyInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumDebugPropertyInfo
 * at Thu May 22 14:24:06 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IEnumDebugPropertyInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51973C51-CB0C-11d0-B5C9-00A0244A0E7A")
    IEnumDebugPropertyInfo : public IUnknown
    {
    public:
        virtual /* [local] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [out] */ DebugPropertyInfo __RPC_FAR *pi,
            /* [out] */ ULONG __RPC_FAR *pcEltsfetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumDebugPropertyInfo __RPC_FAR *__RPC_FAR *ppepi) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG __RPC_FAR *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDebugPropertyInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumDebugPropertyInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumDebugPropertyInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumDebugPropertyInfo __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumDebugPropertyInfo __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [out] */ DebugPropertyInfo __RPC_FAR *pi,
            /* [out] */ ULONG __RPC_FAR *pcEltsfetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumDebugPropertyInfo __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumDebugPropertyInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumDebugPropertyInfo __RPC_FAR * This,
            /* [out] */ IEnumDebugPropertyInfo __RPC_FAR *__RPC_FAR *ppepi);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IEnumDebugPropertyInfo __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        END_INTERFACE
    } IEnumDebugPropertyInfoVtbl;

    interface IEnumDebugPropertyInfo
    {
        CONST_VTBL struct IEnumDebugPropertyInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDebugPropertyInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDebugPropertyInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDebugPropertyInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDebugPropertyInfo_Next(This,celt,pi,pcEltsfetched)	\
    (This)->lpVtbl -> Next(This,celt,pi,pcEltsfetched)

#define IEnumDebugPropertyInfo_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumDebugPropertyInfo_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDebugPropertyInfo_Clone(This,ppepi)	\
    (This)->lpVtbl -> Clone(This,ppepi)

#define IEnumDebugPropertyInfo_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumDebugPropertyInfo_RemoteNext_Proxy( 
    IEnumDebugPropertyInfo __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *dwValidFields,
    /* [out] */ BSTR __RPC_FAR *pbstrName,
    /* [out] */ BSTR __RPC_FAR *pbstrType,
    /* [out] */ BSTR __RPC_FAR *pbstrValue,
    /* [out] */ BSTR __RPC_FAR *pbstrFullName,
    /* [out] */ DWORD __RPC_FAR *pdwAttrib,
    /* [unique][out][in] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppDebugProperty);


void __RPC_STUB IEnumDebugPropertyInfo_RemoteNext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugPropertyInfo_Skip_Proxy( 
    IEnumDebugPropertyInfo __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumDebugPropertyInfo_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugPropertyInfo_Reset_Proxy( 
    IEnumDebugPropertyInfo __RPC_FAR * This);


void __RPC_STUB IEnumDebugPropertyInfo_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugPropertyInfo_Clone_Proxy( 
    IEnumDebugPropertyInfo __RPC_FAR * This,
    /* [out] */ IEnumDebugPropertyInfo __RPC_FAR *__RPC_FAR *ppepi);


void __RPC_STUB IEnumDebugPropertyInfo_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugPropertyInfo_GetCount_Proxy( 
    IEnumDebugPropertyInfo __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcelt);


void __RPC_STUB IEnumDebugPropertyInfo_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDebugPropertyInfo_INTERFACE_DEFINED__ */


#ifndef __IDebugExtendedProperty_INTERFACE_DEFINED__
#define __IDebugExtendedProperty_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDebugExtendedProperty
 * at Thu May 22 14:24:06 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IDebugExtendedProperty;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51973C52-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugExtendedProperty : public IDebugProperty
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetExtendedPropertyInfo( 
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ ExtendedDebugPropertyInfo __RPC_FAR *pExtendedPropertyInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumExtendedMembers( 
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ IEnumDebugExtendedPropertyInfo __RPC_FAR *__RPC_FAR *ppeepi) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugExtendedPropertyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugExtendedProperty __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugExtendedProperty __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugExtendedProperty __RPC_FAR * This);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPropertyInfo )( 
            IDebugExtendedProperty __RPC_FAR * This,
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ DebugPropertyInfo __RPC_FAR *pPropertyInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetExtendedInfo )( 
            IDebugExtendedProperty __RPC_FAR * This,
            /* [in] */ ULONG cInfos,
            /* [size_is][in] */ GUID __RPC_FAR *rgguidExtendedInfo,
            /* [size_is][out] */ VARIANT __RPC_FAR *rgvar);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetValueAsString )( 
            IDebugExtendedProperty __RPC_FAR * This,
            /* [in] */ LPCOLESTR pszValue,
            /* [in] */ UINT nRadix);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumMembers )( 
            IDebugExtendedProperty __RPC_FAR * This,
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [in] */ REFIID refiid,
            /* [out] */ IEnumDebugPropertyInfo __RPC_FAR *__RPC_FAR *ppepi);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetParent )( 
            IDebugExtendedProperty __RPC_FAR * This,
            /* [out] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppDebugProp);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetExtendedPropertyInfo )( 
            IDebugExtendedProperty __RPC_FAR * This,
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ ExtendedDebugPropertyInfo __RPC_FAR *pExtendedPropertyInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumExtendedMembers )( 
            IDebugExtendedProperty __RPC_FAR * This,
            /* [in] */ DWORD dwFieldSpec,
            /* [in] */ UINT nRadix,
            /* [out] */ IEnumDebugExtendedPropertyInfo __RPC_FAR *__RPC_FAR *ppeepi);
        
        END_INTERFACE
    } IDebugExtendedPropertyVtbl;

    interface IDebugExtendedProperty
    {
        CONST_VTBL struct IDebugExtendedPropertyVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugExtendedProperty_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugExtendedProperty_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugExtendedProperty_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugExtendedProperty_GetPropertyInfo(This,dwFieldSpec,nRadix,pPropertyInfo)	\
    (This)->lpVtbl -> GetPropertyInfo(This,dwFieldSpec,nRadix,pPropertyInfo)

#define IDebugExtendedProperty_GetExtendedInfo(This,cInfos,rgguidExtendedInfo,rgvar)	\
    (This)->lpVtbl -> GetExtendedInfo(This,cInfos,rgguidExtendedInfo,rgvar)

#define IDebugExtendedProperty_SetValueAsString(This,pszValue,nRadix)	\
    (This)->lpVtbl -> SetValueAsString(This,pszValue,nRadix)

#define IDebugExtendedProperty_EnumMembers(This,dwFieldSpec,nRadix,refiid,ppepi)	\
    (This)->lpVtbl -> EnumMembers(This,dwFieldSpec,nRadix,refiid,ppepi)

#define IDebugExtendedProperty_GetParent(This,ppDebugProp)	\
    (This)->lpVtbl -> GetParent(This,ppDebugProp)


#define IDebugExtendedProperty_GetExtendedPropertyInfo(This,dwFieldSpec,nRadix,pExtendedPropertyInfo)	\
    (This)->lpVtbl -> GetExtendedPropertyInfo(This,dwFieldSpec,nRadix,pExtendedPropertyInfo)

#define IDebugExtendedProperty_EnumExtendedMembers(This,dwFieldSpec,nRadix,ppeepi)	\
    (This)->lpVtbl -> EnumExtendedMembers(This,dwFieldSpec,nRadix,ppeepi)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugExtendedProperty_GetExtendedPropertyInfo_Proxy( 
    IDebugExtendedProperty __RPC_FAR * This,
    /* [in] */ DWORD dwFieldSpec,
    /* [in] */ UINT nRadix,
    /* [out] */ ExtendedDebugPropertyInfo __RPC_FAR *pExtendedPropertyInfo);


void __RPC_STUB IDebugExtendedProperty_GetExtendedPropertyInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDebugExtendedProperty_EnumExtendedMembers_Proxy( 
    IDebugExtendedProperty __RPC_FAR * This,
    /* [in] */ DWORD dwFieldSpec,
    /* [in] */ UINT nRadix,
    /* [out] */ IEnumDebugExtendedPropertyInfo __RPC_FAR *__RPC_FAR *ppeepi);


void __RPC_STUB IDebugExtendedProperty_EnumExtendedMembers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugExtendedProperty_INTERFACE_DEFINED__ */


#ifndef __IEnumDebugExtendedPropertyInfo_INTERFACE_DEFINED__
#define __IEnumDebugExtendedPropertyInfo_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumDebugExtendedPropertyInfo
 * at Thu May 22 14:24:06 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IEnumDebugExtendedPropertyInfo;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51973C53-CB0C-11d0-B5C9-00A0244A0E7A")
    IEnumDebugExtendedPropertyInfo : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ExtendedDebugPropertyInfo __RPC_FAR *rgExtendedPropertyInfo,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumDebugExtendedPropertyInfo __RPC_FAR *__RPC_FAR *pedpe) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCount( 
            /* [out] */ ULONG __RPC_FAR *pcelt) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumDebugExtendedPropertyInfoVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumDebugExtendedPropertyInfo __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumDebugExtendedPropertyInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ ExtendedDebugPropertyInfo __RPC_FAR *rgExtendedPropertyInfo,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumDebugExtendedPropertyInfo __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
            /* [out] */ IEnumDebugExtendedPropertyInfo __RPC_FAR *__RPC_FAR *pedpe);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCount )( 
            IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
            /* [out] */ ULONG __RPC_FAR *pcelt);
        
        END_INTERFACE
    } IEnumDebugExtendedPropertyInfoVtbl;

    interface IEnumDebugExtendedPropertyInfo
    {
        CONST_VTBL struct IEnumDebugExtendedPropertyInfoVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumDebugExtendedPropertyInfo_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumDebugExtendedPropertyInfo_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumDebugExtendedPropertyInfo_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumDebugExtendedPropertyInfo_Next(This,celt,rgExtendedPropertyInfo,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgExtendedPropertyInfo,pceltFetched)

#define IEnumDebugExtendedPropertyInfo_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumDebugExtendedPropertyInfo_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumDebugExtendedPropertyInfo_Clone(This,pedpe)	\
    (This)->lpVtbl -> Clone(This,pedpe)

#define IEnumDebugExtendedPropertyInfo_GetCount(This,pcelt)	\
    (This)->lpVtbl -> GetCount(This,pcelt)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumDebugExtendedPropertyInfo_Next_Proxy( 
    IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ ExtendedDebugPropertyInfo __RPC_FAR *rgExtendedPropertyInfo,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumDebugExtendedPropertyInfo_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugExtendedPropertyInfo_Skip_Proxy( 
    IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumDebugExtendedPropertyInfo_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugExtendedPropertyInfo_Reset_Proxy( 
    IEnumDebugExtendedPropertyInfo __RPC_FAR * This);


void __RPC_STUB IEnumDebugExtendedPropertyInfo_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugExtendedPropertyInfo_Clone_Proxy( 
    IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
    /* [out] */ IEnumDebugExtendedPropertyInfo __RPC_FAR *__RPC_FAR *pedpe);


void __RPC_STUB IEnumDebugExtendedPropertyInfo_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumDebugExtendedPropertyInfo_GetCount_Proxy( 
    IEnumDebugExtendedPropertyInfo __RPC_FAR * This,
    /* [out] */ ULONG __RPC_FAR *pcelt);


void __RPC_STUB IEnumDebugExtendedPropertyInfo_GetCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumDebugExtendedPropertyInfo_INTERFACE_DEFINED__ */


#ifndef __IPerPropertyBrowsing2_INTERFACE_DEFINED__
#define __IPerPropertyBrowsing2_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IPerPropertyBrowsing2
 * at Thu May 22 14:24:06 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IPerPropertyBrowsing2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51973C54-CB0C-11d0-B5C9-00A0244A0E7A")
    IPerPropertyBrowsing2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetDisplayString( 
            /* [in] */ DISPID dispid,
            /* [out] */ BSTR __RPC_FAR *pBstr) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE MapPropertyToPage( 
            /* [in] */ DISPID dispid,
            /* [out] */ CLSID __RPC_FAR *pClsidPropPage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPredefinedStrings( 
            /* [in] */ DISPID dispid,
            /* [out] */ CALPOLESTR __RPC_FAR *pCaStrings,
            /* [out] */ CADWORD __RPC_FAR *pCaCookies) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPredefinedValue( 
            /* [in] */ DISPID dispid,
            /* [in] */ DWORD dwCookie) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPerPropertyBrowsing2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IPerPropertyBrowsing2 __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IPerPropertyBrowsing2 __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IPerPropertyBrowsing2 __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDisplayString )( 
            IPerPropertyBrowsing2 __RPC_FAR * This,
            /* [in] */ DISPID dispid,
            /* [out] */ BSTR __RPC_FAR *pBstr);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MapPropertyToPage )( 
            IPerPropertyBrowsing2 __RPC_FAR * This,
            /* [in] */ DISPID dispid,
            /* [out] */ CLSID __RPC_FAR *pClsidPropPage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetPredefinedStrings )( 
            IPerPropertyBrowsing2 __RPC_FAR * This,
            /* [in] */ DISPID dispid,
            /* [out] */ CALPOLESTR __RPC_FAR *pCaStrings,
            /* [out] */ CADWORD __RPC_FAR *pCaCookies);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetPredefinedValue )( 
            IPerPropertyBrowsing2 __RPC_FAR * This,
            /* [in] */ DISPID dispid,
            /* [in] */ DWORD dwCookie);
        
        END_INTERFACE
    } IPerPropertyBrowsing2Vtbl;

    interface IPerPropertyBrowsing2
    {
        CONST_VTBL struct IPerPropertyBrowsing2Vtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPerPropertyBrowsing2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPerPropertyBrowsing2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPerPropertyBrowsing2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPerPropertyBrowsing2_GetDisplayString(This,dispid,pBstr)	\
    (This)->lpVtbl -> GetDisplayString(This,dispid,pBstr)

#define IPerPropertyBrowsing2_MapPropertyToPage(This,dispid,pClsidPropPage)	\
    (This)->lpVtbl -> MapPropertyToPage(This,dispid,pClsidPropPage)

#define IPerPropertyBrowsing2_GetPredefinedStrings(This,dispid,pCaStrings,pCaCookies)	\
    (This)->lpVtbl -> GetPredefinedStrings(This,dispid,pCaStrings,pCaCookies)

#define IPerPropertyBrowsing2_SetPredefinedValue(This,dispid,dwCookie)	\
    (This)->lpVtbl -> SetPredefinedValue(This,dispid,dwCookie)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPerPropertyBrowsing2_GetDisplayString_Proxy( 
    IPerPropertyBrowsing2 __RPC_FAR * This,
    /* [in] */ DISPID dispid,
    /* [out] */ BSTR __RPC_FAR *pBstr);


void __RPC_STUB IPerPropertyBrowsing2_GetDisplayString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPerPropertyBrowsing2_MapPropertyToPage_Proxy( 
    IPerPropertyBrowsing2 __RPC_FAR * This,
    /* [in] */ DISPID dispid,
    /* [out] */ CLSID __RPC_FAR *pClsidPropPage);


void __RPC_STUB IPerPropertyBrowsing2_MapPropertyToPage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPerPropertyBrowsing2_GetPredefinedStrings_Proxy( 
    IPerPropertyBrowsing2 __RPC_FAR * This,
    /* [in] */ DISPID dispid,
    /* [out] */ CALPOLESTR __RPC_FAR *pCaStrings,
    /* [out] */ CADWORD __RPC_FAR *pCaCookies);


void __RPC_STUB IPerPropertyBrowsing2_GetPredefinedStrings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPerPropertyBrowsing2_SetPredefinedValue_Proxy( 
    IPerPropertyBrowsing2 __RPC_FAR * This,
    /* [in] */ DISPID dispid,
    /* [in] */ DWORD dwCookie);


void __RPC_STUB IPerPropertyBrowsing2_SetPredefinedValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPerPropertyBrowsing2_INTERFACE_DEFINED__ */


#ifndef __IDebugPropertyEnumType_All_INTERFACE_DEFINED__
#define __IDebugPropertyEnumType_All_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDebugPropertyEnumType_All
 * at Thu May 22 14:24:06 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IDebugPropertyEnumType_All;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51973C55-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugPropertyEnumType_All : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [out] */ BSTR __RPC_FAR *__MIDL_0016) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDebugPropertyEnumType_AllVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugPropertyEnumType_All __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugPropertyEnumType_All __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugPropertyEnumType_All __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IDebugPropertyEnumType_All __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *__MIDL_0016);
        
        END_INTERFACE
    } IDebugPropertyEnumType_AllVtbl;

    interface IDebugPropertyEnumType_All
    {
        CONST_VTBL struct IDebugPropertyEnumType_AllVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugPropertyEnumType_All_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugPropertyEnumType_All_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugPropertyEnumType_All_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugPropertyEnumType_All_GetName(This,__MIDL_0016)	\
    (This)->lpVtbl -> GetName(This,__MIDL_0016)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDebugPropertyEnumType_All_GetName_Proxy( 
    IDebugPropertyEnumType_All __RPC_FAR * This,
    /* [out] */ BSTR __RPC_FAR *__MIDL_0016);


void __RPC_STUB IDebugPropertyEnumType_All_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDebugPropertyEnumType_All_INTERFACE_DEFINED__ */


#ifndef __IDebugPropertyEnumType_Locals_INTERFACE_DEFINED__
#define __IDebugPropertyEnumType_Locals_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDebugPropertyEnumType_Locals
 * at Thu May 22 14:24:06 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IDebugPropertyEnumType_Locals;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51973C56-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugPropertyEnumType_Locals : public IDebugPropertyEnumType_All
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDebugPropertyEnumType_LocalsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugPropertyEnumType_Locals __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugPropertyEnumType_Locals __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugPropertyEnumType_Locals __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IDebugPropertyEnumType_Locals __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *__MIDL_0016);
        
        END_INTERFACE
    } IDebugPropertyEnumType_LocalsVtbl;

    interface IDebugPropertyEnumType_Locals
    {
        CONST_VTBL struct IDebugPropertyEnumType_LocalsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugPropertyEnumType_Locals_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugPropertyEnumType_Locals_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugPropertyEnumType_Locals_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugPropertyEnumType_Locals_GetName(This,__MIDL_0016)	\
    (This)->lpVtbl -> GetName(This,__MIDL_0016)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugPropertyEnumType_Locals_INTERFACE_DEFINED__ */


#ifndef __IDebugPropertyEnumType_Arguments_INTERFACE_DEFINED__
#define __IDebugPropertyEnumType_Arguments_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDebugPropertyEnumType_Arguments
 * at Thu May 22 14:24:06 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IDebugPropertyEnumType_Arguments;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51973C57-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugPropertyEnumType_Arguments : public IDebugPropertyEnumType_All
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDebugPropertyEnumType_ArgumentsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugPropertyEnumType_Arguments __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugPropertyEnumType_Arguments __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugPropertyEnumType_Arguments __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IDebugPropertyEnumType_Arguments __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *__MIDL_0016);
        
        END_INTERFACE
    } IDebugPropertyEnumType_ArgumentsVtbl;

    interface IDebugPropertyEnumType_Arguments
    {
        CONST_VTBL struct IDebugPropertyEnumType_ArgumentsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugPropertyEnumType_Arguments_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugPropertyEnumType_Arguments_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugPropertyEnumType_Arguments_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugPropertyEnumType_Arguments_GetName(This,__MIDL_0016)	\
    (This)->lpVtbl -> GetName(This,__MIDL_0016)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugPropertyEnumType_Arguments_INTERFACE_DEFINED__ */


#ifndef __IDebugPropertyEnumType_LocalsPlusArgs_INTERFACE_DEFINED__
#define __IDebugPropertyEnumType_LocalsPlusArgs_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDebugPropertyEnumType_LocalsPlusArgs
 * at Thu May 22 14:24:06 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IDebugPropertyEnumType_LocalsPlusArgs;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51973C58-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugPropertyEnumType_LocalsPlusArgs : public IDebugPropertyEnumType_All
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDebugPropertyEnumType_LocalsPlusArgsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugPropertyEnumType_LocalsPlusArgs __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugPropertyEnumType_LocalsPlusArgs __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugPropertyEnumType_LocalsPlusArgs __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IDebugPropertyEnumType_LocalsPlusArgs __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *__MIDL_0016);
        
        END_INTERFACE
    } IDebugPropertyEnumType_LocalsPlusArgsVtbl;

    interface IDebugPropertyEnumType_LocalsPlusArgs
    {
        CONST_VTBL struct IDebugPropertyEnumType_LocalsPlusArgsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugPropertyEnumType_LocalsPlusArgs_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugPropertyEnumType_LocalsPlusArgs_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugPropertyEnumType_LocalsPlusArgs_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugPropertyEnumType_LocalsPlusArgs_GetName(This,__MIDL_0016)	\
    (This)->lpVtbl -> GetName(This,__MIDL_0016)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugPropertyEnumType_LocalsPlusArgs_INTERFACE_DEFINED__ */


#ifndef __IDebugPropertyEnumType_Registers_INTERFACE_DEFINED__
#define __IDebugPropertyEnumType_Registers_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IDebugPropertyEnumType_Registers
 * at Thu May 22 14:24:06 1997
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IDebugPropertyEnumType_Registers;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("51973C59-CB0C-11d0-B5C9-00A0244A0E7A")
    IDebugPropertyEnumType_Registers : public IDebugPropertyEnumType_All
    {
    public:
    };
    
#else 	/* C style interface */

    typedef struct IDebugPropertyEnumType_RegistersVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IDebugPropertyEnumType_Registers __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IDebugPropertyEnumType_Registers __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IDebugPropertyEnumType_Registers __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetName )( 
            IDebugPropertyEnumType_Registers __RPC_FAR * This,
            /* [out] */ BSTR __RPC_FAR *__MIDL_0016);
        
        END_INTERFACE
    } IDebugPropertyEnumType_RegistersVtbl;

    interface IDebugPropertyEnumType_Registers
    {
        CONST_VTBL struct IDebugPropertyEnumType_RegistersVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDebugPropertyEnumType_Registers_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDebugPropertyEnumType_Registers_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDebugPropertyEnumType_Registers_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDebugPropertyEnumType_Registers_GetName(This,__MIDL_0016)	\
    (This)->lpVtbl -> GetName(This,__MIDL_0016)


#endif /* COBJMACROS */


#endif 	/* C style interface */




#endif 	/* __IDebugPropertyEnumType_Registers_INTERFACE_DEFINED__ */


/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* [local] */ HRESULT STDMETHODCALLTYPE IDebugProperty_GetPropertyInfo_Proxy( 
    IDebugProperty __RPC_FAR * This,
    /* [in] */ DWORD dwFieldSpec,
    /* [in] */ UINT nRadix,
    /* [out] */ DebugPropertyInfo __RPC_FAR *pPropertyInfo);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDebugProperty_GetPropertyInfo_Stub( 
    IDebugProperty __RPC_FAR * This,
    /* [in] */ DWORD dwFieldSpec,
    /* [in] */ UINT nRadix,
    /* [out] */ DWORD __RPC_FAR *dwValidFields,
    /* [out] */ BSTR __RPC_FAR *pbstrName,
    /* [out] */ BSTR __RPC_FAR *pbstrType,
    /* [out] */ BSTR __RPC_FAR *pbstrValue,
    /* [out] */ BSTR __RPC_FAR *pbstrFullName,
    /* [out] */ DWORD __RPC_FAR *pdwAttrib,
    /* [unique][out][in] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppDebugProperty);

/* [local] */ HRESULT STDMETHODCALLTYPE IEnumDebugPropertyInfo_Next_Proxy( 
    IEnumDebugPropertyInfo __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [out] */ DebugPropertyInfo __RPC_FAR *pi,
    /* [out] */ ULONG __RPC_FAR *pcEltsfetched);


/* [call_as] */ HRESULT STDMETHODCALLTYPE IEnumDebugPropertyInfo_Next_Stub( 
    IEnumDebugPropertyInfo __RPC_FAR * This,
    /* [out] */ DWORD __RPC_FAR *dwValidFields,
    /* [out] */ BSTR __RPC_FAR *pbstrName,
    /* [out] */ BSTR __RPC_FAR *pbstrType,
    /* [out] */ BSTR __RPC_FAR *pbstrValue,
    /* [out] */ BSTR __RPC_FAR *pbstrFullName,
    /* [out] */ DWORD __RPC_FAR *pdwAttrib,
    /* [unique][out][in] */ IDebugProperty __RPC_FAR *__RPC_FAR *ppDebugProperty);



/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\debug.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Debug tools

File: debug.cpp

This file contains the routines for helping with debugging.
===================================================================*/
#include "denpre.h"
#pragma hdrstop


void _ASSERT_IMPERSONATING(void)
	{
	HANDLE _token;
	DWORD _err;																														
	if( OpenThreadToken( GetCurrentThread(), TOKEN_ALL_ACCESS, TRUE, &_token) ) 
		CloseHandle( _token );												
	else																	
		{																	
		_err = GetLastError();												
		ASSERT( _err != ERROR_NO_TOKEN );									
		}																	
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\dbllink.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Hash table for Script Manager

File: DblList.h

Owner: DGottner

extremly simple, yet very flexible, linked list manager
===================================================================*/

#ifndef DBLLINK_H
#define DBLLINK_H

#ifdef LINKTEST
#define _DEBUG
#include <assert.h>
#define Assert assert

#else
#include "debug.h"
#endif


/* C D b l L i n k
 *
 * This structure contains a set of links suitable for a doubly linked list
 * implementation.  Here we actually use it as a circularly linked list -
 * the links are extracted into this file because the list headers are also
 * of this type.
 */

class CDblLink
	{
public:
	CDblLink();
	virtual ~CDblLink();

	// manipulators
	/////
	void UnLink();
	void AppendTo(CDblLink &);
	void PrependTo(CDblLink &);

	// accessors
	/////
	CDblLink *PNext() const;
	CDblLink *PPrev() const;

	// testers
	/////
	bool FIsEmpty() const;
	void AssertValid() const
		{
		#ifdef _DEBUG
			Assert (this == m_pLinkPrev->m_pLinkNext && this == m_pLinkNext->m_pLinkPrev);
		#endif
		}

private:
	CDblLink *m_pLinkNext, *m_pLinkPrev;
	};

inline CDblLink::CDblLink()	 { m_pLinkNext = m_pLinkPrev = this; }
inline CDblLink::~CDblLink() { UnLink(); }

inline bool CDblLink::FIsEmpty() const { return this == m_pLinkNext; }
inline CDblLink *CDblLink::PNext() const { return m_pLinkNext; }
inline CDblLink *CDblLink::PPrev() const { return m_pLinkPrev; }

#endif // DBLLINK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\dbgcxt.h ===
/*==============================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

File:			dbgcxt.h
Maintained by:	DGottner
Component:		include file for IDebugDocumentContext
==============================================================================*/

#ifndef _DBGCXT_H
#define _DBGCXT_H

#include "activdbg.h"

/*	These GUIDs exist to enable the document to determine if an arbitrary
	IDebugDocumentContext object belongs to its document class.  QueryInterface
	for this GUID causes the IDebugDocument object to return a pointer to
	the CDocumentContext (or CIncFileContext) class.
*/
extern const GUID IID_IDenaliTemplateDocumentContext;
extern const GUID IID_IDenaliIncFileDocumentContext;


/*	============================================================================
	Class:		CTemplateDocumentContext
	Synopsis:	implementation of IDebugDocumentContext for CTemplate objects
*/
class CTemplateDocumentContext : public IDebugDocumentContext
	{
friend class CTemplate;		// CTemplate is only user who even cares about this stuff

public:
	// IUnknown methods

	virtual HRESULT STDMETHODCALLTYPE QueryInterface(const GUID &guid, void **ppvObj);
	virtual ULONG STDMETHODCALLTYPE AddRef();
	virtual ULONG STDMETHODCALLTYPE Release();

	// IDebugDocumentContext methods

	virtual HRESULT STDMETHODCALLTYPE GetDocument(
		/* [out] */ IDebugDocument **ppDebugDocument);
 
	virtual HRESULT STDMETHODCALLTYPE EnumCodeContexts(
		/* [out] */ IEnumDebugCodeContexts **ppEnum);
        
	// Constructor & destructor

	CTemplateDocumentContext(
					CTemplate *pTemplate,
					ULONG cchSourceOffset,
					ULONG cchText,
					IActiveScriptDebug *pDebugScript = NULL,	// cached values
					ULONG idEngine = -1,						// only initialize ctor if
					ULONG cchTargetOffset = -1					// values happen to be on hand
					);


	~CTemplateDocumentContext();

private:
	IActiveScriptDebug *m_pDebugScript;		// pointer to script engine
	CTemplate *			m_pTemplate;		// pointer to source document
	ULONG				m_idEngine;			// Engine # in template
	ULONG				m_cchSourceOffset;	// character offset in source
	ULONG				m_cchTargetOffset;	// character offset in target (cached)
	ULONG				m_cchText;			// # of characters in the context
	LONG				m_cRefs;			// reference count
	};


/*	============================================================================
	Class:		CIncFileDocumentContext
	Synopsis:	implementation of IDebugDocumentContext for CIncFile objects
*/
class CIncFileDocumentContext : public IDebugDocumentContext
	{
friend class CIncFile;						// CIncFile is only user who even cares about this stuff
friend class CIncFileEnumCodeContexts;		// iterator class

public:
	// IUnknown methods

	virtual HRESULT STDMETHODCALLTYPE QueryInterface(const GUID &guid, void **ppvObj);
	virtual ULONG STDMETHODCALLTYPE AddRef();
	virtual ULONG STDMETHODCALLTYPE Release();

	// IDebugDocumentContext methods

	virtual HRESULT STDMETHODCALLTYPE GetDocument(
		/* [out] */ IDebugDocument **ppDebugDocument);
 
	virtual HRESULT STDMETHODCALLTYPE EnumCodeContexts(
		/* [out] */ IEnumDebugCodeContexts **ppEnum);
        
	// Constructor & destructor

	CIncFileDocumentContext(
					CIncFile *pIncFile,
					ULONG cchSourceOffset,
					ULONG cchText
					);


	~CIncFileDocumentContext();

private:
	CIncFile *			m_pIncFile;			// pointer to source document
	ULONG				m_cchSourceOffset;	// character offset in source
	ULONG				m_cchText;			// # of characters in the context
	LONG				m_cRefs;			// reference count
	};

#endif /* _DBGCXT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\dbllink.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Hash tables with LRU threading 

File: DblLink.cpp

Owner: DGottner

simple, effective linked list manager
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "DblLink.h"
#include "memchk.h"


/*------------------------------------------------------------------
 * C D b l L i n k
 */

/*===================================================================
CDblLink::UnLink

Unlink this element from the list that it currently resides on
===================================================================*/

void CDblLink::UnLink()
	{
	m_pLinkPrev->m_pLinkNext = m_pLinkNext;
	m_pLinkNext->m_pLinkPrev = m_pLinkPrev;

	// Paranoia:
	//       reset the node to empty after the unlink
	//
	m_pLinkPrev = m_pLinkNext = this;
	}



/*===================================================================
CDblLink::AppendTo

Append this link onto a list

Parameters: pListHead - pointer to a the list header (itself
						a CDblLink) to append this item onto.

Condition: the link must be UnLink'ed before this method is called
===================================================================*/

void CDblLink::AppendTo(CDblLink &ListHead)
	{
	UnLink();

	m_pLinkNext = &ListHead;		// remember termination is at list head
	m_pLinkPrev = ListHead.m_pLinkPrev;
	ListHead.m_pLinkPrev->m_pLinkNext = this;
	ListHead.m_pLinkPrev = this;
	}



/*===================================================================
CDblLink::Prepend

Prepend this link onto a list

Parameters: pListHead - pointer to a the list header (itself
						a CDblLink) to prepend this item onto.

Condition: the link must be UnLink'ed before this method is called
===================================================================*/

void CDblLink::PrependTo(CDblLink &ListHead)
	{
	UnLink();

	m_pLinkPrev = &ListHead;
	m_pLinkNext = ListHead.m_pLinkNext;
	ListHead.m_pLinkNext->m_pLinkPrev = this;
	ListHead.m_pLinkNext = this;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\debug.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Debug tools

File: debug.h

This file contains the header info for helping with debugging.
===================================================================*/
#include "dbgutil.h"

#define DEBUG_FCN				0x00000800L   // File Change Notification
#define DEBUG_TEMPLATE          0x00001000L
#define DEBUG_SCRIPT_DEBUGGER   0x00002000L
#define DEBUG_SCRIPT_ENGINE     0x00004000L

#define DEBUG_RESPONSE          0x00010000L
#define DEBUG_REQUEST           0x00020000L
#define DEBUG_SERVER            0x00040000L
#define DEBUG_APPLICATION       0x00080000L

#define DEBUG_SESSION           0x00100000L
#define DEBUG_MTS               0X00200000L
#define DEBUG_THREADGATE        0X00400000L

#undef Assert
#define Assert(exp)  DBG_ASSERT(exp)

#undef FImplies
#define FImplies(f1,f2) (!(f1)||(f2))

void _ASSERT_IMPERSONATING(void);

#define ASSERT_IMPERSONATING() _ASSERT_IMPERSONATING()

#if _IIS_6_0
#define DBGWARN     DBGPRINTF
#define DBGERROR    DBGPRINTF
#define DBGINFO     DBGPRINTF
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\denevent.c ===
/* Microsoft Developer Support
   Copyright (c) 1992, 1993 Microsoft Corporation */

/* This is the required stub entry point for the message-table DLL */
#include <windows.h>

BOOL WINAPI DllMain(HINSTANCE hDLL, DWORD dwReason, LPVOID lpReserved)
{
  return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\debugger.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: misc

File: util.cpp

Owner: DGottner

This file contains debugger utility functions
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "vector.h"
#include "debugger.h"
#include "iiscnfg.h"
#include "mdcommsg.h"   // for RETURNCODETOHRESULT macro
#include "memchk.h"
#include "vecimpl.h"

/* Win64: This struct is used to package data passed to the thread handler.
 *        (3 DWORDs are too small in 64 bit world.)
 */
struct DebugThreadCallArgs
	{
	DWORD					dwMethod;
	IDebugApplication *		pDebugAppln;
	void *					pvArg;

	DebugThreadCallArgs(DWORD dwMethod = 0, IDebugApplication *pDebugAppln = 0, void *pvArg = 0)
		{
		this->dwMethod = dwMethod;
		this->pDebugAppln = pDebugAppln;
		this->pvArg = pvArg;
		}
	};


// Published globals

IProcessDebugManager *  g_pPDM = NULL;              // instance of debugger for this process.
IDebugApplication *     g_pDebugApp = NULL;         // Root ASP application
IDebugApplicationNode * g_pDebugAppRoot = NULL;     // used to create hierarchy tree
CViperActivity        * g_pDebugActivity = NULL;    // Debugger's activity
DWORD                   g_dwDebugThreadId = 0;      // Thread ID of viper activity

// Globals for debugging

static DWORD    g_dwDenaliAppCookie;            // Cookie to use to remove app
static HANDLE   g_hPDMTermEvent;                // PDM terminate event
static vector<DebugThreadCallArgs> *g_prgThreadCallArgs;    // for new 64 bit interface.

// This hash structure & CS is used by GetServerDebugRoot()

struct CDebugNodeElem : CLinkElem
    {
    IDebugApplicationNode *m_pServerRoot;

    HRESULT Init(char *szKey, int cchKey)
        {
        char *szKeyAlloc = new char [cchKey + 1];
        if (!szKeyAlloc) return E_OUTOFMEMORY;
        return CLinkElem::Init(memcpy(szKeyAlloc, szKey, cchKey + 1), cchKey);
        }

    ~CDebugNodeElem()
        {
        if (m_pKey)
            delete m_pKey;
        }
    };

static CHashTable g_HashMDPath2DebugRoot;
static CRITICAL_SECTION g_csDebugLock;      // Lock for g_hashMDPath2DebugRoot


/*===================================================================
InvokeDebuggerWithThreadSwitch

Invoke Debugger (or Debugger UI) method from a correct thread
using IDebugThreadCall.

Parameters
    IDebugApplication *pDebugAppln      to get to debugger UI
    DWORD              iMethod          which method to call
    void              *Arg              call argument

Returns
    HRESULT
===================================================================*/

// GUIDs for debugger events

static const GUID DEBUGNOTIFY_ONPAGEBEGIN =
            { 0xfd6806c0, 0xdb89, 0x11d0, { 0x8f, 0x81, 0x0, 0x80, 0xc7, 0x3d, 0x6d, 0x96 } };

static const GUID DEBUGNOTIFY_ONPAGEEND =
            { 0xfd6806c1, 0xdb89, 0x11d0, { 0x8f, 0x81, 0x0, 0x80, 0xc7, 0x3d, 0x6d, 0x96 } };

static const GUID DEBUGNOTIFY_ON_REFRESH_BREAKPOINT =
            { 0xffcf4b38, 0xfa12, 0x11d0, { 0x8f, 0x3b, 0x0, 0xc0, 0x4f, 0xc3, 0x4d, 0xcc } };

// Local class that implements IDebugCallback
class CDebugThreadDebuggerCall : public IDebugThreadCall
    {
public:
    STDMETHODIMP         QueryInterface(const GUID &, void **);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    STDMETHODIMP ThreadCallHandler(DWORD_PTR, DWORD_PTR, DWORD_PTR);
    };

HRESULT CDebugThreadDebuggerCall::QueryInterface
(
const GUID &iid,
void **ppv
)
    {
    if (iid == IID_IUnknown || iid == IID_IDebugThreadCall)
        {
        *ppv = this;
        return S_OK;
        }
    else
        {
        *ppv = NULL;
        return E_NOINTERFACE;
        }
    }

ULONG CDebugThreadDebuggerCall::AddRef()
    {
    return 1;
    }

ULONG CDebugThreadDebuggerCall::Release()
    {
    return 1;
    }

HRESULT CDebugThreadDebuggerCall::ThreadCallHandler
(
DWORD_PTR iArg,
DWORD_PTR ,
DWORD_PTR
)
    {
	// Get arguments
	DebugThreadCallArgs *pThreadCallArgs = &(*g_prgThreadCallArgs)[(int)iArg];
    IDebugApplication *  pDebugAppln     = pThreadCallArgs->pDebugAppln;
    DWORD                dwMethod        = pThreadCallArgs->dwMethod;
    void *               pvArg           = pThreadCallArgs->pvArg;

	// we won't reference the argument block again, so free it up now.
	pThreadCallArgs->dwMethod |= DEBUGGER_UNUSED_RECORD;

    BOOL fForceDebugger  = (dwMethod & (DEBUGGER_UI_BRING_DOCUMENT_TO_TOP|DEBUGGER_UI_BRING_DOC_CONTEXT_TO_TOP)) != 0;
    BOOL fNeedDebuggerUI = (dwMethod & (DEBUGGER_UI_BRING_DOCUMENT_TO_TOP|DEBUGGER_UI_BRING_DOC_CONTEXT_TO_TOP)) != 0;
    BOOL fNeedNodeEvents = (dwMethod & DEBUGGER_ON_REMOVE_CHILD) != 0;
    BOOL fNeedDebugger   = (dwMethod & ~DEBUGGER_ON_DESTROY) != 0;

    HRESULT hr = S_OK;

    IApplicationDebugger *pDebugger = NULL;
    IApplicationDebuggerUI *pDebuggerUI = NULL;
    IDebugApplicationNodeEvents *pNodeEvents = NULL;

    if (pDebugAppln == NULL)
        return E_POINTER;

    // Get the debugger
    if (fNeedDebugger)
        {
        hr = pDebugAppln->GetDebugger(&pDebugger);

        if (FAILED(hr))
            {
            // Debugger is not currently debugging our application.
            if (!fForceDebugger)
                return E_FAIL; // no debugger

            // Start the debugger and try again.
            hr = pDebugAppln->StartDebugSession();

            if (SUCCEEDED(hr))
                hr = pDebugAppln->GetDebugger(&pDebugger);
            }

        // Debugger UI is needed only for some methods
        if (SUCCEEDED(hr) && fNeedDebuggerUI)
            {
            hr = pDebugger->QueryInterface
                (
                IID_IApplicationDebuggerUI,
                reinterpret_cast<void **>(&pDebuggerUI)
                );
            }

        // Debugger UI is needed only for some methods
        if (SUCCEEDED(hr) && fNeedNodeEvents)
            {
            hr = pDebugger->QueryInterface
                (
                IID_IDebugApplicationNodeEvents,
                reinterpret_cast<void **>(&pNodeEvents)
                );
            }
        }

    // Call the desired method
    if (SUCCEEDED(hr))
        {
        switch (dwMethod)
            {
            case DEBUGGER_EVENT_ON_PAGEBEGIN:
                {
                hr = pDebugger->onDebuggerEvent
                    (
                    DEBUGNOTIFY_ONPAGEBEGIN,
                    static_cast<IUnknown *>(pvArg)
                    );
                break;
                }
            case DEBUGGER_EVENT_ON_PAGEEND:
                {
                hr = pDebugger->onDebuggerEvent
                    (
                    DEBUGNOTIFY_ONPAGEEND,
                    static_cast<IUnknown *>(pvArg)
                    );
                break;
                }
            case DEBUGGER_EVENT_ON_REFRESH_BREAKPOINT:
                {
                hr = pDebugger->onDebuggerEvent
                    (
                    DEBUGNOTIFY_ON_REFRESH_BREAKPOINT,
                    static_cast<IUnknown *>(pvArg)
                    );
                break;
                }
            case DEBUGGER_ON_REMOVE_CHILD:
                {
                hr = pNodeEvents->onRemoveChild
                    (
                    static_cast<IDebugApplicationNode *>(pvArg)
                    );
                break;
                }
            case DEBUGGER_ON_DESTROY:
                {
                hr = static_cast<IDebugDocumentTextEvents *>(pvArg)->onDestroy();
                break;
                }
            case DEBUGGER_UI_BRING_DOCUMENT_TO_TOP:
                {
                hr = pDebuggerUI->BringDocumentToTop
                    (
                    static_cast<IDebugDocumentText *>(pvArg)
                    );
                break;
                }
            case DEBUGGER_UI_BRING_DOC_CONTEXT_TO_TOP:
                {
                hr = pDebuggerUI->BringDocumentContextToTop
                    (
                    static_cast<IDebugDocumentContext *>(pvArg)
                    );
                break;
                }
            default:
                hr = E_FAIL;
                break;
            }
        }

    // Cleanup
    if (pDebuggerUI) pDebuggerUI->Release();
    if (pNodeEvents) pNodeEvents->Release();
    if (pDebugger) pDebugger->Release();

    return hr;
    }

// The function calls using IDebugThreadCall
HRESULT InvokeDebuggerWithThreadSwitch
(
IDebugApplication *pDebugAppln,
DWORD              dwMethod,
void              *pvArg
)
    {
	// take these arguments and package them up in the array.  We will pass the
	// index to the callback handler.
	//
	// first look for a freed up element before creating a new one.

	for (int i = g_prgThreadCallArgs->length() - 1; i >= 0; --i)
		{
		DebugThreadCallArgs *pThreadCallArgs = &(*g_prgThreadCallArgs)[i];
		if (pThreadCallArgs->dwMethod & DEBUGGER_UNUSED_RECORD)
			{
			pThreadCallArgs->dwMethod    = dwMethod;
			pThreadCallArgs->pDebugAppln = pDebugAppln;
			pThreadCallArgs->pvArg       = pvArg;
			break;
			}
		}
	
	if (i < 0)
		{
		HRESULT hr = g_prgThreadCallArgs->append(DebugThreadCallArgs(dwMethod, pDebugAppln, pvArg));
		if (FAILED(hr))
			return hr;

		i = g_prgThreadCallArgs->length() - 1;
		}

    CDebugThreadDebuggerCall Call;
    return pDebugAppln->SynchronousCallInDebuggerThread
        (
        &Call, i, 0, 0
        );
    }


/*===================================================================
FCaesars

Query registry to determine if default debugger is Caesar's
(Script Debugger)
===================================================================*/

BOOL FCaesars()
	{
	static BOOL fCaesars = 0xBADF00D;
	HKEY  hKey = NULL;
	char  szRegPath[_MAX_PATH];
	DWORD dwSize = sizeof szRegPath;

	// Check to see if Ceasers is registered as the JIT debugger on this machine.

	if (fCaesars == 0xBADF00D)
		{
		fCaesars = FALSE;
		if (RegOpenKey(HKEY_CLASSES_ROOT, _T("CLSID\\{834128A2-51F4-11D0-8F20-00805F2CD064}\\LocalServer32"), &hKey) == ERROR_SUCCESS)
			{
			if (RegQueryValueEx(hKey, NULL, NULL, NULL, (LPBYTE) szRegPath, &dwSize) == ERROR_SUCCESS)
				{
				char szFile[_MAX_FNAME];
				_splitpath(szRegPath, NULL, NULL, szFile, NULL);
				if (_stricmp(szFile, "msscrdbg") == 0)
					fCaesars = TRUE;
				}

			CloseHandle (hKey);
			}
		}

	return fCaesars;
	}


/*===================================================================
DestroyDocumentTree

Recursively release all the nodes in a document tree.

Parameters
    IDebugApplication *pDocRoot         root of hierarchy to destroy
===================================================================*/
void
DestroyDocumentTree(IDebugApplicationNode *pDocRoot)
    {
    IEnumDebugApplicationNodes *pEnum;

    if (SUCCEEDED(pDocRoot->EnumChildren(&pEnum)) && pEnum != NULL)
        {
        IDebugApplicationNode *pDocNode;
        while (pEnum->Next(1, &pDocNode, NULL) == S_OK)
            DestroyDocumentTree(pDocNode);

        pEnum->Release();
        }

    // See if this is a directory node
    //
    IFileNode *pFileNode;
    if (SUCCEEDED(pDocRoot->QueryInterface(IID_IFileNode, reinterpret_cast<void **>(&pFileNode))))
        {
        // This is a directory node, only detach when its document count vanishes)
        if (pFileNode->DecrementDocumentCount() == 0)
            {
            pDocRoot->Detach();
            pDocRoot->Close();
            pDocRoot->Release();
            }

        pFileNode->Release();
        }
    else
        {
        // This node is a CTemplate (or one of its include files)
        pDocRoot->Detach();
        pDocRoot->Close();
        pDocRoot->Release();
        }

    }

/*===================================================================
CreateDocumentTree

Takes a path to be rooted at a node "pDocRoot", parses the path,
and creates a node for each component of the path. Returns the
leaf (Since the root is known) as its value.

This function is called from contexts where part of the document
tree may already exist, so EnumChildren is called and nodes are only
created when a child does not exist. When a node exists, we merely
descend into the tree.

NOTE:
    The intermediate nodes are created with a CFileNode document
    implementation.  The leaf node is not given a document provider
    - the caller must provide one.

Parameters
    wchar_t *          szDocPath    path of the document
    IDebugApplication *pDocParent   parent to attach the application tree to
    IDebugApplication **ppDocRoot   returns root of document hierarchy
    IDebugApplication **ppDocLeaf   returns document leaf node.
    wchar_t **        pwszLeaf      name of the leaf node

Returns
    HRESULT
===================================================================*/
HRESULT CreateDocumentTree
(
wchar_t *wszDocPath,
IDebugApplicationNode *pDocParent,
IDebugApplicationNode **ppDocRoot,
IDebugApplicationNode **ppDocLeaf,
wchar_t **pwszLeaf
)
    {
    HRESULT hr;
    BOOL fCreateOnly = FALSE;   // Set to TRUE when there is no need to check for duplicate node
    *ppDocRoot = *ppDocLeaf = NULL;

    // Ignore initial delimiters
    while (wszDocPath[0] == '/')
        ++wszDocPath;

    // Now loop over every component in the path, adding a node for each
    while (wszDocPath != NULL)
        {
        // Get next path component
        *pwszLeaf = wszDocPath;
        wszDocPath = wcschr(wszDocPath, L'/');
        if (wszDocPath)
            *wszDocPath++ = L'\0';

        // Check to see if this component is already a child or not
        BOOL fNodeExists = FALSE;
        if (!fCreateOnly)
            {
            IEnumDebugApplicationNodes *pEnum;
            if (SUCCEEDED(pDocParent->EnumChildren(&pEnum)) && pEnum != NULL)
                {
                IDebugApplicationNode *pDocChild;
                while (!fNodeExists && pEnum->Next(1, &pDocChild, NULL) == S_OK)
                    {
                    BSTR bstrName = NULL;
                    if (FAILED(hr = pDocChild->GetName(DOCUMENTNAMETYPE_APPNODE, &bstrName)))
                        return hr;

                    if (wcscmp(bstrName, *pwszLeaf) == 0)
                        {
                        // The name of this node is equal to the component.  Instead of
                        // creating a new node, descend into the tree.
                        //
                        fNodeExists = TRUE;
                        *ppDocLeaf = pDocChild;

                        // If '*ppDocRoot' hasn't been assigned to yet, this means that
                        // this is the first node found (and hence the root of the tree)
                        //
                        if (*ppDocRoot == NULL)
                            {
                            *ppDocRoot = pDocChild;
                            (*ppDocRoot)->AddRef();
                            }

                        // If this node is a CFileNode structure (we don't require it to be)
                        // then increment its (recursive) containing document count.
                        //
                        IFileNode *pFileNode;
                        if (SUCCEEDED(pDocChild->QueryInterface(IID_IFileNode, reinterpret_cast<void **>(&pFileNode))))
                            {
                            pFileNode->IncrementDocumentCount();
                            pFileNode->Release();
                            }
                        }

                    SysFreeString(bstrName);
                    pDocChild->Release();
                    }

                pEnum->Release();
                }
            }

        // Create a new node if the node was not found above.  Also, at this point,
        // to save time, we always set "fCreateOnly" to TRUE because if we are
        // forced to create a node at this level, we will need to create nodes at
        // all other levels further down
        //
        if (!fNodeExists)
            {
            fCreateOnly = TRUE;

            // Create the node
            if (FAILED(hr = g_pDebugApp->CreateApplicationNode(ppDocLeaf)))
                return hr;

            // Create a doc provider for the node - for intermediate nodes only
            if (wszDocPath != NULL) // intermediate node
                {
                CFileNode *pFileNode = new CFileNode;
                if (pFileNode == NULL ||
                    FAILED(hr = pFileNode->Init(*pwszLeaf)) ||
                    FAILED(hr = (*ppDocLeaf)->SetDocumentProvider(pFileNode)))
                    {
                    (*ppDocLeaf)->Release();
                    return E_OUTOFMEMORY;
                    }

                // New node, only one document (count started at 0, so this will set to 1)
                pFileNode->IncrementDocumentCount();

                // SetDocumentProvider() AddRef'ed
                pFileNode->Release();
                }

                // If '*ppDocRoot' hasn't been assigned to yet, this means that
                // this is the first node created (and hence the root of the tree)
                //
                if (*ppDocRoot == NULL)
                    {
                    *ppDocRoot = *ppDocLeaf;
                    (*ppDocRoot)->AddRef();
                    }

            // Attach the node
            if (FAILED(hr = (*ppDocLeaf)->Attach(pDocParent)))
                return hr;
            }

        // Descend
        pDocParent = *ppDocLeaf;
        }

    if (*ppDocLeaf)
        (*ppDocLeaf)->AddRef();

    return S_OK;
    }

/*===================================================================
Debugger

The purpose of this thread is to create an execution environment for
the Process Debug Manager (PDM). There is only one PDM per process,
and this does not really fit in other threads, so we dedicate a thread to this.

Parameters:
    LPVOID  params
                Points to a BOOL* which will be set to 1 when
                this thread is completely initialized.

Returns:
    0
===================================================================*/
void __cdecl Debugger(void *pvInit)
    {
    HRESULT hr;

    if (FAILED(hr = CoInitializeEx(NULL, COINIT_MULTITHREADED)))
        {
        // Bug 87857: if we get E_INVALIDARG, we need to do a CoUninitialize
        if (hr == E_INVALIDARG)
            CoUninitialize();

        *static_cast<BOOL *>(pvInit) = TRUE;
        return;
        }

    if (FAILED(CoCreateInstance(
                    CLSID_ProcessDebugManager,
                    NULL,
                    CLSCTX_INPROC_SERVER,
                    IID_IProcessDebugManager,
                    reinterpret_cast<void **>(&g_pPDM))))

        {
        *static_cast<BOOL *>(pvInit) = TRUE;
        CoUninitialize();
        return;
        }

    *static_cast<BOOL *>(pvInit) = TRUE;
    while (TRUE)
        {
        DWORD dwRet = MsgWaitForMultipleObjects(1,
                                                &g_hPDMTermEvent,
                                                FALSE,
                                                INFINITE,
                                                QS_ALLINPUT);

        if (dwRet == WAIT_OBJECT_0)
            break;

        MSG msg;
        while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
            DispatchMessage(&msg);
        }

    g_pPDM->Release();
    CoUninitialize();

    g_pPDM = NULL; // indication that the thread is gone
    }

/*===================================================================
HRESULT StartPDM()

kick off the PDM thread
===================================================================*/

HRESULT StartPDM()
    {
    BOOL fStarted = FALSE;

    g_hPDMTermEvent = IIS_CREATE_EVENT(
                          "g_hPDMTermEvent",
                          &g_hPDMTermEvent,
                          TRUE,
                          FALSE
                          );

    if( g_hPDMTermEvent == NULL )
        return E_FAIL;

    _beginthread(Debugger, 0, &fStarted);
    while (!fStarted)
        Sleep(100);

    if (g_pPDM == NULL)     // could not create the PDM for some reason
        {
        CloseHandle(g_hPDMTermEvent);
        g_hPDMTermEvent = NULL;
        return E_FAIL;
        }

    return S_OK;
    }

/*===================================================================
HRESULT InitDebugging

Initialize everything we need for debugging

===================================================================*/
HRESULT InitDebugging
(
CIsapiReqInfo *pIReq
)
    {
    HRESULT hr;

    // Start the PDM
    if (FAILED(hr = StartPDM()))
        return hr;

    Assert (g_pPDM);    // StartPDM succeeds ==> g_pPDM <> NULL

    ErrInitCriticalSection(&g_csDebugLock, hr);
    if (FAILED(hr))
        return hr;

    // Create the debug application & give it a name
    if (FAILED(hr = g_pPDM->CreateApplication(&g_pDebugApp)))
        goto LErrorCleanup;

    // WinSE 23918: tripple buffer size for friendly app names 
    wchar_t wszDebugAppName[180];

    wcscpy(wszDebugAppName, L"Microsoft Active Server Pages");   // DO NOT LOCALIZE THIS STRING

    if (g_fOOP) {

        // Bug 154300: If a friendly app. name exists, use it along with the PID for
        //             WAM identification.
        // WinSE 23918: avoid buffer overrun. use (..., pid) when friendly app name
        //             is too long (about 120 chars or more). use(?, pid) when
        //             failed to read friendly name. use (-, pid) when szAppMDPath
        //             is empty. We may also return (, pid) when the app name
        //             is set to empty string.
        //
        // Declare some temporaries
        //
        DWORD dwApplMDPathLen;
        DWORD dwRequiredBuffer = 0;
        DWORD cchPrefix = wcslen(wszDebugAppName);
        wchar_t *pFriendlyAppName = wszDebugAppName + cchPrefix;

       	*pFriendlyAppName++ = ' ';
       	*pFriendlyAppName++ = '(';
    
        TCHAR *szApplMDPath = pIReq->QueryPszApplnMDPath();

        // get friendly name from metabase
        hr = pIReq->GetAspMDData(
                        szApplMDPath,
                        MD_APP_FRIENDLY_NAME,
                        METADATA_INHERIT,
                        ASP_MD_UT_APP,
                        STRING_METADATA,
                        sizeof(wszDebugAppName) - (cchPrefix+20)*sizeof(wchar_t),
                        0,
                        (BYTE*)pFriendlyAppName,
                        &dwRequiredBuffer);

        if (hr == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER))
        {
            wcscpy(pFriendlyAppName, L"...");   // friendly app name too long
        }
        else if (FAILED(hr))
        {
            wcscpy(pFriendlyAppName, L"?");    // can't read friendly app name
        }
            
        pFriendlyAppName += wcslen(pFriendlyAppName);

        // append process id
        *pFriendlyAppName++ = ',';
        *pFriendlyAppName++ = ' ';
        _itow(GetCurrentProcessId(), pFriendlyAppName, 10);

        wcscat(pFriendlyAppName, L")");
    }

    if (FAILED(hr = g_pDebugApp->SetName(wszDebugAppName)))
        goto LErrorCleanup;

    if (FAILED(hr = g_pPDM->AddApplication(g_pDebugApp, &g_dwDenaliAppCookie)))
        goto LErrorCleanup;

    if (FAILED(hr = g_pDebugApp->GetRootNode(&g_pDebugAppRoot)))
        goto LErrorCleanup;

    // Init the hash table used for Keeping track of virtual server roots
    if (FAILED(hr = g_HashMDPath2DebugRoot.Init()))
        goto LErrorCleanup;

	// Create the array for passing data to debug thread
	if ((g_prgThreadCallArgs = new vector<DebugThreadCallArgs>) == NULL) {
		hr = E_OUTOFMEMORY;
		goto LErrorCleanup;
    }

    return S_OK;

LErrorCleanup:
    // Clean up some globals (some thing may be NULL and some not)
    if (g_pDebugAppRoot) {
        g_pDebugAppRoot->Release();
        g_pDebugAppRoot = NULL;
    }

    if (g_pDebugApp) {
        g_pDebugApp->Release();
        g_pDebugApp = NULL;
    }

    // Kill PDM thread if we started it up.
    if (g_pPDM) {
        SetEvent(g_hPDMTermEvent);

        while (g_pPDM)
            Sleep(100);

        CloseHandle(g_hPDMTermEvent);
        g_pPDM = NULL;
    }

    return hr;
}

/*===================================================================
UnInitDebugging

Uninitialize debugging

NOTE: WE DO NOT RELEASE THE VIPER DEBUG ACTIVITY.
      (EVEN THOUGH INIT CREATES IT)

      THIS IS BECAUSE UNINIT MUST BE INVOKED WHILE SCRIPTS ON THE
      ACTIVITY ARE STILL RUNNING!
===================================================================*/
HRESULT UnInitDebugging()
    {
    // Clear and UnInit the hash tables (containing the application nodes)
    CDebugNodeElem *pNukeDebugNode = static_cast<CDebugNodeElem *>(g_HashMDPath2DebugRoot.Head());
    while (pNukeDebugNode != NULL)
        {
        CDebugNodeElem *pNext = static_cast<CDebugNodeElem *>(pNukeDebugNode->m_pNext);
        pNukeDebugNode->m_pServerRoot->Detach();
        pNukeDebugNode->m_pServerRoot->Close();
        pNukeDebugNode->m_pServerRoot->Release();
        delete pNukeDebugNode;
        pNukeDebugNode = pNext;
        }
    g_HashMDPath2DebugRoot.UnInit();

    DeleteCriticalSection(&g_csDebugLock);

    // Unlink the top node
    if (g_pDebugAppRoot)
        {
        g_pDebugAppRoot->Detach();
        g_pDebugAppRoot->Close();
        g_pDebugAppRoot->Release();
        }

    // Delete the application
    if (g_pDebugApp)
        {
        Assert (g_pPDM != NULL);

        // EXPLICITLY ignore failure result here:
        //     if Init() failed earlier, then RemoveApplication will fail here.
        g_pPDM->RemoveApplication(g_dwDenaliAppCookie);
        g_pDebugApp->Close();
        g_pDebugApp->Release();
        g_pDebugApp = NULL;
        }

    // Tell the PDM to suicide
    if (g_pPDM)
        {
        SetEvent(g_hPDMTermEvent);

        while (g_pPDM)
            Sleep(100);

        CloseHandle(g_hPDMTermEvent);
        }

	// delete the argument buffer
	delete g_prgThreadCallArgs;

    return S_OK;
    }

/*===================================================================
GetServerDebugRoot

Each virtual server has its own root in the application tree.

    (i.e. the tree looks like
            Microsoft ASP
                <Virtual Server 1 Name>
                    <Denali Application Name>
                        <Files>
                <Virtual Server 2 Name>
                    <Denali Application>
                        ...

Since there may be multiple applications per each server, the
server nodes are managed at one central location (here) so that
new applications get added to the correct nodes.
===================================================================*/
HRESULT GetServerDebugRoot
(
CIsapiReqInfo   *pIReq,
IDebugApplicationNode **ppDebugRoot
)
    {
    HRESULT hr = E_FAIL;

    STACK_BUFFER( tempMDData, 2048 );
    *ppDebugRoot = NULL;

    // Get the metabase path for this virtual server from the CIsapiReqInfo
    DWORD dwInstanceMDPathLen;
    char *szInstanceMDPath;

    STACK_BUFFER( instPathBuf, 128 );

    if (!SERVER_GET(pIReq, "INSTANCE_META_PATH", &instPathBuf, &dwInstanceMDPathLen))
        return HRESULT_FROM_WIN32(GetLastError());

    szInstanceMDPath = (char *)instPathBuf.QueryPtr();

    // See if we already have a node for this path - If not then create it and add to hash table

    EnterCriticalSection(&g_csDebugLock);
    CDebugNodeElem *pDebugNode = static_cast<CDebugNodeElem *>(g_HashMDPath2DebugRoot.FindElem(szInstanceMDPath, dwInstanceMDPathLen - 1));

    if (!pDebugNode)
        {
        // Node does not exist, so create a new application node.
        pDebugNode = new CDebugNodeElem;
        if (pDebugNode == NULL)
            {
            hr = E_OUTOFMEMORY;
            goto LExit;
            }

        if (FAILED(hr = pDebugNode->Init(szInstanceMDPath, dwInstanceMDPathLen - 1)))
            goto LExit;

        // Look up server name in metabase.
        BYTE *prgbData = (BYTE *)tempMDData.QueryPtr();
        DWORD dwRequiredBuffer = 0;
        hr = pIReq->GetAspMDDataA(
                            szInstanceMDPath,
                            MD_SERVER_COMMENT,
                            METADATA_INHERIT,
                            IIS_MD_UT_SERVER,
                            STRING_METADATA,
                            tempMDData.QuerySize(),
                            0,
                            prgbData,
                            &dwRequiredBuffer);

        if (hr == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER)) {

            if (tempMDData.Resize(dwRequiredBuffer) == FALSE) {
                hr = E_OUTOFMEMORY;
            }
            else {
                prgbData = reinterpret_cast<BYTE *>(tempMDData.QueryPtr());
                hr = pIReq->GetAspMDDataA(
                                    szInstanceMDPath,
                                    MD_SERVER_COMMENT,
                                    METADATA_INHERIT,
                                    IIS_MD_UT_SERVER,
                                    STRING_METADATA,
                                    dwRequiredBuffer,
                                    0,
                                    prgbData,
                                    &dwRequiredBuffer);
            }
        }
        if (FAILED(hr))
            {
            // ServerComment does not exist, so construct using server name and port

            STACK_BUFFER( serverNameBuff, 16 );
            DWORD cbServerName;
            STACK_BUFFER( serverPortBuff, 10 );
            DWORD cbServerPort;
            STACK_BUFFER( debugNodeBuff, 30 );

            if (!SERVER_GET(pIReq, "LOCAL_ADDR", &serverNameBuff, &cbServerName)
                || !SERVER_GET(pIReq, "SERVER_PORT", &serverPortBuff, &cbServerPort)) {
                hr = E_FAIL;
                goto LExit;
            }

            char *szServerName = (char *)serverNameBuff.QueryPtr();
            char *szServerPort = (char*)serverPortBuff.QueryPtr();

            // resize the debugNodeBuff to hold <serverIP>:<port>'\0'.
            if (!debugNodeBuff.Resize(cbServerName + cbServerPort + 2)) {
                hr = E_OUTOFMEMORY;
                goto LExit;
            }
            // Syntax is <serverIP:port>
            char *szDebugNode = (char *)debugNodeBuff.QueryPtr();
            strcpyExA(strcpyExA(strcpyExA(szDebugNode, szServerName), ":"), szServerPort);

            // Convert to Wide Char
            hr = MultiByteToWideChar(CP_ACP, 0, szDebugNode, -1, reinterpret_cast<wchar_t *>(prgbData), tempMDData.QuerySize() / 2);
            if (FAILED(hr))
                goto LExit;
            }

        // We've got the metadata (ServerComment), create a debug node with this name
        IDebugApplicationNode *pServerRoot;
        if (FAILED(hr = g_pDebugApp->CreateApplicationNode(&pServerRoot)))
            goto LExit;

        // Create a doc provider for the node
        CFileNode *pFileNode = new CFileNode;
        if (pFileNode == NULL)
            {
            hr = E_OUTOFMEMORY;
            goto LExit;
            }

        if (FAILED(hr = pFileNode->Init(reinterpret_cast<wchar_t *>(prgbData))))
            goto LExit;

        if (FAILED(hr = pServerRoot->SetDocumentProvider(pFileNode)))
            goto LExit;

        // pFileNode has been AddRef'ed and we don't need it now.
        pFileNode->Release();

        // Attach to the UI
        if (FAILED(pServerRoot->Attach(g_pDebugAppRoot)))
            goto LExit;

        // OK, Now add this item to the hashtable (this eats the reference from creation)
        pDebugNode->m_pServerRoot = pServerRoot;
        g_HashMDPath2DebugRoot.AddElem(pDebugNode);
        }

    *ppDebugRoot = pDebugNode->m_pServerRoot;
    (*ppDebugRoot)->AddRef();
    hr = S_OK;

LExit:
    LeaveCriticalSection(&g_csDebugLock);
    return hr;
    }

/*===================================================================
  C  F i l e  N o d e

Implementation of CFileNode - trivial class
===================================================================*/

const GUID IID_IFileNode =
            { 0x41047bd2, 0xfe1e, 0x11d0, { 0x8f, 0x3f, 0x0, 0xc0, 0x4f, 0xc3, 0x4d, 0xcc } };

CFileNode::CFileNode() : m_cRefs(1), m_cDocuments(0), m_wszName(NULL) {}
CFileNode::~CFileNode() { delete[] m_wszName; }


HRESULT
CFileNode::Init(wchar_t *wszName)
    {
    if ((m_wszName = new wchar_t [wcslen(wszName) + 1]) == NULL)
        return E_OUTOFMEMORY;

    wcscpy(m_wszName, wszName);
    return S_OK;
    }


HRESULT
CFileNode::QueryInterface(const GUID &uidInterface, void **ppvObj)
    {
    if (uidInterface == IID_IUnknown ||
        uidInterface == IID_IDebugDocumentProvider ||
        uidInterface == IID_IFileNode)
        {
        *ppvObj = this;
        AddRef();
        return S_OK;
        }
    else
        return E_NOINTERFACE;
    }


ULONG
CFileNode::AddRef()
    {
    InterlockedIncrement(reinterpret_cast<long *>(&m_cRefs));
    return m_cRefs;
    }


ULONG
CFileNode::Release()
{
    if (InterlockedDecrement(reinterpret_cast<long *>(&m_cRefs)) == 0)
        {
        delete this;
        return 0;
        }

    return m_cRefs;
}


HRESULT
CFileNode::GetDocument(IDebugDocument **ppDebugDoc)
    {
    return QueryInterface(IID_IDebugDocument, reinterpret_cast<void **>(ppDebugDoc));
    }


HRESULT
CFileNode::GetName(DOCUMENTNAMETYPE, BSTR *pbstrName)
    {
    return ((*pbstrName = SysAllocString(m_wszName)) == NULL)? E_OUTOFMEMORY : S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\denali.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Hit Manager

File: Denali.h

Owner: PramodD

This is the Hit (Request) Manager header file.
===================================================================*/
#ifndef DENALI_H
#define DENALI_H

//#define	LOG_FCNOTIFICATIONS	// logs file change notifications to a file

#include "Hitobj.h"
#include "CacheMgr.h"
#include "Request.h"

extern BOOL g_fShutDownInProgress;

inline IsShutDownInProgress() 
    {
    return g_fShutDownInProgress;
    }

// de-comment the following line to build with no perfmon counters
//#define 	PERF_DISABLE

DWORD	HandleHit(CIsapiReqInfo     *pIReq);
//void	InitODBC( void );
//void	UnInitODBC( void );

extern BOOL g_fOOP;

/*  inlines to implement ISA per-thread bracketing in OOP case
*/

inline HRESULT StartISAThreadBracket(CIsapiReqInfo     *pIReq)
    {
    if (g_fOOP && pIReq)
        {
        HRESULT hr = pIReq->ISAThreadNotify(TRUE);
        if (FAILED(hr))
            return hr;
        }
    return S_OK;
    }

inline void EndISAThreadBracket(CIsapiReqInfo     *pIReq)
    {
    if (g_fOOP && pIReq)
        {
        pIReq->ISAThreadNotify(FALSE);
        }
    }

extern HINSTANCE g_hinstDLL;

/*	intrinsic object names (bug 164)
	NOTE to add an intrinsic object to denali, follow these steps:
	1. add both sz and wsz versions of the object name below
	2. add a check for the sz version of the object name in CTemplate::FValidObjectName
*/
#define 	CONCAT(a, b)				a ## b
#define 	WSZ(x)						CONCAT(L, x)

#define 	SZ_OBJ_APPLICATION			"Application"
#define 	SZ_OBJ_REQUEST				"Request"
#define 	SZ_OBJ_RESPONSE				"Response"
#define 	SZ_OBJ_SERVER				"Server"
#define 	SZ_OBJ_CERTIFICATE			"Certificate"
#define 	SZ_OBJ_SESSION				"Session"
#define 	SZ_OBJ_SCRIPTINGNAMESPACE 	"ScriptingNamespace"
#define 	SZ_OBJ_OBJECTCONTEXT		"ObjectContext"
#define     SZ_OBJ_ASPPAGETLB           "ASPPAGETLB"
#define     SZ_OBJ_ASPGLOBALTLB         "ASPGLOBALTLB"

#define 	WSZ_OBJ_APPLICATION			WSZ(SZ_OBJ_APPLICATION)
#define 	WSZ_OBJ_REQUEST				WSZ(SZ_OBJ_REQUEST)
#define 	WSZ_OBJ_RESPONSE			WSZ(SZ_OBJ_RESPONSE)
#define 	WSZ_OBJ_SERVER				WSZ(SZ_OBJ_SERVER)
#define 	WSZ_OBJ_CERTIFICATE			WSZ(SZ_OBJ_CERTIFICATE)
#define 	WSZ_OBJ_SESSION				WSZ(SZ_OBJ_SESSION)
#define 	WSZ_OBJ_SCRIPTINGNAMESPACE 	WSZ(SZ_OBJ_SCRIPTINGNAMESPACE)
#define 	WSZ_OBJ_OBJECTCONTEXT		WSZ(SZ_OBJ_OBJECTCONTEXT)
#define     WSZ_OBJ_ASPPAGETLB          WSZ(SZ_OBJ_ASPPAGETLB)
#define     WSZ_OBJ_ASPGLOBALTLB        WSZ(SZ_OBJ_ASPGLOBALTLB)

#define 	BSTR_OBJ_APPLICATION		g_bstrApplication
#define 	BSTR_OBJ_REQUEST			g_bstrRequest
#define 	BSTR_OBJ_RESPONSE			g_bstrResponse
#define 	BSTR_OBJ_SERVER				g_bstrServer
#define 	BSTR_OBJ_CERTIFICATE		g_bstrCertificate
#define 	BSTR_OBJ_SESSION			g_bstrSession
#define 	BSTR_OBJ_SCRIPTINGNAMESPACE g_bstrScriptingNamespace
#define 	BSTR_OBJ_OBJECTCONTEXT		g_bstrObjectContext

// Cached BSTRs
extern BSTR g_bstrApplication;
extern BSTR g_bstrRequest;
extern BSTR g_bstrResponse;
extern BSTR g_bstrServer;
extern BSTR g_bstrCertificate;
extern BSTR g_bstrSession;
extern BSTR g_bstrScriptingNamespace;
extern BSTR g_bstrObjectContext;

// Session ID Cookie 
// consist of 12 char literal constant and 8 hex process ID
#define     CCH_SESSION_ID_COOKIE           20
#define     CCH_SESSION_ID_COOKIE_PREFIX    12
#define		SZ_SESSION_ID_COOKIE_PREFIX     "ASPSESSIONID"

extern char g_szSessionIDCookieName[];

// CLIENT DEBUG (flag) Cookie
#define		SZ_CLIENT_DEBUG_COOKIE	"ASPCLIENTDEBUG"

// Dll name
#define		ASP_DLL_NAME				"ASP.DLL"

// Max # of bytes we will allocate before we assume an attack by a malicious browser
#define		REQUEST_ALLOC_MAX  (100 * 1024)

#define     SZ_GLOBAL_ASA       _T("GLOBAL.ASA")
#define     CCH_GLOBAL_ASA      10

/*
 * InitializeCriticalSection can throw.  Use this macro instead
 */
#define ErrInitCriticalSection( cs, hr ) \
		do { \
		hr = S_OK; \
		__try \
			{ \
			INITIALIZE_CRITICAL_SECTION(cs); \
			} \
		__except(1) \
			{ \
			hr = E_UNEXPECTED; \
			} \
		} while (0)

#ifdef LOG_FCNOTIFICATIONS
void LfcnCreateLogFile();
void LfcnCopyAdvance(char** ppchDest, const char* sz);
void LfcnAppendLog(const char* sz);
void LfcnLogNotification(char* szFile);
void LfcnLogHandleCreation(int i, char* szApp);
void LfcnUnmapLogFile();
#endif	//LOG_FCNOTIFICATIONS

#endif // DENALI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\denpre.cpp ===
#include "denpre.h"
#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\denguid.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Denali

File: denguid.cpp

Owner: SteveBr

Contains all guid's created by Denali not in the .odl.
===================================================================*/

DEFINE_GUID(IID_IObjectCover,0xD99A6DA2L,0x485C,0x17CF,0x83,0xBE,0x01,0xD0,0xC9,0x0C,0x2B,0xD8);

// {7F50F880-1230-11d0-B394-00A0C90C2048}
// this is a dummy GUID that is used to identify all Denali intrinsics, 
// its primary intent is to prevent a user from assigning an intrinsic
// object into the session/ application object
DEFINE_GUID(IID_IDenaliIntrinsic, 0x7f50f880, 0x1230, 0x11d0, 0xb3, 0x94, 0x0, 0xa0, 0xc9, 0xc, 0x20, 0x48);

// BUG 1423: We want to be able to identify JavaScript objects.
//				We are NOT supposed to know what this guid is.  We MUST not use this GUID
//				for anything besides QI'ing to see if the object is a JavaScript object
// The GUID used to identify the IJScriptDispatch interface
// {A0AAC450-A77B-11CF-91D0-00AA00C14A7C}
#define szIID_IJScriptDispatch "{A0AAC450-A77B-11CF-91D0-00AA00C14A7C}"
DEFINE_GUID(IID_IJScriptDispatch,  0xa0aac450, 0xa77b, 0x11cf, 0x91, 0xd0, 0x0, 0xaa, 0x0, 0xc1, 0x4a, 0x7c);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\debugger.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: misc

File: debugger.h

Owner: DGottner, DmitryR

This file contains debugger useful utility prototypes.
===================================================================*/

#ifndef _DEBUGGER_H
#define _DEBUGGER_H

#include "activdbg.h"
#include "dbgcxt.h"		// Convienence for users of debugger.h

/*
 * Globals that we advertise
 */

class CViperActivity;

extern IProcessDebugManager *g_pPDM;
extern IDebugApplication *g_pDebugApp;
extern IDebugApplicationNode *g_pDebugAppRoot;
extern CViperActivity *g_pDebugActivity;
extern DWORD g_dwDebugThreadId;

/*
 * Initialize/Uninitialize debugging
 */

extern HRESULT InitDebugging(CIsapiReqInfo *pIReq);
extern HRESULT UnInitDebugging();


/*
 * Get the application node for the virtual server
 */

extern HRESULT GetServerDebugRoot(CIsapiReqInfo *pIReq, IDebugApplicationNode **ppDebugRoot);


/*
 * Query debugging client
 */
BOOL FCaesars();		// TRUE if default JIT debugger is Script Debugger


/*
 * Debugger (or Debugger UI) invocation from a correct thread
 */

#define DEBUGGER_UI_BRING_DOCUMENT_TO_TOP       0x00000001
#define DEBUGGER_UI_BRING_DOC_CONTEXT_TO_TOP    0x00000002
#define DEBUGGER_EVENT_ON_PAGEBEGIN             0x00000010
#define DEBUGGER_EVENT_ON_PAGEEND               0x00000020
#define DEBUGGER_EVENT_ON_REFRESH_BREAKPOINT	0x00000040
#define DEBUGGER_ON_REMOVE_CHILD                0x00000100
#define DEBUGGER_ON_DESTROY                     0x00000200
#define DEBUGGER_UNUSED_RECORD                  0x80000000  // can reclaim argument space

HRESULT InvokeDebuggerWithThreadSwitch(IDebugApplication *pDebugAppln, DWORD iMethod, void *Arg = NULL);


/*
 * Create/Destroy entire document trees (debugger)
 */

HRESULT CreateDocumentTree(wchar_t *szDocPath, IDebugApplicationNode *pDocParent, IDebugApplicationNode **ppDocRoot, IDebugApplicationNode **ppDocLeaf, wchar_t **pwszLeaf);
void DestroyDocumentTree(IDebugApplicationNode *pDocRoot);


/*===================================================================
  C  F i l e  N o d e

These are used to provide directory nodes in debugger
Used by application mgr & by CreateDocumentTree
===================================================================*/

extern const GUID IID_IFileNode;
struct IFileNode : IDebugDocumentProvider
	{
	//
	// This private interface provides two functions:
	//
	//  * An extra method to retrieve/set the count of documents in
	//    a directory (used to know when we can detach a folder from
	//    the UI
	//
	//  * A way of verifying that an IDebugDocumentProvider is a CFileNode
	//

	STDMETHOD_(DWORD, IncrementDocumentCount)() = 0;
	STDMETHOD_(DWORD, DecrementDocumentCount)() = 0;
	};


class CFileNode : public IFileNode
	{
private:
	DWORD	m_cRefs;			// Reference Count
	DWORD	m_cDocuments;		// # of CTemplates in the directory (and recursively in subdirectories)
	wchar_t *m_wszName;

public:
	CFileNode();
	~CFileNode();
	HRESULT Init(wchar_t *wszName);

	// IUnknown methods
	STDMETHOD(QueryInterface)(const GUID &, void **);
	STDMETHOD_(ULONG, AddRef)();
	STDMETHOD_(ULONG, Release)();

	// IDebugDocumentProvider methods
	STDMETHOD(GetDocument)(/* [out] */ IDebugDocument **ppDebugDoc);

	// IDebugDocumentInfo (also IDebugDocumentProvider) methods
	STDMETHOD(GetName)(
		/* [in] */ DOCUMENTNAMETYPE dnt,
		/* [out] */ BSTR *pbstrName);

	STDMETHOD(GetDocumentClassId)(/* [out] */ CLSID *)
		{
		return E_NOTIMPL;
		}

	STDMETHOD_(DWORD, IncrementDocumentCount)()
		{
		return ++m_cDocuments;
		}

	STDMETHOD_(DWORD, DecrementDocumentCount)()
		{
		return --m_cDocuments;
		}
	};

#endif // _DEBUGGER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\denali.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996-1999 Microsoft Corporation. All Rights Reserved.

Component: Main

File: denali.cpp

Owner: AndyMorr

This file contains the  I S A P I   C A L L B A C K   A P I S
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#undef DEFAULT_TRACE_FLAGS
#define DEFAULT_TRACE_FLAGS     (DEBUG_ERROR)

#include "gip.h"
#include "mtacb.h"
#include "perfdata.h"
#include "activdbg.h"
#include "debugger.h"
#include "dbgutil.h"
#include "randgen.h"
#include "aspdmon.h"
#include "tlbcache.h"
#include "thrdgate.h"
#include "ie449.h"

#include "memcls.h"
#include "memchk.h"

// Globals

BOOL g_fShutDownInProgress = FALSE;
BOOL g_fInitStarted = FALSE;

char g_szExtensionDesc[] = "Microsoft Active Server Pages 2.0";
GLOB gGlob;
BOOL g_fFirstHit = TRUE;
char g_pszASPModuleName[] = "ASP";

DECLARE_DEBUG_PRINTS_OBJECT();
#ifdef _NO_TRACING_
DECLARE_DEBUG_VARIABLE();
#else
#include <initguid.h>
DEFINE_GUID(IisAspGuid, 
0x784d8902, 0xaa8c, 0x11d2, 0x92, 0x5e, 0x00, 0xc0, 0x4f, 0x72, 0xd9, 0x0e);
#endif
DECLARE_PLATFORM_TYPE();

// Out of process flag
BOOL g_fOOP = FALSE;

// session id cookie
char g_szSessionIDCookieName[CCH_SESSION_ID_COOKIE+1];

CRITICAL_SECTION    g_csEventlogLock;
CRITICAL_SECTION    g_csFirstHitLock;
HINSTANCE           g_hODBC32Lib;

// Added to support CacheExtensions
HINSTANCE           g_hDenali = (HINSTANCE)0;
HINSTANCE           g_hinstDLL = (HINSTANCE)0;

extern LONG g_nSessionObjectsActive;

// Cached BSTRs
BSTR g_bstrApplication = NULL;
BSTR g_bstrRequest = NULL;
BSTR g_bstrResponse = NULL;
BSTR g_bstrServer = NULL;
BSTR g_bstrCertificate = NULL;
BSTR g_bstrSession = NULL;
BSTR g_bstrScriptingNamespace = NULL;
BSTR g_bstrObjectContext = NULL;

extern IASPObjectContext  *g_pIASPDummyObjectContext;

// Forward references
HRESULT GlobInit();
HRESULT GlobUnInit();
HRESULT CacheStdTypeInfos();
HRESULT UnCacheStdTypeInfos();
HRESULT InitCachedBSTRs();
HRESULT UnInitCachedBSTRs();
HRESULT ShutDown();
HRESULT SendHtmlSubstitute(CIsapiReqInfo    *pIReq);

void MakeAspCookieName(char *);
BOOL FirstHitInit(CIsapiReqInfo    *pIReq);


// ATL support
#if _IIS_5_1
CWamModule _Module;
#elif _IIS_6_0
CComModule _Module;
#else
#error "Neither _IIS_6_0 nor _IIS_5_1 is defined"
#endif

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()


/*===================================================================
DllMain - Moved from clsfctry.cpp

Main entry point into the DLL.  Called by system on DLL load
and unload.

Returns:
    TRUE on success

Side effects:
    None.
===================================================================*/
BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD dwReason, LPVOID lpvReserved)
    {
/* Obsolete
    // Let the Proxy code get a crack at it
    if (!PrxDllMain(hinstDLL, dwReason, lpvReserved))
        return FALSE;
*/

    switch(dwReason)
        {
    case DLL_PROCESS_ATTACH:
        // hang onto the hinstance so we can use it to get to our string resources
        //
        g_hinstDLL = hinstDLL;

        // Here's an interesting optimization:
        // The following tells the system NOT to call us for Thread attach/detach
        // since we dont handle those calls anyway, this will speed things up a bit.
        // If this turns out to be a problem for some reason (cant imagine why),
        // just remove this again.
        DisableThreadLibraryCalls(hinstDLL);
        break;
            
    case DLL_PROCESS_DETACH:
        break;

    case DLL_THREAD_ATTACH:
        break;

    case DLL_THREAD_DETACH:
        break;

        }
    return TRUE;
    }

/*===================================================================
DWORD HandleHit

Given the CIsapiReqInfo construct a hit object to be queued
for execution

Parameters:
    pIReq  - CIsapiReqInfo 

Returns:
    HSE_STATUS_PENDING if function is successful in queuing request
    HSE_STATUS_ERROR if not successful
===================================================================*/

DWORD HandleHit(CIsapiReqInfo    *pIReq)
    {
    int         errorId   = 0;
    BOOL        fRejected = FALSE;
    BOOL        fCompleted = FALSE;
    HRESULT     hr        = S_OK;
        
    /*
     * We cant read the metabase until we have the WAM_EXEC_INFO, which
     * we dont have at DllInit time.  Therefore, we postpone reading the
     * metabase until now, but we do it only on the first hit.
     */
    if (g_fFirstHit)
        {
        EnterCriticalSection(&g_csFirstHitLock);
        
        // If someone initied while we were waiting for the CS,
        // then noop
        if (g_fFirstHit)
            {
            BOOL fT;
                
            fT = FirstHitInit(pIReq);
            Assert(fT);
            
            g_fFirstHit = FALSE;
            }
            
        LeaveCriticalSection(&g_csFirstHitLock);
        }

#ifndef PERF_DISABLE
    if (!g_fPerfInited) // Init PERFMON data on first request
        {
        // FYI: leverage same CS as first hit lock
        EnterCriticalSection(&g_csFirstHitLock);
        
        // If someone initied while we were waiting for the CS,
        // then noop
        if (!g_fPerfInited)
            {
            if (SUCCEEDED(InitPerfDataOnFirstRequest(pIReq)))
                {
                    g_fPerfInited = TRUE;
                }
                else
                {
                    g_fPerfInited = FALSE;
                    // call this again since InitPerfDataOnFirstRequest will uninit
                    // and erase the criticalsection which will then AV when we try to increment counters
                    PreInitPerfData();
                }
            }
        LeaveCriticalSection(&g_csFirstHitLock);
        }
    g_PerfData.Incr_REQTOTAL();
#endif

    if (Glob(fNeedUpdate))
        {
        if (SUCCEEDED(StartISAThreadBracket(pIReq)))
            {
            // Update uses pIReq - need to bracket
            gGlob.Update(pIReq);
            
            EndISAThreadBracket(pIReq);
            }
        }

    if (IsShutDownInProgress())
        hr = E_FAIL;

    // Enforce the limit of concurrent browser requests
    if (SUCCEEDED(hr) && Glob(dwRequestQueueMax) &&
        (*g_PerfData.PDWCounter(ID_REQCURRENT) >= Glob(dwRequestQueueMax)))
        {
        hr = E_FAIL;
        fRejected = TRUE;
        }

    if (SUCCEEDED(hr))
        hr = CHitObj::NewBrowserRequest(pIReq, &fRejected, &fCompleted, &errorId);

    if (SUCCEEDED(hr))
        return fCompleted ? HSE_STATUS_SUCCESS_AND_KEEP_CONN : HSE_STATUS_PENDING;

    if (fRejected)
        {
        if (Glob(fEnableAspHtmlFallBack))
            {
            // Instead of rejecting the request try to find
            // XXX_ASP.HTM file in the same directory and dump its contents
            hr = SendHtmlSubstitute(pIReq);

            if (hr == S_OK)
                return HSE_STATUS_SUCCESS_AND_KEEP_CONN;      // HTML substitute sent
            else if (FAILED(hr))
                return HSE_STATUS_ERROR;        // error sending
            // HTML substitute not found
            }
 
        errorId = IDE_SERVER_TOO_BUSY;
        
#ifndef PERF_DISABLE
        g_PerfData.Incr_REQREJECTED();
#endif
        }

    if (SUCCEEDED(StartISAThreadBracket(pIReq)))
        {
        // Uses pIReq -- need to bracket
        Handle500Error(errorId, pIReq);
        
        EndISAThreadBracket(pIReq);
        }
    
    return HSE_STATUS_ERROR;
    }

/*===================================================================
BOOL DllInit

Initialize Denali if not invoked by RegSvr32.  Only do inits here
that dont require Glob values loaded from the metabase.  For any
inits that require values loaded into Glob from the metabase, use
FirstHitInit.

Returns:
    TRUE on successful initialization
===================================================================*/
BOOL DllInit()
    {
    HRESULT hr;
    const   CHAR  szASPDebugRegLocation[] =
                        "System\\CurrentControlSet\\Services\\W3Svc\\ASP";

#if _IIS_5_1
    InitializeIISRTL();
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- IISRTL\n"));   
#endif
    
#ifndef _NO_TRACING_
    CREATE_DEBUG_PRINT_OBJECT( g_pszASPModuleName, IisAspGuid);
#else
    CREATE_DEBUG_PRINT_OBJECT( g_pszASPModuleName);
#endif

    if ( !VALID_DEBUG_PRINT_OBJECT()) 
        {
        return ( FALSE);
        }

#ifdef _NO_TRACING_
    LOAD_DEBUG_FLAGS_FROM_REG_STR(szASPDebugRegLocation, (DEBUG_ERROR));
#endif

#ifdef SCRIPT_STATS
    ReadRegistrySettings();
#endif // SCRIPT_STATS

    // Create ASP RefTrace Logs
    IF_DEBUG(TEMPLATE) CTemplate::gm_pTraceLog = CreateRefTraceLog(5000, 0);
    IF_DEBUG(SESSION) CSession::gm_pTraceLog = CreateRefTraceLog(5000, 0);
    IF_DEBUG(APPLICATION) CAppln::gm_pTraceLog = CreateRefTraceLog(5000, 0);
    IF_DEBUG(FCN) CASPDirMonitorEntry::gm_pTraceLog = CreateRefTraceLog(500, 0);
                     CAppln::gm_pTraceLog = CreateRefTraceLog(5000, 0);

    if (FAILED(PreInitPerfData()))
        return FALSE;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- PerfMon Data PreInit\n")); 

    ErrInitCriticalSection( &g_csEventlogLock, hr );
    if (FAILED(hr))
        return FALSE;
        
    ErrInitCriticalSection( &g_csFirstHitLock, hr );
    if (FAILED(hr))
        return FALSE;

#ifdef DENALI_MEMCHK
    if (FAILED(DenaliMemoryInit()))
        return FALSE;
#else
    if (FAILED(AspMemInit()))
        return FALSE;
#endif
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- Denali Memory Init\n"));

    g_pDirMonitor = new CDirMonitor;

    if (g_pDirMonitor == NULL) {
        return FALSE;
    }

    _Module.Init(ObjectMap, g_hinstDLL, &LIBID_ASPTypeLibrary);

#if _IIS_5_1
    if (AtqInitialize(0) == FALSE)
        return FALSE;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- ATQ Initialized\n"));
#endif

    if (FAILED(GlobInit()))
        return FALSE;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- Glob Init\n"));

    if (FAILED(InitMemCls()))
        return FALSE;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- Per-Class Cache Init\n")); 

    if (FAILED(InitCachedBSTRs()))
        return FALSE;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- Cached BSTRs Init\n"));

    if (FAILED(CacheStdTypeInfos()))
        return FALSE;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- Cache Std TypeInfos\n"));

    if (FAILED(g_TypelibCache.Init()))
        return FALSE;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- Typelib Cache Init\n"));

    if (FAILED(ErrHandleInit()))
        return FALSE;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- Err Handler Init\n"));

    srand( (unsigned int) time(NULL) );
    if (FAILED(g_SessionIdGenerator.Init()))    // seed session id
        return FALSE;
    // Init new Exposed Session Id variable
    if (FAILED(g_ExposedSessionIdGenerator.Init(g_SessionIdGenerator)))    // seed exposed session id
    	return FALSE;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- SessionID Generator Init\n"));

    MakeAspCookieName(g_szSessionIDCookieName);

    if (FAILED(InitRandGenerator()))
        return FALSE;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- RandGen Init\n"));

    if (FAILED(g_ApplnMgr.Init()))
        return FALSE;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- Appln Mgr Init\n"));

    if (FAILED(Init449()))
        return FALSE;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- 449 Mgr Init\n"));

    // Note: Template cache manager is inited in two phases.  Do first here.
    if (FAILED(g_TemplateCache.Init()))
        return FALSE;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- Template Cache Init\n"));

    if (FAILED(g_IncFileMap.Init()))
        return FALSE;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- Inc File Users Init\n"));

    if (FIsWinNT())  // No Change notification on Windows 95
    {
        if (FAILED(g_FileAppMap.Init()))
            return FALSE;
        DBGPRINTF((DBG_CONTEXT, "ASP Init -- File-Application Map Init\n"));
    }

    if (FAILED(g_ScriptManager.Init()))
        return FALSE;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- Script Manager Init\n"));

    if (FAILED(CTemplate::InitClass()))
        return FALSE;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- CTemplate Init Class\n"));

    if (FIsWinNT())  // No GIPs on Win95
        {
        if (FAILED(g_GIPAPI.Init()))
            return FALSE;
        DBGPRINTF((DBG_CONTEXT, "ASP Init -- Global Interface API Init\n"));
        }

    if (FAILED(InitMTACallbacks()))
        return FALSE;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- MTA Callbacks Init\n"));

    if (!RequestSupportInit())
        return FALSE;
    DBGPRINTF((DBG_CONTEXT, "ASP Init -- Request Support Init\n"));

    DBGPRINTF((DBG_CONTEXT, "ASP Init -- Denali DLL Initialized\n"));
    
#ifdef LOG_FCNOTIFICATIONS
    LfcnCreateLogFile();
#endif //LOG_FCNOTIFICATIONS

    return TRUE;
    }

/*===================================================================
BOOL FirstHitInit

Initialize any ASP values that can not be inited at DllInit time.

Returns:
    TRUE on successful initialization
===================================================================*/
BOOL FirstHitInit
(
CIsapiReqInfo    *pIReq
)
    {
    HRESULT hr;

    /*
     * In the out of proc case, being able to call the metabase relies on having
     * told WAM that we are a "smart" client
     */

    if (SUCCEEDED(StartISAThreadBracket(pIReq)))
        {
        // ReadConfigFromMD uses pIReq - need to bracket
        hr = ReadConfigFromMD(pIReq, NULL, TRUE);
        
        // Initialize Debugging
        if (FIsWinNT() && RevertToSelf())  // No Debugging on Win95
            {
            // Don't care whether debugging initializaiton succeeds or not.  The most likely
            // falure is debugger not installed on the machine.
            //
            if (SUCCEEDED(InitDebugging(pIReq))) 
            {
                DBGPRINTF((DBG_CONTEXT, "FirstHitInit: Debugging Initialized\n"));
            }
            else 
            {
                DBGPRINTF((DBG_CONTEXT, "FirstHitInit: Debugger Initialization Failed\n"));
            }

            DBG_REQUIRE( SetThreadToken(NULL, pIReq->QueryImpersonationToken()) );
            }

        EndISAThreadBracket(pIReq);
        }
    else
        {
        hr = E_FAIL;
        }

    if (FAILED(hr))
        goto LExit;
    DBGPRINTF((DBG_CONTEXT, "FirstHitInit: Metadata loaded successfully\n"));

    // Do FirstHitInit for the Template Cache Manager.  Primarily initializes
    // the Persisted Template Cache
    if (FAILED(hr = g_TemplateCache.FirstHitInit()))
        goto LExit;
    DBGPRINTF((DBG_CONTEXT, "FirstHitInit: Template Cache Initialized\n"));

    // Configure MTS
    if (FAILED(hr = ViperConfigure(Glob(dwProcessorThreadMax), Glob(fAllowOutOfProcCmpnts))))
        goto LExit;
    DBGPRINTF((DBG_CONTEXT, "FirstHitInit: MTS configured\n"));

    // Configure Thread Gate
    THREADGATE_CONFIG tgc;
    tgc.fEnabled             = Glob(fThreadGateEnabled);
    tgc.msTimeSlice          = Glob(dwThreadGateTimeSlice);
    tgc.msSleepDelay         = Glob(dwThreadGateSleepDelay);
    tgc.nSleepMax            = Glob(dwThreadGateSleepMax);
    tgc.nLoadLow             = Glob(dwThreadGateLoadLow);
    tgc.nLoadHigh            = Glob(dwThreadGateLoadHigh);
    tgc.nMinProcessorThreads = 1;
    tgc.nMaxProcessorThreads = Glob(dwProcessorThreadMax);
    if (FAILED(hr = InitThreadGate(&tgc)))
        goto LExit;
    DBGPRINTF((DBG_CONTEXT, "Thread Gate Init\n"));

    DBGPRINTF((DBG_CONTEXT, "ASP First Hit Initialization complete\n"));

LExit:
    Assert(SUCCEEDED(hr));
    return SUCCEEDED(hr);
    }

/*===================================================================
void DllUnInit

UnInitialize Denali DLL if not invoked by RegSvr32

Returns:
    NONE

Side effects:
    NONE
===================================================================*/
void DllUnInit( void )
    {
    DBGPRINTF((DBG_CONTEXT, "ASP UnInit -- %d Apps %d Sessions %d Requests\n",
                g_nApplications, g_nSessions, g_nBrowserRequests));

    g_fShutDownInProgress = TRUE;

    ShutDown();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- ShutDown Processing\n" ));

    UnInitMTACallbacks();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- MTA Callbacks\n" ));

    UnInitRandGenerator();
    DBGPRINTF((DBG_CONTEXT, "ASP UnInit -- RandGen\n"));

    UnInitThreadGate();
    DBGPRINTF((DBG_CONTEXT, "ASP UnInit -- Thread Gate\n"));

    UnInit449();
    DBGPRINTF((DBG_CONTEXT, "ASP UnInit -- 449 Mgr\n"));
    
    g_ApplnMgr.UnInit();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- Application Manager\n" ));

    g_ScriptManager.UnInit();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- Script Manager\n" ));
    
    g_TemplateCache.UnInit();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- Template Cache\n" ));

    g_IncFileMap.UnInit();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- IncFileMap\n" ));

    if (FIsWinNT()) {
        // No change notification on windows 95
        g_FileAppMap.UnInit();
        DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- File-Application Map\n" ));
        
        if (g_pDirMonitor) {
            g_pDirMonitor->Cleanup();
            DBGPRINTF((DBG_CONTEXT,  "ASP UNInit -- Directory Monitor\n" ));
        }
    }

    CTemplate::UnInitClass();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- CTemplate\n" ));

    g_TypelibCache.UnInit();
    DBGPRINTF((DBG_CONTEXT, "ASP UnInit -- Typelib Cache\n"));

    UnCacheStdTypeInfos();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- TypeInfos\n" ));

    if (FIsWinNT())
        {
        // No GIPs on Win95
        g_GIPAPI.UnInit();
        DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- GIP\n" ));
        }
        
    ErrHandleUnInit();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- ErrHandler\n" ));

    GlobUnInit();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- Glob\n" ));

    UnInitCachedBSTRs();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- Cached BSTRs\n" ));

    //////////////////////////////////////////////////////////
    // Wait for the actual session objects to be destroyed. 
    // The g_nSessions global tracks the init/uninit of session
    // objects but not the memory itself.  This presents a 
    // problem when something outside of ASP holds a reference
    // to a session object or one of the contained intrinsics.
    // One case of this is the revoking of a git'd transaction
    // object.  Turns out the revoke can happen asynchronously.
    //
    // NOTE!!! - This needs to be done BEFORE uniniting the 
    // mem classes since these objects are in the acache.

    LONG    lastCount = g_nSessionObjectsActive;
    DWORD   loopCount = 50;

    while( (g_nSessionObjectsActive > 0) && (loopCount--) )
    {
        if (lastCount != g_nSessionObjectsActive) {
            lastCount = g_nSessionObjectsActive;
            loopCount = 50;
        }
        Sleep( 100 );
    }

    UnInitMemCls();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- Per-Class Cache\n" ));

#if _IIS_5_1
    AtqTerminate();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- ATQ\n" ));
#endif

    // Destroy ASP RefTrace Logs
    IF_DEBUG(TEMPLATE) DestroyRefTraceLog(CTemplate::gm_pTraceLog);
    IF_DEBUG(SESSION) DestroyRefTraceLog(CSession::gm_pTraceLog);
    IF_DEBUG(APPLICATION) DestroyRefTraceLog(CAppln::gm_pTraceLog);
    IF_DEBUG(FCN) DestroyRefTraceLog(CASPDirMonitorEntry::gm_pTraceLog);

    if (g_pIASPDummyObjectContext)
        g_pIASPDummyObjectContext->Release();

    _Module.Term();

    delete g_pDirMonitor;
    g_pDirMonitor = NULL;

    //  UnInitODBC();
    // Note: the memmgr uses perf counters, so must be uninited before the perf counters are uninited
#ifdef DENALI_MEMCHK
    DenaliMemoryUnInit();
#else
    AspMemUnInit();
#endif
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- Memory Manager\n" ));

    UnInitPerfData();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- Perf Counters\n" ));

#if _IIS_5_1
    TerminateIISRTL();
    DBGPRINTF((DBG_CONTEXT,  "ASP UnInit -- IISRTL\n" ));
#endif

    DBGPRINTF((DBG_CONTEXT,  "ASP Uninitialized\n" ));
    
#ifdef LOG_FCNOTIFICATIONS
    LfcnUnmapLogFile();
#endif //LOG_FCNOTIFICATIONS

    // Deleting the following CS's must be last.  Dont put anything after this
    DeleteCriticalSection( &g_csFirstHitLock );
    DeleteCriticalSection( &g_csEventlogLock );

    DELETE_DEBUG_PRINT_OBJECT();
    }

/*===================================================================
GetExtensionVersion

Mandatory server extension call which returns the version number of
the ISAPI spec that we were built with.

Returns:
    TRUE on success

Side effects:
    None.
===================================================================*/
BOOL WINAPI GetExtensionVersion(HSE_VERSION_INFO *pextver)
    {
    // This DLL can be inited only once
    if (g_fShutDownInProgress || 
        InterlockedExchange((LPLONG)&g_fInitStarted, TRUE))
        {
        SetLastError(ERROR_BUSY);
        return FALSE;
        }
        
    if (!DllInit())
        {
        SetLastError(ERROR_BUSY);
        return FALSE;
        }

    pextver->dwExtensionVersion =
            MAKELONG(HSE_VERSION_MAJOR, HSE_VERSION_MINOR);
    strcpy(pextver->lpszExtensionDesc, g_szExtensionDesc);
    return TRUE;
    }

/*===================================================================
HttpExtensionProc

Main entry point into the DLL for the (ActiveX) Internet Information Server.

Returns:
    DWord indicating status of request.  
    HSE_STATUS_PENDING for normal return
        (This indicates that we will process the request, but havent yet.)

Side effects:
    None.
===================================================================*/
DWORD WINAPI HttpExtensionProc(EXTENSION_CONTROL_BLOCK *pECB)
    {
#ifdef SCRIPT_STATS
    InterlockedIncrement(&g_cHttpExtensionsExecuting);
#endif // SCRIPT_STATS

    CIsapiReqInfo   *pIReq = new CIsapiReqInfo(pECB);

    if (pIReq == NULL) {
        SetLastError(ERROR_OUTOFMEMORY);
        return HSE_STATUS_ERROR;
    }

    #ifndef PERF_DISABLE
    g_PerfData.Add_REQTOTALBYTEIN
        (
        pIReq->QueryCchQueryString()
#if _IIS_5_1
        + pIReq->QueryCchPathTranslated()
#elif _IIS_6_0
        + strlen( pIReq->ECB()->lpszPathTranslated )
#endif
        + pIReq->QueryCbTotalBytes()
        );
#endif

    DWORD dw = HandleHit(pIReq);

#ifdef SCRIPT_STATS
    InterlockedDecrement(&g_cHttpExtensionsExecuting);
#endif // SCRIPT_STATS

    pIReq->Release();

    return dw;
    }

/*===================================================================
TerminateExtension

IIS is supposed to call this entry point to unload ISAPI DLLs.

Returns:
    NONE

Side effects:
    Uninitializes the Denali ISAPI DLL if asked to.
===================================================================*/
BOOL WINAPI TerminateExtension( DWORD dwFlag )
    {
    if ( dwFlag == HSE_TERM_ADVISORY_UNLOAD )
        return TRUE;

    if ( dwFlag == HSE_TERM_MUST_UNLOAD )
        {
        // If already shutdown don't uninit twice.
        if (g_fShutDownInProgress)
            return TRUE;

        // make sure this is a CoInitialize()'d thread
        HRESULT hr = CoInitialize(NULL);
        
        if (hr == RPC_E_CHANGED_MODE)
            {
            // already coinitialized MUTLITREADED - OK
            DllUnInit();
            }
        else if (SUCCEEDED(hr))
            {
            DllUnInit();
            
            // need to CoUninit() because CoInit() Succeeded
            CoUninitialize();
            }
            
        return TRUE;
        }
        
    return FALSE;
    }

/*===================================================================
HRESULT ShutDown

ASP Processing ShutDown logic. (Moved from ThreadManager::UnInit())

Returns:
    HRESULT - S_OK on success
    
Side effects:
    May be slow. Kills all requests/sessions/applications
===================================================================*/
HRESULT ShutDown()
    {
    long iT;
    const DWORD dwtLongWait  = 1000;  // 1 sec
    const DWORD dwtShortWait = 100;   // 1/10 sec
        
    DBGPRINTF((DBG_CONTEXT, "ASP Shutdown: %d apps (%d restarting), %d sessions\n",
                g_nApplications, g_nApplicationsRestarting, g_nSessions ));

    //////////////////////////////////////////////////////////
    // Stop change notification on files in template cache
    
    if (FIsWinNT())
        {
        g_TemplateCache.ShutdownCacheChangeNotification();
        }

    //////////////////////////////////////////////////////////
    // Shut down debugging, which will have the effect of
    // resuming scripts stopped at a breakpoint.
    //
    // (otherwise stopping running scripts will hang later)

    if (g_pPDM)
        {
        g_TemplateCache.RemoveApplicationFromDebuggerUI(NULL);  // remove all document nodes
        UnInitDebugging();                                      // kill PDM
        DBGPRINTF((DBG_CONTEXT,  "ASP Shutdown: PDM Closed\n" ));
        }

    //////////////////////////////////////////////////////////
    // Drain down all pending browser requests 

    if (g_nBrowserRequests > 0)
        {
        // Give them a little time each
        for (iT = 2*g_nBrowserRequests; g_nBrowserRequests > 0 && iT > 0; iT--)
            Sleep(dwtShortWait);

        if (g_nBrowserRequests > 0)
            {
            // Still there - kill scripts and wait again
            g_ScriptManager.EmptyRunningScriptList();
            
            for (iT = 2*g_nBrowserRequests; g_nBrowserRequests > 0 && iT > 0; iT--)
                Sleep(dwtShortWait);
            }
        }

    DBGPRINTF((DBG_CONTEXT, "ASP Shutdown: Requests drained: %d remaining\n",
                g_nBrowserRequests));

    //////////////////////////////////////////////////////////
    // Kill any remaining engines running scripts
    
    g_ScriptManager.EmptyRunningScriptList();

    DBGPRINTF((DBG_CONTEXT, "ASP Shutdown: Scripts killed\n"));
    
    //////////////////////////////////////////////////////////
    // Wait till there are no appications restarting
    
    g_ApplnMgr.Lock();
    while (g_nApplicationsRestarting > 0)
        {
        g_ApplnMgr.UnLock();
        Sleep(dwtShortWait);
        g_ApplnMgr.Lock();
        }
    g_ApplnMgr.UnLock();

    DBGPRINTF((DBG_CONTEXT, "ASP Shutdown: 0 applications restarting\n"));

    //////////////////////////////////////////////////////////
    // Make this thread's priority higher than that of worker threads
    
    SetThreadPriority(GetCurrentThread(), THREAD_PRIORITY_ABOVE_NORMAL);

    //////////////////////////////////////////////////////////
    // For each application queue up all its sessions for deletion
    
    CApplnIterator ApplnIterator;
    ApplnIterator.Start();
    CAppln *pAppln;
    while (pAppln = ApplnIterator.Next())
        {
        // remove link to ATQ scheduler (even if killing of sessions fails)
        pAppln->PSessionMgr()->UnScheduleSessionKiller();
        
        for (iT = pAppln->GetNumSessions(); iT > 0; iT--)
            {
            pAppln->PSessionMgr()->DeleteAllSessions(TRUE);

            if (pAppln->GetNumSessions() == 0) // all gone?
                break;
                
            Sleep(dwtShortWait);
            }
        }
    ApplnIterator.Stop();

    DBGPRINTF((DBG_CONTEXT, "ASP Shutdown: All sessions queued up for deletion. nSessions=%d\n",
                g_nSessions));

    //////////////////////////////////////////////////////////
    // Wait till all sessions are gone (UnInited)

    while (g_nSessions > 0)
        {
        // Wait for a maximum of 0.1 sec x # of sessions
        for (iT = g_nSessions; g_nSessions > 0 && iT > 0; iT--)
            Sleep(dwtShortWait);

        if (g_nSessions > 0)
            g_ScriptManager.EmptyRunningScriptList();   // Kill runaway Session_OnEnd scripts
        }

    DBGPRINTF((DBG_CONTEXT, "ASP Shutdown: Finished waiting for sessions to go away. nSessions=%d\n",
                g_nSessions));
    
    //////////////////////////////////////////////////////////
    // Queue up all application objects for deletion

    g_ApplnMgr.DeleteAllApplications();
    DBGPRINTF((DBG_CONTEXT, "ASP Shutdown: All applications queued up for deletion. nApplications=%d\n",
                g_nApplications));

    //////////////////////////////////////////////////////////
    // Wait till all applications are gone (UnInited)
    
    while (g_nApplications > 0)
        {
        // Wait for a maximum of 1 sec x # of applications
        for (iT = g_nApplications; g_nApplications > 0 && iT > 0; iT--)
            Sleep(dwtLongWait);

        if (g_nApplications > 0)
            g_ScriptManager.EmptyRunningScriptList();   // Kill runaway Applications_OnEnd scripts
        }

    DBGPRINTF((DBG_CONTEXT, "ASP Shutdown: Finished waiting for applications to go away. nApplications=%d\n",
                g_nApplications));
    
    /////////////////////////////////////////////////////////
    // Wait on the CViperAsyncRequest objects. COM holds the 
    // final reference to these so we need to let the activity
    // threads release any outstanding references before we
    // exit.

    while( g_nViperRequests > 0 )
    {
        Sleep( dwtShortWait );
    }


    //////////////////////////////////////////////////////////
    // Free up libraries to force call of DllCanUnloadNow()
    //    Component writers should put cleanup code in the DllCanUnloadNow() entry point.

    CoFreeUnusedLibraries();

    //////////////////////////////////////////////////////////
    // Kill Debug Activity if any

    if (g_pDebugActivity)
        delete g_pDebugActivity;

    DBGPRINTF((DBG_CONTEXT, "ASP Shutdown: Debug Activity destroyed\n"));

    //////////////////////////////////////////////////////////

    return S_OK;
    }

/*===================================================================
HRESULT GlobInit

Get all interesting global values (mostly from registry)

Returns:
    HRESULT - S_OK on success
    
Side effects:
    fills in glob.  May be slow
===================================================================*/
HRESULT GlobInit()
{
    //
    // BUGBUG - This really needs to be provided either through
    // a server support function or via the wamexec
    //
    
    char szModule[MAX_PATH+1];
    if (GetModuleFileNameA(NULL, szModule, MAX_PATH) > 0)
    {
        int cch = strlen(szModule);
        if (cch > 12 && stricmp(szModule+cch-12, "inetinfo.exe") == 0)
        {
            g_fOOP = FALSE;
        }
        else if ( cch > 8 && stricmp( szModule+cch-8, "w3wp.exe" ) == 0 )
        {
            g_fOOP = FALSE;
        }
        else
        {
            g_fOOP = TRUE;
        }
    }
    
    // Init gGlob
    return gGlob.GlobInit();
}

/*===================================================================
GlobUnInit

It is a macro now. see glob.h

Returns:
    HRESULT - S_OK on success
    
Side effects:
    memory freed.
===================================================================*/
HRESULT GlobUnInit()
    {
    return gGlob.GlobUnInit();
    }

/*===================================================================
InitCachedBSTRs

Pre-create frequently used BSTRs
===================================================================*/
HRESULT InitCachedBSTRs()
    {
    g_bstrApplication        = SysAllocString(WSZ_OBJ_APPLICATION);
    g_bstrRequest            = SysAllocString(WSZ_OBJ_REQUEST);
    g_bstrResponse           = SysAllocString(WSZ_OBJ_RESPONSE);
    g_bstrServer             = SysAllocString(WSZ_OBJ_SERVER);
    g_bstrCertificate        = SysAllocString(WSZ_OBJ_CERTIFICATE);
    g_bstrSession            = SysAllocString(WSZ_OBJ_SESSION);
    g_bstrScriptingNamespace = SysAllocString(WSZ_OBJ_SCRIPTINGNAMESPACE);
    g_bstrObjectContext      = SysAllocString(WSZ_OBJ_OBJECTCONTEXT);

    return
        (
        g_bstrApplication &&
        g_bstrRequest &&
        g_bstrResponse &&
        g_bstrServer &&
        g_bstrCertificate && 
        g_bstrSession &&
        g_bstrScriptingNamespace &&
        g_bstrObjectContext
        )
        ? S_OK : E_OUTOFMEMORY;
    }

/*===================================================================
UnInitCachedBSTRs

Delete frequently used BSTRs
===================================================================*/
HRESULT UnInitCachedBSTRs()
    {
    if (g_bstrApplication)
        {
        SysFreeString(g_bstrApplication);
        g_bstrApplication = NULL;
        }
    if (g_bstrRequest)
        {
        SysFreeString(g_bstrRequest);
        g_bstrRequest = NULL;
        }
    if (g_bstrResponse)
        {
        SysFreeString(g_bstrResponse);
        g_bstrResponse = NULL;
        }
    if (g_bstrServer)
        {
        SysFreeString(g_bstrServer);
        g_bstrServer = NULL;
        }
    if (g_bstrCertificate)
        {
        SysFreeString(g_bstrCertificate);
        g_bstrCertificate = NULL;
        }
    if (g_bstrSession)
        {
        SysFreeString(g_bstrSession);
        g_bstrSession = NULL;
        }
    if (g_bstrScriptingNamespace)
        {
        SysFreeString(g_bstrScriptingNamespace);
        g_bstrScriptingNamespace = NULL;
        }
    if (g_bstrObjectContext)
        {
        SysFreeString(g_bstrObjectContext);
        g_bstrObjectContext = NULL;
        }
    return S_OK;
    }

// Cached typeinfo's
ITypeInfo   *g_ptinfoIDispatch = NULL;              // Cache IDispatch typeinfo
ITypeInfo   *g_ptinfoIUnknown = NULL;               // Cache IUnknown typeinfo
ITypeInfo   *g_ptinfoIStringList = NULL;            // Cache IStringList typeinfo
ITypeInfo   *g_ptinfoIRequestDictionary = NULL;     // Cache IRequestDictionary typeinfo
ITypeInfo   *g_ptinfoIReadCookie = NULL;            // Cache IReadCookie typeinfo
ITypeInfo   *g_ptinfoIWriteCookie = NULL;           // Cache IWriteCookie typeinfo

/*===================================================================
CacheStdTypeInfos

This is kindofa funny OA-threading bug workaround and perf improvement.
Because we know that they typinfo's for IUnknown and IDispatch are
going to be used like mad, we will load them on startup and keep
them addref'ed.  Without this, OA would be loading and unloading
their typeinfos on almost every Invoke.

Also, cache denali's typelib so everyone can get at it, and
cache tye typeinfo's of all our non-top-level intrinsics.

Returns:
    HRESULT - S_OK on success
    
Side effects:
===================================================================*/
HRESULT CacheStdTypeInfos()
    {
    HRESULT hr = S_OK;
    ITypeLib *pITypeLib = NULL;
    CMBCSToWChar    convStr;

    /*
     * Load the typeinfos for IUnk and IDisp
     */
    hr = LoadRegTypeLib(IID_StdOle,
                 STDOLE2_MAJORVERNUM,
                 STDOLE2_MINORVERNUM,
                 STDOLE2_LCID,
                 &pITypeLib);
    if (hr != S_OK)
        {
        hr = LoadTypeLibEx(OLESTR("stdole2.tlb"), REGKIND_DEFAULT, &pITypeLib);
        }

    hr = pITypeLib->GetTypeInfoOfGuid(IID_IDispatch, &g_ptinfoIDispatch);
    if (SUCCEEDED(hr))
        {
        hr = pITypeLib->GetTypeInfoOfGuid(IID_IUnknown, &g_ptinfoIUnknown);
        }

    pITypeLib->Release();
    pITypeLib = NULL;

    if (FAILED(hr))
        goto LFail;

    /*
     * Load denali's typelibs.  Save them in Glob.
     */
     
    /*
     * The type libraries are registered under 0 (neutral),
     * and 9 (English) with no specific sub-language, which
     * would make them 407 or 409 and such.
     * If we become sensitive to sub-languages, then use the
     * full LCID instead of just the LANGID as done here.
     */

    char szPath[MAX_PATH + 4];
        
    // Get the path for denali so we can look for the TLB there.
    if (!GetModuleFileNameA(g_hinstDLL, szPath, MAX_PATH))
        return E_FAIL;
    
    if (FAILED(hr = convStr.Init(szPath)))
        goto LFail;

    hr = LoadTypeLibEx(convStr.GetString(), REGKIND_DEFAULT, &pITypeLib);

    // Since it's presumably in our DLL, make sure that we loaded it.
    Assert (SUCCEEDED(hr));
    if (FAILED(hr))
        goto LFail;

    // Save it in Glob
    gGlob.m_pITypeLibDenali = pITypeLib;

    // now load the txn type lib

    strcat(szPath, "\\2");

    if (FAILED(hr = convStr.Init(szPath)))
        goto LFail;

    hr = LoadTypeLibEx(convStr.GetString(), REGKIND_DEFAULT, &pITypeLib);

    // Since it's presumably in our DLL, make sure that we loaded it.
    Assert (SUCCEEDED(hr));
    if (FAILED(hr))
        goto LFail;

    // Save it in Glob
    gGlob.m_pITypeLibTxn = pITypeLib;

    /*
     * Now cache the typeinfo's of all non-top-level intrinsics
     * This is for the OA workaround and for performance.
     */
    hr = gGlob.m_pITypeLibDenali->GetTypeInfoOfGuid(IID_IStringList, &g_ptinfoIStringList);
    if (FAILED(hr))
        goto LFail;
    hr = gGlob.m_pITypeLibDenali->GetTypeInfoOfGuid(IID_IRequestDictionary, &g_ptinfoIRequestDictionary);
    if (FAILED(hr))
        goto LFail;
    hr = gGlob.m_pITypeLibDenali->GetTypeInfoOfGuid(IID_IReadCookie, &g_ptinfoIReadCookie);
    if (FAILED(hr))
        goto LFail;
    hr = gGlob.m_pITypeLibDenali->GetTypeInfoOfGuid(IID_IWriteCookie, &g_ptinfoIWriteCookie);
    if (FAILED(hr))
        goto LFail;

LFail:
    return(hr);
    }

/*===================================================================
UnCacheStdTypeInfos

Release the typeinfo's we have cached for IUnknown and IDispatch
and the denali typelib and the other cached stuff.

Returns:
    HRESULT - S_OK on success
    
Side effects:
===================================================================*/
HRESULT UnCacheStdTypeInfos()
    {
    ITypeInfo **ppTypeInfo;

    // Release the typeinfos for IUnk and IDisp
    if (g_ptinfoIDispatch)
        {
        g_ptinfoIDispatch->Release();
        g_ptinfoIDispatch = NULL;
        }
    if (g_ptinfoIUnknown)
        {
        g_ptinfoIUnknown->Release();
        g_ptinfoIDispatch = NULL;
        }

    // Let go of the cached Denali typelibs
    Glob(pITypeLibDenali)->Release();
    Glob(pITypeLibTxn)->Release();

    // Let go of other cached typeinfos
    g_ptinfoIStringList->Release();
    g_ptinfoIRequestDictionary->Release();
    g_ptinfoIReadCookie->Release();
    g_ptinfoIWriteCookie->Release();

    return(S_OK);
    }

/*===================================================================
InitODBC

Based on the registry Entry value for StartConnectionPool
we will initialize the ODBC Connection Pool. 
This initialization requires no un-init call

StartConnectionPool = TRUE - turn on connection pooling
StartConnectionPool = FALSE

Returns:
    Void - no return value
===================================================================*/
/*void InitODBC(void)
    {
        
    if (!Glob(fStartConnectionPool))
        return;
        
    signed short    rc;

    // define the function pointer type     
    typedef signed short(CALLBACK *PFNSQLSetEnvAttr)
                        (
                        DWORD, DWORD, void*, DWORD
                        );  

    // declare the function pointer
    PFNSQLSetEnvAttr pfnSQLSetEnvAttr;
    g_hODBC32Lib = LoadLibrary("odbc32.dll");
    if(g_hODBC32Lib)
        {
        pfnSQLSetEnvAttr = (PFNSQLSetEnvAttr) GetProcAddress(g_hODBC32Lib, "SQLSetEnvAttr");        

        if (pfnSQLSetEnvAttr)
            rc = (*pfnSQLSetEnvAttr)(0UL, 201UL, (void*)2UL, 0UL);      
            // rc = SQLSetEnvAttr(SQL_NULL_HENV, SQL_ATTR_CONNECTION_POOLING, (void*)SQL_CP_ONE_PER_HENV,0)         
            // I did not want to include all of the SQL h files so I hard-coded the values
            // for the constants
            
        }   
    }   
*/
/*===================================================================
UnInitODBC

Based on the registry Entry value for StartConnectionPool
we will free the odbc32.dll that was loaded with InitODBC

StartConnectionPool = TRUE - turn on connection pooling
StartConnectionPool = FALSE


Returns:
    Void - no return value
===================================================================*/
/*      
void UnInitODBC(void)
    {       
    if (!Glob(fStartConnectionPool))
        return;
        
    if (g_hODBC32Lib)
        FreeLibrary(g_hODBC32Lib);  
    }   
*/
/*===================================================================
MakeAspCookieName

Creates the asp cookie name as concatination of standard prefix and
current process id.

This function is called once per ASP.DLL (oon DllInit())

Parameters:
    szCookie        [out] Put cookie name here

Returns:
    NOTHING
===================================================================*/
static void MakeAspCookieName(char *szCookie)
    {
    // Standard prefix
    strcpy(szCookie, SZ_SESSION_ID_COOKIE_PREFIX);
    szCookie += CCH_SESSION_ID_COOKIE_PREFIX;

    // Process ID
    sprintf(szCookie, "%08x", GetCurrentProcessId());

    // Uppercase
    strupr(szCookie);

    // Change digits to letters
    static const char *pszDigitsToLetters[2] = {"GHIJKLMNOP","QRSTUVWXYZ"};
    for (int i = 0; i < 8; i++)
        {
        int ch = szCookie[i];
        if (ch >= '0' && ch <= '9')
            szCookie[i] = pszDigitsToLetters[rand() % 2][ch - '0'];
        }
    }

/*===================================================================
SendHtmlSubstitute

Send the html file named XXX_ASP.HTM instead of rejecting the
request.

Parameters:
    pIReq       CIsapiReqInfo

Returns:
    HRESULT     (S_FALSE = no html substitute found)
===================================================================*/
HRESULT SendHtmlSubstitute(CIsapiReqInfo    *pIReq)
    {
    TCHAR *szAspPath = pIReq->QueryPszPathTranslated();
    DWORD cchAspPath = pIReq->QueryCchPathTranslated();

    // verify file name
    if (cchAspPath < 4 || cchAspPath > MAX_PATH || 
        _tcsicmp(szAspPath + cchAspPath - 4, _T(".asp")) != 0)
        {
        return S_FALSE;
        }

    // construct path of the html file
    TCHAR szHtmPath[MAX_PATH+5];
    DWORD cchHtmPath = cchAspPath + 4;
    _tcscpy(szHtmPath, szAspPath);
    szHtmPath[cchAspPath - 4] = _T('_');
    _tcscpy(szHtmPath + cchAspPath, _T(".htm"));

    // check if the html file exists
    if (FAILED(AspGetFileAttributes(szHtmPath)))
        return S_FALSE;

    return CResponse::SyncWriteFile(pIReq, szHtmPath);
    }
       


#ifdef LOG_FCNOTIFICATIONS
// UNDONE get this from registry
LPSTR   g_szNotifyLogFile = "C:\\Temp\\AspNotify.Log";
HANDLE  g_hfileNotifyLog;
HANDLE  g_hmapNotifyLog;
char*   g_pchNotifyLogStart;
char*   g_pchNotifyLogCurrent;
LPSTR   g_szNotifyPrefix = "File change notification: ";
LPSTR   g_szCreateHandlePrefix = "Create handle: ";

void LfcnCreateLogFile()
    {
    DWORD   dwErrCode;

    if(INVALID_HANDLE_VALUE != (g_hfileNotifyLog = 
                                CreateFile( 
                                            g_szNotifyLogFile,              // file name
                                            GENERIC_READ | GENERIC_WRITE,   // access (read-write) mode
                                            FILE_SHARE_READ,        // share mode
                                            NULL,                   // pointer to security descriptor
                                            CREATE_ALWAYS,          // how to create
                                            FILE_ATTRIBUTE_NORMAL,  // file attributes
                                            NULL                    // handle to file with attributes to copy
                                           )))
        {
        BYTE    rgb[0x10000];
        DWORD   cb = sizeof( rgb );
        DWORD   cbWritten = 0;
//      FillMemory( rgb, cb, 0xAB );

        WriteFile(
                    g_hfileNotifyLog,   // handle to file to write to 
                    rgb,                // pointer to data to write to file 
                    cb,                 // number of bytes to write 
                    &cbWritten,         // pointer to number of bytes written 
                    NULL                // pointer to structure needed for overlapped I/O
                   );

        if(NULL != (g_hmapNotifyLog = 
                    CreateFileMapping(
                                        g_hfileNotifyLog,       // handle to file to map 
                                        NULL,           // optional security attributes 
                                        PAGE_READWRITE,     // protection for mapping object 
                                        0,              // high-order 32 bits of object size  
                                        100,                // low-order 32 bits of object size  
                                        NULL            // name of file-mapping object 
                                    )))
            {
            if(NULL != (g_pchNotifyLogStart = 
                        (char*) MapViewOfFile(
                                                g_hmapNotifyLog,        // file-mapping object to map into address space
                                                FILE_MAP_WRITE, // access mode  
                                                0,              // high-order 32 bits of file offset 
                                                0,              // low-order 32 bits of file offset 
                                                0               // number of bytes to map 
                                            )))
                {
                *g_pchNotifyLogStart = '\0';
                g_pchNotifyLogCurrent = g_pchNotifyLogStart;
                LfcnAppendLog( "ASP change-notifications log file \r\n" );
                LfcnAppendLog( "================================= \r\n" );
                DBGPRINTF((DBG_CONTEXT,  "Notifications log file created and mapped.\r\n" ));
                return;
                }
            }
        }

    dwErrCode = GetLastError();
    DBGERROR((DBG_CONTEXT, "Failed to create notifications log file; last error was %d\r\n", szErrCode));
    }
    
void LfcnCopyAdvance(char** ppchDest, const char* sz)
    {
    // UNDONE make this robust (WriteFile to extend file?)
    strcpy( *ppchDest, sz );
    *ppchDest += strlen( sz );
    }

void LfcnAppendLog(const char* sz)
    {
    LfcnCopyAdvance( &g_pchNotifyLogCurrent, sz );
    DBGPRINTF((DBG_CONTEXT, "%s", sz));
    }

void LfcnLogNotification(char* szFile)
    {
    LfcnAppendLog( g_szNotifyPrefix );
    LfcnAppendLog( szFile );
    LfcnAppendLog( "\r\n" );
    }

void LfcnLogHandleCreation(int i, char* szApp)
    {
    char    szIndex[5];
    _itoa( i, szIndex, 10);

    LfcnAppendLog( g_szCreateHandlePrefix );
    LfcnAppendLog( szIndex );
    LfcnAppendLog( "\t" );
    LfcnAppendLog( szApp );
    LfcnAppendLog( "\r\n" );
    }

void LfcnUnmapLogFile()
    {
    if(g_pchNotifyLogStart != NULL)
        UnmapViewOfFile(g_pchNotifyLogStart);
        
    if(g_hmapNotifyLog!= NULL)
        CloseHandle(g_hmapNotifyLog);
        
    if(g_hfileNotifyLog != NULL && g_hfileNotifyLog != INVALID_HANDLE_VALUE)
        CloseHandle( g_hfileNotifyLog );
        
    g_pchNotifyLogStart = NULL;
    g_hmapNotifyLog = NULL;
    g_hfileNotifyLog = NULL;
    }

#endif  //LOG_FCNOTIFICATIONS

#if _IIS_5_1
LONG CWamModule::Lock()
{
    return CComModule::Lock();
}

LONG CWamModule::Unlock()
{
    return CComModule::Unlock();
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\denpre.h ===
#pragma warning(disable:4237)
#pragma warning(disable:4162)
#undef _WIN32_WINNT
#define _WIN32_WINNT    0x0400
#define _CRYPT32_

#include <ctype.h>
#include <stdlib.h>     // for itow
#include <string.h>
#include <mbstring.h>   // string functions (DBCS)
#include <crtdbg.h>
#include <malloc.h>
#include <time.h>
#include <stdio.h>
#include <limits.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winerror.h>
#include <wtypes.h>
#include <process.h>

#include <rpc.h>
#include <rpcndr.h>
#include <ole2.h>
#include <olectl.h>
#include <oleauto.h>
#include <cguid.h>      // for GUID_NULL
#include <new.h>

#include <iis64.h>
#include <iisextp.h>

#if _IIS_6_0
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#endif

#include <dbgutil.h>

#include "except.h"
#include "isapireq.h"
#include "Denali.h"
#include "applmgr.h"
#include "sessmgr.h"
#include "hitobj.h"
#include "debug.h"
#include "error.h"
#include "eventlog.h"
#include "resource.h"
#include "compcol.h"
#include "scrptmgr.h"
#include "template.h"
#include "cachemgr.h"
#include "glob.h"
#include "scrptmgr.h"
#include "fileapp.h"
#include "util.h"
#include "fileapp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\dispatch.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: IDispatch implementation

File: Dispatch.h

Owner: DGottner

This file contains our implementation of IDispatch
===================================================================*/

#ifndef _Dispatch_H
#define _Dispatch_H

/*
 * C D i s p a t c h
 *
 * IDispatch interface implementation for OLE objects
 *
 * This class contains the basic four IDispatch members.  The Big Three
 * (QueryInterface, AddRef, Release) are left as pure virtual, as this
 * class is designed as an intermediate class for further derivation.
 *
 * This also means that we no longer need a pointer to the controlling unknown.
 */

class CDispatch : public IDispatch
	{
private:
	const GUID *	m_pGuidDispInterface;
	ITypeLib *		m_pITypeLib;
	ITypeInfo *		m_pITINeutral;

public:

	CDispatch();
	~CDispatch();

	// Do this in Init because OLE interfaces in general do not take
	// parameters in the constructor.  This call CANNOT fail, however.
	//
	void Init(const IID &GuidDispInterface, const ITypeLib *pITypeLib = NULL);

	// IDispatch members
	//
	STDMETHODIMP GetTypeInfoCount(UINT *);
	STDMETHODIMP GetTypeInfo(UINT, LCID, ITypeInfo **);
	STDMETHODIMP GetIDsOfNames(REFIID, OLECHAR **, UINT, LCID, DISPID *);
	STDMETHODIMP Invoke(DISPID, REFIID, LCID, WORD,
						DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *);
	};


/*
 * C S u p p o r t E r r o r I n f o
 *
 * Implemention of ISupportErrorInfo for Denali classes
 */

class CSupportErrorInfo : public ISupportErrorInfo
	{
private:
	IUnknown *	m_pUnkObj;
	IUnknown *	m_pUnkOuter;
	const GUID *m_pGuidDispInterface;

public:
	CSupportErrorInfo(void);
	CSupportErrorInfo(IUnknown *pUnkObj, IUnknown *pUnkOuter, const IID &GuidDispInterface);
	void Init(IUnknown *pUnkObj, IUnknown *pUnkOuter, const GUID &GuidDispInterface);

	// IUnknown members that delegate to m_pUnkOuter.
	//
	STDMETHODIMP		 QueryInterface(REFIID, void **);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

	// ISupportErrorInfo members
	//
	STDMETHODIMP InterfaceSupportsErrorInfo(REFIID);
	};


extern void Exception(REFIID ObjID, LPOLESTR strSource, LPOLESTR strDescr);
extern void ExceptionId(REFIID ObjID, UINT SourceID, UINT DescrID, HRESULT hrCode = S_OK);

#endif /* _Dispatch_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\denver.h ===
#include <winver.h>
#include "ntverp.h"

/*------------------------------------------------------------------------------*/
/* the following section defines values used in the version			*/
/* data structure for all files, and which do not change.			*/
/*------------------------------------------------------------------------------*/
#ifndef VER_FILETYPE
#define VER_FILETYPE                VFT_DLL
#endif

#ifndef DLL_VER
#define VER_FILEDESCRIPTION_STR     "Active Server Pages"
#define VER_INTERNALNAME_STR        "asp.dll"
#define VER_ORIGINALFILENAME_STR    "asp.dll"

#endif //DLL_VER

#include "iisver.h"

#include "common.ver"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\disptch2.h ===
#ifndef __DISPTCH2_H__
#define __DISPTCH2_H__

#include "dispatch.h"
#include "asptxn.h"

template <class T>
class ATL_NO_VTABLE CDispatchImpl : public T
{
public:
// IDispatch
	STDMETHOD(GetTypeInfoCount)(UINT* pctinfo)
	{
		*pctinfo = 1;
		return S_OK;
	}
	STDMETHOD(GetTypeInfo)(UINT itinfo, LCID lcid, ITypeInfo** pptinfo)
	{
		return gm_tih.GetTypeInfo(itinfo, lcid, pptinfo);
	}
	STDMETHOD(GetIDsOfNames)(REFIID riid, LPOLESTR* rgszNames, UINT cNames,
		LCID lcid, DISPID* rgdispid)
	{
		return gm_tih.GetIDsOfNames(riid, rgszNames, cNames, lcid, rgdispid);
	}
	STDMETHOD(Invoke)(DISPID dispidMember, REFIID riid,
		LCID lcid, WORD wFlags, DISPPARAMS* pdispparams, VARIANT* pvarResult,
		EXCEPINFO* pexcepinfo, UINT* puArgErr)
	{
		// VBScript does not distinguish between a propget and a method
		// implement that behavior for other languages.
		//
		if (wFlags & (DISPATCH_METHOD | DISPATCH_PROPERTYGET))
			wFlags |= DISPATCH_METHOD | DISPATCH_PROPERTYGET;

		return gm_tih.Invoke((IDispatch*)this, dispidMember, riid, lcid,
                           wFlags, pdispparams, pvarResult, pexcepinfo,
                           puArgErr);
	}
protected:
	static CComTypeInfoHolder gm_tih;
	static HRESULT GetTI(LCID lcid, ITypeInfo** ppInfo)
	{
		return gm_tih.GetTI(lcid, ppInfo);
	}
};

typedef CDispatchImpl<IApplicationObject>   IApplicationObjectImpl;
typedef CDispatchImpl<IASPError>            IASPErrorImpl;
typedef CDispatchImpl<IReadCookie>          IReadCookieImpl;
typedef CDispatchImpl<IRequest>             IRequestImpl;
typedef CDispatchImpl<IRequestDictionary>   IRequestDictionaryImpl;
typedef CDispatchImpl<IResponse>            IResponseImpl;
typedef CDispatchImpl<IScriptingContext>    IScriptingContextImpl;
typedef CDispatchImpl<IServer>              IServerImpl;
typedef CDispatchImpl<ISessionObject>       ISessionObjectImpl;
typedef CDispatchImpl<IStringList>          IStringListImpl;
typedef CDispatchImpl<IVariantDictionary>   IVariantDictionaryImpl;
typedef CDispatchImpl<IWriteCookie>         IWriteCookieImpl;
typedef CDispatchImpl<IASPObjectContext>    IASPObjectContextImpl;

#endif // __DISPTCH2_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\except.h ===
/*-----------------------------------------------------------------------------
Microsoft Denali

Microsoft Confidential
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Exception Handling

File: Except.h

Owner: DGottner

Exception handling macros implemented via Win32 structured exceptions.

Usage:

	TRY
		<try block>

	CATCH (<exception variable>)
		<exception handler>

	END_TRY

To throw an exception use "THROW (<integer expression>)"

To set up a termination handler use:

	TRY
		<try block>

	FINALLY
		<termination handler>

	END_TRY

Rationale:
	This macro package offers a strict subset of Win32 structured exception
	handling. There is no support for exception filters (you have to rethrow
	exceptions), and no support for the resumption model of exception handling
	(though Win32 supports the resumption model)

	The purpose for these restrictions is to make it very easy to rewrite the
	exception handling macros for use with other exception throwing mechanisms.
	It would be easy to use this same interface with C++ exceptions or
	setjmp/longjmp.

	The braces with TRY, CATCH, and FINALLY are optional. Since this code is
	structured using self-bracketing constructs, the braces seem redundant.

	There is no need to declare the datatype of the <exception variable>
	because it is always an integer.
-----------------------------------------------------------------------------*/

#ifndef _EXCEPT_H
#define _EXCEPT_H

// Pragmas --------------------------------------------------------------------
//
// Turn off the "signed/unsigned conversion" warning off because it we get this
// all the time that we throw an HRESULT. (which is a harmless thing)  The
// warning is usually benign anyway.


#pragma warning(disable: 4245)


// Macros ---------------------------------------------------------------------

#define TRY	               __try {
#define CATCH(nException)  } __except(1) { DWORD nException = GetExceptionCode();
#define FINALLY            } __finally {
#define END_TRY            }

#define THROW(nException)  RaiseException(nException, 0, 0, NULL)

#endif // _EXCEPT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\error.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Error handling

File: Error.h

Owner: AndrewS

Include file for general error reporting routines for Denali.
===================================================================*/

#ifndef __ERROR_H
#define __ERROR_H

#include "hitobj.h"
#include "scrptmgr.h"




#define MAX_RESSTRINGSIZE		1024
// bug 840: must use these in both HandleErrorSz and CTemplate
#define	SZ_BREAKBOLD	"<BR><B>"
#define	SZ_UNBREAKBOLD	"<BR></B>"
const UINT	CCH_BREAKBOLD = strlen(SZ_BREAKBOLD);
const UINT	CCH_UNBREAKBOLD = strlen(SZ_UNBREAKBOLD);


/* format of default mask

32 bits

	31				16		8	4	0

	bit 0 - 4	default sink/output places.
	bit 0		NT Event Log
	bit 1		IIS log
	bit 2		Browser
	bit 3		Reserved

	bit 5 - 8	default predefined messages.(from registry)
	bit 5		use generic AccessDenied Message
	bit 6		use generic ScriptError Message
	bit 7 - 8	Reserved

	bit 9 - 10	to browser templates.(4 templates available)
				0x00	Default Script Template
				0x01	Empty Template/No Template
				0x10	System Template(mimic IIS style to Browser on HTTP errors, 204, 404, 500)
				0x11	Reserved
				
	bit 11 - 31	Reserved

*/
#define		ERR_LOGTONT					0x00000001
#define		ERR_LOGTOIIS				0x00000002
#define		ERR_LOGTOBROWSER			0x00000004

//Format(Script style is default, SYS style is for System error, 204, 404 and 500)
#define		ERR_FMT_SCRIPT				0x00000000
#define		ERR_FMT_SYS					0x00000200

#define		ERR_SetNoLogtoNT(x)			((x) & 0xfffffffe)
#define		ERR_SetNoLogtoIIS(x)		((x) & 0xfffffffd)
#define		ERR_SetNoLogtoBrowser(x)	((x) & 0xfffffffb)

#define		ERR_SetLogtoNT(x)			((x) | ERR_LOGTONT)
#define		ERR_SetLogtoIIS(x)			((x) | ERR_LOGTOIIS)
#define		ERR_SetLogtoBrowser(x)		((x) | ERR_LOGTOBROWSER)

#define		ERR_FLogtoNT(x)				((x) & ERR_LOGTONT)
#define		ERR_FLogtoIIS(x)			((x) & ERR_LOGTOIIS)
#define		ERR_FLogtoBrowser(x)		((x) & ERR_LOGTOBROWSER)
#define		ERR_FIsSysFormat(x)			((x) & ERR_FMT_SYS)

#define		ERR_SetSysFormat(x)			((x) | ERR_FMT_SYS)

//The order of the index is the order we send to the browser.(exclude header).
#define 	Im_szEngine				0
#define		Im_szErrorCode			1
#define 	Im_szShortDescription	2
#define 	Im_szFileName			3
#define 	Im_szLineNum			4
#define		Im_szCode				5
#define		Im_szLongDescription	6
#define		Im_szHeader				7
#define		Im_szItemMAX			8

// ASP HTTP sub-error codes for custom 500 errors
#define     SUBERRORCODE500_SERVER_ERROR             0
#define     SUBERRORCODE500_SHUTTING_DOWN           11
#define     SUBERRORCODE500_RESTARTING_APP          12
#define     SUBERRORCODE500_SERVER_TOO_BUSY         13
#define     SUBERRORCODE500_INVALID_APP             14
#define     SUBERRORCODE500_GLOBALASA_FORBIDDEN     15

class CErrInfo
	{
	friend HRESULT ErrHandleInit(void);
	friend HRESULT ErrHandleUnInit(void);
	friend HRESULT GetSpecificError(CErrInfo *pErrInfo,
									HRESULT hrError);
									
	friend HRESULT HandleSysError(	DWORD dwHttpError,
                                    DWORD dwHttpSubError,
	                                UINT ErrorID,
									UINT ErrorHeaderID,
									CIsapiReqInfo   *pIReq,
									CHitObj *pHitObj);

	friend HRESULT HandleOOMError(	CIsapiReqInfo   *pIReq,
									CHitObj *pHitObj);

	friend HRESULT HandleError(	CHAR *szShortDes,
								CHAR *szLongDes,
								DWORD mask,
								CHAR *szFileName, 
								CHAR *szLineNum, 
								CHAR *szEngine, 
								CHAR *szErrCode,
								CIsapiReqInfo   *pIReq, 
								CHitObj *pHitObj);

	friend HRESULT HandleError( IActiveScriptError *pscripterror,
								CTemplate *pTemplate,
								DWORD dwEngineID,
								CIsapiReqInfo   *pIReq, 
								CHitObj *pHitObj);

	friend HRESULT HandleError(	UINT ErrorID,
								CHAR *szFileName, 
								CHAR *szLineNum, 
								CHAR *szEngine,
								CHAR *szErrCode,
								CHAR *szLongDes,
								CIsapiReqInfo   *pIReq, 
								CHitObj *pHitObj,
                                va_list *pArgs = NULL);
	public:
		CErrInfo();

		inline LPSTR GetItem(DWORD iItem) { return m_szItem[iItem]; }
		inline void   GetLineInfo(BSTR *pbstrLineText, int *pnColumn)
			{ *pbstrLineText = m_bstrLineText, *pnColumn = m_nColumn; }

	private:
		//sink, either via CResponse(also use CIsapiReqInfo), or via WAM_EXEC_INFO
		CIsapiReqInfo               *m_pIReq;
		CHitObj						*m_pHitObj;

		// HTTP error code (404, 500, etc.) and sub error code
		DWORD                       m_dwHttpErrorCode;
		DWORD                       m_dwHttpSubErrorCode;
		
		//mask
		DWORD						m_dwMask;

		//data
		LPSTR						m_szItem[Im_szItemMAX];

		//line data (don't use m_szItem[] because data is BSTR
		BSTR						m_bstrLineText;
		int							m_nColumn;
		
		HRESULT						LogError();
		HRESULT						LogError(DWORD dwMask, LPSTR *szErrorString);
		
		HRESULT						LogErrortoNTEventLog(BOOL, BOOL);
		HRESULT						LogErrortoIISLog(BOOL *, BOOL *);
		HRESULT						LogErrortoBrowserWrapper();
		HRESULT						LogErrortoBrowser(CResponse *pResponse);
		HRESULT						LogErrortoBrowser(CIsapiReqInfo   *pIReq);
        HRESULT	                    LogCustomErrortoBrowser(CIsapiReqInfo   *pIReq, BOOL *pfCustomErrorProcessed);
		void						WriteHTMLEncodedErrToBrowser(const CHAR *StrIn, CResponse *pResponse, CIsapiReqInfo   *pIReq);
        HRESULT                     WriteCustomFileError(CIsapiReqInfo   *pIReq, TCHAR *szPath, TCHAR *szMimeType);
        HRESULT                     WriteCustomURLError(CIsapiReqInfo   *pIReq, TCHAR *szURL);
		
		HRESULT						ParseResourceString(CHAR *sz);
	};


//Error Handling APIs
//Case 1.a: Runtime Script Error(From Denali, VBS, JavaScript, or anyother Engines).
//example. Called by OnScriptError.
HRESULT HandleError( IActiveScriptError *pscripterror,
					 CTemplate *pTemplate,
					 DWORD dwEngineID,
					 CIsapiReqInfo   *pIReq, 
					 CHitObj *pHitObj );

//Case 1.b: Runtime Script Error(From Denali, VBS, JavaScript, or anyother Engines).
// Show error in debugger rather than the standard error logging.
HRESULT DebugError( IActiveScriptError *pScriptError, CTemplate *pTemplate, DWORD dwEngineID, IDebugApplication *pDebugApp);

//Case 2: Compiling time Script Error, 
//Also, this function is the most generic HandleError.
HRESULT HandleError(	CHAR *szShortDes,
						CHAR *szLongDes,
						DWORD dwMask,
						CHAR *szFileName, 
						CHAR *szLineNum, 
						CHAR *szEngine, 
						CHAR *szErrCode,
						CIsapiReqInfo   *pIReq, 
						CHitObj *pHitObj);

//Case 3: Predefined Error ID
HRESULT	HandleError(	UINT ErrorID,
						CHAR *szFileName, 
						CHAR *szLineNum, 
						CHAR *szEngine,
						CHAR *szErrCode,
						CHAR *szLongDes,
						CIsapiReqInfo   *pIReq, 
						CHitObj *pHitObj,
                        va_list *pArgs);
						
//Case 4: SystemDefined Error(so far, only 204, 404, and 500 can use this call)
//		 Implementation of this call will first send out the header, if ErrorHeaderID is not 0.
HRESULT HandleSysError(	DWORD dwHttpError,
                        DWORD dwHttpSubError,
                        UINT ErrorID,
						UINT ErrorHeaderID,
						CIsapiReqInfo   *pIReq,
						CHitObj *pHitObj);

// 500 Error processing calls HandleSysError()
HRESULT Handle500Error( UINT ErrorID, CIsapiReqInfo   *pIReq);
						
//OOM, special attention, because Heap is full, and therefore, no dynamic allocation						
HRESULT HandleOOMError(	CIsapiReqInfo   *pIReq,
						CHitObj *pHitObj);

//FileName missing
//		The caller has no file name, nor any other info about where or when
//		the error occurred.  Trys to get the filename from the hitobj
VOID HandleErrorMissingFilename(UINT    errorID, 
                                CHitObj *pHitObj,
                                BOOL    fVarArgs = FALSE,
                                ...);

//The following 2 calls are discouraged for error-handling usage.  
//Use one of the Error Handling APIs instead.
//Ok when loading other strings from resource file.
INT CchLoadStringOfId(UINT id, CHAR *sz, INT cchMax);
INT CwchLoadStringOfId(UINT id, WCHAR *sz, INT cchMax);


HRESULT ErrHandleInit(void);
HRESULT ErrHandleUnInit(void);

HRESULT	LoadErrResString(UINT ErrID/*IN*/, DWORD *dwMask, CHAR *szErrorCode, CHAR *szShortDes, CHAR *LongDes);
CHAR *SzScodeToErrorCode(HRESULT hrError);

BOOL HResultToWsz(HRESULT hrIn, WCHAR *wszOut, DWORD cdwOut);
BOOL HResultToSz(HRESULT hrIn, CHAR *szOut, DWORD cdwOut);


#endif __ERROR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\dispatch.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: IDispatch implementation

File: Dispatch.h

Owner: DGottner

This file contains our implementation of IDispatch
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "dispatch.h"
#include "asptlb.h"

#include "memchk.h"

#ifdef USE_LOCALE
extern DWORD	 g_dwTLS;
#endif

CComTypeInfoHolder CDispatchImpl<IApplicationObject>::gm_tih = {&__uuidof(T), &LIBID_ASPTypeLibrary, 3, 0, NULL, 0, NULL, 0};
CComTypeInfoHolder CDispatchImpl<IASPError>::gm_tih = {&__uuidof(T), &LIBID_ASPTypeLibrary, 3, 0, NULL, 0, NULL, 0};
CComTypeInfoHolder CDispatchImpl<IReadCookie>::gm_tih = {&__uuidof(T), &LIBID_ASPTypeLibrary, 3, 0, NULL, 0, NULL, 0};
CComTypeInfoHolder CDispatchImpl<IRequest>::gm_tih = {&__uuidof(T), &LIBID_ASPTypeLibrary, 3, 0, NULL, 0, NULL, 0};
CComTypeInfoHolder CDispatchImpl<IRequestDictionary>::gm_tih = {&__uuidof(T), &LIBID_ASPTypeLibrary, 3, 0, NULL, 0, NULL, 0};
CComTypeInfoHolder CDispatchImpl<IResponse>::gm_tih = {&__uuidof(T), &LIBID_ASPTypeLibrary, 3, 0, NULL, 0, NULL, 0};
CComTypeInfoHolder CDispatchImpl<IScriptingContext>::gm_tih = {&__uuidof(T), &LIBID_ASPTypeLibrary, 3, 0, NULL, 0, NULL, 0};
CComTypeInfoHolder CDispatchImpl<IServer>::gm_tih = {&__uuidof(T), &LIBID_ASPTypeLibrary, 3, 0, NULL, 0, NULL, 0};
CComTypeInfoHolder CDispatchImpl<ISessionObject>::gm_tih = {&__uuidof(T), &LIBID_ASPTypeLibrary, 3, 0, NULL, 0, NULL, 0};
CComTypeInfoHolder CDispatchImpl<IStringList>::gm_tih = {&__uuidof(T), &LIBID_ASPTypeLibrary, 3, 0, NULL, 0, NULL, 0};
CComTypeInfoHolder CDispatchImpl<IVariantDictionary>::gm_tih = {&__uuidof(T), &LIBID_ASPTypeLibrary, 3, 0, NULL, 0, NULL, 0};
CComTypeInfoHolder CDispatchImpl<IWriteCookie>::gm_tih = {&__uuidof(T), &LIBID_ASPTypeLibrary, 3, 0, NULL, 0, NULL, 0};
CComTypeInfoHolder CDispatchImpl<IASPObjectContext>::gm_tih = {&__uuidof(T), &LIBID_ASPObjectContextTypeLibrary, 3, 0, NULL, 0, NULL, 0};

/*===================================================================
CDispatch::CDispatch
CDispatch::~CDispatch

Parameters (Constructor):
	pUnkObj			pointer to the object we're in.
	pUnkOuter		LPUNKNOWN to which we delegate.
===================================================================*/

CDispatch::CDispatch()
{
	m_pITINeutral = NULL;
	m_pITypeLib = NULL;
	m_pGuidDispInterface = NULL;
}

void CDispatch::Init
(
const GUID &GuidDispInterface,
const ITypeLib *pITypeLib		// = NULL
)
{
	m_pGuidDispInterface = &GuidDispInterface;
	m_pITypeLib = const_cast<ITypeLib *>(pITypeLib);
}

CDispatch::~CDispatch(void)
{
	ReleaseInterface(m_pITINeutral);
	return;
}


/*===================================================================
CDispatch::GetTypeInfoCount

Returns the number of type information (ITypeInfo) interfaces
that the object provides (0 or 1).

Parameters:
	pcInfo		UINT * to the location to receive
				the count of interfaces.

Return Value:
	HRESULT		 S_OK or a general error code.
===================================================================*/

STDMETHODIMP CDispatch::GetTypeInfoCount(UINT *pcInfo)
	{
	// We implement GetTypeInfo so return 1

	*pcInfo = 1;
	return S_OK;
	}


/*===================================================================
CDispatch::GetTypeInfo

Retrieves type information for the automation interface.	This
is used anywhere that the right ITypeInfo interface is needed
for whatever LCID is applicable.	Specifically, this is used
from within GetIDsOfNames and Invoke.

Parameters:
	itInfo			UINT reserved.	Must be zero.
	lcid			LCID providing the locale for the type
					information.	If the object does not support
					localization, this is ignored.
	ppITypeInfo		ITypeInfo ** in which to store the ITypeInfo
					interface for the object.

Return Value:
	HRESULT			S_OK or a general error code.
===================================================================*/

STDMETHODIMP CDispatch::GetTypeInfo(
	UINT itInfo,
	LCID lcid,
	ITypeInfo **ppITypeInfo
)
{
	HRESULT hr;
	ITypeInfo **ppITI = NULL;

    if (0 != itInfo)
		return ResultFromScode(TYPE_E_ELEMENTNOTFOUND);

	if (NULL == ppITypeInfo)
		return ResultFromScode(E_POINTER);

	*ppITypeInfo = NULL;

    // We don't internationalize the type library, so
    // we always return the same one, regardless of the locale.
    
	ppITI = &m_pITINeutral;

	//Load a type lib if we don't have the information already.
	if (NULL == *ppITI)
	{
		ITypeLib *pITL;
		
		// If a specific TypeLib was given at init time use that, otherwise default to the main one
		if (m_pITypeLib == NULL)
			pITL = Glob(pITypeLibDenali);
		else
			pITL = m_pITypeLib;
		Assert(pITL != NULL);
			
		hr = pITL->GetTypeInfoOfGuid(*m_pGuidDispInterface, ppITI);

		if (FAILED(hr))
			return hr;

		// Save the type info in a class member, so we don't have
		// go through all this work again;
		m_pITINeutral = *ppITI;
	}

	/*
	 * Note: the type library is still loaded since we have
	 * an ITypeInfo from it.
	 */
	(*ppITI)->AddRef();
	*ppITypeInfo = *ppITI;
	return S_OK;
}


/*===================================================================
CDispatch::GetIDsOfNames

Converts text names into DISPIDs to pass to Invoke

Parameters:
	riid			REFIID reserved. Must be IID_NULL.
	rgszNames		OLECHAR ** pointing to the array of names to be mapped.
	cNames			UINT number of names to be mapped.
	lcid			LCID of the locale.
	rgDispID		DISPID * caller allocated array containing IDs
					corresponging to those names in rgszNames.

Return Value:
	HRESULT		 S_OK or a general error code.
===================================================================*/

STDMETHODIMP CDispatch::GetIDsOfNames
(
	REFIID riid,
	OLECHAR **rgszNames,
	UINT cNames,
	LCID lcid,
	DISPID *rgDispID
)
{
	HRESULT hr;
	ITypeInfo *pTI;

	if (IID_NULL != riid)
		return ResultFromScode(DISP_E_UNKNOWNINTERFACE);

	//Get the right ITypeInfo for lcid.
	hr = GetTypeInfo(0, lcid, &pTI);

	if (SUCCEEDED(hr))
		{
		hr = DispGetIDsOfNames(pTI, rgszNames, cNames, rgDispID);
		pTI->Release();
    }

	return hr;
}


/*===================================================================
CDispatch::Invoke

Calls a method in the dispatch interface or manipulates a property.

Parameters:
	dispID			DISPID of the method or property of interest.
	riid			REFIID reserved, must be IID_NULL.
	lcid			LCID of the locale.
	wFlags			USHORT describing the context of the invocation.
	pDispParams		DISPPARAMS * to the array of arguments.
	pVarResult		VARIANT * in which to store the result.	Is
					NULL if the caller is not interested.
	pExcepInfo		EXCEPINFO * to exception information.
	puArgErr		UINT * in which to store the index of an
					invalid parameter if DISP_E_TYPEMISMATCH
					is returned.

Return Value:
	HRESULT		 S_OK or a general error code.
===================================================================*/

STDMETHODIMP CDispatch::Invoke
(
DISPID dispID,
REFIID riid,
LCID lcid,
unsigned short wFlags,
DISPPARAMS *pDispParams,
VARIANT *pVarResult,
EXCEPINFO *pExcepInfo,
UINT *puArgErr
)
{
	HRESULT hr;
	ITypeInfo *pTI;
	LANGID langID = PRIMARYLANGID(lcid);

	// riid is supposed to be IID_NULL always
	if (IID_NULL != riid)
		return ResultFromScode(DISP_E_UNKNOWNINTERFACE);

	// Get the ITypeInfo for lcid
	hr = GetTypeInfo(0, lcid, &pTI);

	if (FAILED(hr))
		return hr;

#ifdef USE_LOCALE
	// This saves the language ID for this thread
	TlsSetValue(g_dwTLS, &langID);
#endif

	// Clear exceptions
	SetErrorInfo(0L, NULL);

	// VBScript does not distinguish between a propget and a method
	// implement that behavior for other languages.
	//
	if (wFlags & (DISPATCH_METHOD | DISPATCH_PROPERTYGET))
		wFlags |= DISPATCH_METHOD | DISPATCH_PROPERTYGET;

	// This is exactly what DispInvoke does--so skip the overhead.
	// With dual interface, "this" is the address of the object AND its dispinterface
	//
	hr = pTI->Invoke(this, dispID, wFlags, 
					pDispParams, pVarResult, pExcepInfo, puArgErr);

	// Exception handling is done within ITypeInfo::Invoke

	pTI->Release();
	return hr;
}

/*===================================================================
CSupportErrorInfo::CSupportErrorInfo

Default constructor so that the Init method can be used.

Parameters (Constructor):
	pObj			PCResponse of the object we're in.
	pUnkOuter		LPUNKNOWN to which we delegate.
===================================================================*/
CSupportErrorInfo::CSupportErrorInfo(void)
:	m_pUnkObj(NULL),
	m_pUnkOuter(NULL)
	{
	}

/*===================================================================
CSupportErrorInfo::CSupportErrorInfo

Parameters (Constructor):
	pObj				PCResponse of the object we're in.
	pUnkOuter			LPUNKNOWN to which we delegate.
	GuidDispInterface	GUID of dispatch interface.
===================================================================*/

CSupportErrorInfo::CSupportErrorInfo(IUnknown *pUnkObj, IUnknown *pUnkOuter, const GUID &GuidDispInterface)
	{
	m_pUnkObj = pUnkObj;
	m_pUnkOuter = (pUnkOuter == NULL)? pUnkObj : pUnkOuter;
	m_pGuidDispInterface = &GuidDispInterface;
	}

/*===================================================================
void CSupportErrorInfo::Init

Parameters:
	pObj				PCResponse of the object we're in.
	pUnkOuter			LPUNKNOWN to which we delegate.
	GuidDispInterface	GUID of dispatch interface.

Returns:
	Nothing
===================================================================*/

void CSupportErrorInfo::Init(IUnknown *pUnkObj, IUnknown *pUnkOuter, const GUID &GuidDispInterface)
	{
	m_pUnkObj = pUnkObj;
	m_pUnkOuter = (pUnkOuter == NULL)? pUnkObj : pUnkOuter;
	m_pGuidDispInterface = &GuidDispInterface;
	}

/*===================================================================
CSupportErrorInfo::QueryInterface
CSupportErrorInfo::AddRef
CSupportErrorInfo::Release

IUnknown members for CSupportErrorInfo object.
===================================================================*/

STDMETHODIMP CSupportErrorInfo::QueryInterface(const GUID &Iid, void **ppvObj)
	{
	return m_pUnkOuter->QueryInterface(Iid, ppvObj);
	}

STDMETHODIMP_(ULONG) CSupportErrorInfo::AddRef(void)
	{
	return m_pUnkOuter->AddRef();
	}

STDMETHODIMP_(ULONG) CSupportErrorInfo::Release(void)
	{
	return m_pUnkOuter->Release();
	}



/*===================================================================
CSupportErrorInfo::InterfaceSupportsErrorInfo

Informs a caller whether or not a specific interface
supports exceptions through the Set/GetErrorInfo mechanism.

Parameters:
	riid			REFIID of the interface in question.

Return Value:
	HRESULT			S_OK if a call to GetErrorInfo will succeed
					for callers of riid. S_FALSE if not.
===================================================================*/
STDMETHODIMP CSupportErrorInfo::InterfaceSupportsErrorInfo
(
REFIID riid
)
	{
	if (IID_IDispatch == riid || *m_pGuidDispInterface == riid)
		return S_OK;

	return ResultFromScode(S_FALSE);
	}



/*===================================================================
Exception

Raises an exception using the CreateErrorInfo API and the
ICreateErrorInfo interface.

Note that this method doesn't allow for deferred filling
of an EXCEPINFO structure.

Parameters:
	strSource	LPOLESTR the exception source
	strDescr	LPOLESTR the exception description

Returns:
	Nothing
===================================================================*/

void Exception
(
REFIID ObjID,
LPOLESTR strSource,
LPOLESTR strDescr
)
	{
	HRESULT hr;
	ICreateErrorInfo *pICreateErr;
	IErrorInfo *pIErr;
	LANGID langID = LANG_NEUTRAL;

#ifdef USE_LOCALE
	LANGID *pLangID;
	
	pLangID = (LANGID *)TlsGetValue(g_dwTLS);

	if (NULL != pLangID)
		langID = *pLangID;
#endif

	/*
	 * Thread-safe exception handling means that we call
	 * CreateErrorInfo which gives us an ICreateErrorInfo pointer
	 * that we then use to set the error information (basically
	 * to set the fields of an EXCEPINFO structure.	We then
	 * call SetErrorInfo to attach this error to the current
	 * thread.	ITypeInfo::Invoke will look for this when it
	 * returns from whatever function was invokes by calling
	 * GetErrorInfo.
	 */

	//Not much we can do if this fails.
	if (FAILED(CreateErrorInfo(&pICreateErr)))
		return;

	/*
	 * CONSIDER: Help file and help context?
	 */
	pICreateErr->SetGUID(ObjID);
	pICreateErr->SetHelpFile(L"");
	pICreateErr->SetHelpContext(0L);
	pICreateErr->SetSource(strSource);
	pICreateErr->SetDescription(strDescr);

	hr = pICreateErr->QueryInterface(IID_IErrorInfo, (PPVOID)&pIErr);

	if (SUCCEEDED(hr))
		{
		SetErrorInfo(0L, pIErr);
		pIErr->Release();
		}

	//SetErrorInfo holds the object's IErrorInfo
	pICreateErr->Release();
	return;
	}

/*===================================================================
ExceptionId

Raises an exception using the CreateErrorInfo API and the
ICreateErrorInfo interface.

Note that this method doesn't allow for deferred filling
of an EXCEPINFO structure.

Parameters:
	SourceID	Resource ID for the source string
	DescrID		Resource ID for the description string

Returns:
	Nothing
===================================================================*/

void ExceptionId
(
REFIID ObjID,
UINT SourceID,
UINT DescrID,
HRESULT	hrCode
)
	{
	HRESULT hr;
	ICreateErrorInfo *pICreateErr;
	IErrorInfo *pIErr;
	LANGID langID = LANG_NEUTRAL;

#ifdef USE_LOCALE
	LANGID *pLangID;
	
	pLangID = (LANGID *)TlsGetValue(g_dwTLS);

	if (NULL != pLangID)
		langID = *pLangID;
#endif

	/*
	 * Thread-safe exception handling means that we call
	 * CreateErrorInfo which gives us an ICreateErrorInfo pointer
	 * that we then use to set the error information (basically
	 * to set the fields of an EXCEPINFO structure.	We then
	 * call SetErrorInfo to attach this error to the current
	 * thread.	ITypeInfo::Invoke will look for this when it
	 * returns from whatever function was invokes by calling
	 * GetErrorInfo.
	 */

	//Not much we can do if this fails.
	if (FAILED(CreateErrorInfo(&pICreateErr)))
		return;

	/*
	 * CONSIDER: Help file and help context?
	 */
	DWORD cch;
	WCHAR strSource[MAX_RESSTRINGSIZE];
	WCHAR strDescr[MAX_RESSTRINGSIZE];
	WCHAR strHRESULTDescr[256];
	WCHAR strDescrWithHRESULT[MAX_RESSTRINGSIZE];

	pICreateErr->SetGUID(ObjID);
	pICreateErr->SetHelpFile(L"");
	pICreateErr->SetHelpContext(0L);

	cch = CwchLoadStringOfId(SourceID, strSource, MAX_RESSTRINGSIZE);
	if (cch > 0)
		pICreateErr->SetSource(strSource);
	
	cch = CwchLoadStringOfId(DescrID, strDescr, MAX_RESSTRINGSIZE);
	if (cch > 0) 
		{
		//Bug Fix 91847 use a FormatMessage() based description
		HResultToWsz(hrCode, strHRESULTDescr, 256);

		_snwprintf(strDescrWithHRESULT, MAX_RESSTRINGSIZE, strDescr, strHRESULTDescr);
		strDescrWithHRESULT[MAX_RESSTRINGSIZE - 1] = L'\0';
	
		pICreateErr->SetDescription(strDescrWithHRESULT);
		}

	hr = pICreateErr->QueryInterface(IID_IErrorInfo, (PPVOID)&pIErr);

	if (SUCCEEDED(hr))
		{
		SetErrorInfo(0L, pIErr);
		pIErr->Release();
		}

	//SetErrorInfo holds the object's IErrorInfo
	pICreateErr->Release();
	return;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\error.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Error handling

File: Error.cpp

Owner: AndrewS

This file contains general error reporting routines for Denali.
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include <psapi.h>

#include "debugger.h"
#include "asperror.h"
#include "memchk.h"

#define DELIMITER	"~"
#define MAX_HEADERSIZE			128
#define	MAX_TEMPLATELEN			128

//The order of ErrTemplate_Index should be exactly the same order as the IDS_BROWSER_TEMPLATE 
//in the resource.h, and as the same order we output the template to the browser.
//Implementation will loop through the index and picking the string from the resource file.
//Implementation will also loop through the index and write the string to browser.
#define ErrTemplate_BEGIN			0
#define ErrTemplate_ENGINE_BEGIN	1
#define ErrTemplate_ENGINE_END		2
#define ErrTemplate_ERROR_BEGIN		3
#define ErrTemplate_ERROR_END		4
#define ErrTemplate_SHORT_BEGIN		5
#define ErrTemplate_SHORT_END		6
#define ErrTemplate_FILE_BEGIN		7
#define ErrTemplate_FILE_END		8
#define ErrTemplate_LINE_BEGIN		9
#define ErrTemplate_LINE_END		10
#define ErrTemplate_CODE_BEGIN		11
#define ErrTemplate_CODE_END		12
#define ErrTemplate_LONG_BEGIN		13
#define ErrTemplate_LONG_END		14
#define ErrTemplate_END				15
#define ErrTemplateMAX				16

const 	DWORD	dwDefaultMask				= 0x6;	// toNTLog(OFF), toIISLog(ON), toBrowser(ON)

CHAR			g_szErrTemplate[ErrTemplateMAX][MAX_TEMPLATELEN];
const	LPSTR	szErrSysTemplate[]			= { "<html><body><h1> HTTP/1.1 ",
												"</h1></body></html>"};
CErrInfo		g_ErrInfoOOM, g_ErrInfoUnExpected;	
CHAR			szIISErrorPrefix[20]; 
DWORD			cszIISErrorPrefix;
CPINFO			g_SystemCPInfo;		// global System CodePage default info.

static char s_szContentTypeTextHtml[] = "Content-type: text/html\r\n\r\n";

CHAR *SzScodeToErrorCode(HRESULT hrError);
void FreeNullifySz(CHAR **szIn);
BOOL FIsResStrFormatted(char *szIn);

/*===================================================================
FreeNullifySz

Free the memory allocated in szIn, and Nullify the szIn.
===================================================================*/
void FreeNullifySz(CHAR **szIn)
{
	if(*szIn)
		{
		free(*szIn);
		*szIn = NULL;
		}
}

/*===================================================================
ErrHandleInit

PreLoad strings for 
	1> OOM 
	2> Browser Output Template
Returns:
	HRESULT
===================================================================*/
HRESULT ErrHandleInit(void)
{
	INT	iEntry, iEntryID;
	HRESULT	hr;

	// Retrieve global system codepage and stores it.
	GetCPInfo(CP_ACP, &g_SystemCPInfo);

	//Init g_szErrTemplate
	//Loop through, and load strings from resource file.
	for (iEntry = ErrTemplate_BEGIN, iEntryID = IDS_BROWSER_TEMPLATE_BEGIN; 
			iEntry < ErrTemplateMAX; iEntry ++, iEntryID++)
		{
		CchLoadStringOfId(iEntryID, (CHAR *)g_szErrTemplate[iEntry], MAX_TEMPLATELEN);
		}

	g_ErrInfoOOM.m_szItem[Im_szErrorCode] = (CHAR *)malloc(sizeof(CHAR)*20*g_SystemCPInfo.MaxCharSize);
	g_ErrInfoOOM.m_szItem[Im_szShortDescription] = (CHAR *)malloc(sizeof(CHAR)*256*g_SystemCPInfo.MaxCharSize);
	g_ErrInfoOOM.m_szItem[Im_szLongDescription] = (CHAR *)malloc(sizeof(CHAR)*512*g_SystemCPInfo.MaxCharSize);

    if (!g_ErrInfoOOM.m_szItem[Im_szErrorCode]        ||
        !g_ErrInfoOOM.m_szItem[Im_szShortDescription] || 
        !g_ErrInfoOOM.m_szItem[Im_szLongDescription])
        {
        return E_OUTOFMEMORY;
        }
	
	hr = LoadErrResString(IDE_OOM, 
						&g_ErrInfoOOM.m_dwMask,
						g_ErrInfoOOM.m_szItem[Im_szErrorCode],
						g_ErrInfoOOM.m_szItem[Im_szShortDescription],
						g_ErrInfoOOM.m_szItem[Im_szLongDescription]);

	
	g_ErrInfoUnExpected.m_szItem[Im_szErrorCode] = (CHAR *)malloc(sizeof(CHAR)*20*g_SystemCPInfo.MaxCharSize);
	g_ErrInfoUnExpected.m_szItem[Im_szShortDescription] = (CHAR *)malloc(sizeof(CHAR)*256*g_SystemCPInfo.MaxCharSize);
	g_ErrInfoUnExpected.m_szItem[Im_szLongDescription] = (CHAR *)malloc(sizeof(CHAR)*512*g_SystemCPInfo.MaxCharSize);

    if (!g_ErrInfoUnExpected.m_szItem[Im_szErrorCode]        ||
        !g_ErrInfoUnExpected.m_szItem[Im_szShortDescription] || 
        !g_ErrInfoUnExpected.m_szItem[Im_szLongDescription])
        {
        return E_OUTOFMEMORY;
        }
	
	hr = LoadErrResString(IDE_UNEXPECTED, 
						&g_ErrInfoUnExpected.m_dwMask,
						g_ErrInfoUnExpected.m_szItem[Im_szErrorCode],
						g_ErrInfoUnExpected.m_szItem[Im_szShortDescription],
						g_ErrInfoUnExpected.m_szItem[Im_szLongDescription]);

	cszIISErrorPrefix = CchLoadStringOfId(IDS_IISLOG_PREFIX , szIISErrorPrefix, 20);
	return hr;
}
/*===================================================================
 ErrHandleUnInit

 Unit the global err-handling data.

 Free up the OOM CErrInfo.

 Side Effect:

 Free up memory.
===================================================================*/
HRESULT ErrHandleUnInit(void)
{
	FreeNullifySz((CHAR **)&g_ErrInfoOOM.m_szItem[Im_szErrorCode]);
	FreeNullifySz((CHAR **)&g_ErrInfoOOM.m_szItem[Im_szShortDescription]);
	FreeNullifySz((CHAR **)&g_ErrInfoOOM.m_szItem[Im_szLongDescription]);

	FreeNullifySz((CHAR **)&g_ErrInfoUnExpected.m_szItem[Im_szErrorCode]);
	FreeNullifySz((CHAR **)&g_ErrInfoUnExpected.m_szItem[Im_szShortDescription]);
	FreeNullifySz((CHAR **)&g_ErrInfoUnExpected.m_szItem[Im_szLongDescription]);
	return S_OK;
}
/*===================================================================
Constructor

===================================================================*/
CErrInfo::CErrInfo()
{
	for (UINT iErrInfo = 0; iErrInfo < Im_szItemMAX; iErrInfo++)
		m_szItem[iErrInfo] = NULL;
	m_bstrLineText = NULL;
	m_nColumn = -1;

	m_dwMask 	= 0;
	m_pIReq		= NULL;
	m_pHitObj	= NULL;

	m_dwHttpErrorCode = 0;
    m_dwHttpSubErrorCode = 0;
}

/*===================================================================
CErrInfo::ParseResourceString

Parse Resource String to get default mask, error type, short description, 
and long description.  

Assume resource string is proper formmated.
Format of resource string
DefaultMask~errortype~shortdescription~longdescription

In case we can not allocate szResourceString(szResourceString), we use default.
Returns:
	Nothing
===================================================================*/
HRESULT	CErrInfo::ParseResourceString(CHAR *szResourceString)
{
	CHAR 	*szToken 	= NULL;
	INT		cfield		= 0;
	INT		iItem		= 0;
	INT		iIndex		= 0;
	INT		rgErrInfoIndex[3] = {Im_szErrorCode, Im_szShortDescription, Im_szLongDescription};

	if(NULL == szResourceString)
		{
		m_dwMask = dwDefaultMask;
		for(iItem = 0, iIndex = 0; iIndex < 3; iIndex++)
			{
			iItem = rgErrInfoIndex[iIndex];
			m_szItem[iItem]	= g_ErrInfoUnExpected.m_szItem[iItem];
			}
		return S_OK;
		}
	//Mask
	szToken = (char *)_mbstok((unsigned char *)szResourceString, (unsigned char *)DELIMITER);
	if(szToken != NULL)
		{
		m_dwMask = atoi(szToken);
		cfield++;
		}
	else
		{
		m_dwMask = dwDefaultMask;
		}

	//3 String Items, ErrorCode,ShortDescription,LongDescription
	for(iItem = 0, iIndex = 0; iIndex < 3; iIndex++)
		{
		szToken = (char *)_mbstok(NULL, (unsigned char *)DELIMITER);
		iItem = rgErrInfoIndex[iIndex];
		if (szToken != NULL)
			{
			m_szItem[iItem]	= szToken;
			cfield++;
			}
		else
			{
			// Long Description is optional.
			if (Im_szLongDescription != iItem)
			    {
    			m_szItem[iItem]	= g_ErrInfoUnExpected.m_szItem[iItem];
    			}
			cfield++;
			}
		}

	//check wether we have wrong format of resource string.
	Assert(cfield == 4);

	return S_OK;
}

/*===================================================================
CErrInfo::LogError(void)

Perform all the switch logic in this functions. Send error to NT Log,
IIS Log, or Browser.
When reach this point, we assume all the strings have allocated, and will not be used after this
function.

Side effects:

Returns:
	HRESULT
===================================================================*/
HRESULT	CErrInfo::LogError(void)
{
	HRESULT	hr 		= S_OK;
	HRESULT hr_ret	= S_OK;
	UINT	iEInfo	= 0;
	BOOL	fIISLogFailed, fDupToNTLog;

#if DBG
	// Print details about the error to debug window; don't bother if
	// info is NULL (happens for things like 404 not found, etc.)

	if (m_szItem[Im_szEngine] != NULL && m_szItem[Im_szFileName] != NULL)
		{
		DBGERROR((DBG_CONTEXT, "%s error in %s at line %s\n",
								m_szItem[Im_szEngine],
								m_szItem[Im_szFileName],
								m_szItem[Im_szLineNum]? m_szItem[Im_szLineNum] : "?"));

		DBGPRINTF((DBG_CONTEXT, "  %s: %s\n",
								m_szItem[Im_szErrorCode],
								m_szItem[Im_szShortDescription]));
		}
	else
		DBGERROR((DBG_CONTEXT, "ASP Error: %s\n", m_szItem[Im_szShortDescription]));
#endif

	// Attach ASP error to HitObj (if exists and in 'executing' state)
	if (m_pHitObj && m_pHitObj->FExecuting())
	    {
	    CASPError *pASPError = new CASPError(this);
	    if (pASPError)
    	    m_pHitObj->SetASPError(pASPError);
	    }
	
	hr = LogErrortoIISLog(&fIISLogFailed, &fDupToNTLog);
	if (FAILED(hr))
		{
		hr_ret = hr;
		}

	//fIISLogFailed, if it is TRUE, then, this error was upgraded, and should be a WARNING type in 
	//NT event log.
	hr = LogErrortoNTEventLog(fIISLogFailed, fDupToNTLog);
	if (FAILED(hr))
		{
		hr_ret = hr;
		}
		
	hr = LogErrortoBrowserWrapper();
	
	if (FAILED(hr))
		{
		hr_ret = hr;
		}
		
	if (m_pHitObj)
		{
		m_pHitObj->SetExecStatus(eExecFailed);
		}
	//In case of an error, hr_ret is the last error reported from the 3 logging functions.
	return hr_ret;
	
}

/*===================================================================
CErrInfo::LogErrortoNTEventLog

Log Error/Event to NT Event Log.

Returns:
	Nothing
===================================================================*/
HRESULT CErrInfo::LogErrortoNTEventLog
(
BOOL fIISLogFailed,
BOOL fDupToNTLog
)
{
	CHAR szErrNTLogEntry[4096]; 
	CHAR szStringTemp[MAX_PATH];
	INT	cch = 0;

	if(Glob(fLogErrorRequests))
		{
		//Is the error serious enough to get into NT log
		if(ERR_FLogtoNT(m_dwMask) || fIISLogFailed || fDupToNTLog)
			{
			szErrNTLogEntry[0] = '\0';

			if (fIISLogFailed)
				{
				cch = CchLoadStringOfId(IDS_LOG_IISLOGFAILED, szStringTemp, MAX_PATH);
				strncat(szErrNTLogEntry, szStringTemp, cch);
				}
				
			if (m_szItem[Im_szFileName] != NULL)
				{
				cch = CchLoadStringOfId(IDS_LOGTOEVENTLOG_FILE, szStringTemp, MAX_PATH);
				strncat(szErrNTLogEntry, szStringTemp, cch);
				strncat(szErrNTLogEntry, m_szItem[Im_szFileName], 512);	
				}
			strncat(szErrNTLogEntry, " ", 1);

			if (m_szItem[Im_szLineNum] != NULL)
				{
				cch = CchLoadStringOfId(IDS_LOGTOEVENTLOG_LINE, szStringTemp, MAX_PATH);
				strncat(szErrNTLogEntry, szStringTemp, cch);
				strncat(szErrNTLogEntry, m_szItem[Im_szLineNum], 48);	
				}
			strncat(szErrNTLogEntry, " ", 1);
			
			//Ok, do we have something to log.
			if (m_szItem[Im_szShortDescription] != NULL)
				{
				// ShortDescription does not have ". " at the end.
				// Therefore, the next strncat need to concatenate two sentences together with
				// a period ". ".
				char szTempPeriod[] = ". ";
				
				strncat(szErrNTLogEntry, m_szItem[Im_szShortDescription], 512);
				strncat(szErrNTLogEntry, szTempPeriod, 512);
				}
			else
				{
				DWORD dwMask;
				CHAR szDenaliNotWorking[MAX_PATH];
				
				LoadErrResString(IDE_UNEXPECTED, &dwMask, NULL, szDenaliNotWorking, NULL); 
				strncat(szErrNTLogEntry, szDenaliNotWorking, strlen(szDenaliNotWorking));
				}

			//Ok, do we have something to log.
			if (m_szItem[Im_szLongDescription] != NULL)
				{
				strncat(szErrNTLogEntry, m_szItem[Im_szLongDescription], 512);
				}

			if (fIISLogFailed || fDupToNTLog)
				MSG_Warning((LPCSTR)szErrNTLogEntry);
			else
				MSG_Error((LPCSTR)szErrNTLogEntry);
			}
		}

	return S_OK;
}

/*===================================================================
CErrInfo::LogErrortoIISLog

Log Error/Event to IIS Log.

If we fail to log the message then upgrade logging to NT event Log
with entries indicate the error and the IIS log failed.

Also do the upgrade if the global setting says so.

Returns:
	Nothing
===================================================================*/
HRESULT	CErrInfo::LogErrortoIISLog
(
BOOL *pfIISLogFailed,
BOOL *pfDupToNTLog
)
{
	HRESULT			hr				= S_OK;
	const	LPSTR	szIISDelimiter	= "|";
	const	DWORD	cszIISDelimiter = 1; // strlen("|");
	const	LPSTR	szIISNoInfo		= "-";
	const	DWORD	cszIISNoInfo	= 1; // strlen("-");
	const	CHAR	chProxy			= '_';
	CIsapiReqInfo  *pIReq = NULL;

	*pfIISLogFailed = FALSE;
	*pfDupToNTLog = FALSE;
	
	if (m_pIReq == NULL && m_pHitObj == NULL)
		return S_OK;
	
	//Try to write to IISLog via pIReq->QueryPszLogData()
	if (ERR_FLogtoIIS(m_dwMask))
		{
		//get pIReq
		if (m_pHitObj)
			{
			pIReq = m_pHitObj->PIReq();
			}

		if (NULL == pIReq)
			{
			pIReq = m_pIReq;
			}

		if (pIReq == NULL)
			{
			*pfIISLogFailed = TRUE;
			return E_FAIL;
			}

		// Setup the sub-string array
		const DWORD crgsz = 3;
		LPSTR rgsz[crgsz];

		rgsz[0] = m_szItem[Im_szLineNum];
		rgsz[1] = m_szItem[Im_szErrorCode];
		rgsz[2] = m_szItem[Im_szShortDescription];

		// Allocate the log entry string
		CHAR *szLogEntry = NULL;
		DWORD cszLogEntry = (cszIISDelimiter * crgsz) + 1;
		DWORD dwIndex;

		for (dwIndex = 0; dwIndex < crgsz; dwIndex++) 
			{
			if (rgsz[dwIndex]) 
				cszLogEntry += strlen(rgsz[dwIndex]);
			else
				cszLogEntry += cszIISNoInfo;
			}

		szLogEntry = new CHAR[cszLogEntry];
		if (NULL == szLogEntry) {
			return E_OUTOFMEMORY;
		}

		// Copy the entry, proxy bad characters
		CHAR *szSource = NULL;
		CHAR *szDest = szLogEntry;

		// Start with a delimiter to separate us from
        // the request query
        memcpy(szDest, szIISDelimiter, cszIISDelimiter);
		szDest += cszIISDelimiter;
 
		for (dwIndex = 0; dwIndex < crgsz; dwIndex++)
			{
			szSource = rgsz[dwIndex];
			if (szSource) 
				{
				while (*szSource) 
					{
					if (isleadbyte(*szSource)) 
						{
						*szDest++ = *szSource++;
						*szDest++ = *szSource++;
						}
					else if ((*szSource == ',') ||
							 (*szSource == ' ') ||
							 (*szSource == '\r') ||
							 (*szSource == '\n') ||
							 (*szSource == '\"'))
						{
						*szDest++ = chProxy;
						szSource++;
						}
					else 
						*szDest++ = *szSource++;
					}
				}
			else
				{
				memcpy(szDest, szIISNoInfo, cszIISNoInfo);
				szDest += cszIISNoInfo;
				}

			if ((dwIndex + 1) < crgsz)
				{
				// Another sub-string comming, use a delimiter
				memcpy(szDest, szIISDelimiter, cszIISDelimiter);
				szDest += cszIISDelimiter;
				}
			}
		*szDest = '\0';
		
		// Log it		
		BOOL fResult = TRUE;

        fResult = SUCCEEDED(pIReq->AppendLogParameter(szLogEntry));

		// Set "500" error in log.
		if (pIReq->ECB()->dwHttpStatusCode == 200)   // error content sent, OK, but really an error
			pIReq->ECB()->dwHttpStatusCode = 500;

		// Release log string
		delete [] szLogEntry;
			
		// If any error occurred while writing to log, upgrade to NT Event log
		if (!fResult)
			{
			m_dwMask = ERR_SetLogtoNT(m_dwMask);
			*pfIISLogFailed = TRUE;
			}
			
		// Even if successful we might still want the message
		// in the NT event log if the global setting to do so is on.
	    else if (Glob(fDupIISLogToNTLog))
	        {
	        if (!ERR_FLogtoNT(m_dwMask))
	            {
                // Need to remember the flag in order to insert
                // the upgraded IIS log error as NT log warnings.
                // The errors already destined for NT log should
                // stay as errors.
    			m_dwMask = ERR_SetLogtoNT(m_dwMask);
    			*pfDupToNTLog = TRUE;
    			}
			}
			
		hr = S_OK;
		}
		
	return(hr);
}

/*===================================================================
CErrInfo::LogErrortoBrowserWrapper

Just a Wrapper around Log Error/Event to Browser.  

In this function, pIReq or pResponse is resolved.

NOTE:
Unfortunately, this function can not tell pResponse is inited or not.
In case when pResponse has not been inited, pResponse is not NULL, but things
in pResponse are invalid.
Therefore, caller need to provide pIReq in case where pResponse has not been inited. 

Returns:
	HRESULT
===================================================================*/
HRESULT	CErrInfo::LogErrortoBrowserWrapper()
{
	HRESULT hr = S_OK;
	
	// Must have passed in either an CIsapiReqInfo or a HITOBJ.  Otherwise, there is nothing we can do.
	if (m_pIReq == NULL && m_pHitObj == NULL)
		{
		Assert(FALSE);
		return E_FAIL;
		}

    // Remember response object if any	    
    CResponse *pResponse = m_pHitObj ? m_pHitObj->PResponse() : NULL;

	CIsapiReqInfo *pIReq = 
	    (m_pHitObj && pResponse && m_pHitObj->PIReq()) ? 
	        m_pHitObj->PIReq() : m_pIReq;
	if (!pIReq)
	    return E_FAIL;

    // Do custom errors only if response headers aren't written already
    // ALSO: No custom error if called from global.asa, with intrinsic objects hidden.
    //   (Appln_OnStart & Session_OnStart)
    //
    // for errors in Appln_OnEnd or Session_OnEnd, these are not browser requests
    // and so pResponse == NULL in this case.

    if (!pResponse || !pResponse->FHeadersWritten())
        {
        BOOL fIntrinsicsWereHidden = FALSE;
        if (m_pHitObj)
       	    {
       	    fIntrinsicsWereHidden = m_pHitObj->FRequestAndResponseIntrinsicsHidden();
       	    m_pHitObj->UnHideRequestAndResponseIntrinsics();
       	    }

        BOOL fCustom = FALSE;
        hr = LogCustomErrortoBrowser(pIReq, &fCustom);

        if (fIntrinsicsWereHidden)
        	m_pHitObj->HideRequestAndResponseIntrinsics();

        if (fCustom)
            return hr;
        }

	// No custom error - do regular error from this object

	if (m_szItem[Im_szHeader])
		{
	    BOOL fRet = pIReq->SendHeader
	        (
			m_szItem[Im_szHeader],
			strlen(m_szItem[Im_szHeader]) + 1,
			s_szContentTypeTextHtml,
			sizeof(s_szContentTypeTextHtml),
			FALSE
			);

        if (!fRet)					
			return E_FAIL;
		}

	if (pResponse)
		hr = LogErrortoBrowser(pResponse);
	else
		hr = LogErrortoBrowser(pIReq);
		
	return hr;
}

/*===================================================================
CErrInfo::LogCustomErrortoBrowser

Called by LogErrortoBrowserWrapper.  

Parameters
    pIReq
    pfCustomErrorProcessed

Returns:
	HRESULT
===================================================================*/
HRESULT	CErrInfo::LogCustomErrortoBrowser
(
CIsapiReqInfo *pIReq,
BOOL *pfCustomErrorProcessed
)
    {
    // Custom errors when HttpErrorCode is specified (404 or 500),
    // or '500;100' ASP scripting error case
    BOOL fTryErrorTransfer = FALSE;
    DWORD dwCode, dwSubCode;

    if (m_dwHttpErrorCode == 404 || m_dwHttpErrorCode == 500 || m_dwHttpErrorCode == 401)
        {
        dwCode = m_dwHttpErrorCode;
        dwSubCode = m_dwHttpSubErrorCode;
        }
    else if (m_dwHttpErrorCode == 0 && m_pHitObj &&
             m_pHitObj->FHasASPError() &&               // there's an error on this page
             m_pHitObj->FExecuting() &&                 // while executing
             !m_pHitObj->FInTransferOnError() &&        // not inside transfer-on-error already
             m_pHitObj->PAppln() && m_pHitObj->PResponse() && m_pHitObj->PServer() &&
			 m_pHitObj->PAppln()->QueryAppConfig()->pCLSIDDefaultEngine())   // engine in the registry is valid
        {
        dwCode = 500;
        dwSubCode = 100;
        fTryErrorTransfer = TRUE;
        }
    else
        {
        // no need to try
        *pfCustomErrorProcessed = FALSE;
        return S_OK;
        }

    // Get custom error from W3SVC
        

    STACK_BUFFER( tempParamBuf, MAX_PATH );
    TCHAR *szBuf = (TCHAR *)tempParamBuf.QueryPtr();
    DWORD dwLen = MAX_PATH;
    BOOL fIsFileError;
    
    BOOL fRet = pIReq->GetCustomError(dwCode, dwSubCode, dwLen, szBuf, &dwLen, &fIsFileError);
    if (!fRet && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
        if (tempParamBuf.Resize(dwLen) == TRUE) {
            szBuf = (TCHAR *)tempParamBuf.QueryPtr();
            fRet = pIReq->GetCustomError(dwCode, dwSubCode, dwLen, szBuf, &dwLen, &fIsFileError);
        }
    }
    if (fRet)
        {
        if (fIsFileError)
            {
            // Verify that the error file can be read
            if (FAILED(AspGetFileAttributes(szBuf)))
                fRet = FALSE;
            }
        else
            {
            // Avoid circular client redirections
            // (check if the current URL is the same as error URL
            if (_tcsicmp(szBuf, pIReq->QueryPszPathInfo()) == 0)
                fRet = FALSE;
            }
        }
    if (!fRet)
        {
        // no custom error found
        *pfCustomErrorProcessed = FALSE;
        return S_OK;
        }

    // There's a custom error - use it

    HRESULT hr = S_OK;
        
    if (fIsFileError)
        {
        // in case of file errors mime type follows the file path
        // in the returned buffer
        hr = WriteCustomFileError(pIReq, szBuf, szBuf+_tcslen(szBuf)+1);
        }
    else if (fTryErrorTransfer)
        {
        // transfer to URL 

        // need to Map Path first
    	TCHAR szTemplate[MAX_PATH];
        WCHAR   *pErrorURL;
#if UNICODE
        pErrorURL = szBuf;
#else
        CMBCSToWChar    convStr;
        if (FAILED(convStr.Init(szBuf))) {
            *pfCustomErrorProcessed = FALSE;
            return S_OK;
        }
        pErrorURL = convStr.GetString();
#endif

        if (FAILED(m_pHitObj->PServer()->MapPathInternal(0, pErrorURL, szTemplate))) {
            // could use custom error
            *pfCustomErrorProcessed = FALSE;
            return S_OK;
        }
        Normalize(szTemplate);

        // do the transfer
        m_pHitObj->SetInTransferOnError();
        hr = m_pHitObj->ExecuteChildRequest(TRUE, szTemplate, szBuf);

        if (FAILED(hr))
            {
            // error while reporting error -- report both
            LogErrortoBrowser(m_pHitObj->PResponse());
            }
        }
    else
        {
        // client redirect to URL
        hr = WriteCustomURLError(pIReq, szBuf);
        }

    if (fIsFileError || !fTryErrorTransfer)
        {
        // suppress all output through intrinsic
        if (m_pHitObj && m_pHitObj->PResponse())
             m_pHitObj->PResponse()->SetIgnoreWrites();
        }

    *pfCustomErrorProcessed = TRUE;
    return hr;
    }

/*===================================================================
CErrInfo::WriteCustomFileError

Dumps the content of a custom error file to the browser

Returns:
	NONE.
===================================================================*/
HRESULT CErrInfo::WriteCustomFileError
(
CIsapiReqInfo   *pIReq,
TCHAR *szPath, 
TCHAR *szMimeType
)
{
    HRESULT hr = S_OK;
    char *szStatus = m_szItem[Im_szHeader];
    char *pszMBCSMimeType;

#if UNICODE
    CWCharToMBCS    convStr;
    
    if (FAILED(hr = convStr.Init(szMimeType, 65001))) {
        return hr;
    }
    else {
        pszMBCSMimeType = convStr.GetString();
    }
#else
    pszMBCSMimeType = szMimeType;
#endif

    if (szStatus == NULL) {
        // no status set -- get it from the response object if available
        CResponse *pResponse = m_pHitObj ? m_pHitObj->PResponse() : NULL;
        if (pResponse)
            szStatus = pResponse->PCustomStatus();
    }
    
    hr = CResponse::SyncWriteFile(pIReq, 
                                  szPath, 
                                  pszMBCSMimeType, 
                                  szStatus);        // NULL is OK - means 200

    return hr;
}
    
/*===================================================================
CErrInfo::WriteCustomURLError

Sends client redirect to the custom URL error

Returns:
	NONE.
===================================================================*/
HRESULT CErrInfo::WriteCustomURLError(
CIsapiReqInfo   *pIReq, 
TCHAR           *sztURL)
{
    // Header is
    // Location: redirect_URL?code;http://original_url

    HRESULT         hr = S_OK;
    char            *szURL;
#if UNICODE
    CWCharToMBCS    convRedirURL;

    if (FAILED(hr = convRedirURL.Init(sztURL,65001))) {
        return hr;
    }

    szURL = convRedirURL.GetString();
#else
    szURL = sztURL;
#endif

    // code
    char szCode[8];
    if (m_dwHttpErrorCode > 0 && m_dwHttpErrorCode < 1000)
        ltoa(m_dwHttpErrorCode, szCode, 10);
    else
        return E_FAIL;

    // get the current URL
    char szServer[128];
    DWORD dwServerSize = sizeof(szServer);

    STACK_BUFFER( tempHeader, 256 );
    if (!pIReq->GetServerVariableA("SERVER_NAME", szServer, &dwServerSize))
        return E_FAIL; // shouldn't happen
    char  *szOrigURL;
#if UNICODE
    CWCharToMBCS    convOrigStr;

    if (FAILED(hr = convOrigStr.Init(pIReq->QueryPszPathInfo(), 65001))) {
        return hr;
    }

    szOrigURL = convOrigStr.GetString();
#else
    szOrigURL = pIReq->QueryPszPathInfo();
#endif

    // estimate of the length
    DWORD cchHeaderMax = strlen(szURL) 
                       + strlen(szServer)
                       + strlen(szOrigURL)
                       + 80;    // decorations

    if (tempHeader.Resize(cchHeaderMax) == FALSE) {
        return E_OUTOFMEMORY;
    }
    char *szHeader = (char *)tempHeader.QueryPtr();

    // construct the redirection header
    char *szBuf = szHeader;
    szBuf = strcpyExA(szBuf, "Location: ");
    szBuf = strcpyExA(szBuf, szURL);
    szBuf = strcpyExA(szBuf, "?");
    szBuf = strcpyExA(szBuf, szCode);
    szBuf = strcpyExA(szBuf, ";http://");
    szBuf = strcpyExA(szBuf, szServer);
    szBuf = strcpyExA(szBuf, szOrigURL);
    szBuf = strcpyExA(szBuf, "\r\n\r\n");
    Assert(strlen(szHeader) < cchHeaderMax);

    // set the status
    static char s_szRedirected[] = "302 Object moved";
	pIReq->SetDwHttpStatusCode(302);

    // send the header
    BOOL fRet = pIReq->SendHeader(s_szRedirected,
		                          sizeof(s_szRedirected),
		                          szHeader,
		                          strlen(szHeader) + 1,
		                          FALSE);
    
    return (fRet ? S_OK : E_FAIL);
}

/*===================================================================
CErrInfo::WriteHTMLEncodedErrToBrowser

Log Error/Event to Browser with HTMLEncoded via either pResponse or pIReq.

Either pResponse or pIReq must be valid.

Returns:
	NONE.
===================================================================*/
void CErrInfo::WriteHTMLEncodedErrToBrowser
    (
    const CHAR *StrIn, 
    CResponse *pResponse, 
    CIsapiReqInfo   *pIReq
    )
{
CHAR szHTMLEncoded[2*MAX_RESSTRINGSIZE];
LPSTR pszHTMLEncoded = NULL;
LPSTR pStartszHTMLEncoded = NULL;
DWORD	nszHTMLEncoded = 0;
BOOL fStrAllocated = FALSE;

	nszHTMLEncoded = HTMLEncodeLen(StrIn, CP_ACP, FALSE);
	

	if (nszHTMLEncoded > 0)
		{
		if (nszHTMLEncoded > 2 * MAX_RESSTRINGSIZE)
			{
			pszHTMLEncoded = new char[nszHTMLEncoded+2]; 
			if (pszHTMLEncoded)
				{
				fStrAllocated = TRUE;
				}
			else
				{
				HandleOOMError(NULL, NULL);
				return;
				}
			}
		else
			pszHTMLEncoded = &szHTMLEncoded[0];

		pStartszHTMLEncoded = pszHTMLEncoded;
		pszHTMLEncoded = HTMLEncode(pszHTMLEncoded, StrIn, CP_ACP, FALSE);
		
		nszHTMLEncoded--;		// take out the count for '\0'.
		if (pResponse)
			pResponse->WriteSz((CHAR *)pStartszHTMLEncoded, nszHTMLEncoded);
		else
			CResponse::SyncWrite(pIReq, pStartszHTMLEncoded, nszHTMLEncoded);
		}

	if (fStrAllocated)
		delete [] pStartszHTMLEncoded;

	return;
}

/*===================================================================
CErrInfo::LogErrortoBrowser

Log Error/Event to Browser via pResponse.  

We will output 
	1> default ScriptErrorMessage or
	2> Error Info/Default Template/has long description available or
	3> Error Info/Default Template/no long description available

Returns:
	HRESULT
===================================================================*/
HRESULT CErrInfo::LogErrortoBrowser(CResponse *pResponse)
{
	INT	cch 	= 0;
	INT	cLine	= 0;
	INT iErrTemplate = 0;
	
	Assert(NULL != pResponse);

	// When the error code is zero, then it's coming from a 500 error code path.
	//   (HandleSysError presets the code to 404 or 204.)
	//
	if (!pResponse->FHeadersWritten() && (m_dwHttpErrorCode == 500 || m_dwHttpErrorCode == 0))
		pResponse->put_Status(L"500 Internal Server Error");

	if(ERR_FIsSysFormat(m_dwMask))
		{
		DWORD	cChHeader	= strlen(szErrSysTemplate[0]);
		DWORD	cChTail		= strlen(szErrSysTemplate[1]);
			
		pResponse->WriteSz((CHAR *)szErrSysTemplate[0], cChHeader);
		WriteHTMLEncodedErrToBrowser((CHAR *)m_szItem[Im_szShortDescription], pResponse, NULL);
		pResponse->WriteSz((CHAR *)szErrSysTemplate[1], cChTail);
		return S_OK;
		}
		
	if (!(m_pHitObj->QueryAppConfig())->fScriptErrorsSentToBrowser())
		{
        cch = strlen((CHAR *)((m_pHitObj->QueryAppConfig())->szScriptErrorMessage()));
		GlobStringUseLock();
        pResponse->WriteSz((CHAR *)((m_pHitObj->QueryAppConfig())->szScriptErrorMessage()),cch);
		GlobStringUseUnLock();
		}
	else
		{
		// line 0 is the begin line.
		cch = strlen((CHAR *)g_szErrTemplate[ErrTemplate_BEGIN]);
		pResponse->WriteSz((CHAR *)g_szErrTemplate[ErrTemplate_BEGIN], cch);

		//7 standard items(file, line, engine, error#, short description, code, long description) 
		//If any info missing(is NULL), we skip.
		for (cLine = 0; cLine < 7; cLine++)
			{
			if (NULL == m_szItem[cLine])
	  	 		continue;
			
			iErrTemplate = cLine * 2 + 1;
			/*	BUG 78782 (IIS Active) */
	  		//WriteHTMLEncodedErrToBrowser((CHAR *)g_szErrTemplate[iErrTemplate], pResponse, NULL);
	  		pResponse->WriteSz((CHAR *)g_szErrTemplate[iErrTemplate], strlen((CHAR *)g_szErrTemplate[iErrTemplate]));
	  		
	  		
	  	 	WriteHTMLEncodedErrToBrowser((CHAR *)m_szItem[cLine], pResponse, NULL);
	  	 	
	  	 	iErrTemplate++;
	  	 	/*	BUG 78782 (IIS Active) */
	  		//WriteHTMLEncodedErrToBrowser((CHAR *)g_szErrTemplate[iErrTemplate], pResponse, NULL);
	  		pResponse->WriteSz((CHAR *)g_szErrTemplate[iErrTemplate], strlen((CHAR *)g_szErrTemplate[iErrTemplate]));
	  	 	}

		//ouput the end line
		cch = strlen((CHAR *)g_szErrTemplate[ErrTemplate_END]);
		pResponse->WriteSz((CHAR *)g_szErrTemplate[ErrTemplate_END], cch);
		}	
	return S_OK;
}

/*===================================================================
CErrInfo::LogErrortoBrowser

Log Error/Event to Browser via pIReq.  

We will output 
	1> default ScriptErrorMessage or
	2> Error Info/Default Template/has long description available or
	3> Error Info/Default Template/no long description available

Returns:
	HRESULT
===================================================================*/
HRESULT CErrInfo::LogErrortoBrowser(CIsapiReqInfo  *pIReq)
{
	INT			cLine	= 0;
	INT			iErrTemplate 	= 0;
	
	Assert(NULL != pIReq);

	//HTTP type error, 204, 404, 500
	//mimic IIS error reporting
	//And send out the header.
	if(ERR_FIsSysFormat(m_dwMask))
		{
		CResponse::SyncWrite(pIReq, szErrSysTemplate[0]);
		WriteHTMLEncodedErrToBrowser((CHAR *)m_szItem[Im_szShortDescription], NULL, pIReq);
		CResponse::SyncWrite(pIReq, szErrSysTemplate[1]);
		return S_OK;
		}

	if (!(m_pHitObj->QueryAppConfig())->fScriptErrorsSentToBrowser())
		{
		GlobStringUseLock();
        CResponse::SyncWrite(pIReq, (CHAR *)((m_pHitObj->QueryAppConfig())->szScriptErrorMessage()));
		GlobStringUseUnLock();
		}
	else
		{
		// line 0 is the begin line.
		CResponse::SyncWrite(pIReq, g_szErrTemplate[ErrTemplate_BEGIN]);

		//7 standard items(file, line, engine, error#, short description, code, long description) 
		//If any info missing(is NULL), we skip.
		for (cLine = 0; cLine < 5; cLine++)
			{
			if (NULL == m_szItem[cLine])
	  	 		continue;
			
			iErrTemplate = cLine * 2 + 1;
	  		WriteHTMLEncodedErrToBrowser((CHAR *)g_szErrTemplate[iErrTemplate], NULL, pIReq);
	  		
	  	 	WriteHTMLEncodedErrToBrowser((CHAR *)m_szItem[cLine], NULL, pIReq);

	  	 	iErrTemplate++;
	  		WriteHTMLEncodedErrToBrowser((CHAR *)g_szErrTemplate[iErrTemplate], NULL, pIReq);
	  	 	}

		//ouput the end line
		CResponse::SyncWrite(pIReq, g_szErrTemplate[ErrTemplate_END]);
		}

	return S_OK;
}


/*===================================================================
CchLoadStringOfId

Loads a string from the string table.

Returns:
	sz - the returned string
	INT - 0 if string load failed, otherwise number of characters loaded.
===================================================================*/
INT CchLoadStringOfId
(
UINT id,
CHAR *sz,
INT cchMax
)
	{
	INT cchRet;
	
	// The handle to the DLL instance should have been set up when we were loaded
	if (g_hinstDLL == (HINSTANCE)0)
		{
		// Totally bogus
		Assert(FALSE);
		return(0);
		}

	cchRet = LoadStringA(g_hinstDLL, id, sz, cchMax);

    IF_DEBUG(ERROR)
        {
    	// For debugging purposes, if we get back 0, get the last error info
    	if (cchRet == 0)
    		{
    		DWORD err = GetLastError();
    		DBGERROR((DBG_CONTEXT, "Failed to load string resource.  Id = %d, error = %d\n", id, err));
    		DBG_ASSERT(FALSE);
    		}
		}

	return(cchRet);
	}


/*===================================================================
CwchLoadStringOfId

Loads a string from the string table as a UNICODE string.

Returns:
	sz - the returned string
	INT - 0 if string load failed, otherwise number of characters loaded.
===================================================================*/
INT CwchLoadStringOfId
(
UINT id,
WCHAR *sz,
INT cchMax
)
	{
	INT cchRet;
	
	// The handle to the DLL instance should have been set up when we were loaded
	if (g_hinstDLL == (HINSTANCE)0)
		{
		// Totally bogus
		Assert(FALSE);
		return(0);
		}

	if (FIsWinNT())
		{
		cchRet = LoadStringW(g_hinstDLL, id, sz, cchMax);
		}
	else
		{
		//LoadStringW returns ERROR_CALL_NOT_IMPLEMENTED in Win95, work around
		CHAR szTemp[MAX_RESSTRINGSIZE];
		cchRet = CchLoadStringOfId(id, szTemp, cchMax);
		if (cchRet > 0)
			{
            CMBCSToWChar    convStr;
            convStr.Init(szTemp);
			sz = convStr.GetString(TRUE);
            cchRet = convStr.GetStringLen();
			}
		}

    IF_DEBUG(ERROR)
        {
    	// For debugging purposes, if we get back 0, get the last error info
    	if (cchRet == 0)
    		{
    		DWORD err = GetLastError();
    		DBGERROR((DBG_CONTEXT, "Failed to load string resource.  Id = %d, error = %d\n", id, err));
    		DBG_ASSERT(FALSE);
    		}
		}

	return(cchRet);
	}

/*===================================================================
HandleSysError

Dumps the error to the client and/or to the log
Loads a string from the string table as a UNICODE string.

Returns:
	sz - the returned string
	INT - 0 if string load failed, otherwise number of characters loaded.
===================================================================*/
HRESULT HandleSysError(	DWORD dwHttpError,
                        DWORD dwHttpSubError,
                        UINT ErrorID,
						UINT ErrorHeaderID,
						CIsapiReqInfo   *pIReq,
						CHitObj *pHitObj)
{
	CErrInfo	SysErrInfo;
	CErrInfo	*pErrInfo;
	CHAR		szResourceStr[MAX_RESSTRINGSIZE];
	CHAR		szHeader[MAX_HEADERSIZE];
	INT			cch;
	
	pErrInfo = (CErrInfo *)&SysErrInfo;

	pErrInfo->m_pHitObj = pHitObj;
	pErrInfo->m_pIReq	= pIReq;
	if (ErrorHeaderID != 0)
		{
		cch = CchLoadStringOfId(ErrorHeaderID, szHeader, MAX_HEADERSIZE);
		pErrInfo->m_szItem[Im_szHeader] = szHeader;
		}
	else
		{
		pErrInfo->m_szItem[Im_szHeader] = NULL;
		}
		
	if (ErrorID != 0)
		cch = CchLoadStringOfId(ErrorID, szResourceStr, MAX_RESSTRINGSIZE);
		
	pErrInfo->ParseResourceString(szResourceStr);

	pErrInfo->m_dwMask = ERR_SetSysFormat(pErrInfo->m_dwMask);

    pErrInfo->m_dwHttpErrorCode = dwHttpError;
    pErrInfo->m_dwHttpSubErrorCode = dwHttpSubError;
	
	pErrInfo->LogError();

	return S_OK;
}

/*===================================================================
Handle500Error

Based on ErrorID determines headerID, code, sub-code, and
calls HandleSysError()

Returns:
	HRESULT
===================================================================*/
HRESULT Handle500Error( UINT errorId, 
                        CIsapiReqInfo   *pIReq)
{
    UINT  headerId;
    DWORD dwHttpSubError;
    
    switch (errorId)
        {
        case IDE_SERVER_TOO_BUSY:
            headerId = IDH_500_SERVER_ERROR;
    		dwHttpSubError = SUBERRORCODE500_SERVER_TOO_BUSY;
            break;

        case IDE_SERVER_SHUTTING_DOWN:
            headerId = IDH_500_SERVER_ERROR;
       		dwHttpSubError = SUBERRORCODE500_SHUTTING_DOWN;
       		break;
        
        case IDE_GLOBAL_ASA_CHANGED:
            headerId = IDH_500_SERVER_ERROR;
            dwHttpSubError = SUBERRORCODE500_RESTARTING_APP;    
            break;
            
        case IDE_INVALID_APPLICATION:
    		headerId = IDH_500_SERVER_ERROR;
	    	dwHttpSubError = SUBERRORCODE500_INVALID_APP;
	    	break;

        case IDE_GLOBAL_ASA_FORBIDDEN:
    		headerId = IDH_500_SERVER_ERROR;
	    	dwHttpSubError = SUBERRORCODE500_GLOBALASA_FORBIDDEN;
	    	break;

        default:
            headerId = IDH_500_SERVER_ERROR;
    		dwHttpSubError = SUBERRORCODE500_SERVER_ERROR;
    		break;
		}

    pIReq->SetDwHttpStatusCode(500);
    return HandleSysError(500, dwHttpSubError, errorId, headerId, pIReq, NULL);
}

/*===================================================================
HandleOOMError

Handle OOM error with special care, because we can not do any dynamic allocation.

if pIReq or pHitObj is NULL, nothing will be reported to browser

Returns:
	Nothing
===================================================================*/
HRESULT HandleOOMError(	CIsapiReqInfo   *pIReq,
						CHitObj *pHitObj)
{
	CErrInfo OOMErrInfo;
	CErrInfo *pErrInfo;

	pErrInfo = (CErrInfo *)&OOMErrInfo;

	pErrInfo->m_pIReq 	= pIReq;
	pErrInfo->m_pHitObj	= pHitObj;
	pErrInfo->m_dwMask	= g_ErrInfoOOM.m_dwMask;
	pErrInfo->m_szItem[Im_szErrorCode] = g_ErrInfoOOM.m_szItem[Im_szErrorCode];
	pErrInfo->m_szItem[Im_szShortDescription] = g_ErrInfoOOM.m_szItem[Im_szShortDescription];
	pErrInfo->m_szItem[Im_szLongDescription] = g_ErrInfoOOM.m_szItem[Im_szLongDescription];

	pErrInfo->LogError();

	return S_OK;
}
/*===================================================================
HandleError

Handle reporting of errors given ErrorID, FileName, and LineNum.

If Caller provide ErrCode or LongDescription, the default value will be overwriten.

Strings passed in will be freed.  That is, consider the function as a sink.  Caller
should not use strings after the call.

Returns:
	Nothing
===================================================================*/
HRESULT	HandleError(	UINT ErrorID,
						CHAR *szFileName, 
						CHAR *szLineNum, 
						CHAR *szEngine,
						CHAR *szErrCode,
						CHAR *szLongDes,
						CIsapiReqInfo   *pIReq, 
						CHitObj *pHitObj,
                        va_list *pArgs)
{
	CErrInfo	SysErrInfo;
	CErrInfo	*pErrInfo;
	CHAR		szResourceStr[MAX_RESSTRINGSIZE];
    CHAR        szUnformattedResStr[MAX_RESSTRINGSIZE];
	HRESULT		hr = S_OK;

	pErrInfo = (CErrInfo *)&SysErrInfo;

	pErrInfo->m_szItem[Im_szFileName] 	= szFileName;
	pErrInfo->m_szItem[Im_szLineNum]	= szLineNum;
	pErrInfo->m_szItem[Im_szEngine]		= szEngine;

	pErrInfo->m_pHitObj	= pHitObj;
	pErrInfo->m_pIReq	= pIReq;

	//Load resource string according to the resource ID.

    if (pArgs) {
	    CchLoadStringOfId(ErrorID, szUnformattedResStr, MAX_RESSTRINGSIZE);
        vsprintf(szResourceStr, szUnformattedResStr, *pArgs);
    }
    else {
	    CchLoadStringOfId(ErrorID, szResourceStr, MAX_RESSTRINGSIZE);
    }

	pErrInfo->ParseResourceString(szResourceStr);

	//NOTE: if ErrorCode/LongDescription not NULL, caller want to overwrite.
	if (szErrCode)
		{
		pErrInfo->m_szItem[Im_szErrorCode] = szErrCode;
		}
	if(szLongDes)
		{
		pErrInfo->m_szItem[Im_szLongDescription] = szLongDes;
		}
		
	hr = pErrInfo->LogError();

	//free up the inputs
	FreeNullifySz((CHAR **)&szFileName);
	FreeNullifySz((CHAR **)&szLineNum);
	FreeNullifySz((CHAR **)&szEngine);
	FreeNullifySz((CHAR **)&szErrCode);
	FreeNullifySz((CHAR **)&szLongDes);
	
	return hr;
}
/*===================================================================
HandleError

Handle reporting of errors given all the info.

This is basically a cover over HandleErrorSz which called from OnScriptError.

Strings passed in will be freed.  That is, consider the function as a sink.  Caller
should not use strings after the call.

Returns:
	Nothing
===================================================================*/
HRESULT HandleError(	CHAR *szShortDes,
						CHAR *szLongDes,
						DWORD dwMask,
						CHAR *szFileName, 
						CHAR *szLineNum, 
						CHAR *szEngine, 
						CHAR *szErrCode,
						CIsapiReqInfo   *pIReq, 
						CHitObj *pHitObj)
{
	CErrInfo	SysErrInfo;
	CErrInfo	*pErrInfo;
	HRESULT		hr = S_OK;
	
	pErrInfo = (CErrInfo *)&SysErrInfo;
		
	pErrInfo->m_dwMask 					= dwMask;

	pErrInfo->m_szItem[Im_szHeader]		= NULL;		// Caller has already sent out header
	pErrInfo->m_szItem[Im_szFileName] 	= szFileName;
	pErrInfo->m_szItem[Im_szLineNum]	= szLineNum;
	pErrInfo->m_szItem[Im_szEngine]		= szEngine;
	pErrInfo->m_szItem[Im_szErrorCode]	= szErrCode;
	pErrInfo->m_szItem[Im_szShortDescription]	= szShortDes;
	pErrInfo->m_szItem[Im_szLongDescription]	= szLongDes;
	
	pErrInfo->m_pHitObj	= pHitObj;
	pErrInfo->m_pIReq	= pIReq;

	hr = pErrInfo->LogError();	

	//free up the inputs
	FreeNullifySz((CHAR **)&szFileName);
	FreeNullifySz((CHAR **)&szLineNum);
	FreeNullifySz((CHAR **)&szEngine);
	FreeNullifySz((CHAR **)&szErrCode);
	FreeNullifySz((CHAR **)&szShortDes);
	FreeNullifySz((CHAR **)&szLongDes);
		
	return hr;
}
/*===================================================================
HandleError

Handle reporting of errors given the IActiveScriptError and PFNLINEMAP.

This is basically a cover over HandleErrorSz which called from OnScriptError.

Returns:
	Nothing
===================================================================*/
HRESULT HandleError( IActiveScriptError *pscripterror,
					 CTemplate *pTemplate,
					 DWORD dwEngineID,
					 CIsapiReqInfo  *pIReq, 
					 CHitObj *pHitObj )
	{
	UINT        cchBuf = 0;
	CHAR        *szOrigin = NULL;
	CHAR        *szDesc = NULL;
	CHAR        *szLine = NULL;
	CHAR        *szPrefix = NULL;
	UINT        cchOrigin = 0;
	UINT        cchDesc = 0;
	UINT        cchLineNum = 0;
	UINT        cchLine = 0;
	EXCEPINFO   excepinfo = {0};
	CHAR        *szResult = NULL;
	BSTR        bstrLine = NULL;
	HRESULT     hr;
	DWORD       dwSourceContext = 0;		// Don't trust this one
	ULONG       ulLineError = 0;
	BOOLB       fGuessedLine = FALSE;		// see bug 379
	CHAR        *szLineNumT = NULL;
	LPTSTR      szPathInfo = NULL;
	LPTSTR      szPathTranslated = NULL;
	LONG        ichError = -1;
	CErrInfo	SysErrInfo;
	CErrInfo	*pErrInfo;
    wchar_t     wszUnknownException[128];
    wchar_t     wszUnknownEngine[32];
    CWCharToMBCS  convStr;
	
	pErrInfo = (CErrInfo *)&SysErrInfo;

	pErrInfo->m_pIReq 	= pIReq;
	pErrInfo->m_pHitObj	= pHitObj;

	if (pscripterror == NULL)
		return E_POINTER;

	hr = pscripterror->GetExceptionInfo(&excepinfo);
	if (FAILED(hr))
		goto LExit;

	// bug 99543 If details are deferrred, use the callback to get
	// detailed information.
	if (excepinfo.pfnDeferredFillIn)
		excepinfo.pfnDeferredFillIn(&excepinfo);

	hr = pscripterror->GetSourcePosition(&dwSourceContext, &ulLineError, &ichError);
	if (FAILED(hr))
		goto LExit;

	// Intentionally ignore any error
	(VOID)pscripterror->GetSourceLineText(&bstrLine);

	if (pTemplate == NULL)
		goto LExit;

	// call GetScriptSourceInfo to get path-info (of file) and actual line number where error occurred
	// bug 379: if GetScriptSourceInfo returns fGuessedLine = TRUE, it means we gave it a non-authored line,
	// so we adjust below by not printing bstrLine in the error msg
	if (ulLineError > 0)
		pTemplate->GetScriptSourceInfo(dwEngineID, ulLineError, &szPathInfo, &szPathTranslated, &ulLineError, NULL, &fGuessedLine);
	else
		{
		// ulLineError was zero - no line # specified, so assume main file (usually this will be "out of memory"
		// so effect will be to display the script that was running when this occurred.
		//
		szPathInfo = pTemplate->GetSourceFileName(SOURCEPATHTYPE_VIRTUAL);
		szPathTranslated = pTemplate->GetSourceFileName(SOURCEPATHTYPE_PHYSICAL);
		}

    // if we have HitObj use it to get the virtual path to avoid
    // displaying of wrong path for shared templates
    //
    // first verify that PathTranslated == main file path; this file could be
    // an include file, in which case PszPathInfo is incorrect.
    //
    if (!pTemplate->FGlobalAsa() && _tcscmp(szPathTranslated, pTemplate->GetSourceFileName()) == 0 && pHitObj != NULL && pHitObj->PIReq())
        szPathInfo = pHitObj->PSzCurrTemplateVirtPath();

#if UNICODE
    pErrInfo->m_szItem[Im_szFileName] = StringDupUTF8(szPathInfo);
#else
	pErrInfo->m_szItem[Im_szFileName] = StringDupA(szPathInfo);
#endif
	szLineNumT = (CHAR *)malloc(10*sizeof(CHAR));
	if (szLineNumT)
		{
		// convert the line number
		_ltoa(ulLineError, szLineNumT, 10);
		}
	pErrInfo->m_szItem[Im_szLineNum] = szLineNumT;

	
	// is the scode one of the VBScript of JavaScript errors (this needs to be lang independent)
	// excepinfo.bstrDescription now has the formatted error string.
	if (excepinfo.bstrSource && excepinfo.bstrDescription)
		{
		// Bug 81954: Misbehaved objects may throw an exception without providing any information
		wchar_t *wszDescription;
		if (excepinfo.bstrDescription[0] == L'\0')
			{
			HRESULT hrError;

			if (0 == excepinfo.wCode)
				hrError = excepinfo.scode;
			else
				hrError = excepinfo.wCode;
            
            wszUnknownException[0] = '\0';
			// Bug 91847 Attempt to get a description via FormatMessage()
			if (!HResultToWsz(hrError, wszUnknownException, 128))
				CwchLoadStringOfId(IDE_SCRIPT_UNKNOWN, wszUnknownException, sizeof(wszUnknownException)/sizeof(WCHAR));
			wszDescription = wszUnknownException;
			}
		else
			wszDescription = excepinfo.bstrDescription;

		wchar_t *wszSource;
		if (excepinfo.bstrSource[0] == L'\0')
			{
            wszUnknownEngine[0] = '\0';
			CwchLoadStringOfId(IDS_DEBUG_APP, wszUnknownEngine, sizeof(wszUnknownEngine)/sizeof(WCHAR));
			wszSource = wszUnknownEngine;
			}
		else
			wszSource = excepinfo.bstrSource;

		CHAR *ch = NULL;
		
		// convert the Source to ascii

        if (convStr.Init(wszSource) != NO_ERROR) {
            szOrigin = NULL;
        }
        else {
            szOrigin = convStr.GetString(TRUE);
        }
		if (NULL != szOrigin) 
			{
			// Remove the word "error"from  the string, if any, because we will 
			//print out "error" when we print out the errorID
			cchOrigin = strlen(szOrigin);
			if (cchOrigin > 5) // 5 is strlen("error")
				{
				ch = szOrigin + cchOrigin - 5;
				if (!strncmp(ch, "error", 5))
					{// we found the word "error", truncate the szOrigin by null out the word "error"
					*ch = '\0';
					}
			  	}
			  	ch = NULL;
			} 	
		pErrInfo->m_szItem[Im_szEngine] = szOrigin;

        
		// convert the sDescription to ascii
        if (convStr.Init(wszDescription) != NO_ERROR) {
            szDesc = NULL;
        }
        else {
            szDesc = convStr.GetString(TRUE);
        }
					
		//check whether the szDesc is Denali/formatted error resource string or other unformatted string
		if (FALSE == FIsResStrFormatted(szDesc))
			{
			//unformatted string.
			pErrInfo->m_dwMask 	= dwDefaultMask;
			if (0 == excepinfo.wCode)
				pErrInfo->m_szItem[Im_szErrorCode] 		= SzScodeToErrorCode(excepinfo.scode);
			else
				pErrInfo->m_szItem[Im_szErrorCode] 		= SzScodeToErrorCode(excepinfo.wCode);
				
			pErrInfo->m_szItem[Im_szShortDescription] 	= StringDupA(szDesc);
			pErrInfo->m_szItem[Im_szLongDescription]	= NULL;
			}
		else
			{
			pErrInfo->ParseResourceString(szDesc);

			char *szTempErrorCode 		= SzScodeToErrorCode(excepinfo.scode);
			char *szTempErrorASPCode	= StringDupA(pErrInfo->m_szItem[Im_szErrorCode]);
			int nstrlen					= strlen(szTempErrorCode) + strlen(szTempErrorASPCode); 
			
			pErrInfo->m_szItem[Im_szErrorCode] = new char[nstrlen+4];
			
			if(pErrInfo->m_szItem[Im_szErrorCode])			
				sprintf(pErrInfo->m_szItem[Im_szErrorCode], "%s : %s", szTempErrorASPCode, szTempErrorCode); 

			if (szTempErrorCode)
				delete [] szTempErrorCode; 
				
			if(szTempErrorASPCode)	
				delete [] szTempErrorASPCode;
			
			//pErrInfo->m_szItem[Im_szErrorCode] = StrDup(pErrInfo->m_szItem[Im_szErrorCode]);
			pErrInfo->m_szItem[Im_szShortDescription] 	= StringDupA(pErrInfo->m_szItem[Im_szShortDescription]);
			pErrInfo->m_szItem[Im_szLongDescription]	= StringDupA(pErrInfo->m_szItem[Im_szLongDescription]);
			}

		/*
		 * If we didnt guess a line, and we have a line of source code to display
		 * then attempt to display it and hopefully a line of ------^ to point to the error
		 */
		if (!fGuessedLine && bstrLine != NULL)
			{
			INT cchDBCS = 0;		// Number of DBCS characters in source line
			CHAR *pszTemp = NULL;	// Temp sz pointer used to calculate cchDBCS
			// convert the source code line

            if (FAILED(hr = convStr.Init(bstrLine))) {
                goto LExit;
            }
            szLine = convStr.GetString();
				
			cchLine = strlen(szLine);
			if (0 == cchLine)
				goto LExit;

			// Check for DBCS character, and cchLine -= NumberofDBCScharacter, such that 
			// the ----^ will point to the right position.
			pszTemp = szLine;
			while(*pszTemp != NULL)
				{
					if (IsDBCSLeadByte(*pszTemp))
					{
						cchDBCS++;
						pszTemp += 2;	// skip 2 bytes
					}
					else
					{
						pszTemp++;		// single byte
					}
				}

			// compute the size of the source code indicator:
			// "<source line> + '\r\n' + <error pos>*'-' + '^'
			// 3 chars. without source line and '-'
			LONG ichErrorT = ichError;
			cchBuf += cchLine + ichErrorT + 3;

			// allocate the result buffer
			szResult = new(char[cchBuf + 2]);
			if (szResult == NULL)
				goto LExit;

			// fill up the buffer
			ch = szResult;

			// append the <PRE>
			// bug 87118, moved to template for a proper HTML encoding

			// <source line>
			if (cchLine)
				strncpy(ch, szLine, cchLine);
			ch += cchLine;

			// stick the "----^" string on the end
			if (ichErrorT > -1)
				{
				// prepend the '\n'
				strncpy(ch, "\r\n", 2);
				ch += 2;
				// put in the "---"'s, and shrink "---" by #ofDBCS
				ichErrorT -= cchDBCS;
				while (ichErrorT-- > 0)
					*ch++ = '-';

				*ch++ = '^';
				}

			// append the </PRE>
			// bug 87118, moved to template for a proper HTML encoding

			// terminate the string
			*ch++ = '\0';
			pErrInfo->m_szItem[Im_szCode] = szResult;

			// add line and column to error object
			pErrInfo->m_nColumn = ichError;
			pErrInfo->m_bstrLineText = bstrLine;
			}
		}
	else
		{
		// Not VBS or other Engine errors/Unknown error
		// Load Default
		// try to compute a specific error message
		HRESULT hr_def;
		hr_def = GetSpecificError(pErrInfo, excepinfo.scode);
		CHAR *szShortDescription = new CHAR[256];

		// if that failed try to compute a generic error
		if (FAILED(hr_def))
			{
			pErrInfo->m_dwMask							= dwDefaultMask;
			if (0 == excepinfo.wCode)
				{
				pErrInfo->m_szItem[Im_szErrorCode] 		= SzScodeToErrorCode(excepinfo.scode);
				// Bug 91847 Attempt to get a description via FormatMessage()
				if ((szShortDescription != NULL) && 
					!HResultToSz(excepinfo.scode, szShortDescription, 256)) 
					{
					// Displaying the error number twice would be redundant, delete it
					delete [] szShortDescription;
					szShortDescription = NULL;
					}
				}
			else
				{
				pErrInfo->m_szItem[Im_szErrorCode] 		= SzScodeToErrorCode(excepinfo.wCode);
				// Bug 91847 Attempt to get a description via FormatMessage()
				if ((szShortDescription != NULL) && 
					!HResultToSz(excepinfo.wCode, szShortDescription, 256)) 
					{
					// Displaying the error number twice would be redundant, delete it
					delete [] szShortDescription;
					szShortDescription = NULL;
					}
				}
			pErrInfo->m_szItem[Im_szEngine] 			= NULL;
			pErrInfo->m_szItem[Im_szShortDescription] 	= szShortDescription;
			pErrInfo->m_szItem[Im_szLongDescription]	= NULL;
			}
		}

LExit:
	if (excepinfo.bstrSource)
		{
		SysFreeString(excepinfo.bstrSource);
		}

	if (excepinfo.bstrDescription)
		{
		SysFreeString(excepinfo.bstrDescription);
		}

	if (excepinfo.bstrHelpFile)
		{
		SysFreeString(excepinfo.bstrHelpFile);
		}

	pErrInfo->LogError();

	if (bstrLine)
		{
		SysFreeString(bstrLine);
		}

	FreeNullifySz((CHAR **)&szDesc);

	for(INT iErrInfo = 0; iErrInfo < Im_szItemMAX; iErrInfo++)
		{
		FreeNullifySz((CHAR **)&pErrInfo->m_szItem[iErrInfo]);
		}
	
	return S_OK;
	}
	
/*===================================================================
LoadErrResString

Loads an error string(formatted) from the string table.

Returns:
		pdwMask
		szErrorCode
		szShortDes
		szLongDes

if any of the szVariable is NULL, that particular string value will not be loaded.

		S_OK	if successes.
		E_FAIL	if fails.
Side Effect
		NONE
===================================================================*/
HRESULT	LoadErrResString(
UINT ErrID/*IN*/, 
DWORD *pdwMask, 
CHAR *szErrorCode, 
CHAR *szShortDes, 
CHAR *szLongDes)
{
	CHAR 	*szToken 	= NULL;
	CHAR 	szResTemp[2*MAX_RESSTRINGSIZE];	//ResourceTempString
	INT		cch			= 0;

	cch = CchLoadStringOfId(ErrID, szResTemp, MAX_RESSTRINGSIZE);

	//Mask
	szToken = (char *)_mbstok((unsigned char *)szResTemp, (unsigned char *)DELIMITER);
	if (NULL != szToken)
		*pdwMask = atoi(szToken);
	else
		Assert(FALSE);

	//ErrorCode
	szToken = (char *)_mbstok(NULL, (unsigned char *)DELIMITER);
	if (NULL != szToken && NULL != szErrorCode)
		{
		cch = strlen(szToken);
		memcpy(szErrorCode, szToken, cch);
		szErrorCode[cch] = '\0';
		}

	//ShortDescription
	szToken = (char *)_mbstok(NULL, (unsigned char *)DELIMITER);
	if (NULL != szToken && NULL != szShortDes)
		{
		cch = strlen(szToken);
		memcpy(szShortDes, szToken, cch);
		szShortDes[cch] = '\0';
		}

	//LongDescription
	szToken = (char *)_mbstok(NULL, (unsigned char *)DELIMITER);
	if (NULL != szToken && NULL != szLongDes)
		{
		cch = strlen(szToken);
		memcpy(szLongDes, szToken, cch);
		szLongDes[cch] = '\0';
		}

	return S_OK;
}

/*===================================================================
SzScodeToErrorCode

Conver Scode to string

Returns:
	Composed string

Side Effects:
	***ALLOCATES MEMORY -- CALLER MUST FREE***
===================================================================*/
CHAR *SzScodeToErrorCode
(
HRESULT hrError
)
	{
	CHAR *szResult = NULL;
	CHAR szBuf[17];
	CHAR *szNumber;
	CHAR *szError;
	INT iC;
	INT cch;
	
	// put a bunch of zeros into the buffer
	for (iC = 0; iC < 16; ++iC)
		szBuf[iC] = '0';

	// szNumber points half way into the buffer
	szNumber = &szBuf[8];

	// get the error szNumber as a hex string
	_ltoa(hrError, szNumber, 16);

	// back up szNumber to allow a total of 8 digits
	szNumber -= 8 - strlen(szNumber);

	cch = strlen(szNumber) + 1;

	szError = new(CHAR[cch]);
	if (szError != NULL)
		{
		szError[0] = '\0';
		strcat(szError, szNumber);
		szResult = szError;
		}
	else
		{
		HandleOOMError(NULL, NULL);
		}

	return(szResult);
	}

/*===================================================================
SzComposeSpecificError

Compose a specific error for an HRESULT of the form:
	<string> <error-number>

This is our last resort if there is not more useful information to be had.

Returns:
	Composed string

Side Effects:
	***ALLOCATES MEMORY -- CALLER MUST FREE***
===================================================================*/
HRESULT GetSpecificError
(
CErrInfo *pErrInfo,
HRESULT hrError
)
	{
	HRESULT hr_return = E_FAIL;
	UINT idErr;

	switch (hrError)
		{
		case DISP_E_MEMBERNOTFOUND:
			idErr = IDE_SCRIPT_METHOD_NOT_FOUND;
			break;

		case DISP_E_UNKNOWNNAME:
			idErr = IDE_SCRIPT_UNKNOWN_NAME;
			break;

		case DISP_E_UNKNOWNINTERFACE:
			idErr = IDE_SCRIPT_UNKNOWN_INTERFACE;
			break;

		case DISP_E_PARAMNOTOPTIONAL:
			idErr = IDE_SCRIPT_MISSING_PARAMETER;
			break;

		default:
			// Not one of the errors we know how to handle specially.  E_FAIL will be returned.
			idErr = 0;
			break;
		}

	// build a szResult string if we find a match
	if (idErr != 0)
		{
		hr_return = LoadErrResString(idErr, 
									&(pErrInfo->m_dwMask),
									pErrInfo->m_szItem[Im_szErrorCode],
									pErrInfo->m_szItem[Im_szShortDescription],
									pErrInfo->m_szItem[Im_szLongDescription]
									);
		}

	return(hr_return);
	}

/*===================================================================
HResultToWsz

Tranlates a HRESULT to a description string of the HRESULT.  Attempts
to use FormatMessage() to get a 

Parameters:
	hrIn	The error to lookup
	wszOut	String to output the description to
	cdwOut	Number of WCHARs wszOut can hold

Returns:
	TRUE if a description string was found
	FALSE if the error number was output instead

Notes:
	Added to resolve bug 91847.  When unexpected errors are processed
	the naked error number was output, which developers would then 
	have to look up in winerror.h.
===================================================================*/
BOOL HResultToWsz(HRESULT hrIn, WCHAR *wszOut, DWORD cdwOut) 
	{
	LANGID langID = LANG_NEUTRAL;
    DWORD   dwFound = 0;
    HMODULE  hMsgModule = NULL;

#ifdef USE_LOCALE
	LANGID *pLangID;
	
	pLangID = (LANGID *)TlsGetValue(g_dwTLS);

	if (NULL != pLangID)
		langID = *pLangID;
#endif

    if (HRESULT_FACILITY(hrIn) == (HRESULT)FACILITY_INTERNET)
        hMsgModule = GetModuleHandleA("METADATA");
    else
        hMsgModule = GetModuleHandleA("ASP");
    
    dwFound = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_FROM_HMODULE,
					    hMsgModule,
					    hrIn,
					    langID,
					    wszOut,
					    cdwOut,
					    NULL);


	if (!dwFound) 
		{
		// Error not found, make a string out of the error number
		WCHAR *wszResult = NULL;
		WCHAR wszBuf[17];
		WCHAR *wszNumber;
		WCHAR *wszError;
		INT iC;
	
		// put a bunch of zeros into the buffer
		for (iC = 0; iC < 16; ++iC)
			wszBuf[iC] = L'0';

		// wszNumber points half way into the buffer
		wszNumber = &wszBuf[8];

		// get the error wszNumber as a hex string
		_ltow(hrIn, wszNumber, 16);

		// back up szNumber to allow a total of 8 digits
		wszNumber -= 8 - wcslen(wszNumber);

		// Copy the result to wszOut
		wcsncpy(wszOut, wszNumber, cdwOut);

		return FALSE;
		}
	else
		return TRUE;
	}

HMODULE GetModuleHandleForHRESULT(HRESULT  hrIn)
{
    char        szModuleName[MAX_PATH];
    DWORD       pathLen = 0;
    char       *pch;

    szModuleName[0] = '\0';

    if (g_fOOP) {

            strcat(szModuleName, "INETSRV\\");
    }

    if (HRESULT_FACILITY(hrIn) == (HRESULT)FACILITY_INTERNET)
        strcat(szModuleName, "METADATA.DLL");       
    else
        strcat(szModuleName, "ASP.DLL");       

    return(LoadLibraryExA(szModuleName, NULL, LOAD_LIBRARY_AS_DATAFILE));
}    

/*===================================================================
HResultToSz

Tranlates a HRESULT to a description string of the HRESULT.  Attempts
to use FormatMessage() to get a 

Parameters:
	hrIn	The error to lookup
	szOut	String to output the description to
	cdwOut	Number of WCHARs wszOut can hold

Returns:
	TRUE if a description string was found
	FALSE if the error number was output instead

Notes:
	Added to resolve bug 91847.  When unexpected errors are processed
	the naked error number was output, which developers would then 
	have to look up in winerror.h.
===================================================================*/
BOOL HResultToSz(HRESULT hrIn, CHAR *szOut, DWORD cdwOut) 
	{
	LANGID langID = LANG_NEUTRAL;
    HMODULE  hMsgModule = NULL;
    BOOL     bFound = FALSE;

#ifdef USE_LOCALE
	LANGID *pLangID;
	
	pLangID = (LANGID *)TlsGetValue(g_dwTLS);

	if (NULL != pLangID)
		langID = *pLangID;
#endif

    hMsgModule = GetModuleHandleForHRESULT(hrIn);

    HRESULT hr = GetLastError();

    bFound = FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_FROM_HMODULE,
					    hMsgModule,
					    hrIn,
					    langID,
					    szOut,
					    cdwOut,
					    NULL);

    // make one additional check before giving up.  If the facility of the error is
    // WIN32, then retry the call after masking out the facility code to get standard
    // WIN32 errors. I.E. 80070005 is really just 5 - access denied

    if (!bFound && (HRESULT_FACILITY(hrIn) == (HRESULT)FACILITY_WIN32)) {

        bFound = FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_FROM_HMODULE,
					    NULL,
					    hrIn & 0xffff,
					    langID,
					    szOut,
					    cdwOut,
					    NULL);
    }

    if (hMsgModule)
        FreeLibrary(hMsgModule);

	if (!bFound ) 
		{
		// Error not found, make a string out of the error number
		CHAR *szResult = NULL;
		CHAR szBuf[17];
		CHAR *szNumber;
		CHAR *szError;
		INT iC;
	
		// put a bunch of zeros into the buffer
		for (iC = 0; iC < 16; ++iC)
			szBuf[iC] = L'0';

		// wszNumber points half way into the buffer
		szNumber = &szBuf[8];

		// get the error wszNumber as a hex string
		_ltoa(hrIn, szNumber, 16);

		// back up szNumber to allow a total of 8 digits
		szNumber -= 8 - strlen(szNumber);

		// Copy the result to wszOut
		strncpy(szOut, szNumber, cdwOut);

		return FALSE;
		}
	else
		return TRUE;
	}

/*===================================================================
FIsResStrFormatted

Check for formatted resource string.

RETURN:
	TRUE/FALSE
===================================================================*/
BOOL FIsResStrFormatted(char *szIn)
{
	BOOL  freturn = FALSE;
	UINT  cDelimiter = 0;
	CHAR  *pch;

	if(szIn)
		{
			pch = szIn;
			while(*pch)
			{
			if ('~' == *pch)
				cDelimiter++;
			pch = CharNextA(pch);
			}

			if(3 == cDelimiter)
				return TRUE;
		}
	return freturn;
	
}

/*===================================================================
HandleErrorMissingFilename

In several circumstances we want to report an error, but
we have no filename, and the normal method for getting
the filename from the template wont work because we have
no line number info either (e.g. Script timeout, GPF, control GPF, etc)

Get the filename from the CIsapiReqInfo (if possible) and report the error.

Returns:
	Nothing
===================================================================*/
VOID HandleErrorMissingFilename
(
UINT errorID,
CHitObj *pHitObj,
BOOL    fAddlInfo /* = FALSE */,
...
)
	{
    va_list args;

    if (fAddlInfo)
        va_start(args, fAddlInfo);

	CHAR *szFileName = NULL;

	if (pHitObj && pHitObj->PSzCurrTemplateVirtPath())
		{
#if UNICODE
        szFileName = StringDupUTF8(pHitObj->PSzCurrTemplateVirtPath());
#else
   		szFileName = StringDupA(pHitObj->PSzCurrTemplateVirtPath());
#endif
		}
		
	char szEngine[64];
	CchLoadStringOfId(IDS_ENGINE, szEngine, sizeof szEngine);

	char *pszEngine = new char [strlen(szEngine) + 1];
	if (pszEngine)
		{
		// If the alloc failed, we will pass NULL to HandleError for pszEngine, which is fine.
		// (old code used to pass NULL)  All that will happen is that the AspError.Category == "". Oh Well.
		// TODO: change this function to return an HRESULT.
		//
		strcpy(pszEngine, szEngine);
		}

	HandleError(errorID, szFileName, NULL, pszEngine, NULL, NULL, NULL, pHitObj, fAddlInfo ? &args : NULL);
	}

/*===================================================================
DebugError

Handle a script error by invoking the debugger.

Returns:
	fails if debugger cannot be invoked.
	If this function fails, no other action is taken.
	  (Therefore, the caller should make sure error is reported in
	   some other way)
===================================================================*/
HRESULT DebugError(IActiveScriptError *pScriptError, CTemplate *pTemplate, DWORD dwEngineID, IDebugApplication *pDebugApp)
	{
	EXCEPINFO excepinfo = {0};
	BSTR bstrLine = NULL;
	DWORD dwSourceContext = 0;
	ULONG ulLineError = 0;
	ULONG ichLineError = 0;			// character offset of the line in the source
	ULONG cchLineError = 0;			// length of the source line
	BOOLB fGuessedLine = FALSE;		// see bug 379
	LPTSTR szPathInfo = NULL;
	LPTSTR szPathTranslated = NULL;
	LONG ichError = -1;
	HRESULT hr = S_OK;
	IDebugDocumentContext *pDebugContext = NULL;
	wchar_t *wszErrNum, *wszShortDesc, *wszLongDesc;	// Used to tokenize resource strings
	
	if (pScriptError == NULL || pTemplate == NULL || pDebugApp == NULL)
		return E_POINTER;

	if (FAILED(pScriptError->GetSourcePosition(&dwSourceContext, &ulLineError, &ichError)))
		return E_FAIL;

	if (FAILED(pScriptError->GetExceptionInfo(&excepinfo)))
		return E_FAIL;

	// call template object to get line number and character offset where error occurred
	// (It returns both - caller discards whichever it does not want)
	// bug 379: if pTemplate returns fGuessedLine == TRUE, it means we gave it a non-authored
	// line, so we adjust below by not printing bstrLine in the error msg
	pTemplate->GetScriptSourceInfo(dwEngineID, ulLineError, &szPathInfo, &szPathTranslated, NULL, &ichLineError, NULL);

	// Create a new document context for this statement
	// CONSIDER: character count that we return is bogus - however our debugging
	//           client (Caesar's) does not use this information anyway.
	//
	// If this is in the main file, create a document context based on the CTemplate compiled source
	if (_tcscmp(szPathTranslated, pTemplate->GetSourceFileName()) == 0)
		pDebugContext = new CTemplateDocumentContext(pTemplate, ichLineError, 1);

	// source refers to an include file, so create a documet context based on cached CIncFile dependency graph
	else
		{
		CIncFile *pIncFile;
		if (FAILED(g_IncFileMap.GetIncFile(szPathTranslated, &pIncFile)))
			{
			hr = E_FAIL;
			goto LExit;
			}

		pDebugContext = new CIncFileDocumentContext(pIncFile, ichLineError, 1);
		pIncFile->Release();
		}

	if (pDebugContext == NULL)
		{
		hr = E_OUTOFMEMORY;
		goto LExit;
		}

	// Yes it does, bring up the debugger on this line
    hr =  InvokeDebuggerWithThreadSwitch
        (
        pDebugApp,
        DEBUGGER_UI_BRING_DOC_CONTEXT_TO_TOP,
        pDebugContext
        );
	if (FAILED(hr))
		goto LExit;
	

	// pop up a message box with the error description
	// Bug 81954: Misbehaved objects may throw an exception without providing any information
	wchar_t wszExceptionBuffer[256];
	wchar_t *wszDescription;
	if (excepinfo.bstrDescription == NULL || excepinfo.bstrDescription[0] == L'\0')
		{
		HRESULT hrError;

		if (0 == excepinfo.wCode)
			hrError = excepinfo.scode;
		else
			hrError = excepinfo.wCode;

		// Bug 91847 Attempt to get a description via FormatMessage()
		if (!HResultToWsz(hrError, wszExceptionBuffer, 128))
			CwchLoadStringOfId(IDE_SCRIPT_UNKNOWN, wszExceptionBuffer, sizeof(wszExceptionBuffer)/sizeof(WCHAR));
		wszDescription = wszExceptionBuffer;
		}
	else
		wszDescription = excepinfo.bstrDescription;

	wchar_t wszSource[35];
	CwchLoadStringOfId(IDS_SCRIPT_ERROR, wszSource, sizeof(wszSource)/sizeof(WCHAR));

	// See if this is resource formatted string, and if it is, get pointers to short & long string
	// resource formatted strings are delimited by '~' characters  There are three '~' characters
	// in the resource formatted string
	//
	wszErrNum = wcschr(wszDescription, L'~');
	if (wszErrNum)
		{
		wszShortDesc = wcschr(wszErrNum + 1, L'~');
		if (wszShortDesc)
			{
			wszLongDesc = wcschr(wszShortDesc + 1, L'~');

			// OK. If all three tests succeeded, we know this is a resource formatted string,
			// and we have pointers to all three segments. Replace each '~' with two newlines.
			// First: Load resource strings

			wchar_t wszErrorBegin[20], wszErrorEnd[5];
			wchar_t *pwchEnd;

			CwchLoadStringOfId(IDS_DEBUGGER_TEMPLATE_BEGIN, wszErrorBegin, sizeof(wszErrorBegin)/sizeof(WCHAR));
			CwchLoadStringOfId(IDS_DEBUGGER_TEMPLATE_END, wszErrorEnd, sizeof(wszErrorEnd)/sizeof(WCHAR));

			// Tokenize string by setting '~' characters to NULL and incrementing ptrs

			*wszErrNum++ = *wszShortDesc++ = *wszLongDesc++ = L'\0';

			// Build the string

			pwchEnd = strcpyExW(wszExceptionBuffer, excepinfo.bstrSource);
			*pwchEnd++ = L' ';
			pwchEnd = strcpyExW(pwchEnd, wszErrorBegin);
			pwchEnd = strcpyExW(pwchEnd, wszErrNum);
			pwchEnd = strcpyExW(pwchEnd, wszErrorEnd);
			*pwchEnd++ = L'\n';
			*pwchEnd++ = L'\n';

			pwchEnd = strcpyExW(pwchEnd, wszShortDesc);
			*pwchEnd++ = L'\n';
			*pwchEnd++ = L'\n';

			pwchEnd = strcpyExW(pwchEnd, wszLongDesc);

			wszDescription = wszExceptionBuffer;
			}
		}

	// Win95 does not support MessageBoxW()  -- moot since debugging not supported on Win95
	Assert (FIsWinNT());
	MessageBoxW(NULL, wszDescription, wszSource, MB_SERVICE_NOTIFICATION | MB_TOPMOST | MB_OK | MB_ICONEXCLAMATION);

LExit:
	if (pDebugContext)
		pDebugContext->Release();

	if (excepinfo.bstrSource)
		SysFreeString(excepinfo.bstrSource);

	if (excepinfo.bstrDescription)
		SysFreeString(excepinfo.bstrDescription);

	if (excepinfo.bstrHelpFile)
		SysFreeString(excepinfo.bstrHelpFile);

	return hr;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\eventlog.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: NT Event logging

File: Eventlog.cpp

Owner: Jhittle

This file contains general event logging routines for Denali.
===================================================================*/ 

#include "denpre.h"
#pragma hdrstop
#include <direct.h>
#include "denevent.h"
#include "memchk.h"

extern HINSTANCE g_hinstDLL;
extern CRITICAL_SECTION g_csEventlogLock;

/*===================================================================
STDAPI  UnRegisterEventLog( void )

UnRegister the event log.

Returns:
	HRESULT S_OK or E_FAIL
	
Side effects:
	Removes denali NT eventlog entries from the registry
===================================================================*/
STDAPI UnRegisterEventLog( void )
	{
	HKEY		hkey = NULL;
	DWORD		iKey;
	CHAR		szKeyName[255];
	DWORD		cbKeyName;
	static const char szDenaliKey[] = "SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\Active Server Pages";	

	// Open the HKEY_CLASSES_ROOT\CLSID\{...} key so we can delete its subkeys
	if	(RegOpenKeyExA(HKEY_LOCAL_MACHINE, szDenaliKey, 0, KEY_READ | KEY_WRITE, &hkey) != ERROR_SUCCESS)
		goto LErrExit;

	// Enumerate all its subkeys, and delete them
	for (iKey=0;;iKey++)
		{
		cbKeyName = sizeof(szKeyName);
		if (RegEnumKeyExA(hkey, iKey, szKeyName, &cbKeyName, 0, NULL, 0, NULL) != ERROR_SUCCESS)
			break;

		if (RegDeleteKeyA(hkey, szKeyName) != ERROR_SUCCESS)
			goto LErrExit;
		}

	// Close the key, and then delete it
	if (RegCloseKey(hkey) != ERROR_SUCCESS)
		return E_FAIL;
			
	if (RegDeleteKeyA(HKEY_LOCAL_MACHINE, szDenaliKey) != ERROR_SUCCESS)
		return E_FAIL;

	return S_OK;

LErrExit:
	RegCloseKey(hkey);
	return E_FAIL;
	}

/*===================================================================
STDAPI  RegisterEventLog(void)

Register the NT event log.

Returns:
	HRESULT S_OK or E_FAIL
	
Side effects:
	Sets up denali dll in the Eventlog registry for resolution of
	NT eventlog message strings
===================================================================*/
STDAPI RegisterEventLog( void )
	{

	HKEY	hk;                      // registry key handle 
	DWORD	dwData;					
	BOOL	bSuccess;
	//char	szMsgDLL[MAX_PATH];	

	char    szPath[MAX_PATH];
	char    *pch;

	// Get the path and name of Denali
	if (!GetModuleFileNameA(g_hinstDLL, szPath, sizeof(szPath)/sizeof(char)))
		return E_FAIL;
		
	// BUG FIX: 102010 DBCS code changes
	//
	//for (pch = szPath + lstrlen(szPath); pch > szPath && *pch != TEXT('\\'); pch--)
	//	;
	//	
	//if (pch == szPath)
	//	return E_FAIL;

	pch = (char*) _mbsrchr((const unsigned char*)szPath, '\\');
	if (pch == NULL)	
		return E_FAIL;
		
		
	strcpy(pch + 1, ASP_DLL_NAME);		
	
  	
	// When an application uses the RegisterEventSource or OpenEventLog
	// function to get a handle of an event log, the event loggging service
	// searches for the specified source name in the registry. You can add a
	// new source name to the registry by opening a new registry subkey
	// under the Application key and adding registry values to the new
	// subkey. 

	// Create a new key for our application 
	bSuccess = RegCreateKeyA(HKEY_LOCAL_MACHINE,
		"SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application\\Active Server Pages", &hk);

	if(bSuccess != ERROR_SUCCESS)
		return E_FAIL;

	// Add the Event-ID message-file name to the subkey. 
	bSuccess = RegSetValueExA(hk,  	// subkey handle         
		"EventMessageFile",       	// value name            
		0,                        	// must be zero          
		REG_EXPAND_SZ,            	// value type            
		(LPBYTE) szPath,        	// address of value data 
		strlen(szPath) + 1);   		// length of value data  
		
	if(bSuccess != ERROR_SUCCESS)
		goto LT_ERROR;
	

	// Set the supported types flags and addit to the subkey. 
	dwData = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE;
	bSuccess = RegSetValueExA(hk,	// subkey handle                
		"TypesSupported",         	// value name                   
		0,                        	// must be zero                 
		REG_DWORD,                	// value type                   
		(LPBYTE) &dwData,         	// address of value data        
		sizeof(DWORD));           	// length of value data         

	if(bSuccess != ERROR_SUCCESS)
		goto LT_ERROR;

	RegCloseKey(hk);	
	return S_OK;

	LT_ERROR:

	RegCloseKey(hk);	
	return E_FAIL;
	}

/*===================================================================
STDAPI  reportAnEvent(DWORD, WORD, LPSTR); 

Register report an event to the NT event log

INPUT: 
	the event ID to report in the log, the number of insert    
    strings, and an array of null-terminated insert strings
    
Returns:
	HRESULT S_OK or E_FAIL
	
Side effects:
	Addes an entry in the NT event log
===================================================================*/
STDAPI ReportAnEvent(DWORD dwIdEvent, WORD wEventlog_Type, WORD cStrings, LPCSTR  *pszStrings)
	{
  	HANDLE	hAppLog;
  	BOOL	bSuccess;
  	HRESULT hr = S_OK;

  	

  	// Get a handle to the Application event log 
  	hAppLog = RegisterEventSourceA(NULL,   		// use local machine      
    	  "Active Server Pages");                   	// source name                 
      
	if(hAppLog == NULL)
		return E_FAIL;

	  // Now report the event, which will add this event to the event log 
	bSuccess = ReportEventA(hAppLog,        		// event-log handle            
    	wEventlog_Type,				    		// event type                  
      	0,		                       			// category zero               
      	dwIdEvent,		              			// event ID                    
      	NULL,					     			// no user SID                 
      	cStrings,								// number of substitution strings     
	  	0,	                       				// no binary data              
      	pszStrings,                				// string array                
      	NULL);                     				// address of data             

	if(!bSuccess)
		hr = E_FAIL;
		
	DeregisterEventSource(hAppLog);
  	return hr;
	}

/*===================================================================
void MSG_DenaliStarted(void) 

report an event to the NT event log

INPUT: 
	None
	
Returns:
	Nonw
	
Side effects:
	Addes an entry in the NT event log
===================================================================*/
void MSG_DenaliStarted(void)
	{
	ReportAnEvent( (DWORD) MSG_DENALI_SERVICE_STARTED, (WORD) EVENTLOG_INFORMATION_TYPE, (WORD) 0, (LPCSTR *) NULL );	
	}  

/*===================================================================
void MSG_DenaliStoped(void) 

report an event to the NT event log

INPUT: 
	None
	
Returns:
	None
	
Side effects:
	Addes an entry in the NT event log
===================================================================*/
void MSG_DenaliStoped(void)
	{
	ReportAnEvent( (DWORD) MSG_DENALI_SERVICE_STOPPED, (WORD) EVENTLOG_INFORMATION_TYPE, (WORD) 0, (LPCSTR *) NULL );  	
	return;
	}  

/*===================================================================
void MSG_Error( LPCSTR sz )

report an event to the NT event log

INPUT: 
	ptr to null-terminated string
	
Returns:
	None
	
Side effects:
	Addes an entry in the NT event log
===================================================================*/
void MSG_Error( LPCSTR strSource )
	{
	static char	szLastError[MAX_MSG_LENGTH];

	EnterCriticalSection(&g_csEventlogLock);
	if (strcmp(strSource, szLastError) == 0)
		{
		LeaveCriticalSection(&g_csEventlogLock);
		return;
		}
		
	strncpy(szLastError,strSource, MAX_MSG_LENGTH);
	szLastError[MAX_MSG_LENGTH-1] = '\0';
	LeaveCriticalSection(&g_csEventlogLock);
	
	ReportAnEvent( (DWORD) MSG_DENALI_ERROR_1, (WORD) EVENTLOG_ERROR_TYPE, (WORD) 1, &strSource /*aInsertStrs*/ );  	
	}  

/*===================================================================
void MSG_Error( UINT ustrID )

report an event to the NT event log

INPUT: 
	string table string ID
	
Returns:
	None
	
Side effects:
	Addes an entry in the NT event log
===================================================================*/
void MSG_Error( UINT SourceID1 )
	{
	static unsigned int nLastSourceID1;

	// if this is a repeat of the last reported message then return
	/// without posting an error.
	EnterCriticalSection(&g_csEventlogLock);
	if (SourceID1 == nLastSourceID1)
		{
		LeaveCriticalSection(&g_csEventlogLock);
		return;
		}
	nLastSourceID1 = SourceID1;
	LeaveCriticalSection(&g_csEventlogLock);
	
	DWORD	cch;
	char	strSource[MAX_MSG_LENGTH];
	char	*aInsertStrs[MAX_INSERT_STRS];   // array of pointers to insert strings
	cch = CchLoadStringOfId(SourceID1, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);                                         
	aInsertStrs[0] = (char*) strSource;    	
	ReportAnEvent( (DWORD) MSG_DENALI_ERROR_1, (WORD) EVENTLOG_ERROR_TYPE, (WORD) 1, (LPCSTR *) aInsertStrs );  	
	return;
	}  


/*===================================================================
void MSG_Error( UINT SourcID1, UINT SourceID2 ) 

report an event to the NT event log

INPUT: 
	two part message of string table string ID's
	
Returns:
	None
	
Side effects:
	Addes an entry in the NT event log
===================================================================*/
void MSG_Error( UINT SourceID1, UINT SourceID2 )
	{
	static unsigned int nLastSourceID1;
	static unsigned int nLastSourceID2;

	// if this is a repeat of the last reported message then return
	// without posting an error.
	EnterCriticalSection(&g_csEventlogLock);
	if (SourceID1 == nLastSourceID1 && SourceID2 == nLastSourceID2)
		{
		LeaveCriticalSection(&g_csEventlogLock);
		return;
		}
		
	nLastSourceID1 = SourceID1;
	nLastSourceID2 = SourceID2;
	LeaveCriticalSection(&g_csEventlogLock);
	
	DWORD	cch;
	char	strSource[MAX_MSG_LENGTH];
	char *aInsertStrs[MAX_INSERT_STRS];   // array of pointers to insert strings
    cch = CchLoadStringOfId(SourceID1, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);                                         
	aInsertStrs[0] = (char*) strSource;    	
	cch = CchLoadStringOfId(SourceID2, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);                                         
	aInsertStrs[1] = (char*) strSource;                                     
	ReportAnEvent( (DWORD) MSG_DENALI_ERROR_2, (WORD) EVENTLOG_ERROR_TYPE, (WORD) 2, (LPCSTR *) aInsertStrs );  	
	return;
	}  

/*===================================================================
void MSG_Error( const char* pszError1, const char* pszError2, const char* pszError3) 

report an event to the NT event log

INPUT: 
	three part message string
	
Returns:
	None
	
Side effects:
	Addes an entry in the NT event log
===================================================================*/
void MSG_Error( UINT SourceID1, UINT SourceID2, UINT SourceID3 )
	{
	static unsigned int nLastSourceID1;
	static unsigned int nLastSourceID2;
	static unsigned int nLastSourceID3;

	// if this is a repeat of the last reported message then return
	/// without posting an error.
	EnterCriticalSection(&g_csEventlogLock);
	if (SourceID1 == nLastSourceID1 && SourceID2 == nLastSourceID2 && SourceID3 == nLastSourceID3)
		{
		LeaveCriticalSection(&g_csEventlogLock);
		return;
		}

	nLastSourceID1 = SourceID1;
	nLastSourceID2 = SourceID2;
	nLastSourceID3 = SourceID3;
	LeaveCriticalSection(&g_csEventlogLock);

	DWORD	cch;
	char	strSource[MAX_MSG_LENGTH];
	char *aInsertStrs[MAX_INSERT_STRS];   // array of pointers to insert strings
    cch = CchLoadStringOfId(SourceID1, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);                                         
	aInsertStrs[0] = (char*) strSource;    	
	cch = CchLoadStringOfId(SourceID2, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);                                         
	aInsertStrs[1] = (char*) strSource;                                     
	cch = CchLoadStringOfId(SourceID3, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);                                         
	aInsertStrs[2] = (char*) strSource;                                     	
	ReportAnEvent( (DWORD) MSG_DENALI_ERROR_3, (WORD) EVENTLOG_ERROR_TYPE, (WORD) 3, (LPCSTR *) aInsertStrs );  	
	return;
	}  

/*===================================================================
void MSG_Error( UINT SourcID1, UINT SourceID2, UINT SourceID3, UINT SourceID4 )

report an event to the NT event log

INPUT: 
	four String table ID's
	
Returns:
	None
	
Side effects:
	Addes an entry in the NT event log
===================================================================*/
void MSG_Error( UINT SourceID1, UINT SourceID2, UINT SourceID3, UINT SourceID4 )
	{
	static unsigned int nLastSourceID1;
	static unsigned int nLastSourceID2;
	static unsigned int nLastSourceID3;
	static unsigned int nLastSourceID4;

	// if this is a repeat of the last reported message then return
	/// without posting an error.
	EnterCriticalSection(&g_csEventlogLock);
	if (SourceID1 == nLastSourceID1 && SourceID2 == nLastSourceID2 && SourceID3 == nLastSourceID3 && SourceID4 == nLastSourceID4)
		{
		LeaveCriticalSection(&g_csEventlogLock);
		return;
		}

	nLastSourceID1 = SourceID1;
	nLastSourceID2 = SourceID2;
	nLastSourceID3 = SourceID3;
	nLastSourceID4 = SourceID4;
	LeaveCriticalSection(&g_csEventlogLock);	

	DWORD	cch;
	char	strSource[MAX_MSG_LENGTH];
	char *aInsertStrs[MAX_INSERT_STRS];   // array of pointers to insert strings
    cch = CchLoadStringOfId(SourceID1, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);                                         
	aInsertStrs[0] = (char*) strSource;    	
	cch = CchLoadStringOfId(SourceID2, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);                                         
	aInsertStrs[1] = (char*) strSource;                                     
	cch = CchLoadStringOfId(SourceID3, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);                                         
	aInsertStrs[2] = (char*) strSource;
	cch = CchLoadStringOfId(SourceID4, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);                                         
	aInsertStrs[3] = (char*) strSource;
	ReportAnEvent( (DWORD) MSG_DENALI_ERROR_4, (WORD) EVENTLOG_ERROR_TYPE, (WORD) 4, (LPCSTR *) aInsertStrs );  	
	return;
	}  

/*===================================================================
void MSG_Warning( LPCSTR strSource )

report an event to the NT event log

INPUT: 
	ptr to null-terminated string
	
Returns:
	None
	
Side effects:
	Addes an entry in the NT event log
===================================================================*/
void MSG_Warning( LPCSTR strSource )
{
	static char	szLastError[MAX_MSG_LENGTH];

	EnterCriticalSection(&g_csEventlogLock);
	if (strcmp(strSource, szLastError) == 0)
		{
		LeaveCriticalSection(&g_csEventlogLock);
		return;
		}
	szLastError[0] = '\0';
	strncat(szLastError,strSource, MAX_MSG_LENGTH-1);
	LeaveCriticalSection(&g_csEventlogLock);

		ReportAnEvent( (DWORD) MSG_DENALI_WARNING_1, (WORD) EVENTLOG_WARNING_TYPE, (WORD) 1, &strSource /*aInsertStrs*/ ); 
}
/*===================================================================
void MSG_Warning( UINT SourceID1)

report an event to the NT event log

INPUT: 
	String table message ID
	
Returns:
	None
	
Side effects:
	Addes an entry in the NT event log
===================================================================*/
void MSG_Warning( UINT SourceID1 )
	{

	static unsigned int nLastSourceID1;
	
	// if this is a repeat of the last reported message then return
	/// without posting an error.
	EnterCriticalSection(&g_csEventlogLock);
	if (SourceID1 == nLastSourceID1)
		{
		LeaveCriticalSection(&g_csEventlogLock);
		return;
		}

	nLastSourceID1 = SourceID1;
	LeaveCriticalSection(&g_csEventlogLock);	
	
	DWORD	cch;
	char	strSource[MAX_MSG_LENGTH];	
	char *aInsertStrs[MAX_INSERT_STRS];   // array of pointers to insert strings
    cch = CchLoadStringOfId(SourceID1, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);                                         
	aInsertStrs[0] = (char*) strSource;    	
	ReportAnEvent( (DWORD) MSG_DENALI_WARNING_1, (WORD) EVENTLOG_WARNING_TYPE, (WORD) 1, (LPCSTR *) aInsertStrs );  	
	return;
	}  

/*===================================================================
void MSG_Warning( UINT, SOurceID1, UINT SourceID2 )

report an event to the NT event log

INPUT: 
	two string tabel message ID's
	
Returns:
	None
	
Side effects:
	Addes an entry in the NT event log
===================================================================*/
void MSG_Warning( UINT SourceID1, UINT SourceID2 )
	{
	static unsigned int nLastSourceID1;
	static unsigned int nLastSourceID2;
	
	// if this is a repeat of the last reported message then return
	/// without posting an error.
	EnterCriticalSection(&g_csEventlogLock);
	if (SourceID1 == nLastSourceID1 && SourceID2 == nLastSourceID2)
		{
		LeaveCriticalSection(&g_csEventlogLock);
		return;
		}

	nLastSourceID1 = SourceID1;
	nLastSourceID2 = SourceID2;
	LeaveCriticalSection(&g_csEventlogLock);	

	DWORD	cch;
	char	strSource[MAX_MSG_LENGTH];
	char *aInsertStrs[MAX_INSERT_STRS];   // array of pointers to insert strings
    cch = CchLoadStringOfId(SourceID1, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);                                         
	aInsertStrs[0] = (char*) strSource;    	
	cch = CchLoadStringOfId(SourceID2, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);                                         
	aInsertStrs[1] = (char*) strSource;                                     
	ReportAnEvent( (DWORD) MSG_DENALI_WARNING_2, (WORD) EVENTLOG_WARNING_TYPE, (WORD) 2, (LPCSTR *) aInsertStrs );  	
	return;
	}  

/*===================================================================
void MSG_Warning( UINT SourceID1, UINT SourceID2, UINT SourceID3 )

report an event to the NT event log

INPUT: 
	three string table message ID's
	
Returns:
	None
	
Side effects:
	Addes an entry in the NT event log
===================================================================*/
void MSG_Warning( UINT SourceID1, UINT SourceID2, UINT SourceID3)
	{

	static unsigned int nLastSourceID1;
	static unsigned int nLastSourceID2;
	static unsigned int nLastSourceID3;
	
	// if this is a repeat of the last reported message then return
	/// without posting an error.
	EnterCriticalSection(&g_csEventlogLock);
	if (SourceID1 == nLastSourceID1 && SourceID2 == nLastSourceID2 && SourceID3 == nLastSourceID3)
		{
		LeaveCriticalSection(&g_csEventlogLock);
		return;
		}

	nLastSourceID1 = SourceID1;
	nLastSourceID2 = SourceID2;
	nLastSourceID3 = SourceID3;
	LeaveCriticalSection(&g_csEventlogLock);	

	DWORD	cch;
	char	strSource[MAX_MSG_LENGTH];
	char *aInsertStrs[MAX_INSERT_STRS];   // array of pointers to insert strings
    cch = CchLoadStringOfId(SourceID1, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);                                         
	aInsertStrs[0] = (char*) strSource;    	
	cch = CchLoadStringOfId(SourceID2, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);                                         
	aInsertStrs[1] = (char*) strSource;                                     
	cch = CchLoadStringOfId(SourceID3, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);                                         
	aInsertStrs[2] = (char*) strSource;
	ReportAnEvent( (DWORD) MSG_DENALI_WARNING_3, (WORD) EVENTLOG_WARNING_TYPE, (WORD) 3, (LPCSTR *) aInsertStrs );  	
	return;
	}  

/*===================================================================
void MSG_Warning(  UINT SourceID1, UINT SourceID2, UINT SourceID3, UINT SourceID4 )

report an event to the NT event log

INPUT: 
	four String table message ID's
	
Returns:
	None
	
Side effects:
	Addes an entry in the NT event log
===================================================================*/
void MSG_Warning( UINT SourceID1, UINT SourceID2, UINT SourceID3, UINT SourceID4 )
	{

	static unsigned int nLastSourceID1;
	static unsigned int nLastSourceID2;
	static unsigned int nLastSourceID3;
	static unsigned int nLastSourceID4;

	// if this is a repeat of the last reported message then return
	/// without posting an error.
	EnterCriticalSection(&g_csEventlogLock);
	if (SourceID1 == nLastSourceID1 && SourceID2 == nLastSourceID2 && SourceID3 == nLastSourceID3 && SourceID4 == nLastSourceID4)
		{
		LeaveCriticalSection(&g_csEventlogLock);
		return;
		}

	nLastSourceID1 = SourceID1;
	nLastSourceID2 = SourceID2;
	nLastSourceID3 = SourceID3;
	nLastSourceID4 = SourceID4;
	LeaveCriticalSection(&g_csEventlogLock);	

	DWORD	cch;
	char	strSource[MAX_MSG_LENGTH];
	char *aInsertStrs[MAX_INSERT_STRS];   // array of pointers to insert strings
    cch = CchLoadStringOfId(SourceID1, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);                                         
	aInsertStrs[0] = (char*) strSource;    	
	cch = CchLoadStringOfId(SourceID2, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);                                         
	aInsertStrs[1] = (char*) strSource;                                     
	cch = CchLoadStringOfId(SourceID3, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);                                         
	aInsertStrs[2] = (char*) strSource;
	cch = CchLoadStringOfId(SourceID4, strSource, MAX_MSG_LENGTH);
	Assert(cch > 0);                                         
	aInsertStrs[3] = (char*) strSource;
	ReportAnEvent( (DWORD) MSG_DENALI_WARNING_4, (WORD) EVENTLOG_WARNING_TYPE, (WORD) 4, (LPCSTR *) aInsertStrs );  	
	return;
	}

/*===================================================================
void MSG_Warning(  UINT ErrId, UINT cItem, CHAR **szItems )

report an event to the NT event log

INPUT: 
	four String table message ID's
	
Returns:
	None
	
Side effects:
	Addes an entry in the NT event log
===================================================================*/
void MSG_Warning( UINT ErrId, UINT cItem, CHAR **szItems )
{
	static unsigned int LastErrId;
	
	// if this is a repeat of the last reported message then return
	/// without posting an error.
	EnterCriticalSection(&g_csEventlogLock);
	if (ErrId == LastErrId)
		{
		LeaveCriticalSection(&g_csEventlogLock);
		return;
		}

	LastErrId = ErrId;
	LeaveCriticalSection(&g_csEventlogLock);
	
	MSG_Warning(ErrId);
	ReportAnEvent( (DWORD) MSG_DENALI_WARNING_4, (WORD) EVENTLOG_WARNING_TYPE, (WORD) cItem, (LPCSTR *) szItems );  
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\eventlog.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: NT Event logging

File: eventlog.h

Owner: jhittle

This is the header file for eventlog.cpp
===================================================================*/

#ifndef EVENTLOG_H
#define EVENTLOG_H

#define MAX_MSG_LENGTH	512
#define MSG_ID_MASK		0x0000FFFF
#define MAX_INSERT_STRS 8

		STDAPI	RegisterEventLog( void );
		STDAPI	UnRegisterEventLog( void );
		STDAPI 	ReportAnEvent(DWORD dwIdEvent, WORD wEventlog_Type, WORD cStrings, LPCSTR *pszStrings);


extern void		MSG_DenaliStarted(void);
extern void		MSG_DenaliStoped(void);
extern void 	MSG_Error( LPCSTR );
extern void 	MSG_Error( UINT );
extern void 	MSG_Error( UINT, UINT );
extern void 	MSG_Error( UINT, UINT  UINT );
extern void 	MSG_Error( UINT, UINT, UINT, UINT );
extern void 	MSG_Warning( LPCSTR );
extern void 	MSG_Warning( UINT );
extern void 	MSG_Warning( UINT, UINT );
extern void 	MSG_Warning( UINT, UINT, UINT );
extern void 	MSG_Warning( UINT, UINT, UINT, UINT );
extern void		MSG_Warning( UINT, UINT, CHAR **);

// support function
//extern void queryEventLog(void);

#endif  //EVENTLOG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\exec.h ===
/*-----------------------------------------------------------------------------
Microsoft Denali

Microsoft Confidential
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Executive

File:	Executor.h

Owner: DGottner

Executor API definition
-----------------------------------------------------------------------------*/

#ifndef _EXECUTOR_H
#define _EXECUTOR_H

// Includes -------------------------------------------------------------------

#include "HitObj.h"


// Forward References ---------------------------------------------------------

class CResponse;
class CRequest;
class CServer;
class CScriptingNamespace;


// Error codes ----------------------------------------------------------------

#define E_PAGE_HAS_SESSAPP_OBJECTS		0x8000E001L


// Types and Constants --------------------------------------------------------

class CIntrinsicObjects
	{
private:
    BOOL                    m_fIsChild;
	CResponse *				m_pResponse;
	CRequest *				m_pRequest;
	CServer *				m_pServer;
	CScriptingNamespace *	m_pScriptingNamespace;

public:
	inline CResponse *			PResponse() const { return m_pResponse; }
	inline CRequest *			PRequest()  const { return m_pRequest; }
	inline CServer *			PServer()   const { return m_pServer; }
	inline CScriptingNamespace *PScriptingNamespace() const { return m_pScriptingNamespace; }
	
    CIntrinsicObjects()
        {
        m_fIsChild = FALSE;
    	m_pResponse = NULL;
	    m_pRequest = NULL;
        m_pServer = NULL;
        m_pScriptingNamespace = NULL;
        }
        
    ~CIntrinsicObjects()
        {
        Cleanup();
        }

    HRESULT Prepare(CSession *pSession);
    HRESULT PrepareChild(CResponse *pResponse, CRequest *pRequest, CServer *pServer);
    HRESULT Cleanup();
	};

struct TemplateGoodies
	{
	int				iScriptBlock;
	CTemplate *		pTemplate;
	};

// CONSIDER: declare pScriptEngine to be a CActiveScriptEngine, because that's its
//           actual type.
//
struct ScriptingInfo
	{
	CHAR *				szScriptEngine;		// name of this scripting engine
	PROGLANG_ID *		pProgLangId;		// ptr to prog lang id of the script engine
	CScriptEngine *		pScriptEngine;		// pointer to scripting engine
	TemplateGoodies		LineMapInfo;		// used to map lines back to VBScript
	};

struct ActiveEngineInfo
	{
	int cEngines;           // required engines
	int cActiveEngines;     // successfully instantiated engines
	
	ScriptingInfo *rgActiveEngines; // pointer to array of engines
	
	// when only one engine rgActiveEngines points to here
	ScriptingInfo siOneActiveEngine;
	};

 
// Prototypes -----------------------------------------------------------------

HRESULT Execute
    (
    CTemplate *pTemplate,
    CHitObj *pHitObj,
    const CIntrinsicObjects &intrinsics,
    BOOL fChild = FALSE
    );

HRESULT LoadTemplate
    (
    const TCHAR *szFile,
    CHitObj *pHitObj, 
    CTemplate **ppTemplate,
	const CIntrinsicObjects &intrinsics,
	BOOL fGlobalAsa,
	BOOL *pfTemplateInCache
	);

#endif // _EXECUTOR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\fileapp.h ===
/*-----------------------------------------------------------------------------
Microsoft Denali

Microsoft Confidential
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: File/Application mapping

File: CFileApp.h

Owner: CGrant

File/Application mapping definition
-----------------------------------------------------------------------------*/

#ifndef _CFILEAPP_H
#define _CFILEAPP_H

// Includes -------------------------------------------------------------------
#include "applmgr.h"
#include "hashing.h"
#include "idhash.h"
#include "memcls.h"

#define    NUM_FILEAPP_HASHING_BUCKETS	17

/*****************************************************************************
Class:  CFileApplicationMap
Synopsis:   Maintains a database relating files to the applications that
            must be shut down if the file changes. The key for the hash table
            is the full file name
*/  
class CFileApplicationMap : public CHashTable
{
    // Flags
    DWORD m_fInited : 1;                // Are we initialized?
    DWORD m_fHashTableInited : 1;       // Need to UnInit hash table?
    DWORD m_fCriticalSectionInited : 1; // Need to delete CS?

    // Critical section for locking
    CRITICAL_SECTION m_csLock;

public:

    CFileApplicationMap();
    ~CFileApplicationMap();
    void Lock();
    void UnLock();
    HRESULT Init();
    HRESULT UnInit();
    HRESULT AddFileApplication(const TCHAR *pszFileName, CAppln *pAppln);
    BOOL ShutdownApplications(const TCHAR *pszFile);
};

inline void CFileApplicationMap::Lock()
    {
    Assert(m_fInited);
    EnterCriticalSection(&m_csLock);
    }
    
inline void CFileApplicationMap::UnLock()
    {
    Assert(m_fInited);
    LeaveCriticalSection( &m_csLock ); 
    }
    
/*****************************************************************************
Class:  CFileApplnList
Synopsis:   Maintains a list of applications that
            must be shut down if a file changes
*/
class CFileApplnList : public CLinkElem
{

friend class CFileApplicationMap;

    TCHAR*      m_pszFilename;
    CPtrArray   m_rgpvApplications; // the list of applications
    BOOL        m_fInited;          // flag indicating initialization

public:

    CFileApplnList();
    ~CFileApplnList();

    HRESULT Init(const TCHAR* pszFilename);
    HRESULT UnInit();

    HRESULT AddApplication(void *pApplication);
    HRESULT RemoveApplication(void *pApplication);
    VOID    GetShutdownApplications(CPtrArray *prgpapplnRestartList);

    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
};

/*===================================================================
  Globals
===================================================================*/

extern CFileApplicationMap    g_FileAppMap;

#endif // _CFILEAPP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\ftm.cpp ===
/*===================================================================
Microsoft ASP

Microsoft Confidential.
Copyright 1996, 1997, 1998 Microsoft Corporation. All Rights Reserved.

Component: Free Threaded Marshaller Base Class

File: ftm.cpp

Owner: Lei Jin

This is the free threaded marshaller base class implementation.
===================================================================*/
#include "denpre.h"
#pragma hdrstop
#include "ftm.h"
#include "memchk.h"

IMarshal* CFTMImplementation::m_pUnkFTM     = NULL;

STDMETHODIMP 
CFTMImplementation::GetUnmarshalClass
( 
/* [in] */ REFIID riid,
/* [unique][in] */ void __RPC_FAR *pv,
/* [in] */ DWORD dwDestContext,
/* [unique][in] */ void __RPC_FAR *pvDestContext,
/* [in] */ DWORD mshlflags,
/* [out] */ CLSID __RPC_FAR *pCid
)
    {
    
    DBG_ASSERT(m_pUnkFTM != NULL);
    
    return m_pUnkFTM->GetUnmarshalClass(riid, pv, dwDestContext, pvDestContext, mshlflags, pCid);

    }

STDMETHODIMP 
CFTMImplementation::GetMarshalSizeMax( 
/* [in] */ REFIID riid,
/* [unique][in] */ void __RPC_FAR *pv,
/* [in] */ DWORD dwDestContext,
/* [unique][in] */ void __RPC_FAR *pvDestContext,
/* [in] */ DWORD mshlflags,
/* [out] */ DWORD __RPC_FAR *pSize)
    {
    DBG_ASSERT(m_pUnkFTM != NULL);
    return m_pUnkFTM->GetMarshalSizeMax(riid, pv, dwDestContext, pvDestContext, mshlflags, pSize);
    }

STDMETHODIMP
CFTMImplementation::MarshalInterface( 
/* [unique][in] */ IStream __RPC_FAR *pStm,
/* [in] */ REFIID riid,
/* [unique][in] */ void __RPC_FAR *pv,
/* [in] */ DWORD dwDestContext,
/* [unique][in] */ void __RPC_FAR *pvDestContext,
/* [in] */ DWORD mshlflags)
    {
    DBG_ASSERT(m_pUnkFTM != NULL);
    return m_pUnkFTM->MarshalInterface(pStm, riid, pv, dwDestContext, pvDestContext, mshlflags);
    }

STDMETHODIMP 
CFTMImplementation::UnmarshalInterface
( 
/* [unique][in] */ IStream __RPC_FAR *pStm,
/* [in] */ REFIID riid,
/* [out] */ void __RPC_FAR *__RPC_FAR *ppv
)
    {
    DBG_ASSERT(m_pUnkFTM != NULL);
    return m_pUnkFTM->UnmarshalInterface(pStm, riid, ppv);
    }

STDMETHODIMP 
CFTMImplementation::ReleaseMarshalData
( 
/* [unique][in] */ IStream __RPC_FAR *pStm
)
    {
    DBG_ASSERT(m_pUnkFTM != NULL);
    return m_pUnkFTM->ReleaseMarshalData(pStm);
    }

STDMETHODIMP 
CFTMImplementation::DisconnectObject
( 
/* [in] */ DWORD dwReserved
)
    {
    DBG_ASSERT(m_pUnkFTM != NULL);
    return m_pUnkFTM->DisconnectObject(dwReserved);
    }

HRESULT			
CFTMImplementation::Init
(
void
)
    {
    IUnknown *pUnkFTMTemp = NULL;
    HRESULT hr;
    
    hr = CoCreateFreeThreadedMarshaler(NULL, (IUnknown**)&pUnkFTMTemp);

    DBG_ASSERT(SUCCEEDED(hr));

    if (SUCCEEDED(hr))
        {
        hr = pUnkFTMTemp->QueryInterface(IID_IMarshal, reinterpret_cast<void **>(&m_pUnkFTM));
        DBG_ASSERT(SUCCEEDED(hr) && m_pUnkFTM != NULL);
        pUnkFTMTemp->Release();
        }
        
    return hr;
    }

    
HRESULT			
CFTMImplementation::UnInit
(
void
)
    {
    DBG_ASSERT(m_pUnkFTM != NULL);

    m_pUnkFTM->Release();
    m_pUnkFTM = NULL;
    
    return S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\fileapp.cpp ===
/*-----------------------------------------------------------------------------
Microsoft Denali

Microsoft Confidential
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: File/Application map

File: CFileApp.cpp

Owner: cgrant

File/Application mapping implementation
-----------------------------------------------------------------------------*/

#include "denpre.h"
#pragma hdrstop

#include "dbgutil.h"
#include "memchk.h"

CFileApplicationMap g_FileAppMap;

/*===================================================================
CFileApplnList::CFileApplnList

Constructor

Parameters:
    None

Returns:
    Nothing
===================================================================*/	
CFileApplnList::CFileApplnList() :
    m_pszFilename(NULL),
    m_fInited(FALSE)
{

}


/*===================================================================
CFileApplnList::~CFileApplnList

Destructor

Parameters:
    None

Returns:
    Nothing
===================================================================*/	
CFileApplnList::~CFileApplnList()
{
    // We should have no applications in our list
    DBG_ASSERT(m_rgpvApplications.Count() == 0);

    // Free the string used as the hash key
    if (m_pszFilename)
    {
        delete [] m_pszFilename;
        m_pszFilename = NULL;
    }
}

/*===================================================================
CFileApplnList::Init

Initialize the file application list by setting the key to file name

Parameters:
    pApplication    pointer to the applicaiton
    
Returns:
    S_OK if successful
===================================================================*/	
HRESULT CFileApplnList::Init(const TCHAR* pszFilename)
{
    HRESULT hr = S_OK;

    DBG_ASSERT(pszFilename);

    // Make a copy of the file name to 
    // use as the hash key
    DWORD cch = _tcslen(pszFilename);
    m_pszFilename = new TCHAR[cch+1];
    if (!m_pszFilename)
    {
        return E_OUTOFMEMORY;
    }
    _tcscpy(m_pszFilename, pszFilename);

    if (FAILED(CLinkElem::Init(m_pszFilename, cch*sizeof(TCHAR))))
    {
        return E_FAIL;
    }

    m_fInited = TRUE;
    return hr;
}

/*===================================================================
CFileApplnList::UnInit

Clean up the application list

Parameters:
    pApplication    pointer to the applicaiton
    
Returns:
    S_OK if successful
===================================================================*/	
HRESULT CFileApplnList::UnInit(void)
{
    HRESULT hr = S_OK;

    DBG_ASSERT(m_fInited);
    
    while(m_rgpvApplications.Count())
    {
        CAppln* pAppln = static_cast<CAppln *>(m_rgpvApplications[0]);

        DBG_ASSERT(pAppln);

        // Remove this appliation from the array
        m_rgpvApplications.Remove(pAppln);

        // Release the array's refcount on the application
        // This may result in the application being deleted
        pAppln->Release();
    }

    m_rgpvApplications.Clear();
    m_fInited = FALSE;
    return hr;
}


/*===================================================================
CFileApplnList::AddApplication

Add an application pointer to the list of applications

Parameters:
    pApplication    pointer to the applicaiton
    
Returns:
    S_OK if successful

Comments

    The caller should hold a lock on the hash table containing
    the element    
===================================================================*/	
HRESULT CFileApplnList::AddApplication(void *pApplication)
{
    DBG_ASSERT(m_fInited);
    DBG_ASSERT(pApplication);
    
    HRESULT hr = S_OK;
    int index;
    
    // See if the application is alreay in the list
    hr = m_rgpvApplications.Find(pApplication, &index);
    if (hr == S_FALSE)
    {
       // Not found, add it.
       
       // We are going to hold a reference to the application
       static_cast<CAppln *>(pApplication)->AddRef();

       // Add the application to the list
       if (FAILED(hr = m_rgpvApplications.Append(pApplication)))
       {
            // We failed so give back the refcount we took.
            static_cast<CAppln *>(pApplication)->Release();
       }
    }
    return hr;
}

/*===================================================================
CFileApplnList::RemoveApplication

Removes an application pointer from the list of applications

Parameters:
    pApplication    pointer to the applicaiton
    
Returns:
    S_OK if successful

Comments

    The caller should hold a lock on the hash table containing
    the element
===================================================================*/	
HRESULT CFileApplnList::RemoveApplication(void *pApplication)
{
    DBG_ASSERT(m_fInited);
    DBG_ASSERT(pApplication);
    
    HRESULT hr = S_OK;
    int index;

#ifdef DBG_NOTIFICATION
#if UNICODE
    DBGPRINTF((DBG_CONTEXT, "Removing Application entry for %S\n", reinterpret_cast<CAppln *>(pApplication)->GetApplnPath()));
#else
    DBGPRINTF((DBG_CONTEXT, "Removing Application entry for %s\n", reinterpret_cast<CAppln *>(pApplication)->GetApplnPath()));
#endif
#endif // DBG_NOTIFICATION

    // Remove the application from the list
    hr = m_rgpvApplications.Remove(pApplication);

    // If the count of applications in the list goes
    // to 0, remove the element from the hash table 
    // and delete it
    if (m_rgpvApplications.Count() == 0)
    {
#ifdef DBG_NOTIFICATION
#if UNICODE
        DBGPRINTF((DBG_CONTEXT, "Deleting File/Application entry for %s\n", m_pszFilename));
#else
        DBGPRINTF((DBG_CONTEXT, "Deleting File/Application entry for %s\n", m_pszFilename));
#endif
#endif // DBG_NOTIFICATION
        g_FileAppMap.RemoveElem(this);
        delete this;
    }

    // If we found the application to remove it
    // we need to release a ref count on the application
    if (hr == S_OK)
    {
        static_cast<CAppln *>(pApplication)->Release();
    }

    return hr;
}

/*===================================================================
CFileApplnList::GetShutdownApplications

Obtain a list of applications to shut down

Parameters:
    None

===================================================================*/	
VOID CFileApplnList::GetShutdownApplications(CPtrArray *prgpapplnRestartList)
{
    DBG_ASSERT(m_fInited);

    HRESULT hr = S_OK;

#ifdef DBG_NOTIFICATION
#if UNICODE
    DBGPRINTF((DBG_CONTEXT, "[CFileApplnList] Shutting down %d applications depending on %S.\n", m_rgpvApplications.Count(), m_pszFilename));
#else
    DBGPRINTF((DBG_CONTEXT, "[CFileApplnList] Shutting down %d applications depending on %s.\n", m_rgpvApplications.Count(), m_pszFilename));
#endif
#endif // DBG_NOTIFICATION
    
    for  (int i = m_rgpvApplications.Count() - 1; i >= 0; i--)
    {
        CAppln* pAppln = static_cast<CAppln *>(m_rgpvApplications[i]);
        DBG_ASSERT(pAppln);
        
        // If not already tombstoned, shut the application down.
        // When the application is uninited it will remove itself
        // from this list
        if (!pAppln->FTombstone())
        {
            pAppln->AddRef();
            prgpapplnRestartList->Append(pAppln);
        }
    }
}

/*===================================================================
CFileApplicationMap::CFileApplicationMap

Constructor

Parameters:
    None

Returns:
    Nothing
===================================================================*/	
CFileApplicationMap::CFileApplicationMap()
    : m_fInited(FALSE),
      m_fHashTableInited(FALSE), 
      m_fCriticalSectionInited(FALSE)
{
}

/*===================================================================
CFileApplicationMap::~CFileApplicationMap

Destructor

Parameters:
    None

Returns:
    Nothing
===================================================================*/	
CFileApplicationMap::~CFileApplicationMap()
{
    if (m_fInited)
    {
        UnInit();
    }
}

/*===================================================================
CFileApplicationMap::Init

Initialize the hash table and critical section

Parameters:
    None
    
Returns:
    S_OK if successful
===================================================================*/	
HRESULT CFileApplicationMap::Init()
{
    HRESULT hr = S_OK;
    
    Assert(!m_fInited);

    hr = CHashTable::Init(NUM_FILEAPP_HASHING_BUCKETS);
    if (FAILED(hr))
    {
        return hr;
    }
    m_fHashTableInited = TRUE;

    // Init critical section

    ErrInitCriticalSection(&m_csLock, hr);
    if (FAILED(hr))
    {
        return(hr);
    }
    m_fCriticalSectionInited = TRUE;

    m_fInited = TRUE;
    return S_OK;
}

/*===================================================================
CFileApplicationMap::UnInit

Uninitialize the hash table and critical section
Free any applications lists remaining in the hash
table elements

Parameters:
    None
    
Returns:
    S_OK if successful
===================================================================*/	
HRESULT CFileApplicationMap::UnInit()
{
    if (m_fHashTableInited)
    {
        // Delete any elements remaining in the hash table
        
        CFileApplnList *pNukeElem = static_cast<CFileApplnList *>(Head());

        while (pNukeElem != NULL)
        {
            CFileApplnList *pNext = static_cast<CFileApplnList *>(pNukeElem->m_pNext);
            pNukeElem->UnInit();
            delete pNukeElem;
            pNukeElem = pNext;
        }

        // Uninit the hash table
        CHashTable::UnInit();
        m_fHashTableInited = FALSE;
    }

    if (m_fCriticalSectionInited)
    {
        DeleteCriticalSection(&m_csLock);
        m_fCriticalSectionInited = FALSE;
    }
        
    m_fInited = FALSE;
    return S_OK;
}

/*===================================================================
CFileApplicationMap::AddFileApplication

Add a file-application pair to the hash table

Parameters:
    pszFilename     pointer to string containing name of the file
    pAppln          pointer to the application associated with the file
    
Returns:
    S_OK if successful
===================================================================*/	
HRESULT CFileApplicationMap::AddFileApplication(const TCHAR* pszFilename, CAppln* pAppln)
{
    // We must have both a file and an application
    DBG_ASSERT(pszFilename);
    DBG_ASSERT(pAppln);

    HRESULT hr = S_OK;
    
    Lock();

#ifdef DBG_NOTIFICATION
#if UNICODE
    DBGPRINTF((DBG_CONTEXT, "Adding File/Application entry for %S\n", pszFilename));
#else
    DBGPRINTF((DBG_CONTEXT, "Adding File/Application entry for %s\n", pszFilename));
#endif
#endif // DBG_NOTIFICATION
    
    // See if the file already has an entry
    CFileApplnList* pFileApplns = static_cast<CFileApplnList *>(CHashTable::FindElem(pszFilename, _tcslen(pszFilename)*sizeof(TCHAR)));
    if (pFileApplns == NULL)
    {
    
        // Not found, create new CFileApplnList object
    
        pFileApplns = new CFileApplnList;
    
        if (!pFileApplns)
        {
            hr = E_OUTOFMEMORY;
            goto LExit;
        }

        // Init CFileApplnList object

        hr = pFileApplns->Init(pszFilename);

        if (FAILED(hr))
        {
            delete pFileApplns;
            goto LExit;
        }

        // Add FileApplns object to hash table
    
        if (!CHashTable::AddElem(pFileApplns))
        {
            delete pFileApplns;
            hr = E_FAIL;
            goto LExit;
        }
     }

     // Add the application to the list associated with this file
     hr = pFileApplns->AddApplication(pAppln);

     // Keep this file mapping in the application
     // The application will remove itself from this list
     // when it is uninited.
     
     pAppln->AddFileApplnEntry(pFileApplns);
     
LExit:
    UnLock();
    return hr;
}

/*===================================================================
CFileApplicationMap::ShutdownApplications

Shutdown the applications associated with a file

Parameters:
    pszFilename     pointer to string containing name of the file
    
Returns:
    TRUE if an application was shutdown, FALSE otherwise
===================================================================*/	
BOOL CFileApplicationMap::ShutdownApplications(const TCHAR *pszFilename)
{
    DBG_ASSERT(pszFilename);

    BOOL fResult = TRUE;
    
    Lock();
    
    CFileApplnList* pFileApplns = static_cast<CFileApplnList *>(CHashTable::FindElem(pszFilename, _tcslen(pszFilename)*sizeof(TCHAR)));

    if (pFileApplns)
    {
        // Get a list of applications we need to shutdown
        
        CPtrArray rgpapplnRestartList;
        pFileApplns->GetShutdownApplications(&rgpapplnRestartList);


        // Now that we have the list of applications we need to shut down
        // we can release the lock
        
        UnLock();

        for (int i = 0; i < rgpapplnRestartList.Count(); i++)
        {
            CAppln *pAppln = (CAppln *)rgpapplnRestartList[i];
            pAppln->Restart();
            pAppln->Release();
        }

		// Flush the script cache if any applications were restarted
		if (rgpapplnRestartList.Count())
			g_ScriptManager.FlushAll();
    }
    else
    {
        // No applications to shut down, release the lock
        UnLock();
        fResult = FALSE;
    }

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\ftm.h ===
/*===================================================================
Microsoft ASP

Microsoft Confidential.
Copyright 1996, 1997, 1998 Microsoft Corporation. All Rights Reserved.

Component: Free Threaded Marshaller Base Class

File: ftm.h

Owner: Lei Jin

This is the free threaded marshaller base class header file.
===================================================================*/
#ifndef _FTM_GLOBAL_H
#define _FTM_GLOBAL_H

#include <objbase.h>
#include "debug.h"
#include "util.h"

class CFTMImplementation : public IMarshal 
{
public:

    STDMETHODIMP GetUnmarshalClass( 
		    /* [in] */ REFIID riid,
		    /* [unique][in] */ void __RPC_FAR *pv,
		    /* [in] */ DWORD dwDestContext,
		    /* [unique][in] */ void __RPC_FAR *pvDestContext,
		    /* [in] */ DWORD mshlflags,
		    /* [out] */ CLSID __RPC_FAR *pCid);

    STDMETHODIMP GetMarshalSizeMax( 
	        /* [in] */ REFIID riid,
	        /* [unique][in] */ void __RPC_FAR *pv,
	        /* [in] */ DWORD dwDestContext,
	        /* [unique][in] */ void __RPC_FAR *pvDestContext,
	        /* [in] */ DWORD mshlflags,
	        /* [out] */ DWORD __RPC_FAR *pSize);
    
    STDMETHODIMP MarshalInterface( 
	        /* [unique][in] */ IStream __RPC_FAR *pStm,
	        /* [in] */ REFIID riid,
	        /* [unique][in] */ void __RPC_FAR *pv,
	        /* [in] */ DWORD dwDestContext,
	        /* [unique][in] */ void __RPC_FAR *pvDestContext,
	        /* [in] */ DWORD mshlflags);
    
    STDMETHODIMP UnmarshalInterface( 
	        /* [unique][in] */ IStream __RPC_FAR *pStm,
	        /* [in] */ REFIID riid,
	        /* [out] */ void __RPC_FAR *__RPC_FAR *ppv);
    
    STDMETHODIMP ReleaseMarshalData( 
	        /* [unique][in] */ IStream __RPC_FAR *pStm);
    
    STDMETHODIMP DisconnectObject( 
	        /* [in] */ DWORD dwReserved);

	static	HRESULT			Init();
	static	HRESULT			UnInit();
	
private:
	// Global FTM pointer
	static	IMarshal *		m_pUnkFTM; 
};

#endif _FTM_GLOBAL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\gip.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Global Interface Pointer API support

File: Gip.cpp

Owner: DmitryR

This is the GIP source file.
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "gip.h"
#include "memchk.h"

/*===================================================================
  Globals
===================================================================*/

CGlobalInterfaceAPI g_GIPAPI;

/*===================================================================
  C  G l o b a l  I n t e r f a c e  A P I
===================================================================*/

/*===================================================================
CGlobalInterfaceAPI::CGlobalInterfaceAPI

CGlobalInterfaceAPI constructor

Parameters:

Returns:
===================================================================*/	
CGlobalInterfaceAPI::CGlobalInterfaceAPI() 
    : m_fInited(FALSE), m_pGIT(NULL)
    {
    }
    
/*===================================================================
CGlobalInterfaceAPI::~CGlobalInterfaceAPI

CGlobalInterfaceAPI destructor

Parameters:

Returns:
===================================================================*/	
CGlobalInterfaceAPI::~CGlobalInterfaceAPI()
    {
    UnInit();
    }

/*===================================================================
CGlobalInterfaceAPI::Init

Creates instance of GlobalInterfaceTable

Parameters:

Returns:
    HRESULT
===================================================================*/	
HRESULT CGlobalInterfaceAPI::Init()
    {
    Assert(!m_fInited); // don't init twice
    
    HRESULT hr = CoCreateInstance
        (
        CLSID_StdGlobalInterfaceTable,
        NULL,
        CLSCTX_INPROC_SERVER,
        IID_IGlobalInterfaceTable,
        (void **)&m_pGIT
        );
        
    if (SUCCEEDED(hr))
        m_fInited = TRUE;
    else
        m_pGIT = NULL;

    return hr;
    }

/*===================================================================
CGlobalInterfaceAPI::UnInit

Releases instance of GlobalInterfaceTable

Parameters:

Returns:
    HRESULT (S_OK)
===================================================================*/	
HRESULT CGlobalInterfaceAPI::UnInit()
    {
    if (m_pGIT)
        {
        m_pGIT->Release();
        m_pGIT = NULL;
        }

    m_fInited = FALSE;
    return S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\exec.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Executor

Owner: DGottner

File: executor.cpp

This file contains the executor, whose job is to co-ordinate the
execution of Denali scripts.
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "exec.h"
#include "response.h"
#include "request.h"
#include "perfdata.h"
#include "memchk.h"


// Local declarations
HRESULT ExecuteGlobal(CHitObj *pHitObj,
                        const CIntrinsicObjects &intrinsics,
                        ActiveEngineInfo *pEngineInfo);
HRESULT ExecuteRequest(CTemplate *pTemplate, CHitObj *pHitObj,
                        const CIntrinsicObjects &intrinsics,
                        ActiveEngineInfo *pEngineInfo);
HRESULT ReInitIntrinsics(CHitObj *pHitObj, const CIntrinsicObjects &intrinsics,
                            ActiveEngineInfo *pEngineInfo, BOOL fPostGlobal);
HRESULT AllocAndLoadEngines(CHitObj *pHitObj, CTemplate *pTemplate, ActiveEngineInfo *pEngineInfo,
                            CScriptingNamespace *pScriptingNamespace, BOOL fGlobalAsa);
VOID DeAllocAndFreeEngines(ActiveEngineInfo *pEngineInfo, CAppln *pAppln);
CScriptEngine *GetScriptEngine(int iScriptEngine, void *pvData);
HRESULT CallScriptFunctionOfEngine(ActiveEngineInfo &engineInfo, short iScriptBlock, wchar_t *strFunction, CASPObjectContext  *pASPObjectContext = NULL);
HRESULT CallScriptFunction(ActiveEngineInfo &engineInfo, wchar_t *strFunction);
HRESULT TestScriptFunction(ActiveEngineInfo &engineInfo, wchar_t *strFunction);

/*===================================================================
Execute

Execute a request:
    First determine if Global needs to be called
    then invoke actual requested template

Parameters:
    pTemplate       - pointer to loaded template (could be NULL)
    pHitObj         - pointer to the hit object
    intrinsics      - pointers to the intrinsic IUnknown pointers.
    fChild          - flag: TRUE when child request (Server.Execute())

Returns:
    S_OK on success
===================================================================*/
HRESULT Execute
(
CTemplate *pTemplate,
CHitObj *pHitObj,
const CIntrinsicObjects &intrinsics,
BOOL fChild
)
    {
    HRESULT hr = S_OK;
    ActiveEngineInfo engineInfo;
    BOOL fRanGlobal = FALSE;
    
    // The hit obj must be valid
    Assert(pHitObj != NULL);
    pHitObj->AssertValid();

	// Check for valid Session codepage.  We do it here, rather than in CSession::Init in
	// order to avoid generic "New Session Failed" message.
	if (pHitObj->GetCodePage() != CP_ACP && !IsValidCodePage(pHitObj->GetCodePage()))
		{
		HandleErrorMissingFilename(IDE_BAD_CODEPAGE_IN_MB, pHitObj);
		return E_FAIL;
		}

    // Give the engine list to the hitobject
    pHitObj->SetActiveEngineInfo(&engineInfo);
        
    /*
     * If there is a Global.ASA, call it
     */
    if (pHitObj->GlobalAspPath() && !fChild)
        {
        // Clear out the engine info
        engineInfo.cEngines = 0;
        engineInfo.cActiveEngines = 0;
        engineInfo.rgActiveEngines = NULL;

        // Init the intrinsics
        hr = ReInitIntrinsics(pHitObj, intrinsics, &engineInfo, /* fPostGlobal*/ FALSE);
        if (FAILED(hr))
            return(hr);

        hr = ExecuteGlobal(pHitObj, intrinsics, &engineInfo);

        if (intrinsics.PResponse() && intrinsics.PResponse()->FResponseAborted())
            {
            hr = S_OK;
            goto LExit;
            }

        if (E_SOURCE_FILE_IS_EMPTY == hr)
            // bug 977: silently ignore empty global.asa file
            hr = S_OK;
        else if (FAILED(hr))
            {
            // Bug 481: If global.asa fails due to Response.End (or Response.Redirect),
            //      then halt execution of the calling script.  If the
            //      script fails due to Response.End, then return OK status
            //
            if (hr == DISP_E_EXCEPTION)
                hr = S_OK;

            // In any case, blow out of here
            goto LExit;
            }

        // Running Global.asa added the scripting namespace to the hitobj.  This will cause us problems
        // later, remove it.
        pHitObj->RemoveScriptingNamespace();

        fRanGlobal = TRUE;
        }

    /*
     * If this is not a browser request, then we are done
     * For non-browser requests, we do want to run Global.asa (if any), but there is no real template to run.
     */
    if (!pHitObj->FIsBrowserRequest())
        {
        hr = S_OK;
        goto LExit;
        }

    // Clear out (or re-clear out) the engine info
    engineInfo.cEngines = 0;
    engineInfo.cActiveEngines = 0;
    engineInfo.rgActiveEngines = NULL;

    // Init or Re-Init the intrinsics
    ReInitIntrinsics(pHitObj, intrinsics, &engineInfo, fRanGlobal || fChild);

    if (!fChild)
        {
        // For non-child requests hand new Template to Response object
        // (for child requests already done)
        intrinsics.PResponse()->ReInitTemplate(pTemplate, pHitObj->PSzNewSessionCookie());
        }
    else
        {
        // For child requests hand new engine info to the response object
        intrinsics.PResponse()->SwapScriptEngineInfo(&engineInfo);
        }

    // Run the main template
    if (pTemplate->FScriptless() && !pHitObj->PAppln()->FDebuggable())
        {
        // special case scriptless pages
        hr = intrinsics.PResponse()->WriteBlock(0);
        }
    else
        {
        hr = ExecuteRequest(pTemplate, pHitObj, intrinsics, &engineInfo);
        }
        
LExit:
	intrinsics.PResponse()->SwapScriptEngineInfo(NULL);
	pHitObj->SetActiveEngineInfo(NULL);
    return hr;
    }

/*===================================================================
ExecRequest

Execute a request for an actual template (not Global.asa)

execute a request by
    - getting the script name
    - loading the script into memory
    - interpreting the opcodes

Parameters:
    pTemplate       - pointer to loaded template
    pHitObj         - pointer to the hit object
    intrinsics      - pointers to the intrinsic IUnknown pointers.
    pEngineInfo     - pointers to engine info

Returns:
    S_OK on success
===================================================================*/
HRESULT ExecuteRequest(CTemplate                *pTemplate,
                       CHitObj                  *pHitObj,
                       const CIntrinsicObjects  &intrinsics,
                       ActiveEngineInfo         *pEngineInfo)
{
    HRESULT hr = S_OK;
    BOOL    fAborted = FALSE;
    BOOLB   fDebuggerNotifiedOnStart = FALSE;
    BOOL    fServiceDomainEnterred = FALSE;
    CASPObjectContext   *pASPObjectContext = NULL;
    CASPObjectContext   *pPoppedASPObjectContext = NULL;

#ifndef PERF_DISABLE
    BOOLB fPerfTransPending = FALSE;
#endif      

    // The template must be valid
    Assert(pTemplate);

    // The hit obj must be valid
    Assert(pHitObj != NULL);
    pHitObj->AssertValid();

    // This function should never be called on a non-browser request
    Assert(pHitObj->FIsBrowserRequest());

    // Remember template's type library wrapper with the HitObj
    if (pTemplate->PTypeLibWrapper())
        pHitObj->SetTypeLibWrapper(pTemplate->PTypeLibWrapper());

    if (pTemplate->FTransacted()) {

#ifndef PERF_DISABLE
        g_PerfData.Incr_TRANSTOTAL();
        g_PerfData.Incr_TRANSPENDING();
        fPerfTransPending = TRUE;
#endif      
        pASPObjectContext = new CASPObjectContext();

        if (!pASPObjectContext) {
            hr = E_OUTOFMEMORY;
            goto LExit;
        }
        
        pPoppedASPObjectContext = pHitObj->SetASPObjectContext(pASPObjectContext);
    }

    if (pTemplate->PServicesConfig()) {
        hr = CoEnterServiceDomain(pTemplate->PServicesConfig());
        if (FAILED(hr)) {
            goto LExit;
        }
        fServiceDomainEnterred = TRUE;
    }

	// load script engines
	hr = AllocAndLoadEngines(pHitObj, pTemplate, pEngineInfo, intrinsics.PScriptingNamespace(), /* fGlobalAsa */FALSE);
	if (FAILED(hr)) {
	    pHitObj->SetCompilationFailed();
		goto LExit;
    }

    // If debugging, notify debugger ONPAGESTART
    // BUG 138773: Notify debugger AFTER scripts load
    //    (script must be in running state when AttachTo() is called because debugger may want a code context)
    //
    if (pHitObj->PAppln()->FDebuggable()) {
		pTemplate->AttachTo(pHitObj->PAppln());
        if (SUCCEEDED(pTemplate->NotifyDebuggerOnPageEvent(TRUE)))
            fDebuggerNotifiedOnStart = TRUE;
    }
		
	// bug 1009: if no script engines, do not attempt to do anything
	if(0 == pTemplate->CountScriptEngines())
		goto LExit;

    // run the script by calling primary script engine's global code
    hr = CallScriptFunctionOfEngine(*pEngineInfo,   // engine-info
                                    0,              // primary script engine
                                    NULL,           // call the engine's global code
                                    pHitObj->PASPObjectContext());

    if (fServiceDomainEnterred) {
        fServiceDomainEnterred = FALSE;
        CoLeaveServiceDomain(static_cast<ITransactionStatus *>(pHitObj->PASPObjectContext()));
    }


    if (pTemplate->FTransacted()) {
        fAborted = pHitObj->PASPObjectContext()->FAborted();
    }

    if (FAILED(hr)) {
        /*
         * The cryptically named CONTEXT_E_OLDREF error in this case means that
         * we are trying to run a transacted web page, but DTC isnt running.
         * CONTEXT_E_TMNOTAVAILABLE means the same thing.  God knows why
         */
        if (hr == CONTEXT_E_OLDREF || hr == CONTEXT_E_TMNOTAVAILABLE) {
            HandleErrorMissingFilename(IDE_EXECUTOR_DTC_NOT_RUNNING, pHitObj);
        }

        // Regardless of the error, exit
        goto LExit;
    }

    /*
     * If this is a transacted web page, then run either the OnTransactionCommit
     * or OnTransactionAbort method in the script, if any.
     *
     * If the script writer did an explicit SetAbort, or a component run by the script
     * did a SetAbort, then we run OnTransactionAbort, otherwise run OnTransactionCommit
     */
    if (pTemplate->FTransacted()) {

#ifndef PERF_DISABLE
        g_PerfData.Incr_TRANSPERSEC();
#endif

        if (fAborted) {

            hr = CallScriptFunction(*pEngineInfo, L"OnTransactionAbort");

#ifndef PERF_DISABLE
            g_PerfData.Incr_TRANSABORTED();
#endif
        }
        else {
            hr = CallScriptFunction(*pEngineInfo, L"OnTransactionCommit");

#ifndef PERF_DISABLE
            g_PerfData.Incr_TRANSCOMMIT();
#endif
        }

        // Ignore UNKNOWNNAME -- this means the author didnt write the method, which is fine
        if (hr == DISP_E_UNKNOWNNAME || hr == DISP_E_MEMBERNOTFOUND)
            hr = S_OK;
            
        if (FAILED(hr))
            goto LExit;
    }

LExit:

    if (fServiceDomainEnterred) {
        CoLeaveServiceDomain(NULL);
    }

#ifndef PERF_DISABLE
    if (fPerfTransPending)
        g_PerfData.Decr_TRANSPENDING();
#endif

    // Uninit the scripting namespace
    (VOID)intrinsics.PScriptingNamespace()->UnInit();

    // Return the engine(s) to cache
    DeAllocAndFreeEngines(pEngineInfo, pHitObj->PAppln());

    // If debugging, notify debugger ONPAGEDONE
    if (fDebuggerNotifiedOnStart) {
        Assert(pHitObj->PAppln()->FDebuggable());
        pTemplate->NotifyDebuggerOnPageEvent(FALSE);
    }

    if (pPoppedASPObjectContext)
        pHitObj->SetASPObjectContext(pPoppedASPObjectContext);

    if (pASPObjectContext)
        pASPObjectContext->Release();

    return hr;
}

/*===================================================================
ExecuteGlobal

UNDONE: handle script engine the same manner as mainline script engines
        with respect to debugging.

Execute code in Global.ASA as part of application or session start or end.

Parameters:
    pHitObj         - pointer to the hit object
    intrinsics      - pointers to the intrinsic IUnknown pointers.
    pEngineInfo     - pointers to engine info
    pfDeleteSession - true if global.asa failed, and therefore the caller should

Returns:
    S_OK on success
===================================================================*/
HRESULT ExecuteGlobal
(
CHitObj *pHitObj,
const CIntrinsicObjects &intrinsics,
ActiveEngineInfo *pEngineInfo
)
    {
    HRESULT hr = S_OK;
    CTemplate *pTemplate = NULL;
    WORD iEng;
    BOOLB fDebuggerNotifiedOnStart = FALSE;

    BOOL fUnHideRequestAndResponse = FALSE;

    BOOL fOnStartAppln = FALSE;
    BOOL fOnEndAppln = FALSE;
    BOOL fOnEndSession = FALSE;
    BOOL fGlobalAsaInCache;
    BOOL fApplnStarted = FALSE;
    BOOL fServiceDomainEnterred = FALSE;
    CASPObjectContext   *pASPObjectContext = NULL;
    CASPObjectContext   *pPoppedASPObjectContext = NULL;

    // The hit obj must be there, be valid, & have a global.asa name
    Assert(pHitObj != NULL);
    pHitObj->AssertValid();
    Assert(pHitObj->GlobalAspPath() != NULL && *(pHitObj->GlobalAspPath()) != '\0');

    // Other arg's must be right
    Assert(pEngineInfo != NULL);

    // Load the script - cache will AddRef
    // bug 1051: load template before possibly removing response object (in switch block, below),
    // so error reporting to browser will work
    hr = LoadTemplate(pHitObj->GlobalAspPath(), pHitObj, &pTemplate, intrinsics, /* fGlobalAsa */ TRUE, &fGlobalAsaInCache);
    if (FAILED(hr))
        goto LExit;

    Assert(pTemplate != NULL);

    // Remember GLOBAL.ASA's type library wrapper with the application
    // on the first request

    if (pHitObj->FStartApplication() && pTemplate->PTypeLibWrapper())
        {
        pHitObj->PAppln()->SetGlobTypeLibWrapper(pTemplate->PTypeLibWrapper());
        }

    if (pTemplate->FTransacted()) {

        pASPObjectContext = new CASPObjectContext();

        if (!pASPObjectContext) {
            hr = E_OUTOFMEMORY;
            goto LExit;
        }
        
        pPoppedASPObjectContext = pHitObj->SetASPObjectContext(pASPObjectContext);
    }

    if (pTemplate->PServicesConfig()) {
        hr = CoEnterServiceDomain(pTemplate->PServicesConfig());
        if (FAILED(hr)) {
            goto LExit;
        }
        fServiceDomainEnterred = TRUE;
    }
        
    Assert(pHitObj->FIsValidRequestType());

    // Figure out which events to trigger
    if (pHitObj->FIsBrowserRequest())
        {
        fOnStartAppln = pHitObj->FStartApplication();

        if (fOnStartAppln)
            {
            // Hide response and request intrinsics from namespace
            pHitObj->HideRequestAndResponseIntrinsics();

            // Flag that intrinsics need to be un-hidden back in.
            fUnHideRequestAndResponse = TRUE;
            }
        }
    else if (pHitObj->FIsSessionCleanupRequest())
        {
        fOnEndSession = TRUE;
        }
    else if (pHitObj->FIsApplnCleanupRequest())
        {
        fOnEndAppln = TRUE;
        }

    // If debugging, notify debugger ONPAGESTART
    if (pHitObj->PAppln()->FDebuggable())
        {
        if (SUCCEEDED(pTemplate->NotifyDebuggerOnPageEvent(TRUE)))
            fDebuggerNotifiedOnStart = TRUE;
        }
        
    hr = AllocAndLoadEngines(pHitObj, pTemplate, pEngineInfo, intrinsics.PScriptingNamespace(), /* fGlobalAsa */TRUE);
    if (FAILED(hr))
        goto LExit;

    // BUG 93991: Defer registration of new document with debugger until after script engines have
    //            been loaded
    //
    if (!fGlobalAsaInCache && pHitObj->PAppln()->FDebuggable())
        pTemplate->AttachTo(pHitObj->PAppln());

    // bug 975: if no script engines, do not attempt to call event functions
    if(0 == pTemplate->CountScriptEngines())
        goto LExit;
        
    /*
     * Call event functions as required
     * bug 459: event functions may be in any script engine
     */
    
    // First run Application_OnStart
    if (fOnStartAppln)
        {           
        pHitObj->SetEventState(eEventAppOnStart);
        
        hr = CallScriptFunction(*pEngineInfo, L"Application_OnStart");
        
        if (SUCCEEDED(hr) || hr == DISP_E_UNKNOWNNAME || hr == DISP_E_MEMBERNOTFOUND ||
            intrinsics.PResponse()->FResponseAborted())
            {
            if (fUnHideRequestAndResponse)
                {
                pHitObj->UnHideRequestAndResponseIntrinsics();
                fUnHideRequestAndResponse = FALSE;
                }
                
            fApplnStarted = TRUE;               
            hr = S_OK;
            }
        else
            {
            goto LExit;
            }
        }
    
    if (pHitObj->FStartSession())
        {
    // If application on start was run, add Response and Request names to script engines
        if (fOnStartAppln)
            {
            for (iEng = 0; iEng < pEngineInfo->cActiveEngines; ++iEng)
                {   
                if (FAILED(hr = pEngineInfo->rgActiveEngines[iEng].pScriptEngine->AddAdditionalObject(WSZ_OBJ_RESPONSE, FALSE)))
                    goto LExit;
                
                if (FAILED(hr = pEngineInfo->rgActiveEngines[iEng].pScriptEngine->AddAdditionalObject(WSZ_OBJ_REQUEST, FALSE)))
                    goto LExit;
                }
            }

        pHitObj->SetEventState(eEventSesOnStart);
        hr = CallScriptFunction(*pEngineInfo, L"Session_OnStart");
        
        if (FAILED(hr) && hr != DISP_E_UNKNOWNNAME && hr != DISP_E_MEMBERNOTFOUND &&
            !intrinsics.PResponse()->FResponseAborted())
            {
            // Mark session as on-start-failed - to be deleted soon
            pHitObj->SessionOnStartFailed();
            }   
        else
            {
            if (SUCCEEDED(hr))
                {
                // Mark as on-start-invoked -- need to wait for timeout
                pHitObj->SessionOnStartInvoked();
                }

            // Check if Session_OnEnd Present
            if (SUCCEEDED(TestScriptFunction(*pEngineInfo, L"Session_OnEnd")))
                {
                // Mark as on-end-present -- need to execute OnEnd later
                pHitObj->SessionOnEndPresent();
                }

            hr = S_OK;
            }

        goto LExit;
        }

    if (fOnEndSession)
        {
        pHitObj->SetEventState(eEventSesOnEnd);
        hr = CallScriptFunction(*pEngineInfo, L"Session_OnEnd");
        // We are failing silently here, since there is no corrective action we could take
        }

        
    if (fOnEndAppln)
        {
        pHitObj->SetEventState(eEventAppOnEnd);
        hr = CallScriptFunction(*pEngineInfo, L"Application_OnEnd");
        // We are failing silently here, since there is no corrective action we could take
        }
            
LExit:

    if (fServiceDomainEnterred)
        CoLeaveServiceDomain(NULL);

    if (fUnHideRequestAndResponse)
        {
        pHitObj->UnHideRequestAndResponseIntrinsics();
        }

    if (FAILED(hr) && (hr != E_SOURCE_FILE_IS_EMPTY) && pHitObj->FStartApplication() && !fApplnStarted)
        {
        pHitObj->ApplnOnStartFailed();
        }

    pHitObj->SetEventState(eEventNone);
        
    // Uninit the scripting namespace
    (VOID)intrinsics.PScriptingNamespace()->UnInit();

    // Release the template
    if (pTemplate)
        {

        // bug 975: if no script engines, do not do this
        if(pTemplate->CountScriptEngines() > 0)
            // Return the engine(s) to cache
            DeAllocAndFreeEngines(pEngineInfo, pHitObj->PAppln());

        // If debugging, notify debugger ONPAGEDONE
        if (fDebuggerNotifiedOnStart)
            {
            Assert(pHitObj->PAppln()->FDebuggable());
            pTemplate->NotifyDebuggerOnPageEvent(FALSE);
            }

        pTemplate->Release();
        }

    // It is OK if the event function was not found in global.asa
    if (hr == DISP_E_UNKNOWNNAME || hr == DISP_E_MEMBERNOTFOUND)
        {
        hr = S_OK;
        }

    if (pPoppedASPObjectContext)
        pHitObj->SetASPObjectContext(pPoppedASPObjectContext);

    if (pASPObjectContext)
        pASPObjectContext->Release();

    return hr;
    }

/*===================================================================
CIntrinsicObjects::Prepare

Prepare intrinsics for the request processing

Parameters:
    pSession        session holding the instrinsics (can be NULL)

Returns:
    HRESULT
===================================================================*/
HRESULT CIntrinsicObjects::Prepare
(
CSession *pSession
)
    {
    HRESULT hr = S_OK;

    if (pSession)
        {
        // get request, response, server from session

        if (SUCCEEDED(hr))
            {
            m_pRequest = pSession->PRequest();
            if (m_pRequest)
                m_pRequest->AddRef();
            else
                hr = E_FAIL;
            }

        if (SUCCEEDED(hr))
            {
            m_pResponse = pSession->PResponse();
            if (m_pResponse)
                m_pResponse->AddRef();
            else
                hr = E_FAIL;
            }

        if (SUCCEEDED(hr))
            {
            m_pServer = pSession->PServer();
            if (m_pServer)
                m_pServer->AddRef();
            else
                hr = E_FAIL;
            }
        }
    else
        {
        // create new request, response, server

        if (SUCCEEDED(hr))
            {
            m_pRequest = new CRequest;
            if (!m_pRequest)
                hr = E_OUTOFMEMORY;
            }

        if (SUCCEEDED(hr))
            {
            m_pResponse = new CResponse;
            if (!m_pResponse)
                hr = E_OUTOFMEMORY;
            }

        if (SUCCEEDED(hr))
            {
            m_pServer = new CServer;
            if (!m_pServer)
                hr = E_OUTOFMEMORY;
            }
        }

    // init request, response, server

    if (SUCCEEDED(hr))
        {
        Assert(m_pRequest);
        hr = m_pRequest->Init();
        }

    if (SUCCEEDED(hr))
        {
        Assert(m_pResponse);
        hr = m_pResponse->Init();
        }

    if (SUCCEEDED(hr))
        {
        Assert(m_pServer);
        hr = m_pServer->Init();
        }

    // create the scripting namespace

    if (SUCCEEDED(hr))
        {
        m_pScriptingNamespace = new CScriptingNamespace;
        if (!m_pScriptingNamespace)
            hr = E_OUTOFMEMORY;
        }

    // cleanup on error

    if (FAILED(hr))
        Cleanup();

    m_fIsChild = FALSE;
    return hr;
    }

/*===================================================================
CIntrinsicObjects::PrepareChild

Prepare intrinsics structure for a child request

Parameters:
    pResponse       parent intrinsic
    pRequest        parent intrinsic
    pServer         parent intrinsic

Returns:
    HRESULT
===================================================================*/
HRESULT CIntrinsicObjects::PrepareChild
(
CResponse *pResponse,
CRequest *pRequest,
CServer *pServer
)
    {
    HRESULT hr = S_OK;

    if (!pResponse || !pRequest || !pServer)
        {
        hr = E_FAIL;
        }

    if (SUCCEEDED(hr))
        {
        m_pResponse = pResponse;
        m_pResponse->AddRef();

        m_pRequest = pRequest;
        m_pRequest->AddRef();

        m_pServer = pServer;
        m_pServer->AddRef();

        m_fIsChild = TRUE;
        }

    if (SUCCEEDED(hr))
        {
        m_pScriptingNamespace = new CScriptingNamespace;
        if (!m_pScriptingNamespace)
            hr = E_OUTOFMEMORY;
        }

    if (FAILED(hr))
        Cleanup();

    return hr;
    }

/*===================================================================
CIntrinsicObjects::Cleanup

Cleanup the intrinsics after the request processing

Parameters:

Returns:
    S_OK
===================================================================*/
HRESULT CIntrinsicObjects::Cleanup()
    {
    if (m_pRequest)
        {
        if (!m_fIsChild)
            m_pRequest->UnInit();
        m_pRequest->Release();
        m_pRequest = NULL;
        }

    if (m_pResponse)
        {
        if (!m_fIsChild)
            m_pResponse->UnInit();
        m_pResponse->Release();
        m_pResponse = NULL;
        }

    if (m_pServer)
        {
        if (!m_fIsChild)
            m_pServer->UnInit();
        m_pServer->Release();
        m_pServer = NULL;
        }

    if (m_pScriptingNamespace)
        {
        m_pScriptingNamespace->Release();
        m_pScriptingNamespace = NULL;
        }

    return S_OK;
    }

/*===================================================================
ReInitIntrinsics

Call re-init on each of the intrinsics that require it
to run a new page.

Parameters:
    pHitObj         - pointer to the hit object
    intrinsics      - pointers to the intrinsic IUnknown pointers.
    pEngineInfo     - some engine info
    fPostGlobal     - Is this a reinit after running global.asa?

Returns:
    S_OK on success
===================================================================*/
HRESULT ReInitIntrinsics
(
CHitObj *pHitObj,
const CIntrinsicObjects &intrinsics,
ActiveEngineInfo *pEngineInfo,
BOOL fPostGlobal
)
    {
    HRESULT hr;

    Assert(pHitObj != NULL);
    pHitObj->AssertValid();
    Assert(pEngineInfo != NULL);
    
    // Hand the new CIsapiReqInfo to the Server object
    // Note on bug 682: We do always need to re-init CServer because it takes the phitobj
    if (FAILED(hr = intrinsics.PServer()->ReInit(pHitObj->PIReq(), pHitObj)))
        goto LExit;

    if (FAILED(hr = intrinsics.PScriptingNamespace()->Init()))
        goto LExit;
        
    /*
     * Bug 682 & 671 (better fix to 452 & 512)
     * Dont re-init the Request & response objects after running a Global.Asa
     * because, the running of global.asa may have set cookies into request (bug 671), that reinit
     * would wipe, and the global.asa may have output headers (or other stuff) which impacts the response
     * object (bug 512) that we dont want to reset.
     */
    if (!fPostGlobal)
        {
        if (FAILED(hr = intrinsics.PRequest()->ReInit(pHitObj->PIReq(), pHitObj)))
            goto LExit;
            
        if (FAILED(hr = intrinsics.PResponse()->ReInit(
                                                pHitObj->PIReq(),
                                                pHitObj->PSzNewSessionCookie(),
                                                intrinsics.PRequest(),
                                                GetScriptEngine,
                                                pEngineInfo,
                                                pHitObj
                                                )))
            goto LExit;
        }
            
LExit:
    return(hr);
    }

/*===================================================================
LoadTemplate

Load a template, cleanup and give appropriate errors on failure.

Parameters:
    szFile          - the file to load a template for
    pHitObj         - pointer to the hit object
    ppTemplate      - The returned loaded template
    fGlobalAsa      - is this for Global.asa?

Returns:
    S_OK on success
===================================================================*/
HRESULT LoadTemplate
(
const TCHAR                 *szFile,
      CHitObj               *pHitObj,
      CTemplate             **ppTemplate,
const CIntrinsicObjects     &intrinsics,
      BOOL                  fGlobalAsa,
      BOOL                  *pfTemplateInCache)
{
    HRESULT hr;

    Assert(pHitObj != NULL);
    pHitObj->AssertValid();
    Assert(ppTemplate != NULL);

    // Load the script - cache will AddRef
    if (FAILED(hr = g_TemplateCache.Load(
    							fGlobalAsa,
    							szFile,
    							pHitObj->DWInstanceID(),
    							pHitObj,
    							ppTemplate,
    							pfTemplateInCache)))
        {
        // CONSIDER moving this cleanup into Template.Load
        if (hr == E_COULDNT_OPEN_SOURCE_FILE || hr == E_SOURCE_FILE_IS_EMPTY)
            {
            // Load error string from string table
            // BUG 731: added if to retrieve the correct header

            WCHAR   szwErr[128];
            
            if (hr == E_COULDNT_OPEN_SOURCE_FILE)
                {
                CwchLoadStringOfId(IDH_404_OBJECT_NOT_FOUND, szwErr, 128);
                intrinsics.PResponse()->put_Status( szwErr );
                HandleSysError(404, 0, IDE_404_OBJECT_NOT_FOUND, NULL, NULL, pHitObj);
#ifndef PERF_DISABLE
                g_PerfData.Incr_REQNOTFOUND();
#endif
                }
            // bug 977: silently ignore empty global.asa file
            else if ((E_SOURCE_FILE_IS_EMPTY == hr) && !fGlobalAsa)
                {
                CwchLoadStringOfId(IDH_204_NO_CONTENT, szwErr, 128);
                intrinsics.PResponse()->put_Status( szwErr );
                HandleSysError(204, 0, IDE_204_NO_CONTENT, NULL, NULL, pHitObj);
                }
            }
        // fix for bug 371
        if (*ppTemplate)
            {
            (*ppTemplate)->Release();
            *ppTemplate = NULL;
            }

		if (hr == E_OUTOFMEMORY)
			{
			DBGPRINTF((DBG_CONTEXT, "Loading template returned E_OUTOFMEMORY.  Flushing template & Script Cache.\n"));
			g_TemplateCache.FlushAll();
			g_ScriptManager.FlushAll();
			}
        }

    return(hr);
    }

/*===================================================================
AllocAndLoadEngines

Allocate and load all the engines we need

Parameters:
    pHitObj             - The hit object
    pTemplate           - The template we're gonna run
    pEngineInfo         - Engine info to fill in
    pScriptingNamespace - scripting namespace
    fGlobalAsa          - Are we loading engines to run global.asa?

Returns:
    S_OK on success
===================================================================*/
HRESULT AllocAndLoadEngines
(
CHitObj *pHitObj,
CTemplate *pTemplate,
ActiveEngineInfo *pEngineInfo,
CScriptingNamespace *pScriptingNamespace,
BOOL fGlobalAsa
)
    {
    HRESULT hr = S_OK;
    int iObj;
    WORD iEng;
    WORD iScriptBlock;
    WORD cEngines = pTemplate->CountScriptEngines();

    Assert(pHitObj != NULL);
    pHitObj->AssertValid();
    Assert(pTemplate != NULL);
    Assert(pEngineInfo != NULL);
    Assert(pScriptingNamespace != NULL);

    // Load objects from template into hit object
    for (iObj = pTemplate->Count(tcompObjectInfo) - 1; iObj >= 0; --iObj)
        {
        CHAR      *szObjectName = NULL;
        CLSID      clsid;
        CompScope scope;
        CompModel model;
        CMBCSToWChar    convStr;
        
        // get object-info from template and add to hitobj's list of objects
        hr = pTemplate->GetObjectInfo(iObj, &szObjectName, &clsid, &scope, &model);
        if(FAILED(hr))
            goto LExit;

        hr = convStr.Init(szObjectName);

        if (FAILED(hr))
            goto LExit;

        // ignore error ?
        pHitObj->AddComponent(ctTagged, clsid, scope, model, convStr.GetString());
        }

    // bug 975: if no script engines, exit now
    if(cEngines == 0)
        goto LExit;
    
    // Allocate space for script engines
    //
    // NOTE: There is a timing problem here in that the response object needs to
    //      be instantiated before we instantiate the script engines, but the
    //      response object needs to be able to access the list of active script
    //      engines, because it may need to halt execution.  To accomplish this,
    //      the response object is passed a pointer to the "EngineInfo" structure
    //      as a pointer, and then we modify the contents of the pointer right under
    //      its nose.  We pass an accessor function via pointer so that response just
    //      sees a void pointer.
    //

    if (cEngines == 1)
        {
        // don't do allocations in case of one engine
        pEngineInfo->rgActiveEngines = & (pEngineInfo->siOneActiveEngine);
        }
    else
        {
        pEngineInfo->rgActiveEngines = new ScriptingInfo[cEngines];
        if (pEngineInfo->rgActiveEngines == NULL)
            {
            hr = E_OUTOFMEMORY;
            goto LExit;
            }
        }

    pEngineInfo->cEngines = cEngines;
    pEngineInfo->cActiveEngines = 0;    // number of SUCCESSFULLY instantiated engines

    // Load all of the script engines in advance.
    for (iScriptBlock = 0; iScriptBlock < cEngines; ++iScriptBlock)
        {
        LPCOLESTR       wstrScript;
        SCRIPTSTATE     nScriptState;

        ScriptingInfo *pScriptInfo = &pEngineInfo->rgActiveEngines[iScriptBlock];
        pTemplate->GetScriptBlock(
                                iScriptBlock,
                                &pScriptInfo->szScriptEngine,
                                &pScriptInfo->pProgLangId,
                                &wstrScript);

        // Populate information required for the line mapping callback.
        //
        pScriptInfo->LineMapInfo.iScriptBlock = iScriptBlock;
        pScriptInfo->LineMapInfo.pTemplate = pTemplate;

        // acquire a script engine by:
        //
        //  getting an engine from the template object (if it has one)
        //  else from the script manager.
        //
        // If we are in debug mode, the templates tend to be greedy and hold
        // onto script engines.  (See notes in scrptmgr.h)
        //
        pScriptInfo->pScriptEngine = NULL;
        
        if (pHitObj->PAppln()->FDebuggable())
            {
            pScriptInfo->pScriptEngine = pTemplate->GetActiveScript(iScriptBlock);
            
            if (pScriptInfo->pScriptEngine)
                {
                // If we got one, we don't need to re-init the engine
                nScriptState = SCRIPTSTATE_INITIALIZED;
                hr = static_cast<CActiveScriptEngine *>(pScriptInfo->pScriptEngine)->ReuseEngine(pHitObj, NULL, iScriptBlock, pHitObj->DWInstanceID());
                }
            }
            
        if (pScriptInfo->pScriptEngine == NULL)
            {
            hr = g_ScriptManager.GetEngine(LOCALE_SYSTEM_DEFAULT,
                                            *(pScriptInfo->pProgLangId),
                                            pTemplate->GetSourceFileName(),
                                            pHitObj,
                                            &pScriptInfo->pScriptEngine,
                                            &nScriptState,
                                            pTemplate,
                                            iScriptBlock);
            }
        if (FAILED(hr))
            goto LExit;

        // BUG 252: Keep track of how many engines we actually instantiate
        ++pEngineInfo->cActiveEngines;

        if (nScriptState == SCRIPTSTATE_UNINITIALIZED || fGlobalAsa)
            {
            if (FAILED(hr = pScriptInfo->pScriptEngine->AddObjects(!fGlobalAsa)))
                goto LExit;
            }

        if (nScriptState == SCRIPTSTATE_UNINITIALIZED)
            {
            if (FAILED(hr = pScriptInfo->pScriptEngine->AddScriptlet(wstrScript)))
                goto LExit;
            }

        // Add the engine to the scripting namespace
        if (FAILED(hr = pScriptingNamespace->AddEngineToNamespace(
                                                (CActiveScriptEngine *)pScriptInfo->pScriptEngine)))
                goto LExit;

		// Update locale & code page (in case they are different om this page)
		pScriptInfo->pScriptEngine->UpdateLocaleInfo(hostinfoLocale);
		pScriptInfo->pScriptEngine->UpdateLocaleInfo(hostinfoCodePage);
        }

    // Add the scripting namespace to each script engine. Because all engines might not
    // implement "lazy instantiation", this code requires all
    // engines are pre-instantiated (which means we can't do it in the above loop.)
    // Add the scripting namespace to the hitobj first
    pHitObj->AddScriptingNamespace(pScriptingNamespace);
        
    for (iEng = 0; iEng < pEngineInfo->cActiveEngines; ++iEng)
        pEngineInfo->rgActiveEngines[iEng].pScriptEngine->AddScriptingNamespace();

    /*
     * Bug 735:
     * Bring all engines except the "primary engine" (engine 0) to runnable state
     * in the order in which script for the given language was found in the script file
     */
    for (iEng = 1; iEng < pEngineInfo->cActiveEngines; ++iEng)
        {
        hr = pEngineInfo->rgActiveEngines[iEng].pScriptEngine->MakeEngineRunnable();
        if (FAILED(hr))
            goto LExit;
        }
    
LExit:
    return(hr);
    }

/*===================================================================
DeAllocAndFreeEngines

Deallocate and free any loaded engines

Parameters:
    pEngineInfo         - Engine info to release

Returns:
    Nothing
===================================================================*/
VOID DeAllocAndFreeEngines
(
ActiveEngineInfo *pEngineInfo,
CAppln *pAppln
)
    {
    WORD iEng;

    Assert(pEngineInfo != NULL);

    if (pEngineInfo->cActiveEngines > 0) {
        if (pEngineInfo->rgActiveEngines == NULL) {
            Assert(pEngineInfo->rgActiveEngines);
        }
        else {
            for (iEng = 0; iEng < pEngineInfo->cActiveEngines; ++iEng)
                g_ScriptManager.ReturnEngineToCache(&pEngineInfo->rgActiveEngines[iEng].pScriptEngine, pAppln);
            pEngineInfo->cActiveEngines = 0;
        }
    }
    if (pEngineInfo->cEngines > 1)
        {
        delete pEngineInfo->rgActiveEngines;
        }

    pEngineInfo->cEngines = 0;
    pEngineInfo->rgActiveEngines = NULL;
    }

/*===================================================================
GetScriptEngine

Get a script engine based on index. Return NULL if the index
is not in range.  (this is a callback)

The AllocAndLoadEngines function will create an array of ScriptingInfo
structures that are defined here.  It contains all the infomation
needed to 1. set up the MapScript2SourceLine callback,
2. merge namespaces, 3. set up this callback.

Parameters:
    iScriptEngine - the script engine to retrieve
    pvData      - instance data for the function

Returns:
    The requested script engine or NULL if not such engine
    
Side effects:
    None
===================================================================*/   
CScriptEngine *GetScriptEngine
(
INT iScriptEngine,
VOID *pvData
)
    {
    ActiveEngineInfo *pInfo = static_cast<ActiveEngineInfo *>(pvData);
    if (unsigned(iScriptEngine) >= unsigned(pInfo->cActiveEngines))
        {
        // Note: the caller has no idea how many script engines there are.
        // if the caller asks for an engine out of range, return NULL so they
        // know they have asked for more than there are
        return NULL;
        }

    return(pInfo->rgActiveEngines[iScriptEngine].pScriptEngine);
    }

/*===================================================================
CallScriptFunctionOfEngine

Calls a script engine to execute one of its functions

Returns:
    S_OK on success
    
Side effects:
    None
===================================================================*/
HRESULT CallScriptFunctionOfEngine
(
ActiveEngineInfo &engineInfo,
short iScriptBlock,
wchar_t *strFunction,
CASPObjectContext   *pASPObjectContext  /* = NULL */
)
{
    HRESULT hr;
    CScriptEngine *pScriptEngine = (CScriptEngine *)engineInfo.rgActiveEngines[iScriptBlock].pScriptEngine;


    Assert(engineInfo.rgActiveEngines != NULL);
    Assert(pScriptEngine != NULL);

    hr = pScriptEngine->Call(strFunction);

    // housekeeping for the transacted case...

    if (pASPObjectContext != NULL) {

        // If the script timed out or there was an unhandled error, then autoabort
        if (SUCCEEDED(hr) && (pScriptEngine->FScriptTimedOut() || pScriptEngine->FScriptHadError()))
        {
            hr = pASPObjectContext->SetAbort();
        }

        // If the script author did not do an explicit SetComplete or SetAbort
        // then do a SetComplete here so Viper will return the transaction
        // completion status to the caller
        if (SUCCEEDED(hr) && !pASPObjectContext->FAborted())
        {
            hr = pASPObjectContext->SetComplete();
        }
    }

    return hr;
}

/*===================================================================
CallScriptFunction

Calls each script engine in turn to execute a script function;
exits when an engine succeeds or we run out of engines.

Returns:
    S_OK on success
    
Side effects:
    None
===================================================================*/
HRESULT CallScriptFunction
(
ActiveEngineInfo &engineInfo,
wchar_t *strFunction
)
    {
    HRESULT hr = E_FAIL;
    int     i;
    
    for (i = 0; i < engineInfo.cActiveEngines; i++)
        {
        // if execution succeeds, bail
        if (SUCCEEDED(hr = CallScriptFunctionOfEngine(engineInfo, (SHORT)i, strFunction)))
            goto LExit;

        // if execution fails with exception other then unknown name, bail
        if (hr != DISP_E_UNKNOWNNAME && hr != DISP_E_MEMBERNOTFOUND)
            goto LExit;
        }

LExit:
    return hr;
    }

/*===================================================================
TestScriptFunction

Tests each script engine in turn to test [the existance of] a script
function; exits when an engine succeeds or we run out of engines.

Parameters
    ActiveEngineInfo &engineInfo
    wchar_t          *strFunction       functions name


Returns:
    S_OK if exists
    
Side effects:
    None
===================================================================*/
HRESULT TestScriptFunction
(
ActiveEngineInfo &engineInfo,
wchar_t *strFunction
)
    {
    HRESULT hr = E_FAIL;
    
    for (int i = 0; i < engineInfo.cActiveEngines; i++)
        {
        hr = engineInfo.rgActiveEngines[i].pScriptEngine->
            CheckEntryPoint(strFunction);

        // if execution succeeds, bail
        if (SUCCEEDED(hr))
            break;

        // if fails with result other then unknown name, bail
        if (hr != DISP_E_UNKNOWNNAME && hr != DISP_E_MEMBERNOTFOUND)
            break;
        }

    return hr;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\gip.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Global Interface Pointer API support

File: Gip.h

Owner: DmitryR

This is the GIP header file.
===================================================================*/

#ifndef _ASP_GIP_H
#define _ASP_GIP_H

/*===================================================================
  Includes
===================================================================*/

#include "debug.h"

/*===================================================================
  Defines
===================================================================*/

#define NULL_GIP_COOKIE  0xFFFFFFFF

/*===================================================================
  C  G l o b a l  I n t e r f a c e  A P I
===================================================================*/

class CGlobalInterfaceAPI
    {
private:
    // Is inited?
    DWORD m_fInited : 1;
    
    // Pointer to the COM object
    IGlobalInterfaceTable *m_pGIT;

public:
    CGlobalInterfaceAPI();
    ~CGlobalInterfaceAPI();

    HRESULT Init();
    HRESULT UnInit();

    // inlines for the real API calls:
    HRESULT Register(IUnknown *pUnk, REFIID riid, DWORD *pdwCookie);
    HRESULT Get(DWORD dwCookie, REFIID riid, void **ppv);
    HRESULT Revoke(DWORD dwCookie);
    
public:
#ifdef DBG
	inline void AssertValid() const
	    {
        Assert(m_fInited);
        Assert(m_pGIT);
	    }
#else
	inline void AssertValid() const {}
#endif
    };

/*===================================================================
  CGlobalInterfaceAPI inlines
===================================================================*/

inline HRESULT CGlobalInterfaceAPI::Register
(
IUnknown *pUnk,
REFIID riid,
DWORD *pdwCookie
)
    {
    Assert(m_fInited);
    Assert(m_pGIT);
    return m_pGIT->RegisterInterfaceInGlobal(pUnk, riid, pdwCookie);
    }

inline HRESULT CGlobalInterfaceAPI::Get
(
DWORD dwCookie,
REFIID riid, 
void **ppv
)
    {
    Assert(m_fInited);
    Assert(m_pGIT);
    return m_pGIT->GetInterfaceFromGlobal(dwCookie, riid, ppv);
    }
        
inline HRESULT CGlobalInterfaceAPI::Revoke
(
DWORD dwCookie
)
    {
    Assert(m_fInited);
    Assert(m_pGIT);
    return m_pGIT->RevokeInterfaceFromGlobal(dwCookie);
    }

/*===================================================================
  Globals
===================================================================*/

extern CGlobalInterfaceAPI g_GIPAPI;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\glob.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Globals

File: glob.cpp

Owner: LeiJin

Implementation of Glob class functions
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "iiscnfgp.h"
#include "debugger.h"
#include "appcnfg.h"
#include "memchk.h"
#include "ftm.h"

HRESULT	ReadConfigFromMD(CIsapiReqInfo   *pIReq, CAppConfig *pAppConfig, BOOL fLoadGlob);
HRESULT MDUnRegisterProperties();
HRESULT MDRegisterProperties(void);

#define DEFAULTSTRSIZE 1024

#define dwUnlimited 0xFFFFFFFF
const DWORD dwMDDefaultTimeOut	= 30000;
enum eConfigType { eDLLConfig = 0, eAppConfig };

/*========================================================================================
The following array definition is for D1 to D2 migration only.  It contains the necessary
information reads from D1 ASP settings in registry.

=========================================================================================*/
typedef struct _D1propinfo
	{
	CHAR *szName;			// Name of the property in the registry
	DWORD dwType;			// Type (e.g. REG_DWORD, REG_SZ, etc)
	DWORD cbData;			// How long is the value
	VOID *pData;
	BOOL fSuccess;			// Load from registry successful or not.
	} D1PROPINFO;

#define NUM_D1PROP_NeedMigrated	18
// This index should be match the index in D1PropInfo.
enum D1PropIndex {
	D1Prop_NotExist	= -1,
	D1Prop_BufferingOn = 0,
	D1Prop_LogErrorRequests,
	D1Prop_ScriptErrorsSentToBrowser,
	D1Prop_ScriptErrorMessage,
	D1Prop_ScriptFileCacheSize,
	D1Prop_ScriptEngineCacheMax,
	D1Prop_ScriptTimeout,
	D1Prop_SessionTimeout,
//	D1Prop_MemFreeFactor,
//	D1Prop_MinUsedBlocks,
	D1Prop_AllowSessionState,
	D1Prop_DefaultScriptLanguage,
//	D1Prop_StartConnectionPool,
	D1Prop_AllowOutOfProcCmpnts,
	D1Prop_EnableParentPaths,
// IIS5.0 (from IIS4.0)
	D1Prop_EnableAspHtmlFallback,
	D1Prop_EnableChunkedEncoding,
	D1Prop_EnableTypelibCache,
	D1Prop_ErrorsToNtLog, 
	D1Prop_ProcessorThreadMax,
	D1Prop_RequestQueueMax
	};

// This flag is used only in setup time.
BOOL	g_fD1ConfigExist = FALSE;
// The index is defined in D1PropIndex.				
D1PROPINFO	D1PropInfo[] =
	{
	{	"BufferingOn", REG_DWORD, 0, 0, FALSE},
	{	"LogErrorRequests", REG_DWORD, 0, 0, FALSE},
	{	"ScriptErrorsSentToBrowser", REG_DWORD, 0, 0, FALSE},
	{	"ScriptErrorMessage", REG_SZ, 0, 0, FALSE},
	{	"ScriptFileCacheSize", REG_DWORD, 0, 0, FALSE},
	{	"ScriptEngineCacheMax", REG_DWORD, 0, 0, FALSE},
	{	"ScriptTimeout", REG_DWORD, 0, 0, FALSE},
	{	"SessionTimeout", REG_DWORD, 0, 0, FALSE},
	{	"AllowSessionState", REG_DWORD, 0, 0, FALSE},
	{	"DefaultScriptLanguage", REG_SZ, 0, 0, FALSE},
	{	"AllowOutOfProcCmpnts", REG_DWORD, 0, 0, FALSE},
	{	"EnableParentPaths", REG_DWORD, 0, 0, FALSE},
// IIS5.0 (from IIS4.0)
	{	"EnableAspHtmlFallback", REG_DWORD, 0, 0, FALSE},
	{	"EnableChunkedEncoding", REG_DWORD, 0, 0, FALSE},
	{	"EnableTypelibCache", REG_DWORD, 0, 0, FALSE},
	{	"ErrorsToNTLog", REG_DWORD, 0, 0, FALSE},
	{	"ProcessorThreadMax", REG_DWORD, 0, 0, FALSE},
	{	"RequestQueueMax", REG_DWORD, 0, 0, FALSE}
	
	};


/*
 * The following array contains all the info we need to create and load
 * all of the registry entries for denali.  See the above PROPINFO structure for details on each of the fields.
 *
 * NOTE: There is an odd thing about initializers and unions.  You must initialize a union with the value of
 * the type of the first element in the union.  In the anonymous union in the PROPINFO structure, we have defined
 * the first type to be DWORD.  Thus, for non-DWORD registry entries, the default value must be cast to a DWORD
 * before being initialized, or initialized using a more explicit mechanism.
 */
/*
 * Info about our properties used by Metabase
 */
typedef struct _MDpropinfo
	{
	INT	id;					// Identifier used in Glob if UserType is IIS_MD_UT_WAM,
							// Identifier used in AppConfig if UserType is ASP_MD_UT_APP.
	INT	iD1PropIndex;		// Index in D1PropInfo. if equals to -1, that it does not exist in D1.
	BOOL fAdminConfig;		// Admin Configurable
	DWORD dwMDIdentifier;	// Metabase identifier
	DWORD dwUserType;		// IIS_MD_UT_WAM(data per Dll) or ASP_MD_UT_APP(data per App)
	DWORD dwType;
	DWORD cbData;
	union					// Default Value
		{
		DWORD dwDefault;	// Default value for DWORDs
		INT idDefault;		// Default value for strings -- the id of the string in the resource
		BYTE *pbDefault;	// Pointer to arbitrary default value
		};
	DWORD dwValueMin;		// For DWORD registry entries, min value allowed
	DWORD dwValueMax;		// For DWORD registry entries, max value allowed
	} MDPROPINFO;

//Some default settings for ASP Metabase
#define ASP_MD_DAttributes	METADATA_INHERIT

const MDPROPINFO rgMDPropInfo[] =
				{

#define THREADGATING_DFLT 0L
#define BUFFERING_DFLT    1L
    //          ID                              D1PropIndex         AdminConfig?        Metabase ID                   UserType      Data Type           cbData    Def, Min, Max  

	// Glob Settings
	// -------------
	
	{ IGlob_LogErrorRequests,           D1Prop_LogErrorRequests,        TRUE,   MD_ASP_LOGERRORREQUESTS,            IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 1L, 0L, 1L},
    { IGlob_ScriptFileCacheSize,        D1Prop_ScriptFileCacheSize,     TRUE,   MD_ASP_SCRIPTFILECACHESIZE,         IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 250L, 0L, dwUnlimited},
	{ IGlob_ScriptEngineCacheMax,       D1Prop_ScriptEngineCacheMax,    TRUE,   MD_ASP_SCRIPTENGINECACHEMAX,        IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 125L, 0L, dwUnlimited},
				
	{ IGlob_ExceptionCatchEnable,       D1Prop_NotExist,                TRUE,   MD_ASP_EXCEPTIONCATCHENABLE,        IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 1L, 0L, 1L},
	{ IGlob_TrackThreadingModel,        D1Prop_NotExist,                TRUE,   MD_ASP_TRACKTHREADINGMODEL,         IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 0L, 0L, 1L},
	{ IGlob_AllowOutOfProcCmpnts,       D1Prop_AllowOutOfProcCmpnts,    FALSE,  MD_ASP_ALLOWOUTOFPROCCMPNTS,        IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 1L, 0L, 1L},
	
	// IIS5.0
	{ IGlob_EnableAspHtmlFallback,      D1Prop_EnableAspHtmlFallback,   TRUE,   MD_ASP_ENABLEASPHTMLFALLBACK,       IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 0L, 0L, 1L},
	{ IGlob_EnableChunkedEncoding,      D1Prop_EnableChunkedEncoding,   TRUE,   MD_ASP_ENABLECHUNKEDENCODING,       IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 1L, 0L, 1L},
	{ IGlob_EnableTypelibCache,         D1Prop_EnableTypelibCache,      TRUE,   MD_ASP_ENABLETYPELIBCACHE,          IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 1L, 0L, 1L},
	{ IGlob_ErrorsToNtLog,              D1Prop_ErrorsToNtLog,           TRUE,   MD_ASP_ERRORSTONTLOG,               IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 0L, 0L, 1L},
	{ IGlob_ProcessorThreadMax,         D1Prop_ProcessorThreadMax,      TRUE,   MD_ASP_PROCESSORTHREADMAX,          IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 25L, 0L, dwUnlimited},
	{ IGlob_RequestQueueMax,            D1Prop_RequestQueueMax,         TRUE,   MD_ASP_REQEUSTQUEUEMAX,             IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 3000L, 0L, dwUnlimited},
	// thread gating
	{ IGlob_ThreadGateEnabled,          D1Prop_NotExist,                TRUE,   MD_ASP_THREADGATEENABLED,           IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), THREADGATING_DFLT, 0L, 1L},
	{ IGlob_ThreadGateTimeSlice,        D1Prop_NotExist,                TRUE,   MD_ASP_THREADGATETIMESLICE,         IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 1000L, 100L, dwUnlimited},
	{ IGlob_ThreadGateSleepDelay,       D1Prop_NotExist,                TRUE,   MD_ASP_THREADGATESLEEPDELAY,        IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 100L, 10L, dwUnlimited},
	{ IGlob_ThreadGateSleepMax,         D1Prop_NotExist,                TRUE,   MD_ASP_THREADGATESLEEPMAX,          IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 50L, 1L, dwUnlimited},
	{ IGlob_ThreadGateLoadLow,          D1Prop_NotExist,                TRUE,   MD_ASP_THREADGATELOADLOW,           IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 50L, 0L, 100L},
	{ IGlob_ThreadGateLoadHigh,         D1Prop_NotExist,                TRUE,   MD_ASP_THREADGATELOADHIGH,          IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 80L, 0L, 100L},

    // Persisted Template Cache
	{ IGlob_PersistTemplateMaxFiles,    D1Prop_NotExist,                TRUE,   MD_ASP_MAXDISKTEMPLATECACHEFILES,   IIS_MD_UT_WAM, DWORD_METADATA,  sizeof(DWORD), 1000L,   0L, dwUnlimited},
    { IGlob_PersistTemplateDir,         D1Prop_NotExist,                TRUE,   MD_ASP_DISKTEMPLATECACHEDIRECTORY,  IIS_MD_UT_WAM, EXPANDSZ_METADATA, dwUnlimited, IDS_DEFAULTPERSISTDIR, 0L, dwUnlimited},
	

    // Application settings
	// --------------------
	
	{ IApp_AllowSessionState,           D1Prop_AllowSessionState,       TRUE,   MD_ASP_ALLOWSESSIONSTATE,           ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), 1L, 0L, 1L},
	{ IApp_BufferingOn,                 D1Prop_BufferingOn,             TRUE,   MD_ASP_BUFFERINGON,                 ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), BUFFERING_DFLT, 0L, 1L},
	{ IApp_ScriptLanguage,              D1Prop_DefaultScriptLanguage,   TRUE,   MD_ASP_SCRIPTLANGUAGE,              ASP_MD_UT_APP, STRING_METADATA, dwUnlimited, IDS_SCRIPTLANGUAGE, 0L, dwUnlimited},
	{ IApp_EnableParentPaths,           D1Prop_EnableParentPaths,       TRUE,   MD_ASP_ENABLEPARENTPATHS,           ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), 1L, 0L, 1L},
	{ IApp_ScriptErrorMessage,          D1Prop_ScriptErrorMessage,      TRUE,   MD_ASP_SCRIPTERRORMESSAGE,          ASP_MD_UT_APP, STRING_METADATA, dwUnlimited, IDS_DEFAULTMSG_ERROR, 0L, dwUnlimited},
	{ IApp_SessionTimeout,              D1Prop_SessionTimeout,          TRUE,   MD_ASP_SESSIONTIMEOUT,              ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), 20L, 1L, dwUnlimited},
	{ IApp_QueueTimeout,                D1Prop_NotExist,                TRUE,   MD_ASP_QUEUETIMEOUT,                ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), dwUnlimited, 1L, dwUnlimited},
	{ IApp_CodePage,                    D1Prop_NotExist,                TRUE,   MD_ASP_CODEPAGE,                    ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), CP_ACP, 0L, dwUnlimited},
	{ IApp_ScriptTimeout,               D1Prop_ScriptTimeout,           TRUE,   MD_ASP_SCRIPTTIMEOUT,               ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), 90L, 1L, dwUnlimited},
	{ IApp_ScriptErrorsSenttoBrowser,   D1Prop_ScriptErrorsSentToBrowser, TRUE, MD_ASP_SCRIPTERRORSSENTTOBROWSER,   ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), 1L, 0L, 1L},
	{ IApp_AllowDebugging,              D1Prop_NotExist,                TRUE,   MD_ASP_ENABLESERVERDEBUG,           ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), 0L, 0L, 1L},
	{ IApp_AllowClientDebug,            D1Prop_NotExist,                TRUE,   MD_ASP_ENABLECLIENTDEBUG,           ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), 0L, 0L, 1L},
	{ IApp_KeepSessionIDSecure,         D1Prop_NotExist,                TRUE,   MD_ASP_KEEPSESSIONIDSECURE,           ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), 0L, 0L, 1L},	

	// IIS5.0
	{ IApp_EnableApplicationRestart,    D1Prop_NotExist,                TRUE,   MD_ASP_ENABLEAPPLICATIONRESTART,    ASP_MD_UT_APP, DWORD_METADATA, sizeof(DWORD), 1L, 0L, 1L},
	{ IApp_QueueConnectionTestTime,     D1Prop_NotExist,                TRUE,   MD_ASP_QUEUECONNECTIONTESTTIME,     ASP_MD_UT_APP, DWORD_METADATA, sizeof(DWORD), 3L, 1L, dwUnlimited},
	{ IApp_SessionMax,                  D1Prop_NotExist,                TRUE,   MD_ASP_SESSIONMAX,                  ASP_MD_UT_APP, DWORD_METADATA, sizeof(DWORD), dwUnlimited, 1L, dwUnlimited},

    // IIS5.1
	{ IApp_ExecuteInMTA,                D1Prop_NotExist,                TRUE,   MD_ASP_EXECUTEINMTA,                ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), 0L, 0L, 1},
    { IApp_LCID,                        D1Prop_NotExist,                TRUE,   MD_ASP_LCID,                        ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), LOCALE_SYSTEM_DEFAULT, 0L, dwUnlimited},

    // IIS6.0 ServicesWithoutComponents
    { IApp_ServiceFlags,                D1Prop_NotExist,                TRUE,   MD_ASP_SERVICE_FLAGS,               ASP_MD_UT_APP, DWORD_METADATA,  sizeof(DWORD), 0L, 0L, 7L},
	{ IApp_PartitionGUID,               D1Prop_NotExist,                TRUE,   MD_ASP_SERVICE_PARTITION_ID,        ASP_MD_UT_APP, STRING_METADATA, dwUnlimited, 0xffffffff, 0L, dwUnlimited},
	{ IApp_SxsName,                     D1Prop_NotExist,                TRUE,   MD_ASP_SERVICE_SXS_NAME,            ASP_MD_UT_APP, STRING_METADATA, dwUnlimited, 0xffffffff, 0L, dwUnlimited}
	};

const DWORD rgdwMDObsoleteIdentifiers[] =
    {MD_ASP_MEMFREEFACTOR,
     MD_ASP_MINUSEDBLOCKS
    };
    
const UINT cPropsMax = sizeof(rgMDPropInfo) / sizeof(MDPROPINFO);


/*===================================================================
ReadAndRemoveOldD1PropsFromRegistry

Reads whatever old D1 properties are in the registry and
stores the values into D1PropInfo[] global array.
Removes the old properties found from the registry.

Returns:
	HRESULT	- S_OK on success

Side effects:
	Fills in values in Glob
===================================================================*/
BOOL ReadAndRemoveOldD1PropsFromRegistry()
{
	HKEY		hkey = NULL;
	DWORD		iValue;
	BYTE		cTrys = 0;
	DWORD		dwType;
	BYTE		bData[DEFAULTSTRSIZE];			// Size???
	BYTE		*lpRegString = NULL;			// need to use dynamic allocation when we have ERROR_MORE_DATA
	DWORD		cbData;
	HRESULT 	hr = S_OK;

	// Open the key for W3SVC\ASP\Parameters
	if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Services\\W3SVC\\ASP\\Parameters", 0, KEY_READ|KEY_WRITE, &hkey) != ERROR_SUCCESS)
		return(FALSE);

	// Load each of the values
	for (iValue = 0; iValue < NUM_D1PROP_NeedMigrated; iValue++)
		{
		LONG err;
		D1PROPINFO *pPropInfo;

		pPropInfo = &D1PropInfo[iValue];

		cbData = sizeof(bData);
		err = RegQueryValueExA(hkey, pPropInfo->szName, 0, &dwType, bData, &cbData);

		if (err == ERROR_MORE_DATA)
			{
			lpRegString = (BYTE *)GlobalAlloc(GPTR, cbData);
			err = RegQueryValueExA(hkey, pPropInfo->szName, 0, &dwType, lpRegString, &cbData);
			}

		// if get an error, or not the type we expect, then use the default
		if (err != ERROR_SUCCESS || dwType != pPropInfo->dwType)
			{
			pPropInfo->fSuccess = FALSE;
			continue;
			}
			
		// Success : Got the data, copy it into Glob
		// But first, if this is a DWORD type, make sure it is within allowed Max/Min range
		switch (pPropInfo->dwType)
			{
			case REG_DWORD:
				Assert(cbData == sizeof(DWORD));
				if (cbData == sizeof(DWORD))
					{
					pPropInfo->cbData = cbData;
					pPropInfo->pData = (VOID *)UIntToPtr((*(DWORD *)bData));
					pPropInfo->fSuccess = TRUE;
					}
				break;

			case REG_SZ:		
				if (lpRegString == NULL)
					{	// The string fit into default allocation
					lpRegString = (BYTE *)GlobalAlloc(GPTR, cbData * sizeof(WCHAR));
					if (lpRegString == NULL)
						return FALSE;

					MultiByteToWideChar(CP_ACP, 0, (LPCSTR)bData, -1, (LPWSTR)lpRegString, cbData);
					}
					
				pPropInfo->cbData = cbData * sizeof(WCHAR);
				pPropInfo->pData = (VOID *)lpRegString;
				pPropInfo->fSuccess = TRUE;
				lpRegString = NULL;
				break;
			}

		// remove the value from the registry
		RegDeleteValueA(hkey, pPropInfo->szName);
		}

    // remove some old properties that 'get lost' in the upgrade
	RegDeleteValueA(hkey, "CheckForNestedVroots");
	RegDeleteValueA(hkey, "EventLogDirection");
	RegDeleteValueA(hkey, "ScriptFileCacheTTL");
	RegDeleteValueA(hkey, "StartConnectionPool");
	RegDeleteValueA(hkey, "NumInitialThreads");
	RegDeleteValueA(hkey, "ThreadCreationThreshold");
	RegDeleteValueA(hkey, "MinUsedBlocks");
	RegDeleteValueA(hkey, "MemFreeFactor");
	RegDeleteValueA(hkey, "MemClsFreeFactor");
	RegDeleteValueA(hkey, "ThreadDeleteDelay");
	RegDeleteValueA(hkey, "ViperRequestQueueMax");

	RegCloseKey(hkey);

	// remove the W3SVC\ASP\Paramaters key
	if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Services\\W3SVC\\ASP", 0, KEY_READ|KEY_WRITE, &hkey) == ERROR_SUCCESS)
	    {
        RegDeleteKeyA(hkey, "Parameters");
    	RegCloseKey(hkey);
	    }
	    
	// remove the W3SVC\ASP key
	if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, "System\\CurrentControlSet\\Services\\W3SVC", 0, KEY_READ|KEY_WRITE, &hkey) == ERROR_SUCCESS)
	    {
        RegDeleteKeyA(hkey, "ASP");
    	RegCloseKey(hkey);
	    }
	
	return TRUE;
}

/*==================================================================
MDRegisterProperties
Register info about our properties in the metabase.  This funtion is
called during regsvr32, self-registration time.

Returns:
	HRESULT	- S_OK on success

Side effects:
	Registers denali properties in the metabase
===================================================================*/
HRESULT MDRegisterProperties(void)
{
	HRESULT	hr = S_OK;
	DWORD	iValue;
	IMSAdminBase	*pMetabase = NULL;
	METADATA_HANDLE hMetabase = NULL;
	METADATA_RECORD	recMetaData;
	BYTE	szDefaultString[2*DEFAULTSTRSIZE];
	HRESULT	hrT = S_OK;
	BOOL	fNeedMigrated;

	fNeedMigrated = ReadAndRemoveOldD1PropsFromRegistry();

	hr = CoInitialize(NULL);
	if (FAILED(hr))
		{
		return hr;
		}

	hr = CoCreateInstance(CLSID_MSAdminBase, NULL, CLSCTX_SERVER, IID_IMSAdminBase, (void **)&pMetabase);
	if (FAILED(hr))
		{
		CoUninitialize();
		return hr;
		}
		
	// Open key to the Web service, and get a handle of \LM\w3svc
	hr = pMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE, (LPWSTR)(L"\\LM\\W3SVC"),
							METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
							dwMDDefaultTimeOut, &hMetabase);
	if (FAILED(hr))
		{
		goto LExit;
		}

    //
    // Remove obsolete metabase settings
    // See rgdwMDObsoleteIdentifiers structure for detail list of properties
    //
    for (iValue = 0; iValue < sizeof(rgdwMDObsoleteIdentifiers)/sizeof(DWORD);
        iValue++)
        {
        hr = pMetabase->DeleteData( hMetabase,
                                    NULL,
                                    rgdwMDObsoleteIdentifiers[iValue],
                                    0);
        if (FAILED(hr))
            {
            if (hr == MD_ERROR_DATA_NOT_FOUND)
                {
                hr = S_OK;
                }
            else
                {
                Assert(FALSE);
                }
            }
        }

    //
    // Set metabase properties
    //
	recMetaData.dwMDDataTag = 0;	// this parameter is not used when setting data
	for (iValue = 0; iValue < cPropsMax; iValue++)
		{
		INT	    cch;
		BYTE    aByte[4]; // Temporary buffer
		DWORD   dwLen;
		D1PROPINFO *pD1PropInfo;
		recMetaData.dwMDIdentifier = rgMDPropInfo[iValue].dwMDIdentifier;
		recMetaData.dwMDAttributes = METADATA_INHERIT;
		recMetaData.dwMDUserType = rgMDPropInfo[iValue].dwUserType;
		recMetaData.dwMDDataType = rgMDPropInfo[iValue].dwType;

        dwLen = 0;
        recMetaData.dwMDDataLen = 0;
		recMetaData.pbMDData = (unsigned char *)aByte;

        HRESULT hrGetData = pMetabase->GetData(hMetabase, NULL, &recMetaData, &dwLen);
		
		if (hrGetData == MD_ERROR_DATA_NOT_FOUND)
		    {
		    switch (rgMDPropInfo[iValue].dwType)
    			{
    			case DWORD_METADATA:
    			
    				if (fNeedMigrated && rgMDPropInfo[iValue].iD1PropIndex != D1Prop_NotExist )
    					{
    					pD1PropInfo = &D1PropInfo[rgMDPropInfo[iValue].iD1PropIndex];
    					if (pD1PropInfo->fSuccess == TRUE)
    						{
    						recMetaData.dwMDDataLen = pD1PropInfo->cbData;
    						recMetaData.pbMDData = (unsigned char *)&(pD1PropInfo->pData);
    						break;
    						}
    					}
    				// Did not migrated.		
    				recMetaData.dwMDDataLen = rgMDPropInfo[iValue].cbData;
    				recMetaData.pbMDData = (unsigned char *)&(rgMDPropInfo[iValue].dwDefault);
    				break;
    				
                case EXPANDSZ_METADATA:
    			case STRING_METADATA:
    				if (fNeedMigrated && rgMDPropInfo[iValue].iD1PropIndex != D1Prop_NotExist )
    					{
    					pD1PropInfo = &D1PropInfo[rgMDPropInfo[iValue].iD1PropIndex];
    					if (pD1PropInfo->fSuccess == TRUE)
    						{
    						recMetaData.dwMDDataLen = pD1PropInfo->cbData;
    						recMetaData.pbMDData = (unsigned char *)(pD1PropInfo->pData);
    						break;
    						}
    					}

    				// Did not migrated
    				cch = CwchLoadStringOfId(rgMDPropInfo[iValue].idDefault, (LPWSTR)szDefaultString, DEFAULTSTRSIZE);
    				if (cch == 0)
    					{
    					DBGPRINTF((DBG_CONTEXT, "LoadString failed, id = %d\n", rgMDPropInfo[iValue].idDefault));
    					}
    				recMetaData.dwMDDataLen = (cch + 1)*sizeof(WCHAR);
    				recMetaData.pbMDData = szDefaultString;
    				break;
    				
    			default:
    				// So far, DWORD and STRING are the only 2 types.
    				// Never reach this code path.
    				Assert(FALSE);
    				continue;
    			}
    			
    		// not found - then set
    		hr = pMetabase->SetData(hMetabase, NULL,  &recMetaData);
    		}
        else
            {
    		// don't change if the data is already in the metabase
            hr = S_OK;
            }
            
    	if (FAILED(hr))
	    	{
	    	DBGPRINTF((DBG_CONTEXT, "Metabase SetData failed, identifier = %08x.\n", rgMDPropInfo[iValue].dwMDIdentifier));
		    }
		}
	hrT = pMetabase->CloseKey(hMetabase);

	if (fNeedMigrated)
		{
		if (D1PropInfo[D1Prop_DefaultScriptLanguage].pData != NULL)
			{
			GlobalFree(D1PropInfo[D1Prop_DefaultScriptLanguage].pData);
			}
			
		if (D1PropInfo[D1Prop_ScriptErrorMessage].pData != NULL)
			{
			GlobalFree(D1PropInfo[D1Prop_ScriptErrorMessage].pData);
			}
		}
	//
LExit:
	if (pMetabase)
		pMetabase->Release();

	CoUninitialize();
	
	return hr;
}

/*===================================================================
SetConfigToDefaults

Before loading values from the Metabase, set up default values
in case anything goes wrong.

Parameters:
	CAppConfig	Application Config Object / per application
	fLoadGlob	if fLoadGlob is TRUE, load glob data, otherwise, load data into AppConfig object.

Returns:
	HRESULT	- S_OK on success

Side effects:
===================================================================*/
HRESULT	SetConfigToDefaults(CAppConfig *pAppConfig, BOOL fLoadGlob)
{
	HRESULT 			hr = S_OK;
	DWORD				dwMDUserType = 0;
	BYTE				*szRegString	= NULL;
	UINT 				iEntry = 0;

	if (fLoadGlob)
		{
		dwMDUserType = IIS_MD_UT_WAM;
		}
	else
		{
		dwMDUserType = ASP_MD_UT_APP;
		}

	for(iEntry = 0; iEntry < cPropsMax; iEntry++)
		{
		if (rgMDPropInfo[iEntry].dwUserType != dwMDUserType)
			continue;

		// After metabase has been read once, data with fAdminConfig = FALSE cant be changed on the fly.
		// so we dont bother to reset it
		if (fLoadGlob)
			{
			if (TRUE == Glob(fMDRead) && FALSE == rgMDPropInfo[iEntry].fAdminConfig)
				{
				continue;
				}
			}
		else
			{
			if (TRUE == pAppConfig->fInited() && FALSE == rgMDPropInfo[iEntry].fAdminConfig)
				{
				continue;
				}
			}
			
		switch (rgMDPropInfo[iEntry].dwType)
			{
			case DWORD_METADATA:
				if (fLoadGlob)
					gGlob.SetGlobValue(rgMDPropInfo[iEntry].id, (BYTE *)&rgMDPropInfo[iEntry].dwDefault);
				else
					hr = pAppConfig->SetValue(rgMDPropInfo[iEntry].id, (BYTE *)&rgMDPropInfo[iEntry].dwDefault);
				break;
				
			case STRING_METADATA:
            case EXPANDSZ_METADATA:
                if (rgMDPropInfo[iEntry].idDefault == 0xffffffff)
                    continue;
				szRegString = (BYTE *)GlobalAlloc(GPTR, DEFAULTSTRSIZE);
                if (szRegString == NULL) {
                    hr = E_OUTOFMEMORY;
                    break;
                }
				CchLoadStringOfId(rgMDPropInfo[iEntry].idDefault, (LPSTR)szRegString, DEFAULTSTRSIZE);
                if (rgMDPropInfo[iEntry].dwType == EXPANDSZ_METADATA) {
                    BYTE  *pszExpanded = (BYTE *)GlobalAlloc(GPTR, DEFAULTSTRSIZE);
                    if (pszExpanded == NULL) {
                        hr = E_OUTOFMEMORY;
                        break;
                    }
                    INT result = ExpandEnvironmentStringsA((LPCSTR)szRegString,
                                                           (LPSTR)pszExpanded,
                                                           DEFAULTSTRSIZE);   
                    if ((result <= DEFAULTSTRSIZE) && (result > 0)) {
                        GlobalFree(szRegString);
                        szRegString = pszExpanded;
                    }
                }                                                         
				if (fLoadGlob)
					gGlob.SetGlobValue(rgMDPropInfo[iEntry].id, (BYTE *)(&szRegString));
				else
					hr = pAppConfig->SetValue(rgMDPropInfo[iEntry].id, (BYTE *)(&szRegString));
				break;
				
			default:
				Assert(FALSE);
				break;
			}
		}

	// Disable caching in Win95
	// Registry get read only once in the Init time in Win95.
	// So, set those caching related values here.
	if(!gGlob.m_fWinNT)
		{
		gGlob.m_dwScriptFileCacheSize = 0;
		gGlob.m_dwScriptEngineCacheMax = 0;
		}

	return hr;
}

/*===================================================================
ReadConfigFromMD

Read our properties from the registry.  If our props are missing, the
registry is messed up, try to re-register.  If our props are there, but
one or more values is missing, use the defaults.

Parameters:
	CAppConfig	Application Config Object / per application
	fLoadGlob	if fLoadGlob is TRUE, load glob data, otherwise, load data into AppConfig object.

Returns:
	HRESULT	- S_OK on success

Side effects:
===================================================================*/
HRESULT	ReadConfigFromMD
(
CIsapiReqInfo   *pIReq,
CAppConfig *pAppConfig,
BOOL fLoadGlob
)
{
	HRESULT 			hr = S_OK;
	HRESULT 			hrT = S_OK;
	DWORD				dwNumDataEntries = 0;
	DWORD				cbRequired = 0;
	DWORD				dwMDUserType = 0;
	DWORD        		cbBuffer;
	BYTE				bBuffer[2000];
	BYTE				*pBuffer = NULL;
	BYTE				*szRegString	= NULL;
	BOOL				fAllocBuffer = FALSE;
	CHAR				szMDOORange[DEFAULTSTRSIZE];
	TCHAR				szMDGlobPath[] = _T("\\LM\\W3SVC");
	TCHAR				*szMDPath = NULL;
	UINT 				iEntry = 0;
	METADATA_GETALL_RECORD	*pMDGetAllRec;
	
	if (fLoadGlob)
		{
		// BUGs 88902, 105745:
		// If we are InProc, then use the "root" path for global values
		// If OutOfProc, then use the app path for global values
		if (pIReq->FInPool())
	    	szMDPath = szMDGlobPath;
	    else
	    	szMDPath = pIReq->QueryPszApplnMDPath();

   		dwMDUserType = IIS_MD_UT_WAM;
		}
	else
		{
		dwMDUserType = ASP_MD_UT_APP;
		szMDPath = pAppConfig->SzMDPath();
		}

	Assert(szMDPath != NULL);

	// PreLoad config data with default, in case anything failed.
    hr = SetConfigToDefaults(pAppConfig, fLoadGlob);
    if (FAILED(hr))
        {
        Assert(FALSE);
        DBGPRINTF((DBG_CONTEXT,"ReadConfigFromMD: Setting defaults failed with %x\n",hr));
		return hr;
		}

	// Set flags.
	//
	BOOL fConfigLoaded[cPropsMax];
	for (iEntry = 0; iEntry < cPropsMax; iEntry++) {
		fConfigLoaded[iEntry] = FALSE;
    }

	pBuffer = bBuffer;
    hr = pIReq->GetAspMDAllData(szMDPath, 
								dwMDUserType,
								sizeof(bBuffer),
								(unsigned char *)pBuffer,
								&cbRequired,
								&dwNumDataEntries
								);
								
    if (hr == RETURNCODETOHRESULT(ERROR_INSUFFICIENT_BUFFER)) {
		pBuffer = (BYTE *)GlobalAlloc(GPTR, cbRequired);
		if (pBuffer == NULL)
			return E_OUTOFMEMORY;

		fAllocBuffer = TRUE;
		cbBuffer = cbRequired;
        hr = pIReq->GetAspMDAllData(szMDPath, 
								    dwMDUserType,
								    cbRequired,
								    (unsigned char *)pBuffer,
								    &cbRequired,
								    &dwNumDataEntries);
    }

	if (FAILED(hr)) {
        DBGPRINTF((DBG_CONTEXT,"ReadConfigFromMD: GetAspMDAllData failed with %x\n",hr));
		return hr;
    }
    else {
		INT	cProps = 0;
		
		pMDGetAllRec = (METADATA_GETALL_RECORD *)pBuffer;
		for (UINT iValue = 0; iValue < dwNumDataEntries; iValue ++)
			{
			DWORD dwData;
			DWORD iTemp;
			DWORD cbStr;
			CHAR szMDOORangeFormat[DEFAULTSTRSIZE];

			// Init iEntry to be -1, -1 is invalid for rgMDPropInfo[] Array Index.
			iEntry = -1;
			for (iTemp = 0; iTemp < cPropsMax; iTemp++) {
				if (rgMDPropInfo[iTemp].dwMDIdentifier == pMDGetAllRec->dwMDIdentifier) {
					iEntry = iTemp;
					break;
                }
            }

			// Not found
			if (iEntry == -1) {
				pMDGetAllRec++;
				continue;
            }

			// Do found the entry in rgMDPropInfo, but datatype does not match.
			// Should never happen.
			if (rgMDPropInfo[iEntry].dwUserType != dwMDUserType) {	// GetAllData should filter out the unwanted UserType.
				Assert(FALSE);
				pMDGetAllRec++;
				continue;
            }

			cProps++;
			
			// After metabase has been read once, data with fAdminConfig = FALSE cant be changed on the fly.
			// so we dont bother to reread it
			if (fLoadGlob) {
				if (TRUE == Glob(fMDRead) && FALSE == rgMDPropInfo[iEntry].fAdminConfig) {
					pMDGetAllRec++;
					continue;
                }
			}
			else {
				if (TRUE == pAppConfig->fInited() && FALSE == rgMDPropInfo[iEntry].fAdminConfig) {
					pMDGetAllRec++;
					continue;
                }
            }
				
			switch(pMDGetAllRec->dwMDDataType) {
				case DWORD_METADATA:
					Assert(pMDGetAllRec->dwMDDataLen == sizeof(DWORD));

					dwData = *(UNALIGNED64 DWORD *)(pBuffer + pMDGetAllRec->dwMDDataOffset);

                    if (dwData > rgMDPropInfo[iEntry].dwValueMax) {
						szMDOORange[0] = '\0';
						CchLoadStringOfId(IDS_MDOORANGE_FORMAT, szMDOORangeFormat, DEFAULTSTRSIZE);
						sprintf(szMDOORange, szMDOORangeFormat,
							rgMDPropInfo[iEntry].dwMDIdentifier,	
							rgMDPropInfo[iEntry].dwValueMax);
						MSG_Warning((LPCSTR)szMDOORange);

						dwData = rgMDPropInfo[iEntry].dwValueMax;
                    }

					if (dwData < rgMDPropInfo[iEntry].dwValueMin) {
						szMDOORange[0] = '\0';
						CchLoadStringOfId(IDS_MDOORANGE_FORMAT, szMDOORangeFormat, DEFAULTSTRSIZE);
						sprintf(szMDOORange, szMDOORangeFormat,
							rgMDPropInfo[iEntry].dwMDIdentifier,	
							rgMDPropInfo[iEntry].dwValueMin);
						MSG_Warning((LPCSTR)szMDOORange);

						dwData = rgMDPropInfo[iEntry].dwValueMin;
                    }
					
					if (fLoadGlob)
						gGlob.SetGlobValue(rgMDPropInfo[iEntry].id, (BYTE *)&dwData);
					else
						pAppConfig->SetValue(rgMDPropInfo[iEntry].id, (BYTE *)&dwData);

					fConfigLoaded[iEntry] = TRUE;

					break;
					
				case STRING_METADATA:
                case EXPANDSZ_METADATA:
					// bug fix 102010 DBCS fixes (& 99806)
					//cbStr = (pMDGetAllRec->dwMDDataLen) / sizeof(WCHAR);
					cbStr = pMDGetAllRec->dwMDDataLen;
					szRegString = (BYTE *)GlobalAlloc(GPTR, cbStr);
                    if (szRegString == NULL) {
                        hr = E_OUTOFMEMORY;
                        break;
                    }
					WideCharToMultiByte(CP_ACP, 0, (LPWSTR)(pBuffer + pMDGetAllRec->dwMDDataOffset), -1,
						(LPSTR)szRegString, cbStr, NULL, NULL);
                    if (pMDGetAllRec->dwMDDataType == EXPANDSZ_METADATA) {
                        BYTE  *pszExpanded = (BYTE *)GlobalAlloc(GPTR, DEFAULTSTRSIZE);
                        if (pszExpanded == NULL) {
                            hr = E_OUTOFMEMORY;
                            break;
                        }
                        INT result = ExpandEnvironmentStringsA((LPCSTR)szRegString,
                                                               (LPSTR)pszExpanded,
                                                               DEFAULTSTRSIZE);   
                        if ((result <= DEFAULTSTRSIZE) && (result > 0)) {
                            GlobalFree(szRegString);
                            szRegString = pszExpanded;
                        }
                    }                                                         
					if (fLoadGlob)
						gGlob.SetGlobValue(rgMDPropInfo[iEntry].id, (BYTE *)(&szRegString));
					else
						pAppConfig->SetValue(rgMDPropInfo[iEntry].id, (BYTE *)(&szRegString));

					fConfigLoaded[iEntry] = TRUE;
					szRegString = NULL;
					break;
					
				default:
					Assert(FALSE);
					break;
			}
            pMDGetAllRec++;
        }
    }

	BOOL fHasLoadError;
	for (iEntry = 0, fHasLoadError = FALSE; iEntry < cPropsMax && fHasLoadError == FALSE; iEntry++) {
		//
		// Check LoadError in Glob config settings when fLoadGlob is TRUE
		// Check LoadError in App Config settings when fLoadGlob is FALSE
		//
		if ((fLoadGlob && rgMDPropInfo[iEntry].dwUserType == IIS_MD_UT_WAM) ||
			(!fLoadGlob && rgMDPropInfo[iEntry].dwUserType ==ASP_MD_UT_APP)) {
			fHasLoadError = (fConfigLoaded[iEntry]) ? FALSE : TRUE;
        }
    }

	if (fHasLoadError) {			
		// Reuse szMDOORange as the error logging buffer
		szMDOORange[0] = '\0';
		CchLoadStringOfId(IDS_RE_REGSVR_ASP, szMDOORange, DEFAULTSTRSIZE);
		MSG_Error((LPCSTR)szMDOORange);
		//hr = E_FAIL;
    }
	
    if (SUCCEEDED(hr) && !gGlob.m_fMDRead &fLoadGlob)
        gGlob.m_fMDRead = TRUE;

	if (fAllocBuffer == TRUE) {
		GlobalFree(pBuffer);
    }

	return hr;
}

/*==================================================================
CMDGlobConfigSink::QueryInterface

Returns:
	HRESULT	- S_OK on success

Side effects:
===================================================================*/
STDMETHODIMP CMDGlobConfigSink::QueryInterface(REFIID iid, void **ppv)
	{
	*ppv = NULL;
	
	if (iid == IID_IUnknown || iid == IID_IMSAdminBaseSink)
		*ppv = (IMSAdminBaseSink *)this;
	else
		return ResultFromScode(E_NOINTERFACE);

	((IUnknown *)*ppv)->AddRef();
	return S_OK;
	}

/*==================================================================
CMDGlobConfigSink::AddRef

Returns:
	ULONG	- The new ref counter of object

Side effects:
===================================================================*/
STDMETHODIMP_(ULONG) CMDGlobConfigSink::AddRef(void)
	{
	LONG  cRefs = InterlockedIncrement((long *)&m_cRef);
	return cRefs;
	}

/*==================================================================
CMDGlobConfigSink::Release

Returns:
	ULONG	- The new ref counter of object

Side effects: Delete object if ref counter is zero.
===================================================================*/
STDMETHODIMP_(ULONG) CMDGlobConfigSink::Release(void)
	{
	LONG  cRefs = InterlockedDecrement((long *)&m_cRef);
	if (cRefs == 0)
		{
		delete this;
		}
	return cRefs;
	}

/*==================================================================
CMDGlobConfigSink::SinkNotify

Returns:
	HRESULT	- S_OK on success

Side effects: Set fNeedUpdate to TRUE, and glob data will gets update next time a request coming in.
===================================================================*/
STDMETHODIMP	CMDGlobConfigSink::SinkNotify(
				DWORD	dwMDNumElements,
				MD_CHANGE_OBJECT_W	__RPC_FAR	pcoChangeList[])
	{
    if (IsShutDownInProgress())
        return S_OK;
        
        
	UINT	iEventNum = 0;
	DWORD	iDataIDNum = 0;
	WCHAR	wszMDPath[] = L"/LM/W3SVC/";
	UINT	cSize = 0;


	cSize = wcslen(wszMDPath);
	for (iEventNum = 0; iEventNum < dwMDNumElements; iEventNum++)
		{
		if (0 == wcsnicmp(wszMDPath, (LPWSTR)pcoChangeList[iEventNum].pszMDPath, cSize + 1))
			{
			for (iDataIDNum = 0; iDataIDNum < pcoChangeList[iEventNum].dwMDNumDataIDs; iDataIDNum++)
				{
				if (pcoChangeList[iEventNum].pdwMDDataIDs[iDataIDNum] >= ASP_MD_SERVER_BASE
					&& pcoChangeList[iEventNum].pdwMDDataIDs[iDataIDNum] <= MD_ASP_ID_LAST)
					{
					gGlob.NotifyNeedUpdate();
					return S_OK;
					}

				}
			}
		}

	return S_OK;
	}

/*===================================================================
MDUnRegisterProperties

Remove info about our properties in the Metabase.

Returns:
	HRESULT	- S_OK on success

Side effects:
	Removes denali properties in the Metabase

	// to settings per dll.
===================================================================*/
HRESULT MDUnRegisterProperties(void)
{
	HRESULT	hr = S_OK;
	DWORD	iValue;
	IMSAdminBase	*pMetabase = NULL;
	METADATA_HANDLE hMetabase = NULL;
	BYTE	szDefaultString[DEFAULTSTRSIZE];
	BOOL	fMDSaveData = TRUE;
	HRESULT	hrT = S_OK;

	hr = CoInitialize(NULL);
	if (FAILED(hr))
		{
		return hr;
		}

	hr = CoCreateInstance(CLSID_MSAdminBase, NULL, CLSCTX_SERVER, IID_IMSAdminBase, (void **)&pMetabase);
	if (FAILED(hr))
		{
		CoUninitialize();
		return hr;
		}
		
	// Open key to the Web service, and get a handle of \LM\w3svc
	hr = pMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE, (LPWSTR)L"\\LM\\W3SVC",
										METADATA_PERMISSION_WRITE, dwMDDefaultTimeOut, &hMetabase);
	if (FAILED(hr))
		{
		goto LExit;
		}

	for (iValue = 0; iValue < cPropsMax; iValue++)
		{
		hr = pMetabase->DeleteData(	hMetabase,
									NULL,
									rgMDPropInfo[iValue].dwMDIdentifier,
									0);
		if (FAILED(hr))
			{
			if (hr == MD_ERROR_DATA_NOT_FOUND)
				{
				hr = S_OK;
				}
			else
				{
				Assert(FALSE);
				}
			}
		}

	hrT = pMetabase->CloseKey(hMetabase);
	// Add data to W3SVC
LExit:
	if (pMetabase)
		pMetabase->Release();

	CoUninitialize();
	
	return hr;
}
/*===================================================================
Cglob::CGlob

Constructor.  Fill glob with some default values.

in:

returns:

Side effects:
===================================================================*/
CGlob::CGlob()
	:
	m_pITypeLibDenali(NULL),
    m_pITypeLibTxn(NULL),
	m_fWinNT(TRUE),			
    m_dwNumberOfProcessors(1),
	m_fInited(FALSE),
	m_fMDRead(FALSE),
	m_fNeedUpdate(TRUE),			
	m_dwScriptEngineCacheMax(120),
	m_dwScriptFileCacheSize(dwUnlimited),
	m_fLogErrorRequests(TRUE),
	m_fExceptionCatchEnable(TRUE),
	m_fAllowOutOfProcCmpnts(FALSE),
	m_fAllowDebugging(FALSE),
	m_fTrackThreadingModel(FALSE),
	m_dwMDSinkCookie(0),
	m_pMetabaseSink(NULL),
    m_pMetabase(NULL),
	m_fEnableAspHtmlFallBack(FALSE),
	m_fEnableTypelibCache(TRUE),
	m_fEnableChunkedEncoding(TRUE),  // UNDONE: temp.
	m_fDupIISLogToNTLog(FALSE),
	m_dwRequestQueueMax(500),        // default limit on # of requests
	m_dwProcessorThreadMax(10),
	m_fThreadGateEnabled(FALSE),
	m_dwThreadGateTimeSlice(1000),
	m_dwThreadGateSleepDelay(100),
	m_dwThreadGateSleepMax(50),
	m_dwThreadGateLoadLow(75),
	m_dwThreadGateLoadHigh(90),
    m_dwPersistTemplateMaxFiles(1000),
    m_pszPersistTemplateDir(NULL)
	{
	OSVERSIONINFO osv;
	SYSTEM_INFO	si;
	BOOL fT;
	
	// Check the OS we are running on
	osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
	fT = GetVersionEx( &osv );
	Assert( fT );
	m_fWinNT = ( osv.dwPlatformId == VER_PLATFORM_WIN32_NT );

	// Find out how many processors are on this machine
	GetSystemInfo(&si);
	m_dwNumberOfProcessors = si.dwNumberOfProcessors;
	if (m_dwNumberOfProcessors <= 0)
		{
		m_dwNumberOfProcessors = 1;		// Just in case!
		}
	}

/*===================================================================
Cglob::SetGlobValue

Set global values.

in:
	int 	index		the index in the propinfo[]
	BYTE*	pData		lp to the Data being copied/assigned in the glob.

returns:
	BOOL	TRUE/FALSE

Side effects:
	Free old string memory and allocate new memory for string.
===================================================================*/
HRESULT	CGlob::SetGlobValue(unsigned int iValue, BYTE *pData)
{
	Assert((iValue < IGlob_MAX) && (pData != NULL));
	
	switch(iValue) {
		case IGlob_LogErrorRequests:
			InterlockedExchange((LPLONG)&m_fLogErrorRequests, *(LONG *)pData);
			break;

		case IGlob_ScriptFileCacheSize:
			InterlockedExchange((LPLONG)&m_dwScriptFileCacheSize, *(LONG *)pData);
			break;
			
		case IGlob_ScriptEngineCacheMax:
			InterlockedExchange((LPLONG)&m_dwScriptEngineCacheMax, *(LONG *)pData);
			break;

		case IGlob_ExceptionCatchEnable:
			InterlockedExchange((LPLONG)&m_fExceptionCatchEnable, *(LONG *)pData);
			break;

		case IGlob_TrackThreadingModel:
			InterlockedExchange((LPLONG)&m_fTrackThreadingModel, *(LONG *)pData);
			break;
			
		case IGlob_AllowOutOfProcCmpnts:
			InterlockedExchange((LPLONG)&m_fAllowOutOfProcCmpnts, *(LONG *)pData);
			break;

        case IGlob_EnableAspHtmlFallback:
			InterlockedExchange((LPLONG)&m_fEnableAspHtmlFallBack, *(LONG *)pData);
            break;
            
        case IGlob_EnableChunkedEncoding:
			InterlockedExchange((LPLONG)&m_fEnableChunkedEncoding, *(LONG *)pData);
            break;
            
        case IGlob_EnableTypelibCache:
			InterlockedExchange((LPLONG)&m_fEnableTypelibCache, *(LONG *)pData);
            break;
            
        case IGlob_ErrorsToNtLog:
			InterlockedExchange((LPLONG)&m_fDupIISLogToNTLog, *(LONG *)pData);
            break;
            
        case IGlob_ProcessorThreadMax:
			InterlockedExchange((LPLONG)&m_dwProcessorThreadMax, *(LONG *)pData);
            break;
            
        case IGlob_RequestQueueMax:
			InterlockedExchange((LPLONG)&m_dwRequestQueueMax, *(LONG *)pData);
            break;
            
        case IGlob_ThreadGateEnabled:
			InterlockedExchange((LPLONG)&m_fThreadGateEnabled, *(LONG *)pData);
            break;
            
        case IGlob_ThreadGateTimeSlice:
			InterlockedExchange((LPLONG)&m_dwThreadGateTimeSlice, *(LONG *)pData);
            break;
            
        case IGlob_ThreadGateSleepDelay:
			InterlockedExchange((LPLONG)&m_dwThreadGateSleepDelay, *(LONG *)pData);
            break;
            
        case IGlob_ThreadGateSleepMax:
			InterlockedExchange((LPLONG)&m_dwThreadGateSleepMax, *(LONG *)pData);
            break;
            
        case IGlob_ThreadGateLoadLow:
			InterlockedExchange((LPLONG)&m_dwThreadGateLoadLow, *(LONG *)pData);
            break;
            
        case IGlob_ThreadGateLoadHigh:
			InterlockedExchange((LPLONG)&m_dwThreadGateLoadHigh, *(LONG *)pData);
            break;
			
        case IGlob_PersistTemplateMaxFiles:
			InterlockedExchange((LPLONG)&m_dwPersistTemplateMaxFiles, *(LONG *)pData);
            break;
			
		case IGlob_PersistTemplateDir:
			GlobStringUseLock();
			if (m_pszPersistTemplateDir != NULL) {
				GlobalFree(m_pszPersistTemplateDir);
			}
			m_pszPersistTemplateDir = *(LPSTR *)pData;
			GlobStringUseUnLock();
			break;

		default:
			break;
	}

	return S_OK;
}

/*===================================================================
HRESULT	CGlob::GlobInit

Get all interesting global values (mostly from registry)

Returns:
	HRESULT - S_OK on success
	
Side effects:
	fills in glob.  May be slow
===================================================================*/
HRESULT CGlob::GlobInit(void)
	{
	HRESULT hr = S_OK;

	m_fInited = FALSE;
	
	ErrInitCriticalSection(&m_cs, hr);
	if (FAILED(hr))
		return(hr);

    hr = CFTMImplementation::Init();
    if (FAILED(hr))
        return(hr);
        
	hr = MDInit();
	if (FAILED(hr))
		return hr;

	// Disable caching in Win95
	// Registry get read only once in the Init time in Win95.
	// So, set those caching related values here.
	if(!m_fWinNT)
		{
		m_dwScriptFileCacheSize 	= 0;
		m_dwScriptEngineCacheMax	= 0;
		}

	//Finish loading, any registry change from this moment requires Admin Configurable(TRUE) to take
	//affect.  Other registry changes need to have IIS be stopped and restarted.
	m_fInited = TRUE;
	m_fNeedUpdate = FALSE;

	return(hr);
	}

/*===================================================================
GlobUnInit

Free all GlobalString Values.

Returns:
	HRESULT - S_OK on success
	
Side effects:
	memory freed.
===================================================================*/
HRESULT CGlob::GlobUnInit(void)
	{
	HRESULT hr = S_OK;

	MDUnInit();
	
    CFTMImplementation::UnInit();
        
	DeleteCriticalSection(&m_cs);

	return(hr);
	}

static HRESULT GetMetabaseIF(IMSAdminBase **hMetabase)
{
	IClassFactory 					*pcsfFactory = NULL;
    HRESULT                         hr;

	hr = CoGetClassObject(
			CLSID_MSAdminBase,
			CLSCTX_SERVER,
			NULL,
			IID_IClassFactory,
			(void **)&pcsfFactory);

	if (FAILED(hr)) {
        DBGPRINTF((DBG_CONTEXT,"MDInit: CoGetClassObject failed with %x\n",hr));
        return hr;
    }

	hr = pcsfFactory->CreateInstance(
			NULL,
			IID_IMSAdminBase,
			(void **) hMetabase);

	pcsfFactory->Release();
	
	if (FAILED(hr)) {
        DBGPRINTF((DBG_CONTEXT,"MDInit: CreateInstance failed with %x\n",hr));
		goto LExit;
    }
		
	Assert(*hMetabase != NULL);
	if (FAILED(hr))
		{
		(*hMetabase)->Release();
		(*hMetabase) = NULL;
		goto LExit;
		}
LExit:
    return(hr);
}

/*==================================================================
CGlob::MDInit

1. Create Metabase interface.
2. Load Glob configuration Settings from Metabase
2. Register SinkNotify() callback function through Metabase connectionpoint interface.

Returns:
	HRESULT	- S_OK on success

Side effects: Register SinkNotify().
===================================================================*/
HRESULT CGlob::MDInit(void)
{
	HRESULT 						hr = S_OK;
	IConnectionPointContainer		*pConnPointContainer = NULL;
	IConnectionPoint				*pConnPoint = NULL;

    if (FAILED(hr = GetMetabaseIF(&m_pMetabase))) {
        goto LExit;
    }

	m_pMetabaseSink = new CMDGlobConfigSink();
	if (!m_pMetabaseSink)
	    return E_OUTOFMEMORY;
	    
	m_dwMDSinkCookie = 0;

	// Init the Glob structure with defaults.  The metabase will actually be read later
	hr = SetConfigToDefaults(NULL, TRUE);
	if (SUCCEEDED(hr)) {
		// Advise Metabase about SinkNotify().
		hr = m_pMetabase->QueryInterface(IID_IConnectionPointContainer, (void **)&pConnPointContainer);
		if (pConnPointContainer != NULL)
			{
			//Find the requested Connection Point.  This AddRef's the return pointer.
			hr = pConnPointContainer->FindConnectionPoint(IID_IMSAdminBaseSink, &pConnPoint);
			pConnPointContainer->Release();

			if (pConnPoint != NULL)
				{
				hr = pConnPoint->Advise((IUnknown *)m_pMetabaseSink, &m_dwMDSinkCookie);
				pConnPoint->Release();
				}
			}
	} else {
        DBGPRINTF((DBG_CONTEXT,"MDInit: SetConfigToDefaults failed with %x\n",hr));
    }
		
	if (FAILED(hr))	//Advise failed
		{
        DBGPRINTF((DBG_CONTEXT,"MDInit: Advise failed with %x\n",hr));
		m_pMetabase->Release();
		m_pMetabase = NULL;
		}

LExit:

	return hr;
}

/*==================================================================
CGlob::MDUnInit

1. UnRegister SinkNofity() from Metabase connectionpoint interface.
2. delete m_pMetabaseSink.
3. release interface pointer of m_pMetabase.

Returns:
	HRESULT	- S_OK on success

Side effects: release interface pointer of m_pMetabase
===================================================================*/
HRESULT CGlob::MDUnInit(void)
{
	HRESULT 						hr 						= S_OK;
	IConnectionPointContainer		*pConnPointContainer	= NULL;
	IConnectionPoint				*pConnPoint 			= NULL;
	IClassFactory 					*pcsfFactory            = NULL;

    if (m_pMetabase != NULL)
		{
		//Advise Metabase about SinkNotify().
		hr = m_pMetabase->QueryInterface(IID_IConnectionPointContainer, (void **)&pConnPointContainer);
		if (pConnPointContainer != NULL)
			{
			//Find the requested Connection Point.  This AddRef's the return pointer.
			hr = pConnPointContainer->FindConnectionPoint(IID_IMSAdminBaseSink, &pConnPoint);
			pConnPointContainer->Release();
			if (pConnPoint != NULL)
				{
				hr = pConnPoint->Unadvise(m_dwMDSinkCookie);
				if (FAILED(hr))
					{
                    DBGPRINTF((DBG_CONTEXT, "UnAdvise Glob Config Change Notify failed.\n"));
					}
				pConnPoint->Release();
				m_dwMDSinkCookie = 0;
				}
			}
		m_pMetabase->Release();
		m_pMetabase = NULL;
		}

	if (m_pMetabaseSink)
		m_pMetabaseSink->Release();

	return hr;
}

/*==================================================================
CMDAppConfigSink::QueryInterface

Returns:
	HRESULT	- S_OK on success

Side effects:
===================================================================*/
STDMETHODIMP CMDAppConfigSink::QueryInterface(REFIID iid, void **ppv)
	{
	*ppv = 0;
	
	if (iid == IID_IUnknown || iid == IID_IMSAdminBaseSink)
		*ppv = (IMSAdminBaseSink *)this;
	else
		return ResultFromScode(E_NOINTERFACE);

	((IUnknown *)*ppv)->AddRef();
	return S_OK;
	}

/*==================================================================
CMDAppConfigSink::AddRef

Returns:
	ULONG	- The new ref counter of object

Side effects:
===================================================================*/
STDMETHODIMP_(ULONG) CMDAppConfigSink::AddRef(void)
	{
	LONG  cRefs = InterlockedIncrement((long *)&m_cRef);
	return cRefs;
	}

/*==================================================================
CMDGlobConfigSink::Release

Returns:
	ULONG	- The new ref counter of object

Side effects: Delete object if ref counter is zero.
===================================================================*/
STDMETHODIMP_(ULONG) CMDAppConfigSink::Release(void)
	{
	LONG cRefs = InterlockedDecrement((long *)&m_cRef);
	if (cRefs == 0)
		{
		delete this;
		}
	return cRefs;
	}

/*==================================================================
CMDAppConfigSink::SinkNotify

Returns:
	HRESULT	- S_OK on success

Side effects: Set fNeedUpdate to TRUE, and glob data will gets update next time a request coming in.
===================================================================*/
STDMETHODIMP	CMDAppConfigSink::SinkNotify(
				DWORD	dwMDNumElements,
				MD_CHANGE_OBJECT_W	__RPC_FAR	pcoChangeList[])
{
    if (IsShutDownInProgress())
        return S_OK;

	UINT	iEventNum = 0;
	DWORD	iDataIDNum = 0;
	WCHAR 	*wszMDPath = NULL;
    BOOL    fWszMDPathAllocd = FALSE;
	UINT	cSize = 0;

#if UNICODE
    wszMDPath = m_pAppConfig->SzMDPath();
    cSize = wcslen(wszMDPath);
	// Tag on a trailing '/'because the directories in pszMDPath will have one
	if (wszMDPath[cSize - 1] != L'/') {
        wszMDPath = new WCHAR[cSize+2];
        if (wszMDPath == NULL) {
            return E_OUTOFMEMORY;
        }
        fWszMDPathAllocd = TRUE;
        wcscpy(wszMDPath, m_pAppConfig->SzMDPath());
		wszMDPath[cSize] = L'/';
	    wszMDPath[cSize + 1] = 0;
    }
#else
	CHAR * 	szMDPathT = m_pAppConfig->SzMDPath();

	Assert(szMDPathT != NULL);
	DWORD cbStr = strlen(szMDPathT);
	
	wszMDPath = new WCHAR[cbStr + 2]; // Allow for adding trailing '/' and '\0'
	if (wszMDPath == NULL) {
		return E_OUTOFMEMORY;
    }
    fWszMDPathAllocd = TRUE;
	cSize = MultiByteToWideChar(CP_ACP, 0, szMDPathT, cbStr, wszMDPath, cbStr + 2);
	if (cSize == 0) {
	    return HRESULT_FROM_WIN32(GetLastError());
    }

	wszMDPath[cSize] = 0;
	wszMDPath[cSize + 1] = 0;

	// Tag on a trailing '/'because the directories in pszMDPath will have one
	if (wszMDPath[cSize - 1] != L'/') {
		wszMDPath[cSize] = L'/';
    }
#endif

	for (iEventNum = 0; iEventNum < dwMDNumElements; iEventNum++)
		{
		DWORD dwMDChangeType = pcoChangeList[iEventNum].dwMDChangeType;
		if ((dwMDChangeType == MD_CHANGE_TYPE_DELETE_OBJECT) || (dwMDChangeType == MD_CHANGE_TYPE_RENAME_OBJECT))
		    {
		    if (wcsicmp(wszMDPath, (LPWSTR)pcoChangeList[iEventNum].pszMDPath) == 0)
		        {
                m_pAppConfig->m_pAppln->Restart(TRUE);
		        }
		    }
		if (0 == wcsnicmp(wszMDPath, (LPWSTR)pcoChangeList[iEventNum].pszMDPath, cSize + 1))
			{
			for (iDataIDNum = 0; iDataIDNum < pcoChangeList[iEventNum].dwMDNumDataIDs; iDataIDNum++)
				{
				if (pcoChangeList[iEventNum].pdwMDDataIDs[iDataIDNum] == MD_VR_PATH)
					{
				    if (wcsicmp(wszMDPath, (LPWSTR)pcoChangeList[iEventNum].pszMDPath) == 0)
				        {
                        m_pAppConfig->m_pAppln->Restart(TRUE);
				        }
					}

				if (pcoChangeList[iEventNum].pdwMDDataIDs[iDataIDNum] >= ASP_MD_SERVER_BASE
					&& pcoChangeList[iEventNum].pdwMDDataIDs[iDataIDNum] <= MD_ASP_ID_LAST)
					{
                    if (m_pAppConfig->fNeedUpdate() == FALSE)
					    m_pAppConfig->NotifyNeedUpdate();
                    if ((pcoChangeList[iEventNum].pdwMDDataIDs[iDataIDNum] == MD_ASP_ENABLEAPPLICATIONRESTART) 
                        && (wcsicmp(wszMDPath, (LPWSTR)pcoChangeList[iEventNum].pszMDPath) == 0))
                        {
                        m_pAppConfig->NotifyRestartEnabledUpdated();
					    goto LExit;
                        }
					}
				}
			}
		}

LExit:
    if (fWszMDPathAllocd)
	    delete [] wszMDPath;
	return S_OK;
}
/*===================================================================
CAppConfig::CAppConfig

Returns:
	Nothing

Side Effects:
	None.
===================================================================*/
CAppConfig::CAppConfig()
	: 
    m_dwScriptTimeout(45),
    m_dwSessionTimeout(10),
    m_dwQueueTimeout(0xffffffff),
    m_fScriptErrorsSentToBrowser(TRUE),
    m_fBufferingOn(TRUE),
    m_fEnableParentPaths(TRUE),
    m_fAllowSessionState(TRUE),
    m_fAllowOutOfProcCmpnts(FALSE),
    m_fAllowDebugging(FALSE),
    m_fAllowClientDebug(FALSE),
    m_fExecuteInMTA(FALSE),
    m_fEnableApplicationRestart(TRUE),
    m_dwQueueConnectionTestTime(3),
    m_dwSessionMax(0xffffffff),
	m_fInited(FALSE),
    m_fRestartEnabledUpdated(FALSE),
	m_uCodePage(CP_ACP),
	m_fIsValidProglangCLSID(FALSE),
    m_pMetabase(NULL),
    m_pMetabaseSink(NULL),
    m_fIsValidPartitionGUID(FALSE),
    m_fSxsEnabled(FALSE),
    m_fTrackerEnabled(FALSE),
    m_fUsePartition(FALSE)
{
    m_uCodePage = GetACP();

	for (UINT cMsg = 0; cMsg < APP_CONFIG_MESSAGEMAX; cMsg++)
		m_szString[cMsg] = 0;
}

/*===================================================================
CAppConfig::Init

Init the CAppConfig.	Only called once.

in:
	CAppln	pAppln	The backpointer to Application.

Side effects:
	Allocate CMDAppConfigSink. Register metabase sink. etc.
===================================================================*/
HRESULT CAppConfig::Init
(
CIsapiReqInfo   *pIReq,
CAppln *pAppln
)
{

	HRESULT 						hr = S_OK;
	IConnectionPointContainer		*pConnPointContainer = NULL;
	IConnectionPoint				*pConnPoint = NULL;
	IClassFactory 					*pcsfFactory = NULL;

    if (FAILED(hr = GetMetabaseIF(&m_pMetabase))) {
        return hr;
    }

	m_pMetabaseSink = new CMDAppConfigSink(this);
	if (!m_pMetabaseSink)
		return E_OUTOFMEMORY;

	m_pAppln = pAppln;
	m_dwMDSinkCookie = 0;

	// Read info into Glob structure
	hr = ReadConfigFromMD(pIReq, this, FALSE);
    
    if (SUCCEEDED(hr)) {
        hr = g_ScriptManager.ProgLangIdOfLangName((LPCSTR)m_szString[IAppMsg_SCRIPTLANGUAGE],
		    								      &m_DefaultScriptEngineProgID);
		// BUG 295239
		// If it failed, we still should create an application because the error message
		// "New Application Failed" is too confusing for the user.  This is not a fatal error
		// because it is still (theoretically) possible to run scripts (those with explicit language
		// attributes)  Therefore, we reset the hr to S_OK.

		m_fIsValidProglangCLSID = SUCCEEDED(hr);
		hr = S_OK;
    }

    if (SUCCEEDED(hr) && m_szString[IAppMsg_PARTITIONGUID]) {
        BSTR    pbstrPartitionGUID = NULL;
        hr = SysAllocStringFromSz(m_szString[IAppMsg_PARTITIONGUID], 0, &pbstrPartitionGUID, CP_ACP);
        if (FAILED(hr)) {
            Assert(0);
            hr = S_OK;
        }
        else {
            hr = CLSIDFromString(pbstrPartitionGUID, &m_PartitionGUID);
		    m_fIsValidPartitionGUID = SUCCEEDED(hr);
		    hr = S_OK;
        }
        if (pbstrPartitionGUID)
            SysFreeString(pbstrPartitionGUID);
    }

	//Advise Metabase about SinkNotify().
	hr = m_pMetabase->QueryInterface(IID_IConnectionPointContainer, (void **)&pConnPointContainer);
	if (pConnPointContainer != NULL)
		{
		//Find the requested Connection Point.  This AddRef's the return pointer.
		hr = pConnPointContainer->FindConnectionPoint(IID_IMSAdminBaseSink, &pConnPoint);
		pConnPointContainer->Release();

		if (pConnPoint != NULL)
			{
			hr = pConnPoint->Advise((IUnknown *)m_pMetabaseSink, &m_dwMDSinkCookie);
			pConnPoint->Release();
			}
		}

    if (FAILED(hr)) {
        m_pMetabase->Release();
        m_pMetabase = NULL;
    }

	m_fInited = TRUE;
	m_fNeedUpdate = FALSE;

	return hr;
}

/*===================================================================
CAppConfig::UnInit

UnInit the CAppConfig.	Only called once.

in:
	None.

Side effects:
	DeAllocate CMDAppConfigSink. disconnect metabase sink. etc.
===================================================================*/
HRESULT CAppConfig::UnInit(void)
{
	HRESULT 						hr 						= S_OK;
	IConnectionPointContainer		*pConnPointContainer	= NULL;
	IConnectionPoint				*pConnPoint 			= NULL;
    CHAR                            szErr[256];

    if (m_pMetabase) {

        //Advise Metabase about SinkNotify().
	    hr = m_pMetabase->QueryInterface(IID_IConnectionPointContainer, (void **)&pConnPointContainer);
	    if (pConnPointContainer != NULL)
		    {
		    //Find the requested Connection Point.  This AddRef's the return pointer.
		    hr = pConnPointContainer->FindConnectionPoint(IID_IMSAdminBaseSink, &pConnPoint);

		    if (FAILED(hr))
		        {
                DBGPRINTF((DBG_CONTEXT, "FindConnectionPoint failed. hr = %08x\n", hr));
                }
            
		    pConnPointContainer->Release();
		    if (pConnPoint != NULL)
			    {
			    hr = pConnPoint->Unadvise(m_dwMDSinkCookie);
			    if (FAILED(hr))
				    {
				    DBGPRINTF((DBG_CONTEXT, "UnAdvise App Config Change Notify failed. hr = %08x\n", hr));
				    }
			    hr = S_OK; // benign failure if Advise was not called (happens with unknown script lang)
			    pConnPoint->Release();
			    m_dwMDSinkCookie = 0;
			    }
		    }
	    else
	        {
	        DBGPRINTF((DBG_CONTEXT, "QueryInterface failed. hr = %08x\n", hr));
	        }
        m_pMetabase->Release();
        m_pMetabase = NULL;
    }

    if (m_pMetabaseSink) {
        CoDisconnectObject(m_pMetabaseSink,0);
		m_pMetabaseSink->Release();
    }

	for (int iStr = 0; iStr < APP_CONFIG_MESSAGEMAX; iStr++)
		{
		if (m_szString[iStr] != NULL)
			{
			GlobalFree(m_szString[iStr]);
			m_szString[iStr] = NULL;
			}
		}

	return hr;
}

/*===================================================================
AppConfigUnInit

BUG 89144: Uninit AppConfig but do it from the MTA
When AppConfig is inited, it is done on a WAM thread.  WAM
threads are MTA threads.  At that time we register an event
sink to get Metabase change notifications.  Now, during shutdown,
we are running on an ASP worker thread, which is an STA thread.
That means we will get an RPC_E_WRONGTHREAD error shutting down.  The 
fix is to make the uninit call happen on an MTA thread.
This cover is used to do the work in the MTA.

in:
    pAppConfig

Side effects:
===================================================================*/
HRESULT AppConfigUnInit(void *pv1, void *pv2)
{
    Assert(pv1 != NULL);
    Assert(pv2 != NULL);

	HRESULT hr = static_cast<CAppConfig *>(pv1)->UnInit();
	SetEvent(reinterpret_cast<HANDLE>(pv2));
	return hr;
}


/*===================================================================
CAppConfig::szMDPath


in:
	None

returns:
	LPTSTR: ptr to szmetabsekey

Side effects:
	Get MetabaseKey
===================================================================*/
LPTSTR CAppConfig::SzMDPath()
{
	return m_pAppln->GetMetabaseKey();
}

/*===================================================================
CAppConfig::SetValue


in:
	int 	index		the index in the propinfo[]
	BYTE*	pData		lp to the Data being copied/assigned in the glob.

returns:
	BOOL	TRUE/FALSE

Side effects:
	Free old string memory and allocate new memory for string.
===================================================================*/
HRESULT CAppConfig::SetValue(unsigned int iValue, BYTE *pData)
{
    HRESULT hr = S_OK;

	Assert((iValue < IApp_MAX) && (pData != NULL));
	
	switch(iValue) {
        case IApp_CodePage: {
            LONG lCodePage = *(LONG *)pData;
            if (lCodePage == 0) 
                lCodePage = GetACP();
			InterlockedExchange((LPLONG)&m_uCodePage, lCodePage);
			break;
        }
			
		case IApp_BufferingOn:
			InterlockedExchange((LPLONG)&m_fBufferingOn, *(LONG *)pData);
			break;

		case IApp_ScriptErrorsSenttoBrowser:
			InterlockedExchange((LPLONG)&m_fScriptErrorsSentToBrowser, *(LONG *)pData);
			break;
			
		case IApp_ScriptErrorMessage:
			GlobStringUseLock();
			if (m_szString[IAppMsg_SCRIPTERROR] != NULL) {
				GlobalFree(m_szString[IAppMsg_SCRIPTERROR]);
			}
			m_szString[IAppMsg_SCRIPTERROR] = *(LPSTR *)pData;
			GlobStringUseUnLock();
			break;

		case IApp_ScriptTimeout:
			InterlockedExchange((LPLONG)&m_dwScriptTimeout, *(LONG *)pData);
			break;
			
		case IApp_SessionTimeout:
			InterlockedExchange((LPLONG)&m_dwSessionTimeout, *(LONG *)pData);
			break;

		case IApp_QueueTimeout:
			InterlockedExchange((LPLONG)&m_dwQueueTimeout, *(LONG *)pData);
			break;

		case IApp_EnableParentPaths:
			InterlockedExchange((LPLONG)&m_fEnableParentPaths, !*(LONG *)pData);
			break;

		case IApp_AllowSessionState:
			InterlockedExchange((LPLONG)&m_fAllowSessionState, *(LONG *)pData);
			break;

		case IApp_ScriptLanguage:
			GlobStringUseLock();
			if (m_szString[IAppMsg_SCRIPTLANGUAGE] != NULL) {
				GlobalFree(m_szString[IAppMsg_SCRIPTLANGUAGE] );
            }
			m_szString[IAppMsg_SCRIPTLANGUAGE] = *(LPSTR *)pData;
			if (m_szString[IAppMsg_SCRIPTLANGUAGE] != NULL) {
				if('\0' == m_szString[IAppMsg_SCRIPTLANGUAGE][0]) { 
					MSG_Error("No Default Script Language specified, using VBScript as default.");
					GlobalFree(m_szString[IAppMsg_SCRIPTLANGUAGE] );
					m_szString[IAppMsg_SCRIPTLANGUAGE] = (LPSTR)GlobalAlloc(GPTR, 128);
					CchLoadStringOfId(IDS_SCRIPTLANGUAGE, (LPSTR)m_szString[IAppMsg_SCRIPTLANGUAGE], 128);
                }
            }
            hr = g_ScriptManager.ProgLangIdOfLangName((LPCSTR)m_szString[IAppMsg_SCRIPTLANGUAGE],
		   											      &m_DefaultScriptEngineProgID);
            GlobStringUseUnLock();
			break;

		case IApp_AllowClientDebug:
			InterlockedExchange((LPLONG)&m_fAllowClientDebug, *(LONG *)pData);
			break;

		case IApp_AllowDebugging:
			InterlockedExchange((LPLONG)&m_fAllowDebugging, *(LONG *)pData);
			break;

		case IApp_EnableApplicationRestart:
			InterlockedExchange((LPLONG)&m_fEnableApplicationRestart, *(LONG *)pData);
			break;

		case IApp_QueueConnectionTestTime:
			InterlockedExchange((LPLONG)&m_dwQueueConnectionTestTime, *(LONG *)pData);
			break;

		case IApp_SessionMax:
			InterlockedExchange((LPLONG)&m_dwSessionMax, *(LONG *)pData);
			break;

		case IApp_ExecuteInMTA:
			InterlockedExchange((LPLONG)&m_fExecuteInMTA, *(LONG *)pData);
			break;

		case IApp_LCID:
			InterlockedExchange((LPLONG)&m_uLCID, *(LONG *)pData);
			break;

        case IApp_KeepSessionIDSecure:
            InterlockedExchange((LPLONG)&m_fKeepSessionIDSecure, *(LONG *)pData);
            break;

        case IApp_ServiceFlags:
            InterlockedExchange((LPLONG)&m_fTrackerEnabled, !!((*(LONG *)pData) & IFlag_SF_TrackerEnabled));
            InterlockedExchange((LPLONG)&m_fSxsEnabled,     !!((*(LONG *)pData) & IFlag_SF_SxsEnabled));
            InterlockedExchange((LPLONG)&m_fUsePartition,   !!((*(LONG *)pData) & IFlag_SF_UsePartition));
            break;

        case IApp_PartitionGUID:
			GlobStringUseLock();
			if (m_szString[IAppMsg_PARTITIONGUID] != NULL) {
				GlobalFree(m_szString[IAppMsg_PARTITIONGUID] );
            }
			m_szString[IAppMsg_PARTITIONGUID] = *(LPSTR *)pData;
			if (m_szString[IAppMsg_PARTITIONGUID] != NULL) {
				if('\0' == m_szString[IAppMsg_PARTITIONGUID][0]) {
					GlobalFree(m_szString[IAppMsg_PARTITIONGUID] );
                    m_szString[IAppMsg_PARTITIONGUID] = NULL;
                }
            }
			GlobStringUseUnLock();
            break;

        case IApp_SxsName:
			GlobStringUseLock();
			if (m_szString[IAppMsg_SXSNAME] != NULL) {
				GlobalFree(m_szString[IAppMsg_SXSNAME] );
            }
			m_szString[IAppMsg_SXSNAME] = *(LPSTR *)pData;
			if (m_szString[IAppMsg_SXSNAME] != NULL) {
				if('\0' == m_szString[IAppMsg_SXSNAME][0]) {
					GlobalFree(m_szString[IAppMsg_SXSNAME] );
                    m_szString[IAppMsg_SXSNAME] = NULL;
                }
            }
			GlobStringUseUnLock();
            
		default:
			break;
	}

	return hr;
}

/*===================================================================
CAppConfig::Update
Update settings in CAppConfig.

in:

returns:
	HRESULT

Side effects:
	Update CAppConfig settings.
===================================================================*/
HRESULT CAppConfig::Update(CIsapiReqInfo    *pIReq)
{
	Glob(Lock);
	if (m_fNeedUpdate == TRUE)
		{
		InterlockedExchange((LPLONG)&m_fNeedUpdate, 0);
        m_fRestartEnabledUpdated = FALSE;
		}
	else
		{
		Glob(UnLock);
		return S_OK;
		}
	Glob(UnLock);
	return ReadConfigFromMD(pIReq, this, FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\hashing.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Link list and Hash table

File: Hashing.cpp

Owner: PramodD

This is the Link list and Hash table source file.
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "memchk.h"


/*===================================================================
::DefaultHash

this is a hash algorithm that is highly recommended by Aho,
Seth, and Ulman from the dragon book. (THE compiler reference)

Parameters:
    BYTE *  pbKey
    int     cbKey

Returns:
    Hashed DWORD value.
===================================================================*/

DWORD DefaultHash(const BYTE *pbKey, int cbKey)
{
    const unsigned WORD_BITS            = CHAR_BIT * sizeof(unsigned);
    const unsigned SEVENTY_FIVE_PERCENT = WORD_BITS * 3 / 4;
    const unsigned ONE_EIGHTH           = WORD_BITS / 8;
    const unsigned HIGH_BITS            = ~(unsigned(~0) >> ONE_EIGHTH);

    register unsigned uT, uResult = 0;
    register const BYTE *pb = pbKey;

    while (cbKey-- > 0)
    {
        uResult = (uResult << ONE_EIGHTH) + *pb++;
        if ((uT = uResult & HIGH_BITS) != 0)
            uResult = (uResult ^ (uT >> SEVENTY_FIVE_PERCENT)) & ~HIGH_BITS;
    }

    return uResult;
}



/*===================================================================
::UnicodeUpcaseHash

This is Aho, Seth, and Ulman's hash algorithm adapted for wide
character strings.  Their algorithm was not designed for cases
where every other character is 0 (which is how a unicode string
looks if you pretend it's ascii)  Therefore, performance
qualities are unknown for that case.

NOTE: for real Unicode, (not unicode that is merely ANSI converted)
      I have no idea how good a distribution this algorithm will
      produce. (since we are shifting in values > 8 bits now)

Parameters:
    BYTE *  pbKey
    int     cbKey

Returns:
    Hashed DWORD value.
===================================================================*/

#define toupper(x)  WORD(CharUpper(LPSTR(WORD(x))))

DWORD UnicodeUpcaseHash(const BYTE *pbKey, int cbKey)
{
    // PERF hash on last CCH_HASH chars only
    const unsigned WORD_BITS            = CHAR_BIT * sizeof(unsigned);
    const unsigned SEVENTY_FIVE_PERCENT = WORD_BITS * 3 / 4;
    const unsigned ONE_EIGHTH           = WORD_BITS / 8;
    const unsigned HIGH_BITS            = ~(unsigned(~0) >> ONE_EIGHTH);
    const unsigned CCH_HASH             = 8;

    register unsigned uT, uResult = 0;

    Assert ((cbKey & 1) == 0);      // cbKey better be even!
    int cwKey = unsigned(cbKey) >> 1;

    register const WORD *pw = reinterpret_cast<const WORD *>(pbKey) + cwKey;

    cwKey = min(cwKey, CCH_HASH);

    if (FIsWinNT())
    {
        WCHAR awcTemp[CCH_HASH];

        // copy last cwKey WCHARs of pbKey to last cwKey WCHARs of awcTemp
        wcsncpy(awcTemp + CCH_HASH - cwKey, pw - cwKey, cwKey);
        CharUpperBuffW(awcTemp + CCH_HASH - cwKey, cwKey);

        pw = awcTemp + CCH_HASH;

        while (cwKey-- > 0)
        {
            uResult = (uResult << ONE_EIGHTH) + *--pw;
            if ((uT = uResult & HIGH_BITS) != 0)
                uResult = (uResult ^ (uT >> SEVENTY_FIVE_PERCENT)) & ~HIGH_BITS;
        }
    }
    else
    {
        // CharUpperBuffW does nothing on Windows 95, so we use CharUpperBuffA
        // instead.  Chances are that the top eight bits are zero anyway,
        // and even if they aren't, this will still give us a halfway-decent
        // distribution.

        CHAR achTemp[CCH_HASH];

        for (int i = 0;  i < cwKey;  ++i)
            achTemp[i] = (CHAR) *(pw - cwKey + i);
        CharUpperBuffA(achTemp, cwKey);

        while (cwKey-- > 0)
        {
            uResult = (uResult << ONE_EIGHTH) + achTemp[cwKey];
            if ((uT = uResult & HIGH_BITS) != 0)
                uResult = (uResult ^ (uT >> SEVENTY_FIVE_PERCENT)) & ~HIGH_BITS;
        }
    }

    return uResult;
}

DWORD MultiByteUpcaseHash(const BYTE *pbKey, int cbKey)
{
    // PERF hash on first CCH_HASH chars only
    const unsigned WORD_BITS            = CHAR_BIT * sizeof(unsigned);
    const unsigned SEVENTY_FIVE_PERCENT = WORD_BITS * 3 / 4;
    const unsigned ONE_EIGHTH           = WORD_BITS / 8;
    const unsigned HIGH_BITS            = ~(unsigned(~0) >> ONE_EIGHTH);
    const unsigned CCH_HASH             = 8;

    register unsigned uT, uResult = 0;

    unsigned char achTemp[CCH_HASH + 1];

    // For performance we only HASH on at most CCH_HASH characters.
    cbKey = min(cbKey, CCH_HASH);

    // Copy cbKey chacters into temporary buffer
    memcpy(achTemp, pbKey, cbKey);

    // Add terminating null character
    achTemp[cbKey] = 0;

    // Convert to upper case
    _mbsupr(achTemp);

    while (cbKey-- > 0)
    {
        uResult = (uResult << ONE_EIGHTH) + achTemp[cbKey];
        if ((uT = uResult & HIGH_BITS) != 0)
            uResult = (uResult ^ (uT >> SEVENTY_FIVE_PERCENT)) & ~HIGH_BITS;
    }

    return uResult;
}

/*===================================================================
::PtrHash

Hash function that returns the pointer itself as the
DWORD hash value


Parameters:
    BYTE *  pbKey
    int     cbKey (not used)

Returns:
    Hashed DWORD value.
===================================================================*/
DWORD PtrHash
(
const BYTE *pbKey,
int /* cbKey */
)
    {
    return *(reinterpret_cast<DWORD *>(&pbKey));
    }


/*===================================================================
CLSIDHash

CLSID hash. Uses xor of the first and last DWORD

Parameters:
    BYTE *  pbKey
    int     cbKey

Returns:
    Hashed DWORD value.
===================================================================*/
DWORD CLSIDHash
(
const BYTE *pbKey,
int cbKey
)
    {
    Assert(cbKey == 16);
    DWORD *pdwKey = (DWORD *)pbKey;
    return (pdwKey[0] ^ pdwKey[3]);
    }

/*===================================================================
CLinkElem::CLinkElem

The Constructor.

Parameters:
    NONE

Returns:
    NONE
===================================================================*/
CLinkElem::CLinkElem(void)
: m_pKey(NULL),
  m_cbKey(0),
  m_Info(0),
  m_pPrev(NULL),
  m_pNext(NULL)
{
}

/*===================================================================
HRESULT CLinkElem::Init

Initializes class members

Parameters:
    void *  pKey
    int     cbKey

Returns:
    S_OK     Success
    E_FAIL      Error
===================================================================*/
HRESULT CLinkElem::Init( void *pKey, int cbKey )
{
    m_pPrev = NULL;
    m_pNext = NULL;
    m_Info = 0;

    if ( pKey == NULL || cbKey == 0 )
        return E_FAIL;

    m_pKey = static_cast<BYTE *>(pKey);
    m_cbKey = (short)cbKey;

    return S_OK;
}

/*===================================================================
CHashTable::CHashTable

Constructor for CHashTable

Parameters:
    NONE

Returns:
    NONE
===================================================================*/
CHashTable::CHashTable( HashFunction pfnHash )
: m_fInited(FALSE),
  m_fBucketsAllocated(FALSE),
  m_pHead(NULL),
  m_pTail(NULL),
  m_rgpBuckets(NULL),
  m_pfnHash(pfnHash),
  m_cBuckets(0),
  m_Count(0)
{
}

/*===================================================================
CHashTable::~CHashTable

Destructor for CHashTable. Frees allocated bucket array.

Parameters:
    NONE

Returns:
    NONE
===================================================================*/
CHashTable::~CHashTable( void )
{
    if (m_fBucketsAllocated)
    {
        Assert(m_rgpBuckets);
        delete [] m_rgpBuckets;
    }
}

/*===================================================================
HRESULT CHashTable::UnInit

Frees allocated bucket array.

Parameters:
    NONE

Returns:
    S_OK     Always
===================================================================*/
HRESULT CHashTable::UnInit( void )
{
    if (m_fBucketsAllocated)
    {
        Assert(m_rgpBuckets);
        delete [] m_rgpBuckets;
        m_fBucketsAllocated = FALSE;
    }

    m_rgpBuckets = NULL;
    m_pHead      = NULL;
    m_pTail      = NULL;
    m_cBuckets   = 0;
    m_Count      = 0;
    m_fInited    = FALSE;

    return S_OK;
}

/*===================================================================
void CHashTable::AssertValid

Verify integrity of the data structure.

NOTE: This function does very deep integrity checks and thus is
      very slow.

Checks performed:

        verify that m_Count is valid
        verify that each element is in the right bucket
        verify prev, next links and info fields
===================================================================*/

#ifdef DBG
void CHashTable::AssertValid() const
{
    CLinkElem *pElem;       // pointer to current link element
    unsigned i;             // index into current bucket
    unsigned cItems = 0;    // actual number of items in the table

    Assert(m_fInited);

    if (m_Count == 0)
    {
        if (m_rgpBuckets)
        {
            BOOL fAllNulls = TRUE;
            // empty hash table - make sure that everything reflects this
            Assert(m_pHead == NULL);
            Assert (m_pTail == NULL);

            for (i = 0; i < m_cBuckets; i++)
            {
                if (m_rgpBuckets[i] != NULL)
                {
                    fAllNulls = FALSE;
                    break;
                }
            }

            Assert(fAllNulls);
        }
        return;
    }

    // If m_Count > 0
    Assert(m_pHead);
    Assert(m_pHead->m_pPrev == NULL);
    Assert(m_pTail != NULL && m_pTail->m_pNext == NULL);
    Assert(m_rgpBuckets);

    // Now verify each entry
    for (i = 0; i < m_cBuckets; ++i)
    {
        pElem = m_rgpBuckets[i];
        while (pElem != NULL)
        {
            // Verify hashing
            Assert ((m_pfnHash(pElem->m_pKey, pElem->m_cbKey) % m_cBuckets) == i);

            // Verify links
            if (pElem->m_pPrev)
                {
                Assert (pElem->m_pPrev->m_pNext == pElem);
                }
            else
                {
                Assert (m_pHead == pElem);
                }
                
            if (pElem->m_pNext)
                {
                Assert (pElem->m_pNext->m_pPrev == pElem);
                }
            else
                {
                Assert (m_pTail == pElem);
                }

            // Verify info fields
            Assert (pElem->m_Info >= 0);
            if (pElem != m_rgpBuckets[i])
                {
                Assert (pElem->m_Info == pElem->m_pPrev->m_Info - 1);
                }

            // Prepare for next iteration, stopping when m_Info is zero.
            ++cItems;
            if (pElem->m_Info == 0)
                break;

            pElem = pElem->m_pNext;
        }
    }

    // Verify count
    Assert (m_Count == cItems);
}
#endif



/*===================================================================
HRESULT CHashTable::Init

Initialize CHashTable by allocating the bucket array and
and initializing the bucket link lists.

Parameters:
    UINT    cBuckets    Number of buckets

Returns:
    HRESULT S_OK
            E_OUTOFMEMORY
===================================================================*/
HRESULT CHashTable::Init( UINT cBuckets )
{
    m_cBuckets = cBuckets;
    m_Count = 0;
    m_rgpBuckets = NULL;  // created on demand

    m_fInited = TRUE;
    return S_OK;
}

/*===================================================================
HRESULT CHashTable::ReInit

Reinitialize CHashTable by deleting everything in it.  - client
is responsible for making the hashtable empty first

Parameters:
    None

Returns:
    None
===================================================================*/
void CHashTable::ReInit()
{
    Assert( m_fInited );

    if (m_rgpBuckets)
        memset(m_rgpBuckets, 0, m_cBuckets * sizeof(CLinkElem *));

    m_Count = 0;
    m_pHead = NULL;
    m_pTail = NULL;
}

/*===================================================================
HRESULT CHashTable::AllocateBuckets()

Allocates hash table buckets on demand

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CHashTable::AllocateBuckets()
{
    Assert(m_rgpBuckets == NULL);
    Assert(m_fInited);
    Assert(m_cBuckets > 0);

    if (m_cBuckets <= PREALLOCATED_BUCKETS_MAX)
    {
        m_rgpBuckets = m_rgpBucketsBuffer;
    }
    else
    {
        m_rgpBuckets = new CLinkElem * [m_cBuckets];
        if (m_rgpBuckets == NULL)
            return E_OUTOFMEMORY;
        m_fBucketsAllocated = TRUE;
    }

    memset(m_rgpBuckets, 0, m_cBuckets * sizeof(CLinkElem *));
    return S_OK;
}

/*===================================================================
BOOL CHashTable::FIsEqual

compare two keys using their lengths and memcmp()

Parameters:
    const void *pKey1       first key
    int         cbKey1      length of the first key
    const void *pKey2       second key
    int         cbKey2      length of second key

Returns:
    Pointer to element added/found.
===================================================================*/
BOOL CHashTable::FIsEqual( const void * pKey1,
              int           cbKey1,
              const void *  pKey2,
              int           cbKey2 )
{
    if (cbKey1 != cbKey2)
        return FALSE;

    return memcmp(pKey1, pKey2, cbKey1) == 0;
}

#pragma optimize("g", off)
/*===================================================================
CHashTable::AddElem

Adds a CLinkElem to Hash table.
User is responsible for allocating the Element to be added.

Parameters:
    CLinkElem * pElem       Object to be added
    BOOL        fTestDups   Look for duplicates if true

Returns:
    Pointer to element added/found.
===================================================================*/
CLinkElem *CHashTable::AddElem( CLinkElem *pElem, BOOL fTestDups )
{
    if (m_rgpBuckets == NULL)
    {
        if (FAILED(AllocateBuckets()))
            return NULL;
    }

    if (pElem == NULL)
        return NULL;

    BOOL        fNew = TRUE;
    DWORD       iT = m_pfnHash( pElem->m_pKey, pElem->m_cbKey ) % m_cBuckets;
    CLinkElem * pT = m_rgpBuckets[iT];
    BOOL        fDebugTestDups = FALSE;

#ifdef DBG
    // In retail, if fTestDups is false, it means that
    // there shouldnt be any dups, so dont bother testing.  Under debug, however
    // we want to be able to assert that there isnt a dup (since there isnt supposed to be one).
    fDebugTestDups = !fTestDups;
#endif

    if (fTestDups || fDebugTestDups)
    {
        while ( pT && fNew )
        {
            if ( FIsEqual( pT->m_pKey, pT->m_cbKey, pElem->m_pKey, pElem->m_cbKey ) )
                fNew = FALSE;
            else if ( pT->m_Info > 0 )
                pT = pT->m_pNext;
            else
                break;
        }
    }

#ifdef DBG
    // If there arent supposed to be any dups, then make sure this element is seen as "new"
    if (fDebugTestDups)
        Assert(fNew);
#endif

#ifdef DUMP_HASHING_INFO
    static DWORD cAdds = 0;
    FILE *logfile = NULL;

    if (cAdds++ > 1000000 && m_Count > 100)
        {
        cAdds = 0;
        if (logfile = fopen("C:\\Temp\\hashdump.Log", "a+"))
            {
            DWORD cZero = 0;
            short iMax = 0;
            DWORD cGte3 = 0;
            DWORD cGte5 = 0;
            DWORD cGte10 = 0;

            fprintf(logfile, "Hash dump: # elements = %d\n", m_Count);
            for (UINT iBucket = 0; iBucket < m_cBuckets; iBucket++)
                {
                if (m_rgpBuckets[iBucket] == NULL)
                    cZero++;
                else
                    {
                    short Info = m_rgpBuckets[iBucket]->m_Info;
                    if (Info > iMax)
                        iMax = Info;
                    if (Info >= 10) cGte10++;
                    else if (Info >= 5) cGte5++;
                    else if (Info >= 3) cGte3++;
                    }
                }
            fprintf(logfile, "Max chain = %d, # 0 chains = %d, # >= 3 = %d, # >= 5 = %d, # >= 10 = %d\n",
                        (DWORD)iMax, cZero, cGte3, cGte5, cGte10);
            fflush(logfile);
            fclose(logfile);
            }
        }
#endif

    if ( fNew )
    {
        if ( pT )
        {
            // There are other elements in bucket
            pT = m_rgpBuckets[iT];
            m_rgpBuckets[iT] = pElem;
            pElem->m_Info = pT->m_Info + 1;
            pElem->m_pNext = pT;
            pElem->m_pPrev = pT->m_pPrev;
            pT->m_pPrev = pElem;
            if ( pElem->m_pPrev == NULL )
                m_pHead = pElem;
            else
                pElem->m_pPrev->m_pNext = pElem;
        }
        else
        {
            // This is the first element in the bucket
            m_rgpBuckets[iT] = pElem;
            pElem->m_pPrev = NULL;
            pElem->m_pNext = m_pHead;
            pElem->m_Info = 0;
            if ( m_pHead )
                m_pHead->m_pPrev = pElem;
            else
                m_pTail = pElem;
            m_pHead = pElem;
        }
        m_Count++;

        AssertValid();
        return pElem;
    }

    AssertValid();
    return pT;
}
#pragma optimize("g", on)

#pragma optimize("g", off)
/*===================================================================
CLinkElem * CHashTable::FindElem

Finds an object in the hash table based on the name.

Parameters:
    void *  pKey
    int     cbKey

Returns:
    Pointer to CLinkElem if found, otherwise NULL.
===================================================================*/
CLinkElem * CHashTable::FindElem( const void *pKey, int cbKey )
{
    AssertValid();

    if ( m_rgpBuckets == NULL || pKey == NULL )
        return NULL;

    DWORD       iT = m_pfnHash( static_cast<const BYTE *>(pKey), cbKey ) % m_cBuckets;
    CLinkElem * pT = m_rgpBuckets[iT];
    CLinkElem * pRet = NULL;

    while ( pT && pRet == NULL )
    {
        if ( FIsEqual( pT->m_pKey, pT->m_cbKey, pKey, cbKey ) )
            pRet = pT;
        else if ( pT->m_Info > 0 )
            pT = pT->m_pNext;
        else
            break;
    }

    return pRet;
}
#pragma optimize("g", on)

#pragma optimize("g", off)
/*===================================================================
CHashTable::DeleteElem

Removes a CLinkElem from Hash table.
The user should delete the freed link list element.

Parameters:
    void *  pbKey       key
    int     cbKey       length of key

Returns:
    Pointer to element removed, NULL if not found
===================================================================*/
CLinkElem * CHashTable::DeleteElem( const void *pKey, int cbKey )
{
    if ( m_rgpBuckets == NULL || pKey == NULL )
        return NULL;

    CLinkElem * pRet = NULL;
    DWORD       iT = m_pfnHash( static_cast<const BYTE *>(pKey), cbKey ) % m_cBuckets;
    CLinkElem * pT = m_rgpBuckets[iT];

    while ( pT && pRet == NULL )// Find it !
    {
        if ( FIsEqual( pT->m_pKey, pT->m_cbKey, pKey, cbKey ) )
            pRet = pT;
        else if ( pT->m_Info > 0 )
            pT = pT->m_pNext;
        else
            break;
    }
    if ( pRet )
    {
        pT = m_rgpBuckets[iT];

        if ( pRet == pT )
        {
            // Update bucket head
            if ( pRet->m_Info > 0 )
                m_rgpBuckets[iT] = pRet->m_pNext;
            else
                m_rgpBuckets[iT] = NULL;
        }
        // Update counts in bucket link list
        while ( pT != pRet )
        {
            pT->m_Info--;
            pT = pT->m_pNext;
        }
        // Update link list
        if ( pT = pRet->m_pPrev )
        {
            // Not the Head of the link list
            if ( pT->m_pNext = pRet->m_pNext )
                pT->m_pNext->m_pPrev = pT;
            else
                m_pTail = pT;
        }
        else
        {
            // Head of the link list
            if ( m_pHead = pRet->m_pNext )
                m_pHead->m_pPrev = NULL;
            else
                m_pTail = NULL;
        }
        m_Count--;
    }

    AssertValid();
    return pRet;
}
#pragma optimize("g", on)

/*===================================================================
CHashTable::RemoveElem

Removes a given CLinkElem from Hash table.
The user should delete the freed link list element.

Parameters:
    CLinkElem * pLE     Element to remove

Returns:
    Pointer to element removed
===================================================================*/
CLinkElem * CHashTable::RemoveElem( CLinkElem *pLE )
{
    CLinkElem *pLET;

    if ( m_rgpBuckets == NULL || pLE == NULL )
        return NULL;

    // Remove this item from the linked list
    pLET = pLE->m_pPrev;
    if (pLET)
        pLET->m_pNext = pLE->m_pNext;
    pLET = pLE->m_pNext;
    if (pLET)
        pLET->m_pPrev = pLE->m_pPrev;
    if (m_pHead == pLE)
        m_pHead = pLE->m_pNext;
    if (m_pTail == pLE)
        m_pTail = pLE->m_pPrev;

    /*
     * If this was the first item in a bucket, then fix up the bucket.
     * Otherwise, decrement the count of items in the bucket for each item
     * in the bucket prior to this item
     */
    if (pLE->m_pPrev == NULL || pLE->m_pPrev->m_Info == 0)
        {
        UINT iBucket;

        // This item is head of a bucket.  Need to find out which bucket!
        for (iBucket = 0; iBucket < m_cBuckets; iBucket++)
            if (m_rgpBuckets[iBucket] == pLE)
                break;
        Assert(iBucket < m_cBuckets && m_rgpBuckets[iBucket] == pLE);

        if (pLE->m_Info == 0)
            m_rgpBuckets[iBucket] = NULL;
        else
            m_rgpBuckets[iBucket] = pLE->m_pNext;
        }
    else
        {
        // This item is in the middle of a bucket chain.  Update counts in preceeding items
        pLET = pLE->m_pPrev;
        while (pLET != NULL && pLET->m_Info != 0)
            {
            pLET->m_Info--;
            pLET = pLET->m_pPrev;
            }
        }

    // Decrement count of total number of items
    m_Count--;

    AssertValid();
    return pLE;
}

/*===================================================================
CHashTableStr::CHashTableStr

Constructor for CHashTableStr

Parameters:
    NONE

Returns:
    NONE
===================================================================*/
CHashTableStr::CHashTableStr( HashFunction pfnHash )
    : CHashTable( pfnHash )
{
}

/*===================================================================
BOOL CHashTableStr::FIsEqual

compare two keys using their lengths, treating the keys
as Unicode and doing case insensitive compare.


Parameters:
    const void *pKey1       first key
    int         cbKey1      length of the first key
    const void *pKey2       second key
    int         cbKey2      length of second key

Returns:
    Pointer to element added/found.
===================================================================*/
BOOL CHashTableStr::FIsEqual( const void *  pKey1,
              int           cbKey1,
              const void *  pKey2,
              int           cbKey2 )
{
    if ( cbKey1 != cbKey2 )
        return FALSE;

    return _wcsnicmp(static_cast<const wchar_t *>(pKey1), static_cast<const wchar_t *>(pKey2), cbKey1) == 0;
}


/*===================================================================
CHashTableMBStr::CHashTableMBStr

Constructor for CHashTableMBStr

Parameters:
    NONE

Returns:
    NONE
===================================================================*/
CHashTableMBStr::CHashTableMBStr( HashFunction pfnHash )
    : CHashTable( pfnHash )
{
}

/*===================================================================
BOOL CHashTableMBStr::FIsEqual

compare two keys using their lengths, treating the keys
as multi-byte strings and doing case insensitive compare.


Parameters:
    const void *pKey1       first key
    int         cbKey1      length of the first key
    const void *pKey2       second key
    int         cbKey2      length of second key

Returns:
    Pointer to element added/found.
===================================================================*/
BOOL CHashTableMBStr::FIsEqual( const void *    pKey1,
              int           cbKey1,
              const void *  pKey2,
              int           cbKey2 )
{
    if ( cbKey1 != cbKey2 )
        return FALSE;

    return _mbsnicmp(static_cast<const unsigned char *>(pKey1), static_cast<const unsigned char *>(pKey2), cbKey1) == 0;
}

/*===================================================================
CHashTablePtr::CHashTablePtr

Constructor for CHashTableStr

Parameters:
    HashFunction pfnHash    has function (PtrHash is default)

Returns:
    NONE
===================================================================*/
CHashTablePtr::CHashTablePtr
(
    HashFunction pfnHash
)
    : CHashTable(pfnHash)
    {
    }

/*===================================================================
BOOL CHashTablePtr::FIsEqual

Compare two pointers.
Used by CHashTable to find elements

Parameters:
    const void *pKey1       first key
    int         cbKey1      length of the first key (unused)
    const void *pKey2       second key
    int         cbKey2      length of second key (unused)

Returns:
    BOOL (true when equal)
===================================================================*/
BOOL CHashTablePtr::FIsEqual
(
const void *pKey1,
int        /* cbKey1 */,
const void *pKey2,
int         /* cbKey2 */
)
    {
    return (pKey1 == pKey2);
    }

/*===================================================================
CHashTableCLSID::CHashTableCLSID

Constructor for CHashTableCLSID

Parameters:
    HashFunction pfnHash    has function (CLSIDHash is default)

Returns:
    NONE
===================================================================*/
CHashTableCLSID::CHashTableCLSID
(
    HashFunction pfnHash
)
    : CHashTable(pfnHash)
    {
    }

/*===================================================================
BOOL CHashTableCLSID::FIsEqual

Compare two CLSIDs.

Parameters:
    const void *pKey1       first key
    int         cbKey1      length of the first key
    const void *pKey2       second key
    int         cbKey2      length of second key

Returns:
    BOOL (true when equal)
===================================================================*/
BOOL CHashTableCLSID::FIsEqual
(
const void *pKey1,
int         cbKey1,
const void *pKey2,
int         cbKey2
)
    {
    Assert(cbKey1 == sizeof(CLSID) && cbKey2 == sizeof(CLSID));
    return IsEqualCLSID(*((CLSID *)pKey1), *((CLSID *)pKey2));
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\glob.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Globals

File: glob.h

Owner: AndrewS

Useful globals
===================================================================*/

#ifndef __Glob_H
#define __Glob_H

#include "util.h"
#include <schnlsp.h>
#include <wincrypt.h>
#include <iadmw.h>

extern "C" {

#define SECURITY_WIN32
#include <sspi.h>           // Security Support Provider APIs

}

class CMDGlobConfigSink : public IMSAdminBaseSinkW
        {
        private:
        INT                     m_cRef;
        public:

        CMDGlobConfigSink ()                    {m_cRef = 1;};

        HRESULT STDMETHODCALLTYPE       QueryInterface(REFIID riid, void **ppv);
        ULONG   STDMETHODCALLTYPE       AddRef(void);
        ULONG   STDMETHODCALLTYPE       Release(void);

        HRESULT STDMETHODCALLTYPE       SinkNotify(
                        DWORD   dwMDNumElements,
                        MD_CHANGE_OBJECT        __RPC_FAR       pcoChangeList[]);

        HRESULT STDMETHODCALLTYPE ShutdownNotify( void)
        {
            return HRESULT_FROM_WIN32(ERROR_NOT_SUPPORTED);
        }

        };
#define IGlob_LogErrorRequests                                  0x0
#define IGlob_ScriptFileCacheSize                               0x1
#define IGlob_ScriptEngineCacheMax                              0x2
//#define IGlob_MemFreeFactor                                   0x3
//#define IGlob_MinUsedBlocks                                   0x4
//#define IGlob_StartConnectionPool                             0x5
#define IGlob_ExceptionCatchEnable                              0x3
#define IGlob_TrackThreadingModel                               0x4
#define IGlob_AllowOutOfProcCmpnts                              0x5
// IIS5.0
#define IGlob_EnableAspHtmlFallback                             0x6
#define IGlob_EnableChunkedEncoding                             0x7
#define IGlob_EnableTypelibCache                                0x8
#define IGlob_ErrorsToNtLog                                     0x9
#define IGlob_ProcessorThreadMax                                0xa
#define IGlob_RequestQueueMax                                   0xb
#define IGlob_ThreadGateEnabled                                 0xc
#define IGlob_ThreadGateTimeSlice                               0xd
#define IGlob_ThreadGateSleepDelay                              0xe
#define IGlob_ThreadGateSleepMax                                0xf
#define IGlob_ThreadGateLoadLow                                 0x10
#define IGlob_ThreadGateLoadHigh                                0x11
#define IGlob_PersistTemplateMaxFiles                           0x12
#define IGlob_PersistTemplateDir                                0x13
#define IGlob_MAX                                               0x14

//forward declaration
class CAppConfig;
//      Glob data object
class CGlob
        {
private:
        // Friends that can access the private data, they are the functions setting the global data.
        friend          HRESULT CacheStdTypeInfos();
        friend          HRESULT ReadConfigFromMD(CIsapiReqInfo  *pIReq, CAppConfig *pAppConfig, BOOL fLoadGlob);
        friend          HRESULT SetConfigToDefaults(CAppConfig *pAppConfig, BOOL fLoadGlob);

        //Private Data
        ITypeLib                        *m_pITypeLibDenali;     // Denali's type library
        ITypeLib                        *m_pITypeLibTxn;        // Denali's type library
        BOOL                            m_fWinNT;               // TRUE if this is Windows NT; false otherwise
        DWORD                           m_dwNumberOfProcessors;
        BOOL                            m_fInited;
        BOOL                            m_fMDRead;				// Has Metadata been read at least once
        BOOL                            m_fNeedUpdate;          // FALSE, needs reload config data from metabase

        // Metadata configuration settings per dll
        DWORD                           m_dwScriptEngineCacheMax;
        DWORD                           m_dwScriptFileCacheSize;
        BOOL                            m_fLogErrorRequests;
        BOOL                            m_fExceptionCatchEnable;
        BOOL                            m_fAllowDebugging;
        BOOL                            m_fAllowOutOfProcCmpnts;
        BOOL                            m_fTrackThreadingModel;
        DWORD                           m_dwMDSinkCookie;
        CMDGlobConfigSink              *m_pMetabaseSink;
        IMSAdminBase                   *m_pMetabase;

        BOOL    m_fEnableAspHtmlFallBack;
		BOOL    m_fEnableTypelibCache;
		BOOL    m_fEnableChunkedEncoding;
		BOOL    m_fDupIISLogToNTLog;
        DWORD   m_dwRequestQueueMax;
		DWORD   m_dwProcessorThreadMax;
            
		BOOL    m_fThreadGateEnabled;
		DWORD   m_dwThreadGateTimeSlice;
		DWORD   m_dwThreadGateSleepDelay;
		DWORD   m_dwThreadGateSleepMax;
		DWORD   m_dwThreadGateLoadLow;
		DWORD   m_dwThreadGateLoadHigh;

        LPSTR   m_pszPersistTemplateDir;
        DWORD   m_dwPersistTemplateMaxFiles;
        

        CRITICAL_SECTION        m_cs;                           // Glob Strings need to be protected by CriticalSection

                                                                                    // Functions Pointers for WINNT & WIN95 singal binary compatibility
        //Private functions
        HRESULT         SetGlobValue(unsigned int index, BYTE *lpByte);

public:
        CGlob();

        HRESULT         MDInit(void);
        HRESULT         MDUnInit(void);


public:
        ITypeLib*       pITypeLibDenali()                       {return m_pITypeLibDenali;};            // Denali's type library
        ITypeLib*       pITypeLibTxn()                          {return m_pITypeLibTxn;};            // Denali's type library
        BOOL            fWinNT()                                {return m_fWinNT;};                                     // TRUE if this is Windows NT; false otherwise
	    DWORD           dwNumberOfProcessors()                  {return m_dwNumberOfProcessors;};
    	BOOL            fNeedUpdate()                           {return (BOOLB)m_fNeedUpdate;};
        void            NotifyNeedUpdate();
        DWORD           dwScriptEngineCacheMax()                {return m_dwScriptEngineCacheMax;};
        DWORD           dwScriptFileCacheSize()                 {return m_dwScriptFileCacheSize;};
        BOOLB           fLogErrorRequests()                     {return (BOOLB)m_fLogErrorRequests;};
        BOOLB           fInited()                               {return (BOOLB)m_fInited;};
        BOOLB           fMDRead()                               {return (BOOLB)m_fMDRead;};
        BOOLB           fTrackThreadingModel()                  {return (BOOLB)m_fTrackThreadingModel;};
        BOOLB     		fExceptionCatchEnable()	    		    {return (BOOLB)m_fExceptionCatchEnable;};
        BOOLB     		fAllowOutOfProcCmpnts() 	        	{return (BOOLB)m_fAllowOutOfProcCmpnts;};

        BOOL    fEnableAspHtmlFallBack()   { return m_fEnableAspHtmlFallBack; }
		BOOL    fEnableTypelibCache()      { return m_fEnableTypelibCache; }
		BOOL    fEnableChunkedEncoding()   { return m_fEnableChunkedEncoding; }  // UNDONE: temp.
		BOOL    fDupIISLogToNTLog()        { return m_fDupIISLogToNTLog; }
        DWORD   dwRequestQueueMax()        { return m_dwRequestQueueMax; }
		DWORD   dwProcessorThreadMax()     { return m_dwProcessorThreadMax; }
            
		BOOL    fThreadGateEnabled()       { return m_fThreadGateEnabled; }
		DWORD   dwThreadGateTimeSlice()    { return m_dwThreadGateTimeSlice; }
		DWORD   dwThreadGateSleepDelay()   { return m_dwThreadGateSleepDelay; }
		DWORD   dwThreadGateSleepMax()     { return m_dwThreadGateSleepMax; }
		DWORD   dwThreadGateLoadLow()      { return m_dwThreadGateLoadLow; }
		DWORD   dwThreadGateLoadHigh()     { return m_dwThreadGateLoadHigh; }

        DWORD   dwPersistTemplateMaxFiles(){ return m_dwPersistTemplateMaxFiles; }
        LPSTR   pszPersistTemplateDir()    { return m_pszPersistTemplateDir; }

        void            Lock()                                  {EnterCriticalSection(&m_cs);};
        void            UnLock()                                {LeaveCriticalSection(&m_cs);};
        HRESULT         GlobInit(void);
        HRESULT         GlobUnInit(void);

        //Used in Scriptmgr for hashing table setup.
        DWORD           dwThreadMax()                                   {return 10;};
        //Used in ScriptKiller for script killer thread to wake up, might rename this to be
        //ScriptCleanupInterval.
        DWORD           dwScriptTimeout()                               {return 90;};

        HRESULT                     Update(CIsapiReqInfo  *pIReq);

};

inline HRESULT CGlob::Update(CIsapiReqInfo  *pIReq)
{
        Lock();
        if (m_fNeedUpdate == TRUE)
                {
                InterlockedExchange((LPLONG)&m_fNeedUpdate, 0);
                }
        else
                {
                UnLock();
                return S_OK;
                }
        UnLock();
        return ReadConfigFromMD(pIReq, NULL, TRUE);
}

inline void CGlob::NotifyNeedUpdate(void)
{
        InterlockedExchange((LPLONG)&m_fNeedUpdate, 1);
}

typedef class CGlob GLOB;
extern class CGlob gGlob;


//      General Access functions.(Backward compatibility).
//      Any non-friends functions should use and only use the following methods. Same macros as before.
//      If elem is a glob string, then, GlobStringUseLock() should be called before the string usage.
//      And GlobStringUseUnLock() should be called after.  The critical section is supposed to protect
//      not only the LPTSTR of global string, but also the memory that LPTSTR points to.
//      Making local copy of global string is recommended.
#define Glob(elem)                              (gGlob.elem())
#define GlobStringUseLock()             (gGlob.Lock())
#define GlobStringUseUnLock()   (gGlob.UnLock())
#define FIsWinNT()                              (Glob(fWinNT))

DWORD __stdcall RestartAppln(VOID *pAppln);
#endif // __Glob_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\hitobj.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Hit Object

File: Hitobj.h

Owner: PramodD

This is the Hit Object header file.
===================================================================*/
#ifndef HITOBJ_H
#define HITOBJ_H

#include "Compcol.h"
#include "Sessmgr.h"
#include "Applmgr.h"
#include "Context.h"
#include "Resource.h"
#include "exec.h"
#include "glob.h"
#include "memcls.h"
#include "gip.h"
#include "txnsup.h"

#define hNil            (HANDLE)0
#define SESSIONID_LEN   24

// HitObj type
#define EHitType                DWORD
#define ehtUnInitedRequest      0x00000000
#define ehtBrowserRequest       0x00000001
#define ehtSessionCleanup       0x00000002
#define ehtApplicationCleanup   0x00000004

// Execution status (result)
#define EExecStatus             DWORD
#define eExecFailed             0x00000000
#define eExecSucceeded          0x00000001
#define eExecTimedOut           0x00000002

// Current execution state
#define EEventState             DWORD
#define eEventNone              0x00000000
#define eEventAppOnStart        0x00000001
#define eEventSesOnStart        0x00000002
#define eEventAppOnEnd          0x00000004
#define eEventSesOnEnd          0x00000008

// Global interface table
extern IGlobalInterfaceTable *g_pGIT;

/*===================================================================
  C H i t O b j
  
The Hit Manager runs in the context of an IIS thread.
It packages up a request, calls Viper async. and 
on callback executes the request
===================================================================*/

class CHitObj
    {
private:
    // Flags and other bit-fields
    DWORD m_fInited : 1;                // Are we initialized?
    DWORD m_fRunGlobalAsa : 1;          // Should we run global.asa
    DWORD m_fStartSession : 1;          // New session
    DWORD m_fNewCookie : 1;             // Is New session cookie?
    DWORD m_fStartApplication : 1;      // New application
    DWORD m_fClientCodeDebug : 1;       // Client code debug enabled?
    DWORD m_fApplnOnStartFailed : 1;    // Application_OnStart failed
    DWORD m_fCompilationFailed : 1;     // Script Compilation error?
    DWORD m_fExecuting : 1;             // Currently inside Viper callback
    DWORD m_fHideRequestAndResponseIntrinsics : 1;  // TRUE while instrinsics are hidden
    DWORD m_fHideSessionIntrinsic : 1;  // TRUE if session intrinsic's hidden
    DWORD m_fDoneWithSession : 1;       // TRUE after DONE_WITH_SESSION
    DWORD m_fRejected : 1;              // TRUE if rejected (not posted)
    DWORD m_f449Done : 1;               // 449 processing done for this request
    DWORD m_fInTransferOnError : 1;     // doing transfer on error (to break infinite)
    DWORD m_fSecure : 1;                // Secure Connection

    EHitType    m_ehtType : 4;          // Type of the request
    EExecStatus m_eExecStatus : 4;      // Error Status // for Perf Counter only
    EEventState m_eEventState : 4;      // Current Event
    CompScope   m_ecsActivityScope : 4; // Which activity running this request?

    // Intrinsics set from inside HitObj
    CSession  *m_pSession;
    CAppln    *m_pAppln;
    CResponse *m_pResponse;
    CRequest  *m_pRequest;
    CServer   *m_pServer;
    CASPObjectContext   *m_pASPObjectContext;

    // IsapiReqInfo

    CIsapiReqInfo   *m_pIReq;

    // Intrinsics set from outside HitObj (to be ref. counted)
    IUnknown *m_punkScriptingNamespace;

    // Component collection of extrinsic objects
    CComponentCollection  *m_pPageCompCol;
    CPageComponentManager *m_pPageObjMgr;

    // Impersonation handle
    HANDLE m_hImpersonate;

    // Viper page-level activity (if no session)
    CViperActivity *m_pActivity;

    // Current session info
    char        m_szSessionCookie[SESSIONID_LEN+4]; // +4 to keep DWORD boundary
    CSessionId  m_SessionId;

    // Context object (for OnStartPage)
    CScriptingContext * m_pScriptingContext;

    // Misc
    long                m_nScriptTimeout;   // Maximum number of seconds script should run
    UINT                m_uCodePage;        // RunTime CodePage
    LCID                m_lcid;             // RunTime LCID
    ActiveEngineInfo   *m_pEngineInfo;      // List of active engines for this hit objext
    IDispatch          *m_pdispTypeLibWrapper;  // Page-level typelib wrapper
    DWORD               m_dwtTimestamp;     // Timestamp for wait time and perf calcs

    // Used to reffer to the current template during the compilation
    TCHAR              *m_szCurrTemplatePhysPath;
    TCHAR              *m_szCurrTemplateVirtPath;

    // ASP Error object
    IASPError          *m_pASPError;

    // Store a pointer to the associated template so as to avoid redundant
    // FindTemplate calls.
    
    CTemplate          *m_pTemplate;

    // Private interfaces
    HRESULT             ParseCookiesForSessionIdAndFlags();
    // Request rejection logic
    HRESULT             RejectBrowserRequestWhenNeeded(DWORD dwtQueueWaitTime, BOOL *pfRejected);


// Public Interfaces
public: 
                        CHitObj();
    virtual             ~CHitObj();

    static HRESULT      NewBrowserRequest(CIsapiReqInfo   *pIReq, 
                                          BOOL *pfRejected = NULL, 
                                          BOOL *pfCompleted = NULL,
                                          int  *piErrorId  = NULL);
                                          
    HRESULT             BrowserRequestInit(CIsapiReqInfo   *pIReq, int * dwId);
    HRESULT             AssignApplnToBrowserRequest(BOOL *pfApplnRestarting);
    HRESULT             AssignSessionToBrowserRequest(BOOL *pfNewSession, BOOL *pfNewCookie, int *pErrorId);
    HRESULT             DetachBrowserRequestFromSession();
    HRESULT             ReassignAbandonedSession();
    
    void                SessionCleanupInit(CSession *pSession);
    void                ApplicationCleanupInit(CAppln *pAppln);
    
    BOOL                SendHeader(const char *szStatus);
    BOOL                SendError(const char *szError);
    
    TCHAR*              GetSzAppPhysicalPath(void);
    void                ApplnOnStartFailed();
    void                SessionOnStartFailed();
    void                SessionOnStartInvoked();
    void                SessionOnEndPresent();
    void                SetEventState(EEventState eEvent);
    EEventState         EventState();

    // Report server error without response object
    HRESULT ReportServerError(UINT ErrorId);

// Component Collection Interfaces

    HRESULT InitComponentProcessing();
    HRESULT StopComponentProcessing();
    
    HRESULT GetPageComponentCollection(CComponentCollection **ppCollection);
    HRESULT GetSessionComponentCollection(CComponentCollection **ppCollection);
    HRESULT GetApplnComponentCollection(CComponentCollection **ppCollection);

    HRESULT AddComponent(CompType type, const CLSID &clsid, CompScope scope,
                         CompModel model, LPWSTR pwszName = NULL,
                         IUnknown *pUnk = NULL);
    HRESULT GetComponent(CompScope scope, LPWSTR pwszName, DWORD cbName,
                         CComponentObject **ppObj);
    HRESULT GetIntrinsic(LPWSTR pwszName, DWORD cbName, IUnknown **ppUnk);
    HRESULT CreateComponent(const CLSID &clsid, IDispatch **ppDisp);
    HRESULT SetPropertyComponent(CompScope scope, LPWSTR pwszName,
                          VARIANT *pVariant);
    HRESULT GetPropertyComponent(CompScope scope, LPWSTR pwszName,
                        CComponentObject **ppObj);

// Viper Integration

    CViperActivity *PActivity();
    CViperActivity *PCurrentActivity();
    HRESULT SetActivity(CViperActivity *pActivity);

    HRESULT PostViperAsyncCall();
    HRESULT ViperAsyncCallback(BOOL *pfRePosted);

// Execute / Transfer

    HRESULT ExecuteChildRequest(BOOL fTransfer, TCHAR *szTemplate, TCHAR *szVirtTemplate);

    HRESULT     GetASPError(IASPError **ppASPError);
    inline void SetASPError(IASPError *pASPError);
    inline BOOL FHasASPError();
    
// inline functions
public:
    CIsapiReqInfo      *PIReq();
    HANDLE              HImpersonate();
    CResponse *         PResponse();
    CRequest *          PRequest();
    CServer *           PServer();
    CAppln *            PAppln();
    CSession *          PSession();
    CASPObjectContext  *PASPObjectContext();
    CASPObjectContext  *SetASPObjectContext(CASPObjectContext  *);
    CPageComponentManager * PPageComponentManager();
    BOOL                FIsBrowserRequest() const;
    BOOL                FIsSessionCleanupRequest() const;
    BOOL                FIsApplnCleanupRequest() const;
    BOOL                FIsValidRequestType() const;
    const char *        PSzNewSessionCookie() const;
    DWORD               SessionId() const;
    CScriptingContext * PScriptingContextGet();
    BOOL                FStartApplication();
    BOOL                FStartSession();
    BOOL                FNewCookie();
    BOOL                FObjectTag(IDispatch * pDispatch);
    BOOL                FHasSession();
    BOOL                FClientCodeDebug();
    BOOL                FDoneWithSession();
    BOOL                FExecuting();
    BOOL                F449Done();
    BOOL                FInTransferOnError();
    BOOL                FSecure();

    void                SetScriptTimeout(long nScriptTimeout);
    long                GetScriptTimeout();
    void                SetExecStatus(EExecStatus status);
    EExecStatus         ExecStatus();
    void                SetActiveEngineInfo(ActiveEngineInfo *);
    void                SetCompilationFailed();
    void                SetDoneWithSession();
    void                Set449Done();
    void                SetInTransferOnError();
    
    TCHAR *             GlobalAspPath();
    HRESULT             SetCodePage(UINT uCodePage);    // Proxy function, CodePage is stored in m_pSession
    UINT                GetCodePage();                  // same as above
    HRESULT             SetLCID(LCID lcid);             // Proxy function, LCID is stored in m_pSession
    LCID                GetLCID();                  // same as above

    CAppConfig *        QueryAppConfig();

    TCHAR *              PSzCurrTemplatePhysPath();
    TCHAR *              PSzCurrTemplateVirtPath();
    DWORD               DWInstanceID();

    CTemplate          *GetTemplate();
    void                SetTemplate(CTemplate *);

    // Instead of add/remove to/from component collection use these:
    void HideRequestAndResponseIntrinsics();
    void UnHideRequestAndResponseIntrinsics();
    BOOL FRequestAndResponseIntrinsicsHidden();
    void AddScriptingNamespace(IUnknown *punkNamespace);
    void RemoveScriptingNamespace();

    // Typelib wrapper support
    IDispatch *PTypeLibWrapper();
    void SetTypeLibWrapper(IDispatch *pdisp);

    // Timestamp manipulation
    void  UpdateTimestamp();
    DWORD ElapsedTimeSinceTimestamp();

#ifdef DBG
    virtual void AssertValid() const;
#else
    virtual void AssertValid() const {}
#endif

    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };

/*===================================================================
  CHitObj inlines
===================================================================*/

inline CIsapiReqInfo   *CHitObj::PIReq()
    {
    return m_pIReq; 
    }
    
inline BOOL CHitObj::FIsBrowserRequest() const
    {
    return (m_ehtType == ehtBrowserRequest);
    }

inline BOOL CHitObj::FIsSessionCleanupRequest() const
    {
    return (m_ehtType == ehtSessionCleanup);
    }
    
inline BOOL CHitObj::FIsApplnCleanupRequest() const
    {
    return (m_ehtType == ehtApplicationCleanup);
    }

inline BOOL CHitObj::FIsValidRequestType() const
    {
    return (FIsBrowserRequest() || 
            FIsSessionCleanupRequest() ||
            FIsApplnCleanupRequest());
    }
    
inline HANDLE CHitObj::HImpersonate()
    {
    return m_hImpersonate; 
    }

inline DWORD CHitObj::SessionId() const 
    {
    return m_SessionId.m_dwId; 
    }

inline const char *CHitObj::PSzNewSessionCookie() const 
    {
    return (m_fNewCookie ? m_szSessionCookie : NULL); 
    }

inline BOOL CHitObj::FStartApplication()
    {
    return m_fStartApplication; 
    }

inline BOOL CHitObj::FStartSession()
    {
    return m_fStartSession; 
    }

inline BOOL CHitObj::FNewCookie() 
    {
    return m_fNewCookie; 
    }

inline BOOL CHitObj::FHasSession()
    {
    return (m_pSession != NULL && !m_fHideSessionIntrinsic);
    }

inline BOOL CHitObj::FClientCodeDebug()
    {
    return m_fClientCodeDebug;
    }

inline BOOL CHitObj::FDoneWithSession()
    {
    return m_fDoneWithSession;
    }

inline BOOL CHitObj::FExecuting()
    {
    return m_fExecuting;
    }

inline BOOL CHitObj::F449Done()
    {
    return m_f449Done;
    }

inline BOOL CHitObj::FInTransferOnError()
    {
    return m_fInTransferOnError;
    }

inline BOOL CHitObj::FSecure()
    {
    return m_fSecure;
    }

inline void CHitObj::SessionOnStartFailed() 
    {
    Assert(m_pSession);
    m_pSession->SetOnStartFailedFlag();
    }
    
inline void CHitObj::ApplnOnStartFailed() 
    {
    m_fApplnOnStartFailed = TRUE;
    
    if (m_pSession)
        SessionOnStartFailed();
    }
    
inline void CHitObj::SessionOnStartInvoked()
    {
    Assert(m_pSession); 
    m_pSession->SetOnStartInvokedFlag(); 
    }

inline void CHitObj::SessionOnEndPresent()
    {
    Assert(m_pSession); 
    m_pSession->SetOnEndPresentFlag(); 
    }

inline DWORD CHitObj::DWInstanceID()
    {
    return (m_pIReq) ? m_pIReq->QueryInstanceId() : 0;
    }

inline CViperActivity *CHitObj::PActivity()
    {
    return m_pActivity; 
    }
    
inline CScriptingContext *CHitObj::PScriptingContextGet()
    {
    return m_pScriptingContext; 
    }
    
inline CResponse *CHitObj::PResponse()
    {
    return m_pResponse; 
    }

inline CRequest *CHitObj::PRequest()
    {
    return m_pRequest; 
    }

inline CServer *CHitObj::PServer()
    {
    return m_pServer; 
    }

inline CAppln *CHitObj::PAppln()
    {
    return m_pAppln;
    }

inline CSession *CHitObj::PSession()
    {
    return m_pSession;
    }

inline CASPObjectContext *CHitObj::PASPObjectContext()
{
    return m_pASPObjectContext;
}

inline CASPObjectContext *CHitObj::SetASPObjectContext(CASPObjectContext *pContext)
{
    CASPObjectContext   *pPoppedContext = m_pASPObjectContext;
    m_pASPObjectContext = pContext;

    return pPoppedContext;
}

inline CPageComponentManager *CHitObj::PPageComponentManager()
    {
    return m_pPageObjMgr;
    }

inline TCHAR *CHitObj::GlobalAspPath()
    {
    if ( m_fRunGlobalAsa )
        return m_pAppln->GetGlobalAsa();
    else
        return NULL;
    }

inline void CHitObj::SetScriptTimeout(long nScriptTimeout)
    {
    m_nScriptTimeout = nScriptTimeout; 
    }
    
inline long CHitObj::GetScriptTimeout()
    {
    return m_nScriptTimeout; 
    }

inline void CHitObj::SetExecStatus(EExecStatus status)
    {
    m_eExecStatus = status;
    }
    
inline EExecStatus CHitObj::ExecStatus()
    {
    return m_eExecStatus;
    }
    
inline EEventState CHitObj::EventState()
    {
    return m_eEventState;
    }

inline void CHitObj::SetEventState(EEventState eState)
    {
    m_eEventState = eState;
    }

inline CAppConfig * CHitObj::QueryAppConfig(void)
    {
    return m_pAppln->QueryAppConfig();
    }
    
inline UINT CHitObj::GetCodePage(void)
    {
    return m_uCodePage == 0 ? GetACP() : m_uCodePage;
    }

inline LCID CHitObj::GetLCID()
    {
    return m_lcid;
    }

inline  VOID CHitObj::SetActiveEngineInfo(ActiveEngineInfo *pActiveEngineInfo)
    {
    m_pEngineInfo = pActiveEngineInfo;
    }

inline void CHitObj::SetCompilationFailed()
    {
    m_fCompilationFailed = TRUE;
    }

inline void CHitObj::SetDoneWithSession()
    {
    Assert(!m_fDoneWithSession);
    m_fDoneWithSession = TRUE;
    }

inline void CHitObj::Set449Done()
    {
    Assert(!m_f449Done);
    m_f449Done = TRUE;
    }

inline void CHitObj::SetInTransferOnError()
    {
    Assert(!m_fInTransferOnError);
    m_fInTransferOnError = TRUE;
    }

inline void CHitObj::HideRequestAndResponseIntrinsics()
    {
    m_fHideRequestAndResponseIntrinsics = TRUE;
    }
    
inline void CHitObj::UnHideRequestAndResponseIntrinsics()
    {
    m_fHideRequestAndResponseIntrinsics = FALSE;
    }

inline BOOL CHitObj::FRequestAndResponseIntrinsicsHidden()
    {
    return m_fHideRequestAndResponseIntrinsics;
    }

inline void CHitObj::AddScriptingNamespace(IUnknown *punkNamespace)
    {
    Assert(m_punkScriptingNamespace == NULL);
    Assert(punkNamespace);
    m_punkScriptingNamespace = punkNamespace;
    m_punkScriptingNamespace->AddRef();
    }
    
inline void CHitObj::RemoveScriptingNamespace()
    {
    if (m_punkScriptingNamespace)
        {
        m_punkScriptingNamespace->Release();
        m_punkScriptingNamespace = NULL;
        }
    }
    
inline IDispatch *CHitObj::PTypeLibWrapper()
    {
    return m_pdispTypeLibWrapper;
    }
    
inline void CHitObj::SetTypeLibWrapper(IDispatch *pdisp)
    {
    if (m_pdispTypeLibWrapper)
        m_pdispTypeLibWrapper->Release();
        
    m_pdispTypeLibWrapper = pdisp;
    
    if (m_pdispTypeLibWrapper)
        m_pdispTypeLibWrapper->AddRef();
    }

inline void CHitObj::UpdateTimestamp() 
    {
    m_dwtTimestamp = GetTickCount();
    }
    
inline DWORD CHitObj::ElapsedTimeSinceTimestamp() 
    {
    DWORD dwt = GetTickCount();
    if (dwt >= m_dwtTimestamp)
        return (dwt - m_dwtTimestamp);
    else
        return ((0xffffffff - m_dwtTimestamp) + dwt);
    }

inline TCHAR *CHitObj::PSzCurrTemplatePhysPath()
    {
    if (m_szCurrTemplatePhysPath != NULL) 
        return m_szCurrTemplatePhysPath;
    else if (m_pIReq != NULL)
        return m_pIReq->QueryPszPathTranslated();
    else
        return NULL;
    }
    
inline TCHAR *CHitObj::PSzCurrTemplateVirtPath()
    {
    if (m_szCurrTemplateVirtPath != NULL) 
        return m_szCurrTemplateVirtPath;
    else if (m_pIReq != NULL)
        return m_pIReq->QueryPszPathInfo();
    else
        return NULL;
    }

inline void CHitObj::SetASPError(IASPError *pASPError)
    {
    if (m_pASPError)
        m_pASPError->Release();
    m_pASPError = pASPError;  // passed addref'd
    }

inline BOOL CHitObj::FHasASPError()
    {
    return (m_pASPError != NULL);
    }

inline CTemplate *CHitObj::GetTemplate()
    {
    return m_pTemplate;
    }

inline void CHitObj::SetTemplate(CTemplate *pTemplate)
{
    m_pTemplate = pTemplate;
}

/*===================================================================
  Globals
===================================================================*/

extern DWORD g_nBrowserRequests;
extern DWORD g_nSessionCleanupRequests;
extern DWORD g_nApplnCleanupRequests;


#undef  SCRIPT_STATS

#ifdef SCRIPT_STATS
# include <locks.h>

void
ReadRegistrySettings();

extern CSmallSpinLock g_lockRequestStats;
extern DWORD          g_dwQueueDebugThreshold;
extern DWORD          g_fSendScriptlessOnAtqThread;
extern LONG           g_cRequests;
extern LONG           g_cScriptlessRequests;
extern LONG           g_cHttpExtensionsExecuting;
extern LONG           g_cConcurrentScriptlessRequests;
extern LONG           g_cMaxConcurrentScriptlessRequests;
extern LONGLONG       g_nSumConcurrentScriptlessRequests;
extern LONGLONG       g_nSumExecTimeScriptlessRequests;
extern LONG           g_nAvgConcurrentScriptlessRequests;
extern LONG           g_nAvgExecTimeScriptlessRequests;
#endif // SCRIPT_STATS

#endif // HITOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\hashing.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Link list and Hash table

File: Hashing.h

Owner: PramodD

This is the Link list and Hash table class header file.
===================================================================*/

#ifndef HASHING_H
#define HASHING_H

// General purpose hash function
typedef DWORD (*HashFunction)( const BYTE *pBytes, int cBytes );

// Default hash function
extern DWORD DefaultHash( const BYTE *pBytes, int cBytes );

// unicode hash function, based on algorithm used by ::DefaultHash, CASE INSENSITIVE
extern DWORD UnicodeUpcaseHash( const BYTE *pKey, int cbKey );

// multi-byte ucase hash function, based on algorithm used by ::DefaultHash, CASE INSENSITIVE
extern DWORD MultiByteUpcaseHash( const BYTE *pKey, int cbKey );

// Cache pointers. The 4-byte address is the DWORD.
extern DWORD PtrHash( const BYTE *pKey, int );

// CLSID hashing.
extern DWORD CLSIDHash( const BYTE *pKey, int );

/*
The CLinkElem class is intended to be used as a base class for
other link lists and/or hash table implementations.

The name is used for identification and search purposes.

The previous and next pointers are used for traversal.

The Info member is the number of elements in bucket following
this element.

*/

struct CLinkElem
{
	BYTE *		m_pKey;		// Unique key - unknown datatype
	short		m_cbKey;	// length of the key
	short		m_Info;		// Link list element info
	CLinkElem *	m_pPrev;	// Previous element in link list
	CLinkElem *	m_pNext;	// Next element in link list

			CLinkElem();
	virtual	~CLinkElem() {} // Did not allocate so we do not delete
	HRESULT	Init(void *pKey, int cKeyLen);
};

/*
This Hash Table class is used to store and find Named elements
of the type CLinkElem. Classes derived from CLinkElem can use
this class.

The principal requirements for the implementation are:
	Speed of search
	Forward and backward traversal through stored elements

The expected use of this class is as follows.

The user calls the Init method with a size argument to indicate
the number of buckets.

CLinkElems are added to the Hash table using AddElem()

CLinkElems are searched for by name using FindElemByName()

CLinkElems are searched for by index using FindElemByIndex()

CLinkElems are removed by name using DeleteElem()

Reference counting should be implemented by the class derived
from CLinkElem.
*/

#define PREALLOCATED_BUCKETS_MAX    25

class CHashTable
{
protected:
	DWORD				m_fInited : 1;
	DWORD               m_fBucketsAllocated : 1;
	CLinkElem *			m_pHead;
	CLinkElem *			m_pTail;
	CLinkElem **		m_rgpBuckets;
	HashFunction		m_pfnHash;
	UINT				m_cBuckets;
	UINT				m_Count;
	CLinkElem *         m_rgpBucketsBuffer[PREALLOCATED_BUCKETS_MAX];

protected:
    HRESULT             AllocateBuckets();
	virtual BOOL		FIsEqual( const void * pKey1, int cbKey1, const void * pKey2, int cbKey2 );

// inline access functions
public:
	CLinkElem *			Head(void);
	CLinkElem *			Tail(void);
	UINT				Buckets(void);
	UINT				Count(void);

public:
						CHashTable(HashFunction = DefaultHash);
	virtual				~CHashTable(void); // We allocate and need a destructor
	HRESULT				Init(UINT cBuckets = 11);
	HRESULT				UnInit(void);
	void				ReInit();
	CLinkElem *			AddElem(CLinkElem *pElem, BOOL fTestDups = TRUE);
	CLinkElem *			FindElem(const void *pKey, int cKeyLen);
	CLinkElem *			DeleteElem(const void *pKey, int cKeyLen);
	CLinkElem * 		RemoveElem( CLinkElem *pLE );

	void				AssertValid() const;
};

inline CLinkElem *	CHashTable::Head(void) { return m_pHead; }
inline CLinkElem *	CHashTable::Tail(void) { return m_pTail; }
inline UINT			CHashTable::Buckets(void) { return m_cBuckets; }
inline UINT			CHashTable::Count(void) { return m_Count; }

#ifndef DBG
inline void CHashTable::AssertValid() const {}
#endif


/*
 * CHashTableStr
 *
 * This is exactly the same as a CHashTable, but the elements are understood to be pointers
 * to Unicode strings, and the string compares are done **CASE INSENSITIVE**
 */
class CHashTableStr : public CHashTable
{
protected:
	BOOL				FIsEqual( const void * pKey1, int cbKey1, const void * pKey2, int cbKey2 );

public:
						CHashTableStr(HashFunction = UnicodeUpcaseHash);

};


/*
 * CHashTableMBStr
 *
 * This is exactly the same as a CHashTable, but the elements are understood to be pointers
 * to multi-byte strings, and the string compares are done **CASE INSENSITIVE**
 */
class CHashTableMBStr : public CHashTable
{
protected:
	BOOL				FIsEqual( const void * pKey1, int cbKey1, const void * pKey2, int cbKey2 );

public:
						CHashTableMBStr(HashFunction = MultiByteUpcaseHash);

};

/*
 * CHashTablePtr
 *
 * CHashTable where but the elements are hashed by pointers
 * used as DWORD hash values
 */
class CHashTablePtr : public CHashTable
{
protected:
	BOOL FIsEqual(const void *pKey1, int, const void *pKey2, int);

public:
	CHashTablePtr(HashFunction = PtrHash);
};

/*
 * CHashTableCLSID
 *
 * CHashTable where but the elements are hashed by CLSIDs
 */
class CHashTableCLSID : public CHashTable
{
protected:
	BOOL FIsEqual(const void *pKey1, int, const void *pKey2, int);

public:
	CHashTableCLSID(HashFunction = CLSIDHash);
};

#endif // HASHING_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\hitobj.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Main

File: Hitobj.cpp

Owner: DmitryR


This file contains the CHitObj class implementation.
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "context.h"
#include "exec.h"
#include "mtacb.h"
#include "perfdata.h"
#include "debugger.h"
#include "asperror.h"
#include "thrdgate.h"

#include "memchk.h"

//resource failure globals
#include "rfs.h"
#ifdef _RFS
MemRFS memrfs;
#endif


#ifdef SCRIPT_STATS

# define REG_ASP_DEBUG_LOCATION "System\\CurrentControlSet\\Services\\W3Svc\\ASP"

# define REG_STR_QUEUE_DEBUG_THRESHOLD "QueueDebugThreshold"
# define REG_DEF_QUEUE_DEBUG_THRESHOLD 25
DWORD g_dwQueueDebugThreshold = 0; // REG_DEF_QUEUE_DEBUG_THRESHOLD;

# define REG_STR_SEND_SCRIPTLESS_ON_ATQ_THREAD "SendScriptlessOnAtqThread"
# define REG_DEF_SEND_SCRIPTLESS_ON_ATQ_THREAD 1
DWORD g_fSendScriptlessOnAtqThread = REG_DEF_SEND_SCRIPTLESS_ON_ATQ_THREAD;

void
ReadRegistrySettings()
{
    HKEY hkey = NULL;
    DWORD dwErr = RegOpenKeyEx(HKEY_LOCAL_MACHINE, REG_ASP_DEBUG_LOCATION,
                               0, KEY_READ, &hkey);
    if (dwErr == NO_ERROR)
    {
        DWORD dwType, dwBuffer;
        DWORD cbBuffer = sizeof(dwBuffer);

        dwErr = RegQueryValueEx(hkey, REG_STR_QUEUE_DEBUG_THRESHOLD,
                                NULL, &dwType, (LPBYTE) &dwBuffer, &cbBuffer);
        if (dwErr == NO_ERROR)
            g_dwQueueDebugThreshold = dwBuffer;

        dwErr = RegQueryValueEx(hkey, REG_STR_SEND_SCRIPTLESS_ON_ATQ_THREAD,
                                NULL, &dwType, (LPBYTE) &dwBuffer, &cbBuffer);
        if (dwErr == NO_ERROR)
            g_fSendScriptlessOnAtqThread = dwBuffer;

        RegCloseKey(hkey);
    }

    char szTemp[200];
    sprintf(szTemp, "RRS, err = %d, QueueDebugThreshold = %d, SendScriptlessOnAtqThread = %d\n",
            dwErr, g_dwQueueDebugThreshold, g_fSendScriptlessOnAtqThread);
    OutputDebugString(szTemp);
}


CSmallSpinLock g_lockRequestStats;
LONG           g_cRequests = 0;
LONG           g_cScriptlessRequests = 0;
LONG           g_cHttpExtensionsExecuting = 0;
LONG           g_cConcurrentScriptlessRequests = 0;
LONG           g_cMaxConcurrentScriptlessRequests = 0;
LONGLONG       g_nSumConcurrentScriptlessRequests = 0;
LONGLONG       g_nSumExecTimeScriptlessRequests = 0;
LONG           g_nAvgConcurrentScriptlessRequests = 0;
LONG           g_nAvgExecTimeScriptlessRequests = 0;

#endif // SCRIPT_STATS

DWORD g_nBrowserRequests = 0;
DWORD g_nSessionCleanupRequests = 0;
DWORD g_nApplnCleanupRequests = 0;

IGlobalInterfaceTable *g_pGIT = NULL;

IASPObjectContext  *g_pIASPDummyObjectContext = NULL;

/*===================================================================
CHitObj::CHitObj

Constructor 

Parameters:
    NONE

Returns:
    NONE
===================================================================*/   
CHitObj::CHitObj()
  : m_fInited(FALSE),
    m_ehtType(ehtUnInitedRequest),
    m_hImpersonate(hNil),
    m_pIReq(NULL),
    m_pResponse(NULL),
    m_pRequest(NULL),
    m_pServer(NULL),
    m_pASPObjectContext(NULL),
    m_punkScriptingNamespace(NULL),
    m_pPageCompCol(NULL),
    m_pPageObjMgr(NULL),
    m_pActivity(NULL),
    m_ecsActivityScope(csUnknown),
    m_SessionId(INVALID_ID, 0, 0),
    m_pSession(NULL),
    m_pAppln(NULL),
    m_fRunGlobalAsa(FALSE),
    m_fStartSession(FALSE),
    m_fNewCookie(FALSE),
    m_fStartApplication(FALSE),
    m_fApplnOnStartFailed(FALSE),
    m_fClientCodeDebug(FALSE),
    m_fCompilationFailed(FALSE),
    m_fExecuting(FALSE),
    m_fHideRequestAndResponseIntrinsics(FALSE),
    m_fHideSessionIntrinsic(FALSE),
    m_fDoneWithSession(FALSE),
    m_fRejected(FALSE),
    m_f449Done(FALSE),
    m_fInTransferOnError(FALSE),
    m_pScriptingContext(NULL),
    m_nScriptTimeout(0),
    m_eExecStatus(eExecSucceeded),
    m_eEventState(eEventNone),
    m_uCodePage(CP_ACP),
    m_lcid(LOCALE_SYSTEM_DEFAULT),
    m_dwtTimestamp(0),
    m_pEngineInfo(NULL),
    m_pdispTypeLibWrapper(NULL),
    m_szCurrTemplateVirtPath(NULL),
    m_szCurrTemplatePhysPath(NULL),
    m_pASPError(NULL),
    m_pTemplate(NULL),
    m_fSecure(FALSE)
    {
        m_uCodePage = GetACP();
    }

/*===================================================================
CHitObj::~CHitObj

Destructor

Parameters:
    None 

Returns:
    None
===================================================================*/
CHitObj::~CHitObj( void )
    {
    Assert(!m_fExecuting); // no deletes while still executing

    if (FIsBrowserRequest())
        {
        if (m_hImpersonate != hNil)
            m_hImpersonate = hNil;
            
        if (m_pSession)
            DetachBrowserRequestFromSession();
        }

    if (m_pASPError) // Error object
        {
        m_pASPError->Release();
        m_pASPError = NULL;
        }
        
    if (m_pActivity) // page-level Viper activity
        {
        delete m_pActivity;
        m_pActivity = NULL;
        }

    StopComponentProcessing();

    if (m_pdispTypeLibWrapper)
        m_pdispTypeLibWrapper->Release();

    // update request counters in application and session manager
    
    if (m_pAppln)
        {
        if (FIsBrowserRequest())
            {
            m_pAppln->DecrementRequestCount();
            }
        else if (FIsSessionCleanupRequest() && m_pAppln->PSessionMgr())
            {
            m_pAppln->PSessionMgr()->DecrementSessionCleanupRequestCount();
            }
        }

    if (m_pTemplate)
        m_pTemplate->Release();

    // update global request counters
    
    if (FIsBrowserRequest())
        InterlockedDecrement((LPLONG)&g_nBrowserRequests);
    else if (FIsSessionCleanupRequest())
        InterlockedDecrement((LPLONG)&g_nSessionCleanupRequests);
    else if (FIsApplnCleanupRequest())
        InterlockedDecrement((LPLONG)&g_nApplnCleanupRequests);

    if (m_pIReq)
        m_pIReq->Release();

}

/*===================================================================
CHitObj::NewBrowserRequest

Static method. Creates, Inits, Posts new browser request

Parameters:
    pIReq           CIsapiReqInfo
    pfRejected      [out] TRUE if rejected  (optional)
    pfCompeleted    [out] TRUE if comleted  (optional)
    piErrorId       [out] error id          (optional)

Returns:
    S_OK on success
    E_FAIL  on failure
===================================================================*/
HRESULT CHitObj::NewBrowserRequest
(
CIsapiReqInfo *pIReq,
BOOL *pfRejected,
BOOL *pfCompleted,
int  *piErrorId
)
    {
    HRESULT hr = S_OK;
    BOOL fRejected = FALSE;
    BOOL fCompleted = FALSE;
    int  iError = 0;

    CHitObj *pHitObj = new CHitObj;
    if (!pHitObj)
        hr = E_OUTOFMEMORY;

    if (SUCCEEDED(hr))
        {
        // Bracket BrowserRequestInit

        if (SUCCEEDED(StartISAThreadBracket(pIReq)))
            {
            hr = pHitObj->BrowserRequestInit(pIReq, &iError);

            if (SUCCEEDED(hr))
                {
                if (pHitObj->FDoneWithSession())
                    {
                    // finished while on I/O thread
                    fCompleted = TRUE;
                    delete pHitObj;
                    pHitObj = NULL;
                    }
                }
            else // if FAILED
                {
                if (iError == IDE_SERVER_TOO_BUSY)
                    fRejected = TRUE;
                }
            
            EndISAThreadBracket(pIReq);
            }
        else
            {
            hr = E_FAIL;
            }
        }

    // Post into Viper
    if (SUCCEEDED(hr) && !fCompleted)
        {
        hr = pHitObj->PostViperAsyncCall();

        if (FAILED(hr))
            fRejected = TRUE;
        }

    if (FAILED(hr) && pHitObj)
        {
        // Bracket HitObj destructor
        
        // This code is only executed if PostViperAsyncCall either
        // failed or was never called -- thus we don't worry about
        // everlapping bracketing with the worker thread.
        
        if (SUCCEEDED(StartISAThreadBracket(pIReq)))
            {
            pHitObj->m_fRejected = TRUE;
            delete pHitObj;
            
            EndISAThreadBracket(pIReq);
            }
        }

    if (pfRejected)
        *pfRejected = fRejected;
    if (pfCompleted)
        *pfCompleted = fCompleted;
    if (piErrorId)
        *piErrorId = iError;
    
    return hr;
}

/*===================================================================
HRESULT CHitObj::SetCodePage

Set Runtime CodePage, if fAllowSessionState is On, this will set 
Session.CodePage and we should always use Session.CodePage when we
call HitObj.GetCodePage when fAllowSessionState on.

HitObj.CodePage is only set when fAllowSessionState is off or 
ApplicationCleanup, because we don't have Session.CodePage anymore, session
does not even exist.

Parameters:
    UINT    uCodePage

Returns:
    S_OK on success
    E_FAIL  on failure
===================================================================*/
HRESULT CHitObj::SetCodePage(UINT uCodePage)
{
    HRESULT hr = S_OK;
    
    if (uCodePage == CP_ACP || IsValidCodePage(uCodePage))
        {
        m_uCodePage = uCodePage == CP_ACP ? GetACP() : uCodePage;

        // If engine info is available, notify the scripts engines that the code
        // page has changed
        if (m_pEngineInfo)
            {
            for (int i = 0; i < m_pEngineInfo->cActiveEngines; i++)
                {
                Assert(m_pEngineInfo->rgActiveEngines[i].pScriptEngine != NULL);
                m_pEngineInfo->rgActiveEngines[i].pScriptEngine->UpdateLocaleInfo(hostinfoCodePage); 
                }
            }

        return hr;
        }

    return E_FAIL;
}

/*===================================================================
HRESULT CHitObj::SetLCID

Set Runtime LCID, if fAllowSessionState is On, this will set 
Session.LCID and we should always use Session.LCID when we
call HitObj.LCID when fAllowSessionState on.

HitObj.LCID is only set when fAllowSessionState is off or 
ApplicationCleanup, because we don't have Session.CodePage anymore, session
does not even exist.

Parameters:
    LCID    lcid

Returns:
    S_OK on success
    E_FAIL  on failure
===================================================================*/
HRESULT CHitObj::SetLCID(LCID lcid)
{
    HRESULT hr = S_OK;

    if ((LOCALE_SYSTEM_DEFAULT == lcid) || IsValidLocale(lcid, LCID_INSTALLED))
        {
        m_lcid = lcid;

        // If engine info is available, notify the scripts engines that the
        // lcid has changed
        if (m_pEngineInfo)
            {
            for (int i = 0; i < m_pEngineInfo->cActiveEngines; i++)
                {
                Assert(m_pEngineInfo->rgActiveEngines[i].pScriptEngine != NULL);
                m_pEngineInfo->rgActiveEngines[i].pScriptEngine->UpdateLocaleInfo(hostinfoLocale); 
                }
            }

        return hr;
        }

    return E_FAIL;
}

/*===================================================================
HRESULT CHitObj::BrowserRequestInit

Initialize the request object

Parameters:
    CIsapiReqInfo   *pIReq
    int *pErrorId

Returns:
    S_OK on success
    E_FAIL  on failure
===================================================================*/
HRESULT CHitObj::BrowserRequestInit
(
CIsapiReqInfo   *pIReq,
int  *pErrorId 
)
    {
    HRESULT hr;

    m_pIReq = pIReq;

    m_pIReq->AddRef();

    m_ehtType = ehtBrowserRequest;
    InterlockedIncrement((LPLONG)&g_nBrowserRequests);

#ifdef SCRIPT_STATS
    InterlockedIncrement(&g_cRequests);
#endif // SCRIPT_STATS

    STACK_BUFFER( serverPortSecureBuff, 8 );
    DWORD cbServerPortSecure;
    if( !SERVER_GET (pIReq,"SERVER_PORT_SECURE", &serverPortSecureBuff, &cbServerPortSecure))
    {
        if (GetLastError() == E_OUTOFMEMORY) 
        {
            return E_OUTOFMEMORY;
        }
    }
    char *szServerPortSecure = (char *)serverPortSecureBuff.QueryPtr();
    m_fSecure = (szServerPortSecure[0] == '1' );

    // Ask W3SVC for the impersonation token so we can later impersonate on Viper's thread
    if (FIsWinNT())
        m_hImpersonate = m_pIReq->QueryImpersonationToken();

    // Uppercase path - BUGBUG - can't Normalize in place!!!!
    Normalize(m_pIReq->QueryPszPathTranslated());

    // Reject direct requests for global.asa file
    if (FIsGlobalAsa(m_pIReq->QueryPszPathTranslated(), m_pIReq->QueryCchPathTranslated()))
        {
        *pErrorId = IDE_GLOBAL_ASA_FORBIDDEN;
        return E_FAIL;
        }

    // Create page component collection
    hr = InitComponentProcessing();
    if (FAILED(hr))
        {
        *pErrorId = (hr == E_OUTOFMEMORY) ? IDE_OOM : IDE_INIT_PAGE_LEVEL_OBJ;
        return hr;
        }

    // Attach to application (or create a new one)
    BOOL fApplnRestarting = FALSE;
    hr = AssignApplnToBrowserRequest(&fApplnRestarting);
    if (FAILED(hr))
        {
		*pErrorId = fApplnRestarting ? IDE_GLOBAL_ASA_CHANGED
									 : IDE_ADD_APPLICATION;
        return E_FAIL;
        }

    // Get Session cookie, and misc flags from http header
    hr = ParseCookiesForSessionIdAndFlags();
    if (FAILED(hr)) // no cookie is not an error -- failed here means OOM
        return hr;

    // Remember script timeout value
    m_nScriptTimeout = m_pAppln->QueryAppConfig()->dwScriptTimeout();

    // Check if the session is needed
    BOOL fAllowSessions = m_pAppln->QueryAppConfig()->fAllowSessionState();
    BOOL fNeedSession = fAllowSessions;

    // Look if the template is cached
    CTemplate *pTemplate = NULL;

    // Find in cache - don't load if not in cache already
    hr = g_TemplateCache.FindCached
        (
        m_pIReq->QueryPszPathTranslated(),
        DWInstanceID(),
        &pTemplate
        );

    if (hr == S_OK)
        {
        Assert(pTemplate);
        
        // store the template away for later use...
        //pTemplate->AddRef();
        //m_pTemplate = pTemplate;

        if (fAllowSessions)
            {
            // check for session-less templates
            fNeedSession = pTemplate->FSession();
            }
        else
            {
#ifdef SCRIPT_STATS
            if (pTemplate->FScriptless())
                InterlockedIncrement(&g_cScriptlessRequests);
#endif // SCRIPT_STATS

            // check for scipt-less templates to be
            // completed on the I/O thread (when no debugging)
            if (
#ifdef SCRIPT_STATS
                g_fSendScriptlessOnAtqThread &&
#endif // SCRIPT_STATS
                pTemplate->FScriptless() && !m_pAppln->FDebuggable())
                {
#ifdef SCRIPT_STATS
                LONG c = InterlockedIncrement(&g_cConcurrentScriptlessRequests);
                DWORD dwTime = GetTickCount();
#endif // SCRIPT_STATS

                if (SUCCEEDED(CResponse::SyncWriteScriptlessTemplate(m_pIReq, pTemplate)))
                    {
#ifndef PERF_DISABLE
                    g_PerfData.Incr_REQPERSEC();
                    g_PerfData.Incr_REQSUCCEEDED();
#endif
                    m_fDoneWithSession = TRUE;  // do not post to MTS
                    }

#ifdef SCRIPT_STATS
                dwTime = GetTickCount() - dwTime;
                InterlockedDecrement(&g_cConcurrentScriptlessRequests);
                
                g_lockRequestStats.WriteLock();
                    g_nSumExecTimeScriptlessRequests += dwTime;

                    if (c > g_cMaxConcurrentScriptlessRequests)
                        g_cMaxConcurrentScriptlessRequests = c;
                    g_nSumConcurrentScriptlessRequests += c;

                    g_nAvgConcurrentScriptlessRequests = (LONG)
                        (g_nSumConcurrentScriptlessRequests
                         / g_cScriptlessRequests);
                    g_nAvgExecTimeScriptlessRequests = (LONG)
                        (g_nSumExecTimeScriptlessRequests
                         / g_cScriptlessRequests);
                g_lockRequestStats.WriteUnlock();
#endif // SCRIPT_STATS
                }
            }

        // When possible, generate 449 cookies while on I/O thread
        if (!m_fDoneWithSession)
            {
                if (!SUCCEEDED(pTemplate->Do449Processing(this)))
                    g_TemplateCache.Flush(m_pIReq->QueryPszPathTranslated(), DWInstanceID());
            }

        pTemplate->Release();
        }

    // initialize CodePage and LCID to the app defaults...

    m_uCodePage = PAppln()->QueryAppConfig()->uCodePage();

    m_lcid = PAppln()->QueryAppConfig()->uLCID();

    if (!fNeedSession || m_fDoneWithSession)
    {
        m_fInited = TRUE;
        return S_OK;
    }

    // Attach to session or create a new one
    BOOL fNewSession, fNewCookie;
    hr = AssignSessionToBrowserRequest(&fNewSession, &fNewCookie, pErrorId);

    if (FAILED(hr))
        return E_FAIL;

    Assert(m_pSession);
    
    // Move from inside "if (fNewSesson)"
    if (fNewCookie)
        m_fNewCookie = TRUE;

    if (fNewSession)
        {
        m_fStartSession = TRUE;

        if (m_pAppln->FHasGlobalAsa())
            m_fRunGlobalAsa = TRUE;
        }

    m_fInited = TRUE;
    return S_OK;
    }

/*===================================================================
CHitObj::AssignApplnToBrowserRequest

Find or create a new appln for this browser request
Does the appln manager locking

Parameters:
    pfApplnRestarting   [out] flag - failed because the appln
                                     found is restarting

Returns:
    HRESULT
===================================================================*/
HRESULT CHitObj::AssignApplnToBrowserRequest
(
BOOL *pfApplnRestarting
)
    {
    HRESULT hr;
    
    Assert(pfApplnRestarting);
    *pfApplnRestarting = FALSE;
    
    Assert(!m_pAppln);

    TCHAR *szAppMDPath = m_pIReq->QueryPszApplnMDPath();
    if (!szAppMDPath)
        return E_FAIL;
        
    // Lock the application manager
    g_ApplnMgr.Lock();

    // Find by application by metabase key
    CAppln *pAppln;
    hr = g_ApplnMgr.FindAppln(szAppMDPath, &pAppln);

    if (hr == S_OK)
        {
        // Reject requests for restarting applications
        if (pAppln->FGlobalChanged())
            {
            *pfApplnRestarting = TRUE;
            g_ApplnMgr.UnLock();
            return E_FAIL;
            }
        // Update appln config from metabase if needed
        else if (pAppln->FConfigNeedsUpdate())
            {
            // If debugging flag has changed, then restart the application
            BOOL fRestartAppln = FALSE;
            BOOL fFlushAll = FALSE;
            pAppln->UpdateConfig(m_pIReq, &fRestartAppln, &fFlushAll);

            if (fRestartAppln)
                {
                pAppln->Restart(TRUE);      // force a restart
                pAppln = NULL;

                if (fFlushAll)  // flush all can only happen when restart is TRUE
                    {
                    // do flush while unlocked
                    g_ApplnMgr.UnLock();
                    g_TemplateCache.FlushAll();
                    g_ApplnMgr.Lock();
                    }
                
                // Find again
                hr = g_ApplnMgr.FindAppln(szAppMDPath, &pAppln);

                // Reject if still restarting
                if (hr == S_OK && pAppln->FGlobalChanged())
                    {
                    *pfApplnRestarting = TRUE;
                    g_ApplnMgr.UnLock();
                    return E_FAIL;
                    }
                }
            else
                {
                // adjust sctipt killer timeout
                g_ScriptManager.AdjustScriptKillerTimeout
                    (
                    // application timeout / 2 (in ms)
                    pAppln->QueryAppConfig()->dwScriptTimeout() * 500
                    );
                }
            }
        }
        
    if (hr != S_OK) // Application NOT found
        {
        TCHAR *szAppPhysicalPath = GetSzAppPhysicalPath();
        if (!szAppPhysicalPath)
            {
            g_ApplnMgr.UnLock();
            return E_FAIL;
            }

        // try to create a new one
        hr = g_ApplnMgr.AddAppln
            (
            szAppMDPath, // metabase key 
            szAppPhysicalPath, 
            m_pIReq,
            m_hImpersonate,
            &pAppln
            );

        if (FAILED(hr))
            {
            g_ApplnMgr.UnLock();
            free (szAppPhysicalPath);
            return hr;
            }

        // Check for GLOBAL.ASA

        TCHAR szGlobalAsaPath[MAX_PATH*2];
        DWORD cchPath = _tcslen(szAppPhysicalPath);
        _tcscpy(szGlobalAsaPath, szAppPhysicalPath);

        // BUG FIX: 102010 DBCS code fixes
        //if (szGlobalAsaPath[cchPath-1] != '\\')
        if ( *CharPrev(szGlobalAsaPath, szGlobalAsaPath + cchPath) != _T('\\'))
            szGlobalAsaPath[cchPath++] = _T('\\');
            
        _tcscpy(szGlobalAsaPath+cchPath, SZ_GLOBAL_ASA);

        // Check if GLOBAL.ASA exists
        BOOL fGlobalAsaExists = FALSE;
        if (SUCCEEDED(AspGetFileAttributes(szGlobalAsaPath)))
            {
            fGlobalAsaExists = TRUE;
            }
        else if (GetLastError() == ERROR_ACCESS_DENIED)
            {
            // If the current user doesn't have access (could happen when
            // there's an ACL on directory) try under SYSTEM user
            
            if (m_hImpersonate)
                {
                RevertToSelf();
                if (SUCCEEDED(AspGetFileAttributes(szGlobalAsaPath)))
                    fGlobalAsaExists = TRUE;
                HANDLE hThread = GetCurrentThread();
                SetThreadToken(&hThread, m_hImpersonate);
                }
            }

        if (fGlobalAsaExists)
            pAppln->SetGlobalAsa(szGlobalAsaPath);

        // Start monitoring application directory to
        // catch changes to GLOBAL.ASA even if it's not there
        if (FIsWinNT())
            {
            g_FileAppMap.AddFileApplication(szGlobalAsaPath, pAppln);
            CASPDirMonitorEntry *pDME = NULL;
            if (RegisterASPDirMonitorEntry(szAppPhysicalPath, &pDME, TRUE))
                pAppln->AddDirMonitorEntry(pDME);
            }

        free(szAppPhysicalPath);
        szAppPhysicalPath = NULL;

        // Update config from registry - don't care about restart
        // application is fresh baked
        pAppln->UpdateConfig(m_pIReq);

        // Adjust script killer timeout to current application
        g_ScriptManager.AdjustScriptKillerTimeout
            (
            // application timeout / 2 (in ms)
            pAppln->QueryAppConfig()->dwScriptTimeout() * 500
            );
        }

    // We have an application at this point
    Assert(pAppln);
    m_pAppln = pAppln;

    // Increment request count before releasing ApplMgr lock
    // to make sure it will not remove the app from under us
    m_pAppln->IncrementRequestCount();

    // Unlock the application manager
    g_ApplnMgr.UnLock();

    return S_OK;
    }
    
/*===================================================================
CHitObj::AssignSessionToBrowserRequest

Find or create a new session for this browser request
Does the session manager locking

Parameters:
    pfNewSession        [out] flag - new session created
    pfNewCookie         [out] flag - new cookie crated
    pErrorId            [out] -- error ID if failed

Returns:
    HRESULT
===================================================================*/
HRESULT CHitObj::AssignSessionToBrowserRequest
(
BOOL *pfNewSession,
BOOL *pfNewCookie,
int  *pErrorId
)
    {
    Assert(pfNewSession);
    Assert(pfNewCookie);
    
    Assert(!m_pSession);

    // Local vars

    BOOL fTooManySessions = FALSE;
    BOOL fUseNewSession = FALSE;
    BOOL fUseOldSession = FALSE;
    BOOL fUseNewCookie = FALSE;
    
    CSession *pNewSession = NULL; // newly created
    CSession *pOldSession = NULL; // existing session that is found
    
    BOOL fReuseIdAndCookie = FALSE;
    BOOL fValidId = g_SessionIdGenerator.IsValidId(m_SessionId.m_dwId);

    HRESULT hr = S_OK;

    CSessionMgr *pSessionMgr = m_pAppln->PSessionMgr();

    while (1)
        {
        // Try to find session by Id

        if (fValidId)
            {
            pSessionMgr->LockMaster();
            
            pOldSession = NULL;
            HRESULT hrFind = pSessionMgr->FindInMasterHash
                (
                m_SessionId,
                &pOldSession
                );

            // Good old Session?
            if (hrFind == S_OK) // QFE has this condition as hrFind == NOERROR  
                {
                Assert(pOldSession);

                // If AspKeepSessionIDSecure is set in metabase and
                // they are going from a nonsecure to a secure connection then 
                // transition the user from their old http sessionid to their
                // new https secure session id
                if (QueryAppConfig()->fKeepSessionIDSecure() &&
                    FSecure() &&
                    !pOldSession->FSecureSession()
                    )
                {
                    // Generate New Cookie
                    hr = pSessionMgr->GenerateIdAndCookie
                        (
                        &m_SessionId,
                        m_szSessionCookie
                        );
                            
                    if (SUCCEEDED(hr))
                    {
                        hr = pSessionMgr->ChangeSessionId(pOldSession,m_SessionId);
                    }            

                    if (FAILED(hr))
                    {
                        pSessionMgr->UnLockMaster();
                        break;
                    }

                    pOldSession->SetSecureSession(TRUE);
                    fUseNewCookie = TRUE;                    
                }
                
                // Increment request count before unlock to avoid 
                // deletion of the session by other threads
                pOldSession->IncrementRequestsCount();
                pSessionMgr->UnLockMaster();
                fUseOldSession = TRUE;
                break;
                }

            // Bad old Session?
            else if (pOldSession)
                {
                pSessionMgr->UnLockMaster();
                fValidId = FALSE;
                }

            // No old session and we have a new session to insert?
            else if (pNewSession)
                {
                hr = pSessionMgr->AddToMasterHash(pNewSession);
                    
                if (SUCCEEDED(hr))
                    {
                    // Increment request count before unlock to avoid 
                    // deletion of the session by other threads
                    pNewSession->IncrementRequestsCount();
                    fUseNewSession = TRUE;
                    }
                pSessionMgr->UnLockMaster();
                break;
                }

            // No old session and no new session
            else
                {
                pSessionMgr->UnLockMaster();

                if (FSecure () && QueryAppConfig()->fKeepSessionIDSecure())
                    {
                        fValidId = FALSE;
                    }                
                }
            }

        // Generate id and cookie when needed

        if (!fValidId)  // 2nd time generate new id
            {
            hr = pSessionMgr->GenerateIdAndCookie
                (
                &m_SessionId,
                m_szSessionCookie
                );
            if (FAILED(hr))
                break;
            fValidId = TRUE;
            fUseNewCookie = TRUE;
            }
        
        // Create new session object if needed

        if (!pNewSession)
            {
            // Enforce the session limit for the application
            DWORD dwSessionLimit = m_pAppln->QueryAppConfig()->dwSessionMax();
            if (dwSessionLimit != 0xffffffff && dwSessionLimit != 0 &&
                m_pAppln->GetNumSessions() >= dwSessionLimit)
                {
                fTooManySessions = TRUE;
                hr = E_FAIL;
                break;
                }

            hr = pSessionMgr->NewSession(m_SessionId, &pNewSession);
            if (FAILED(hr))
                break;
            }
        else
            {
            // Assign new id to already created new session
            pNewSession->AssignNewId(m_SessionId);
            }

        // continue with the loop
        }

    // the results

    if (fUseNewSession)
        {
        Assert(SUCCEEDED(hr));
        Assert(pNewSession);

        m_pSession = pNewSession;
        m_pSession->SetSecureSession(FSecure());
        pNewSession = NULL;  // not to be deleted later
        }
    else if (fUseOldSession)
        {
        Assert(SUCCEEDED(hr));
        Assert(pOldSession);
        
        m_pSession = pOldSession;
        }
    else
        {
        Assert(FAILED(hr));
        
        *pErrorId = fTooManySessions ? IDE_TOO_MANY_USERS : IDE_ADD_SESSION;
        }
        
    // cleanup new session if unused
    if (pNewSession)
        {
        pNewSession->UnInit();
        pNewSession->Release();
        pNewSession = NULL;
        }

    if (m_pSession && m_pSession->FCodePageSet()) {
        m_uCodePage = m_pSession->GetCodePage();
    }
    else {
        m_uCodePage = PAppln()->QueryAppConfig()->uCodePage();
    }

    if (m_pSession && m_pSession->FLCIDSet()) {
        m_lcid = m_pSession->GetLCID();
    }
    else {
        m_lcid = PAppln()->QueryAppConfig()->uLCID();
    }

    // return flags
    *pfNewSession = fUseNewSession;
    *pfNewCookie  = fUseNewCookie;
    return hr;
    }

/*===================================================================
CHitObj::DetachBrowserRequestFromSession

Removes session from browser request.
Does session clean-up when needed

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CHitObj::DetachBrowserRequestFromSession()
    {
    Assert(m_pSession);
    Assert(m_pSession->PAppln());

    if (IsShutDownInProgress() || m_pSession->FInTOBucket())
        {
        // nothing fancy on shutdown
        
        // or if the session is still in the timeout bucket
        // (could happen for rejected requests)
        
        m_pSession->DecrementRequestsCount();
        m_pSession = NULL;
        return S_OK;
        }
        
    CSessionMgr *pSessionMgr = m_pSession->PAppln()->PSessionMgr();
    Assert(pSessionMgr);

     // try to delete this session if this is the last pending request
    if (m_pSession->GetRequestsCount() == 1)
        {
        // convert to lightweight if possible
        m_pSession->MakeLightWeight();

        // check if need to delete now
        if (m_pSession->FShouldBeDeletedNow(TRUE))
            {
            pSessionMgr->LockMaster();

            // check if still need to delete now after locking
            if (m_pSession->FShouldBeDeletedNow(TRUE))
                {
                pSessionMgr->RemoveFromMasterHash(m_pSession);
                pSessionMgr->UnLockMaster();
                
                m_pSession->DecrementRequestsCount();
                pSessionMgr->DeleteSession(m_pSession, TRUE);
                m_pSession = NULL;
                return S_OK;
                }

            pSessionMgr->UnLockMaster();
            }
        }

    // We can end up here for a rejected requests only if there are
    // other (non-rejected) requests for this session.
    //
    // The category of rejected here does not include rejected because
    // of the RequestQueueMax. This only applies to real OOM situations.
    //
    // In case of rejected request or if there are other pending
    // requests for this, session these other requests will take
    // care of reinserting the session into the timeout bucket.
    //
    // Rejected requests are NOT serialized -- they don't run on Viper
    // threads. Inserting the session into a timeout bucket for a
    // rejected request might create a race condition with regular requests.
    
    if (!m_fRejected && m_pSession->GetRequestsCount() == 1)
        {
        // Insert into proper timeout bucket
        if (pSessionMgr->FIsSessionKillerScheduled())
            {
            pSessionMgr->UpdateSessionTimeoutTime(m_pSession);
            pSessionMgr->AddSessionToTOBucket(m_pSession);
            }
        }
    
    m_pSession->DecrementRequestsCount();

    // session is no longer attached to the request
    m_pSession = NULL;
    
    return S_OK;
    }

/*===================================================================
void CHitObj::SessionCleanupInit

Initialize a request object for session cleanup

Parameters:
    CSession *pSession      Session object context

Returns:
    NONE
===================================================================*/
void CHitObj::SessionCleanupInit
(
CSession * pSession
)
    {
    m_ehtType = ehtSessionCleanup;
    InterlockedIncrement((LPLONG)&g_nSessionCleanupRequests);

    HRESULT hr = InitComponentProcessing();
    if (FAILED(hr))
        {
        if (hr == E_OUTOFMEMORY)
            HandleOOMError(NULL, NULL);
        }

    m_pSession      = pSession;
    m_pAppln        = pSession->PAppln();
    m_fRunGlobalAsa = TRUE;
    m_pIReq          = NULL;

    if (m_pAppln->PSessionMgr())
        m_pAppln->PSessionMgr()->IncrementSessionCleanupRequestCount();

    m_fInited = TRUE;
    }

/*===================================================================
void CHitObj::ApplicationCleanupInit

Initializes a request object for application cleanup

Parameters:
    CAppln *        pAppln      Application object context

Returns:
    NONE
===================================================================*/
void CHitObj::ApplicationCleanupInit( CAppln * pAppln )
{
    m_ehtType = ehtApplicationCleanup;
    InterlockedIncrement((LPLONG)&g_nApplnCleanupRequests);

    // If OOM here, then cleanup request does not get a server object.
    HRESULT hr = InitComponentProcessing();
    if (FAILED(hr))
        {
        if (hr == E_OUTOFMEMORY)
            HandleOOMError(NULL, NULL);
        }
        
    m_pAppln = pAppln;
    m_fRunGlobalAsa = TRUE;
    m_pIReq = NULL;

    m_fInited = TRUE;
}

/*===================================================================
CHitObj::ReassignAbandonedSession

Reassign ID of a the session being abandonded thus
detaching it from the client

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CHitObj::ReassignAbandonedSession()
    {
    HRESULT hr = E_FAIL;
    
    Assert(m_pSession);
    Assert(m_pAppln);
    m_pAppln->AssertValid();

    hr = m_pAppln->PSessionMgr()->GenerateIdAndCookie
        (
        &m_SessionId,
        m_szSessionCookie
        );

    if (SUCCEEDED(hr))
        {
        hr = m_pAppln->PSessionMgr()->ChangeSessionId
            (
            m_pSession,
            m_SessionId
            );
        }
                            
    return hr;
    }

/*===================================================================
void CHitObj::FObjectTag

Check if the object passed in as argument is an object tag
created object.

Parameters:
    IDispatch * pDispatch   pointer to object

Returns:
    TRUE    Is a object tag created object
    FALSE   Otherwise
===================================================================*/
BOOL CHitObj::FObjectTag( IDispatch * pDispatch )
{
    if (!m_pPageObjMgr)
        return FALSE;
        
    BOOL fRet = TRUE;

    CComponentObject *pObj = NULL;
    HRESULT hr = m_pPageObjMgr->
        FindAnyScopeComponentByIDispatch(pDispatch, &pObj);

    return (SUCCEEDED(hr) && pObj);
}

/*  buffer allows space for: <user cookie>  +    CCH_SESSION_ID_COOKIE  +   =   +   <cookie>        +   '\0')
                                50          +       20                  +   1   +   SESSIONID_LEN   +   1
    NOTE we arbitrarily allow 50 bytes for <user cookie>
    NOTE if CCH_SESSION_ID_COOKIE changes, CCH_BUFCOOKIES_DEFAULT must be changed accordingly
*/
#define CCH_BUFCOOKIES_DEFAULT  72 + SESSIONID_LEN

/*===================================================================
CHitObj::ParseCookiesForSessionIdAndFlags

Extracts Cookie from CIsapiReqInfo.

Parameters:

Side Effects:
    Initializes m_SessionId, m_SessionIdR1, m_SessionIdR2 and
                m_szSessionCookie
    Sets m_fClientCodeDebug flag

Returns:
    S_OK        Extracted cookie value successfully
    S_FALSE     Success, but no cookie found
    other       error
===================================================================*/
HRESULT CHitObj::ParseCookiesForSessionIdAndFlags()
    {
    Assert(m_pAppln);
    CAppConfig *pAppConfig = m_pAppln->QueryAppConfig();
    
    // Are we interested in ANY cookies?

    if (!pAppConfig->fAllowSessionState() && 
        !pAppConfig->fAllowClientDebug())
        return S_OK;

    // If session cookie is needed init it

    if (pAppConfig->fAllowSessionState())
        {
        m_SessionId.m_dwId = INVALID_ID;
        m_szSessionCookie[0] = '\0';
        }

    // Get cookies from WAM_EXEC_INFO
    char *szBufCookies = m_pIReq->QueryPszCookie();
    if (!szBufCookies || !*szBufCookies)
        return S_OK; // no cookies

    // Obtain Session Cookie (and ID) if needed
        
    if (pAppConfig->fAllowSessionState())
        {
        char *pT;

        if (pT = strstr(szBufCookies, g_szSessionIDCookieName))
            {
            pT += CCH_SESSION_ID_COOKIE;
            if (*pT == '=')
                {
                pT++;
                if (strlen( pT ) >= SESSIONID_LEN)
                    {
                    memcpy(m_szSessionCookie, pT, SESSIONID_LEN);
                    m_szSessionCookie[SESSIONID_LEN] = '\0';
                    }
                }
            }

        // validate and try to decode the session id cookie
        if (m_szSessionCookie[0] != '\0')
            {
            if (FAILED(DecodeSessionIdCookie
                    (
                    m_szSessionCookie,
                    &m_SessionId.m_dwId, 
                    &m_SessionId.m_dwR1,
                    &m_SessionId.m_dwR2
                    )))
                {
                m_SessionId.m_dwId = INVALID_ID;
                m_szSessionCookie[0] = '\0';
                }
            }
        }

    // Look for Client Debug enabling cookie

    if (pAppConfig->fAllowClientDebug())
        {
        if (strstr(szBufCookies, SZ_CLIENT_DEBUG_COOKIE"="))
            m_fClientCodeDebug = TRUE;
        }

    return S_OK;
    }

/*===================================================================
BOOL CHitObj::GetSzAppPhysicalPath

Extracts application directory from WAM_EXEC_INFO

Parameters:

Side Effects:
On success, allocate memory for pszAppPhysicalPath

Returns:
    TRUE        AppPhysicalPath
    FALSE       NULL
===================================================================*/
TCHAR *CHitObj::GetSzAppPhysicalPath()
{
    DWORD  dwSizeofBuffer = 265*sizeof(TCHAR);
    TCHAR  *pszAppPhysicalPathLocal = (TCHAR *)malloc(dwSizeofBuffer);
    CHAR   *pszApplPhysPathVarName;

    if (!pszAppPhysicalPathLocal)
        return NULL;

#if UNICODE
    pszApplPhysPathVarName = "UNICODE_APPL_PHYSICAL_PATH";
#else
    pszApplPhysPathVarName = "APPL_PHYSICAL_PATH";
#endif

    BOOL fFound = m_pIReq->GetServerVariable
        (
        pszApplPhysPathVarName, 
        pszAppPhysicalPathLocal, 
        &dwSizeofBuffer
        );

    if (!fFound)
        {
        DWORD dwErr = GetLastError();

        if (ERROR_INSUFFICIENT_BUFFER == dwErr)
            {
            // Not Enough Buffer
            free(pszAppPhysicalPathLocal);
            pszAppPhysicalPathLocal = (TCHAR *)malloc(dwSizeofBuffer);
            if (pszAppPhysicalPathLocal)
                {
                // Try again
                fFound = m_pIReq->GetServerVariable
                    (
                    pszApplPhysPathVarName, 
                    pszAppPhysicalPathLocal, 
                    &dwSizeofBuffer
                    );
                }
            }
        }

    if (!fFound) {
        if (pszAppPhysicalPathLocal) {
            free(pszAppPhysicalPathLocal);
            pszAppPhysicalPathLocal = NULL;
        }
    }
    else
        {
        Assert(pszAppPhysicalPathLocal);
        Normalize(pszAppPhysicalPathLocal);
        }

    return pszAppPhysicalPathLocal;
    }

/*===================================================================
CHitObj::InitComponentProcessing

Creates and inits component collection and page object manager

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CHitObj::InitComponentProcessing()
    {
    Assert(!m_pPageCompCol);
    Assert(!m_pPageObjMgr);

    HRESULT hr = S_OK;

    // Page component collection

    m_pPageCompCol = new CComponentCollection;
    if (!m_pPageCompCol)
        return E_OUTOFMEMORY;

    hr = m_pPageCompCol->Init(csPage);
    if (FAILED(hr))
        return hr;

    // Page object manager
        
    m_pPageObjMgr = new CPageComponentManager;
    if (!m_pPageObjMgr)
        return E_OUTOFMEMORY;

    hr = m_pPageObjMgr->Init(this);
    if (FAILED(hr))
        return hr;

    return S_OK;
    }

/*===================================================================
CHitObj::StopComponentProcessing

Deletes component collection and page object manager

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CHitObj::StopComponentProcessing()
    {
    if (m_pPageObjMgr)
        {
        delete m_pPageObjMgr;
        m_pPageObjMgr = NULL;
        }

    if (m_pPageCompCol)
        {
        delete m_pPageCompCol;
        m_pPageCompCol = NULL;
        }

    if (m_punkScriptingNamespace)
        {
        m_punkScriptingNamespace->Release();
        m_punkScriptingNamespace = NULL;
        }
        
    return S_OK;
    }
    
/*===================================================================
CHitObj::GetPageComponentCollection

Returns component collection for page

Parameters:
    CComponentCollection **ppCollection     output

Returns:
    HRESULT
===================================================================*/
HRESULT CHitObj::GetPageComponentCollection
(
CComponentCollection **ppCollection
)
    {
    *ppCollection = m_pPageCompCol;
    return (*ppCollection) ? S_OK : TYPE_E_ELEMENTNOTFOUND;
    }

/*===================================================================
CHitObj::GetSessionComponentCollection

Returns component collection for session

Parameters:
    CComponentCollection **ppCollection     output

Returns:
    HRESULT
===================================================================*/
HRESULT CHitObj::GetSessionComponentCollection
(
CComponentCollection **ppCollection
)
    {
    if (m_pSession)
        {
        *ppCollection = m_pSession->PCompCol();

        if (*ppCollection == NULL             &&  // no collection
            m_eEventState != eEventAppOnStart &&  // not an application
            m_eEventState != eEventAppOnEnd)      //       level event
            {
            // init session collection on demand
            HRESULT hr = m_pSession->CreateComponentCollection();
            if (SUCCEEDED(hr))
                *ppCollection = m_pSession->PCompCol();
            }
        }
    else
        *ppCollection = NULL;
        
    return (*ppCollection) ? S_OK : TYPE_E_ELEMENTNOTFOUND;
    }

/*===================================================================
CHitObj::GetApplnComponentCollection

Returns component collection for application

Parameters:
    CComponentCollection **ppCollection     output

Returns:
    HRESULT
===================================================================*/
HRESULT CHitObj::GetApplnComponentCollection
(
CComponentCollection **ppCollection
)
    {
    if (m_pAppln)
        *ppCollection = m_pAppln->PCompCol();
    else
        *ppCollection = NULL;
        
    return (*ppCollection) ? S_OK : TYPE_E_ELEMENTNOTFOUND;
    }

/*===================================================================
CHitObj::AddComponent

Adds uninstantiated tagged object to appropriate
component collection

Parameters:
    CompType  type
    const CLSID &clsid
    CompScope scope
    CompModel model
    LPWSTR     pwszName
    IUnknown  *pUnk

Returns:
    HRESULT
===================================================================*/
HRESULT CHitObj::AddComponent
(
CompType  type,
const CLSID &clsid,
CompScope scope,
CompModel model,
LPWSTR    pwszName,
IUnknown *pUnk
)
    {
    Assert(m_pPageObjMgr);
    m_pPageObjMgr->AssertValid();
 
    Assert(type == ctTagged);
    
    HRESULT hr = m_pPageObjMgr->AddScopedTagged
        (
        scope, 
        pwszName,
        clsid,
        model
        );

    return hr;
    }

/*===================================================================
CHitObj::GetComponent

Finds CComponentObject by scope and name

Parameters:
    CompScope         scope        can be csUnknown
    LPWSTR            pwszName     name to find
    DWORD             cbName       name length (in bytes)
    CComponentObject **ppObj       (out) object found

Returns:
    HRESULT     S_OK on success
                TYPE_E_ELEMENTNOTFOUND if the object wasnt found
                Other HRESULT if object fails to instantiate
===================================================================*/
HRESULT CHitObj::GetComponent
(
CompScope          scope, 
LPWSTR             pwszName, 
DWORD              cbName,
CComponentObject **ppObj
)
    {
    Assert(ppObj);
    *ppObj = NULL;

    if (!m_pPageObjMgr)
        return TYPE_E_ELEMENTNOTFOUND;
    
    BOOL fNewInstance = FALSE;
    HRESULT hr = m_pPageObjMgr->GetScopedObjectInstantiated
        (
        scope,
        pwszName,
        cbName,
        ppObj,
        &fNewInstance
        );

	if (FAILED(hr))
		return hr;

    // If an object that restricts threading has been instantiateed
    // as the session's tagged <OBJECT>, and the session's activity
    // runs this request, then bind the session's activity to thread

    if ((*ppObj)->GetScope() == csSession  && // session scope component
        m_ecsActivityScope == csSession    && // session scope activity
        SUCCEEDED(hr)                      && // get object succeeded
        fNewInstance                       && // object was just instantiated
        *ppObj && !(*ppObj)->FAgile())      // the object is thread-locked
        {
        m_pSession->PActivity()->BindToThread();
        }

    return hr;
    }

/*===================================================================
CHitObj::GetIntrinsic

Finds Intrinsic by name

Parameters:
    LPWSTR            pwszName     name to find
    DWORD             cbName       name length (in bytes)
    IUnknown        **ppUnk        (out) object found

Returns:
    HRESULT     S_OK on success
                S_FALSE name of the instrinsic but it's missing
                TYPE_E_ELEMENTNOTFOUND if the object not found
===================================================================*/
HRESULT CHitObj::GetIntrinsic
(
LPWSTR     pwszName, 
DWORD      cbName,
IUnknown **ppUnk
)
    {
    Assert(ppUnk);
    *ppUnk = NULL;


    // Lookup table based on (wszName[0] - cbName) % 32
    // Works for both uppper and lower case names

    static enum IntrinsicType
        {
        itUnknown = 0,
        itObjContext,
        itNamespace,
        itAppln,
        itSession,
        itRequest,
        itResponse,
        itServer,
        itASPPageTLB,
        itASPGlobalTLB
        }
    rgitLookupEntries[] =
        {
        /* 0-1   */     itUnknown, itUnknown,
        /* 2     */ itResponse,
        /* 3     */     itUnknown,
        /* 4     */ itRequest,
        /* 5     */ itSession,
        /* 6     */     itUnknown,
        /* 7     */ itServer,
        /* 8     */     itUnknown,
        /* 9     */ itASPGlobalTLB,
        /* 10    */     itUnknown,
        /* 11    */ itAppln,
        /* 12    */     itUnknown,
        /* 13    */ itASPPageTLB,
        /* 14    */     itUnknown,
        /* 15    */ itNamespace,
        /* 16-20 */     itUnknown, itUnknown, itUnknown, itUnknown, itUnknown,
        /* 21    */ itObjContext,
        /* 22-31 */     itUnknown, itUnknown, itUnknown, itUnknown, itUnknown,
                        itUnknown, itUnknown, itUnknown, itUnknown, itUnknown
        };

    IntrinsicType itType = rgitLookupEntries
        [
        (pwszName[0] - cbName) & 0x1f   // &1f same as %32
        ];

    if (itType == itUnknown)  // most likely
        return TYPE_E_ELEMENTNOTFOUND;

    // Do the string comparison
    BOOL fNameMatch = FALSE;
    
    switch (itType)
        {
    case itNamespace:
        if (_wcsicmp(pwszName, WSZ_OBJ_SCRIPTINGNAMESPACE) == 0)
            {
            fNameMatch = TRUE;
            *ppUnk = m_punkScriptingNamespace;
            }
        break;

    case itResponse:
        if (_wcsicmp(pwszName, WSZ_OBJ_RESPONSE) == 0)
            {
            fNameMatch = TRUE;
            if (!m_fHideRequestAndResponseIntrinsics)
                *ppUnk = static_cast<IResponse *>(m_pResponse);
            }
        break;

    case itRequest:
        if (_wcsicmp(pwszName, WSZ_OBJ_REQUEST) == 0)
            {
            fNameMatch = TRUE;
            if (!m_fHideRequestAndResponseIntrinsics)
                *ppUnk = static_cast<IRequest *>(m_pRequest);
            }
        break;
        
    case itSession:
        if (_wcsicmp(pwszName, WSZ_OBJ_SESSION) == 0)
            {
            fNameMatch = TRUE;
            if (!m_fHideSessionIntrinsic)
                *ppUnk = static_cast<ISessionObject *>(m_pSession);
            }
        break;
        
    case itServer:
        if (_wcsicmp(pwszName, WSZ_OBJ_SERVER) == 0)
            {
            fNameMatch = TRUE;
            *ppUnk = static_cast<IServer *>(m_pServer);
            }
        break;
        
    case itAppln:
        if (_wcsicmp(pwszName, WSZ_OBJ_APPLICATION) == 0)
            {
            fNameMatch = TRUE;
            *ppUnk = static_cast<IApplicationObject *>(m_pAppln);
            }
        break;
        
    case itObjContext:
        if (_wcsicmp(pwszName, WSZ_OBJ_OBJECTCONTEXT) == 0) {

            // if there isn't an ASPObjectContext, then most likely
            // the asp script is asking for the object context on a 
            // non-transacted page.  Return the Dummy Object Context
            // which will allow ASP to return a friendly error saying
            // that ObjectContext is not available rather than
            // ELEMENT_NOT_FOUND.

            if (m_pASPObjectContext == NULL) {

                if (g_pIASPDummyObjectContext == NULL) {

                    CASPDummyObjectContext  *pContext = new CASPDummyObjectContext();

                    if (pContext == NULL) {
                        return E_OUTOFMEMORY;
                    }
                    g_pIASPDummyObjectContext = static_cast<IASPObjectContext *>(pContext);
                }
                *ppUnk = g_pIASPDummyObjectContext;
			}
            else {

                *ppUnk = static_cast<IASPObjectContext *>(m_pASPObjectContext);
            }
            fNameMatch = TRUE;
        }
        break;

    case itASPPageTLB:
        if (_wcsicmp(pwszName, WSZ_OBJ_ASPPAGETLB) == 0)
            {
            fNameMatch = TRUE;
            *ppUnk = m_pdispTypeLibWrapper;
            }
        break;

    case itASPGlobalTLB:
        if (_wcsicmp(pwszName, WSZ_OBJ_ASPGLOBALTLB) == 0)
            {
            fNameMatch = TRUE;
            *ppUnk = m_pAppln->PGlobTypeLibWrapper();
            }
        break;
        }

    if      (*ppUnk)        return S_OK;
    else if (fNameMatch)    return S_FALSE;
    else                    return TYPE_E_ELEMENTNOTFOUND;
    }

/*===================================================================
CHitObj::CreateComponent

Server.CreateObject calls this

Parameters:
    clsid       create of this CLSID
    ppDisp      return IDispatch*

Returns:
    HRESULT
===================================================================*/
HRESULT CHitObj::CreateComponent
(
const CLSID &clsid,
IDispatch **ppDisp
)
    {
    Assert(m_pPageObjMgr);

    CComponentObject *pObj = NULL;
    
    HRESULT hr = m_pPageObjMgr->AddScopedUnnamedInstantiated
        (
        csPage, 
        clsid, 
        cmUnknown,
        NULL,
        &pObj
        );
    if (FAILED(hr))
        {
        *ppDisp = NULL;
        return hr;
        }

    Assert(pObj);

    hr = pObj->GetAddRefdIDispatch(ppDisp);

    if (SUCCEEDED(hr))
        {
        // don't keep the object around unless needed
        if (pObj->FEarlyReleaseAllowed())
            m_pPageObjMgr->RemoveComponent(pObj);
        }

    return hr;
    }

/*===================================================================
CHitObj::SetPropertyComponent

Sets property value to variant

Parameters:
    CompScope         scope        property scope
    LPWSTR             pwszName     property name
    VARIANT            pVariant     property value to set

Returns:
    HRESULT
===================================================================*/
HRESULT CHitObj::SetPropertyComponent
(
CompScope scope,
LPWSTR     pwszName, 
VARIANT   *pVariant
)
    {
    if (!m_pPageObjMgr)
        return TYPE_E_ELEMENTNOTFOUND;

    CComponentObject *pObj = NULL;
    HRESULT hr = m_pPageObjMgr->AddScopedProperty(scope, pwszName, 
                                                  pVariant, &pObj);

    // If an object that restricts threading has been assigned as
    // the session property, and the session's activity runs this
    // request, then bind the session's activity to thread

    if (scope == csSession               && // session scope property
        m_ecsActivityScope == csSession  && // session scope activity
        SUCCEEDED(hr)                    && // set property succeed
        pObj && !pObj->FAgile())            // the object is thread-locked
        {
        m_pSession->PActivity()->BindToThread();
        }
        
    return hr;
    }

/*===================================================================
CHitObj::GetPropertyComponent

Finds property CComponentObject by scope and name

Parameters:
    CompScope         scope        wher to find
    LPWSTR             pwszName     name to find
    CComponentObject **ppObj        (out) object found

Returns:
    HRESULT     S_OK on success
                TYPE_E_ELEMENTNOTFOUND if the object wasnt found
                Other HRESULT
===================================================================*/
HRESULT CHitObj::GetPropertyComponent
(
CompScope         scope, 
LPWSTR             pwszName, 
CComponentObject **ppObj
)
    {
    *ppObj = NULL;
    
    if (!m_pPageObjMgr)
        return TYPE_E_ELEMENTNOTFOUND;

    return m_pPageObjMgr->GetScopedProperty(scope, pwszName, ppObj);
    }

/*===================================================================
CHitObj::SetActivity

Remember activity with CHitObj

Parameters
    CViperActivity *pActivity       Viper activity to remember
                                    (and later delete)

Returns:
    HRESULT
===================================================================*/
HRESULT CHitObj::SetActivity
(
CViperActivity *pActivity
)
    {
    Assert(!m_pActivity);
    m_pActivity = pActivity;
    return S_OK;
    }

/*===================================================================
CHitObj::PCurrentActivity

Returns Viper Activity, the current HitObj is running under

Parameters

Returns:
    CViperActivity *
===================================================================*/
CViperActivity *CHitObj::PCurrentActivity()
    {
    CViperActivity *pActivity = NULL;

    switch (m_ecsActivityScope)
        {
        case csPage:
            pActivity = m_pActivity;
            break;
        case csSession:
            Assert(m_pSession);
            pActivity = m_pSession->PActivity();
            break;
        case csAppln:
            Assert(m_pAppln);
            pActivity = m_pAppln->PActivity();
            break;
        }

    return pActivity;
    }

/*===================================================================
CHitObj::PostViperAsyncCall

Asks Viper to calls us back from the right thread to execute
the request.

Used instead of queueing

Returns:
    HRESULT

Side effects:
===================================================================*/
HRESULT CHitObj::PostViperAsyncCall()
    {
#ifndef PERF_DISABLE
    BOOL fDecrOnFail = FALSE;
    if (FIsBrowserRequest())
        {
        DWORD dwRequestQueued = g_PerfData.Incr_REQCURRENT();
#if 0 && defined(SCRIPT_STATS)
        if (g_dwQueueDebugThreshold != 0
            &&  dwRequestQueued >= g_dwQueueDebugThreshold)
            DebugBreak();
#endif
        fDecrOnFail = TRUE;
        }
#endif

    UpdateTimestamp();  // before posting into queue

    CViperActivity *pApplnAct = m_pAppln ?
        m_pAppln->PActivity() : NULL;
        
    CViperActivity *pSessnAct = m_pSession ?
        m_pSession->PActivity() : NULL;

    HRESULT hr;

    if (pApplnAct)
        {
        m_ecsActivityScope = csAppln;
        hr = pApplnAct->PostAsyncRequest(this);
        }
    else if (pSessnAct)
        {
        m_ecsActivityScope = csSession;
        hr = pSessnAct->PostAsyncRequest(this);
        }
    else
        {
        m_ecsActivityScope = csPage;
        hr = CViperActivity::PostGlobalAsyncRequest(this);
        }
        
#ifndef PERF_DISABLE
    if (FAILED(hr) && fDecrOnFail)
        g_PerfData.Decr_REQCURRENT();
#endif    

    return hr;
    }

/*===================================================================
CHitObj::ViperAsyncCallback

Viper calls us back from the right thread to execute
the request.

Used instead of queueing

Parameters
    BOOL       *pfRePosted   [out] flag TRUE if request re-posted
                             under diff activity (don't delete it)
  
Returns:
    HRESULT

Side effects:
===================================================================*/
HRESULT CHitObj::ViperAsyncCallback
(
BOOL *pfRePosted
)
    {
    HRESULT hr = S_OK;
    BOOL fTemplateInCache;
    
    *pfRePosted = FALSE;

    Assert(!m_fExecuting); // no nested executions of the same request
    m_fExecuting = TRUE;
    
    Assert(FIsValidRequestType());

    DWORD dwtWaitTime = ElapsedTimeSinceTimestamp();
    UpdateTimestamp();  // received from the queue

#ifndef PERF_DISABLE
    if (FIsBrowserRequest())
        {
        g_PerfData.Decr_REQCURRENT();
        g_PerfData.Set_REQWAITTIME(dwtWaitTime);
        }
#endif

    ///////////////////
    // Reject browser requests in certain situations
    
    if (FIsBrowserRequest())
        {
        BOOL fRejected = FALSE;
        RejectBrowserRequestWhenNeeded(dwtWaitTime, &fRejected);
        if (fRejected)
            return S_OK;
        }

    ///////////////////
    // Pass through the thread gate
    
    EnterThreadGate(m_dwtTimestamp);

    ///////////////////
    // Reject browser requests in certain situations
    
    if (FIsBrowserRequest() && IsShutDownInProgress())
        {
        BOOL fRejected = FALSE;
        RejectBrowserRequestWhenNeeded(dwtWaitTime, &fRejected);
        if (fRejected)
            return S_OK;
        }

    ///////////////////
    // Remove the session from it's timeout bucket 
    // while executing the request

    if (m_pSession && m_pSession->FInTOBucket())
        m_pAppln->PSessionMgr()->RemoveSessionFromTOBucket(m_pSession);

    ///////////////////
    // If there's an application level activity we need to make
    // sure this activity is bound to a thread. Could not bind it
    // before because it has to be Viper thread to bind to.

    CViperActivity *pApplnActivity = m_pAppln->PActivity();

    if (pApplnActivity && !pApplnActivity->FThreadBound())
        pApplnActivity->BindToThread();

    ///////////////////
    // Take care of first application request with GLOBAL.ASA
    // Lock application if needed

    BOOL fApplnLocked = FALSE;
    BOOL fFirstAppRequest = FALSE;

    if (FIsBrowserRequest() && m_pAppln->FHasGlobalAsa() &&
                              !m_pAppln->FFirstRequestRun())
        {
        m_pAppln->InternalLock();
        fApplnLocked = TRUE;

        if (!m_pAppln->FFirstRequestRun())
            {
            m_fStartApplication = TRUE;
            m_fRunGlobalAsa = TRUE;
            fFirstAppRequest = TRUE;
            }
        else
            {
            m_pAppln->InternalUnLock();
            fApplnLocked = FALSE;
            }
        }

    ///////////////////
    // Repost under a different activity if needed
    // (do it only after the first app request finished)

    if (!fApplnLocked) // if not processing first app request
        {
        CViperActivity *pSessnAct, *pApplnAct;
        CViperActivity *pRepostToActivity = NULL;
            
        switch (m_ecsActivityScope)
            {
            case csPage:
                // repost to session activity if any
                pSessnAct = m_pSession ? m_pSession->PActivity() : NULL;
                if (pSessnAct)
                    pRepostToActivity = pSessnAct;
                    
                // no break;
            case csSession:
                // repost to application activity if any
                pApplnAct = m_pAppln ? m_pAppln->PActivity() : NULL;
                if (pApplnAct)
                    pRepostToActivity = pApplnAct;
                    
                // no break;
            case csAppln:
                // never repost application activity request
                break;
            }

        if (pRepostToActivity)
            {
            LeaveThreadGate();   // notify the thead gate
            m_fExecuting = FALSE;  // before reposting to avoid nesting
            hr = pRepostToActivity->PostAsyncRequest(this);
            *pfRePosted = SUCCEEDED(hr);
            return hr;
            }
        }

    ///////////////////
    // Cleanup any scripting engines that need to be shut
    // down on this thread, if we are on a thread enabled
    // for debugging
 
    if (m_pAppln->FDebuggable() && FIsBrowserRequest())
        {
        Assert(m_ecsActivityScope == csAppln);
        g_ApplnMgr.CleanupEngines();
        if (!g_dwDebugThreadId)
            g_dwDebugThreadId = GetCurrentThreadId();
        }

    ///////////////////
    // Prepare intrinsics

    CIntrinsicObjects intrinsics;

    m_pServer = NULL;
    m_pResponse = NULL;
    m_pRequest = NULL;
    m_fHideRequestAndResponseIntrinsics = FALSE;
    m_fHideSessionIntrinsic = FALSE;
    m_punkScriptingNamespace = NULL;

    hr = intrinsics.Prepare(m_pSession);

    if (FAILED(hr))  // couldn't setup intrinsics
        {
        if (fApplnLocked)
            m_pAppln->InternalUnLock();
            
#ifndef PERF_DISABLE
        g_PerfData.Incr_REQFAILED();
        g_PerfData.Incr_REQERRORPERSEC();
#endif            
        LeaveThreadGate();   // notify the thead gate
        m_fExecuting = FALSE;
        
        if (FIsBrowserRequest())
            ReportServerError(IDE_SERVER_TOO_BUSY);
            
        return hr;
        }

    if (FIsBrowserRequest())
        {
        m_pResponse = intrinsics.PResponse();
        m_pRequest  = intrinsics.PRequest();
        }
        
    m_pServer = intrinsics.PServer();
    
    Assert(!FIsBrowserRequest() || m_pResponse);

    ///////////////////
    // Point session to this hit object

    if (m_pSession)
        m_pSession->SetHitObj(this);
        
    ///////////////////
    // Impersonate
    
    HANDLE hThread = GetCurrentThread();

    if (FIsBrowserRequest())
        {
        if (FIsWinNT())
            {
            if (!SetThreadToken(&hThread, m_hImpersonate))
                {
#ifdef DBG
                // for debug purposes, it is interesting to know what the error was
                DWORD err = GetLastError();
#endif

                ReportServerError(IDE_IMPERSONATE_USER);
                m_eExecStatus = eExecFailed;
                hr = E_FAIL;
                }
            }
        }

    ///////////////////
    // Make Scripting Context

    if (SUCCEEDED(hr))
        {
        Assert(!m_pScriptingContext);
        
        m_pScriptingContext = new CScriptingContext
            (
            m_pAppln,
            m_pSession,
            m_pRequest,
            m_pResponse,
            m_pServer
            );
            
        if (!m_pScriptingContext)
            hr = E_OUTOFMEMORY;
        }

    ///////////////////
    // Attach to Viper context flow
    
    if (SUCCEEDED(hr))
        {
        hr = ViperAttachIntrinsicsToContext
            (
            m_pAppln,
            m_pSession,
            m_pRequest,
            m_pResponse,
            m_pServer
            );
        }

    ///////////////////
    // Execute

    BOOL fSkipExecute = FALSE; // (need to skip if session-less)

    if (SUCCEEDED(hr))
        {
        CTemplate *pTemplate = NULL;

        if (FIsBrowserRequest())
            {
#ifndef PERF_DISABLE
            g_PerfData.Incr_REQBROWSEREXEC();
#endif
            // Init Response and Server for compiler errors
            m_pResponse->ReInit(m_pIReq, NULL, m_pRequest, NULL, NULL, this);
            m_pRequest->ReInit(m_pIReq, this);
            m_pServer->ReInit(m_pIReq, this);
            
            // Load the script - cache will AddRef
            hr = LoadTemplate(m_pIReq->QueryPszPathTranslated(), this, 
                              &pTemplate, intrinsics,
                              FALSE /* !GlobalAsa */, &fTemplateInCache);

            // In case of ACL on the file (or directory) make sure
            // we don't assume that AppOnStart succeeded on the
            // first try (without the correct impersonation). Setting
            // m_fApplnOnStartFailed will force another try, with the
            // correct impersonation.
            if (fFirstAppRequest && FAILED(hr))
                m_fApplnOnStartFailed = TRUE;

            // Take care of is session-less templates
            if (SUCCEEDED(hr) && !pTemplate->FSession())
                {
                
                // UNDONE - Remove the reposting logic. Bug 301311.
                //
                // The problem is that we will leak the wam request and 
                // cause all sorts of trouble with keep alives. It seems 
                // like a marginal cost to just allow the first request to
                // run on the session activity. We could also remove the
                // StartISAThreadBracket restriction on nesting, but that
                // seems like it might open up the door to making some
                // real errors.

                /*
                // The problem only occurs the first time the
                // template is loaded. After that there's a
                // look-ahead in BrowserRequestInit()
                
                // if the template wasn't cached before we could
                // be running on session activity
                if (m_ecsActivityScope == csSession)
                    {
                    // Repost with it's own activity
                    hr = NewBrowserRequest(m_pIReq);
                    fSkipExecute = TRUE;

                    // Mark this request as DONE_WITH_SESSION so that
                    // it will not be forced later. We don't need it
                    // because we posted another HitObj with the
                    // same WAM_EXEC_INFO
                    m_fDoneWithSession = TRUE;
                    }
                else 
                */
                
                if (m_pSession)
                    {
                    // Activity is alright (most likely 
                    // application level) but still there's
                    // a session attached -> hide it
                    m_fHideSessionIntrinsic = TRUE;
                    }
                }
                
            // Take care of the 449 processing (most likely already done on I/O thread)
            if (SUCCEEDED(hr) && !m_fDoneWithSession)
                {
                pTemplate->Do449Processing(this);
                if (m_fDoneWithSession)
                    fSkipExecute = TRUE;  // 449 sent the response
                }
            }

        if (SUCCEEDED(hr) && !fSkipExecute)
            {
            // Execute script
            MFS_START(memrfs)
            hr = Execute(pTemplate, this, intrinsics);
            MFS_END_HR(memrfs)
            
            // OnEndPage
            if (m_pPageObjMgr)
                m_pPageObjMgr->OnEndPageAllObjects();
            }

        // Release the template
        if (pTemplate)
            pTemplate->Release();

        if (FIsBrowserRequest())
            {
            if (!fSkipExecute)
                {
                // Flush response after completing execution
                m_pResponse->FinalFlush(hr);
                }

#ifndef PERF_DISABLE
            g_PerfData.Decr_REQBROWSEREXEC();
#endif
            }
        else if (FIsSessionCleanupRequest())
            {
            // Remove session
            if (m_pSession)
                {
                m_pSession->UnInit();
                m_pSession->Release();
                m_pSession = NULL;
                }
            }
        else if (FIsApplnCleanupRequest())
            {
            // Remove application
            if ( m_pAppln )
                {
                m_pAppln->UnInit();
                m_pAppln->Release();
                m_pAppln = NULL;
                }
            }
        }

    ///////////////////
    // Release Scripting Context
    
    if (m_pScriptingContext)
        {
        m_pScriptingContext->Release();
        m_pScriptingContext = NULL;
        }
        
    ///////////////////
    // Do The Perf Counters

#ifndef PERF_DISABLE
    DWORD dwtExecTime = ElapsedTimeSinceTimestamp();

    if (!fSkipExecute && FIsBrowserRequest())
        {
        g_PerfData.Incr_REQPERSEC();
        g_PerfData.Set_REQEXECTIME(dwtExecTime);
    
        switch (m_eExecStatus)
            {
        case eExecSucceeded:
            if (m_pResponse->FWriteClientError())
                {
                g_PerfData.Incr_REQCOMFAILED();
                g_PerfData.Incr_REQERRORPERSEC();
                }
            else
                {
                g_PerfData.Incr_REQSUCCEEDED();
                }
            break;
            
        case eExecFailed:
            if (hr == E_USER_LACKS_PERMISSIONS)
                {
                g_PerfData.Incr_REQNOTAUTH();
                }
            else if (FIsPreprocessorError(hr))
                {
                g_PerfData.Incr_REQERRPREPROC();
                }
            else if (m_fCompilationFailed)
                {
                g_PerfData.Incr_REQERRCOMPILE();
                }
            else
                {
                g_PerfData.Incr_REQERRRUNTIME();
                }
        
            g_PerfData.Incr_REQFAILED();
            g_PerfData.Incr_REQERRORPERSEC();
            break;
            
        case eExecTimedOut:
            g_PerfData.Incr_REQTIMEOUT();
            break;
            }
        }
#endif    

    ///////////////////
    // Cleanup after first application request
    
    if (fFirstAppRequest && !m_fApplnOnStartFailed && !fSkipExecute)
        m_pAppln->SetFirstRequestRan();

    if (fApplnLocked)
        m_pAppln->InternalUnLock();
    
    ///////////////////
    // make sure script didn't leave application locked

    if (!FIsApplnCleanupRequest())
        m_pAppln->UnLockAfterRequest();

    ///////////////////
    // In order not to refer to intrinsics later
    // remove page component collection
    
    StopComponentProcessing();

	// Unset the impersonation
	if (FIsWinNT())
		SetThreadToken(&hThread, NULL);
                
    ///////////////////
    // Point session to NULL HitObj

    if (m_pSession)
        m_pSession->SetHitObj(NULL);

    LeaveThreadGate();   // notify the thead gate
    m_fExecuting = FALSE;
    
    return hr;
    }

/*===================================================================
CHitObj::ExecuteChildRequest

Executes child browser request

Parameters:
    fTransfer       -- flag -- End execution after this
    szTemplate      -- filename of the template to execute
    szVirtTemplate  -- virt path to template

Returns:
    S_OK
===================================================================*/
HRESULT CHitObj::ExecuteChildRequest
(
BOOL fTransfer, 
TCHAR *szTemplate,
TCHAR *szVirtTemplate
)
    {
    HRESULT hr = S_OK;

    // Prepare the new intrinsics structure (with the new scripting namespace)
    CIntrinsicObjects intrinsics;
    intrinsics.PrepareChild(m_pResponse, m_pRequest, m_pServer);
    
    TCHAR *saved_m_szCurrTemplateVirtPath = m_szCurrTemplateVirtPath;
    TCHAR *saved_m_szCurrTemplatePhysPath = m_szCurrTemplatePhysPath;
    // these two fields used for compilation and error reporting
    m_szCurrTemplateVirtPath = szVirtTemplate;
    m_szCurrTemplatePhysPath = szTemplate;
    
    // Load the template from cache
    CTemplate *pTemplate = NULL;
    BOOL fTemplateInCache;
    hr = g_TemplateCache.Load(FALSE, szTemplate, DWInstanceID(), this, &pTemplate, &fTemplateInCache);

    if (FAILED(hr))
        {
        if (pTemplate)
            {
            pTemplate->Release();
            pTemplate = NULL;
            }

        m_szCurrTemplateVirtPath = saved_m_szCurrTemplateVirtPath;
        m_szCurrTemplatePhysPath = saved_m_szCurrTemplatePhysPath;

        // to tell the server object to display the correct error message
        return E_COULDNT_OPEN_SOURCE_FILE;
        }

    // Save HitObj's execution state info
    CComponentCollection  *saved_m_pPageCompCol           = m_pPageCompCol;
    CPageComponentManager *saved_m_pPageObjMgr            = m_pPageObjMgr;
    IUnknown              *saved_m_punkScriptingNamespace = m_punkScriptingNamespace;
    ActiveEngineInfo      *saved_m_pEngineInfo            = m_pEngineInfo;
    IDispatch             *saved_m_pdispTypeLibWrapper    = m_pdispTypeLibWrapper;

    CTemplate *saved_pTemplate = m_pResponse->SwapTemplate(pTemplate);
    void *saved_pvEngineInfo   = m_pResponse->SwapScriptEngineInfo(NULL);

    // Re-Init the saved state
    m_pPageCompCol = NULL;
    m_pPageObjMgr = NULL;
    m_punkScriptingNamespace = NULL;
    m_pEngineInfo = NULL;
    m_pdispTypeLibWrapper = NULL;

    // Create child request components framework
    hr = InitComponentProcessing();

    // Execute
    if (SUCCEEDED(hr))
        {
		// Set status code to 500 in error cases.
		if (FHasASPError())
			m_pResponse->put_Status(L"500 Internal Server Error");

        // Execute [child] script
        hr = ::Execute(pTemplate, this, intrinsics, TRUE);
        
        // OnEndPage
        if (m_pPageObjMgr)
            m_pPageObjMgr->OnEndPageAllObjects();
        }

    // Clean-out new components framework
    StopComponentProcessing();

    // Restore HitObj's execution state info
    m_pPageCompCol           = saved_m_pPageCompCol;
    m_pPageObjMgr            = saved_m_pPageObjMgr;
    m_punkScriptingNamespace = saved_m_punkScriptingNamespace;
    m_pEngineInfo            = saved_m_pEngineInfo;
    SetTypeLibWrapper(saved_m_pdispTypeLibWrapper);
    m_pResponse->SwapTemplate(saved_pTemplate);
    m_pResponse->SwapScriptEngineInfo(saved_pvEngineInfo);
    m_szCurrTemplateVirtPath = saved_m_szCurrTemplateVirtPath;
    m_szCurrTemplatePhysPath = saved_m_szCurrTemplatePhysPath;

    // Cleanup
    if (pTemplate)
        pTemplate->Release();

    if (m_pResponse->FResponseAborted() || fTransfer || FHasASPError())
        {
        // propagate Response.End up the script engine chain
        m_pResponse->End();
        }

    // Done
    return hr;
    }

/*===================================================================
CHitObj::GetASPError

Get ASP Error object. Used for Server.GetLastError()

Parameters
    ppASPError  [out] addref'd error object (new or old)
    
Returns
    HRESULT
===================================================================*/
HRESULT CHitObj::GetASPError
(
IASPError **ppASPError
)
    {
    Assert(ppASPError);
    
    if (m_pASPError == NULL)
        {
        // return bogus one
        *ppASPError = new CASPError;
        return (*ppASPError != NULL) ? S_OK : E_OUTOFMEMORY;
        }
        
    m_pASPError->AddRef();      // return addref'd
    *ppASPError = m_pASPError;
    return S_OK;
    }

/*===================================================================
CHitObj::RejectBrowserRequestWhenNeeded

Request reject-before-execution-started logic

Parameters:
    dwtQueueWaitTime    time request waited in the queue, ms
    pfRejected          OUT flag -- TRUE if rejected

Returns:
    S_OK
===================================================================*/
HRESULT CHitObj::RejectBrowserRequestWhenNeeded
(
DWORD dwtQueueWaitTime,
BOOL *pfRejected
)
    {
    Assert(FIsBrowserRequest());
    
    UINT wError = 0;
    
    // If shutting down
    if (IsShutDownInProgress())
        {
        wError = IDE_SERVER_SHUTTING_DOWN;
        }
        
    // If waited long enough need to check if still connected
    if (wError == 0)
        {
        DWORD dwConnTestSec = m_pAppln->QueryAppConfig()->dwQueueConnectionTestTime();
        
        if (dwConnTestSec != 0xffffffff && dwConnTestSec != 0)
            {
            if (dwtQueueWaitTime > (dwConnTestSec * 1000))
                {
                BOOL fConnected = TRUE;
                if (m_pIReq)
                    m_pIReq->TestConnection(&fConnected);

                // if client disconnected -- respond with 'Server Error'
                if (!fConnected)
                    {
                    wError = IDE_500_SERVER_ERROR;
#ifndef PERF_DISABLE
                    g_PerfData.Incr_REQCOMFAILED();
#endif                    
                    }
                }
            }
        }
    
    // If waited too long -- reject
    if (wError == 0)
        {
        DWORD dwTimeOutSec = m_pAppln->QueryAppConfig()->dwQueueTimeout();
        
        if (dwTimeOutSec != 0xffffffff && dwTimeOutSec != 0)
            {
            if (dwtQueueWaitTime > (dwTimeOutSec * 1000))
                {
                wError = IDE_SERVER_TOO_BUSY;
#ifndef PERF_DISABLE
                g_PerfData.Incr_REQREJECTED();
#endif
                }
            }
        }

    if (wError)
        {
        m_fExecuting = FALSE; // before 'report error' to disable transfer
        ReportServerError(wError);
        *pfRejected = TRUE;
        }
    else
        {
        *pfRejected = FALSE;
        }

    return S_OK;
    }

/*===================================================================
CHitObj::ReportServerError

Report server error without using the response object

Parameters:
    ErrorID     error message id

Returns:

Side effects:
    None.
===================================================================*/
HRESULT CHitObj::ReportServerError
(
UINT ErrorId
)
    {
    // do nothing on non-browser requests or if no WAM_EXEC_INFO
    if (!FIsBrowserRequest() || m_pIReq == NULL)
        return S_OK;

    DWORD dwRequestStatus = HSE_STATUS_ERROR;

    if (ErrorId)
        {
        Handle500Error(ErrorId, m_pIReq);
        }
            
    m_pIReq->ServerSupportFunction
        (
        HSE_REQ_DONE_WITH_SESSION,
        &dwRequestStatus,
        0,
        NULL
        );

    SetDoneWithSession();
    return S_OK;
    }

#ifdef DBG
/*===================================================================
CHitObj::AssertValid

Test to make sure that the CHitObj object is currently correctly formed
and assert if it is not.

Returns:

Side effects:
    None.
===================================================================*/
VOID CHitObj::AssertValid() const
    {
    Assert(m_fInited);
    Assert(FIsValidRequestType());
    if (FIsBrowserRequest())
        {
        Assert(m_pIReq != NULL);
        Assert(m_pPageCompCol != NULL );
        Assert(m_pPageObjMgr != NULL);
        }
    }
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\hostinfo.h ===
#ifndef HOST_INFO_H_INCLUDED
#define HOST_INFO_H_INCLUDED

// {1D044690-8923-11d0-ABD2-00A0C911E8B2}
const GUID IID_IHostInfoUpdate =
{ 0x1d044690, 0x8923, 0x11d0, { 0xab, 0xd2, 0x0, 0xa0, 0xc9, 0x11, 0xe8, 0xb2 } };

enum hostinfo
{
	hostinfoLocale = 0,
	hostinfoCodePage = 1
};

class IHostInfoUpdate : public IUnknown
{

	public:

	// *** IUnknown Methods ***
	STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj) = 0;
	STDMETHOD_(ULONG,AddRef)(void) = 0;
	STDMETHOD_(ULONG,Release)(void) = 0;

	// *** IHostInfoUpdate Methods ***

	STDMETHOD(UpdateInfo)(hostinfo hostinfoNew) = 0;
};

// {F8418AE0-9A5D-11d0-ABD4-00A0C911E8B2}
const GUID IID_IHostInfoProvider =
{ 0xf8418ae0, 0x9a5d, 0x11d0, { 0xab, 0xd4, 0x0, 0xa0, 0xc9, 0x11, 0xe8, 0xb2 } };

class IHostInfoProvider : public IUnknown
{

	public:

	// *** IUnknown Methods ***
	STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj) = 0;
	STDMETHOD_(ULONG,AddRef)(void) = 0;
	STDMETHOD_(ULONG,Release)(void) = 0;

	// *** IHostInfoProvider Methods ***

	STDMETHOD(GetHostInfo)(hostinfo hostinfoRequest, void * * ppvInfo) = 0;
};

#endif // HOST_INFO_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\idgener.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: ID Generator

File: Idgener.cpp

Owner: DmitryR

This is the ID Generator source file.
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "Idgener.h"

#include "memchk.h"

/*===================================================================
CIdGenerator::CIdGenerator

NOTE: Constructor

Parameters:

Returns:
===================================================================*/
CIdGenerator::CIdGenerator()
    : m_fInited(FALSE),
      m_dwStartId(0), 
      m_dwLastId(0)
    {
    }

/*===================================================================
CIdGenerator::~CIdGenerator()

NOTE: Destructor

Parameters:

Returns:
===================================================================*/
CIdGenerator::~CIdGenerator()
    {
	if ( m_fInited )
		DeleteCriticalSection( &m_csLock );
    }
		
/*===================================================================
HRESULT CIdGenerator::Init()

NOTE: Seed new starting Id

Parameters:

Returns: HRESULT (could fail to create critical section)
===================================================================*/
HRESULT CIdGenerator::Init()
    {
    Assert(!m_fInited);
    
    /*===
    
    Seed the starting id
    The starting Id should be:
        1) random
        2) not to close to recently generated starting ids
    To accomplish the above, starting Id is in the 
    following (binary) format:
    
        00TT.TTTT TTTT.TTTT TTT1.RRRR RRRR.RRRR
        
        RRR is random number to introduce some
            randomness
            
        1   is needed to make sure the id is far
            enough from 0
            
        TTT is current time() in 4 second increments.
            This means that 4 second in server restart
            delay translates into 8,192 difference in
            the starting Id (122880 sessions / minute).
            17 bits of 4 sec intervals make a roll over
            time of about 145 hours, hopefully longer
            than a client's connection lifetime (not
            that it REALLY matters).
            
        00  in the highest bits is to make sure it
            doesn't reach 0xffffffff too soon
            
    ===*/
    
    DWORD dwRRR = rand() & 0x00000FFF;
    DWORD dwTTT = (((DWORD)time(NULL)) >> 2) & 0x0001FFFF;
    
    m_dwStartId = (dwTTT << 13) | (1 << 12) | dwRRR;
    m_dwLastId  = m_dwStartId;


    HRESULT hr = S_OK;
	ErrInitCriticalSection( &m_csLock, hr );
	if ( FAILED( hr ) )
		return hr;
			
	m_fInited = TRUE;
	return S_OK;
}

/*===================================================================
HRESULT CIdGenerator::Init(CIdGenerator StartId)   

NOTE: Seed new starting Id with Id passed in

Parameters:

Returns: HRESULT (could fail to create critical section)
===================================================================*/
HRESULT CIdGenerator::Init(CIdGenerator & StartId)
    {
    Assert(!m_fInited);
    
    m_dwStartId = StartId.m_dwStartId;
    m_dwLastId  = m_dwStartId;

    HRESULT hr = NOERROR;
    ErrInitCriticalSection( &m_csLock, hr );
    if ( FAILED( hr ) )
        return hr;
			
    m_fInited = TRUE;
    return NOERROR;
}

/*===================================================================
DWORD CIdGenerator::NewId()

NOTE: Generates new ID

Parameters:

Returns: generated ID
===================================================================*/
DWORD CIdGenerator::NewId()
    {
    Assert(m_fInited);
    
    DWORD dwId;

    EnterCriticalSection(&m_csLock);
    dwId = ++m_dwLastId;
    LeaveCriticalSection(&m_csLock);
        
    if (dwId == INVALID_ID)
        {
        // doesn't happen very often do critical section again
        // to make the above critical section shorter
        
        EnterCriticalSection(&m_csLock);
        
        // check again in case other thread changed it
        if (m_dwLastId == INVALID_ID)
            m_dwLastId = m_dwStartId;  // roll over
        m_dwLastId++;
        
        LeaveCriticalSection(&m_csLock);
        
        dwId = m_dwLastId;
        }

    return dwId;
    }

/*===================================================================
BOOL CIdGenerator::IsValidId(DWORD dwId)

NOTE: Checks if the given Id is valid (with start-last range)

Parameters:
    DWORD dwId      Id value to check

Returns: generated ID
===================================================================*/
BOOL CIdGenerator::IsValidId
(
DWORD dwId
)
    {
    Assert(m_fInited);
    return (dwId > m_dwStartId && dwId <= m_dwLastId);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\idgener.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: ID Generator

File: IdGener.h

Owner: DmitryR

This file contains the declarations for the ID Generator class
===================================================================*/
#ifndef IDGENER_H
#define IDGENER_H

#define INVALID_ID      0xFFFFFFFF

class CIdGenerator
    {
private:
	BOOL              m_fInited;    // Initialized?
	CRITICAL_SECTION  m_csLock;		// Synchronize access
    DWORD             m_dwStartId;  // Starting (seed) Id
	DWORD			  m_dwLastId;   // Last Generated Id
		
public:	
	CIdGenerator();
	~CIdGenerator();
	
public:
	HRESULT Init();
	HRESULT Init(CIdGenerator & StartId);      
	DWORD   NewId();
	BOOL    IsValidId(DWORD dwId);
    };

#endif // IDGENER_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\htmldump.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: ASP Status Html Dump

File: htmldump.cpp

Owner: dmitryr

This file contains the ASP status html dump code
used from IISPROBE.DLL 
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "gip.h"
#include "mtacb.h"
#include "perfdata.h"
#include "activdbg.h"
#include "debugger.h"
#include "dbgutil.h"
#include "randgen.h"
#include "aspdmon.h"

#include "memcls.h"
#include "memchk.h"

/*===================================================================
Helper classes and functions
===================================================================*/
class CAspDump
    {
private:
    char *m_szBuffer;
    DWORD m_dwMaxSize;
    DWORD m_dwActSize;

public:
    CAspDump(char *szBuffer, DWORD dwMaxSize)
        {
        m_szBuffer = szBuffer;
        m_dwMaxSize = dwMaxSize;
        m_dwActSize = 0;
        }

    inline void __cdecl Dump(LPCSTR fmt, ...)
        {
        char szStr[512];
        
        va_list marker;
        va_start(marker, fmt);
        vsprintf(szStr, fmt, marker);
        va_end(marker);
        
        DWORD len = strlen(szStr);
            
        if (len > 0 && len < (m_dwMaxSize-m_dwActSize))
            {
            memcpy(m_szBuffer+m_dwActSize, szStr, len+1);
            m_dwActSize += len;
            }
        }

    DWORD GetSize()
        {
        return m_dwActSize;
        }
    };


/*===================================================================
AspStatusHtmlDump

Function called from IISPROBE.DLL
Fills in the buffer with the ASP status as HTML

Parameters:
    szBuffer        buffer to fill in
    pwdSize         in  - max buffer len
                    out - actual buffer len filled

Returns:
    TRUE
===================================================================*/
extern "C"
BOOL WINAPI AspStatusHtmlDump(char *szBuffer, DWORD *pdwSize)
    {
    CAspDump dump(szBuffer, *pdwSize);


    dump.Dump("<table border=1>\r\n");
    
    dump.Dump("<tr><td align=center colspan=2><b>Misc. Globals</b>\r\n");

    dump.Dump("<tr><td>fShutDownInProgress<td>%d\r\n",      g_fShutDownInProgress);
    dump.Dump("<tr><td>nApplications<td>%d\r\n",            g_nApplications);
    dump.Dump("<tr><td>nApplicationsRestarting<td>%d\r\n",  g_nApplicationsRestarting);
    dump.Dump("<tr><td>nSessions<td>%d\r\n",                g_nSessions);
    dump.Dump("<tr><td>nBrowserRequests<td>%d\r\n",         g_nBrowserRequests);
    dump.Dump("<tr><td>nSessionCleanupRequests<td>%d\r\n",  g_nSessionCleanupRequests);
    dump.Dump("<tr><td>nApplnCleanupRequests<td>%d\r\n",    g_nApplnCleanupRequests);
    dump.Dump("<tr><td>pPDM (debugger)<td>%08p\r\n",        g_pPDM);


    dump.Dump("<tr><td align=center colspan=2><b>Selected PerfMon Counters</b>\r\n");

    dump.Dump("<tr><td>Last request's execution time, ms<td>%d\r\n",        *g_PerfData.PLCounter(ID_REQEXECTIME));
    dump.Dump("<tr><td>Last request's wait time, ms<td>%d\r\n",             *g_PerfData.PLCounter(ID_REQWAITTIME));
    dump.Dump("<tr><td>Number of executing requests<td>%d\r\n",             *g_PerfData.PLCounter(ID_REQBROWSEREXEC));
    dump.Dump("<tr><td>Number of requests waiting in the queue<td>%d\r\n",  *g_PerfData.PLCounter(ID_REQCURRENT));
    dump.Dump("<tr><td>Number of rejected requests<td>%d\r\n",              *g_PerfData.PLCounter(ID_REQREJECTED));
    dump.Dump("<tr><td>Total number of requests<td>%d\r\n",                 *g_PerfData.PLCounter(ID_REQTOTAL));
    dump.Dump("<tr><td>Last session's duration, ms<td>%d\r\n",              *g_PerfData.PLCounter(ID_SESSIONLIFETIME));
    dump.Dump("<tr><td>Current number of sessions<td>%d\r\n",               *g_PerfData.PLCounter(ID_SESSIONCURRENT));
    dump.Dump("<tr><td>Total number of sessions<td>%d\r\n",                 *g_PerfData.PLCounter(ID_SESSIONSTOTAL));
    dump.Dump("<tr><td>Number of cached templates<td>%d\r\n",               *g_PerfData.PLCounter(ID_TEMPLCACHE));
    dump.Dump("<tr><td>Number of pending transactions<td>%d\r\n",           *g_PerfData.PLCounter(ID_TRANSPENDING));


    dump.Dump("<tr><td align=center colspan=2><b>Applications</b>\r\n");

	CApplnIterator ApplnIterator;
    ApplnIterator.Start();
    CAppln *pAppln;
    while (pAppln = ApplnIterator.Next())
        {
        
        dump.Dump("<tr><td colspan=2>%08p\r\n",                         pAppln);
        dump.Dump("<tr><td align=right>metabase key<td>%s\r\n",         pAppln->GetMetabaseKey());
        dump.Dump("<tr><td align=right>physical path<td>%s\r\n",        pAppln->GetApplnPath(SOURCEPATHTYPE_PHYSICAL));
        dump.Dump("<tr><td align=right>virtual path<td>%s\r\n",         pAppln->GetApplnPath(SOURCEPATHTYPE_VIRTUAL));
        dump.Dump("<tr><td align=right>number of sessions<td>%d\r\n",   pAppln->GetNumSessions());
        dump.Dump("<tr><td align=right>number of requests<td>%d\r\n",   pAppln->GetNumRequests());
#if 0
        dump.Dump("<tr><td align=right>global.asa path<td>%s\r\n",      pAppln->FHasGlobalAsa() ? pAppln->GetGlobalAsa() : "n/a");
#endif
        dump.Dump("<tr><td align=right>global changed?<td>%d\r\n",      pAppln->FGlobalChanged());
        dump.Dump("<tr><td align=right>tombstone?<td>%d\r\n",           pAppln->FTombstone());
        dump.Dump("<tr><td align=right>debuggable?<td>%d\r\n",          pAppln->FDebuggable());

        CSessionMgr *pSessionMgr = pAppln->PSessionMgr();

        dump.Dump("<tr><td align=right>session manager<td>%08p\r\n", pSessionMgr);

        if (pSessionMgr)
            {
            
            dump.Dump("<tr><td align=right>session killer scheduled?<td>%d\r\n", pSessionMgr->FIsSessionKillerScheduled());
            dump.Dump("<tr><td align=right>session cleanup requests<td>%d\r\n",  pSessionMgr->GetNumSessionCleanupRequests());
            
            }
        else
            {
            }
        }
    ApplnIterator.Stop();


    dump.Dump("</table>\r\n");

    *pdwSize = dump.GetSize();
    return TRUE;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\idhash.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

File: idhash.cpp

Owner: DmitryR

Source file for the new hashing stuff
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "idhash.h"
#include "memcls.h"

#include "memchk.h"

/*===================================================================
  C  P t r  A r r a y
===================================================================*/

HRESULT CPtrArray::Insert
(
int iPos,
void *pv
)
    {
    if (!m_rgpvPtrs) // empty?
        {
        m_rgpvPtrs = (void **)malloc(m_dwInc * sizeof(void *));
        if (!m_rgpvPtrs)
            return E_OUTOFMEMORY;
        m_dwSize = m_dwInc;
        m_cPtrs = 0;
        }
    else if (m_cPtrs == m_dwSize) // full?
        {
        void **pNewPtrs = (void **)realloc
            (
            m_rgpvPtrs,
            (m_dwSize + m_dwInc) * sizeof(void *)
            );
        if (!pNewPtrs)
            return E_OUTOFMEMORY;
        m_rgpvPtrs = pNewPtrs;
        m_dwSize += m_dwInc;
        }

    if (iPos < 0)
        iPos = 0;
    if ((DWORD)iPos >= m_cPtrs) // append?
        {
        m_rgpvPtrs[m_cPtrs++] = pv;
        return S_OK;
        }

    memmove
        (
        &m_rgpvPtrs[iPos+1],
        &m_rgpvPtrs[iPos],
        (m_cPtrs-iPos) * sizeof(void *)
        );

    m_rgpvPtrs[iPos] = pv;
    m_cPtrs++;
    return S_OK;
    }

HRESULT CPtrArray::Find
(
void *pv,
int *piPos
)
    const
    {
    Assert(piPos);

    for (DWORD i = 0; i < m_cPtrs; i++)
        {
        if (m_rgpvPtrs[i] == pv)
            {
            *piPos = i;
            return S_OK;
            }
        }

     // not found
    *piPos = -1;
    return S_FALSE;
    }

HRESULT CPtrArray::Remove
(
void *pv
)
    {
    HRESULT hr = S_FALSE;

    for (DWORD i = 0; i < m_cPtrs; i++)
        {
        if (m_rgpvPtrs[i] == pv)
            hr = Remove(i);
        }

    return hr;
    }

HRESULT CPtrArray::Remove
(
int iPos
)
    {
    Assert(iPos >= 0 && (DWORD)iPos < m_cPtrs);
    Assert(m_rgpvPtrs);

    // remove the element
    DWORD dwMoveSize = (m_cPtrs - iPos - 1) * sizeof(void *);
    if (dwMoveSize)
        memmove(&m_rgpvPtrs[iPos], &m_rgpvPtrs[iPos+1], dwMoveSize);
    m_cPtrs--;

    if (m_dwSize > 4*m_dwInc && m_dwSize > 8*m_cPtrs)
        {
        // collapse to 1/4 if size > 4 x increment and less < 1/8 full

        void **pNewPtrs = (void **)realloc
            (
            m_rgpvPtrs,
            (m_dwSize / 4) * sizeof(void *)
            );

        if (pNewPtrs)
            {
            m_rgpvPtrs = pNewPtrs;
            m_dwSize /= 4;
            }
        }

    return S_OK;
    }

HRESULT CPtrArray::Clear()
    {
    if (m_rgpvPtrs)
        free(m_rgpvPtrs);

    m_dwSize = 0;
    m_rgpvPtrs = NULL;
    m_cPtrs = 0;
    return S_OK;
    }

/*===================================================================
  C  I d  H a s h  U n i t
===================================================================*/

// Everything is inline for this structure. See the header file.

/*===================================================================
  C  I d  H a s h  A r r a y
===================================================================*/

/*===================================================================
For some hardcoded element counts (that relate to session hash),
ACACHE is used for allocations
This is wrapped in the two functions below.
===================================================================*/
ACACHE_FSA_EXTERN(MemBlock128)
ACACHE_FSA_EXTERN(MemBlock256)
static inline void *AcacheAllocIdHashArray(DWORD cElems)
    {
/* removed because in 64bit land it doesn't work because of padding
    void *pvMem;
    if      (cElems == 13) { pvMem = ACACHE_FSA_ALLOC(MemBlock128); }
    else if (cElems == 31) { pvMem = ACACHE_FSA_ALLOC(MemBlock256); }
   else { pvMem = malloc(2*sizeof(USHORT) + cElems*sizeof(CIdHashElem)); }
*/

    return malloc(offsetof(CIdHashArray, m_rgElems) + cElems*sizeof(CIdHashElem));
    }

static inline void AcacheFreeIdHashArray(CIdHashArray *pArray)
    {
/* removed because in 64bit land it doesn't work because of padding
    if (pArray->m_cElems == 13)      { ACACHE_FSA_FREE(MemBlock128, pArray); }
    else if (pArray->m_cElems == 31) { ACACHE_FSA_FREE(MemBlock256, pArray); }
    else                             { free(pArray); }
*/
    free(pArray);
    }

/*===================================================================
CIdHashArray::Alloc

Static method.
Allocates CIdHashArray as a memory block containing var length array.

Parameters:
    cElems          # of elements in the array

Returns:
    Newly created CIdHashArray
===================================================================*/
CIdHashArray *CIdHashArray::Alloc
(
DWORD cElems
)
    {
    CIdHashArray *pArray = (CIdHashArray *)AcacheAllocIdHashArray(cElems);
    if (!pArray)
        return NULL;

    pArray->m_cElems = (USHORT)cElems;
    pArray->m_cNotNulls = 0;
    memset(&(pArray->m_rgElems[0]), 0, cElems * sizeof(CIdHashElem));
    return pArray;
    }

/*===================================================================
CIdHashArray::Alloc

Static method.
Frees allocated CIdHashArray as a memory block.
Also frees any sub-arrays.

Parameters:
    pArray          CIdHashArray object to be freed

Returns:
===================================================================*/
void CIdHashArray::Free
(
CIdHashArray *pArray
)
    {
    if (pArray->m_cNotNulls > 0)
        {
        for (DWORD i = 0; i < pArray->m_cElems; i++)
            {
            if (pArray->m_rgElems[i].FIsArray())
                Free(pArray->m_rgElems[i].PArray());
            }
        }

    AcacheFreeIdHashArray(pArray);
    }

/*===================================================================
CIdHashArray::Find

Searches this array and any sub-arrays for an objects with the
given id.

Parameters:
    dwId            id to look for
    ppvObj          object found (if any)

Returns:
    S_OK = found, S_FALSE = not found
===================================================================*/
HRESULT CIdHashArray::Find
(
DWORD_PTR dwId,
void **ppvObj
)
    const
    {
    DWORD i = (DWORD)(dwId % m_cElems);

    if (m_rgElems[i].DWId() == dwId)
        {
        if (ppvObj)
            *ppvObj = m_rgElems[i].PObject();
        return S_OK;
        }

    if (m_rgElems[i].FIsArray())
        return m_rgElems[i].PArray()->Find(dwId, ppvObj);

    // Not found
    if (ppvObj)
        *ppvObj = NULL;
    return S_FALSE;
    }

/*===================================================================
CIdHashArray::Add

Adds an object to this (or sub-) array by Id.
Creates new sub-arrays as needed.

Parameters:
    dwId            object id
    pvObj           object to add
    rgusSizes       array of sizes (used when creating sub-arrays)

Returns:
    HRESULT (S_OK = added)
===================================================================*/
HRESULT CIdHashArray::Add
(
DWORD_PTR dwId,
void *pvObj,
USHORT *rgusSizes
)
{
    DWORD i = (DWORD)(dwId % m_cElems);

    if (m_rgElems[i].FIsEmpty()) {
        m_rgElems[i].SetToObject(dwId, pvObj);
        m_cNotNulls++;
        return S_OK;
    }

    // Advance array of sizes one level deeper
    if (rgusSizes[0]) // not at the end
        ++rgusSizes;

    if (m_rgElems[i].FIsObject()) {

        // this array logic can't handle adding the same ID twice.  It will
        // loop endlessly.  So, if an attempt is made to add the same
        // ID a second, return an error
        if (m_rgElems[i].DWId() == dwId) {
            return E_INVALIDARG;
        }

        // Old object already taken the slot - need to create new array
        // the size of first for three levels is predefined
        // increment by 1 thereafter
        CIdHashArray *pArray = Alloc (rgusSizes[0] ? rgusSizes[0] : m_cElems+1);
        if (!pArray)
            return E_OUTOFMEMORY;

        // Push the old object down into the array
        HRESULT hr = pArray->Add(m_rgElems[i].DWId(),
                                 m_rgElems[i].PObject(),
                                 rgusSizes);
        if (FAILED(hr))
            return hr;

        // Put array into slot
        m_rgElems[i].SetToArray(pArray);
    }

    Assert(m_rgElems[i].FIsArray());
    return m_rgElems[i].PArray()->Add(dwId, pvObj, rgusSizes);
}

/*===================================================================
CIdHashArray::Remove

Removes an object by id from this (or sub-) array.
Removes empty sub-arrays.

Parameters:
    dwId            object id
    ppvObj          object removed (out, optional)

Returns:
    HRESULT (S_OK = removed, S_FALSE = not found)
===================================================================*/
HRESULT CIdHashArray::Remove
(
DWORD_PTR dwId,
void **ppvObj
)
    {
    DWORD i = (DWORD)(dwId % m_cElems);

    if (m_rgElems[i].DWId() == dwId)
        {
        if (ppvObj)
            *ppvObj = m_rgElems[i].PObject();
        m_rgElems[i].SetToEmpty();
        m_cNotNulls--;
        return S_OK;
        }

    if (m_rgElems[i].FIsArray())
        {
        HRESULT hr = m_rgElems[i].PArray()->Remove(dwId, ppvObj);
        if (hr == S_OK && m_rgElems[i].PArray()->m_cNotNulls == 0)
            {
            Free(m_rgElems[i].PArray());
            m_rgElems[i].SetToEmpty();
            }
        return hr;
        }

    // Not found
    if (ppvObj)
        *ppvObj = NULL;
    return S_FALSE;
    }

/*===================================================================
CIdHashArray::Iterate

Calls a supplied callback for each object in the array and sub-arrays.

Parameters:
    pfnCB               callback
    pvArg1, pvArg2      args to path to the callback

Returns:
    IteratorCallbackCode  what to do next?
===================================================================*/
IteratorCallbackCode CIdHashArray::Iterate
(
PFNIDHASHCB pfnCB,
void *pvArg1,
void *pvArg2
)
    {
    IteratorCallbackCode rc = iccContinue;

    for (DWORD i = 0; i < m_cElems; i++)
        {
        if (m_rgElems[i].FIsObject())
            {
            rc = (*pfnCB)(m_rgElems[i].PObject(), pvArg1, pvArg2);

            // remove if requested
            if (rc & (iccRemoveAndContinue|iccRemoveAndStop))
                {
                m_rgElems[i].SetToEmpty();
                m_cNotNulls--;
                }
            }
        else if (m_rgElems[i].FIsArray())
            {
            rc = m_rgElems[i].PArray()->Iterate(pfnCB, pvArg1, pvArg2);

            // remove sub-array if empty
            if (m_rgElems[i].PArray()->m_cNotNulls == 0)
                {
                Free(m_rgElems[i].PArray());
                m_rgElems[i].SetToEmpty();
                }
            }
        else
            {
            continue;
            }

        // stop if requested
        if (rc & (iccStop|iccRemoveAndStop))
            {
            rc = iccStop;
            break;
            }
        }

    return rc;
    }

#ifdef DBG
/*===================================================================
CIdHashTable::Dump

Dump hash table to a file (for debugging).

Parameters:
    szFile      file name where to dump

Returns:
===================================================================*/
void CIdHashArray::DumpStats
(
FILE *f,
int   nVerbose,
DWORD iLevel,
DWORD &cElems,
DWORD &cSlots,
DWORD &cArrays,
DWORD &cDepth
)
    const
    {
    if (nVerbose > 0)
        {
        for (DWORD t = 0; t < iLevel; t++) fprintf(f, "\t");
        fprintf(f, "Array (level=%d addr=%p) %d slots, %d not null:\n",
            iLevel, this, m_cElems, m_cNotNulls);
        }

    cSlots += m_cElems;
    cArrays++;

    if (iLevel > cDepth)
        cDepth = iLevel;

    for (DWORD i = 0; i < m_cElems; i++)
        {
        if (nVerbose > 1)
            {
            for (DWORD t = 0; t < iLevel; t++) fprintf(f, "\t");
            fprintf(f, "%[%08x:%p@%04d] ", m_rgElems[i].m_dw, m_rgElems[i].m_pv, i);
            }

        if (m_rgElems[i].FIsEmpty())
            {
            if (nVerbose > 1)
                fprintf(f, "NULL\n");
            }
        else if (m_rgElems[i].FIsObject())
            {
            if (nVerbose > 1)
                fprintf(f, "Object\n");
            cElems++;
            }
        else if (m_rgElems[i].FIsArray())
            {
            if (nVerbose > 1)
                fprintf(f, "Array:\n");
            m_rgElems[i].PArray()->DumpStats(f, nVerbose, iLevel+1,
                cElems, cSlots, cArrays, cDepth);
            }
        else
            {
            if (nVerbose > 1)
                fprintf(f, "BAD\n");
            }
        }
    }
#endif
/*===================================================================
  C  I d  H a s h  T a b l e
===================================================================*/

/*===================================================================
CIdHashTable::Init

Initialize id hash table. Does not allocate anything.

Parameters:
    usSize1         size of the first level array
    usSize2         size of the 2nd level arrays (optional)
    usSize3         size of the 3rd level arrays (optional)

Returns:
    S_OK
===================================================================*/
HRESULT CIdHashTable::Init
(
USHORT usSize1,
USHORT usSize2,
USHORT usSize3
)
    {
    Assert(!FInited());
    Assert(usSize1);

    m_rgusSizes[0] = usSize1;   // size of first level array
    m_rgusSizes[1] = usSize2 ? usSize2 : 7;
    m_rgusSizes[2] = usSize3 ? usSize3 : 11;
    m_rgusSizes[3] = 0;         // last one stays 0 to indicate
                                // the end of predefined sizes
    m_pArray = NULL;
    return S_OK;
    }

/*===================================================================
CIdHashTable::UnInit

Uninitialize id hash table. Frees all arrays.

Parameters:

Returns:
    S_OK
===================================================================*/
HRESULT CIdHashTable::UnInit()
    {
    if (!FInited())
        {
        Assert(!m_pArray);
        return S_OK;
        }

    if (m_pArray)
        CIdHashArray::Free(m_pArray);

    m_pArray = NULL;
    m_rgusSizes[0] = 0;
    return S_OK;
    }

#ifdef DBG
/*===================================================================
CIdHashTable::AssertValid

Validates id hash table.

Parameters:

Returns:
===================================================================*/
void CIdHashTable::AssertValid() const
    {
    Assert(FInited());
    }

/*===================================================================
CIdHashTable::Dump

Dump hash table to a file (for debugging).

Parameters:
    szFile      file name where to dump

Returns:
===================================================================*/
void CIdHashTable::Dump
(
const char *szFile
)
    const
    {
    Assert(FInited());
    Assert(szFile);

    FILE *f = fopen(szFile, "a");
    if (!f)
        return;

    fprintf(f, "ID Hash Table Dump:\n");

    DWORD cElems = 0;
    DWORD cSlots = 0;
    DWORD cArrays = 0;
    DWORD cDepth = 0;

    if (m_pArray)
        m_pArray->DumpStats(f, 1, 1, cElems, cSlots, cArrays, cDepth);

    fprintf(f, "Total %d Objects in %d Slots, %d Arrays, %d Max Depth\n\n",
        cElems, cSlots, cArrays, cDepth);
    fclose(f);
    }
#endif

/*===================================================================
  C  H a s h  L o c k
===================================================================*/

/*===================================================================
CHashLock::Init

Initialize the critical section.

Parameters:

Returns:
    S_OK
===================================================================*/
HRESULT CHashLock::Init()
    {
    Assert(!m_fInited);

    HRESULT hr;
    ErrInitCriticalSection(&m_csLock, hr);
    if (FAILED(hr))
        return hr;

    m_fInited = TRUE;
    return S_OK;
    }

/*===================================================================
CHashLock::UnInit

Uninitialize the critical section.

Parameters:

Returns:
    S_OK
===================================================================*/
HRESULT CHashLock::UnInit()
    {
    if (m_fInited)
        {
        DeleteCriticalSection(&m_csLock);
        m_fInited = FALSE;
        }
    return S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\ie449.h ===
/*===================================================================
Microsoft IIS 5.0 (ASP)

Microsoft Confidential.
Copyright 1998 Microsoft Corporation. All Rights Reserved.

Component: 449 negotiations w/IE

File: ie449.h

Owner: DmitryR

This file contains the definitons for the 449 negotiations w/IE
===================================================================*/

#ifndef IE449_H
#define IE449_H

#include "hashing.h"
#include "aspdmon.h"
#include "memcls.h"

// forward declr
class CHitObj;
class C449Cookie;
class C449File;

/*===================================================================
The API
===================================================================*/

// init/uninit on dll level
HRESULT Init449();
HRESULT UnInit449();

// create a new cookie
HRESULT Create449Cookie(char *szName, TCHAR *szFile, C449Cookie **pp449);

// do the work
HRESULT Do449Processing
    (
    CHitObj *pHitObj, 
    C449Cookie **rgpCookies, 
    DWORD cCookies
    );

// change notification processing
HRESULT Do449ChangeNotification(TCHAR *szFile = NULL);

/*===================================================================
C449File class definition
    files are hashed
===================================================================*/
class C449File : public IUnknown, public CLinkElem
    {
private:
    LONG  m_cRefs;              // ref count
    LONG  m_fNeedLoad;          // flag when need to reload (Interlocked)
    TCHAR *m_szFile;             // file name with script
    char *m_szBuffer;           // file contents
    DWORD m_cbBuffer;           // file contents length
    CDirMonitorEntry *m_pDME;   // for change notification support

    C449File();       // should be done using Create449Cookie()
    ~C449File();      // should be done using Release()

    HRESULT Init(TCHAR *szFile);

public:
    // public constructor
    static HRESULT Create449File(TCHAR *szFile, C449File **ppFile);

    HRESULT Load();

    inline char *SzBuffer() { return m_szBuffer; }
    inline DWORD CbBuffer() { return m_cbBuffer; }

    inline void SetNeedLoad() { InterlockedExchange(&m_fNeedLoad, 1); }

    // IUnknown implementation
	STDMETHODIMP		 QueryInterface(REFIID, VOID**);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);
        
	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };

/*===================================================================
C449FileMgr class definition
    file manager keeps the hash table of files
===================================================================*/
class C449FileMgr
    {
private:
    CRITICAL_SECTION m_csLock;
    CHashTableMBStr  m_ht449Files;

    inline void Lock()    { EnterCriticalSection(&m_csLock); }
    inline void UnLock()  { LeaveCriticalSection(&m_csLock); }

public:
    C449FileMgr();
    ~C449FileMgr();
    
    HRESULT Init();

    // find or create a new one
    HRESULT GetFile(TCHAR *szFile, C449File **ppFile);

    // change notification
    HRESULT Flush(TCHAR *szFile);
    HRESULT FlushAll();
    };

/*===================================================================
C449Cookie class definition
    cookie is a cookie -- file pair
===================================================================*/
class C449Cookie : public IUnknown
    {
private:
    LONG      m_cRefs;      // ref count
    char     *m_szName;     // cookie name to check
    DWORD     m_cbName;     // cookie name length
    C449File *m_pFile;      // related file

    C449Cookie();       // should be done using Create449Cookie()
    ~C449Cookie();      // should be done using Release()

    HRESULT Init(char *szName, C449File *pFile);

public:
    // public constructor
    static HRESULT Create449Cookie(char *szName, C449File *pFile, C449Cookie **pp449);

    inline char *SzCookie() { return m_szName; }
    inline DWORD CbCookie() { return m_cbName; }

    inline HRESULT LoadFile() { return m_pFile ? m_pFile->Load() : E_FAIL; }
    inline char   *SzBuffer() { return m_pFile ? m_pFile->SzBuffer() : NULL; }
    inline DWORD   CbBuffer() { return m_pFile ? m_pFile->CbBuffer() : 0; }

    // IUnknown implementation
	STDMETHODIMP		 QueryInterface(REFIID, VOID**);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);
        
	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };

#endif // IE449_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\initguid.c ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Script Manager

File: InitGuid.cpp

Owner: AndrewS

Init all guids used by Denali in one place.
We are only allowed to #include objbase with INITGUID set once,
and after that we need to create all our GUIDs.  Otherwise, the
linker complains about redefeined symbols.  We do it here.
===================================================================*/

#define CINTERFACE
#include <objbase.h>
#include <initguid.h>
#include "_asptlb.h"
#include "_asptxn.h"
#include "activscp.h"
#include "activdbg.h"
#include "wraptlib.h"
#include "denguid.h"
#include "asptxn_i.c"

#if _IIS_5_1
#include <iadm.h>
#elif _IIS_6_0
#include <iadmw.h>
#else
#error "Neither _IIS_6_0 nor _IIS_5_1 is defined"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\idhash.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

File: idhash.h

Owner: DmitryR

Header file for the new hashing stuff
===================================================================*/

#ifndef ASP_IDHASH_H
#define ASP_IDHASH_H

// forward declarations

class  CPtrArray;

class  CHashLock;

struct CIdHashElem;
struct CIdHashArray;
class  CIdHashTable;
class  CIdHashTableWithLock;

struct CObjectListElem;
class  CObjectList;
class  CObjectListWithLock;


// defines for the iterator callback return codes

#define IteratorCallbackCode   DWORD
#define iccContinue            0x00000001  // goto next object
#define iccStop                0x00000002  // stop iterating
#define iccRemoveAndContinue   0x00000004  // remove this, goto next
#define iccRemoveAndStop       0x00000008  // remove this and stop


// typedefs for the iterator callback
typedef IteratorCallbackCode (*PFNIDHASHCB)
                           (void *pvObj, void *pvArg1, void *pvArg2);

/*===================================================================
  C  P t r  A r r a y

Self-reallocating array of void pointers
===================================================================*/
class CPtrArray
    {
private:
    DWORD  m_dwSize;    // allocated size
    DWORD  m_dwInc;     // allocation increment
    void **m_rgpvPtrs;  // array of void pointers
    DWORD  m_cPtrs;     // pointers in the array

public:
    CPtrArray(DWORD dwInc = 8); // 8 pointers is the default increment
    ~CPtrArray();

    // # of elements
    int Count() const;

    // get pointer at position
    void *Get(int i) const;
    // same as operator []
    void *operator[](int i) const;

    // append to array
    HRESULT Append(void *pv);
    // prepend to array
    HRESULT Prepend(void *pv);
    // insert into given position
    HRESULT Insert(int iPos, void *pv);

    // find first position of a pointer
    HRESULT Find(void *pv, int *piPos) const;
    // same as operator []
    int operator[](void *pv) const;

    // remove by position
    HRESULT Remove(int iPos);
    // remove by pointer (all occurances)
    HRESULT Remove(void *pv);

    // remove all
    HRESULT Clear();
    };

// inlines

inline CPtrArray::CPtrArray(DWORD dwInc)
    : m_dwSize(0), m_dwInc(dwInc), m_rgpvPtrs(NULL), m_cPtrs(0)
    {
    Assert(m_dwInc > 0);
    }

inline CPtrArray::~CPtrArray()
    {
    Clear();
    }

inline int CPtrArray::Count() const
    {
    return m_cPtrs;
    }

inline void *CPtrArray::Get(int i) const
    {
    Assert(i >= 0 && (DWORD)i < m_cPtrs);
    Assert(m_rgpvPtrs);
    return m_rgpvPtrs[i];
    }

inline void *CPtrArray::operator[](int i) const
    {
    return Get(i);
    }

inline HRESULT CPtrArray::Append(void *pv)
    {
    return Insert(m_cPtrs, pv);
    }

inline HRESULT CPtrArray::Prepend(void *pv)
    {
    return Insert(0, pv);
    }

inline int CPtrArray::operator[](void *pv) const
    {
    int i;
    if (Find(pv, &i) == S_OK)
        return i;
    return -1; // not found
    }


/*===================================================================
  C  H a s h  L o c k

A wrapper around CRITICAL_SECTION.
===================================================================*/

class CHashLock
    {
private:
    DWORD m_fInited : 1;
    CRITICAL_SECTION m_csLock;

public:
    CHashLock();
    ~CHashLock();

    HRESULT Init();
    HRESULT UnInit();

    void Lock();
    void UnLock();
    };

// inlines

inline CHashLock::CHashLock()
    : m_fInited(FALSE)
    {
    }

inline CHashLock::~CHashLock()
    {
    UnInit();
    }

inline void CHashLock::Lock()
    {
    Assert(m_fInited);
    EnterCriticalSection(&m_csLock);
    }

inline void CHashLock::UnLock()
    {
    Assert(m_fInited);
    LeaveCriticalSection( &m_csLock );
    }


/*===================================================================
  C  I d  H a s h  U n i t

8-byte structure -- one element of hash array. Could be:
1) empty, 2) point to an object, 3) point to sub-array
===================================================================*/

struct CIdHashElem
    {
    DWORD_PTR m_dw;
    void *m_pv;

    BOOL FIsEmpty() const;
    BOOL FIsObject() const;
    BOOL FIsArray() const;

    DWORD_PTR DWId() const;
    void *PObject() const;
    CIdHashArray *PArray() const;

    void SetToEmpty();
    void SetToObject(DWORD_PTR dwId, void *pvObj);
    void SetToArray(CIdHashArray *pArray);
    };

// inlines

inline BOOL CIdHashElem::FIsEmpty() const
    {
    return (m_pv == NULL);
    }

inline BOOL CIdHashElem::FIsObject() const
    {
    return (m_dw != 0);
    }

inline BOOL CIdHashElem::FIsArray() const
    {
    return (m_pv != NULL && m_dw == 0);
    }

inline DWORD_PTR CIdHashElem::DWId() const
    {
    return m_dw;
    }

inline void *CIdHashElem::PObject() const
    {
    return m_pv;
    }

inline CIdHashArray *CIdHashElem::PArray() const
    {
    return reinterpret_cast<CIdHashArray *>(m_pv);
    }

inline void CIdHashElem::SetToEmpty()
    {
    m_dw = 0;
    m_pv = NULL;
    }

inline void CIdHashElem::SetToObject
(
DWORD_PTR dwId,
void *pvObj
)
    {
    m_dw = dwId;
    m_pv = pvObj;
    }

inline void CIdHashElem::SetToArray
(
CIdHashArray *pArray
)
    {
    m_dw = 0;
    m_pv = pArray;
    }

/*===================================================================
  C  I d  H a s h  A r r a y

Structure to consisting of DWORD (# of elems) and the array of Elems
===================================================================*/

struct CIdHashArray
    {
    USHORT m_cElems;            // total number of elements
    USHORT m_cNotNulls;         // number of not NULL elements
    CIdHashElem m_rgElems[1];   // 1 doesn't matter

    static CIdHashArray *Alloc(DWORD cElems);
    static void Free(CIdHashArray *pArray);

    HRESULT Find(DWORD_PTR dwId, void **ppvObj) const;
    HRESULT Add(DWORD_PTR dwId, void *pvObj, USHORT *rgusSizes);
    HRESULT Remove(DWORD_PTR dwId, void **ppvObj);
    IteratorCallbackCode Iterate(PFNIDHASHCB pfnCB, void *pvArg1, void *pvArg2);

#ifdef DBG
    void DumpStats(FILE *f, int nVerbose, DWORD iLevel,
        DWORD &cElems, DWORD &cSlots, DWORD &cArrays, DWORD &cDepth) const;
#else
    inline void DumpStats(FILE *, int, DWORD,
        DWORD &, DWORD &,  DWORD &, DWORD &) const {}
#endif
    };

/*===================================================================
  C  I d  H a s h  T a b l e

Remembers sizes of arrays on all levels and has a pointer to the
first level array of CIdHashElem elements.
===================================================================*/

class CIdHashTable
    {
private:
    USHORT        m_rgusSizes[4]; // Sizes of arrays on first 4 levels
    CIdHashArray *m_pArray;       // Pointer to first level array

    inline BOOL FInited() const { return (m_rgusSizes[0] != 0); }

public:
    CIdHashTable();
    CIdHashTable(USHORT usSize1, USHORT usSize2 = 0, USHORT usSize3 = 0);
    ~CIdHashTable();

    HRESULT Init(USHORT usSize1, USHORT usSize2 = 0, USHORT usSize3 = 0);
    HRESULT UnInit();

    HRESULT FindObject(DWORD_PTR dwId, void **ppvObj = NULL) const;
    HRESULT AddObject(DWORD_PTR dwId, void *pvObj);
    HRESULT RemoveObject(DWORD_PTR dwId, void **ppvObj = NULL);
    HRESULT RemoveAllObjects();

    HRESULT IterateObjects
        (
        PFNIDHASHCB pfnCB,
        void *pvArg1 = NULL,
        void *pvArg2 = NULL
        );

public:
#ifdef DBG
    void AssertValid() const;
    void Dump(const char *szFile) const;
#else
    inline void AssertValid() const {}
    inline void Dump(const char *) const {}
#endif
    };

// inlines

inline CIdHashTable::CIdHashTable()
    {
    m_rgusSizes[0] = 0; // mark as UnInited
    m_pArray = NULL;
    }

inline CIdHashTable::CIdHashTable
(
USHORT usSize1,
USHORT usSize2,
USHORT usSize3
)
    {
    m_rgusSizes[0] = 0; // mark as UnInited
    m_pArray = NULL;

    Init(usSize1, usSize2, usSize3);  // use Init to initialize
    }

inline CIdHashTable::~CIdHashTable()
    {
    UnInit();
    }

inline HRESULT CIdHashTable::FindObject
(
DWORD_PTR dwId,
void **ppvObj
)
    const
    {
    Assert(FInited());
    Assert(dwId);

    if (!m_pArray)
        {
        if (ppvObj)
            *ppvObj = NULL;
        return S_FALSE;
        }

    return m_pArray->Find(dwId, ppvObj);
    }

inline HRESULT CIdHashTable::AddObject
(
DWORD_PTR dwId,
void *pvObj
)
    {
    Assert(FInited());
    Assert(dwId);
    Assert(pvObj);

    if (!m_pArray)
        {
        m_pArray = CIdHashArray::Alloc(m_rgusSizes[0]);
        if (!m_pArray)
            return E_OUTOFMEMORY;
        }

    return m_pArray->Add(dwId, pvObj, m_rgusSizes);
    }

inline HRESULT CIdHashTable::RemoveObject
(
DWORD_PTR dwId,
void **ppvObj
)
    {
    Assert(FInited());
    Assert(dwId);

    if (!m_pArray)
        {
        if (ppvObj)
            *ppvObj = NULL;
        return S_FALSE;
        }

    return m_pArray->Remove(dwId, ppvObj);
    }

inline HRESULT CIdHashTable::RemoveAllObjects()
    {
    if (m_pArray)
        {
        CIdHashArray::Free(m_pArray);
        m_pArray = NULL;
        }
    return S_OK;
    }

inline HRESULT CIdHashTable::IterateObjects
(
PFNIDHASHCB pfnCB,
void *pvArg1,
void *pvArg2
)
    {
    Assert(FInited());
    Assert(pfnCB);

    if (!m_pArray)
        return S_OK;

    return m_pArray->Iterate(pfnCB, pvArg1, pvArg2);
    }

/*===================================================================
  C  I d  H a s h  T a b l e  W i t h  L o c k

CIdHashTable + CRITICAL_SECTION.
===================================================================*/

class CIdHashTableWithLock : public CIdHashTable, public CHashLock
    {
public:
    CIdHashTableWithLock();
    ~CIdHashTableWithLock();

    HRESULT Init(USHORT usSize1, USHORT usSize2 = 0, USHORT usSize3 = 0);
    HRESULT UnInit();
    };

// inlines

inline CIdHashTableWithLock::CIdHashTableWithLock()
    {
    }

inline CIdHashTableWithLock::~CIdHashTableWithLock()
    {
    UnInit();
    }

inline HRESULT CIdHashTableWithLock::Init
(
USHORT usSize1,
USHORT usSize2,
USHORT usSize3
)
    {
    HRESULT hr = CIdHashTable::Init(usSize1, usSize2, usSize3);
    if (SUCCEEDED(hr))
        hr = CHashLock::Init();

    return hr;
    }

inline HRESULT CIdHashTableWithLock::UnInit()
    {
    CIdHashTable::UnInit();
    CHashLock::UnInit();
    return S_OK;
    }


/*===================================================================
  C  O b j e c t  L i s t  E l e m

Double linked list element
===================================================================*/

struct CObjectListElem
    {
    CObjectListElem *m_pNext;
    CObjectListElem *m_pPrev;

    CObjectListElem();

    void Insert(CObjectListElem *pPrevElem, CObjectListElem *pNextElem);
    void Remove();

    void *PObject(DWORD dwFieldOffset);
    };

inline CObjectListElem::CObjectListElem()
    : m_pNext(NULL), m_pPrev(NULL)
    {
    }

inline void CObjectListElem::Insert
(
CObjectListElem *pPrevElem,
CObjectListElem *pNextElem
)
    {
    Assert(!pPrevElem || (pPrevElem->m_pNext == pNextElem));
    Assert(!pNextElem || (pNextElem->m_pPrev == pPrevElem));

    m_pPrev = pPrevElem;
    m_pNext = pNextElem;

    if (pPrevElem)
        pPrevElem->m_pNext = this;

    if (pNextElem)
        pNextElem->m_pPrev = this;
    }

inline void CObjectListElem::Remove()
    {
    if (m_pPrev)
        m_pPrev->m_pNext = m_pNext;

    if (m_pNext)
        m_pNext->m_pPrev = m_pPrev;

    m_pPrev = m_pNext = NULL;
    }

inline void *CObjectListElem::PObject(DWORD dwFieldOffset)
    {
    return ((BYTE *)this - dwFieldOffset);
    }

// Macro to get the byte offset of a field in a class
#define OBJECT_LIST_ELEM_FIELD_OFFSET(type, field) \
        (PtrToUlong(&(((type *)0)->field)))

inline CObjectListElem *PListElemField
(
void *pvObj,
DWORD dwFieldOffset
)
    {
    if (!pvObj)
        return NULL;
    return (CObjectListElem *)((BYTE *)pvObj + dwFieldOffset);
    }

/*===================================================================
  C  O b j e c t  L i s t

Double linked list of objects
===================================================================*/

class CObjectList
    {
private:
    CObjectListElem m_Head;   // list head
    DWORD m_dwFieldOffset;    // offset to CObjectListElem member field

public:
    CObjectList();
    ~CObjectList();

    HRESULT Init(DWORD dwFieldOffset = 0);
    HRESULT UnInit();

    HRESULT AddObject(void *pvObj);
    HRESULT RemoveObject(void *pvObj);
    HRESULT RemoveAllObjects();

    // iteration
    void *PFirstObject();
    void *PNextObject(void *pvObj);
    };

// inlines

inline CObjectList::CObjectList()
    : m_dwFieldOffset(0)
    {
    }

inline CObjectList::~CObjectList()
    {
    UnInit();
    }

inline HRESULT CObjectList::Init(DWORD dwFieldOffset)
    {
    m_dwFieldOffset = dwFieldOffset;
    m_Head.m_pPrev = m_Head.m_pNext = NULL;
    return S_OK;
    }

inline HRESULT CObjectList::UnInit()
    {
    RemoveAllObjects();
    return S_OK;
    }

inline HRESULT CObjectList::AddObject(void *pvObj)
    {
    Assert(pvObj);
    // insert between head and its next
    PListElemField(pvObj, m_dwFieldOffset)->Insert(&m_Head, m_Head.m_pNext);
    return S_OK;
    }

inline HRESULT CObjectList::RemoveObject(void *pvObj)
    {
    Assert(pvObj);
    PListElemField(pvObj, m_dwFieldOffset)->Remove();
    return S_OK;
    }

inline HRESULT CObjectList::RemoveAllObjects()
    {
    if (m_Head.m_pNext)
        m_Head.m_pNext = NULL;
    return S_OK;
    }

inline void *CObjectList::PFirstObject()
    {
    return m_Head.m_pNext ? m_Head.m_pNext->PObject(m_dwFieldOffset) : NULL;
    }

inline void *CObjectList::PNextObject(void *pvObj)
    {
    CObjectListElem *pNextElem =
        pvObj ? PListElemField(pvObj, m_dwFieldOffset)->m_pNext : NULL;
    return pNextElem ? pNextElem->PObject(m_dwFieldOffset) : NULL;
    }

/*===================================================================
  C  O b j e c t  L i s t  W i t h  L o c k

CObjectList + CRITICAL_SECTION.
===================================================================*/

class CObjectListWithLock : public CObjectList, public CHashLock
    {
public:
    CObjectListWithLock();
    ~CObjectListWithLock();

    HRESULT Init(DWORD dwFieldOffset = 0);
    HRESULT UnInit();
    };

// inlines

inline CObjectListWithLock::CObjectListWithLock()
    {
    }

inline CObjectListWithLock::~CObjectListWithLock()
    {
    UnInit();
    }

inline HRESULT CObjectListWithLock::Init(DWORD dwFieldOffset)
    {
    HRESULT hr = CObjectList::Init(dwFieldOffset);
    if (SUCCEEDED(hr))
        hr = CHashLock::Init();
    return hr;
    }

inline HRESULT CObjectListWithLock::UnInit()
    {
    CObjectList::UnInit();
    CHashLock::UnInit();
    return S_OK;
    }

#endif // ifndef ASP_IDHASH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\ie449.cpp ===
/*===================================================================
Microsoft IIS 5.0 (ASP)

Microsoft Confidential.
Copyright 1998 Microsoft Corporation. All Rights Reserved.

Component: 449 negotiations w/IE

File: ie449.cpp

Owner: DmitryR

This file contains the implementation of the 449 negotiations w/IE
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "ie449.h"
#include "memchk.h"

/*===================================================================
Globals
===================================================================*/

C449FileMgr *m_p449FileMgr = NULL;

/*===================================================================
Internal funcitons
===================================================================*/
inline BOOL FindCookie
(
char *szCookiesBuf,
char *szCookie,
DWORD cbCookie
)
    {
    char *pch = szCookiesBuf;
    if (pch == NULL || *pch == '\0')
        return FALSE;

    while (1)
        {
        if (strnicmp(pch, szCookie, cbCookie) == 0)
            {
            if (pch[cbCookie] == '=')  // next char must be '='
                return TRUE;
            }
            
        // next cookie
        pch = strchr(pch, ';');
        if (pch == NULL)
            break;
        while (*(++pch) == ' ') // skip ; and any spaces
            ;
        }

    return FALSE;
    }


/*===================================================================
The API
===================================================================*/

/*===================================================================
Init449
===================================================================*/
HRESULT Init449()
    {
    // init hash table
    m_p449FileMgr = new C449FileMgr;
    if (m_p449FileMgr == NULL)
        return E_OUTOFMEMORY;

    HRESULT hr = m_p449FileMgr->Init();
    if (FAILED(hr))
        {
        delete m_p449FileMgr;
        m_p449FileMgr = NULL;
        return hr;
        }
    
    return S_OK;
    }
    
/*===================================================================
UnInit449
===================================================================*/
HRESULT UnInit449()
    {
    if (m_p449FileMgr != NULL)
        {
        delete m_p449FileMgr;
        m_p449FileMgr = NULL;
        }
        
    return S_OK;
    }

/*===================================================================
Create449Cookie

Get an existing 449 cookie from cache or create a new one

Parameters
    szName  cookie name
    szFile  script file
    pp449   [out] the cookie

Returns
    HRESULT
===================================================================*/
HRESULT Create449Cookie
(
char *szName, 
TCHAR *szFile, 
C449Cookie **pp449
)
    {
    HRESULT hr = S_OK;
    
    // Get the file first
    C449File *pFile = NULL;
    hr = m_p449FileMgr->GetFile(szFile, &pFile);
    if (FAILED(hr))
        return hr;

    // Create the cookie
    hr = C449Cookie::Create449Cookie(szName, pFile, pp449);
    if (FAILED(hr))
        pFile->Release();  // GetFile gave it addref'd
    
    return hr;
    }

/*===================================================================
Do449Processing

Check
    if the browser is IE5+
    there's no echo-reply: header
    all the cookies are present
    
Construct and send 449 response if needed

When the response is sent, HitObj is marked as 'done with session'
    
Parameters
    pHitObj             the request
    rgpCookies          array of cookie requirements
    cCookies            number of cookie requirements

Returns
    HRESULT
===================================================================*/
HRESULT Do449Processing
(
CHitObj *pHitObj, 
C449Cookie **rgpCookies, 
DWORD cCookies
)
    {
    HRESULT  hr = S_OK;

    if (cCookies == 0)
        return hr;
    
    //////////////////////////////////////////
    // check the browser

    BOOL fBrowser = FALSE;
    char *szBrowser = pHitObj->PIReq()->QueryPszUserAgent();
    if (szBrowser == NULL || szBrowser[0] == '\0')
        return S_OK; // bad browser
    
    char *szMSIE = strstr(szBrowser, "MSIE ");
    if (szMSIE)
        {
        char chVersion = szMSIE[5];
        if (chVersion >= '5' && chVersion <= '9')
            fBrowser = TRUE;
        }

#ifdef TINYGET449
    if (strcmp(szBrowser, "WBCLI") == 0)
        fBrowser = TRUE;
#endif

    if (!fBrowser)  // bad browser
        return S_OK;

    //////////////////////////////////////////
    // check the cookies
    
    char *szCookie = pHitObj->PIReq()->QueryPszCookie();

    // collect the arrays of pointers and sizes for not found cookies.
    // arrays size to at most number of cookies in the template.
    DWORD cNotFound = 0;
    DWORD cbNotFound = 0;
    STACK_BUFFER( tempCookiePtrs, 128 );
    STACK_BUFFER( tempCookieCBs, 128 );

    if (!tempCookiePtrs.Resize(cCookies * sizeof(void *))
        || !tempCookieCBs.Resize(cCookies * sizeof(DWORD))) {
        return E_OUTOFMEMORY;
    }
    void **rgpvNotFound = (void **)tempCookiePtrs.QueryPtr();
    DWORD *rgcbNotFound = (DWORD *)tempCookieCBs.QueryPtr();
    
    for (DWORD i = 0; SUCCEEDED(hr) && (i < cCookies); i++)
        {
        if (!FindCookie(szCookie, rgpCookies[i]->SzCookie(), rgpCookies[i]->CbCookie()))
            {
            // cookie not found -- append to the list

            hr = rgpCookies[i]->LoadFile();
            if (SUCCEEDED(hr)) // ignore bad files
                {
                rgpvNotFound[cNotFound] = rgpCookies[i]->SzBuffer();
                rgcbNotFound[cNotFound] = rgpCookies[i]->CbBuffer();
                cbNotFound += rgpCookies[i]->CbBuffer();
                cNotFound++;
                }
            }
        }

    if (!SUCCEEDED(hr))
        return hr;

    if (cNotFound == 0)
        return S_OK;    // everything's found    

    //////////////////////////////////////////
    // check echo-reply header

    char szEcho[80];
    DWORD dwEchoLen = sizeof(szEcho);
	if (pHitObj->PIReq()->GetServerVariableA("HTTP_MS_ECHO_REPLY", szEcho, &dwEchoLen) 
	    || GetLastError() == ERROR_INSUFFICIENT_BUFFER)
	    {
		return S_OK;   // already in response cycle
		}
    
    //////////////////////////////////////////
    // send the 449 response

    CResponse::SyncWriteBlocks
        (
        pHitObj->PIReq(),    // WAM_EXEC_INFO
        cNotFound,          // number of blocks
        cbNotFound,         // total number of bytes in blocks
        rgpvNotFound,       // array of block pointers
        rgcbNotFound,       // array of block sizes
        NULL,               // text/html
        "449 Retry with",   // status
        "ms-echo-request: execute opaque=\"0\" location=\"BODY\"\r\n"  // extra header
        );

    //////////////////////////////////////////
    // tell HitObj no to write anything else

    if (pHitObj->FExecuting()) // on MTS worker thread?
        {
		DWORD dwRequestStatus = HSE_STATUS_SUCCESS_AND_KEEP_CONN;
        pHitObj->PIReq()->ServerSupportFunction
            (
		    HSE_REQ_DONE_WITH_SESSION,
    		&dwRequestStatus,
        	0,
		    NULL
    		);
  		}
    pHitObj->SetDoneWithSession();

    return S_OK;
    }

/*===================================================================
Do449ChangeNotification

Change notification processing
    
Parameters
    szFile  file changed or NULL for all
    
Returns
    HRESULT
===================================================================*/
HRESULT Do449ChangeNotification
(
TCHAR *szFile
)
    {
    if (szFile)
        return m_p449FileMgr->Flush(szFile);
    else
        return m_p449FileMgr->FlushAll();
    }


/*===================================================================
Class C449File
===================================================================*/

/*===================================================================
C449File::C449File

Constructor
===================================================================*/
C449File::C449File()
    {
    m_cRefs = 0;
    m_fNeedLoad = 0;
    m_szFile = NULL;
    m_szBuffer = NULL;
    m_cbBuffer = 0;
    m_pDME = NULL;
    }

/*===================================================================
C449File::~C449File

Destructor
===================================================================*/
C449File::~C449File()
    {
    Assert(m_cRefs == 0);
    if (m_szFile)
        free(m_szFile);
    if (m_szBuffer)
        free(m_szBuffer);
    if (m_pDME)
        m_pDME->Release();
    }

/*===================================================================
C449File::Init

Init strings, 
Load file for the first time,
Start change notifications
===================================================================*/
HRESULT C449File::Init
(
TCHAR *szFile
)
    {
    // remember the name
    m_szFile = StringDup(szFile);
    if (m_szFile == NULL)
        return E_OUTOFMEMORY;

    // init link element
    CLinkElem::Init(m_szFile, _tcslen(m_szFile)*sizeof(TCHAR));

    // load
    m_fNeedLoad = 1;
    HRESULT hr = Load();
    if (FAILED(hr))
        return hr;

    // start directory notifications
    TCHAR *pch = _tcsrchr(m_szFile, _T('\\')); // last backslash
    if (pch == NULL)
        return E_FAIL; // bogus filename?
    CASPDirMonitorEntry *pDME = NULL;
    *pch = _T('\0');
    RegisterASPDirMonitorEntry(m_szFile, &pDME);
    *pch = _T('\\');
    m_pDME = pDME;
    
    // done
    return S_OK;    
    }
    
/*===================================================================
C449File::Load

Load the file if needed
===================================================================*/
HRESULT C449File::Load()
    {
    HRESULT hr = S_OK;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HANDLE hMap = NULL;
    BYTE *pbBytes = NULL;
    DWORD dwSize = 0;

    // check if this thread needs to load the file
    if (InterlockedExchange(&m_fNeedLoad, 0) == 0)
        return S_OK;
        
    // cleanup the existing data if any
    if (m_szBuffer)
        free(m_szBuffer);
    m_szBuffer = NULL;        
    m_cbBuffer = 0;
        
    // open the file
    if (SUCCEEDED(hr))
        {
        hFile = CreateFile(
            m_szFile,
            GENERIC_READ,          // access (read-write) mode
            FILE_SHARE_READ,       // share mode
            NULL,                  // pointer to security descriptor
            OPEN_EXISTING,         // how to create
            FILE_ATTRIBUTE_NORMAL, // file attributes
            NULL                   // handle to file with attributes to copy
    		);
        if (hFile == INVALID_HANDLE_VALUE)
            hr = E_FAIL;
        }

    // get file size
    if (SUCCEEDED(hr))
        {
        dwSize = GetFileSize(hFile, NULL);
        if (dwSize == 0 || dwSize == 0xFFFFFFFF)
            hr = E_FAIL;
        }

    // create mapping
    if (SUCCEEDED(hr))
        {
        hMap = CreateFileMapping(
            hFile, 		    // handle to file to map 
            NULL,           // optional security attributes 
            PAGE_READONLY,  // protection for mapping object 
            0,              // high-order 32 bits of object size  
            0,              // low-order 32 bits of object size  
            NULL            // name of file-mapping object 
            );
        if (hMap == NULL)
            hr = E_FAIL;
        }
        
    // map the file
    if (SUCCEEDED(hr))
        {
        pbBytes = (BYTE *)MapViewOfFile(
            hMap,           // file-mapping object to map into address space
            FILE_MAP_READ,  // access mode 	
            0,              // high-order 32 bits of file offset 
            0,              // low-order 32 bits of file offset 
            0               // number of bytes to map 
			);
        if (pbBytes == NULL)
            hr = E_FAIL;
        }

    // remember the bytes
    if (SUCCEEDED(hr))
        {
        m_szBuffer = (char *)malloc(dwSize);
        if (m_szBuffer != NULL)
            {
            memcpy(m_szBuffer, pbBytes, dwSize);
            m_cbBuffer = dwSize;
            }
        else
            {
            hr = E_OUTOFMEMORY;
            }
        }

    // cleanup
    if (pbBytes != NULL)
        UnmapViewOfFile(pbBytes);
    if (hMap != NULL)
        CloseHandle(hMap);
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);

    if (!SUCCEEDED(hr))
        SetNeedLoad();

    return hr;
    }

/*===================================================================
C449File::Create449File

static constructor
===================================================================*/
HRESULT C449File::Create449File
(
TCHAR *szFile,
C449File **ppFile
)
    {
    HRESULT hr = S_OK;
    C449File *pFile = new C449File;
    if (pFile == NULL)
        hr = E_OUTOFMEMORY;

    if (SUCCEEDED(hr))
        {
        hr = pFile->Init(szFile);
        }
        
    if (SUCCEEDED(hr))
        {
        pFile->AddRef();
        *ppFile = pFile;
        }
    else if (pFile)
        {
        delete pFile;
        }
    return hr;
    }

/*===================================================================
C449File::QueryInterface
C449File::AddRef
C449File::Release

IUnknown members for C449File object.
===================================================================*/
STDMETHODIMP C449File::QueryInterface(REFIID riid, VOID **ppv)
	{
	// should never be called
	Assert(FALSE);
	*ppv = NULL;
	return E_NOINTERFACE;
	}
	
STDMETHODIMP_(ULONG) C449File::AddRef()
	{
	return InterlockedIncrement(&m_cRefs);
	}
	
STDMETHODIMP_(ULONG) C449File::Release()
	{
    LONG cRefs = InterlockedDecrement(&m_cRefs);
	if (cRefs)
		return cRefs;
	delete this;
	return 0;
	}


/*===================================================================
Class C449FileMgr
===================================================================*/

/*===================================================================
C449FileMgr::C449FileMgr

Constructor
===================================================================*/
C449FileMgr::C449FileMgr()
    {
    INITIALIZE_CRITICAL_SECTION(&m_csLock);
    }

/*===================================================================
C449FileMgr::~C449FileMgr

Destructor
===================================================================*/
C449FileMgr::~C449FileMgr()
    {
    FlushAll();
    m_ht449Files.UnInit();
    DeleteCriticalSection(&m_csLock);
    }

/*===================================================================
C449FileMgr::Init

Initialization
===================================================================*/
HRESULT C449FileMgr::Init()
    {
    return m_ht449Files.Init(199);
    }

/*===================================================================
C449FileMgr::GetFile

Find file in the hash table, or create a new one
===================================================================*/
HRESULT C449FileMgr::GetFile
(
TCHAR *szFile, 
C449File **ppFile
)
    {
    C449File *pFile = NULL;
    CLinkElem *pElem;

    Lock();
    
    pElem = m_ht449Files.FindElem(szFile, _tcslen(szFile)*sizeof(TCHAR));
    
    if (pElem)
        {
        // found
        pFile = static_cast<C449File *>(pElem);
        if (!SUCCEEDED(pFile->Load()))
            pFile = NULL;
        else 
            pFile->AddRef();    // 1 ref to hand out
        }
    else if (SUCCEEDED(C449File::Create449File(szFile, &pFile)))
        {
        if (m_ht449Files.AddElem(pFile))
            pFile->AddRef();    // 1 for hash table + 1 to hand out
        }

    UnLock();
    
    *ppFile = pFile;
    return (pFile != NULL) ? S_OK : E_FAIL;
    }

/*===================================================================
C449FileMgr::Flush

Change notification for a single file
===================================================================*/
HRESULT C449FileMgr::Flush
(
TCHAR *szFile
)
    {
    Lock();
    
    CLinkElem *pElem = m_ht449Files.FindElem(szFile, _tcslen(szFile)*sizeof(TCHAR));
    if (pElem)
        {
        C449File *pFile = static_cast<C449File *>(pElem);
        pFile->SetNeedLoad(); // next time reload
        }

    UnLock();
    return S_OK;
    }
    
/*===================================================================
C449FileMgr::FlushAll

Remove all files
FlushAll is always together with template flush
===================================================================*/
HRESULT C449FileMgr::FlushAll()
    {
    // Unlink from hash table first
    Lock();
    CLinkElem *pElem = m_ht449Files.Head();
    m_ht449Files.ReInit();
    UnLock();

    // Walk the list to remove all
    while (pElem)
        {
        C449File *pFile = static_cast<C449File *>(pElem);
        pElem = pElem->m_pNext;
        pFile->Release();
        }
    
    return S_OK;
    }

/*===================================================================
Class C449Cookie
===================================================================*/

/*===================================================================
C449Cookie::C449Cookie

Constructor
===================================================================*/
C449Cookie::C449Cookie()
    {
    m_cRefs = 0;
    m_szName = NULL;
    m_cbName = 0;
    m_pFile = NULL;
    }

/*===================================================================
C449Cookie::~C449Cookie

Destructor
===================================================================*/
C449Cookie::~C449Cookie()
    {
    Assert(m_cRefs == 0);
    if (m_szName)
        free(m_szName);
    if (m_pFile)
        m_pFile->Release();
    }

/*===================================================================
C449Cookie::Init

Initialize
===================================================================*/
HRESULT C449Cookie::Init
(
char *szName, 
C449File *pFile
)
    {
    m_szName = StringDupA(szName);
    if (m_szName == NULL)
        return E_OUTOFMEMORY;
    m_cbName = strlen(m_szName);
    
    m_pFile = pFile;
    return S_OK;
    }

/*===================================================================
C449Cookie::Create449Cookie

static constructor
===================================================================*/
HRESULT C449Cookie::Create449Cookie
(
char *szName, 
C449File *pFile,
C449Cookie **pp449Cookie
)
    {
    HRESULT hr = S_OK;
    C449Cookie *pCookie = new C449Cookie;
    if (pCookie == NULL)
        hr = E_OUTOFMEMORY;

    if (SUCCEEDED(hr))
        {
        hr = pCookie->Init(szName, pFile);
        }
        
    if (SUCCEEDED(hr))
        {
        pCookie->AddRef();
        *pp449Cookie = pCookie;
        }
    else if (pCookie)
        {
        delete pCookie;
        }
        
    return hr;
    }

/*===================================================================
C449Cookie::QueryInterface
C449Cookie::AddRef
C449Cookie::Release

IUnknown members for C449Cookie object.
===================================================================*/
STDMETHODIMP C449Cookie::QueryInterface(REFIID riid, VOID **ppv)
	{
	// should never be called
	Assert(FALSE);
	*ppv = NULL;
	return E_NOINTERFACE;
	}
	
STDMETHODIMP_(ULONG) C449Cookie::AddRef()
	{
	return InterlockedIncrement(&m_cRefs);
	}
	
STDMETHODIMP_(ULONG) C449Cookie::Release()
	{
    LONG cRefs = InterlockedDecrement(&m_cRefs);
	if (cRefs)
		return cRefs;
	delete this;
	return 0;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\linkhash.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Hash tables with LRU threading 

File: LinkHash.cpp

Owner: DGottner

This is the Link list and Hash table for use by any classes which
also need LRU access to items. (This includes cache manager,
script manager, and session deletion code)
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "LinkHash.h"
#include "memchk.h"



/*------------------------------------------------------------------
 * C L i n k H a s h
 */

/*===================================================================
CLinkHash::CLinkHash

Constructor for CLinkHash

Parameters:
    NONE

Returns:
    NONE
===================================================================*/
CLinkHash::CLinkHash( HashFunction pfnHash )
    : CHashTable( pfnHash )
{
}

/*===================================================================
CLinkHash::AddElem

Parameters:
    pElem - item to add to the table.  The item is marked as the most
            recently accessed.

Returns:
    Returns a pointer to the item added
===================================================================*/

CLruLinkElem *CLinkHash::AddElem(CLruLinkElem *pElem, BOOL fTestDups)
    {
    AssertValid();

    CLruLinkElem *pElemAdded = static_cast<CLruLinkElem *>(CHashTable::AddElem(pElem, fTestDups));
    pElemAdded->PrependTo(m_lruHead);

    AssertValid();
    return pElemAdded;
    }



/*===================================================================
CLinkHash::FindElem

Parameters:
    pvKey - pointer to the key to insert
    cbKey - number of bytes in the key

Returns:
    NULL if the key is not in the hash table, otherwise it returns
    a pointer to the key's record.  If the key is found, it is
    moved to the front of the list.
===================================================================*/

CLruLinkElem *CLinkHash::FindElem(const void *pvKey, int cbKey)
    {
    AssertValid();

    CLruLinkElem *pElemFound = static_cast<CLruLinkElem *>(CHashTable::FindElem(pvKey, cbKey));
    if (pElemFound)
        {
        pElemFound->PrependTo(m_lruHead);
        AssertValid();
        }

    return pElemFound;
    }



/*===================================================================
CLinkHash::DeleteElem

Parameters:
    pvKey - pointer to the key to delete
    cbKey - number of bytes in the key

Returns:
    NULL if the key is not in the hash table, otherwise it returns
    a pointer to the key's record.  If the key is found, it is
    removed from the hash table and the LRU list.
===================================================================*/

CLruLinkElem *CLinkHash::DeleteElem(const void *pvKey, int cbKey)
    {
    AssertValid();

    CLruLinkElem *pElemFound = static_cast<CLruLinkElem *>(CHashTable::DeleteElem(pvKey, cbKey));
    if (pElemFound)
        pElemFound->UnLink();

    AssertValid();
    return pElemFound;
    }



/*===================================================================
CLinkHash::RemoveElem

Parameters:
    pvKey - pointer to the key to delete
    cbKey - number of bytes in the key

Returns:
    NULL if the key is not in the hash table, otherwise it returns
    a pointer to the key's record.  If the key is found, it is
    removed from the hash table and the LRU list.
===================================================================*/

CLruLinkElem *CLinkHash::RemoveElem(CLruLinkElem *pElem)
    {
    AssertValid();

    CLruLinkElem *pElemRemoved = static_cast<CLruLinkElem *>(CHashTable::RemoveElem(pElem));

    Assert (pElemRemoved);
    pElemRemoved->UnLink();

    AssertValid();
    return pElemRemoved;
    }



/*===================================================================
CLinkHash::AssertValid

verify the integrity of the data structure
===================================================================*/

#ifdef DBG
void CLinkHash::AssertValid() const
    {
    // NOTE: avoid calling CHashTable::AssertValid as long as hash table primitives are calling it.
    //  CHashTable::AssertValid();

    m_lruHead.AssertValid();
    for (CDblLink *pLink = m_lruHead.PNext(); pLink != &m_lruHead; pLink = pLink->PNext())
        pLink->AssertValid();
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\isapireq.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: CIsapiReqInfo Object

File: IsapiReq.h

Owner: AndyMorr

===================================================================*/
#ifndef ISAPIREQ_H
#define ISAPIREQ_H

#include <iadmw.h>

#if _IIS_5_1
#include <wamxinfo.hxx>
#else
#include <string.hxx>
#endif

#include "memcls.h"

/*
    Mappings of CIsapiReqInfo methods to the proper routines based
    on the UNICODE setting
*/
#ifdef UNICODE
#define QueryPszPathInfo        QueryPszPathInfoW
#define QueryCchPathInfo        QueryCchPathInfoW
#define QueryPszPathTranslated  QueryPszPathTranslatedW
#define QueryCchPathTranslated  QueryCchPathTranslatedW
#define QueryPszApplnMDPath     QueryPszApplnMDPathW
#define QueryCchApplnMDPath     QueryCchApplnMDPathW
#define MapUrlToPath            MapUrlToPathW
#define GetCustomError          GetCustomErrorW
#define GetAspMDData            GetAspMDDataW
#define GetAspMDAllData         GetAspMDAllDataW
#define GetServerVariable       GetServerVariableW
#else
#define QueryPszPathInfo        QueryPszPathInfoA
#define QueryCchPathInfo        QueryCchPathInfoA
#define QueryPszPathTranslated  QueryPszPathTranslatedA
#define QueryCchPathTranslated  QueryCchPathTranslatedA
#define QueryPszApplnMDPath     QueryPszApplnMDPathA
#define QueryCchApplnMDPath     QueryCchApplnMDPathA
#define MapUrlToPath            MapUrlToPathA
#define GetCustomError          GetCustomErrorA
#define GetAspMDData            GetAspMDDataA
#define GetAspMDAllData         GetAspMDAllDataA
#define GetServerVariable       GetServerVariableA
#endif

/*===================================================================
  C I s a p i R e q I n f o
  
Class which encapsulates Request info we need from the ISAPI interface.
Information either comes from the public ISAPI interfaces (SSE and
ServerVariables) or from the private WAM_EXEC_INFO.

===================================================================*/

class CIsapiReqInfo {

private:

    LONG    m_cRefs;
#if _IIS_5_1
    // Associated WAM_EXEC_INFO (for browser requests)
    WAM_EXEC_INFO   *m_pWXI;
#endif

    EXTENSION_CONTROL_BLOCK *m_pECB;

    int     m_cchQueryString;
    int     m_cchApplnMDPathA;
    int     m_cchPathTranslatedA;
    int     m_cchPathInfoA;
    int     m_cchApplnMDPathW;
    int     m_cchPathTranslatedW;
    int     m_cchPathInfoW;

    DWORD   m_fApplnMDPathAInited    : 1;
    DWORD   m_fApplnMDPathWInited    : 1;
    DWORD   m_fPathInfoWInited       : 1;
    DWORD   m_fPathTranslatedWInited : 1;
    DWORD   m_fCookieInited          : 1;
    DWORD   m_fUserAgentInited       : 1;
    DWORD   m_fInstanceIDInited      : 1;
    DWORD   m_fVersionInited         : 1;
    DWORD   m_fFKeepConnInited       : 1;

    DWORD   m_dwInstanceID;

    DWORD   m_dwVersionMajor;
    DWORD   m_dwVersionMinor;

    BOOL    m_fKeepConn;

    BUFFER  m_ApplnMDPathA;
    BUFFER  m_ApplnMDPathW;
    BUFFER  m_PathInfoW;
    BUFFER  m_PathTranslatedW;
    BUFFER  m_Cookie;
    BUFFER  m_UserAgent;

    IMSAdminBase    *m_pIAdminBase;

public:

    CIsapiReqInfo(EXTENSION_CONTROL_BLOCK *pECB) {

        m_cRefs = 1;

        m_fApplnMDPathAInited = 0;
        m_fApplnMDPathWInited = 0;
        m_fPathInfoWInited    = 0;
        m_fPathTranslatedWInited    = 0;
        m_fCookieInited       = 0;
        m_fUserAgentInited    = 0;
        m_fInstanceIDInited   = 0;
        m_fVersionInited      = 0;
        m_fFKeepConnInited    = 0;

        m_dwInstanceID        = 0;
        
        m_dwVersionMajor      = 1;
        m_dwVersionMinor      = 0;

        m_cchQueryString      = -1;
        m_cchApplnMDPathA     = -1;
        m_cchPathTranslatedA  = -1;
        m_cchPathInfoA        = -1;
        m_cchApplnMDPathW     = -1;
        m_cchPathTranslatedW  = -1;
        m_cchPathInfoW        = -1;

        m_fKeepConn           = FALSE;

        m_pIAdminBase         = NULL;

#if _IIS_5_1
        m_pWXI                = QueryPWAM_EXEC_INFOfromPECB(pECB);
#endif

        m_pECB                = pECB;
    }

    ~CIsapiReqInfo() {
        if (m_pIAdminBase != NULL) {
            m_pIAdminBase->Release();
            m_pIAdminBase = NULL;
        }
    }

    LONG    AddRef() {
        return InterlockedIncrement(&m_cRefs);
    }

    LONG    Release() {
        LONG    cRefs = InterlockedDecrement(&m_cRefs);
        if (cRefs == 0) {
            delete this;
        }
        return cRefs;
    }

#if _IIS_5_1
    EXTENSION_CONTROL_BLOCK     *ECB() { return &m_pWXI->ecb; }
#else
    EXTENSION_CONTROL_BLOCK     *ECB() { return m_pECB; }
#endif

    LPSTR QueryPszQueryString();

    DWORD QueryCchQueryString();

    LPSTR QueryPszApplnMDPathA();

    DWORD QueryCchApplnMDPathA();

    LPWSTR QueryPszApplnMDPathW();

    DWORD QueryCchApplnMDPathW();

    LPSTR QueryPszPathInfoA();

    DWORD QueryCchPathInfoA();

    LPWSTR QueryPszPathInfoW();

    DWORD QueryCchPathInfoW();

    LPSTR QueryPszPathTranslatedA();
    
    DWORD QueryCchPathTranslatedA();

    LPWSTR QueryPszPathTranslatedW();
    
    DWORD QueryCchPathTranslatedW();

    LPSTR QueryPszCookie();

    VOID  SetDwHttpStatusCode( DWORD dwStatus );

    LPBYTE QueryPbData();

    DWORD QueryCbAvailable();

    DWORD QueryCbTotalBytes();

    LPSTR QueryPszContentType();

    LPSTR QueryPszMethod();

    LPSTR QueryPszUserAgent();

    DWORD QueryInstanceId();

    BOOL  IsChild();

    BOOL FInPool();

    DWORD QueryHttpVersionMajor();

    DWORD QueryHttpVersionMinor();

    HRESULT ISAThreadNotify( BOOL fStart );

    HRESULT GetAspMDDataA(CHAR          * pszMDPath,
                          DWORD           dwMDIdentifier,
                          DWORD           dwMDAttributes,
                          DWORD           dwMDUserType,
                          DWORD           dwMDDataType,
                          DWORD           dwMDDataLen,
                          DWORD           dwMDDataTag,
                          unsigned char * pbMDData,
                          DWORD *         pdwRequiredBufferSize);

    HRESULT GetAspMDDataW(WCHAR         * pszMDPath,
                          DWORD           dwMDIdentifier,
                          DWORD           dwMDAttributes,
                          DWORD           dwMDUserType,
                          DWORD           dwMDDataType,
                          DWORD           dwMDDataLen,
                          DWORD           dwMDDataTag,
                          unsigned char * pbMDData,
                          DWORD *         pdwRequiredBufferSize);

    HRESULT GetAspMDAllDataA(CHAR  * pszMDPath,
                             DWORD   dwMDUserType,
                             DWORD   dwDefaultBufferSize,
                             LPVOID  pvBuffer,
                             DWORD * pdwRequiredBufferSize,
                             DWORD * pdwNumDataEntries);

    HRESULT GetAspMDAllDataW(WCHAR  * pszMDPath,
                             DWORD   dwMDUserType,
                             DWORD   dwDefaultBufferSize,
                             LPVOID  pvBuffer,
                             DWORD * pdwRequiredBufferSize,
                             DWORD * pdwNumDataEntries);

    BOOL GetCustomErrorA(DWORD dwError,
                         DWORD dwSubError,
                         DWORD dwBufferSize,
                         CHAR  *pvBuffer,
                         DWORD *pdwRequiredBufferSize,
                         BOOL  *pfIsFileError);

    BOOL GetCustomErrorW(DWORD dwError,
                         DWORD dwSubError,
                         DWORD dwBufferSize,
                         WCHAR *pvBuffer,
                         DWORD *pdwRequiredBufferSize,
                         BOOL  *pfIsFileError);

    HANDLE QueryImpersonationToken();

    HRESULT AppendLogParameter( LPSTR szExtraParam );

    BOOL SendHeader(LPVOID pvStatus,
                    DWORD  cchStatus,
                    LPVOID pvHeader,
                    DWORD  cchHeader,
                    BOOL   fIsaKeepConn);

    BOOL GetServerVariableA(LPSTR   szVarName, 
                            LPSTR   pBuffer, 
                            LPDWORD pdwSize );

    BOOL GetServerVariableW(LPSTR   szVarName,
                            LPWSTR  pBuffer,
                            LPDWORD pdwSize);

    BOOL ServerSupportFunction(DWORD   dwHSERequest,
                               LPVOID  pvData, 
                               LPDWORD pdwSize, 
                               LPDWORD pdwDataType);

    BOOL SendEntireResponseOop(IN HSE_SEND_ENTIRE_RESPONSE_INFO * pHseResponseInfo);

    BOOL SendEntireResponse(IN HSE_SEND_ENTIRE_RESPONSE_INFO * pHseResponseInfo);

    BOOL TestConnection(BOOL  *pfIsConnected);

    BOOL MapUrlToPathA(LPSTR pBuffer, LPDWORD pdwBytes);

    BOOL MapUrlToPathW(LPWSTR pBuffer, LPDWORD pdwBytes);

    BOOL SyncReadClient(LPVOID pvBuffer, LPDWORD pdwBytes );

    BOOL SyncWriteClient(LPVOID pvBuffer, LPDWORD pdwBytes);

private:

    void             InitVersionInfo();

    IMSAdminBase    *GetMetabaseIF();

    BOOL             InternalGetServerVariable(LPSTR  pszVar, BUFFER  *pBuffer);

    BOOL             FKeepConn();

    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\largeint.h ===
/*--

Module Name:

    largeint.h

Abstract:

    Include file for sample Large Integer Arithmetic routines.  
    This file includes all of the prototypes for the routines found in 
    largeint.lib.  For complete descriptions of these functions, see the
    largeint.s source file for MIPS, or the divlarge.c and largeint.asm 
    source files for x86. 

Revision History:

--*/

#ifdef __cplusplus
extern "C" {
#endif

//
//Large integer arithmetic routines.
//

//
// Large integer add - 64-bits + 64-bits -> 64-bits
//

LARGE_INTEGER
WINAPI
LargeIntegerAdd (
    LARGE_INTEGER Addend1,
    LARGE_INTEGER Addend2
    );

//
// Enlarged integer multiply - 32-bits * 32-bits -> 64-bits
//

LARGE_INTEGER
WINAPI
EnlargedIntegerMultiply (
    LONG Multiplicand,
    LONG Multiplier
    );

//
// Unsigned enlarged integer multiply - 32-bits * 32-bits -> 64-bits
//

LARGE_INTEGER
WINAPI
EnlargedUnsignedMultiply (
    ULONG Multiplicand,
    ULONG Multiplier
    );

//
// Enlarged integer divide - 64-bits / 32-bits > 32-bits
//

ULONG
WINAPI
EnlargedUnsignedDivide (
    IN ULARGE_INTEGER Dividend,
    IN ULONG Divisor,
    IN PULONG Remainder
    );

//
// Extended large integer magic divide - 64-bits / 32-bits -> 64-bits
//

LARGE_INTEGER
WINAPI
ExtendedMagicDivide (
    LARGE_INTEGER Dividend,
    LARGE_INTEGER MagicDivisor,
    CCHAR ShiftCount
    );

//
// Large Integer divide - 64-bits / 32-bits -> 64-bits
//

LARGE_INTEGER
WINAPI
ExtendedLargeIntegerDivide (
    LARGE_INTEGER Dividend,
    ULONG Divisor,
    PULONG Remainder
    );

//
// Large Integer divide - 64-bits / 32-bits -> 64-bits
//

LARGE_INTEGER
WINAPI
LargeIntegerDivide (
    LARGE_INTEGER Dividend,
    LARGE_INTEGER Divisor,
    PLARGE_INTEGER Remainder
    );

//
// Extended integer multiply - 32-bits * 64-bits -> 64-bits
//

LARGE_INTEGER
WINAPI
ExtendedIntegerMultiply (
    LARGE_INTEGER Multiplicand,
    LONG Multiplier
    );

//
// Large integer negation - -(64-bits)
//

LARGE_INTEGER
WINAPI
LargeIntegerNegate (
    LARGE_INTEGER Subtrahend
    );

//
// Large integer subtract - 64-bits - 64-bits -> 64-bits.
//

LARGE_INTEGER
WINAPI
LargeIntegerSubtract (
    LARGE_INTEGER Minuend,
    LARGE_INTEGER Subtrahend
    );

//
// Large integer and - 64-bite & 64-bits -> 64-bits.
//

#define LargeIntegerAnd(Result, Source, Mask)   \
        {                                           \
            Result.HighPart = Source.HighPart & Mask.HighPart; \
            Result.LowPart = Source.LowPart & Mask.LowPart; \
        }


//
// Large integer conversion routines.
//

//
// Convert signed integer to large integer.
//

LARGE_INTEGER
WINAPI
ConvertLongToLargeInteger (
    LONG SignedInteger
    );

//
// Convert unsigned integer to large integer.
//

LARGE_INTEGER
WINAPI
ConvertUlongToLargeInteger (
    ULONG UnsignedInteger
    );


//
// Large integer shift routines.
//

LARGE_INTEGER
WINAPI
LargeIntegerShiftLeft (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    );

LARGE_INTEGER
WINAPI
LargeIntegerShiftRight (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    );

LARGE_INTEGER
WINAPI
LargeIntegerArithmeticShift (
    LARGE_INTEGER LargeInteger,
    CCHAR ShiftCount
    );

#define LargeIntegerGreaterThan(X,Y) (                              \
    (((X).HighPart == (Y).HighPart) && ((X).LowPart > (Y).LowPart)) || \
    ((X).HighPart > (Y).HighPart)                                      \
)

#define LargeIntegerGreaterThanOrEqualTo(X,Y) (                      \
    (((X).HighPart == (Y).HighPart) && ((X).LowPart >= (Y).LowPart)) || \
    ((X).HighPart > (Y).HighPart)                                       \
)

#define LargeIntegerEqualTo(X,Y) (                              \
    !(((X).LowPart ^ (Y).LowPart) | ((X).HighPart ^ (Y).HighPart)) \
)

#define LargeIntegerNotEqualTo(X,Y) (                          \
    (((X).LowPart ^ (Y).LowPart) | ((X).HighPart ^ (Y).HighPart)) \
)

#define LargeIntegerLessThan(X,Y) (                                 \
    (((X).HighPart == (Y).HighPart) && ((X).LowPart < (Y).LowPart)) || \
    ((X).HighPart < (Y).HighPart)                                      \
)

#define LargeIntegerLessThanOrEqualTo(X,Y) (                         \
    (((X).HighPart == (Y).HighPart) && ((X).LowPart <= (Y).LowPart)) || \
    ((X).HighPart < (Y).HighPart)                                       \
)

#define LargeIntegerGreaterThanZero(X) (       \
    (((X).HighPart == 0) && ((X).LowPart > 0)) || \
    ((X).HighPart > 0 )                           \
)

#define LargeIntegerGreaterOrEqualToZero(X) ( \
    (X).HighPart >= 0                            \
)

#define LargeIntegerEqualToZero(X) ( \
    !((X).LowPart | (X).HighPart)       \
)

#define LargeIntegerNotEqualToZero(X) ( \
    ((X).LowPart | (X).HighPart)           \
)

#define LargeIntegerLessThanZero(X) ( \
    ((X).HighPart < 0)                   \
)

#define LargeIntegerLessOrEqualToZero(X) (           \
    ((X).HighPart < 0) || !((X).LowPart | (X).HighPart) \
)

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\isapireq.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: CIsapiReqInfo implementation....

File: IsapiReq.cpp

Owner: AndyMorr

===================================================================*/
#include "denpre.h"
#pragma hdrstop

// undef these here so that we can call the WXI and ECB functions with
// the same name and not be victims of the substituition.
 
#undef MapUrlToPath           
#undef GetCustomError         
#undef GetAspMDData           
#undef GetAspMDAllData        
#undef GetServerVariable      

/*===================================================================
CIsapiReqInfo::QueryPszQueryString
===================================================================*/
LPSTR CIsapiReqInfo::QueryPszQueryString()
{
    return m_pECB->lpszQueryString;
}

/*===================================================================
CIsapiReqInfo::QueryCchQueryString
===================================================================*/
DWORD CIsapiReqInfo::QueryCchQueryString()
{
    if (m_cchQueryString == -1) {
        m_cchQueryString = QueryPszQueryString() ? strlen(QueryPszQueryString()) : 0;
    }

    return m_cchQueryString;
}

/*===================================================================
CIsapiReqInfo::QueryPszApplnMDPathA
===================================================================*/
LPSTR CIsapiReqInfo::QueryPszApplnMDPathA()
{
    if (m_fApplnMDPathAInited == FALSE) {
        *((LPSTR)m_ApplnMDPathA.QueryPtr()) = '\0';
        m_fApplnMDPathAInited = InternalGetServerVariable("APPL_MD_PATH", &m_ApplnMDPathA);
    }

    ASSERT(m_fApplnMDPathAInited);

    return (LPSTR)m_ApplnMDPathA.QueryPtr();
}

/*===================================================================
CIsapiReqInfo::QueryCchApplnMDPathA
===================================================================*/
DWORD CIsapiReqInfo::QueryCchApplnMDPathA()
{
    if (m_cchApplnMDPathA == -1) {
        m_cchApplnMDPathA = QueryPszApplnMDPathA() 
                                ? strlen(QueryPszApplnMDPathA())
                                : 0;
    }
    
    return(m_cchApplnMDPathA);
}

/*===================================================================
CIsapiReqInfo::QueryPszApplnMDPathW
===================================================================*/
LPWSTR CIsapiReqInfo::QueryPszApplnMDPathW()
{
    if (m_fApplnMDPathWInited == FALSE) {
        *((LPWSTR)m_ApplnMDPathW.QueryPtr()) = L'\0';
        m_fApplnMDPathWInited = InternalGetServerVariable("UNICODE_APPL_MD_PATH", &m_ApplnMDPathW);
    }

    ASSERT(m_fApplnMDPathWInited);

    return (LPWSTR)m_ApplnMDPathW.QueryPtr();
}

/*===================================================================
CIsapiReqInfo::QueryCchApplnMDPathW
===================================================================*/
DWORD CIsapiReqInfo::QueryCchApplnMDPathW()
{
    if (m_cchApplnMDPathW == -1) {
        m_cchApplnMDPathW = QueryPszApplnMDPathW() 
                                ? wcslen(QueryPszApplnMDPathW())
                                : 0;
    }
    
    return(m_cchApplnMDPathW);
}

/*===================================================================
CIsapiReqInfo::QueryPszPathInfoA
===================================================================*/
LPSTR CIsapiReqInfo::QueryPszPathInfoA()
{
    return m_pECB->lpszPathInfo;
}

/*===================================================================
CIsapiReqInfo::QueryCchPathInfoA
===================================================================*/
DWORD CIsapiReqInfo::QueryCchPathInfoA()
{
    if (m_cchPathInfoA == -1) {
        m_cchPathInfoA = QueryPszPathInfoA()
                            ? strlen(QueryPszPathInfoA())
                            : 0;
    }
    return m_cchPathInfoA;
}

/*===================================================================
CIsapiReqInfo::QueryPszPathInfoW
===================================================================*/
LPWSTR CIsapiReqInfo::QueryPszPathInfoW()
{
    if (m_fPathInfoWInited == FALSE) {
        *((LPWSTR)m_PathInfoW.QueryPtr()) = L'\0';
        m_fPathInfoWInited = InternalGetServerVariable("UNICODE_PATH_INFO", &m_PathInfoW);
    }

    ASSERT(m_fPathInfoWInited);

    return (LPWSTR)m_PathInfoW.QueryPtr();
}

/*===================================================================
CIsapiReqInfo::QueryCchPathInfoW
===================================================================*/
DWORD CIsapiReqInfo::QueryCchPathInfoW()
{
    if (m_cchPathInfoW == -1) {
        m_cchPathInfoW = QueryPszPathInfoW()
                            ? wcslen(QueryPszPathInfoW())
                            : 0;
    }
    return m_cchPathInfoW;
}

/*===================================================================
CIsapiReqInfo::QueryPszPathTranslatedA
===================================================================*/
LPSTR CIsapiReqInfo::QueryPszPathTranslatedA()
{
    return m_pECB->lpszPathTranslated;
}

/*===================================================================
CIsapiReqInfo::QueryCchPathTranslatedA
===================================================================*/
DWORD CIsapiReqInfo::QueryCchPathTranslatedA()
{
    if (m_cchPathTranslatedA == -1) {
        m_cchPathTranslatedA = QueryPszPathTranslatedA() 
                                ? strlen(QueryPszPathTranslatedA())
                                : 0;
    }

    return m_cchPathTranslatedA;
}

/*===================================================================
CIsapiReqInfo::QueryPszPathTranslatedW
===================================================================*/
LPWSTR CIsapiReqInfo::QueryPszPathTranslatedW()
{
    if (m_fPathTranslatedWInited == FALSE) {
        *((LPWSTR)m_PathTranslatedW.QueryPtr()) = L'\0';
        m_fPathTranslatedWInited = InternalGetServerVariable("UNICODE_PATH_TRANSLATED", &m_PathTranslatedW);
    }

    ASSERT(m_fPathTranslatedWInited);

    return (LPWSTR)m_PathTranslatedW.QueryPtr();
}

/*===================================================================
CIsapiReqInfo::QueryCchPathTranslatedW
===================================================================*/
DWORD CIsapiReqInfo::QueryCchPathTranslatedW()
{
    if (m_cchPathTranslatedW == -1) {
        m_cchPathTranslatedW = QueryPszPathTranslatedW() 
                                ? wcslen(QueryPszPathTranslatedW())
                                : 0;
    }

    return m_cchPathTranslatedW;
}

/*===================================================================
CIsapiReqInfo::QueryPszCookie
===================================================================*/
LPSTR CIsapiReqInfo::QueryPszCookie()
{
    if (m_fCookieInited == FALSE) {
        *((LPSTR)m_Cookie.QueryPtr()) = '\0';
        InternalGetServerVariable("HTTP_COOKIE", &m_Cookie);
        m_fCookieInited = TRUE;
    }

    return (LPSTR)m_Cookie.QueryPtr();
}

/*===================================================================
CIsapiReqInfo::SetDwHttpStatusCode
===================================================================*/
VOID CIsapiReqInfo::SetDwHttpStatusCode(DWORD  dwStatus)
{
    m_pECB->dwHttpStatusCode = dwStatus;
}

/*===================================================================
CIsapiReqInfo::QueryPbData
===================================================================*/
LPBYTE CIsapiReqInfo::QueryPbData()
{
    return m_pECB->lpbData;
}

/*===================================================================
CIsapiReqInfo::QueryCbAvailable
===================================================================*/
DWORD CIsapiReqInfo::QueryCbAvailable()
{
    return m_pECB->cbAvailable;
}

/*===================================================================
CIsapiReqInfo::QueryCbTotalBytes
===================================================================*/
DWORD CIsapiReqInfo::QueryCbTotalBytes()
{
    return m_pECB->cbTotalBytes;
}

/*===================================================================
CIsapiReqInfo::QueryPszContentType
===================================================================*/
LPSTR CIsapiReqInfo::QueryPszContentType()
{
    return m_pECB->lpszContentType;
}

/*===================================================================
CIsapiReqInfo::QueryPszMethod
===================================================================*/
LPSTR CIsapiReqInfo::QueryPszMethod()
{
    return m_pECB->lpszMethod;
}

/*===================================================================
CIsapiReqInfo::QueryPszUserAgent
===================================================================*/
LPSTR CIsapiReqInfo::QueryPszUserAgent()
{
    if (m_fUserAgentInited == FALSE) {
        *((LPSTR)m_UserAgent.QueryPtr()) = '\0';
        InternalGetServerVariable("HTTP_USER_AGENT", &m_UserAgent);
    }

    return (LPSTR)m_UserAgent.QueryPtr();
}

/*===================================================================
CIsapiReqInfo::QueryInstanceId
===================================================================*/
DWORD CIsapiReqInfo::QueryInstanceId()
{
    if (m_fInstanceIDInited == FALSE) {
        BUFFER  instanceID;
        m_fInstanceIDInited = InternalGetServerVariable("INSTANCE_ID", &instanceID);
        if (m_fInstanceIDInited == TRUE) {
            m_dwInstanceID = atoi((char *)instanceID.QueryPtr());
        }
        else {
            m_dwInstanceID = 1;
        }
    }

    return m_dwInstanceID;
}

/*===================================================================
CIsapiReqInfo::IsChild
===================================================================*/
BOOL CIsapiReqInfo::IsChild()
{

#if _IIS_5_1
    return m_pWXI->IsChild();
#else
    // BUGBUG: This needs to be implemented
#endif

    return FALSE;
}

/*===================================================================
CIsapiReqInfo::FInPool
===================================================================*/
BOOL CIsapiReqInfo::FInPool()
{
#if _IIS_5_1
    return m_pWXI->FInPool();
#else
    DWORD   dwAppFlag;

    if (ServerSupportFunction(HSE_REQ_IS_IN_PROCESS,
                              &dwAppFlag,
                              NULL,
                              NULL) == FALSE) {

        // BUGBUG:  Need to enable this Assert in future builds.
        //Assert(0);

        // if error, the best we can do is return TRUE here so
        // that ASP picks up its settings from the service level
        return TRUE;
    }
    return !(dwAppFlag == HSE_APP_FLAG_ISOLATED_OOP);
#endif

}

/*===================================================================
CIsapiReqInfo::QueryHttpVersionMajor
===================================================================*/
DWORD CIsapiReqInfo::QueryHttpVersionMajor()
{
    InitVersionInfo();

    return m_dwVersionMajor;
}

/*===================================================================
CIsapiReqInfo::QueryHttpVersionMinor
===================================================================*/
DWORD CIsapiReqInfo::QueryHttpVersionMinor()
{
    InitVersionInfo();

    return m_dwVersionMinor;
}

/*===================================================================
CIsapiReqInfo::ISAThreadNotify
===================================================================*/
HRESULT CIsapiReqInfo::ISAThreadNotify(BOOL  fStart)
{
#if _IIS_5_1
    return m_pWXI->ISAThreadNotify(fStart);
#else
    //BUGBUG: Obsolete?
    return S_OK;
#endif
}

/*===================================================================
CIsapiReqInfo::GetAspMDData
===================================================================*/
HRESULT CIsapiReqInfo::GetAspMDDataA(CHAR          * pszMDPath,
                                     DWORD           dwMDIdentifier,
                                     DWORD           dwMDAttributes,
                                     DWORD           dwMDUserType,
                                     DWORD           dwMDDataType,
                                     DWORD           dwMDDataLen,
                                     DWORD           dwMDDataTag,
                                     unsigned char * pbMDData,
                                     DWORD *         pdwRequiredBufferSize)
{
#if _IIS_5_1
    return m_pWXI->GetAspMDData((UCHAR *)pszMDPath,
                                dwMDIdentifier,
                                dwMDAttributes,
                                dwMDUserType,
                                dwMDDataType,
                                dwMDDataLen,
                                dwMDDataTag,
                                pbMDData,
                                pdwRequiredBufferSize);
#else
    return E_NOTIMPL;
#endif
}

/*===================================================================
CIsapiReqInfo::GetAspMDData
===================================================================*/
HRESULT CIsapiReqInfo::GetAspMDDataW(WCHAR         * pszMDPath,
                                     DWORD           dwMDIdentifier,
                                     DWORD           dwMDAttributes,
                                     DWORD           dwMDUserType,
                                     DWORD           dwMDDataType,
                                     DWORD           dwMDDataLen,
                                     DWORD           dwMDDataTag,
                                     unsigned char * pbMDData,
                                     DWORD *         pdwRequiredBufferSize)
{
    IMSAdminBase       *pMetabase;
    METADATA_HANDLE     hKey = NULL;
    METADATA_RECORD     MetadataRecord;
    DWORD               dwTimeout = 30000;
    HRESULT             hr;

    HANDLE hCurrentUser = INVALID_HANDLE_VALUE;
    AspDoRevertHack( &hCurrentUser );

    pMetabase = GetMetabaseIF();

    ASSERT(pMetabase);

    hr = pMetabase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                             pszMDPath,
                             METADATA_PERMISSION_READ,
                             dwTimeout,
                             &hKey
                             );

    ASSERT(SUCCEEDED(hr));

    if( SUCCEEDED(hr) )
    {
        MetadataRecord.dwMDIdentifier = dwMDIdentifier;
        MetadataRecord.dwMDAttributes = dwMDAttributes;
        MetadataRecord.dwMDUserType = dwMDUserType;
        MetadataRecord.dwMDDataType = dwMDDataType;
        MetadataRecord.dwMDDataLen = dwMDDataLen;
        MetadataRecord.pbMDData = pbMDData;
        MetadataRecord.dwMDDataTag = dwMDDataTag;

        hr = pMetabase->GetData( hKey,
                                 L"",
                                 &MetadataRecord,
                                 pdwRequiredBufferSize);

        ASSERT(SUCCEEDED(hr));

        pMetabase->CloseKey( hKey );
    }

    AspUndoRevertHack( &hCurrentUser );

    return hr;
}

/*===================================================================
CIsapiReqInfo::GetAspMDAllData
===================================================================*/
HRESULT CIsapiReqInfo::GetAspMDAllDataA(LPSTR   pszMDPath,
                                        DWORD   dwMDUserType,
                                        DWORD   dwDefaultBufferSize,
                                        LPVOID  pvBuffer,
                                        DWORD * pdwRequiredBufferSize,
                                        DWORD * pdwNumDataEntries)
{
#if _IIS_5_1
    return m_pWXI->GetAspMDAllData(pszMDPath,
                                   dwMDUserType,
                                   dwDefaultBufferSize,
                                   pvBuffer,
                                   pdwRequiredBufferSize,
                                   pdwNumDataEntries);
#else
    return E_NOTIMPL;
#endif
}
    
/*===================================================================
CIsapiReqInfo::GetAspMDAllData
===================================================================*/
HRESULT CIsapiReqInfo::GetAspMDAllDataW(LPWSTR  pwszMDPath,
                                        DWORD   dwMDUserType,
                                        DWORD   dwDefaultBufferSize,
                                        LPVOID  pvBuffer,
                                        DWORD * pdwRequiredBufferSize,
                                        DWORD * pdwNumDataEntries)
{
    
    HRESULT             hr = S_OK;
    IMSAdminBase       *pMetabase;
    METADATA_HANDLE     hKey = NULL;
    DWORD               dwTimeout = 30000;
    DWORD               dwDataSet;

    HANDLE hCurrentUser = INVALID_HANDLE_VALUE;
    AspDoRevertHack( &hCurrentUser );

    //
    // Wide-ize the metabase path
    //

    pMetabase = GetMetabaseIF();

    ASSERT(pMetabase);

    hr = pMetabase->OpenKey( METADATA_MASTER_ROOT_HANDLE,
                             pwszMDPath,
                             METADATA_PERMISSION_READ,
                             dwTimeout,
                             &hKey);

    if( SUCCEEDED(hr) ) {
        hr = pMetabase->GetAllData( hKey,
                                    L"",
                                    METADATA_INHERIT,
                                    dwMDUserType,
                                    ALL_METADATA,
                                    pdwNumDataEntries,
                                    &dwDataSet,
                                    dwDefaultBufferSize,
                                    (UCHAR *)pvBuffer,
                                    pdwRequiredBufferSize);
        
        ASSERT(SUCCEEDED(hr));

        pMetabase->CloseKey( hKey );
    }

    AspUndoRevertHack( &hCurrentUser );

    return hr;
}

/*===================================================================
CIsapiReqInfo::GetCustomErrorA
===================================================================*/
BOOL CIsapiReqInfo::GetCustomErrorA(DWORD dwError,
                                    DWORD dwSubError,
                                    DWORD dwBufferSize,
                                    CHAR  *pvBuffer,
                                    DWORD *pdwRequiredBufferSize,
                                    BOOL  *pfIsFileError)
{
#if _IIS_5_1
    return m_pWXI->GetCustomError(dwError,
                                  dwSubError,
                                  dwBufferSize,
                                  pvBuffer,
                                  pdwRequiredBufferSize,
                                  pfIsFileError);
#else
    SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
    return FALSE;
#endif
}

/*===================================================================
CIsapiReqInfo::GetCustomErrorW
===================================================================*/
BOOL CIsapiReqInfo::GetCustomErrorW(DWORD dwError,
                                    DWORD dwSubError,
                                    DWORD dwBufferSize,
                                    WCHAR *pvBuffer,
                                    DWORD *pdwRequiredBufferSize,
                                    BOOL  *pfIsFileError)
{
#if _IIS_5_1
    SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
    return FALSE;
#else

    BOOL                        fRet;
    HSE_CUSTOM_ERROR_PAGE_INFO  cei;

    STACK_BUFFER(ansiBuf, 1024);

    cei.dwError = dwError;
    cei.dwSubError = dwSubError;
    cei.dwBufferSize = ansiBuf.QuerySize();
    cei.pBuffer = (CHAR *)ansiBuf.QueryPtr();
    cei.pdwBufferRequired = pdwRequiredBufferSize;
    cei.pfIsFileError = pfIsFileError;

    fRet = ServerSupportFunction(HSE_REQ_GET_CUSTOM_ERROR_PAGE,
                                 &cei,
                                 NULL,
                                 NULL);

    if (!fRet) {
        DWORD   dwErr = GetLastError();

        if (dwErr == ERROR_INSUFFICIENT_BUFFER) {

            if (ansiBuf.Resize(*pdwRequiredBufferSize) == FALSE) {
                SetLastError(ERROR_OUTOFMEMORY);
                return FALSE;
            }

            cei.dwBufferSize = ansiBuf.QuerySize();
            cei.pBuffer = (CHAR *)ansiBuf.QueryPtr();

            fRet = ServerSupportFunction(HSE_REQ_GET_CUSTOM_ERROR_PAGE,
                                         &cei,
                                         NULL,
                                         NULL);
        }

        if (!fRet) {
            SetLastError(ERROR_OUTOFMEMORY);
            return FALSE;
        }
    }

    CMBCSToWChar convError;

    if (FAILED(convError.Init((LPCSTR)ansiBuf.QueryPtr()))) {
        SetLastError(ERROR_OUTOFMEMORY);
        return FALSE;
    }

    *pdwRequiredBufferSize = (convError.GetStringLen()+1)*sizeof(WCHAR);
    
    if (*pdwRequiredBufferSize > dwBufferSize) {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return FALSE;
    }

    memcpy(pvBuffer, convError.GetString(), *pdwRequiredBufferSize);

    if (*pfIsFileError) {

        CMBCSToWChar    convMime;
        DWORD           fileNameLen = *pdwRequiredBufferSize;

        if (FAILED(convMime.Init((LPCSTR)ansiBuf.QueryPtr()+strlen((LPCSTR)ansiBuf.QueryPtr())+1))) {
            SetLastError(ERROR_OUTOFMEMORY);
            return FALSE;
        }

        *pdwRequiredBufferSize += (convMime.GetStringLen()+1)*sizeof(WCHAR);

        if (*pdwRequiredBufferSize > dwBufferSize) {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            return FALSE;
        }

        memcpy(&((BYTE *)pvBuffer)[fileNameLen], convMime.GetString(), (convMime.GetStringLen()+1)*sizeof(WCHAR));
    }

    return TRUE;

#endif // _IIS_5_1

}

/*===================================================================
CIsapiReqInfo::QueryImpersonationToken
===================================================================*/
HANDLE CIsapiReqInfo::QueryImpersonationToken()
{
    HANDLE  hToken = INVALID_HANDLE_VALUE;

    ServerSupportFunction(HSE_REQ_GET_IMPERSONATION_TOKEN,
                          &hToken,
                          NULL,
                          NULL);

    return hToken;

}

/*===================================================================
CIsapiReqInfo::AppendLogParameter
===================================================================*/
HRESULT CIsapiReqInfo::AppendLogParameter(LPSTR extraParam)
{
    if (ServerSupportFunction(HSE_APPEND_LOG_PARAMETER,
                              extraParam,
                              NULL,
                              NULL) == FALSE) {

        return HRESULT_FROM_WIN32(GetLastError());
    }
    return S_OK;
}

/*===================================================================
CIsapiReqInfo::SendHeader
===================================================================*/
BOOL CIsapiReqInfo::SendHeader(LPVOID pvStatus,
                               DWORD  cchStatus,
                               LPVOID pvHeader,
                               DWORD  cchHeader,
                               BOOL   fIsaKeepConn)
{
    HSE_SEND_HEADER_EX_INFO     HeaderInfo;

    HeaderInfo.pszStatus = (LPCSTR)pvStatus;
    HeaderInfo.cchStatus = cchStatus;
    HeaderInfo.pszHeader = (LPCSTR) pvHeader;
    HeaderInfo.cchHeader = cchHeader;
    HeaderInfo.fKeepConn = fIsaKeepConn;

    return ServerSupportFunction( HSE_REQ_SEND_RESPONSE_HEADER_EX, 
                                  &HeaderInfo, 
                                  NULL, 
                                  NULL ); 
}

/*===================================================================
CIsapiReqInfo::GetServerVariableA
===================================================================*/
BOOL CIsapiReqInfo::GetServerVariableA(LPSTR   szVarName, 
                                       LPSTR   pBuffer, 
                                       LPDWORD pdwSize )
{
    return m_pECB->GetServerVariable( (HCONN)m_pECB->ConnID,
                                      szVarName,
                                      pBuffer,
                                      pdwSize );
}

/*===================================================================
CIsapiReqInfo::GetServerVariableW
===================================================================*/
BOOL CIsapiReqInfo::GetServerVariableW(LPSTR   szVarName, 
                                       LPWSTR  pBuffer, 
                                       LPDWORD pdwSize )
{
    return m_pECB->GetServerVariable( (HCONN)m_pECB->ConnID,
                                      szVarName,
                                      pBuffer,
                                      pdwSize );
}

/*===================================================================
CIsapiReqInfo::ServerSupportFunction
===================================================================*/
BOOL CIsapiReqInfo::ServerSupportFunction(DWORD   dwHSERequest,
                                          LPVOID  pvData, 
                                          LPDWORD pdwSize, 
                                          LPDWORD pdwDataType)
{
    return m_pECB->ServerSupportFunction( (HCONN)m_pECB->ConnID,
                                           dwHSERequest,
                                           pvData, 
                                           pdwSize, 
                                           pdwDataType );
}

/*===================================================================
CIsapiReqInfo::SendEntireResponseOop
===================================================================*/
BOOL CIsapiReqInfo::SendEntireResponseOop(IN HSE_SEND_ENTIRE_RESPONSE_INFO * pHseResponseInfo)
{
#if _IIS_5_1
    return m_pWXI->SendEntireResponseOop(pHseResponseInfo);
#elif _IIS_6_0
    return SendEntireResponse(pHseResponseInfo);
#else
#error "Neither _IIS_5_1 nor _IIS_6_0 is defined"
#endif
}

/*===================================================================
CIsapiReqInfo::SendEntireResponse
===================================================================*/
BOOL CIsapiReqInfo::SendEntireResponse(IN HSE_SEND_ENTIRE_RESPONSE_INFO * pResponseInfo)
{
#if _IIS_5_1
    return m_pWXI->SendEntireResponse(pResponseInfo);
#elif _IIS_6_0


    HRESULT             hr              = S_OK;
    DWORD               nElementCount;
    HSE_VECTOR_ELEMENT  *pVectorElement = NULL;
    HSE_RESPONSE_VECTOR respVector;
    HANDLE              hCurrentUser    = INVALID_HANDLE_VALUE;
    BOOL                fKeepConn;

    STACK_BUFFER ( buffResp, 512);

    //
    // Set the keep connection flag.  It can only be TRUE if the
    // ISAPI and the client both want keep alive.
    //

    fKeepConn = FKeepConn() && pResponseInfo->HeaderInfo.fKeepConn;

    //
    // Munge the input structure into something that IIsapiCore can
    // understand.  Note that ASP sets the number of buffer to be one more
    // than actual and the first buffer is not valid
    //

    nElementCount = pResponseInfo->cWsaBuf - 1;
    if (!buffResp.Resize(nElementCount * sizeof(HSE_VECTOR_ELEMENT)))
    {
        hr = HRESULT_FROM_WIN32( ERROR_NOT_ENOUGH_MEMORY );
        goto Exit;
    }
    ZeroMemory(buffResp.QueryPtr(),
               nElementCount * sizeof(HSE_VECTOR_ELEMENT));

    pVectorElement = (HSE_VECTOR_ELEMENT *)buffResp.QueryPtr();

    for (DWORD i = 0; i < nElementCount; i++)
    {
        pVectorElement[i].pBuffer = (LPBYTE)pResponseInfo->rgWsaBuf[i+1].buf;
        pVectorElement[i].cbSize = pResponseInfo->rgWsaBuf[i+1].len;
    }

    respVector.dwFlags          = HSE_IO_SYNC
                                    | (!fKeepConn ? HSE_IO_DISCONNECT_AFTER_SEND : 0)
                                    | HSE_IO_SEND_HEADERS;
    respVector.pszStatus        = (LPSTR)pResponseInfo->HeaderInfo.pszStatus;
    respVector.pszHeaders       = (LPSTR)pResponseInfo->HeaderInfo.pszHeader;
    respVector.nElementCount    = nElementCount;
    respVector.lpElementArray   = pVectorElement;

    //
    // Send it
    //

    if (ServerSupportFunction(HSE_REQ_VECTOR_SEND,
                              &respVector,
                              NULL,
                              NULL) == FALSE) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

 Exit:

    if (FAILED(hr))
    {
        SetLastError((HRESULT_FACILITY(hr) == (HRESULT)FACILITY_WIN32) 
            ? HRESULT_CODE(hr) 
            : ERROR_INVALID_PARAMETER);
        return FALSE;
    }

    return TRUE;
#else
#error "Neither _IIS_5_1 nor _IIS_6_0 is defined"
#endif
}

/*===================================================================
CIsapiReqInfo::TestConnection
===================================================================*/
BOOL CIsapiReqInfo::TestConnection(BOOL  *pfIsConnected)
{
    BOOL bRet = TRUE;

    ServerSupportFunction(HSE_REQ_IS_CONNECTED,
                          &bRet,
                          NULL,
                          NULL);
    return bRet;
}

/*===================================================================
CIsapiReqInfo::MapUrlToPathA
===================================================================*/
BOOL CIsapiReqInfo::MapUrlToPathA(LPSTR pBuffer, LPDWORD pdwBytes)
{
    return ServerSupportFunction( HSE_REQ_MAP_URL_TO_PATH, 
                                  pBuffer, 
                                  pdwBytes, 
                                  NULL );
}

/*===================================================================
CIsapiReqInfo::MapUrlToPathW
===================================================================*/
BOOL CIsapiReqInfo::MapUrlToPathW(LPWSTR pBuffer, LPDWORD pdwBytes)
{
    return ServerSupportFunction( HSE_REQ_MAP_UNICODE_URL_TO_PATH, 
                                  pBuffer, 
                                  pdwBytes, 
                                  NULL );
}

/*===================================================================
CIsapiReqInfo::SyncReadClient
===================================================================*/
BOOL CIsapiReqInfo::SyncReadClient(LPVOID pvBuffer, LPDWORD pdwBytes )
{
    return m_pECB->ReadClient(m_pECB->ConnID, pvBuffer, pdwBytes);
}

/*===================================================================
CIsapiReqInfo::SyncWriteClient
===================================================================*/
BOOL CIsapiReqInfo::SyncWriteClient(LPVOID pvBuffer, LPDWORD pdwBytes)
{
    return m_pECB->WriteClient(m_pECB->ConnID, pvBuffer, pdwBytes, HSE_IO_SYNC);
}


/*********************************************************************
PRIVATE FUNCTIONS
*********************************************************************/

/*===================================================================
CIsapiReqInfo::InitVersionInfo
===================================================================*/
void CIsapiReqInfo::InitVersionInfo()
{
    if (m_fVersionInited == FALSE) {

        BUFFER  version;

        m_fVersionInited = TRUE;
        m_dwVersionMajor = 1;
        m_dwVersionMinor = 0;

        if (InternalGetServerVariable("SERVER_PROTOCOL", &version)) {

            char *pVersionStr = (char *)version.QueryPtr();

            if ((strlen(pVersionStr) >= 8)
                && (isdigit((UCHAR)pVersionStr[5]))
                && (isdigit((UCHAR)pVersionStr[7]))) {

                m_dwVersionMajor = pVersionStr[5] - '0';
                m_dwVersionMinor = pVersionStr[7] - '0';
            }
        }
    }
}

/*===================================================================
CIsapiReqInfo::InternalGetServerVariable
===================================================================*/
BOOL CIsapiReqInfo::InternalGetServerVariable(LPSTR pszVarName, BUFFER  *pBuf)
{
    BOOL    bRet;
    DWORD   dwRequiredBufSize = pBuf->QuerySize();

    bRet = m_pECB->GetServerVariable(m_pECB->ConnID,
                                     pszVarName,
                                     pBuf->QueryPtr(),
                                     &dwRequiredBufSize);

    if ((bRet == FALSE) && (GetLastError() == ERROR_INSUFFICIENT_BUFFER)) {
        if (!pBuf->Resize(dwRequiredBufSize)) {
            SetLastError(ERROR_OUTOFMEMORY);
            return FALSE;
        }

        bRet = m_pECB->GetServerVariable(m_pECB->ConnID,
                                         pszVarName,
                                         pBuf->QueryPtr(),
                                         &dwRequiredBufSize);
    }

    return(bRet);
}

/*===================================================================
CIsapiReqInfo::FKeepConn
===================================================================*/
BOOL CIsapiReqInfo::FKeepConn()
{
    if (m_fFKeepConnInited == FALSE) {

        m_fFKeepConnInited = TRUE;
        m_fKeepConn = FALSE;

        InitVersionInfo();

        if (m_dwVersionMajor == 1) {

            if (m_dwVersionMinor == 1) {
                m_fKeepConn = TRUE;
            }

            BUFFER  connectStr;

            if (InternalGetServerVariable("HTTP_CONNECTION", &connectStr)) {

                if (m_dwVersionMinor == 0) {

                    m_fKeepConn = !(_stricmp((char *)connectStr.QueryPtr(), "keep-alive"));
                }
                else if (m_dwVersionMinor == 1) {

                    m_fKeepConn = !!(_stricmp((char *)connectStr.QueryPtr(), "close"));
                }
            }
        }
    }

    return m_fKeepConn;
}

/*===================================================================
CIsapiReqInfo::GetMetabaseIF
===================================================================*/
IMSAdminBase   *CIsapiReqInfo::GetMetabaseIF()
{
    if (m_pIAdminBase == NULL) {
        HRESULT hr = CoCreateInstance(CLSID_MSAdminBase,
                                      NULL,
                                      CLSCTX_ALL,
                                      IID_IMSAdminBase,
                                      (void**)&m_pIAdminBase);

        ASSERT(SUCCEEDED(hr));
    }
    return m_pIAdminBase;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\linkhash.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Hash table for Script Manager

File: LinkHash.h

Owner: DGottner

This is the Link list and Hash table for use by any classes which
also need LRU access to items. (This includes cache manager,
script manager, and session deletion code)
===================================================================*/

#ifndef LINKHASH_H
#define LINKHASH_H

#include "hashing.h"
#include "DblLink.h"



/* C L r u L i n k E l e m
 *
 * CLruLink is a CLinkElem with extra links to maintain a circular LRU queue
 *
 * NOTE: Both the CLinkElem list and the CDblLink lists are intrusive.
 *       therefore, we need to use multiple inheritance to make sure that
 *       downcasts from CLruLinkElem will work on both CLinkElem pointers
 *       and CDblLink pointers.  See the ARM, p. 221
 */

class CLruLinkElem : public CLinkElem, public CDblLink
	{
	};



/*
 * C L i n k H a s h
 *
 * CLinkHash differs from CHashTable in that it maintains some extra pointers to
 * maintain a threaded lru queue.
 */

class CLinkHash : public CHashTable
	{
public:
	CLinkHash(HashFunction = DefaultHash);
	
	CLruLinkElem *AddElem(CLruLinkElem *pElem, BOOL fTestDups = TRUE);
	CLruLinkElem *FindElem(const void *pvKey, int cbKeyLen);
	CLruLinkElem *DeleteElem(const void *pvKey, int cbKeyLen);
	CLruLinkElem *RemoveElem(CLruLinkElem *pElem);

	// you CANNOT compare LRU nodes to NULL to know if you are at the end
	// of the list!  Instead use this member.
	//
	BOOL FLruElemIsEmpty(CLruLinkElem *pElem)
		{
		pElem->AssertValid();
		return pElem == &m_lruHead;
		}

	CLruLinkElem *Begin()		// return pointer to last referenced item
		{
		return static_cast<CLruLinkElem *>(m_lruHead.PNext());
		}

	CLruLinkElem *End()			// return pointer to least recently accessed item
		{
		return static_cast<CLruLinkElem *>(m_lruHead.PPrev());
		}

	void AssertValid() const;

protected:

	CDblLink	m_lruHead;
	};

#ifndef DBG
	inline void CLinkHash::AssertValid() const {}
#endif
	
#endif // LINKHASH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\magic.h ===
#define SZ_MAGICKEY	"Denali rocks!"

void* xor(void* pData, const int cbData, const void* pKey, const int cbKey)
	{
	void*	pRet = pData;
	int		iKeyPos = 0;
	BYTE*	pbData = (BYTE*) pData;
	BYTE*	pbKey = (BYTE*) pKey;
	
	for(int i = 0; i < cbData; i++)
		{
		*pbData++ ^= *(pbKey + iKeyPos++);
		iKeyPos %= cbKey;
		}
	
	return pRet;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\listmgr.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: List Allocater Template

File: Listmgr.h

Owner: PramodD

This is the List Allocator template header file.
It manages memory requests by allocating from a array/linklist.
The size of the initial array is a parameter to the constructor.
===================================================================*/
#ifndef LISTMGR_H
#define LISTMGR_H

#ifdef PAGESIZE
#undef PAGESIZE
#endif

#define PAGESIZE    4096

// Allocation unit
template <class T>
class CListElem
{
private:
    T       m_Element;  // The actual element we want to allocate
    T *     m_pNext;    // Next element in free list
    
public:
    void    SetNext(CListElem<T> * element);
    T *     GetNext(void);
};

// Member access functions
template <class T>
inline void CListElem<T>::SetNext(CListElem<T> * element) { m_pNext = (T *) element; }

template <class T>
inline T * CListElem<T>::GetNext( void ) { return m_pNext; }

// Single Threaded List Manager

template <class T>
class CSTList
{
private:
    CListElem<T> *  m_pFreeHead;
    CListElem<T> *  m_pAllocHead;
    UINT            m_cFree;
    UINT            m_cUsed;
    UINT            m_cSize;

public:
    CSTList(void);

private:
    void    MakeLinks(CListElem<T> * TArray, UINT cSize);
    HRESULT GrabMemory(UINT cSize);

public:
    HRESULT Init(UINT cSize=0);     // Initial allocation
    HRESULT UnInit(void);           // Release memory
    T *     Allocate(void);         // Allocate one element
    T *     ReAlloc(UINT cSize=0);  // Allocate memory if needed
    void    Free( T * element );    // Free one element
    UINT    FreeCount(void);        // Number of free elements
    UINT    UsedCount(void);        // Number of used elements
    UINT    Size(void);             // Number of elements
};

// Constructor
template <class T>
CSTList<T>::CSTList( void )
{
    m_pFreeHead = NULL;
    m_pAllocHead = NULL;
    m_cFree = 0;
    m_cUsed = 0;
    m_cSize = 0;
}

template <class T>
void CSTList<T>::MakeLinks( CListElem<T> *TArray, UINT cSize )
{
    CListElem<T> *  pT = TArray;
    UINT            i = 0;

    m_cSize += cSize;
    m_cFree += cSize;

    // Initialize link list
    while ( i < cSize - 1 )
    {
        pT->SetNext( pT + 1 );
        pT++;
        i++;
    }
    if ( m_pFreeHead )
        pT->SetNext( m_pFreeHead );
    else
        pT->SetNext( pT + 1 );

    m_pFreeHead = TArray;
}

template <class T>
HRESULT CSTList<T>::GrabMemory( UINT cSize )
{
    CListElem<T> *  pT;
    UINT cT;
    
    if ( cSize )
        cT = cSize;
    else
        cT = PAGESIZE/sizeof(CListElem<T>);

    if ( pT = (CListElem<T> *) GlobalAlloc( GPTR, sizeof( CListElem<T> ) * (cT + 1) ) )
    {
        pT->SetNext( m_pAllocHead );
        m_pAllocHead = pT;
        pT++;
        MakeLinks( pT, cT );
        return S_OK;
    }
    return E_FAIL;
}

// Initialization
template <class T>
inline HRESULT CSTList<T>::Init( UINT cSize = 0 ) { return GrabMemory( cSize ); }

// Free all memory, All allocated elements should have been
// returned to the list. Otherwise it returns E_FAIL.
template <class T>
HRESULT CSTList<T>::UnInit( void )
{
    HRESULT         hr = S_OK;
    CListElem<T> *  pT;

    // Free all the memory
    while ( m_pAllocHead )
    {
        pT = (CListElem<T> *) m_pAllocHead->GetNext();
        GlobalFree( (HGLOBAL) m_pAllocHead );
        m_pAllocHead = pT;
    }
    m_pFreeHead = NULL;

    // Check for memory leaks
    if ( m_cSize != m_cFree )
        hr = E_FAIL;

    m_cSize = 0;
    m_cFree = 0;
    m_cUsed = 0;

    return hr;
}

// Allocate element from array
template <class T>
T * CSTList<T>::Allocate( void )
{
    if ( m_cFree == 0 )
        return NULL;

    CListElem<T> * pT = m_pFreeHead;

    m_pFreeHead = (CListElem<T> *) pT->GetNext();
    pT->SetNext( NULL );
    m_cFree--;
    m_cUsed++;

    return (T *) pT;
}

// Allocate element from array, get more memory if needed
template <class T>
T * CSTList<T>::ReAlloc( UINT cSize = 0 )
{
    if ( m_cFree == 0 )
        GrabMemory(cSize);
    return Allocate();
}

// Return element to array
template <class T>
void CSTList<T>::Free( T *element )
{
    if ( element == NULL || m_cUsed == 0 )
        return;

    CListElem<T> * pT = (CListElem<T> *) element;

    if ( pT->GetNext() == NULL )
    {
        pT->SetNext( m_pFreeHead );
        m_pFreeHead = pT;
        m_cUsed--;
        m_cFree++;
    }
}

// Member access functions
template <class T>
inline UINT CSTList<T>::FreeCount( void ) { return m_cFree; }

template <class T>
inline UINT CSTList<T>::UsedCount( void ) { return m_cUsed; }

template <class T>
inline UINT CSTList<T>::Size( void ) {  return m_cSize; }



// Multi Threaded List Manager

template <class T>
class CMTList: private CSTList<T>
{
    // Synchronization objects
private:
    BOOL                m_fInited;
    CRITICAL_SECTION    m_csList;
    HANDLE              m_hBlockedReaders;
    HANDLE              m_hBlockedWriters;

    // Counters
private:
    int     m_cActiveReaders;
    int     m_cWaitingReaders;
    int     m_cActiveWriters;
    int     m_cWaitingWriters;

    // Public constructor and destructor
public:
            CMTList(void) { m_fInited = FALSE; }
    virtual ~CMTList( void );

    // Private synchronization functions
private:
    void    ReadLock(void);         // Lock List access for read
    void    WriteLock(void);        // Lock List access for write
    void    ReleaseReadLock(void);  // Unlock read access
    void    ReleaseWriteLock(void); // Unlock write access

    // Public List functions
public:
    HRESULT Init( int cSize = 0 );// Initial allocation
    HRESULT UnInit(void);           // Free all memory
    T *     Allocate(void);         // Allocate one element
    T *     ReAlloc(UINT cSize=0);  // Allocate more memory if needed
    void    Free(T *element);       // Free one element
    UINT    FreeCount(void);        // Number of free elements
    UINT    UsedCount(void);        // Number of used elements
    UINT    Size(void);             // Total number of elements
};

template <class T>
HRESULT CMTList<T>::Init( int cSize = 0 )
{
    HRESULT hr;
    
    // Initialize synchronization objects
    ErrInitCriticalSection( &m_csList, hr );
    if ( FAILED( hr ) )
        return hr;

    m_hBlockedReaders = IIS_CREATE_SEMAPHORE(
                            "CMTList<T>::m_hBlockedReaders",
                            this,
                            0L,
                            9999L
                            );
        
    m_hBlockedWriters = IIS_CREATE_SEMAPHORE(
                            "CMTList<T>::m_hBlockedWriters",
                            this,
                            0L,
                            9999L
                            );
        
    if ( m_hBlockedReaders && m_hBlockedWriters )
    {
        // Initialize counters
        m_cActiveReaders = 0;
        m_cWaitingReaders = 0;
        m_cActiveWriters = 0;
        m_cWaitingWriters = 0;
        m_fInited = TRUE;

        if ( SUCCEEDED( CSTList<T>::Init(cSize) ) )
            return S_OK;
    }
    return E_FAIL;
}

template <class T>
HRESULT CMTList<T>::UnInit( void )
{
    if ( !m_fInited )
        return E_FAIL;

    WriteLock();
    HRESULT hr = CSTList<T>::UnInit();
    ReleaseWriteLock();
    return hr;
}

template <class T>
CMTList<T>::~CMTList( void )
{
    if ( m_fInited )
    {
        // Destroy synchronization objects
        DeleteCriticalSection( &m_csList );
        CloseHandle( m_hBlockedReaders );
        CloseHandle( m_hBlockedWriters );
    }
}

template <class T>
void CMTList<T>::ReadLock( void )
{
    if ( !m_fInited )
        return;

    EnterCriticalSection( &m_csList );
    if ( m_cActiveWriters > 0 || m_cWaitingWriters > 0 )
    {
        m_cWaitingReaders++;
        LeaveCriticalSection( &m_csList );
        WaitForSingleObject( m_hBlockedReaders, INFINITE );
    }
    else
    {
        m_cActiveReaders++;
        LeaveCriticalSection( &m_csList );
    }
}

template <class T>
void CMTList<T>::ReleaseReadLock( void )
{
    if ( !m_fInited )
        return;

    EnterCriticalSection( &m_csList );
    m_cActiveReaders--;
    if ( m_cActiveReaders == 0 && m_cWaitingWriters > 0 )
    {
        m_cActiveWriters = 1;
        m_cWaitingWriters = 0;
        ReleaseSemaphore( m_hBlockedWriters, 1, NULL );
    }
    LeaveCriticalSection( &m_csList );
}

template <class T>
void CMTList<T>::WriteLock( void )
{
    if ( !m_fInited )
        return;

    EnterCriticalSection( &m_csList );
    if ( m_cActiveReaders == 0 && m_cActiveWriters == 0 )
    {
        m_cActiveWriters = 1;
        LeaveCriticalSection( &m_csList );
    }
    else
    {
        m_cWaitingWriters++;
        LeaveCriticalSection( &m_csList );
        WaitForSingleObject( m_hBlockedWriters, INFINITE );
    }
}

template <class T>
void CMTList<T>::ReleaseWriteLock( void )
{
    if ( !m_fInited )
        return;

    EnterCriticalSection( &m_csList );
    m_cActiveWriters = 0;
    if ( m_cWaitingReaders > 0 )
    {
        m_cActiveReaders = m_cWaitingReaders;
        m_cWaitingReaders = 0;
        ReleaseSemaphore( m_hBlockedReaders, m_cActiveReaders, NULL );
    }
    else if ( m_cWaitingWriters > 0 )
    {
        m_cWaitingWriters--;
        ReleaseSemaphore( m_hBlockedWriters, 1, NULL );
    }
    LeaveCriticalSection( &m_csList );
}

template <class T>
T * CMTList<T>::Allocate( void )
{
    if ( !m_fInited )
        return NULL;

    WriteLock();
    T * retVal = CSTList<T>::Allocate();
    ReleaseWriteLock();
    return retVal;
}

template <class T>
T * CMTList<T>::ReAlloc( UINT cSize = 0 )
{
    if ( !m_fInited )
        return NULL;

    WriteLock();
    T * retVal = CSTList<T>::ReAlloc( cSize );
    ReleaseWriteLock();
    return retVal;
}

template <class T>
void CMTList<T>::Free( T *element )
{
    if ( !m_fInited )
        return;

    WriteLock();
    CSTList<T>::Free( element );
    ReleaseWriteLock();
}

template <class T>
UINT CMTList<T>::FreeCount( void )
{
    if ( !m_fInited )
        return 0;

    ReadLock();
    UINT retVal = CSTList<T>::FreeCount();
    ReleaseReadLock();
    return retVal;
}

template <class T>
UINT CMTList<T>::UsedCount( void )
{
    if ( !m_fInited )
        return 0;

    ReadLock();
    UINT retVal = CSTList<T>::UsedCount();
    ReleaseReadLock();
    return retVal;
}

template <class T>
UINT CMTList<T>::Size( void )
{
    if ( !m_fInited )
        return 0;

    ReadLock();
    UINT retVal = CSTList<T>::Size();
    ReleaseReadLock();
    return retVal;
}

#endif // LISTMGR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\makevers.cpp ===
/*
 * Program to make verdep.h
 
   Owner:
   Lei Jin(leijin)
   
   Borrowed from Access team.(Andrew)
 */
#pragma hdrstop
#include <time.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "windows.h"

main()
	{
	// need to collect the current date, the version number, the version
	// type, and the volume label.
	struct tm *tmTime;
	char szVersNum[120];
	char szbuf[256];
	char *szMakeType, *szUserName;
	time_t tt;

	static char *szMonth[] =
		{
		"January",
		"February",
		"March",
		"April",
		"May",
		"June",
		"July",
		"August",
		"September",
		"October",
		"November",
		"December"
		};


	// Get the time
	time(&tt);
	tmTime = localtime(&tt);
  

	// Get the types from environment
	szMakeType = getenv("MAKETYPE");

	if (!szMakeType)
		szMakeType = "Unknown";


	// Get the user name
	szUserName = getenv("USERNAME");

	if (!szUserName)
		{
		//unsigned long dw;

		if (!GetVolumeInformation(NULL, szbuf, 255, NULL, NULL, NULL, NULL, 0))
			szUserName = "NOBODY";
		else
			szUserName = szbuf;
		}

	// Get the version number from stdin
	//gets(szVersNum);
	sprintf(szVersNum, "2");	
	

	printf("#define vszMakeDate\t\"%s %d, 19%d\"\n", szMonth[tmTime->tm_mon], tmTime->tm_mday, tmTime->tm_year);
	printf("#define vszMakeVers\t\"Version %s - %s - %s\"\n", szVersNum, szMakeType, szUserName);
	printf("#define vszVersNum\t\"%s\"\n", szVersNum, szMakeType);
	printf("#define vszCopyright\t\"Copyright \251 1996 Microsoft Corp.\"\n");
	printf("#define vszVersName\t\"%s (%s)\"\n", szUserName, szMakeType);
	printf("#define vszMakeSerial\t\"%02d-%02d-%02d-%02d%02d%02d\"\n", tmTime->tm_mon + 1, tmTime->tm_mday, tmTime->tm_year, 
		tmTime->tm_hour, tmTime->tm_min, tmTime->tm_sec);
	printf("#define vszDenaliVersion\t%s.%02d.%02d.0\n", szVersNum, (tmTime->tm_year - 96)*12 + tmTime->tm_mon + 1, tmTime->tm_mday);
	printf("#define vszDenaliVersionNULL\t\"%s.%02d.%02d.0\\0\"\n", szVersNum, (tmTime->tm_year - 96)*12 + tmTime->tm_mon + 1, tmTime->tm_mday);
	
	// the following block is for the version stamp resource
	{
	#include <string.h>
	char *sz;
	// major
	if(sz = strtok(szVersNum, ".\n \t"))
		printf("#define rmj\t\t%0u\n", atoi(sz));
	// minor
	if(sz = strtok(NULL, ".\n \t"))
		printf("#define rmm\t\t%01u\n", atoi(sz));
	else
		printf("#define rmm\t\t0\n");
	// release
	if(sz = strtok(NULL, ""))
		printf("#define rup\t\t%0u\n", atoi(sz));
	else
		printf("#define rup\t\t0\n");
	}

	return 0;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\memchk.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Memory Management

File: Memchk.h

Owner: PramodD

This is the Memory Manager header file
===================================================================*/

#ifndef MEMCHK_H
#define MEMCHK_H

#define DENALI_MEMCHK

// Always use these macros, DO NOT ever use DenaliMemXX functions directly

// Function names that SHOULD BE used

#define malloc(x)			DenaliMemAlloc( x, __FILE__, __LINE__ )
#define calloc(x,y)			DenaliMemCalloc( x, y, __FILE__, __LINE__ )
#define realloc(x,y)		DenaliMemReAlloc( x, y, __FILE__, __LINE__ )
#define free(x)				DenaliMemFree( x, __FILE__, __LINE__ )
#define DenaliMemoryInit()	DenaliMemInit( __FILE__, __LINE__ )
#define DenaliMemoryUnInit() DenaliMemUnInit( __FILE__, __LINE__ )
#define DenaliDiagnostics()	DenaliMemDiagnostics( __FILE__, __LINE__ )
#define DenaliIsValid(x)	DenaliMemIsValid(x)

// Functions that are actually linked

extern HRESULT				DenaliMemInit(const char *szFile, int lineno);
extern void					DenaliMemUnInit(const char *szFile, int lineno);
extern void					DenaliMemDiagnostics(const char *szFile, int lineno);
extern void					DenaliLogCall(const char *szLog, const char *szFile, int lineno);
extern void *				DenaliMemAlloc(size_t cSize, const char *szFile, int lineno );
extern void *				DenaliMemCalloc(size_t cNum, size_t cbSize, const char *szFile, int lineno );
extern void					DenaliMemFree(void * p, const char *szFile, int lineno);
extern void *				DenaliMemReAlloc(void * p, size_t cSize, const char *szFile, int lineno);
extern int					DenaliMemIsValid(void * p);

// Redefinition of global operators new and delete
#ifdef __cplusplus

// override for the default operator new
inline void * __cdecl operator new(size_t cSize) 
	{
	return DenaliMemAlloc(cSize, NULL, 0); 
	}

// override for the custom operator new with 3 args
inline void * operator new(size_t cSize, const char *szFile, int lineno)
	{
	return DenaliMemAlloc(cSize, szFile, lineno); 
	}

// override for the default operator delete
inline void __cdecl operator delete(void * p) 
    {
    DenaliMemFree(p, NULL, 0); 
    }

// Macro to grab source file and line number information

#define new					new( __FILE__, __LINE__ )

/*
#define delete DenaliLogCall( "Calling delete operator", __FILE__, __LINE__ ), delete
*/

#endif // __cplusplus

#endif // MEMCHK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\memcls.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Per-Class Memory Management

File: Memcls.cpp

Owner: dmitryr

This file contains the code to access ATQ memory cache on per
class basis
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "asperror.h"
#include "clcert.h"
#include "context.h"
#include "cookies.h"
#include "request.h"
#include "response.h"
#include "server.h"
#include "strlist.h"
#include "tlbcache.h"
#include "memcls.h"

// Don't #include "memchk.h" in this file

/*===================================================================
  DEBUG only

  gs_cTotalObjectsLeaked counts memory leaks

  DebugCheckLeaks() outputs the ATQ cache memory
  leaks into denmem.log

  DEBUG_ACACHE_UNINIT() and DEBUG_ACACHE_FSA_UNINIT() call
  DebugCheckLeaks() in DEBUG mode only
===================================================================*/

#ifdef DBG

static DWORD gs_cTotalObjectsLeaked = 0;

#define SZ_MEMCLS_LOG_FILE  "C:\\TEMP\\MEMCLS.LOG"

static void DebugCheckLeaks(ALLOC_CACHE_HANDLER *pach, const char *szClass)
    {
    ALLOC_CACHE_STATISTICS acStats;
    pach->QueryStats(&acStats);
    DWORD cLeaked = acStats.nTotal - acStats.nFreeEntries;

    if (cLeaked > 0)
        {
        gs_cTotalObjectsLeaked += cLeaked;
        
        DebugFilePrintf
            (
            SZ_MEMCLS_LOG_FILE, 
            "MEMCLS: ATQ allocation cache leak: %d of %s objects.\n",
            cLeaked,
            szClass
            );
        }
    }

#define DEBUG_ACACHE_UNINIT(C)      { DebugCheckLeaks(C::sm_pach, #C);  \
                                      ACACHE_UNINIT(C) }
#define DEBUG_ACACHE_FSA_UNINIT(C)  { DebugCheckLeaks(g_pach##C, #C);   \
                                      ACACHE_FSA_UNINIT(C) }
#else

#define DEBUG_ACACHE_UNINIT(C)      ACACHE_UNINIT(C)
#define DEBUG_ACACHE_FSA_UNINIT(C)  ACACHE_FSA_UNINIT(C)

#endif

/*===================================================================
  For each class with ACACHE_INCLASS_DEFINITIONS() inside add
  here ACACHE_CODE macro.
===================================================================*/

ACACHE_CODE(C449Cookie)
ACACHE_CODE(C449File)
ACACHE_CODE(CASEElem)
ACACHE_CODE(CActiveScriptEngine)
ACACHE_CODE(CAppln)
ACACHE_CODE(CApplnVariants)
ACACHE_CODE(CASPError)
ACACHE_CODE(CClCert)
ACACHE_CODE(CComponentCollection)
ACACHE_CODE(CComponentObject)
ACACHE_CODE(CCookie)
ACACHE_CODE(CDebugResponseBuffer)
ACACHE_CODE(CEngineDispElem)
ACACHE_CODE(CFileApplnList)
ACACHE_CODE(CHitObj)
ACACHE_CODE(CHTTPHeader)
ACACHE_CODE(CIsapiReqInfo)
ACACHE_CODE(CPageComponentManager)
ACACHE_CODE(CPageObject)
ACACHE_CODE(CRequest)
ACACHE_CODE(CRequestData)
ACACHE_CODE(CRequestHit)
ACACHE_CODE(CResponse)
ACACHE_CODE(CResponseBuffer)
ACACHE_CODE(CResponseData)
ACACHE_CODE(CScriptingNamespace)
ACACHE_CODE(CScriptingContext)
ACACHE_CODE(CServer)
ACACHE_CODE(CServerData)
ACACHE_CODE(CSession)
ACACHE_CODE(CSessionVariants)
ACACHE_CODE(CStringList)
ACACHE_CODE(CStringListElem)
ACACHE_CODE(CTemplate)
//ACACHE_CODE(CTemplate::CBuffer)
ACACHE_CODE(CTemplate::CFileMap)
ACACHE_CODE(CTypelibCacheEntry)
ACACHE_CODE(CVariantsIterator)
ACACHE_CODE(CViperActivity)
ACACHE_CODE(CViperAsyncRequest)

/*===================================================================
  For each fixed size allocator add here ACACHE_FSA_DEFINITION macro.
===================================================================*/

ACACHE_FSA_DEFINITION(MemBlock128)
ACACHE_FSA_DEFINITION(MemBlock256)
ACACHE_FSA_DEFINITION(ResponseBuffer)

/*===================================================================
  Defines for cache threshold of each kind
===================================================================*/
#define HARDCODED_PER_APPLN_CACHE_MAX     128
#define HARDCODED_PER_REQUEST_CACHE_MAX   1024
#define HARDCODED_PER_QUEUEITEM_CACHE_MAX 8192
#define HARDCODED_PER_SESSION_CACHE_MAX   8192
#define HARDCODED_PER_SCRPTENG_CACHE_MAX  256
#define HARDCODED_PER_TEMPLATE_CACHE_MAX  2048
#define HARDCODED_PER_RESPONSE_BUFFER_MAX 64
#define HARDCODED_PER_SIZE_BUFFER_MAX     4096

// do scaling per registry setting
DWORD dwMemClsScaleFactor;

#define PER_APPLN_CACHE_MAX     ((HARDCODED_PER_APPLN_CACHE_MAX     * dwMemClsScaleFactor) / 100)
#define PER_REQUEST_CACHE_MAX   ((HARDCODED_PER_REQUEST_CACHE_MAX   * dwMemClsScaleFactor) / 100)
#define PER_QUEUEITEM_CACHE_MAX ((HARDCODED_PER_QUEUEITEM_CACHE_MAX * dwMemClsScaleFactor) / 100)
#define PER_SESSION_CACHE_MAX   ((HARDCODED_PER_SESSION_CACHE_MAX   * dwMemClsScaleFactor) / 100)
#define PER_SCRPTENG_CACHE_MAX  ((HARDCODED_PER_SCRPTENG_CACHE_MAX  * dwMemClsScaleFactor) / 100)
#define PER_TEMPLATE_CACHE_MAX  ((HARDCODED_PER_TEMPLATE_CACHE_MAX  * dwMemClsScaleFactor) / 100)
#define PER_RESPONSE_BUFFER_MAX ((HARDCODED_PER_RESPONSE_BUFFER_MAX * dwMemClsScaleFactor) / 100)
#define PER_SIZE_BUFFER_MAX     ((HARDCODED_PER_SIZE_BUFFER_MAX     * dwMemClsScaleFactor) / 100)

/*===================================================================
InitMemCls

To be called from DllInit(). Creates per-class ATQ memory allocators.

For each class with ACACHE_INCLASS_DEFINITIONS() inside add
here ACACHE_INIT macro.

For each ACACHE_FSA_DEFINITION() add here ACACHE_FSA_INIT macro.

Parameters

Returns:
    HRESULT
===================================================================*/
HRESULT InitMemCls()
    {
    // Set the scaling to normal
    dwMemClsScaleFactor = 100;

    // Init the allocators
    
    HRESULT hr = S_OK;

    ACACHE_INIT(C449Cookie,             PER_TEMPLATE_CACHE_MAX/4, hr)
    ACACHE_INIT(C449File,               PER_TEMPLATE_CACHE_MAX/4, hr)
    ACACHE_INIT(CASEElem,               PER_SCRPTENG_CACHE_MAX, hr)
    ACACHE_INIT(CActiveScriptEngine,    PER_SCRPTENG_CACHE_MAX, hr)
    ACACHE_INIT_EX(CAppln,              PER_APPLN_CACHE_MAX,    FALSE, hr)
    ACACHE_INIT(CApplnVariants,         PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CASPError,              PER_RESPONSE_BUFFER_MAX,hr)
    ACACHE_INIT(CClCert,                PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CComponentCollection,   PER_SESSION_CACHE_MAX,  hr)
    ACACHE_INIT(CComponentObject,     2*PER_SESSION_CACHE_MAX,  hr)
    ACACHE_INIT(CCookie,                PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CDebugResponseBuffer,   PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CEngineDispElem,        PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CFileApplnList,       2*PER_APPLN_CACHE_MAX,    hr)
    ACACHE_INIT(CHitObj,                PER_QUEUEITEM_CACHE_MAX,hr)
    ACACHE_INIT(CHTTPHeader,          2*PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CIsapiReqInfo,          PER_QUEUEITEM_CACHE_MAX,hr)
    ACACHE_INIT(CPageComponentManager,  PER_QUEUEITEM_CACHE_MAX,hr)
    ACACHE_INIT(CPageObject,            PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CRequest,               PER_SESSION_CACHE_MAX,  hr)
    ACACHE_INIT(CRequestData,           PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CRequestHit,            PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CResponse,              PER_SESSION_CACHE_MAX,  hr)
    ACACHE_INIT(CResponseBuffer,        PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CResponseData,          PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CScriptingContext,      PER_SESSION_CACHE_MAX,  hr)
    ACACHE_INIT(CScriptingNamespace,    PER_SESSION_CACHE_MAX,  hr)
    ACACHE_INIT(CServer,                PER_SESSION_CACHE_MAX,  hr)
    ACACHE_INIT(CServerData,            PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT_EX(CSession,            PER_SESSION_CACHE_MAX,  FALSE, hr)
    ACACHE_INIT(CSessionVariants,       PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CStringList,            PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CStringListElem,      2*PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CTemplate,              PER_TEMPLATE_CACHE_MAX, hr)
//    ACACHE_INIT(CTemplate::CBuffer,     PER_TEMPLATE_CACHE_MAX, hr)
    ACACHE_INIT(CTemplate::CFileMap,    PER_TEMPLATE_CACHE_MAX, hr)
    ACACHE_INIT(CTypelibCacheEntry,     PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CVariantsIterator,      PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CViperActivity,         PER_REQUEST_CACHE_MAX,  hr)
    ACACHE_INIT(CViperAsyncRequest,     PER_QUEUEITEM_CACHE_MAX,hr)
    
    ACACHE_FSA_INIT(MemBlock128,    128,                  PER_SIZE_BUFFER_MAX,     hr)
    ACACHE_FSA_INIT(MemBlock256,    256,                  PER_SIZE_BUFFER_MAX,     hr)
    ACACHE_FSA_INIT(ResponseBuffer, RESPONSE_BUFFER_SIZE, PER_RESPONSE_BUFFER_MAX, hr)

#ifdef DBG
    unlink(SZ_MEMCLS_LOG_FILE);

    DebugFilePrintf
        (
        SZ_MEMCLS_LOG_FILE, 
        "MEMCLS: ATQ allocation cache inited with HRESULT=%08x.\n",
        hr
        );
#endif

    return hr;
    }

/*===================================================================
UnInitMemCls

To be called from DllInit(). Deletes per-class ATQ memory allocators.

For each class with ACACHE_INCLASS_DEFINITIONS() inside add
here ACACHE_UNINIT macro.

For each ACACHE_FSA_DEFINITION() add here ACACHE_FSA_UNINIT macro.

Parameters

Returns:
    HRESULT
===================================================================*/
HRESULT UnInitMemCls()
    {
#ifdef DBG
    gs_cTotalObjectsLeaked = 0;
#endif

    DEBUG_ACACHE_UNINIT(C449Cookie)
    DEBUG_ACACHE_UNINIT(C449File)
    DEBUG_ACACHE_UNINIT(CASEElem)
    DEBUG_ACACHE_UNINIT(CActiveScriptEngine)
    DEBUG_ACACHE_UNINIT(CAppln)
    DEBUG_ACACHE_UNINIT(CApplnVariants)
    DEBUG_ACACHE_UNINIT(CASPError)
    DEBUG_ACACHE_UNINIT(CClCert)
    DEBUG_ACACHE_UNINIT(CComponentCollection)
    DEBUG_ACACHE_UNINIT(CComponentObject)
    DEBUG_ACACHE_UNINIT(CCookie)
    DEBUG_ACACHE_UNINIT(CDebugResponseBuffer)
    DEBUG_ACACHE_UNINIT(CEngineDispElem)
    DEBUG_ACACHE_UNINIT(CFileApplnList)
    DEBUG_ACACHE_UNINIT(CHitObj)
    DEBUG_ACACHE_UNINIT(CHTTPHeader)
    DEBUG_ACACHE_UNINIT(CIsapiReqInfo)
    DEBUG_ACACHE_UNINIT(CPageComponentManager)
    DEBUG_ACACHE_UNINIT(CPageObject)
    DEBUG_ACACHE_UNINIT(CRequest)
    DEBUG_ACACHE_UNINIT(CRequestData)
    DEBUG_ACACHE_UNINIT(CRequestHit)
    DEBUG_ACACHE_UNINIT(CResponse)
    DEBUG_ACACHE_UNINIT(CResponseBuffer)
    DEBUG_ACACHE_UNINIT(CResponseData)
    DEBUG_ACACHE_UNINIT(CScriptingNamespace)
    DEBUG_ACACHE_UNINIT(CScriptingContext)
    DEBUG_ACACHE_UNINIT(CServer)
    DEBUG_ACACHE_UNINIT(CServerData)
    DEBUG_ACACHE_UNINIT(CSession)
    DEBUG_ACACHE_UNINIT(CSessionVariants)
    DEBUG_ACACHE_UNINIT(CStringList)
    DEBUG_ACACHE_UNINIT(CStringListElem)
    DEBUG_ACACHE_UNINIT(CTemplate)
//    DEBUG_ACACHE_UNINIT(CTemplate::CBuffer)
    DEBUG_ACACHE_UNINIT(CTemplate::CFileMap)
    DEBUG_ACACHE_UNINIT(CTypelibCacheEntry)
    DEBUG_ACACHE_UNINIT(CVariantsIterator)
    DEBUG_ACACHE_UNINIT(CViperActivity)
    DEBUG_ACACHE_UNINIT(CViperAsyncRequest)

    DEBUG_ACACHE_FSA_UNINIT(MemBlock128)
    DEBUG_ACACHE_FSA_UNINIT(MemBlock256)
    DEBUG_ACACHE_FSA_UNINIT(ResponseBuffer)

#ifdef DBG
    DebugFilePrintf
        (
        SZ_MEMCLS_LOG_FILE,
        "MEMCLS: ATQ allocation cache uninited.\n"
        "MEMCLS: Total of %d ASP objects leaked.\n",
        gs_cTotalObjectsLeaked
        );
#endif

    return S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\memchk.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Memory Management

File: Memchk.cpp

Owner: PramodD

TODO: restore the IIS5 debug heap wrappers

This is the Memory Manager source file
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "perfdata.h"
#include "memchk.h"

HANDLE g_hDenaliHeap = NULL;

/*===================================================================
int ::DenaliMemIsValid

Global function which validates an allocated memory pointer

Parameters:
	NONE

Returns:
	1		Valid pointer
	0		Invalid pointer
===================================================================*/
int DenaliMemIsValid( void * pvIn )
{
    return 1;
}

/*===================================================================
::DenaliMemInit

Initializes the memory manager

Parameters:
	const char *	szFile		Source file in which this was called
	int				lineno		The line number in the source file

Returns:
	S_OK on success
===================================================================*/
HRESULT DenaliMemInit( const char *szFile, int lineno )
{

    g_hDenaliHeap = ::HeapCreate( 0, 0, 0 );

	return S_OK;
}

/*===================================================================
void ::DenaliMemUnInit

Uninitializes the memory manager

Parameters:
	const char *	szFile		Source file in which this was called
	int				lineno		The line number in the source file

Returns:
	NONE
===================================================================*/
void DenaliMemUnInit( const char *szFile, int lineno )
{
    if (g_hDenaliHeap)
    {
        ::HeapDestroy(g_hDenaliHeap);
        g_hDenaliHeap = NULL;
    }
}

/*===================================================================
void ::DenaliLogCall

Writes source file and line number for log message to log file

Parameters:
	const char *	szLog		Log message
	const char *	szFile		Source file in which this was called
	int				lineno		The line number in the source file

Returns:
	NONE
===================================================================*/
void DenaliLogCall( const char * szLog, const char *szFile, int lineno )
{
    return;
}

/*===================================================================
void ::DenaliMemDiagnostics

Diagnostics for the memory manager

Parameters:
	const char *	szFile		Source file in which this was called
	int				lineno		The line number in the source file

Returns:
	NONE
===================================================================*/
void DenaliMemDiagnostics( const char *szFile, int lineno )
{
    return;
}


/*===================================================================
void * ::DenaliMemAlloc

Allocates a block of memory.

Parameters:
	size_t			cSize		Size in bytes to be allocated
	const char *	szFile		Source file in which function is called
	int				lineno		Line number at which function is called

Returns:
	NONE
===================================================================*/
void * DenaliMemAlloc( size_t cSize, const char *szFile, int lineno )
{
    return ::HeapAlloc( g_hDenaliHeap, 0, cSize );
}

/*===================================================================
void ::DenaliMemFree

Validates and frees a block of allocated memory.

Parameters:
	BYTE *			pIn			Pointer to free
	const char *	szFile		Source file in which function is called
	int				lineno		Line number at which function is called

Returns:
	NONE
===================================================================*/
void DenaliMemFree( void * pIn, const char *szFile, int lineno )
{
    ::HeapFree( g_hDenaliHeap, 0, pIn );
}


/*===================================================================
void * ::DenaliMemCalloc

Allocates and clears a block of memory.

Parameters:
	size_t			cNum		Number of elements to be allocated
	size_t			cbSize		Size in bytes of each element
	const char *	szFile		Source file in which function is called
	int				lineno		Line number at which function is called

Returns:
	NONE
===================================================================*/
void * DenaliMemCalloc(size_t cNum, size_t cbSize,
                       const char *szFile, int lineno )
{
    return ::HeapAlloc( g_hDenaliHeap, HEAP_ZERO_MEMORY, cNum * cbSize );
}


/*===================================================================
void ::DenaliMemReAlloc

Validates and frees a block of allocated memory.

Parameters:
	BYTE *			pIn			Pointer memory to ReAllocate
	size_t			cSize		Number of bytes to allocate
	const char *	szFile		Source file in which function is called
	int				lineno		Line number at which function is called

Returns:
	Pointer to allocated block
===================================================================*/
void * DenaliMemReAlloc( void * pIn, size_t cSize, const char *szFile, int lineno )
{
    return ::HeapReAlloc( g_hDenaliHeap, 0, pIn, cSize );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\mtacb.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: MTA Callback

File: mtacb.h

Owner: DmitryR

This file contains the definitons for MTA Callback
===================================================================*/

#ifndef MTACALLBACK_H
#define MTACALLBACK_H

// To be called from DllInit()
HRESULT InitMTACallbacks();

// To be called from DllUnInit()
HRESULT UnInitMTACallbacks();

// The callback function to be called from an MTA thread
typedef HRESULT (__stdcall *PMTACALLBACK)(void *, void *);

HRESULT CallMTACallback
    (
    PMTACALLBACK pMTACallback,          // call this function
    void        *pvContext,             // pass this to it
    void        *pvContext2             // extra arg
    );

#endif // MTACALLBACK_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\mtacb.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: MTA Callback

File: mtacb.cpp

Owner: DmitryR

This file contains the implementation of MTA callbacks
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "MTAcb.h"
#include "memchk.h"

/*===================================================================
  MTA Callback Thread

  Worker thread that implements the MTA callback functionality
===================================================================*/
class CMTACallbackThread
    {
private:
    DWORD m_fInited : 1;    // inited?
    DWORD m_fCSInited : 1;  // critical section inited?
    DWORD m_fShutdown : 1;  // shutdown?

    CRITICAL_SECTION  m_csLock;      // callback critical section
    HANDLE            m_hDoItEvent;  // callback requested event
    HANDLE            m_hDoneEvent;  // callback done event
    HANDLE            m_hThread;     // thread handle

    PMTACALLBACK      m_pMTACallback;   // callback function ptr
    void             *m_pvContext;      // arg1
    void             *m_pvContext2;     // arg2
    HRESULT           m_hrResult;       // return code

    // The call callback from MTA thread
    void DoCallback()
        {
        Assert(m_pMTACallback);
        m_hrResult = (*m_pMTACallback)(m_pvContext, m_pvContext2);
        }

    // The thread function
    static void __cdecl Thread(void *pvArg)
        {
        HRESULT hr;

        Assert(pvArg);
        CMTACallbackThread *pThread = (CMTACallbackThread *)pvArg;

        hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);  // MTA
        if (FAILED(hr))
            {
            // Bug 87857: Handle failure from CoInitialize
            if (hr == E_INVALIDARG)
                {
                CoUninitialize();
                }
                
            // This shouldnt actually fail.  Not entirely clear what to do if it does
            Assert(FALSE);
            return;
            }

        while (!pThread->m_fShutdown)
            {
            DWORD dwRet = MsgWaitForMultipleObjects
                (
                1,
                &(pThread->m_hDoItEvent),
                FALSE,
                INFINITE,
                QS_ALLINPUT
                );

            if (pThread->m_fShutdown)
                break;

            if (dwRet == WAIT_OBJECT_0)
                {
                // Event -> do the callback
                pThread->DoCallback();
                SetEvent(pThread->m_hDoneEvent);
                }
            else
                {
                // Do messages
                MSG msg;
                while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                    DispatchMessage(&msg);
                }
            }

        CoUninitialize();
        }

public:
    // Constructor
    CMTACallbackThread()
        : m_fInited(FALSE), m_fCSInited(FALSE), m_fShutdown(FALSE),
          m_hDoItEvent(NULL), m_hDoneEvent(NULL), m_hThread(NULL),
          m_pMTACallback(NULL)
        {
        }

    // Destructor
    ~CMTACallbackThread()
        {
        // Real cleanup is in UnInit()
        // This is to cleanup after a bad Init()
        if (m_fCSInited)
            DeleteCriticalSection(&m_csLock);
        if (m_hDoItEvent)
            CloseHandle(m_hDoItEvent);
        if (m_hDoneEvent)
            CloseHandle(m_hDoneEvent);
        }

    // Init (real constructor)
    HRESULT Init()
        {
        HRESULT hr = S_OK;

        if (SUCCEEDED(hr))
            {
            ErrInitCriticalSection(&m_csLock, hr);
            m_fCSInited = SUCCEEDED(hr);
            }

        if (SUCCEEDED(hr))
            {
            m_hDoItEvent = IIS_CREATE_EVENT(
                               "CMTACallbackThread::m_hDoItEvent",
                               this,
                               FALSE,
                               FALSE
                               );
            if (!m_hDoItEvent)
                hr = E_OUTOFMEMORY;
            }

        if (SUCCEEDED(hr))
            {
            m_hDoneEvent = IIS_CREATE_EVENT(
                               "CMTACallbackThread::m_hDoneEvent",
                               this,
                               FALSE,
                               FALSE
                               );
            if (!m_hDoneEvent)
                hr = E_OUTOFMEMORY;
            }
        
        // Launch the MTA thread

        uintptr_t ulThread = _beginthread(CMTACallbackThread::Thread, 0, this);
        if (ulThread == 0xffffffff || ulThread == 0)
            hr = E_OUTOFMEMORY;
        else
            m_hThread = (HANDLE)ulThread;

        if (SUCCEEDED(hr))
            m_fInited = TRUE;
        return hr;
        }

    // UnInit (real destructor)
    HRESULT UnInit()
        {
        Assert(m_fInited);

        if (m_hThread)
            {
            // Kill the MTA thread
            m_fShutdown = TRUE;
            SetEvent(m_hDoItEvent);
            WaitForSingleObject(m_hThread, INFINITE);
            m_hThread = NULL;
            }

        if (m_fCSInited)
            {
            DeleteCriticalSection(&m_csLock);
            m_fCSInited = FALSE;
            }

        if (m_hDoItEvent)
            {
            CloseHandle(m_hDoItEvent);
            m_hDoItEvent = NULL;
            }

        if (m_hDoneEvent)
            {
            CloseHandle(m_hDoneEvent);
            m_hDoneEvent = NULL;
            }
    
        m_fInited = FALSE;
        return S_OK;
        }

    // Execute callback
    HRESULT CallCallback
    (
    PMTACALLBACK pMTACallback,
    void        *pvContext,
    void        *pvContext2
    )
        {
        if (m_fShutdown)
            return E_FAIL;

        Assert(m_fInited);
        Assert(pMTACallback);

        HRESULT hr = E_FAIL;
        DWORD   eventSignaled;

        EnterCriticalSection(&m_csLock);

        Assert(m_pMTACallback == NULL);
        m_pMTACallback = pMTACallback;
        m_pvContext  = pvContext;
        m_pvContext2 = pvContext2;
        m_hrResult   = E_FAIL;

        // Tell MTA thread to call back
        SetEvent(m_hDoItEvent);

        // Wait till done
        CoWaitForMultipleHandles(0,
                                 INFINITE,
                                 1,
                                 &m_hDoneEvent,
                                 &eventSignaled);

        // remember HRESULT
        hr = m_hrResult;

        // to make sure we never do it twice
        m_pMTACallback = NULL;

        LeaveCriticalSection(&m_csLock);
        return hr;
        }
    };

// Sole instance of the above
static CMTACallbackThread g_MTACallbackThread;

/*===================================================================
  E x t e r n a l  A P I
===================================================================*/

/*===================================================================
InitMTACallbacks

To be called from DllInit()
Inits the MTA callback processing
Launches the MTA thread

Parameters

Returns:
    HRESULT
===================================================================*/
HRESULT InitMTACallbacks()
    {
    return g_MTACallbackThread.Init();
    }

/*===================================================================
UnInitMTACallbacks

To be called from DllUnInit()
Stops the MTA callback processing
Kills the MTA thread

Parameters

Returns:
    HRESULT
===================================================================*/
HRESULT UnInitMTACallbacks()
    {
    return g_MTACallbackThread.UnInit();
    }

/*===================================================================
CallMTACallback

Calls the hack.

Parameters
    PMTACALLBACK  pMTACallback       call this function
    void         *pvContext          pass this to it
    void         *pvContext2         extra arg

Returns:
    HRESULT
===================================================================*/
HRESULT CallMTACallback
(
PMTACALLBACK pMTACallback,
void        *pvContext,
void        *pvContext2
)
    {
    return g_MTACallbackThread.CallCallback
        (
        pMTACallback,
        pvContext,
        pvContext2
        );
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\memcls.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Per-Class Memory Management

File: Memcls.h

Owner: dmitryr

This file contains #defines to access ATQ memory cache on per
class basis
===================================================================*/

#ifndef MEMCLS_H
#define MEMCLS_H

// ATQ memory cache
#include <acache.hxx>

// To resolve Assert()
#include "debug.h"

// Prototypes

HRESULT InitMemCls();
HRESULT UnInitMemCls();

/*===================================================================
  M A C R O S  to make a class use ACACHE allocator
===================================================================*/

/*===================================================================
  I n s t r u c t i o n s

    To add a class named CFoo to the per-class basis follow these
    four simple steps:

    1) Inside the class definition include ACACHE_INCLASS_DEFINITIONS():

            class CFoo
                {
                ...


                ACACHE_INCLASS_DEFINITIONS()    // <-add this line
                };

    2) In a source file add the ACACHE_CODE macro outside
       any function body:
       
            ACACHE_CODE(CFoo)                   // <-add this line

    3) In a DLL initialization routine add ACACHE_INIT macro:

            ACACHE_INIT(CFoo, 13, hr)           // <-add this line

       where 13 is the threshold. Use the desired number instead.
       

    4) In a DLL uninitialization routine add ACACHE_UNINIT macro:

            ACACHE_UNINIT(CFoo)                 // <-add this line
            

===================================================================*/

/*

The following macro should be used inside class definition to
enable per-class caching.

The second operator new is needed in case memchk.h [#define]'s new
to this expanded form.

*/

#define ACACHE_INCLASS_DEFINITIONS()                            \
    public:                                                     \
        static void * operator new(size_t);                     \
        static void * operator new(size_t, const char *, int);  \
        static void   operator delete(void *);                  \
        static ALLOC_CACHE_HANDLER *sm_pach;

/*

The following macro should be used once per class in a source
file outside of any functions. The argument is the class name.

*/

#define ACACHE_CODE(C)                                          \
    ALLOC_CACHE_HANDLER *C::sm_pach;                            \
    void *C::operator new(size_t s)                             \
        { Assert(s == sizeof(C)); Assert(sm_pach);              \
        return sm_pach->Alloc(); }                              \
    void *C::operator new(size_t s, const char *, int)          \
        { Assert(s == sizeof(C)); Assert(sm_pach);              \
        return sm_pach->Alloc(); }                              \
    void C::operator delete(void *pv)                           \
        { Assert(pv); if (sm_pach) sm_pach->Free(pv); }

/*

The following macro should be used once per class in the
DLL initialization routine.
Arguments: class name, cache size, HRESULT var name

*/

#define ACACHE_INIT(C, T, hr)                                   \
    { if (SUCCEEDED(hr)) { Assert(!C::sm_pach);                 \
    ALLOC_CACHE_CONFIGURATION acc = { 1, T, sizeof(C) };        \
    C::sm_pach = new ALLOC_CACHE_HANDLER("ASP:" #C, &acc);      \
    hr = C::sm_pach ? S_OK : E_OUTOFMEMORY; } }

#define ACACHE_INIT_EX(C, T, F, hr)                                   \
    { if (SUCCEEDED(hr)) { Assert(!C::sm_pach);                 \
    ALLOC_CACHE_CONFIGURATION acc = { 1, T, sizeof(C) };        \
    C::sm_pach = new ALLOC_CACHE_HANDLER("ASP:" #C, &acc, F);      \
    hr = C::sm_pach ? S_OK : E_OUTOFMEMORY; } }

/*

The following macro should be used once per class in the
DLL uninitialization routine. The argument is the class name.

*/

#define ACACHE_UNINIT(C)                                        \
    { if (C::sm_pach) { delete C::sm_pach; C::sm_pach = NULL; } }


/*===================================================================
  M A C R O S  to create a fixes size allocator
===================================================================*/

/*===================================================================
  I n s t r u c t i o n s

    To add a fixed size allocator for 1K buffers named Foo
    to the code follow these simple steps:

    1) In a header file include extern definition

            ACACHE_FSA_EXTERN(Foo)

    2) In a source file the actual definition outside
       any function body:
       
            ACACHE_FSA_DEFINITION(Foo)

    3) In a DLL initialization routine add INIT macro:

            ACACHE_FSA_INIT(Foo, 1024, 13, hr)

       where 1024 is the size and 13 is the threshold.
       Use the desired numbers instead.
       
    4) In a DLL uninitialization routine add UNINIT macro:

            ACACHE_FSA_UNINIT(CFoo)

    5) To allocate, do:

            void *pv = ACACHE_FSA_ALLOC(Foo)

    6) To free, do:

            ACACHE_FSA_FREE(Foo, pv)

===================================================================*/

#define ACACHE_FSA_EXTERN(C)                                    \
    extern ALLOC_CACHE_HANDLER *g_pach##C;

#define ACACHE_FSA_DEFINITION(C)                                \
    ALLOC_CACHE_HANDLER *g_pach##C = NULL;

#define ACACHE_FSA_INIT(C, S, T, hr)                            \
    { if (SUCCEEDED(hr)) { Assert(!g_pach##C);                  \
    ALLOC_CACHE_CONFIGURATION acc = { 1, T, S };                \
    g_pach##C = new ALLOC_CACHE_HANDLER("ASP:" #C, &acc);       \
    hr = g_pach##C ? S_OK : E_OUTOFMEMORY; } }

#define ACACHE_FSA_UNINIT(C)                                    \
    { if (g_pach##C) { delete g_pach##C; g_pach##C = NULL; } }

#define ACACHE_FSA_ALLOC(C)                                     \
    ( g_pach##C ? g_pach##C->Alloc() : NULL )

#define ACACHE_FSA_FREE(C, pv)                                  \
    { Assert(pv); if (g_pach##C) g_pach##C->Free(pv); }
    
#endif // MEMCLS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\ntsec.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: NT/OLE Security

File: NTSec.cpp

Owner: AndrewS

This file contains code related to NT security on Desktops

BUG 87164: This whole code path is unused.  I'm leaving this around
in case we ever need it.
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "ntsec.h"

// Globals
HDESK ghDesktop = NULL;
HDESK ghdeskPrev = NULL;

// Local Defines
// Note: This name is deliberately obscure so no one will guess it
#define SZ_DEN_DESKTOP	"__A8D9S1_42_D"

#define DESKTOP_ALL (DESKTOP_READOBJECTS     | DESKTOP_CREATEWINDOW     | \
                     DESKTOP_CREATEMENU      | DESKTOP_HOOKCONTROL      | \
                     DESKTOP_JOURNALRECORD   | DESKTOP_JOURNALPLAYBACK  | \
                     DESKTOP_ENUMERATE       | DESKTOP_WRITEOBJECTS     | \
                     DESKTOP_SWITCHDESKTOP   | STANDARD_RIGHTS_REQUIRED)

/*===================================================================
InitDesktop

Create a desktop for ASP threads to use & tells Viper to call
us back on every thread create so we can set the desktop

Parameters:

Returns:
	HRESULT		S_OK on success

Side effects
	Sets global variables
===================================================================*/
HRESULT InitDesktop()
	{
	HRESULT hr = S_OK;
	DWORD err;
	HDESK hDesktop = NULL;

	// Only applies to NT
	if (!Glob(fWinNT))
		return(S_OK);

	// Save the old desktop because we might need it later for an obscure error condition
	if ((ghdeskPrev = GetThreadDesktop(GetCurrentThreadId())) == NULL)
		goto LErr;

	// Create a desktop for denali to use
	if ((hDesktop = CreateDesktop(SZ_DEN_DESKTOP, NULL, NULL, 0, DESKTOP_ALL, NULL)) == NULL)
		goto LErr;

	// store this handle in the global
	ghDesktop = hDesktop;

#ifdef UNUSED
	hr = SetViperThreadEvents();
	Assert(SUCCEEDED(hr));
#endif

	return(hr);
	
LErr:
	Assert(FALSE);

	if (hDesktop != NULL)
		CloseDesktop(hDesktop);

	err = GetLastError();
	hr = HRESULT_FROM_WIN32(err);
	return(hr);
	}
	
/*===================================================================
UnInitDesktop

Destroy the ASP desktop 

Parameters:
	None
	
Returns:
	Nothing

Side effects
	Sets global variables
===================================================================*/
VOID UnInitDesktop()
	{
	BOOL fClosed;

	if (ghDesktop != NULL)
		{
		BOOL fRetried = FALSE;
LRetry:
		Assert(ghDesktop != NULL);
		fClosed = CloseDesktop(ghDesktop);
		// If this fails, it probably means that we are in the obscure case where
		// IIS's CacheExtensions registry setting is 0.  In this case, we are shutting
		// down in a worker thread.  This worker thread is using the desktop, so
		// it cant be closed.  In this case, attempt to set the desktop back to the
		// original IIS desktop, and then retry closing the desktop.  Only retry once.
		if (!fClosed && !fRetried)
			{
			fRetried = TRUE;
			if (!SetThreadDesktop(ghdeskPrev))
				Assert(FALSE);
			goto LRetry;
			}
        // BUG 86775: Begning assert	
		// Assert(fClosed);
		
		ghDesktop = NULL;
		}
		
	return;
	}

/*===================================================================
SetDesktop

Set the desktop for the calling thread

Parameters:
	None
	
Returns:
	S_OK on success

Side effects:
	Sets desktop
===================================================================*/
HRESULT SetDesktop()
	{
	DWORD err;

	if (Glob(fWinNT) && ghDesktop != NULL)
		{
		if (!SetThreadDesktop(ghDesktop))
			goto LErr;
		}

	return(S_OK);
	
LErr:
	Assert(FALSE);

	err = GetLastError();
	return(HRESULT_FROM_WIN32(err));
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\ntsec.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: NT/OLE Security

File: NTSec.h

Owner: AndrewS

This file contains code related to NT security on Desktops
===================================================================*/

#ifndef __NTSec_h
#define __NTSec_h

HRESULT InitDesktop();
VOID UnInitDesktop();
HRESULT SetDesktop();

#endif //__NTSec_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\perfdata.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Main

File: perfdata.h

Owner: DmitryR

PERFMON related data in asp.dll -- header file
===================================================================*/

#ifndef _ASP_PERFDATA_H
#define _ASP_PERFDATA_H

#ifndef PERF_DISABLE

#include "perfdef.h"
#include "denali.h"

// Counter offsets in the array

#define ID_DEBUGDOCREQ      0
#define ID_REQERRRUNTIME    1
#define ID_REQERRPREPROC    2
#define ID_REQERRCOMPILE    3
#define ID_REQERRORPERSEC   4
#define ID_REQTOTALBYTEIN   5
#define ID_REQTOTALBYTEOUT  6
#define ID_REQEXECTIME      7
#define ID_REQWAITTIME      8
#define ID_REQCOMFAILED     9
#define ID_REQBROWSEREXEC   10
#define ID_REQFAILED        11
#define ID_REQNOTAUTH       12
#define ID_REQNOTFOUND      13
#define ID_REQCURRENT       14
#define ID_REQREJECTED      15
#define ID_REQSUCCEEDED     16
#define ID_REQTIMEOUT       17
#define ID_REQTOTAL         18
#define ID_REQPERSEC        19
#define ID_SCRIPTFREEENG    20
#define ID_SESSIONLIFETIME  21
#define ID_SESSIONCURRENT   22
#define ID_SESSIONTIMEOUT   23
#define ID_SESSIONSTOTAL    24
#define ID_TEMPLCACHE       25
#define ID_TEMPLCACHEHITS   26
#define ID_TEMPLCACHETRYS   27
#define ID_TEMPLFLUSHES     28
#define ID_TRANSABORTED     29
#define ID_TRANSCOMMIT      30
#define ID_TRANSPENDING     31
#define ID_TRANSTOTAL       32
#define ID_TRANSPERSEC      33
#define ID_MEMORYTEMPLCACHE   34
#define ID_MEMORYTEMPLCACHEHITS 35
#define ID_MEMORYTEMPLCACHETRYS 36

/*===================================================================
CPerfData -- PERFMON data for ASP
             CPerfProcBlock 
                + macros to update counters
                + clsid to remember
                + place to update counters before perfmon inited
===================================================================*/

class CPerfData : public CPerfProcBlock
    {
private:
    // Initial counter values (gathered when uninit)
    DWORD m_rgdwInitCounters[C_PERF_PROC_COUNTERS];
    // CLSID
    DWORD m_fValid : 1;
    CLSID m_ClsId;

public:
    inline CPerfData() 
        : m_fValid(FALSE)
        {
        memset(m_rgdwInitCounters, 0, CB_COUNTERS);
        }

    inline ~CPerfData()
        {
        }

    inline HRESULT Init(const CLSID &ClsId)
        {
        HRESULT hr = InitForThisProcess(ClsId, m_rgdwInitCounters);
        if (SUCCEEDED(hr))
            {
            m_ClsId = ClsId;
            m_fValid = TRUE;
            }
        return hr;
        }

    inline HRESULT UnInit()
        {
        m_fValid = FALSE;
        return CPerfProcBlock::UnInit();
        }

    inline BOOL FValid()
        {
        return m_fValid;
        }

    inline const CLSID & ClsId()
        {
        return m_ClsId;
        }

    // helper inline to get counter address as DWORD *
    inline DWORD *PDWCounter(int i)
        {
        return m_fInited ? &(m_pData->m_rgdwCounters[i])
                         : &(m_rgdwInitCounters[i]);
        }
    
    // helper inline to get counter address as LPLONG
    inline LPLONG PLCounter(int i)
        {
        return (LPLONG)PDWCounter(i);
        }

    // Inlines to change individual counters --------------

    inline void Incr_DEBUGDOCREQ()
        {
        InterlockedIncrement(PLCounter(ID_DEBUGDOCREQ));
        }
    inline void Incr_REQERRRUNTIME()
        {
        InterlockedIncrement(PLCounter(ID_REQERRRUNTIME));
        }
    inline void Incr_REQERRPREPROC()
        {
        InterlockedIncrement(PLCounter(ID_REQERRPREPROC));
        }
    inline void Incr_REQERRCOMPILE()
        {
        InterlockedIncrement(PLCounter(ID_REQERRCOMPILE));
        }
    inline void Incr_REQERRORPERSEC()
        {
        InterlockedIncrement(PLCounter(ID_REQERRORPERSEC));
        }
    inline void Add_REQTOTALBYTEIN(DWORD dw)
        {
        EnterCriticalSection(&m_csReqLock);
        *PDWCounter(ID_REQTOTALBYTEIN) += dw;
    	LeaveCriticalSection(&m_csReqLock);
        }
    inline void Add_REQTOTALBYTEOUT(DWORD dw)
        {
        EnterCriticalSection(&m_csReqLock);
        *PDWCounter(ID_REQTOTALBYTEOUT) += dw;
    	LeaveCriticalSection(&m_csReqLock);
        }
    inline void Set_REQEXECTIME(DWORD dw)
        {
        InterlockedExchange(PLCounter(ID_REQEXECTIME), (LONG)dw);
        }
    inline void Set_REQWAITTIME(DWORD dw)
        {
        InterlockedExchange(PLCounter(ID_REQWAITTIME), (LONG)dw);
        }
    inline void Incr_REQCOMFAILED()
        {
        InterlockedIncrement(PLCounter(ID_REQCOMFAILED));
        }
    inline void Incr_REQBROWSEREXEC()
        {
        InterlockedIncrement(PLCounter(ID_REQBROWSEREXEC));
        }
    inline void Decr_REQBROWSEREXEC()
        {
        InterlockedDecrement(PLCounter(ID_REQBROWSEREXEC));
        }
    inline void Incr_REQFAILED()
        {
        InterlockedIncrement(PLCounter(ID_REQFAILED));
        }
    inline void Incr_REQNOTAUTH()
        {
        InterlockedIncrement(PLCounter(ID_REQNOTAUTH));
        }
    inline void Incr_REQNOTFOUND()
        {
        InterlockedIncrement(PLCounter(ID_REQNOTFOUND));
        }
    inline DWORD Incr_REQCURRENT()
        {
        return InterlockedIncrement(PLCounter(ID_REQCURRENT));
        }
    inline void Decr_REQCURRENT()
        {
        InterlockedDecrement(PLCounter(ID_REQCURRENT));
        }
    inline void Incr_REQREJECTED()
        {
        InterlockedIncrement(PLCounter(ID_REQREJECTED));
        }
    inline void Incr_REQSUCCEEDED()
        {
        InterlockedIncrement(PLCounter(ID_REQSUCCEEDED));
        }
    inline void Incr_REQTIMEOUT()
        {
        InterlockedIncrement(PLCounter(ID_REQTIMEOUT));
        }
    inline void Incr_REQTOTAL()
        {
        InterlockedIncrement(PLCounter(ID_REQTOTAL));
        }
    inline void Incr_REQPERSEC()
        {
        InterlockedIncrement(PLCounter(ID_REQPERSEC));
        }
    inline void Incr_SCRIPTFREEENG()
        {
        InterlockedIncrement(PLCounter(ID_SCRIPTFREEENG));
        }
    inline void Decr_SCRIPTFREEENG()
        {
        InterlockedDecrement(PLCounter(ID_SCRIPTFREEENG));
        }
    inline void Set_SESSIONLIFETIME(DWORD dw)
        {
        InterlockedExchange(PLCounter(ID_SESSIONLIFETIME), (LONG)dw);
        }
    inline void Incr_SESSIONCURRENT()
        {
        InterlockedIncrement(PLCounter(ID_SESSIONCURRENT));
        }
    inline void Decr_SESSIONCURRENT()
        {
        InterlockedDecrement(PLCounter(ID_SESSIONCURRENT));
        }
    inline void Incr_SESSIONTIMEOUT()
        {
        InterlockedIncrement(PLCounter(ID_SESSIONTIMEOUT));
        }
    inline void Incr_SESSIONSTOTAL()
        {
        InterlockedIncrement(PLCounter(ID_SESSIONSTOTAL));
        }
    inline void Incr_TEMPLCACHE()
        {
        InterlockedIncrement(PLCounter(ID_TEMPLCACHE));
        }
    inline void Decr_TEMPLCACHE()
        {
        InterlockedDecrement(PLCounter(ID_TEMPLCACHE));
        }
    inline void Zero_TEMPLCACHE()
        {
        InterlockedExchange(PLCounter(ID_TEMPLCACHE), 0);
        }
    inline void Incr_TEMPLCACHEHITS()
        {
        InterlockedIncrement(PLCounter(ID_TEMPLCACHEHITS));
        }
    inline void Incr_TEMPLCACHETRYS()
        {
        InterlockedIncrement(PLCounter(ID_TEMPLCACHETRYS));
        }
    inline void Incr_MEMORYTEMPLCACHE()
        {
        InterlockedIncrement(PLCounter(ID_MEMORYTEMPLCACHE));
        }
    inline void Decr_MEMORYTEMPLCACHE()
        {
        InterlockedDecrement(PLCounter(ID_MEMORYTEMPLCACHE));
        }
    inline void Zero_MEMORYTEMPLCACHE()
        {
        InterlockedExchange(PLCounter(ID_MEMORYTEMPLCACHE), 0);
        }
    inline void Incr_MEMORYTEMPLCACHEHITS()
        {
        InterlockedIncrement(PLCounter(ID_MEMORYTEMPLCACHEHITS));
        }
    inline void Incr_MEMORYTEMPLCACHETRYS()
        {
        InterlockedIncrement(PLCounter(ID_MEMORYTEMPLCACHETRYS));
        }
    inline void Incr_TEMPLFLUSHES()
        {
        InterlockedIncrement(PLCounter(ID_TEMPLFLUSHES));
        }
    inline void Incr_TRANSABORTED()
        {
        InterlockedIncrement(PLCounter(ID_TRANSABORTED));
        }
    inline void Incr_TRANSCOMMIT()
        {
        InterlockedIncrement(PLCounter(ID_TRANSCOMMIT));
        }
    inline void Incr_TRANSPENDING()
        {
        InterlockedIncrement(PLCounter(ID_TRANSPENDING));
        }
    inline void Decr_TRANSPENDING()
        {
        InterlockedDecrement(PLCounter(ID_TRANSPENDING));
        }
    inline void Incr_TRANSTOTAL()
        {
        InterlockedIncrement(PLCounter(ID_TRANSTOTAL));
        }
    inline void Incr_TRANSPERSEC()
        {
        InterlockedIncrement(PLCounter(ID_TRANSPERSEC));
        }
        
    };

// We init PERFMON data on first request
extern BOOL g_fPerfInited;

// Object to access main shared PERFMON memory
extern CPerfMainBlock g_PerfMain;

// Object to access shared memory (incl. counters) for this process
extern CPerfData g_PerfData;

HRESULT PreInitPerfData();

HRESULT InitPerfDataOnFirstRequest(CIsapiReqInfo    *pIReq);

HRESULT UnInitPerfData();

#else

inline HRESULT PreInitPerfData()
    {
    return S_OK;
    }

inline HRESULT InitPerfDataOnFirstRequest(CIsapiReqInfo    *pIReq) 
    {
    return S_OK; 
    }

inline HRESULT UnInitPerfData()
    {
    return S_OK; 
    }

#endif  // PERF_DISABLE


#endif // _ASP_PERFDATA_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\perfdata.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Main

File: perfdata.cpp

Owner: DmitryR

PERFMON related data in asp.dll -- source file
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "perfdata.h"
#include "memchk.h"

// to access metabase
#include <iiscnfg.h>
#include <iwamreg.h>

#ifndef PERF_DISABLE

BOOL g_fPerfInited = FALSE;
CPerfMainBlock g_PerfMain;
CPerfData      g_PerfData;

/*===================================================================
GetCurrentClsId

Static function to find the current WAM CLSID in the metabase

Parameters
    pIReq            to retrieve WAM CLSID from the metabase
    pClsId          [out] CLSID

Returns:
    HRESULT
===================================================================*/
static HRESULT GetCurrentClsId
(
CIsapiReqInfo   *pIReq,
CLSID *pClsId
)
    {
    HRESULT hr = S_OK;

    Assert(pClsId);

    TCHAR *szMDPath = pIReq->QueryPszApplnMDPath();
    if (!szMDPath)
        {
        *pClsId = CLSID_NULL;
        return E_FAIL;
        }

    CLSID ClsId = CLSID_NULL;

    // Bracket ISA thread

    if (SUCCEEDED(StartISAThreadBracket(pIReq)))
        {
        WCHAR wszClsBuffer[80];
    	DWORD dwRequiredLen, dwAppMode;
        // Find the application mode, inproc, out-of-proc, or pooled OOP
        hr = pIReq->GetAspMDData(szMDPath,
                                 MD_APP_ISOLATED,
                                 METADATA_INHERIT,
                                 IIS_MD_UT_WAM,
                                 DWORD_METADATA,
                                 sizeof(DWORD),
                                 0,
                                 (unsigned char*) &dwAppMode,
                                 &dwRequiredLen);
    	if (SUCCEEDED(hr))
        {
            switch (dwAppMode)
            {
            case eAppRunInProc:
                // preconfigured WAM CLSID for all inproc apps
                wcscpy(wszClsBuffer,
                       L"{99169CB0-A707-11d0-989D-00C04FD919C1}");
                break;
            case eAppRunOutProcIsolated:
                // custom WAM CLSID for non-pooled OOP apps
                hr = pIReq->GetAspMDData(szMDPath,
                                         MD_APP_WAM_CLSID,
                                         METADATA_INHERIT,
                                         IIS_MD_UT_WAM,
                                         STRING_METADATA,
                                         sizeof(wszClsBuffer) / sizeof(WCHAR),
                                         0,
                                         (unsigned char *)wszClsBuffer,
                                         &dwRequiredLen);
                break;
            case eAppRunOutProcInDefaultPool:
                // preconfigured WAM CLSID for the pooled OOP apps
                wcscpy(wszClsBuffer,
                       L"{3D14228D-FBE1-11d0-995D-00C04FD919C1}");
                break;
            default:
                Assert(!"unknown AppMode");
                hr = E_FAIL;
                break;
            }
        }
                            
    	if (SUCCEEDED(hr))
    	    {
    	    // Convert string to CLSID
    		hr = CLSIDFromString(wszClsBuffer, &ClsId);
    	    }

        EndISAThreadBracket(pIReq);
        }
    else
        {
        hr = E_FAIL;
        }

    if (SUCCEEDED(hr) && g_fOOP) // always CLSID_NULL if inproc
        *pClsId = ClsId;
    else
        *pClsId = CLSID_NULL;
    
    return hr;
    }

/*===================================================================
PreInitPerfData

Initialize from DllInit
Creates critical sections

Parameters

Returns:
    HRESULT
===================================================================*/
HRESULT PreInitPerfData()
    {
    HRESULT hr = S_OK;

    hr = g_PerfData.InitCriticalSections();

    return hr;
    }

/*===================================================================
InitPerfDataOnFirstRequest

Initialize PERFMON related ASP data from first request

Parameters
    pIReq    to retrieve WAM CLSID from the metabase

Returns:
    HRESULT
===================================================================*/
HRESULT InitPerfDataOnFirstRequest
(
CIsapiReqInfo   *pIReq
)
    {
    // Get CLSID from metabase
    CLSID ClsId;
    HRESULT hr = GetCurrentClsId(pIReq, &ClsId);

    // Check HRESULT from GetCurrentClsId
    if (FAILED(hr))
        return hr;

    // access main shared memory
    if (SUCCEEDED(hr))
        hr = g_PerfMain.Init();

    // access shared memory of this process
    if (SUCCEEDED(hr))
        hr = g_PerfData.Init(ClsId);

    // add this process data to main shared memory
    if (SUCCEEDED(hr))
        hr = g_PerfMain.AddProcess(ClsId);

    if (FAILED(hr))
        {
        g_PerfData.UnInit();
        g_PerfMain.UnInit();
        }

    return hr;
    }

/*===================================================================
UnInitPerfData

UnInitialize PERFMON related ASP data

Returns:
    HRESULT
===================================================================*/
HRESULT UnInitPerfData()
    {
    // remove this process data from main shared memory
    if (g_PerfData.FValid())
        g_PerfMain.RemoveProcess(g_PerfData.ClsId());

    // stop accessing process shared memory
    g_PerfData.UnInit();
    
    // stop accessing main shared memory
    g_PerfMain.UnInit();

    return S_OK;
    }

#endif  // PERF_DISABLE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\randgen.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Random number generator

File: randgen.h

Owner: DmitryR

This file contains the definitons for the random number
generator.
===================================================================*/

#ifndef RANDGEN_H
#define RANDGEN_H

// To be called from DllInit()
HRESULT InitRandGenerator();

// To be called from DllUnInit()
HRESULT UnInitRandGenerator();

// The generator funcions
DWORD GenerateRandomDword();
HRESULT GenerateRandomDwords(DWORD *pdwDwords, DWORD cDwords);

#endif // RANDGEN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\perfdef.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Main

File: perfdef.h

Owner: DmitryR

Data definitions shared between asp.dll and aspperf.dll
===================================================================*/

#ifndef _ASP_PERFDEF_H
#define _ASP_PERFDEF_H

#include <pudebug.h>

/*===================================================================
Definitions of names, sizes and mapped data block structures
===================================================================*/

// Mutex name to access the main file map
#define SZ_PERF_MUTEX           "Global\\ASP_PERFMON_MUTEX"

// WaitForSingleObject arg (how long to wait for mutext before failing)
#define PERM_MUTEX_WAIT         1000

// Main shared file map name
#define SZ_PERF_MAIN_FILEMAP    "Global\\ASP_PERFMON_MAIN_BLOCK"

// Max number of registered (ASP) processes in main file map
#define C_PERF_PROC_MAX         1024

// Structure that defines main file map
struct CPerfMainBlockData
    {
    DWORD m_dwTimestamp;  // time (GetTickCount()) of the last change
    DWORD m_cItems;       // number of registred processes
    
    // array of process WAM CLS IDs
    CLSID m_rgClsIds[C_PERF_PROC_MAX];
    };

#define CB_PERF_MAIN_BLOCK      (sizeof(struct CPerfMainBlockData))

// Name for per-process file map
#define SZ_PERF_PROC_FILEMAP_PREFIX    "Global\\ASP_PERFMON_BLOCK_"
#define CCH_PERF_PROC_FILEMAP_PREFIX   25

// Number of counters in per-process file map
#define C_PERF_PROC_COUNTERS    37

struct CPerfProcBlockData
    {
    CLSID m_ClsId;                               // process CLS ID
    DWORD m_rgdwCounters[C_PERF_PROC_COUNTERS];  // array counters
    };

#define CB_PERF_PROC_BLOCK      (sizeof(struct CPerfProcBlockData))
#define CB_COUNTERS             (sizeof(DWORD) * C_PERF_PROC_COUNTERS)



/*===================================================================
CSharedMemBlock  --  generic shared memory block
===================================================================*/

class CSharedMemBlock
    {
private:
    HANDLE m_hMemory;
    void  *m_pMemory;

protected:
    SECURITY_ATTRIBUTES m_sa;

public:
    inline CSharedMemBlock() : m_hMemory(NULL), m_pMemory(NULL) {
		m_sa.nLength = sizeof(SECURITY_ATTRIBUTES);
    	m_sa.lpSecurityDescriptor = NULL;
	    m_sa.bInheritHandle = FALSE;
    }
    inline ~CSharedMemBlock() { 
        UnInitMap(); 
        if (m_sa.lpSecurityDescriptor)
            free(m_sa.lpSecurityDescriptor);
    }

    inline void *PMemory() { return m_pMemory; }

    HRESULT InitSD();
    HRESULT InitMap(LPCSTR szName, DWORD dwSize);
    HRESULT UnInitMap();
private:
    HRESULT CreateSids( PSID                    *ppBuiltInAdministrators,
                        PSID                    *ppPowerUsers,
                        PSID                    *ppAuthenticatedUsers);
    };

//
// CreateSids
//
// Create 3 Security IDs
//
// Caller must free memory allocated to SIDs on success.
//
// Returns: HRESULT indicating SUCCESS or FAILURE
//
inline HRESULT CSharedMemBlock::CreateSids(
    PSID                    *ppBuiltInAdministrators,
    PSID                    *ppPowerUsers,
    PSID                    *ppAuthenticatedUsers
)
{
    HRESULT     hr = S_OK;

    *ppBuiltInAdministrators = NULL;
    *ppPowerUsers = NULL;
    *ppAuthenticatedUsers = NULL;

    //
    // An SID is built from an Identifier Authority and a set of Relative IDs
    // (RIDs).  The Authority of interest to us SECURITY_NT_AUTHORITY.
    //

    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;

    //
    // Each RID represents a sub-unit of the authority.  Two of the SIDs we
    // want to build, Local Administrators, and Power Users, are in the "built
    // in" domain.  The other SID, for Authenticated users, is based directly
    // off of the authority.
    //     
    // For examples of other useful SIDs consult the list in
    // \nt\public\sdk\inc\ntseapi.h.
    //

    if (!AllocateAndInitializeSid(&NtAuthority,
                                  2,            // 2 sub-authorities
                                  SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS,
                                  0,0,0,0,0,0,
                                  ppBuiltInAdministrators)) {

        hr = HRESULT_FROM_WIN32(GetLastError());
        
    } else if (!AllocateAndInitializeSid(&NtAuthority,
                                         2,            // 2 sub-authorities
                                         SECURITY_BUILTIN_DOMAIN_RID,
                                         DOMAIN_ALIAS_RID_POWER_USERS,
                                         0,0,0,0,0,0,
                                         ppPowerUsers)) {

        hr = HRESULT_FROM_WIN32(GetLastError());
        
    } else if (!AllocateAndInitializeSid(&NtAuthority,
                                         1,            // 1 sub-authority
                                         SECURITY_AUTHENTICATED_USER_RID,
                                         0,0,0,0,0,0,0,
                                         ppAuthenticatedUsers)) {

        hr = HRESULT_FROM_WIN32(GetLastError());
        
    }

    if (FAILED(hr)) {

        if (*ppBuiltInAdministrators) {
            FreeSid(*ppBuiltInAdministrators);
            *ppBuiltInAdministrators = NULL;
        }

        if (*ppPowerUsers) {
            FreeSid(*ppPowerUsers);
            *ppPowerUsers = NULL;
        }

        if (*ppAuthenticatedUsers) {
            FreeSid(*ppAuthenticatedUsers);
            *ppAuthenticatedUsers = NULL;
        }
    }

    return hr;
}


//
// InitSD
//
// Creates a SECURITY_DESCRIPTOR with specific DACLs.
//

inline HRESULT CSharedMemBlock::InitSD()
{
    HRESULT                 hr = S_OK;
    PSID                    pAuthenticatedUsers = NULL;
    PSID                    pBuiltInAdministrators = NULL;
    PSID                    pPowerUsers = NULL;
    PSECURITY_DESCRIPTOR    pSD = NULL;

    if (m_sa.lpSecurityDescriptor != NULL) {
        return S_OK;
    }

    if (FAILED(hr = CreateSids(&pBuiltInAdministrators,
                               &pPowerUsers,
                               &pAuthenticatedUsers)));


    else {

        // 
        // Calculate the size of and allocate a buffer for the DACL, we need
        // this value independently of the total alloc size for ACL init.
        //

        ULONG                   AclSize;

        //
        // "- sizeof (ULONG)" represents the SidStart field of the
        // ACCESS_ALLOWED_ACE.  Since we're adding the entire length of the
        // SID, this field is counted twice.
        //

        AclSize = sizeof (ACL) +
            (3 * (sizeof (ACCESS_ALLOWED_ACE) - sizeof (ULONG))) +
            GetLengthSid(pAuthenticatedUsers) +
            GetLengthSid(pBuiltInAdministrators) +
            GetLengthSid(pPowerUsers);

        pSD = malloc(SECURITY_DESCRIPTOR_MIN_LENGTH + AclSize);

        if (!pSD) {

            hr = E_OUTOFMEMORY;

        } else {

            ACL                     *Acl;

            Acl = (ACL *)((BYTE *)pSD + SECURITY_DESCRIPTOR_MIN_LENGTH);

            if (!InitializeAcl(Acl,
                               AclSize,
                               ACL_REVISION)) {

                hr = HRESULT_FROM_WIN32(GetLastError());

            } else if (!AddAccessAllowedAce(Acl,
                                            ACL_REVISION,
                                            SYNCHRONIZE | GENERIC_ALL,
                                            pAuthenticatedUsers)) {

                hr = HRESULT_FROM_WIN32(GetLastError());

            } else if (!AddAccessAllowedAce(Acl,
                                            ACL_REVISION,
                                            SYNCHRONIZE | GENERIC_ALL,
                                            pPowerUsers)) {

                hr = HRESULT_FROM_WIN32(GetLastError());

            } else if (!AddAccessAllowedAce(Acl,
                                            ACL_REVISION,
                                            SYNCHRONIZE | GENERIC_ALL,
                                            pBuiltInAdministrators)) {

                hr = HRESULT_FROM_WIN32(GetLastError());

            } else if (!InitializeSecurityDescriptor(pSD,
                                                     SECURITY_DESCRIPTOR_REVISION)) {

                hr = HRESULT_FROM_WIN32(GetLastError());

            } else if (!SetSecurityDescriptorDacl(pSD,
                                                  TRUE,
                                                  Acl,
                                                  FALSE)) {

                hr = HRESULT_FROM_WIN32(GetLastError());

            } 
        }
    }

    if (pAuthenticatedUsers)
        FreeSid(pAuthenticatedUsers);

    if (pBuiltInAdministrators)
        FreeSid(pBuiltInAdministrators);

    if (pPowerUsers)
        FreeSid(pPowerUsers);

    if (FAILED(hr) && pSD) {
        free(pSD);
        pSD = NULL;
    }

    m_sa.lpSecurityDescriptor = pSD;

    return hr;
}

inline HRESULT CSharedMemBlock::InitMap
(
LPCSTR szName,
DWORD  dwSize
)
    {
    BOOL fNew = FALSE;
    HRESULT hr = S_OK;

    if (FAILED(hr = InitSD())) {
        return hr;
    }
    
    // Try to open existing
    m_hMemory = OpenFileMappingA
        (
        FILE_MAP_ALL_ACCESS,
        FALSE, 
        szName
        );
    if (!m_hMemory)
        {
	    m_hMemory = CreateFileMappingA
	        (
	        INVALID_HANDLE_VALUE,
    		&m_sa,
    		PAGE_READWRITE,
	    	0,
		    dwSize,
			szName
			);
		fNew = TRUE;
		}
    if (!m_hMemory)
        return E_FAIL;

	m_pMemory = MapViewOfFile
	    (
	    m_hMemory,
		FILE_MAP_ALL_ACCESS,
		0,
		0,
		0
		);
	if (!m_pMemory)
	    {
        UnInitMap();
	    return E_FAIL;
	    }

	if (fNew)
	    memset(m_pMemory, 0, dwSize);
	    
	return S_OK;
    }

inline HRESULT CSharedMemBlock::UnInitMap()
    {
   	if (m_pMemory) 
   	    {
		UnmapViewOfFile(m_pMemory);
		m_pMemory = NULL;
		}
	if (m_hMemory) 
	    {
		CloseHandle(m_hMemory);
		m_hMemory = NULL;
    	}
    return S_OK;
  	}

/*===================================================================
CPerfProcBlock - class representing pref data for a single process
===================================================================*/

class CPerfProcBlock : public CSharedMemBlock
    {

friend class CPerfMainBlock;

protected:
    DWORD m_fInited : 1;
    DWORD m_fMemCSInited : 1;
    DWORD m_fReqCSInited : 1;

    // critical sections (only used in ASP.DLL)
    CRITICAL_SECTION m_csMemLock; // CS for memory counters
    CRITICAL_SECTION m_csReqLock; // CS for per-request counters

    // block of counters
    CPerfProcBlockData *m_pData;
    
    // next process data (used in ASPPERF.DLL)
    CPerfProcBlock *m_pNext;

    // access shared memory
    HRESULT MapMemory(const CLSID &ClsId);

public:
    inline CPerfProcBlock() 
        : m_fInited(FALSE),
          m_fMemCSInited(FALSE), m_fReqCSInited(FALSE),
          m_pData(NULL), m_pNext(NULL) 
        {}
        
    inline ~CPerfProcBlock() { UnInit(); }

    HRESULT InitCriticalSections();
    
    HRESULT InitExternal(const CLSID &ClsId);  // from ASPPERF.DLL
    
    HRESULT InitForThisProcess                 // from ASP.DLL
        (
        const CLSID &ClsId,
        DWORD *pdwInitCounters = NULL
        );

    HRESULT UnInit();
    };

inline HRESULT CPerfProcBlock::MapMemory
(
const CLSID &ClsId
)
    {
    // Construct unique map name with CLSID
    char szMapName[CCH_PERF_PROC_FILEMAP_PREFIX+32+1];
    strcpy(szMapName, SZ_PERF_PROC_FILEMAP_PREFIX);
    
    char  *pszHex = szMapName + CCH_PERF_PROC_FILEMAP_PREFIX;
    DWORD *pdwHex = (DWORD *)&ClsId;
    for (int i = 0; i < 4; i++, pszHex += 8, pdwHex++)
        sprintf(pszHex, "%08x", *pdwHex);

    // create or open the map
    HRESULT hr = InitMap(szMapName, CB_PERF_PROC_BLOCK);
    
    if (SUCCEEDED(hr))
        {
        m_pData = (CPerfProcBlockData *)PMemory();

        if (m_pData->m_ClsId == CLSID_NULL)
            m_pData->m_ClsId = ClsId;
        else if (m_pData->m_ClsId != ClsId)
            hr = E_FAIL; // cls id mismatch
        }
        
    return hr;
    }

inline HRESULT CPerfProcBlock::InitCriticalSections()
    {
    HRESULT hr = S_OK;
    
    if (!m_fMemCSInited)
        {
		__try { INITIALIZE_CRITICAL_SECTION(&m_csMemLock); }
		__except(1) { hr = E_UNEXPECTED; }
		if (SUCCEEDED(hr))
		    m_fMemCSInited = TRUE;
		else
		    return hr;
        }
        
    if (!m_fReqCSInited)
        {
		__try { INITIALIZE_CRITICAL_SECTION(&m_csReqLock); }
		__except(1) { hr = E_UNEXPECTED; }
		if (SUCCEEDED(hr))
		    m_fReqCSInited = TRUE;
		else
		    return hr;
        }

    return S_OK;
    }

inline HRESULT CPerfProcBlock::InitExternal
(
const CLSID &ClsId
)
    {
    HRESULT hr = MapMemory(ClsId);
	if (SUCCEEDED(hr))
	    m_fInited = TRUE;
	else
	    UnInit();
    return hr;
    }

inline HRESULT CPerfProcBlock::InitForThisProcess
(
const CLSID &ClsId,
DWORD *pdwInitCounters
)
    {
	HRESULT hr = S_OK;

    // Map the shared memory
	if (SUCCEEDED(hr))
        hr = MapMemory(ClsId);

	if (SUCCEEDED(hr))
	    {
        // init the counters
	    if (pdwInitCounters)
	        memcpy(m_pData->m_rgdwCounters, pdwInitCounters, CB_COUNTERS);
        else
        	memset(m_pData->m_rgdwCounters, 0, CB_COUNTERS);
        	
	    m_fInited = TRUE;
      	}
    else
        {
	    UnInit();
	    }
	    
    return hr;
    }

inline HRESULT CPerfProcBlock::UnInit()
    {
    if (m_fMemCSInited)
        {
    	DeleteCriticalSection(&m_csMemLock);
    	m_fMemCSInited = FALSE;
    	}
	if (m_fReqCSInited)
	    {
	    DeleteCriticalSection(&m_csReqLock);
	    m_fReqCSInited = FALSE;
	    }

    UnInitMap();
    
    m_pData = NULL;
    m_pNext = NULL;		    
    m_fInited = FALSE;
    return S_OK;
    }

/*===================================================================
CPerfMainBlock - class representing the main perf data
===================================================================*/

class CPerfMainBlock : public CSharedMemBlock
    {
private:
    DWORD m_fInited : 1;

    // the process block directory
    CPerfMainBlockData *m_pData;

    // mutex to access the process block directory
    HANDLE m_hMutex;

    // first process data (used in ASPPERF.DLL)
    CPerfProcBlock *m_pProcBlock;

    // timestamp of main block when the list of process blocks
    // last loaded -- to make decide to reload (ASPPREF.DLL only)
    DWORD m_dwTimestamp;

public:
    inline CPerfMainBlock() 
        : m_fInited(FALSE),
          m_pData(NULL), m_hMutex(NULL), 
          m_pProcBlock(NULL), m_dwTimestamp(NULL)
        {}
        
    inline ~CPerfMainBlock() { UnInit(); }

    HRESULT Init();
    HRESULT UnInit();

    // lock / unlock using mutex
    HRESULT Lock();
    HRESULT UnLock();

    // add/remove process record to the main block (used from ASP.DLL)
    HRESULT AddProcess(const CLSID &ClsId);
    HRESULT RemoveProcess(const CLSID &ClsId);

    // load CPerfProcBlock blocks from the main block into
    // objects (used from APPPREF.DLL)
    HRESULT Load();

    // gather (sum-up) the statistics from each proc block
    HRESULT GetStats(DWORD *pdwCounters);
    };

inline HRESULT CPerfMainBlock::Init()
    {
    HRESULT hr = S_OK;

    if (FAILED(hr = InitSD())) {
        return hr;
    }
    
    m_hMutex = OpenMutexA(MUTEX_ALL_ACCESS, FALSE, SZ_PERF_MUTEX);
    if (!m_hMutex)
        {
    
        m_hMutex = CreateMutexA(&m_sa, FALSE, SZ_PERF_MUTEX);

        }
        
    if (!m_hMutex)
        hr = E_FAIL;

	if (SUCCEEDED(hr))
	    {
        hr = InitMap(SZ_PERF_MAIN_FILEMAP, CB_PERF_MAIN_BLOCK);
    	if (SUCCEEDED(hr))
    	    m_pData = (CPerfMainBlockData *)PMemory();
        }

	if (SUCCEEDED(hr))
	    m_fInited = TRUE;
	else
	    UnInit();
    return hr;
    }

inline HRESULT CPerfMainBlock::UnInit()
    {
    while (m_pProcBlock)
        {
        CPerfProcBlock *pNext = m_pProcBlock->m_pNext;
        m_pProcBlock->UnInit();
        delete m_pProcBlock;
        m_pProcBlock = pNext;
        }
        
    if (m_hMutex)
        {
        CloseHandle(m_hMutex);
        m_hMutex = NULL;
        }
    
    UnInitMap();

    m_dwTimestamp = 0;
    m_pData = NULL;
    m_pProcBlock = NULL;
    m_fInited = FALSE;
    return S_OK;
    }

inline HRESULT CPerfMainBlock::Lock()
    {
    if (!m_hMutex)
        return E_FAIL;
    if (WaitForSingleObject(m_hMutex, PERM_MUTEX_WAIT) == WAIT_TIMEOUT)
        return E_FAIL;
    return S_OK;
    }
    
inline HRESULT CPerfMainBlock::UnLock()
    {
    if (m_hMutex)
        ReleaseMutex(m_hMutex);
    return S_OK;
    }

inline HRESULT CPerfMainBlock::AddProcess
(
const CLSID &ClsId
)
    {
    if (!m_fInited)
        return E_FAIL;

    if (FAILED(Lock()))  // lock mutex
        return E_FAIL;
    HRESULT hr = S_OK;

    BOOL fFound = FALSE;
    // find
    for (DWORD i = 0; i < m_pData->m_cItems; i++)
        {
        if (m_pData->m_rgClsIds[i] == ClsId)
            {
            fFound = TRUE;
            break;
            }
        }

    // add only if not already there
    if (!fFound)
        {
        if (m_pData->m_cItems < C_PERF_PROC_MAX)
            {
            m_pData->m_rgClsIds[m_pData->m_cItems] = ClsId;
            m_pData->m_cItems++;
            m_pData->m_dwTimestamp = GetTickCount();
            }
        else
            {
            hr = E_OUTOFMEMORY;
            }
        }

    UnLock();   // unlock mutex
    return hr;
    }

inline HRESULT CPerfMainBlock::RemoveProcess
(
const CLSID &ClsId
)
    {
    if (!m_fInited)
        return E_FAIL;

    if (FAILED(Lock()))  // lock mutex
        return E_FAIL;
    HRESULT hr = S_OK;

    int iFound = -1;
    // find
    for (DWORD i = 0; i < m_pData->m_cItems; i++)
        {
        if (m_pData->m_rgClsIds[i] == ClsId)
            {
            iFound = i;
            break;
            }
        }

    // remove
    if (iFound >= 0)
        {
        for (i = iFound; i < m_pData->m_cItems-1; i++)
            m_pData->m_rgClsIds[i] = m_pData->m_rgClsIds[i+1];
            
        m_pData->m_cItems--;
        m_pData->m_dwTimestamp = GetTickCount();
        }

    UnLock();   // unlock mutex
    return hr;
    }
    
inline HRESULT CPerfMainBlock::Load()
    {
    if (!m_fInited)
        return E_FAIL;

    if (m_dwTimestamp == m_pData->m_dwTimestamp)
        return S_OK; // already up-to-date

    // clear out what we have
    while (m_pProcBlock)
        {
        CPerfProcBlock *pNext = m_pProcBlock->m_pNext;
        m_pProcBlock->UnInit();
        delete m_pProcBlock;
        m_pProcBlock = pNext;
        }
        
    if (FAILED(Lock())) // lock mutex
        return E_FAIL;
    HRESULT hr = S_OK;

    // populate new objects for blocks
    for (DWORD i = 0; i < m_pData->m_cItems; i++)
        {
        CPerfProcBlock *pBlock = new CPerfProcBlock;
        if (!pBlock)
            {
            hr = E_OUTOFMEMORY;
            break;
            }
        
        hr = pBlock->InitExternal(m_pData->m_rgClsIds[i]);
        if (FAILED(hr))
            {
            delete pBlock;
            continue;
            }

        pBlock->m_pNext = m_pProcBlock;
        m_pProcBlock = pBlock;
        }

    // remember timestamp
    m_dwTimestamp = SUCCEEDED(hr) ? m_pData->m_dwTimestamp : 0;

    UnLock();   // unlock mutex
    return hr;
    }

inline HRESULT CPerfMainBlock::GetStats
(
DWORD *pdwCounters
)
    {
    if (!m_fInited)
        return E_FAIL;

    // reload if needed
    if (FAILED(Load()))
        return E_FAIL;

    // init
    memset(pdwCounters, 0, CB_COUNTERS);

    // gather
    CPerfProcBlock *pBlock = m_pProcBlock;
    while (pBlock)
        {
        for (int i = 0; i < C_PERF_PROC_COUNTERS; i++)
            pdwCounters[i] += pBlock->m_pData->m_rgdwCounters[i];
        pBlock = pBlock->m_pNext;
        }
        
    return S_OK;
    }

#endif // _ASP_PERFDEF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\randgen.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Random number generator

File: randgen.cpp

Owner: DmitryR

This file contains the implementation of the random number
generator.
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "randgen.h"
#include "memchk.h"

/*===================================================================
  Random DWORD using rand()
===================================================================*/
#define RAND_DWORD()  (((rand() & 0xffff) << 16) | (rand() & 0xffff))

/*===================================================================
  Random number generator class
===================================================================*/
class CRandomGenerator
    {
private:
    DWORD m_fInited   : 1;  // inited?
    DWORD m_fCSInited : 1;  // critical section inited?

    HCRYPTPROV        m_hCryptProvider;     // crypt provider
    CRITICAL_SECTION  m_csLock;             // critical section

    DWORD m_cItems;     // number of items in the array
    DWORD *m_pdwItems;  // pointer to the array of random DWORDs
    DWORD m_iItem;      // next random item index

public:
    CRandomGenerator()
        :
        m_fInited(FALSE),
        m_fCSInited(FALSE),
        m_hCryptProvider(NULL),
        m_cItems(0),
        m_pdwItems(NULL),
        m_iItem(0)
        {
        }
        
    ~CRandomGenerator()
        {
        UnInit();
        }

    HRESULT Init(DWORD cItems = 128)
        {
        Assert(!m_fInited);
        
        m_hCryptProvider = NULL;
        
        if (cItems > 0 &&   gGlob.fWinNT())
            {
            CryptAcquireContext
                (
                &m_hCryptProvider, 
                NULL,
                NULL, 
                PROV_RSA_FULL, 
                CRYPT_VERIFYCONTEXT
                );
            }

        if (!m_hCryptProvider)
            {
                return HRESULT_FROM_WIN32(GetLastError());
            }

        HRESULT hr;
        ErrInitCriticalSection(&m_csLock, hr);
      	if (FAILED(hr))
      	    return hr;
      	m_fCSInited = TRUE;

      	m_pdwItems = new DWORD[cItems];
      	if (!m_pdwItems)
      	    return E_OUTOFMEMORY;
      	m_cItems = cItems;
      	m_iItem  = cItems;  // to start with new chunk

        m_fInited = TRUE;
        return S_OK;
        }

    HRESULT UnInit()
        {
        if (m_hCryptProvider)
            {
            CryptReleaseContext(m_hCryptProvider, 0);
            m_hCryptProvider = NULL;
            }

        if (m_fCSInited)
            {
     		DeleteCriticalSection(&m_csLock);
            m_fCSInited = FALSE;
            }
        
        if (m_pdwItems)
            {
            delete [] m_pdwItems;
            m_pdwItems = NULL;
            }
        m_cItems = 0;
        m_iItem = 0;

        m_fInited = FALSE;
        return S_OK;
        }

    HRESULT Generate(DWORD *pdwDwords, DWORD cDwords)
        {
        Assert(pdwDwords);
        Assert(cDwords > 0);
        
        Assert(m_fInited);

        DWORD i;
        
        // use CryptGenRandom

        Assert(cDwords <= m_cItems); // requested # of items < m_cItems
        Assert(m_fCSInited);
            
        EnterCriticalSection(&m_csLock);

        if (m_iItem+cDwords-1 >= m_cItems)
            {
            
            BOOL fSucceeded = CryptGenRandom
                (
                m_hCryptProvider, 
                m_cItems * sizeof(DWORD),
                reinterpret_cast<BYTE *>(m_pdwItems)
                );

            if (!fSucceeded)
                {
                // Failed -> use rand()
                // Dont use rand() instead throw an error.
                return HRESULT_FROM_WIN32(GetLastError());
                }

            m_iItem = 0; // start over
            }

        for (i = 0; i < cDwords; i++)
            pdwDwords[i] = m_pdwItems[m_iItem++];
        
        LeaveCriticalSection(&m_csLock);

        return S_OK;
        }
    };

// Pointer to the sole instance of the above
static CRandomGenerator *gs_pRandomGenerator = NULL;

/*===================================================================
  E x t e r n a l  A P I
===================================================================*/

/*===================================================================
InitRandGenerator

To be called from DllInit()

Parameters

Returns:
    HRESULT
===================================================================*/
HRESULT InitRandGenerator()
    {
    gs_pRandomGenerator = new CRandomGenerator;
    if (!gs_pRandomGenerator)
        return E_OUTOFMEMORY;

    return gs_pRandomGenerator->Init();
    }

/*===================================================================
UnInitRandGenerator

To be called from DllUnInit()

Parameters

Returns:
    HRESULT
===================================================================*/
HRESULT UnInitRandGenerator()
    {
    if (gs_pRandomGenerator)
        {
        gs_pRandomGenerator->UnInit();
        delete gs_pRandomGenerator;
        }
    return S_OK;
    }

/*===================================================================
GenerateRandomDword

Returns random DWORD

Parameters

Returns:
    Random number
===================================================================*/
DWORD GenerateRandomDword()
    {
    DWORD dw;
    Assert(gs_pRandomGenerator);
    gs_pRandomGenerator->Generate(&dw, 1);
    return dw;
    }

/*===================================================================
GenerateRandomDwords

Returns random DWORDs

Parameters
    pdwDwords     array of DWORDs to fill
    cDwords       # of DWORDs

Returns:
    Random number
===================================================================*/
HRESULT GenerateRandomDwords
(
DWORD *pdwDwords, 
DWORD  cDwords
)
    {
    Assert(gs_pRandomGenerator);
    return gs_pRandomGenerator->Generate(pdwDwords, cDwords);
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\request.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Request object

File: Request.h

Owner: CGrant, DGottner

This file contains the header info for defining the Request object.
Note: This was largely stolen from Kraig Brocjschmidt's Inside OLE2
second edition, chapter 14 Beeper v5.
===================================================================*/

#ifndef _Request_H
#define _Request_H

#include "debug.h"
#include "util.h"
#include "hashing.h"
#include "dispatch.h"
#include "strlist.h"
#include "asptlb.h"
#include "response.h"
#include "memcls.h" 
#include "ftm.h"

#ifdef USE_LOCALE
extern DWORD	 g_dwTLS;
#endif

class CCookie;
class CClCert;
class CRequestHit;
class CServVarsIterator;

// Type for an object-destroyed callback
typedef void (*PFNDESTROYED)(void);

enum CollectionType {NONE, SERVERVARIABLE, QUERYSTRING, FORM, COOKIE, CLCERT };
enum FormDataStatus {AVAILABLE, BINARYREADONLY, FORMCOLLECTIONONLY, ISTREAMONLY};

class CRequest;

#define	NUM_REQUEST_HITS 32

/*
 * C R e q u e s t H i t s A r r a y
 *
 * Base class for:
 *      CQueryString
 *      CFormInputs
 *      CCookies
 *      CClCerts
 *
 * Implements self-reallocating array of CRequestHit 
 */

class CRequestHitsArray
    {
protected:    
	DWORD			m_dwCount;			// How many Request hits there are
	DWORD			m_dwHitMax;			// Number of slots available to store Request hits
	CRequestHit**	m_rgRequestHit;		// Array of Request hits

    CRequestHitsArray();
    ~CRequestHitsArray();

    inline HRESULT Init()
        {
        m_dwCount = 0;
        m_dwHitMax = 0;
        m_rgRequestHit = NULL;
        return S_OK;
        }
        
    inline HRESULT ReInit() 
        {
        m_dwCount = 0; 
        return S_OK;
        }

public:
	BOOL AddRequestHit(CRequestHit *pHit);
	
    };

/*
 * C Q u e r y S t r i n g
 *
 * Implements the QueryString object (interface derived from IRequestDictionary)
 */

class CQueryString : public IRequestDictionaryImpl, public CRequestHitsArray
	{
private:
    IUnknown *          m_punkOuter;        // object to do ref count
	CRequest *			m_pRequest;			// pointer to parent object
	CSupportErrorInfo	m_ISupportErrImp;	// implementation of ISupportErr

public:
	CQueryString(CRequest *, IUnknown *);

	// The Big Three

	STDMETHODIMP			QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	// OLE Automation Interface

	STDMETHODIMP	get_Item(VARIANT varKey, VARIANT *pvarReturn);
	STDMETHODIMP	get__NewEnum(IUnknown **ppEnumReturn);
	STDMETHODIMP	get_Count(int *pcValues);
	STDMETHODIMP	get_Key(VARIANT VarKey, VARIANT *pvar);

	HRESULT			Init();
	HRESULT         ReInit();

	~CQueryString();
	};
 


/*
 * C S e r v e r V a r i a b l e s
 *
 * Implements the ServerVariables object (interface derived from IRequestDictionary)
 */

class CServerVariables : public IRequestDictionaryImpl
	{
private:
    IUnknown *          m_punkOuter;        // object to do ref count
	CRequest *			m_pRequest;			// pointer to parent object
	CSupportErrorInfo	m_ISupportErrImp;	// implementation of ISupportErr
	CServVarsIterator *	m_pIterator;		// we use an iterator to support integer index

public:
	CServerVariables(CRequest *, IUnknown *);
	HRESULT Init()
		{
		return S_OK;
		}

	// The Big Three

	STDMETHODIMP			QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	// OLE Automation Interface

	STDMETHODIMP	get_Item(VARIANT Var, VARIANT *pVariantReturn);
	STDMETHODIMP	get__NewEnum(IUnknown **ppEnumReturn);
	STDMETHODIMP	get_Count(int *pcValues);
	STDMETHODIMP	get_Key(VARIANT VarKey, VARIANT *pvar);

	// We've added a destructor, but didn't want to change the
	// order of the existing vtbl entries.
	~CServerVariables();
	};


/*
 * C F o r m I n p u t s
 *
 * Implements the Form object (interface derived from IRequestDictionary)
 */

class CFormInputs : public IRequestDictionaryImpl, public CRequestHitsArray
	{
private:
    IUnknown *          m_punkOuter;        // object to do ref count
	CRequest *			m_pRequest;			// pointer to parent object
	CSupportErrorInfo	m_ISupportErrImp;	// implementation of ISupportErr

public:
	CFormInputs(CRequest *, IUnknown *);
	HRESULT Init();
	HRESULT ReInit();

	// The Big Three

	STDMETHODIMP			QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	// OLE Automation Interface

	STDMETHODIMP	get_Item(VARIANT Var, VARIANT *pVariantReturn);
	STDMETHODIMP	get__NewEnum(IUnknown **ppEnumReturn);
	STDMETHODIMP	get_Count(int *pcValues);
	STDMETHODIMP	get_Key(VARIANT VarKey, VARIANT *pvar);

	~CFormInputs();
	};
 

/*
 * C C o o k i e s
 *
 * Implements the Cookies object (interface derived from IRequestDictionary)
 */

class CCookies : public IRequestDictionaryImpl, public CRequestHitsArray
	{
friend CResponseCookies;
	
private:
    IUnknown *          m_punkOuter;        // object to do ref count
	CRequest *			m_pRequest;			// pointer to parent object
	CSupportErrorInfo	m_ISupportErrImp;	// implementation of ISupportErr
	CCookie *			m_pEmptyCookie;		// for when the cookie is not there

public:
	CCookies(CRequest *, IUnknown *);
	~CCookies();
	HRESULT Init();
	HRESULT ReInit();
		
	// The Big Three

	STDMETHODIMP			QueryInterface(const GUID &, void **);
   	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	// OLE Automation Interface

	STDMETHODIMP	get_Item(VARIANT Var, VARIANT *pVariantReturn);
	STDMETHODIMP	get__NewEnum(IUnknown **ppEnumReturn);
	STDMETHODIMP	get_Count(int *pcValues);
	STDMETHODIMP	get_Key(VARIANT VarKey, VARIANT *pvar);
	};
 


/*
 * C C l C e r t s
 *
 * Implements the ClCerts object (interface derived from IRequestDictionary)
 */

class CClCerts : public IRequestDictionaryImpl, public CRequestHitsArray
	{
private:
    IUnknown *          m_punkOuter;        // object to do ref count
	CRequest *			m_pRequest;			// pointer to parent object
	CSupportErrorInfo	m_ISupportErrImp;	// implementation of ISupportErr
	CClCert *			m_pEmptyClCert;		// for when the clcert is not there

public:
	CClCerts(CRequest *, IUnknown *);
	~CClCerts();
	HRESULT Init();
	HRESULT ReInit();
		
	// The Big Three

	STDMETHODIMP			QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	// OLE Automation Interface

	STDMETHODIMP	get_Item(VARIANT Var, VARIANT *pVariantReturn);
	STDMETHODIMP	get__NewEnum(IUnknown **ppEnumReturn);
	STDMETHODIMP	get_Count(int *pcValues);
	STDMETHODIMP	get_Key(VARIANT VarKey, VARIANT *pvar);
	};


/*
 * C R e q u e s t H i t
 *
 * Implements the RequestHit object
 */

class CRequestHit : private CLinkElem
	{
friend class CRequest;
friend class CRequestData;
friend class CQueryString;
friend class CFormInputs;
friend class CCookies;
friend class CClCerts;
friend class CCertRequest;
friend class CResponseCookies;
friend class CRequestIterator;

private:
	BOOL			m_fInited:1;
	BOOL			m_fDuplicate:1;
	CStringList		*m_pQueryData, *m_pFormData;
	CCookie			*m_pCookieData;
	CClCert			*m_pClCertData;

public:
	CRequestHit();
	~CRequestHit();

	HRESULT Init(char *szName, BOOL fDuplicate = FALSE);
	HRESULT AddValue(CollectionType source, char *szValue, CIsapiReqInfo *, UINT lCodePage);
    HRESULT AddCertValue(VARENUM ve, LPBYTE pValue, UINT cLen );
	HRESULT AddKeyAndValue(CollectionType source, char *szKey, char *szValue, CIsapiReqInfo *, UINT lCodePage);

	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};

/*
 * C R e q u e s t D a t a
 *
 * Structure that holds the intrinsic's properties.
 * The instrinsic keeps pointer to it (NULL when lightweight)
 */
class CRequestData : public IUnknown
    {
friend class CRequest;
friend class CResponse;
friend class CQueryString;
friend class CServerVariables;
friend class CFormInputs;
friend class CCookies;
friend class CClCerts;
friend class CResponseCookies;
friend class CRequestIterator;
friend class CCertRequest;

private:
    // constructor to pass params to members and init members
    CRequestData(CRequest *pRequest);
    ~CRequestData();

    HRESULT Init();
	HRESULT	ReInit(CIsapiReqInfo *pIReq, CHitObj *pHitObj);

	HRESULT GetEmptyStringList(IDispatch **ppdisp);
    
	CSupportErrorInfo		m_ISupportErrImp;	// Implementation of ISupportErrorInfo for this object
	CIsapiReqInfo *         m_pIReq;			    // CIsapiReqInfo block for HTTP info
	CHitObj	*				m_pHitObj;			// pointer to hitobj for this request
	CHashTableMBStr			m_mpszStrings;		// map sz's to string lists
	BOOL					m_fLoadForm:1;		// do we need to load the body?
	BOOL					m_fLoadQuery:1;		// do we need to load QueryString?
	BOOL					m_fLoadCookies:1;	// do we need to load Cookies?
	BOOL					m_fLoadClCerts:1;	// do we need to load ClCerts?
	FormDataStatus			m_FormDataStatus;	// Is form data available for BinaryRead or Form Collection?
	BYTE *					m_pbAvailableData;	// pointer to available data in CIsapiReqInfo
	size_t					m_cbAvailable;		// number of bytes available in CIsapiReqInfo
	size_t					m_cbTotal;			// Total number of bytes remaining in request
	char *					m_szFormData;		// pointer to form data (allocted or CIsapiReqInfo)
	size_t					m_cbFormData;		// number of bytes allocated for form data
	char *					m_szFormClone;		// clone of form data (LoadVariables clobbers)
	char *					m_szCookie;			// clone of cookie data (this one gets trashed)
	size_t					m_cbCookie;			// number of bytes allocated for the cookie data
	char *					m_szClCert;			// clone of clcert data (this one gets trashed)
	size_t					m_cbClCert;			// number of bytes allocated for the clcert data
    char *                  m_szQueryString;    // query string data
	CStringList *			m_pEmptyString;		// all empty results share the same object
	CQueryString			m_QueryString;		// pointer to the "QueryString" object
	CServerVariables		m_ServerVariables;	// pointer to the "ServerVariables" object
	CFormInputs				m_FormInputs;		// pointer to the "Form" object
	CCookies				m_Cookies;			// pointer to the "Cookies" object
	CClCerts    			m_ClCerts;			// pointer to the "ClCert" object
	ULONG                   m_cRefs;            // ref count

public:
	STDMETHODIMP			QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };

/*
 * C R e q u e s t
 *
 * Implements the Request object
 */
class CRequest : public IRequestImpl, public CFTMImplementation, public IStream
	{
friend class CQueryString;
friend class CServerVariables;
friend class CFormInputs;
friend class CCookies;
friend class CClCerts;
friend class CResponseCookies;
friend class CRequestIterator;
friend class CCertRequest;

private:
    // Flags
	DWORD m_fInited : 1;	    // Is initialized?
	DWORD m_fDiagnostics : 1;   // Display ref count in debug output
	DWORD m_fOuterUnknown : 1;  // Ref count outer unknown?

    // Ref count / Outer unknown
    union
    {
    DWORD m_cRefs;
    IUnknown *m_punkOuter;
    };

    // Properties
    CRequestData *m_pData;   // pointer to structure that holds
                             // CRequest properties

    UINT GetCodePage();

	HRESULT LoadVariables(CollectionType Source, char *szURL, UINT lCodePage);
	HRESULT LoadCookies(char *szCookies);
	HRESULT LoadClCerts(char *szClCerts, UINT lCodePage);

	HRESULT LoadCertList( LPSTR pszPrefix, LPSTR* pszCertList);
	HRESULT CopyClientData();
    HRESULT GetRequestEnumerator(CollectionType, IUnknown **ppEnumReturn);

    // Added support for chunked Transfer in Request.form  
    HRESULT CopyChunkedClientData();
    HRESULT CopyNonChunkedClientData();	    

#ifdef DBG
    inline void TurnDiagsOn()  { m_fDiagnostics = TRUE; }
    inline void TurnDiagsOff() { m_fDiagnostics = FALSE; }
    void AssertValid() const;
#else
    inline void TurnDiagsOn()  {}
    inline void TurnDiagsOff() {}
    inline void AssertValid() const {}
#endif

public:
	CRequest(IUnknown *punkOuter = NULL);
	~CRequest();

    HRESULT CleanUp();
    HRESULT Init();
    HRESULT UnInit();
	
	HRESULT	ReInit(CIsapiReqInfo *pIReq, CHitObj *pHitObj);
	
    inline CIsapiReqInfo *GetIReq()
        {
        Assert(m_fInited);
        Assert(m_pData);
        return m_pData->m_pIReq;
        }
        
    inline CLinkElem* CertStoreFindElem(LPSTR pV, int cV)
        {
        Assert(m_fInited);
        Assert(m_pData);
        return m_pData->m_mpszStrings.FindElem( pV, cV );
        }
        
    inline CLinkElem* CertStoreAddElem(CLinkElem* pH)
        {
        Assert(m_fInited);
        Assert(m_pData);
        return m_pData->m_mpszStrings.AddElem( pH ); 
        }
        
    inline LPSTR GetCertStoreBuf()
        {
        Assert(m_fInited);
        Assert(m_pData);
        return m_pData->m_szClCert; 
        }
        
    inline size_t GetCertStoreSize()
        {
        Assert(m_fInited);
        Assert(m_pData);
        return m_pData->m_cbClCert; 
        }
        
    inline void SetCertStore(LPSTR p, size_t s)
        {
        Assert(m_fInited);
        Assert(m_pData);
        m_pData->m_szClCert = p;
        m_pData->m_cbClCert = s;
        }

    inline CHashTable *GetStrings()
        {
        Assert(m_fInited);
        Assert(m_pData);
        return &(m_pData->m_mpszStrings);
        }

	// Non-delegating object IUnknown
	//
	STDMETHODIMP		 QueryInterface(const IID &Iid, void **ppvObj);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

    // Tombstone stub
	HRESULT CheckForTombstone();
	
	// IRequest functions
	//
	STDMETHODIMP	get_Item(BSTR bstrVar, IDispatch **ppDispReturn);
	STDMETHODIMP	get_QueryString(IRequestDictionary **ppDictReturn);
	STDMETHODIMP	get_Form(IRequestDictionary **ppDictReturn);
	STDMETHODIMP	get_Body(IRequestDictionary **ppDictReturn);
	STDMETHODIMP	get_ServerVariables(IRequestDictionary **ppDictReturn);
	STDMETHODIMP	get_ClientCertificate(IRequestDictionary **ppDictReturn);
	STDMETHODIMP	get_Cookies(IRequestDictionary **ppDictReturn);
	STDMETHODIMP	get_TotalBytes(long *pcbTotal);
	STDMETHODIMP	BinaryRead(VARIANT *pvarCount, VARIANT *pvarReturn);

    // IStream implementation

    STDMETHODIMP Read(void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHODIMP Write(const void *pv, ULONG cb, ULONG *pcbWritten);
    STDMETHODIMP Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin,
                      ULARGE_INTEGER *plibNewPosition);
    STDMETHODIMP SetSize(ULARGE_INTEGER libNewSize);
    STDMETHODIMP CopyTo(IStream *pstm, ULARGE_INTEGER cb,
                        ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
    STDMETHODIMP Commit(DWORD grfCommitFlags);
    STDMETHODIMP Revert();
    STDMETHODIMP LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,
                            DWORD dwLockType);
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,
                              DWORD dwLockType);
    STDMETHODIMP Stat(STATSTG *pstatstg, DWORD grfStatFlag);
    STDMETHODIMP Clone(IStream **ppstm);

	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};

/*===================================================================
ITERATORS:

There are two iterators used for Request - a general purpose
iterator which will iterate through the keys of Cookies, QueryString,
Form.  A special iterator is used for ServerVariables
===================================================================*/

/*
 * C S e r v V a r s I t e r a t o r
 *
 * IEnumVariant implementation for Request.ServerVariables
 */

class CServVarsIterator : public IEnumVARIANT
	{
friend CServerVariables;
	
public:
	CServVarsIterator();
	~CServVarsIterator();

	HRESULT Init(CIsapiReqInfo *pIReq);


	// The Big Three

	STDMETHODIMP			QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	// standard methods for iterators

	STDMETHODIMP	Clone(IEnumVARIANT **ppEnumReturn);
	STDMETHODIMP	Next(unsigned long cElements, VARIANT *rgVariant, unsigned long *pcElementsFetched);
	STDMETHODIMP	Skip(unsigned long cElements);
	STDMETHODIMP	Reset();

private:
	ULONG m_cRefs;					// reference count
	wchar_t **m_rgwszKeys;			// array of ISAPI keys
	wchar_t **m_pwszKey;			// current key in gm_rgwszKeys
	wchar_t *m_pwchAllHttp;			// extra keys in ALL_HTTP server variable
	ULONG	m_cKeys;				// total number of keys

	void CreateKeys(wchar_t *pwchKeys, int *pcwchAlloc, int *pcRequestHeaders);
	};


/*
 * C R e q u e s t I t e r a t o r
 *
 * IEnumVariant implementation for all Request collections except
 * ServerVariables
 */

class CRequestIterator : public IEnumVARIANT
	{
public:
	CRequestIterator(CRequest *, CollectionType);
	~CRequestIterator();

	HRESULT Init();

	// The Big Three

	STDMETHODIMP			QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	// standard methods for iterators

	STDMETHODIMP	Clone(IEnumVARIANT **ppEnumReturn);
	STDMETHODIMP	Next(unsigned long cElements, VARIANT *rgVariant, unsigned long *pcElementsFetched);
	STDMETHODIMP	Skip(unsigned long cElements);
	STDMETHODIMP	Reset();

private:
	ULONG m_cRefs;					// reference count
	CollectionType m_Collection;	// which collection to iterate over?
	CRequest *m_pRequest;			// pointer to the request object
	CRequestHit *m_pRequestHit;		// current bookmark for iteration
	};

BOOL RequestSupportInit();
VOID RequestSupportTerminate();

#endif //_Request_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\resource.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Resources

File: Resource.h

Owner: AndrewS

This file contains constants for all resources used by Denali

===================================================================*/


#define IDE_BEGIN					100

//
// General errors
//
#define IDE_GENERAL_BEGIN			100
#define IDE_OOM						IDE_GENERAL_BEGIN
#define IDE_UNEXPECTED				IDE_GENERAL_BEGIN + 1
#define IDE_EXPECTING_STR			IDE_GENERAL_BEGIN + 2
#define IDE_EXPECTING_INT			IDE_GENERAL_BEGIN + 3
#define IDE_NOT_ALLOWED				IDE_GENERAL_BEGIN + 4
#define IDE_BAD_ARRAY_INDEX			IDE_GENERAL_BEGIN + 5	
#define IDE_TYPE_MISMATCH			IDE_GENERAL_BEGIN + 6
#define IDE_STACK_OVERFLOW			IDE_GENERAL_BEGIN + 7
#define IDS_COUNINITIALIZE			IDE_GENERAL_BEGIN + 8
#define IDS_TRUE					IDE_GENERAL_BEGIN + 9
#define IDS_FALSE					IDE_GENERAL_BEGIN + 10
#define IDE_INTRINSIC_OUT_OF_SCOPE  IDE_GENERAL_BEGIN + 11
#define IDE_CANT_MOD_STATICOBJECTS  IDE_GENERAL_BEGIN + 12
#define IDE_TOOBIG					IDE_GENERAL_BEGIN + 13
#define IDS_CACHE_DIR_MISSING       IDE_GENERAL_BEGIN + 14
#define IDE_GENERAL_END				IDE_GENERAL_BEGIN + 14

#define IDS_REG_GENERAL_BEGIN		200
#define IDS_DEFAULTMSG_DENIED		IDS_REG_GENERAL_BEGIN + 1
#define IDS_DEFAULTMSG_ERROR		IDS_REG_GENERAL_BEGIN + 2
#define IDS_DEFAULTMSG_BUSY			IDS_REG_GENERAL_BEGIN + 3
#define IDS_SCRIPTLANGUAGE			IDS_REG_GENERAL_BEGIN + 4
#define IDS_IIS_NOTINSTALLED		IDS_REG_GENERAL_BEGIN + 5
#define IDS_DEFAULTPERSISTDIR       IDS_REG_GENERAL_BEGIN + 6
#define IDS_REG_GENERAL_END			IDS_REG_GENERAL_BEGIN + 6

#define IDS_BROWSER_TEMPLATE_BEGIN			300
#define IDS_BROWSER_TEMPLATE_ENGINE_BEGIN	IDS_BROWSER_TEMPLATE_BEGIN + 1
#define IDS_BROWSER_TEMPLATE_ENGINE_END		IDS_BROWSER_TEMPLATE_BEGIN + 2
#define IDS_BROWSER_TEMPLATE_ERROR_BEGIN	IDS_BROWSER_TEMPLATE_BEGIN + 3
#define IDS_BROWSER_TEMPLATE_ERROR_END		IDS_BROWSER_TEMPLATE_BEGIN + 4
#define IDS_BROWSER_TEMPLATE_SHORT_BEGIN	IDS_BROWSER_TEMPLATE_BEGIN + 5
#define IDS_BROWSER_TEMPLATE_SHORT_END		IDS_BROWSER_TEMPLATE_BEGIN + 6
#define IDS_BROWSER_TEMPLATE_FILE_BEGIN		IDS_BROWSER_TEMPLATE_BEGIN + 7
#define IDS_BROWSER_TEMPLATE_FILE_END		IDS_BROWSER_TEMPLATE_BEGIN + 8
#define IDS_BROWSER_TEMPLATE_LINE_BEGIN		IDS_BROWSER_TEMPLATE_BEGIN + 9
#define IDS_BROWSER_TEMPLATE_LINE_END		IDS_BROWSER_TEMPLATE_BEGIN + 10
#define IDS_BROWSER_TEMPLATE_CODE_BEGIN		IDS_BROWSER_TEMPLATE_BEGIN + 11
#define IDS_BROWSER_TEMPLATE_CODE_END		IDS_BROWSER_TEMPLATE_BEGIN + 12
#define IDS_BROWSER_TEMPLATE_LONG_BEGIN		IDS_BROWSER_TEMPLATE_BEGIN + 13
#define IDS_BROWSER_TEMPLATE_LONG_END		IDS_BROWSER_TEMPLATE_BEGIN + 14
#define IDS_BROWSER_TEMPLATE_END			IDS_BROWSER_TEMPLATE_BEGIN + 15

#define IDS_ERROR_HANDLINGSTRING	400
#define IDS_DEBUG_APP				IDS_ERROR_HANDLINGSTRING + 1
#define IDS_LOG_IISLOGFAILED		IDS_ERROR_HANDLINGSTRING + 2
#define	IDS_COMPILER				IDS_ERROR_HANDLINGSTRING + 3
#define IDS_ENGINE					IDS_ERROR_HANDLINGSTRING + 4
#define IDS_LOGTOEVENTLOG_FILE		IDS_ERROR_HANDLINGSTRING + 5
#define	IDS_LOGTOEVENTLOG_LINE		IDS_ERROR_HANDLINGSTRING + 6
#define IDS_MDOORANGE_FORMAT		IDS_ERROR_HANDLINGSTRING + 7
#define IDS_IISLOG_PREFIX			IDS_ERROR_HANDLINGSTRING + 8
#define IDS_RE_REGSVR_ASP			IDS_ERROR_HANDLINGSTRING + 9
#define IDS_SCRIPT_ERROR			IDS_ERROR_HANDLINGSTRING + 10
#define IDS_DEBUGGER_TEMPLATE_BEGIN	IDS_ERROR_HANDLINGSTRING + 11
#define IDS_DEBUGGER_TEMPLATE_END	IDS_ERROR_HANDLINGSTRING + 12
#define IDS_DEBUGGING_DISABLED		IDS_ERROR_HANDLINGSTRING + 13

//Header strings
#define IDH_HEADER_BEGIN			500
#define IDH_204_NO_CONTENT			IDH_HEADER_BEGIN + 1
#define IDH_403_FORBIDDEN           IDH_HEADER_BEGIN + 2
#define IDH_404_OBJECT_NOT_FOUND	IDH_HEADER_BEGIN + 3
#define IDH_500_SERVER_ERROR		IDH_HEADER_BEGIN + 4
#define IDH_401_3_ACCESS_DENIED     IDH_HEADER_BEGIN + 5
#define IDH_HEADER_END				IDH_HEADER_BEGIN + 6

//Encrypted ASP printable file header
#define IDS_EASP_PRINTABLE_HEADER   601

// Errors previously hardcoded in hitobj.h

// 
// Script Engine/Manager errors
//
#define IDE_SCRIPT_BEGIN			1000
#define	IDE_SCRIPT_CANT_LOAD_OBJ	IDE_SCRIPT_BEGIN+0
#define	IDE_SCRIPT_GENERIC_PREFIX	IDE_SCRIPT_BEGIN+1
#define	IDE_SCRIPT_LINE_NUMBER		IDE_SCRIPT_BEGIN+2
#define	IDE_SCRIPT_FILE_PATH_INFO	IDE_SCRIPT_BEGIN+3
#define	IDE_SCRIPT_METHOD_NOT_FOUND	IDE_SCRIPT_BEGIN+4
#define	IDE_SCRIPT_UNKNOWN_NAME		IDE_SCRIPT_BEGIN+5
#define	IDE_SCRIPT_UNKNOWN_INTERFACE IDE_SCRIPT_BEGIN+6
#define	IDE_SCRIPT_MISSING_PARAMETER IDE_SCRIPT_BEGIN+7
#define	IDE_SCRIPT_TIMEOUT			IDE_SCRIPT_BEGIN+8
#define IDE_SCRIPT_BAD_SCOPE_MODEL	IDE_SCRIPT_BEGIN+9
#define IDE_SCRIPT_GPF				IDE_SCRIPT_BEGIN+10
#define IDE_SCRIPT_UNKNOWN			IDE_SCRIPT_BEGIN+11
#define IDE_SCRIPT_ENGINE_GPF       IDE_SCRIPT_BEGIN+12
#define IDE_SCRIPT_OBJ_INSTANTIATE_FAILED	IDE_SCRIPT_BEGIN+13
#define IDE_SCRIPT_OBJ_ONPAGE_QI_FAILED		IDE_SCRIPT_BEGIN+14   
#define IDE_SCRIPT_END				IDE_SCRIPT_BEGIN+15

// 
// CTemplate errors
//
#define IDE_TEMPLATE_BEGIN						2000
#define IDE_TEMPLATE_ERRMSG_TITLE				IDE_TEMPLATE_BEGIN
#define IDE_TEMPLATE_ERRMSG_PREFIX				IDE_TEMPLATE_BEGIN + 1
#define IDE_TEMPLATE_NO_CLOSE_PSCRIPT			IDE_TEMPLATE_BEGIN + 2
#define IDE_TEMPLATE_NO_CLOSE_TSCRIPT			IDE_TEMPLATE_BEGIN + 3
#define IDE_TEMPLATE_NO_CLOSE_OBJECT			IDE_TEMPLATE_BEGIN + 4
#define IDE_TEMPLATE_NO_CLASSID_PROGID			IDE_TEMPLATE_BEGIN + 5
#define IDE_TEMPLATE_RUNAT_NOT_SERVER			IDE_TEMPLATE_BEGIN + 6
#define IDE_TEMPLATE_BAD_PAGE_OBJECT_SCOPE		IDE_TEMPLATE_BEGIN + 7
#define IDE_TEMPLATE_BAD_GLOBAL_OBJECT_SCOPE	IDE_TEMPLATE_BEGIN + 8
#define IDE_TEMPLATE_NO_OBJECT_NAME				IDE_TEMPLATE_BEGIN + 9
#define IDE_TEMPLATE_NO_ENGINE_NAME				IDE_TEMPLATE_BEGIN + 10
#define IDE_TEMPLATE_NO_ATTRIBUTE_DELIMITER		IDE_TEMPLATE_BEGIN + 11
#define IDE_TEMPLATE_BAD_INCLUDE				IDE_TEMPLATE_BEGIN + 12
#define IDE_TEMPLATE_NO_CLOSE_HTML_COMMENT		IDE_TEMPLATE_BEGIN + 13
#define IDE_TEMPLATE_NO_INCLUDE_NAME			IDE_TEMPLATE_BEGIN + 14
#define IDE_TEMPLATE_BAD_PROGLANG				IDE_TEMPLATE_BEGIN + 15
#define IDE_TEMPLATE_BAD_FILE_TAG				IDE_TEMPLATE_BEGIN + 16
#define IDE_TEMPLATE_DISALLOWED_PARENT_PATH		IDE_TEMPLATE_BEGIN + 17
#define IDE_TEMPLATE_ERRMSG_GENERIC				IDE_TEMPLATE_BEGIN + 18
#define IDE_TEMPLATE_BAD_CLASSID				IDE_TEMPLATE_BEGIN + 19
#define IDE_TEMPLATE_BAD_PROGID					IDE_TEMPLATE_BEGIN + 20
#define IDE_TEMPLATE_CYCLIC_INCLUDE				IDE_TEMPLATE_BEGIN + 21
#define IDE_TEMPLATE_INVALID_OBJECT_NAME		IDE_TEMPLATE_BEGIN + 22
#define IDE_TEMPLATE_BAD_GLOBAL_PSCRIPT			IDE_TEMPLATE_BEGIN + 23
#define IDE_TEMPLATE_NESTED_TSCRIPT				IDE_TEMPLATE_BEGIN + 24
#define IDE_TEMPLATE_NESTED_OBJECT				IDE_TEMPLATE_BEGIN + 25
#define IDE_TEMPLATE_PAGE_COMMAND_NOT_FIRST		IDE_TEMPLATE_BEGIN + 26
#define IDE_TEMPLATE_PAGE_COMMAND_REPEATED		IDE_TEMPLATE_BEGIN + 27
#define IDE_TEMPLATE_BAD_PROGLANG_IN_REGISTRY	IDE_TEMPLATE_BEGIN + 28
#define IDE_TEMPLATE_NO_CODEPAGE				IDE_TEMPLATE_BEGIN + 29
#define IDE_TEMPLATE_BAD_CODEPAGE				IDE_TEMPLATE_BEGIN + 30
#define IDE_TEMPLATE_BAD_TRANSACTED_VALUE		IDE_TEMPLATE_BEGIN + 31
#define IDE_TEMPLATE_BAD_SESSION_VALUE		    IDE_TEMPLATE_BEGIN + 32
#define IDE_TEMPLATE_BAD_OBJECT_SCOPE           IDE_TEMPLATE_BEGIN + 33
#define IDE_TEMPLATE_NO_LCID					IDE_TEMPLATE_BEGIN + 34
#define IDE_TEMPLATE_BAD_LCID					IDE_TEMPLATE_BEGIN + 35
#define IDE_TEMPLATE_BAD_AT_COMMAND				IDE_TEMPLATE_BEGIN + 36
#define IDE_TEMPLATE_BAD_TYPELIB_SPEC           IDE_TEMPLATE_BEGIN + 37
#define IDE_TEMPLATE_BAD_TYPELIB_REG_SPEC       IDE_TEMPLATE_BEGIN + 38
#define IDE_TEMPLATE_LOAD_TYPELIB_FAILED        IDE_TEMPLATE_BEGIN + 39
#define IDE_TEMPLATE_WRAP_TYPELIB_FAILED        IDE_TEMPLATE_BEGIN + 40
#define IDE_TEMPLATE_BAD_COOKIE_SPEC			IDE_TEMPLATE_BEGIN + 41
#define IDE_TEMPLATE_LOAD_COOKIESCRIPT_FAILED   IDE_TEMPLATE_BEGIN + 42
#define IDE_TEMPLATE_BAD_SSI_COMMAND			IDE_TEMPLATE_BEGIN + 43
#define IDE_TEMPLATE_BAD_COOKIE_SPEC_SRC        IDE_TEMPLATE_BEGIN + 44
#define IDE_TEMPLATE_BAD_COOKIE_SPEC_NAME       IDE_TEMPLATE_BEGIN + 45
#define IDE_TEMPLATE_VALUE_REQUIRED				IDE_TEMPLATE_BEGIN + 46
#define IDE_TEMPLATE_UNICODE_NOTSUP             IDE_TEMPLATE_BEGIN + 47
#define IDE_TEMPLATE_METADATA_IN_GLOBAL_ASA		IDE_TEMPLATE_BEGIN + 48
#define IDE_TEMPLATE_CANT_ENABLE_SESSIONS	    IDE_TEMPLATE_BEGIN + 49
#define IDE_TEMPLATE_END						IDE_TEMPLATE_BEGIN + 49

// 
// Executor errors
//
#define IDE_EXECUTOR_BEGIN				3000
#define IDE_204_NO_CONTENT				IDE_EXECUTOR_BEGIN + 1
#define IDE_404_OBJECT_NOT_FOUND		IDE_EXECUTOR_BEGIN + 2
#define IDE_EXECUTOR_DTC_NOT_RUNNING	IDE_EXECUTOR_BEGIN + 3
#define IDE_401_3_ACCESS_DENIED         IDE_EXECUTOR_BEGIN + 4
#define IDE_EXECUTOR_END				IDE_EXECUTOR_BEGIN + 4

// 
// Sessmgr errors
//
#define IDE_SESSMGR_BEGIN			4000
#define IDE_ERROR_STRING_403		IDE_SESSMGR_BEGIN
#define IDE_ERROR_SCRIPT_NF			IDE_SESSMGR_BEGIN+1
#define IDE_ERROR_SCRIPT_EMPTY		IDE_SESSMGR_BEGIN+2
#define IDE_OPEN_THREAD_TOKEN		IDE_SESSMGR_BEGIN+3
#define IDE_INVALID_APPLICATION		IDE_SESSMGR_BEGIN+4
#define IDE_INIT_PAGE_LEVEL_OBJ		IDE_SESSMGR_BEGIN+5
#define IDE_ADD_APPLICATION			IDE_SESSMGR_BEGIN+6
#define IDE_ADD_SESSION				IDE_SESSMGR_BEGIN+7
#define IDE_OPEN_APPLN_DIR			IDE_SESSMGR_BEGIN+8
#define IDE_CHANGE_NOTIFICATION		IDE_SESSMGR_BEGIN+9
#define IDE_IMPERSONATE_USER		IDE_SESSMGR_BEGIN+10
#define IDE_500_SERVER_ERROR		IDE_SESSMGR_BEGIN+11
#define IDE_SERVER_TOO_BUSY			IDE_SESSMGR_BEGIN+12
#define	IDE_SERVER_SHUTTING_DOWN	IDE_SESSMGR_BEGIN+13
#define IDE_GLOBAL_ASA_CHANGED		IDE_SESSMGR_BEGIN+14
#define IDE_GLOBAL_ASA_FORBIDDEN    IDE_SESSMGR_BEGIN+15
#define IDE_TOO_MANY_USERS			IDE_SESSMGR_BEGIN+16
#define IDE_BAD_CODEPAGE_IN_MB		IDE_SESSMGR_BEGIN+17
#define IDE_SESSMGR_END				IDE_SESSMGR_BEGIN+17

// 
// Threadmgr errors
//
#define IDE_THREADMGR_BEGIN			5000
#define IDE_CANT_CREATE_THREAD		IDE_THREADMGR_BEGIN
#define IDE_THREADMGR_END			IDE_CANT_CREATE_THREAD

// 
// Intrinsic errors
//
#define IDE_INTRINSIC_BEGIN						6000
#define IDE_RESPONSE_BEGIN						IDE_INTRINSIC_BEGIN
#define IDE_RESPONSE							IDE_RESPONSE_BEGIN
#define IDE_RESPONSE_HEADERS_CANT_REACH_CLIENT	IDE_RESPONSE_BEGIN + 1
#define IDE_RESPONSE_BODY_CANT_REACH_CLIENT		IDE_RESPONSE_BEGIN + 2
#define IDE_RESPONSE_HEADERS_WRITTEN			IDE_RESPONSE_BEGIN + 3
#define IDE_RESPONSE_CANT_STOP_BUFFER			IDE_RESPONSE_BEGIN + 4
#define IDE_RESPONSE_NO_URL						IDE_RESPONSE_BEGIN + 5
#define IDE_RESPONSE_BUFFER_NOT_ON				IDE_RESPONSE_BEGIN + 6
#define IDE_RESPONSE_LOG_FAILURE				IDE_RESPONSE_BEGIN + 7
#define IDE_RESPONSE_REDIRECT1					IDE_RESPONSE_BEGIN + 8
#define IDE_RESPONSE_REDIRECT2					IDE_RESPONSE_BEGIN + 9
#define IDE_RESPONSE_UNABLE_TO_CONVERT			IDE_RESPONSE_BEGIN + 10
#define IDE_RESPONSE_MODIFY_SESS_COOKIE			IDE_RESPONSE_BEGIN + 11
#define IDE_RESPONSE_COMMAS_NOT_ALLOWED			IDE_RESPONSE_BEGIN + 12
#define IDE_RESPONSE_CLEAR_AFTER_FLUSH_IN_DEBUG	IDE_RESPONSE_BEGIN + 13
#define IDE_RESPONSE_NOT_IMPLEMENTED			IDE_RESPONSE_BEGIN + 14
#define IDE_RESPONSE_END						IDE_RESPONSE_BEGIN + 14

#define IDE_SESSION								6100
#define IDE_SESSION_ID							IDE_SESSION + 1
#define IDE_SESSION_INVALID_TIMEOUT				IDE_SESSION + 2
#define IDE_SESSION_MAP_FAILED					IDE_SESSION + 3
#define IDE_SESSION_UNINITIALIZED_OBJ   		IDE_SESSION + 4
#define IDE_SESSION_INIT_FAIL					IDE_SESSION + 5
#define IDE_SESSION_END							IDE_SESSION + 6
#define IDE_SESSION_CANT_STORE_INTRINSIC		IDE_SESSION + 7
#define IDE_SESSION_CANT_STORE_NO_MODEL			IDE_SESSION + 8
#define IDE_SESSION_COULD_NOT_DELETE			IDE_SESSION + 9
#define	IDE_SESSION_CANT_STORE_TAG_OBJECT		IDE_SESSION + 10
#define	IDE_CANT_STORE_JAVASCRIPT_OBJECT		IDE_SESSION + 11
#define IDE_SESSION_INVALID_CODEPAGE			IDE_SESSION + 12

#define IDE_SERVER								6200
#define IDE_SERVER_MAPPATH						IDE_SERVER + 1
#define IDE_SERVER_MAPPATH_INVALID_STR			IDE_SERVER + 2
#define IDE_SERVER_MAPPATH_PHY_STR				IDE_SERVER + 3
#define IDE_SERVER_MAPPATH_INVALID_CHR			IDE_SERVER + 4
#define IDE_SERVER_MAPPATH_INVALID_CHR2			IDE_SERVER + 5
#define IDE_SERVER_MAPPATH_INVALID_CHR3			IDE_SERVER + 6
#define IDE_SERVER_MAPPATH_FAILED				IDE_SERVER + 7
#define IDE_SERVER_INVALID_CALL					IDE_SERVER + 8
#define IDE_SERVER_CREATEOBJ_FAILED				IDE_SERVER + 9
#define IDE_SERVER_CREATEOBJ_DENIED				IDE_SERVER + 10
#define IDE_SERVER_CREATEOBJ_NOTINPROC			IDE_SERVER + 11
#define IDE_SERVER_INVALID_TIMEOUT				IDE_SERVER + 12
#define IDE_SERVER_EXCEDED_MAX_PATH				IDE_SERVER + 13
#define IDE_SERVER_EXECUTE_FAILED				IDE_SERVER + 14
#define IDE_SERVER_EXECUTE_CANTLOAD				IDE_SERVER + 15
#define IDE_SERVER_EXECUTE_INVALID_PATH			IDE_SERVER + 16
#define IDE_SERVER_TRANSFER_FAILED				IDE_SERVER + 17
#define IDE_SERVER_TRANSFER_CANTLOAD			IDE_SERVER + 18
#define IDE_SERVER_TRANSFER_INVALID_PATH		IDE_SERVER + 19


#define IDE_APPLICATION							6300
#define IDE_APPLICATION_FAILED_INIT				IDE_APPLICATION + 1
#define IDE_APPLICATION_CANT_STORE_INTRINSIC 	IDE_APPLICATION + 2
#define IDE_APPLICATION_CANT_STORE_APT_MODEL	IDE_APPLICATION + 3
#define IDE_APPLICATION_CANT_STORE_NO_MODEL		IDE_APPLICATION + 4
#define	IDE_APPLICATION_CANT_STORE_TAG_OBJECT	IDE_APPLICATION + 5
#define IDE_APPLICATION_LOCKED_CANT_STORE_OBJ		IDE_APPLICATION + 7
#define IDE_APPLICATION_CANT_STORE_OBJECT		IDE_APPLICATION + 8
#define IDE_APPLICATION_CREATE_EVENT_FAILED		IDE_APPLICATION + 9

#define IDE_COOKIE								6400
#define IDE_COOKIE_EMPTY_DICT					IDE_COOKIE + 1
#define IDE_COOKIE_NO_NAME						IDE_COOKIE + 2
#define IDE_COOKIE_BAD_EXPIRATION				IDE_COOKIE + 3

#define IDE_REQUEST								6500
#define IDE_REQUEST_BINARYREAD_NA				IDE_REQUEST + 1
#define IDE_REQUEST_FORMCOLLECTION_NA			IDE_REQUEST + 2
#define IDE_REQUEST_GENERICCOLLECTION_NA		IDE_REQUEST + 3
#define IDE_REQUEST_STREAMONLY   				IDE_REQUEST + 4
#define IDE_REQUEST_BINREAD_BAD_ARG				IDE_REQUEST + 5

#define	IDE_COVER								6700
#define IDE_COVER_DISP_RELEASE_GPF			IDE_COVER + 1
#define IDE_COVER_ON_START_PAGE_GPF			IDE_COVER + 2
#define IDE_COVER_ON_END_PAGE_GPF			IDE_COVER + 3
#define IDE_COVER_ON_START_PAGE_FAILED		IDE_COVER + 4
#define IDE_COVER_ON_END_PAGE_FAILED		IDE_COVER + 5
	
#define IDE_CERTIFICATE					6800
#define IDE_CERTIFICATE_BAD_CERT        6801

#define IDE_OBJECTCONTEXT					6850
#define IDE_OBJECTCONTEXT_NOT_TRANSACTED	6851

#define IDE_INTRINSIC_END				IDE_CERTIFICATE_BAD_CERT

// 
// Cachemgr errors
//
#define IDE_CACHEMGR_BEGIN			7000
#define IDE_CACHEMGR_END			IDE_CACHEMGR_BEGIN

//
// NT event log errors and warnings
//
#define IDE_EVENT_BEGIN				8000
#define IDE_EVENT_END				IDE_EVENT_BEGIN + 1

//
// Errors that utility functions detect
//
#define IDE_UTIL_BEGIN				9000
#define IDE_UTIL_NO_VALUE			IDE_UTIL_BEGIN

#define IDE_END						IDE_UTIL_NO_VALUE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\request.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: request object

File: request.cpp

Owner: CGrant, DGottner

This file contains the code for the implementation of the Request object.
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "objbase.h"
#include "request.h"
#include "cookies.h"
#include "clcert.h"
#include "memchk.h"

#pragma warning (disable: 4355)  // ignore: "'this' used in base member init


static char HexToChar(LPSTR);
static char DecodeFromURL(char **pszSource, char *szStop, char *szDest, UINT uCodePage, BOOL fIgnoreCase = FALSE);

#define toupper(x)  BYTE(CharUpper(LPSTR(BYTE(x))))

#if _IIS_6_0

struct {
    int     varLen;
    char    *szVarName;
} g_sUNICODEVars [] = {
    
    {3, "URL"},
    {9, "PATH_INFO"},
    {9, "AUTH_USER"},
    {10,"LOGON_USER"},
    {11,"REMOTE_USER"},
    {11,"SCRIPT_NAME"},
    {11,"APP_POOL_ID"},
    {12,"APPL_MD_PATH"},
    {15,"PATH_TRANSLATED"},
    {17,"SCRIPT_TRANSLATED"},
    {18,"APPL_PHYSICAL_PATH"},
    {20,"UNMAPPED_REMOTE_USER"},
    {-1,""}
};

#endif

/*------------------------------------------------------------------
 * C R e q u e s t H i t
 */

/*===================================================================
CRequestHit::CRequestHit

Constructor

Parameters:
    None
===================================================================*/

CRequestHit::CRequestHit()
    {
    m_fInited = FALSE;
    m_fDuplicate = FALSE;
    m_pQueryData = m_pFormData = NULL;
    m_pCookieData = NULL;
    m_pClCertData = NULL;
    }



/*===================================================================
CRequestHit::~CRequestHit

Destructor
===================================================================*/

CRequestHit::~CRequestHit()
    {
    if (m_pQueryData != NULL)
        m_pQueryData->Release();

    if (m_pFormData != NULL)
        m_pFormData->Release();

    if (m_pCookieData != NULL)
        m_pCookieData->Release();

    if (m_pClCertData != NULL)
        m_pClCertData->Release();

    if (m_fDuplicate)
        delete m_pKey;
    }



/*===================================================================
CRequestHit::Init

Constructor

Parameters:
    szName - pointer to string containing name
    fDuplicate - TRUE if we should dup the string

Returns:
    E_OUTOFMEMORY, E_FAIL, or S_OK
===================================================================*/

HRESULT CRequestHit::Init(char *szName, BOOL fDuplicate)
    {
    if (m_fInited)
        return E_FAIL;

    m_fDuplicate = fDuplicate;
    if (fDuplicate)
        {
        char *szNewKey = new char [strlen(szName) + 1];
        if (szNewKey == NULL)
            return E_OUTOFMEMORY;

        if (FAILED(CLinkElem::Init(strcpy(szNewKey, szName), strlen(szName))))
            return E_FAIL;
        }
    else
        if (FAILED(CLinkElem::Init(szName, strlen(szName))))
            return E_FAIL;

    m_fInited = TRUE;
    return S_OK;
    }




/*===================================================================
CRequestHit::AddValue

Parameters:
    source - type of the value (QueryString or Body)
    szValue - the value as a null-terminated string.
    lCodePage - the CodePage used when retrieve the data

Returns:
    Nothing.
===================================================================*/
HRESULT CRequestHit::AddValue
(
CollectionType Source,
char *szValue,
CIsapiReqInfo   *pIReq,
UINT lCodePage
)
    {
    HRESULT hResult;
    CStringList **ppValues = NULL;

    switch (Source)
        {
    case QUERYSTRING:
        ppValues = &m_pQueryData;
        break;

    case FORM:
        ppValues = &m_pFormData;
        break;

    case COOKIE:
        if (m_pCookieData == NULL)
            {
            m_pCookieData = new CCookie(pIReq, lCodePage);

            if (m_pCookieData == NULL)
                return E_OUTOFMEMORY;

            if (FAILED(hResult = m_pCookieData->Init()))
                return hResult;
            }

        return m_pCookieData->AddValue(szValue);

    case CLCERT:
        if (m_pClCertData == NULL)
            {
            m_pClCertData = new CClCert;

            if (m_pClCertData == NULL)
                return E_OUTOFMEMORY;

            if (FAILED(hResult = m_pClCertData->Init()))
                return hResult;
            }

        return m_pClCertData->AddValue(szValue);

    default:
        return E_FAIL;
        }

    if (*ppValues == NULL)
        {
        *ppValues = new CStringList;
        if (*ppValues == NULL)
            return E_OUTOFMEMORY;
        }

    if (FAILED(hResult = (*ppValues)->AddValue(szValue, FALSE, lCodePage)))
        return hResult;

    return S_OK;
    }



HRESULT CRequestHit::AddCertValue(VARENUM ve, LPBYTE pValue, UINT cLen )
    {
    HRESULT hResult;

    if (m_pClCertData == NULL)
        {
        m_pClCertData = new CClCert;

        if (m_pClCertData == NULL)
            return E_OUTOFMEMORY;

        if (FAILED(hResult = m_pClCertData->Init()))
            return hResult;
        }

    return m_pClCertData->AddValue( (LPSTR)pValue, ve, cLen );
    }




/*===================================================================
CRequestHit::AddKeyAndValue

Add a value based on keys for collections that support them.  Currently,
only cookies support them.

Parameters:
    source - type of the value (must be Cookie)
    szKey - the key
    szValue - the value as a null-terminated string.

Returns:
    Returns E_OUTOFMEMORY if memory cannot be allocated,
    E_FAIL if source collection does not support keys,
===================================================================*/
HRESULT CRequestHit::AddKeyAndValue
(
CollectionType Source,
char *szKey,
char *szValue,
CIsapiReqInfo    *pIReq,
UINT    lCodePage
)
{
    HRESULT hResult;

    switch ( Source )
    {
        case COOKIE:
            if (m_pCookieData == NULL)
                {
                m_pCookieData = new CCookie( pIReq , lCodePage);

                if (m_pCookieData == NULL)
                    return E_OUTOFMEMORY;

                if (FAILED(hResult = m_pCookieData->Init()))
                    return hResult;
                }

            return m_pCookieData->AddKeyAndValue(szKey, szValue);

        default:
            return E_FAIL;
    }
}

/*------------------------------------------------------------------
 * C R e q u e s t H i t s A r r a y
 */

/*===================================================================
CRequestHitsArray::CRequestHitsArray

Constructor

Parameters:

Returns:
===================================================================*/
CRequestHitsArray::CRequestHitsArray()
    : m_dwCount(0), m_dwHitMax(0), m_rgRequestHit(NULL)
    {
    }

/*===================================================================
CRequestHitsArray::~CRequestHitsArray

Destructor

Parameters:

Returns:
===================================================================*/
CRequestHitsArray::~CRequestHitsArray()
    {
    if (m_rgRequestHit)
        delete [] m_rgRequestHit;
    }

/*===================================================================
CRequestHitsArray::AddRequestHit

Add an element to the array

Parameters:
    pHit    element to add

Returns:
===================================================================*/
BOOL CRequestHitsArray::AddRequestHit
(
CRequestHit *pHit
)
    {
    Assert(pHit);

    if (m_dwCount == m_dwHitMax)
        {
        DWORD dwNewSize = m_dwHitMax + NUM_REQUEST_HITS;
        CRequestHit **ppNewArray = new CRequestHit *[dwNewSize];

        if (ppNewArray == NULL)
            return FALSE;

        if (m_dwCount)
            {
            Assert(m_rgRequestHit);

            // Copy pointers from old array
            memcpy
                (
                ppNewArray,
                m_rgRequestHit,
                m_dwCount * sizeof(CRequestHit *)
                );

            // free old array
            delete [] m_rgRequestHit;
            }
         else
            {
            Assert(m_rgRequestHit == NULL);
            }

        m_rgRequestHit = ppNewArray;
        m_dwHitMax = dwNewSize;
        }

    m_rgRequestHit[m_dwCount++] = pHit;
    return TRUE;
    }

/*------------------------------------------------------------------
 * C Q u e r y S t r i n g
 */

/*===================================================================
CQueryString::CQueryString

Constructor

Parameters:
    pRequest        Pointer to main Request object
    pUnkOuter       LPUNKNOWN of a controlling unknown.

Returns:
    Nothing.

Note:
    This object is NOT ref counted since it is created & destroyed
    automatically by C++.
===================================================================*/

CQueryString::CQueryString(CRequest *pRequest, IUnknown *pUnkOuter)
    : m_ISupportErrImp(this, pUnkOuter, IID_IRequestDictionary)
    {
    m_punkOuter = pUnkOuter;

    if (pRequest)
        pRequest->AddRef();
    m_pRequest = pRequest;

    CDispatch::Init(IID_IRequestDictionary);
    }

/*===================================================================
CQueryString::~CQueryString

Destructor

Parameters:
    None
Returns:
    Nothing.
===================================================================*/
CQueryString::~CQueryString()
    {
    if (m_pRequest)
        m_pRequest->Release();
    }

/*===================================================================
HRESULT CQueryString::Init

Parameters:
    None

Returns:
    E_OUTOFMEMORY if allocation fails.

===================================================================*/
HRESULT CQueryString::Init()
    {
    return CRequestHitsArray::Init();
    }

/*===================================================================
HRESULT CQueryString::ReInit

Parameters:
    None

Returns:
    S_OK
===================================================================*/
HRESULT CQueryString::ReInit()
    {
    return CRequestHitsArray::ReInit();
    }

/*===================================================================
CQueryString::QueryInterface
CQueryString::AddRef
CQueryString::Release

IUnknown members for CQueryString object.
===================================================================*/

STDMETHODIMP CQueryString::QueryInterface(REFIID iid, void **ppvObj)
    {
    *ppvObj = NULL;

    if (iid == IID_IUnknown || iid == IID_IRequestDictionary || iid == IID_IDispatch)
        *ppvObj = this;

    else if (iid == IID_ISupportErrorInfo)
        *ppvObj = &m_ISupportErrImp;

    if (*ppvObj != NULL)
        {
        static_cast<IUnknown *>(*ppvObj)->AddRef();
        return S_OK;
        }

    return ResultFromScode(E_NOINTERFACE);
    }


STDMETHODIMP_(ULONG) CQueryString::AddRef(void)
    {
    return m_punkOuter->AddRef();
    }


STDMETHODIMP_(ULONG) CQueryString::Release(void)
    {
    return m_punkOuter->Release();
    }



/*===================================================================
CQueryString::get_Item

Function called from DispInvoke to get values from the QueryString collection.

Parameters:
    vKey        VARIANT [in], which parameter to get the value of - Empty means whole collection
    pvarReturn  VARIANT *, [out] value of the requested parameter

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/

HRESULT CQueryString::get_Item(VARIANT varKey, VARIANT *pvarReturn)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    char            *szKey;
    CWCharToMBCS    convKey;
    CRequestHit     *pRequestHit;   // pointer to request bucket
    IDispatch       *pSListReturn;  // value of the key

    // Initialize things
    //
    VariantInit(pvarReturn);
    VARIANT *pvarKey = &varKey;
    HRESULT hrReturn = S_OK;

    // BUG 937: VBScript passes VT_VARIANT|VT_BYREF when passing obect
    //          produced by IEnumVariant
    //
    // Use VariantResolveDispatch which will:
    //
    //     *  Copy BYREF variants for us using VariantCopyInd
    //     *  handle E_OUTOFMEMORY for us
    //     *  get the default value from an IDispatch, which seems
    //        like an appropriate conversion.
    //
    VARIANT varKeyCopy;
    VariantInit(&varKeyCopy);
    DWORD vt = V_VT(pvarKey);

    if ((vt != VT_BSTR) && (vt != VT_I2) && (vt != VT_I4))
        {
        if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
            goto LExit;

        pvarKey = &varKeyCopy;
        }
    vt = V_VT(pvarKey);

    switch (vt)
        {
    // Bug 95201 support all numberic sub-types
    case VT_I1:  case VT_I2:               case VT_I8:
    case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
    case VT_R4:  case VT_R8:
        // Coerce all integral types to VT_I4
        if (FAILED(hrReturn = VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
            goto LExit;

        // fallthru to VT_I4

    case VT_I4:
    case VT_BSTR:
        break;

    case VT_ERROR:
        if (V_ERROR(pvarKey) == DISP_E_PARAMNOTFOUND)
            {
            // Look up QueryString using the "ServerVariables" collection -
            // The LoadVariables() function trashes QueryPszQueryString() in the CIsapiReqInfo
            //
            DWORD dwQStrSize;

            STACK_BUFFER( queryStrBuff, 256 );

            if (!SERVER_GET(m_pRequest->GetIReq(), "QUERY_STRING", &queryStrBuff, &dwQStrSize)) {
                if (GetLastError() == E_OUTOFMEMORY) {
                    ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                    hrReturn = E_OUTOFMEMORY;
                }
                else {
                    hrReturn = E_FAIL;
                }
                goto LExit;
            }

            char *szQueryString = (char *)queryStrBuff.QueryPtr();

            BSTR bstrT;
            if (FAILED(SysAllocStringFromSz(szQueryString, 0, &bstrT,m_pRequest->GetCodePage())))
                {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                hrReturn = E_OUTOFMEMORY;
                goto LExit;
                }
            V_VT(pvarReturn) = VT_BSTR;
            V_BSTR(pvarReturn) = bstrT;

            goto LExit;
            }

        // Other error, FALL THROUGH to wrong type case

    default:
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_EXPECTING_STR);
        hrReturn = E_FAIL;
        goto LExit;
        }

    if (m_pRequest->m_pData->m_fLoadQuery)
        {
        if (FAILED(m_pRequest->LoadVariables(QUERYSTRING, m_pRequest->GetIReq()->QueryPszQueryString(), m_pRequest->GetCodePage())))
            {
            hrReturn = E_FAIL;
            goto LExit;
            }

        m_pRequest->m_pData->m_fLoadQuery = FALSE;
        }

    if (vt == VT_BSTR)
        {
        // convert BSTR version to ANSI version of the key using current Session.CodePage

        if (FAILED(hrReturn = convKey.Init(V_BSTR(pvarKey), m_pRequest->GetCodePage()))) {
            if (hrReturn == E_OUTOFMEMORY) {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                goto LExit;
            }
            hrReturn = NO_ERROR;
            szKey = "";
        }
        else {
            szKey = convKey.GetString();
        }

        pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->FindElem(szKey, strlen(szKey)));
        }
    else
        {
        // Look up item by index
        int iCount;

        iCount = V_I4(pvarKey);

        // BUG 86117 test passes when m_dwCount == 0
        if ( ((iCount < 1) || (iCount > (int) m_dwCount)) || ((iCount > 0) && (int) m_dwCount == 0))
            {
            hrReturn = E_FAIL;
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_BAD_ARRAY_INDEX);
            goto LExit;
            }


        pRequestHit = m_rgRequestHit[iCount - 1];
        }

    if (pRequestHit)
        {
        CStringList *pValues = pRequestHit->m_pQueryData;
        if (pValues == NULL)
            goto LNotFound;

        if (FAILED(pValues->QueryInterface(IID_IDispatch, reinterpret_cast<void **>(&pSListReturn))))
            Assert (FALSE);

        V_VT(pvarReturn) = VT_DISPATCH;
        V_DISPATCH(pvarReturn) = pSListReturn;

        goto LExit;
        }

LNotFound: // Return "Empty"
    if (FAILED(m_pRequest->m_pData->GetEmptyStringList(&pSListReturn)))
        hrReturn = E_FAIL;

    V_VT(pvarReturn) = VT_DISPATCH;
    V_DISPATCH(pvarReturn) = pSListReturn;

LExit:
    VariantClear(&varKeyCopy);
    return hrReturn;
    }

/*===================================================================
CQueryString::get_Key

Function called from DispInvoke to get keys from the QueryString collection.

Parameters:
    vKey        VARIANT [in], which parameter to get the key of
    pvarReturn  VARIANT *, [out] value of the requested parameter

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/

HRESULT CQueryString::get_Key(VARIANT varKey, VARIANT *pVar)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    char            *szKey;         // ascii version of the key
    CWCharToMBCS    convKey;
    CRequestHit     *pRequestHit;   // pointer to request bucket
    IDispatch       *pSListReturn;  // value of the key

    // Initialize things
    //
    VariantInit(pVar);
    VARIANT *pvarKey = &varKey;
    V_VT(pVar) = VT_BSTR;
    V_BSTR(pVar) = NULL;
    HRESULT hrReturn = S_OK;

    // Use VariantResolveDispatch which will:
    //
    //     *  Copy BYREF variants for us using VariantCopyInd
    //     *  handle E_OUTOFMEMORY for us
    //     *  get the default value from an IDispatch, which seems
    //        like an appropriate conversion.
    //
    VARIANT varKeyCopy;
    VariantInit(&varKeyCopy);
    DWORD vt = V_VT(pvarKey);

    if ((vt != VT_BSTR) && (vt != VT_I2) && (vt != VT_I4))
        {
        if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
            goto LExit;

        pvarKey = &varKeyCopy;
        }
    vt = V_VT(pvarKey);

    switch (vt)
        {
    // Bug 95201 support all numberic sub-types
    case VT_I1:  case VT_I2:               case VT_I8:
    case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
    case VT_R4:  case VT_R8:
        // Coerce all integral types to VT_I4
        if (FAILED(hrReturn = VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
            goto LExit;

        // fallthru to VT_I4

    case VT_I4:
    case VT_BSTR:
        break;

    default:
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_EXPECTING_STR);
        hrReturn = E_FAIL;
        goto LExit;
        }

    if (m_pRequest->m_pData->m_fLoadQuery)
        {
        if (FAILED(m_pRequest->LoadVariables(QUERYSTRING, m_pRequest->GetIReq()->QueryPszQueryString(), m_pRequest->GetCodePage())))
            {
            hrReturn = E_FAIL;
            goto LExit;
            }

        m_pRequest->m_pData->m_fLoadQuery = FALSE;
        }

    if (vt == VT_BSTR)
        {
        // convert BSTR version to ANSI version of the key using current Session.CodePage

        if (FAILED(hrReturn = convKey.Init(V_BSTR(pvarKey),m_pRequest->GetCodePage()))) {
            if (hrReturn == E_OUTOFMEMORY) {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                goto LExit;
            }
            hrReturn = NO_ERROR;
			szKey = "";
        }
        else {
            szKey = convKey.GetString();
        }

        pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->FindElem(szKey, strlen(szKey)));
        }
    else
        {
        int iCount;

        iCount = V_I4(pvarKey);

        // BUG 86117 test passes when m_dwCount == 0
        if ( ((iCount < 1) || (iCount > (int) m_dwCount)) || ((iCount > 0) && ((int) m_dwCount == 0)))
            {
            hrReturn = E_FAIL;
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_BAD_ARRAY_INDEX);
            goto LExit;
            }

        pRequestHit = m_rgRequestHit[iCount - 1];
        }

    if (pRequestHit)
        {
        // Create a BSTR containing the key for this variant
        BSTR bstrT = NULL;
        
        SysAllocStringFromSz((char *)pRequestHit->m_pKey,0,&bstrT,m_pRequest->GetCodePage());
        if (!bstrT)
            return E_OUTOFMEMORY;
        V_BSTR(pVar) = bstrT;
        }
LExit:
    VariantClear(&varKeyCopy);
    return hrReturn;
    }

/*===================================================================
CQueryString::get_Count

Parameters:
    pcValues - count is stored in *pcValues
===================================================================*/

STDMETHODIMP CQueryString::get_Count(int *pcValues)
    {
    HRESULT hrReturn = S_OK;

    if (m_pRequest->m_pData->m_fLoadQuery)
        {
        if (FAILED(hrReturn = m_pRequest->LoadVariables(QUERYSTRING, m_pRequest->GetIReq()->QueryPszQueryString(), m_pRequest->GetCodePage())))
            {
            goto LExit;
            }
        m_pRequest->m_pData->m_fLoadQuery = FALSE;
        }

    *pcValues = m_dwCount;

LExit:
    return hrReturn;
    }

/*===================================================================
CQueryString::get__NewEnum

Return a new enumerator
===================================================================*/

HRESULT CQueryString::get__NewEnum(IUnknown **ppEnumReturn)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    return m_pRequest->GetRequestEnumerator(QUERYSTRING, ppEnumReturn);
    }

/*------------------------------------------------------------------
 * C F o r m I n p u t s
 */

/*===================================================================
CFormInputs::CFormInputs

Constructor

Parameters:
    pRequest        Pointer to main Request object
    pUnkOuter       LPUNKNOWN of a controlling unknown.

Returns:
    Nothing.

Note:
    This object is NOT ref counted since it is created & destroyed
    automatically by C++.
===================================================================*/

CFormInputs::CFormInputs(CRequest *pRequest, IUnknown *pUnkOuter)
    : m_ISupportErrImp(this, pUnkOuter, IID_IRequestDictionary)
    {
    m_punkOuter = pUnkOuter;

    if (pRequest)
        pRequest->AddRef();
    m_pRequest = pRequest;

    CDispatch::Init(IID_IRequestDictionary);
    }

/*===================================================================
CFormInputs::CFormInputs

Destructor

Parameters:
    None
Returns:
    Nothing.
===================================================================*/
CFormInputs::~CFormInputs()
    {
    if (m_pRequest)
        m_pRequest->Release();
    }

/*===================================================================
HRESULT CFormInputs::Init

Parameters:
    None

Returns:
    E_OUTOFMEMORY if allocation fails.
===================================================================*/
HRESULT CFormInputs::Init()
    {
    return CRequestHitsArray::Init();
    }

/*===================================================================
HRESULT CFormInputs::ReInit

Parameters:
    None

Returns:
    S_OK
===================================================================*/
HRESULT CFormInputs::ReInit()
    {
    return CRequestHitsArray::ReInit();
    }

/*===================================================================
CFormInputs::QueryInterface
CFormInputs::AddRef
CFormInputs::Release

IUnknown members for CFormInputs object.
===================================================================*/

STDMETHODIMP CFormInputs::QueryInterface(REFIID iid, void **ppvObj)
    {
    *ppvObj = NULL;

    if (iid == IID_IUnknown || iid == IID_IRequestDictionary || iid == IID_IDispatch)
        *ppvObj = this;

    else if (iid == IID_ISupportErrorInfo)
        *ppvObj = &m_ISupportErrImp;

    if (*ppvObj != NULL)
        {
        static_cast<IUnknown *>(*ppvObj)->AddRef();
        return S_OK;
        }

    return E_NOINTERFACE;
    }


STDMETHODIMP_(ULONG) CFormInputs::AddRef(void)
    {
    return m_punkOuter->AddRef();
    }


STDMETHODIMP_(ULONG) CFormInputs::Release(void)
    {
    return m_punkOuter->Release();
    }



/*===================================================================
CFormInputs::get_Item

Function called from DispInvoke to get values from the QueryString collection.

Parameters:
    vKey        VARIANT [in], which parameter to get the value of - Empty means whole collection
    pvarReturn  VARIANT *, [out] value of the requested parameter

Returns:
    S_OK on success, S_OK if key not found, E_FAIL on failure.
===================================================================*/

HRESULT CFormInputs::get_Item(VARIANT varKey, VARIANT *pvarReturn)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    char            *szKey;                // ascii version of the key
    CWCharToMBCS    convKey;
    IDispatch       *pSListReturn;         // value of the key
    CRequestHit     *pRequestHit;          // pointer to request bucket
    BOOL            fDataAvail = FALSE;    // true if data seen from client

    // Initialize things
    //
    VariantInit(pvarReturn);
    VARIANT *pvarKey = &varKey;
    HRESULT hrReturn = S_OK;

    // If BinaryRead has been called, the Form collection is no longer available
    if (m_pRequest->m_pData->m_FormDataStatus != AVAILABLE &&
        m_pRequest->m_pData->m_FormDataStatus != FORMCOLLECTIONONLY)
        {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_REQUEST_FORMCOLLECTION_NA);
        hrReturn = E_FAIL;
        }

    if (m_pRequest->m_pData->m_FormDataStatus == AVAILABLE)
        m_pRequest->m_pData->m_FormDataStatus = FORMCOLLECTIONONLY;

    // BUG 937: VBScript passes VT_VARIANT|VT_BYREF when passing obect
    //          produced by IEnumVariant
    //
    // Use VariantResolveDispatch which will:
    //
    //     *  Copy BYREF variants for us using VariantCopyInd
    //     *  handle E_OUTOFMEMORY for us
    //     *  get the default value from an IDispatch, which seems
    //        like an appropriate conversion.
    //
    VARIANT varKeyCopy;
    VariantInit(&varKeyCopy);
    DWORD vt = V_VT(pvarKey);

    if ((vt != VT_BSTR) && (vt != VT_I2) && (vt != VT_I4))
        {
        if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
            goto LExit;

        pvarKey = &varKeyCopy;
        }
    vt = V_VT(pvarKey);

    if (m_pRequest->m_pData->m_fLoadForm)
        {
        if (FAILED(hrReturn = m_pRequest->CopyClientData()))
            goto LExit;

        if (FAILED(hrReturn = m_pRequest->LoadVariables(FORM, m_pRequest->m_pData->m_szFormData, m_pRequest->GetCodePage())))
            goto LExit;

        // BUG:895 (JHITTLE) added to check for null result set
        // this fixes the out of memory error when the form
        // data is NULL
        //
        fDataAvail = (m_pRequest->m_pData->m_szFormData != NULL);
        m_pRequest->m_pData->m_fLoadForm = FALSE;
        }
    else
        fDataAvail = (m_pRequest->m_pData->m_szFormData != NULL);

    switch (vt)
        {
    // Bug 95201 support all numberic sub-types
    case VT_I1:  case VT_I2:               case VT_I8:
    case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
    case VT_R4:  case VT_R8:
        // Coerce all integral types to VT_I4
        if (FAILED(hrReturn = VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
            goto LExit;

        // fallthru to VT_I4

    case VT_I4:
    case VT_BSTR:
        break;

    case VT_ERROR:
        if (V_ERROR(pvarKey) == DISP_E_PARAMNOTFOUND)
            {
            if (fDataAvail)
                {
                BSTR bstrT;
                if (FAILED(SysAllocStringFromSz(m_pRequest->m_pData->m_szFormClone, 0, &bstrT,m_pRequest->GetCodePage())))
                    {
                    ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                    hrReturn = E_OUTOFMEMORY;
                    }
                V_VT(pvarReturn) = VT_BSTR;
                V_BSTR(pvarReturn) = bstrT;
                }

            // If there was no data available, status & return value are already set
            goto LExit;
            }

        // Other error, FALL THROUGH to wrong type case

    default:
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_EXPECTING_STR);
        hrReturn = E_FAIL;
        goto LExit;
        }

    pRequestHit = NULL;
    if (! fDataAvail)       // Quick check before we do an expensive lookup
        goto LNotFound;

    if (vt == VT_BSTR)
        {
        // convert BSTR version to ANSI version of the key using current Session.CodePage

        if (FAILED(hrReturn = convKey.Init(V_BSTR(pvarKey), m_pRequest->GetCodePage()))) {
            if (hrReturn == E_OUTOFMEMORY) {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                goto LExit;
            }
            hrReturn = NO_ERROR;
			szKey = "";
        }
        else {
            szKey = convKey.GetString();
        }

        pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->FindElem(szKey, strlen(szKey)));
        }
    else
        {
        // Look up item by index
        int iCount;

        iCount = V_I4(pvarKey);

        // BUG 86117 test passes when m_dwCount == 0
        if ( ((iCount < 1) || (iCount > (int) m_dwCount)) || ((iCount > 0) && ((int) m_dwCount == 0)))
            {
            hrReturn = E_FAIL;
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_BAD_ARRAY_INDEX);
            goto LExit;
            }


        pRequestHit = m_rgRequestHit[iCount - 1];
        }

    if (pRequestHit)
        {
        CStringList *pValues = pRequestHit->m_pFormData;
        if (pValues == NULL)
            goto LNotFound;

        if (FAILED(pValues->QueryInterface(IID_IDispatch, reinterpret_cast<void **>(&pSListReturn))))
            Assert (FALSE);

        V_VT(pvarReturn) = VT_DISPATCH;
        V_DISPATCH(pvarReturn) = pSListReturn;
        goto LExit;
        }

LNotFound: // Return "Empty"
    if(vt != VT_BSTR)
        {
        hrReturn = E_FAIL;
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_BAD_ARRAY_INDEX);
        goto LExit;
        }

    if (FAILED(m_pRequest->m_pData->GetEmptyStringList(&pSListReturn)))
        hrReturn = E_FAIL;

    V_VT(pvarReturn) = VT_DISPATCH;
    V_DISPATCH(pvarReturn) = pSListReturn;

LExit:
    VariantClear(&varKeyCopy);
    return hrReturn;
    }

/*===================================================================
CFormInputs::get_Count

Parameters:
    pcValues - count is stored in *pcValues
===================================================================*/

STDMETHODIMP CFormInputs::get_Count(int *pcValues)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    HRESULT hrReturn = S_OK;

    // If BinaryRead has been called, the Form collection is no longer available
    if (m_pRequest->m_pData->m_FormDataStatus != AVAILABLE &&
        m_pRequest->m_pData->m_FormDataStatus != FORMCOLLECTIONONLY)
        {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_REQUEST_FORMCOLLECTION_NA);
        hrReturn = E_FAIL;
        }

    if (m_pRequest->m_pData->m_FormDataStatus == AVAILABLE)
        m_pRequest->m_pData->m_FormDataStatus = FORMCOLLECTIONONLY;


    if (m_pRequest->m_pData->m_fLoadForm)
        {
        if (FAILED(hrReturn = m_pRequest->CopyClientData()))
            goto LExit;

        if (FAILED(hrReturn = m_pRequest->LoadVariables(FORM, m_pRequest->m_pData->m_szFormData, m_pRequest->GetCodePage())))
            goto LExit;

        m_pRequest->m_pData->m_fLoadForm = FALSE;
        }

    *pcValues = m_dwCount;

LExit:
    return hrReturn;
    }

/*===================================================================
CFormInputs::get_Key

Function called from DispInvoke to get keys from the form inputs collection.

Parameters:
    vKey        VARIANT [in], which parameter to get the key of
    pvarReturn  VARIANT *, [out] value of the requested parameter

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/

HRESULT CFormInputs::get_Key(VARIANT varKey, VARIANT *pVar)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    char            *szKey;         // ascii version of the key
    CWCharToMBCS    convKey;
    CRequestHit     *pRequestHit;   // pointer to request bucket
    IDispatch       *pSListReturn;  // value of the key

    // Initialize things
    //
    VariantInit(pVar);
    VARIANT *pvarKey = &varKey;
    V_VT(pVar) = VT_BSTR;
    V_BSTR(pVar) = NULL;
    HRESULT hrReturn = S_OK;

    // Use VariantResolveDispatch which will:
    //
    //     *  Copy BYREF variants for us using VariantCopyInd
    //     *  handle E_OUTOFMEMORY for us
    //     *  get the default value from an IDispatch, which seems
    //        like an appropriate conversion.
    //
    VARIANT varKeyCopy;
    VariantInit(&varKeyCopy);
    DWORD vt = V_VT(pvarKey);

    if ((vt != VT_BSTR) && (vt != VT_I2) && (vt != VT_I4))
        {
        if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
            goto LExit;

        pvarKey = &varKeyCopy;
        }
    vt = V_VT(pvarKey);

    switch (vt)
        {
    // Bug 95201 support all numberic sub-types
    case VT_I1:  case VT_I2:               case VT_I8:
    case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
    case VT_R4:  case VT_R8:
        // Coerce all integral types to VT_I4
        if (FAILED(hrReturn = VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
            goto LExit;

        // fallthru to VT_I4

    case VT_I4:
    case VT_BSTR:
        break;
    default:
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_EXPECTING_STR);
        hrReturn = E_FAIL;
        goto LExit;
        }

    if (m_pRequest->m_pData->m_fLoadForm)
        {
        if (FAILED(hrReturn = m_pRequest->CopyClientData()))
            goto LExit;

        if (FAILED(hrReturn = m_pRequest->LoadVariables(FORM, m_pRequest->m_pData->m_szFormData, m_pRequest->GetCodePage())))
            {
            goto LExit;
            }
        m_pRequest->m_pData->m_fLoadForm = FALSE;
        }

    if (vt == VT_BSTR)
        {
        // convert BSTR version to ANSI version of the key using current Session.CodePage

        if (FAILED(hrReturn = convKey.Init(V_BSTR(pvarKey), m_pRequest->GetCodePage()))) {
            if (hrReturn == E_OUTOFMEMORY) {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                goto LExit;
            }
            hrReturn = NO_ERROR;
			szKey = "";
        }
        else {
            szKey = convKey.GetString();
        }

        pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->FindElem(szKey, strlen(szKey)));
        }
    else
        {
        int iCount;

        iCount = V_I4(pvarKey);

        // BUG 86117 test passes when m_dwCount == 0
        if ( ((iCount < 1) || (iCount > (int) m_dwCount)) || ((iCount > 0) && ((int) m_dwCount == 0)))
            {
            hrReturn = E_FAIL;
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_BAD_ARRAY_INDEX);
            goto LExit;
            }

        pRequestHit = m_rgRequestHit[iCount - 1];
        }

    if (pRequestHit)
        {
        // Create a BSTR containing the key for this variant
        BSTR bstrT = NULL;
        SysAllocStringFromSz((char *)pRequestHit->m_pKey,0,&bstrT,m_pRequest->GetCodePage());
        if (!bstrT)
            return E_OUTOFMEMORY;
        V_BSTR(pVar) = bstrT;
        }
LExit:
    VariantClear(&varKeyCopy);
    return hrReturn;
    }

/*===================================================================
CFormInputs::get__NewEnum

Return a new enumerator
===================================================================*/

HRESULT CFormInputs::get__NewEnum(IUnknown **ppEnumReturn)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    return m_pRequest->GetRequestEnumerator(FORM, ppEnumReturn);
    }

/*------------------------------------------------------------------
 * C C o o k i e s
 */

/*===================================================================
CCookies::CCookies

Constructor

Parameters:
    pRequest        Pointer to main Request object
    pUnkOuter       LPUNKNOWN of a controlling unknown.

Returns:
    Nothing.

Note:
    This object is NOT ref counted since it is created & destroyed
    automatically by C++.
===================================================================*/

CCookies::CCookies(CRequest *pRequest, IUnknown *pUnkOuter)
    : m_ISupportErrImp(this, pUnkOuter, IID_IRequestDictionary)
    {
    m_punkOuter = pUnkOuter;

    if (pRequest)
        pRequest->AddRef();
    m_pRequest = pRequest;

    m_pEmptyCookie = NULL;
    CDispatch::Init(IID_IRequestDictionary);
    }

/*===================================================================
CCookies::CCookies

Destructor

Note:
    This object is NOT ref counted since it is created & destroyed
    automatically by C++.
===================================================================*/
CCookies::~CCookies()
    {
    if (m_pRequest)
        m_pRequest->Release();
    if (m_pEmptyCookie)
        m_pEmptyCookie->Release();
    }


/*===================================================================
CCookies::Init

Initializer

Parameters:
    None

Returns:
    Nothing.
===================================================================*/
HRESULT CCookies::Init()
    {
    return CRequestHitsArray::Init();
    }

/*===================================================================
HRESULT CCookies::ReInit

Parameters:
    None

Returns:
    S_OK
===================================================================*/
HRESULT CCookies::ReInit()
    {
    return CRequestHitsArray::ReInit();
    }

/*===================================================================
CCookies::QueryInterface
CCookies::AddRef
CCookies::Release

IUnknown members for CQueryString object.
===================================================================*/

STDMETHODIMP CCookies::QueryInterface(REFIID iid, void **ppvObj)
    {
    *ppvObj = NULL;

    if (iid == IID_IUnknown || iid == IID_IRequestDictionary || iid == IID_IDispatch)
        *ppvObj = this;

    else if (iid == IID_ISupportErrorInfo)
        *ppvObj = &m_ISupportErrImp;

    if (*ppvObj != NULL)
        {
        static_cast<IUnknown *>(*ppvObj)->AddRef();
        return S_OK;
        }

    return E_NOINTERFACE;
    }


STDMETHODIMP_(ULONG) CCookies::AddRef(void)
    {
    return m_punkOuter->AddRef();
    }


STDMETHODIMP_(ULONG) CCookies::Release(void)
    {
    return m_punkOuter->Release();
    }



/*===================================================================
CCookies::get_Item

Function called from DispInvoke to get values from the Cookies collection.

Parameters:
    vKey        VARIANT [in], which parameter to get the value of - Empty means whole collection
    pvarReturn  VARIANT *, [out] value of the requested parameter

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/

HRESULT CCookies::get_Item(VARIANT varKey, VARIANT *pvarReturn)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    char            *szKey;          // ascii version of the key
    CRequestHit     *pRequestHit;   // pointer to request bucket
    CWCharToMBCS    convKey;

    STACK_BUFFER( tempCookie, 128 );
    // Initialize things
    //
    VariantInit(pvarReturn);
    VARIANT *pvarKey = &varKey;
    HRESULT hrReturn = S_OK;

    // BUG 937: VBScript passes VT_VARIANT|VT_BYREF when passing obect
    //          produced by IEnumVariant
    //
    // Use VariantResolveDispatch which will:
    //
    //     *  Copy BYREF variants for us using VariantCopyInd
    //     *  handle E_OUTOFMEMORY for us
    //     *  get the default value from an IDispatch, which seems
    //        like an appropriate conversion.
    //
    VARIANT varKeyCopy;
    VariantInit(&varKeyCopy);
    DWORD vt = V_VT(pvarKey);

    if ((vt != VT_BSTR) && (vt != VT_I2) && (vt != VT_I4))
        {
        if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
            goto LExit;

        pvarKey = &varKeyCopy;
        }
    vt = V_VT(pvarKey);

    if (m_pRequest->m_pData->m_fLoadCookies)
        {
        char *szCookie = m_pRequest->GetIReq()->QueryPszCookie();
        
        if (FAILED(hrReturn = m_pRequest->LoadVariables(COOKIE, szCookie, m_pRequest->GetCodePage())))
            goto LExit;

        m_pRequest->m_pData->m_fLoadCookies = FALSE;
        }

    switch (vt)
        {
    // Bug 95201 support all numberic sub-types
    case VT_I1:  case VT_I2:               case VT_I8:
    case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
    case VT_R4:  case VT_R8:
        // Coerce all integral types to VT_I4
        if (FAILED(hrReturn = VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
            goto LExit;

        // fallthru to VT_I4

    case VT_I4:
    case VT_BSTR:
        break;

    case VT_ERROR:
        if (V_ERROR(pvarKey) == DISP_E_PARAMNOTFOUND)
            {
            // Dynamically construct value of HTTP_COOKIE.
            //
            // Step 1: figure out how much space we need
            //
            int cbHTTPCookie = 1; // At the least we will need space for '\0'

            for (pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->Head());
                 pRequestHit != NULL;
                 pRequestHit = static_cast<CRequestHit *>(pRequestHit->m_pNext))
                {
                CCookie *pCookie = pRequestHit->m_pCookieData;
                if (pCookie)
                    cbHTTPCookie += pCookie->GetHTTPCookieSize() + pRequestHit->m_cbKey + 1;
                }

            // Allocate space for the HTTP_COOKIE value
            //
            if (cbHTTPCookie > REQUEST_ALLOC_MAX)
                {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_STACK_OVERFLOW);
                hrReturn = E_FAIL;
                goto LExit;
                }
            if (tempCookie.Resize(cbHTTPCookie) == FALSE) {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                hrReturn = E_OUTOFMEMORY;
                goto LExit;
            }
            char *szHTTPCookie = static_cast<char *>(tempCookie.QueryPtr());

            // Step 2: create the value of HTTP_COOKIE
            //
            char *szDest = szHTTPCookie;

            for (pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->Head());
                 pRequestHit != NULL;
                 pRequestHit = static_cast<CRequestHit *>(pRequestHit->m_pNext))
                {
                CCookie *pCookie = pRequestHit->m_pCookieData;
                if (pCookie)
                    {
                    strcpy(szDest, reinterpret_cast<char *>(pRequestHit->m_pKey));
                    szDest = strchr(szDest, '\0');

                    *szDest++ = '=';

                    szDest = pCookie->GetHTTPCookie(szDest);
                    if (pRequestHit->m_pNext)
                        *szDest++ = ';';
                    }
                }
            *szDest = '\0';

            // Now we have the value, so return it.
            //
            BSTR bstrT;
            if (FAILED(SysAllocStringFromSz(szHTTPCookie, 0, &bstrT, m_pRequest->GetCodePage())))
                {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                hrReturn = E_OUTOFMEMORY;
                goto LExit;
                }
            V_VT(pvarReturn) = VT_BSTR;
            V_BSTR(pvarReturn) = bstrT;

            goto LExit;
            }

        // Other error, FALL THROUGH to wrong type case

    default:
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_EXPECTING_STR);
        hrReturn = E_FAIL;
        goto LExit;
        }

    V_VT(pvarReturn) = VT_DISPATCH;
    V_DISPATCH(pvarReturn) = NULL;

    if (vt == VT_BSTR)
        {
        if (FAILED(hrReturn = convKey.Init(V_BSTR(pvarKey),m_pRequest->GetCodePage()))) {
            if (hrReturn == E_OUTOFMEMORY) {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                goto LExit;
            }
            hrReturn = NO_ERROR;
            szKey = "";
        }
        else {
            szKey = convKey.GetString();
        }

        pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->FindElem(szKey, strlen(szKey)));
        }
    else
        {
        // Look up item by index
        int iCount;

        iCount = V_I4(pvarKey);

        // BUG 86117 test passes when m_dwCount == 0
        if ( ((iCount < 1) || (iCount > (int) m_dwCount)) || ((iCount > 0) && ((int) m_dwCount == 0)))
            {
            hrReturn = E_FAIL;
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_BAD_ARRAY_INDEX);
            goto LExit;
            }


        pRequestHit = m_rgRequestHit[iCount - 1];
        }

    if (pRequestHit)
        {
        CCookie *pDictionary = pRequestHit->m_pCookieData;
        if (pDictionary == NULL)
            goto LNotFound;

        if (FAILED(pDictionary->QueryInterface(IID_IReadCookie, reinterpret_cast<void **>(&V_DISPATCH(pvarReturn)))))
            Assert (FALSE);

        goto LExit;
        }

LNotFound: // Return Empty Cookie
    if (!m_pEmptyCookie)
        {
        // create on demand
        if ((m_pEmptyCookie = new CCookie(m_pRequest->GetIReq(), m_pRequest->GetCodePage())) != NULL)
            hrReturn = m_pEmptyCookie->Init();
        else
            hrReturn = E_OUTOFMEMORY;
        }
    if (m_pEmptyCookie)
        hrReturn = m_pEmptyCookie->QueryInterface(IID_IReadCookie, reinterpret_cast<void **>(&V_DISPATCH(pvarReturn)));

LExit:
    VariantClear(&varKeyCopy);
    return hrReturn;
    }

/*===================================================================
CCookies::get_Key

Function called from DispInvoke to get keys from the cookie collection.

Parameters:
    vKey        VARIANT [in], which parameter to get the key of
    pvarReturn  VARIANT *, [out] value of the requested parameter

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/

HRESULT CCookies::get_Key(VARIANT varKey, VARIANT *pVar)
{
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    char            *szKey;         // ascii version of the key
    CWCharToMBCS    convKey;
    CRequestHit     *pRequestHit;   // pointer to request bucket
    IDispatch       *pSListReturn;  // value of the key

    // Initialize things
    //
    VariantInit(pVar);
    VARIANT *pvarKey = &varKey;
    V_VT(pVar) = VT_BSTR;
    V_BSTR(pVar) = NULL;
    HRESULT hrReturn = S_OK;

    // Use VariantResolveDispatch which will:
    //
    //     *  Copy BYREF variants for us using VariantCopyInd
    //     *  handle E_OUTOFMEMORY for us
    //     *  get the default value from an IDispatch, which seems
    //        like an appropriate conversion.
    //
    VARIANT varKeyCopy;
    VariantInit(&varKeyCopy);
    DWORD vt = V_VT(pvarKey);

    if ((vt != VT_BSTR) && (vt != VT_I2) && (vt != VT_I4))
        {
        if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
            goto LExit;

        pvarKey = &varKeyCopy;
        }
    vt = V_VT(pvarKey);

    switch (vt)
        {
    // Bug 95201 support all numberic sub-types
    case VT_I1:  case VT_I2:               case VT_I8:
    case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
    case VT_R4:  case VT_R8:
        // Coerce all integral types to VT_I4
        if (FAILED(hrReturn = VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
            goto LExit;

        // fallthru to VT_I4

    case VT_I4:
    case VT_BSTR:
        break;
    default:
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_EXPECTING_STR);
        hrReturn = E_FAIL;
        goto LExit;
        }

    if (m_pRequest->m_pData->m_fLoadCookies)
        {
        char *szCookie = m_pRequest->GetIReq()->QueryPszCookie();
        
        if (FAILED(hrReturn = m_pRequest->LoadVariables(COOKIE, szCookie, m_pRequest->GetCodePage())))
            goto LExit;

        m_pRequest->m_pData->m_fLoadCookies = FALSE;
        }

    if (vt == VT_BSTR)
        {
        // convert BSTR version to ANSI version of the key using current Session.CodePage

        if (FAILED(hrReturn = convKey.Init(V_BSTR(pvarKey), m_pRequest->GetCodePage()))) {
            if (hrReturn == E_OUTOFMEMORY) {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                goto LExit;
            }
            hrReturn = NO_ERROR;
			szKey = "";
        }
        else {
            szKey = convKey.GetString();
        }

        pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->FindElem(szKey, strlen(szKey)));
        }
    else
        {
        int iCount;

        iCount = V_I4(pvarKey);

        // BUG 86117 test passes when m_dwCount == 0
        if ( ((iCount < 1) || (iCount > (int) m_dwCount)) || ((iCount > 0) && ((int) m_dwCount == 0)))
            {
            hrReturn = E_FAIL;
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_BAD_ARRAY_INDEX);
            goto LExit;
            }

        pRequestHit = m_rgRequestHit[iCount - 1];
        }

    if (pRequestHit)
        {
        // Create a BSTR containing the key for this variant
        BSTR bstrT = NULL;
        SysAllocStringFromSz((char *)pRequestHit->m_pKey,0,&bstrT,m_pRequest->GetCodePage());
        if (!bstrT)
            return E_OUTOFMEMORY;
        V_BSTR(pVar) = bstrT;
        }
LExit:
    VariantClear(&varKeyCopy);
    return hrReturn;
    }

/*===================================================================
CCookies::get_Count

Parameters:
    pcValues - count is stored in *pcValues
===================================================================*/

STDMETHODIMP CCookies::get_Count(int *pcValues)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    HRESULT hrReturn = S_OK;
    
    if (m_pRequest->m_pData->m_fLoadCookies)
        {
        char *szCookie = m_pRequest->GetIReq()->QueryPszCookie();
        
        if (FAILED(hrReturn = m_pRequest->LoadVariables(COOKIE, szCookie, m_pRequest->GetCodePage())))
            goto LExit;

        m_pRequest->m_pData->m_fLoadCookies = FALSE;
        }

    *pcValues = m_dwCount;

LExit:
    return hrReturn;
    }

/*===================================================================
CCookies::get__NewEnum

Return a new enumerator
===================================================================*/

HRESULT CCookies::get__NewEnum(IUnknown **ppEnumReturn)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    return m_pRequest->GetRequestEnumerator(COOKIE, ppEnumReturn);
    }


/*------------------------------------------------------------------
 * C C l C e r t s
 */

/*===================================================================
CClCerts::CClCerts

Constructor

Parameters:
    pRequest        Pointer to main Request object
    pUnkOuter       LPUNKNOWN of a controlling unknown.

Returns:
    Nothing.

Note:
    This object is NOT ref counted since it is created & destroyed
    automatically by C++.
===================================================================*/

CClCerts::CClCerts(CRequest *pRequest, IUnknown *pUnkOuter)
    : m_ISupportErrImp(this, pUnkOuter, IID_IRequestDictionary)
    {
    m_punkOuter = pUnkOuter;

    if (pRequest)
        pRequest->AddRef();
    m_pRequest = pRequest;

    m_pEmptyClCert = NULL;
    CDispatch::Init(IID_IRequestDictionary);
    }

/*===================================================================
CClCerts::ClCerts

Destructor

Note:
    This object is NOT ref counted since it is created & destroyed
    automatically by C++.
===================================================================*/
CClCerts::~CClCerts()
    {
    if (m_pRequest)
        m_pRequest->Release();
    if (m_pEmptyClCert)
        m_pEmptyClCert->Release();
    }

/*===================================================================
CClCerts::Init

Initializer

Parameters:
    None

Returns:
    Nothing.
===================================================================*/
HRESULT CClCerts::Init()
    {
    return CRequestHitsArray::Init();
    }

/*===================================================================
CClCerts::ReInit

Parameters:
    None

Returns:
    S_OK
===================================================================*/
HRESULT CClCerts::ReInit()
    {
    return CRequestHitsArray::ReInit();
    }

/*===================================================================
CClCerts::QueryInterface
CClCerts::AddRef
CClCerts::Release

IUnknown members for CQueryString object.
===================================================================*/

STDMETHODIMP CClCerts::QueryInterface(REFIID riid, void **ppv)
    {
    *ppv = NULL;

    if (riid == IID_IUnknown || riid == IID_IRequestDictionary || riid == IID_IDispatch)
        *ppv = this;

    else if (riid == IID_ISupportErrorInfo)
        *ppv = &m_ISupportErrImp;

    if (*ppv != NULL)
        {
        static_cast<IUnknown *>(*ppv)->AddRef();
        return S_OK;
        }

    return ResultFromScode(E_NOINTERFACE);
    }


STDMETHODIMP_(ULONG) CClCerts::AddRef(void)
    {
    return m_punkOuter->AddRef();
    }


STDMETHODIMP_(ULONG) CClCerts::Release(void)
    {
    return m_punkOuter->Release();
    }



/*===================================================================
CClCerts::get_Item

Function called from DispInvoke to get values from the ClCerts collection.

Parameters:
    vKey        VARIANT [in], which parameter to get the value of - Empty means whole collection
    pvarReturn  VARIANT *, [out] value of the requested parameter

Returns:
    S_OK on success, S_FALSE if key not found, E_FAIL on failure.
===================================================================*/

HRESULT CClCerts::get_Item(VARIANT varKey, VARIANT *pvarReturn)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    char            *szKey;          // ascii version of the key
    CRequestHit     *pRequestHit;   // pointer to request bucket
    CWCharToMBCS    convKey;

    // Initialize things
    //
    VariantInit(pvarReturn);
    VARIANT *pvarKey = &varKey;
    HRESULT hrReturn = S_OK;

    // BUG 937: VBScript passes VT_VARIANT|VT_BYREF when passing obect
    //          produced by IEnumVariant
    //
    // Use VariantResolveDispatch which will:
    //
    //     *  Copy BYREF variants for us using VariantCopyInd
    //     *  handle E_OUTOFMEMORY for us
    //     *  get the default value from an IDispatch, which seems
    //        like an appropriate conversion.
    //
    VARIANT varKeyCopy;
    VariantInit(&varKeyCopy);
    DWORD vt = V_VT(pvarKey);

    if ((vt != VT_BSTR) && (vt != VT_I2) && (vt != VT_I4))
        {
        if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
            goto LExit;

        pvarKey = &varKeyCopy;
        }
    vt = V_VT(pvarKey);

    if (m_pRequest->m_pData->m_fLoadClCerts)
        {
        if (FAILED(hrReturn = m_pRequest->LoadVariables(CLCERT, reinterpret_cast<char *>(m_pRequest->GetIReq()), m_pRequest->GetCodePage())))
            goto LExit;

        m_pRequest->m_pData->m_fLoadClCerts = FALSE;
        }

    switch (vt)
        {
    // Bug 95201 support all numberic sub-types
    case VT_I1:  case VT_I2:               case VT_I8:
    case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
    case VT_R4:  case VT_R8:
        // Coerce all integral types to VT_I4
        if (FAILED(hrReturn = VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
            goto LExit;

        // fallthru to VT_I4

    case VT_I4:
    case VT_BSTR:
        break;

    case VT_ERROR:
        if (V_ERROR(pvarKey) == DISP_E_PARAMNOTFOUND)
            {
            // Dynamically construct value of CLCERT
            //
            // Step 1: figure out how much space we need
            //
            int cbHTTPClCert = 0;

            for (pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->Head());
                 pRequestHit != NULL;
                 pRequestHit = static_cast<CRequestHit *>(pRequestHit->m_pNext))
                {
                CClCert *pClCert = pRequestHit->m_pClCertData;
                if (pClCert)
                    cbHTTPClCert += pClCert->GetHTTPClCertSize() + pRequestHit->m_cbKey + 1;
                }

            STACK_BUFFER( tempClCert, 256);

            if (!tempClCert.Resize(cbHTTPClCert)) {
			    ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                hrReturn = E_OUTOFMEMORY;
                goto LExit;
            }
            char *szHTTPClCert = static_cast<char *>(tempClCert.QueryPtr());

            // Step 2: create the value of CLCERT
            //
            char *szDest = szHTTPClCert;

            for (pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->Head());
                 pRequestHit != NULL;
                 pRequestHit = static_cast<CRequestHit *>(pRequestHit->m_pNext))
                {
                CClCert *pClCert = pRequestHit->m_pClCertData;
                if (pClCert)
                    {
                    strcpy(szDest, reinterpret_cast<char *>(pRequestHit->m_pKey));
                    szDest = strchr(szDest, '\0');

                    *szDest++ = '=';

                    szDest = pClCert->GetHTTPClCert(szDest);
                    if (pRequestHit->m_pNext)
                        *szDest++ = ';';
                    }
                }
            *szDest = '\0';

            // Now we have the value, so return it.
            //
            BSTR bstrT;
            if (FAILED(SysAllocStringFromSz(szHTTPClCert, 0, &bstrT)))
                {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                hrReturn = E_OUTOFMEMORY;
                goto LExit;
                }
            V_VT(pvarReturn) = VT_BSTR;
            V_BSTR(pvarReturn) = bstrT;

            goto LExit;
            }

        // Other error, FALL THROUGH to wrong type case

    default:
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_EXPECTING_STR);
        hrReturn = E_FAIL;
        goto LExit;
        }

    V_VT(pvarReturn) = VT_DISPATCH;
    V_DISPATCH(pvarReturn) = NULL;

    if (vt == VT_BSTR)
        {
        if (FAILED(hrReturn = convKey.Init(V_BSTR(pvarKey)))) {
            if (hrReturn == E_OUTOFMEMORY) {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                goto LExit;
            }
            hrReturn = NO_ERROR;
    		szKey = "";
        }
        else {
            szKey = convKey.GetString();
        }

        pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->FindElem(szKey, strlen(szKey)));
        }
    else
        {
        // Look up item by index
        int iCount;

        iCount = V_I4(pvarKey);

        // BUG 86117 test passes when m_dwCount == 0
        if ( ((iCount < 1) || (iCount > (int) m_dwCount)) || ((iCount > 0) && ((int) m_dwCount == 0)))
            {
            hrReturn = E_FAIL;
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_BAD_ARRAY_INDEX);
            goto LExit;
            }

        pRequestHit = m_rgRequestHit[iCount - 1];
        }

    if (pRequestHit)
        {
        CClCert *pDictionary = pRequestHit->m_pClCertData;
        if (pDictionary == NULL)
            goto LNotFound;

        if (FAILED(pDictionary->QueryInterface(IID_IRequestDictionary, reinterpret_cast<void **>(&V_DISPATCH(pvarReturn)))))
            Assert (FALSE);

        goto LExit;
        }

LNotFound: // Return "Empty"
    if (!m_pEmptyClCert)
        {
        // create on demand
        if ((m_pEmptyClCert = new CClCert) != NULL)
            hrReturn = m_pEmptyClCert->Init();
        else
            hrReturn = E_OUTOFMEMORY;
        }
    if (m_pEmptyClCert)
        hrReturn = m_pEmptyClCert->QueryInterface(IID_IRequestDictionary, reinterpret_cast<void **>(&V_DISPATCH(pvarReturn)));

LExit:
    VariantClear(&varKeyCopy);
    return hrReturn;
    }

/*===================================================================
CClCerts::get_Key

Function called from DispInvoke to get keys from the certificate collection.

Parameters:
    vKey        VARIANT [in], which parameter to get the key of
    pvarReturn  VARIANT *, [out] value of the requested parameter

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/

HRESULT CClCerts::get_Key(VARIANT varKey, VARIANT *pVar)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    char            *szKey;         // ascii version of the key
    CWCharToMBCS    convKey;
    CRequestHit     *pRequestHit;   // pointer to request bucket

    // Initialize things
    //
    VariantInit(pVar);
    VARIANT *pvarKey = &varKey;
    V_VT(pVar) = VT_BSTR;
    V_BSTR(pVar) = NULL;
    HRESULT hrReturn = S_OK;

    // Use VariantResolveDispatch which will:
    //
    //     *  Copy BYREF variants for us using VariantCopyInd
    //     *  handle E_OUTOFMEMORY for us
    //     *  get the default value from an IDispatch, which seems
    //        like an appropriate conversion.
    //
    VARIANT varKeyCopy;
    VariantInit(&varKeyCopy);
    DWORD vt = V_VT(pvarKey);

    if ((vt != VT_BSTR) && (vt != VT_I2) && (vt != VT_I4))
        {
        if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
            goto LExit;

        pvarKey = &varKeyCopy;
        }
    vt = V_VT(pvarKey);

    switch (vt)
        {
    // Bug 95201 support all numberic sub-types
    case VT_I1:  case VT_I2:               case VT_I8:
    case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
    case VT_R4:  case VT_R8:
        // Coerce all integral types to VT_I4
        if (FAILED(hrReturn = VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
            goto LExit;

        // fallthru to VT_I4

    case VT_I4:
    case VT_BSTR:
        break;
    default:
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_EXPECTING_STR);
        hrReturn = E_FAIL;
        goto LExit;
        }

    if (m_pRequest->m_pData->m_fLoadClCerts)
        {
        if (FAILED(hrReturn = m_pRequest->LoadVariables(CLCERT, reinterpret_cast<char *>(m_pRequest->GetIReq()), m_pRequest->GetCodePage())))
            {
            goto LExit;
            }
        m_pRequest->m_pData->m_fLoadClCerts = FALSE;
        }

    if (vt == VT_BSTR)
        {
        // convert BSTR version to ANSI version of the key using current Session.CodePage
        if (FAILED(hrReturn = convKey.Init(V_BSTR(pvarKey), m_pRequest->GetCodePage()))) {
            if (hrReturn == E_OUTOFMEMORY) {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                goto LExit;
            }
            hrReturn = NO_ERROR;
			szKey = "";
        }
        else {
            szKey = convKey.GetString();
        }

        pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->FindElem(szKey, strlen(szKey)));
        }
    else
        {
        int iCount;

        iCount = V_I4(pvarKey);

        // BUG 86117 test passes when m_dwCount == 0
        if ( ((iCount < 1) || (iCount > (int) m_dwCount)) || ((iCount > 0) && ((int) m_dwCount == 0)))
            {
            hrReturn = E_FAIL;
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_BAD_ARRAY_INDEX);
            goto LExit;
            }

        pRequestHit = m_rgRequestHit[iCount - 1];
        }

    if (pRequestHit)
        {
        // Create a BSTR containing the key for this variant
        BSTR bstrT = NULL;
        SysAllocStringFromSz((char *)pRequestHit->m_pKey,0,&bstrT,m_pRequest->GetCodePage());
        if (!bstrT)
            return E_OUTOFMEMORY;
        V_BSTR(pVar) = bstrT;
        }
LExit:
    VariantClear(&varKeyCopy);
    return hrReturn;
    }

/*===================================================================
CClCerts::get_Count

Parameters:
    pcValues - count is stored in *pcValues
===================================================================*/

STDMETHODIMP CClCerts::get_Count(int *pcValues)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    HRESULT hrReturn = S_OK;

    if (m_pRequest->m_pData->m_fLoadClCerts)
        {
        if (FAILED(hrReturn = m_pRequest->LoadVariables(CLCERT, reinterpret_cast<char *>(m_pRequest->GetIReq()), m_pRequest->GetCodePage())))
            {
            goto LExit;
            }
        m_pRequest->m_pData->m_fLoadClCerts = FALSE;
        }

    *pcValues = m_dwCount;

LExit:
    return hrReturn;
    }

/*===================================================================
CClCerts::get__NewEnum

Return a new enumerator
===================================================================*/

HRESULT CClCerts::get__NewEnum(IUnknown **ppEnumReturn)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    return m_pRequest->GetRequestEnumerator(CLCERT, ppEnumReturn);
    }


/*------------------------------------------------------------------
 * C S e r v e r V a r i a b l e s
 */

/*===================================================================
CServerVariables::CServerVariables

Constructor

Parameters:
    pRequest        Pointer to main Request object
    pUnkOuter       LPUNKNOWN of a controlling unknown.

Returns:
    Nothing.

Note:
    This object is NOT ref counted since it is created & destroyed
    automatically by C++.
===================================================================*/

CServerVariables::CServerVariables(CRequest *pRequest, IUnknown *pUnkOuter)
    : m_ISupportErrImp(this, pUnkOuter, IID_IRequestDictionary),
      m_pIterator(NULL)
    {
    m_punkOuter = pUnkOuter;

    if (pRequest)
        pRequest->AddRef();
    m_pRequest = pRequest;

    CDispatch::Init(IID_IRequestDictionary);
    }

/*===================================================================
CServerVariables::~CServerVariables

Destructor

Parameters:
    None

Returns:
    Nothing.

Note:
    This object is NOT ref counted since it is created & destroyed
    automatically by C++.
===================================================================*/

CServerVariables::~CServerVariables( )
    {
    if (m_pRequest)
        m_pRequest->Release();
    if (m_pIterator)
        m_pIterator->Release();
    }

/*===================================================================
CServerVariables::QueryInterface
CServerVariables::AddRef
CServerVariables::Release

IUnknown members for CFormInputs object.
===================================================================*/

STDMETHODIMP CServerVariables::QueryInterface(REFIID iid, void **ppvObj)
    {
    *ppvObj = NULL;

    if (iid == IID_IUnknown || iid == IID_IRequestDictionary || iid == IID_IDispatch)
        *ppvObj = this;

    else if (iid == IID_ISupportErrorInfo)
        *ppvObj = &m_ISupportErrImp;

    if (*ppvObj != NULL)
        {
        static_cast<IUnknown *>(*ppvObj)->AddRef();
        return S_OK;
        }

    return E_NOINTERFACE;
    }


STDMETHODIMP_(ULONG) CServerVariables::AddRef(void)
    {
    return m_punkOuter->AddRef();
    }


STDMETHODIMP_(ULONG) CServerVariables::Release(void)
    {
    return m_punkOuter->Release();
    }



/*===================================================================
CServerVariables::get_Item

Function called from DispInvoke to get values from the ServerVariables
collection.

Parameters:
    vKey        VARIANT [in], which parameter to get the value of
    pvarReturn  VARIANT *, [out] value of the requested parameter

Returns:
    S_OK on success, E_FAIL on failure.

NOTE:
    This code is basically an enacpsulation from the SERVER_GET macro,
    only more efficient, since it only looks up the key once on average
    unfortunately, the only way to get good memory utilization with
    ISAPI is to use _alloca() with lookups, which means we can't
    encapsulate the lookup logic very well.
===================================================================*/

HRESULT CServerVariables::get_Item(VARIANT varKey, VARIANT *pvarReturn)
{

    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    DWORD           dwValSize;             // buffer size

    char            *szKey;                // pointer to ASCII value of varKey
    char            *szValue;              
    WCHAR           *wszValue;              

    BOOL            fSuccess;              // TRUE when call to GetServerVariable succeeds
    UINT            uCodePage = GetACP();
    CWCharToMBCS    convKey;
    BOOL            fUnicodeVar = FALSE;

    STACK_BUFFER( tempVal, 128 );

    dwValSize = tempVal.QuerySize();
    szValue = (char *)tempVal.QueryPtr();
    wszValue = (WCHAR *)tempVal.QueryPtr();

    // Initialize things
    //
    VariantInit(pvarReturn);
    VARIANT *pvarKey = &varKey;
    HRESULT hrReturn = S_OK;

    // BUG 937: VBScript passes VT_VARIANT|VT_BYREF when passing obect
    //          produced by IEnumVariant
    //
    // Use VariantResolveDispatch which will:
    //
    //     *  Copy BYREF variants for us using VariantCopyInd
    //     *  handle E_OUTOFMEMORY for us
    //     *  get the default value from an IDispatch, which seems
    //        like an appropriate conversion.
    //
    VARIANT varKeyCopy;
    VariantInit(&varKeyCopy);
    DWORD vt = V_VT(pvarKey);

    if ((vt != VT_BSTR) && (vt != VT_I2) && (vt != VT_I4)) {
        if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
            goto LExit;

        pvarKey = &varKeyCopy;
    }

    vt = V_VT(pvarKey);
    V_VT(pvarReturn) = VT_DISPATCH;
    V_DISPATCH(pvarReturn) = NULL;      // initial value of Nothing

    switch (vt) {

        // Bug 95201 support all numberic sub-types
        case VT_I1:  case VT_I2:               case VT_I8:
        case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
        case VT_R4:  case VT_R8:
            // Coerce all integral types to VT_I4
            if (FAILED(hrReturn = VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
                goto LExit;

            // fallthru to VT_I4

        case VT_I4:
        case VT_BSTR:
            break;

        case VT_ERROR:
            if (V_ERROR(pvarKey) == DISP_E_PARAMNOTFOUND) {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_NOT_ALLOWED);
                hrReturn = E_FAIL;
                goto LExit;
            }

            // Other error, FALL THROUGH to wrong type case

        default:
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_EXPECTING_STR);
            hrReturn = E_FAIL;
            goto LExit;
    }

    uCodePage = m_pRequest->GetCodePage();

    if (vt == VT_BSTR) {
        if (FAILED(hrReturn = convKey.Init(V_BSTR(pvarKey), uCodePage))) {
            if (hrReturn == E_OUTOFMEMORY) {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                goto LExit;
            }
            hrReturn = NO_ERROR;
            szKey = "";
        }
        else {
            szKey = CharUpperA(convKey.GetString());
        }
    }
    else {
        // Look up item by index
        int iCount;

        iCount = V_I4(pvarKey);

        // We use the CServVarsIterator to manange
        // the count of sv and integer index
        if (!m_pIterator) {
            m_pIterator = new CServVarsIterator;
            if (!m_pIterator) {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                hrReturn = E_OUTOFMEMORY;
                goto LExit;
            }
            m_pIterator->Init(m_pRequest->m_pData->m_pIReq);
        }
        // BUG 86117 test passes when m_dwCount == 0
        if ( ((iCount < 1) || (iCount > (int) m_pIterator->m_cKeys)) || ((iCount > 0) && ((int) m_pIterator->m_cKeys == 0))) {
            hrReturn = E_FAIL;
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_BAD_ARRAY_INDEX);
            goto LExit;
        }
        if (FAILED(hrReturn = convKey.Init(m_pIterator->m_rgwszKeys[iCount - 1], uCodePage))) {
            if (hrReturn == E_OUTOFMEMORY) {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                goto LExit;
            }
            hrReturn = NO_ERROR;
            szKey = "";
        }
        else {
            szKey = CharUpperA(convKey.GetString());
        }
    }

    if (strncmp(convKey.GetString(), "UNICODE_", 7) == 0) {
        fSuccess = false;
        goto SkipLookup;
    }


#if _IIS_6_0

    // in IIS6, there are a number of variables that are UNICODE.  To
    // access them, you simply place UNICODE_ infront of the name.
    // Two approaches could be taken here. One would be to always
    // try for a UNICODE_ var and fallback to the non-UNICODE var
    // if the lookup fails.  This can be costly.  The second, and
    // chosen method here, would be to maintain a list of vars 
    // that have UNICODE_ versions.

    // this char array is declared on the stack and is currently only
    // 32 chars.  It only needs to be as big as the largest UNICODE
    // var name.  Which is UNICODE_UNMAPPED_REMOTE_USER.

    char            szUNICODEName[32];

    // search the list to see if this is one of the UNICODE_ vars.
    // the list is sorted by length of string.  The current list is
    // not all that long, so a sequential search is not that expensive
    // in the scheme of things.

    for (int i=0; 
         (g_sUNICODEVars[i].varLen != -1) 
             && (convKey.GetStringLen() >= g_sUNICODEVars[i].varLen); 
         i++) {

        // the 'for' loop allows in anything which is at least as long
        // as the current entry.  The following 'if' will check for
        // for an exact length match and then a string compare.

        if ((convKey.GetStringLen() == g_sUNICODEVars[i].varLen)
            && (strcmp(convKey.GetString(), g_sUNICODEVars[i].szVarName) == 0)) {

            // if a hit is made, set the fUnicodeVar = TRUE so that the
            // right ISAPI lookup routine is called and the right StringList
            // AddValue is called.

            fUnicodeVar = TRUE;

            // build up the UNICODE_ version into the stack temp array

            strcpyExA(strcpyExA(szUNICODEName,"UNICODE_"),convKey.GetString());

            // reassign the key name to this value

            szKey = szUNICODEName;

            break;
        }
    }
#endif

    fSuccess = fUnicodeVar
                ? m_pRequest->GetIReq()->GetServerVariableW(szKey, wszValue, &dwValSize)
                : m_pRequest->GetIReq()->GetServerVariableA(szKey, szValue, &dwValSize);

    if (!fSuccess && (dwValSize > tempVal.QuerySize())) {
        if (dwValSize > REQUEST_ALLOC_MAX) {
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_STACK_OVERFLOW);
            hrReturn = E_FAIL;
            goto LExit;
        }

        if (tempVal.Resize(dwValSize) == FALSE) {
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
            hrReturn = E_OUTOFMEMORY;
            goto LExit;
        }
        szValue = static_cast<char *>(tempVal.QueryPtr());
        wszValue = static_cast<WCHAR *>(tempVal.QueryPtr());
        fSuccess = fUnicodeVar
                    ? m_pRequest->GetIReq()->GetServerVariableW(szKey, wszValue, &dwValSize)
                    : m_pRequest->GetIReq()->GetServerVariableA(szKey, szValue, &dwValSize);
    }

SkipLookup:

    if (fSuccess) {
        // Create return value
        CStringList *pValue = new CStringList;
        if (pValue == NULL) {
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
            hrReturn = E_OUTOFMEMORY;
            goto LExit;
        }

        // add the value and QueryInterface for IDispatch interface - strdup the input string
        if (FAILED(hrReturn = (fUnicodeVar 
                                  ? pValue->AddValue(wszValue, TRUE)
                                  : pValue->AddValue(szValue, TRUE, uCodePage))))
            goto LExit;

        if (FAILED(pValue->QueryInterface(IID_IDispatch, reinterpret_cast<void **>(&V_DISPATCH(pvarReturn)))))
            Assert (FALSE);

        // Release temporary (QueryInterface AddRef'd)
        pValue->Release();
        goto LExit;
    }
    else {
        if (FAILED(m_pRequest->m_pData->GetEmptyStringList(&V_DISPATCH(pvarReturn))))
            hrReturn = E_FAIL;
    }

LExit:
    VariantClear(&varKeyCopy);
    return hrReturn;
}

/*===================================================================
CServerVariables::get_Key

Function called from DispInvoke to get keys from the server variables collection.

Parameters:
    vKey        VARIANT [in], which parameter to get the key of
    pvarReturn  VARIANT *, [out] value of the requested parameter

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/

HRESULT CServerVariables::get_Key(VARIANT varKey, VARIANT *pVar)
    {
    HRESULT hrReturn = S_OK;
    int iCount = 0;
    BSTR bstrT = NULL;

    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    char            *szKey;         // ascii version of the key
    CRequestHit     *pRequestHit;   // pointer to request bucket
    IDispatch       *pSListReturn;  // value of the key
    CWCharToMBCS    convKey;

    // Initialize things
    //
    VariantInit(pVar);
    VARIANT *pvarKey = &varKey;
    V_VT(pVar) = VT_BSTR;
    V_BSTR(pVar) = NULL;

    // Use VariantResolveDispatch which will:
    //
    //     *  Copy BYREF variants for us using VariantCopyInd
    //     *  handle E_OUTOFMEMORY for us
    //     *  get the default value from an IDispatch, which seems
    //        like an appropriate conversion.
    //
    VARIANT varKeyCopy;
    VariantInit(&varKeyCopy);
    DWORD vt = V_VT(pvarKey);

    if ((vt != VT_BSTR) && (vt != VT_I2) && (vt != VT_I4))
        {
        if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
            goto LExit;

        pvarKey = &varKeyCopy;
        }

    vt = V_VT(pvarKey);

    switch (vt)
        {
    // Bug 95201 support all numberic sub-types
    case VT_I1:  case VT_I2:               case VT_I8:
    case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
    case VT_R4:  case VT_R8:
        // Coerce all integral types to VT_I4
        if (FAILED(hrReturn = VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
            goto LExit;
        vt = V_VT(pvarKey);
        // fallthru to VT_I4

    case VT_I4:
    case VT_BSTR:
        break;

    default:
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_EXPECTING_STR);
        hrReturn = E_FAIL;
        goto LExit;
        }

    // At this point the VT of pvarKey should be VT_I4 or VT_BSTR
    Assert((vt == VT_I4) || (vt == VT_BSTR));

    if (vt == VT_I4)
        {
        // We were passed in a number.
        // Look up the key by integer index

        iCount = V_I4(pvarKey);

        // We use the CServVarsIterator to manange
        // the count of sv and integer index
        if (!m_pIterator)
            {
            m_pIterator = new CServVarsIterator;
            if (!m_pIterator)
                {
                hrReturn = E_OUTOFMEMORY;
                goto LExit;
                }
            m_pIterator->Init(m_pRequest->m_pData->m_pIReq);
            }

        // BUG 86117 test passes when m_dwCount == 0
        if ( ((iCount < 1) || (iCount > (int) m_pIterator->m_cKeys)) || ((iCount > 0) && ((int) m_pIterator->m_cKeys == 0)))
            {
            hrReturn = E_FAIL;
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_BAD_ARRAY_INDEX);
            goto LExit;
            }

        // Create a BSTR containing the key for this variant
        bstrT = SysAllocString(m_pIterator->m_rgwszKeys[iCount - 1]);
        if (!bstrT)
            {
            hrReturn = E_OUTOFMEMORY;
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
            goto LExit;
            }
        }
    else
        {
        // We were passed in a BSTR. Check to see if there
        // is a server variable for this key

        char szBuffer;
        DWORD dwValSize = sizeof(szBuffer);
        UINT uCodePage = m_pRequest->GetCodePage();
        
        if (FAILED(hrReturn = convKey.Init(V_BSTR(pvarKey), uCodePage))) {
            if (hrReturn == E_OUTOFMEMORY) {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                goto LExit;
            }
            hrReturn = NO_ERROR;
            szKey = "";
        }
        else {
            szKey = CharUpperA(convKey.GetString());
        }
        
        BOOL fSuccess = m_pRequest->GetIReq()->GetServerVariableA(szKey, &szBuffer, &dwValSize);

        DWORD dwError = 0;

        if (!fSuccess)
            {
            dwError = GetLastError();
            }

        // If the error was that we had insufficient buffer then
        // there is a server variable for that key

        if (fSuccess || dwError == ERROR_INSUFFICIENT_BUFFER)
            {
            bstrT = SysAllocString(V_BSTR(pvarKey));
            if (!bstrT)
                {
                hrReturn = E_OUTOFMEMORY;
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
                goto LExit;
                }
            }
         else if (dwError != ERROR_INVALID_INDEX)
            {

            // Any other error indicates an unexpected failure

            hrReturn = HRESULT_FROM_WIN32(dwError);
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_UNEXPECTED);
            goto LExit;
            }
        }

    // If we found a key, copy it into the out parmater
    if (bstrT)
        {
        V_BSTR(pVar) = bstrT;
        }

LExit:
    VariantClear(&varKeyCopy);
    return hrReturn;
    }

/*===================================================================
CServerVariables::get_Count

Parameters:
    pcValues - count is stored in *pcValues
===================================================================*/

STDMETHODIMP CServerVariables::get_Count(int *pcValues)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    HRESULT hrReturn = S_OK;

    // We use the CServVarsIterator to manange
    // the count of sv and integer index
    if (!m_pIterator)
        {
        m_pIterator = new CServVarsIterator;
        if (!m_pIterator)
            {
            *pcValues = 0;
            return E_OUTOFMEMORY;
            }
        m_pIterator->Init(m_pRequest->m_pData->m_pIReq);
        }

    *pcValues = m_pIterator->m_cKeys;

    return hrReturn;
    }

/*===================================================================
CServerVariables::get__NewEnum

Return a new enumerator
===================================================================*/

HRESULT CServerVariables::get__NewEnum(IUnknown **ppEnumReturn)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    *ppEnumReturn = NULL;

    CServVarsIterator *pIterator = new CServVarsIterator;
    if (pIterator == NULL)
        {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        return E_OUTOFMEMORY;
        }

    if (FAILED(pIterator->Init(m_pRequest->GetIReq())))
        {
        delete pIterator;
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        return E_OUTOFMEMORY;
        }

    *ppEnumReturn = pIterator;
    return S_OK;
    }


/*------------------------------------------------------------------
 * C R e q u e s t D a t a
 */

/*===================================================================
CRequestData::CRequestData

Constructor

Parameters:
    CRequest *pRequest

Returns:
    Nothing.
===================================================================*/
CRequestData::CRequestData
(
CRequest *pRequest
)
    : m_ISupportErrImp(static_cast<IRequest *>(pRequest), this, IID_IRequest),
      m_QueryString(pRequest, this),
      m_ServerVariables(pRequest, this),
      m_FormInputs(pRequest, this),
      m_Cookies(pRequest, this),
      m_ClCerts(pRequest, this),
      m_cRefs(1)
    {
    m_pIReq = NULL;
    m_pHitObj = NULL;
    m_FormDataStatus = AVAILABLE;
    m_pbAvailableData = NULL;
    m_cbAvailable = 0;
    m_cbTotal = 0;
    m_szFormData = NULL;
    m_cbFormData = 0;
    m_szFormClone = NULL;
    m_szCookie = NULL;
    m_cbCookie = 0;
    m_szClCert = NULL;
    m_cbClCert = 0;
    m_szQueryString = NULL;
    m_fLoadForm = TRUE;
    m_fLoadQuery = TRUE;
    m_fLoadCookies = TRUE;
    m_fLoadClCerts = TRUE;
    m_pEmptyString = NULL;
    }

/*===================================================================
CRequestData::~CRequestData

Destructor

Parameters:

Returns:
    Nothing.
===================================================================*/
CRequestData::~CRequestData()
    {
    CRequestHit *pNukeElem = static_cast<CRequestHit *>
        (
        m_mpszStrings.Head()
        );
    while (pNukeElem != NULL) {
        CRequestHit *pNext = static_cast<CRequestHit *>(pNukeElem->m_pNext);
        delete pNukeElem;
        pNukeElem = pNext;
    }

    m_mpszStrings.UnInit();

    if (m_pEmptyString)
        m_pEmptyString->Release();

    if (m_szFormData)
        free(m_szFormData);

    if (m_szFormClone)
        free(m_szFormClone);

    if (m_szCookie)
        free(m_szCookie);

    if (m_szClCert)
        free(m_szClCert);

    if (m_szQueryString)
        free(m_szQueryString);
    }

/*===================================================================
CRequestData::Init

Init

Parameters:

Returns:
    Nothing.
===================================================================*/
HRESULT CRequestData::Init()
    {
    HRESULT hr = S_OK;

    if (SUCCEEDED(hr))
        hr = m_mpszStrings.Init();

    if (SUCCEEDED(hr))
        hr = m_QueryString.Init();

    if (SUCCEEDED(hr))
        hr = m_FormInputs.Init();

    if (SUCCEEDED(hr))
        hr = m_Cookies.Init();

    if (SUCCEEDED(hr))
        hr = m_ClCerts.Init();

    if (SUCCEEDED(hr))
        hr = m_ServerVariables.Init();

    return hr;
    }

/*===================================================================
CRequestData::ReInit

ReInit -- associate with new CIsapiReqInfo and HitObj

Parameters:

Returns:
    Nothing.
===================================================================*/
HRESULT CRequestData::ReInit
(
CIsapiReqInfo   *pIReq,
CHitObj *pHitObj
)
    {
    CRequestHit *pNukeElem = static_cast<CRequestHit *>
        (
        m_mpszStrings.Head()
        );
    while (pNukeElem != NULL)
        {
        CRequestHit *pNext = static_cast<CRequestHit *>
            (
            pNukeElem->m_pNext
            );
        delete pNukeElem;
        pNukeElem = pNext;
        }
    m_mpszStrings.ReInit();

    m_QueryString.ReInit();
    m_FormInputs.ReInit();
    m_Cookies.ReInit();
    m_ClCerts.ReInit();

    m_pIReq = pIReq;
    m_pHitObj = pHitObj;
    m_fLoadForm = TRUE;
    m_fLoadQuery = TRUE;
    m_fLoadCookies = TRUE;
    m_fLoadClCerts = TRUE;
    m_FormDataStatus = AVAILABLE;

    if (pIReq)
        {
        m_pbAvailableData = pIReq->QueryPbData();
        m_cbAvailable = pIReq->QueryCbAvailable();
        m_cbTotal = pIReq->QueryCbTotalBytes();
        }
    else
        {
        m_pbAvailableData = NULL;
        m_cbAvailable = 0;
        m_cbTotal = 0;
        }

    if (m_szFormData)
        {
        m_szFormData[0] = '\0';
        m_szFormClone[0] = '\0';
        }

    if (m_szCookie)
        m_szCookie[0] = '\0';

    if (m_szClCert)
        m_szClCert[0] = '\0';

    return S_OK;
    }

/*===================================================================
CRequestData::GetEmptyStringList

Get empty string list's IDispatch *
Create empty string list on demand
===================================================================*/
HRESULT CRequestData::GetEmptyStringList
(
IDispatch **ppdisp
)
    {
    if (!m_pEmptyString)
        {
        m_pEmptyString = new CStringList;
        if (!m_pEmptyString)
            {
            *ppdisp = NULL;
            return E_FAIL;
            }
        }
    return m_pEmptyString->QueryInterface(IID_IDispatch, reinterpret_cast<void **>(ppdisp));
    }

/*===================================================================
CRequestData::QueryInterface
CRequestData::AddRef
CRequestData::Release

IUnknown members for CRequestData object.
===================================================================*/
STDMETHODIMP CRequestData::QueryInterface
(
REFIID iid,
void **ppvObj
)
    {
    if (iid == IID_IUnknown)
        {
        *ppvObj = this;
        AddRef();
        return S_OK;
        }
    else
        {
        *ppvObj = NULL;
        return E_NOINTERFACE;
        }
    }

STDMETHODIMP_(ULONG) CRequestData::AddRef()
    {
    return ++m_cRefs;
    }

STDMETHODIMP_(ULONG) CRequestData::Release(void)
    {
    if (--m_cRefs)
        return m_cRefs;
    delete this;
    return 0;
    }


/*------------------------------------------------------------------
 * C R e q u e s t
 */

/*===================================================================
CRequest::CRequest

Constructor

Parameters:
    punkOuter   object to ref count (can be NULL)
===================================================================*/
CRequest::CRequest(IUnknown *punkOuter)
    :
    m_fInited(FALSE),
    m_fDiagnostics(FALSE),
    m_pData(NULL)
    {
    CDispatch::Init(IID_IRequest);

    if (punkOuter)
        {
        m_punkOuter = punkOuter;
        m_fOuterUnknown = TRUE;
        }
    else
        {
        m_cRefs = 1;
        m_fOuterUnknown = FALSE;
        }

#ifdef DBG
    m_fDiagnostics = TRUE;
#endif // DBG
    }

/*===================================================================
CRequest::~CRequest

Destructor

Parameters:
    None

Returns:
    Nothing.
===================================================================*/
CRequest::~CRequest()
    {
    Assert(!m_fInited);
    Assert(m_fOuterUnknown || m_cRefs == 0);  // must have 0 ref count
    }

/*===================================================================
CRequest::CleanUp

Deallocates members and removes m_pData

Parameters:
    None

Returns:
    HRESULT (S_OK)
===================================================================*/
HRESULT CRequest::CleanUp()
    {
    if (m_pData)
        {
        m_pData->Release();
        m_pData = NULL;
        }
    return S_OK;
    }

/*===================================================================
CRequest::Init

Allocates m_pData.
Performs any intiailization of a CRequest that's prone to failure
that we also use internally before exposing the object outside.

Parameters:
    None

Returns:
    S_OK on success.
===================================================================*/

HRESULT CRequest::Init()
    {
    if (m_fInited)
        return S_OK; // already inited

    Assert(!m_pData);

    m_pData = new CRequestData(this);
    if (!m_pData)
        return E_OUTOFMEMORY;

    HRESULT hr = m_pData->Init();

    if (SUCCEEDED(hr))
        m_fInited = TRUE;
    else
        CleanUp();

    return hr;
    }

/*===================================================================
CRequest::UnInit

Remove m_pData. Back to UnInited state

Parameters:
    None

Returns:
    HRESULT
===================================================================*/
HRESULT CRequest::UnInit()
    {
    if (!m_fInited)
        return S_OK; // already uninited

    Assert(m_pData);
    CleanUp();
    Assert(!m_pData);

    m_fInited = FALSE;
    return S_OK;
    }

/*===================================================================
Request::ReInit

Each Request we service will have a new CIsapiReqInfo.
This function is used to set the value of the CIsapiReqInfo.

Parameters:
    CIsapiReqInfo *pIReq       CIsapiReqInfo
    CHitObj *pHitObj          HitObj

Returns:
    HRESULT
===================================================================*/

HRESULT CRequest::ReInit
(
CIsapiReqInfo *pIReq,
CHitObj *pHitObj
)
    {
    Assert(m_fInited);
    Assert(m_pData);

    return m_pData->ReInit(pIReq, pHitObj);
    }

/*===================================================================
CRequest::GetCodePage

GetCodePage from current HitObj

Parameters:

Returns:
    CodePage
===================================================================*/
UINT CRequest::GetCodePage()
    {
    Assert(m_fInited);
    Assert(m_pData);
    Assert(m_pData->m_pHitObj);
    return m_pData->m_pHitObj->GetCodePage();
    }

/*===================================================================
CRequest::LoadCookies

Load the Request map with values from the HTTP_COOKIE variable.

Parameters:
    bstrVar     BSTR, which parameter to get the value of
    pbstrRet    BSTR FAR *, return value of the requested parameter

Returns:
    S_OK on success. E_FAIL on failure.

Bugs:
    This code assumes that dictionary cookies are well-formed.
    If they are not, then the results will be unpredictable.

    The dictionary cookies are gauranteed to be well-formed if
    Response.Cookies is used.  If other means, such as a direct
    use of the <META> tag, or if Response.SetCookie is used, we
    are at the mercy of the script writer.
===================================================================*/

HRESULT CRequest::LoadCookies(char *szData)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT hResult;

    if (szData == NULL)
        return S_OK;

    // Each cookie definition is moved to a buffer so that we don't
    // overwrite the value of HTTP_COOKIE.  We can save a strcpy()
    // call since 'DecodeFromURL' can copy for us.
    //
    size_t cbCookie = strlen(szData) + 1;
    if (m_pData->m_cbCookie == 0)
        m_pData->m_szCookie = static_cast<char *>(malloc(m_pData->m_cbCookie = cbCookie));

    else if (cbCookie > m_pData->m_cbCookie)
        m_pData->m_szCookie = static_cast<char *>(realloc(m_pData->m_szCookie, m_pData->m_cbCookie = cbCookie));

    if (m_pData->m_szCookie == NULL)
        return E_OUTOFMEMORY;

    char *szDest = m_pData->m_szCookie;
    char chDelimiter;           // delimiter that we found to stop the scan

    while (*szData != '\0')
        {
        char *szName, *szPartialValue;

        // Get the cookie name
        chDelimiter = DecodeFromURL(&szData, ";=", szName = szDest, GetCodePage(), FALSE);
        szDest = strchr(szDest, '\0') + 1;

        if (chDelimiter == '=') 
            {
            // if DecodeFromURL stop scanning because of an equal sign, then the browser sent
            // a value for this cookie

            // Get the cookie's value
            chDelimiter = DecodeFromURL(&szData, ";=", szPartialValue = szDest, GetCodePage(), FALSE);
            szDest = strchr(szDest, '\0') + 1;

            // discard the denali session ID
            if (strncmp(szName, SZ_SESSION_ID_COOKIE_PREFIX, CCH_SESSION_ID_COOKIE_PREFIX) == 0)
                {
                // DENALISESSIONID better not have non-alphabetics in it!  expecting
                // termination with ';' or NUL.
                //
                continue;
                }
            }
        else if (*szName == '\0')
            {
            continue;
            }
        else
            {
            // either we hit a ';' char or end of string.  In either case, this indicates that
            // the cookie has no value.  Set the szPartialValue to an empty string and set the
            // delimiter to ';' to trick the remainder of this function into thinking that the
            // cookie does have a value and that is a simple value (i.e. no sub-cookies).

            chDelimiter = ';';
            szPartialValue = "";
            }

        // Add this cookie to the Request
        CRequestHit *pRequestHit = static_cast<CRequestHit *>(GetStrings()->FindElem(szName, strlen(szName)));
        if (pRequestHit == NULL)
            {
            pRequestHit = new CRequestHit;
            if (pRequestHit == NULL)
                return E_OUTOFMEMORY;

            if (FAILED(pRequestHit->Init(szName))) {
                delete pRequestHit;
                return E_FAIL;
            }

            GetStrings()->AddElem(pRequestHit);

            // This is a new request hit, add it to the array of request hits
            if (!m_pData->m_Cookies.AddRequestHit(pRequestHit))
                {
                return E_OUTOFMEMORY;
                }
            }
        else if (pRequestHit->m_pCookieData)    // a cookie by this name already exists
            {
            if (chDelimiter == '=')                     // eat the rest of this cookie
                DecodeFromURL(&szData, ";", szDest, GetCodePage());    // no need to advance szDest

            continue;                               // discard later cookies
            }

        // The cookie value may be in the form <key1=value1&key2=value2...>
        // or not. If there is an '=' sign present, that lets us know if it
        // is a cookie dictionary or a simple value.
        //
        // We assume that '=' signs that are part of the cookie are escaped in hex.
        //
        if (chDelimiter != '=')
            {
            if (FAILED(hResult = pRequestHit->AddValue(COOKIE, szPartialValue, m_pData->m_pIReq, GetCodePage())))
                return hResult;
            }
        else
            {
            char *szKey = szPartialValue;     // already got the key
            for (;;)
                {
                char *szValue;
                chDelimiter = DecodeFromURL(&szData, ";&", szValue = szDest, GetCodePage(), FALSE);
                szDest = strchr(szDest, '\0') + 1;

                if (FAILED(hResult = pRequestHit->AddKeyAndValue(COOKIE, szKey, szValue, m_pData->m_pIReq, GetCodePage())))
                    return hResult;

                if (chDelimiter == ';' || chDelimiter == '\0')
                    break;

                // get the key, exit when NUL terminator found
                chDelimiter = DecodeFromURL(&szData, "=;", szKey = szDest,  GetCodePage(), FALSE);
                if (chDelimiter == ';' || chDelimiter == '\0')
                    break;

                szDest = strchr(szDest, '\0') + 1;
                }
            }

        }

        return S_OK;
    }


#define CB_CERT_DEFAULT     4096
/*===================================================================
CRequest::LoadClCerts

Load the Request map with values from the CIsapiReqInfo

Parameters:
    szData - ptr to CIsapiReqInfo

Returns:
    S_OK on success. E_FAIL on failure.

===================================================================*/

HRESULT CRequest::LoadClCerts(char *szData, UINT lCodePage)
{
    HRESULT         hres = S_OK;
    CERT_CONTEXT_EX CertContextEx;
    CCertRequest    CertReq( this );

    STACK_BUFFER( tempCert, CB_CERT_DEFAULT );

    ZeroMemory( &CertContextEx, sizeof(CERT_CONTEXT_EX) );
    
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    CIsapiReqInfo *pIReq = reinterpret_cast<CIsapiReqInfo *>(szData);

    // allocate certificate buffer
    CertContextEx.cbAllocated = tempCert.QuerySize();
    CertContextEx.CertContext.pbCertEncoded = static_cast<BYTE *>(tempCert.QueryPtr());

    // get certificate info from web server
    if ( !pIReq->ServerSupportFunction( HSE_REQ_GET_CERT_INFO_EX,
                                       &CertContextEx,
                                       NULL,
                                       NULL ) )
    {
        DWORD   dwErr = GetLastError();

        if ( dwErr == ERROR_INSUFFICIENT_BUFFER )
        {
            // buffer was too small - realloc and call again
            Assert( CertContextEx.cbAllocated < CertContextEx.CertContext.cbCertEncoded );
            CertContextEx.cbAllocated = CertContextEx.CertContext.cbCertEncoded;

            // If CB_CERT_DEFAULT wasn't enough, we want to allocate from the heap, rather then the stack

            if (tempCert.Resize(CertContextEx.cbAllocated) == FALSE) {
                hres = E_OUTOFMEMORY;
                goto LExit;
            }
            CertContextEx.CertContext.pbCertEncoded = static_cast<BYTE *>(tempCert.QueryPtr());

            if ( !pIReq->ServerSupportFunction(
                                               HSE_REQ_GET_CERT_INFO_EX,
                                               &CertContextEx,
                                               NULL,
                                               NULL ) )
            {
                // if we fail a second time, just bail
                // NOTE this should never happen?
                dwErr = GetLastError();
                Assert(dwErr != ERROR_INSUFFICIENT_BUFFER);
                hres = HRESULT_FROM_WIN32(dwErr);
                goto LExit;
            }

        }
        else if ( dwErr == ERROR_INVALID_PARAMETER )
        {
            // not supported (old IIS)
            hres = S_OK;
            goto LExit;
        }
        else
        {
            hres = HRESULT_FROM_WIN32(dwErr);
            goto LExit;
        }
    }

    if(CertContextEx.CertContext.cbCertEncoded == 0)
    {
        hres = CertReq.NoCertificate();
    }
    else
    {
        hres = CertReq.ParseCertificate( CertContextEx.CertContext.pbCertEncoded,
                                         CertContextEx.CertContext.cbCertEncoded,
                                         CertContextEx.CertContext.dwCertEncodingType,
                                         CertContextEx.dwCertificateFlags,
                                         lCodePage );
    }


LExit:
    return hres;

}



/*===================================================================
CRequest::LoadVariables

Load the Request map with values from a URL encoded string

WARNING:  This function modifies the passed szData!!
Note: this is part of bug 682, but we are not going to fix it for
performance reasons.  Just be aware that this function
screws up the passed in string.

Parameters:
    bstrVar     BSTR, which parameter to get the value of
    pbstrRet    BSTR FAR *, return value of the requested parameter
    lCodePage   UINT, the codepage used in retrieving the data

Returns:
    S_OK on success. E_FAIL on failure.
===================================================================*/

HRESULT CRequest::LoadVariables(CollectionType Source, char *szData, UINT lCodePage)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT hResult;

    if (Source == COOKIE)                          // cookies are a special case
        return LoadCookies(szData);                // handle them specially

    if (Source == CLCERT)                          // clcerts are a special case
        return LoadClCerts(szData, lCodePage);     // handle them specially

    if (szData == NULL)         // treat NULL as "no data available"
        return S_OK;

    if (Source == QUERYSTRING) {

        if (m_pData->m_szQueryString) {
            free(m_pData->m_szQueryString);
        }
        if (!(m_pData->m_szQueryString = (char *)malloc(strlen(szData)+1)))
            return E_OUTOFMEMORY;

        strcpy(m_pData->m_szQueryString, szData);
        szData = m_pData->m_szQueryString;
    }
        
    while (*szData != '\0')
        {
        char *szName, *szValue;

        DecodeFromURL(&szData, "=", szName = szData,  lCodePage, FALSE);
        DecodeFromURL(&szData, "&", szValue = szData, lCodePage, FALSE);

        // this is to handle the case where an un-named pair was passed.
        // skip it and process the next named pair
        //
        if(*szName == '\0')
            continue;

        CRequestHit *pRequestHit = static_cast<CRequestHit *>
            (
            GetStrings()->FindElem(szName, strlen(szName))
            );
        if (pRequestHit == NULL)
            {
            pRequestHit = new CRequestHit;
            if (pRequestHit == NULL)
                return E_OUTOFMEMORY;

            if (FAILED(pRequestHit->Init(szName))) {
                delete pRequestHit;
                return E_FAIL;
            }

            GetStrings()->AddElem(pRequestHit);

            // This is a new request hit, so we should add it
            // to the array of request
            if (Source == QUERYSTRING)
                {
                if (!m_pData->m_QueryString.AddRequestHit(pRequestHit))
                    {
                    return E_FAIL;
                    }
                }
            else if (Source == FORM)
                {
                if (!m_pData->m_FormInputs.AddRequestHit(pRequestHit))
                    {
                    return E_FAIL;
                    }
                }
            }

        if (FAILED(hResult = pRequestHit->AddValue(Source, szValue, m_pData->m_pIReq, lCodePage)))
            return hResult;

        }

    return S_OK;
    }

/*===================================================================
CRequest::QueryInterface
CRequest::AddRef
CRequest::Release

IUnknown members for CRequest object.
===================================================================*/

STDMETHODIMP CRequest::QueryInterface(REFIID iid, void **ppvObj)
    {
    *ppvObj = NULL;

    // BUG FIX 683 added IID_IDenaliIntrinsic to prevent the user from
    // storing intrinsic objects in the application and session object
    if (iid == IID_IUnknown || iid == IID_IDispatch || iid == IID_IRequest || iid == IID_IDenaliIntrinsic)
        *ppvObj = static_cast<IRequest *>(this);

    else if (iid == IID_ISupportErrorInfo)
        {
        if (m_pData)
            *ppvObj = &(m_pData->m_ISupportErrImp);
        }
        
    // Support IStream for ADO/XML
    else if (iid == IID_IStream )
        {
        *ppvObj = static_cast<IStream *>(this);
        }

    else if (IID_IMarshal == iid)
        {
        *ppvObj = static_cast<IMarshal *>(this);
        }
        
    if (*ppvObj != NULL)
        {
        static_cast<IUnknown *>(*ppvObj)->AddRef();
        return S_OK;
        }

    return E_NOINTERFACE;
    }


STDMETHODIMP_(ULONG) CRequest::AddRef(void)
    {
    if (m_fOuterUnknown)
        return m_punkOuter->AddRef();

    return InterlockedIncrement((LPLONG)&m_cRefs);
    }

STDMETHODIMP_(ULONG) CRequest::Release(void)
    {
    if (m_fOuterUnknown)
        return m_punkOuter->Release();

    DWORD cRefs = InterlockedDecrement((LPLONG)&m_cRefs);
    if (cRefs)
        return cRefs;

    delete this;
    return 0;
    }

/*===================================================================
CRequest::CheckForTombstone

Tombstone stub for IRequest methods. If the object is
tombstone, does ExceptionId and fails.

Parameters:

Returns:
    HRESULT     E_FAIL  if Tombstone
                S_OK if not
===================================================================*/
HRESULT CRequest::CheckForTombstone()
    {
    if (m_fInited)
        {
        // inited - good object
        Assert(m_pData); // must be present for inited objects
        return S_OK;
        }

    ExceptionId
        (
        IID_IRequest,
        IDE_REQUEST,
        IDE_INTRINSIC_OUT_OF_SCOPE
        );
    return E_FAIL;
    }

/*===================================================================
CRequest::get_QueryString

Return the QueryString dictionary
===================================================================*/

HRESULT CRequest::get_QueryString(IRequestDictionary **ppDictReturn)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    return m_pData->m_QueryString.QueryInterface(IID_IRequestDictionary, reinterpret_cast<void **>(ppDictReturn));
    }


/*===================================================================
CRequest::get_Form

Return the Form dictionary
===================================================================*/

HRESULT CRequest::get_Form(IRequestDictionary **ppDictReturn)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    return m_pData->m_FormInputs.QueryInterface(IID_IRequestDictionary, reinterpret_cast<void **>(ppDictReturn));
    }



/*===================================================================
CRequest::get_Body

Return the Body dictionary (alias for Form dictionary)
===================================================================*/

HRESULT CRequest::get_Body(IRequestDictionary **ppDictReturn)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    return m_pData->m_FormInputs.QueryInterface(IID_IRequestDictionary, reinterpret_cast<void **>(ppDictReturn));
    }



/*===================================================================
CRequest::get_Cookies

Return the Cookies dictionary
===================================================================*/

HRESULT CRequest::get_Cookies(IRequestDictionary **ppDictReturn)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    return m_pData->m_Cookies.QueryInterface(IID_IRequestDictionary, reinterpret_cast<void **>(ppDictReturn));
    }



/*===================================================================
CRequest::get_ClientCertificate

Return the ClCerts dictionary
===================================================================*/

HRESULT CRequest::get_ClientCertificate(IRequestDictionary **ppDictReturn)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    return m_pData->m_ClCerts.QueryInterface(IID_IRequestDictionary, reinterpret_cast<void **>(ppDictReturn));
    }



/*===================================================================
CRequest::get_ServerVariables

Return the Form dictionary
===================================================================*/

HRESULT CRequest::get_ServerVariables(IRequestDictionary **ppDictReturn)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    return m_pData->m_ServerVariables.QueryInterface(IID_IRequestDictionary, reinterpret_cast<void **>(ppDictReturn));
    }



/*===================================================================
CRequest::get_Item

Function called from DispInvoke to get values from any one of four
collections. Search order is "ServerVariables", "QueryString",
"Form", "Cookies", "ClientCertificate"

Parameters:
    bstrVar     BSTR, which parameter to get the value of
    pVarReturn  VARIANT *, return value of the requested parameter

Returns:
    S_OK on success. E_FAIL on failure.
===================================================================*/

HRESULT CRequest::get_Item(BSTR bstrName, IDispatch **ppDispReturn)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (bstrName == NULL)
        {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_EXPECTING_STR);
        return E_FAIL;
        }

    UINT            lCodePage = GetACP();
    CWCharToMBCS    convName;
    char            *szName;

    // If BinaryRead has been called, the Form collection is no longer available
    // so we insist that the script writer specify which collection to use
    if (m_pData->m_FormDataStatus != AVAILABLE &&
        m_pData->m_FormDataStatus != FORMCOLLECTIONONLY)
        {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_REQUEST_GENERICCOLLECTION_NA);
        return E_FAIL;
        }

    // At this point, we are forced to load the QueryString, Form, Cookies
    // and ClientCertificate
    // collections even though it will only come from one of these.
    //
    if (m_pData->m_fLoadQuery)
        {
        // QueryString can contains DBCS string
        lCodePage = GetCodePage();
        if (FAILED(LoadVariables(QUERYSTRING, GetIReq()->QueryPszQueryString(), lCodePage)))
            return E_FAIL;

        m_pData->m_fLoadQuery = FALSE;
        }

    if (m_pData->m_fLoadCookies)
        {
        char *szCookie = GetIReq()->QueryPszCookie();

        if (FAILED(LoadVariables(COOKIE, szCookie, lCodePage)))
            return E_FAIL;

        m_pData->m_fLoadCookies = FALSE;
        }

    if (m_pData->m_fLoadClCerts)
        {
        lCodePage = GetCodePage();
        if (FAILED(LoadVariables(CLCERT, (char*)GetIReq(), lCodePage)))
            return E_FAIL;

        m_pData->m_fLoadClCerts = FALSE;
        }

    if (m_pData->m_fLoadForm)
        {
        HRESULT hrGetData = CopyClientData();
        if (FAILED(hrGetData))
            return hrGetData;

        // Form can contain DBCS string
        lCodePage = GetCodePage();
        if (FAILED(LoadVariables(FORM, m_pData->m_szFormData, lCodePage)))
            return E_FAIL;

        m_pData->m_fLoadForm = FALSE;
        }

    // Convert name to ANSI
    //
    HRESULT hr;
    if (FAILED(hr = convName.Init(bstrName, lCodePage))) {
        if (hr == E_OUTOFMEMORY) {
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
            return hr;
        }
        hr = NO_ERROR;
        szName = "";
    }
    else {
        szName = convName.GetString();
    }
    // Look up the name in the collections
    //
    CRequestHit *pRequestHit = static_cast<CRequestHit *>(GetStrings()->FindElem(szName, strlen(szName)));
    if (pRequestHit)
        {
        IUnknown *pValues = NULL;
        if (pRequestHit->m_pQueryData)
            pValues = pRequestHit->m_pQueryData;

        else if (pRequestHit->m_pFormData)
            pValues = pRequestHit->m_pFormData;

        else if (pRequestHit->m_pCookieData)
            pValues = pRequestHit->m_pCookieData;

        else if (pRequestHit->m_pClCertData)
            pValues = pRequestHit->m_pClCertData;

        if (pValues == NULL)
            goto NotFound;

        if (FAILED(pValues->QueryInterface(IID_IDispatch, reinterpret_cast<void **>(ppDispReturn))))
            return E_FAIL;

        return S_OK;
        }

NotFound:
    // Look in server variables
    VARIANT varKey, varValue;

    V_VT(&varKey) = VT_BSTR;
    V_BSTR(&varKey) = bstrName;

    if (m_pData->m_ServerVariables.get_Item(varKey, &varValue) == S_OK)
        {
        Assert (V_VT(&varValue) == VT_DISPATCH);
        *ppDispReturn = V_DISPATCH(&varValue);

        return S_OK;
        }

    if (FAILED(m_pData->GetEmptyStringList(ppDispReturn)))
        return E_FAIL;

    return S_OK;
    }



/*===================================================================
CRequest::CopyClientData

Load the form data (stdin) by using either ReadClient or the
ISAPI buffer
===================================================================*/

HRESULT CRequest::CopyClientData()
{
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    STACK_BUFFER(tempContent, 1024 );

    CIsapiReqInfo *pIReq = m_pData->m_pIReq;

    // assert that the data is in the format we want
    //
	// we need to scan the content type for the supported header,
	// the client my send multiple headers so use strstr to search
	// the header string this is a HOT_FIX for NT BUG:208530
	//
	if (pIReq->QueryPszContentType())
    {
        size_t cbQueryPszContentType = (strlen(pIReq->QueryPszContentType()) + 1);
        if (cbQueryPszContentType > REQUEST_ALLOC_MAX)
        {
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_STACK_OVERFLOW);
            return E_FAIL;
        }

        if (tempContent.Resize(cbQueryPszContentType) == FALSE) 
        {
            ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
            return E_FAIL;
        }

        CHAR *szQueryPszContentType = _strlwr(
							        strcpy(
								        static_cast<char *>(tempContent.QueryPtr()),
								        pIReq->QueryPszContentType()
								        ));
        if (strstr(szQueryPszContentType, "application/x-www-form-urlencoded") == NULL)
            return S_OK;
    }
	else
		return S_OK;

	//
	// Determine if it is chunked or not.
	//    
    DWORD dwVarSize = 0;
    STACK_BUFFER( varBuff, 128 );    
    
    if (SERVER_GET(pIReq, "HTTP_TRANSFER_ENCODING", &varBuff, &dwVarSize) && 
        (!stricmp(static_cast<char *>(varBuff.QueryPtr()),"chunked")))
            CopyChunkedClientData();    
    else    
        CopyNonChunkedClientData();    

    // Clone the data (LoadVariables will destroy the data)
    
    // Allocate memory for clone. It should theoritically be equal to the size of FormData.        
    m_pData->m_szFormClone = static_cast<char *>(malloc(m_pData->m_cbFormData));
    if (m_pData->m_szFormClone == NULL)
        return E_OUTOFMEMORY;
    
    // Actually perform the copy of data.    
    strcpy(m_pData->m_szFormClone, m_pData->m_szFormData); 

    return S_OK;
}

	
/*===================================================================
CRequest::CopyChunkedClientData

Load the form data (stdin) by using either ReadClient or the
ISAPI buffer. This case is called when Data is being sent in a chunks.
===================================================================*/
HRESULT CRequest::CopyChunkedClientData ()
{
    CIsapiReqInfo *pIReq = m_pData->m_pIReq;
    
    // Try to initially allocate units 4K,16K,32K.... 
    // For the current implementation we shall stop at 32K 
    // Which will bring us to an allocation of (48) +4+8+16+32 +32 +32 + .....
    //
    short int allocUnit = 4096;    // 0001 0000 0000 0000 B

    
    size_t cbFormData = (pIReq->QueryCbAvailable() + 1);

    // Alloc the 4K extra memory.
    cbFormData += allocUnit;
    
    if (m_pData->m_cbFormData == 0)
        m_pData->m_szFormData = static_cast<char *>(malloc(m_pData->m_cbFormData = cbFormData));        // space for data & its clone

    else if (cbFormData > m_pData->m_cbFormData)
        m_pData->m_szFormData = static_cast<char *>(realloc(m_pData->m_szFormData, m_pData->m_cbFormData = cbFormData));

    if (m_pData->m_szFormData == NULL)
        return E_OUTOFMEMORY;

    char * pszOffset;
    // Once we start to read the form data only the form collection can use it
    m_pData->m_FormDataStatus = FORMCOLLECTIONONLY;
    
    memcpy( m_pData->m_szFormData,
            pIReq->QueryPbData(),
            pIReq->QueryCbAvailable() );

    pszOffset = m_pData->m_szFormData + pIReq->QueryCbAvailable();
    DWORD cBytesToRead = allocUnit;
    DWORD cBytesRead = cBytesToRead;    

    //
    // Call ReadClient until we have read all the data
    //
    while (cBytesRead > 0)
    {
        if ((!pIReq->SyncReadClient(pszOffset, &cBytesRead)) || (cBytesRead == 0))
            break;

        cBytesToRead -= cBytesRead;
        if (cBytesToRead == 0)
        {            
            // Dont allocatate anything larger than 32K unit else double the size of the allocation Unit.
            if (allocUnit < 0x8000)                  
                allocUnit = allocUnit << 1;
            
            // Adjust buffer size
            cbFormData += allocUnit;                

            // Allocate new memory.
            m_pData->m_szFormData = static_cast<char *>(realloc(m_pData->m_szFormData, 
                            m_pData->m_cbFormData = cbFormData));
            // Check for out of memory.
            if (m_pData->m_szFormData == NULL)
                return E_OUTOFMEMORY;  

            // Adjust offset.
            pszOffset = m_pData->m_szFormData + cbFormData - allocUnit;
            cBytesToRead = allocUnit;
        }
        else
        {
            pszOffset += cBytesRead;            
        }
        cBytesRead = cBytesToRead;
    }        

    // Adjust cbFormData to read the currect count of data.
    m_pData->m_cbFormData -= cBytesToRead;
    // Add the NULL terminator.
    m_pData->m_szFormData[m_pData->m_cbFormData] = '\0';

    return S_OK;
}
	
/*===================================================================
CRequest::CopyNonChunkedClientData

Load the form data (stdin) by using either ReadClient or the
ISAPI buffer. This case is called when the Content Length is known and 
===================================================================*/
HRESULT CRequest::CopyNonChunkedClientData ()
{
    CIsapiReqInfo *pIReq = m_pData->m_pIReq;
    //
    // Allocate enough space for the form data and a copy
    //
    size_t cbFormData = (pIReq->QueryCbTotalBytes() + 1);

    if (m_pData->m_cbFormData == 0)
        m_pData->m_szFormData = static_cast<char *>(malloc(m_pData->m_cbFormData = cbFormData));        // space for data & its clone

    else if (cbFormData > m_pData->m_cbFormData)
        m_pData->m_szFormData = static_cast<char *>(realloc(m_pData->m_szFormData, m_pData->m_cbFormData = cbFormData));

    if (m_pData->m_szFormData == NULL)
        return E_OUTOFMEMORY;

    char * pszOffset;

    // Once we start to read the form data only the form collection can use it
    m_pData->m_FormDataStatus = FORMCOLLECTIONONLY;

    // Load the data
    //
    if (pIReq->QueryCbTotalBytes() <= pIReq->QueryCbAvailable())
        {
        memcpy( m_pData->m_szFormData,
                pIReq->QueryPbData(),
                pIReq->QueryCbTotalBytes() ); // bytes are available now
        }
    else
        {
        // Some bytes are in the CIsapiReqInfo buffer, we must call ReadClient for others
        // First copy the data in the CIsapiReqInfo buffer
        //
        memcpy( m_pData->m_szFormData,
                pIReq->QueryPbData(),
                pIReq->QueryCbAvailable() );

        DWORD cBytesToRead = pIReq->QueryCbTotalBytes() - pIReq->QueryCbAvailable();
        DWORD cBytesRead = cBytesToRead;
        pszOffset = m_pData->m_szFormData + pIReq->QueryCbAvailable();

        // Call ReadClient until we have read all the data
        //
        while (cBytesToRead > 0)
            {
            if ((!pIReq->SyncReadClient(pszOffset, &cBytesRead)) || (cBytesRead == 0))
                return E_FAIL;
            cBytesToRead -= cBytesRead;
            pszOffset += cBytesRead;
            cBytesRead = cBytesToRead;
            }
        }
    m_pData->m_szFormData[pIReq->QueryCbTotalBytes()] = '\0';


    return S_OK;

}

/*===================================================================
CResponse::GetRequestIterator

Provide a default implementation of get__NewEnum for the Request
collections because most of the collections can use this
implementation.

Parameters:
    Collection - the type of iterator to create
    ppEnumReturn - on return, this points to the new enumeration

Returns:
    Can return E_FAIL or E_OUTOFMEMORY

Side effects:
    None.
===================================================================*/

HRESULT CRequest::GetRequestEnumerator(CollectionType WhichCollection, IUnknown **ppEnumReturn)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    *ppEnumReturn = NULL;

    CRequestIterator *pIterator = new CRequestIterator(this, WhichCollection);
    if (pIterator == NULL)
        {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        return E_OUTOFMEMORY;
        }

    HRESULT hrInit = pIterator->Init();
    if (FAILED(hrInit))
        {
        delete pIterator;
        ExceptionId(IID_IRequestDictionary,
                    IDE_REQUEST,
                    (hrInit == E_OUTOFMEMORY)? IDE_OOM : IDE_UNEXPECTED);
        return hrInit;
        }

    *ppEnumReturn = pIterator;
    return S_OK;
    }

/*===================================================================
CResponse::get_TotalBytes

Presents the number of bytes to expect in the request body

Parameters:
    pcBytes - pointer to long where we will place the number
              of bytes to expect in the request body

Returns:
    Can return E_FAIL

Side effects:
    None.
===================================================================*/

HRESULT CRequest::get_TotalBytes(long *pcbTotal)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (pcbTotal == NULL)
        return E_FAIL;

    Assert(m_pData->m_pIReq);
    *pcbTotal = (long) m_pData->m_pIReq->QueryCbTotalBytes();
    return S_OK;
    }

/*===================================================================
CResponse::BinaryRead

Read bytes from the Request Body to a SafeArray of VT_U1.

Parameters:
    pcBytes     - pointer to long where we will find the number
                  of bytes to read in the request body, and where
                  we will store the number of bytes we read.

     pvarOutput - pointer to variant that will contain the SafeArray we create


Returns:
    Can return E_FAIL or E_OUTOFMEMORY

Side effects:
    Allocates memory.
===================================================================*/

HRESULT CRequest::BinaryRead(VARIANT *pvarCount, VARIANT *pvarReturn)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT hr = S_OK;
    SAFEARRAYBOUND rgsabound[1];
    size_t cbToRead = 0;
    size_t cbRead = 0;
    BYTE *pbData = NULL;

    Assert(m_pData->m_pIReq);
    Assert(pvarCount);
    Assert(pvarReturn);

    // Set the variant type of the output parameter
    V_VT(pvarReturn) = VT_ARRAY|VT_UI1;
    V_ARRAY(pvarReturn) = NULL;

    if (m_pData->m_FormDataStatus == FORMCOLLECTIONONLY)
        {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_REQUEST_BINARYREAD_NA);
		hr = E_FAIL;
		goto error;
        }

    // Convert the byte count variant to a long
    if (FAILED(hr = VariantChangeTypeEx(pvarCount, pvarCount, m_pData->m_pHitObj->GetLCID(), 0,  VT_I4)))
        {
        switch (hr)
            {
            case E_OUTOFMEMORY:
                ExceptionId(IID_IResponse, IDE_REQUEST, IDE_OOM);
                break;
            case DISP_E_OVERFLOW:
                hr = E_FAIL;
                ExceptionId(IID_IResponse, IDE_REQUEST, IDE_RESPONSE_UNABLE_TO_CONVERT);
                break;
            case DISP_E_TYPEMISMATCH:
                ExceptionId(IID_IResponse, IDE_REQUEST, IDE_TYPE_MISMATCH);
                break;
            default:
                ExceptionId(IID_IResponse, IDE_REQUEST, IDE_UNEXPECTED);
            }
            goto error;
        }

    cbToRead = V_I4(pvarCount);
    V_I4(pvarCount) = 0;

	if ((signed long) cbToRead < 0)
		{
		ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_REQUEST_BINREAD_BAD_ARG);
		hr = E_FAIL;
		goto error;
		}


    // If 0 bytes are requested, or available we're done
    if (cbToRead == 0 || m_pData->m_cbTotal == 0)
        return S_OK;

    // Allocate a SafeArray for the data
    // If they've asked for more bytes then the request
    // contains, give them all the bytes in the request.
    rgsabound[0].lLbound = 0;
    if (cbToRead > m_pData->m_cbTotal)
        cbToRead = m_pData->m_cbTotal;

    rgsabound[0].cElements = cbToRead;

    V_ARRAY(pvarReturn) = SafeArrayCreate(VT_UI1, 1, rgsabound);
    if (V_ARRAY(pvarReturn) == NULL)
        {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_OOM);
        hr = E_OUTOFMEMORY;
        goto error;
        }

    if (FAILED(SafeArrayAccessData(V_ARRAY(pvarReturn), (void **) &pbData)))
        {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_UNEXPECTED);
        hr = E_UNEXPECTED;
        goto error;
        }

    // There is no turning back now. The Request.Form collection will
    // no longer be available.
    if (m_pData->m_FormDataStatus == AVAILABLE)
        {
        m_pData->m_FormDataStatus = BINARYREADONLY;
        m_pData->m_fLoadForm = FALSE;
        }

    // If the number of bytes requested is less then the number of
    // bytes available (as maintained by the request object),
    // then copy the requested bytes from the request object copy
    // of the pointer to the CIsapiReqInfo buffer, decrement the number of bytes
    // available, and increment the pointer to the CIsapiReqInfo buffer.
    // Otherwise, copy all available bytes from the CIsapiReqInfo buffer, and
    // then issue a call to ReadClient to get the remaining needed bytes.

    if (cbToRead <= m_pData->m_cbAvailable)
        {
        memcpy(pbData, m_pData->m_pbAvailableData, cbToRead);
        m_pData->m_pbAvailableData += cbToRead;
        m_pData->m_cbAvailable -= cbToRead;
        m_pData->m_cbTotal -= cbToRead;
        V_I4(pvarCount) = cbToRead;
        }
    else
        {
        if (m_pData->m_cbAvailable > 0)
            {
            memcpy(pbData, m_pData->m_pbAvailableData, m_pData->m_cbAvailable);
            V_I4(pvarCount) = m_pData->m_cbAvailable;
            cbToRead -= m_pData->m_cbAvailable;
            m_pData->m_cbTotal -= m_pData->m_cbAvailable;
            pbData += m_pData->m_cbAvailable;
            }
        m_pData->m_pbAvailableData = NULL;
        m_pData->m_cbAvailable = 0;
        while (cbToRead)
            {
            cbRead = cbToRead;
            if (!GetIReq()->SyncReadClient(pbData, (DWORD *)&cbRead) || (cbRead == 0))
                {
                SafeArrayUnaccessData(V_ARRAY(pvarReturn));
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST, IDE_UNEXPECTED);
                hr = E_FAIL;
                goto error;
                }
            pbData += cbRead;
            V_I4(pvarCount) += cbRead;
            m_pData->m_cbTotal -= cbRead;
            cbToRead -= cbRead;
            }
    }

    SafeArrayUnaccessData(V_ARRAY(pvarReturn));
    return S_OK;

error:
    VariantClear(pvarReturn);
    return(hr);
    }


/*===================================================================
IStream implementation for ADO/XML
===================================================================*/

STDMETHODIMP CRequest::Read(
    void *pv,
    ULONG cb,
    ULONG *pcbRead)
{
    if (pv == NULL)
        return E_POINTER;

    ULONG cbReadDummy;
    if (pcbRead == NULL)
        pcbRead = &cbReadDummy;

    if (m_pData->m_FormDataStatus != AVAILABLE &&
        m_pData->m_FormDataStatus != ISTREAMONLY)
    {
        ExceptionId(IID_IRequestDictionary, IDE_REQUEST,
                    IDE_REQUEST_STREAMONLY);
        return E_FAIL;
    }

    // If they've asked for more bytes then the request
    // contains, give them all the bytes in the request.
    if (cb > m_pData->m_cbTotal)
        cb = m_pData->m_cbTotal;

    // There is no turning back now. The Request.Form collection and
    // Request.BinaryRead will no longer be available.
    if (m_pData->m_FormDataStatus == AVAILABLE)
    {
        m_pData->m_FormDataStatus = ISTREAMONLY;
        m_pData->m_fLoadForm = FALSE;
    }

    // If the number of bytes requested is less then the number of
    // bytes available (as maintained by the request object),
    // then copy the requested bytes from the request object copy of
    // the pointer to the CIsapiReqInfo buffer, decrement the number of bytes
    // available, and increment the pointer to the CIsapiReqInfo buffer.
    // Otherwise, copy all available bytes from the CIsapiReqInfo buffer, and
    // then issue a call to ReadClient to get the remaining needed bytes.

    BYTE* pbData = static_cast<BYTE*>(pv);

    if (cb <= m_pData->m_cbAvailable)
    {
        memcpy(pbData, m_pData->m_pbAvailableData, cb);
        m_pData->m_pbAvailableData += cb;
        m_pData->m_cbAvailable -= cb;
        m_pData->m_cbTotal -= cb;
        *pcbRead = cb;
    }
    else
    {
        *pcbRead = 0;
        if (m_pData->m_cbAvailable > 0)
        {
            memcpy(pbData, m_pData->m_pbAvailableData, m_pData->m_cbAvailable);
            *pcbRead = m_pData->m_cbAvailable;
            cb -= m_pData->m_cbAvailable;
            m_pData->m_cbTotal -= m_pData->m_cbAvailable;
            pbData += m_pData->m_cbAvailable;
        }
        m_pData->m_pbAvailableData = NULL;
        m_pData->m_cbAvailable = 0;

        while (cb > 0)
        {
            DWORD cbRead = cb;
            if ((!GetIReq()->SyncReadClient(pbData, &cbRead)) || (cbRead == 0))
            {
                ExceptionId(IID_IRequestDictionary, IDE_REQUEST,
                            IDE_UNEXPECTED);
                return E_FAIL;
            }
            pbData += cbRead;
            *pcbRead += cbRead;
            m_pData->m_cbTotal -= cbRead;
            cb -= cbRead;
        }
    }
    
    return S_OK;
}


STDMETHODIMP CRequest::Write(
    const void *pv,
    ULONG cb,
    ULONG *pcbWritten)
{
    return E_NOTIMPL;
}


STDMETHODIMP CRequest::Seek(
    LARGE_INTEGER dlibMove,
    DWORD dwOrigin,
    ULARGE_INTEGER *plibNewPosition)
{
    // We can only do a seek if we're in the first, pre-read portion of the
    // form data
    if (m_pData->m_pbAvailableData == NULL)
        return E_FAIL;

    BYTE* pbAvailableData;

    switch (dwOrigin)
    {
    case STREAM_SEEK_SET:
        // relative to beginning of stream
        pbAvailableData = m_pData->m_pIReq->QueryPbData() + dlibMove.LowPart;
        break;
    case STREAM_SEEK_CUR:
        // relative to current position in stream
        pbAvailableData = m_pData->m_pbAvailableData + dlibMove.LowPart;
        break;
    case STREAM_SEEK_END:
        // relative to end of stream; not supported
        return E_FAIL;
    };

    // Does the new offset fall within the initial header?
    if (m_pData->m_pIReq->QueryPbData() <= pbAvailableData 
        &&  pbAvailableData < m_pData->m_pIReq->QueryPbData()
                              + m_pData->m_pIReq->QueryCbAvailable())
    {
        DWORD dwDiff = DIFF(pbAvailableData - m_pData->m_pIReq->QueryPbData());
        m_pData->m_pbAvailableData = pbAvailableData;
        m_pData->m_cbAvailable = m_pData->m_pIReq->QueryCbAvailable() - dwDiff;
        m_pData->m_cbTotal = m_pData->m_pIReq->QueryCbTotalBytes() - dwDiff;
        // Return the new position, if wanted
        if (plibNewPosition != NULL)
            plibNewPosition->LowPart = dwDiff;
        return S_OK;
    }

    return E_FAIL;
}

STDMETHODIMP CRequest::SetSize(
    ULARGE_INTEGER libNewSize)
{
    return E_NOTIMPL;
}

STDMETHODIMP CRequest::CopyTo(
    IStream *pstm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER *pcbRead,
    ULARGE_INTEGER *pcbWritten)
{
    return E_NOTIMPL;
}

STDMETHODIMP CRequest::Commit(
    DWORD grfCommitFlags)
{
    return E_NOTIMPL;
}

STDMETHODIMP CRequest::Revert()
{
    return E_NOTIMPL;
}

STDMETHODIMP CRequest::LockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType)
{
    return E_NOTIMPL;
}

STDMETHODIMP CRequest::UnlockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType)
{
    return E_NOTIMPL;
}

STDMETHODIMP CRequest::Stat(
    STATSTG *pstatstg,
    DWORD grfStatFlag)
{
    return E_NOTIMPL;
}

STDMETHODIMP CRequest::Clone(
    IStream **ppstm)
{
    return E_NOTIMPL;
}


#ifdef DBG
/*===================================================================
CRequest::AssertValid

Test to make sure that the CRequest object is currently correctly formed
and assert if it is not.

Returns:

Side effects:
    None.
===================================================================*/
VOID CRequest::AssertValid() const
    {
    }
#endif // DBG



/*===================================================================
HexToChar

Convert two digit hex string to a hex byte

Parameters:
    szHex - pointer to two digit hex string

Return Value:
    the character value of the hex string
===================================================================*/

char HexToChar(LPSTR szHex)
    {
    char chResult, chDigit;

    chDigit = (char)CharUpperA((LPSTR)szHex[0]);
    chResult = (chDigit >= 'A'? (chDigit - 'A' + 0xA) : (chDigit - '0')) << 4;

    chDigit = (char)CharUpperA((LPSTR)szHex[1]);
    chResult |= chDigit >= 'A'? (chDigit - 'A' + 0xA) : (chDigit - '0');

    return chResult;
    }



/*===================================================================
DecodeFromURL

Convert two digit hex string to a hex byte

WARNING:  This function modifies the passed pszSource!!
Note: this is part of bug 682, but we are not going to fix it for
performance reasons.  Just be aware that this function
screws up the passed in string.

Parameters:
    pszSource    - in/out parameter points to a substring in the URL which
                   contains a Name=Value pair
    szDelimiters - a set of delimiters for this field
    szDest       - pointer to buffer to hold the substring

Return Value:
    Returns the actual delimiter that caused parsing to halt.
===================================================================*/

char DecodeFromURL(char **pszSource, char *szDelimiters, char *szDest, UINT uCodePage, BOOL fIgnoreCase)
    {
    char  ch;
    char *szSource = *pszSource;
    char *pszDestStart = szDest;
    CPINFO  CpInfo;
    BOOL    fIschLeadingByte = TRUE;
    BOOL    InvalidPercent = FALSE; 

    GetCPInfo(uCodePage, (LPCPINFO)&CpInfo);

    while ((ch = *szSource++) != '\0' &&
        ((!strchr(szDelimiters, ch) && fIschLeadingByte) || (!fIschLeadingByte))) {
        InvalidPercent = FALSE;
        switch (ch) {
            case ' ':       // skip whitespace - assume that all whitespace
            case '\t':      // that we need is escaped
            case '\r':      // all these chars are out of trailing byte range
            case '\n':
            case '\f':
            case '\v':
                Assert(fIschLeadingByte);
                continue;

            case '+':       // '+' is out of trailing byte range, can never be a trailing byte
                *szDest++ = ' ';
                Assert(fIschLeadingByte);
                break;

            case '%':       // '%' is out of trailing byte range, can never be a trailing byte
                if (*szSource == 'u') {
                    if (isxdigit((UCHAR)*(szSource+1)) && 
                        isxdigit((UCHAR)*(szSource+2)) &&
                        isxdigit((UCHAR)*(szSource+3)) &&
                        isxdigit((UCHAR)*(szSource+4))) {
	                    WCHAR   wch[2];
                        int     cch = 1;
    	                wch[0] =  (UCHAR)HexToChar(&szSource[1]) << 8;
        	            wch[0] |= (UCHAR)HexToChar(&szSource[3]);
            	        szSource += 5;

                        // if the current UNICODE value falls into the
                        // range of valid high-Surrogate, check to see if
                        // the next character is in the low-Surrogate
                        // range.

                        if ((wch[0] >= 0xd800)
                            && (wch[0] <= 0xdbff)
                            && (szSource[0] == '%')
                            && (szSource[1] == 'u')
                            && isxdigit((UCHAR)szSource[2])
                            && isxdigit((UCHAR)szSource[3])
                            && isxdigit((UCHAR)szSource[4])
                            && isxdigit((UCHAR)szSource[5])) {

                            // Well, the current UNICODE value is in the high
                            // range and the next portion of the string is
                            // a UNICODE encoding.  Decode it.

                            wch[1] = (UCHAR)HexToChar(&szSource[2]) << 8;
                            wch[1] |= (UCHAR)HexToChar(&szSource[4]);

                            // Now see if it falls in the range of low-Surrogates

                            if ((wch[1] >= 0xdc00)
                                && (wch[1] <= 0xdfff)) {

                                // it does!!!  Up the number of characters in the
                                // string that WideCharToMultiByte is going to
                                // convert.  And advance the source string past this
                                // location.

                                cch = 2;
                                szSource += 6;
                            }
                        }
                	    szDest += WideCharToMultiByte( uCodePage, 0, wch, cch, szDest, 6, NULL, NULL );
                    } else {
                        // What to do here ?
                        // since we have at least the u char after the %, 
                        // keep the u and let the show go on
                    }
                    break;
                }
                else {
                    if (isxdigit((UCHAR)*szSource) && isxdigit((UCHAR)*(szSource+1))) {
                        ch = HexToChar(szSource);
		                szSource += 2;
                    }
                    else 
                    {
                         // the spurious encoding MUST be removed
                         InvalidPercent = TRUE;
                    }
                }
                // FALL THROUGH to "Normal" case

            default:
                if (fIschLeadingByte == TRUE) {
                    if (CpInfo.MaxCharSize > 1) {
                        // if this is a Leading byte, then, the next one is a trailing byte, we need
                        // not process the next char even the next char is in szDelimiter, next char
                        // is just the second byte of a DBCS char.
                        if (IsDBCSLeadByteEx(uCodePage, ch))
                            fIschLeadingByte = FALSE;
                    }
                }
                else {   // A trailing byte
                    // If we skip a DBCS trailing byte, then, the next char we check is a leading byte
                    Assert(CpInfo.MaxCharSize == 2);
                    fIschLeadingByte = TRUE;
                }
                if (!InvalidPercent) {
                    *szDest++ = ch;
                }
        }
    }

    if (ch == '\0')     // End of String - undo increment of szSource
        --szSource;

    *szDest = '\0';

    if (fIgnoreCase)
        CharUpperA(pszDestStart);

    *pszSource = szSource;

    return ch;
    }




/*------------------------------------------------------------------
 * C S e r v V a r s I t e r a t o r
 */

/*===================================================================
CServVarsIterator::CServVarsIterator

Constructor
===================================================================*/

CServVarsIterator::CServVarsIterator()
    {
    m_rgwszKeys   = NULL;
    m_pwszKey     = NULL;
    m_pwchAllHttp = NULL;
    m_cRefs       = 1;
    m_cKeys       = 0;
    }



/*===================================================================
CServVarsIterator::~CServVarsIterator

Destructor
===================================================================*/

CServVarsIterator::~CServVarsIterator()
    {
    delete m_rgwszKeys;
    delete m_pwchAllHttp;
    }



/*===================================================================
CServVarsIterator::Init

Initialize the iterator by:

    * Getting the value of ALL_HTTP, and parsing it to get the
      extra keys

    * creating a dynamic memory area to hold the ALL_HTTP keys

    * setting m_rgwszKeys by copying pointers from rgwszStandardKeys
      and from ALL_HTTP keys

Parameters:
    pIReq - pointer to CIsapiReqInfo used to query for extra headers

Return Value:
    Returns E_OUTOFMEMORY or S_OK
===================================================================*/

HRESULT CServVarsIterator::Init
(
CIsapiReqInfo *pIReq
)
    {
    static wchar_t *rgwszStandardKeys[] = {
                                            L"ALL_HTTP",
                                            L"ALL_RAW",
                                            L"APPL_MD_PATH",
                                            L"APPL_PHYSICAL_PATH",
                                            L"AUTH_PASSWORD",
                                            L"AUTH_TYPE",
                                            L"AUTH_USER",
                                            L"CERT_COOKIE",
                                            L"CERT_FLAGS",
                                            L"CERT_ISSUER",
                                            L"CERT_KEYSIZE",
                                            L"CERT_SECRETKEYSIZE",
                                            L"CERT_SERIALNUMBER",
                                            L"CERT_SERVER_ISSUER",
                                            L"CERT_SERVER_SUBJECT",
                                            L"CERT_SUBJECT",
                                            L"CONTENT_LENGTH",
                                            L"CONTENT_TYPE",
                                            L"GATEWAY_INTERFACE",
// Purposely left out of IIS 4.0            L"HTTP_CFG_ENC_CAPS",
// Purposely left out of IIS 4.0            L"HTTP_REQ_PWD_EXPIRE",
// Purposely left out of IIS 4.0            L"HTTP_REQ_REALM",
                                            L"HTTPS",
                                            L"HTTPS_KEYSIZE",
                                            L"HTTPS_SECRETKEYSIZE",
                                            L"HTTPS_SERVER_ISSUER",
                                            L"HTTPS_SERVER_SUBJECT",
                                            L"INSTANCE_ID",
                                            L"INSTANCE_META_PATH",
                                            L"LOCAL_ADDR",
                                            L"LOGON_USER",
                                            L"PATH_INFO",
                                            L"PATH_TRANSLATED",
                                            L"QUERY_STRING",
                                            L"REMOTE_ADDR",
                                            L"REMOTE_HOST",
                                            L"REMOTE_USER",
                                            L"REQUEST_METHOD",
// Deleted bogus variable in IIS 4.0        L"SCRIPT_MAP",
                                            L"SCRIPT_NAME",
                                            L"SERVER_NAME",
                                            L"SERVER_PORT",
                                            L"SERVER_PORT_SECURE",
                                            L"SERVER_PROTOCOL",
                                            L"SERVER_SOFTWARE",
// Purposely left out of IIS 4.0            L"UNMAPPED_REMOTE_USER",
                                            L"URL"
                                            };

    const int cStandardKeys = sizeof(rgwszStandardKeys) / sizeof(rgwszStandardKeys[0]);

    // Style note:
    //
    //  pwchExtraKeys points not to just one NUL terminated wide string
    //  but a whole sequence of NUL terminated wide string followed by
    //  a double NUL terminator.  I therefore chose not to use the
    //  standard "wsz" hungarian prefix, instead using "pwch" as
    //  "pointer to wide characters"
    //
    int cwchAlloc = 0, cRequestHeaders = 0;
    DWORD dwHeaderSize = 0;

    STACK_BUFFER( extraKeysBuff, 2048 );

    if (!SERVER_GET(pIReq, "ALL_HTTP", &extraKeysBuff, &dwHeaderSize)) {
        if (GetLastError() == E_OUTOFMEMORY) {
            return E_OUTOFMEMORY;
        }
        else {
            return E_FAIL;
        }
    }

    char            *szExtraKeys = (char *)extraKeysBuff.QueryPtr();
    CMBCSToWChar    convStr;
    HRESULT         hrConvResult;

    if (FAILED(hrConvResult = convStr.Init(szExtraKeys))) {
        return hrConvResult;
    }

    wchar_t *pwchExtraKeys = convStr.GetString();

    CreateKeys(pwchExtraKeys, &cwchAlloc, &cRequestHeaders);

    // At this point, pwchExtraKeys has the strings.  Copy them
    // into more permanent storage.
    //
    if (cwchAlloc)
        {
        Assert(pwchExtraKeys != NULL);
        if ((m_pwchAllHttp = new wchar_t [cwchAlloc]) == NULL)
            return E_OUTOFMEMORY;

        memcpy(m_pwchAllHttp, pwchExtraKeys, cwchAlloc * sizeof(wchar_t));
        }
    else
        m_pwchAllHttp = NULL;

    // Allocate the array of keys, m_rgwszKeys, and copy the standard
    // ISAPI keys, the extra keys from the request headers, and a
    // terminating NULL to easily mark the end of an iteration.
    //
    if ((m_rgwszKeys = new wchar_t *[cStandardKeys + cRequestHeaders + 1]) == NULL)
        return E_OUTOFMEMORY;

    m_cKeys = cStandardKeys + cRequestHeaders;

    wchar_t **pwszKey = m_rgwszKeys;
    int i;

    for (i = 0; i < cStandardKeys; ++i)
        *pwszKey++ = rgwszStandardKeys[i];

    wchar_t *pwch = m_pwchAllHttp;
    for (i = 0; i < cRequestHeaders; ++i)
        {
        *pwszKey++ = pwch;
        pwch = wcschr(pwch, L'\0') + 1;
        }

    // make sure that cRequestHeaders was equal to the actual number of strings
    // in the pwchAllHttp string table.  (Do this by making sure that we stored
    // the exact amount of bytes and are now at the NULL terminator)
    //
    Assert (*pwch == L'\0' && (pwch - m_pwchAllHttp + 1) == cwchAlloc);

    *pwszKey = NULL;                // terminate the array
    return Reset();                 // reset the iterator
    }



/*===================================================================
CServVarsIterator::CreateKeys

Parse the string from Request.ServerVariables["ALL_HTTP"], then
transform the string into a list of NUL terminated wide strings
in place, terminated with a double NUL.

Parameters:
    pwchKeys -
        Input: Contains the value of Request.ServerVariables["ALL_HTTP"]
                as a wide string

        Output: Contains the keys from Request.ServerVariables["ALL_HTTP"],
                each key is separated by a NUL terminator, and the entire
                list of keys is terminated by a double NUL.

    pwchAlloc -
        Output: Contains the number of wide characters that should be
                allocated to contain the entire list of strings pointed
                to by pwchKeys

    pcRequestHeaders -
        Output: Contains the number of keys that were found in
                Request.ServerVariables["ALL_HTTP"].

Return Value:
    None
===================================================================*/

void CServVarsIterator::CreateKeys(wchar_t *pwchKeys, int *pcwchAlloc, int *pcRequestHeaders)
    {
    wchar_t *pwchSrc = pwchKeys;            // source
    wchar_t *pwchDest = pwchKeys;           // destination

    if (pwchKeys == NULL)
        {
        *pcwchAlloc = 0;
        *pcRequestHeaders = 0;
        return;
        }

    // Loop over pwchKeys until we hit the NUL terminator
    //
    *pcRequestHeaders = 0;
    while (*pwchSrc)
        {
        // Copy characters up to the ':' and store in pwchDest
        //
        while (*pwchSrc != L':')
            {
            Assert (*pwchSrc != L'\0');     // better not find End of String yet
            *pwchDest++ = *pwchSrc++;
            }

        // now NUL terminate pwchDest, advance pwchSrc, increment cRequestHeaders
        //
        *pwchDest++ = L'\0';
        ++pwchSrc;
        ++*pcRequestHeaders;

        // Skip characters until we find a \r OR \n
        //
        // If wcspbrk returns NULL here, it means there was no terminating
        // \r or \n.  In this case we can exit the loop because there
        // are no more keys (the value must have ran to the end of the
        // string without termination)
        //
        pwchSrc = wcspbrk(pwchSrc, L"\r\n");
        if (! pwchSrc)
            break;

        // we found either \r OR \n. Skip the remaining whitspace char.
        //
        while (*pwchSrc == L'\r' || *pwchSrc == L'\n')
            ++pwchSrc;

        // pwchSrc now points to the next key.
        }

    // terminate with the final NUL.
    *pwchDest++ = L'\0';
    *pcwchAlloc = DIFF(pwchDest - pwchKeys);
    }



/*===================================================================
CServVarsIterator::QueryInterface
CServVarsIterator::AddRef
CServVarsIterator::Release

IUnknown members for CServVarsIterator object.
===================================================================*/

STDMETHODIMP CServVarsIterator::QueryInterface(REFIID iid, void **ppvObj)
    {
    if (iid == IID_IUnknown || iid == IID_IEnumVARIANT)
        {
        AddRef();
        *ppvObj = this;
        return S_OK;
        }

    *ppvObj = NULL;
    return E_NOINTERFACE;
    }


STDMETHODIMP_(ULONG) CServVarsIterator::AddRef()
    {
    return ++m_cRefs;
    }


STDMETHODIMP_(ULONG) CServVarsIterator::Release()
    {
    if (--m_cRefs > 0)
        return m_cRefs;

    delete this;
    return 0;
    }



/*===================================================================
CServVarsIterator::Clone

Clone this iterator (standard method)

NOTE:
    Cloning this iterator is quite involved.  (It essentially
    involves copying the allocated memory, then adjusting
    ONLY the dynamic pointers in the rgwszKeys array.)

    Right now, this is NYI, as our client (VBScript)
    does not clone this iterator.
===================================================================*/

STDMETHODIMP CServVarsIterator::Clone(IEnumVARIANT **ppEnumReturn)
    {
    return E_NOTIMPL;
    }



/*===================================================================
CServVarsIterator::Next

Get next value (standard method)

To rehash standard OLE semantics:

    We get the next "cElements" from the collection and store them
    in "rgVariant" which holds at least "cElements" items.  On
    return "*pcElementsFetched" contains the actual number of elements
    stored.  Returns S_FALSE if less than "cElements" were stored, S_OK
    otherwise.
===================================================================*/

STDMETHODIMP CServVarsIterator::Next(unsigned long cElementsRequested, VARIANT *rgVariant, unsigned long *pcElementsFetched)
    {
    // give a valid pointer value to 'pcElementsFetched'
    //
    unsigned long cElementsFetched;
    if (pcElementsFetched == NULL)
        pcElementsFetched = &cElementsFetched;

    // Loop through the collection until either we reach the end or
    // cElements becomes zero
    //
    unsigned long cElements = cElementsRequested;
    *pcElementsFetched = 0;

    while (cElements > 0 && *m_pwszKey != NULL)
        {
        BSTR bstrT = SysAllocString(*m_pwszKey);
        if (bstrT == NULL)
            return E_OUTOFMEMORY;
        V_VT(rgVariant) = VT_BSTR;
        V_BSTR(rgVariant) = bstrT;

        ++m_pwszKey;
        ++rgVariant;
        --cElements;
        ++*pcElementsFetched;
        }

    // initialize the remaining variants
    //
    while (cElements-- > 0)
        VariantInit(rgVariant++);

    return (*pcElementsFetched == cElementsRequested)? S_OK : S_FALSE;
    }



/*===================================================================
CServVarsIterator::Skip

Skip items (standard method)

To rehash standard OLE semantics:

    We skip over the next "cElements" from the collection.
    Returns S_FALSE if less than "cElements" were skipped, S_OK
    otherwise.
===================================================================*/

STDMETHODIMP CServVarsIterator::Skip(unsigned long cElements)
    {
    /* Loop through the collection until either we reach the end or
     * cElements becomes zero
     */
    while (cElements > 0 && *m_pwszKey != NULL)
        {
        --cElements;
        ++m_pwszKey;
        }

    return (cElements == 0)? S_OK : S_FALSE;
    }



/*===================================================================
CServVarsIterator::Reset

Reset the iterator (standard method)
===================================================================*/

STDMETHODIMP CServVarsIterator::Reset()
    {
    m_pwszKey = &m_rgwszKeys[0];
    return S_OK;
    }



/*------------------------------------------------------------------
 * C R e q u e s t I t e r a t o r
 */

/*===================================================================
CRequestIterator::CRequestIterator

Constructor

NOTE: CRequest is (currently) not refcounted.  AddRef/Release
      added to protect against future changes.
===================================================================*/

CRequestIterator::CRequestIterator(CRequest *pRequest, CollectionType Collection)
    {
    m_Collection  = Collection;
    m_pRequest    = pRequest;
    m_cRefs       = 1;
    m_pRequestHit = NULL;       // Init() will change this pointer anyway...

    m_pRequest->AddRef();
    }



/*===================================================================
CRequestIterator::CRequestIterator

Destructor
===================================================================*/

CRequestIterator::~CRequestIterator()
    {
    m_pRequest->Release();
    }



/*===================================================================
CRequestIterator::Init

Initialize the iterator by loading the collection that we are
about to iterate over.

Return Value:
    Returns E_FAIL if there were problems loading the collection,
    and possibly E_OUTOFMEMORY.
===================================================================*/

HRESULT CRequestIterator::Init()
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    switch (m_Collection)
        {
    case QUERYSTRING:
        if (m_pRequest->m_pData->m_fLoadQuery)
            {
            if (FAILED(m_pRequest->LoadVariables(QUERYSTRING, m_pRequest->GetIReq()->QueryPszQueryString(), m_pRequest->GetCodePage())))
                return E_FAIL;

            m_pRequest->m_pData->m_fLoadQuery = FALSE;
            }
        break;

    case FORM:
        if (m_pRequest->m_pData->m_fLoadForm)
            {
            HRESULT hrGetData = m_pRequest->CopyClientData();
            if (FAILED(hrGetData))
                return hrGetData;

            if (FAILED(m_pRequest->LoadVariables(FORM, m_pRequest->m_pData->m_szFormData, m_pRequest->GetCodePage())))
                return E_FAIL;

            m_pRequest->m_pData->m_fLoadForm = FALSE;
            }
        break;

    case COOKIE:
        if (m_pRequest->m_pData->m_fLoadCookies)
            {
            char *szCookie = m_pRequest->GetIReq()->QueryPszCookie();

            if (FAILED(m_pRequest->LoadVariables(COOKIE, szCookie, m_pRequest->GetCodePage())))
                return E_FAIL;

            m_pRequest->m_pData->m_fLoadCookies = FALSE;
            }
        break;

    case CLCERT:
        if (m_pRequest->m_pData->m_fLoadClCerts)
            {
            if (FAILED(m_pRequest->LoadVariables(CLCERT, (char*)m_pRequest->GetIReq(), m_pRequest->GetCodePage())))
                return E_FAIL;

            m_pRequest->m_pData->m_fLoadClCerts = FALSE;
            }
        break;
        }

    return Reset();
    }



/*===================================================================
CRequestIterator::QueryInterface
CRequestIterator::AddRef
CRequestIterator::Release

IUnknown members for CRequestIterator object.
===================================================================*/

STDMETHODIMP CRequestIterator::QueryInterface(REFIID iid, void **ppvObj)
    {
    if (iid == IID_IUnknown || iid == IID_IEnumVARIANT)
        {
        AddRef();
        *ppvObj = this;
        return S_OK;
        }

    *ppvObj = NULL;
    return E_NOINTERFACE;
    }


STDMETHODIMP_(ULONG) CRequestIterator::AddRef()
    {
    return ++m_cRefs;
    }


STDMETHODIMP_(ULONG) CRequestIterator::Release()
    {
    if (--m_cRefs > 0)
        return m_cRefs;

    delete this;
    return 0;
    }



/*===================================================================
CRequestIterator::Clone

Clone this iterator (standard method)
===================================================================*/

STDMETHODIMP CRequestIterator::Clone(IEnumVARIANT **ppEnumReturn)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    CRequestIterator *pNewIterator = new CRequestIterator(m_pRequest, m_Collection);
    if (pNewIterator == NULL)
        return E_OUTOFMEMORY;

    // new iterator should point to same location as this.
    pNewIterator->m_pRequestHit = m_pRequestHit;

    *ppEnumReturn = pNewIterator;
    return S_OK;
    }



/*===================================================================
CRequestIterator::Next

Get next value (standard method)

To rehash standard OLE semantics:

    We get the next "cElements" from the collection and store them
    in "rgVariant" which holds at least "cElements" items.  On
    return "*pcElementsFetched" contains the actual number of elements
    stored.  Returns S_FALSE if less than "cElements" were stored, S_OK
    otherwise.
===================================================================*/

STDMETHODIMP CRequestIterator::Next(unsigned long cElementsRequested, VARIANT *rgVariant, unsigned long *pcElementsFetched)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    // give a valid pointer value to 'pcElementsFetched'
    //
    unsigned long cElementsFetched;
    if (pcElementsFetched == NULL)
        pcElementsFetched = &cElementsFetched;

    // Loop through the collection until either we reach the end or
    // cElements becomes zero
    //
    unsigned long cElements = cElementsRequested;
    *pcElementsFetched = 0;

    while (cElements > 0 && m_pRequestHit != NULL)
        {
        BOOL fHaveData = FALSE;
        switch (m_Collection)
            {
        case QUERYSTRING:
            fHaveData = m_pRequestHit->m_pQueryData != NULL;
            break;

        case FORM:
            fHaveData = m_pRequestHit->m_pFormData != NULL;
            break;

        case COOKIE:
            fHaveData = m_pRequestHit->m_pCookieData != NULL;
            break;

        case CLCERT:
            fHaveData = m_pRequestHit->m_pClCertData != NULL;
            }

        if (fHaveData)
            {
            BSTR bstrT;
            if (FAILED(SysAllocStringFromSz(reinterpret_cast<char *>(m_pRequestHit->m_pKey), 0, &bstrT,m_pRequest->GetCodePage())))
                return E_OUTOFMEMORY;
            V_VT(rgVariant) = VT_BSTR;
            V_BSTR(rgVariant) = bstrT;

            ++rgVariant;
            --cElements;
            ++*pcElementsFetched;
            }

        m_pRequestHit = static_cast<CRequestHit *>(m_pRequestHit->m_pPrev);
        }

    // initialize the remaining variants
    //
    while (cElements-- > 0)
        VariantInit(rgVariant++);

    return (*pcElementsFetched == cElementsRequested)? S_OK : S_FALSE;
    }



/*===================================================================
CRequestIterator::Skip

Skip items (standard method)

To rehash standard OLE semantics:

    We skip over the next "cElements" from the collection.
    Returns S_FALSE if less than "cElements" were skipped, S_OK
    otherwise.
===================================================================*/

STDMETHODIMP CRequestIterator::Skip(unsigned long cElements)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    /* Loop through the collection until either we reach the end or
     * cElements becomes zero
     */
    while (cElements > 0 && m_pRequestHit != NULL)
        {
        BOOL fHaveData = FALSE;
        switch (m_Collection)
            {
        case QUERYSTRING:
            fHaveData = m_pRequestHit->m_pQueryData != NULL;
            break;

        case FORM:
            fHaveData = m_pRequestHit->m_pFormData != NULL;
            break;

        case COOKIE:
            fHaveData = m_pRequestHit->m_pCookieData != NULL;
            break;

        case CLCERT:
            fHaveData = m_pRequestHit->m_pClCertData != NULL;
            }

        if (fHaveData)
            --cElements;

        m_pRequestHit = static_cast<CRequestHit *>(m_pRequestHit->m_pPrev);
        }

    return (cElements == 0)? S_OK : S_FALSE;
    }



/*===================================================================
CRequestIterator::Reset

Reset the iterator (standard method)
===================================================================*/

STDMETHODIMP CRequestIterator::Reset()
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    m_pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->Tail());
    return S_OK;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\reg.cpp ===
/*===================================================================
Microsoft IIS Active Server Pages

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Registry stuff

File: reg.cpp

Owner: AndrewS/LeiJin
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#if _IIS_5_1
#include <iadm.h>
#elif _IIS_6_0
#include <iadmw.h>
#else
#error "Neither _IIS_6_0 nor _IIS_5_1 is defined"
#endif

#include "comadmin.h"

#include "memchk.h"

#include "Accctrl.h"
#include "aclapi.h"

#include "iiscnfg.h"

//External functions, defined in glob.cpp
extern HRESULT MDRegisterProperties(void);
extern HRESULT MDUnRegisterProperties(void);
// Globals

const REGSAM samDesired =       KEY_READ | KEY_WRITE;

HRESULT RegisterASPProperties(BOOL fReg = TRUE);



/*
 * Info about our intrinsics used by Register & UnRegister
 */
const char *szClassDesc[] = {  "ASP Response Object",
                               "ASP Request Object",
                               "ASP Request Dictionary",
                               "ASP Server Object",
                               "ASP Application Object",
                               "ASP Session Object",
                               "ASP String List Object",
                               "ASP Read Cookie",
                               "ASP Write Cookie",
                               "ASP Scripting Context Object",
                               "ASP Certificate Object",
                                };

const char *szCLSIDEntry[] = { "CLSID\\{D97A6DA0-A864-11cf-83BE-00A0C90C2BD8}",  // IResponse
                               "CLSID\\{D97A6DA0-A861-11cf-93AE-00A0C90C2BD8}",  // IRequest
                               "CLSID\\{D97A6DA0-A85F-11df-83AE-00A0C90C2BD8}",  // IRequestDictionary
                               "CLSID\\{D97A6DA0-A867-11cf-83AE-01A0C90C2BD8}",  // IServer
                               "CLSID\\{D97A6DA0-A866-11cf-83AE-10A0C90C2BD8}",  // IApplicationObject
                               "CLSID\\{D97A6DA0-A865-11cf-83AF-00A0C90C2BD8}",  // ISessionObject
                               "CLSID\\{D97A6DA0-A85D-11cf-83AE-00A0C90C2BD8}",  // IStringList
                               "CLSID\\{71EAF260-0CE0-11d0-A53E-00A0C90C2091}",  // IReadCookie
                               "CLSID\\{D97A6DA0-A862-11cf-84AE-00A0C90C2BD8}",  // IWriteCookie
                               "CLSID\\{D97A6DA0-A868-11cf-83AE-00B0C90C2BD8}",  // IScriptingContext
                               "CLSID\\{b3192190-1176-11d0-8ce8-00aa006c400c}",  // ICertificate
                               };

const cClassesMax = sizeof(szCLSIDEntry) / sizeof(char *);


/*===================================================================
RegisterIntrinsics

Register info about our intrinsics in the registry.

Returns:
        HRESULT - S_OK on success

Side effects:
        Registers denali objects in the registry
===================================================================*/
HRESULT RegisterIntrinsics(void)
{
        static const char szDenaliDLL[] = "asp.DLL";
        static const char szThreadingModel[] = "ThreadingModel";
        static const char szInprocServer32[] = "InprocServer32";
        static const char szFreeThreaded[] = "Both";
        static const char szProgIdKey[] = "ProgId";
        static const char szCLSIDKey[] = "CLSID";

        HRESULT hr = S_OK;
        char            szPath[MAX_PATH];
        char            *pch;
        HKEY            hkeyCLSID = NULL;
        HKEY            hkeyT = NULL;
        HKEY            hkey2;
        DWORD           iClass;

        // Get the path and name of Denali
        if (!GetModuleFileNameA(g_hinstDLL, szPath, sizeof(szPath)/sizeof(char)))
                return E_FAIL;
        // bug fix 102010 DBCS fixes
        //
        //for (pch = szPath + lstrlen(szPath); pch > szPath && *pch != TEXT('\\'); pch--)
        //      ;
        //if (pch == szPath)

        pch = (char*) _mbsrchr((const unsigned char*)szPath, '\\');
        if (pch == NULL)
                {
                Assert(FALSE);
                goto LErrExit;
                }

        strcpy(pch + 1, szDenaliDLL);

        for (iClass = 0; iClass < cClassesMax; iClass++)
                {
                // install the CLSID key
                // Setting the value of the description creates the key for the clsid
                if ((RegSetValueA(HKEY_CLASSES_ROOT, szCLSIDEntry[iClass], REG_SZ, szClassDesc[iClass],
                        strlen(szClassDesc[iClass])) != ERROR_SUCCESS))
                        goto LErrExit;

                // Open the CLSID key so we can set values on it
                if      (RegOpenKeyExA(HKEY_CLASSES_ROOT, szCLSIDEntry[iClass], 0, samDesired, &hkeyCLSID) != ERROR_SUCCESS)
                        goto LErrExit;

                // install the InprocServer32 key and open the sub-key to set the named value
                if ((RegSetValueA(hkeyCLSID, szInprocServer32, REG_SZ, szPath, strlen(szPath)) != ERROR_SUCCESS))
                        goto LErrExit;

                if ((RegOpenKeyExA(hkeyCLSID, szInprocServer32, 0, samDesired, &hkeyT) != ERROR_SUCCESS))
                        goto LErrExit;

                // install the ThreadingModel named value
                if (RegSetValueExA(hkeyT, szThreadingModel, 0, REG_SZ, (const BYTE *)szFreeThreaded,
                                (strlen(szFreeThreaded)+1) * sizeof(char)) != ERROR_SUCCESS)
                        goto LErrExit;

                if (RegCloseKey(hkeyT) != ERROR_SUCCESS)
                        goto LErrExit;
                hkeyT = NULL;

                RegCloseKey(hkeyCLSID);
                hkeyCLSID = NULL;
                }


        return hr;

LErrExit:
        RegCloseKey(hkeyT);
        RegCloseKey(hkeyCLSID);
        return E_FAIL;
}

/*===================================================================
UnRegisterKey

Given a string which is the name of a key under HKEY_CLASSES_ROOT,
delete everything under that key and the key itself from the registry
(why the heck isnt there an API that does this!?!?)

Returns:
        HRESULT - S_OK on success

Side effects:
        Removes a key & all subkeys from the registry
===================================================================*/
HRESULT UnRegisterKey(CHAR *szKey)
{
        HKEY            hkey = NULL;
        CHAR            szKeyName[255];
        DWORD           cbKeyName;
        LONG            errT;

        // Open the HKEY_CLASSES_ROOT\CLSID\{...} key so we can delete its subkeys
        if      (RegOpenKeyExA(HKEY_CLASSES_ROOT, szKey, 0, samDesired, &hkey) != ERROR_SUCCESS)
                goto LErrExit;

        // Enumerate all its subkeys, and delete them
        while (TRUE)
                {
                cbKeyName = sizeof(szKeyName);
                if ((errT = RegEnumKeyExA(hkey, 0, szKeyName, &cbKeyName, 0, NULL, 0, NULL)) != ERROR_SUCCESS)
                        break;

                if ((errT = RegDeleteKeyA(hkey, szKeyName)) != ERROR_SUCCESS)
                        goto LErrExit;
                }

        // Close the key, and then delete it
        if ((errT = RegCloseKey(hkey)) != ERROR_SUCCESS)
                return(E_FAIL);
        if ((errT = RegDeleteKeyA(HKEY_CLASSES_ROOT, szKey)) != ERROR_SUCCESS)
                {
        DBGPRINTF((DBG_CONTEXT, "Deleting key %s returned %d\n",
                    szKey, GetLastError()));
                return(E_FAIL);
                }

        return S_OK;

LErrExit:
        RegCloseKey(hkey);
        return E_FAIL;
}

/*===================================================================
UnRegisterIntrinsics

UnRegister the info about our intrinsics from the registry.

Returns:
        HRESULT - S_OK on success

Side effects:
        Removes denali objects from the registry
===================================================================*/
HRESULT UnRegisterIntrinsics(void)
{
        HRESULT         hr = S_OK, hrT;
        DWORD           iClass;

        // Now delete the keys for the objects
        for (iClass = 0; iClass < cClassesMax; iClass++)
                {
                // Open the HKEY_CLASSES_ROOT\CLSID\{...} key so we can delete its subkeys
                if (FAILED(hrT = UnRegisterKey((CHAR *)szCLSIDEntry[iClass])))
                        hr = hrT;       // Hold onto the error, but keep going

                }

        return hr;
}


/*===================================================================
RegisterTypeLib

Register denali typelib in the registry.

Returns:
        HRESULT - S_OK on success

Side effects:
        register denali typelib in the registry
===================================================================*/
HRESULT RegisterTypeLib(void)
{
        HRESULT hr;
        ITypeLib *pITypeLib = NULL;

        char szFile[MAX_PATH+4];

        BSTR    bstrFile;

        // Get the path and name of Denali
        if (!GetModuleFileNameA(g_hinstDLL, szFile, MAX_PATH))
                return E_FAIL;

        // There are two type libraries: First the standard ASP typelib
        //              then the typelib for the Transacted Script Context object.
        //              Load them both.

        // First type lib, from default (first ITypeLib entry) location
        hr = SysAllocStringFromSz(szFile, 0, &bstrFile);
        if (FAILED(hr))
                return hr;

        hr = LoadTypeLibEx(bstrFile, REGKIND_REGISTER, &pITypeLib);
        if (pITypeLib) {
            pITypeLib->Release();
            pITypeLib = NULL;
        }

        SysFreeString(bstrFile);

        if (FAILED(hr))
            return hr;

        // now register the Transacted Script Context Object

        strcat(szFile, "\\2");

        hr = SysAllocStringFromSz(szFile, 0, &bstrFile);
        if (FAILED(hr))
            return hr;

        hr = LoadTypeLibEx(bstrFile, REGKIND_REGISTER, &pITypeLib);
        if (pITypeLib) {
            pITypeLib->Release();
            pITypeLib = NULL;
        }

        SysFreeString(bstrFile);

        return hr;
}
/*===================================================================
UnRegisterTypeLib

UnRegister denali typelib in the registry.  Note: Only the current version used by asp.dll is removed.

Returns:
        HRESULT - S_OK on success

Side effects:
        unregister denali typelib in the registry
===================================================================*/
HRESULT UnRegisterTypeLib(void)
{
    HRESULT hr;
    ITypeLib *pITypeLib = NULL;
    TLIBATTR *pTLibAttr = NULL;

    char    szFile[MAX_PATH + 4];
    BSTR    bstrFile;

    // Get the path and name of Denali
    if (!GetModuleFileNameA(g_hinstDLL, szFile, MAX_PATH))
            return E_FAIL;

    hr = SysAllocStringFromSz(szFile, 0, &bstrFile);
    if (FAILED(hr))
            return hr;

    hr = LoadTypeLibEx(bstrFile, REGKIND_REGISTER, &pITypeLib);
    if(SUCCEEDED(hr) && pITypeLib) 
    {
        hr = pITypeLib->GetLibAttr(&pTLibAttr);
        if(SUCCEEDED(hr) && pTLibAttr)
        {
            hr = UnRegisterTypeLib( pTLibAttr->guid,
                                    pTLibAttr->wMajorVerNum,
                                    pTLibAttr->wMinorVerNum,
                                    pTLibAttr->lcid,
                                    pTLibAttr->syskind);

            pITypeLib->ReleaseTLibAttr(pTLibAttr);
            pTLibAttr = NULL;
        }
        pITypeLib->Release();
        pITypeLib = NULL;
    }

    SysFreeString(bstrFile);

    // unregister the Txn typelib
    strcat(szFile, "\\2");

    hr = SysAllocStringFromSz(szFile, 0, &bstrFile);
    if (FAILED(hr))
            return hr;

    hr = LoadTypeLibEx(bstrFile, REGKIND_REGISTER, &pITypeLib);
    if(SUCCEEDED(hr) && pITypeLib) 
    {
        hr = pITypeLib->GetLibAttr(&pTLibAttr);
        if(SUCCEEDED(hr) && pTLibAttr)
        {
            hr = UnRegisterTypeLib( pTLibAttr->guid,
                                    pTLibAttr->wMajorVerNum,
                                    pTLibAttr->wMinorVerNum,
                                    pTLibAttr->lcid,
                                    pTLibAttr->syskind);

            pITypeLib->ReleaseTLibAttr(pTLibAttr);
            pTLibAttr = NULL;
        }
        pITypeLib->Release();
        pITypeLib = NULL;
    }

    SysFreeString(bstrFile);

    return hr;
}

HRESULT  GetIWAMAccountName(LPSTR   pszIdentity,
                            DWORD    cbIdentity)
{

    HRESULT         hr = S_OK;
  	IMSAdminBase	*pMetabase = NULL;
	METADATA_HANDLE hMetabase = NULL;
	METADATA_RECORD	recMetaData;
    DWORD           dwRequiredLen;
    CWCharToMBCS    convStr;

	MD_SET_DATA_RECORD(	&recMetaData, 
                        MD_WAM_USER_NAME, 
                        METADATA_NO_ATTRIBUTES, 
                        IIS_MD_UT_WAM,
						STRING_METADATA,  
                        cbIdentity, 
                        pszIdentity);

   	if (FAILED(hr = CoCreateInstance(CLSID_MSAdminBase, 
                                     NULL, 
                                     CLSCTX_SERVER, 
                                     IID_IMSAdminBase, 
                                     (void **)&pMetabase)));
		
	// Open key to the Web service, and get a handle of \LM\w3svc
	else if (FAILED(hr = pMetabase->OpenKey(METADATA_MASTER_ROOT_HANDLE, 
                                            (LPWSTR)(L"\\LM\\W3SVC"),
							                METADATA_PERMISSION_READ | METADATA_PERMISSION_WRITE,
							                30000, 
                                            &hMetabase)));

    // get the data.  This will return the IWAM username in the caller
    // supplied buffer.  The name will be UNICODE.

    else if (FAILED(hr = pMetabase->GetData(hMetabase, 
                                            NULL, 
                                            &recMetaData, 
                                            &dwRequiredLen)));

    // convert the string to MBCS using the CP_ACP

    else if (FAILED(hr = convStr.Init((LPWSTR)pszIdentity)));

    // overwrite the caller's memory with the converted string

    else strcpy(pszIdentity, convStr.GetString());

    // cleanup

    if (hMetabase && pMetabase)
        pMetabase->CloseKey(hMetabase);

    if (pMetabase)
        pMetabase->Release();

    return(hr);
}

HRESULT CreateCompiledTemplatesTempDir()
{
    HRESULT                 hr = S_OK;
	BYTE                    szRegString[MAX_PATH];
    BYTE                    pszExpanded[MAX_PATH];
    int                     result = 0;
    EXPLICIT_ACCESSA        ea[3];
    PACL                    pNewDACL = NULL;
    char                    szWamIdentity[1024];
    SID_IDENTIFIER_AUTHORITY    NtAuthority = SECURITY_NT_AUTHORITY;

    // read the temp dir name for the persistant templ
    // cache.

    CchLoadStringOfId(IDS_DEFAULTPERSISTDIR, (LPSTR)szRegString, MAX_PATH);

    result = ExpandEnvironmentStringsA((LPCSTR)szRegString,
                                       (LPSTR)pszExpanded,
                                       MAX_PATH);  
    
    if ((result <= MAX_PATH) && (result > 0)) {
        CreateDirectoryA((LPCSTR)pszExpanded,NULL);        
    }

    // this next section of code will place the SYSTEM and IWAM_<ComputerName>
    // ACEs on the directorie's ACL

    ZeroMemory(ea, sizeof(EXPLICIT_ACCESSA) * 3);
    
    ea[0].grfAccessPermissions = SYNCHRONIZE | GENERIC_ALL;
    ea[0].grfAccessMode = GRANT_ACCESS;
    ea[0].grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ea[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;

    ea[1].grfAccessPermissions = SYNCHRONIZE | GENERIC_ALL;
    ea[1].grfAccessMode = GRANT_ACCESS;
    ea[1].grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ea[1].Trustee.TrusteeForm = TRUSTEE_IS_NAME;
    ea[1].Trustee.ptstrName = szWamIdentity;

    ea[2].grfAccessPermissions = SYNCHRONIZE | GENERIC_ALL;
    ea[2].grfAccessMode = GRANT_ACCESS;
    ea[2].grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ea[2].Trustee.TrusteeForm = TRUSTEE_IS_SID;

    // go get the IWAM account name from the metabase

    if (FAILED(hr = GetIWAMAccountName(szWamIdentity, sizeof(szWamIdentity))));

    // build the new DACL with just these ACEs

    else if (!AllocateAndInitializeSid(&NtAuthority,
                                       1,
                                       SECURITY_LOCAL_SYSTEM_RID,
                                       0,0,0,0,0,0,0,
                                       (PSID *)(&ea[0].Trustee.ptstrName)))

        hr = HRESULT_FROM_WIN32(GetLastError());

    else if (!AllocateAndInitializeSid(&NtAuthority,
                                       2,            // 2 sub-authorities
                                       SECURITY_BUILTIN_DOMAIN_RID,
                                       DOMAIN_ALIAS_RID_ADMINS,
                                       0,0,0,0,0,0,
                                       (PSID *)(&ea[2].Trustee.ptstrName)))

        hr = HRESULT_FROM_WIN32(GetLastError());

    else if ((hr = SetEntriesInAclA(3, 
                                    ea, 
                                    NULL, 
                                    &pNewDACL)) != ERROR_SUCCESS);

    // set the ACL on the directory

    else hr = SetNamedSecurityInfoA((LPSTR)pszExpanded,
                                    SE_FILE_OBJECT,
                                    DACL_SECURITY_INFORMATION | PROTECTED_DACL_SECURITY_INFORMATION,
                                    NULL,
                                    NULL,
                                    pNewDACL,
                                    NULL);
    if (pNewDACL)
        LocalFree(pNewDACL);

    if (ea[0].Trustee.ptstrName)
        FreeSid(ea[0].Trustee.ptstrName);

    if (ea[2].Trustee.ptstrName)
        FreeSid(ea[2].Trustee.ptstrName);

    return(hr);
}

/*===================================================================
DllRegisterServer

Entry point used by RegSvr32.exe to register the DLL.

Returns:
        HRESULT - S_OK on success

Side effects:
        Registers denali objects in the registry
===================================================================*/
STDAPI DllRegisterServer(void)
        {
        HRESULT             hr;
        HRESULT             hrCoInit;

        hrCoInit = CoInitialize(NULL);

    // First try to unregister some stuff
    // This is important when we are registering on top of
    // an old IIS 3.0 Denali registration
    // Don't care if fails
        UnRegisterEventLog();
        UnRegisterIntrinsics();
        UnRegisterTypeLib();


    // Now do the registration

        if (FAILED(hr = MDRegisterProperties()))
                goto LErr;

        // Register NT event log
        if(FAILED(hr = RegisterEventLog()))
                goto LErr;

        if (FAILED(hr = RegisterTypeLib()))
                goto LErr;

        // Register our intrinsics
        if (FAILED(hr = RegisterIntrinsics()))
                goto LErr;

        if(FAILED(hr = RegisterASPProperties(TRUE)))
                goto LErr;

        if (FAILED(hr = CreateCompiledTemplatesTempDir()))
            goto LErr;

LErr:
        if (SUCCEEDED(hrCoInit))
                CoUninitialize();
        return(hr);
        }

/*===================================================================
DllUnregisterServer

Entry point used by RegSvr32.exe to unregister the DLL.

Returns:
        HRESULT - S_OK on success

Side effects:
        Removes denali registrations from the registry
===================================================================*/
STDAPI DllUnregisterServer(void)
        {
        HRESULT hr = S_OK, hrT;
        HRESULT hrCoInit;

        hrCoInit = CoInitialize(NULL);

        hrT = UnRegisterEventLog();
        if (FAILED(hrT))
                hr = hrT;

        hrT = MDUnRegisterProperties();
        if (FAILED(hrT))
                hr = hrT;

        hrT = UnRegisterIntrinsics();
        if (FAILED(hrT))
                hr = hrT;

        hrT = UnRegisterTypeLib();
        if (FAILED(hrT))
                hr = hrT;

        hrT = RegisterASPProperties(FALSE);
        if (FAILED(hrT))
                hr = hrT;


        // UNDONE BUG 80063: Ignore errors from this call
#ifdef UNDONE
        if (FAILED(hrT))
                hr = hrT;
#endif


        if (SUCCEEDED(hrCoInit))
                CoUninitialize();

        return(hr);
        }

/*===================================================================
RegisterASPProperties

Entry point used by RegSvr32.exe to register and unregister
ASP setting stored in the SYSTEM registry.

Parameters
        fReg    = TRUE  - to register
                          FALSE - to unregister
Returns:
        HRESULT - S_OK on success

Side effects:
        Removes denali registrations from the registry
===================================================================*/

HRESULT RegisterASPProperties(BOOL fReg)
        {
        HKEY    hkey1 = NULL, hkey2 = NULL;
        DWORD   iValue;
        LONG    lT;

        static const char szW3SVC[]    = "System\\CurrentControlSet\\Services\\W3SVC";
        static const char szW3SVCASP[] = "System\\CurrentControlSet\\Services\\W3SVC\\ASP\\Parameters";
        static const char szASPParm[]  = "ASP\\Parameters";

        BYTE    szDefailtString[1024];


        // Open the key for W3SVCASP so we can add denali under it if it does not exist
        //
        if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, szW3SVCASP, 0, samDesired, &hkey2) != ERROR_SUCCESS)
                {
                // if the key does not exits and you call with FALSE the exit with error
                //
                if (!fReg)
                        goto LErrExit;

                // Open the key for W3SVC so we can add denali under it
                //
                if (RegOpenKeyExA(HKEY_LOCAL_MACHINE, szW3SVC, 0, samDesired, &hkey1) != ERROR_SUCCESS)
                        {
                        MSG_Error(IDS_IIS_NOTINSTALLED);
                        return(E_FAIL);
                        }

                // Add the key for Denali\Parameters
                //
                if (RegCreateKeyA(hkey1, szASPParm, &hkey2) != ERROR_SUCCESS)
                        return(E_FAIL);
                }

        // release the extra key
        //
        if (hkey1)
                RegCloseKey(hkey1);
        hkey1 = hkey2;

    // set whatever is needed under hkey1
    // (currently nothing)

        // done clean up and exit
        if (RegCloseKey(hkey1) != ERROR_SUCCESS)
                return(E_FAIL);
        return S_OK;

LErrExit:
        RegCloseKey(hkey1);
        return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\response.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Response object

File: response.cpp

Owner: CGrant

This file contains the code for the implementation of the Response object.
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "response.h"
#include "request.h"
#include "Cookies.h"
#include "perfdata.h"

#include "winsock2.h"

#include "memchk.h"

#pragma warning (disable: 4355)  // ignore: "'this' used in base member init

static const char s_szContentLengthHeader[] = "Content-Length: ";
static const char s_szContentTypeHeader[]   = "Content-Type: ";
static const char s_szCharSetHTML[]         = "; Charset=";
static const char s_szCacheControl[]        = "Cache-control: ";
static const char s_szCacheControlPrivate[] = "Cache-control: private\r\n";
static const char s_szTransferEncoding[]    = "Transfer-Encoding: chunked\r\n";
static const char s_szHTML[]                = "text/html";
static const char s_szCDF[]                 = "application/x-cdf";
static const char s_szDefaultStatus[]       = "200 OK";

inline void AddtoTotalByteOut(int cByteOut)
    {
#ifndef PERF_DISABLE
    g_PerfData.Add_REQTOTALBYTEOUT(cByteOut);
#endif
    }

inline const char *GetResponseMimeType(CIsapiReqInfo *pIReq)
    {
    TCHAR *szPath = pIReq->QueryPszPathTranslated();
    DWORD cch = pIReq->QueryCchPathTranslated();
    if (cch > 4 && _tcscmp(szPath + cch - 4, _T(".CDX")) == 0)
        {
        return s_szCDF;
        }
    else
        {
        return s_szHTML;
        }
    }

/*
 *
 *
 *
 * C R e s p o n s e C o o k i e s
 *
 *
 *
 */

//===================================================================
// CResponseCookies::CResponseCookies
//
// Constructor.
//===================================================================
CResponseCookies::CResponseCookies(CResponse *pResponse, IUnknown *pUnkOuter)
    : m_ISupportErrImp(this, pUnkOuter, IID_IRequestDictionary)
    {
    m_punkOuter = pUnkOuter;

    if (pResponse)
        pResponse->AddRef();
    m_pResponse = pResponse;

    m_pRequest = NULL;

    CDispatch::Init(IID_IRequestDictionary);
    }

//===================================================================
// CResponseCookies::~CResponseCookies
//
// Destructor.
//===================================================================
CResponseCookies::~CResponseCookies()
    {
    if (m_pRequest)
        m_pRequest->Release();

    if (m_pResponse)
        m_pResponse->Release();
    }

//===================================================================
// CResponseCookies::ReInit
//
// Parameters:
//  pRequest  - pointer to the request object. Will need it to
//              read the request for the cookies
//
// Returns:
//  always S_OK, unlest pRequest is NULL.
//===================================================================
HRESULT CResponseCookies::ReInit(CRequest *pRequest)
    {
    if (pRequest)
        pRequest->AddRef();
    if (m_pRequest)
        m_pRequest->Release();

    m_pRequest = pRequest;      // CRequest is not ref counted, so no need for AddRef/Release

    if (m_pRequest == NULL)
        return E_POINTER;

    return S_OK;
    }

/*===================================================================
CResponseCookies::QueryInterface
CResponseCookies::AddRef
CResponseCookies::Release

IUnknown members for CResponseCookies object.
===================================================================*/

STDMETHODIMP CResponseCookies::QueryInterface(const IID &idInterface, void **ppvObj)
    {
    *ppvObj = NULL;

    if (idInterface == IID_IUnknown || idInterface == IID_IRequestDictionary || idInterface == IID_IDispatch)
        *ppvObj = this;

    else if (idInterface == IID_ISupportErrorInfo)
        *ppvObj = &m_ISupportErrImp;

    if (*ppvObj != NULL)
        {
        static_cast<IUnknown *>(*ppvObj)->AddRef();
        return S_OK;
        }

    return ResultFromScode(E_NOINTERFACE);
    }

STDMETHODIMP_(ULONG) CResponseCookies::AddRef()
    {
    return m_punkOuter->AddRef();
    }

STDMETHODIMP_(ULONG) CResponseCookies::Release()
    {
    return m_punkOuter->Release();
    }



/*===================================================================
CResponseCookies::get_Item

Function called from DispInvoke to get values from the Response.Cookies
collection.  If the Cookie does not exist, then a new one is created
and added to the Request dictionary

Parameters:
    varKey      VARIANT [in], which parameter to get the value of - Empty means whole collection
    pvarReturn  VARIANT *, [out] value of the requested parameter

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/
HRESULT CResponseCookies::get_Item(VARIANT varKey, VARIANT *pvarReturn)
    {
    if (FAILED(m_pResponse->CheckForTombstone()))
        return E_FAIL;

    char            *szKey;         // ascii value of 'varKey'
    CRequestHit     *pRequestHit;   // pointer to request bucket
    DWORD           vt = 0;         // Variant type of key
    CWCharToMBCS    convKey;

    if (m_pResponse->FHeadersWritten())
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_HEADERS_WRITTEN);
        return E_FAIL;
        }

    // Initialize things
    //
    V_VT(pvarReturn) = VT_DISPATCH;
    V_DISPATCH(pvarReturn) = NULL;
    VARIANT *pvarKey = &varKey;
    HRESULT hrReturn = S_OK;

    // BUG 937: VBScript passes VT_VARIANT|VT_BYREF when passing obect
    //          produced by IEnumVariant
    //
    // Use VariantResolveDispatch which will:
    //
    //     *  Copy BYREF variants for us using VariantCopyInd
    //     *  handle E_OUTOFMEMORY for us
    //     *  get the default value from an IDispatch, which seems
    //        like an appropriate conversion.
    //
    VARIANT varKeyCopy;
    VariantInit(&varKeyCopy);
    vt = V_VT(pvarKey);

    if ((vt != VT_BSTR) && (vt != VT_I2) && (vt != VT_I4))
        {
        if (FAILED(VariantResolveDispatch(&varKeyCopy, &varKey, IID_IRequestDictionary, IDE_REQUEST)))
            goto LExit;

        pvarKey = &varKeyCopy;
        }

    vt = V_VT(pvarKey);

    switch(vt)
        {
        // Bug 95201 support all numberic sub-types
        case VT_I1:  case VT_I2:               case VT_I8:
        case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
        case VT_R4:  case VT_R8:
            // Coerce all integral types to VT_I4
            if (FAILED(hrReturn = VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
                goto LExit;

            // fallthru to VT_I4

        case VT_I4:
        case VT_BSTR:
            break;
        default:
            ExceptionId(IID_IRequestDictionary, IDE_COOKIE, IDE_EXPECTING_STR);
            hrReturn = E_FAIL;
            goto LExit;
        }

    if (FAILED(m_pRequest->CheckForTombstone()))
        {
        hrReturn = E_FAIL;
        goto LExit;
        }

    if (m_pRequest->m_pData->m_fLoadCookies)
        {
        char *szCookie = m_pRequest->GetIReq()->QueryPszCookie();

        if (FAILED(hrReturn = m_pRequest->LoadVariables(COOKIE, szCookie, m_pRequest->GetCodePage())))
            goto LExit;

        m_pRequest->m_pData->m_fLoadCookies = FALSE;
        }

    if (vt == VT_BSTR)
        {
        if (FAILED(hrReturn = convKey.Init(V_BSTR(pvarKey),m_pRequest->GetCodePage()))) {
            if (hrReturn == E_OUTOFMEMORY) {
                ExceptionId(IID_IResponse, IDE_COOKIE, IDE_OOM);
                goto LExit;
            }
            hrReturn = NO_ERROR;
                        szKey = "";
        }
        else {
            szKey = convKey.GetString();
        }

        // Bug 456: Don't allow assignment to DenaliSessionID
        if (strncmp(szKey, SZ_SESSION_ID_COOKIE_PREFIX, CCH_SESSION_ID_COOKIE_PREFIX) == 0)
            {
            ExceptionId(IID_IResponse, IDE_COOKIE, IDE_RESPONSE_MODIFY_SESS_COOKIE);
            hrReturn = E_FAIL;
            goto LExit;
            }

            pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->FindElem(szKey, strlen(szKey)));
        }
    else
        {
        // Look up item by index
        int iCount = 0;
        if (vt == VT_I2)
            {
            iCount = V_I2(pvarKey);
            }
        else
            {
            iCount = V_I4(pvarKey);
            }

        // The Request hits for all cookies are stored with the request object
        if ((iCount < 1) || (iCount > (int) m_pRequest->m_pData->m_Cookies.m_dwCount))
            {
            hrReturn = E_FAIL;
            goto LExit;
            }

        pRequestHit = m_pRequest->m_pData->m_Cookies.m_rgRequestHit[iCount - 1];
        }

    if (pRequestHit)
        {
        CCookie *pDictionary = pRequestHit->m_pCookieData;
        if (pDictionary == NULL)
            goto LNotFound;

        if (FAILED(pDictionary->QueryInterface(IID_IWriteCookie, reinterpret_cast<void **>(&V_DISPATCH(pvarReturn)))))
            Assert (FALSE);

        goto LExit;
        }

LNotFound:
    // don't allow empty cookie names
    //
    if (*szKey == '\0')
        {
        ExceptionId(IID_IResponse, IDE_COOKIE, IDE_COOKIE_NO_NAME);
        hrReturn = E_FAIL;
        goto LExit;
        }

    // Create a new RequestHit if there is no key by this name
    if (pRequestHit == NULL)
        {
        pRequestHit = new CRequestHit;
        if (pRequestHit == NULL || FAILED(pRequestHit->Init(szKey, TRUE)))
            {
            if (pRequestHit)
                delete pRequestHit;
            ExceptionId(IID_IResponse, IDE_COOKIE, IDE_OOM);
            hrReturn = E_OUTOFMEMORY;
            goto LExit;
            }

        m_pRequest->GetStrings()->AddElem(pRequestHit);
        }

    // Create a new cookie, with an initial unassigned value.
    if (pRequestHit->m_pCookieData == NULL)
        {
        pRequestHit->m_pCookieData = new CCookie(m_pResponse->GetIReq(),m_pRequest->GetCodePage());
        if (pRequestHit->m_pCookieData == NULL || FAILED(pRequestHit->m_pCookieData->Init()))
            {
            ExceptionId(IID_IResponse, IDE_COOKIE, IDE_OOM);
            hrReturn = E_OUTOFMEMORY;
            goto LExit;
            }
        }

    // Add this Request hit to the ResponseCookies array of hits
    if (!m_pRequest->m_pData->m_Cookies.AddRequestHit(pRequestHit))
        {
        return E_OUTOFMEMORY;
        }

    // Query for IWriteCookie
    if (FAILED(pRequestHit->m_pCookieData->QueryInterface(IID_IWriteCookie, reinterpret_cast<void **>(&V_DISPATCH(pvarReturn)))))
        {
        Assert (FALSE);
        }

LExit:
    VariantClear(&varKeyCopy);
    return hrReturn;
    }

/*===================================================================
CResponseCookies::get_Count

Parameters:
    pcValues - count is stored in *pcValues
===================================================================*/

STDMETHODIMP CResponseCookies::get_Count(int *pcValues)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    return m_pRequest->m_pData->m_Cookies.get_Count(pcValues);
    }

/*===================================================================
CResponseCookies::get_Key

Function called from DispInvoke to get keys from the response cookie collection.

Parameters:
    vKey        VARIANT [in], which parameter to get the key of
    pvarReturn  VARIANT *, [out] value of the requested parameter

Returns:
    S_OK on success, E_FAIL on failure.
===================================================================*/

HRESULT CResponseCookies::get_Key(VARIANT varKey, VARIANT *pVar)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return E_FAIL;

    return m_pRequest->m_pData->m_Cookies.get_Key(varKey, pVar);
    }

/*===================================================================
CResponseCookies::get__NewEnum

Return a new enumerator
===================================================================*/
HRESULT CResponseCookies::get__NewEnum(IUnknown **ppEnumReturn)
    {
    if (FAILED(m_pResponse->CheckForTombstone()))
        return E_FAIL;

    *ppEnumReturn = NULL;

    CRequestIterator *pIterator = new CRequestIterator(m_pRequest, COOKIE);
    if (pIterator == NULL)
        return E_OUTOFMEMORY;

    HRESULT hrInit = pIterator->Init();
    if (FAILED(hrInit))
        {
        delete pIterator;
        return hrInit;
        }

    *ppEnumReturn = pIterator;
    return S_OK;
    }

/*===================================================================
CResponseCookies::QueryHeaderSize

Returns:
    returns the number of bytes required for the cookie headers.
===================================================================*/

size_t CResponseCookies::QueryHeaderSize()
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        return 0;

    int cbHeaders = 0;

    for (CRequestHit *pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->Head());
         pRequestHit != NULL;
         pRequestHit = static_cast<CRequestHit *>(pRequestHit->m_pNext))
        {
        CCookie *pCookie = pRequestHit->m_pCookieData;
        if (pCookie == NULL || !pCookie->IsDirty())
            continue;

        // add two bytes for '\r\n'
        //
        // CCookie::GetCookieHeaderSize adds one byte for NUL terminator, so
        // just add one byte here.
        //
        // CResponse::WriteHeaders does not want to know about the NUL yet.
        //
        cbHeaders += pCookie->GetCookieHeaderSize(reinterpret_cast<char *>(pRequestHit->m_pKey)) + 1;
        }

    return cbHeaders;
    }

/*===================================================================
CResponseCookies::GetHeaders

Parameters:
    szBuffer - contains the destination buffer for the cookie header
                text

Returns:
    return a pointer to the NUL character in the destination
===================================================================*/

char *CResponseCookies::GetHeaders(char *szBuffer)
    {
    if (FAILED(m_pRequest->CheckForTombstone()))
        {
        szBuffer[0] = '\0';
        return szBuffer;
        }

    for (CRequestHit *pRequestHit = static_cast<CRequestHit *>(m_pRequest->GetStrings()->Head());
         pRequestHit != NULL;
         pRequestHit = static_cast<CRequestHit *>(pRequestHit->m_pNext))
        {
        CCookie *pCookie = pRequestHit->m_pCookieData;
        if (pCookie == NULL || !pCookie->IsDirty())
            continue;

        szBuffer = pCookie->GetCookieHeader(reinterpret_cast<char *>(pRequestHit->m_pKey), szBuffer);
        szBuffer = strcpyExA(szBuffer, "\r\n");
        }

    return szBuffer;
    }


/*
 *
 *
 *
 * C R e s p o n s e B u f f e r
 *
 *
 *
 */

/*===================================================================
The CResponseBuffer object maintains an array of buffers.
If buffering is turned on, the Response.Write and Response.WriteBlock
methods will write to the buffers in these arrays rather then directly
back to the client. Response.Flush writes the content of the buffers to
the client and then frees the buffers. Response.Clear frees the buffers without
writing to the client
====================================================================*/

/*===================================================================
CResponseBuffer::CResponseBuffer

Constructor

Parameters:
    None

Returns:
    Nothing

Side Effects
    None

===================================================================*/
CResponseBuffer::CResponseBuffer()
    {
    m_pResponse = NULL;

    m_rgpchBuffers = &m_pchBuffer0;
    m_cBufferPointers = 1;
    m_pchBuffer0 = NULL;

    m_cBuffers = 0;
    m_iCurrentBuffer = 0;
    m_cchOffsetInCurrentBuffer = 0;
    m_cchTotalBuffered = 0;
    m_fInited = FALSE;
    }

/*===================================================================
CResponseBuffer::Init

Initializes the CResponseBuffer object

Parameters:
    None

Returns:
    S_OK         Success
    E_OUTOFMEMORY   Failure

Side Effects
    Allocates memory

===================================================================*/
HRESULT CResponseBuffer::Init(CResponse* pResponse)
    {
    Assert(pResponse);

    // Set the pointer to the enclosing response object
    m_pResponse = pResponse;
    m_fInited = TRUE;

    return S_OK;
    }

/*===================================================================
CResponseBuffer::~CResponseBuffer

Destructor

Parameters:
    None

Returns:
    Nothing

Side Effects
    Frees memory

===================================================================*/
CResponseBuffer::~CResponseBuffer()
    {
    Assert(m_rgpchBuffers);

    // Free all the buffers we've allocated
    for (DWORD i = 0; i < m_cBuffers; i++)
        {
        if (m_rgpchBuffers[i])
            {
            ACACHE_FSA_FREE(ResponseBuffer, m_rgpchBuffers[i]);
            }
        }

    // Free the array of buffer pointers
    // (only if allocated - doesn't point to the member pointer
    if (m_cBufferPointers > 1)
        free(m_rgpchBuffers);
    }

/*===================================================================
CResponseBuffer::GrowBuffers

Increases available buffer space

Parameters:
    cchNewRequest   count of bytes to be accomodated

Returns:
    HRESULT         Indicating success or type of failure

Side Effects
    May cause memory to be allocated

===================================================================*/
HRESULT CResponseBuffer::GrowBuffers(DWORD cchNewRequest)
    {
    Assert(m_fInited);

    // Calculate how many more buffers are needed
    DWORD cAddBuffers = (cchNewRequest+RESPONSE_BUFFER_SIZE-1)/RESPONSE_BUFFER_SIZE;

    // Always at least one must be there already
    Assert(m_rgpchBuffers);
    Assert(m_cBufferPointers);

    // Allocate more buffer pointers if needed
    if (cAddBuffers > (m_cBufferPointers - m_cBuffers)) // doesn't fit?
        {
        char **rgpchTmp;
        DWORD cNewBufferPointers = m_cBufferPointers + cAddBuffers + BUFFERS_INCREMENT;

        if (m_cBufferPointers == 1)
            rgpchTmp = (char **)malloc(cNewBufferPointers*sizeof(char *));
        else
            rgpchTmp = (char **)realloc(m_rgpchBuffers, cNewBufferPointers*sizeof(char *));
        if (!rgpchTmp)
            return E_OUTOFMEMORY;

        // preserve the first buffer pointer in the special case
        // of m_rgpchBuffers initally pointing to a member buffer pointer
        if (m_cBufferPointers == 1)
            rgpchTmp[0] = m_rgpchBuffers[0];

        m_rgpchBuffers = rgpchTmp;
        m_cBufferPointers = cNewBufferPointers;
        }

    // Allocate the new buffers
    for (DWORD i = 0; i < cAddBuffers; i++)
        {
        char *pchTmp = (char *)ACACHE_FSA_ALLOC(ResponseBuffer);
        if (!pchTmp)
            return E_OUTOFMEMORY;
        m_rgpchBuffers[m_cBuffers++] = pchTmp;
        }

    return S_OK;
    }


/*===================================================================
CResponseBuffer::Write

Writes data to the CResponseBuffer object. We first write
a data structure that describes this segment of the buffer.
The data structure identifies which method is doing the
writing, and contains an index to the starting buffer,
the starting offset in that buffer, and the length of the
data. The data itself is then writen to one or more buffers.
New buffers are allocated as needed

Parameters:
    szSource    pointer to buffer to read into the Response buffer
    cch         count of bytes to be read into the Response buffer

Returns:
    HRESULT     Indicating success or type of failure

Side Effects
    May cause memory to be allocated

===================================================================*/
HRESULT CResponseBuffer::Write(char* szSource, DWORD cch)
    {

    HRESULT hr = S_OK;

    Assert(m_fInited);

    // Caclulate how much buffer space we have left
    DWORD cchBufferRemaining;
    if (m_cBuffers)
        cchBufferRemaining = RESPONSE_BUFFER_SIZE - m_cchOffsetInCurrentBuffer;
    else
        cchBufferRemaining = 0;

    // Check if enough space is left in the current buffer
    if (cch <= cchBufferRemaining)
        {
        // Enough space available, copy data to buffer
        memcpy(m_rgpchBuffers[m_iCurrentBuffer] + m_cchOffsetInCurrentBuffer, szSource, cch);
        m_cchOffsetInCurrentBuffer += cch;
        m_cchTotalBuffered += cch;
        }
    else
        {
        // Not enough space in current buffer, allocate more buffers
        hr = GrowBuffers(cch - cchBufferRemaining);
        if (FAILED(hr))
            {
            goto lRet;
            }

        // Copy data to the buffers, we loop to handle
        // the case where the data is larger then the buffer size
        while (cch)
            {
            if (RESPONSE_BUFFER_SIZE == m_cchOffsetInCurrentBuffer)
                {
                m_iCurrentBuffer++;
                m_cchOffsetInCurrentBuffer = 0;
                }
            DWORD cchToCopy = min(cch, (RESPONSE_BUFFER_SIZE - m_cchOffsetInCurrentBuffer));
            memcpy(m_rgpchBuffers[m_iCurrentBuffer] + m_cchOffsetInCurrentBuffer, szSource, cchToCopy);
            m_cchOffsetInCurrentBuffer += cchToCopy;
            szSource += cchToCopy;
            cch -= cchToCopy;
            m_cchTotalBuffered += cchToCopy;
            }
        }

lRet:
    return(hr);
    }

/*===================================================================
CResponseBuffer::Clear

  Deletes all information currently in the buffers, and restores
  the buffer array to it's starting state.

Parameters:
    None

Returns:
    S_OK success

Side Effects
    May free memory

===================================================================*/
HRESULT CResponseBuffer::Clear()
    {
    Assert(m_fInited);

    if (m_cBuffers == 0)
        return S_OK;

    // Free all but the first of the allocated buffers
    for (DWORD i = 1; i < m_cBuffers;  i++)
        {
        ACACHE_FSA_FREE(ResponseBuffer, m_rgpchBuffers[i]);
        m_rgpchBuffers[i] = NULL;
        }

    m_cBuffers = 1;
    m_iCurrentBuffer = 0;
    m_cchOffsetInCurrentBuffer = 0;
    m_cchTotalBuffered = 0;
    return S_OK;
    }


/*===================================================================
CResponseBuffer::Flush

    Writes all data in the buffer to the client. We walk through
    the array of descriptions of buffer requests. The description
    includes which method was responsible for the request. If WriteBlock
    made the request, then we can just hand WriteClient the pointer to the HTML
    block and its length. If Write made the request, we find the starting buffer
    and offset from the request description, walk through the array of buffers until
    all of the data from the request has been writen to the client.

    After all data in the buffers has been writen to the client the buffers
    are freed.

Parameters:
    Pointer to CIsapiReqInfo
    Flag indicating whether this is in response to a head request

Returns:
    S_OK success

Side Effects
    May free memory

===================================================================*/
HRESULT CResponseBuffer::Flush(CIsapiReqInfo *pIReq)
    {
    HRESULT hr = S_OK;

    Assert(m_fInited);
    Assert(pIReq);

    // If no buffers are allocated, no point in going any further
    if (m_cchTotalBuffered == 0)
        return S_OK;

    // If this is not a head request transmit the buffer contents to the client
    if (!m_pResponse->IsHeadRequest())
        {
        // Write out all the buffers
        for (DWORD i = 0; i <= m_iCurrentBuffer; i++)
            {
            DWORD cchToWrite = (i == m_iCurrentBuffer) ?
                m_cchOffsetInCurrentBuffer : RESPONSE_BUFFER_SIZE;

            if (FAILED(CResponse::SyncWrite(pIReq, m_rgpchBuffers[i], cchToWrite)))
                {
                // Failed to write to the client,
                // further ouput to client is futile
                m_pResponse->m_pData->m_fWriteClientError = TRUE;
                break;
                }
            }
        }

    Clear();
    return hr;
    }

/*
 *
 *
 *
 * C D e b u g R e s p o n s e B u f f e r
 *
 *
 *
 */

/*===================================================================
CDebugResponseBuffer::AppendRecord

Create client side debugger metadata record and appends it to
the buffer

Parameters:

Returns:
    HRESULT     Indicating success or type of failure
===================================================================*/
HRESULT CDebugResponseBuffer::AppendRecord
(
const int cchBlockOffset,
const int cchBlockLength,
const int cchSourceOffset,
const char *pszSourceFile
)
    {
    HRESULT hr = S_OK;

#define CCH_METADATA_RECORD_MAX 40 // without filename

    if (pszSourceFile)
        {
        char *pszBuf = new char [strlen(pszSourceFile) +
                                 CCH_METADATA_RECORD_MAX + 1];
        if (pszBuf)
            {
            sprintf(pszBuf, "%d,%d,%d,%s\r\n",
                cchBlockOffset, cchBlockLength, cchSourceOffset,
                pszSourceFile);

            hr = Write(pszBuf);
            delete [] pszBuf;
            }
        else
            {
            hr = E_OUTOFMEMORY;
            }
        }
    else
        {
        char szBuf[CCH_METADATA_RECORD_MAX+1];
        sprintf(szBuf, "%d,%d,%d\r\n",
            cchBlockOffset, cchBlockLength, cchSourceOffset);

        hr = Write(szBuf);
        }

#undef CCH_METADATA_RECORD_MAX

    return hr;
    }

/*
 *
 *
 *
 * C H T T P H e a d e r
 *
 *
 *
 */

/*===================================================================
CHTTPHeader::CHTTPHeader

Constructor.
===================================================================*/
CHTTPHeader::CHTTPHeader()
    :
    m_fInited(FALSE),
    m_fNameAllocated(FALSE), m_fValueAllocated(FALSE),
    m_szName(NULL), m_szValue(NULL),
    m_cchName(0), m_cchValue(0),
    m_pNext(NULL)
    {
    }

/*===================================================================
CHTTPHeader::~CHTTPHeader

Destructor
===================================================================*/
CHTTPHeader::~CHTTPHeader()
    {
    if (m_fNameAllocated)
        {
        Assert(m_szName);
        delete [] m_szName;
        }
    if (m_fValueAllocated)
        {
        Assert(m_szValue);
        delete [] m_szValue;
        }
    }

/*===================================================================
HRESULT CHTTPHeader::InitHeader

Functions set the header strings. Agrument types combinations:
    BSTR, BSTR
    hardcoded char*, BSTR
    hardcoded char*, hardcoded char*
    hardcoded char*, int

Parameters:
    Name, Value

Returns:
    S_OK     Success
===================================================================*/
HRESULT CHTTPHeader::InitHeader(BSTR wszName, BSTR wszValue, UINT lCodePage /* CP_ACP */)
    {
    Assert(!m_fInited);
    Assert(wszName);

    CWCharToMBCS    convStr;
    HRESULT         hr = S_OK;

    // name

    if (FAILED(hr = convStr.Init(wszName,lCodePage))) {
        if (hr == E_OUTOFMEMORY)
            return hr;
        m_fNameAllocated = FALSE;
        m_szName = "";
    }
    else {
        m_szName = convStr.GetString(TRUE);
        m_fNameAllocated = TRUE;
    }
    m_cchName = strlen(m_szName);

    // value
    int cch = wszValue ? wcslen(wszValue) : 0;
    if (cch > 0)
        {
        if (FAILED(hr = convStr.Init(wszValue,lCodePage))) {
            return hr;
        }
        m_szValue = convStr.GetString(TRUE);
        m_fValueAllocated = TRUE;
        m_cchValue = strlen(m_szValue);
        }
    else
        {
        m_szValue = NULL;
        m_fValueAllocated = FALSE;
        m_cchValue = 0;
        }

    m_fInited = TRUE;
    return S_OK;
    }

HRESULT CHTTPHeader::InitHeader(char *szName, BSTR wszValue, UINT lCodePage /* = CP_ACP */)
    {
    Assert(!m_fInited);
    Assert(szName);

    CWCharToMBCS    convStr;
    HRESULT         hr = S_OK;

    m_szName = szName;
    m_cchName = strlen(m_szName);
    m_fNameAllocated = FALSE;

    int cch = wszValue ? wcslen(wszValue) : 0;
    if (cch > 0)
        {
        if (FAILED(hr = convStr.Init(wszValue,lCodePage))) {
            return hr;
        }
        m_szValue = convStr.GetString(TRUE);
        m_fValueAllocated = TRUE;
        m_cchValue = strlen(m_szValue);
        }
    else
        {
        m_szValue = NULL;
        m_fValueAllocated = FALSE;
        m_cchValue = 0;
        }

    m_fInited = TRUE;
    return S_OK;
    }

HRESULT CHTTPHeader::InitHeader(char *szName, char *szValue, BOOL fCopyValue)
    {
    Assert(!m_fInited);
    Assert(szName);

    m_szName = szName;
    m_cchName = strlen(m_szName);
    m_fNameAllocated = FALSE;

    if (fCopyValue)
        {
        int cch = szValue ? strlen(szValue) : 0;
        if (cch > 0)
            {
            m_szValue = new char[cch+1];
            if (m_szValue == NULL)
                return E_OUTOFMEMORY;
            m_fValueAllocated = TRUE;
            strcpy(m_szValue, szValue);
            m_cchValue = cch;
            }
        else
            {
            m_szValue = NULL;
            m_fValueAllocated = FALSE;
            m_cchValue = 0;
            }
        }
    else
        {
        m_szValue = szValue;
        m_cchValue = strlen(m_szValue);
        m_fValueAllocated = FALSE;
        }

    m_fInited = TRUE;
    return S_OK;
    }

HRESULT CHTTPHeader::InitHeader(char *szName, long lValue)
    {
    Assert(!m_fInited);
    Assert(szName);

    m_szName = szName;
    m_cchName = strlen(m_szName);
    m_fNameAllocated = FALSE;

    ltoa(lValue, m_rgchLtoaBuffer, 10);
    m_szValue = m_rgchLtoaBuffer;
    m_cchValue = strlen(m_szValue);
    m_fValueAllocated = FALSE;

    m_fInited = TRUE;
    return S_OK;
    }

/*===================================================================
CHTTPHeader::Print

Prints the header into a buffer in "Header: Value\r\n" format.

Parameters:
    szBuf       buffer to fill
===================================================================*/
void CHTTPHeader::Print
(
char *szBuf
)
    {
    Assert(m_fInited);

    Assert(m_cchName);
    Assert(m_szName);
    memcpy(szBuf, m_szName, m_cchName);
    szBuf += m_cchName;

    *szBuf++ = ':';
    *szBuf++ = ' ';

    if (m_cchValue)
        {
        Assert(m_szValue);
        memcpy(szBuf, m_szValue, m_cchValue);
        szBuf += m_cchValue;
        }

    *szBuf++ = '\r';
    *szBuf++ = '\n';
    *szBuf = '\0';
    }


/*
 *
 *
 *
 * C R e s p o n s e D a t a
 *
 *
 *
 */

/*===================================================================
CResponseData::CResponseData

Constructor

Parameters:
    CResponse *pResponse

Returns:
    Nothing.
===================================================================*/
CResponseData::CResponseData
(
CResponse *pResponse
)
    :
    m_ISupportErrImp(static_cast<IResponse *>(pResponse), this, IID_IResponse),
    m_WriteCookies(pResponse, this),
    m_cRefs(1)
    {
    m_pIReq = NULL;
    m_pHitObj = NULL;
    m_pTemplate = NULL;
    m_pFirstHeader = m_pLastHeader = NULL;
    m_fHeadersWritten = FALSE;
    m_fResponseAborted = FALSE;
    m_fWriteClientError = FALSE;
    m_fIgnoreWrites = FALSE;
    m_fBufferingOn = FALSE;
    m_fFlushed = FALSE;
    m_fChunked = FALSE;
    m_fClientDebugMode = FALSE;
    m_fClientDebugFlushIgnored = FALSE;
    m_szCookieVal = NULL;
    m_pszDefaultContentType = NULL;
    m_pszContentType = NULL;
    m_pszCharSet = NULL;
    m_pszStatus = NULL;
    m_pszCacheControl = NULL;
    m_dwVersionMajor = 0;
    m_dwVersionMinor = 0;
    m_pResponseBuffer = NULL;
    m_pClientDebugBuffer = NULL;
    m_tExpires = -1;
    m_pszDefaultExpires = NULL;
    m_pfnGetScript = NULL;
    m_pvGetScriptContext = NULL;
    }

/*===================================================================
CResponseData::~CResponseData

Destructor

Parameters:

Returns:
    Nothing.
===================================================================*/
CResponseData::~CResponseData()
    {
    // points to static string - no need to free
    // m_pszDefaultContentType = NULL;

    // Free any memory associated with the content-type
    if (m_pszContentType)
        free(m_pszContentType);

        // Free any memory associated with the CacheControl
        if (m_pszCacheControl)
                free(m_pszCacheControl);

    // Free any memory associated with the CharSet
    if (m_pszCharSet)
        free(m_pszCharSet);

    // Free any memory associated with the status
    if (m_pszStatus)
        free(m_pszStatus);

    // Free all headers
    CHTTPHeader *pHeader = m_pFirstHeader;
    while (pHeader)
        {
        CHTTPHeader *pNextHeader = pHeader->PNext();
        delete pHeader;
        pHeader = pNextHeader;
        }
    m_pFirstHeader = m_pLastHeader = NULL;

    // Clean up the Response Buffer
    if (m_pResponseBuffer)
        delete m_pResponseBuffer;

    // Clean up Client Debug Response Buffer
    if (m_pClientDebugBuffer)
        delete m_pClientDebugBuffer;
    }

/*===================================================================
CResponseData::Init

Init

Parameters:
    CResponse *pResponse

Returns:
    Nothing.
===================================================================*/
HRESULT CResponseData::Init
(
CResponse *pResponse
)
    {
    HRESULT hr = S_OK;

    m_pIReq = NULL;

    // set the HEAD request flag to 0 un-inited
    m_IsHeadRequest = 0;

    // Initialize header list
    m_pFirstHeader = m_pLastHeader = NULL;

    // Initialize the response buffer
    m_pResponseBuffer = new CResponseBuffer;
    if (m_pResponseBuffer == NULL)
        hr = E_OUTOFMEMORY;

    if (SUCCEEDED(hr))
        hr = m_pResponseBuffer->Init(pResponse);

    return hr;
    }

/*===================================================================
CResponseData::QueryInterface
CResponseData::AddRef
CResponseData::Release

IUnknown members for CRequestData object.
===================================================================*/
STDMETHODIMP CResponseData::QueryInterface
(
REFIID iid,
void **ppvObj
)
    {
    if (iid == IID_IUnknown)
        {
        *ppvObj = this;
        AddRef();
        return S_OK;
        }
    else
        {
        *ppvObj = NULL;
        return E_NOINTERFACE;
        }
    }

STDMETHODIMP_(ULONG) CResponseData::AddRef()
    {
    return ++m_cRefs;
    }

STDMETHODIMP_(ULONG) CResponseData::Release(void)
    {
    if (--m_cRefs)
        return m_cRefs;
    delete this;
    return 0;
    }

/*
 *
 *
 *
 * C R e s p o n s e
 *
 *
 *
 */

/*===================================================================
CResponse::CResponse

Constructor

Parameters:
    punkOuter   object to ref count (can be NULL)
===================================================================*/
CResponse::CResponse(IUnknown *punkOuter)
    :
    m_fInited(FALSE),
    m_fDiagnostics(FALSE),
    m_pData(NULL)
    {
    CDispatch::Init(IID_IResponse);

    if (punkOuter)
        {
        m_punkOuter = punkOuter;
        m_fOuterUnknown = TRUE;
        }
    else
        {
        m_cRefs = 1;
        m_fOuterUnknown = FALSE;
        }

#ifdef DBG
    m_fDiagnostics = TRUE;
#endif // DBG
    }

/*===================================================================
CResponse::~CResponse

Destructor

Parameters:
    None

Returns:
    Nothing.

===================================================================*/
CResponse::~CResponse()
    {
    Assert(!m_fInited);
    Assert(m_fOuterUnknown || m_cRefs == 0);  // must have 0 ref count
    }

/*===================================================================
CResponse::CleanUp

Deallocates members and removes m_pData

Parameters:
    None

Returns:
    HRESULT (S_OK)
===================================================================*/
HRESULT CResponse::CleanUp()
    {
    if (m_pData)
        {
        m_pData->Release();
        m_pData = NULL;
        }
    return S_OK;
    }

/*===================================================================
CResponse::Init

Allocates m_pData
Performs any intiailization of a CResponse that's prone to failure
that we also use internally before exposing the object outside.

Parameters:
    None

Returns:
    S_OK on success.

===================================================================*/
HRESULT CResponse::Init()
    {
    if (m_fInited)
        return S_OK; // already inited

    Assert(!m_pData);

    m_pData = new CResponseData(this);
    if (!m_pData)
        return E_OUTOFMEMORY;

    HRESULT hr = m_pData->Init(this);

    if (SUCCEEDED(hr))
        m_fInited = TRUE;
    else
        CleanUp();

    return hr;
    }

/*===================================================================
CResponse::UnInit

Remove m_pData. Back to UnInited state

Parameters:
    None

Returns:
    HRESULT
===================================================================*/
HRESULT CResponse::UnInit()
    {
    if (!m_fInited)
        return S_OK; // already uninited

    Assert(m_pData);
    CleanUp();
    Assert(!m_pData);

    m_fInited = FALSE;
    return S_OK;
    }

/*===================================================================
CResponse::ReInitTemplate

This function is used to set the template member. It should only
be used for an ordinary script file's template, not for global.asa template.

Parameters:
    Pointer to template

Returns:
    S_OK on success.
===================================================================*/
HRESULT CResponse::ReInitTemplate
(
CTemplate* pTemplate,
const char *szCookieVal
)
    {
    Assert(m_fInited);
    Assert(m_pData);

    Assert(pTemplate != NULL);
    Assert(m_pData->m_pTemplate == NULL);

    m_pData->m_pTemplate = pTemplate;
    m_pData->m_pTemplate->AddRef(); // We release the template in FinalFlush

    m_pData->m_szCookieVal = szCookieVal;
    return(S_OK);
    }

/*===================================================================
CResponse::SwapTemplate

Temporary substitutes Template in response
Used in child request execution

Parameters:
    Pointer to the new template

Returns:
    Pointer to the old template
===================================================================*/
CTemplate *CResponse::SwapTemplate
(
CTemplate* pNewTemplate
)
    {
    Assert(m_fInited);
    Assert(m_pData);

    CTemplate *pOldTemplate = m_pData->m_pTemplate;
    m_pData->m_pTemplate = pNewTemplate;
    return pOldTemplate;
    }

/*===================================================================
CResponse::ReInit

Each Request we service will have a new CIsapiReqInfo.
This function is used to set the value of the CIsapiReqInfo.

Parameters:
    Pointer to CIsapiReqInfo
Returns:
    S_OK on success.
===================================================================*/
HRESULT CResponse::ReInit
(
CIsapiReqInfo *pIReq,
const char *szCookieVal,
CRequest *pRequest,
PFNGETSCRIPT pfnGetScript,
void *pvGetScriptContext,
CHitObj *pHitObj
)
    {
    Assert(m_fInited);
    Assert(m_pData);

    CHTTPHeader *pCurr;
    CLinkElem *pT;
    CLinkElem *pNext;

    // set the HEAD request flag to 0 un-inited
    m_pData->m_IsHeadRequest = 0;

    // ReInitialize the WriteCookie dictionary
    if (FAILED(m_pData->m_WriteCookies.ReInit(pRequest)))
        return E_FAIL;

    // points to static string - no need to free
    m_pData->m_pszDefaultContentType = NULL;

    // Free any memory associated with the content type
    if (m_pData->m_pszContentType != NULL)
        {
        free(m_pData->m_pszContentType);
        m_pData->m_pszContentType = NULL;
        }

    // Free any memory associated with the content type
    if (m_pData->m_pszCharSet != NULL)
        {
        free(m_pData->m_pszCharSet);
        m_pData->m_pszCharSet = NULL;
        }


    // Free any memory associated with the status
    if (m_pData->m_pszStatus != NULL)
        {
        free(m_pData->m_pszStatus);
        m_pData->m_pszStatus = NULL;
        }

    // Free all headers
    CHTTPHeader *pHeader = m_pData->m_pFirstHeader;
    while (pHeader)
        {
        CHTTPHeader *pNextHeader = pHeader->PNext();
        delete pHeader;
        pHeader = pNextHeader;
        }
    m_pData->m_pFirstHeader = m_pData->m_pLastHeader = NULL;

    m_pData->m_fHeadersWritten = FALSE;

    m_pData->m_fResponseAborted = FALSE;
    m_pData->m_fWriteClientError = FALSE;
    m_pData->m_fIgnoreWrites = FALSE;
    m_pData->m_pIReq = pIReq;
    m_pData->m_szCookieVal = szCookieVal;
    m_pData->m_pszDefaultContentType = NULL;
    m_pData->m_pszContentType = NULL;
    m_pData->m_pszCharSet = NULL;
    m_pData->m_pszStatus = NULL;
    m_pData->m_pfnGetScript = pfnGetScript;
    m_pData->m_pvGetScriptContext = pvGetScriptContext;
    m_pData->m_pHitObj = pHitObj;
    m_pData->m_tExpires = -1;
    m_pData->m_pszDefaultExpires = NULL;

    // Ask for the HTTP version of the client
    GetClientVerison();

    // Set the default content type
    if (m_pData->m_pIReq)
        m_pData->m_pszDefaultContentType = GetResponseMimeType(m_pData->m_pIReq);

    // Set the default Expires Header
    // NOTE - removed per discussions on proper header settings with IE/IIS
    // teams.
#if 0
    if (m_pData->m_pIReq)
        m_pData->m_pszDefaultExpires = m_pData->m_pIReq->QueryPszExpires();
#endif

    // Set the buffering flag to the global value
    m_pData->m_fBufferingOn = (pHitObj->QueryAppConfig())->fBufferingOn();

    // Buffering always on for client code debug
    if (pHitObj && pHitObj->FClientCodeDebug())
        {
        m_pData->m_fBufferingOn = TRUE;
        m_pData->m_fClientDebugMode = TRUE;
        m_pData->m_fClientDebugFlushIgnored = FALSE;
        }
    else
        {
        m_pData->m_fClientDebugMode = FALSE;
        m_pData->m_fClientDebugFlushIgnored = FALSE;
        }

    HRESULT hr = S_OK;

    if (m_pData->m_fClientDebugMode)
        {
        // Create and init client debug buffer if needed
        if (m_pData->m_pClientDebugBuffer)
            {
            hr = m_pData->m_pClientDebugBuffer->ClearAndStart();
            }
        else
            {
            m_pData->m_pClientDebugBuffer = new CDebugResponseBuffer;
            if (m_pData->m_pClientDebugBuffer)
                hr = m_pData->m_pClientDebugBuffer->InitAndStart(this);
            else
                hr = E_OUTOFMEMORY;
            }
        }

    return hr;
    }

/*===================================================================
CResponse::QueryInterface
CResponse::AddRef
CResponse::Release

IUnknown members for CResponse object.

===================================================================*/
STDMETHODIMP CResponse::QueryInterface
(
REFIID riid,
PPVOID ppv
)
    {
    *ppv = NULL;

    /*
     * The only calls for IUnknown are either in a nonaggregated
     * case or when created in an aggregation, so in either case
     * always return our IUnknown for IID_IUnknown.
     */

    // BUG FIX 683 added IID_IDenaliIntrinsic to prevent the user from
    // storing intrinsic objects in the application and session object
    if (IID_IUnknown == riid || IID_IDispatch == riid || IID_IResponse == riid || IID_IDenaliIntrinsic == riid)
        *ppv = static_cast<IResponse *>(this);

    // Support IStream for ADO/XML
    else if (IID_IStream == riid)
        *ppv = static_cast<IStream *>(this);

    //Indicate that we support error information
    else if (IID_ISupportErrorInfo == riid)
        {
        if (m_pData)
            *ppv = &(m_pData->m_ISupportErrImp);
        }

    else if (IID_IMarshal == riid)
        {
        *ppv = static_cast<IMarshal *>(this);
        }

    //AddRef any interface we'll return.
    if (NULL != *ppv)
        {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
        }

    return ResultFromScode(E_NOINTERFACE);
    }


STDMETHODIMP_(ULONG) CResponse::AddRef(void)
    {
    if (m_fOuterUnknown)
        return m_punkOuter->AddRef();

    return InterlockedIncrement((LPLONG)&m_cRefs);
    }


STDMETHODIMP_(ULONG) CResponse::Release(void)
    {
    if (m_fOuterUnknown)
        return m_punkOuter->Release();

    DWORD cRefs = InterlockedDecrement((LPLONG)&m_cRefs);
    if (cRefs)
        return cRefs;

    delete this;
    return 0;
    }

/*===================================================================
CResponse::GetIDsOfNames

Special-case implementation for Response.WriteBlock and
Response.Write

Parameters:
    riid            REFIID reserved. Must be IID_NULL.
    rgszNames       OLECHAR ** pointing to the array of names to be mapped.
    cNames          UINT number of names to be mapped.
    lcid            LCID of the locale.
    rgDispID        DISPID * caller allocated array containing IDs
                    corresponging to those names in rgszNames.

Return Value:
    HRESULT      S_OK or a general error code.
===================================================================*/
STDMETHODIMP CResponse::GetIDsOfNames
(
REFIID riid,
OLECHAR **rgszNames,
UINT cNames,
LCID lcid,
DISPID *rgDispID
)
    {
    const DISPID dispidWrite      = 0x60020013;
    const DISPID dispidWriteBlock = 0x60020014;

    if (cNames == 1)
        {
        // first char 'W'
        if (rgszNames[0][0] == L'w' || rgszNames[0][0] == L'W')
            {
            // swtich on strlen
            switch (wcslen(rgszNames[0]))
                {
            case 5:
                // case insensitive because user can type either way
                if (wcsicmp(rgszNames[0], L"write") == 0)
                    {
                    *rgDispID = dispidWrite;
                    return S_OK;
                    }
                break;
            case 10:
                // case sensitive because only we generate WriteBlock
                if (wcscmp(rgszNames[0], L"WriteBlock") == 0)
                    {
                    *rgDispID = dispidWriteBlock;
                    return S_OK;
                    }
                break;
                }
            }
        }

    // default to CDispatch's implementation
    return CDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispID);
    }

/*===================================================================
CResponse::CheckForTombstone

Tombstone stub for IResponse methods. If the object is
tombstone, does ExceptionId and fails.

Parameters:

Returns:
    HRESULT     E_FAIL  if Tombstone
                S_OK if not
===================================================================*/
HRESULT CResponse::CheckForTombstone()
    {
    if (m_fInited)
        {
        // inited - good object
        Assert(m_pData); // must be present for inited objects
        return S_OK;
        }

    ExceptionId
        (
        IID_IResponse,
        IDE_RESPONSE,
        IDE_INTRINSIC_OUT_OF_SCOPE
        );
    return E_FAIL;
    }

/*===================================================================
CResponse::SyncWrite

Static method. Sends data until either everything is sent
or there's an error.

Parameters:
    pIReq        CIsapiReqInfo to send
    pchBuf      pointer to buffer to send
    cchBuf      number of bytes to send (0 means do strlen())

Returns:
    HRESULT
===================================================================*/
HRESULT CResponse::SyncWrite
(
CIsapiReqInfo *pIReq,
char *pchBuf,
DWORD cchBuf
)
    {
    Assert(pchBuf);
    if (cchBuf == 0)
        cchBuf = strlen(pchBuf);

    while (cchBuf)
        {
        // never send out more then MAX_RESPONSE bytes at one shot
        DWORD cchSend = (cchBuf < MAX_RESPONSE) ? cchBuf : MAX_RESPONSE;

        if (!pIReq->SyncWriteClient(pchBuf, &cchSend))
            return E_FAIL;

        AddtoTotalByteOut(cchSend);
        cchBuf -= cchSend;
        pchBuf += cchSend;
        }

    return S_OK;
    }

/*===================================================================
CResponse::SyncWriteFile

Static method.
Sends entire response as a content of the file

Parameters:
    pIReq            CIsapiReqInfo to send
    szFile          file name
    szMimeType      mime type
    szStatus        HTTP status
    szExtraHeaders  additional HTTP headers to send

Returns:
    HRESULT
===================================================================*/
HRESULT CResponse::SyncWriteFile
(
CIsapiReqInfo *pIReq,
TCHAR *szFile,
char *szMimeType,
char *szStatus,
char *szExtraHeaders
)
    {
    HRESULT hr = S_OK;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    HANDLE hMap = NULL;
    BYTE *pbBytes = NULL;
    DWORD dwSize = 0;

    // open the file
    if (SUCCEEDED(hr)) {
        hFile = CreateFile(
            szFile,
            GENERIC_READ,          // access (read-write) mode
            FILE_SHARE_READ,       // share mode
            NULL,                  // pointer to security descriptor
            OPEN_EXISTING,         // how to create
            FILE_ATTRIBUTE_NORMAL, // file attributes
            NULL                   // handle to file with attributes to copy
            );
        if (hFile == INVALID_HANDLE_VALUE) {
#if UNICODE
            DBGERROR((DBG_CONTEXT, "Could not open \"%S\".  Win32 Error = %u\n", szFile, GetLastError()));
#else
            DBGERROR((DBG_CONTEXT, "Could not open \"%s\".  Win32 Error = %u\n", szFile, GetLastError()));
#endif
            hr = E_FAIL;
        }
    }

    // get file size
    if (SUCCEEDED(hr))
        {
        dwSize = GetFileSize(hFile, NULL);
        if (dwSize == 0 || dwSize == 0xFFFFFFFF)
            hr = E_FAIL;
        }

    // create mapping
    if (SUCCEEDED(hr))
        {
        hMap = CreateFileMapping(
            hFile,          // handle to file to map
            NULL,           // optional security attributes
            PAGE_READONLY,  // protection for mapping object
            0,              // high-order 32 bits of object size
            0,              // low-order 32 bits of object size
            NULL            // name of file-mapping object
            );
        if (hMap == NULL)
            hr = E_FAIL;
        }

    // map the file
    if (SUCCEEDED(hr))
        {
        pbBytes = (BYTE *)MapViewOfFile(
            hMap,           // file-mapping object to map into address space
            FILE_MAP_READ,  // access mode
            0,              // high-order 32 bits of file offset
            0,              // low-order 32 bits of file offset
            0               // number of bytes to map
            );
        if (pbBytes == NULL)
            hr = E_FAIL;
        }

    // send the response
    if (SUCCEEDED(hr))
        {
        hr = SyncWriteBlock(pIReq, pbBytes, dwSize, szMimeType, szStatus, szExtraHeaders);
        }

    // cleanup
    if (pbBytes != NULL)
        UnmapViewOfFile(pbBytes);
    if (hMap != NULL)
        CloseHandle(hMap);
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);

    return hr;
    }

/*===================================================================
CResponse::SyncWriteScriptlessTemplate

Static method.
Sends entire response as a content of the [scriptless] template.

Parameters:
    pIReq        CIsapiReqInfo to send
    pTemplate   template

Returns:
    HRESULT
===================================================================*/
HRESULT CResponse::SyncWriteScriptlessTemplate
(
CIsapiReqInfo *pIReq,
CTemplate *pTemplate
)
    {
    Assert(pTemplate && pTemplate->FScriptless());

    char*   pbHTML = NULL;
    ULONG   cbHTML = 0;
    ULONG   cbSrcOffset = 0;
    char*   pbIncSrcFileName = NULL;

    HRESULT hr = pTemplate->GetHTMLBlock(0, &pbHTML, &cbHTML, &cbSrcOffset, &pbIncSrcFileName);

    if (FAILED(hr))
        return hr;
    if (pbHTML == NULL || cbHTML == 0)
        return E_FAIL;

    SyncWriteBlock(pIReq, pbHTML, cbHTML);
    return S_OK;
    }

/*===================================================================
CResponse::SyncWriteBlocks

Static method.
Sends entire response as a content of a set of memory blocks.

Parameters:
    pIReq            CIsapiReqInfo to send
    cBlocks         number of blocks
    cbTotal         total length of all blocks
    rgpvBlock       array of pointers to buffers
    rgcbBlock       array of block sizes
    szMimeType      mime type
    szStatus        HTTP status
    szExtraHeaders  additional HTTP headers to send

Returns:
    HRESULT
===================================================================*/
HRESULT CResponse::SyncWriteBlocks
(
CIsapiReqInfo *pIReq,
DWORD cBlocks,
DWORD cbTotal,
void **rgpvBlock,
DWORD *rgcbBlock,
char *szMimeType,
char *szStatus,
char *szExtraHeaders
)
    {
    BOOL fCacheControlPrivate = FALSE;

    STACK_BUFFER( tempContent, 1024);

    // defaut mime type and status

    if (szMimeType == NULL)
        szMimeType = (char *)GetResponseMimeType(pIReq);

    if (szStatus == NULL)
        {
        szStatus = (char *)s_szDefaultStatus;
        fCacheControlPrivate = TRUE;
        }
    else
        {
        fCacheControlPrivate = (strcmp(szStatus, s_szDefaultStatus) == 0);
        }

    // extra headers size

    DWORD cbExtra = (szExtraHeaders != NULL) ? strlen(szExtraHeaders) : 0;

    // send the header

    char szLength[20];
    ltoa(cbTotal, szLength, 10);

    DWORD cchContentHeader = (DWORD)(0
      + sizeof(s_szContentTypeHeader)-1     // Content-Type:
      + strlen(szMimeType)                  // text/html
      + 2                                   // \r\n
      + cbExtra                             // Extra headers
      + sizeof(s_szContentLengthHeader)-1   // Content-Length:
      + strlen(szLength)                    // <length>
      + 4                                   // \r\n\r\n
      + 1);                                 // '\0'

    if (fCacheControlPrivate)
        cchContentHeader += sizeof(s_szCacheControlPrivate)-1;

    if (!tempContent.Resize(cchContentHeader)) {
        return E_OUTOFMEMORY;
    }

    char *szContentHeader = (char *)tempContent.QueryPtr();

    char *szBuf = szContentHeader;

    szBuf = strcpyExA(szBuf, s_szContentTypeHeader);
    szBuf = strcpyExA(szBuf, szMimeType);
    szBuf = strcpyExA(szBuf, "\r\n");

    if (cbExtra > 0)
        szBuf = strcpyExA(szBuf, szExtraHeaders);

    if (fCacheControlPrivate)
        szBuf = strcpyExA(szBuf, s_szCacheControlPrivate);

    szBuf = strcpyExA(szBuf, s_szContentLengthHeader);
    szBuf = strcpyExA(szBuf, szLength);
    szBuf = strcpyExA(szBuf, "\r\n\r\n");

    BOOL fRet = pIReq->SendHeader
        (
        szStatus,
        strlen(szStatus) + 1,
        szContentHeader,
        cchContentHeader,
        FALSE
        );
    if (!fRet)
        return E_FAIL;

    // send the data

    for (DWORD i = 0; i < cBlocks; i++)
        {
        if (FAILED(SyncWrite(pIReq, (char *)rgpvBlock[i], rgcbBlock[i])))
            return E_FAIL;
        }

    return S_OK;
    }


//IResponse interface functions

/*===================================================================
CResponse::WriteHeaders

Write out standard HTTP headers and any user created headers.
If transmission of the headers to the client fails, we still
want the calling script to finish execution, so we will return
S_OK, but set the m_fWriteClientError flag. If we are unable
to build the needed headers we will return E_FAIL.

Parameters:
    BOOL fSendEntireResponse - send headers and body all at once?

Returns:
    HRESULT     S_OK on success
                E_FAIL if unable to build expires headers
                E_OUTOFMEMORY if memory failure
===================================================================*/
HRESULT CResponse::WriteHeaders(
    BOOL fSendEntireResponse)
{
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (FDontWrite())
        return S_OK;

    HRESULT hr = S_OK;
    CHAR *szBuff;
    DWORD cch = 0;
    BOOL fContentTypeFound = FALSE;

    // Static cookie buffer should be enough to fit:
    //   cookie name    20 chars
    //   cookie value   24 chars
    //   decorations    28 = strlen("Set-Cookie: C=V; secure; path=/;\r\n")
#define CCH_STATIC_COOKIE_BUF    88
    char szCookieBuff[CCH_STATIC_COOKIE_BUF];
    DWORD cchCookieBuff = 0;

    STACK_BUFFER( tempHeaders, 2048 );

    STACK_BUFFER( tempWSABUFs, 128 );

    AssertValid();

    // Loop through any headers counting up the length
    CHTTPHeader *pHeader = m_pData->m_pFirstHeader;
    while (pHeader) {
        cch += pHeader->CchLength();
        pHeader = pHeader->PNext();
    }

    // Add the content-type tag
    cch += sizeof(s_szContentTypeHeader)-1;
    cch += strlen(PContentType())+2;

    // Add the Character set tag
    if (m_pData->m_pszCharSet) {
        cch += sizeof(s_szCharSetHTML)-1;
        cch += strlen(m_pData->m_pszCharSet);
    }

    // Add the Expires tag
    if ((m_pData->m_tExpires != -1) || (m_pData->m_pszDefaultExpires != NULL))
        cch += DATE_STRING_SIZE + 11;   // DATE_STRING_SIZE + length("Expires: \r\n")

    // Add the cookies that we will send
    cch += m_pData->m_WriteCookies.QueryHeaderSize()+2;

    // Account for space required by headers we always send back.

    // Prepare cookie if any.
    if (m_pData->m_szCookieVal) {
        char *pchEnd = strcpyExA(szCookieBuff, "Set-Cookie: ");
        pchEnd = strcpyExA(pchEnd, g_szSessionIDCookieName);
        pchEnd = strcpyExA(pchEnd, "=");
        pchEnd = strcpyExA(pchEnd, m_pData->m_szCookieVal);

        // If we keep secure sessions secure, and this connection is secure,  add flag to cookie
        if ((m_pData->m_pHitObj->QueryAppConfig()->fKeepSessionIDSecure()) && 
            (m_pData->m_pHitObj->FSecure()))
        {
            pchEnd = strcpyExA(pchEnd,"; secure");
        }
        
        pchEnd = strcpyExA(pchEnd, "; path=/\r\n");
        cchCookieBuff = strlen(szCookieBuff);
        cch += cchCookieBuff;
        Assert(cchCookieBuff < CCH_STATIC_COOKIE_BUF);
    }
    else {
        szCookieBuff[0] = '\0';
        cchCookieBuff = 0;
    }

    // Will len of cache control header
    if (m_pData->m_pszCacheControl) {
        cch += sizeof(s_szCacheControl)-1;
        cch += strlen(m_pData->m_pszCacheControl)+2;
    }
    else {
        cch += sizeof(s_szCacheControlPrivate)-1;
    }

    // If using HTTP/1.1 and not buffering add length ofTransfer-Encoding headers
    if ((m_pData->m_dwVersionMinor >= 1) && (m_pData->m_dwVersionMajor >= 1) &&
        (m_pData->m_fBufferingOn == FALSE) &&
        !GetIReq()->IsChild()) { // don't chunk child request output

        // UNDONE: Temporary setting to turn off chuncked encoding
        if (Glob(fEnableChunkedEncoding))
            m_pData->m_fChunked = TRUE;
    }
    if (m_pData->m_fChunked)
        cch += sizeof(s_szTransferEncoding)-1;

    // Will terminate with \r\n.  Leave extra space
    cch += 2;

    /*
     * We know how big; allocate memory and build the string.
     */

    if (!tempHeaders.Resize(cch + 1)) {
        return E_OUTOFMEMORY;
    }
    szBuff = (LPSTR)tempHeaders.QueryPtr();
    *szBuff = '\0';

    char *szTmpBuf = szBuff;

    pHeader = m_pData->m_pFirstHeader;
    while (pHeader) {
        pHeader->Print(szTmpBuf);
        szTmpBuf += pHeader->CchLength();
        pHeader = pHeader->PNext();
    }

    // Send the content-type tag
    szTmpBuf = strcpyExA(szTmpBuf, s_szContentTypeHeader);
    szTmpBuf = strcpyExA(szTmpBuf, PContentType());

    // Send the CharSet tag if exists
    if (m_pData->m_pszCharSet) {
        szTmpBuf = strcpyExA(szTmpBuf, s_szCharSetHTML);
        szTmpBuf = strcpyExA(szTmpBuf, m_pData->m_pszCharSet);
    }

    szTmpBuf = strcpyExA(szTmpBuf, "\r\n");

    // Send the Expires tag
    if ((m_pData->m_tExpires != -1) || (m_pData->m_pszDefaultExpires != NULL)) {

        // if the script set an expires value, than use it
        if (m_pData->m_tExpires != -1) {
            szTmpBuf = strcpyExA(szTmpBuf, "Expires: ");
            if (FAILED(CTimeToStringGMT(&m_pData->m_tExpires, szTmpBuf)))
                return E_FAIL;
            szTmpBuf += strlen(szTmpBuf);
            szTmpBuf = strcpyExA(szTmpBuf, "\r\n");
        }
        // else, use the default value in the metabase.  Note that it already
        // includes the Expires: prefix and \r\n suffix
        else {

            szTmpBuf = strcpyExA(szTmpBuf, m_pData->m_pszDefaultExpires);
        }
    }

    // send the cookies
    m_pData->m_WriteCookies.GetHeaders(szTmpBuf);
    szTmpBuf += strlen(szTmpBuf);

    // Send the required headers: session id cookie and cache control
    szTmpBuf = strcpyExA(szTmpBuf, szCookieBuff);

    // Send the cache-control tag
    if (m_pData->m_pszCacheControl) {
        szTmpBuf = strcpyExA(szTmpBuf, s_szCacheControl);
        szTmpBuf = strcpyExA(szTmpBuf, m_pData->m_pszCacheControl);
        szTmpBuf = strcpyExA(szTmpBuf, "\r\n");
    }
    else {
        szTmpBuf = strcpyExA(szTmpBuf, s_szCacheControlPrivate);
    }

    // Chunked encoding
    if (m_pData->m_fChunked)
        szTmpBuf = strcpyExA(szTmpBuf, s_szTransferEncoding);

    // Add trailing \r\n to terminate headers
    szTmpBuf = strcpyExA(szTmpBuf, "\r\n");

    Assert(strlen(szBuff) <= cch);

    // Output the headers
    // Failure is not a fatal error, so we still return success
    // but set the m_fWriteClient flag
    CHAR *szStatus = m_pData->m_pszStatus ? m_pData->m_pszStatus
                                          : (CHAR *)s_szDefaultStatus;

    BOOL fKeepConnected =
        (m_pData->m_fBufferingOn && !m_pData->m_fFlushed) || m_pData->m_fChunked;

    BOOL fHeaderSent;
    DWORD cchStatus = strlen(szStatus) + 1;
    DWORD cchHeader = strlen(szBuff) + 1;

    if ( !fSendEntireResponse ) {
        fHeaderSent = GetIReq()->SendHeader
                            (
                            szStatus,
                            cchStatus,
                            szBuff,
                            cchHeader,
                            fKeepConnected
                            );
    }
    else {
        BOOL    fSendDebugBuffers = (m_pData->m_fClientDebugMode && m_pData->m_pClientDebugBuffer);

        // if we are sending both headers and body at once, we put
        // all of our content into an optimized struct which we pass
        // to an optimized api

        HSE_SEND_ENTIRE_RESPONSE_INFO   tempHseResponseInfo;
        HSE_SEND_ENTIRE_RESPONSE_INFO * pHseResponseInfo = &tempHseResponseInfo;

        // populate struct with header info
        pHseResponseInfo->HeaderInfo.pszStatus = szStatus;
        pHseResponseInfo->HeaderInfo.cchStatus = cchStatus;
        pHseResponseInfo->HeaderInfo.pszHeader = szBuff;
        pHseResponseInfo->HeaderInfo.cchHeader = cchHeader;
        pHseResponseInfo->HeaderInfo.fKeepConn = fKeepConnected;

        // populate struct with response body buffers (and, if required, debug buffers)
        //
        // NOTE: To send an entire response whose data (body)
        // is contained in N buffers, caller must allocate N+1 buffers
        // and fill buffers 1 through N with its data buffers.
        // IIS will fill the extra buffer (buffer 0) with header info.
        //
        CResponseBuffer * pResponseBuffer = m_pData->m_pResponseBuffer;
        CResponseBuffer * pClientDebugBuffer = (fSendDebugBuffers
                                               ? m_pData->m_pClientDebugBuffer
                                               : NULL);

        DWORD   cResponseBuffers = pResponseBuffer->CountOfBuffers();
        DWORD   cClientDebugBuffers = ( fSendDebugBuffers
                                        ? pClientDebugBuffer->CountOfBuffers()
                                        : 0);
        Assert(cResponseBuffers);

        pHseResponseInfo->cWsaBuf = 1 + cResponseBuffers + cClientDebugBuffers;

        if (!tempWSABUFs.Resize(pHseResponseInfo->cWsaBuf * sizeof(WSABUF))) {
            return E_OUTOFMEMORY;
        }

        pHseResponseInfo->rgWsaBuf = static_cast<WSABUF *>(tempWSABUFs.QueryPtr());

        //  zero-out the empty array slot - allows IIS to assert that it is "available"
        pHseResponseInfo->rgWsaBuf[0].len = 0;
        pHseResponseInfo->rgWsaBuf[0].buf = NULL;

        UINT i;
        // fill buffers 1 through N with our buffers 0 through N-1 (see NOTE above)
        // buffers 1 through N will be debug buffers, if required, followed by response body buffers
        for ( i = 0; i < cClientDebugBuffers; i++ ) {
            pHseResponseInfo->rgWsaBuf[i+1].len = pClientDebugBuffer->GetBufferSize(i);
            pHseResponseInfo->rgWsaBuf[i+1].buf = pClientDebugBuffer->GetBuffer(i);
        }

        for ( i = 0; i < cResponseBuffers; i++ ) {
            pHseResponseInfo->rgWsaBuf[i + 1 + cClientDebugBuffers].len = pResponseBuffer->GetBufferSize(i);
            pHseResponseInfo->rgWsaBuf[i + 1 + cClientDebugBuffers].buf = pResponseBuffer->GetBuffer(i);
        }

        // send entire response (headers and body) at once
        if( g_fOOP ) {
            fHeaderSent = GetIReq()->SendEntireResponseOop(pHseResponseInfo);
        }
        else {
            fHeaderSent = GetIReq()->SendEntireResponse(pHseResponseInfo);
        }
    }

    if (!fHeaderSent) {
        m_pData->m_fWriteClientError = TRUE;
    }
    else {
        m_pData->m_fHeadersWritten = TRUE;
        //PERF ADD-ON
        AddtoTotalByteOut(cch);
    }

    return(hr);
    }


/*===================================================================
CResponse::Write

Writes a string to the client.

It accepts a variant as an argument and attempts to coerce that
variant into a BSTR. We convert that BSTR into an ANSI string,
and then hand that ANSI string to Response::WriteSz which sends
it back to the client.

Normally a VT_NULL variant cannot be coerced to a BSTR, but we want
VT_NULL to be a valid input, therefore we explictly handle the case of
variants of type VT_NULL. If the type of the input variant is VT_NULL
we return S_OK, but don't send anything back to the client.

If we are handed a VT_DISPATCH variant, we resolve it by repeatedly calling
Dispatch on the associated pdispVal, until we get back a variant that is not
a VT_DISPATCH. VariantChangeType would ordinarily handle this for us, but the
final resulting variant might be a VT_NULL which VariantChangeType would not
coerce into a BSTR. This is why we have to handle walking down the VT_DISPATC
variants outselves.

Parameters:
    VARIANT     varInput, value: the variant to be converted to string
                                  and written to the client

Returns:
    S_OK on success. E_FAIL on failure.

===================================================================*/
STDMETHODIMP CResponse::Write(VARIANT varInput)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT hr = S_OK;
    DWORD cch;
    LPSTR szT;
    BSTR  bstr;
    VARIANT varResolved;

    static char szTrue[MAX_MESSAGE_LENGTH];
    static char szFalse[MAX_MESSAGE_LENGTH];

    AssertValid();

    // If we've already had an error writing to the client
    // there is no point in proceding, so we immediately return
    // with no error
    if (FDontWrite())
        goto lRet2;

    // If already BSTR (directly or as VARIANT by ref)
    bstr = VariantGetBSTR(&varInput);
    if (bstr != NULL)
        {
        hr = WriteBSTR(bstr);
        goto lRet2;
        }

    // If the variant passed in is a VT_DISPATCH, get its default property
    if (FAILED(hr = VariantResolveDispatch(&varResolved, &varInput, IID_IResponse, IDE_RESPONSE)))
        goto lRet2;

    // Check if the variant in is VT_NULL
    if (V_VT(&varResolved) == VT_NULL)
        goto lRet;                  // S_OK, but don't send anything to the client

    // Check if the variant in is VT_BOOL
    if(V_VT(&varResolved) == VT_BOOL)
        {
        if (V_BOOL(&varResolved) == VARIANT_TRUE)
            {
            if (szTrue[0] == '\0')
                cch = CchLoadStringOfId(IDS_TRUE, szTrue, MAX_MESSAGE_LENGTH);
            szT = szTrue;
            }
        else
            {
            if(szFalse[0] == '\0')
                cch = CchLoadStringOfId(IDS_FALSE, szFalse, MAX_MESSAGE_LENGTH);
            szT = szFalse;
            }
        cch = strlen(szT);
        if (FAILED(hr = WriteSz(szT, cch)))
            {
            if (E_OUTOFMEMORY == hr)
                ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
            else
                ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_UNEXPECTED);
            }
        goto lRet;
        }

    // Coerce the variant into a bstr if necessary
    if (V_VT(&varResolved) != VT_BSTR)
        {
        if (FAILED(hr = VariantChangeTypeEx(&varResolved, &varResolved, m_pData->m_pHitObj->GetLCID(), 0, VT_BSTR)))
            {
            switch (GetScode(hr))
                {
                case E_OUTOFMEMORY:
                    ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
                    break;
                case DISP_E_OVERFLOW:
                    hr = E_FAIL;
                    ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_UNABLE_TO_CONVERT);
                    break;
                case DISP_E_TYPEMISMATCH:
                    ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_TYPE_MISMATCH);
                    break;
                default:
                    ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_UNEXPECTED);
                }
            goto lRet;
            }
        }

    hr = WriteBSTR(V_BSTR(&varResolved));

lRet:
#ifdef DBG
    hr =
#endif // DBG
    VariantClear(&varResolved);
    Assert(SUCCEEDED(hr));
lRet2:
    return(hr);
    }

/*===================================================================
CResponse::BinaryWrite

Function called from DispInvoke to invoke the BinaryWrite method.

Parameters:
    varInput    Variant which must resolve to an array of unsigned bytes

Returns:
    S_OK on success. E_FAIL on failure.

===================================================================*/
STDMETHODIMP CResponse::BinaryWrite(VARIANT varInput)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT hr = S_OK;
    DWORD nDim = 0;
    long lLBound = 0;
    long lUBound = 0;
    void *lpData = NULL;
    DWORD cch = 0;
    VARIANT varResolved;
    SAFEARRAY* pvarBuffer;

    AssertValid();

    // If we've already had an error writing to the client
    // there is no point in proceding, so we immediately return
    // with no error
    if (FDontWrite())
        goto lRet2;

    // De-reference and de-dispatch the variant
    if (FAILED(hr = VariantResolveDispatch(&varResolved, &varInput, IID_IResponse, IDE_RESPONSE)))
        goto lRet2;

    // Coerce the result into an array of VT_UI1 if needed
    if (V_VT(&varResolved) != (VT_ARRAY|VT_UI1))
        {
        if (FAILED(hr = VariantChangeType(&varResolved, &varResolved, 0, VT_ARRAY|VT_UI1)))
            {
            switch (GetScode(hr))
                {
                case E_OUTOFMEMORY:
                    ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
                    break;
                case DISP_E_OVERFLOW:
                    hr = E_FAIL;
                    ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_UNABLE_TO_CONVERT);
                    break;
                case DISP_E_TYPEMISMATCH:
                    ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_TYPE_MISMATCH);
                    break;
                default:
                    ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_UNEXPECTED);
                }
            goto lRet;
            }
        }

    // We got here, so we must have a variant containing a safe array of UI1 in varResolved
    pvarBuffer = V_ARRAY(&varResolved);

    nDim = SafeArrayGetDim(pvarBuffer);
    if (nDim != 1)
        {
        hr = E_INVALIDARG;
        goto lRet;
        }

    if (FAILED(SafeArrayGetLBound(pvarBuffer, 1, &lLBound)))
        {
        hr = E_INVALIDARG;
        goto lRet;
        }

    if (FAILED(SafeArrayGetUBound(pvarBuffer, 1, &lUBound)))
        {
        hr = E_INVALIDARG;
        goto lRet;
        }

    if (FAILED(SafeArrayAccessData(pvarBuffer, &lpData)))
        {
        hr = E_INVALIDARG;
        goto lRet;
        }
    cch = lUBound - lLBound + 1;

    if (m_pData->m_fBufferingOn)
        {
        // Buffering is on
        if (FAILED(hr = m_pData->m_pResponseBuffer->Write((char *) lpData, cch)))
            {
            // We can't buffer the ouput, so quit
            SafeArrayUnaccessData(pvarBuffer);
            if (E_OUTOFMEMORY == hr)
                ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
            else
                ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_UNEXPECTED);
            goto lRet;
            }
        }
    else
        {
        // Buffering is off
        // If this is the first write response, then output the headers first
        if (!FHeadersWritten())  // bug 512: write hdrs even if global.asa
            {
            if (FAILED(hr = WriteHeaders()))
                {
                if (E_OUTOFMEMORY == hr)
                    ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
                else
                    ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_UNEXPECTED);
                }
            }

        // If this is not a head request we transmit the string to the clienet
        if (SUCCEEDED(hr) && !IsHeadRequest() && !FDontWrite())
            WriteClient((BYTE *) lpData, cch);
        }

    hr = SafeArrayUnaccessData(pvarBuffer);

lRet:
    VariantClear(&varResolved);
lRet2:
    return(hr);
    }

/*===================================================================
CResponse::WriteSz

Support routine for the Write method to write the string.  Unlike
CResponse::Write(), this routine takes an Ascii string, and is
not intended to be exposed as a method

Parameters:
    sz - String to write as an Ascii string
    cch - Length of string to write

Returns:
    S_OK on success.

===================================================================*/
HRESULT CResponse::WriteSz(CHAR *sz, DWORD cch)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT hr = S_OK;

    AssertValid();

    // If we've already had an error writing to the client
    // there is no point in proceding, so we immediately return
    // with no error
    if (FDontWrite())
        goto lRet;

    if (m_pData->m_fBufferingOn)
        {
        // Buffering is on
        hr = m_pData->m_pResponseBuffer->Write(sz, cch);
        }
    else
        {
        // Buffering is off
        if (!FHeadersWritten())  // bug 512: write hdrs even if global.asa
            {
            // This is the first response, then output the headers first
            if (FAILED(hr = WriteHeaders()))
                goto lRet;
            }

        // If this is not a head request we transmit the string to the client
        if (!IsHeadRequest() && !FDontWrite())
            WriteClient((BYTE *) sz, cch);
        }

lRet:
    return(hr);
    }

/*===================================================================
CResponse::WriteBSTR

Support routine for the Write method

Parameters:
    BSTR - String to write as an Ascii string

Returns:
    S_OK on success.
===================================================================*/
HRESULT CResponse::WriteBSTR(BSTR bstr)
    {
    CWCharToMBCS  convStr;
    HRESULT       hr = NO_ERROR;

    if (FAILED(hr = convStr.Init(bstr, m_pData->m_pHitObj->GetCodePage())));


    else hr = WriteSz(convStr.GetString(), convStr.GetStringLen());

    if (FAILED(hr))
        {
        if (E_OUTOFMEMORY == hr)
            ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        else
            ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_UNEXPECTED);
        }

    return hr;
    }

/*===================================================================
CResponse::WriteBlock

Function called from DispInvoke to invoke the WriteBlock method.

Parameters:
    Identifier for the HTML block

Returns:
    S_OK on success. E_FAIL on failure.

===================================================================*/
HRESULT CResponse::WriteBlock(short iBlockNumber)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT hr = S_OK;
    char*   pbHTML = NULL;
    ULONG   cbHTML = 0;
    ULONG   cbSrcOffset = 0;
    char*   pbIncSrcFileName = NULL;

    AssertValid();

    // If we've already had an error writing to the client
    // there is no point in proceding, so we immediately return
    // with no error
    if (FDontWrite())
        goto lRet;

    // bail out (and assert) if template is null
    Assert(m_pData->m_pTemplate != NULL);
    if (m_pData->m_pTemplate == NULL)
        {
        hr = E_FAIL;
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_UNEXPECTED);
        goto lRet;
        }

    /*
        get ptr and byte count for html block from template
        NOTE: by design, this public template call cannot fail because we give it a block id
        generated during template compilation (instead we assert within and after the call)

        I added the return HRESULT to catch for invalid user access of this method, if a user
        attempts to access this method and passes an invalid array offset it will return the
        error IDE_BAD_ARRAY_INDEX, this really should not happen except for the case of a user
        attempting to access this hidden method.
    */


    hr = m_pData->m_pTemplate->GetHTMLBlock(iBlockNumber, &pbHTML, &cbHTML, &cbSrcOffset, &pbIncSrcFileName);
    if ( hr != S_OK )
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_BAD_ARRAY_INDEX);
        goto lRet;
        }

    Assert(pbHTML);
    Assert(cbHTML > 0);

    if (m_pData->m_fBufferingOn)
        {
        hr = S_OK;

        // Take care of Client Debugger issues
        if (m_pData->m_fClientDebugMode && m_pData->m_pClientDebugBuffer)
            {
            if (cbSrcOffset) // only if source info is known
                {
                // Write a METADATA line corresponding to this block
                // into ClientDebugBuffer
                ULONG cbPos = m_pData->m_pResponseBuffer->BytesBuffered() + 1;
                ULONG cbLen = cbHTML;

                hr  = m_pData->m_pClientDebugBuffer->AppendRecord(
                    cbPos, cbLen, cbSrcOffset, pbIncSrcFileName);
                }
            }

        // Write the actual data
        if (SUCCEEDED(hr))
            hr = m_pData->m_pResponseBuffer->Write(pbHTML, cbHTML);

        // Buffering is on
        if (FAILED(hr))
            {
            if (E_OUTOFMEMORY == hr)
                ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
            else
                ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_UNEXPECTED);
            }
        }
    else
        {
        // Buffering is off
        if (!FHeadersWritten())  // bug 512: write hdrs even if global.asa
            {
            // This is the first response.write, so output the headers
            if (FAILED(hr = WriteHeaders()))
                {
                if (E_OUTOFMEMORY == hr)
                    ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
                else
                    ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_UNEXPECTED);
                goto lRet;
                }
            }

        // If this is not a head request we transmit the string to the clienet
        if (!IsHeadRequest() && !FDontWrite())
            {
                WriteClient((BYTE * ) pbHTML, cbHTML);
            }
        }

lRet:
    return(hr);
    }

/*===================================================================
CResponse::GetClientVersion

Uses GetServerVariable to determine the HTTP version of the client.
Borrowed from simiarl code in w3 server Httpreq.cxx, OnVersion()

Parameters:

    None

Returns:
    None
===================================================================*/
VOID CResponse::GetClientVerison()
    {
    if (FAILED(CheckForTombstone()))
        return;

    if (m_pData->m_pIReq)
        {
        m_pData->m_dwVersionMajor = (BYTE)m_pData->m_pIReq->QueryHttpVersionMajor();
        m_pData->m_dwVersionMinor = (BYTE)m_pData->m_pIReq->QueryHttpVersionMinor();
        }
    else
        {
        // Assume version 0.9
        m_pData->m_dwVersionMajor = 0;
        m_pData->m_dwVersionMinor = 9;
        }
    }

/*===================================================================
CResponse::WriteClient

Wrapper for the ISAPI WriteClient method. Use for non-buffered responses
by the WriteSz, BinaryWrite, and WriteBlock methods.

Parameters:

    sz - pointer to buffer to write
    cch - Length of buffer

Returns:
    HRESULT     S_OK if ok
===================================================================*/
HRESULT CResponse::WriteClient(BYTE *pb, DWORD cb)
    {
    HRESULT hr = S_OK;

    if (m_pData->m_fChunked)
        return WriteClientChunked(pb, cb);

    if (FAILED(CResponse::SyncWrite(GetIReq(), (char *)pb, cb)))
        m_pData->m_fWriteClientError = TRUE;

    return hr;
    }

/*===================================================================
CResponse::WriteClientChunked

Wrapper for the ISAPI WriteClient method using chunk transfer encoding.
Use for non-buffered responses by the WriteSz, BinaryWrite, and WriteBlock
methods if using HTTP 1.1

Each chunk is prefaced with the size of the chunk and terminated with a CRLF

Parameters:
    sz - pointer to buffer to write
    cch - Length of buffer

Returns:
    HRESULT     S_OK if ok
===================================================================*/
HRESULT CResponse::WriteClientChunked(BYTE *pb, DWORD cb)
    {
    HRESULT hr = S_OK;

    if (cb == 0)
        return hr;

    char *pchBuf = NULL;
    const int cchMaxChunkOverhead = 16;

    if (cb + cchMaxChunkOverhead < ALLOCA_LIMIT) {
        TRY
            pchBuf = (char *)_alloca(cb + cchMaxChunkOverhead);
        CATCH(hrException)
            // if exception occurred, just make sure that pchBuf is NULL and
            // let the routine continue
            pchBuf = NULL;
        END_TRY
    }

    if (pchBuf)
        {
        // fill in new buffer and do one single send
        char *pch = pchBuf;

        // chunk length
        _itoa(cb, pch, 16);
        pch += strlen(pch);

        // CR LF
        *pch++ = '\r';
        *pch++ = '\n';

        // buffer
        memcpy(pch, pb, cb);
        pch += cb;

        // CR LF
        *pch++ = '\r';
        *pch++ = '\n';

        *pch = '\0';

        // Send
        if (FAILED(CResponse::SyncWrite(GetIReq(), pchBuf, DIFF(pch-pchBuf))))
            m_pData->m_fWriteClientError = TRUE;
        }
    else
        {
        // do multiple sends

        char szLen[12];
        _itoa(cb, szLen, 16);
        DWORD cchLen = strlen(szLen);
        szLen[cchLen++] = '\r';
        szLen[cchLen++] = '\n';
        szLen[cchLen] = '\0';

        // send length
        if (FAILED(CResponse::SyncWrite(GetIReq(), szLen, cchLen)))
            m_pData->m_fWriteClientError = TRUE;

        // send buffer
        else if (FAILED(CResponse::SyncWrite(GetIReq(), (char *)pb, cb)))
            m_pData->m_fWriteClientError = TRUE;

        // send trailing CR LF
        else if (FAILED(CResponse::SyncWrite(GetIReq(), "\r\n", 2)))
            m_pData->m_fWriteClientError = TRUE;
        }

    return hr;
    }

/*===================================================================
CResponse::AppendHeader

Functions to add headers of different kind
(hardcoded and user-supplied)

Parameters:
    Name, Value

Returns:
    HRESULT         S_OK if ok

===================================================================*/
HRESULT CResponse::AppendHeader(BSTR wszName, BSTR wszValue)
    {
    CHTTPHeader *pHeader = new CHTTPHeader;
    if (!pHeader)
        return E_OUTOFMEMORY;
    if (FAILED(pHeader->InitHeader(wszName, wszValue,m_pData->m_pHitObj->GetCodePage())))
        {
        delete pHeader;
        return E_FAIL;
        }
    m_pData->AppendHeaderToList(pHeader);
    return S_OK;
    }

HRESULT CResponse::AppendHeader(char *szName, BSTR wszValue)
    {
    CHTTPHeader *pHeader = new CHTTPHeader;
    if (!pHeader)
        return E_OUTOFMEMORY;
    if (FAILED(pHeader->InitHeader(szName, wszValue,m_pData->m_pHitObj->GetCodePage())))
        {
        delete pHeader;
        return E_FAIL;
        }
    m_pData->AppendHeaderToList(pHeader);
    return S_OK;
    }

HRESULT CResponse::AppendHeader(char *szName, char *szValue, BOOL fCopyValue)
    {
    CHTTPHeader *pHeader = new CHTTPHeader;
    if (!pHeader)
        return E_OUTOFMEMORY;
    if (FAILED(pHeader->InitHeader(szName, szValue, fCopyValue)))
        {
        delete pHeader;
        return E_FAIL;
        }
    m_pData->AppendHeaderToList(pHeader);
    return S_OK;
    }

HRESULT CResponse::AppendHeader(char *szName, long lValue)
    {
    CHTTPHeader *pHeader = new CHTTPHeader;
    if (!pHeader)
        return E_OUTOFMEMORY;
    if (FAILED(pHeader->InitHeader(szName, lValue)))
        {
        delete pHeader;
        return E_FAIL;
        }
    m_pData->AppendHeaderToList(pHeader);
    return S_OK;
    }

/*===================================================================
CResponse::get_ContentType

Functions called from DispInvoke to return the ContentType property.

Parameters:
    pbstrContentTypeRet     BSTR FAR *, return value: pointer to the ContentType as a string

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::get_ContentType
(
BSTR FAR * pbstrContentTypeRet
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT hr = S_OK;

    hr = SysAllocStringFromSz((char *)PContentType(), 0, pbstrContentTypeRet);
    if (FAILED(hr))
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        hr = E_FAIL;
        }
    return(hr);
    }

/*===================================================================
CResponse::put_ContentType

Functions called from DispInvoke to set the ContentType property.

Parameters:
    bstrContentType     BSTR, value: the ContentType as a string

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::put_ContentType
(
BSTR bstrContentType
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT       hr = S_OK;
    CWCharToMBCS  convStr;

    if (FHeadersWritten())
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_HEADERS_WRITTEN);
        hr = E_FAIL;
        goto lRet;
        }

    if (m_pData->m_pszContentType) {
        free(m_pData->m_pszContentType);
        m_pData->m_pszContentType = NULL;
    }

    if (FAILED(hr = convStr.Init(bstrContentType)));

    else if ((m_pData->m_pszContentType = convStr.GetString(TRUE)) == NULL) {
        hr = E_OUTOFMEMORY;
    }

lRet:
    if (hr == E_OUTOFMEMORY) {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        SetLastError((DWORD)E_OUTOFMEMORY);
    }
    return(hr);
    }


/*===================================================================
CResponse::get_Status

Function called from DispInvoke to return the Status property.

Parameters:
    pbstrStatusRet      BSTR FAR *, return value: pointer to the Status as a string

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::get_Status
(
BSTR FAR * pbstrStatusRet
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT hr = S_OK;
    if (m_pData->m_pszStatus)
        hr = SysAllocStringFromSz(m_pData->m_pszStatus, 0, pbstrStatusRet);
    else
        hr = SysAllocStringFromSz((CHAR *)s_szDefaultStatus, 0, pbstrStatusRet);
    if (FAILED(hr))
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        hr = E_FAIL;
        }
    return(hr);
    }

/*===================================================================
CResponse::put_Status

Function called from DispInvoke to set the ContentType property.

Parameters:
    bstrStatus      BSTR, value: the status as a string

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::put_Status
(
BSTR bstrStatus
)
    {
    DWORD dwStatus = 200;

    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT      hr = S_OK;
    CWCharToMBCS convStr;

    if (FHeadersWritten())
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_HEADERS_WRITTEN);
        hr = E_FAIL;
        goto lRet;
        }

    if (m_pData->m_pszStatus) {
        free(m_pData->m_pszStatus);
        m_pData->m_pszStatus = NULL;
    }

    if (FAILED(hr = convStr.Init(bstrStatus)));

    else if ((m_pData->m_pszStatus = convStr.GetString(TRUE)) == NULL) {
        hr = E_OUTOFMEMORY;
    }
    else {
        dwStatus = atol(m_pData->m_pszStatus);
        GetIReq()->SetDwHttpStatusCode(dwStatus);
    }

lRet:
    if (hr == E_OUTOFMEMORY) {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        SetLastError((DWORD)E_OUTOFMEMORY);
    }
    return(hr);
    }

/*===================================================================
CResponse::get_Expires

Function called from DispInvoke to return the Expires property.

Parameters:
    plExpiresTimeRet        long *, return value: pointer to number of minutes until response expires

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::get_Expires
(
VARIANT * pvarExpiresTimeRet
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    // return early if we can
    //
    if (m_pData->m_tExpires == -1)
        {
        V_VT(pvarExpiresTimeRet) = VT_NULL;
        return S_OK;
        }

    // get the current time
    //
    time_t tNow;
    time(&tNow);

    // get the time difference and round to the nearest minute
    //
    V_VT(pvarExpiresTimeRet) = VT_I4;
    V_I4(pvarExpiresTimeRet) = long((difftime(m_pData->m_tExpires, tNow) / 60) + 0.5);
    return S_OK;
    }

/*===================================================================
CResponse::put_Expires

Functions called from DispInvoke to set the expires property.

Parameters:
    iValue      int, value: the number of minutes until response should expire

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::put_Expires
(
long lExpiresMinutes
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (FHeadersWritten())
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_HEADERS_WRITTEN);
        return E_FAIL;
        }

    // get the current time
    //
    time_t tNow;
    time(&tNow);
    time_t tRelativeTime;
    // add the number of minuites.  (must convert to seconds first)
    //
    tRelativeTime = lExpiresMinutes * 60;
    if ((lExpiresMinutes < 0 && tRelativeTime > 0)
        || (lExpiresMinutes > 0 && tRelativeTime < 0))
        {
        // overflow, tRelativeTime could be a small positive integer if lExpiresMinutes is
        // some value like 0x80000010
        // tNow will be overflowed if tRelativeTime is negative
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_COOKIE_BAD_EXPIRATION);
        return E_FAIL;
        }

    tNow += tRelativeTime;

    // Store the date if
    //      a. No date was stored previously
    //      b. This date comes before the previously set date.
    //
    if (m_pData->m_tExpires == -1 || tNow < m_pData->m_tExpires)
        {
        struct tm *ptmGMT = gmtime(&tNow);
        if (ptmGMT == NULL)
            {
            ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_COOKIE_BAD_EXPIRATION);
            return E_FAIL;
            }

        m_pData->m_tExpires = tNow;
        }
        // convert time to GMT
    return S_OK;
    }

/*===================================================================
CResponse::get_ExpiresAbsolute

Function called from DispInvoke to return the ExpiresAbsolute property.

Parameters:
    pbstrTimeRet    BSTR *, return value: pointer to string that will contain
                    the time response should expire

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::get_ExpiresAbsolute
(
VARIANT *pvarTimeRet
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    V_VT(pvarTimeRet) = VT_DATE;
    CTimeToVariantDate(&m_pData->m_tExpires, &V_DATE(pvarTimeRet));
    return S_OK;
    }

/*===================================================================
CResponse::put_ExpiresAbsolute

Function called from DispInvoke to set the ExpiresAbsolute property.

Parameters:
    pbstrTime       BSTR, value: time response should expire

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::put_ExpiresAbsolute
(
DATE dtExpires
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (FHeadersWritten())
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_HEADERS_WRITTEN);
        return E_FAIL;
        }

    if (int(dtExpires) == 0)                    // time specified but no date (assume today)
        {
        time_t tToday;                                          // get the date and time now
        DATE dtToday;

        time(&tToday);
        struct tm *tmToday = localtime(&tToday);

        tmToday->tm_hour = tmToday->tm_min = tmToday->tm_sec = 0;       // reset to midnight
        tToday = mktime(tmToday);

        if (FAILED(CTimeToVariantDate(&tToday, &dtToday)))
            return E_FAIL;

        dtExpires += dtToday;
        }

    time_t tExpires;
    if (FAILED(VariantDateToCTime(dtExpires, &tExpires)))
        {
        ExceptionId(IID_IWriteCookie, IDE_RESPONSE, IDE_COOKIE_BAD_EXPIRATION);
        return E_FAIL;
        }

    if (m_pData->m_tExpires == -1 || tExpires < m_pData->m_tExpires)
        {
        m_pData->m_tExpires = tExpires;
        }

    return S_OK;
    }

/*===================================================================
CResponse::put_Buffer

Function called from DispInvoke to set the Buffer property.

Parameters:
    fIsBuffering        VARIANT_BOOL, if true turn on buffering of HTML output

Returns:
    HRESULT     S_OK if ok

Side Effects:
    Turning buffering on will cause memory to be allocated.
===================================================================*/
STDMETHODIMP CResponse::put_Buffer
(
VARIANT_BOOL fIsBuffering
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    // Assume TRUE if not 0
    if (fIsBuffering != VARIANT_FALSE)
        fIsBuffering = VARIANT_TRUE;

    // Ignore no change requests
    if ((fIsBuffering == VARIANT_TRUE) && m_pData->m_fBufferingOn)
        return S_OK;
    if ((fIsBuffering == VARIANT_FALSE) && !m_pData->m_fBufferingOn)
        return S_OK;

    // Ignore if change is not allowed to change (Client Dedug)
    if (m_pData->m_fClientDebugMode)
        return S_OK;

    // Set the new value (error if cannot change)

    if (fIsBuffering == VARIANT_TRUE)
        {
        if (FHeadersWritten())
            {
            ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_HEADERS_WRITTEN);
            return E_FAIL;
            }

        m_pData->m_fBufferingOn = TRUE;
        }
    else // if (fIsBuffering == VARIANT_FALSE)
        {
        if ((m_pData->m_pResponseBuffer->BytesBuffered() > 0) ||
            FHeadersWritten())
            {
            // If we already buffered some output it is too late to go back
            ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_CANT_STOP_BUFFER);
            return E_FAIL;
            }

        m_pData->m_fBufferingOn = FALSE;
        }

    return S_OK;
    }

/*===================================================================
CResponse::get_Buffer

Function called from DispInvoke to get the Buffer property.

Parameters:
    fIsBuffering        VARIANT_BOOL, value: if true turn buffering of HTML output
                        is turned on

Returns:
    HRESULT         S_OK if ok

Side Effects:
    None

===================================================================*/
STDMETHODIMP CResponse::get_Buffer
(
VARIANT_BOOL *fIsBuffering
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT hr = S_OK;

    if (m_pData->m_fBufferingOn)
        *fIsBuffering = VARIANT_TRUE;
    else
        *fIsBuffering = VARIANT_FALSE;

    return(hr);
    }

/*===================================================================
CResponse::Redirect

Function called from DispInvoke to invoke the Redirect method.

Parameters:
    bstrURL Unicode BSTR    Value: URL to rediect to

Returns:
    S_OK on success. E_FAIL on failure.

===================================================================*/
STDMETHODIMP CResponse::Redirect(BSTR bstrURL)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    AssertValid();

    HRESULT hr = S_OK;
    DWORD cch = 0;
    DWORD cchURL = 0;
    DWORD cchMessage = 0;
    char *szURL = NULL;
    char *szMessage = NULL;
    DWORD  cchEncodedURL;
    char *pszEncodedURL = NULL;
    char *pszURL = NULL;
    CWCharToMBCS  convURL;

    STACK_BUFFER( tempURL, 256 );
    STACK_BUFFER( tempMessage, 256 + 512 );


    // Insist that we have a non-zero length URL
    if (bstrURL)
        cchURL = wcslen(bstrURL);

    if (cchURL == 0)
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_NO_URL);
        hr =  E_FAIL;
        goto lRet;
        }

    // Check that we haven't already passed data back to the client
    if (FHeadersWritten())
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_HEADERS_WRITTEN);
        hr = E_FAIL;
        goto lRet;
        }

    // If buffering is on, clear any pending output
    if (m_pData->m_fBufferingOn)
        Clear();

        // turn buffering on for this response.
        m_pData->m_fBufferingOn = TRUE;

    // BUGBUG - should this be 65001?

    if (FAILED(hr = convURL.Init(bstrURL, m_pData->m_pHitObj->GetCodePage()))) {
        if (hr == E_OUTOFMEMORY)
            ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        goto lRet;
    }

    pszURL = convURL.GetString();

    cchEncodedURL = URLPathEncodeLen(pszURL);

    if (!tempURL.Resize(cchEncodedURL)) {
        hr = E_OUTOFMEMORY;
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        goto lRet;
    }

    pszEncodedURL = (CHAR *)tempURL.QueryPtr();

    URLPathEncode(pszEncodedURL, pszURL);

    // We need to alloccate memory to build the body redirection message.
    // If our memory requirement is small we allocate memory from the stack,
    // otherwise we allocate from the heap.
    cchMessage = strlen(pszEncodedURL);
    cchMessage += 512; // Allow space for sub-strings coming from resource file.

    if (!tempMessage.Resize(cchMessage)) {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        hr = E_OUTOFMEMORY;
        goto lRet;
    }

    szMessage = (char *)tempMessage.QueryPtr();

    // Build the body redirection message
    // Redirect(URL), URL must be a valid URL, that is, no DBCS string.
    cch = CchLoadStringOfId(IDE_RESPONSE_REDIRECT1, szMessage, cchMessage);
    strcpy(szMessage + cch, pszEncodedURL);
    cch += strlen(pszEncodedURL);
    cch += CchLoadStringOfId(IDE_RESPONSE_REDIRECT2, szMessage + cch, cchMessage - cch);

    // Set the status to redirect
    put_Status(L"302 Object moved");

    // Add the location header
    AppendHeader("Location", pszEncodedURL, TRUE);

    // Transmit redirect text to the client, headers will be
    // sent automatically
    if (FAILED(WriteSz(szMessage, cch)))
        {
        hr = E_FAIL;
        goto lRet;
        }

    // No further processing of the script
    End();

lRet:

    return(hr);
    }

/*===================================================================
CResponse::Add

Functions called from DispInvoke to Add a header.

This is a compatibility for the ISBU controls.

Parameters:
    bstrHeaderValue     Unicode BSTR, value: the value of header
    bstrHeaderName      Unicode BSTR, value: the name of the header

  Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::Add
(
BSTR bstrHeaderValue,
BSTR bstrHeaderName
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    return AddHeader(bstrHeaderName, bstrHeaderValue);
    }

/*===================================================================
CResponse::AddHeader

Functions called from DispInvoke to Add a header.

Parameters:
    bstrHeaderName      Unicode BSTR, value: the name of the header
    bstrHeaderValue     Unicode BSTR, value: the value of header

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::AddHeader
(
BSTR bstrHeaderName,
BSTR bstrHeaderValue
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    AssertValid();

    if (FHeadersWritten())
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_HEADERS_WRITTEN);
        return E_FAIL;
        }

    if (bstrHeaderName == NULL || wcslen(bstrHeaderName) == 0)
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_EXPECTING_STR);
        return E_FAIL;
        }

    if (FAILED(AppendHeader(bstrHeaderName, bstrHeaderValue)))
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        SetLastError((DWORD)E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
        }

    return S_OK;
    }

/*===================================================================
CResponse::Clear

Erases all output waiting in buffer.

Parameters
    None

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::Clear()
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT hr = S_OK;

    if (m_pData->m_fClientDebugMode && m_pData->m_fClientDebugFlushIgnored)
        {
        // Clear after flush in ClientDebugMode is an error
        hr = E_FAIL;
        ExceptionId(IID_IResponse, IDE_RESPONSE,
                    IDE_RESPONSE_CLEAR_AFTER_FLUSH_IN_DEBUG);
        }
    else if (!m_pData->m_fBufferingOn)
        {
        hr = E_FAIL;
        ExceptionId(IID_IResponse, IDE_RESPONSE,
                    IDE_RESPONSE_BUFFER_NOT_ON);
        }
    else
        {
        AssertValid();
        hr = m_pData->m_pResponseBuffer->Clear();

        if (SUCCEEDED(hr))
            {
            if (m_pData->m_fClientDebugMode && m_pData->m_pClientDebugBuffer)
                hr = m_pData->m_pClientDebugBuffer->ClearAndStart();
            }

        if (FAILED(hr))
            ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_UNEXPECTED);
        }
    return(hr);
    }

/*===================================================================
CResponse::Flush

Sends out all HTML waiting in the buffer.

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::Flush()
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT hr = S_OK;

    AssertValid();

    if (!m_pData->m_fBufferingOn)
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_BUFFER_NOT_ON);
        hr = E_FAIL;
        goto lRet;
        }

    // Ignore Response.Flush() in Client Debug Mode
    if (m_pData->m_fClientDebugMode)
        {
        m_pData->m_fClientDebugFlushIgnored = TRUE;
        goto lRet;
        }

    // We mark this response as having had flush called so
    // that we won't try to do keep-alive
    m_pData->m_fFlushed = TRUE;

    if (!FHeadersWritten())  // bug 512: write hdrs even if global.asa
        {
        if (FAILED(WriteHeaders()))
            {
            if (E_OUTOFMEMORY == hr)
                ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
            else
                ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_UNEXPECTED);
            goto lRet;
            }
        }

    if (FAILED(hr = m_pData->m_pResponseBuffer->Flush(GetIReq())))
        {
        if (E_OUTOFMEMORY == hr)
            ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        else
            ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_UNEXPECTED);
        }
lRet:
    return(hr);
    }

/*===================================================================
CResponse::FinalFlush

FinalFlush is called if a script terminates without having yet sent
the response headers. This means we can use the Content-Length and
Connection: Keep-Alive headers to increase efficiency. We add those headers,
then send all headers, and all waiting output.

Returns:
    HRESULT         S_OK if ok

===================================================================*/
HRESULT CResponse::FinalFlush(HRESULT hr_Status)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT hr = S_OK;
    DWORD dwRequestStatus = (FAILED(hr_Status) ? HSE_STATUS_ERROR : HSE_STATUS_SUCCESS);
    BOOL fWriteBodyWithHeaders = FALSE;   // append body to headers?
    AssertValid();

    // If the headers have not yet been sent, send them now
    if (!FHeadersWritten() && !FDontWrite())
        {
        DWORD dwLength = m_pData->m_fBufferingOn ? m_pData->m_pResponseBuffer->BytesBuffered() : 0;

        // If there was an error and and nothing is buffered,
        // send "server error" instead of an empty 200 OK response
        if (FAILED(hr_Status) && dwLength == 0)
            {
            Handle500Error(IDE_500_SERVER_ERROR, GetIReq());
            goto lRet;
            }

        // If buffering, add the Content: Keep-Alive, and Content-Length headers
        if (m_pData->m_fBufferingOn)
            {

            // If client is less then HTTP 1.1 add Keep-Alive header
            if (!(m_pData->m_dwVersionMinor >= 1 && m_pData->m_dwVersionMajor >=1))
                {
                AppendHeader("Connection", "Keep-Alive");
                }

            if (m_pData->m_fClientDebugMode && m_pData->m_pClientDebugBuffer)
                {
                // end the buffer with end of METADATA
                m_pData->m_pClientDebugBuffer->End();
                dwLength += m_pData->m_pClientDebugBuffer->BytesBuffered();
                }

            AppendHeader("Content-Length", (LONG)dwLength);
            dwRequestStatus = HSE_STATUS_SUCCESS_AND_KEEP_CONN;

            // if
            //      buffering is on,
            //      we are in-proc,
            //      headers are not yet written, and
            //      there is body
            // then we can optimize by sending both headers and body at once
            //
            if (!IsHeadRequest() && dwLength)
                {
                fWriteBodyWithHeaders = TRUE;
                }
            }

        // If buffering, tell WriteHeaders to append response body
        if (FAILED(hr = WriteHeaders(fWriteBodyWithHeaders)))
            {
            dwRequestStatus = HSE_STATUS_ERROR;
            goto lRet;
            }
        }

    // if we sent body with headers, we are done
    if (fWriteBodyWithHeaders)
        {
        goto lRet;
        }

    // If we have a response buffer, and we have not yet
    // had a write client error, flush the buffer
    // CONSIDER: Rearrange the tests for greater efficiency
    if (m_pData->m_fBufferingOn && !FDontWrite() && !IsHeadRequest())
        {
        // client debug buffer goes first
        if (m_pData->m_fClientDebugMode && m_pData->m_pClientDebugBuffer)
            {
            if (FAILED(hr = m_pData->m_pClientDebugBuffer->Flush(GetIReq())))
                {
                dwRequestStatus = HSE_STATUS_ERROR;
                goto lRet;
                }
            }

        // response buffer follows
        if (FAILED(hr = m_pData->m_pResponseBuffer->Flush(GetIReq())))
            {
            dwRequestStatus = HSE_STATUS_ERROR;
            goto lRet;
            }
        }
    else if (m_pData->m_fBufferingOn)
        {
        // If we have a response buffer and have had a write client
        // error, or this is a head request, we clear the buffers

        if (m_pData->m_pClientDebugBuffer)
            m_pData->m_pClientDebugBuffer->Clear();

        m_pData->m_pResponseBuffer->Clear();
        }
    else if (m_pData->m_fChunked && !FDontWrite() && !IsHeadRequest())
        {
        // Send closing 0-length chunk, we don't use any entity headers
        // so this is just 0 followed by two CRLF
        if (FAILED(CResponse::SyncWrite(GetIReq(), "0\r\n\r\n", 5)))
            {
            m_pData->m_fWriteClientError = TRUE;
            }
        }

lRet:
    // Done with this request
    if (m_pData->m_fWriteClientError)
        dwRequestStatus = HSE_STATUS_ERROR; // We had a write error at some point

    GetIReq()->ServerSupportFunction(
                        HSE_REQ_DONE_WITH_SESSION,
                        &dwRequestStatus,
                        0,
                        NULL);

    if (m_pData->m_pHitObj)
        m_pData->m_pHitObj->SetDoneWithSession();

    // We no longer need access to the template
    // which we AddRef'd in Response::ReinitTemplate
    if (m_pData->m_pTemplate)
        {
        m_pData->m_pTemplate->Release();
        m_pData->m_pTemplate = NULL;
        }

    return(hr);
    }

/*===================================================================
CResponse::End

Stops all further template processing, and returns the current response

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::End()
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (m_pData->m_pfnGetScript != NULL && m_pData->m_pvGetScriptContext != NULL)
        {
        int i = 0;

        CScriptEngine* pEngine;
        while (NULL != (pEngine = (*m_pData->m_pfnGetScript)(i, m_pData->m_pvGetScriptContext)))
            {
            pEngine->InterruptScript(/*fAbnormal*/ FALSE);
            i++;
            }
        }

    m_pData->m_fResponseAborted = TRUE;
    return S_OK;
    }

/*===================================================================
CResponse::AppendToLog

Append a string to the current log entry.

Parameters
    bstrLogEntry Unicode BSTR, value: string to add to log entry

Returns:
    HRESULT         S_OK if ok

Side Effects:
    NONE
===================================================================*/
STDMETHODIMP CResponse::AppendToLog(BSTR bstrLogEntry)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    AssertValid();

    HRESULT       hr = S_OK;
    CWCharToMBCS  convEntry;

    // BUGBUG - should this be 65001?

    if (FAILED(hr = convEntry.Init(bstrLogEntry, m_pData->m_pHitObj->GetCodePage())));

    else hr = GetIReq()->AppendLogParameter(convEntry.GetString());

    if (FAILED(hr)) {
        if (hr == E_OUTOFMEMORY) {
            ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        }
        else {
            ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_LOG_FAILURE);
        }
    }

    return(hr);
    }

/*===================================================================
CResponse::get_Cookies

Return the write-only response cookie dictionary

Parameters
    bstrLogEntry Unicode BSTR, value: string to add to log entry

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::get_Cookies(IRequestDictionary **ppDictReturn)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    AssertValid();
    return m_pData->m_WriteCookies.QueryInterface(IID_IRequestDictionary, reinterpret_cast<void **>(ppDictReturn));
    }

#ifdef DBG
/*===================================================================
CResponse::AssertValid

Test to make sure that the CResponse object is currently correctly formed
and assert if it is not.

Returns:

Side effects:
    None.
===================================================================*/
VOID CResponse::AssertValid() const
    {
    Assert(m_fInited);
    Assert(m_pData);
    Assert(m_pData->m_pResponseBuffer);
    Assert(m_pData->m_pIReq);
    }
#endif // DBG


/*===================================================================
IsHeadRequest

This function will check the REQUEST_METHOD and set a BOOL flag in
the class.  If the request method is HEAD the flag will be set to
true.

Also the flag must be reset with each init/reinit call

m_IsHeadRequest == 0    // HEAD request status not set
m_IsHeadRequest == 1    // Not a HEAD request
m_IsHeadRequest == 2    // is a HEAD request

Parameters

Returns:
    void

Side effects:
    sets status flag m_IsHeadRequest

===================================================================*/
BOOL CResponse::IsHeadRequest(void)
    {
    if (FAILED(CheckForTombstone()))
        return FALSE;

    AssertValid();

    if (m_pData->m_IsHeadRequest != 0)
        return ( m_pData->m_IsHeadRequest == 2);

    if (stricmp(GetIReq()->QueryPszMethod(), "HEAD") == 0 )
        m_pData->m_IsHeadRequest = 2;
    else
        m_pData->m_IsHeadRequest = 1;

    return ( m_pData->m_IsHeadRequest == 2);
    }

/*===================================================================
IsClientConnected

This function will return the status of the last attempt to write to
the client. If Ok, it check the connection using new CIsapiReqInfo method

Parameters
    none

Returns:
    VARIANT_BOOL reflecting the status of the client connection
===================================================================*/
STDMETHODIMP CResponse::IsClientConnected(VARIANT_BOOL* fIsClientConnected)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (m_pData->m_fWriteClientError)
        {
        *fIsClientConnected = VARIANT_FALSE;
        }
    else
        {
        // assume connected
        BOOL fConnected = TRUE;

        // test
        if (m_pData->m_pIReq)
            m_pData->m_pIReq->TestConnection(&fConnected);

        *fIsClientConnected = fConnected ? VARIANT_TRUE : VARIANT_FALSE;
        }

    return(S_OK);
    }

/*===================================================================
CResponse::get_CharSet

Functions called from DispInvoke to return the CarSet property.

Parameters:
    pbstrCharSetRet     BSTR FAR *, return value: pointer to the CharSet as a string

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::get_CharSet
(
BSTR FAR * pbstrCharSetRet
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT hr = S_OK;

    if (m_pData->m_pszCharSet)
        hr = SysAllocStringFromSz(m_pData->m_pszCharSet, 0, pbstrCharSetRet);
    else
        *pbstrCharSetRet    = NULL;

    if (FAILED(hr))
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        hr = E_FAIL;
        }
    return(hr);
    }

/*===================================================================
CResponse::put_CharSet

Functions called from DispInvoke to set the CharSet property.

This function takses a string, which identifies the name of the
character set of the current page, and appends the name of the
character set (for example, " ISO-LATIN-7") specified by the
charsetname to the content-type header in the response object

Notes:

* this function inserts any string in the header, whether or not
it represents a valis charcter set.
* if a single page contains multiple tags contianing response.charset,
each response.charset will replace the cahrset by the previous entry.
As a result, the charset will be set to the value specified by the
last instance of response.charset on a page.
* this command must also be invoked before the first response.write
operation unless buffering is turned on.

Parameters:
    bstrContentType     BSTR, value: the ContentType as a string

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::put_CharSet
(
BSTR bstrCharSet
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT         hr = S_OK;
    CWCharToMBCS    convStr;

    if (FHeadersWritten())
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_HEADERS_WRITTEN);
        hr = E_FAIL;
        goto lRet;
        }

    if (m_pData->m_pszCharSet) {
        free(m_pData->m_pszCharSet);
        m_pData->m_pszCharSet = NULL;
    }

    if (FAILED(hr = convStr.Init(bstrCharSet)));

    else if ((m_pData->m_pszCharSet = convStr.GetString(TRUE)) == NULL) {
        hr = E_OUTOFMEMORY;
    }

lRet:
    if (hr == E_OUTOFMEMORY) {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        SetLastError((DWORD)E_OUTOFMEMORY);
    }
    return(hr);
    }


/*===================================================================
CResponse::Pics

Functions called from DispInvoke to Add a pics header.

Parameters:
    bstrHeaderValue     Unicode BSTR, value: the value of pics header

Takes a string, which is the properly formatted PICS label, and adds
the value specified by the picslabel to the pics-label field of the response header.

Note:

* this function inserts any string in the header, whether or not it
represents a valid PICS lavel.

* current implimentation is a wraper on the addheader method.


Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::Pics
(
BSTR bstrHeaderValue
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (FHeadersWritten())
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_HEADERS_WRITTEN);
        return E_FAIL;
        }

    if (FAILED(AppendHeader("pics-label", bstrHeaderValue)))
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        SetLastError((DWORD)E_OUTOFMEMORY);
        return E_OUTOFMEMORY;
        }

    return S_OK;
    }

/*===================================================================
CResponse::get_CacheControl

Functions called from DispInvoke to return the CacheControl property.

Parameters:
    pbstrCacheControl   BSTR FAR *, return value: pointer to the CacheControl as a string

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::get_CacheControl
(
BSTR FAR * pbstrCacheControl
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT hr = S_OK;

    if (m_pData->m_pszCacheControl)
        hr = SysAllocStringFromSz(m_pData->m_pszCacheControl, 0, pbstrCacheControl);
    else
        hr = SysAllocStringFromSz( "private", 0, pbstrCacheControl);

    if (FAILED(hr))
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        hr = E_FAIL;
        }
    return(hr);
    }

/*===================================================================
CResponse::put_CacheControl

Functions called from DispInvoke to set the CacheControl property.

Parameters:
    bstrCacheControl    BSTR, value: the CacheControl as a string

Returns:
    HRESULT         S_OK if ok

===================================================================*/
STDMETHODIMP CResponse::put_CacheControl
(
BSTR bstrCacheControl
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    HRESULT         hr = S_OK;
    CWCharToMBCS    convStr;

    if (FHeadersWritten())
        {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_RESPONSE_HEADERS_WRITTEN);
        hr = E_FAIL;
        goto lRet;
        }

    if (m_pData->m_pszCacheControl) {
        free(m_pData->m_pszCacheControl);
        m_pData->m_pszCacheControl = NULL;
    }

    if (FAILED(hr = convStr.Init(bstrCacheControl)));

    else if ((m_pData->m_pszCacheControl = convStr.GetString(TRUE)) == NULL) {
        hr = E_OUTOFMEMORY;
    }

lRet:
    if (hr == E_OUTOFMEMORY) {
        ExceptionId(IID_IResponse, IDE_RESPONSE, IDE_OOM);
        SetLastError((DWORD)E_OUTOFMEMORY);
    }
    return(hr);
    }

/*===================================================================
CResponse::get_CodePage

Returns the current code page value for the response

Parameters:
    long *plVar     [out] code page value

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CResponse::get_CodePage
(
long *plVar 
)
{
    Assert(m_pData);
        Assert(m_pData->m_pHitObj);

        *plVar = m_pData->m_pHitObj->GetCodePage();

	// If code page is 0, look up default ANSI code page
	if (*plVar == 0) {
		*plVar = (long) GetACP();
    }
		
	return S_OK;
}

/*===================================================================
CResponse::put_CodePage

Sets the current code page value for the response

Parameters:
    long lVar       code page to assign to this response

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CResponse::put_CodePage
(
long lVar 
) 
{
    Assert(m_pData);
    Assert(m_pData->m_pHitObj);

    // set code page member variable 
    HRESULT hr = m_pData->m_pHitObj->SetCodePage(lVar);

    if (FAILED(hr)) {
        ExceptionId
            (
            IID_IResponse,
            IDE_RESPONSE, 
            IDE_SESSION_INVALID_CODEPAGE 
            );
        return E_FAIL;
    }

	return S_OK;
}

/*===================================================================
CResponse::get_LCID

Returns the current LCID value for the response

Parameters:
    long *plVar     [out] LCID value

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CResponse::get_LCID
(
long *plVar 
)
{
    Assert(m_pData);
    Assert(m_pData->m_pHitObj);

        *plVar = m_pData->m_pHitObj->GetLCID();

	// If code page is 0, look up default ANSI code page
	if (*plVar == LOCALE_SYSTEM_DEFAULT) {
		*plVar = (long) GetSystemDefaultLCID();
	}
		
	return S_OK;
}

/*===================================================================
CResponse::put_LCID

Sets the current LCID value for the response

Parameters:
    long lVar       LCID to assign to this response

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CResponse::put_LCID
(
long lVar 
) 
{
    Assert(m_pData);
    Assert(m_pData->m_pHitObj);

    // set code page member variable 
    HRESULT hr = m_pData->m_pHitObj->SetLCID(lVar);

    if (FAILED(hr)) {
        ExceptionId
            (
            IID_IResponse,
            IDE_RESPONSE, 
            IDE_TEMPLATE_BAD_LCID 
            );
        return E_FAIL;
    }

	return S_OK;
}


/*===================================================================
IStream implementation for ADO/XML
===================================================================*/

STDMETHODIMP CResponse::Read(
    void *pv,
    ULONG cb,
    ULONG *pcbRead)
{
    return E_NOTIMPL;
}

STDMETHODIMP CResponse::Write(
    const void *pv,
    ULONG cb,
    ULONG *pcbWritten)
{
    if (pcbWritten != NULL)
        *pcbWritten = cb;
    return WriteSz((CHAR*) pv, cb);
}

STDMETHODIMP CResponse::Seek(
    LARGE_INTEGER dlibMove,
    DWORD dwOrigin,
    ULARGE_INTEGER *plibNewPosition)
{
    return E_NOTIMPL;
}

STDMETHODIMP CResponse::SetSize(
    ULARGE_INTEGER libNewSize)
{
    return E_NOTIMPL;
}

STDMETHODIMP CResponse::CopyTo(
    IStream *pstm,
    ULARGE_INTEGER cb,
    ULARGE_INTEGER *pcbRead,
    ULARGE_INTEGER *pcbWritten)
{
    return E_NOTIMPL;
}

STDMETHODIMP CResponse::Commit(
    DWORD grfCommitFlags)
{
    return E_NOTIMPL;
}

STDMETHODIMP CResponse::Revert()
{
    return E_NOTIMPL;
}

STDMETHODIMP CResponse::LockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType)
{
    return E_NOTIMPL;
}

STDMETHODIMP CResponse::UnlockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType)
{
    return E_NOTIMPL;
}

STDMETHODIMP CResponse::Stat(
    STATSTG *pstatstg,
    DWORD grfStatFlag)
{
    return E_NOTIMPL;
}

STDMETHODIMP CResponse::Clone(
    IStream **ppstm)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\rfs.cpp ===
/*===================================================================
Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: RFS

File: rfs.cpp

Owner: EricN

This the Resource failure objects.
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#ifdef _RFS

#include <tchar.h>
#include <stdio.h>
#include "rfs.h"

//constructor
RFS::RFS(DWORD dwFailOn, DWORD dwThreadID)
{
	__asm {int 3}
	m_dwFailOn = dwFailOn;
	m_dwTtlNumAllocs = 0;
	m_dwCurrentAlloc = 0;
	m_dwThreadID = dwThreadID;
	m_fFail = FALSE;
	m_bType = -1;
}

//*****************************************************************************
// Name:	RFS::SetFailOn
// Args:	Changes the fail on value and spcifies what the number means
//			bType = COUNT | ALLOCATE
// Author:	EricN
// History:	Created 4/15/97 (tax day)
// Notes:	
//*****************************************************************************
void
RFS::SetFailOn(DWORD dwFailOn, BYTE bType)
{
	m_dwFailOn = dwFailOn;
	m_bType = bType;
}

//*****************************************************************************
// Name:	RFS::SetFailOn
// Args:	Causes a failure on a line or allocation form a specific file
//			pszFile - the file (a .cpp file)
//			lLine - the line number
//			the type is forced to FILE_LINE
// Author:	EricN
// History:	Created 7/8/97
// Notes:	
//*****************************************************************************
void
RFS::SetFailOn(LPSTR pszFile, long lLine)
{
	strcpy(m_szFailIn, pszFile);
	m_dwFailOn = lLine;
	m_bType = FILE_LINE;
}

//*****************************************************************************
// Name:	RFS::WriteData
// Args:	none
// Author:	EricN
// History:	Created 4/22/97 (tax day)
// Notes:	writes out any interesting data
//*****************************************************************************
void
RFS::WriteData()
{
	char szOutput[200];

	sprintf(szOutput, "\n\nTotal Number of allocations: %ld\n", m_dwTtlNumAllocs);
	Log(MFSLOGFILE, szOutput);
}

//*****************************************************************************
// Name:	RFS::DetermineFailure
// Args:	None
// Author:	EricN
// History:	Created 4/15/97 (tax day)
// Notes:	
//			This determines if the particular resource should fail
//			Currently it just logs the failure to a file, but will eventually
//			communicate with an outside application
//*****************************************************************************
BOOL
RFS::DetermineFailure(LPCSTR szFile, int iLineNo)
{
	BOOL  fFail = FALSE;
	DWORD dwThreadID = GetCurrentThreadId();
	char  szOutput[200];

	//verify the we're being called on the correct threadid
	if (dwThreadID != m_dwThreadID)
	{
		//sprintf(szOutput, "Called on differnt thread. Exp: %ld, Rec: %ld\n", m_dwThreadID, dwThreadID);
		//Log(MFSLOGFILE, szOutput); 
		return FALSE;
	}
	
	m_dwTtlNumAllocs++;
	m_dwCurrentAlloc++;

	switch(m_bType)
	{
	case COUNT:

		if (m_fFail && m_dwCurrentAlloc == m_dwFailOn)
		{
			fFail = TRUE;
			m_dwFailOn++;
			m_dwCurrentAlloc = 0;
		}

		break;
	case MEM:
		break;
	case FILE_LINE:
			if (m_fFail && m_dwFailOn == iLineNo)
			{
				if (_stricmp(m_szFailIn, szFile) == 0)
				{
					fFail = TRUE;
				}
			}

		break;
	default:
		sprintf(szOutput, "BAD failure type specified: %d\n",m_bType);
		Log(MFSLOGFILE, szOutput); 
		break;
	}//switch

	if (fFail)
	{
		if (szFile != NULL)
			sprintf(szOutput, "Failing Allocation: %ld File: %s, Line: %d\n", m_dwCurrentAlloc, 
					szFile, iLineNo);
		else
			sprintf(szOutput, "Failing Allocation: %ld\n", m_dwCurrentAlloc);

		Log(MFSLOGFILE, szOutput); 
		return TRUE;
	}

	return FALSE;
}

void
RFS::SetThreadID(DWORD dwThreadID)
{
	m_dwThreadID = dwThreadID;
}

void
RFS::Log(LPSTR pszFileName, LPSTR pszMsg)
{
int fh;

	fh = _open(pszFileName, 
			   _O_WRONLY | _O_CREAT | _O_APPEND | _O_BINARY, 
			   _S_IREAD | _S_IWRITE );

	if (fh == -1)
	{
		DBG_PRINTF((DBG_CONTEXT, "FAIL: Could not open RFS log\n"));
	}

	_write( fh, (void*)pszMsg, strlen(pszMsg));
	_close(fh);
}

//construstor
MemRFS::MemRFS(DWORD dwFailOn, DWORD dwThreadID) : RFS(dwFailOn, dwThreadID)
{
}

//*****************************************************************************
// Name:	MemRFS::Init
// Args:	None
// Author:	EricN
// History:	Created 4/15/97 (tax day)
// Notes:	
//*****************************************************************************
HRESULT
MemRFS::Init()
{
	int fh;
	long lVal;
	char szBuff[MAX_PATH];

	//only read the file the first time the RFS stuff is instantiated
	if (m_dwCurrentAlloc == 0)
	{
		fh = _open(MFSINIFILE, 
				   _O_RDONLY | _O_BINARY, _S_IREAD | _S_IWRITE );

		//init doesn't fail if there is no init file,
		if (fh != -1)
		{
			DWORD dwBytes = _read( fh, (void*)szBuff, MAX_PATH);
			_close(fh);
			szBuff[dwBytes-1] = '\0';
			//determine type of failure requested
			lVal = atol(szBuff);
			//if lval is 0 then a file name was specified
			if (lVal == 0)
			{
				LPSTR pStr;
				pStr = strstr(szBuff, ",");
				if (pStr != NULL)
				{
					//replace ',' with \0
					*pStr = '\0';

					pStr++;
					lVal = atol(pStr);
					SetFailOn(szBuff, lVal);
				}
				else
				{
					//having a line of zero will force a failure on the 
					//first request from a file
					SetFailOn(szBuff, 0);
				}
			}
			else
			{
				LPSTR pStr;
				pStr = strstr(szBuff, ",");
				if (!pStr != NULL)
				{
					pStr++;
					SetFailOn(lVal, (BYTE)atoi(pStr));
				}
				else
					SetFailOn(lVal, COUNT);					
			}
		}
	}

	//reset the allocations for this request.
	m_dwCurrentAlloc = 0;

	return S_OK;
}

//*****************************************************************************
// Name:	MemRFS::FailAlloc
// Args:	None
// Author:	EricN
// History:	Created 4/15/97 (tax day)
// Notes:	Just calls base class
//*****************************************************************************
BOOL
MemRFS::FailAlloc(void *cSize, LPCSTR szFile, int iLineNo)
{
	//need to add code to handle size stuff.
	return DetermineFailure(szFile, iLineNo);
}

//*****************************************************************************
// Name:	MemRFS::SetRFSOn
// Args:	fRFSOn - determines if RFS is on or off
// Author:	EricN
// History:	Created 4/15/97 (tax day)
// Notes:	This turns on and off RFS
//*****************************************************************************
void
MemRFS::SetRFSOn(BOOL fRFSOn)
{
	m_fFail = fRFSOn;
}

//*****************************************************************************
// Name:	MemRFS::SetFailOn
// Args:	Changes the fail on value
// Author:	EricN
// History:	Created 4/15/97 (tax day)
// Notes:	This turns on and off RFS
//*****************************************************************************
void
MemRFS::SetFailOn(DWORD dwFailOn, BYTE bType)
{
	RFS::SetFailOn(dwFailOn, bType);
}

//*****************************************************************************
// Name:	MemRFS::SetFailOn
// Args:	Changes the fail on value
// Author:	EricN
// History:	Created 4/15/97 (tax day)
// Notes:	This turns on and off RFS
//*****************************************************************************
void
MemRFS::SetFailOn(LPSTR pszFile, long lLine)
{
	RFS::SetFailOn(pszFile, lLine);
}

//*****************************************************************************
// Name:	MemRFS::WriteData
// Args:	None
// Author:	EricN
// History:	Created 4/22/97 
// Notes:	Writes out any data of interest
//*****************************************************************************
void
MemRFS::WriteData()
{
	RFS::WriteData();
}

#endif // _RFS
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\response.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Response object

File: response.h

Owner: CGrant

This file contains the header info for defining the Response object.
Note: This was largely stolen from Kraig Brocjschmidt's Inside OLE2
second edition, chapter 14 Beeper v5.
===================================================================*/

#ifndef _RESPONSE_H
#define _RESPONSE_H

#include "debug.h"
#include "util.h"
#include "template.h"
#include "disptch2.h"
#include "hashing.h"
#include "memcls.h" 
#include "ftm.h"

const DWORD RESPONSE_BUFFER_SIZE = 32768;
const DWORD BUFFERS_INCREMENT = 256;
const DWORD ALLOCA_LIMIT = 4096;
const DWORD MAX_RESPONSE = 32768;
const DWORD MAX_MESSAGE_LENGTH = 512;

class CScriptEngine;

#ifdef USE_LOCALE
extern DWORD	 g_dwTLS;
#endif

// fixed size allocator for response buffers
ACACHE_FSA_EXTERN(ResponseBuffer)

// forward refs
class CResponse;
class CRequest;

//This file is generated from MKTYPLIB on denali.obj
#include "asptlb.h"

//Type for an object-destroyed callback
typedef void (*PFNDESTROYED)(void);

//Type for the "Get Active Script Engine" callback
typedef CScriptEngine *(*PFNGETSCRIPT)(int iScriptEngine, void *pvContext);

/*
 * C H T T P H e a d e r L i n k
 *
 */

class CHTTPHeader
	{
private:
    DWORD m_fInited : 1;
    DWORD m_fNameAllocated : 1;
    DWORD m_fValueAllocated : 1;
    
	char *m_szName;
	char *m_szValue;
	
    DWORD m_cchName;
    DWORD m_cchValue;

    CHTTPHeader *m_pNext;

	char m_rgchLtoaBuffer[20];  // enough for atol

public:
	CHTTPHeader();
	~CHTTPHeader();

	HRESULT InitHeader(BSTR wszName, BSTR wszValue, UINT lCodePage = CP_ACP);
	HRESULT InitHeader(char *szName, BSTR wszValue, UINT lCodePage = CP_ACP);
	HRESULT InitHeader(char *szName, char *szValue, BOOL fCopyValue);
	HRESULT InitHeader(char *szName, long lValue);

	char *PSzName();
	char *PSzValue();
	DWORD CchLength();
	
	void  Print(char *szBuf);

	void  SetNext(CHTTPHeader *pHeader);
	CHTTPHeader *PNext();
	
	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};

// CHTTPHeader inlines

inline char *CHTTPHeader::PSzName()
    {
    Assert(m_fInited);
    return m_szName; 
    }
    
inline char *CHTTPHeader::PSzValue()
    {
    Assert(m_fInited);
    return m_szValue; 
    }
	
inline DWORD CHTTPHeader::CchLength()
    {
    Assert(m_fInited);
    return (m_cchName + m_cchValue + 4); // account for ": " and "\r\n"
    }

inline void CHTTPHeader::SetNext(CHTTPHeader *pHeader)
    {
    Assert(m_fInited);
    Assert(!m_pNext);
    m_pNext = pHeader;
    }
    
inline CHTTPHeader *CHTTPHeader::PNext()
    {
    return m_pNext;
    }

/*
 * C R e s p o n s e B u f f e r
 *
 */

class CResponseBuffer
	{
	CResponse*			m_pResponse;				// Pointer to enclosing response
	char				**m_rgpchBuffers;			// Array of pointers to buffers
	char                *m_pchBuffer0;              // In case of 1 element array of pointers
	DWORD				m_cBufferPointers;			// Count of buffer pointers
	DWORD				m_cBuffers;					// Count of buffers we have allocated
	DWORD				m_iCurrentBuffer;			// Array index for the buffer we are currently filling
	DWORD				m_cchOffsetInCurrentBuffer;	// Offset within the current buffer
	DWORD				m_cchTotalBuffered;			// Total of ouput bytes buffered
	BOOL				m_fInited;					// Initialization status for the object

	HRESULT				GrowBuffers(DWORD cchNewRequest);	// Increase the size of the buffers

public:
	CResponseBuffer();
	~CResponseBuffer();      
	HRESULT Init(CResponse* pResponse);
	char * GetBuffer(UINT i);
	DWORD GetBufferSize(UINT i);
	DWORD CountOfBuffers();
	DWORD BytesBuffered();
	HRESULT Write(char* pszSource, DWORD cch);
	HRESULT Flush(CIsapiReqInfo *pIReq);
	HRESULT Clear();

	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};

inline char * CResponseBuffer::GetBuffer(UINT i)
    {
    Assert( i < m_cBuffers );
    return m_rgpchBuffers[i];
    }

inline DWORD CResponseBuffer::GetBufferSize(UINT i)
    {
    Assert( i < m_cBuffers );

    // if buffer is final one, its content-length is current offset
    if ( i == (m_cBuffers - 1 ) )
        {
        return m_cchOffsetInCurrentBuffer;
        }

    // if buffer is other than final one, its content-length is default buffer size
    return RESPONSE_BUFFER_SIZE;
    }

inline DWORD CResponseBuffer::CountOfBuffers()
    {
    return m_cBuffers; 
    }

inline DWORD CResponseBuffer::BytesBuffered()
    {
    return m_cchTotalBuffered; 
    }

/*
 * C D e b u g R e s p o n s e B u f f e r
 *
 */

class CDebugResponseBuffer : public CResponseBuffer
    {
private:
    HRESULT Write(const char* pszSource);

public:
	inline CDebugResponseBuffer() {}
	inline ~CDebugResponseBuffer() {}     

    HRESULT Start();
    HRESULT End();

    HRESULT InitAndStart(CResponse* pResponse);
    HRESULT ClearAndStart();

    // the only real method
	HRESULT AppendRecord
	    (
	    const int cchBlockOffset,
	    const int cchBlockLength,
	    const int cchSourceOffset,
	    const char *pszSourceFile = NULL
	    );
	    
	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };

inline HRESULT CDebugResponseBuffer::Write(const char* pszSource)
    {
    return CResponseBuffer::Write((char *)pszSource, strlen(pszSource));
    }

inline HRESULT CDebugResponseBuffer::Start()
    {
    return Write("<!--METADATA TYPE=\"ASP_DEBUG_INFO\"\r\n");
    }

inline HRESULT CDebugResponseBuffer::End()
    {
    return Write("-->\r\n");
    }
    
inline HRESULT CDebugResponseBuffer::InitAndStart(CResponse* pResponse)
    {
    HRESULT hr = CResponseBuffer::Init(pResponse);
    if (SUCCEEDED(hr))
        hr = Start();
    return hr;
    }

inline HRESULT CDebugResponseBuffer::ClearAndStart()
    {
    HRESULT hr = CResponseBuffer::Clear();
    if (SUCCEEDED(hr))
        hr = Start();
    return hr;
    }

/*
 * C R e s p o n s e C o o k i e s
 *
 * Implements the IRequestDictionary interface for writing cookies.
 */

class CResponseCookies : public IRequestDictionaryImpl
	{
private:
    IUnknown *          m_punkOuter;        // for addrefs
	CSupportErrorInfo	m_ISupportErrImp;	// implementation of ISupportErr
	CRequest *			m_pRequest;			// pointer to request object
	CResponse *			m_pResponse;		// pointer to parent object

public:
	CResponseCookies(CResponse *, IUnknown *);
	~CResponseCookies();
	
	HRESULT Init()
		{
		return S_OK;
		}

	HRESULT ReInit(CRequest *);

	// The Big Three
	STDMETHODIMP			QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	// OLE Automation Interface
	STDMETHODIMP	get_Item(VARIANT varKey, VARIANT *pvarReturn);
	STDMETHODIMP	get__NewEnum(IUnknown **ppEnumReturn);
	STDMETHODIMP	get_Count(int *pcValues);
	STDMETHODIMP	get_Key(VARIANT VarKey, VARIANT *pvar);

	// C++ interface to write headers

	size_t QueryHeaderSize();
	char *GetHeaders(char *szBuffer);
	};

/*
 * C R e s p o n s e D a t a
 *
 * Structure that holds the intrinsic's properties.
 * The instrinsic keeps pointer to it (NULL when lightweight)
 */
class CResponseData : public IUnknown
    {
friend CResponse;
friend CResponseCookies;
friend CResponseBuffer;
    
private:
    // constructor to pass params to members and init members
    CResponseData(CResponse *pResponse);
    ~CResponseData();
    
    HRESULT Init(CResponse *pResponse);

	CSupportErrorInfo	    m_ISupportErrImp;	    // Interface to indicate that we support ErrorInfo reporting
	CIsapiReqInfo *         m_pIReq;				    // CIsapiReqInfo block for HTTP info
	CHitObj*				m_pHitObj;			    // pointer to hitobj for this request
	CTemplate*				m_pTemplate;		    // Pointer to the template for this request
    CHTTPHeader*            m_pFirstHeader;	        // List of
    CHTTPHeader*            m_pLastHeader;	        //      headers
	time_t					m_tExpires;			    // date that the HTML output page expires; -1 if no date assigned
	const char*				m_szCookieVal;		    // Value of session id
	const char*             m_pszDefaultContentType;// Default content type (pointer to static string)
    const char*             m_pszDefaultExpires;    // Default expires header value
	char*					m_pszContentType;	    // Content type of response (set by user)
	char*					m_pszCharSet;			// CharSet header of response
	char*					m_pszCacheControl;		// cache-control header of response
	char*					m_pszStatus;		    // HTTP Status to be returned
	BYTE					m_dwVersionMajor;		// Major version of HTTP supported by client
	BYTE					m_dwVersionMinor;		// Minor version of HTTP supported by client
	CResponseBuffer *		m_pResponseBuffer;	    // Pointer to response buffer object
	CDebugResponseBuffer *  m_pClientDebugBuffer;   // Pointer to response buffer object for client debugging data
	int						m_IsHeadRequest;	    // HEAD request flag 0=uninit, 1=not head, 2=head
	PFNGETSCRIPT			m_pfnGetScript;		    // Pointer to callback function for obtaining CActiveEngine pointers
	void*					m_pvGetScriptContext;   // Pointer to data for for callback function for CActiveEngines
	CResponseCookies		m_WriteCookies;		    // write-only cookie collection
	BOOL					m_fHeadersWritten : 1;	// Have the output headers been written?
	BOOL					m_fResponseAborted : 1;	// Was "Response.End" invoked?
	BOOL					m_fWriteClientError : 1;// Write Client Failed
	BOOL                    m_fIgnoreWrites : 1;    // Ignore all writes? (in case of custom error)
	BOOL					m_fBufferingOn : 1;		// Buffer response output
	BOOL                    m_fFlushed : 1;         // Has flush been called?             
	BOOL                    m_fChunked : 1;         // Doing HTTP 1.1 chunking?
	BOOL                    m_fClientDebugMode : 1; // In client debug mode?
	BOOL                    m_fClientDebugFlushIgnored : 1; // Flush request ignored due to client debug?
	ULONG                   m_cRefs;                // ref count

    void AppendHeaderToList(CHTTPHeader *pHeader);
        
public:	
	STDMETHODIMP			QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };

inline void CResponseData::AppendHeaderToList(CHTTPHeader *pHeader)
    {
    if (!m_pLastHeader)
        {
        Assert(!m_pFirstHeader);
        m_pFirstHeader = pHeader;
        }
    else
        {
        Assert(m_pFirstHeader);
        m_pLastHeader->SetNext(pHeader);
        }
    m_pLastHeader = pHeader;
    }


    
/*
 * C R e s p o n s e
 *
 * Implements the Response object
 */
class CResponse : public IResponseImpl, public CFTMImplementation, public IStream
	{

friend CResponseCookies;
friend CResponseBuffer;

private:
    // Flags
	DWORD m_fInited : 1;	    // Is initialized?
	DWORD m_fDiagnostics : 1;   // Display ref count in debug output
	DWORD m_fOuterUnknown : 1;  // Ref count outer unknown?

    // Ref count / Outer unknown
    union
    {
    DWORD m_cRefs;
    IUnknown *m_punkOuter;
    };

    // Properties
    CResponseData *m_pData;   // pointer to structure that holds
                              // CResponse properties

	VOID	GetClientVerison(VOID);
	HRESULT WriteClient(BYTE *pb, DWORD cb);
	HRESULT WriteClientChunked(BYTE *pb, DWORD cb);

#ifdef DBG
    inline void TurnDiagsOn()  { m_fDiagnostics = TRUE; }
    inline void TurnDiagsOff() { m_fDiagnostics = FALSE; }
    void AssertValid() const;
#else
    inline void TurnDiagsOn()  {}
    inline void TurnDiagsOff() {}
    inline void AssertValid() const {}
#endif

public:
	CResponse(IUnknown *punkOuter = NULL);
	~CResponse();

    HRESULT CleanUp();
	HRESULT	Init();
	HRESULT UnInit();
	
	HRESULT	ReInitTemplate(CTemplate* pTemplate, const char *szCookie);

	CTemplate *SwapTemplate(CTemplate* pNewTemplate);
	
	HRESULT	ReInit(CIsapiReqInfo *pIReq, const char *szCookie, CRequest *pRequest,
 				   PFNGETSCRIPT pfnGetScript, void *pvGetScriptContext, CHitObj *pHitObj);

	HRESULT	WriteHeaders(BOOL fSendEntireResponse = FALSE);
	HRESULT	FinalFlush(HRESULT);
	HRESULT	WriteSz(CHAR *sz, DWORD cch);
	HRESULT	WriteBSTR(BSTR bstr);

    // append headers of different kind
	HRESULT AppendHeader(BSTR wszName, BSTR wszValue);
	HRESULT AppendHeader(char *szName, BSTR wszValue);
	HRESULT AppendHeader(char *szName, char *szValue, BOOL fCopyValue = FALSE);
	HRESULT AppendHeader(char *szName, long lValue);

	// inlines
	inline BOOL	FHeadersWritten();
	inline BOOL	IsHeadRequest(void);
	inline BOOL	FResponseAborted();
	inline BOOL	FWriteClientError();
	inline BOOL FDontWrite();
	inline void	SetHeadersWritten();
	inline void SetIgnoreWrites();
    inline CIsapiReqInfo* GetIReq();
    inline const char* PContentType() const;
    inline char *PCustomStatus();
    inline void *SwapScriptEngineInfo(void *pvEngineInfo);
		
	//Non-delegating object IUnknown
	STDMETHODIMP		 QueryInterface(REFIID, PPVOID);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

    // GetIDsOfNames special-case implementation
	STDMETHODIMP GetIDsOfNames(REFIID, OLECHAR **, UINT, LCID, DISPID *);

    // Tombstone stub
	HRESULT CheckForTombstone();

	//IResponse functions
	STDMETHODIMP	Write(VARIANT varInput);
	STDMETHODIMP	BinaryWrite(VARIANT varInput);
	STDMETHODIMP	WriteBlock(short iBlockNumber);
	STDMETHODIMP	Redirect(BSTR bstrURL);
	STDMETHODIMP	AddHeader(BSTR bstrHeaderName, BSTR bstrHeaderValue);
	STDMETHODIMP	Pics(BSTR bstrHeaderValue);	
	STDMETHODIMP	Add(BSTR bstrHeaderValue, BSTR bstrHeaderName);
	STDMETHODIMP	SetCookie(BSTR bstrHeader, BSTR bstrValue, VARIANT varExpires,
							VARIANT varDomain, VARIANT varPath, VARIANT varSecure);
	STDMETHODIMP	Clear(void);
	STDMETHODIMP	Flush(void);
	STDMETHODIMP	End(void);
	STDMETHODIMP	AppendToLog(BSTR bstrLogEntry);
	STDMETHODIMP	get_ContentType(BSTR *pbstrContentTypeRet);
	STDMETHODIMP	put_ContentType(BSTR bstrContentType);
	STDMETHODIMP	get_CharSet(BSTR *pbstrContentTypeRet);
	STDMETHODIMP	put_CharSet(BSTR bstrContentType);
	STDMETHODIMP	get_CacheControl(BSTR *pbstrCacheControl);
	STDMETHODIMP	put_CacheControl(BSTR bstrCacheControl);	
	STDMETHODIMP	get_Status(BSTR *pbstrStatusRet);	
	STDMETHODIMP	put_Status(BSTR bstrStatus);
	STDMETHODIMP	get_Expires(VARIANT *pvarExpiresMinutesRet);
	STDMETHODIMP	put_Expires(long lExpiresMinutes);
	STDMETHODIMP	get_ExpiresAbsolute(VARIANT *pvarTimeRet);
	STDMETHODIMP	put_ExpiresAbsolute(DATE dtExpires);
	STDMETHODIMP	get_Buffer(VARIANT_BOOL* fIsBuffering);
	STDMETHODIMP	put_Buffer(VARIANT_BOOL fIsBuffering);
	STDMETHODIMP	get_Cookies(IRequestDictionary **ppDictReturn);
	STDMETHODIMP	IsClientConnected(VARIANT_BOOL* fIsBuffering);
    STDMETHODIMP    get_CodePage(long *plVar);
    STDMETHODIMP    put_CodePage(long var);
    STDMETHODIMP    get_LCID(long *plVar);
    STDMETHODIMP    put_LCID(long var);

    // static method to send the entire block using SyncWriteClient
    static HRESULT SyncWrite(CIsapiReqInfo *pIReq,
                             char *pchBuf, 
                             DWORD cchBuf = 0);

    // static method to send contents of several memory blocks as the entire response (sync)
    static HRESULT SyncWriteBlocks(CIsapiReqInfo *pIReq, 
                                   DWORD cBlocks,
                                   DWORD cbTotal,
                                   void **rgpvBlock, 
                                   DWORD *rgcbBlock, 
                                   char *szMimeType = NULL, 
                                   char *szStatus = NULL,
                                   char *szExtraHeaders = NULL);
    
    // static method to send contents of a memory block as the entire response (sync)
    inline static HRESULT SyncWriteBlock(CIsapiReqInfo *pIReq,
                                         void *pvBlock, 
                                         DWORD cbBlock, 
                                         char *szMimeType = NULL,
                                         char *szStatus = NULL,
                                         char *szExtraHeaders = NULL)
        {
        return SyncWriteBlocks(pIReq, 1, cbBlock, &pvBlock, &cbBlock,
                               szMimeType, szStatus, szExtraHeaders);
        }

    // static method to send contents of a file as the entire response (sync)
    static HRESULT SyncWriteFile(CIsapiReqInfo *pIReq, 
                                 TCHAR *szFile, 
                                 char *szMimeType = NULL, 
                                 char *szStatus = NULL,
                                 char *szExtraHeaders = NULL);

    // static method to send contents of a scriptless template as the entire response (sync)
    static HRESULT SyncWriteScriptlessTemplate(CIsapiReqInfo *pIReq, 
                                               CTemplate *pTemplate);

    // IStream implementation

    STDMETHODIMP Read(void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHODIMP Write(const void *pv, ULONG cb, ULONG *pcbWritten);
    STDMETHODIMP Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin,
                      ULARGE_INTEGER *plibNewPosition);
    STDMETHODIMP SetSize(ULARGE_INTEGER libNewSize);
    STDMETHODIMP CopyTo(IStream *pstm, ULARGE_INTEGER cb,
                        ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
    STDMETHODIMP Commit(DWORD grfCommitFlags);
    STDMETHODIMP Revert();
    STDMETHODIMP LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,
                            DWORD dwLockType);
    STDMETHODIMP UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,
                              DWORD dwLockType);
    STDMETHODIMP Stat(STATSTG *pstatstg, DWORD grfStatFlag);
    STDMETHODIMP Clone(IStream **ppstm);
        
	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };

inline BOOL CResponse::FHeadersWritten() 
    {
    Assert(m_fInited);
    Assert(m_pData);
    return m_pData->m_fHeadersWritten; 
    }
    
inline BOOL CResponse::FResponseAborted()
    {
    Assert(m_fInited);
    Assert(m_pData);
    return m_pData->m_fResponseAborted;
    }

inline BOOL CResponse::FWriteClientError() 
    {
    Assert(m_fInited);
    Assert(m_pData);
    return m_pData->m_fWriteClientError; 
    }

inline BOOL CResponse::FDontWrite()
    {
    Assert(m_fInited);
    Assert(m_pData);
    return (m_pData->m_fWriteClientError || m_pData->m_fIgnoreWrites);
    }
    
inline void	CResponse::SetHeadersWritten() 
    {
    Assert(m_fInited);
    Assert(m_pData);
    m_pData->m_fHeadersWritten = TRUE; 
    }

inline void CResponse::SetIgnoreWrites()
    {
    Assert(m_fInited);
    Assert(m_pData);
    m_pData->m_fIgnoreWrites = TRUE; 
    }

inline CIsapiReqInfo* CResponse::GetIReq()
    {
    Assert(m_fInited);
    Assert(m_pData);
    return m_pData->m_pIReq;
    }

inline const char* CResponse::PContentType() const
    {
    Assert(m_fInited);
    Assert(m_pData);
    if (m_pData->m_pszContentType)
        return m_pData->m_pszContentType;
	else
		return m_pData->m_pszDefaultContentType;
    }

inline char* CResponse::PCustomStatus()
    {
    Assert(m_fInited);
    Assert(m_pData);
    return m_pData->m_pszStatus;
    }

inline void *CResponse::SwapScriptEngineInfo(void *pvEngineInfo)
    {
    Assert(m_fInited);
    Assert(m_pData);
    void *pvOldEngineInfo = m_pData->m_pvGetScriptContext;
    m_pData->m_pvGetScriptContext = pvEngineInfo;
    return pvOldEngineInfo;
    }

#endif //_RESPONSE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\rfs.h ===
/*===================================================================
Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: RFS

File: rfs.h

Owner: EricN

This the Resource failure objects.
===================================================================*/

#ifdef _RFS
#ifndef _RFS_CLS_H
#define _RFS_CLS_H

#include <io.h>
#include <fcntl.h>
#include <sys/stat.h>

// for failure types
#define COUNT			1
#define MEM				2
#define	FILE_LINE		3

// for logging
#define MFSLOGFILE		"\\temp\\mfs.log"
#define MFSINIFILE		"\\temp\\mfs.ini"
	
//RFS MACROS for memory 
#define MFS_INIT(mem)		(mem).Init()
#define MFS_ON(mem)			(mem).SetRFSOn(TRUE)
#define MFS_OFF(mem)		(mem).SetRFSOn(FALSE)
#define MFS_SETTHREAD(mem)	(mem).SetThreadID(GetCurrentThreadId())
#define MFS_WRITEDATA(mem)	(mem).WriteData()
#define MFS_STARTLOOP \
	while(TRUE) \
	{
#define MFS_ENDLOOP(mem)		}
#define MFS_ENDLOOP_HR(mem)	if (hr == S_OK) break;}
#define MFS_EXTERN(mem)	extern MemRFS (mem)
#define MFS_CHECKFAIL(mem, size, file, line) \
	if ((mem).FailAlloc(size, file, line)) \
		return NULL
		
#define MFS_START(mem) \
		MFS_INIT(mem); \
		MFS_SETTHREAD(mem); \
		MFS_ON(mem); \
		MFS_STARTLOOP 

#define MFS_END_HR(mem) \
		MFS_ENDLOOP_HR(mem); \
		MFS_WRITEDATA(mem); 
 
//end macros


//rfs class
class RFS
{
public:

	RFS(DWORD dwFailOn, DWORD dwThreadID);

	void	SetThreadID(DWORD);
	virtual HRESULT Init() = 0;

protected:

	BOOL	m_fFail;
	DWORD	m_dwCurrentAlloc;

	//this will communicate with outside program	
	BOOL	DetermineFailure(LPCSTR szFile = NULL, int iLineNo = -1);	
	void	SetFailOn(DWORD, BYTE); //after a certain amount of memory or a specific request
	void	SetFailOn(LPSTR, long); //on a specific line in a file
	virtual void WriteData();

private:

	BYTE	m_bType;
	DWORD	m_dwFailOn;
	DWORD	m_dwTtlNumAllocs;
	DWORD	m_dwThreadID;
	char	m_szFailIn[MAX_PATH];

	virtual BOOL FailAlloc(void *v = NULL, LPCSTR szFile = NULL, int iLineNo = -1) = 0; //implemeneted by derived class
	virtual void Log(LPSTR pszFileName, LPSTR pszMsg);
};

class MemRFS : public RFS
{

public:

	HRESULT Init();
	MemRFS(DWORD dwFailOn = 1, DWORD dwThreadID = -1);
	void SetRFSOn(BOOL);
	void SetFailOn(DWORD, BYTE); //after a certain amount of memory or a specific request
	void SetFailOn(LPSTR, long); //on a specific line in a file
	BOOL FailAlloc(void *v = NULL, LPCSTR szFile = NULL, int iLineNo = -1);
	void WriteData();
};

#endif //_rfs_cls_h
#else

//blank out macros for non rfs build

#define MFS_ON	
#define MFS_OFF 
#define MFS_INIT  
#define MFS_STARTLOOP 
#define MFS_ENDLOOP
#define MFS_ENDLOOP_HR
#define MFS_EXTERN(mem)
#define MFS_CHECKFAIL(mem, size, file, line)
#define MFS_SETTHREAD
#define MFS_WRITEDATA
#define MFS_START(mem)
#define MFS_END_HR(mem)
#endif //_rfs
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\scrpteng.h ===
/*
 *
 *
 * C S c r i p t E n g i n e
 *
 * An individual script engine for a given language.  May be used
 * by one and only one client at a time.
 *
 */
class CScriptEngine
	{
public:	
	// public methods
	virtual HRESULT AddScriptlet(LPCOLESTR wstrScript) = 0; // Text of scriptlet

	virtual HRESULT AddObjects(BOOL fPersistNames = TRUE) = 0;

	virtual HRESULT AddAdditionalObject(LPWSTR strObjName, BOOL fPersistNames = TRUE) = 0;

	virtual HRESULT Call(LPCOLESTR strEntryPoint) = 0;

	virtual HRESULT CheckEntryPoint(LPCOLESTR strEntryPoint) = 0;

	virtual HRESULT MakeEngineRunnable() = 0;

	virtual HRESULT ResetScript() = 0;

	virtual HRESULT AddScriptingNamespace() = 0;

	virtual VOID Zombify() = 0;

	virtual HRESULT InterruptScript(BOOL fAbnormal = TRUE) = 0;

	virtual BOOL FScriptTimedOut() = 0;

	virtual BOOL FScriptHadError() = 0;

	virtual HRESULT UpdateLocaleInfo(hostinfo) = 0;

	};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\sessmgr.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Session Object Manager

File: Sessmgr.cpp

Owner: PramodD

This is the Session Manager source file.
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "idgener.h"
#include "perfdata.h"
#include "randgen.h"

// ATQ Scheduler
#include "issched.hxx"

#include "MemChk.h"

#pragma warning (disable: 4355)  // ignore: "'this' used in base member init

/*===================================================================
  G l o b a l s
===================================================================*/

PTRACE_LOG CSession::gm_pTraceLog = NULL;
unsigned long g_nSessions = 0;
CIdGenerator  g_SessionIdGenerator;
CIdGenerator  g_ExposedSessionIdGenerator;        
LONG    g_nSessionObjectsActive = 0;

// On app restart post session cleanup requests so many at a time
#define SUGGESTED_SESSION_CLEANUP_REQUESTS_MAX 500

/*===================================================================
   C S e s s i o n V a r i a n t s
===================================================================*/

/*===================================================================
CSessionVariants::CSessionVariants

Constructor

Parameters:

Returns:
===================================================================*/
CSessionVariants::CSessionVariants()
	: 
	m_cRefs(1),
	m_pSession(NULL), 
	m_ctColType(ctUnknown),
    m_ISupportErrImp(this, this, IID_IVariantDictionary)
	{
	CDispatch::Init(IID_IVariantDictionary);
	}

/*===================================================================
CSessionVariants::~CSessionVariants

Destructor

Parameters:

Returns:
===================================================================*/
CSessionVariants::~CSessionVariants()
	{
	Assert(!m_pSession);
	}
	
/*===================================================================
CSessionVariants::Init

Initialize object

Parameters:
	pSession    Session
	ctColType   Type of variables to expose in the collection
	                e.g. Tagged objects or Properties

Returns:
    HRESULT
===================================================================*/
HRESULT CSessionVariants::Init
(
CSession *pSession, 
CompType ctColType
)
	{
	Assert(pSession);
	pSession->AddRef();

	Assert(!m_pSession);

	m_pSession  = pSession;
	m_ctColType = ctColType;
	return S_OK;
	}

/*===================================================================
CSessionVariants::UnInit

UnInitialize object

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CSessionVariants::UnInit()
	{
	if (m_pSession)
	    {
	    m_pSession->Release();
	    m_pSession = NULL;
	    }
	return S_OK;
	}
	
/*===================================================================
CSessionVariants::QueryInterface
CSessionVariants::AddRef
CSessionVariants::Release

IUnknown members for CSessionVariables object.
===================================================================*/
STDMETHODIMP CSessionVariants::QueryInterface
(
REFIID iid, 
void **ppvObj
)
	{
	if (iid == IID_IUnknown || iid == IID_IDispatch ||
	    iid == IID_IVariantDictionary)
	    {
	    AddRef();
		*ppvObj = this;
		return S_OK;
        }
	else if (iid == IID_ISupportErrorInfo)
	    {
	    m_ISupportErrImp.AddRef();
		*ppvObj = &m_ISupportErrImp;
		return S_OK;
        }
        
	*ppvObj = NULL;
	return E_NOINTERFACE;
	}

STDMETHODIMP_(ULONG) CSessionVariants::AddRef()
	{
	return InterlockedIncrement((LPLONG)&m_cRefs);
	}

STDMETHODIMP_(ULONG) CSessionVariants::Release()
	{
	if (InterlockedDecrement((LPLONG)&m_cRefs) > 0)
		return m_cRefs;

	delete this;
	return 0;
	}

/*===================================================================
CSessionVariants::ObjectNameFromVariant

Gets name from variant. Resolves operations by index.
Allocates memory for name.

Parameters:
	vKey		VARIANT
	ppwszName   [out] allocated name
	fVerify     flag - check existance if named

	
Returns:
    HRESULT
===================================================================*/
HRESULT CSessionVariants::ObjectNameFromVariant
(
VARIANT &vKey,
WCHAR **ppwszName,
BOOL fVerify
)
    {
    *ppwszName = NULL;
    
	VARIANT *pvarKey = &vKey;
	VARIANT varKeyCopy;
	VariantInit(&varKeyCopy);
	if (V_VT(pvarKey) != VT_BSTR && V_VT(pvarKey) != VT_I2 && V_VT(pvarKey) != VT_I4)
		{
		if (FAILED(VariantResolveDispatch(&varKeyCopy, &vKey, IID_IVariantDictionary, IDE_SESSION)))
            {
		    ExceptionId(IID_IVariantDictionary, IDE_SESSION, IDE_EXPECTING_STR);
        	VariantClear(&varKeyCopy);
		    return E_FAIL;
		    }
		pvarKey = &varKeyCopy;
		}

    LPWSTR pwszName = NULL;

	switch (V_VT(pvarKey))
		{
		case VT_BSTR:
		    {
		    pwszName = V_BSTR(pvarKey);

		    if (fVerify && pwszName)
		        {
		        CComponentObject *pObj = NULL;

                Assert(m_pSession);
                Assert(m_pSession->PCompCol());

		        if (m_ctColType == ctTagged)
                    m_pSession->PCompCol()->GetTagged(pwszName, &pObj);
                else
                    m_pSession->PCompCol()->GetProperty(pwszName, &pObj);

                if (!pObj || pObj->GetType() != m_ctColType)
                    pwszName = NULL; // as if not found        
                }
		    break;
		    }

   		case VT_I1:  case VT_I2:               case VT_I8:
		case VT_UI1: case VT_UI2: case VT_UI4: case VT_UI8:
		case VT_R4:  case VT_R8:
			// Coerce all integral types to VT_I4
			if (FAILED(VariantChangeType(pvarKey, pvarKey, 0, VT_I4)))
				return E_FAIL;

			// fallthru to VT_I4

		case VT_I4:
		    {
		    int i;
			HRESULT hr;

			// Look up the object by index
			i = V_I4(pvarKey);

            if (i > 0)
                {
                Assert(m_pSession);
                Assert(m_pSession->PCompCol());
                
                hr = m_pSession->PCompCol()->GetNameByIndex
                    (
                    m_ctColType, 
                    i,
                    &pwszName
                    );

				if (FAILED(hr))
					return DISP_E_BADINDEX;
                }
			else 
				{
				ExceptionId(IID_IVariantDictionary, IDE_SESSION, IDE_BAD_ARRAY_INDEX);
				return E_FAIL;
				}
            break;
            }		        
		}
  	VariantClear(&varKeyCopy);

    if (!pwszName)
        return S_OK;

    // Copy name
	*ppwszName = StringDupW(pwszName);

  	return S_OK;
    }

/*===================================================================
CSessionVariants::get_Item

Function called from DispInvoke to get values from the 
SessionVariables collection.

Parameters:
	vKey		VARIANT [in], which parameter to get the value of 
	                        - integers access collection as an array
	pvarReturn	VARIANT *, [out] value of the requested parameter

Returns:
	S_OK on success, E_FAIL on failure.
===================================================================*/
HRESULT CSessionVariants::get_Item
(
VARIANT varKey, 
VARIANT *pVar
)
	{
	if (!m_pSession || FAILED(m_pSession->CheckForTombstone()))
        return E_FAIL;
        
    // Initialize return value
	VariantInit(pVar);

	if (!m_pSession->PHitObj() || !m_pSession->PCompCol())
	    return S_OK;  // return empty variant
	CHitObj *pHitObj = m_pSession->PHitObj();

    // Get name
    WCHAR *pwszName = NULL;
    HRESULT hr = ObjectNameFromVariant(varKey, &pwszName);
    if (!pwszName)
        return S_OK; // bogus index - no error

    // Find object by name
	CComponentObject *pObj = NULL;

	if (m_ctColType == ctTagged)
   		{
        pHitObj->GetComponent(csSession, pwszName, CbWStr(pwszName), &pObj);
		if (pObj && (pObj->GetType() != ctTagged))
    		pObj = NULL;
    	}
	else 
	    {
        pHitObj->GetPropertyComponent(csSession, pwszName, &pObj);
		}

    free(pwszName);

    if (!pObj)
        return S_OK;

    // return the variant
    return pObj->GetVariant(pVar);
	}

/*===================================================================
CSessionVariants::put_Item

IVariantsDictionary implementation.

Implement property put by dereferencing variants before
calling putref.

Parameters:
	VARIANT varKey	Name of the variable to set
	VARIANT Var		Value/object to set for the variable

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CSessionVariants::put_Item
(
VARIANT varKey,
VARIANT Var 
)
    {	
	if (!m_pSession || FAILED(m_pSession->CheckForTombstone()))
        return E_FAIL;

	if (m_ctColType == ctTagged)
	    {
	    ExceptionId(IID_IVariantDictionary, IDE_SESSION, 
	                IDE_CANT_MOD_STATICOBJECTS);
	    return E_FAIL;
	    }

	if (!m_pSession->PHitObj())
	    return E_FAIL;

    Assert(m_ctColType == ctProperty);

    // Resolve the variant
	VARIANT varResolved;
	HRESULT hr = VariantResolveDispatch
	    (
	    &varResolved, 
	    &Var,
        IID_ISessionObject, 
        IDE_SESSION
        );
	if (FAILED(hr))
		return hr;		// exception already raised

    // Get name
    WCHAR *pwszName = NULL;
    hr = ObjectNameFromVariant(varKey, &pwszName);
    if (!pwszName)
        return hr;

   	hr = m_pSession->PHitObj()->SetPropertyComponent
    	(
    	csSession, 
    	pwszName,
    	&varResolved
    	);

    free(pwszName);
    VariantClear(&varResolved);
	return hr;
    }

/*===================================================================
CSessionVariants::putref_Item

IVariantsDictionary implementation.

Implement property put be reference.

Parameters:
	VARIANT varKey	Name of the variable to set
	VARIANT Var		Value/object to set for the variable

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CSessionVariants::putref_Item
(
VARIANT varKey,
VARIANT Var 
)
    {	
	if (!m_pSession || FAILED(m_pSession->CheckForTombstone()))
        return E_FAIL;

	if (m_ctColType == ctTagged)
	    {
	    ExceptionId(IID_IVariantDictionary, IDE_SESSION,
	                IDE_CANT_MOD_STATICOBJECTS);
	    return E_FAIL;
	    }

    if (FIsIntrinsic(&Var))
        {
	    ExceptionId(IID_IVariantDictionary, IDE_SESSION,
	                IDE_SESSION_CANT_STORE_INTRINSIC);
	    return E_FAIL;
        }

	if (!m_pSession->PHitObj())
	    return E_FAIL;

    Assert(m_ctColType == ctProperty);

    // Get name
    WCHAR *pwszName = NULL;
    HRESULT hr = ObjectNameFromVariant(varKey, &pwszName);
    if (!pwszName)
        return hr;

   	hr = m_pSession->PHitObj()->SetPropertyComponent
    	(
    	csSession, 
    	pwszName,
    	&Var
    	);

    free(pwszName);
	return hr;
    }

/*===================================================================
CSessionVariants::get_Key

Function called from DispInvoke to get Keys from the SessionVariables collection.

Parameters:
	vKey		VARIANT [in], which parameter to get the value of - integers access collection as an array
	pvarReturn	VARIANT *, [out] value of the requested parameter

Returns:
	S_OK on success, E_FAIL on failure.
===================================================================*/
HRESULT CSessionVariants::get_Key
(
VARIANT varKey,
VARIANT *pVar
)
	{
	if (!m_pSession || FAILED(m_pSession->CheckForTombstone()))
        return E_FAIL;
        
	VariantInit(pVar);

	if (!m_pSession->PHitObj() || !m_pSession->PCompCol())
	    return S_OK;

    // Get name
    WCHAR *pwszName = NULL;
    HRESULT hr = ObjectNameFromVariant(varKey, &pwszName, TRUE);
    if (!pwszName)
        return S_OK;  // no error if bogus index

    // Return BSTr
   	BSTR bstrT = SysAllocString(pwszName);
   	free(pwszName);
   	
	if (!bstrT)
		return E_OUTOFMEMORY;
		
    V_VT(pVar) = VT_BSTR;
	V_BSTR(pVar) = bstrT;
	return S_OK;
	}

/*===================================================================
CSessionVariants::get_Count

Parameters:
	pcValues - count is stored in *pcValues
===================================================================*/
STDMETHODIMP CSessionVariants::get_Count
(
int *pcValues
)
	{
	*pcValues = 0;

	if (!m_pSession || FAILED(m_pSession->CheckForTombstone()))
        return E_FAIL;

	if (m_pSession->PCompCol())
	    {
    	if (m_ctColType == ctTagged)
    		*pcValues = m_pSession->PCompCol()->GetTaggedObjectCount();
    	else
    		*pcValues = m_pSession->PCompCol()->GetPropertyCount();
   		}
		
	return S_OK;
	}

/*===================================================================
CSessionVariants::get__NewEnum

Return a new enumerator
===================================================================*/
HRESULT CSessionVariants::get__NewEnum
(
IUnknown **ppEnumReturn
)
	{
	*ppEnumReturn = NULL;

	if (!m_pSession || FAILED(m_pSession->CheckForTombstone()))
        return E_FAIL;
	
	CVariantsIterator *pIterator = new CVariantsIterator
	    (
	    m_pSession, 
	    m_ctColType
	    );
	if (pIterator == NULL)
		{
		ExceptionId(IID_IVariantDictionary, IDE_SESSION, IDE_OOM);
		return E_OUTOFMEMORY;
		}

	*ppEnumReturn = pIterator;
	return S_OK;
	}

/*===================================================================
CSessionVariants::Remove

Remove item from the collection

Parameters:
	varKey		VARIANT [in]

Returns:
	S_OK on success, E_FAIL on failure.
===================================================================*/
STDMETHODIMP CSessionVariants::Remove
(
VARIANT varKey
)
	{
	if (!m_pSession || FAILED(m_pSession->CheckForTombstone()))
        return E_FAIL;

	if (m_ctColType == ctTagged)
	    {
	    ExceptionId(IID_IVariantDictionary, IDE_SESSION,
	                IDE_CANT_MOD_STATICOBJECTS);
	    return E_FAIL;
	    }

    Assert(m_ctColType == ctProperty);

    // Get name
    WCHAR *pwszName = NULL;
    ObjectNameFromVariant(varKey, &pwszName);
    if (!pwszName)
        return S_OK;

    CComponentCollection *pCompCol = m_pSession->PCompCol();

    if (pCompCol)
        pCompCol->RemoveProperty(pwszName);
        
    free(pwszName);
	return S_OK;
	}

/*===================================================================
CSessionVariants::RemoveAll

Remove all items from the collection

Parameters:

Returns:
	S_OK on success, E_FAIL on failure.
===================================================================*/
STDMETHODIMP CSessionVariants::RemoveAll()
	{
	if (!m_pSession || FAILED(m_pSession->CheckForTombstone()))
        return E_FAIL;

	if (m_ctColType == ctTagged)
	    {
	    ExceptionId(IID_IVariantDictionary, IDE_SESSION,
	                IDE_CANT_MOD_STATICOBJECTS);
	    return E_FAIL;
	    }

    Assert(m_ctColType == ctProperty);

    CComponentCollection *pCompCol = m_pSession->PCompCol();

    if (pCompCol)
        {
        pCompCol->RemoveAllProperties();
        }
        
	return S_OK;
	}

/*===================================================================
  C  S e s s i o n
===================================================================*/

/*===================================================================
CSession::CSession

Constructor

Parameters:

Returns:
===================================================================*/
CSession::CSession()
    :
    m_fInited(FALSE),
    m_fLightWeight(FALSE),
    m_fOnStartFailed(FALSE),
    m_fOnStartInvoked(FALSE),
    m_fOnEndPresent(FALSE),
    m_fTimedOut(FALSE), 
    m_fStateAcquired(FALSE),
    m_fCustomTimeout(FALSE), 
    m_fAbandoned(FALSE),
    m_fTombstone(FALSE),
    m_fInTOBucket(FALSE),
	m_fSessCompCol(FALSE),
    m_fCodePageSet(FALSE),
    m_fLCIDSet(FALSE),
    m_Request(static_cast<ISessionObject *>(this)),
	m_Response(static_cast<ISessionObject *>(this)),
	m_Server(static_cast<ISessionObject *>(this)),
	m_pAppln(NULL),
	m_pHitObj(NULL),
	m_pTaggedObjects(NULL),
	m_pProperties(NULL),
	m_Id(INVALID_ID, 0, 0),
	m_dwExternId(INVALID_ID),
    m_cRefs(1), 
	m_cRequests(0),
    m_dwmTimeoutTime(0),
	m_nTimeout(0),
#ifndef PERF_DISABLE
    m_dwtInitTimestamp(0),
#endif
	m_lCodePage(0),
	m_lcid(LOCALE_SYSTEM_DEFAULT),
	m_fSecureSession(FALSE)
    {
    m_lCodePage = GetACP();
	m_ISuppErrImp.Init(static_cast<ISessionObject *>(this), 
	                static_cast<ISessionObject *>(this), 
	                IID_ISessionObject);
	CDispatch::Init(IID_ISessionObject);

    InterlockedIncrement(&g_nSessionObjectsActive);

	IF_DEBUG(SESSION)
		WriteRefTraceLog(gm_pTraceLog, m_cRefs, this);
    }

/*===================================================================
CSession::~CSession

Destructor

Parameters:

Returns:
===================================================================*/
CSession::~CSession()
    {
    Assert(m_fTombstone); // must be tombstoned before destructor
    Assert(m_cRefs == 0);  // must have 0 ref count

    InterlockedDecrement(&g_nSessionObjectsActive);

    }

/*===================================================================
CSession::Init

Initialize CSession object

Parameters:
    pAppln          session's application to remember
    Id              session id

Returns:
    HRESULT
===================================================================*/
HRESULT CSession::Init
(
CAppln *pAppln, 
const CSessionId &Id
)
	{
	// Update global sessions counter
    InterlockedIncrement((LPLONG)&g_nSessions);
    
#ifndef PERF_DISABLE
    g_PerfData.Incr_SESSIONCURRENT();
    g_PerfData.Incr_SESSIONSTOTAL();
    m_dwtInitTimestamp = GetTickCount();
#endif

	// Setup the object

	HRESULT hr = S_OK;

	m_pAppln = pAppln;
    m_Id     = Id;
    m_dwExternId = g_ExposedSessionIdGenerator.NewId();     
    
    // Update application's session count
    
	m_pAppln->IncrementSessionCount();

	// default to system's ansi code page
	m_lCodePage = pAppln->QueryAppConfig()->uCodePage();
	
    m_lcid = pAppln->QueryAppConfig()->uLCID();

	// default session timeout
	m_nTimeout = pAppln->QueryAppConfig()->dwSessionTimeout();

	// initialize Viper activity
	if (SUCCEEDED(hr))
   	    hr = m_Activity.Init(pAppln->PServicesConfig());

    // mark as Inited and update timestamp
	if (SUCCEEDED(hr))
    	m_fInited = TRUE;

    return hr;
    }
    
/*===================================================================
CSession::UnInit

UnInitialize CSession object. Convert to tombstone state.

Parameters:

Returns:
    HRESULT (S_OK)
===================================================================*/
HRESULT CSession::UnInit()
	{
	Assert(!m_fTombstone);  // don't do it twice

	// Remove from timeout bucket if any
	if (m_fInTOBucket)
        m_pAppln->PSessionMgr()->RemoveSessionFromTOBucket(this);

	// Cleanup the object
    RemoveComponentCollection();

    // Get rid of the intrinsics
    m_Request.UnInit();
	m_Response.UnInit();
	m_Server.UnInit();
    
    // Get rid of Viper activity
    m_Activity.UnInit();

	// Update global counters
#ifndef PERF_DISABLE
	if (m_fTimedOut)
	    g_PerfData.Incr_SESSIONTIMEOUT();
    g_PerfData.Decr_SESSIONCURRENT();
    DWORD dwt = GetTickCount();
	if (dwt >= m_dwtInitTimestamp)
	    dwt = dwt - m_dwtInitTimestamp;
    else
        dwt = (DWT_MAX - m_dwtInitTimestamp) + dwt;
    g_PerfData.Set_SESSIONLIFETIME(dwt);
#endif

	m_pAppln->DecrementSessionCount();
    InterlockedDecrement((LPLONG)&g_nSessions);

    m_pAppln = NULL;
    m_pHitObj = NULL;

    // Mark this session as Tombstone
	
	m_fTombstone = TRUE;

	// Disconnect proxies NOW (in case we are in shutdown, or enter shutdown later & a proxy has a ref.)

	CoDisconnectObject(static_cast<ISessionObject *>(this), 0);

	return S_OK;
    }
    
/*===================================================================
CSession::MakeLightWeight

Convert to 'light-weight' state if possible

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CSession::MakeLightWeight()
    {
    Assert(m_fInited);
    
    if (m_fLightWeight)
        return S_OK;
    
    if (m_cRequests > 1)   // requests pending for this session?
        return S_OK;

    if (m_fSessCompCol && !m_SessCompCol.FHasStateInfo())
        {
        // don't remove component collection from under enumerators
        if (!m_pTaggedObjects && !m_pProperties)
            RemoveComponentCollection();
        }

    m_fLightWeight = TRUE;
    return S_OK;
    }

/*===================================================================
CSession::CreateComponentCollection

Create and Init Session's component collection.

The actual object is aggregated by the session. Its state
is controlled be m_fSessCompCol flag.

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CSession::CreateComponentCollection()
    {
    Assert(!m_fSessCompCol);

    HRESULT hr = m_SessCompCol.Init(csSession);

    if (SUCCEEDED(hr))
        {
        m_fSessCompCol = TRUE;
        }
    else
        {
        RemoveComponentCollection();
        }
        
	return hr;
    }

/*===================================================================
CSession::RemoveComponentCollection

Remove Session's component collection

The actual object is aggregated by the session. Its state
is controlled be m_fSessCompCol flag.

Parameters:

Returns:
    HRESULT
===================================================================*/
HRESULT CSession::RemoveComponentCollection()
    {
    if (m_pTaggedObjects)
        {
        m_pTaggedObjects->UnInit();
        m_pTaggedObjects->Release();
        m_pTaggedObjects = NULL;
        }

    if (m_pProperties)
        {
        m_pProperties->UnInit();
        m_pProperties->Release();
        m_pProperties = NULL;
        }
        
    if (m_fSessCompCol)
        {
   	    m_SessCompCol.UnInit();
   	    m_fSessCompCol = FALSE;
   	    }

    return S_OK;
    }

/*===================================================================
CSession::FShouldBeDeletedNow

Tests if the session should be deleted

Parameters:
    BOOL fAtEndOfRequest    TRUE if at the end of a request

Returns:
    BOOL    TRUE (should be deleted) or FALSE (shouldn't)
===================================================================*/
BOOL CSession::FShouldBeDeletedNow
(
BOOL fAtEndOfRequest
)
    {
    if (fAtEndOfRequest)
        {
        // Any OTHER requests pending -> don't delete
    	if (m_cRequests > 1)
	        return FALSE;
        }
    else
        {
        // Any requests pending -> don't delete
    	if (m_cRequests > 0)
	        return FALSE;
        }

    // GLOBAL.ASA changed - delete
   	if (m_pAppln->FGlobalChanged())
   	    return TRUE;

    // Failed to start or abandoned - delete
	if (m_fOnStartFailed || m_fAbandoned)
	    return TRUE;

    // Is stateless session? No need for Session_OnEnd?
    if (!m_fSessCompCol    &&  // CompCol gone in MakeLightWeight()
        !m_fStateAcquired  &&  // no other properties set
        !m_fOnStartInvoked &&  // on start was never invoked
        !m_fOnEndPresent)      // on end is not present
        return TRUE;           // -> delete this session

    // don't check timeout here
    return FALSE;
    }

/*===================================================================
CSession::QueryInterface

QueryInterface() -- IUnknown implementation.

Parameters:
    REFIID riid
    void **ppv
    
Returns:
	HRESULT
===================================================================*/
STDMETHODIMP CSession::QueryInterface
(
REFIID riid,
void **ppv
)
    {
	*ppv = NULL;

	if (IID_IUnknown         == riid ||
	    IID_IDispatch        == riid ||
	    IID_ISessionObject   == riid || 
	    IID_IDenaliIntrinsic == riid)
	    {
		*ppv = static_cast<ISessionObject *>(this);
        ((IUnknown *)*ppv)->AddRef();
		return S_OK;
		}
		
    else if (IID_ISupportErrorInfo == riid)
        {
        m_ISuppErrImp.AddRef();
		*ppv = &m_ISuppErrImp;
		return S_OK;
		}
    else if (IID_IMarshal == riid)
        {
        *ppv = static_cast<IMarshal *>(this);
        ((IUnknown *)*ppv)->AddRef();
        return S_OK;
        }
	else
	    {
    	return E_NOINTERFACE;
    	}
    	
	}

/*===================================================================
CSession::AddRef

AddRef() -- IUnknown implementation.

Parameters:
    
Returns:
    Ref count
===================================================================*/
STDMETHODIMP_(ULONG) CSession::AddRef()
    {
    DWORD cRefs = InterlockedIncrement((LPLONG)&m_cRefs);

	IF_DEBUG(SESSION)
		WriteRefTraceLog(gm_pTraceLog, m_cRefs, this);

	return cRefs;
    }

/*===================================================================
CSession::Release

Release() -- IUnknown implementation.

Parameters:
    
Returns:
    Ref count
===================================================================*/
STDMETHODIMP_(ULONG) CSession::Release()
    {
    DWORD cRefs = InterlockedDecrement((LPLONG)&m_cRefs);

	IF_DEBUG(SESSION)
		WriteRefTraceLog(gm_pTraceLog, m_cRefs, this);

	if (cRefs)
		return cRefs;

	delete this;
	return 0;
    }

/*===================================================================
CSession::CheckForTombstone

Tombstone stub for ISessionObject methods. If the object is
tombstone, does ExceptionId and fails.

Parameters:
    
Returns:
	HRESULT     E_FAIL  if Tombstone
	            S_OK if not
===================================================================*/
HRESULT CSession::CheckForTombstone()
    {
    if (!m_fTombstone)
        return S_OK;
        
	ExceptionId
	    (
	    IID_ISessionObject, 
	    IDE_SESSION, 
	    IDE_INTRINSIC_OUT_OF_SCOPE
	    );
    return E_FAIL;
    }

/*===================================================================
CSession::get_SessionID

ISessionObject implementation.

Return the session ID to the caller

Parameters:
	BSTR *pbstrRet      [out] session id value
    
Returns:
	HRESULT
===================================================================*/
STDMETHODIMP CSession::get_SessionID
(
BSTR *pbstrRet
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;
        
	HRESULT hr = S_OK;

	wchar_t	wszId[15];
	_ultow(m_dwExternId, wszId, 10);
	*pbstrRet = SysAllocString(wszId);
	
	if (*pbstrRet == NULL)
    	{
		ExceptionId
		    (
		    IID_ISessionObject, 
		    IDE_SESSION_ID, 
		    IDE_SESSION_MAP_FAILED
		    );
		hr = E_FAIL;
	    }

	m_fStateAcquired = TRUE;                
	return hr;
    }
    
/*===================================================================
CSession::get_Timeout

ISessionObject implementation.

Return the default or user set timeout interval (in minutes)

Parameters:
    long *plVar         [out] timeout value (in minutes)
    
Returns:
	HRESULT
===================================================================*/
STDMETHODIMP CSession::get_Timeout
(
long *plVar
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;
        
	*plVar = m_nTimeout;
	return S_OK;
    }
    
/*===================================================================
CSession::put_Timeout

ISessionObject implementation.

Allows the user to set the timeout interval (in minutes)

Parameters:
    long lVar         timeout value (in minutes)
    
Returns:
	HRESULT
===================================================================*/
STDMETHODIMP CSession::put_Timeout
(
long lVar
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;
        
	if (lVar < SESSION_TIMEOUT_MIN || lVar > SESSION_TIMEOUT_MAX)
    	{
		ExceptionId
    		(
	    	IID_ISessionObject, 
	    	IDE_SESSION_ID, 
	    	IDE_SESSION_INVALID_TIMEOUT 
	    	);
		return E_FAIL;
	    }

	m_fStateAcquired = TRUE;
	m_fCustomTimeout = TRUE;
	
	m_nTimeout = lVar;
	return S_OK;
    }

/*===================================================================
CSession::get_CodePage

ISessionObject implementation.

Returns the current code page value for the request

Parameters:
    long *plVar     [out] code page value

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CSession::get_CodePage
(
long *plVar 
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;
        
	Assert(m_pHitObj);

	*plVar = m_lCodePage;

	// If code page is 0, look up default ANSI code page
	if (*plVar == 0)
		{
		*plVar = (long) GetACP();
		}
		
	return S_OK;
    }

/*===================================================================
CSession::put_CodePage

ISessionObject implementation.

Sets the current code page value for the request

Parameters:
    long lVar       code page to assign to this session

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CSession::put_CodePage
(
long lVar 
) 
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;
        
	// set code page member variable 
	Assert(m_pHitObj);
	HRESULT hr = m_pHitObj->SetCodePage(lVar);

	if (FAILED(hr))
		{
		ExceptionId
		    (
		    IID_ISessionObject,
		    IDE_SESSION_ID, 
		    IDE_SESSION_INVALID_CODEPAGE 
		    );
		return E_FAIL;
		}

    m_fCodePageSet = TRUE;

    m_lCodePage = lVar;
		
	// we need to preserve session since the user has set 
	// its code page member variable
	m_fStateAcquired = TRUE;
	return S_OK;
    }


/*===================================================================
CSession::get_LCID

ISessionObject implementation.

Returns the current lcid value for the request

Parameters:
    long *plVar     [out] code page value

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CSession::get_LCID
(
long *plVar 
)
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;
        
	Assert(m_pHitObj);

	*plVar = m_lcid;

    if (*plVar == LOCALE_SYSTEM_DEFAULT) {
        *plVar = GetSystemDefaultLCID();
    }
	return S_OK;
    }

/*===================================================================
CSession::put_LCID

ISessionObject implementation.

Sets the current LCID value for the request

Parameters:
    long lVar   LCID to assign to this session

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CSession::put_LCID
(
long lVar 
) 
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;
        
	// set code page member variable 
	Assert(m_pHitObj);
	HRESULT hr = m_pHitObj->SetLCID(lVar);	

	if (FAILED(hr))
		{
		ExceptionId
		    (
		    IID_ISessionObject,
		    IDE_SESSION_ID, 
		    IDE_TEMPLATE_BAD_LCID 
		    );
		return E_FAIL;
		}
	
    m_fLCIDSet = TRUE;
    m_lcid = lVar;

	// we need to preserve session since the user has set 
	// its lcid member variable
	m_fStateAcquired = TRUE;
	return S_OK;
    }

/*===================================================================
CSession::get_Value

ISessionObject implementation.

Will allow the user to retreive a session state variable, 
the variable will come as a named pair, bstr is the name and
var is the value or object to be returned for that name

Parameters:
	BSTR     bstrName	Name of the variable to get
	VARIANT *pVar		Value/object to get for the variable

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CSession::get_Value
(
BSTR bstrName, 
VARIANT *pVar
)
    {	
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

   	if (bstrName == NULL)
	    {
		ExceptionId(IID_ISessionObject, IDE_SESSION, IDE_EXPECTING_STR);
		return E_FAIL;
		}

	VariantInit(pVar); // default variant empty
	
    WCHAR *pwszName;
    STACK_BUFFER(rgbName, 42);
    WSTR_STACK_DUP(bstrName, &rgbName, &pwszName);
    
	if (pwszName == NULL)
	    return S_OK; // no name - no value - no error
	//_wcsupr(pwszName);

	CComponentObject *pObj = NULL;
	HRESULT hr = S_OK;

    Assert(m_pHitObj);
    m_pHitObj->AssertValid();
    
	hr = m_pHitObj->GetPropertyComponent(csSession, pwszName, &pObj);
	
    if (SUCCEEDED(hr) && pObj)
        hr = pObj->GetVariant(pVar);

	return S_OK;
    }

/*===================================================================
CSession::putref_Value

ISessionObject implementation.

Will allow the user to assign a session state variable to be saved
the variable will come as a named pair, bstr is the name and
var is the value or object to be stored for that name

Parameters:
	BSTR 	bstrName	Name of the variable to set
	VARIANT Var			Value/object to set for the variable

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CSession::putref_Value
(
BSTR bstrName, 
VARIANT Var
) 
    {	
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (FIsIntrinsic(&Var))
        {
	    ExceptionId(IID_ISessionObject, IDE_SESSION,
	                IDE_SESSION_CANT_STORE_INTRINSIC);
	    return E_FAIL;
        }

   	if (bstrName == NULL)
	    {
		ExceptionId(IID_ISessionObject, IDE_SESSION, IDE_EXPECTING_STR);
		return E_FAIL;
		}
        
	HRESULT hr;

    Assert(m_pHitObj);
    m_pHitObj->AssertValid();

    WCHAR *pwszName;
    STACK_BUFFER(rgbName, 42);
    WSTR_STACK_DUP(bstrName, &rgbName, &pwszName);
    
	if (pwszName == NULL)
	    {
		ExceptionId
		    (
		    IID_ISessionObject,
		    IDE_SESSION,
		    IDE_EXPECTING_STR
		    );
		return E_FAIL;
		}
	//_wcsupr(pwszName);

    hr = m_pHitObj->SetPropertyComponent(csSession, pwszName, &Var);

	return hr;
    }

/*===================================================================
CSession::put_Value

ISessionObject implementation.

Implement property put by dereferencing variants before
calling putref.

Parameters:
	BSTR    bstrName	Name of the variable to set
	VARIANT Var			Value/object to set for the variable

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CSession::put_Value
(
BSTR bstrName,
VARIANT Var 
)
    {	
    if (FAILED(CheckForTombstone()))
        return E_FAIL;
        
   	if (bstrName == NULL)
	    {
		ExceptionId(IID_ISessionObject, IDE_SESSION, IDE_EXPECTING_STR);
		return E_FAIL;
		}
        
	HRESULT hr;
	VARIANT varResolved;
	
	hr = VariantResolveDispatch
	    (
	    &varResolved, 
	    &Var,
        IID_ISessionObject, 
        IDE_SESSION
        );
        
	if (FAILED(hr))
		return hr;		// exception already raised

    Assert(m_pHitObj);
    m_pHitObj->AssertValid();

    WCHAR *pwszName;
    STACK_BUFFER(rgbName, 42);
    WSTR_STACK_DUP(bstrName, &rgbName, &pwszName);
    
	if (pwszName == NULL)
	    {
		ExceptionId
		    (
		    IID_ISessionObject, 
		    IDE_SESSION,
		    IDE_EXPECTING_STR
		    );
    	VariantClear( &varResolved );
		return E_FAIL;
		}
	//_wcsupr(pwszName);
    
    hr = m_pHitObj->SetPropertyComponent
        (
        csSession, 
        pwszName,
        &varResolved
        );
        
	VariantClear( &varResolved );
                                         
	return hr;
    }

/*===================================================================
CSession::Abandon

ISessionObject implementation.

Abandon reassignes session id to avoid hitting this session
with incoming requests. Abandoned sessions get deleted ASAP.

Parameters:
	None

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CSession::Abandon()
    {	
    if (FAILED(CheckForTombstone()))
        return E_FAIL;
        
	m_fAbandoned = TRUE;

	// The new session logic allows only one session id per
	// client need to disassociate session from client
	// (good idea when abandoning anyway)
	Assert(m_pHitObj);

    // If execution Session_OnEnd (not a browser request), do nothing
	if (!m_pHitObj->FIsBrowserRequest())
	    return S_OK;
	    
   	return m_pHitObj->ReassignAbandonedSession();
    }

/*===================================================================
CSession::get_StaticObjects

Return the session static objects dictionary
===================================================================*/
STDMETHODIMP CSession::get_StaticObjects
(
IVariantDictionary **ppDictReturn
)
	{
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (!m_pTaggedObjects)
        {
        m_pTaggedObjects = new CSessionVariants;
        if (!m_pTaggedObjects)
            return E_OUTOFMEMORY;
        
        HRESULT hr = m_pTaggedObjects->Init(this, ctTagged);
        if (FAILED(hr))
            {
            m_pTaggedObjects->UnInit();
            m_pTaggedObjects->Release();
            m_pTaggedObjects = NULL;
            }
        }

    Assert(m_pTaggedObjects);
	return m_pTaggedObjects->QueryInterface(IID_IVariantDictionary, reinterpret_cast<void **>(ppDictReturn));
	}

/*===================================================================
CSession::get_Contents

Return the session contents dictionary
===================================================================*/
STDMETHODIMP CSession::get_Contents
(
IVariantDictionary **ppDictReturn
)
	{
    if (FAILED(CheckForTombstone()))
        return E_FAIL;

    if (!m_pProperties)
        {
        m_pProperties = new CSessionVariants;
        if (!m_pProperties)
            return E_OUTOFMEMORY;
            
        HRESULT hr = m_pProperties->Init(this, ctProperty);
        if (FAILED(hr))
            {
            m_pProperties->UnInit();
            m_pProperties->Release();
            m_pProperties = NULL;
            }
        }
        
    Assert(m_pProperties);
	return m_pProperties->QueryInterface(IID_IVariantDictionary, reinterpret_cast<void **>(ppDictReturn));
	}

#ifdef DBG
/*===================================================================
CSession::AssertValid

Test to make sure that the CSession object is currently 
correctly formed and assert if it is not.

Returns:
	None

Side effects:
	None.
===================================================================*/
VOID CSession::AssertValid() const
    {	
    Assert(m_fInited);

    if (!m_fTombstone)
        Assert(m_pAppln);
    }
#endif // DBG


/*===================================================================
  C  S e s s i o n  M g r
===================================================================*/

/*===================================================================
CSessionMgr::CSessionMgr

CSessionMgr constructor.

Parameters:
	NONE

Returns:
===================================================================*/
CSessionMgr::CSessionMgr()
    :
    m_fInited(FALSE),
    m_pAppln(NULL),
    m_cSessionCleanupRequests(0),
	m_cTimeoutBuckets(0),
	m_rgolTOBuckets(NULL),
    m_idSessionKiller(0),
    m_dwmCurrentTime(0),
    m_dwtNextSessionKillerTime(0)
    {
    }
    
/*===================================================================
CSessionMgr::~CSessionMgr

CSessionMgr destructor.

Parameters:
	NONE

Returns:
===================================================================*/
CSessionMgr::~CSessionMgr()
    {
    UnInit(); 
    }

/*===================================================================
HRESULT CSessionMgr::Init

Initializes the Session Manager.
Initializes hash tables.
Schedules session killer.

Parameters:
	pAppln      Application

Returns:
    HRESULT
===================================================================*/
HRESULT CSessionMgr::Init
(
CAppln *pAppln
)
    {
    Assert(!m_fInited);

    HRESULT hr;
	m_pAppln = pAppln;

    // Master hash table
	hr = m_htidMaster.Init
	    (
        SESSION_MASTERHASH_SIZE1_MAX,
        SESSION_MASTERHASH_SIZE2_MAX,
        SESSION_MASTERHASH_SIZE3_MAX
	    );
	if (FAILED(hr))
	    return hr;

    // Number of timeout buckets = session timeout in minutes + 1
    m_cTimeoutBuckets = 
        m_pAppln->QueryAppConfig()->dwSessionTimeout() + 1;
    
    if (m_cTimeoutBuckets < SESSION_TIMEOUTBUCKETS_MIN)
        m_cTimeoutBuckets = SESSION_TIMEOUTBUCKETS_MIN;
    else if (m_cTimeoutBuckets > SESSION_TIMEOUTBUCKETS_MAX)
        m_cTimeoutBuckets = SESSION_TIMEOUTBUCKETS_MAX;

	// Timeout buckets hash tables array
	m_rgolTOBuckets = new CObjectListWithLock[m_cTimeoutBuckets];
	if (!m_rgolTOBuckets)
	    return E_OUTOFMEMORY;

    // Each timeout bucket hash table
    for (DWORD i = 0; i < m_cTimeoutBuckets; i++)
        {
    	hr = m_rgolTOBuckets[i].Init
    	    (
    	    OBJECT_LIST_ELEM_FIELD_OFFSET(CSession, m_TOBucketElem)
    	    );
    	if (FAILED(hr))
    	    return hr;
        }

    // Schedule session killer
    hr = ScheduleSessionKiller();
    if (FAILED(hr))
        return hr;

    // Start counting time
    m_dwmCurrentTime = 0;
    
    // Remember the time of the next session killer
    m_dwtNextSessionKillerTime = ::GetTickCount() + MSEC_ONE_MINUTE;

	m_fInited = TRUE;
	return S_OK;
    }

/*===================================================================
HRESULT CSessionMgr::UnInit

UnInitializes the Session Manager.

Parameters:

Returns:
	S_OK
===================================================================*/
HRESULT CSessionMgr::UnInit( void )
    {
    // Un-schedule session killer
    if (m_idSessionKiller)
        UnScheduleSessionKiller();

    // Timeout buckets
	if (m_rgolTOBuckets)
	    {
        for (DWORD i = 0; i < m_cTimeoutBuckets; i++)
        	m_rgolTOBuckets[i].UnInit();
	    delete [] m_rgolTOBuckets;
	    m_rgolTOBuckets = NULL;
	    }
    m_cTimeoutBuckets = 0;	    

    // Master hash
	m_htidMaster.UnInit();

	m_fInited = FALSE;
	return S_OK;
    }

/*===================================================================
CSessionMgr::ScheduleSessionKiller

Sets up the session killer workitem for ATQ scheduler

Parameters:
    
Returns:
    HRESULT
===================================================================*/
HRESULT CSessionMgr::ScheduleSessionKiller()
    {
    Assert(!m_idSessionKiller);
    
    m_idSessionKiller = ScheduleWorkItem
        (
        CSessionMgr::SessionKillerSchedulerCallback,  // callback
        this,                                         // context
        MSEC_ONE_MINUTE,                              // timeout
        TRUE                                          // periodic
        );
        
    return m_idSessionKiller ? S_OK : E_FAIL;
    }
    
/*===================================================================
CSessionMgr::UnScheduleSessionKiller

Removes the session killer workitem for ATQ scheduler

Parameters:
    
Returns:
    S_OK
===================================================================*/
HRESULT CSessionMgr::UnScheduleSessionKiller()
    {
    if (m_idSessionKiller)
        {
        RemoveWorkItem(m_idSessionKiller);
        m_idSessionKiller = 0;
        }
    return S_OK;
    }

/*===================================================================
CSessionMgr::GenerateIdAndCookie

Generate new ID and cookie to be used create new session
or reassign the session ID for an existing session.

Parameters:
    pId             [out] ID
    pszNewCookie    [out] Cookie (buf must be long enough)

Returns:
    S_OK
===================================================================*/
HRESULT CSessionMgr::GenerateIdAndCookie
(
CSessionId *pId,
char  *pszNewCookie
)
    {
    pId->m_dwId = g_SessionIdGenerator.NewId();
    GenerateRandomDwords(&pId->m_dwR1, 2);
 
    EncodeSessionIdCookie
        (
        pId->m_dwId,
        pId->m_dwR1,
        pId->m_dwR2,
        pszNewCookie
        );
    
    return S_OK;
    }

/*===================================================================
CSessionMgr::NewSession

Creates and Inits a new CSession object

Parameters:
    Id            session id
    ppSession     [out] session created

Returns:
    HRESULT
===================================================================*/
HRESULT CSessionMgr::NewSession
(
const CSessionId &Id,
CSession **ppSession
)
    {
    Assert(m_fInited);
    
    HRESULT hr = S_OK;
    
	CSession *pSession = new CSession;
	if (!pSession)
	    hr = E_OUTOFMEMORY;

	if (SUCCEEDED(hr))
	    hr = pSession->Init(m_pAppln, Id);

	if (SUCCEEDED(hr))
	    {
	    Assert(pSession);
        *ppSession = pSession;
	    }
	else
	    {
	    // failed - do cleanup
	    if (pSession)
	        {
	        pSession->UnInit();
	        pSession->Release();
	        }
        *ppSession = NULL;
	    }
		
	return hr;
    }

/*===================================================================
CSessionMgr::ChangeSessionId

Reassigns different session Id to a session.
Updates the master hash.

This method is called when abandoning a session
to disassociate it from the client.

Parameters:
	pSession        session to change id on
    Id		        new session id to assign

Returns:
	S_OK on success
	E_FAIL	on failure
===================================================================*/
HRESULT CSessionMgr::ChangeSessionId
(
CSession *pSession,
const CSessionId &Id
)
    {
    HRESULT hr;
    
    // During request processing session's not supposed to be
    // in any timeout bucket
    Assert(!pSession->m_fInTOBucket);

    LockMaster();

    // Remove from master hash by Id
    hr = RemoveFromMasterHash(pSession);
    
    if (SUCCEEDED(hr))
        {
        // Assign new id
        pSession->AssignNewId(Id);

        // Reinsert into master hash by id
        hr = AddToMasterHash(pSession);
        }

    UnLockMaster();
    
    return hr;
    }

/*===================================================================
CSessionMgr::FindInMasterHash

Finds Session in master hash session id.
Doesn't Lock.

Parameters:
        Id            session id to find
        **ppSession   [out] session found
	
Returns:
	S_OK     good session found
	S_FALSE     session not found or bad session found
===================================================================*/
HRESULT CSessionMgr::FindInMasterHash
(
const CSessionId &Id, 
CSession **ppSession
)
    {
    Assert(m_fInited);
    
	// Find in the hash table
	HRESULT hr = m_htidMaster.FindObject(Id.m_dwId, (void **)ppSession);
	if (hr != S_OK)
	    {
	    // Not found
	    *ppSession = NULL;
	    return hr;
	    }

    // Session found, check if valid
	if ((*ppSession)->m_fAbandoned ||
	    (*ppSession)->m_fTombstone ||
	    !(*ppSession)->FPassesIdSecurityCheck(Id.m_dwR1, Id.m_dwR2))
	    {
	    // Bad session
        hr = S_FALSE;
	    }

	return hr;
	}

/*===================================================================
CSessionMgr::AddSessionToTOBucket

Adds session to the correct timeout bucket.
Locks the timeout bucket.

Parameters:
	pSession        - session to add
    
Returns:
	HRESULT
===================================================================*/
HRESULT CSessionMgr::AddSessionToTOBucket
(
CSession *pSession
)
    {
    HRESULT hr;
    
    // Should not be already in a timeout bucket
    Assert(!pSession->m_fInTOBucket);

    DWORD iBucket = GetSessionTOBucket(pSession);

    LockTOBucket(iBucket);
    
    hr = m_rgolTOBuckets[iBucket].AddObject(pSession);
    
    if (SUCCEEDED(hr))
        pSession->m_fInTOBucket = TRUE;
        
    UnLockTOBucket(iBucket);
    
    return hr;
    }
    
/*===================================================================
CSessionMgr::RemoveSessionToTOBucket

Removes from its timeout bucket if any.
Locks the timeout bucket.

Parameters:
	pSession        - session to remove
	fLock           - lock bucket? (not needed during shutdown)
    
Returns:
	HRESULT
===================================================================*/
HRESULT CSessionMgr::RemoveSessionFromTOBucket
(
CSession *pSession,
BOOL fLock
)
    {
    HRESULT hr;
    
    Assert(m_fInited);
    Assert(pSession->m_fInited);

    if (!pSession->m_fInTOBucket)   // not there - no error
        return S_OK;

    DWORD iBucket = GetSessionTOBucket(pSession);

    if (fLock)
        LockTOBucket(iBucket);

    if (pSession->m_fInTOBucket)    // recheck after locking
        hr = m_rgolTOBuckets[iBucket].RemoveObject(pSession);
    else
        hr = S_OK;

    if (SUCCEEDED(hr))
        pSession->m_fInTOBucket = FALSE;

    if (fLock)
        UnLockTOBucket(iBucket);
        
    return hr;
    }

/*===================================================================
CSessionMgr::DeleteSession

Delete now or post for deletion.
Should be called after the session is gone from the hash table

Parameters:
	CSession *pSession        - session to release
    BOOL fInSessionActivity   - TRUE when deleting HitObj's session
                                at the end of request (no Async 
                                calls needed)
    
Returns:
	HRESULT (S_OK)
===================================================================*/
HRESULT CSessionMgr::DeleteSession
(
CSession *pSession,
BOOL fInSessionActivity
)
    {
    Assert(pSession);
    pSession->AssertValid();

    // Take care of DELETE NOW case

    BOOL fDeleteNow = pSession->FCanDeleteWithoutExec();

    // If called not from the session's activity and session
    // has objects then need to switch to the right activity
    // to remove the session level objects

    if (!fInSessionActivity && pSession->FHasObjects())
        fDeleteNow = FALSE; 
    
    if (fDeleteNow)
        {
        pSession->UnInit();
        pSession->Release();
		return S_OK;
		}

    // THE ASYNC DELETE LOGIC

	HRESULT hr = S_OK;

	// Make sure session object exists after AsyncCall
	pSession->AddRef(); 

    // Create new HitObj and init it for session delete
    
	CHitObj *pHitObj = new CHitObj;
	if (pHitObj)
	    {
	    pHitObj->SessionCleanupInit(pSession);

    	if (fInSessionActivity)
    	    {
    	    // Already inside the correct activity no need to 
    	    // push the call through Viper
    	    
            BOOL fRequestReposted = FALSE;
            pHitObj->ViperAsyncCallback(&fRequestReposted);
            Assert(!fRequestReposted);  // this better not happen
            delete pHitObj;
    	    }
        else
            {
            // Ask Viper to post the request
        	hr = pHitObj->PostViperAsyncCall();
            if (FAILED(hr))
                delete pHitObj;
        	}
        }
    else
    	{
		hr = E_OUTOFMEMORY;
	    }

    if (FAILED(hr))
        {
        // Out of memery or Viper failed to post a request
        // Force the issue inside TRY CATCH
        // (not always safe to delete in the wrong thread)
        TRY
            hr = pSession->UnInit();
    	CATCH(nExcept)
    	    pSession->m_fTombstone = TRUE;
			CoDisconnectObject(static_cast<ISessionObject *>(pSession), 0);
	        hr = E_UNEXPECTED;
        END_TRY
        pSession->Release();
        }

    pSession->Release(); // Undo AddRef()
    return S_OK;
    }
    
/*===================================================================
CSessionMgr::DeleteExpiredSessions

Removes expired Sessions from a given timeout bucket

Parameters:
    iBucket     timeout bucket #

Returns:
    HRESULT (S_OK)
===================================================================*/
HRESULT CSessionMgr::DeleteExpiredSessions
(
DWORD iBucket
)
    {
    LockTOBucket(iBucket);

    void *pvSession = m_rgolTOBuckets[iBucket].PFirstObject();

    while (pvSession && !IsShutDownInProgress())
        {
        CSession *pSession = reinterpret_cast<CSession *>(pvSession);
        pvSession = m_rgolTOBuckets[iBucket].PNextObject(pvSession);

        if (pSession->GetRequestsCount() == 0)
            {
            BOOL fTimedOut = pSession->GetTimeoutTime() <= GetCurrentTime();
            BOOL fRemovedFromMasterHash = FALSE;
            
            if (fTimedOut || pSession->FShouldBeDeletedNow(FALSE))
                {
                LockMaster();

                if (pSession->GetRequestsCount() == 0) // recheck after lock
                    {
                    RemoveFromMasterHash(pSession);
                    fRemovedFromMasterHash = TRUE;
                    }
                    
          	    UnLockMaster();
                }

            if (fRemovedFromMasterHash)
                {
                if (fTimedOut)
                    pSession->m_fTimedOut = TRUE;

                // delete from timeout bucket
                m_rgolTOBuckets[iBucket].RemoveObject(pSession);
                pSession->m_fInTOBucket = FALSE;

                // delete session object itself (or schedule for deletion)
                DeleteSession(pSession);
                }
            }
        }

    UnLockTOBucket(iBucket);
    return S_OK;
    }

/*===================================================================
CSessionMgr::DeleteAllSessions

Application shutdown code.

Parameters:
    fForce      flag - force delete?

Returns:
    HRESULT (S_OK)
===================================================================*/
HRESULT CSessionMgr::DeleteAllSessions
(
BOOL fForce
)
    {
    // Remove session killer so that it wouldn't interfere
    UnScheduleSessionKiller();
    
    LockMaster();

    HRESULT hr = m_htidMaster.IterateObjects
        (
        DeleteAllSessionsCB,
        this,
        &fForce
        );

    if (fForce)
        m_htidMaster.RemoveAllObjects();
    
    UnLockMaster();
    return hr;
    }
    
/*===================================================================
CSessionMgr::DeleteAllSessionsCB

Static iterator callback. 
Removes Session regardless.

Parameters:
    pvSession       session passed as void*
    pvSessionMgr    session manager passed as void*
    pvfForce        flag if TRUE - force the issue

Returns:
    IteratorCallbackCode
===================================================================*/
IteratorCallbackCode CSessionMgr::DeleteAllSessionsCB
(
void *pvSession,
void *pvSessionMgr,
void *pvfForce
)
    {
    IteratorCallbackCode rc = iccContinue;
    
    CSession *pSession = reinterpret_cast<CSession *>(pvSession);
    CSessionMgr *pMgr = reinterpret_cast<CSessionMgr *>(pvSessionMgr);
    BOOL fForce = *(reinterpret_cast<BOOL *>(pvfForce));

	// Try for 5 seconds to post delete for each session
	for (int iT = 0; iT < 10; iT++)
	    {
	    if (pSession->GetRequestsCount() == 0)
	        {
	        if (fForce)
	            {
	            // When forcing delete and there are too many
	            // session cleanup requests quequed
	            // wait for the queue to drain
	            while (pMgr->GetNumSessionCleanupRequests() >= SUGGESTED_SESSION_CLEANUP_REQUESTS_MAX)
	                Sleep(100);
	            }
	        else // if (!fForce)
	            {
	            // When not forcing delete (on application restart)
	            // don't queue too many sessions at one time
	            
	            if (pMgr->GetNumSessionCleanupRequests() < SUGGESTED_SESSION_CLEANUP_REQUESTS_MAX)
                    rc = iccRemoveAndContinue;
                else
                    rc = iccRemoveAndStop;
                }
                
            if (pSession->FInTOBucket())
                pMgr->RemoveSessionFromTOBucket(pSession, !fForce);
                
       		pMgr->DeleteSession(pSession);
   		    break;
            }

        if (!fForce)
            break;
            
		Sleep(500);
		}

    return rc;
    }

/*===================================================================
CSessionMgr::SessionKillerSchedulerCallback

Static method implements ATQ scheduler callback functions.
Replaces session killer thread

Parameters:
    void *pv    context pointer (points to appl)

Returns:

Side effects:
    None.
===================================================================*/
void WINAPI CSessionMgr::SessionKillerSchedulerCallback
(
void *pv
)
    {
    if (IsShutDownInProgress())
        return;

    Assert(pv);
    CSessionMgr *pMgr = reinterpret_cast<CSessionMgr *>(pv);

    // Advance session killer time by 1 [minute]
    pMgr->m_dwmCurrentTime++;

    // Choose the bucket
    DWORD iBucket = pMgr->m_dwmCurrentTime % pMgr->m_cTimeoutBuckets;

    // Kill the sessions
    pMgr->DeleteExpiredSessions(iBucket);

    // Adjust the timeout to stay on the minute boundary
    pMgr->m_dwtNextSessionKillerTime += MSEC_ONE_MINUTE;

    // Calculate wait till next callback wakes up    
    DWORD dwtCur  = ::GetTickCount();
    DWORD dwtWait = 5000; //  5 sec if we are already late

//    if (dwtCur < pMgr->m_dwtNextSessionKillerTime)
//        {
        dwtWait = pMgr->m_dwtNextSessionKillerTime - dwtCur;
        if (dwtWait > MSEC_ONE_MINUTE)
            dwtWait = MSEC_ONE_MINUTE; // in case of wrap-around
//        }

    ScheduleAdjustTime(pMgr->m_idSessionKiller, dwtWait);
    }

#ifdef DBG
/*===================================================================
CSessionMgr::AssertValid

Test to make sure that this is currently correctly formed
and assert if it is not.

Returns:
===================================================================*/
void CSessionMgr::AssertValid() const
    {
    Assert(m_fInited);
    }
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\server.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Server object

File: Server.h

Owner: CGrant

This file contains the header info for defining the Server object.
Note: This was largely stolen from Kraig Brocjschmidt's Inside OLE2
second edition, chapter 14 Beeper v5.
===================================================================*/

#ifndef _Server_H
#define _Server_H

#include "debug.h"
#include "dispatch.h"
#include "denguid.h"
#include "memcls.h"
#include "ftm.h"

#ifdef USE_LOCALE
extern DWORD g_dwTLS;
#endif

//This file is generated from MKTYPLIB on denali.obj
#include "asptlb.h"

// Forward declr
class CHitObj;

/*
 * C S e r v e r D a t a
 *
 * Structure that holds the intrinsic's properties.
 * The instrinsic keeps pointer to it (NULL when lightweight)
 */
class CServerData
    {
public:    
    // Interface to indicate that we support ErrorInfo reporting
	CSupportErrorInfo m_ISupportErrImp;

    // CIsapiReqInfo block for HTTP info
    CIsapiReqInfo *m_pIReq;

    // Back pointer to current HitObj (required for the MapPath)
	CHitObj *m_pHitObj;

	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };

/*
 * C S e r v e r
 *
 * Implements the Server object
 */
class CServer : public IServerImpl, public CFTMImplementation
	{
private:

    // Flags
	DWORD m_fInited : 1;	    // Is initialized?
	DWORD m_fDiagnostics : 1;   // Display ref count in debug output
	DWORD m_fOuterUnknown : 1;  // Ref count outer unknown?

    // Ref count / Outer unknown
    union
    {
    DWORD m_cRefs;
    IUnknown *m_punkOuter;
    };

    // Properties
    CServerData *m_pData;   // pointer to structure that holds
                            // CServer properties
                            
public:
	CServer(IUnknown *punkOuter = NULL);
	~CServer();

    HRESULT Init();
    HRESULT UnInit();
    
    HRESULT ReInit(CIsapiReqInfo *pIReq, CHitObj *pHitObj);

    HRESULT MapPathInternal(DWORD dwContextId, WCHAR *wszVirtPath, 
                            TCHAR *szPhysPath, TCHAR *szVirtPath = NULL);

    // Retrieve HitObj
    inline CHitObj *PHitObj() { return m_pData ? m_pData->m_pHitObj : NULL; }

	//Non-delegating object IUnknown
	STDMETHODIMP		 QueryInterface(REFIID, PPVOID);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

    // GetIDsOfNames special-case implementation
	STDMETHODIMP GetIDsOfNames(REFIID, OLECHAR **, UINT, LCID, DISPID *);

    // Tombstone stub
	HRESULT CheckForTombstone();

	//IServer functions
	STDMETHODIMP CreateObject(BSTR bstr, IDispatch **ppdispObject);
	STDMETHODIMP MapPath(BSTR bstrLogicalPath, BSTR *pbstrPhysicalPath);
	STDMETHODIMP HTMLEncode(BSTR bstrIn, BSTR *pbstrEncoded);
	STDMETHODIMP URLEncode(BSTR bstrIn, BSTR *pbstrEncoded);
	STDMETHODIMP URLPathEncode(BSTR bstrIn, BSTR *pbstrEncoded);
	STDMETHODIMP get_ScriptTimeout(long * plTimeoutSeconds);
	STDMETHODIMP put_ScriptTimeout(long lTimeoutSeconds);		
	STDMETHODIMP Execute(BSTR bstrURL);
	STDMETHODIMP Transfer(BSTR bstrURL);
	STDMETHODIMP GetLastError(IASPError **ppASPErrorObject);

    // Debug support
    
#ifdef DBG
	inline void TurnDiagsOn()  { m_fDiagnostics = TRUE; }
	inline void TurnDiagsOff() { m_fDiagnostics = FALSE; }
	void AssertValid() const;
#else
	inline void TurnDiagsOn()  {}
	inline void TurnDiagsOff() {}
	inline void AssertValid() const {}
#endif

	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };

typedef CServer *PCServer;

#endif //_Server_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\script.h ===
#ifndef SCRIPT_H
#define SCRIPT_H


/***************************************************************************
	Project: VB Script and JavaScript
	Reviewed:
	Copyright (c) Microsoft Corporation

	This defines the public interface to VB Script and JavaScript.

***************************************************************************/

#include "activscp.h"

typedef void *HSCRIPT;	// Handle to a scripting environment instance
typedef void *HENTRY;	// Handle to a script entry point
typedef unsigned long MODID;
const MODID kmodGlobal = 0;

// PFNOUTPUT is used for all output for the script, including compile errors,
// printing (if ScriptAdmin is called to turn on printing), dumping pcode
// (if requested when ScriptAddScript is called), etc.
typedef void  (_stdcall *PFNOUTPUT)(DWORD, LPCOLESTR, BOOL);

enum SAdminEnum
	{
	scadEnableCreateObject = 1, // Only used in VER1
	scadEnablePrint,
	scadEnableTakeOutTrash,     // Only used in JavaScript
	};

STDAPI ScriptBreakThread(DWORD dwThreadID);


inline void FreeExcepInfo(EXCEPINFO *pei)
	{
	if (pei->bstrSource)
		SysFreeString(pei->bstrSource);
	if (pei->bstrDescription)
		SysFreeString(pei->bstrDescription);
	if (pei->bstrHelpFile)
		SysFreeString(pei->bstrHelpFile);
	memset(pei, 0, sizeof(*pei));
	}

struct ScriptException
	{
	IUnknown *punk;
	BSTR bstrUser;		// user data as provided to AddToScript - binary data
	long ichMin;		// character range of error
	long ichLim;
	long line;			// line number of error (zero based)
	long ichMinLine;	// starting char of the line

	BSTR bstrLine;		// source line (if available)
	BOOL fReported;		// been reported via IScriptSite->OnScriptError?

	// must be last
	EXCEPINFO ei;

	void Clear(void)
		{ memset(this, 0, sizeof(*this)); }

	void Free(void)
		{
		FreeExcepInfo(&ei);
		if (NULL != punk)
			punk->Release();
		if (NULL != bstrUser)
			SysFreeString(bstrUser);
		if (NULL != bstrLine)
			SysFreeString(bstrLine);
		memset(this, 0, offsetof(ScriptException, ei));
		}
	};

/***************************************************************************
	The COM Interfaces
***************************************************************************/

enum
	{
	fdexNil = 0x00,
	fdexDontCreate = 0x01,
	fdexInitNull = 0x02,
	fdexCaseSensitive = 0x04,
	fdexLim = 0x80,
	};
const DWORD kgrfdexAll = fdexLim - 1;


// This is the interface for extensible IDispatch objects.
class IDispatchEx : public IDispatch
	{
public:
	// Get dispID for names, with options
	virtual HRESULT STDMETHODCALLTYPE GetIDsOfNamesEx(REFIID riid,
		LPOLESTR *prgpsz, UINT cpsz, LCID lcid, DISPID *prgid, DWORD grfdex) = 0;

	// Enumerate dispIDs and their associated "names".
	// Returns S_FALSE if the enumeration is done, S_OK if it's not, an
	// error code if the call fails.
	virtual HRESULT STDMETHODCALLTYPE GetNextDispID(DISPID id, DISPID *pid,
		BSTR *pbstrName) = 0;
	};


// Interface on owner of an IScript object. To avoid circular refcounts,
// the IScript implementation should not AddRef this interface.
class IScriptSite : public IUnknown
	{
public:
	// IScriptSite Methods

	// NOTE:  OnEnterScript() and OnLeaveScript() will nest, but must be
	// balanced pairs.
	// OnEnterScript() is called before entering the execution loop.
	virtual void STDMETHODCALLTYPE OnEnterScript(void) = 0;
	// OnLeaveScript() is called upon exiting the execution loop.
	virtual void STDMETHODCALLTYPE OnLeaveScript(void) = 0;

	virtual HRESULT STDMETHODCALLTYPE GetActiveScriptSiteWindow(
		IActiveScriptSiteWindow **ppassw) = 0;

	// error feedback - the client should not muck with the sei. We own it.
	virtual HRESULT STDMETHODCALLTYPE OnScriptError(const ScriptException *psei) = 0;

	// LCID support
	virtual LCID STDMETHODCALLTYPE GetUserLcid(void) = 0;

	// call back to get an object for a name
	virtual HRESULT STDMETHODCALLTYPE GetExternObject(long lwCookie, IDispatch ** ppdisp) = 0;

#if SCRIPT_DEBUGGER
	virtual HRESULT STDMETHODCALLTYPE DebugBreakPoint(IUnknown *punk,
		void *pvUser, long cbUser, long ichMin, long ichLim) = 0;
#endif //SCRIPT_DEBUGGER

#if VER2
	virtual DWORD STDMETHODCALLTYPE GetSafetyOptions(void) = 0;
#endif //VER2

	virtual HRESULT STDMETHODCALLTYPE GetInterruptInfo(EXCEPINFO * pexcepinfo) = 0;

	};


enum
	{
	fscrNil = 0x00,
	fscrDumpPcode = 0x01,		// dump pcode to the output function
	fscrPersist = 0x08,			// keep this code on reset
	fscrParseHTMLComments = 0x10,
	fscrReturnExpression = 0x20,// call should return the last expression
	fscrImpliedThis = 0x40,		// 'this.' is optional (for Call)
	fscrDebug = 0x80,			// keep this code around for debugging
	};

#if SCRIPT_DEBUGGER
enum BP_COMMAND
	{
	BPCMD_GET,
	BPCMD_SET,
	BPCMD_CLEAR,
	BPCMD_TOGGLE
	};
#endif //SCRIPT_DEBUGGER

class IScript : public IUnknown
	{
public:
	// IScript methods
	virtual HRESULT STDMETHODCALLTYPE AddToScript(LPCOLESTR pszSrc, MODID mod,
		IUnknown *punk, void *pvData, long cbData, ULONG grfscr,
		HENTRY *phentryGlobal, ScriptException *pse) = 0;
	virtual HRESULT STDMETHODCALLTYPE AddObject(LPCOLESTR pszName,
		IDispatch *pdisp, MODID mod = kmodGlobal, long lwCookie = 0) = 0;
	virtual HRESULT STDMETHODCALLTYPE AddObjectMember(LPCOLESTR pszName,
		IDispatch *pdisp, DISPID dispID, MODID mod = kmodGlobal) = 0;
	virtual HRESULT STDMETHODCALLTYPE GetEntryPoint(LPCOLESTR pszName,
		HENTRY *phentry, MODID mod = kmodGlobal) = 0;
	virtual HRESULT STDMETHODCALLTYPE ReleaseEntryPoint(HENTRY hentry) = 0;

	virtual HRESULT STDMETHODCALLTYPE Call(HENTRY hentry, VARIANT *pvarRes,
		int cvarArgs, VARIANT *prgvarArgs, IDispatch *pdispThis = NULL,
		ScriptException *pse = NULL, DWORD grfscr = fscrNil) = 0;

	virtual HRESULT STDMETHODCALLTYPE Break(void) = 0;
	virtual HRESULT STDMETHODCALLTYPE Admin(SAdminEnum scad, void *pvArg = NULL,
		MODID mod = kmodGlobal) = 0;
	virtual void STDMETHODCALLTYPE SetOutputFunction(PFNOUTPUT pfn,
		DWORD dwOutput) = 0;
	virtual HRESULT STDMETHODCALLTYPE SetDefaultDispatch(MODID mod,
		IDispatch *pdisp) = 0;

	// psite may be NULL
	virtual void STDMETHODCALLTYPE SetScriptSite(IScriptSite *psite) = 0;
#if WIN16
	virtual HRESULT STDMETHODCALLTYPE
        SetActiveScriptSitePoll(IActiveScriptSiteInterruptPoll *pPoll) = 0;
#endif // WIN16

	virtual void STDMETHODCALLTYPE Enter(void) = 0;
	virtual void STDMETHODCALLTYPE Leave(void) = 0;

	// get an IDispatch wrapper for the module
	virtual HRESULT STDMETHODCALLTYPE GetDispatchForModule(MODID mod,
		IDispatch **ppdisp) = 0;

	// Reset/Clone functionality
	virtual HRESULT STDMETHODCALLTYPE Reset(void) = 0;
	virtual HRESULT STDMETHODCALLTYPE Clone(IScript **ppscript) = 0;
	virtual HRESULT STDMETHODCALLTYPE Execute(ScriptException *pse = NULL) = 0;

#if SCRIPT_DEBUGGER
	virtual HRESULT STDMETHODCALLTYPE ToggleBreakPoint(IUnknown *punk, long ich,
		BP_COMMAND bpcmd, long *pichMin, long *pichLim, BOOL *pfSet) = 0;
	virtual HRESULT STDMETHODCALLTYPE SetOneTimeBreakOnEntry(BOOL fSet = TRUE) = 0;
#endif //SCRIPT_DEBUGGER
	virtual HRESULT STDMETHODCALLTYPE GetLineNumber(IUnknown *punk, long ich,
		long *pline, long *pichMinLine, long *pichLimLine) = 0;
	virtual HRESULT STDMETHODCALLTYPE GetUserData(IUnknown *punk, BSTR *pbstr) = 0;

#if SUPPORT_SCRIPT_HELPER
#if DBG
    virtual HRESULT STDMETHODCALLTYPE DumpPCode(void) = 0;
#endif // DBG
#endif // SUPPORT_SCRIPT_HELPER
	};

// helper to create a script object
STDAPI CreateScript(IScript **ppscript, PFNOUTPUT pfn = NULL, DWORD dwOutput = 0);

#endif // SCRIPT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\scrptmgr.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Script Manager

File: ScrptMgr.cpp

Owner: AndrewS

This file contains the implementation of the Scrip Manager,
ie: siting an ActiveX Scripting engine (in our case VBScript) for Denali.

===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "dbgcxt.h"
#include "SMHash.h"
#include "perfdata.h"
#include "debugger.h"
#include "wraptlib.h"

// ATQ Scheduler
#include "issched.hxx"

#include "MemChk.h"

CScriptManager g_ScriptManager;
IWrapTypeLibs *g_pWrapTypelibs = NULL;

#define RESPONSE_END_ERRORCODE ERROR_OPERATION_ABORTED

HRESULT GetProgLangIdOfName(LPCSTR szProgLangName, PROGLANG_ID *pProgLangId);

//*****************************************************************************
// The following macros are used to catch exceptions thrown from the external
// scripting engines.
//
// Use of TRY/CATCH blocks around calls to the script engine is controlled by
// the DBG compile #define.  If DBG is 1, then the TRY/CATCH blocks are NOT
// used so that checked builds break into the debugger and we can examine why
// the error occurred.  If DBG is 0, then the TRY/CATCH blocks are used and
// exceptions are captured and logged to the browser (if possible) and the NT
// Event log.
//
// The TRYCATCH macros are:
//
//  TRYCATCH(_s, _IFStr)
//      _s      - statement to execute inside of TRY/CATCH block.
//      _IFStr  - string containing the name of interface invoked
//  TRYCATCH_HR(_s, _hr, _IFStr)
//      _s      - statement to execute inside of TRY/CATCH block.
//      _hr     - HRESULT to store return from _s
//      _IFStr  - string containing the name of interface invoked
//  TRYCATCH_NOHITOBJ(_s, _IFStr)
//      Same as TRYCATCH() except there is no Hitobj in the "this" object
//  TRYCATCH_HR_NOHITOBJ(_s, _hr, _IFStr)
//      Same as TRYCATCH_HR() except there is no Hitobj in the "this" object
//
//  NOTES:
//  The macros also expect that there is a local variable defined in the function
//  the macros is used of type char * named _pFuncName.
//  
//  A minimal test capability is included to allow for random errors to be throw.
//  The test code is compiled in based on the TEST_TRYCATCH #define.
//
//*****************************************************************************

//*****************************************************************************
// TEST_TRYCATCH definitions
//*****************************************************************************
#define TEST_TRYCATCH 0

#if TEST_TRYCATCH
#define  THROW_INTERVAL 57

int g_TryCatchCount = 0;

#define TEST_THROW_ERROR  g_TryCatchCount++; if ((g_TryCatchCount % THROW_INTERVAL) == 0) {THROW(0x80070000+g_TryCatchCount);}
#else
#define TEST_THROW_ERROR  
#endif

//*****************************************************************************
// The following is the heart of the TRYCATCH macros.  The definitions here are
// based on the definition of DBG.  Again, note that when DBG is off that the
// TRYCATCH defines are removed.
//*****************************************************************************

#if DBG == 0

#define START_TRYCATCH do { TRY
#define END_TRYCATCH(_hr, _hitobj, _IFStr) \
    CATCH(nException) \
        HandleErrorMissingFilename(IDE_SCRIPT_ENGINE_GPF, _hitobj,TRUE,nException,_IFStr,_pFuncName); \
        _hr = nException; \
    END_TRY } while(0)
#else
#define START_TRYCATCH do {
#define END_TRYCATCH(_hr, _hitobj, _IFStr) } while (0)
#endif

//*****************************************************************************
// Definition of TRYCATCH_INT which is used by all of the TRYCATCH macros
// described above.
//*****************************************************************************

#define TRYCATCH_INT(_s, _hr, _hitobj, _IFStr) \
    START_TRYCATCH \
    TEST_THROW_ERROR \
    _hr = _s; \
    END_TRYCATCH(_hr, _hitobj, _IFStr)

//*****************************************************************************
// Here are the actual definitions of the TRYCATCH macros described above.
//*****************************************************************************

#define TRYCATCH(_s, _IFStr) \
    do { \
        HRESULT     _tempHR; \
        TRYCATCH_INT(_s, _tempHR, m_pHitObj, _IFStr); \
    } while (0)
#define TRYCATCH_HR(_s, _hr, _IFStr) TRYCATCH_INT(_s, _hr, m_pHitObj, _IFStr)
#define TRYCATCH_NOHITOBJ(_s, _IFStr) \
    do { \
        HRESULT     _tempHR; \
        TRYCATCH_INT(_s, _tempHR, NULL, _IFStr); \
    } while (0)
#define TRYCATCH_HR_NOHITOBJ(_s, _hr, _IFStr) TRYCATCH_INT(_s, _hr, NULL, _IFStr)

/*===================================================================
CActiveScriptEngine::CActiveScriptEngine

Constructor for CActiveScriptEngine object

Returns:
	Nothing

Side effects:
	None.
===================================================================*/
CActiveScriptEngine::CActiveScriptEngine()
	: m_cRef(1), m_fInited(FALSE), m_fZombie(FALSE), m_fScriptLoaded(FALSE), 
	  m_fObjectsLoaded(FALSE), m_fTemplateNameAllocated(FALSE),
	  m_pAS(NULL), m_pASP(NULL), m_pDisp(NULL), m_pHIUpdate(NULL), m_lcid(LOCALE_SYSTEM_DEFAULT),
	  m_pHitObj(NULL), m_szTemplateName(NULL), m_fScriptAborted(FALSE), m_fScriptTimedOut(FALSE), 
	  m_fScriptHadError(FALSE), m_fCorrupted(FALSE), m_fBeingDebugged(FALSE), m_pTemplate(NULL),
	  m_dwInstanceID(0xBADF00D), m_dwSourceContext(0xBADF00D)
	{
	}

/*===================================================================
CActiveScriptEngine::~CActiveScriptEngine

Destructor for CActiveScriptEngine object

Returns:
	Nothing

Side effects:
	None.
===================================================================*/
CActiveScriptEngine::~CActiveScriptEngine()
	{

	if (m_fTemplateNameAllocated)
    	delete[] m_szTemplateName;

	if (m_pTemplate)
		m_pTemplate->Release();
	}

/*===================================================================
CActiveScriptEngine::FinalRelease

Call this when we are done with the object - Like release but
it removes all of the interfaces we got, so that the ref.
count can vanish when last external user is done with the engine

Returns:
	Nothing

Side effects:
	None.
===================================================================*/
ULONG CActiveScriptEngine::FinalRelease()
	{
    static const char *_pFuncName = "CActiveScriptEngine::FinalRelease()";

	if (m_pDisp)
		{
		TRYCATCH(m_pDisp->Release(),"IScriptDispatch::Release()");
		m_pDisp = NULL;
		}

	if (m_pASP)
		{
		TRYCATCH(m_pASP->Release(),"IActiveScriptParse::Release()");
		m_pASP = NULL;
		}

	if (m_pHIUpdate)
		{
		TRYCATCH(m_pHIUpdate->Release(),"IHostInfoUpdate::Release()");
		m_pHIUpdate = NULL;
		}

	if (m_pAS)
		{
		HRESULT hr;
		
		// First "close" the engine
		TRYCATCH_HR(m_pAS->Close(), hr, "IActiveScript::Close()");
		Assert(SUCCEEDED(hr));

		// Then we can release it
		TRYCATCH(m_pAS->Release(), "IActiveScript::Release()");

		m_pAS = NULL;
		}

	ULONG cRefs = Release();
	Assert (cRefs == 0);
	return cRefs;
	}

/*===================================================================
CActiveScriptEngine::Init

Init the script site object.  This must only be called once.

Returns:
	HRESULT.  S_OK on success.

Side effects:
	None.
===================================================================*/
HRESULT CActiveScriptEngine::Init
(
PROGLANG_ID proglang_id,
LPCTSTR szTemplateName,
LCID lcid,
CHitObj *pHitObj,
CTemplate *pTemplate,
DWORD dwSourceContext
)
	{
    static const char *_pFuncName = "CActiveScriptEngine::Init()";
	HRESULT hr;
	UINT cTrys = 0;
	
	if (m_fInited)
		{
		Assert(FALSE);
		return(ERROR_ALREADY_INITIALIZED);
		}

	// Note: need to init these first, because we will need them if AS calls back into us during init.
	m_lcid = lcid;
	m_proglang_id = proglang_id;
	m_pHitObj = pHitObj;
	m_dwSourceContext = dwSourceContext;
	m_dwInstanceID = pHitObj->DWInstanceID();
	m_pTemplate = pTemplate;
	m_pTemplate->AddRef();

lRetry:
	// Create an instance of the script engine for the given language
	hr = CoCreateInstance(proglang_id, NULL, CLSCTX_INPROC_SERVER, IID_IActiveScript, (void**)&m_pAS);
	if (FAILED(hr))
		{
		/*
		 * If some control (or other component) does a CoUninitialize on our thread, we will
		 * never be able to create another object.  In this case, we will get back CO_E_NOTINITIALIZED.
		 * Try (once) to re-initialize and then create the object
		 */
		if (hr == CO_E_NOTINITIALIZED && cTrys++ == 0)
			{
			MSG_Error(IDS_COUNINITIALIZE);
			hr = CoInitialize(NULL);
            if (SUCCEEDED(hr))
			    goto lRetry;
			}
		goto LFail;
		}

    // Remember template name
    hr = StoreTemplateName(szTemplateName);
	if (FAILED(hr))
		goto LFail;
    
	// Tell ActiveScripting that this is our script site
    TRYCATCH_HR(m_pAS->SetScriptSite((IActiveScriptSite *)this), hr, "IActiveScript::SetScriptSite()");
	if (FAILED(hr))
		{
		goto LFail;
		}

	// Tell ActiveScripting which exceptions we want caught
	IActiveScriptProperty *pScriptProperty;
    TRYCATCH_HR(m_pAS->QueryInterface(IID_IActiveScriptProperty, reinterpret_cast<void **>(&pScriptProperty)), hr, "IActiveScript::QueryInterface()");
    if (SUCCEEDED(hr))
    	{
    	static const int rgnExceptionsToCatch[] =
							{
							STATUS_GUARD_PAGE_VIOLATION      ,
							STATUS_DATATYPE_MISALIGNMENT     ,
							STATUS_ACCESS_VIOLATION          ,
							STATUS_INVALID_HANDLE            ,
							STATUS_NO_MEMORY                 ,
							STATUS_ILLEGAL_INSTRUCTION       ,
							STATUS_INVALID_DISPOSITION       , // what's this?  Do we need to catch it?
							STATUS_ARRAY_BOUNDS_EXCEEDED     ,
							STATUS_FLOAT_DENORMAL_OPERAND    ,
							STATUS_FLOAT_DIVIDE_BY_ZERO      ,
							STATUS_FLOAT_INVALID_OPERATION   ,
							STATUS_FLOAT_OVERFLOW            ,
							STATUS_FLOAT_STACK_CHECK         ,
							STATUS_INTEGER_DIVIDE_BY_ZERO    ,
							STATUS_INTEGER_OVERFLOW          ,
							STATUS_PRIVILEGED_INSTRUCTION    ,
							STATUS_STACK_OVERFLOW
							};

    	VARIANT varBoolTrue;
    	VARIANT varExceptionType;

    	V_VT(&varExceptionType) = VT_I4;
    	V_VT(&varBoolTrue) = VT_BOOL;
    	V_BOOL(&varBoolTrue) = -1;

		for (int i = 0; i < (sizeof rgnExceptionsToCatch) / sizeof(int); ++i)
			{
			V_I4(&varExceptionType) = rgnExceptionsToCatch[i];
			TRYCATCH(pScriptProperty->SetProperty(SCRIPTPROP_CATCHEXCEPTION, &varExceptionType, &varBoolTrue), "IActiveScriptProperty::SetProperty");
			}

		pScriptProperty->Release();
		}

	// Get ActiveScriptParse interface
	hr = GetASP();
	if (FAILED(hr))
		goto LFail;

	// Tell the script parser to init itself
    TRYCATCH_HR(m_pASP->InitNew(), hr, "IActiveScriptParse::InitNew()");
	if (FAILED(hr))
		goto LFail;

	// Get IDisp interface
	hr = GetIDisp();
	if (FAILED(hr))
		goto LFail;

	// Get IHostInfoUpdate interface
	hr = GetIHostInfoUpdate();
	if (FAILED(hr))
		goto LFail;

	m_fInited = TRUE;

LFail:
	if (FAILED(hr))
		{
		if (m_pAS)
			{
			TRYCATCH(m_pAS->Release(),"IActiveScript::Release()");
			m_pAS = NULL;
			}
		if (m_pASP)
			{
            TRYCATCH(m_pASP->Release(),"IActiveScriptParse::Release()");
			m_pASP = NULL;
			}
		if (m_pDisp)
			{
			TRYCATCH(m_pDisp->Release(),"IScriptDispatch::Release()");
			m_pDisp = NULL;
			}
		if (m_pTemplate)
			{
			m_pTemplate->Release();
			m_pTemplate = NULL;
			}
		if (m_pHIUpdate)
		    {
		    TRYCATCH(m_pHIUpdate->Release(),"IHostInfoUpdate::Release()");
		    m_pHIUpdate = NULL;
		    }
		}

	return(hr);
	}

/*===================================================================
CActiveScriptEngine::StoreTemplateName

Stores template name inside CActiveScriptEngine. Allocates
buffer or uses internal one if the name fits.

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Might allocate memory for long template names
===================================================================*/
HRESULT CActiveScriptEngine::StoreTemplateName
(
LPCTSTR szTemplateName
)
    {
    DWORD cch = _tcslen(szTemplateName);

    if (((cch+1)*sizeof(TCHAR)) <= sizeof(m_szTemplateNameBuf))
        {
        m_szTemplateName = m_szTemplateNameBuf;
        m_fTemplateNameAllocated = FALSE;
        }
    else
        {
    	m_szTemplateName = new TCHAR[cch+1];
    	if (!m_szTemplateName)
            return E_OUTOFMEMORY;
        m_fTemplateNameAllocated = TRUE;
        }
        
	_tcscpy(m_szTemplateName, szTemplateName);
    return S_OK;
    }

/*===================================================================
CActiveScriptEngine::GetASP

Get an ActiveScriptParser interface from ActiveScripting

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Fills in member variables
===================================================================*/
HRESULT CActiveScriptEngine::GetASP
(
)
	{
    static const char *_pFuncName = "CActiveScriptEngine::GetASP()";
	HRESULT hr;

	Assert(m_pASP == NULL);
	
	m_pASP = NULL;
			
	// Get OLE Scripting parser interface, if any
    TRYCATCH_HR(m_pAS->QueryInterface(IID_IActiveScriptParse, (void **)&m_pASP), hr, "IActiveScript::QueryInterface()");

	if (m_pASP == NULL && SUCCEEDED(hr))
		hr = E_FAIL;
	if (FAILED(hr))
		{
		goto LFail;
		}

LFail:
	if (FAILED(hr))
		{
		if (m_pASP)
			{
            TRYCATCH(m_pASP->Release(),"IActiveScriptParse::Release()");
			m_pASP = NULL;
			}
		}

	return(hr);
	}

/*===================================================================
CActiveScriptEngine::GetIDisp

Get an IDispatch interface from ActiveScripting

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Fills in member variables
===================================================================*/
HRESULT CActiveScriptEngine::GetIDisp
(
)
	{
    static const char *_pFuncName = "CActiveScriptEngine::GetIDisp()";

	HRESULT hr;

	Assert(m_pDisp == NULL);
	
	m_pDisp = NULL;
			
	// Get an IDispatch interface to be able to call functions in the script
    
    TRYCATCH_HR(m_pAS->GetScriptDispatch(NULL, &m_pDisp),hr,"IActiveScript::GetScriptDispatch()");

	if (m_pDisp == NULL && SUCCEEDED(hr))
		hr = E_FAIL;
	if (FAILED(hr))
		{
		goto LFail;
		}

LFail:
	if (FAILED(hr))
		{
		if (m_pDisp)
			{
			TRYCATCH(m_pDisp->Release(),"IScriptDispatch::Release()");
			m_pDisp = NULL;
			}
		}

	return(hr);
	}

/*===================================================================
CActiveScriptEngine::GetIHostInfoUpdate

Get an IHostInfoUpdate interface from ActiveScripting.
This interface is used to advise the scripting engine that
we have new information about the host (change in LCID for example)
If we can't find the interface, we exit succesfully anyway.

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Fills in member variables
===================================================================*/
HRESULT CActiveScriptEngine::GetIHostInfoUpdate
(
)
	{
    static const char *_pFuncName = "CActiveScriptEngine::GetIHostInfoUpdate()";
	HRESULT hr = S_OK;

	Assert(m_pHIUpdate == NULL);
	m_pHIUpdate = NULL;
			
	// Get an IHostInfoUpdate interface to be able to call functions in the script
    TRYCATCH_HR(m_pAS->QueryInterface(IID_IHostInfoUpdate, (void **) &m_pHIUpdate),
                hr,
                "IActiveScript::QueryInterface()");

	Assert(SUCCEEDED(hr) || hr == E_NOINTERFACE);

	return(S_OK);
	}

/*===================================================================
CActiveScriptEngine::ResetToUninitialized

When we want to reuse and engine, we reset it to an uninited state
before putting it on the FSQ

Returns:
	HRESULT.  S_OK on success.

Side effects:
	None.
===================================================================*/
HRESULT CActiveScriptEngine::ResetToUninitialized()
{
    static const char *_pFuncName = "CActiveScriptEngine::ResetToUninitialized()";
	HRESULT hr = S_OK;
	
	// Reset our flags
	m_fScriptAborted = FALSE;
	m_fScriptTimedOut = FALSE;
	m_fScriptHadError = FALSE;
	m_fBeingDebugged = FALSE;

	// Release interfaces, they will need to be re-gotten when
	// the engine is reused
	if (m_pASP) {
        TRYCATCH(m_pASP->Release(),"IActiveScriptParse::Release()");
		m_pASP = NULL;
    }

	if (m_pDisp) {
		TRYCATCH(m_pDisp->Release(),"IScriptDispatch::Release()");
		m_pDisp = NULL;
    }

	if(m_pHIUpdate) {
		TRYCATCH(m_pHIUpdate->Release(),"IHostInfoUpdate::Release()");
		m_pHIUpdate = NULL;
    }

	// Hitobj will no longer be valid
	m_pHitObj = NULL;

	// Set the script state to Uninited
	if (m_pAS) {
        TRYCATCH_HR(ResetScript(), hr, "IActiveScript::SetScriptState()");
    }

	return(hr);
}

/*===================================================================
CActiveScriptEngine::ReuseEngine

Reusing an engine from the FSQ.  Reset stuff

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Sets member variables.
===================================================================*/
HRESULT CActiveScriptEngine::ReuseEngine
(
CHitObj *pHitObj,
CTemplate *pTemplate,
DWORD dwSourceContext,
DWORD dwInstanceID
)
	{
    static const char *_pFuncName = "CActiveScriptEngine::ReuseEngine()";
	HRESULT hr = S_OK;

	/* NOTE: we must reset the hitobj & other members BEFORE calling
	 * any Active Scripting methods (esp. SetScriptSite)  This is
	 * because SetScriptSite queries us for the debug application, which
	 * relies on the hitobj being set.
	 */

	// reset the hitobj
	m_pHitObj = pHitObj;

	// Reset the debug document
	if (pTemplate)
		{
		if (m_pTemplate)
			m_pTemplate->Release();

		m_dwSourceContext = dwSourceContext;
		m_dwInstanceID = dwInstanceID;
		m_pTemplate = pTemplate;
		m_pTemplate->AddRef();
		}

	// If the engine is in the UNITIALIZED state ONLY then tell ActiveScripting
	// that this is our script site.  (Scripts in the debug cache are already initialized)
	SCRIPTSTATE nScriptState;
    TRYCATCH_HR(m_pAS->GetScriptState(&nScriptState), hr, "IActiveScript::GetScriptState()");
	if (FAILED(hr))
		goto LFail;

	if (nScriptState == SCRIPTSTATE_UNINITIALIZED)
		{
        TRYCATCH_HR(m_pAS->SetScriptSite(static_cast<IActiveScriptSite *>(this)),hr, "IActiveScript::SetScriptState()");
		if (FAILED(hr))
			goto LFail;
		}

	// Get ActiveScriptParse interface
	hr = GetASP();
	if (FAILED(hr))
		goto LFail;

	// Get IDisp interface
	hr = GetIDisp();
	if (FAILED(hr))
		goto LFail;

	// Get IHostInfoUpdate interface
	hr = GetIHostInfoUpdate();
	if (FAILED(hr))
		goto LFail;

	AssertValid();
LFail:
	return(hr);
	}

/*===================================================================
CActiveScriptEngine::MakeClone

We are cloning a running script engine.  Fill this new ActiveScriptEngine
with the cloned ActiveScript.

Returns:
	HRESULT.  S_OK on success.

Side effects:
	None.
===================================================================*/
HRESULT CActiveScriptEngine::MakeClone
(
PROGLANG_ID proglang_id,
LPCTSTR szTemplateName,
LCID lcid,
CHitObj *pHitObj,
CTemplate *pTemplate,
DWORD dwSourceContext,
DWORD dwInstanceID,
IActiveScript *pAS			// The cloned script engine
)
	{
    static const char *_pFuncName = "CActiveScriptEngine::MakeClone()";
	HRESULT hr;
	
	if (m_fInited)
		{
		Assert(FALSE);
		return(ERROR_ALREADY_INITIALIZED);
		}

	// Note: need to init these first, because we will need them if AS calls back into us during init.
	m_lcid = lcid;
	m_proglang_id = proglang_id;
	m_pHitObj = pHitObj;

	m_pAS = pAS;

	StoreTemplateName(szTemplateName);

	if (m_pTemplate)
		m_pTemplate->Release();

	m_dwSourceContext = dwSourceContext;
	m_dwInstanceID = dwInstanceID;
	m_pTemplate = pTemplate;
	m_pTemplate->AddRef();

	// We are not yet inited fully but SetScriptSite may call back into us so we must flag inited now.
	m_fInited = TRUE;

	// Tell ActiveScripting that this is our script site
    TRYCATCH_HR(m_pAS->SetScriptSite((IActiveScriptSite *)this), hr, "IActiveScript::SetScriptSite()");

	if (FAILED(hr))
		{
		goto LFail;
		}

	// Get ActiveScriptParse interface
	hr = GetASP();
	if (FAILED(hr))
		goto LFail;

	// Get IDisp interface
	hr = GetIDisp();
	if (FAILED(hr))
		goto LFail;

	// Get IHostInfoUpdate interface
	hr = GetIHostInfoUpdate();
	if (FAILED(hr))
		goto LFail;

	// Because we are a clone of an already loaded engine, we have script and objects loaded.
	m_fScriptLoaded = TRUE;
	m_fObjectsLoaded = TRUE;

	// We should be valid now.
	AssertValid();
	
LFail:
	if (FAILED(hr))
		{
		m_fInited = FALSE;
		
		if (m_pAS)
			{
			// dont release the passed in script engine on failure
			m_pAS = NULL;
			}
		if (m_pASP)
			{
			TRYCATCH(m_pASP->Release(),"IActiveScriptParse::Release()");
			m_pASP = NULL;
			}
		if (m_pDisp)
			{
			TRYCATCH(m_pDisp->Release(),"IScriptDispatch::Release()");
			m_pDisp = NULL;
			}
		if (m_pTemplate)
			{
			m_pTemplate->Release();
			m_pTemplate = NULL;
			}
		if (m_pHIUpdate)
		    {
		    TRYCATCH(m_pHIUpdate->Release(),"IHostInfoUpdate::Release()");
		    m_pHIUpdate = NULL;
		    }
		}

	return(hr);
	}

/*===================================================================
CActiveScriptEngine::InterruptScript

Stop the script from running

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Stops the script from running
===================================================================*/
HRESULT CActiveScriptEngine::InterruptScript
(
BOOL fAbnormal				// = TRUE
)
	{
    static const char *_pFuncName = "CActiveScriptEngine::InterruptScript()";
	HRESULT hr;
	EXCEPINFO excepinfo;

	AssertValid();

	// Fill in the excepinfo.  This will be passed to OnScriptError
	memset(&excepinfo, 0x0, sizeof(EXCEPINFO));
	if (fAbnormal)
		{
		m_fScriptTimedOut = TRUE;
		excepinfo.wCode = ERROR_SERVICE_REQUEST_TIMEOUT;
		}
	else
		{
		m_fScriptAborted = TRUE;
		excepinfo.wCode = RESPONSE_END_ERRORCODE;		// Error code to ourselves - means Response.End was invoked
		}
	
        TRYCATCH_HR(m_pAS->InterruptScriptThread(SCRIPTTHREADID_BASE,		// The thread in which the engine was instantiated
		           						  &excepinfo,
								          0),
                    hr,
                    "IActiveScript::InterruptScriptThread()");
	return(hr);
	}

/*===================================================================
CActiveScriptEngine::UpdateLocaleInfo

Advise the script engine that we want to update the lcid or
code page

Returns:
	HRESULT.  S_OK on success.
===================================================================*/
HRESULT CActiveScriptEngine::UpdateLocaleInfo
(
hostinfo hiNew
)
	{
    static const char *_pFuncName = "CActiveScriptEngine::UpdateLocaleInfo()";
	HRESULT hr = S_OK;
	
	// If no IUpdateHost ineterface is available 
	// just skip the call to UpdateInfo;
	if (m_pHIUpdate)
		TRYCATCH_HR(m_pHIUpdate->UpdateInfo(hiNew), hr, "IHostInfoUpdate::UpdateInfo()");

	return hr;
	}

#ifdef DBG
/*===================================================================
CActiveScriptEngine::AssertValid

Test to make sure that the CActiveScriptEngine object is currently correctly formed
and assert if it is not.

Returns:

Side effects:
	None.
===================================================================*/
VOID CActiveScriptEngine::AssertValid() const
	{
	Assert(m_fInited);
	Assert(m_pAS != NULL);
	Assert(m_pTemplate != NULL);
	}
#endif // DBG

/*
 *
 *
 *
 * I U n k n o w n   M e t h o d s
 *
 *
 *
 *
 */ 

/*===================================================================
CActiveScriptEngine::QueryInterface
CActiveScriptEngine::AddRef
CActiveScriptEngine::Release

IUnknown members for CActiveScriptEngine object.
===================================================================*/
STDMETHODIMP CActiveScriptEngine::QueryInterface
(
REFIID riid,
PVOID *ppvObj
)
	{
	if (ppvObj == NULL)
		{
		Assert(FALSE);
		return E_POINTER;
		} 

	*ppvObj = NULL;

	if (IsEqualIID(riid, IID_IUnknown))
	    {
	    // this IS NOT derived directly from IUnknown
	    // typecast this to something that IS
		*ppvObj = static_cast<IActiveScriptSite *>(this);
        }
	else if (IsEqualIID(riid, IID_IActiveScriptSite))
	    {
		*ppvObj = static_cast<IActiveScriptSite *>(this);
        }
	else if (IsEqualIID(riid, IID_IActiveScriptSiteDebug))
	    {
		*ppvObj = static_cast<IActiveScriptSiteDebug *>(this);
        }
	else if (IsEqualIID(riid, IID_IHostInfoProvider))
	    {
		*ppvObj = static_cast<IHostInfoProvider *>(this);
        }
        
	if (*ppvObj != NULL)
		{
		AddRef();
		return(S_OK);
		}
	
	return(E_NOINTERFACE);
	}

STDMETHODIMP_(ULONG) CActiveScriptEngine::AddRef()
	{
	++m_cRef;

	return(m_cRef);
	}

STDMETHODIMP_(ULONG) CActiveScriptEngine::Release()
	{
	if (--m_cRef)
		return(m_cRef);

	delete this;
	return(0);
	}

/*
 *
 *
 *
 * I A c t i v e S c r i p t S i t e   M e t h o d s
 *
 *
 *
 *
 */ 

/*===================================================================
CActiveScriptEngine::GetLCID

Provide the local id for the script to the script engine.

Returns:
	HRESULT.  Always returns S_OK.

Side effects:
	None.
===================================================================*/
STDMETHODIMP CActiveScriptEngine::GetLCID
(
LCID *plcid
)
	{
	// It is OK to call this before we are fully inited.
	//AssertValid();

	*plcid = ((CActiveScriptEngine *)this)->m_lcid;
	
	return(S_OK);
	}

/*===================================================================
CActiveScriptEngine::GetItemInfo

Provide requested info for a named item to the script engine.  May be
asked for IUnknown, ITypeInfo or both.

Returns:
	HRESULT.  S_OK on success.

Side effects:
	None.
===================================================================*/
STDMETHODIMP CActiveScriptEngine::GetItemInfo
(
LPCOLESTR pcszName,
DWORD dwReturnMask,IUnknown **ppiunkItem,
ITypeInfo **ppti
)
	{
	HRESULT hr;
	AssertValid();
	
	// Assume none
	if (ppti)
		*ppti = NULL;
	if (ppiunkItem)
		*ppiunkItem = NULL;

    CHitObj *pHitObj = m_pHitObj;
    if (pHitObj == NULL)
        {
        // could happen when debugging and re-initializing
        // the scripting engine when storing it in the template
        // in this case GetItemInfo() is called for TYPELIB stuff
        ViperGetHitObjFromContext(&pHitObj);
    	if (pHitObj == NULL)
	        return TYPE_E_ELEMENTNOTFOUND;
        }

    // Calculate name length once
    
    DWORD cbName = CbWStr((LPWSTR)pcszName);
    
	// Special case for intrinsics
	
	IUnknown *punkIntrinsic = NULL;
	hr = pHitObj->GetIntrinsic((LPWSTR)pcszName, cbName, &punkIntrinsic);
	
	if (hr == S_OK)
	    {
    	if (dwReturnMask & SCRIPTINFO_IUNKNOWN)
	    	{
    		Assert(ppiunkItem);
    		Assert(punkIntrinsic);
    		punkIntrinsic->AddRef();
    		*ppiunkItem = punkIntrinsic;
		    }
		return S_OK;
	    }
	else if (hr == S_FALSE)
	    {
	    // Missing intrinsic case
	    return TYPE_E_ELEMENTNOTFOUND;
	    }

	// It's not an intrinsic -- try component collection
	
	CComponentObject *pObj = NULL;
	hr = pHitObj->GetComponent(csUnknown, (LPWSTR)pcszName, cbName, &pObj);

	if (hr == S_OK) // object found
	    {
    	if (dwReturnMask & SCRIPTINFO_IUNKNOWN)
	    	{
    		Assert(ppiunkItem != NULL);
	    	hr = pObj->GetAddRefdIUnknown(ppiunkItem);
		    }

		if (SUCCEEDED(hr))
		    return S_OK;
	    }

	// Could'n find -- output an error

	HandleItemNotFound(pcszName);
    	
	return hr;
	}

/*===================================================================
CActiveScriptEngine::HandleItemNotFound

Error handling due to item not found in GetItemInfo().

Parameters:
    pcszName        name of the item not found

Returns:
===================================================================*/
void CActiveScriptEngine::HandleItemNotFound
(
LPCOLESTR pcszName
)
    {
    HRESULT         hr = TYPE_E_ELEMENTNOTFOUND;
    
	CHAR 	        *szErrT		= NULL;
	CHAR	        szEngineT[255];
	CHAR	        szErr[255];
	TCHAR	        *szFileNameT = NULL;
    CHAR            *szFileName = NULL;
	CHAR 	        *szLineNum  = NULL;
	CHAR	        *szEngine	= NULL;
	CHAR	        *szErrCode	= NULL;
	CHAR	        *szLongDes	= NULL;
	ULONG 	        ulLineError = 0;
	DWORD	        dwMask = 0x3;
	BOOLB	        fGuessedLine = FALSE;
	UINT	        ErrId = IDE_OOM;
    CWCharToMBCS    convName;

	m_pTemplate->GetScriptSourceInfo(m_dwSourceContext, ulLineError, &szFileNameT, NULL, &ulLineError, NULL, &fGuessedLine);
	//Make a copy for error handling
#if UNICODE
	szFileName = StringDupUTF8(szFileNameT);
#else
    szFileName = StringDupA(szFileNameT);
#endif

	//get line num
	if (ulLineError)
		{
		szLineNum = (CHAR *)malloc(sizeof(CHAR)*10);
		if (szLineNum)
			_ltoa(ulLineError, szLineNum, 10);
		else
			{
			hr = E_OUTOFMEMORY;
			goto lCleanUp;
			}
		}
	//get engine
	CchLoadStringOfId(IDS_ENGINE, szEngineT, 255);
	szEngine = StringDupA(szEngineT);

	//get informative string

    if (FAILED(hr = convName.Init((LPWSTR)pcszName))) {
        goto lCleanUp;
    }
		
	// Error string is: "Failed to create object 'objname'.  Error code (code)."
	ErrId = IDE_SCRIPT_CANT_LOAD_OBJ;
	LoadErrResString(ErrId, &dwMask, NULL, NULL, szErr);
	if (szErr)
		{
		INT	cch = strlen(szErr);
		szErrT = (CHAR *)malloc((CHAR)(cch + strlen(convName.GetString()) + 1));
		if (!szErrT)
			{
			hr = E_OUTOFMEMORY;
			goto lCleanUp;
			}

		sprintf(szErrT, szErr, convName.GetString());
		szErrCode = SzScodeToErrorCode(hr);
		}
		
lCleanUp:		
	
	//szErrT is the long description		
	HandleError(ErrId, szFileName, szLineNum, szEngine, szErrCode, szErrT, NULL, m_pHitObj);
    }

/*===================================================================
CActiveScriptEngine::GetDocVersionString

Return a string uniquely identifying the current document version
from Denali's point of view.

I dont think we need this. It is mostly interesting if
the scripting engine is persisting scripts so that it can decide
if a script needs a recompile.  Since the scripting engine is
not persisting anything for us, we dont need to do anything here.

Returns:
	HRESULT.  Always returns E_NOTIMPL.

Side effects:
	None.
===================================================================*/
STDMETHODIMP CActiveScriptEngine::GetDocVersionString
(
BSTR *pbstrVersion
)
	{
	return(E_NOTIMPL);
	}

/*===================================================================
CActiveScriptEngine::RequestItems

If this is called, it means that the Script engine wants us to call
IActiveScript::AddNameItem() for each named item associated with the 
script.

Returns:
	HRESULT.  Always returns S_OK.

Side effects:
	None.
===================================================================*/
STDMETHODIMP CActiveScriptEngine::RequestItems
(
BOOL fPersistNames			// = TRUE
)
	{
    static const char *_pFuncName = "CActiveScriptEngine::RequestItems()";
	HRESULT hr = S_OK;

	AssertValid();
	Assert (m_pHitObj != NULL);

	DWORD grf = SCRIPTITEM_ISVISIBLE;
	if (fPersistNames)
		grf |= SCRIPTITEM_ISPERSISTENT;

	/*
	 * Intrinsics
	 */

    START_TRYCATCH

	if (m_pHitObj->FIsBrowserRequest())
	    {
        hr = m_pAS->AddNamedItem(WSZ_OBJ_RESPONSE, grf);
        Assert(SUCCEEDED(hr));

        hr = m_pAS->AddNamedItem(WSZ_OBJ_REQUEST, grf);
        Assert(SUCCEEDED(hr));
        }
	
    hr = m_pAS->AddNamedItem(WSZ_OBJ_SERVER, grf);
	Assert(SUCCEEDED(hr));

	if (m_pHitObj->FHasSession())
	    {
        hr = m_pAS->AddNamedItem(WSZ_OBJ_SESSION, grf);
	    Assert(SUCCEEDED(hr));
	    }

    hr = m_pAS->AddNamedItem(WSZ_OBJ_APPLICATION, grf);
	Assert(SUCCEEDED(hr));
	
    hr = m_pAS->AddNamedItem(WSZ_OBJ_OBJECTCONTEXT, grf);
	Assert(SUCCEEDED(hr));

	/*
	 * Components from different collections
	 */

	CComponentIterator CompIter(m_pHitObj);
    LPWSTR strObjName;
        
    while (strObjName = CompIter.WStrNextComponentName())
        {
   		hr = m_pAS->AddNamedItem(strObjName, grf);
        if (FAILED(hr))
   			break;
        }
	
	Assert(SUCCEEDED(hr));

	/*
	 * Type library wrappers. (Has to be last in order to be called
	 * only when everything else fails.
	 */

	// Special flag value for typelib wrappers
	grf |= SCRIPTITEM_GLOBALMEMBERS;

	if (m_pHitObj->PTypeLibWrapper())
	    {
        hr = m_pAS->AddNamedItem(WSZ_OBJ_ASPPAGETLB, grf);
    	Assert(SUCCEEDED(hr));
	    }

    // GLOBAL.ASA typelib wrapper is added always
    // because each page does not pick up changes to
    // GLOBAL.ASA and there's no way to figure out
    // when TYPELIBs get added to GLOBAL.ASA
    hr = m_pAS->AddNamedItem(WSZ_OBJ_ASPGLOBALTLB, grf);
  	Assert(SUCCEEDED(hr));

    END_TRYCATCH(hr, m_pHitObj, "IActiveScript::AddNamedItem");

	// We are required to return OK
	return(S_OK);
	}

/*===================================================================
CActiveScriptEngine::RequestTypeLibs 

If this is called, it means that the Script engine wants us to call
IActiveScript::AddTypeLib() for each typelib associated with the 
script.  It is unclear to me that this will ever be called in our case.

Returns:
	HRESULT.  Always returns S_OK.

Side effects:
	None.
===================================================================*/
STDMETHODIMP CActiveScriptEngine::RequestTypeLibs()
	{
	AssertValid();

	// We have no typelibs for the namespace	
	
	return(S_OK);
	}

/*===================================================================
CActiveScriptEngine::OnEnterScript

Host callback to indicate that the script has started executing

Returns:
	HRESULT.  Always returns S_OK.

Side effects:
	None.
===================================================================*/
STDMETHODIMP CActiveScriptEngine::OnEnterScript()
	{
	return(S_OK);
	}

/*===================================================================
CActiveScriptEngine::OnLeaveScript

Host callback to indicate that the script has stopped executing

Returns:
	HRESULT.  Always returns S_OK.

Side effects:
	None.
===================================================================*/
STDMETHODIMP CActiveScriptEngine::OnLeaveScript()
	{
	return(S_OK);
	}

/*===================================================================
CActiveScriptEngine::GetHostInfo

Host callback to for furnishing LCID and code page info

Returns:
	HRESULT.  Always returns S_OK.

Side effects:
	None.
===================================================================*/
STDMETHODIMP CActiveScriptEngine::GetHostInfo(hostinfo hostinfoRequest, void **ppvInfo)
	{

	Assert(hostinfoRequest == hostinfoLocale || hostinfoRequest == hostinfoCodePage);

	HRESULT hr = S_OK;
	
	if (hostinfoRequest == hostinfoLocale)
		{
		// Allocate an LCID and set it to the current
		// value for the HitObj
		*ppvInfo = CoTaskMemAlloc(sizeof(UINT));
		if (!*ppvInfo)
			hr = E_OUTOFMEMORY;
		else
			(*(UINT *)*ppvInfo) = m_pHitObj->GetLCID();
		}
	else if (hostinfoRequest == hostinfoCodePage)
		{
		// Allocate an code page and set it to the current
		// value for the HitObj
		*ppvInfo = CoTaskMemAlloc(sizeof(UINT));
		if (!*ppvInfo)
			hr = E_OUTOFMEMORY;
		else
			(*(UINT *)*ppvInfo) = m_pHitObj->GetCodePage();
		}
	else
		hr = E_FAIL;
		
	return(hr);
	}

/*===================================================================
CActiveScriptEngine::OnScriptTerminate

Host callback to indicate that the script has completed.

Returns:
	HRESULT.  Always returns S_OK.

Side effects:
	None.
===================================================================*/
STDMETHODIMP CActiveScriptEngine::OnScriptTerminate
(
const VARIANT *pvarResult,
const EXCEPINFO *pexcepinfo
)
	{
	return(S_OK);
	}

/*===================================================================
CActiveScriptEngine::OnStateChange

Host callback to indicate that the script has changed state (e.g. from
Uninitialized to Loaded.)

Returns:
	HRESULT.  Always returns S_OK.

Side effects:
	None.
===================================================================*/
STDMETHODIMP CActiveScriptEngine::OnStateChange
(
SCRIPTSTATE ssScriptState
)
	{
	return(S_OK);
	}

/*===================================================================
CActiveScriptEngine::OnScriptError

Host callback to indicate that an error has occured in the script.
We should handle the error.  We will return E_FAIL to indicate that we 
want the script to terminate.

Returns:
	HRESULT.  E_FAIL -- Terminate executing the script.

Side effects:
	None.
===================================================================*/
STDMETHODIMP CActiveScriptEngine::OnScriptError
(
IActiveScriptError __RPC_FAR *pscripterror
)
	{
	Assert(pscripterror);
	AssertValid();

	// Bug 153: If we terminate the script due to Response.End, dont show an error
	// NOTE: ActiveXScripting was failing to pass us our excepinfo.  Use member flags
	// ALSO: ActiveXScripting has fixed the problem of failing to pass us our excepinfo, but the
	// way we are doing this with flags works just fine.  
	if (m_fScriptAborted)
		{
		goto LRet;
		}
	
	if (m_fScriptTimedOut)
		{
            //Load Default Engine from resource
        char  szEngine[128];
        DWORD cch;
        cch = CchLoadStringOfId(IDS_ENGINE, szEngine, 128);
        szEngine[cch] = '\0';
        CHAR    *szFileName;
#if UNICODE
        szFileName = StringDupUTF8(m_pHitObj->PSzCurrTemplateVirtPath());
#else
        szFileName = StringDupA(m_pHitObj->PSzCurrTemplateVirtPath());
#endif

	    HandleError(IDE_SCRIPT_TIMEOUT, 
                    szFileName, 
                    NULL, 
                    StringDupA(szEngine), 
                    NULL, 
                    NULL, 
                    NULL, 
                    m_pHitObj,
                    NULL);

		if(m_pHitObj)
			{
			m_pHitObj->SetExecStatus(eExecTimedOut);
			}
		goto LRet;
		}

	// OnScriptErrorDebug calls OnScriptError.  use this test to be sure we don't log error
	// twice if we are called twice.  (won't happen with present debugging implementation,
	// but externals may change.)
	if (m_fScriptHadError)
		{
		goto LRet;
		}

	m_fScriptHadError = TRUE;				// Note that the script had an error so we can abort transactions (if any)
		
	if (pscripterror)
		{
		// If there was an error in the script, first see if we should pop up the debugger
		// (ONLY bring up Script Debugger; VID will do the right thing on its own)
		//
		// NEW CHANGE: always bring error description to browser, since VID does not
		// give sufficient description.
		//
		if (FCaesars() && m_pHitObj->PAppln()->FDebuggable())
			DebugError(pscripterror, m_pTemplate, m_dwSourceContext, g_pDebugApp);

		HandleError(pscripterror, m_pTemplate, m_dwSourceContext, NULL, m_pHitObj);
		}

LRet:
	// Bug 99718 return S_OK to tell the script engine that we handled the error ok.
	// Returning E_FAIL would not stop the scripting engine, this was a doc error.
	return(S_OK);
	}


/*
 *
 *
 *
 * I A c t i v e S c r i p t S i t e D e b u g   M e t h o d s
 *
 *
 *
 *
 */ 

/*===================================================================
CActiveScriptEngine::OnScriptErrorDebug

Callback for debugger to query host on what to do on exception.

NOTE: Theoretically, we would set *pfCallOnScriptErrorWhenContinuing
      to TRUE and not call OnScriptError, and set *pfEnterDebugger
      to TRUE or FALSE based on whether debugging is enabled and
      whether user wants to debug.

      However, in practice, *pfCallOnScriptErrorWhenContinuing is
      not honored (OnScriptError is NOT called in any case), and
      the VID team wants us to pretend like we don't implement
      this interface.  However, we always need our "OnScriptError"
      code to execute, so we call our OnScriptError function
      explicitly, then fail

Returns:
	HRESULT.  always returns E_NOTIMPL

Side effects:
	calls OnScriptError
===================================================================*/
STDMETHODIMP CActiveScriptEngine::OnScriptErrorDebug
(
IActiveScriptErrorDebug *pscripterror,
BOOL *pfEnterDebugger,
BOOL *pfCallOnScriptErrorWhenContinuing
)
	{
	OnScriptError(pscripterror);
	return E_NOTIMPL;
	} 

/*===================================================================
CActiveScriptEngine::GetDocumentContextFromPosition

Create a document context (file + offset + length) from an offset in the
script.

Returns:
	HRESULT.  S_OK on success.
===================================================================*/
HRESULT CActiveScriptEngine::GetDocumentContextFromPosition
(
/* [in] */ DWORD_PTR dwSourceContext,
/* [in] */ ULONG cchTargetOffset,
/* [in] */ ULONG cchText,
/* [out] */ IDebugDocumentContext **ppDocumentContext)
	{
    static const char *_pFuncName = "CActiveScriptEngine::GetDocumentContextFromPosition()";
	TCHAR *szSourceFile;
	ULONG cchSourceOffset;
	ULONG cchSourceText;
	IActiveScriptDebug *pASD;

	// Convert offset in script engine to source location, and get debugging interfaces
	m_pTemplate->GetSourceOffset(m_dwSourceContext, cchTargetOffset, &szSourceFile, &cchSourceOffset, &cchSourceText);
    
    HRESULT  hr;

    TRYCATCH_HR(m_pAS->QueryInterface(IID_IActiveScriptDebug, reinterpret_cast<void **>(&pASD)), 
                                      hr,
                                      "IActiveScript::QueryInterface()");

    if (FAILED(hr))
        return(E_FAIL);

	// If this is in the main file, create a document context based on the CTemplate compiled source
	if (_tcscmp(szSourceFile, m_pTemplate->GetSourceFileName()) == 0)
		{
		if (
			(*ppDocumentContext = new CTemplateDocumentContext(m_pTemplate, cchSourceOffset, cchSourceText, pASD, m_dwSourceContext, cchTargetOffset))
			 == NULL
		   )
			{
			pASD->Release();
			return E_OUTOFMEMORY;
			}
		}

	// source refers to an include file, so create a documet context based on cached CIncFile dependency graph
	else
		{
		CIncFile *pIncFile;
		if (FAILED(g_IncFileMap.GetIncFile(szSourceFile, &pIncFile)))
			return E_FAIL;

		if (
			(*ppDocumentContext = new CIncFileDocumentContext(pIncFile, cchSourceOffset, cchSourceText))
			 == NULL
		   )
			{
			TRYCATCH(pASD->Release(),"IActiveScriptDebug::Release()");
			pIncFile->Release();
			return E_OUTOFMEMORY;
			}

		pIncFile->Release();
		}

	TRYCATCH(pASD->Release(),"IActiveScriptDebug::Release()");
	m_fBeingDebugged = TRUE;
	return S_OK;
	}

/*===================================================================
CActiveScriptEngine::GetApplication

Return a pointer to the application that the script resides in.

Returns:
	HRESULT.  Always succeeds.
===================================================================*/
HRESULT CActiveScriptEngine::GetApplication
(
/* [out] */ IDebugApplication **ppDebugApp
)
	{
	Assert (m_pTemplate != NULL);
	if (m_pTemplate->FDebuggable())
		{
		Assert (g_pDebugApp);

		*ppDebugApp = g_pDebugApp;
		(*ppDebugApp)->AddRef();

		return S_OK;
		}
	else
		{
		*ppDebugApp = NULL;
		return E_FAIL;
		}
	}

/*===================================================================
CActiveScriptEngine::GetRootApplicationNode

Return a pointer to the top level node (for browsing)

Returns:
	HRESULT.  Always succeeds.
===================================================================*/
HRESULT CActiveScriptEngine::GetRootApplicationNode
(
/* [out] */ IDebugApplicationNode **ppRootNode
)
	{
	Assert (m_pTemplate != NULL);
	if (m_pTemplate->FDebuggable())
		{
		Assert (g_pDebugAppRoot);

		*ppRootNode = g_pDebugAppRoot;
		(*ppRootNode)->AddRef();
		return S_OK;
		}
	else
		{
		*ppRootNode = NULL;
		return E_FAIL;
		}
	}

/*
 *
 *
 *
 * C S c r i p t E n g i n e   M e t h o d s
 *
 *
 *
 *
 */ 

/*===================================================================
CActiveScriptEngine::AddScriptlet

Add a piece of code to the script engine.

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Adds script code to the engine. Potentially allocates memory.
===================================================================*/
HRESULT CActiveScriptEngine::AddScriptlet
(
LPCOLESTR wstrScript // scriptlet text
)
	{
    static const char *_pFuncName = "CActiveScriptEngine::AddScriptlet()";
	HRESULT hr;
	EXCEPINFO excepinfo;

	AssertValid();

	// Tell ActiveScripting to add the script to the engine

    TRYCATCH_HR(m_pASP->ParseScriptText(
						wstrScript,			// the scriptlet text
						NULL,				// pstrItemName
						NULL,				// punkContext
						L"</SCRIPT>",		// End Delimiter -- Engine will never see this, but does tell it to strip comments.
						m_dwSourceContext,	// dwSourceContextCookie
						1,					// ulStartingLineNumber
						SCRIPTTEXT_ISPERSISTENT | SCRIPTTEXT_HOSTMANAGESSOURCE,
						NULL,				// pvarResult
						&excepinfo),		// exception info filled in on error
                hr,
                "IActiveScriptParse::ParseScriptText()");

	if (SUCCEEDED(hr))
		m_fScriptLoaded = TRUE;

	return(hr);
	}

/*===================================================================
CActiveScriptEngine::AddObjects

Add named objects to the script name space

Returns:
	HRESULT.  Always returns S_OK.

Side effects:
	None.
===================================================================*/
HRESULT CActiveScriptEngine::AddObjects
(
BOOL fPersistNames			// = TRUE
)
	{
	HRESULT hr = S_OK;
	AssertValid();

	// There must be a hit object set
	Assert(m_pHitObj != NULL);

	// Leverage RequestItems to give AS all the names
	hr = RequestItems(fPersistNames);

	if (SUCCEEDED(hr))
		m_fObjectsLoaded = TRUE;

	return(hr);
	}

/*===================================================================
CActiveScriptEngine::AddAdditionalObject

Add additional named objects to the script name space beyond the
names already added with AddObject.  Note: the caller MUST have
added then names to the HitObj before making this call

Returns:
	HRESULT.  S_OK on success

Side effects:
	None.
===================================================================*/
HRESULT CActiveScriptEngine::AddAdditionalObject
(
LPWSTR strObjName,
BOOL fPersistNames			// = TRUE
)
	{
    static const char *_pFuncName = "CActiveScriptEngine::AddAdditionalObject()";
	HRESULT hr = S_OK;
	DWORD grf;
	
	AssertValid();

	// There must be a hit object set
	Assert(m_pHitObj != NULL);

	// CONSIDER: It would be nice in debug code to walk the hitobj objlist and make sure
	//			that the given name is in there

	/*
	 * Give AS the names
	 */
	grf = SCRIPTITEM_ISVISIBLE;
	if (fPersistNames)
		grf |= SCRIPTITEM_ISPERSISTENT;
		
    TRYCATCH_HR(m_pAS->AddNamedItem(strObjName, grf), hr, "IActiveScript::AddNamedItem()");

    Assert(SUCCEEDED(hr));		// Should never fail!

	return(hr);
	}

/*===================================================================
CActiveScriptEngine::AddScriptingNamespace

Add the given scripting namespace object to the engine.

Note that it is added as GLOBALMEMBERS, and Not as ISPERSISTENT

Returns:
	HRESULT.  S_OK on success

Side effects:
	None.
===================================================================*/
HRESULT CActiveScriptEngine::AddScriptingNamespace
(
)
	{
    static const char *_pFuncName = "CActiveScriptEngine::AddScriptingNamespace()";
	HRESULT hr = S_OK;
	
	AssertValid();
	Assert(m_pHitObj != NULL);
	
	/*
	 * Give AXS the name and mark it GLOBALMEMBERS so all members are top level names
	 * in the namespace
	 */
    TRYCATCH_HR(m_pAS->AddNamedItem(WSZ_OBJ_SCRIPTINGNAMESPACE, SCRIPTITEM_ISVISIBLE | SCRIPTITEM_GLOBALMEMBERS), 
                hr,
                "IActiveScript::AddNamedItem()");
	Assert(SUCCEEDED(hr));		// Should never fail!

	return(hr);
	}

/*===================================================================
CActiveScriptEngine::CheckEntryPoint

Determines if the specific named entry point exists in the given script.

Returns:
	S_OK if found
	DISP_E_UNKNOWNNAME if not found
	Other OLE errors may be returned

Side effects:
	None
===================================================================*/
HRESULT CActiveScriptEngine::CheckEntryPoint
(
LPCOLESTR strEntryPoint		// The name of the sub/fn to look for
)
	{
    static const char *_pFuncName = "CActiveScriptEngine::CheckEntryPoint()";
	HRESULT hr;
	DISPID dispid;

	AssertValid();

	if (strEntryPoint == NULL)
		{
		Assert(FALSE);
		hr = DISP_E_UNKNOWNNAME;
		}
	else
		{
		// Get the DISPID of the method to call

        TRYCATCH_HR(m_pDisp->GetIDsOfNames(IID_NULL,		// REFIID - Reserved, must be NULL
	    							 (LPOLESTR *)&strEntryPoint, // Array of names to look up
		    						 1,					// Number of names in array
			    					 m_lcid,			// Locale id
				    				 &dispid),			// returned dispid
                    hr,
                    "IScriptDispatch::GetIDsOfNames()");
								 
		// Only error we expect is DISP_E_UNKNOWNNAME (or DISP_E_MEMBERNOTFOUND)
		Assert(hr == S_OK || hr == DISP_E_UNKNOWNNAME || hr == DISP_E_MEMBERNOTFOUND);
		}
		
	return(hr);
	}

/*===================================================================
CActiveScriptEngine::Call

Runs the specified function.

If a specific named entry point is provided (e.g. Session_OnStart)
then we will call that by name.  Otherwise (e.g. a "main" script),
pass NULL for the name and we will run just the mainline code.

Calls TryCall (optionally from under TRY CATCH) to do the job

Returns:
	HRESULT.  S_OK on success.

Side effects:
	May have various side effects depending on the script run
===================================================================*/
HRESULT CActiveScriptEngine::Call
(
LPCOLESTR strEntryPoint		// The name of the sub/fn to call (may be NULL for "main")
)
{
	HRESULT hr;
	
	AssertValid();

	if (Glob(fExceptionCatchEnable)) {
    	// Catch any GPFs in VBS, OleAut, or external components

        TRY

            hr = TryCall(strEntryPoint);
        
    	CATCH(nExcept)
    		/*
    		 * Catching a GPF or stack overflow
    		 * Report it to the user, Assert (if debug), and exit with E_UNEXPECTED.
    		 */
    		if (STATUS_STACK_OVERFLOW == nExcept) {
    			HandleErrorMissingFilename(IDE_STACK_OVERFLOW, m_pHitObj);
#if UNICODE
                DBGPRINTF((DBG_CONTEXT, "Invoking the script '%S' overflowed the stack", m_szTemplateName));
#else
                DBGPRINTF((DBG_CONTEXT, "Invoking the script '%s' overflowed the stack", m_szTemplateName));
#endif
            }
    		else {	
    			HandleErrorMissingFilename(IDE_SCRIPT_GPF, m_pHitObj, TRUE, nExcept);
#if UNICODE
                DBGPRINTF((DBG_CONTEXT, "Invoking the script '%S' threw an exception (%x).", m_szTemplateName, nExcept));
#else
                DBGPRINTF((DBG_CONTEXT, "Invoking the script '%s' threw an exception (%x).", m_szTemplateName, nExcept));
#endif
            }

    		// Dont reuse the engine
    		m_fCorrupted = TRUE;
    		
    		hr = E_UNEXPECTED;
    	END_TRY
    }
    else {
        // Don't catch exceptions
        hr = TryCall(strEntryPoint);
    }

	return(hr);
}

/*===================================================================
CActiveScriptEngine::TryCall

Runs the specified function.

If a specific named entry point is provided (e.g. Session_OnStart)
then we will call that by name.  Otherwise (e.g. a "main" script),
pass NULL for the name and we will run just the mainline code.

Called from Call (optionally from under TRY CATCH)

Returns:
	HRESULT.  S_OK on success.

Side effects:
	May have various side effects depending on the script run
===================================================================*/
HRESULT CActiveScriptEngine::TryCall
(
LPCOLESTR strEntryPoint		// The name of the sub/fn to call (may be NULL for "main")
)
	{
	HRESULT hr;
	DISPID dispid;
	DISPPARAMS dispparams;
	UINT nArgErr;

	/*
	 * Before calling any code we will transition the script to "STARTED" state.
	 * This is part of the ActiveXScripting Reset work.
	 */
    hr = m_pAS->SetScriptState(SCRIPTSTATE_STARTED);

	if (FAILED(hr))
		{
		Assert(FALSE);
		goto LRet;
		}
		
	if (strEntryPoint != NULL)
		{
		// Get the DISPID of the method to call
		hr = m_pDisp->GetIDsOfNames(IID_NULL,		// REFIID - Reserved, must be NULL
								 (LPOLESTR *)&strEntryPoint, // Array of names to look up
								 1,					// Number of names in array
								 m_lcid,			// Locale id
								 &dispid);			// returned dispid
		if (FAILED(hr))
			{
			// Only error we expect is DISP_E_UNKNOWNNAME (or DISP_E_MEMBERNOTFOUND)
			Assert(hr == DISP_E_UNKNOWNNAME || hr == DISP_E_MEMBERNOTFOUND);
			goto LRet;
			}

		// There are no arguments
		memset(&dispparams, 0, sizeof(dispparams));

		// Invoke it
		hr = m_pDisp->Invoke(dispid,			// dispid to invoke
						IID_NULL,				// REFIID - Reserved, must be NULL
						 m_lcid,				// Locale id
						 DISPATCH_METHOD,		// Calling a method, not a property get/put
						 &dispparams,			// pass arguments
						 NULL,					// return value
						 NULL,					// We aren't interested in the exception info
						 &nArgErr);				// if there is a Type Mismatch, which argument was the problem
		}
	
LRet:
	return(hr);
	}


/*
 *
 *
 *
 * C S c r i p t M a n a g e r
 *
 *
 *
 *
 */ 

/*===================================================================
CScriptManager::CScriptManager

Constructor for CScriptManager object

Returns:
	Nothing

Side effects:
	None.
===================================================================*/
CScriptManager::CScriptManager()
	: m_fInited(FALSE), m_idScriptKiller(0)
	{
	}

/*===================================================================
CScriptManager::~CScriptManager

Destructor for CScriptManager object

Returns:
	Nothing

Side effects:
	None.
===================================================================*/
CScriptManager::~CScriptManager()
	{
	}

/*===================================================================
CScriptManager::Init

Init the script manager.  This must only be called once.

Returns:
	HRESULT.  S_OK on success.

Side effects:
	None.
===================================================================*/
HRESULT CScriptManager::Init
(
)
	{
    static const char *_pFuncName = "CScriptManager::Init()";
	HRESULT hr;
	BOOL fPLLInited = FALSE;
	BOOL fcsPLLInited = FALSE;
	BOOL fFSQInited = FALSE;
	BOOL fcsFSQInited = FALSE;
	BOOL fRSLInited = FALSE;
	BOOL fcsRSLInited = FALSE;
	DWORD cBuckets;
	DWORD rgPrime[] = { 3, 11, 23, 57, 89 };
	WORD iP;
    IActiveScript *pAST = NULL;
	static const GUID uid_VBScript	= { 0xB54F3741, 0x5B07, 0x11cf, { 0xA4, 0xB0, 0x00, 0xAA, 0x00, 0x4A, 0x55, 0xE8}};
	
	// Illegal to re-init
	if (m_fInited)
		{
		Assert(FALSE);
		return(ERROR_ALREADY_INITIALIZED);
		}

	// Create the critical sections for serializing access to lists
	ErrInitCriticalSection(&m_cSPLL, hr);
	if (FAILED(hr))
		goto LError;
	fcsPLLInited = TRUE;
	ErrInitCriticalSection(&m_csFSQ, hr);
	if (FAILED(hr))
		goto LError;
	fcsFSQInited = TRUE;
	ErrInitCriticalSection(&m_csRSL, hr);
	if (FAILED(hr))
		goto LError;
	fcsRSLInited = TRUE;

	// List of programming language clsid's
	hr = m_hTPLL.Init();
	if (FAILED(hr))
		goto LError;
	fPLLInited = TRUE;

	// Free Script Queue
	// Init it with a prime # of buckets in relation to script engine cache max
	cBuckets = (Glob(dwScriptEngineCacheMax) / 2) + 1;
	for (iP = (sizeof(rgPrime) / sizeof(DWORD)) - 1; iP > 0; iP--)
		if (rgPrime[iP] < cBuckets)
			{
			cBuckets = rgPrime[iP];
			break;
			}
	if (cBuckets < rgPrime[1])
		cBuckets = rgPrime[0];
			
	hr = m_htFSQ.Init(cBuckets);
	if (FAILED(hr))
		goto LError;
	fFSQInited = TRUE;

	// Running Script List
	// Init it with a prime # of buckets in relation to max # of threads
	cBuckets = Glob(dwThreadMax) / 2;
	for (iP = (sizeof(rgPrime) / sizeof(DWORD)) - 1; iP > 0; iP--)
		if (rgPrime[iP] < cBuckets)
			{
			cBuckets = rgPrime[iP];
			break;
			}
	if (cBuckets < rgPrime[1])
		cBuckets = rgPrime[0];
		
	hr = m_htRSL.Init(cBuckets);
	if (FAILED(hr))
		goto LError;
	fRSLInited = TRUE;

	// Schedule script killer
    m_msecScriptKillerTimeout = Glob(dwScriptTimeout) * 500;
	m_idScriptKiller = ScheduleWorkItem
	    (
	    CScriptManager::ScriptKillerSchedulerCallback,  // callback
	    this,                                           // context
        m_msecScriptKillerTimeout,                      // timeout
        TRUE                                            // periodic
        );
    if (!m_idScriptKiller)
        {
        hr = E_FAIL;
        goto LError;
        }

    // TypeLib support: Create a scripting engine and QI it for the TypeLib wrapper support
    hr = CoCreateInstance(uid_VBScript, NULL, CLSCTX_INPROC_SERVER, IID_IActiveScript, (void**)&pAST);
    if (FAILED(hr))
        goto LError;
    TRYCATCH_HR_NOHITOBJ(pAST->QueryInterface(IID_IWrapTypeLibs, (VOID **)&g_pWrapTypelibs),
                         hr,
                         "IActiveScript::QueryInterface()");
    TRYCATCH_NOHITOBJ(pAST->Release(),"IActiveScript::Release()");        // No longer need the pointer to the engine
    if (FAILED(hr))
        goto LError;
    
	// All OK.  We are inited.
	m_fInited = TRUE;

	goto LExit;
	
LError:
    if (m_idScriptKiller)
        RemoveWorkItem(m_idScriptKiller);
	if (fcsPLLInited)
		DeleteCriticalSection(&m_cSPLL);
	if (fcsFSQInited)
		DeleteCriticalSection(&m_csFSQ);
	if (fcsRSLInited)
		DeleteCriticalSection(&m_csRSL);
	if (fPLLInited)
		m_hTPLL.UnInit();
	if (fFSQInited)
		m_htFSQ.UnInit();
	if (fRSLInited)
		m_htRSL.UnInit();
	if (pAST)
	    TRYCATCH_NOHITOBJ(pAST->Release(),"IActiveScript::Release()");
	if (g_pWrapTypelibs)
	    {
	    TRYCATCH_NOHITOBJ(g_pWrapTypelibs->Release(),"IWrapTypeLibs::Release()");
	    g_pWrapTypelibs = NULL;
	    }

LExit:	
	return(hr);
	}

/*===================================================================
CScriptManager::UnInit

UnInit the script manager.  This must only be called once.

Returns:
	HRESULT.  S_OK on success.

Side effects:
	None.
===================================================================*/
HRESULT CScriptManager::UnInit
(
)
	{
    static const char *_pFuncName = "CScriptManager::UnInit()";
	HRESULT hr = S_OK, hrT;
	
	if (m_fInited)
		{
		// Un-schedule script killer
        if (m_idScriptKiller)
            {
            RemoveWorkItem(m_idScriptKiller);
            m_idScriptKiller = 0;
            }
        
		// Uninit each of the lists.  Attempt to uninit them all, even if we get an error.
		// Dont lose any errors along the way.
		hr = UnInitASEElems();
		hrT = UnInitPLL();
		if (SUCCEEDED(hr))
			hr = hrT;	
		hrT = m_hTPLL.UnInit();
		if (SUCCEEDED(hr))
			hr = hrT;	
		hrT = m_htFSQ.UnInit();
		if (SUCCEEDED(hr))
			hr = hrT;	
		hrT = m_htRSL.UnInit();
		if (SUCCEEDED(hr))
			hr = hrT;	

        if (g_pWrapTypelibs)
            {
            TRYCATCH_NOHITOBJ(g_pWrapTypelibs->Release(),"IWrapTypeLibs::Release()");
            g_pWrapTypelibs = NULL;
            }
            
		// Free the critical sections (bug 1140: do this after freeing everything else)
		DeleteCriticalSection(&m_cSPLL);
		DeleteCriticalSection(&m_csFSQ);
		DeleteCriticalSection(&m_csRSL);

		m_fInited = FALSE;
		}

	return(hr);
	}


/*===================================================================
CScriptManager::AdjustScriptKillerTimeout

Adjust (shorten) script killer timeout when needed.
The caller should take care of the critical sectioning.

Parameters:
    msecNewTimeout    new suggested timeout value (in ms)

Returns:
	HRESULT.  S_OK on success.
===================================================================*/
HRESULT CScriptManager::AdjustScriptKillerTimeout
(
DWORD msecNewTimeout
)
    {
    const DWORD MSEC_MIN_SCRIPT_TIMEOUT = 5000;   // 5 seconds

    if (!m_idScriptKiller)
        return E_FAIL;  // no script killer scheduled

    // don't set to < minimum
    if (msecNewTimeout < MSEC_MIN_SCRIPT_TIMEOUT)
        msecNewTimeout = MSEC_MIN_SCRIPT_TIMEOUT;
        
    if (m_msecScriptKillerTimeout <= msecNewTimeout)
        return S_OK; // the timeout already short enough

    if (ScheduleAdjustTime(
            m_idScriptKiller, 
            msecNewTimeout) == S_OK)
        {
        m_msecScriptKillerTimeout = msecNewTimeout;
        return S_OK;
        }
    else
        {
        return E_FAIL;
        }
    }

/*===================================================================
CScriptManager::GetEngine

Return an engine to the caller.  Ideally, we will find an engine
that already has the given script in it in our Free Script Queue
and will just hand it out.  If there isnt one, then we will look
in the Running Script List and attempt to clone a running script.
Failing that, we will create a new script
engine.  We return an ENGINESTATE state indicating if the engine
is filled with script or not.

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Potentially allocates memory.
===================================================================*/
HRESULT CScriptManager::GetEngine
(
LCID lcid,					// The system language to use
PROGLANG_ID& progLangId,	// prog lang id of the script
LPCTSTR szTemplateName,		// Template we want an engine for
CHitObj *pHitObj,			// Hit obj to use in this engine
CScriptEngine **ppSE,		// Returned script engine
ENGINESTATE *pdwState,		// Current state of the engine
CTemplate *pTemplate,		// template which engine is based from
DWORD dwSourceContext		// source context cookie (engine ID)
)
	{
	HRESULT hr = S_OK;
	CActiveScriptEngine *pASE = NULL;
	CASEElem *pASEElem = NULL;
	DWORD dwInstanceID = pHitObj->DWInstanceID();
	
	AssertValid();

	/*	NOTE progLangId must be valid because CTemplate::Compile() 
		fails way upstream of this point if it cannot generate a valid progLangId.
		Unfortunately there is no easy way to assert progLangId is valid ...
	*/

	/*
	 * First try to find the engine in the FSQ
	 *
	 * Note: We are going to enter our CS now, and keep it until we have
	 * secured the engine for ourselves.  Otherwise, it might be possible
	 * for us to get an engine, and then have another thread get the
	 * same engine before we manage to get it off of the FSQ.
	 * This makes the code a little hard to read, but is nessecary.
	 */
	EnterCriticalSection(&m_csFSQ);
#ifndef REUSE_ENGINE

    // This will only find fully loaded engines
	hr = FindEngineInList(szTemplateName, progLangId, dwInstanceID, /*fFSQ*/TRUE, &pASEElem);
	
#endif
	if (FAILED(hr))
		{
    	LeaveCriticalSection(&m_csFSQ);
		goto LFail;
		}

	if (pASEElem == NULL || pASEElem->PASE() == NULL)
		{
    	LeaveCriticalSection(&m_csFSQ);
		}
	else
		{
		// We got an engine we want to use, remove it from FSQ
		(VOID)m_htFSQ.RemoveElem(pASEElem);
#ifndef PERF_DISABLE
        g_PerfData.Decr_SCRIPTFREEENG();
#endif
    	LeaveCriticalSection(&m_csFSQ);

		pASE = pASEElem->PASE();
		Assert(!pASE->FIsZombie());
		Assert(pASE->FFullyLoaded());
		hr = pASE->ReuseEngine(pHitObj, pTemplate, dwSourceContext, dwInstanceID);
		if (FAILED(hr))
			goto LFail;
		}
		
	/*
	 * If not found, try to find the engine in the RSL and clone it
	 */
	if (pASE == NULL)
		{
		CASEElem *pASEElemRunning = NULL;
		CActiveScriptEngine *pASERunning = NULL;

		// If we do find an engine to clone, dont let anyone at it until we've cloned it
    	EnterCriticalSection(&m_csRSL);

#ifndef CLONE
		hr = FindEngineInList(szTemplateName, progLangId, dwInstanceID, /*fFSQ*/FALSE, &pASEElemRunning);
#else	// CLONE
		// Clone turned off - pretend one wasnt found
		pASEElemRunning = NULL;
#endif
		/*
		 * If we didnt find an element, or it was null, or (bug 1225) it was corrupted
		 * by a GPF running a script, or it was a zombie, then leave the CS and continue.
		 */
		if (FAILED(hr) || pASEElemRunning == NULL || pASEElemRunning->PASE() == NULL ||
			pASEElemRunning->PASE()->FIsCorrupted() || pASEElemRunning->PASE()->FIsZombie())
			{
			LeaveCriticalSection(&m_csRSL);
			if (FAILED(hr))
				goto LFail;
			}
		else
	        {
			pASERunning = pASEElemRunning->PASE();
			Assert(pASERunning != NULL);
			}

		if (pASERunning != NULL)
			{
			IActiveScript *pAS, *pASClone;

    		Assert(!pASERunning->FIsZombie());
	    	Assert(pASERunning->FFullyLoaded());

			// Found a running engine, clone it
			pAS = pASERunning->GetActiveScript();
			Assert(pAS != NULL);
			hr = pAS->Clone(&pASClone);

			// We've cloned the engine, we can let go of the CS
			LeaveCriticalSection(&m_csRSL);

			// Scripting engines are not required to implement clone.  If we get an error,
			// just continue on and create a new engine
			if (FAILED(hr))
				{
				Assert(hr == E_NOTIMPL);		// I only expect E_NOTIMPL
				Assert(pASE == NULL);			// the ASE should not be filled in
				pASE = NULL;
				hr = S_OK;
				}
			else
				{
				// Got back a cloned IActiveScript.  Create a new ASE and fill it in
				pASE = new CActiveScriptEngine;
				if (!pASE)
					{
					hr = E_OUTOFMEMORY;
					pASClone->Release();
					goto LFail;
					}
				hr = pASE->MakeClone(progLangId, szTemplateName, lcid, pHitObj, pTemplate, dwSourceContext, dwInstanceID, pASClone);
				if (FAILED(hr))
					{
					// if we failed, we must release the clone AS
					pASClone->Release();
					goto LFail;
					}
				}
			}
		}

	/*
	 * Have an engine that we can reuse
	 */
	if (pASE != NULL)
		{
		// Reusing an engine.  Let the caller know that it is already initialized
		*pdwState = SCRIPTSTATE_INITIALIZED;

		goto LHaveEngine;
		}

	/*
	 * No suitable engine to reuse.  Return a new one
	 */
	pASE = new CActiveScriptEngine;
	if (!pASE)
		{
		hr = E_OUTOFMEMORY;
		goto LFail;
		}
	hr = pASE->Init(progLangId, szTemplateName, lcid, pHitObj, pTemplate, dwSourceContext);
	if (FAILED(hr))
		goto LFail;

	// This is a new engine, let the caller know it is uninitialized
	*pdwState = SCRIPTSTATE_UNINITIALIZED;

LHaveEngine:
	// Return the engine as a CScriptEngine -- the caller only needs those interfaces
	pASE->AssertValid();				// The engine we're about to give back should be valid
	*ppSE = (CScriptEngine *)pASE;
	
	// Put the engine on the Running Scrips List
	// If we got this engine from the FSQ, reuse that elem.
	if (pASEElem == NULL)
		{
		pASEElem = new CASEElem;
		if (!pASEElem)
			{
			hr = E_OUTOFMEMORY;
			goto LFail;
			}
		hr = pASEElem->Init(pASE);
		if (FAILED(hr))
			{
			Assert(FALSE);		// Shouldnt fail
			delete pASEElem;
			goto LFail;
			}
		}

    /*
     * Above, we may have gotten an engine from the FSQ or cloned on from the RSL or
     * created a new one.  And, we are about to put that engine on the RSL.  However,
     * it is possible that the template in question was flushed due to a change notification
     * while this was going on.  Regardless of how we got the engine, there is the possibility
     * that the template was flushed while we were holding onto an engine which was not on
     * any list (the FSQ or RSL), and so we have an engine which should be flushed but isnt.
     * We can detect this by seeing if the template is marked as being a Zombie.  If it is
     * we must mark this engine as being a zombie too, so it wont be returned to the FSQ when
     * it is done running.  Note that once we add this engine to the RSL we are "safe", because
     * any flushes after that point would correctly zombify the engine.
     */
    EnterCriticalSection(&m_csRSL);    
    if (pTemplate->FIsZombie())
        {
        // The template asking for this engine is obsolete. Make sure that no
        // one else will use this engine by marking it zombie
        DBGPRINTF((DBG_CONTEXT, "[CScriptManager] Zombie template found.\n"));
        (*ppSE)->Zombify();
        }

	(VOID)m_htRSL.AddElem(pASEElem);
	LeaveCriticalSection(&m_csRSL);


	// Set the time that the engine was handed out so we will know when to kill it
	pASE->SetTimeStarted(time(NULL));

LFail:

	Assert(SUCCEEDED(hr) || hr == TYPE_E_ELEMENTNOTFOUND);
	return(hr);
	}

/*===================================================================
CScriptManager::ReturnEngineToCache

Caller is done with the engine.  Return it to the cache.

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Potentially allocates memory.
===================================================================*/
HRESULT CScriptManager::ReturnEngineToCache
(
CScriptEngine **ppSE,
CAppln *pAppln
)
{
	HRESULT hr = S_OK;
	CASEElem *pASEElem;
	CActiveScriptEngine *pASE;

	Assert(ppSE != NULL);
	Assert(*ppSE != NULL);

	pASE = static_cast<CActiveScriptEngine *>(*ppSE);
	
	// Remove the engine from the Running Script List
	EnterCriticalSection( &m_csRSL );
	hr = FindASEElemInList(static_cast<CActiveScriptEngine *>(*ppSE), /*fFSQ*/FALSE, &pASEElem);
	if (FAILED(hr)) {
		LeaveCriticalSection( &m_csRSL );
		goto LExit;
    }
		
	// Note: Sometimes a script will not be in the RSL!  This occurs when
	//       we are reusing a script that is stored in the CTemplate object.
	//       (When the script is reloaded, it is retrieved directly from the
	//        template, bypassing our code which places engines on the RSL)
	//
	if (pASEElem != NULL)
		m_htRSL.RemoveElem(pASEElem);

	LeaveCriticalSection( &m_csRSL );

	/*
	 * If the engine was zombified while it was running, deallocate it.
	 * Or, if there was a GPF while then engine was running, then it might
	 * be in a corrupted state (bug 1225).  Also remove it in that case.
	 */
	pASE = static_cast<CActiveScriptEngine *>(*ppSE);
	if (pASE->FIsZombie() || pASE->FIsCorrupted()) {
		delete pASEElem;
		pASE->FinalRelease();
		goto LExit;
    }

	HRESULT hrT;
	/*
	 * We want to reuse this engine.  Try to return it to the "Uninitialized"
	 * state.  Some engine languages arent able to do this.  If it fails, deallocate
	 * the engine; it cant be reused.
	 */
	hrT = pASE->ResetToUninitialized();
	if (FAILED(hrT)) {
		// Engine doesnt support this, sigh.  Deallocate and continue.
		delete pASEElem;
		pASE->FinalRelease();
		goto LExit;
    }

    // Get the pTemplate for this engine
	CTemplate *pTemplate;
	DWORD dwEngine;
	pASE->GetDebugDocument(&pTemplate, &dwEngine);

	// CONSIDER: Better strategy for keeping live scripts?
	// Only remember good (no compiler errors) scripts in the template
	if (pAppln->FDebuggable() && pASE->FFullyLoaded() && pTemplate && !pTemplate->FDontAttach()) {
		// Template is marked as incomplete (invalid) when change notification occurs
		// and template is flushed from cache.  In this case, don't cache in CTemplate
		// object!

		if (pTemplate->FIsValid())
			pTemplate->AddScript(dwEngine, pASE);

		// NOTE: Always release the scripting engine.  Exec code is structured so that it
		//       consumes a reference (either through GetEngine() or CTemplate::GetActiveScript())
		//       and assumes that ReturnToCache will release its reference.
		// CONSIDER: Bad design.  Caller should do the release

		delete pASEElem;
		pASE->Release();
    }
	else {
	    // reuse engines, not debugging
		/*
		 * We removed the engine from the RSL, put it onto the FSQ for potential reuse.
		 *
		 * In certain multi-threaded change-notify situations it is possible
		 * that the template was flushed (zombied) while we were in the middle
		 * of returning this engine to the cache.  That is to say, between the time
		 * that we took the engine off the RSL and when we are going to put it on the FSQ
		 * it might have been flushed. In that case, this engine should
		 * not go into the FSQ, but should be deleted instead.  Check for that case.
		 * Do that inside the FSQ CS so that we are safe from the template getting zombied
		 * after we do the test but before the engine goes into the FSQ.  Also, do not
		 * put template on FSQ during shut down phase, since FSQ may go away soon, and
		 * the final destination of the engine is FinalRelease() anyway.
		 */
    	EnterCriticalSection(&m_csFSQ);
    	if (!pTemplate->FIsZombie() && !IsShutDownInProgress()) {
    		AddToFSQ(pASEElem);
        }
    	else {
    		delete pASEElem;
    		pASE->FinalRelease();
        }
		LeaveCriticalSection(&m_csFSQ);
    }

LExit:
	return(hr);
}

/*===================================================================
CScriptManager::FlushCache

A script has been edited; cached versions must be discarded

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Potentially allocates memory.
===================================================================*/
HRESULT CScriptManager::FlushCache
(
LPCTSTR szTemplateName
)
	{
	HRESULT hr = S_OK;
	CASEElem *pASEElem;
	CASEElem *pASEElemNext = NULL;
	CActiveScriptEngine *pASE;
	
	AssertValid();

	EnterCriticalSection(&m_csRSL);
	EnterCriticalSection(&m_csFSQ);

	// First Zombify engines on the RSL of the given name.
	// Note: must explicitly loop through all elements, since the hash table implementation
	//		doesnt support FindNext to find subsequent elements of the same name.  Repeated
	//		calls to find returns the same element over and over
	// CONSIDER: I have written a custom FindElem.  Consider using it.
	
	pASEElem = (CASEElem *)m_htRSL.Head();
	while (pASEElem != NULL)
		{
		pASEElemNext = (CASEElem *)pASEElem->m_pNext;
		pASE = pASEElem->PASE();

		if (_tcsicmp(pASE->SzTemplateName(), szTemplateName) == 0)
			pASE->Zombify();
		
		pASEElem = pASEElemNext;
		}


	// Now throw out engines on the FSQ of the given name
	// Delete any item with the given name (may be several)
	pASEElem = (CASEElem *)m_htFSQ.Head();
	while (pASEElem != NULL)
		{
		pASEElemNext = (CASEElem *)pASEElem->m_pNext;
		pASE = pASEElem->PASE();

		if (_tcsicmp(pASE->SzTemplateName(), szTemplateName) == 0)
			{
			(VOID)m_htFSQ.RemoveElem(pASEElem);
#ifndef PERF_DISABLE
            g_PerfData.Decr_SCRIPTFREEENG();
#endif
			pASE->FinalRelease();
			delete pASEElem;
			}
		
		pASEElem = pASEElemNext;
		}

	LeaveCriticalSection(&m_csFSQ);
	LeaveCriticalSection(&m_csRSL);

	return(hr);
	}

/*===================================================================
CScriptManager::FlushAll

global.asa changed, everything must go

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Potentially allocates memory.
===================================================================*/
HRESULT CScriptManager::FlushAll
(
)
	{
	HRESULT hr = S_OK;
	CASEElem *pASEElem;
	CASEElem *pASEElemNext = NULL;
	CActiveScriptEngine *pASE;
	
	AssertValid();

	EnterCriticalSection(&m_csRSL);
	EnterCriticalSection(&m_csFSQ);

	// First Zombify all engines on the RSL
	// Note: must explicitly loop through all elements, since the hash table implementation
	//		doesnt support FindNext to find subsequent elements of the same name.  Repeated
	//		calls to find returns the same element over and over
	// CONSIDER: I have written a custom FindElem.  Consider using it.
	
	pASEElem = (CASEElem *)m_htRSL.Head();
	while (pASEElem != NULL)
		{
		pASEElemNext = (CASEElem *)pASEElem->m_pNext;
		pASEElem->PASE()->Zombify();
		pASEElem = pASEElemNext;
		}

	// Now throw out engines on the FSQ
	pASEElem = (CASEElem *)m_htFSQ.Head();
	while (pASEElem != NULL)
		{
		pASEElemNext = (CASEElem *)pASEElem->m_pNext;
		(VOID)m_htFSQ.RemoveElem(pASEElem);
#ifndef PERF_DISABLE
		g_PerfData.Decr_SCRIPTFREEENG();
#endif
		pASEElem->PASE()->FinalRelease();
		delete pASEElem;
		pASEElem = pASEElemNext;
		}

	LeaveCriticalSection(&m_csFSQ);
	LeaveCriticalSection(&m_csRSL);

	return(hr);
	}

/*===================================================================
CScriptManager::GetDebugScript

Try to find an engine via template pointer, and query for IActiveScriptDebug,
in the RSL.

Returns:
	An AddRef'ed copy of the script engine if found, or NULL if not.
===================================================================*/
IActiveScriptDebug *
CScriptManager::GetDebugScript
(
CTemplate *pTemplate,
DWORD dwSourceContext
)
	{
	EnterCriticalSection(&m_csRSL);

	CASEElem *pASEElem = static_cast<CASEElem *>(m_htRSL.Head());
	while (pASEElem != NULL)
		{
		CTemplate *pScriptTemplate = NULL;
		DWORD dwScriptSourceContext = -1;
		CActiveScriptEngine *pASE = pASEElem->PASE();
		pASE->GetDebugDocument(&pScriptTemplate, &dwScriptSourceContext);

		if (pTemplate == pScriptTemplate && dwSourceContext == dwScriptSourceContext)
			{
			IActiveScript *pActiveScript = pASE->GetActiveScript();
			void *pDebugScript;
			if (SUCCEEDED(pActiveScript->QueryInterface(IID_IActiveScriptDebug, &pDebugScript)))
				{
				pASE->IsBeingDebugged();
				LeaveCriticalSection(&m_csRSL);
				return reinterpret_cast<IActiveScriptDebug *>(pDebugScript);
				}
			else
				{
				LeaveCriticalSection(&m_csRSL);
				return NULL;
				}
			}

		pASEElem = static_cast<CASEElem *>(pASEElem->m_pNext);
		}

	LeaveCriticalSection(&m_csRSL);

	return NULL;
	}

/*===================================================================
CScriptManager::FindEngineInList

Try to find an engine of the given name in the given list (either
the FSQ or the RSL.)

Returns:
	HRESULT.  S_OK on success.
	ppASEElem contains found engine
===================================================================*/
HRESULT CScriptManager::FindEngineInList
(
LPCTSTR szTemplateName,	// Template we want an engine for
PROGLANG_ID progLangId,	// what language do we want this engine for
DWORD dwInstanceID,     // which server instance
BOOL fFSQ,				// TRUE -> look in FSQ, FALSE -> look in RSQ
CASEElem **ppASEElem
)
	{
	HRESULT hr = S_OK;
	DWORD cb;
	
	AssertValid();
	Assert(ppASEElem != NULL);

	*ppASEElem = NULL;
	
	// Key is name
	cb = _tcslen(szTemplateName)*sizeof(TCHAR);
	if (fFSQ)
		{
		EnterCriticalSection(&m_csFSQ);
		*ppASEElem = static_cast<CASEElem *>(m_htFSQ.FindElem((VOID *)szTemplateName, cb, 
											progLangId, dwInstanceID, /*fCheckLoaded*/TRUE));
		LeaveCriticalSection(&m_csFSQ);
		}
	else
		{
		EnterCriticalSection(&m_csRSL);
		*ppASEElem = static_cast<CASEElem *>(m_htRSL.FindElem((VOID *)szTemplateName, cb,
											progLangId, dwInstanceID, /*fCheckLoaded*/TRUE));
		LeaveCriticalSection(&m_csRSL);
		}

	return(hr);
	}

/*===================================================================
CScriptManager::FindASEElemInList

Given an ASE, find its corresponding ASEElem in the hash table. Note
that this is relatively slow because it is doing a linked list traversal
not a hash table lookup.  

CONSIDER: create second hash table to do this quickly.

Returns:
	HRESULT.  S_OK on success.
	ppASEElem contains found engine
===================================================================*/
HRESULT CScriptManager::FindASEElemInList
(
CActiveScriptEngine *pASE,
BOOL fFSQ,				// TRUE -> look in FSQ, FALSE -> look in RSQ
CASEElem **ppASEElem
)
	{
	HRESULT hr = S_OK;
	CASEElem *pASEElem;
	
	AssertValid();
	Assert(pASE != NULL);
	Assert(ppASEElem != NULL);

	*ppASEElem = NULL;
	
	if (fFSQ)
		{
		EnterCriticalSection(&m_csFSQ);
		pASEElem = static_cast<CASEElem *>(m_htFSQ.Head());
		}
	else
		{
		EnterCriticalSection(&m_csRSL);
		pASEElem = static_cast<CASEElem *>(m_htRSL.Head());
		}

	while (pASEElem != NULL)
		{
		if (pASE == pASEElem->PASE())
			break;
		pASEElem = static_cast<CASEElem *>(pASEElem->m_pNext);
		}

	if (fFSQ)
		LeaveCriticalSection(&m_csFSQ);
	else
		LeaveCriticalSection(&m_csRSL);

	*ppASEElem = pASEElem;
		
	return(hr);
	}

/*===================================================================
CScriptManager::KillOldEngines

Loops through all running engines and kills any engines which are "old"
(presumably they are stuck in an infinite loop in VBS.)

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Potentially kills off engines
===================================================================*/
HRESULT CScriptManager::KillOldEngines
(
BOOLB fKillNow // Kill all engines now if TRUE
)
	{
	HRESULT hr = S_OK;
	CASEElem *pASEElem, *pASEElemNext;
	time_t timeNow;
	time_t timeRunning;
	CActiveScriptEngine *pASE;
	
	AssertValid();

	timeNow = time(NULL);

	EnterCriticalSection(&m_csRSL);
	
	pASEElemNext = static_cast<CASEElem *>(m_htRSL.Head());

	/*
	 * Loop through each element.  Turn it into an ASE.
	 * If it is older than cSeconds, then kill it.
	 */
	while (pASEElemNext)
		{
		pASEElem = pASEElemNext;
		pASEElemNext = static_cast<CASEElem *>(pASEElemNext->m_pNext);
		pASE = pASEElem->PASE();

		timeRunning = timeNow - pASE->TimeStarted();

		if (TRUE == fKillNow || timeRunning >= pASE->GetTimeout())
			{
			// Too old. Kill it.
			pASE->InterruptScript();
			}
		}
	
	LeaveCriticalSection(&m_csRSL);

	return(hr);
	}

/*===================================================================
CScriptManager::EmptyRunningScriptList

When we are going to shut down, the RSL must be empty.  This routine
kills off all running engines, then waits up to 5 minutes
for the engines to leave the RSL.  Added for Bug 1140

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Potentially kills off engines
===================================================================*/
HRESULT CScriptManager::EmptyRunningScriptList
(
)
	{
	HRESULT hr;
	UINT cTrys;

	hr = KillOldEngines(TRUE);
	Assert(SUCCEEDED(hr));
	for (cTrys = 0; cTrys < 300; cTrys++)
		{
		if (static_cast<CASEElem *>(m_htRSL.Head()) == NULL)
			break;
		Sleep(1000);			// sleep 1 seconds
		}

	return(S_OK);
	}

/*===================================================================
CScriptManager::UnInitASEElems

Free engines in FSQ and RSL

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Frees memory
===================================================================*/
HRESULT CScriptManager::UnInitASEElems()
	{
	CASEElem *pASEElem = NULL;
	CASEElem *pASEElemNext = NULL;

	// First the FSQ
	EnterCriticalSection(&m_csFSQ);
	pASEElem = static_cast<CASEElem *>(m_htFSQ.Head());
	while (pASEElem != NULL)
		{
		pASEElemNext = static_cast<CASEElem *>(pASEElem->m_pNext);
		pASEElem->PASE()->FinalRelease();
		delete pASEElem;
		pASEElem = pASEElemNext;
		}
	LeaveCriticalSection(&m_csFSQ);

	/*
	 * Next the RSL (note: this really should be empty)
	 *
	 * Bug 1140: This is very dangerous, but we have no choice left at this point
	 */
	EnterCriticalSection(&m_csRSL);
	pASEElem = static_cast<CASEElem *>(m_htRSL.Head());
	while (pASEElem != NULL)
		{
		pASEElemNext = static_cast<CASEElem *>(pASEElem->m_pNext);
		pASEElem->PASE()->FinalRelease();
		delete pASEElem;
		pASEElem = pASEElemNext;
		}
	LeaveCriticalSection(&m_csRSL);
	
	return(S_OK);
	}

/*===================================================================
CScriptManager::AddToFSQ

Add the given ASEElem to the FSQ and to the front of the LRU list

Returns:
	HRESULT.  S_OK on success.

Side effects:
	None.
===================================================================*/
HRESULT CScriptManager::AddToFSQ
(
CASEElem *pASEElem
)
	{
	HRESULT hr = S_OK;

	Assert(pASEElem != NULL);

	// If CacheMax is 0, this is a NoOp
	if (Glob(dwScriptEngineCacheMax) <= 0)
		{
		// delete the passed in ASEElem because it wont be saved
		pASEElem->PASE()->FinalRelease();
		delete pASEElem;

		return(S_OK);
		}

	EnterCriticalSection(&m_csFSQ);

	// Add the element to the FSQ
	(VOID)m_htFSQ.AddElem(pASEElem);

#ifndef PERF_DISABLE
    g_PerfData.Incr_SCRIPTFREEENG();
#endif

	// Check the FSQ LRU too see if it is too long
	CheckFSQLRU();

	LeaveCriticalSection(&m_csFSQ);

	return(hr);
	}

/*===================================================================
CScriptManager::CheckFSQLRU

Check to see if the FSQ is too long, and if so throw out the LRU engine

WARNING: Caller must enter FSQ critical section before calling

Returns:
	HRESULT.  S_OK on success.

Side effects:
	None.
===================================================================*/
HRESULT CScriptManager::CheckFSQLRU()
	{
	HRESULT hr = S_OK;
	CASEElem *pASEElemOld;
	CActiveScriptEngine *pASE;

	// If the list isnt too long, noop
	if (m_htFSQ.Count() <= Glob(dwScriptEngineCacheMax) || Glob(dwScriptEngineCacheMax) == 0xFFFFFFFF)
		return(S_OK);

	// FSQLRU list is too long, remove oldest
	Assert (! m_htFSQ.FLruElemIsEmpty( m_htFSQ.End() ));
	pASEElemOld = static_cast<CASEElem *>(m_htFSQ.RemoveElem(m_htFSQ.End()));
	Assert(pASEElemOld != NULL);
	pASE = pASEElemOld->PASE();

#ifndef PERF_DISABLE
    g_PerfData.Decr_SCRIPTFREEENG();
#endif

	// Delete the engine
	delete pASEElemOld;
	pASE->FinalRelease();

	return(hr);
	}

/*===================================================================
CScriptManager::UnInitPLL

Free the names of the script engines

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Frees memory
===================================================================*/
HRESULT CScriptManager::UnInitPLL()
	{
	CPLLElem *pPLLElem = NULL;
	CPLLElem *pPLLElemNext = NULL;

	pPLLElem = (CPLLElem *)m_hTPLL.Head();

	while (pPLLElem != NULL)
		{
		pPLLElemNext = (CPLLElem *)pPLLElem->m_pNext;
		if (pPLLElem->m_pKey != NULL)
			free((CHAR *)(pPLLElem->m_pKey));
		pPLLElem->m_pKey = NULL;
		delete pPLLElem;
		pPLLElem = pPLLElemNext;
		}
	
	return(S_OK);
	}

/*===================================================================
CScriptManager::ProgLangIdOfLangName

Given a programming language name, get the CLSID of the ActiveX Scripting
Engine which runs that language.

WARNING: Needs to look in the registry for this info.  Maybe slow

Returns:
	HRESULT.  S_OK on success.

Side effects:
	None.
===================================================================*/
HRESULT CScriptManager::ProgLangIdOfLangName
(
LPCSTR szProgLang,			// The programming lang of the script
PROGLANG_ID *pProgLangId	// The programming language id
)
	{
	HRESULT hr = S_OK;
	CPLLElem *pPLLElem;
	
	AssertValid();
	
	EnterCriticalSection(&m_cSPLL);
	pPLLElem = (CPLLElem *) m_hTPLL.FindElem((VOID *)szProgLang, strlen(szProgLang));
	if (pPLLElem != NULL)
		{
		*pProgLangId = pPLLElem->ProgLangId();
		}
	else
		{
		// Not already in list, look in registry
		hr = GetProgLangIdOfName(szProgLang, pProgLangId);
		if (FAILED(hr))
			{
			hr = TYPE_E_ELEMENTNOTFOUND;
			goto LExit;
			}

		// Add it to the list so we dont have to re-look it up
		hr = AddProgLangToPLL((CHAR *)szProgLang, *pProgLangId);
		if (FAILED(hr))
			goto LExit;
		}

LExit:
	LeaveCriticalSection(&m_cSPLL);
	return(hr);
	}

/*===================================================================
CScriptManager::AddProgLangToPLL

Keep list of programming language CLSIDs so we dont have to look
them up every time.  Add the given programming language name/id pair
to the Programming Language List.

Returns:
	HRESULT.  S_OK on success.

Side effects:
	None.
===================================================================*/
HRESULT CScriptManager::AddProgLangToPLL
(
CHAR *szProgLangName,
PROGLANG_ID progLangId
)
	{
	HRESULT hr;
	CPLLElem *pPLLElem = NULL;

	// Put the language clsid on the Programming Language List
	pPLLElem = new CPLLElem;
	if (!pPLLElem)
		{
		hr = E_OUTOFMEMORY;
		goto LFail;
		}

	hr = pPLLElem->Init(szProgLangName, progLangId);
	if (FAILED(hr))
		{
		Assert(FALSE);		// Shouldnt fail
		goto LFail;
		}

	EnterCriticalSection(&m_cSPLL);
	(VOID)m_hTPLL.AddElem(pPLLElem);
	LeaveCriticalSection(&m_cSPLL);

LFail:
	return(hr);
	}

/*===================================================================
CScriptManager::ScriptKillerSchedulerCallback

Static method implements ATQ scheduler callback functions.
Replaces script killer thread 

Parameters:
    void *pv    context pointer (points to script mgr)
    
Returns:

Side effects:
	None.
===================================================================*/
void WINAPI CScriptManager::ScriptKillerSchedulerCallback
(
void *pv
)
    {
    if (IsShutDownInProgress())
        return;

    Assert(pv);
    
    CScriptManager *pScriptMgr = reinterpret_cast<CScriptManager *>(pv);
    if (pScriptMgr->m_fInited)
        {
        pScriptMgr->KillOldEngines();
        }
    }

#ifdef DBG
/*===================================================================
CScriptManager::AssertValid

Test to make sure that the CScriptManager object is currently correctly formed
and assert if it is not.

Returns:

Side effects:
	None.
===================================================================*/
VOID CScriptManager::AssertValid() const
	{
	Assert(m_fInited);
	}
#endif // DBG



/*
 *
 *
 *
 * C A S E E l e m
 *
 * Active Script Engine Elements
 *
 *
 *
 */ 

/*===================================================================
CASEElem::~CASEElem

Destructor for CASEElem object.

Returns:
	Nothing

Side effects:
	None
===================================================================*/
CASEElem::~CASEElem()
	{
	}

/*===================================================================
CASEElem::Init

Init the Active Script Engine Elem.  This must only be called once.

Returns:
	HRESULT.  S_OK on success.

Side effects:
	None.
===================================================================*/
HRESULT CASEElem::Init
(
CActiveScriptEngine *pASE
)
	{
	HRESULT hr = S_OK;
	TCHAR *szT = pASE->SzTemplateName();

	if (szT == NULL)
		{
		Assert(FALSE);
		return(E_FAIL);
		}

	// Key is name
	hr = CLinkElem::Init((LPVOID) szT, _tcslen(szT)*sizeof(TCHAR));
	if (FAILED(hr))
		{
		Assert(FALSE);		// Shouldnt fail
		return(hr);
		}

	m_pASE = pASE;

	return(hr);
	}




/*
 *
 *
 *
 * C P L L E l e m
 *
 * Programming Language List Element
 *
 *
 *
 *
 */ 

/*===================================================================
CPLLElem::~CPLLElem

Destructor for CPLLElem object.

Returns:
	Nothing

Side effects:
	Deallocates memory
===================================================================*/
CPLLElem::~CPLLElem()
	{
	CHAR *szT;

	// Free the memory allocated for the key string
	szT = (CHAR *)m_pKey;
	if (szT != NULL)
		free(szT);
	m_pKey = NULL;
	}

/*===================================================================
CPLLElem::Init

Init the Prog Lang Elem.  This must only be called once.

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Allocates memory
===================================================================*/
HRESULT CPLLElem::Init
(
CHAR *szProgLangName,
PROGLANG_ID progLangId
)
	{
	HRESULT hr = S_OK;
	CHAR *szT;
	UINT cch;

	if (szProgLangName == NULL)
		{
		Assert(FALSE);
		return(E_FAIL);
		}
		
	cch = strlen(szProgLangName);
	szT = (CHAR *)malloc(cch+1);
	if (!szT)
		{
		return(E_OUTOFMEMORY);
		}
	strcpy(szT, szProgLangName);
	hr = CLinkElem::Init((LPVOID) szT, cch);
	if (FAILED(hr))
		{
		Assert(FALSE);		// Shouldnt fail
		free(szT);
		return(hr);
		}

	m_ProgLangId = progLangId;

	return(hr);
	}


/*===================================================================
GetProgLangIdOfName

Given the name of a programming language, get its programming
language Id from the registry.

Returns:
	HRESULT.  S_OK on success.

Side effects:
	None.
===================================================================*/
HRESULT GetProgLangIdOfName
(
LPCSTR szProgLangName,
PROGLANG_ID *pProgLangId
)
	{
	HRESULT hr = S_OK;
	LONG lT;
	HKEY hkeyRoot, hkeyCLSID;
	DWORD dwType;
	CLSID clsid;
	CHAR szClsid[40];
	DWORD cbData;
	LPOLESTR strClsid;
    CMBCSToWChar    convStr;
	
	// The programming language id is really the CLSID of the scripting engine
	// It is in the registry under HKEY_CLASSES_ROOT.  Under the script name,
	// there is a key for "CLSID".  The CLSID is a value under the 
	// engine name.  E.g. \HKEY_CLASSES_ROOT\VBScript\CLSID
	lT = RegOpenKeyExA(HKEY_CLASSES_ROOT, szProgLangName, 0,
						KEY_READ, &hkeyRoot);
	if (lT != ERROR_SUCCESS)
		return(HRESULT_FROM_WIN32(lT));
	lT = RegOpenKeyExA(hkeyRoot, "CLSID", 0,
						KEY_READ, &hkeyCLSID);
	RegCloseKey(hkeyRoot);
	if (lT != ERROR_SUCCESS)
		return(HRESULT_FROM_WIN32(lT));

	cbData = sizeof(szClsid);
	lT = RegQueryValueExA(hkeyCLSID, NULL, 0, &dwType, (BYTE *)szClsid, &cbData);
	if (lT != ERROR_SUCCESS)
		{
		hr = HRESULT_FROM_WIN32(lT);
		goto lExit;
		}
	Assert(cbData <= sizeof(szClsid));

	// What we got back was the GUID as a string (e.g. {089999-444....}). Convert to a CLSID

    convStr.Init(szClsid);
	strClsid = convStr.GetString();
	hr = CLSIDFromString(strClsid, &clsid);

	*pProgLangId = clsid;

lExit:
	RegCloseKey(hkeyCLSID);

	return(hr);
	}




/*
 *
 *
 *
 * C S c r i p t i n g N a m e s p a c e
 *
 * Scripting namespace object
 *
 *
 *
 */ 

/*===================================================================
CScriptingNamespace::CScriptingNamespace

Constructor for CScriptingNamespace object.

Returns:
	Nothing

Side effects:
	None
===================================================================*/
CScriptingNamespace::CScriptingNamespace()
	: m_fInited(FALSE), m_cRef(1), m_cEngDispMac(0) 
	{
	}

/*===================================================================
CScriptingNamespace::~CScriptingNamespace

Destructor for CScriptingNamespace object.

Returns:
	Nothing

Side effects:
	Deallocates memory
===================================================================*/
CScriptingNamespace::~CScriptingNamespace()
	{
	UnInit();
	}

/*===================================================================
CScriptingNamespace::Init

Init the CScriptingNamespace object.

Returns:
	S_OK on success
===================================================================*/
HRESULT CScriptingNamespace::Init()
	{
	Assert(m_fInited == FALSE);
	
	m_fInited = TRUE;

	AssertValid();

	return(S_OK);
	}

/*===================================================================
CScriptingNamespace::UnInit

Free the script engine dispatch's

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Frees memory
===================================================================*/
HRESULT CScriptingNamespace::UnInit()
	{
    static const char *_pFuncName = "CScriptingNamespace::UnInit()";
	CEngineDispElem *pElem = NULL;
	ENGDISPBUCKET *pBucket = NULL;

	if (!m_fInited)
		return(S_OK);
		
	while (!m_listSE.FIsEmpty())
		{
		pElem = static_cast<CEngineDispElem *>(m_listSE.PNext());
		TRYCATCH_NOHITOBJ(pElem->m_pDisp->Release(),"IScriptDispatch::Release()");
        if (pElem->m_pDispEx) {
		        TRYCATCH_NOHITOBJ(pElem->m_pDispEx->Release(),"IScriptDispatchEx::Release()");
        }
		delete pElem;
		}

    while (!m_listEngDisp.FIsEmpty())
        {
        pBucket = static_cast<ENGDISPBUCKET *>(m_listEngDisp.PNext());
        delete pBucket;
        }
		
	m_cEngDispMac = 0;
	m_fInited = FALSE;

	return(S_OK);
	}

/*===================================================================
CScriptingNamespace::ReInit

Reinit the scripting namespace object

Returns:
	HRESULT.  S_OK on success.

Side effects:
	Frees memory
===================================================================*/
HRESULT CScriptingNamespace::ReInit()
	{
	HRESULT hr;

	hr = UnInit();
	if (SUCCEEDED(hr))
		hr = Init();

	return(hr);
	}

/*===================================================================
CScriptingNamespace::AddEngineToNamespace

Add an engine to the list of engines

Returns:
	S_OK on success
===================================================================*/
HRESULT CScriptingNamespace::AddEngineToNamespace(CActiveScriptEngine *pASE)
	{
    static const char *_pFuncName = "CScriptingNamespace::AddEngineToNamespace()";
	HRESULT hr;
	IDispatch *pDisp = NULL;
	CEngineDispElem *pElem;

	AssertValid();
	Assert(pASE != NULL);
	pASE->AssertValid();

    TRYCATCH_HR_NOHITOBJ(pASE->GetActiveScript()->GetScriptDispatch(NULL, &pDisp), 
                         hr,
                         "IActiveScript::GetScriptDispatch()");	// FYI - does addref

	if (FAILED(hr))
		{
		goto LFail;
		}
	else
		if (pDisp == NULL)
			{
			hr = E_FAIL;
			goto LFail;
			}

	// Add the engine to the engine hash table.
	pElem = new CEngineDispElem;
	if (pElem == NULL)
		{
		hr = E_OUTOFMEMORY;
		goto LFail;
		}
	pElem->m_pDisp = pDisp;
    pElem->m_pDispEx = NULL;

    // QI for IDispatchEx if available
    TRYCATCH_NOHITOBJ(pDisp->QueryInterface(IID_IDispatchEx, (void **)&pElem->m_pDispEx),"IScriptDispatch::QueryInterface()");
	
	pElem->AppendTo(m_listSE);

	return(S_OK);
	
LFail:
    if (pDisp) {
		TRYCATCH_NOHITOBJ(pDisp->Release(),"IScriptDispatch::Release()");
    }
	return(hr);
	}

/*===================================================================
CScriptingNamespace::QueryInterface
CScriptingNamespace::AddRef
CScriptingNamespace::Release

IUnknown members for CScriptingNamespace object.
===================================================================*/
STDMETHODIMP CScriptingNamespace::QueryInterface(REFIID iid, void **ppvObj)
	{
	AssertValid();

	if (iid == IID_IUnknown || iid == IID_IDispatch || iid == IID_IDispatchEx)
	    {
		*ppvObj = this;
        AddRef();
		return S_OK;
		}

	*ppvObj = NULL;
	return E_NOINTERFACE;
	}

STDMETHODIMP_(ULONG) CScriptingNamespace::AddRef(void)
	{
	AssertValid();

	return ++m_cRef;
	}

STDMETHODIMP_(ULONG) CScriptingNamespace::Release(void)
	{
	if (--m_cRef > 0)
		return m_cRef;

    delete this;
	return 0;
	}

/*===================================================================
CScriptingNamespace::GetTypeInfoCount

We have no typeinfo, so 0.

Parameters:
	pcInfo		UINT * to the location to receive
				the count of interfaces.

Return Value:
	HRESULT		 S_OK or a general error code.
===================================================================*/
STDMETHODIMP CScriptingNamespace::GetTypeInfoCount(UINT *pcInfo)
	{
	AssertValid();
	
	*pcInfo = 0;
	return S_OK;
	}

/*===================================================================
CScriptingNamespace::GetTypeInfo

We dont have a typeinfo

Parameters:
	itInfo			UINT reserved.	Must be zero.
	lcid			LCID providing the locale for the type
					information.	If the object does not support
					localization, this is ignored.
	ppITypeInfo		ITypeInfo ** in which to store the ITypeInfo
					interface for the object.

Return Value:
	HRESULT			S_OK or a general error code.
===================================================================*/
STDMETHODIMP CScriptingNamespace::GetTypeInfo
(
UINT itInfo,
LCID lcid,
ITypeInfo **ppITypeInfo
)
	{
	AssertValid();

	*ppITypeInfo = NULL;
	return(E_NOTIMPL);
	}

/*===================================================================
CScriptingNamespace::GetIDsOfNames

Looks through all the engines we know about, calling GetIdsOfNames on
them till we find the requested name.

Parameters:
	riid			REFIID reserved. Must be IID_NULL.
	rgszNames		OLECHAR ** pointing to the array of names to be mapped.
	cNames			UINT number of names to be mapped.
	lcid			LCID of the locale.
	rgDispID		DISPID * caller allocated array containing IDs
					corresponging to those names in rgszNames.

Return Value:
	HRESULT		 S_OK or a general error code.
===================================================================*/
STDMETHODIMP CScriptingNamespace::GetIDsOfNames
(
REFIID riid,
OLECHAR **rgszNames,
UINT cNames,
LCID lcid,
DISPID *rgDispID
)
	{
    static const char *_pFuncName = "CScriptingNamespace::GetIDsOfNames()";
	HRESULT hr;
	CEngineDispElem *pElem;

	AssertValid();

	if (IID_NULL != riid)
		return ResultFromScode(DISP_E_UNKNOWNINTERFACE);

	/*
	 * Loop through the engines we know about until we find the one that has the requested name
	 * (or hit the end of the list, in which case it is not found)
	 */
	for (pElem = static_cast<CEngineDispElem *>(m_listSE.PNext());
		 pElem != &m_listSE;
		 pElem = static_cast<CEngineDispElem *>(pElem->PNext()))
		{
		Assert(pElem->m_pDisp != NULL);
		
		    TRYCATCH_HR_NOHITOBJ(pElem->m_pDisp->GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispID), 
                                 hr,
                                 "IScriptDispatch::GetIDsOfNames()");
		
		if (SUCCEEDED(hr))
		    {
            return CacheDispID(pElem, rgDispID[0], rgDispID);
			}
		}

	return DISP_E_UNKNOWNNAME;
	}

/*===================================================================
CScriptingNamespace::Invoke

Map the dispID to the correct engine, and pass the invoke on to that
engine.

Parameters:
	dispID			DISPID of the method or property of interest.
	riid			REFIID reserved, must be IID_NULL.
	lcid			LCID of the locale.
	wFlags			USHORT describing the context of the invocation.
	pDispParams		DISPPARAMS * to the array of arguments.
	pVarResult		VARIANT * in which to store the result.	Is
					NULL if the caller is not interested.
	pExcepInfo		EXCEPINFO * to exception information.
	puArgErr		UINT * in which to store the index of an
					invalid parameter if DISP_E_TYPEMISMATCH
					is returned.

Return Value:
	HRESULT		 S_OK or a general error code.
===================================================================*/
STDMETHODIMP CScriptingNamespace::Invoke
(
DISPID dispID,
REFIID riid,
LCID lcid,
unsigned short wFlags,
DISPPARAMS *pDispParams,
VARIANT *pVarResult,
EXCEPINFO *pExcepInfo,
UINT *puArgErr
)
	{
    static const char *_pFuncName = "CScriptingNamespace::Invoke()";
	HRESULT hr;
    ENGDISP *pEngDisp;

	AssertValid();
	
	// riid is supposed to be IID_NULL always
	if (IID_NULL != riid)
		return ResultFromScode(DISP_E_UNKNOWNINTERFACE);

    // navigate to the correct ENGDISP structure 
    hr = FetchDispID(dispID, &pEngDisp);
    if (FAILED(hr))
        return hr;
	
	Assert(pEngDisp->pDisp != NULL);
	
    // invoke
	TRYCATCH_HR_NOHITOBJ(pEngDisp->pDisp->Invoke
	                        (
	                        pEngDisp->dispid, 
	                        riid, 
	                        lcid,
		                    wFlags, 
		                    pDispParams, 
		                    pVarResult, 
		                    pExcepInfo, 
		                    puArgErr
		                    ),
                         hr,
                         "IScriptDispatch::Invoke()");
	
	return hr;
	}

/*===================================================================
CScriptingNamespace::  IDispatchEx implementation stubs
===================================================================*/
STDMETHODIMP CScriptingNamespace::DeleteMemberByDispID(DISPID id)
    {
    return E_NOTIMPL;
    }
    
STDMETHODIMP CScriptingNamespace::DeleteMemberByName(BSTR bstrName, DWORD grfdex)
    {
    return E_NOTIMPL;
    }
    
STDMETHODIMP CScriptingNamespace::GetMemberName(DISPID id, BSTR *pbstrName)
    {
    return E_NOTIMPL;
    }
    
STDMETHODIMP CScriptingNamespace::GetMemberProperties(DISPID id, DWORD grfdexFetch, DWORD *pgrfdex)
    {
    return E_NOTIMPL;
    }
    
STDMETHODIMP CScriptingNamespace::GetNameSpaceParent(IUnknown **ppunk)
    {
    return E_NOTIMPL;
    }
    
STDMETHODIMP CScriptingNamespace::GetNextDispID(DWORD grfdex, DISPID id, DISPID *pid)
    {
    return E_NOTIMPL;
    }
    
/*===================================================================
CScriptingNamespace::GetDispID

IDispatchEx replacement for GetIDsOfNames
===================================================================*/
STDMETHODIMP CScriptingNamespace::GetDispID
(
BSTR bstrName, 
DWORD grfdex, 
DISPID *pid
)
    {
    static const char *_pFuncName = "CScriptingNamespace::GetDispID()";
    HRESULT hr;
	CEngineDispElem *pElem = NULL;
    grfdex &= ~fdexNameEnsure;  // engines shouldn't create new names

    // Try IDispatchEx for all engines that have it
    
	for (pElem = static_cast<CEngineDispElem *>(m_listSE.PNext());
		 pElem != &m_listSE;
		 pElem = static_cast<CEngineDispElem *>(pElem->PNext()))
		{
		if (pElem->m_pDispEx != NULL)
		    {
		    TRYCATCH_HR_NOHITOBJ(pElem->m_pDispEx->GetDispID(bstrName, grfdex, pid), 
                                 hr,
                                 "IScriptDispatchEx::GetDispID()");
		    
    		if (SUCCEEDED(hr))
	    	    {
                return CacheDispID(pElem, *pid, pid);
			    }
		    }
		}

    // Try IDispatch for engines that don't have IDispatchEx
	for (pElem = static_cast<CEngineDispElem *>(m_listSE.PNext());
		 pElem != &m_listSE;
		 pElem = static_cast<CEngineDispElem *>(pElem->PNext()))
		{
		if (pElem->m_pDispEx == NULL)
		    {
    		Assert(pElem->m_pDisp != NULL);
    		TRYCATCH_HR_NOHITOBJ(pElem->m_pDisp->GetIDsOfNames
            		                (
    	        	                IID_NULL,
    		                        &bstrName,
    		                        1,
    		                        LOCALE_SYSTEM_DEFAULT,
    		                        pid
    		                        ),
                                 hr,
                                 "IScriptDispatch::GetIDsOfNames()");
    		    
    		if (SUCCEEDED(hr))
	    	    {
                return CacheDispID(pElem, *pid, pid);
			    }
		    }
		}
	
	return DISP_E_UNKNOWNNAME;
    }
    
/*===================================================================
CScriptingNamespace::Invoke

IDispatchEx replacement for Invoke
===================================================================*/
STDMETHODIMP CScriptingNamespace::InvokeEx
(
DISPID id, 
LCID lcid, 
WORD wFlags, 
DISPPARAMS *pdp,
VARIANT *pVarRes,    
EXCEPINFO *pei,    
IServiceProvider *pspCaller 
)
    {
    static const char *_pFuncName = "CScriptingNamespace::InvokeEx()";
	HRESULT hr;
    ENGDISP *pEngDisp;

    // navigate to the correct ENGDISP structure 
    hr = FetchDispID(id, &pEngDisp);
    if (FAILED(hr))
        return hr;
	
    if (pEngDisp->pDispEx != NULL)
        {
        // InvokeEx if the engine supports IDispatchEx
        
    	TRYCATCH_HR_NOHITOBJ(pEngDisp->pDispEx->InvokeEx
    	                            (
    	                            pEngDisp->dispid, 
                                    lcid, 
                                    wFlags, 
                                    pdp,
                                    pVarRes,    
                                    pei,    
                                    pspCaller 
    	                            ),
                             hr,
                             "IScriptDispatchEx::InvokeEx()");
        }
    else
        {
        // use IDispatch::Invoke if the engine doesn't support IDispatchEx
    	Assert(pEngDisp->pDisp != NULL);

    	UINT uArgErr;
        
    	TRYCATCH_HR_NOHITOBJ(pEngDisp->pDisp->Invoke
    	                            (
    	                            pEngDisp->dispid, 
    	                            IID_NULL, 
    	                            lcid,
    		                        wFlags, 
    		                        pdp, 
    		                        pVarRes, 
    		                        pei, 
    		                        &uArgErr
    		                        ),
                             hr,
                             "IScriptDispatch::Invoke()");
	    }
	
	return hr;
    }

/*===================================================================
CScriptingNamespace::CacheDispID

Adds new DISPID to the list

Parameters
    pEngine         -- engine for which disp id found
    dispidEngine    -- found dispid
    pdispidCached   -- [out] cached dispid (for ScriptingNamespace)

Returns
    HRESULT    
===================================================================*/
HRESULT CScriptingNamespace::CacheDispID
(
CEngineDispElem *pEngine,
DISPID dispidEngine,
DISPID *pdispidCached
)
	{
	ENGDISPBUCKET *pEngDispBucket;
	
	// See if we need to add another bucket
	if ((m_cEngDispMac % ENGDISPMAX) == 0)
		{
		pEngDispBucket = new ENGDISPBUCKET;
		if (pEngDispBucket == NULL)
			return E_OUTOFMEMORY;

		pEngDispBucket->AppendTo(m_listEngDisp);
		}

    // Navigate to the correct bucket
	unsigned iEngDisp = m_cEngDispMac;
	pEngDispBucket = static_cast<ENGDISPBUCKET *>(m_listEngDisp.PNext());
	while (iEngDisp > ENGDISPMAX)
		{
		iEngDisp -= ENGDISPMAX;
		pEngDispBucket = static_cast<ENGDISPBUCKET *>(pEngDispBucket->PNext());
		}

	pEngDispBucket->rgEngDisp[iEngDisp].dispid  = dispidEngine;
	pEngDispBucket->rgEngDisp[iEngDisp].pDisp   = pEngine->m_pDisp;
	pEngDispBucket->rgEngDisp[iEngDisp].pDispEx = pEngine->m_pDispEx;

	// Return index as the dispid
	*pdispidCached = (DISPID)m_cEngDispMac;
	m_cEngDispMac++;
	return S_OK;
	}
    
/*===================================================================
CScriptingNamespace::FetchDispID

Find ENGDISP by DISPID

Parameters
    dispid      - in
    ppEngDisp   - out

Returns
    HRESULT    
===================================================================*/
HRESULT CScriptingNamespace::FetchDispID
(
DISPID dispid, 
ENGDISP **ppEngDisp
)
    {
	if (dispid >= (DISPID)m_cEngDispMac)
	    return E_FAIL;

	unsigned iEngDisp = dispid;
	ENGDISPBUCKET *pEngDispBucket = static_cast<ENGDISPBUCKET *>(m_listEngDisp.PNext());
	while (iEngDisp > ENGDISPMAX)
		{
		iEngDisp -= ENGDISPMAX;
		pEngDispBucket = static_cast<ENGDISPBUCKET *>(pEngDispBucket->PNext());
		}

    *ppEngDisp = &pEngDispBucket->rgEngDisp[iEngDisp];
    return S_OK;
    }
    

#ifdef DBG
/*===================================================================
CScriptingNamespace::AssertValid

Test to make sure that the CScriptingNamespace object is currently correctly formed
and assert if it is not.

Returns:

Side effects:
	None.
===================================================================*/
VOID CScriptingNamespace::AssertValid() const
	{
	Assert(m_fInited);
	Assert(m_cRef > 0);
	}
	
#endif // DBG



/*
 *
 *
 * U t i l i t i e s
 *
 * General utility functions
 *
 */



/*===================================================================
WrapTypeLibs

Utility routine to take an array of Typelibs, and return an IDispatch
implementation that wraps the array of typelibs.

Parameters:
    ITypeLib **prgpTypeLib  - pointer to an array of typelibs
    UINT cTypeLibs          - count of typelibs in array
    IDispatch **ppDisp      - returned IDispatch

Return Value:
	HRESULT		 S_OK or a general error code.
===================================================================*/
HRESULT WrapTypeLibs
(
ITypeLib **prgpTypeLib,
UINT cTypeLibs,
IDispatch **ppDisp
)
	{
	HRESULT hr;
	Assert(g_pWrapTypelibs != NULL);
	Assert(prgpTypeLib != NULL);
	Assert(cTypeLibs > 0);
	Assert(ppDisp != NULL);

    hr = g_pWrapTypelibs->WrapTypeLib(prgpTypeLib, cTypeLibs, ppDisp);
    
	return(hr);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\sessmgr.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Session Manager

File: Sessmgr.h

Owner: PramodD

This is the session manager header file.
===================================================================*/
#ifndef SESSMGR_H
#define SESSMGR_H

#include "debug.h"
#include "idhash.h"
#include "idgener.h"
#include "compcol.h"
#include "request.h"
#include "response.h"
#include "server.h"
#include "viperint.h"
#include "ftm.h"
#include "memcls.h"

/*===================================================================
  #defines
===================================================================*/

// Min/Max session timeout in minutes
#define SESSION_TIMEOUT_MIN		        1		// 1 minute
#define SESSION_TIMEOUT_MAX		        1440	// 1 day

// Master hash table sizes
#define SESSION_MASTERHASH_SIZE1_MAX    499
#define SESSION_MASTERHASH_SIZE2_MAX    31
#define SESSION_MASTERHASH_SIZE3_MAX    13

// Timeout bucket hash tables sizes
#define SESSION_TIMEOUTHASH_SIZE1_MAX   97
#define SESSION_TIMEOUTHASH_SIZE2_MAX   29
#define SESSION_TIMEOUTHASH_SIZE3_MAX   11

// Min/Max # of timeout buckets (hash tables)
#define SESSION_TIMEOUTBUCKETS_MIN      10
#define SESSION_TIMEOUTBUCKETS_MAX      45

// max value of GetTickCount()
#define	DWT_MAX 0xFFFFFFFF

// session killer workitem default wait
#define MSEC_ONE_MINUTE     60000   // 1 min

#include "asptlb.h"

/*===================================================================
  Forward declarations
===================================================================*/

class CAppln;
class CHitObj;
class CSession;

/*===================================================================
  C S e s s i o n V a r i a n t s
===================================================================*/
class CSessionVariants : public IVariantDictionary
	{
private:
    ULONG               m_cRefs;            // ref count
	CSession *			m_pSession;			// pointer to parent object
	CompType            m_ctColType;        // collection type
	CSupportErrorInfo	m_ISupportErrImp;	// implementation of ISupportErr

	HRESULT ObjectNameFromVariant(VARIANT &vKey, WCHAR **ppwszName, 
	                              BOOL fVerify = FALSE);

public:
	CSessionVariants();
	~CSessionVariants();

	HRESULT Init(CSession *pSession, CompType ctColType);
	HRESULT UnInit();

	// The Big Three

	STDMETHODIMP		 QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

	// OLE Automation Interface

	STDMETHODIMP get_Item(VARIANT VarKey, VARIANT *pvar);
	STDMETHODIMP put_Item(VARIANT VarKey, VARIANT var);
	STDMETHODIMP putref_Item(VARIANT VarKey, VARIANT var);
	STDMETHODIMP get_Key(VARIANT VarKey, VARIANT *pvar);
	STDMETHODIMP get__NewEnum(IUnknown **ppEnumReturn);
	STDMETHODIMP get_Count(int *pcValues);
	STDMETHODIMP Remove(VARIANT VarKey);
	STDMETHODIMP RemoveAll();
	
    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};

/*===================================================================
  C  S e s s i o n  I D
===================================================================*/
struct CSessionId
    {
	DWORD m_dwId;	// Session Id
	DWORD m_dwR1;	// Session Id random element 1
	DWORD m_dwR2;	// Session Id random element 2

    CSessionId(DWORD dwId = INVALID_ID, DWORD dwR1 = 0, DWORD dwR2 = 0);
    };

inline CSessionId::CSessionId(DWORD dwId, DWORD dwR1, DWORD dwR2)
    {
    m_dwId = dwId;
    m_dwR1 = dwR1;
    m_dwR2 = dwR2;
    }

/*===================================================================
  C  S e s s i o n
===================================================================*/
class CSession : public ISessionObjectImpl, public CFTMImplementation
    {

friend class CSessionMgr;
friend class CSessionVariants;

private:

    //========= Misc flags
    
	DWORD m_fInited : 1;		  // Are we initialized?
	DWORD m_fLightWeight : 1;     // Is in lightweight form?
	DWORD m_fOnStartFailed : 1;	  // Session_OnStart failed?
	DWORD m_fOnStartInvoked : 1;  // Session_OnStart invoked?
	DWORD m_fOnEndPresent : 1;    // Need to invoke Session_OnEnd ?
	DWORD m_fTimedOut : 1;        // Session timed out?
	DWORD m_fStateAcquired : 1;   // Any property set (!m_fCanDelete)?
	DWORD m_fCustomTimeout : 1;   // Timeout different from standard?
	DWORD m_fAbandoned : 1;       // Session abandoned?
	DWORD m_fTombstone : 1;       // ASP is done with the session?
	DWORD m_fInTOBucket : 1;      // Session in a timeout bucket?
	DWORD m_fSessCompCol : 1;     // Component collection present?
	DWORD m_fSecureSession : 1;   //  Is the session used over a secure line?
    DWORD m_fCodePageSet : 1;     // CodePage explicitly set?
    DWORD m_fLCIDSet     : 1;     // LCID explicitly set?

	//========= Pointers to related objects
	
	CAppln  *m_pAppln;    // Session's Application
	CHitObj *m_pHitObj;   // Session's current HitObj
	
	//========= Session's dictionaries for presenting component collection
	
	CSessionVariants *m_pTaggedObjects;
	CSessionVariants *m_pProperties;

    //========= Session data

    CSessionId m_Id;        // Session ID + 2 random keys
    DWORD m_dwExternId;     // Session ID to be given out (Session.ID)

    DWORD m_cRefs;          // Ref count
	DWORD m_cRequests;      // Requests count

	// Timeout when current time (in minutes) reaches this
	// The timeout bucket is current_time mod #_of_buckets
	DWORD m_dwmTimeoutTime;
	
	long  m_lCodePage;	    // Code page for this session
	LCID  m_lcid;			// LCID for this session
	long  m_nTimeout;       // Current time value in minutes

	// to make session elem in the timeout bucket
	CObjectListElem m_TOBucketElem;
	
#ifndef PERF_DISABLE
    DWORD m_dwtInitTimestamp; // Timestamp of session creation for PERFMON
#endif

	//========= Session's Component Collection

	// to avoid the memory fragmentation component collection is
	// aggregated here. its validity is indicated by m_fSessCompCol flag
	CComponentCollection m_SessCompCol;  // Session scope objects
	
	//========= Viper Activity of this Session
	
	CViperActivity m_Activity;

	//========= Intrinsics for this Session
	
	CRequest    m_Request;
	CResponse   m_Response;
	CServer     m_Server;

	//========= SupportErrorInfo
	
	// Interface to indicate that we support ErrorInfo reporting
    CSupportErrorInfo m_ISuppErrImp;

public:	
	CSession();
	~CSession();

	HRESULT Init(CAppln *pAppln, const CSessionId &Id);

    // Convert to tombstone state
    HRESULT UnInit();

	// Convert to 'light-weight' state if possible
	HRESULT MakeLightWeight();

	// Create/Remove Session's component collection
	HRESULT CreateComponentCollection();
	HRESULT RemoveComponentCollection();

    // Check if the session should be deleted
    BOOL FShouldBeDeletedNow(BOOL fAtEndOfRequest);

	// Non-delegating object IUnknown
	STDMETHODIMP		 QueryInterface(REFIID, void **);
	STDMETHODIMP_(ULONG) AddRef();
	STDMETHODIMP_(ULONG) Release();

    // Tombstone stub
	HRESULT CheckForTombstone();

	// ISessionObject functions
	STDMETHODIMP get_SessionID(BSTR *pbstrRet);
	STDMETHODIMP get_Timeout(long *plVar);
	STDMETHODIMP put_Timeout(long lVar);
	STDMETHODIMP get_CodePage(long *plVar);
	STDMETHODIMP put_CodePage(long lVar);
	STDMETHODIMP get_Value(BSTR bstr, VARIANT FAR * pvar);
	STDMETHODIMP put_Value(BSTR bstr, VARIANT var);
	STDMETHODIMP putref_Value(BSTR bstr, VARIANT var);
	STDMETHODIMP Abandon();
	STDMETHODIMP get_LCID(long *plVar);
	STDMETHODIMP put_LCID(long lVar);
	STDMETHODIMP get_StaticObjects(IVariantDictionary **ppDictReturn);
	STDMETHODIMP get_Contents(IVariantDictionary **ppDictReturn);

	// inline methods to access member properties
	CAppln                *PAppln();
	CHitObj               *PHitObj();
	CComponentCollection  *PCompCol();
	CViperActivity        *PActivity();
	CRequest              *PRequest();
	CResponse             *PResponse();
	CServer               *PServer();
	BOOL                   FCustomTimeout();
	BOOL                   FAbandoned();
	DWORD                  GetId();
	BOOL                   FInTOBucket();
	LCID				   GetLCID();
    long                   GetCodePage();
	DWORD                  GetTimeoutTime();
	BOOL                   FSecureSession(); 


    // inline methods to set member properties
	void    SetHitObj(CHitObj *pHitObj);
	void    SetOnStartFailedFlag();
	void    SetOnStartInvokedFlag();
	void    SetOnEndPresentFlag();
	HRESULT SetLCID(LCID lcid);
	
    // Misc inline methods
	DWORD   IncrementRequestsCount();
	DWORD   DecrementRequestsCount();
    DWORD   GetRequestsCount();
    BOOL    FCanDeleteWithoutExec();
    BOOL    FHasObjects();
	BOOL    FPassesIdSecurityCheck(DWORD dwR1, DWORD dwR2);
    void    AssignNewId(const CSessionId &Id);
    void    SetSecureSession(BOOL fSecure); 
    BOOL    FCodePageSet();
    BOOL    FLCIDSet();

    // AssertValid()
public:
#ifdef DBG
	virtual void AssertValid() const;
#else
	virtual void AssertValid() const {}
#endif

    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()

	// Trace Log info -- keep in both free & checked builds so that ntsd extension will work for both builds
	// for FREE build, trace log is always NULL.  Checked builds, it must be enabled.
	static PTRACE_LOG gm_pTraceLog;
    };

/*===================================================================
  C  S e s s i o n   inlines
===================================================================*/

inline CAppln *CSession::PAppln()
    {
    Assert(m_fInited);
    return m_pAppln;
    }
    
inline CHitObj *CSession::PHitObj()
    {
    Assert(m_fInited);
    return m_pHitObj;
    }
    
inline CComponentCollection  *CSession::PCompCol()
    {
    Assert(m_fInited);
    return (m_fSessCompCol ? &m_SessCompCol : NULL);
    }
    
inline CViperActivity *CSession::PActivity()
    {
    Assert(m_fInited);
    return &m_Activity;
    }

inline CRequest *CSession::PRequest()
    {
    Assert(m_fInited);
    return &m_Request;
    }
    
inline CResponse *CSession::PResponse()
    {
    Assert(m_fInited);
    return &m_Response;
    }
    
inline CServer *CSession::PServer()
    {
    Assert(m_fInited);
    return &m_Server;
    }

inline BOOL CSession::FCustomTimeout()
    {
    Assert(m_fInited);
    return m_fCustomTimeout;
    }
    
inline BOOL CSession::FAbandoned()
    {
    Assert(m_fInited);
    return m_fAbandoned;
    }
    
inline DWORD CSession::GetId()
    {
    Assert(m_fInited);
    return m_Id.m_dwId;
    }

inline BOOL CSession::FInTOBucket()
    {
    Assert(m_fInited);
    return m_fInTOBucket;
    }

inline LCID CSession::GetLCID()
    {
    Assert(m_fInited);
    return (UINT)m_lcid;
    }

inline long CSession::GetCodePage()
{
    Assert(m_fInited);
    return m_lCodePage == 0 ? GetACP() : m_lCodePage;
}

inline BOOL CSession::FCodePageSet()
{
    Assert(m_fInited);
    return (m_fCodePageSet);
}

inline BOOL CSession::FLCIDSet()
{
    Assert(m_fInited);
    return (m_fLCIDSet);
}

inline DWORD CSession::GetTimeoutTime()
    {
    Assert(m_fInited);
    return m_dwmTimeoutTime;
    }


inline BOOL CSession::FSecureSession()
    {
    Assert(m_fInited);
    return m_fSecureSession;
    }

inline void CSession::SetHitObj(CHitObj *pHitObj)
    {
    Assert(m_fInited);
    Assert(pHitObj ? (m_pHitObj == NULL) : (m_pHitObj != NULL));
    m_pHitObj = pHitObj;
    }
    
inline void CSession::SetOnStartFailedFlag()
    {
    Assert(m_fInited);
    m_fOnStartFailed = TRUE;
    }
    
inline void CSession::SetOnStartInvokedFlag()
    {
    Assert(m_fInited);
    m_fOnStartInvoked = TRUE;
    }

inline void CSession::SetOnEndPresentFlag()
    {
    Assert(m_fInited);
    m_fOnEndPresent = TRUE;
    }
    
inline HRESULT CSession::SetLCID(LCID lcid)
    {
    Assert(m_fInited);
	if ((LOCALE_SYSTEM_DEFAULT == lcid) || IsValidLocale(lcid, LCID_INSTALLED))
	    {
	    m_lcid = lcid; 
	    return S_OK;
	    }
	 else
	    {
	    return E_FAIL;
	    }
    }

inline DWORD CSession::IncrementRequestsCount()
    {
    Assert(m_fInited);
    return InterlockedIncrement((LPLONG)&m_cRequests);
    }
    
inline DWORD CSession::DecrementRequestsCount()
    {
    Assert(m_fInited);
    return InterlockedDecrement((LPLONG)&m_cRequests);
    }
    
inline DWORD CSession::GetRequestsCount()
    {
    Assert(m_fInited);
    return m_cRequests;
    }
    
inline BOOL CSession::FCanDeleteWithoutExec()
    {
    // Return TRUE to delete CSession right away or FALSE to
    // post Viper request to execute Session_OnEnd()
	return (m_fOnStartFailed || !m_fOnEndPresent);
	}

inline BOOL CSession::FHasObjects()
    {
    return m_fSessCompCol && m_SessCompCol.FHasObjects();
    }
    
inline BOOL CSession::FPassesIdSecurityCheck(DWORD dwR1, DWORD dwR2)
    {
    Assert(m_fInited);
    return (m_Id.m_dwR1 == dwR1 && m_Id.m_dwR2 == dwR2);
    }

inline void CSession::AssignNewId(const CSessionId &Id)
    {
    Assert(m_fInited);
	m_Id = Id;
    }


inline void CSession::SetSecureSession(BOOL fSecure)
    {
    Assert(m_fInited);
    m_fSecureSession = fSecure;
    }

/*===================================================================
  C  S e s s i o n  M g r
===================================================================*/

class CSessionMgr
    {
private:
    // Flags
	DWORD m_fInited : 1;	            // Are we initialized?

    // Application
	CAppln *m_pAppln;

	// Sessions master hash table
	CIdHashTableWithLock m_htidMaster;

	// Number of posted Session Cleanup requests
	DWORD m_cSessionCleanupRequests;

	// Timeout buckets
	DWORD m_cTimeoutBuckets;
	CObjectListWithLock *m_rgolTOBuckets;

    // Session killer scheduler workitem
    DWORD m_idSessionKiller;    // workitem id

    DWORD m_dwmCurrentTime; // current time in minutes since start
    DWORD m_dwtNextSessionKillerTime;  // next session killer time

public:
	CSessionMgr();
	~CSessionMgr();

    // Init/Unit
	HRESULT	Init(CAppln *pAppln);
	HRESULT	UnInit();

    // Add/remove session killer workitem
    HRESULT ScheduleSessionKiller();
    HRESULT UnScheduleSessionKiller();
    BOOL    FIsSessionKillerScheduled();

    // Lock/Unlock master hash table
	HRESULT LockMaster();
    HRESULT UnLockMaster();
    
    // Lock/Unlock a timeout bucket hash table
	HRESULT LockTOBucket(DWORD iBucket);
    HRESULT UnLockTOBucket(DWORD iBucket);

    // Get current time in minute ticks
    DWORD GetCurrentTime();
    // Set the time when the session should be gone
    HRESULT UpdateSessionTimeoutTime(CSession *pSession);
    // Calculate which timeout bucket the session's in
    DWORD GetSessionTOBucket(CSession *pSession);

    // Generate new ID and cookie
    HRESULT GenerateIdAndCookie(CSessionId *pId, char *pszCookie);

    // Create new session object
    HRESULT NewSession(const CSessionId &Id, CSession **ppSession);

    // Reassign session's Id (reinsert session into master hash)
    HRESULT ChangeSessionId(CSession *pSession, const CSessionId &Id);
   
    // Master hash table manipulations
    HRESULT AddToMasterHash(CSession *pSession);
    HRESULT RemoveFromMasterHash(CSession *pSession);
    HRESULT FindInMasterHash(const CSessionId &Id, CSession **ppSession);

    // Insert/remove session into the timeout bucket hash table
    HRESULT AddSessionToTOBucket(CSession *pSession);
    HRESULT RemoveSessionFromTOBucket(CSession *pSession, BOOL fLock = TRUE);

    // Delete session now or queue for deletion
    HRESULT DeleteSession(CSession *pSession, BOOL fInSessActivity = FALSE);

    // Delete expired sessions from a given bucket
    HRESULT DeleteExpiredSessions(DWORD iBucket);

    // Delete all sessions (application shut-down code)
    HRESULT DeleteAllSessions(BOOL fForce);
    // Static iterator call back to delete all sessions
    static IteratorCallbackCode DeleteAllSessionsCB(void *, void *, void *);

    // The Session Killer 
    static VOID WINAPI SessionKillerSchedulerCallback(VOID *pv);

    // Incr/Decr/Get number of posted Session Cleanup requests
    void  IncrementSessionCleanupRequestCount();
    void  DecrementSessionCleanupRequestCount();
    DWORD GetNumSessionCleanupRequests();

    // AssertValid()
public:
#ifdef DBG
	virtual void AssertValid() const;
#else
	virtual void AssertValid() const {}
#endif
	};

inline BOOL CSessionMgr::FIsSessionKillerScheduled()
    {
    return (m_idSessionKiller != 0);
    }
    
inline HRESULT CSessionMgr::LockMaster()
    {
    m_htidMaster.Lock();
    return S_OK;
    }
    
inline HRESULT CSessionMgr::UnLockMaster()
    {
    m_htidMaster.UnLock();
    return S_OK;
    }
    
inline HRESULT CSessionMgr::LockTOBucket(DWORD iBucket)
    {
    Assert(m_rgolTOBuckets);
    Assert(iBucket < m_cTimeoutBuckets);
    m_rgolTOBuckets[iBucket].Lock();
    return S_OK;
    }
    
inline HRESULT CSessionMgr::UnLockTOBucket(DWORD iBucket)
    {
    Assert(m_rgolTOBuckets);
    Assert(iBucket < m_cTimeoutBuckets);
    m_rgolTOBuckets[iBucket].UnLock();
    return S_OK;
    }

inline DWORD CSessionMgr::GetCurrentTime()
    {
    return m_dwmCurrentTime;
    }

inline HRESULT CSessionMgr::UpdateSessionTimeoutTime(CSession *pSession)
    {
    Assert(pSession);

    // remember when the session times out
    pSession->m_dwmTimeoutTime =
        m_dwmCurrentTime + pSession->m_nTimeout + 1;

    return S_OK;    
    }

inline DWORD CSessionMgr::GetSessionTOBucket(CSession *pSession)
    {
    Assert(pSession->m_fInited);
    return (pSession->m_dwmTimeoutTime % m_cTimeoutBuckets);
    }

inline HRESULT CSessionMgr::AddToMasterHash(CSession *pSession)
    {
    Assert(m_fInited);
 	return m_htidMaster.AddObject(pSession->GetId(), pSession);
    }
    
inline HRESULT CSessionMgr::RemoveFromMasterHash(CSession *pSession)
    {
    Assert(m_fInited);
	return m_htidMaster.RemoveObject(pSession->GetId());
    }

inline void CSessionMgr::IncrementSessionCleanupRequestCount()
    {
    InterlockedIncrement((LPLONG)&m_cSessionCleanupRequests);
    }
    
inline void CSessionMgr::DecrementSessionCleanupRequestCount()
    {
    InterlockedDecrement((LPLONG)&m_cSessionCleanupRequests);
    }

inline DWORD CSessionMgr::GetNumSessionCleanupRequests()
    {
    return m_cSessionCleanupRequests;
    }

/*===================================================================
  G l o b a l s
===================================================================*/

// There are multiple session managers (one per application)
// The following variables are 1 per ASP.DLL

extern unsigned long g_nSessions;
extern CIdGenerator  g_SessionIdGenerator;
extern CIdGenerator  g_ExposedSessionIdGenerator;     

#endif // SESSMGR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\scrptmgr.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Script Manager

File: ScrptMgr.h

Owner: AndrewS

This file contains the declarations for the Script Manager, ie. siting an
ActiveX Scripting engine (in our case VBScript) for Denali.
===================================================================*/

#ifndef __ScrptMgr_h
#define __ScrptMgr_h

#include <dispex.h>

#include "activscp.h"
#include "activdbg.h"
#include "hostinfo.h"
#include "util.h"
#include "HitObj.h"
#include "hashing.h"
#include "memcls.h"
#include "scrpteng.h"


typedef SCRIPTSTATE ENGINESTATE;	// Uninited, Loaded, etc
typedef CLSID PROGLANG_ID;
const CBPROGLANG_ID = sizeof(PROGLANG_ID);

class CActiveScriptSite;
class CActiveScriptEngine;
class CASEElem;
class CScriptingNamespace;
class CAppln;

// SMHash depends on stuff in this include file which must be defined first.
#include "SMHash.h"

/*
 *
 *
 * C S c r i p t M a n a g e r
 *
 *
 * Manages script engines, potentially caching them for future use,
 * hands script engines to callers for use.
 *
 */
class CScriptManager
	{
private:
	// private data members
	BOOLB m_fInited;				// Are we initialized?

	/*
	 * Script Engines that are not in use can be reused and 
	 * go on the Free Script Queue.  It is a queue so we can
	 * discard the oldest if we need to.
	 *
	 * Engines that are in use cant be reused.  When an engine
	 * is handed out to be used, it is removed from the FSQ.  When a thread
	 * is done using an engine, it calls ReturnEngineToCache to put it back on
	 * the FSQ.  If the Queue is at max length, the oldest engine on the queue is
	 * freed at that point.  The one returned is put on the front of the queue.
	 *
	 * We also maintain a Running Script List.  This is needed so that if we 
	 * are told to flush a given script from our cache, we can "zombify" any
	 * running scripts that have that script in them (so they will be discarded
	 * when they are done running.)
	 *
	 * Additional note: Though we cant have multiple users of the *same* runing engine
	 * we can "clone" a running engine.  If we get two simulanteous requests for Foo.ASP
	 * we expect that it will be faster to clone the second one from the first one than
	 * to create a second engine for the second request.  Thus, the RSL will be searched
	 * for a given engine to clone if no suitable engine is found on the FSQ.
	 *
	 * DEBUGGING NOTE:
	 *    Once the debugger asks a script engine for a code context cookie, we cannot
	 *    ever let go of the script engine until the debugger detaches.  Therefore, we
	 *    don't cache scripts in the FSQ if debugging is active.  Instead, the scripts
	 *    are placed in the template when execution is finished, there to be doled back
	 *    out when that engine is needed by the debugging engine.
	 *
	 *    CONSIDER:
	 *       We could be smarter about this, and cache scripts UNTIL the debugger either
	 *          a. Asks for a code context from a document context, or
	 *          b. Calls GetDocumentContextFromPosition, in which case, the debugger
	 *             got a code context "behind our virtual backs".
	 *
	 *       If we don't do this, we could, at the very least, only implement this
	 *       debugging behavior when a debugger attaches to our application.
	 *       (i.e. stop caching on attach, then on detach, resume caching, and also
	 *        free scripts that the template objects are holding onto.)
	 */
	CSMHash m_htFSQ;				// Free Script Queue
	CRITICAL_SECTION m_csFSQ;		// Serialize access to FSQ
	CSMHash m_htRSL;				// Running Script List
	CRITICAL_SECTION m_csRSL;		// Serialize access to RSL

	CHashTable 		m_hTPLL;		// Hash table of language engine classid's
	CRITICAL_SECTION m_cSPLL;		// Serialize access to PLL

	DWORD m_idScriptKiller;         // Script killer sched workitem id
	DWORD m_msecScriptKillerTimeout;// Current script killer timeout

	// private methods
	HRESULT UnInitASEElems();
	HRESULT UnInitPLL();
	HRESULT AddProgLangToPLL(CHAR *szProgLangName, PROGLANG_ID progLangId);

    // script killer
	static VOID WINAPI ScriptKillerSchedulerCallback(VOID *pv);

public:	
	// public methods
	CScriptManager();
	~CScriptManager();

	HRESULT Init();
	HRESULT UnInit();

	// Resolves a language name into a prog lang id, adding to engine list (m_hTPLL) if not already there
	HRESULT ProgLangIdOfLangName(LPCSTR szProgLang, PROGLANG_ID *pProgLangId);

	// Return an engine, preferably filled with the script for the given template/language
	HRESULT GetEngine(	LCID lcid,					// The system language to use
						PROGLANG_ID& progLangId,	// prog lang id of the script
						LPCTSTR szTemplateName,		// Template we want an engine for
						CHitObj *pHitObj,			// Hit obj to use in this engine
						CScriptEngine **ppSE,		// Returned script engine
						ENGINESTATE *pdwState,		// Current state of the engine
						CTemplate *pTemplate,		// template (debug document)
						DWORD dwSourceContext);		// script engine index

	HRESULT ReturnEngineToCache(CScriptEngine **, CAppln *);

	// Throw out any cached engines containing a given template
	// (presumably the script changed on disk so the cache is obsolete.)
	HRESULT FlushCache(LPCTSTR szTemplateName);	// Template to throw out of the cache

	HRESULT FlushAll();    // Clear the entire FSQ

	HRESULT KillOldEngines(BOOLB fKillNow = FALSE); // Kill expired scripting engines

	// Bug 1140: Called prior to shutting down script manager to make sure RSL is empty
	HRESULT EmptyRunningScriptList();

    // Adjust (shorten) script killer timeout
    HRESULT AdjustScriptKillerTimeout(DWORD msecNewTimeout);

	// Find running script that corresponds to a template (in one of its script blocks)
	IActiveScriptDebug *GetDebugScript(CTemplate *pTemplate, DWORD dwSourceContext);

private:
	HRESULT FindEngineInList(LPCTSTR szTemplateName, PROGLANG_ID progLangId, DWORD dwInstanceID, BOOL fFSQ, CASEElem **ppASEElem);
	HRESULT FindASEElemInList(CActiveScriptEngine *pASE, BOOL fFSQ, CASEElem **ppASEElem);

	// For threading a FIFO queue through the hash table
	HRESULT AddToFSQ(CASEElem *pASEElem);
	HRESULT CheckFSQLRU();

#ifdef DBG
	virtual void AssertValid() const;
#else
	virtual void AssertValid() const {}
#endif
	};

extern CScriptManager g_ScriptManager;


/*
 *
 *
 * C A c t i v e S c r i p t E n g i n e
 *
 * Object defining methods required to host an ActiveXScripting engine &
 * service requests to that engine.
 *
 */
class CActiveScriptEngine :
				public CScriptEngine,
				public IActiveScriptSite,
				public IActiveScriptSiteDebug,
				public IHostInfoProvider
	{
private:
	// private data members
	UINT m_cRef;				// Reference count
	IDispatch *m_pDisp;			// IDispatch interface on script
	CHitObj *m_pHitObj;			// The hit object contains a list of objects for this run
	LPTSTR m_szTemplateName;	// The name of the template this engine has loaded
	DWORD m_dwInstanceID;		// server instance ID of template this engine has loaded
	TCHAR m_szTemplateNameBuf[64]; // Buffer for short templates to fit to avoid allocs
	PROGLANG_ID m_proglang_id;	// What programming language?
	LCID m_lcid;				// what system language
	IActiveScript *m_pAS;		// The script object sited here
	IActiveScriptParse *m_pASP;	// The script object parser
	IHostInfoUpdate *m_pHIUpdate;// Interface for advising the script that we have new host info
	time_t m_timeStarted;		// Time when the script engine was handed out last.
	CTemplate *m_pTemplate;		// template that acts as debugging document
	DWORD m_dwSourceContext;	// "Cookie" value which is really script engine
	DWORD m_fInited : 1;		// Have we been inited?
	DWORD m_fZombie : 1;		// Do we need to be deleted on last use
	DWORD m_fScriptLoaded : 1;	// Have we been called with script to load yet? (Used for clone)
	DWORD m_fObjectsLoaded : 1;	// Have we been called with a set of objects yet? (Used for clone)
	DWORD m_fBeingDebugged : 1;	// Is this script being debugged now?
	DWORD m_fTemplateNameAllocated : 1; // Is name allocated? (need to free?)

	/*
	 * NOTE: ActiveXScripting:
	 * ActiveXScripting had an undone such that the excepinfo filled in in InteruptScript
	 * was not passed to OnScriptError.  We would have liked to use that mechanism to cause
	 * correct error loging (or suppression) if we interrupt a script.  However,
	 * since ActiveXScripting wasnt passing the info, we didnt know.  We wrote this code to 
	 * handle it ourselves.  They have now fixed it, but the mechanism we implemented works very
	 * well, so we are not going to change it.
	 */
	DWORD m_fScriptAborted : 1;		// The script did a Response.End
	DWORD m_fScriptTimedOut : 1;	// We killed the script on timeout
	DWORD m_fScriptHadError : 1;	// The script had an error while running.  Transacted script should autoabort

	/*
	 * BUG 1225: If there is a GPF running a script, we shouldnt reuse the engine
	 */
	DWORD m_fCorrupted : 1;		// Might the engine be "unsafe" for reuse?

    // handle GetItemInfo() failure
	void HandleItemNotFound(LPCOLESTR pcszName);

	HRESULT StoreTemplateName(LPCTSTR szTemplateName);

public:
	CActiveScriptEngine();
	~CActiveScriptEngine();

	HRESULT Init(
				PROGLANG_ID proglang_id,
				LPCTSTR szTemplateName,
				LCID lcid,
				CHitObj *pHitObj,
				CTemplate *pTemplate,
				DWORD dwSourceContext);

	HRESULT MakeClone(
				PROGLANG_ID proglang_id,
				LPCTSTR szTemplateName,
				LCID lcid,
				CHitObj *pHitObj,
				CTemplate *pTemplate,
				DWORD dwSourceContext,
				DWORD dwInstanceID,
				IActiveScript *pAS);			// The cloned script engine

	HRESULT ReuseEngine(
						CHitObj *pHitObj,
						CTemplate *pTemplate,
						DWORD dwSourceContext,
						DWORD dwInstanceID
						);

	time_t TimeStarted();
	VOID SetTimeStarted(time_t timeStarted);

	BOOL FBeingDebugged();			// Is the script being debugged?
	VOID IsBeingDebugged();			// Notify script that it is being debugged

	HRESULT ResetToUninitialized();
	HRESULT GetASP();
	HRESULT GetIDisp();
	HRESULT GetIHostInfoUpdate();
	IActiveScript *GetActiveScript();
	LPTSTR SzTemplateName();
	BOOL FIsZombie();
	BOOL FIsCorrupted();
	PROGLANG_ID ProgLang_Id();
	DWORD DWInstanceID();
	BOOL FFullyLoaded();
	long GetTimeout();
	BOOL FScriptTimedOut();
	BOOL FScriptHadError();
	void GetDebugDocument(CTemplate **ppTemplate, DWORD *pdwSourceContext);


	/*
	 * C S c r i p t E n g i n e   M e t h o d s
	 */
	HRESULT AddScriptlet(LPCOLESTR wstrScript);

	HRESULT AddObjects(BOOL fPersistNames = TRUE);

	HRESULT AddAdditionalObject(LPWSTR strObjName, BOOL fPersistNames = TRUE);

	HRESULT AddScriptingNamespace();
	
	HRESULT Call(LPCOLESTR strEntryPoint);

	HRESULT CheckEntryPoint(LPCOLESTR strEntryPoint);

	HRESULT MakeEngineRunnable()  { return(Call(NULL)); };

	HRESULT ResetScript() { return m_pAS? m_pAS->SetScriptState(SCRIPTSTATE_UNINITIALIZED) : E_FAIL; }

	VOID Zombify();

	HRESULT InterruptScript(BOOL fAbnormal = TRUE);

	HRESULT UpdateLocaleInfo(hostinfo hi);

	HRESULT TryCall(LPCOLESTR strEntryPoint);

	ULONG FinalRelease();

	/*
	 * I U n k n o w n   M e t h o d s
	 */
	STDMETHOD(QueryInterface)(REFIID riid, PVOID *ppvObject);
	STDMETHOD_(ULONG, AddRef)(VOID);
	STDMETHOD_(ULONG, Release)(VOID);

	/*
	 * C A c t i v e S c r i p t S i t e   M e t h o d s
	 */
	STDMETHOD(GetLCID)(LCID *plcid);

	STDMETHOD(GetItemInfo)(LPCOLESTR pcszName,
							DWORD dwReturnMask,
							IUnknown **ppiunkItem,
							ITypeInfo **ppti);

	STDMETHOD(GetDocVersionString)(BSTR *pszVersion);

	STDMETHOD(RequestItems)(BOOL fPersistNames = TRUE);

	STDMETHOD(RequestTypeLibs)(VOID);

	STDMETHOD(OnScriptTerminate)(const VARIANT *pvarResult,
								const EXCEPINFO *pexcepinfo);
	STDMETHOD(OnStateChange)(SCRIPTSTATE ssScriptState);

	STDMETHOD(OnScriptError)(IActiveScriptError __RPC_FAR *pscripterror);

	STDMETHOD(OnEnterScript)(VOID);

	STDMETHOD(OnLeaveScript)(VOID);

	/*
	 * C A c t i v e S c r i p t S i t e D e b u g   M e t h o d s
	 */
	STDMETHOD(GetDocumentContextFromPosition)(
			/* [in] */ DWORD_PTR dwSourceContext,
			/* [in] */ ULONG uCharacterOffset,
			/* [in] */ ULONG uNumChars,
			/* [out] */ IDebugDocumentContext **ppsc);

	STDMETHOD(GetApplication)(/* [out] */ IDebugApplication **ppda);

	STDMETHOD(GetRootApplicationNode)(/* [out] */ IDebugApplicationNode **);

	STDMETHOD(OnScriptErrorDebug)(
			/* [in] */ IActiveScriptErrorDebug *pErrorDebug,
			/* [out] */ BOOL *pfEnterDebugger,
			/* [out] */ BOOL *pfCallOnScriptErrorWhenContinuing);
        
        
	/*
	 * IHostInfoProvider methods
	 */

	 STDMETHOD(GetHostInfo)(hostinfo hostinfoRequest, void **ppvInfo);

public:
#ifdef DBG
	virtual void AssertValid() const;
#else
	virtual void AssertValid() const {}
#endif

	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };

inline VOID CActiveScriptEngine::Zombify() { m_fZombie = TRUE; }
inline BOOL CActiveScriptEngine::FFullyLoaded() { return(m_fScriptLoaded && m_fObjectsLoaded); }
inline BOOL CActiveScriptEngine::FIsZombie() { return(m_fZombie); }
inline BOOL CActiveScriptEngine::FIsCorrupted() { return(m_fCorrupted); }
inline time_t CActiveScriptEngine::TimeStarted() { return(m_timeStarted); }
inline VOID CActiveScriptEngine::SetTimeStarted(time_t timeStarted) { m_timeStarted = timeStarted; }
inline IActiveScript *CActiveScriptEngine::GetActiveScript() { return(m_pAS); }
inline LPTSTR CActiveScriptEngine::SzTemplateName() { return(m_szTemplateName); }
inline PROGLANG_ID CActiveScriptEngine::ProgLang_Id() { return(m_proglang_id); }
inline DWORD CActiveScriptEngine::DWInstanceID() { return(m_dwInstanceID); }
inline BOOL CActiveScriptEngine::FBeingDebugged() { return(m_fBeingDebugged); }			// Is the script being debugged?
inline VOID CActiveScriptEngine::IsBeingDebugged() { m_fBeingDebugged = TRUE; }
inline BOOL CActiveScriptEngine::FScriptTimedOut() { return m_fScriptTimedOut; }
inline BOOL CActiveScriptEngine::FScriptHadError() { return m_fScriptHadError; }
inline long CActiveScriptEngine::GetTimeout() { return m_fBeingDebugged? LONG_MAX : m_pHitObj->GetScriptTimeout(); }
inline void CActiveScriptEngine::GetDebugDocument(CTemplate **ppTemplate, DWORD *pdwSourceContext)
	{
	if (ppTemplate) *ppTemplate = m_pTemplate;
	if (pdwSourceContext) *pdwSourceContext = m_dwSourceContext;
	}

/*
 *
 *
 * C A S E E l e m
 *
 * Script element.  For keeping lists and queues of script engines
 *
 */
class CASEElem : public CLruLinkElem
	{
private:
	CActiveScriptEngine *m_pASE;

public:
	CASEElem() : m_pASE(NULL) {}
	~CASEElem();

	HRESULT Init(CActiveScriptEngine *pASE);
	CActiveScriptEngine *PASE();
	
	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};

inline CActiveScriptEngine *CASEElem::PASE() { return(m_pASE); }


/*
 *
 *
 * C P L L E l e m
 *
 * Hash table list element for a Programming Language List.
 *
 */
class CPLLElem : public CLinkElem
	{
private:
	PROGLANG_ID m_ProgLangId;			// clsid for the language
	
public:
	CPLLElem() : m_ProgLangId(CLSID_NULL) {};
	~CPLLElem();

	HRESULT Init(CHAR *szProgLangName, PROGLANG_ID progLangId);
	PROGLANG_ID ProgLangId();
	};

inline PROGLANG_ID CPLLElem::ProgLangId() { return(m_ProgLangId); }


/*
 *
 *
 * C S c r i p t i n g N a m e s p a c e
 *
 * We need to keep track of all of the names which different engines (and typeinfos)
 * contribute to the namespace.   All of these names go into this object
 * which we give to each engine with the SCRIPTITEM_GLOBALMEMBERS flag. When
 * ActiveXScripting calls us back on GetIdsOfNames, we will call the engines
 * we have cached until we find the name.  When AXS calls us with Invoke,
 * we will map the id to the appropriate engine and pass on the invoke
 *
 * Data structure note:
 *   We implement the ScriptingNamespace with a linked list of arrays.
 *   This gives reasonable access time and should minimize heap
 *   fragmentation.  In debug mode, the number of buckets is small to
 *   excersize the resize code.
 *
 * NOTE: "ENGDISPMAX" should be a power of two - this will allow the optimizer
 *       to optimize the integer divide and modulus operations with bit-ands and
 *       shifts.  However, the code does not assume that "ENGDISPMAX" is a power
 *       of two.
 */

#ifdef DBG
#define ENGDISPMAX 2
#else
#define ENGDISPMAX 32
#endif

typedef struct _engdisp
	{
	DISPID dispid;				// the dispid that the engine really uses
	IDispatch *pDisp;			// the engine to call for this dispid
	IDispatchEx *pDispEx;	    // the engine to call for this dispid
	} ENGDISP;

typedef struct _engdispbucket : CDblLink
	{
	ENGDISP rgEngDisp[ENGDISPMAX+1];
	} ENGDISPBUCKET;

class CEngineDispElem : public CDblLink
	{
public:
	IDispatch *m_pDisp;
	IDispatchEx *m_pDispEx;
	
	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};

class CScriptingNamespace : public IDispatchEx
	{
private:
	ULONG m_cRef;				// Reference count
	BOOLB m_fInited;
	CDblLink m_listSE;			// List of scripting engines (list of CSEElem's)
	UINT m_cEngDispMac;
	CDblLink m_listEngDisp;

    HRESULT CacheDispID(CEngineDispElem *pEngine, DISPID dispidEngine, DISPID *pdispidCached);
    HRESULT FetchDispID(DISPID dispid, ENGDISP **ppEngDisp);

public:
	// public methods
	CScriptingNamespace();
	~CScriptingNamespace();

	HRESULT Init();
	HRESULT UnInit();
	HRESULT ReInit();
	HRESULT AddEngineToNamespace(CActiveScriptEngine *pASE);

    // IUnknown
	STDMETHODIMP QueryInterface(REFIID, void **);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);
    // IDispatch
	STDMETHODIMP GetTypeInfoCount(UINT *);
	STDMETHODIMP GetTypeInfo(UINT, LCID, ITypeInfo **);
	STDMETHODIMP GetIDsOfNames(REFIID, OLECHAR **, UINT, LCID, DISPID *);
	STDMETHODIMP Invoke(DISPID, REFIID, LCID, WORD,
						DISPPARAMS *, VARIANT *, EXCEPINFO *, UINT *);
    // IDispatchEx
    STDMETHODIMP DeleteMemberByDispID(DISPID id);
    STDMETHODIMP DeleteMemberByName(BSTR bstrName, DWORD grfdex);
    STDMETHODIMP GetMemberName(DISPID id, BSTR *pbstrName);
    STDMETHODIMP GetMemberProperties(DISPID id, DWORD grfdexFetch, DWORD *pgrfdex);
    STDMETHODIMP GetNameSpaceParent(IUnknown **ppunk);
    STDMETHODIMP GetNextDispID(DWORD grfdex, DISPID id, DISPID *pid);
    STDMETHODIMP GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid);
    STDMETHODIMP InvokeEx(DISPID id, LCID lcid, WORD wFlags, DISPPARAMS *pdp,
                          VARIANT *pVarRes, EXCEPINFO *pei, IServiceProvider *pspCaller);

public:
#ifdef DBG
	VOID AssertValid() const;
#else
	VOID AssertValid() const {}
#endif

	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};


/*
 *
 *
 * U t i l i t i e s
 *
 * General utility functions
 *
 */
HRESULT WrapTypeLibs(ITypeLib **prgpTypeLib, UINT cTypeLibs, IDispatch **ppDisp);

#endif // __ScrptMgr_h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\server.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Server object

File: Server.cpp

Owner: CGrant

This file contains the code for the implementation of the Server object.
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "Server.h"
#include "tlbcache.h"
#include "memchk.h"

/*
 *
 * C S e r v e r
 *
 */

/*===================================================================
CServer::CServer

Constructor

Parameters:
    punkOuter   object to ref count (can be NULL)
					
Returns:
===================================================================*/
CServer::CServer(IUnknown *punkOuter)
    :
	m_fInited(FALSE),
	m_fDiagnostics(FALSE),
    m_pData(NULL)
	{
	CDispatch::Init(IID_IServer);

    if (punkOuter)
        {
        m_punkOuter = punkOuter;
        m_fOuterUnknown = TRUE;
        }
    else
        {
        m_cRefs = 1;
        m_fOuterUnknown = FALSE;
        }
	
#ifdef DBG
	m_fDiagnostics = TRUE;
#endif // DBG
	}

/*===================================================================
CServer::~CServer

Destructor

Parameters:
					
Returns:
===================================================================*/
CServer::~CServer()
    {
	Assert(!m_fInited);
    Assert(m_fOuterUnknown || m_cRefs == 0);  // must have 0 ref count
    }
    
/*===================================================================
CServer::Init

Allocates m_pData.
Performs any intiailization of a CServer that's prone to failure
that we also use internally before exposing the object outside.

Parameters:
	None
					
Returns:
	S_OK on success.
===================================================================*/

HRESULT CServer::Init()
	{
	if (m_fInited)
	    return S_OK; // already inited
	    
	Assert(!m_pData);

    m_pData = new CServerData;
    if (!m_pData)
        return E_OUTOFMEMORY;

	m_pData->m_pIReq = NULL;
	m_pData->m_pHitObj = NULL;
	
	m_pData->m_ISupportErrImp.Init(static_cast<IServer *>(this), 
	            static_cast<IServer *>(this), 
	            IID_IServer);
	    
	m_fInited = TRUE;
	return S_OK;
	}
	
/*===================================================================
CServer::UnInit

Remove m_pData. Make tombstone (UnInited state).

Parameters:
					
Returns:
    HRESULT (S_OK)
===================================================================*/
HRESULT CServer::UnInit()
	{
	if (!m_fInited)
	    return S_OK; // already uninited

	Assert(m_pData);
    delete m_pData;
    m_pData = NULL;

    m_fInited = FALSE;
	return S_OK;
	}

/*===================================================================
CServer::ReInit

The only need for a re-init here is to update the CIsapiReqInfo
for this request, the CIsapiReqInfo is required to access the
MapPath Method. Ideally this method should be part of the Request 
object

Parameters:
	CIsapiReqInfo *
	CHitObj *
					
Returns:
	S_OK on success.

===================================================================*/
HRESULT CServer::ReInit
(
CIsapiReqInfo * pIReq,
CHitObj *pHitObj
)
	{
	Assert(m_fInited);
	Assert(m_pData);
	
	m_pData->m_pIReq	   = pIReq;
	m_pData->m_pHitObj = pHitObj;
	return S_OK;
	}

/*===================================================================
CServer::MapPathInternal

Map virtual path BSTR into single char buffer
Used by MapPath(), Execute(), Transfer()

Parameters:
    dwContextId     for error messages
    wszVirtPath     path to translate
    szPhysPath      [out] translate into this buffer (MAX_PATH sized)
    szVirtPath      [out, optional] mb virtual path buffer (MAX_PATH sized)
					
Returns:
	S_OK on success.
===================================================================*/
HRESULT CServer::MapPathInternal
(
DWORD dwContextId, 
WCHAR *wszVirtPath, 
TCHAR *szPhysPath,
TCHAR *szVirtPath
)
    {
	// increment the pointer past leading white spaces
	wchar_t *wszLogicalPath = wszVirtPath;
	while (iswspace(*wszLogicalPath))
		++wszLogicalPath;

	unsigned cchLogicalPath = wcslen(wszLogicalPath);
	if (cchLogicalPath > MAX_PATH-1)
		{
		if (dwContextId)
    		ExceptionId(IID_IServer, dwContextId, IDE_SERVER_EXCEDED_MAX_PATH);
		return E_FAIL;
		}

	else if (cchLogicalPath == 0)
		{
		if (dwContextId)
    		ExceptionId(IID_IServer, dwContextId, IDE_SERVER_MAPPATH_INVALID_STR);
		return E_FAIL;
		}		

	// Is this a physical path?
	if (iswalpha(wszLogicalPath[0]) && wszLogicalPath[1] == L':')
		{		
		if (dwContextId)
    		ExceptionId(IID_IServer, dwContextId, IDE_SERVER_MAPPATH_PHY_STR);
		return E_FAIL;
		}

	// simple validation: look for invalid characters in string [*?<>,;:'"]
	// and multiple slash characters ie "//" or "\\"
	//
	BOOL fParentPath = FALSE;
	BOOL fEnableParentPaths = m_pData->m_pHitObj->QueryAppConfig()->fEnableParentPaths();
	BOOL fAnyBackslashes = FALSE;
	wchar_t *pwchT = wszLogicalPath;
	while (*pwchT != L'\0')
		{
		switch (*pwchT)
			{
			case L'*': case L':': case L'?': case L'<': 
			case L'>': case L',': case L'"': 
        		if (dwContextId)
		    		ExceptionId( IID_IServer, dwContextId, IDE_SERVER_MAPPATH_INVALID_CHR);
				return E_FAIL;

			case L'.': 				
				if (*++pwchT == L'.') 
					{
					if (!fEnableParentPaths)
						{
                		if (dwContextId)
   				    		ExceptionId(IID_IServer, dwContextId, IDE_SERVER_MAPPATH_INVALID_CHR3);
   						return E_FAIL;
   						}
   					else
   						{
   						fParentPath = TRUE;
   						++pwchT;
   						}
   					}
				break;
	
			case L'\\':
			    fAnyBackslashes = TRUE;
			case L'/': 
				++pwchT;
				if (*pwchT == '/' || *pwchT == '\\')
					{
            		if (dwContextId)
   			    		ExceptionId(IID_IServer, dwContextId, IDE_SERVER_MAPPATH_INVALID_CHR2);
   					return E_FAIL;
					}
				break;

			default:
				++pwchT;
			}
		}

	// whew! Error handling done!
	// Convert wszLogicalPath to multi-byte

    TCHAR szLogicalPath[MAX_PATH];
#if UNICODE
    wcscpy(szLogicalPath, wszLogicalPath);
#else 
    HRESULT hr;
    CWCharToMBCS    convStr;

    if (hr = convStr.Init(wszLogicalPath)) {
        if ((hr == E_OUTOFMEMORY) && dwContextId)
    		ExceptionId(IID_IServer, dwContextId, IDE_OOM);
        return hr;
    }
    
    if (convStr.GetStringLen() > (MAX_PATH-1)) {
		if (dwContextId)
    		ExceptionId(IID_IServer, dwContextId, IDE_SERVER_EXCEDED_MAX_PATH);
		return E_FAIL;
    }
    strcpy(szLogicalPath,convStr.GetString());
#endif

    // change all backslashes to forward slashes
	if (fAnyBackslashes)
	    {
	    TCHAR *pbBackslash = szLogicalPath;
	    while (pbBackslash = _tcschr(pbBackslash, _T('\\')))
	        *pbBackslash = _T('/');
	    }

	// is this a Relative path request. I.E. no leading slash
	// if so prepend the path_info string to szLogicalPath

	BOOL fPathAlreadyIsMapped = FALSE;		// Some cases map the path earlier
	if (szLogicalPath[0] != _T('/'))
		{
		TCHAR szParentPath[MAX_PATH];
		_tcscpy(szParentPath, m_pData->m_pIReq->QueryPszPathInfo());

		// Trim off the ASP file name from the PATH_INFO
		TCHAR *pchT = _tcsrchr(szParentPath, _T('/'));
		if (pchT != NULL) *pchT = '\0';

		// If there were parent paths, map the parent now, then append the relative path
		// the relative path to the parent path
		if (fParentPath)
			{
			Assert (fEnableParentPaths);			// Errors should have been flagged upstairs
			DWORD dwPathSize = sizeof(szParentPath);
			if (! m_pData->m_pIReq->MapUrlToPath(szParentPath, &dwPathSize))
				{
        		if (dwContextId)
		    		ExceptionId(IID_IServer,
			    				dwContextId,
				    			::GetLastError() == ERROR_INSUFFICIENT_BUFFER? IDE_SERVER_EXCEDED_MAX_PATH : IDE_SERVER_MAPPATH_FAILED);
				return E_FAIL;
				}

			fPathAlreadyIsMapped = TRUE;
			}

		// Resolve relative paths
		if (! DotPathToPath(szLogicalPath, szLogicalPath, szParentPath))
			{
    		if (dwContextId)
	    		ExceptionId(IID_IServer, dwContextId, IDE_SERVER_MAPPATH_FAILED);
			return E_FAIL;
			}
		}

    // return virtual path if requested
	if (szVirtPath)
	    _tcscpy(szVirtPath, szLogicalPath);

	// Map this to a physical file name (if required)
	if (!fPathAlreadyIsMapped)
		{
		DWORD dwPathSize = sizeof(szLogicalPath);
		if (! m_pData->m_pIReq->MapUrlToPath(szLogicalPath, &dwPathSize))
			{
    		if (dwContextId)
	    		ExceptionId(IID_IServer,
		    				dwContextId,
			    			::GetLastError() == ERROR_INSUFFICIENT_BUFFER? IDE_SERVER_EXCEDED_MAX_PATH : IDE_SERVER_MAPPATH_FAILED);
			return E_FAIL;
			}
		}

	// remove any ending delimiters (unless it's the root directory. The root always starts with drive letter)
	TCHAR *pchT = CharPrev(szLogicalPath, szLogicalPath + _tcslen(szLogicalPath));
	if ((*pchT == _T('/') || *pchT == _T('\\')) && pchT[-1] != _T(':'))
		{
		*pchT = _T('\0');
		}

	// Replace forward slash with back slash
	for (pchT = szLogicalPath; *pchT != _T('\0'); ++pchT)
	    {
		if (*pchT == _T('/'))
			*pchT = _T('\\');
        }

    _tcscpy(szPhysPath, szLogicalPath);
	return S_OK;
    }

/*===================================================================
CServer::QueryInterface
CServer::AddRef
CServer::Release

IUnknown members for CServer object.
===================================================================*/
STDMETHODIMP CServer::QueryInterface
(
REFIID riid,
PPVOID ppv
)
	{
	*ppv = NULL;

	/*
	 * The only calls for IUnknown are either in a nonaggregated
	 * case or when created in an aggregation, so in either case
	 * always return our IUnknown for IID_IUnknown.
	 */

	// BUG FIX 683 added IID_IDenaliIntrinsic to prevent the user from 
	// storing intrinsic objects in the application and session object

	if (IID_IUnknown == riid ||
		IID_IDispatch == riid ||
		IID_IServer == riid ||
		IID_IDenaliIntrinsic == riid)
		*ppv = static_cast<IServer *>(this);

	//Indicate that we support error information
	if (IID_ISupportErrorInfo == riid)
	    {
	    if (m_pData)
    		*ppv = & (m_pData->m_ISupportErrImp);
		}

    if (IID_IMarshal == riid)
        {
        *ppv = static_cast<IMarshal *>(this);
        }

	//AddRef any interface we'll return.
	if (NULL != *ppv)
		{
		((LPUNKNOWN)*ppv)->AddRef();
		return S_OK;
		}

	return E_NOINTERFACE;
	}

STDMETHODIMP_(ULONG) CServer::AddRef()
	{
	if (m_fOuterUnknown)
	    return m_punkOuter->AddRef();
	    
	return InterlockedIncrement((LPLONG)&m_cRefs);
	}

STDMETHODIMP_(ULONG) CServer::Release()
	{
	if (m_fOuterUnknown)
	    return m_punkOuter->Release();
	    
    DWORD cRefs = InterlockedDecrement((LPLONG)&m_cRefs);
	if (cRefs)
		return cRefs;

	delete this;
	return 0;
	}

/*===================================================================
CServer::GetIDsOfNames

Special-case implementation for CreateObject, Execute, Transfer

Parameters:
	riid			REFIID reserved. Must be IID_NULL.
	rgszNames		OLECHAR ** pointing to the array of names to be mapped.
	cNames			UINT number of names to be mapped.
	lcid			LCID of the locale.
	rgDispID		DISPID * caller allocated array containing IDs
					corresponging to those names in rgszNames.

Return Value:
	HRESULT		 S_OK or a general error code.
===================================================================*/
STDMETHODIMP CServer::GetIDsOfNames
(
REFIID riid,
OLECHAR **rgszNames,
UINT cNames,
LCID lcid,
DISPID *rgDispID
)
    {
    const DISPID dispidCreateObject = 0x60020002;
    const DISPID dispidExecute      = 0x60020007;
    const DISPID dispidTransfer     = 0x60020008;

    if (cNames == 1)
        {
        switch (rgszNames[0][0])
            {
        case L'C':
        case L'c':
            if (wcsicmp(rgszNames[0]+1, L"reateobject") == 0)
                {
                *rgDispID = dispidCreateObject;
                return S_OK;
                }
            break;

        case L'E':
        case L'e':
            if (wcsicmp(rgszNames[0]+1, L"xecute") == 0)
                {
                *rgDispID = dispidExecute;
                return S_OK;
                }
            break;
        
        case L'T':
        case L't':
            if (wcsicmp(rgszNames[0]+1, L"ransfer") == 0)
                {
                *rgDispID = dispidTransfer;
                return S_OK;
                }
            break;
            }
        }
        
    // default to CDispatch's implementation
    return CDispatch::GetIDsOfNames(riid, rgszNames, cNames, lcid, rgDispID);
    }

/*===================================================================
CServer::CheckForTombstone

Tombstone stub for IServer methods. If the object is
tombstone, does ExceptionId and fails.

Parameters:
    
Returns:
	HRESULT     E_FAIL  if Tombstone
	            S_OK if not
===================================================================*/
HRESULT CServer::CheckForTombstone()
    {
    if (m_fInited)
        {
        // inited - good object
        Assert(m_pData); // must be present for inited objects
        return S_OK;
        }
        
	ExceptionId
	    (
	    IID_IServer, 
	    IDE_SERVER, 
	    IDE_INTRINSIC_OUT_OF_SCOPE
	    );
    return E_FAIL;
    }

/*===================================================================
CServer::CreateObject

Parameters: BSTR containing ProgID
			Variant to fillin with IUknown pointer

Returns: S_OK if successful E_FAIL otherwise

Side effects:
	Creates an instance of an ole automation object
===================================================================*/
STDMETHODIMP CServer::CreateObject(BSTR bstrProgID, IDispatch **ppDispObj)
	{
    if (FAILED(CheckForTombstone()))
        return E_FAIL;
        
    if (bstrProgID == NULL)
        {
        ExceptionId(IID_IServer, IDE_SERVER, IDE_EXPECTING_STR);
        return E_FAIL;
        }

    Assert(m_pData->m_pHitObj);
        
	*ppDispObj = NULL;

    HRESULT hr;
    CLSID clsid;

	if (Glob(fEnableTypelibCache))
	    {
	    // Use typelib cache to create the component
	    
        hr = g_TypelibCache.CreateComponent
                (
                bstrProgID,
                m_pData->m_pHitObj,
                ppDispObj,
                &clsid
                );

    	if (FAILED(hr) && clsid == CLSID_NULL)
            {
            // bad prog id or something
    		ExceptionId(IID_IServer, IDE_SERVER, IDE_SERVER_CREATEOBJ_FAILED, hr);
    	    return hr;
            }
	    }
	else
	    {
	    // Don't use typelib cache
	    
    	hr = CLSIDFromProgID((LPCOLESTR)bstrProgID, &clsid);
    	if (FAILED(hr))
    	    {
    		ExceptionId(IID_IServer, IDE_SERVER, IDE_SERVER_CREATEOBJ_FAILED, hr);
    	    return hr;
    	    }
    	    
        hr = m_pData->m_pHitObj->CreateComponent(clsid, ppDispObj);
        }
        
    if (SUCCEEDED(hr))
        return S_OK;

    // Check if a custom error was already posted
    IErrorInfo *pErrInfo = NULL;
    if (GetErrorInfo(0, &pErrInfo) == S_OK && pErrInfo)
        {
		SetErrorInfo(0, pErrInfo);
        pErrInfo->Release();
        }
    // Standard errors
	else if (hr == E_ACCESSDENIED)
		ExceptionId(IID_IServer, IDE_SERVER, IDE_SERVER_CREATEOBJ_DENIED);
	else
	    {
	    if (hr == REGDB_E_CLASSNOTREG)
    	    {
    		BOOL fInProc;
            if (SUCCEEDED(CompModelFromCLSID(clsid, NULL, &fInProc)) && !fInProc)
            	{
        		ExceptionId(IID_IServer, IDE_SERVER, IDE_SERVER_CREATEOBJ_NOTINPROC);
            	}
    	    }
    	else
    		ExceptionId(IID_IServer, IDE_SERVER, IDE_SERVER_CREATEOBJ_FAILED, hr);
    	}
    return hr;
    }
	
/*===================================================================
CServer::MapPath

Return the physical path translated from a logical path

Parameters:
	BSTR		bstrLogicalPath
	BSTR FAR *	pbstrPhysicalPath

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CServer::MapPath(BSTR bstrLogicalPath, BSTR FAR * pbstrPhysicalPath)
	{	
	if (FAILED(CheckForTombstone()))
        return E_FAIL;

	// Bug 1361: error if no CIsapiReqInfo (presumably called during
	//           Application_OnEnd or Session_OnEnd)
	if (m_pData->m_pIReq == NULL)
		{
		ExceptionId(IID_IServer, IDE_SERVER_MAPPATH, IDE_SERVER_INVALID_CALL);
		return E_FAIL;
		}

	AssertValid();
	Assert (pbstrPhysicalPath != NULL);
	*pbstrPhysicalPath = NULL;

    // use MapPathInternal() to do the mapping
	TCHAR szLogicalPath[MAX_PATH];
    HRESULT  hr = MapPathInternal(IDE_SERVER_MAPPATH, bstrLogicalPath, szLogicalPath);
    if (FAILED(hr))
        return hr;

#if UNICODE
    *pbstrPhysicalPath = SysAllocString(szLogicalPath);
    if (*pbstrPhysicalPath == NULL) {
		ExceptionId(IID_IServer, IDE_SERVER_MAPPATH, IDE_OOM);
		return E_FAIL;
    }
#else
	// Convert the path to wide character
	if (FAILED(SysAllocStringFromSz(szLogicalPath, 0, pbstrPhysicalPath, CP_ACP))) {
		ExceptionId(IID_IServer, IDE_SERVER_MAPPATH, IDE_OOM);
		return E_FAIL;
		}
#endif
	return S_OK;
	}

/*===================================================================
CServer::HTMLEncode

Encodes a string to HTML standards

Parameters:
	BSTR		bstrIn			value: string to be encoded
	BSTR FAR *	pbstrEncoded	value: pointer to HTML encoded version of string

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CServer::HTMLEncode ( BSTR bstrIn, BSTR FAR * pbstrEncoded )
	{	
    if (FAILED(CheckForTombstone()))
        return E_FAIL;
        
	char*	        pszstrIn 			= NULL;	
	char*	        pszEncodedstr		= NULL;
	char*	        pszStartEncodestr	= NULL;
	int		        nbstrLen 			= 0;
	int		        nstrLen				= 0;
	HRESULT	        hr					= S_OK;
	UINT 	        uCodePage			= m_pData->m_pHitObj->GetCodePage();
    CWCharToMBCS    convIn;

    STACK_BUFFER( tempHTML, 2048 );

	if (bstrIn)
		nbstrLen = wcslen(bstrIn);
	else
		nbstrLen = 0;

	if (nbstrLen <= 0)
		return S_OK;

    if (FAILED(hr = convIn.Init(bstrIn, uCodePage))) {
        if (hr == E_OUTOFMEMORY)
			ExceptionId( IID_IServer, IDE_SERVER, IDE_OOM);
        goto L_Exit;
    }

    pszstrIn = convIn.GetString();
				
	nstrLen = HTMLEncodeLen(pszstrIn, uCodePage, bstrIn);
	
	if (nstrLen > 0)
		{
		
		//Encode string	, NOTE this function returns a pointer to the
		// NULL so you need to keep a pointer to the start of the string
		//

        if (!tempHTML.Resize(nstrLen + 2)) {
			ExceptionId( IID_IServer, IDE_SERVER, IDE_OOM);
			hr = E_FAIL;
			goto L_Exit;
        }

        pszEncodedstr = (char*)tempHTML.QueryPtr();

		pszStartEncodestr	= pszEncodedstr;
		pszEncodedstr = ::HTMLEncode( pszEncodedstr, pszstrIn, uCodePage, bstrIn);
	
		// convert result to bstr
		//
		if (FAILED(SysAllocStringFromSz(pszStartEncodestr, 0, pbstrEncoded, uCodePage)))
			{
			ExceptionId( IID_IServer, IDE_SERVER, IDE_OOM);
			hr = E_FAIL;
			goto L_Exit;
			}
		}

	L_Exit:
			
	return hr;
	}


/*===================================================================
CServer::URLEncode

Encodes a query string to URL standards

Parameters:
	BSTR		bstrIn			value: string to be URL encoded
	BSTR FAR *	pbstrEncoded	value: pointer to URL encoded version of string

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CServer::URLEncode ( BSTR bstrIn, BSTR FAR * pbstrEncoded )
	{	
    if (FAILED(CheckForTombstone()))
        return E_FAIL;
        
	char*	        pszstrIn 			= NULL;	
	char*	        pszEncodedstr		= NULL;
	char*	        pszStartEncodestr	= NULL;
	int		        nbstrLen 			= 0;
	int		        nstrLen				= 0;
	HRESULT	        hr					= S_OK;
    CWCharToMBCS    convIn;

    STACK_BUFFER( tempURL, 256 );

	if (bstrIn)
		nbstrLen = wcslen(bstrIn);
	else
		nbstrLen = 0;

	if (nbstrLen <= 0)
		return S_OK;

    if (FAILED(hr = convIn.Init(bstrIn, m_pData->m_pHitObj->GetCodePage()))) {
        if (hr == E_OUTOFMEMORY)
			ExceptionId( IID_IServer, IDE_SERVER, IDE_OOM);
        goto L_Exit;
    }
	
    pszstrIn = convIn.GetString();
				
	nstrLen = URLEncodeLen(pszstrIn);
	if (nstrLen > 0)
		{
		
		//Encode string	, NOTE this function returns a pointer to the
		// NULL so you need to keep a pointer to the start of the string
		//

        if (!tempURL.Resize(nstrLen + 2)) {
			ExceptionId( IID_IServer, IDE_SERVER, IDE_OOM);
			hr = E_FAIL;
			goto L_Exit;
        }

        pszEncodedstr = (char *)tempURL.QueryPtr();

		pszStartEncodestr	= pszEncodedstr;
		pszEncodedstr = ::URLEncode( pszEncodedstr, pszstrIn );
	
		// convert result to bstr
		//
		if (FAILED(SysAllocStringFromSz(pszStartEncodestr, 0, pbstrEncoded)))
			{
			ExceptionId( IID_IServer, IDE_SERVER, IDE_OOM);
			hr = E_FAIL;
			goto L_Exit;
			}
		}

	L_Exit:
	
	return hr;
	}

/*===================================================================
CServer::URLPathEncode

Encodes the path portion of a URL or a full URL.  All characters
up to the first '?' are encoded with the following rules:
	o Charcters that are needed to parse the URL are left alone
	o RFC 1630 safe characters are left alone
	o Non-foreign alphanumberic characters are left alone
	o Anything else is escape encoded
Everything after the '?' is not encoded.

Parameters:
	BSTR		bstrIn			value: string to be URL path encoded
	BSTR FAR *	pbstrEncoded	value: pointer to URL path encoded version of string

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CServer::URLPathEncode ( BSTR bstrIn, BSTR FAR * pbstrEncoded )
	{	
    if (FAILED(CheckForTombstone()))
        return E_FAIL;
        
	char*	        pszstrIn 			= NULL;	
	char*	        pszEncodedstr		= NULL;
	char*	        pszStartEncodestr	= NULL;
	int		        nbstrLen 			= 0;
	int		        nstrLen				= 0;
	HRESULT	        hr					= S_OK;
    CWCharToMBCS    convIn;

    STACK_BUFFER( tempPath, 256 );

	if (bstrIn)
		nbstrLen = wcslen(bstrIn);
	else
		nbstrLen = 0;

	if (nbstrLen <= 0)
		return S_OK;

    if (FAILED(hr = convIn.Init(bstrIn, m_pData->m_pHitObj->GetCodePage()))) {
        if (hr == E_OUTOFMEMORY)
			ExceptionId( IID_IServer, IDE_SERVER, IDE_OOM);
        goto L_Exit;
    }
    
    pszstrIn = convIn.GetString();
				
	nstrLen = URLPathEncodeLen(pszstrIn);
	if (nstrLen > 0)
		{
		
		//Encode string	, NOTE this function returns a pointer to the
		// NULL so you need to keep a pointer to the start of the string
		//

        if (!tempPath.Resize(nstrLen+2)) {
			ExceptionId( IID_IServer, IDE_SERVER, IDE_OOM);
			hr = E_FAIL;
			goto L_Exit;
        }

        pszEncodedstr = (char *)tempPath.QueryPtr();

		pszStartEncodestr	= pszEncodedstr;
		pszEncodedstr = ::URLPathEncode( pszEncodedstr, pszstrIn );
	
		// convert result to bstr
		//
		if (FAILED(SysAllocStringFromSz(pszStartEncodestr, 0, pbstrEncoded)))
			{
			ExceptionId( IID_IServer, IDE_SERVER, IDE_OOM);
			hr = E_FAIL;
			goto L_Exit;
			}
		}

	L_Exit:
	
	return hr;
	}

/*===================================================================
CServer::get_ScriptTimeout

Will return the script timeout interval (in seconds)

Parameters:
	long *plTimeoutSeconds

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CServer::get_ScriptTimeout( long * plTimeoutSeconds )
{
    if (FAILED(CheckForTombstone()))
        return E_FAIL;
        
	if (m_pData->m_pHitObj == NULL)
		{
		ExceptionId(IID_IServer, IDE_SERVER_MAPPATH, IDE_SERVER_INVALID_CALL);
		return(E_FAIL);
		}
	*plTimeoutSeconds = m_pData->m_pHitObj->GetScriptTimeout();
	return S_OK;
}

/*===================================================================
CServer::put_ScriptTimeout

Allows the user to set the timeout interval for a script (in seconds)

Parameters:
	long lTimeoutSeconds

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CServer::put_ScriptTimeout( long lTimeoutSeconds ) 
    {
    if (FAILED(CheckForTombstone()))
        return E_FAIL;
        
	if ( lTimeoutSeconds < 0 )
    	{
		ExceptionId( IID_IServer, IDE_SERVER, IDE_SERVER_INVALID_TIMEOUT );
		return E_FAIL;
	    }
	else
    	{
		if (m_pData->m_pHitObj == NULL)
			{
			ExceptionId(IID_IServer, IDE_SERVER_MAPPATH, IDE_SERVER_INVALID_CALL);
			return(E_FAIL);
			}
		m_pData->m_pHitObj->SetScriptTimeout(lTimeoutSeconds);
		return S_OK;
	    }
    }

/*===================================================================
CServer::Execute

Execute an ASP

Parameters:
	bstrURL     URL to execute

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CServer::Execute(BSTR bstrURL)
    {
	if (FAILED(CheckForTombstone()))
        return E_FAIL;

	if (m_pData->m_pIReq == NULL || m_pData->m_pHitObj == NULL)
		{
		ExceptionId(IID_IServer, IDE_SERVER, IDE_SERVER_INVALID_CALL);
		return E_FAIL;
		}

	TCHAR szTemplate[MAX_PATH], szVirtTemp[MAX_PATH];
    HRESULT  hr = MapPathInternal(IDE_SERVER, bstrURL, szTemplate, szVirtTemp);
    if (FAILED(hr))
        {
        ExceptionId(IID_IServer, IDE_SERVER, IDE_SERVER_EXECUTE_INVALID_PATH);
        return hr;
        }
    Normalize(szTemplate);

    hr = m_pData->m_pHitObj->ExecuteChildRequest(FALSE, szTemplate, szVirtTemp);
    if (FAILED(hr))
        {
        if (m_pData->m_pHitObj->FHasASPError()) // error already reported
            return hr;
            
		ExceptionId(IID_IServer, IDE_SERVER, (hr == E_COULDNT_OPEN_SOURCE_FILE) ?
    		IDE_SERVER_EXECUTE_CANTLOAD : IDE_SERVER_EXECUTE_FAILED);
		return E_FAIL;
        }

    return S_OK;
    }
    
/*===================================================================
CServer::Transfer

Transfer execution an ASP

Parameters:
	bstrURL     URL to execute

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CServer::Transfer(BSTR bstrURL)
    {
	if (FAILED(CheckForTombstone()))
        return E_FAIL;
        
	if (m_pData->m_pIReq == NULL || m_pData->m_pHitObj == NULL)
		{
		ExceptionId(IID_IServer, IDE_SERVER_MAPPATH, IDE_SERVER_INVALID_CALL);
		return E_FAIL;
		}

	TCHAR szTemplate[MAX_PATH], szVirtTemp[MAX_PATH];
    HRESULT  hr = MapPathInternal(IDE_SERVER, bstrURL, szTemplate, szVirtTemp);
    if (FAILED(hr))
        {
        ExceptionId(IID_IServer, IDE_SERVER, IDE_SERVER_TRANSFER_INVALID_PATH);
        return hr;
        }
    Normalize(szTemplate);

    hr = m_pData->m_pHitObj->ExecuteChildRequest(TRUE, szTemplate, szVirtTemp);
    if (FAILED(hr))
        {
        if (m_pData->m_pHitObj->FHasASPError()) // error already reported
            return hr;
            
		ExceptionId(IID_IServer, IDE_SERVER, (hr == E_COULDNT_OPEN_SOURCE_FILE) ?
    		IDE_SERVER_TRANSFER_CANTLOAD : IDE_SERVER_TRANSFER_FAILED);
		return E_FAIL;
        }

    return S_OK;
    }

/*===================================================================
CServer::GetLastError

Get ASPError object for the last error

Parameters:
	ppASPErrorObject    [out] the error object

Returns:
	HRESULT		S_OK on success
===================================================================*/
STDMETHODIMP CServer::GetLastError(IASPError **ppASPErrorObject)
    {
    *ppASPErrorObject = NULL;
    
	if (FAILED(CheckForTombstone()))
        return E_FAIL;
        
	if (m_pData->m_pIReq == NULL || m_pData->m_pHitObj == NULL)
		{
		ExceptionId(IID_IServer, IDE_SERVER, IDE_SERVER_INVALID_CALL);
		return E_FAIL;
		}

    HRESULT hr = m_pData->m_pHitObj->GetASPError(ppASPErrorObject);
    
    if (FAILED(hr))
        {
		ExceptionId(IID_IServer, IDE_SERVER, IDE_UNEXPECTED);
		return hr;
        }

    return S_OK;
    }

#ifdef DBG
/*===================================================================
CServer::AssertValid

Test to make sure that the CServer object is currently correctly formed
and assert if it is not.

Returns:

Side effects:
	None.
===================================================================*/
void CServer::AssertValid() const
	{
	Assert(m_fInited);
	Assert(m_pData);
	Assert(m_pData->m_pIReq);
	}
#endif DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\smhash.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Hash table for Script Manager

File: SMHash.h

Owner: AndrewS

This is the Link list and Hash table for use by the Script Manager only
===================================================================*/

#ifndef SMHASH_H
#define SMHASH_H

#include "LinkHash.h"

/*
 * C S M H a s h
 *
 * CSMHash is identical to CHashTable, but AddElem has differing behavior.
 */
class CSMHash : public CLinkHash
{
public:
	CLruLinkElem *AddElem(CLruLinkElem *pElem);
	CLruLinkElem *FindElem(const void *pKey, int cbKey, PROGLANG_ID proglang_id, DWORD dwInstanceID, BOOL fCheckLoaded);

};

#endif // SMHASH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\strlist.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: StringList object

File: strlist.cpp

Owner: DGottner

This file contains the code for the implementation of the String List object.
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "strlist.h"
#include "MemChk.h"

#pragma warning (disable: 4355)  // ignore: "'this' used in base member init


/*===================================================================
CStringListElem::CStringListElem

Constructor
===================================================================*/
CStringListElem::CStringListElem()
    : 
    m_fBufferInUse(FALSE),
    m_fAllocated(FALSE),
    m_pNext(NULL),
    m_szPointer(NULL)
	{
	}

/*===================================================================
CStringListElem::~CStringListElem

Destructor
===================================================================*/
CStringListElem::~CStringListElem()
	{
	if (m_fAllocated)
		delete [] m_szPointer;

    if (m_pNext)
    	delete m_pNext;
	}

/*===================================================================
CStringListElem::Init

Init CStringListElem

Parameters
	szValue         the string
	fMakeCopy       if FALSE - just store the pointer
    lCodePage       codepage to use to convert to UNICODE
===================================================================*/
HRESULT CStringListElem::Init(
    char    *szValue,
    BOOL    fMakeCopy,
    UINT    lCodePage)
{
    // for now, always make a copy of the string.  This is to ensure
    // that any string lists placed in session state via a dictionary
    // object do not have their elements freed from under them when
    // the request completes.

	if (1 /*fMakeCopy*/) {

        CMBCSToWChar    convStr;
        HRESULT         hr = S_OK;

        if (FAILED(hr = convStr.Init(szValue, lCodePage))) {
            return hr;
        }

        // now we will move the string into the elements memory.  If the 
        // converted string is bigger than the internal buffer, then
        // set the element's pointer to an allocated copy of the converted
        // string.

        if ((convStr.GetStringLen() + 1) > (sizeof(m_szBuffer)/sizeof(WCHAR))) {
            m_szPointer = convStr.GetString(TRUE);
            if (!m_szPointer)
                return E_OUTOFMEMORY;
		    m_fBufferInUse = FALSE;
		    m_fAllocated = TRUE;
        }
        else {

            // if it fits, simply copy it into the internal buffer.

            wcscpy(m_szBuffer, convStr.GetString());
		    m_fBufferInUse = TRUE;
		    m_fAllocated = FALSE;
        }
    }
#if 0
	else {
	    m_szPointer = szValue;
	    m_fBufferInUse = FALSE;
	    m_fAllocated = FALSE;
	}
#endif

    m_pNext = NULL;
    return S_OK;
}

/*===================================================================
CStringListElem::Init

Init CStringListElem

Parameters
	szValue         the string
	fMakeCopy       if FALSE - just store the pointer
===================================================================*/
HRESULT CStringListElem::Init(
    WCHAR   *wszValue,
    BOOL    fMakeCopy)
{
    // for now, always make a copy of the string.  This is to ensure
    // that any string lists placed in session state via a dictionary
    // object do not have their elements freed from under them when
    // the request completes.

	if (1 /*fMakeCopy*/) {

        // now we will move the string into the elements memory.  If the 
        // converted string is bigger than the internal buffer, then
        // set the element's pointer to an allocated copy

        if ((wcslen(wszValue) + 1) > (sizeof(m_szBuffer)/sizeof(WCHAR))) {
            m_szPointer = StringDupW(wszValue);
            if (!m_szPointer)
                return E_OUTOFMEMORY;
		    m_fBufferInUse = FALSE;
		    m_fAllocated = TRUE;
        }
        else {

            // if it fits, simply copy it into the internal buffer.

            wcscpy(m_szBuffer, wszValue);
		    m_fBufferInUse = TRUE;
		    m_fAllocated = FALSE;
        }
    }
#if 0
	else {
	    m_szPointer = szValue;
	    m_fBufferInUse = FALSE;
	    m_fAllocated = FALSE;
	}
#endif

    m_pNext = NULL;
    return S_OK;
}


/*===================================================================
CStringList::CStringList

Constructor
===================================================================*/

CStringList::CStringList(IUnknown *pUnkOuter, PFNDESTROYED pfnDestroy)
	: m_ISupportErrImp(this, pUnkOuter, IID_IStringList)
	{
	m_pBegin = m_pEnd = NULL;
	m_cValues = 0;
	m_cRefs = 1;
	m_pfnDestroy = pfnDestroy;
	CDispatch::Init(IID_IStringList);
	m_lCodePage = GetACP();
	}



/*===================================================================
CStringList::~CStringList

Destructor
===================================================================*/

CStringList::~CStringList()
	{
	if (m_pBegin)
    	delete m_pBegin;
	}



/*===================================================================
CStringList::AddValue

Parameters:
	szValue - value to add to the string list
	lCodePage - the CodePage used when construct return value
===================================================================*/

HRESULT CStringList::AddValue(char *szValue, BOOL fDuplicate, UINT lCodePage)
	{
	CStringListElem *pElem = new CStringListElem;
	if (!pElem)
    	return E_OUTOFMEMORY;

	m_lCodePage = lCodePage;

	HRESULT hr = pElem->Init(szValue, fDuplicate, lCodePage);
    if (FAILED(hr)) {
        delete pElem;
	    return hr;
    }

	if (m_pBegin == NULL)
	    {
		m_pBegin = m_pEnd = pElem;
		}
	else
		{
		m_pEnd->SetNext(pElem);
		m_pEnd = pElem;
		}

	++m_cValues;
	return S_OK;
	}

/*===================================================================
CStringList::AddValue

Parameters:
	szValue - value to add to the string list
	lCodePage - the CodePage used when construct return value
===================================================================*/

HRESULT CStringList::AddValue(WCHAR *szValue, BOOL fDuplicate)
	{
	CStringListElem *pElem = new CStringListElem;
	if (!pElem)
    	return E_OUTOFMEMORY;

	HRESULT hr = pElem->Init(szValue, fDuplicate);

    if (FAILED(hr)) {
        delete pElem;
	    return hr;
    }

	if (m_pBegin == NULL)
	    {
		m_pBegin = m_pEnd = pElem;
		}
	else
		{
		m_pEnd->SetNext(pElem);
		m_pEnd = pElem;
		}

	++m_cValues;
	return S_OK;
	}



/*===================================================================
CStringList::QueryInterface
CStringList::AddRef
CStringList::Release

IUnknown members for CStringList object.
===================================================================*/

STDMETHODIMP CStringList::QueryInterface(const IID &iid, void **ppvObj)
	{
	*ppvObj = NULL;

	if (iid == IID_IUnknown || iid == IID_IDispatch ||
	    iid == IID_IStringList || iid == IID_IDenaliIntrinsic)
	    {
		*ppvObj = this;
		}

	if (iid == IID_ISupportErrorInfo)
		*ppvObj = &m_ISupportErrImp;

	if (*ppvObj != NULL)
		{
		static_cast<IUnknown *>(*ppvObj)->AddRef();
		return S_OK;
		}

	return ResultFromScode(E_NOINTERFACE);
	}


STDMETHODIMP_(ULONG) CStringList::AddRef()
	{
	return ++m_cRefs;
	}


STDMETHODIMP_(ULONG) CStringList::Release()
	{
	if (--m_cRefs != 0)
		return m_cRefs;

	if (m_pfnDestroy != NULL)
		(*m_pfnDestroy)();

	delete this;
	return 0;
	}



/*===================================================================
CStringList::get_Count

Parameters:
	pcValues - count is stored in *pcValues
===================================================================*/

STDMETHODIMP CStringList::get_Count(int *pcValues)
	{
	*pcValues = m_cValues;
	return S_OK;
	}



/*===================================================================
CStringList::ConstructDefaultReturn

Return comma-separated list for the case where the CStringList
is not indexed.
===================================================================*/

HRESULT CStringList::ConstructDefaultReturn(VARIANT *pvarOut) {
	VariantClear(pvarOut);

	//
	// NEW SEMANTIC: we now return Empty (and not "") if nothing is in the collection
	//
	if (m_cValues == 0)
		return S_OK;		// VariantClear set pvarOut to Empty

    STACK_BUFFER( tempValues, 1024 );

	register CStringListElem *pElem;
	int cBytes = 0;

	for (pElem = m_pBegin; pElem != NULL; pElem = pElem->QueryNext())
		cBytes += (wcslen(pElem->QueryValue()) * sizeof(WCHAR));

    // need to account for the ", " and NULL Termination

	cBytes += sizeof(WCHAR) + ((2*(m_cValues - 1)) * sizeof(WCHAR));

    if (!tempValues.Resize(cBytes)) {
		ExceptionId(IID_IStringList, IDE_REQUEST, IDE_OOM);
		return E_FAIL;
    }

	WCHAR *szReturn = (WCHAR *)tempValues.QueryPtr();
	szReturn[0] = L'\0';
    WCHAR *szNext = szReturn;

	for (pElem = m_pBegin; pElem != NULL; pElem = pElem->QueryNext()) {
		szNext = strcpyExW(szNext, pElem->QueryValue());
		if (pElem->QueryNext() != NULL)
			szNext = strcpyExW(szNext, L", ");
    }

	BSTR bstrT;
	if ((bstrT = SysAllocString(szReturn)) == NULL) {
		ExceptionId(IID_IStringList, IDE_REQUEST, IDE_OOM);
		return E_FAIL;
    }

	V_VT(pvarOut) = VT_BSTR;
	V_BSTR(pvarOut) = bstrT;

	return S_OK;
}



/*===================================================================
CStringList::get_Item
===================================================================*/

STDMETHODIMP CStringList::get_Item(VARIANT varIndex, VARIANT *pvarOut)
	{
	long i;
	VariantInit(pvarOut);


	if (V_VT(&varIndex) == VT_ERROR) {
		return ConstructDefaultReturn(pvarOut);
    }

	// BUG 937: VBScript passes VT_VARIANT|VT_BYREF when passing variants
	//   Loop through while we have a VT_BYREF until we get the real variant.
	//
	// and changed again...
	//
	// BUG 1609 the prior code was only checking for VT_I4 and jscript passed in a
	// VT_R8 and it failed so now we use the VariantChangeType call to solve the
	// problem

	VARIANT var;		
	VariantInit(&var);
	
	
	HRESULT hr = S_OK;
	if((hr = VariantChangeType(&var, &varIndex ,0,VT_I4)) != S_OK) {
		ExceptionId(IID_IStringList, IDE_REQUEST, IDE_EXPECTING_INT);
		return E_FAIL;
    }

	i = V_I4(&var);		
	VariantClear(&var);

	// END bug 1609

	if (i <= 0 || i > m_cValues) {
		ExceptionId(IID_IStringList, IDE_REQUEST, IDE_BAD_ARRAY_INDEX);
		return E_FAIL;
    }

	register CStringListElem *pElem = m_pBegin;
	while (--i > 0)
		pElem = pElem->QueryNext();

	BSTR bstrT;
	if ((bstrT = SysAllocString(pElem->QueryValue())) == NULL ) {
		ExceptionId(IID_IStringList, IDE_REQUEST, IDE_OOM);
		return E_FAIL;
    }

	V_VT(pvarOut) = VT_BSTR;
	V_BSTR(pvarOut) = bstrT;

	return S_OK;
}


/*===================================================================
CStringList::get__NewEnum
===================================================================*/

STDMETHODIMP CStringList::get__NewEnum(IUnknown **ppEnumReturn)
	{
	*ppEnumReturn = new CStrListIterator(this);
	if (*ppEnumReturn == NULL)
		{
		ExceptionId(IID_IStringList, IDE_REQUEST, IDE_OOM);
		return E_OUTOFMEMORY;
		}

	return S_OK;
	}



/*------------------------------------------------------------------
 * C S t r L i s t I t e r a t o r
 */

/*===================================================================
CStrListIterator::CStrListIterator

Constructor

NOTE: CRequest is (currently) not refcounted.  AddRef/Release
      added to protect against future changes.
===================================================================*/

CStrListIterator::CStrListIterator(CStringList *pStrings)
	{
	Assert (pStrings != NULL);

	m_pStringList = pStrings;
	m_pCurrent    = m_pStringList->m_pBegin;
	m_cRefs       = 1;

	m_pStringList->AddRef();
	}



/*===================================================================
CStrListIterator::CStrListIterator

Destructor
===================================================================*/

CStrListIterator::~CStrListIterator()
	{
	m_pStringList->Release();
	}



/*===================================================================
CStrListIterator::QueryInterface
CStrListIterator::AddRef
CStrListIterator::Release

IUnknown members for CServVarsIterator object.
===================================================================*/

STDMETHODIMP CStrListIterator::QueryInterface(REFIID iid, void **ppvObj)
	{
	if (iid == IID_IUnknown || iid == IID_IEnumVARIANT)
		{
		AddRef();
		*ppvObj = this;
		return S_OK;
		}

	*ppvObj = NULL;
	return E_NOINTERFACE;
	}


STDMETHODIMP_(ULONG) CStrListIterator::AddRef()
	{
	return ++m_cRefs;
	}


STDMETHODIMP_(ULONG) CStrListIterator::Release()
	{
	if (--m_cRefs > 0)
		return m_cRefs;

	delete this;
	return 0;
	}



/*===================================================================
CStrListIterator::Clone

Clone this iterator (standard method)
===================================================================*/

STDMETHODIMP CStrListIterator::Clone(IEnumVARIANT **ppEnumReturn)
	{
	CStrListIterator *pNewIterator = new CStrListIterator(m_pStringList);
	if (pNewIterator == NULL)
		return E_OUTOFMEMORY;

	// new iterator should point to same location as this.
	pNewIterator->m_pCurrent = m_pCurrent;

	*ppEnumReturn = pNewIterator;
	return S_OK;
	}



/*===================================================================
CStrListIterator::Next

Get next value (standard method)

To rehash standard OLE semantics:

	We get the next "cElements" from the collection and store them
	in "rgVariant" which holds at least "cElements" items.  On
	return "*pcElementsFetched" contains the actual number of elements
	stored.  Returns S_FALSE if less than "cElements" were stored, S_OK
	otherwise.
===================================================================*/

STDMETHODIMP CStrListIterator::Next(unsigned long cElementsRequested, VARIANT *rgVariant, unsigned long *pcElementsFetched)
	{
	// give a valid pointer value to 'pcElementsFetched'
	//
	unsigned long cElementsFetched;
	if (pcElementsFetched == NULL)
		pcElementsFetched = &cElementsFetched;

	// Loop through the collection until either we reach the end or
	// cElements becomes zero
	//
	unsigned long cElements = cElementsRequested;
	*pcElementsFetched = 0;

	while (cElements > 0 && m_pCurrent != NULL)
		{
		BSTR bstrT = SysAllocString(m_pCurrent->QueryValue());
		if (bstrT == NULL)
			return E_OUTOFMEMORY;
		V_VT(rgVariant) = VT_BSTR;
		V_BSTR(rgVariant) = bstrT;

		++rgVariant;
		--cElements;
		++*pcElementsFetched;
		m_pCurrent = m_pCurrent->QueryNext();
		}

	// initialize the remaining variants
	//
	while (cElements-- > 0)
		VariantInit(rgVariant++);

	return (*pcElementsFetched == cElementsRequested)? S_OK : S_FALSE;
	}



/*===================================================================
CStrListIterator::Skip

Skip items (standard method)

To rehash standard OLE semantics:

	We skip over the next "cElements" from the collection.
	Returns S_FALSE if less than "cElements" were skipped, S_OK
	otherwise.
===================================================================*/

STDMETHODIMP CStrListIterator::Skip(unsigned long cElements)
	{
	/* Loop through the collection until either we reach the end or
	 * cElements becomes zero
	 */
	while (cElements > 0 && m_pCurrent != NULL)
		{
		--cElements;
		m_pCurrent = m_pCurrent->QueryNext();
		}

	return (cElements == 0)? S_OK : S_FALSE;
	}



/*===================================================================
CStrListIterator::Reset

Reset the iterator (standard method)
===================================================================*/

STDMETHODIMP CStrListIterator::Reset()
	{
	m_pCurrent = m_pStringList->m_pBegin;
	return S_OK;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\smhash.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: Hash table for Script Manager

File: SMHash.cpp

Owner: AndrewS

This is the Link list and Hash table for use by the Script Manager only
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "memchk.h"

/*===================================================================
CSMHash::AddElem

Adds a CLruLinkElem to the SM Hash table.
User is responsible for allocating the Element to be added.

Note: This is identical to the standard CHashTable::AddElem, except
that it allows for elements with duplicate names

Parameters:
	CLruLinkElem *pElem		Object to be added

Returns:
	Pointer to element added/found.
===================================================================*/
CLruLinkElem *CSMHash::AddElem
(
CLruLinkElem *pElem
)
	{
	AssertValid();

    if (m_rgpBuckets == NULL)
        {
        if (FAILED(AllocateBuckets()))
            return NULL;
        }
	
	if (pElem == NULL)
		return NULL;

	UINT			iBucket = m_pfnHash(pElem->m_pKey, pElem->m_cbKey) % m_cBuckets;
	CLruLinkElem *	pT = static_cast<CLruLinkElem *>(m_rgpBuckets[iBucket]);
	
	while (pT)
		{
		if (pT->m_Info > 0)
			pT = static_cast<CLruLinkElem *>(pT->m_pNext);
		else
			break;
		}

	if (pT)
		{
		// There are other elements in bucket
		pT = static_cast<CLruLinkElem *>(m_rgpBuckets[iBucket]);
		m_rgpBuckets[iBucket] = pElem;
		pElem->m_Info = pT->m_Info + 1;
		pElem->m_pNext = pT;
		pElem->m_pPrev = pT->m_pPrev;
		pT->m_pPrev = pElem;
		if (pElem->m_pPrev == NULL)
			m_pHead = pElem;
		else
			pElem->m_pPrev->m_pNext = pElem;
		}
	else
		{
		// This is the first element in the bucket
		m_rgpBuckets[iBucket] = pElem;
		pElem->m_pPrev = NULL;
		pElem->m_pNext = m_pHead;
		pElem->m_Info = 0;
		if (m_pHead)
			m_pHead->m_pPrev = pElem;
		else
			m_pTail = pElem;
		m_pHead = pElem;
		}
	m_Count++;
	pElem->PrependTo(m_lruHead);
	AssertValid();
	return pElem;
	}

/*===================================================================
CSMHash::FindElem

Finds a script engine element in the hash table based on the name
and language type.

Parameters:
	void *	pKey			- the key to look for
	int		cbKey			- length of the key to look for
	PROGLANG_ID proglang_id - program language name
	DWORD   dwInstanceID    - instance ID to find
	BOOL	fCheckLoaded	- if true, only return engines flagged as "loaded"

Returns:
	Pointer to CLruLinkElem if found, otherwise NULL.
===================================================================*/
CLruLinkElem * CSMHash::FindElem
(
const void *pKey,
int cbKey,
PROGLANG_ID proglang_id,
DWORD dwInstanceID,
BOOL fCheckLoaded
)
	{
	AssertValid();
	if (m_rgpBuckets == NULL || pKey == NULL)
		return NULL;

	UINT iBucket = m_pfnHash(static_cast<const BYTE *>(pKey), cbKey) % m_cBuckets;
	CLruLinkElem *	pT = static_cast<CLruLinkElem *>(m_rgpBuckets[iBucket]);
	CLruLinkElem *	pRet = NULL;

	/*
	 * We have the right bucket based on the hashed name.  
	 * Search through the bucket chain looking for elements whose name
	 * is correct (multiple names can hash to the same bucket), and 
	 * whose language is the one we want, and (optionally) skip
	 * elements that are not fully "loaded"
	 *
	 * Note: This all relys on intimate knowlege of the format of an ActiveScriptEngine.
	 *			these elements better be ASE's.
	 */
	while (pT && pRet == NULL)
		{
		if (FIsEqual(pT->m_pKey, pT->m_cbKey, pKey, cbKey))
			{
			CASEElem *pASEElem = static_cast<CASEElem *>(pT);
			Assert(pASEElem != NULL);
			CActiveScriptEngine *pASE = pASEElem->PASE();
			Assert(pASE != NULL);
			
			// Element has the right name.  Is it really the one we want?
			if (proglang_id != pASE->ProgLang_Id())
				goto LNext;

			if (dwInstanceID != pASE->DWInstanceID())
				goto LNext;

			if (fCheckLoaded && !pASE->FFullyLoaded())
				goto LNext;

			// Yup, its the right one!
			pRet = pT;
			break;
			}
			
LNext:			
		if (pT->m_Info > 0)
			pT = static_cast<CLruLinkElem *>(pT->m_pNext);
		else
			{
			// got to the last element in this bucket chain
			break;
			}
		}
		
	if (pRet)
		pRet->PrependTo(m_lruHead);

	AssertValid();
	return pRet;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\svcintfs.h ===
EXTERN_C const IID IID_IComStaThreadPoolKnobs;

    
    MIDL_INTERFACE("324B64FA-33B6-11d2-98B7-00C04F8EE1C4")
    IComStaThreadPoolKnobs : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE SetMinThreadCount( 
            DWORD minThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMinThreadCount( 
            /* [out] */ DWORD __RPC_FAR *minThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetMaxThreadCount( 
            DWORD maxThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMaxThreadCount( 
            /* [out] */ DWORD __RPC_FAR *maxThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetActivityPerThread( 
            DWORD activitiesPerThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetActivityPerThread( 
            /* [out] */ DWORD __RPC_FAR *activitiesPerThread) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetActivityRatio( 
            DOUBLE activityRatio) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetActivityRatio( 
            /* [out] */ DOUBLE __RPC_FAR *activityRatio) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetThreadCount( 
            /* [out] */ DWORD __RPC_FAR *pdwThreads) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetQueueDepth( 
            /* [out] */ DWORD __RPC_FAR *pdwQDepth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetQueueDepth( 
            /* [in] */ long dwQDepth) = 0;
        
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\template.h ===
/*==============================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

File:           template.h
Maintained by:  DaveK
Component:      include file for Denali Compiled Template object
==============================================================================*/

#ifndef _TEMPLATE_H
#define _TEMPLATE_H

#include "vector.h"
#include "LinkHash.h"
#include "Compcol.h"
#include "util.h"
#include "activdbg.h"
#include "ConnPt.h"
#include "DblLink.h"
#include "aspdmon.h"
#include "ie449.h"
#include "memcls.h"

#define PER_TEMPLATE_REFLOG 0

/*  NOTE we ensure that C_COUNTS_IN_HEADER is a multiple of 4 because the offsets which follow
    the counts in template header are dword-aligned.  It is easiest (and fastest at runtime)
    to make sure those offsets start on a dword-alignment point; thus no runtime alignment calc
    is needed in GetAddress().
*/
#define C_REAL_COUNTS_IN_HEADER     3       // actual number of count fields in template header
#define C_COUNTS_IN_HEADER          (C_REAL_COUNTS_IN_HEADER/4 + 1) * 4     // allocated number of count fields in template header

#define C_OFFOFFS_IN_HEADER         4       // number of 'ptr-to-ptr' fields in template header
#define CB_TEMPLATE_DEFAULT         2500    // default memory allocation for new template
#define C_TARGET_LINES_DEFAULT      50      // default count of target script lines per engine

#define C_TEMPLATES_PER_INCFILE_DEFAULT 4   // default count of templates per inc-file

#define         SZ_NULL         "\0"
#define         WSTR_NULL      L"\0"
#define         SZ_NEWLINE      "\r\n"
const unsigned  CB_NEWLINE      = strlen(SZ_NEWLINE);

const   LPSTR   g_szWriteBlockOpen  = "Response.WriteBlock(";
const   LPSTR   g_szWriteBlockClose = ")";
const   LPSTR   g_szWriteOpen       = "Response.Write(";
const   LPSTR   g_szWriteClose      = ")";

// defaults for buffering interim compile results
#define     C_SCRIPTENGINESDEFAULT  2       // default count of script engines
#define     C_SCRIPTSEGMENTSDEFAULT 20      // default count of script segments
#define     C_OBJECTINFOS_DEFAULT   10      // default count of object-infos
#define     C_HTMLSEGMENTSDEFAULT   20      // default count of HTML segments
#define     C_INCLUDELINESDEFAULT   5       // default count of include lines
#define     CB_TOKENS_DEFAULT       400     // default byte count for tokens

#define     CH_ATTRIBUTE_SEPARATOR  '='     // separator for attribute-value pair
#define     CH_SINGLE_QUOTE         '\''    // single-quote character
#define     CH_DOUBLE_QUOTE         '"'     // double-quote character
#define     CH_ESCAPE               '\\'    // escape character - tells us to ignore following token

// ACLs: the following code should in future be shared with IIS (see creatfil.cxx in IIS project)
// NOTE we want SECURITY_DESC_DEFAULT_SIZE to be relatively small, since it affects template memory reqt dramatically
#define     SECURITY_DESC_GRANULARITY   128        // 'chunk' size for re-sizing file security descriptor
#define     SECURITY_DESC_DEFAULT_SIZE  256        // initial default size of file security descriptor
#define     SIZE_PRIVILEGE_SET          128        // size of privilege set

// macros
// use outside of CTokenList class
#define SZ_TOKEN(i)                 (*gm_pTokenList).m_bufTokens.PszLocal(i)
#define CCH_TOKEN(i)                (*gm_pTokenList)[i]->m_cb
#define _TOKEN                      CTemplate::CTokenList::TOKEN
// use within CTokenList class
#define CCH_TOKEN_X(i)              (*this)[i]->m_cb
#define BR_TOKEN_X(i)               *((*this)[i])

// Use to specify which source file name you want (pathInfo or pathTranslated)
#ifndef _SRCPATHTYPE_DEFINED
#define _SRCPATHTYPE_DEFINED
enum SOURCEPATHTYPE
    {
    SOURCEPATHTYPE_VIRTUAL = 0,
    SOURCEPATHTYPE_PHYSICAL = 1
    };
#endif

// CTemplate error codes
#define E_COULDNT_OPEN_SOURCE_FILE              0x8000D001L
#define E_SOURCE_FILE_IS_EMPTY                  0x8000D002L
#define E_TEMPLATE_COMPILE_FAILED               0x8000D003L
#define E_USER_LACKS_PERMISSIONS                0x8000D004L
#define E_TEMPLATE_COMPILE_FAILED_DONT_CACHE    0x8000D005L
#define E_TEMPLATE_MAGIC_FAILURE                0x8000D006L

inline BOOL FIsPreprocessorError(HRESULT hr)
    {
    return
        (
        hr == E_SOURCE_FILE_IS_EMPTY                ||
        hr == E_TEMPLATE_COMPILE_FAILED             ||
        hr == E_TEMPLATE_COMPILE_FAILED_DONT_CACHE  ||
        hr == E_TEMPLATE_MAGIC_FAILURE
        );
    }

//Can not use same index as CErrorInfo anymore.
//Index for lastErrorInfo in Template
#define ILE_szFileName      0
#define ILE_szLineNum       1
#define ILE_szEngine        2
#define ILE_szErrorCode     3
#define ILE_szShortDes      4
#define ILE_szLongDes       5
#define ILE_MAX             6

// forward references
class CTemplate;
class CTemplateCacheManager;
class CHitObj;
class CTokenList;
class CIncFile;
typedef CLSID PROGLANG_ID;  // NOTE also defined in scrptmgr.h; we define here to avoid include file circularity

/*  ============================================================================
    Class:      CByteRange
    Synopsis:   A range of bytes
    NOTE fLocal member is only used if the byte range is stored in a CBuffer

    NOTE 2
        m_pfilemap is really a pointer to a CFileMap - however, it's impossible
        to declare that type here because the CFileMap struct is nested inside
        CTemplate, and C++ won't let you forward declare nested classes.  Since
        the CTemplate definition depends on CByteRange, properly declaring the
        type of "m_pfilemap" is impossible.
*/
class CByteRange
{
public:
    BYTE*   m_pb;               // ptr to bytes
    ULONG   m_cb;               // count of bytes
    ULONG   m_fLocal:1;         // whether bytes are stored in buffer (TRUE) or elsewhere (FALSE)
    UINT    m_idSequence:31;    // byte range's sequence id
    void*   m_pfilemap;         // file the byte range comes from

            CByteRange(): m_pb(NULL), m_cb(0), m_fLocal(FALSE), m_idSequence(0), m_pfilemap(NULL) {}
            CByteRange(BYTE* pb, ULONG cb): m_fLocal(FALSE), m_idSequence(0) {m_pb = pb; m_cb = cb;}
    BOOLB   IsNull() { return((m_pb == NULL) || (m_cb == 0)) ; }
    void    Nullify() { m_pb = NULL; m_cb = 0; }
    void    operator=(const CByteRange& br)
                { m_pb = br.m_pb; m_cb = br.m_cb; m_fLocal = br.m_fLocal; m_idSequence = br.m_idSequence; }
    BOOLB   FMatchesSz(LPCSTR psz);
    void    Advance(UINT i);
    BYTE*   PbString(LPSTR psz, LONG lCodePage);
    BYTE*   PbOneOfAspOpenerStringTokens(LPSTR rgszTokens[], UINT rgcchTokens[],
                                         UINT nTokens, UINT *pidToken);
    BOOLB   FEarlierInSourceThan(CByteRange& br);
};

/*  ============================================================================
    Enum type:  TEMPLATE_COMPONENT
    Synopsis:   A component of a template, e.g. script block, html block, etc.
*/
enum TEMPLATE_COMPONENT
{
    // NOTE enum values and order are tightly coupled with template layout order
    // DO NOT CHANGE
    tcompScriptEngine = 0,
    tcompScriptBlock,
    tcompObjectInfo,
    tcompHTMLBlock,
};

/*  ****************************************************************************
    Class:      CTemplateConnPt
    Synopsis:   Connection point for IDebugDocumentTextEvents
*/
class CTemplateConnPt : public CConnectionPoint
{
public:
    // ctor
    CTemplateConnPt(IConnectionPointContainer *pContainer, const GUID &uidConnPt)
        : CConnectionPoint(pContainer, uidConnPt) {}

    // IUnknown methods
    STDMETHOD(QueryInterface)(const GUID &, void **);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();
};

/*	****************************************************************************
	Class:		CTemplateKey
	Synopsis:	Packaged data to locate template in hash table
	               (instance ID, and template name)
*/	
#define MATCH_ALL_INSTANCE_IDS 0xFFFBAD1D	// unlikely instance ID.  sort of spells "BAD ID"
struct CTemplateKey
	{
	const TCHAR *	szPathTranslated;
	DWORD			dwInstanceID;

	CTemplateKey(const TCHAR *_szPathTranslated = NULL, UINT _dwInstanceID = MATCH_ALL_INSTANCE_IDS)
		: szPathTranslated(_szPathTranslated),
		  dwInstanceID(_dwInstanceID)  {}
	};


/*  ****************************************************************************
    Class:      CTemplate
    Synopsis:   A Denali compiled template.

    NOTE: CTemplate's primary client is CTemplateCacheManager, which maintains
    a cache of compiled templates.

    USAGE
    -----
    The CTemplate class must be used as follows:

    CLASS INIT - InitClass must be called before any CTemplate can be created.

    NEW TEMPLATE - For each new template the client wants to create, the client
      must do the following, in order:
      1) New a CTemplate
      2) Initialize the CTemplate by calling Init, passing a source file name
      3) Load the CTemplate by calling Load; when Load returns, the new CTemplate is ready for use.

    EXISTING TEMPLATE - To use an existing template, the client must:
      1) Call Deliver; when Deliver returns, the existing CTemplate is ready for use.

    CLASS UNINIT - UnInitClass must be called after the last CTemplate has been destroyed.

    To ensure thread-safety, the client must implement a critical section
    around the call to Init.  Init is designed to be as fast as possible,
    so the client can quickly learn that it has a pending template for a given
    source file, and queue up other requests for the same source file.

    CTemplate provides implementations for Debug documents, namely
    IDebugDocumentProvider & IDebugDocumentText
*/
class CActiveScriptEngine;

class CTemplate :
            public CDblLink,
            public IDebugDocumentProvider,
            public IDebugDocumentText,
            public IConnectionPointContainer    // Source of IDebugDocumentTextEvents
{
private:
#include "templcap.h"   // 'captive' classes, only used internally within CTemplate

friend HRESULT InitMemCls();
friend HRESULT UnInitMemCls();

friend class	CTemplateCacheManager;			// TODO: decouple CTemplate class from it's manager class
friend class    CFileMap;
friend class    CIncFile;                       // IncFiles are privy to debugging data structures

// CScriptStore::Init() must access gm_brDefaultScriptLanguage, gm_progLangIdDefault
friend HRESULT  CTemplate::CScriptStore::Init(LPCSTR szDefaultScriptLanguage, CLSID *pCLSIDDefaultEngine);

private:
    CWorkStore* m_pWorkStore;               // ptr to working storage for source segments
    HANDLE      m_hEventReadyForUse;        // ready-for-use event handle
public:
    BYTE*       m_pbStart;                  // ptr to start of template memory
    ULONG       m_cbTemplate;               // bytes allocated for template
    LONG        m_cRefs;                    // ref count - NOTE LONG required by InterlockedIncrement
private:
    CTemplateConnPt m_CPTextEvents;         // Connection point for IDebugDocumentTextEvents

    // support for compile-time errors
    BYTE*       m_pbErrorLocation;          // ptr to error location in source file
    UINT        m_idErrMsg;                 // error message id
    UINT        m_cMsgInserts;              // count of insert strings for error msg
    char**      m_ppszMsgInserts;           // array of ptrs to error msg insert strings
    // support for run-time errors and debugging
    UINT        m_cScriptEngines;           // count of script engines
    CActiveScriptEngine **m_rgpDebugScripts;// array (indexed by engine) of scripts CURRENTLY BEING DEBUGGED
    vector<CSourceInfo> *m_rgrgSourceInfos; // array of arrays of script source line infos, one per script engine per target line
	ULONG       m_cbTargetOffsetPrevT;		// running total of last source offset processed
    CRITICAL_SECTION m_csDebuggerDetach;    // CS needed to avoid race condition with detaching from debugger
    CDblLink    m_listDocNodes;             // list of document nodes we are attached to
    CFileMap**  m_rgpFilemaps;              // array of ptrs to filemaps of source files
    CTemplateKey m_LKHashKey;               // bundled info for key (contains copy of m_rgpfilemaps[0] filename to make things simpler
    UINT        m_cFilemaps;                // count of filemaps of source files
    CFileMap**  m_rgpSegmentFilemaps;       // array of filemap ptrs per source segment
    UINT        m_cSegmentFilemapSlots;     // count of per-source-segment filemap ptrs
    LPSTR       m_pszLastErrorInfo[6];      // text of last error - cached for new requests on this template
                                            //  FileName, LineNum, Engine, ShortDes, LongDes
    DWORD       m_dwLastErrorMask;          // cached for new requests on this template
	DWORD		m_hrOnNoCache;				// HRESULT when don't cache is set.
    TCHAR*      m_szApplnVirtPath;          // application virtual path (substring of Application URL)
    TCHAR*      m_szApplnURL;               // application URL (starts with "http://")
    // for best structure packing we all boleans here as bitfields
    unsigned    m_fGlobalAsa:1;             // is template for global.asa file?
    unsigned    m_fIsValid:1;               // is template in valid state?
    unsigned    m_fDontCache:1;             // don't cache this template
    unsigned    m_fReadyForUse:1;           // is template ready for use?

    unsigned    m_fDebuggerDetachCSInited:1;// has debugger attach critical section been initialized?
    unsigned    m_fDontAttach:1;            // should not be attached to debugger (not in cache)
    unsigned    m_fSession:1;               // does this page require session state
    unsigned    m_fScriptless:1;            // doesn't have any scripts

    unsigned    m_fDebuggable:1;            // is this page part of at least one debuggable app?
    unsigned    m_fZombie:1;                // File template is based on has changed since obtained from cache
    unsigned    m_fCodePageSet:1;           // Did template contain a code page directive
    unsigned    m_fLCIDSet:1;               // Did template contain an LCID directive

    unsigned    m_fIsPersisted:1;
    TransType   m_ttTransacted;             // type of transaction support

    // class-wide support for compilation
    static      CTokenList*     gm_pTokenList;              // array of tokens
    unsigned    m_wCodePage;                                // Compiler Time CodePage
    long        m_lLCID;                                    // Compile Time LCID

    vector<ITypeLib *>  m_rgpTypeLibs;          // array of ptrs to typelibs
    IDispatch*          m_pdispTypeLibWrapper;  // typelib wrapper object

    vector<C449Cookie *> m_rgp449;              // array of ptrs to 449 requests

    LPSTR               m_szPersistTempName;    // filename of persisted template, if any
    void               *m_pHashTable;           // CacheMgr hash table that this template is on

    IUnknown           *m_pServicesConfig;

    static  HANDLE sm_hSmallHeap;
    static  HANDLE sm_hLargeHeap;

public:
    /**
     **  Initialization and destruction public interfaces
     **/

    // Initializes CTemplate static members; must be called on denali.dll load
    static HRESULT InitClass();

    // Un-initilaizes CTemplate static members; must be called on denali.dll unload
    static void UnInitClass();

    //  Inits template in preparation for compilation
    //  Called by template cache mgr before calling Load
    HRESULT Init(CHitObj* pHitObj, BOOL fGlobalAsp, const CTemplateKey &rTemplateKey);

    //  Compiles the template from its main source file (and include files, if any)
    HRESULT Compile(CHitObj* pHitObj);

    // Called by requestor of existing template to determine if template is ready for use
    HRESULT Deliver(CHitObj* pHitObj);

    // Create this template's CServicesConfig object
    HRESULT CreateTransServiceConfig(BOOL  fEnableTracker);

            CTemplate();
            ~CTemplate();
    void    RemoveIncFile(CIncFile* pIncFile);

	// Trace Log info
	static PTRACE_LOG gm_pTraceLog;

public:
#if PER_TEMPLATE_REFLOG
    PTRACE_LOG  m_pTraceLog;
#endif
    
    /*
        'Consumer' public interfaces
        Methods for getting info out of a CTemplate
    */

    // Returns name of source file on which this template is based
    LPTSTR GetSourceFileName(SOURCEPATHTYPE = SOURCEPATHTYPE_PHYSICAL);

    // Returns virtual path of the source file
    LPTSTR GetApplnPath(SOURCEPATHTYPE = SOURCEPATHTYPE_PHYSICAL);

    // Returns hashing key of the template
    const CTemplateKey *ExtractHashKey() const;

    // Returns version stamp of compiler by which this template was compiled
    LPSTR GetCompilerVersion();

    // Component counts
    USHORT Count(TEMPLATE_COMPONENT tcomp);
    USHORT CountScriptEngines() { return (USHORT)m_cScriptEngines; }

    // Returns i-th script block as ptr to prog lang id and ptr to script text
    void GetScriptBlock(UINT i, LPSTR* pszScriptEngine, PROGLANG_ID** ppProgLangId, LPCOLESTR* pwstrScriptText);

    // Returns i-th object-info as object name, clsid, scope, model
    HRESULT GetObjectInfo(UINT i, LPSTR* ppszObjectName,
            CLSID *pClsid, CompScope *pScope, CompModel *pcmModel);

    // Returns i-th HTML block as ptr, count of bytes, original offset, incl filename
    HRESULT GetHTMLBlock(UINT i, LPSTR* pszHTML, ULONG* pcbHTML, ULONG* pcbSrcOffs, LPSTR* pszSrcIncFile);

    // Returns line number and source file name a given target line in a given script engine.
    void GetScriptSourceInfo(UINT idEngine, int iTargetLine, LPTSTR* pszPathInfo, LPTSTR* pszPathTranslated, ULONG* piSourceLine, ULONG* pichSourceLine, BOOLB* pfGuessedLine);

    // Converts a character offset from the target script to the offset in the source
    void GetSourceOffset(ULONG idEngine, ULONG cchTargetOffset, TCHAR **pszSourceFile, ULONG *pcchSourceOffset, ULONG *pcchSourceText);

    // Converts a character offset from the source document to the offset in the target
    BOOL GetTargetOffset(TCHAR *szSourceFile, ULONG cchSourceOffset, ULONG *pidEngine, ULONG *pcchTargetOffset);

    // Get the character position of a line (directly implements debugging interface)
    HRESULT GetPositionOfLine(CFileMap *pFilemap, ULONG cLineNumber, ULONG *pcCharacterPosition);

    // Get the line # of a character position (directly implements debugging interface)
    HRESULT GetLineOfPosition(CFileMap *pFilemap, ULONG cCharacterPosition, ULONG *pcLineNumber, ULONG *pcCharacterOffsetInLine);

    // Return a RUNNING script based on the engine, or NULL if code context has never been requested yet
    CActiveScriptEngine *GetActiveScript(ULONG idEngine);

    // associate a running script for an engine ID (Use after you get the first code context)
    HRESULT AddScript(ULONG idEngine, CActiveScriptEngine *pScriptEngine);

    // attach the CTemplate object to an application (debugger tree view)
    HRESULT AttachTo(CAppln *pAppln);

    // detach the CTemplate object from an application (debugger tree view)
    HRESULT DetachFrom(CAppln *pAppln);

    // detach the CTemplate object all applications (and release script engines)
    HRESULT Detach();

    // Signifies last use of template as a recylable object. Any outstanding references
    // should be from currently executing scripts.
    ULONG End();

    // Let debugger know about page start/end
    HRESULT NotifyDebuggerOnPageEvent(BOOL fStart);

    // Generate 449 response in cookie negotiations with IE when needed
    HRESULT Do449Processing(CHitObj *pHitObj);

    HRESULT PersistData(char    *pszTempFilePath);
    HRESULT UnPersistData();
    HRESULT PersistCleanup();
    ULONG   TemplateSize()  { return m_cbTemplate; }

    BOOL FTransacted();
    BOOL FSession();
    BOOL FScriptless();
    BOOL FDebuggable();
    BOOL FIsValid();        // determine if compilation succeeded
    BOOL FTemplateObsolete();
    BOOL FGlobalAsa();
    BOOL FIsZombie();
    BOOL FDontAttach();
    BOOL FIsPersisted();
    VOID Zombify();

    IUnknown    *PServicesConfig() {return m_pServicesConfig;};

    IDispatch *PTypeLibWrapper();

    void       SetHashTablePtr(void  *pTable) { m_pHashTable = pTable; }
    void      *GetHashTablePtr() { return m_pHashTable; }

public:
    /*
        COM public interfaces
        Implementation of debugging documents.
    */

    // IUnknown methods
    STDMETHOD(QueryInterface)(const GUID &, void **);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IDebugDocumentProvider methods
    STDMETHOD(GetDocument)(/* [out] */ IDebugDocument **ppDebugDoc);

    // IDebugDocumentInfo (also IDebugDocumentProvider) methods
    STDMETHOD(GetName)(
        /* [in] */ DOCUMENTNAMETYPE dnt,
        /* [out] */ BSTR *pbstrName);

    STDMETHOD(GetDocumentClassId)(/* [out] */ CLSID *)
        {
        return E_NOTIMPL;
        }

    // IDebugDocumentText methods
    STDMETHOD(GetDocumentAttributes)(
        /* [out] */ TEXT_DOC_ATTR *ptextdocattr);

    STDMETHOD(GetSize)(
        /* [out] */ ULONG *pcLines,
        /* [out] */ ULONG *pcChars);

    STDMETHOD(GetPositionOfLine)(
        /* [in] */ ULONG cLineNumber,
        /* [out] */ ULONG *pcCharacterPosition);

    STDMETHOD(GetLineOfPosition)(
        /* [in] */ ULONG cCharacterPosition,
        /* [out] */ ULONG *pcLineNumber,
        /* [out] */ ULONG *pcCharacterOffsetInLine);

    STDMETHOD(GetText)(
        /* [in] */ ULONG cCharacterPosition,
        /* [size_is][length_is][out][in] */ WCHAR *pcharText,
        /* [size_is][length_is][out][in] */ SOURCE_TEXT_ATTR *pstaTextAttr,
        /* [out][in] */ ULONG *pcChars,
        /* [in] */ ULONG cMaxChars);

    STDMETHOD(GetPositionOfContext)(
        /* [in] */ IDebugDocumentContext *psc,
        /* [out] */ ULONG *pcCharacterPosition,
        /* [out] */ ULONG *cNumChars);

    STDMETHOD(GetContextOfPosition)(
        /* [in] */ ULONG cCharacterPosition,
        /* [in] */ ULONG cNumChars,
        /* [out] */ IDebugDocumentContext **ppsc);

    // IConnectionPointContainer methods
    STDMETHOD(EnumConnectionPoints)(
        /* [out] */ IEnumConnectionPoints __RPC_FAR *__RPC_FAR *ppEnum)
            {
            return E_NOTIMPL;   // doubt we need this - client is expecting only TextEvents
            }

    STDMETHOD(FindConnectionPoint)(
        /* [in] */ const IID &iid,
        /* [out] */ IConnectionPoint **ppCP);

private:
    /*  NOTE Compile() works by calling GetSegmentsFromFile followed by WriteTemplate
        Most other private methods support one of these two workhorse functions
    */

    void        AppendMapFile(LPCTSTR szFileSpec, CFileMap* pfilemapParent, BOOLB fVirtual,
                                    CHitObj* pHitObj, BOOLB fGlobalAsp);
    void        GetSegmentsFromFile(CFileMap& filemap, CWorkStore& WorkStore, CHitObj* pHitObj, BOOL fIsHTML = TRUE);
    void        GetLanguageEquivalents();
    void        SetLanguageEquivalent(HANDLE hKeyScriptLanguage, LPSTR szLanguageItem, LPSTR* pszOpen, LPSTR* pszClose);
    void        ThrowError(BYTE* pbErrorLocation, UINT idErrMsg);
    void        AppendErrorMessageInsert(BYTE* pbInsert, UINT cbInsert);
    void        ThrowErrorSingleInsert(BYTE* pbErrorLocation, UINT idErrMsg, BYTE* pbInsert, UINT cbInsert);
    HRESULT     ShowErrorInDebugger(CFileMap* pFilemap, UINT cchErrorLocation, char* szDescription, CHitObj* pHitObj, BOOL fAttachDocument);
    void        ProcessSpecificError(CFileMap& filemap, CHitObj* pHitObj);
    void        HandleCTemplateError(CFileMap* pfilemap, BYTE* pbErrorLocation,
                                        UINT idErrMsg, UINT cInserts, char** ppszInserts, CHitObj *pHitObj);
    void        FreeGoodTemplateMemory();
    void        UnmapFiles();

    // ExtractAndProcessSegment: gets and processes next source segment in search range
    void        ExtractAndProcessSegment(CByteRange& brSearch, const SOURCE_SEGMENT& ssegLeading,
                    _TOKEN* rgtknOpeners, UINT ctknOpeners, CFileMap* pfilemapCurrent, CWorkStore& WorkStore,
                    CHitObj* pHitObj, BOOL fScriptTagProcessed = FALSE, BOOL fIsHTML = TRUE);
    // Support methods for ExtractAndProcessSegment()
    SOURCE_SEGMENT  SsegFromHTMLComment(CByteRange& brSegment);
    void        ProcessSegment(SOURCE_SEGMENT sseg, CByteRange& brSegment, CFileMap* pfilemapCurrent,
                                CWorkStore& WorkStore, BOOL fScriptTagProcessed, CHitObj* pHitObj,
                                BOOL fIsHTML);
    void        ProcessHTMLSegment(CByteRange& brHTML, CBuffer& bufHTMLBlocks, UINT idSequence, CFileMap* pfilemapCurrent);
    void        ProcessHTMLCommentSegment(CByteRange& brSegment, CFileMap* pfilemapCurrent, CWorkStore& WorkStore, CHitObj* pHitObj);
    void        ProcessScriptSegment(SOURCE_SEGMENT sseg, CByteRange& brSegment, CFileMap* pfilemapCurrent,
                                        CWorkStore& WorkStore, UINT idSequence, BOOLB fScriptTagProcessed, CHitObj* pHitObj);
    HRESULT     ProcessMetadataSegment(const CByteRange& brSegment, UINT *pidError, CHitObj* pHitObj);
    HRESULT     ProcessMetadataTypelibSegment(const CByteRange& brSegment, UINT *pidError, CHitObj* pHitObj);
    HRESULT     ProcessMetadataCookieSegment(const CByteRange& brSegment, UINT *pidError, CHitObj* pHitObj);
	void		GetScriptEngineOfSegment(CByteRange& brSegment, CByteRange& brEngine, CByteRange& brInclude);
    void        ProcessTaggedScriptSegment(CByteRange& brSegment, CFileMap* pfilemapCurrent, CWorkStore& WorkStore, CHitObj* pHitObj);
    void        ProcessObjectSegment(CByteRange& brSegment, CFileMap* pfilemapCurrent, CWorkStore& WorkStore,
                                        UINT idSequence);
    void        GetCLSIDFromBrClassIDText(CByteRange& brClassIDText, LPCLSID pclsid);
    void        GetCLSIDFromBrProgIDText(CByteRange& brProgIDText, LPCLSID pclsid);
    BOOLB       FValidObjectName(CByteRange& brName);
    void        ProcessIncludeFile(CByteRange& brSegment, CFileMap* pfilemapCurrent, CWorkStore& WorkStore, UINT idSequence, CHitObj* pHitObj, BOOL fIsHTML);
    void        ProcessIncludeFile2(CHAR* szFileSpec, CByteRange& brFileSpec, CFileMap* pfilemapCurrent, CWorkStore& WorkStore, UINT idSequence, CHitObj* pHitObj, BOOL fIsHTML);
    BYTE*       GetOpenToken(CByteRange brSearch, SOURCE_SEGMENT ssegLeading, _TOKEN* rgtknOpeners, UINT ctknOpeners, _TOKEN* ptknOpen);
    BYTE*       GetCloseToken(CByteRange brSearch, _TOKEN tknClose);
    _TOKEN      GetComplementToken(_TOKEN tkn);
    SOURCE_SEGMENT  GetSegmentOfOpenToken(_TOKEN tknOpen);
    CByteRange  BrTagsFromSegment(CByteRange brSegment, _TOKEN tknClose, BYTE** ppbCloseTag);
    CByteRange  BrValueOfTag(CByteRange brTags, _TOKEN tknTag);
    BYTE*       GetTagName(CByteRange brTags, _TOKEN tknTagName);

    BOOL        GetTag(CByteRange &brTags, int nIndex = 1);
    BOOL        CompTagName(CByteRange &brTags, _TOKEN tknTagName);

    BOOLB       FTagHasValue(const CByteRange& brTags, _TOKEN tknTag, _TOKEN tknValue);
    void        CopySzAdv(char* pchWrite, LPSTR psz);

    // WriteTemplate: writes the template to a contiguous block of memory
    void    WriteTemplate(CWorkStore& WorkStore, CHitObj* pHitObj);
    // Support methods for WriteTemplate()
    // NOTE Adv suffix on some function names == advance ptr after writing
    void    WriteHeader(USHORT cScriptBlocks,USHORT cObjectInfos, USHORT cHTMLBlocks, UINT* pcbHeaderOffset, UINT* pcbOffsetToOffset);
    void    WriteScriptBlockOfEngine(USHORT idEnginePrelim, USHORT idEngine, CWorkStore& WorkStore, UINT* pcbDataOffset,
                                        UINT* pcbOffsetToOffset, CHitObj* pHitObj);
    void    WritePrimaryScriptProcedure(USHORT idEngine, CWorkStore& WorkStore, UINT* pcbDataOffset, UINT cbScriptBlockStart);
    void    WriteScriptSegment(USHORT idEngine, CFileMap* pfilemap, CByteRange& brScript, UINT* pcbDataOffset, UINT cbScriptBlockStart,
                                BOOL fAllowExprWrite);
    void    WriteScriptMinusEscapeChars(CByteRange brScript, UINT* pcbDataOffset, UINT* pcbPtrOffset);
    BOOLB   FVbsComment(CByteRange& brLine);
    BOOLB   FExpression(CByteRange& brLine);
    void    WriteOffsetToOffset(USHORT cBlocks, UINT* pcbHeaderOffset, UINT* pcbOffsetToOffset);
    void    WriteSzAsBytesAdv(LPCSTR szSource, UINT* pcbDataOffset);
    void    WriteByteRangeAdv(CByteRange& brSource, BOOLB fWriteAsBsz, UINT* pcbDataOffset, UINT* pcbPtrOffset);
    void    WriteLongAdv(ULONG uSource, UINT* pcbOffset);
    void    WriteShortAdv(USHORT uSource, UINT* pcbOffset);
    void    MemCpyAdv(UINT* pcbOffset, void* pbSource, ULONG cbSource, UINT cbByteAlign = 0);

    // Memory access primitives
    // NOTE invalid until WriteTemplate() has succeeded
    BYTE*   GetAddress(TEMPLATE_COMPONENT tcomp, USHORT i);

    // Debugging methods
    void    AppendSourceInfo(USHORT idEngine, CFileMap* pfilemap, BYTE* pbSource,
							 ULONG cbSourceOffset, ULONG cbScriptBlockOffset, ULONG cbTargetOffset,
							 ULONG cchSourceText, BOOL fIsHTML);
    UINT    SourceLineNumberFromPb(CFileMap* pfilemap, BYTE* pbSource);
    HRESULT CreateDocumentTree(CFileMap *pfilemapRoot, IDebugApplicationNode **ppDocRoot);
    BOOLB   FIsLangVBScriptOrJScript(USHORT idEngine);

#if 0
    void OutputDebugTables();
    void OutputIncludeHierarchy(CFileMap *pfilemap, int cchIndent);
    void GetScriptSnippets(ULONG cchSourceOffset, CFileMap *pFilemapSource, ULONG cchTargetOffset, ULONG idTargetEngine, wchar_t wszSourceText[], wchar_t wszTargetText[]);
#endif

    void    RemoveFromIncFiles();

    void    ReleaseTypeLibs();
    void    WrapTypeLibs(CHitObj *pHitObj);

    void    Release449();

    HRESULT BuildPersistedDACL(PACL  *ppRetDACL);

    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()

public:
    // memory allocation
    static void* SmallMalloc(SIZE_T dwBytes);
    static void* SmallReAlloc(void* pvMem, SIZE_T dwBytes);
    static void  SmallFree(void* pvMem);

    static void* LargeMalloc(SIZE_T dwBytes);
    static void* LargeReAlloc(void* pvMem, SIZE_T dwBytes);
    static void  LargeFree(void* pvMem);
};

////////////////////////////////////////////////////////////////////////////////
//  Inline functions

// Write a long or short to memory, then advance target-ptr
inline void     CTemplate::WriteLongAdv(ULONG uSource, UINT* pcbOffset)
                    { MemCpyAdv(pcbOffset, &uSource, sizeof(ULONG), sizeof(ULONG)); }
inline void     CTemplate::WriteShortAdv(USHORT uSource, UINT* pcbOffset)
                    { MemCpyAdv(pcbOffset, &uSource, sizeof(USHORT), sizeof(USHORT)); }
inline const CTemplateKey * CTemplate::ExtractHashKey() const
					{ return &m_LKHashKey; }
inline BOOL     CTemplate::FTransacted()
                    { return (m_ttTransacted != ttUndefined); }
inline BOOL     CTemplate::FDebuggable()
                    { return(m_fDebuggable); }
inline BOOL     CTemplate::FSession()
                    { return(m_fSession); }
inline BOOL     CTemplate::FScriptless()
                    { return m_fScriptless; }
inline BOOL     CTemplate::FIsValid()
                    { return(m_fIsValid); }
inline BOOL     CTemplate::FGlobalAsa()
                    { return(m_fGlobalAsa); }
inline BOOL     CTemplate::FIsZombie()
                    { return m_fZombie; }
inline VOID     CTemplate::Zombify()
                    { m_fZombie = TRUE; }
inline BOOL     CTemplate::FDontAttach()
                    { return (m_fDontAttach); }
inline BOOL     CTemplate::FIsPersisted()
                    { return (m_fIsPersisted); }
inline LPTSTR   CTemplate::GetApplnPath(SOURCEPATHTYPE pathtype)
                    { Assert (pathtype == SOURCEPATHTYPE_VIRTUAL); return m_szApplnVirtPath; }
inline IDispatch *CTemplate::PTypeLibWrapper()
                    { return (m_pdispTypeLibWrapper); }


/*  ****************************************************************************
    Class:      CIncFile
    Synopsis:   A file included by one or more templates.

    NOTE: We store an incfile-template dependency by storing a template ptr in m_rgpTemplates.
    This is efficient but ***will break if we ever change Denali to move its memory around***
*/
class CIncFile :
            private CLinkElem,
            public IDebugDocumentProvider,
            public IDebugDocumentText,
            public IConnectionPointContainer    // Source of IDebugDocumentTextEvents
{
// CIncFileMap is a friend so that it can manipulate CLinkElem private members and to access m_ftLastWriteTime
friend class CIncFileMap;

private:
    LONG                m_cRefs;            // ref count - NOTE LONG required by InterlockedIncrement
    TCHAR *             m_szIncFile;        // include file name - NOTE we keep this as a stable ptr to hash table key
    CRITICAL_SECTION    m_csUpdate;         // CS for updating the template ptrs array
    vector<CTemplate *> m_rgpTemplates;     // array of ptrs to templates which include this include file
    CTemplateConnPt     m_CPTextEvents;     // Connection point for IDebugDocumentTextEvents
    BOOLB               m_fCsInited;        // has CS been initialized yet?

    CTemplate::CFileMap *GetFilemap();      // Return the filemap pointer from a template

public:
                CIncFile();
    HRESULT     Init(const TCHAR* szIncFile);
                ~CIncFile();
    HRESULT     AddTemplate(CTemplate* pTemplate);
    void        RemoveTemplate(CTemplate* pTemplate);
    CTemplate*  GetTemplate(int iTemplate);
    BOOL        FlushTemplates();
    TCHAR *     GetIncFileName() { return m_szIncFile; }
    void        OnIncFileDecache();

    /*
        COM public interfaces
        Implementation of debugging documents.
    */

    // IUnknown methods
    STDMETHOD(QueryInterface)(const GUID &, void **);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IDebugDocumentProvider methods
    STDMETHOD(GetDocument)(/* [out] */ IDebugDocument **ppDebugDoc);

    // IDebugDocumentInfo (also IDebugDocumentProvider) methods
    STDMETHOD(GetName)(
        /* [in] */ DOCUMENTNAMETYPE dnt,
        /* [out] */ BSTR *pbstrName);

    STDMETHOD(GetDocumentClassId)(/* [out] */ CLSID *)
        {
        return E_NOTIMPL;
        }

    // IDebugDocumentText methods
    STDMETHOD(GetDocumentAttributes)(
        /* [out] */ TEXT_DOC_ATTR *ptextdocattr);

    STDMETHOD(GetSize)(
        /* [out] */ ULONG *pcLines,
        /* [out] */ ULONG *pcChars);

    STDMETHOD(GetPositionOfLine)(
        /* [in] */ ULONG cLineNumber,
        /* [out] */ ULONG *pcCharacterPosition);

    STDMETHOD(GetLineOfPosition)(
        /* [in] */ ULONG cCharacterPosition,
        /* [out] */ ULONG *pcLineNumber,
        /* [out] */ ULONG *pcCharacterOffsetInLine);

    STDMETHOD(GetText)(
        /* [in] */ ULONG cCharacterPosition,
        /* [size_is][length_is][out][in] */ WCHAR *pcharText,
        /* [size_is][length_is][out][in] */ SOURCE_TEXT_ATTR *pstaTextAttr,
        /* [out][in] */ ULONG *pcChars,
        /* [in] */ ULONG cMaxChars);

    STDMETHOD(GetPositionOfContext)(
        /* [in] */ IDebugDocumentContext *psc,
        /* [out] */ ULONG *pcCharacterPosition,
        /* [out] */ ULONG *cNumChars);

    STDMETHOD(GetContextOfPosition)(
        /* [in] */ ULONG cCharacterPosition,
        /* [in] */ ULONG cNumChars,
        /* [out] */ IDebugDocumentContext **ppsc);

    // IConnectionPointContainer methods
    STDMETHOD(EnumConnectionPoints)(
        /* [out] */ IEnumConnectionPoints __RPC_FAR *__RPC_FAR *ppEnum)
            {
            return E_NOTIMPL;   // doubt we need this - client is expecting only TextEvents
            }

    STDMETHOD(FindConnectionPoint)(
        /* [in] */ const IID &iid,
        /* [out] */ IConnectionPoint **ppCP);

};

#endif /* _TEMPLATE_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\strlist.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: StringList object

File: StrList.h

Owner: DGottner

This file contains the header info for defining the Request object.
Note: This was largely stolen from Kraig Brocjschmidt's Inside OLE2
second edition, chapter 14 Beeper v5.
===================================================================*/

#ifndef _StrList_H
#define _StrList_H

#include "dispatch.h"
#include "asptlb.h"
#include "memcls.h"

// Type for an object-destroyed callback
typedef void (*PFNDESTROYED)(void);


/*
 * C S t r i n g L i s t E l e m
 *
 * A String list is a linked list of CStringListElem's
 * This approach was chosen because it should cause less fragmentation
 * than an array-based approach. (At least with our current memory
 * management algorithm.)
 */
class CStringListElem
	{
private:
    DWORD   m_fBufferInUse : 1; // buffer instead of pointer?
    DWORD   m_fAllocated : 1;   // free the pointer on destructor?

	CStringListElem	*m_pNext;   // next element

    union
        {
    WCHAR   *m_szPointer;     // valid when m_fBufferInUse is FALSE
    WCHAR    m_szBuffer[48];  // valid when m_fBufferInUse is TRUE
                              // 48 hardcoded only here - sizeof() used elsewhere
        };
    
public:
	CStringListElem();
	~CStringListElem();

	HRESULT Init(char *szValue, BOOL fMakeCopy, UINT  lCodePage);

    HRESULT Init(WCHAR *wszValue, BOOL fMakeCopy);
	
	inline WCHAR *QueryValue()
	    {
	    return (m_fBufferInUse ? m_szBuffer : m_szPointer);
	    }
	    
	inline CStringListElem *QueryNext()
	    {
	    return m_pNext;
	    }
	    
	inline void SetNext(CStringListElem *pNext)
	    {
	    m_pNext = pNext;
	    }
	    
	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};



/*
 * C S t r i n g L i s t
 *
 * IStringList implementation (includes IDispatch)
 */
class CStringList : public IStringList
	{
friend class CStrListIterator;

protected:
	CSupportErrorInfo	m_ISupportErrImp;	// ISupportError implementation
	ULONG				m_cRefs;			// reference count
	PFNDESTROYED		m_pfnDestroy;		// To call on closure

private:
	CStringListElem		*m_pBegin, *m_pEnd;	// begin & end of string list
	int					m_cValues;			// number of values stored
	long				m_lCodePage;		// CodePage used in converting stored value to proper UNICODE string

	HRESULT ConstructDefaultReturn(VARIANT *);	// construct comma-separated return

public:
	CStringList(IUnknown * = NULL, PFNDESTROYED = NULL);
	~CStringList();

	HRESULT AddValue(char *szValue, BOOL fDuplicate = FALSE, UINT lCodePage = CP_ACP);

	HRESULT AddValue(WCHAR *szValue, BOOL fDuplicate = FALSE);

	// IUnknown implementation
	//
	STDMETHODIMP		 	QueryInterface(const IID &rIID, void **ppvObj);
	STDMETHODIMP_(ULONG) 	AddRef();
	STDMETHODIMP_(ULONG) 	Release();

	// IStringList implementation
	//
	STDMETHODIMP			get_Item(VARIANT varIndex, VARIANT *pvarOut);
	STDMETHODIMP			get_Count(int *pcValues);
	STDMETHODIMP			get__NewEnum(IUnknown **ppEnum);
	
	// Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
	};



/*
 * C S t r L i s t I t e r a t o r
 *
 * IEnumVariant implementation for all Request collections except
 * ServerVariables
 */

class CStrListIterator : public IEnumVARIANT
	{
public:
	CStrListIterator(CStringList *pStrings);
	~CStrListIterator();

	// The Big Three

	STDMETHODIMP			QueryInterface(const GUID &, void **);
	STDMETHODIMP_(ULONG)	AddRef();
	STDMETHODIMP_(ULONG)	Release();

	// standard methods for iterators

	STDMETHODIMP	Clone(IEnumVARIANT **ppEnumReturn);
	STDMETHODIMP	Next(unsigned long cElements, VARIANT *rgVariant, unsigned long *pcElementsFetched);
	STDMETHODIMP	Skip(unsigned long cElements);
	STDMETHODIMP	Reset();

private:
	ULONG				m_cRefs;		// reference count
	CStringList *		m_pStringList;	// pointer to iteratee
	CStringListElem *	m_pCurrent;		// pointer to current element in target CStringList
	};

#endif  // _StrList_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\template.cpp ===
//depot/private/jasbr/inetsrv/iis/svcs/cmp/asp/template.cpp#19 - edit change 3548 (text)
/*==============================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

File:           template.cpp
Maintained by:  DaveK
Component:      source file for Denali Compiled Template object
==============================================================================*/
#include "denpre.h"

#pragma hdrstop

const int SNIPPET_SIZE = 20;    // # of characters in the code snippets

#pragma warning( disable : 4509 )   // suppress SEH/destructor warnings
#pragma warning( disable : 4355 )   // ignore: "'this' used in base member init

#include "debugger.h"
#include "dbgutil.h"
#include "tlbcache.h"
#include "ie449.h"

#include "memchk.h"
#include "vecimpl.h"    // Include after memchk to insure that vector uses our mem manager.

#include "Accctrl.h"
#include "aclapi.h"

// Init class statics
CTemplate::CTokenList *CTemplate::gm_pTokenList = NULL;
PTRACE_LOG CTemplate::gm_pTraceLog = NULL;
HANDLE CTemplate::sm_hSmallHeap = NULL;
HANDLE CTemplate::sm_hLargeHeap = NULL;

// Max # of opener tokens to look for
#define TOKEN_OPENERS_MAX   8

/*===================================================================
    Private non-class support functions
===================================================================*/
static void       ByteRangeFromPb(BYTE* pbSource, CByteRange& brTarget);
static BOOLB      FByteRangesAreEqual(CByteRange& br1, CByteRange& br2);
static unsigned   CharAdvDBCS(WORD wCodePage, char *pchStart, char *pchEnd, unsigned cCharAdv, char **ppchEnd, BOOL fForceDBCS = FALSE);
static void       LineFromByteRangeAdv(CByteRange& br, CByteRange& brLine);
static void       LTrimWhiteSpace(CByteRange& br);
static void       RTrimWhiteSpace(CByteRange& br);
static CByteRange BrNewLine(CByteRange br);
static BOOLB      FWhiteSpace(char ch, BOOLB fSpaceIsWhiteSpace = TRUE);
static BOOLB      FByteRangeIsWhiteSpace(CByteRange br);
static BOOLB      FTagName(BYTE* pb, UINT cb);
static void       ByteAlignOffset(UINT* pcbOffset, UINT cbAlignment);
static void       GetSzFromPatternInserts(char* pszPattern, UINT cInserts, char** ppszInserts, char* szReturned);
static UINT       CchPathFromFilespec(LPCTSTR szFile);
static void       GetPathFromParentAndFilespec(LPCTSTR szParentPath, LPCTSTR szFileSpec, LPTSTR* pszPath);
static void       HandleAccessFailure(CHitObj* pHitObj, TCHAR* szFile);
static void       SendToLog(DWORD dwMask, CHAR *szFileName, CHAR *szLineNum, CHAR *szShortDes, CHAR *szLongDes, CHAR *szEngine, CHitObj *pHitObj);
static HRESULT    GetProgLangId(CByteRange& brEngine, PROGLANG_ID* pProgLangId);

inline
void __cdecl DebugPrintf(LPCSTR fmt, ...)
    {
#if DBG
    char msg[512];
    va_list marker;
    va_start(marker, fmt);
    vsprintf(msg, fmt, marker);
    va_end(marker);
    OutputDebugStringA(msg);
#endif
    }


/*  ============================================================================
    ByteRangeFromPb
    Gets a byte range from a contiguous block of memory

Returns:
    Nothing.

Side effects:
    None.
*/
void
ByteRangeFromPb
(
BYTE*       pbSource,
CByteRange& brTarget
)
    {
    Assert(pbSource != NULL);
    brTarget.m_cb = *(ULONG*)pbSource;
    brTarget.m_pb = pbSource + sizeof(ULONG);
    }

/*  ============================================================================
    FByteRangesAreEqual

    Compares two byte ranges

    Returns:
        BOOLB. True if byte ranges are equal, else false.

    Side effects:
        None.
*/
BOOLB
FByteRangesAreEqual
(
CByteRange& br1,
CByteRange& br2
)
    {
    if(br1.m_cb != br2.m_cb)
        return FALSE;
    return (!_strnicmp((LPCSTR)br1.m_pb, (LPCSTR)br2.m_pb, br1.m_cb));
    }

/*  ============================================================================
    CharAdvDBCS

    Advance "cchCharAdv" characters in a buffer
    SBCS: Degenerates to simple pointer arithmatic

    Arguments:
            wCodePage       - code page
            pchStart        - pointer to beginning of segment
            pchEnd          - pointer to just past end of segment
            cCharAdv        - # of characters to advance
            ppchEnd         - [output], contains pointer "cCharAdv" chars past pchStart
            fForceDBCS      - if TRUE, always use double byte algorithm.
                                (for verifying correct behavior of func in debug mode)

    Returns:
        (int) # of characters that we actually advanced

    Notes:
        By passing INFINITE for "cCharAdv", you can use this function to count characters
        in a block

    Side effects:
        None.
*/
unsigned
CharAdvDBCS
(
WORD wCodePage,
char *pchStart,
char *pchEnd,
unsigned cCharAdv,
char **ppchEnd,
BOOL fForceDBCS
)
    {
    CPINFO CpInfo;
    GetCPInfo(wCodePage, &CpInfo);
    if (!fForceDBCS && CpInfo.MaxCharSize == 1)
        {
        char *pchT = pchStart + min(cCharAdv, unsigned(pchEnd - pchStart));

        if (ppchEnd)
            *ppchEnd = pchT;

        #if DBG
            // Verify DBCS algorithm (not often tested otherwise)
            char *pchTest;
            unsigned cchTest = CharAdvDBCS(wCodePage, pchStart, pchEnd, cCharAdv, &pchTest, TRUE);
            Assert (cchTest == unsigned(pchT - pchStart) && pchTest == pchT);
        #endif

        return DIFF(pchT - pchStart);
        }
    else
        {
        int cch = 0;
        char *pchNext = pchStart;

        // Count DBCS characters. We have to stop before pchEnd because
        // pchEnd may point past file map and CharNextExA AVs when advancing
        // past allocated memory

        while (cCharAdv > 0 && pchNext < pchEnd-2)
            {
            pchNext = *pchNext? AspCharNextA(wCodePage, pchNext) : pchNext + 1;
            --cCharAdv;
            ++cch;
            }

        // We could stop on the last or the before last character
        // depending on the DBCS char sequence
        if (cCharAdv > 0 && pchNext == pchEnd-1)
            {
            // Only one byte - has to be one single byte character
            ++pchNext;
            ++cch;
            }

        else if (cCharAdv > 0 && pchNext == pchEnd-2)
            {
            // 2 bytes left - either 1 2-byte char or 2 1-byte chars
            if (IsDBCSLeadByteEx(wCodePage, *pchNext))
                {
                ++cch;
                pchNext += 2;
                }
            else
                {
                // Two characters left. If cCharAdv > 1, this means that user wants to
                // advance at least two more chars. Otherwise, cCharAdv == 1, and
                // we advance one char
                //
                if (cCharAdv > 1)
                    {
                    cch += 2;
                    pchNext += 2;
                    }
                else
                    {
                    Assert (cCharAdv == 1);
                    ++cch;
                    ++pchNext;
                    }
                }
            }

        if (ppchEnd)
            *ppchEnd = pchNext;

        return cch;
        }
    }

/*  ============================================================================
    LineFromByteRangeAdv
    Gets the first line in a byte range.

    Returns:
        Nothing

    Side effects:
        Advances source byte range to just beyond its first non-white-space line,
        if one is found.

*/
void
LineFromByteRangeAdv
(
CByteRange& brSource,
CByteRange& brLine
)
    {
    CByteRange brTemp;

    if(brSource.IsNull())
        {
        brLine.Nullify();
        return;
        }

    brLine.m_pb = brSource.m_pb;

        brTemp = BrNewLine(brSource);
    if(brTemp.IsNull())
        {
        // We found no newline in a non-empty byte range:
        // set line range to entire source byte range and empty source byte range
        brLine.m_cb = brSource.m_cb;
        brSource.Nullify();
        }
    else
        {
        // We found a newline in a non-empty byte range:
        // set line range to portion of source byte range before new line;
        // set source range to portion of source range after new line
        brLine.m_cb = DIFF(brTemp.m_pb - brSource.m_pb);
        brSource.m_pb = brTemp.m_pb + brTemp.m_cb;
        brSource.m_cb -= (brLine.m_cb + brTemp.m_cb);
        }
    }

/*  ============================================================================
LTrimWhiteSpace

Left-trim white space from byte-range

Returns:
    Nothing

Side effects:
    Advances byte range to just beyond its first non-white-space character.

*/
void
LTrimWhiteSpace
(
CByteRange& br
)
    {
    if(br.IsNull())
        return;
    while(FWhiteSpace(*br.m_pb))
        {
        br.m_pb++;
        if(--br.m_cb == 0)
            return;
        }
    }

/*  ============================================================================
    RTrimWhiteSpace
    Right-trim white space from byte-range
*/
void
RTrimWhiteSpace(CByteRange& br)
    {
    if(br.IsNull())
        return;
    while(FWhiteSpace(*(br.m_pb + br.m_cb - 1)))
        {
        if(--br.m_cb == 0)
            return;
        }
    }

/*  ============================================================================
    BrNewLine
    Returns ptr to the first newline in a byte range
    NOTE does not change byte range (since it is passed by value)
*/
CByteRange
BrNewLine(CByteRange br)
    {
    while(!br.IsNull())
        {
        if(*br.m_pb == '\r')
                        return CByteRange(br.m_pb, (br.m_cb > 1 && br.m_pb[1] == '\n')? 2 : 1);

        else if (*br.m_pb == '\n')
                return CByteRange(br.m_pb, 1);

        ++br.m_pb;
        --br.m_cb;
        }
    return CByteRange();
    }

/*  ============================================================================
    FWhiteSpace
    Returns:
        TRUE if ch is a white-space character, else returns FALSE
        Certain character(s) (e.g. space) may be treated as
        non-white-space; to do this, caller passes FALSE for
        fSpaceIsWhiteSpace flag.
*/
BOOLB
FWhiteSpace(char ch, BOOLB fSpaceIsWhiteSpace)
{
    switch (ch)
    {
        case ' ':
            return fSpaceIsWhiteSpace;
        case '\0':
            return TRUE;
        case '\a':
            return TRUE;
        case '\b':
            return TRUE;
        case '\f':
            return TRUE;
        case '\n':
            return TRUE;
        case '\r':
            return TRUE;
        case '\t':
            return TRUE;
        case '\v':
            return TRUE;
        default:
            return FALSE;
    }
}

/*  ============================================================================
    FByteRangeIsWhiteSpace
    Is the entire input byte range white space?
    NOTE input byte range is byval; caller's copy is not changed
*/
BOOLB
FByteRangeIsWhiteSpace(CByteRange br)
    {
    while(!br.IsNull())
        {
        if(!FWhiteSpace(*(br.m_pb)))
            return FALSE;
        br.Advance(1);
        }

    return TRUE;
    }

/*  ============================================================================
    FTagName
    Does pb point to a valid HTML tag name?
    (i.e., is *pb a valid HTML tag name and not a substring?)

    Returns
        TRUE or FALSE
    Side effects
        None
*/
BOOLB
FTagName(BYTE* pb, UINT cb)
    {
    if((pb == NULL) || (cb == 0))
        return FALSE;

    // a valid HTML tag name must be preceded by white space  ...
    if( FWhiteSpace(*(pb - 1)) ||  *(pb - 1) == '@' )
        {
        // ... and followed either by white space or the tag separator
        if(FWhiteSpace(*(pb + cb)))
            return TRUE;
        else if(*(pb + cb) == CH_ATTRIBUTE_SEPARATOR)
            return TRUE;
        }

    return FALSE;
    }

/*===================================================================
    ByteAlignOffset
    Byte-aligns an offset value, based on size of source data
*/
void
ByteAlignOffset
(
UINT*   pcbOffset,      // ptr to offset value
UINT    cbAlignment // Alignment boundary
)
    {
        // comment the below code out so that it works for 64 bit...

    // only byte-align for 2-, or 4-byte data
    // since our base pointer in only aligned to a 4 byte boundary
    //if(cbAlignment == 2 || cbAlignment == 4)
        //{
        // if current offset does not fall on a byte-aligned location for current data type,
        // advance offset to next byte-aligned location
                Assert(cbAlignment > 0);
        --cbAlignment;
                if (*pcbOffset & cbAlignment)
                        *pcbOffset = (*pcbOffset + cbAlignment + 1) & ~cbAlignment;
    }

/*  ============================================================================
    GetSzFromPatternInserts
    Returns a 'resolved' version of a pattern string, i.e. a new string in which
    | characters have been replaced by caller-specified insert strings.
    NOTE this function allocates, but caller must free

    Returns:
        Nothing
    Side effects:
        allocates memory
*/
void
GetSzFromPatternInserts
(
char*   pszPattern,     // 'pattern' string
UINT    cInserts,       // count of insert strings
char**  ppszInserts,    // array of ptrs to insert strings
char*   szReturned      // returned string MUST be allocated by caller
)
    {
    UINT    cchRet = strlen(pszPattern);   // length of return string
    char*   pchStartCopy = pszPattern;      // ptr to start of copy range in pattern
    char*   pchEndCopy = pszPattern;        // ptr to end of copy range in pattern
    UINT    cActualInserts = 0;             // count of actual insert strings

    // init return string to empty so we can concatenate onto it
    szReturned[0] = NULL;

    // zero out length of return string - we now use it to count actual length as we build return string
    cchRet = 0;

    while(TRUE)
        {
        // advance end-of-copy ptr through pattern looking for insertion points or end of string

        while ((*pchEndCopy != NULL) && (IsDBCSLeadByte(*pchEndCopy) || (*pchEndCopy != '|')))
            pchEndCopy = CharNextA(pchEndCopy);

        // cat from start-of-copy to end-of-copy onto return string
        strncat(szReturned, pchStartCopy, DIFF(pchEndCopy - pchStartCopy));

        // update return string length
        cchRet += DIFF(pchEndCopy - pchStartCopy);

        // if we are at end of pattern, exit
        if(*pchEndCopy == NULL)
            goto Exit;

        if(cActualInserts < cInserts)
            {
            // if inserts remain, cat the next one onto return string
            strcat(szReturned, ppszInserts[cActualInserts]);
            // update return string length
            cchRet += strlen(ppszInserts[cActualInserts]);
            cActualInserts++;
            }

        // advance end-of-copy and start-of-copy beyond insertion point
        pchEndCopy++;
        pchStartCopy = pchEndCopy;
        }

Exit:
    // null-terminate return string
    szReturned[cchRet] = NULL;
    }

/*  ============================================================================
    CchPathFromFilespec
    Returns a filespec's path length (exclusive of filespec)
    NOTE path string includes trailing '\' or '/'

    Returns:
        Length of path string
    Side effects:
        None
*/
UINT
CchPathFromFilespec
(
LPCTSTR  szFileSpec  // filespec
)
    {
    // BUG FIX 102010 DBCS fixes
    //int   ich = lstrlen(szFileSpec) - 1;  // index of char to compare
    //
    //while(*(szFileSpec + ich) != '\\' && *(szFileSpec + ich) != '/')
    //  {
    //  if(--ich < 0)
    //      THROW(E_FAIL);
    //  }
    //return (UINT) (ich + 1);  // path length, including trailing '\' or '/', is char index + 1

    TCHAR* p1 = _tcsrchr(szFileSpec, _T('\\'));
    TCHAR* p2 = _tcsrchr(szFileSpec, _T('/'));        // this wont be a DBCS trail byte.

    if (p1 == NULL && p2 == NULL)
        THROW(E_FAIL);

    return (UINT) ((((LPTSTR)max(p1,p2) - szFileSpec)) + 1);
    }

/*  ============================================================================
    GetPathFromParentAndFilespec
    Returns an absolute path which is a 'parent' file's path concatenated with a filespec.

    Returns:
        absolute path (out-parameter)
    Side effects:
        None
*/
void
GetPathFromParentAndFilespec
(
LPCTSTR  szParentPath,   // parent path
LPCTSTR  szFileSpec,     // filespec
LPTSTR*  pszPath         // resolved path (out-parameter)
)
    {
    UINT    cchParentPath = CchPathFromFilespec(szParentPath);

	if ((cchParentPath + _tcslen(szFileSpec)) > MAX_PATH)
		THROW(E_FAIL);
	
    _tcsncpy(*pszPath, szParentPath, cchParentPath);
    _tcscpy(*pszPath + cchParentPath, szFileSpec);
    }

/*  ============================================================================
    HandleAccessFailure
    Handles an access-denied failure

    Returns:
        nothing
    Side effects:
        none
*/
void
HandleAccessFailure
(
CHitObj*    pHitObj,	// browser's hitobj
TCHAR *     szFile		// file path of main template
)
    {
    Assert(pHitObj);

        // debugging diagnostic print
#if DBG

    STACK_BUFFER( authUserBuff, 32 );

    char *szAuthUser;
    DWORD cbAuthUser;

    if (SERVER_GET(pHitObj->PIReq(), "AUTH_USER", &authUserBuff, &cbAuthUser)) {
	    szAuthUser = (char*)authUserBuff.QueryPtr();
    }
    else {
            szAuthUser = "anonymous";
    }

#if UNICODE
	DBGPRINTF((DBG_CONTEXT, "No permission to read file %S\n", szFile != NULL? szFile : pHitObj->PIReq()->QueryPszPathTranslated()));
#else
	DBGPRINTF((DBG_CONTEXT, "No permission to read file %s\n", szFile != NULL? szFile : pHitObj->PIReq()->QueryPszPathTranslated()));
#endif
    DBGPRINTF((DBG_CONTEXT, "  The user account is \"%s\"\n", szAuthUser));
#endif

    CResponse *pResponse = pHitObj->PResponse();
    if (!pResponse)
        return;

    HandleSysError(401,3,IDE_401_3_ACCESS_DENIED,IDH_401_3_ACCESS_DENIED,pHitObj->PIReq(),pHitObj);


    return;
    }

/*  ============================================================================
    SendToLog
    Sends Error Info to Log

    Returns:
        Nothing

    Side effects:
        None.
*/
void
SendToLog
(
DWORD   dwMask,
CHAR    *szFileName,
CHAR    *szLineNum,
CHAR    *szEngine,
CHAR    *szErrCode,
CHAR    *szShortDes,
CHAR    *szLongDes,
CHitObj *pHitObj    // browser's hitobj
)
{
    CHAR    *szFileNameT;
    CHAR    *szLineNumT;
    CHAR    *szEngineT;
    CHAR    *szErrCodeT;
    CHAR    *szShortDesT;
    CHAR    *szLongDesT;
    if(pHitObj) {
        // NOTE - szFileName is assumed to be UTF8 when UNICODE is defined
        szFileNameT = StringDupA(szFileName);
        szLineNumT  = StringDupA(szLineNum);
        szEngineT   = StringDupA(szEngine);
        szErrCodeT  = StringDupA(szErrCode);
        szShortDesT = StringDupA(szShortDes);
        szLongDesT  = StringDupA(szLongDes);

        HandleError(szShortDesT, szLongDesT, dwMask, szFileNameT, szLineNumT, szEngineT, szErrCodeT, NULL, pHitObj);
        }
    }

/*  ============================================================================
    FreeNullify
    Frees and nullifies a ptr to memory allocated with malloc.

    Returns:
        Nothing
    Side effects:
        None
*/
static void
FreeNullify
(
void**  pp
)
    {
    if(*pp != NULL)
        {
        free(*pp);
        *pp = NULL;
        }
    }

/*  ============================================================================
    SmallTemplateFreeNullify
    Frees and nullifies a ptr to memory allocated with CTemplate::SmallMalloc.

    Returns:
        Nothing
    Side effects:
        None
*/
static void
SmallTemplateFreeNullify
(
void**  pp
)
    {
    if(*pp != NULL)
        {
        CTemplate::SmallFree(*pp);
        *pp = NULL;
        }
    }

/*  ============================================================================
    LargeTemplateFreeNullify
    Frees and nullifies a ptr to memory allocated with CTemplate::LargeMalloc.

    Returns:
        Nothing
    Side effects:
        None
*/
static void
LargeTemplateFreeNullify
(
void**  pp
)
    {
    if(*pp != NULL)
        {
        CTemplate::LargeFree(*pp);
        *pp = NULL;
        }
    }

/*  ============================================================================
    GetProgLangId
    Gets the prog lang id for a script engine

    Returns:
        Nothing
    Side effects:
        throws on error
*/
HRESULT
GetProgLangId
(
CByteRange&     brEngine,   // engine name
PROGLANG_ID*    pProgLangId // prog lang id (out-parameter)
)
    {

    STACK_BUFFER( tempEngine, 128 );

    if (!tempEngine.Resize(brEngine.m_cb + 1)) {
        return E_OUTOFMEMORY;
    }

    LPSTR           szProgLang = static_cast<LPSTR> (tempEngine.QueryPtr());

    strncpy(szProgLang, (LPCSTR)brEngine.m_pb, brEngine.m_cb);
    szProgLang[brEngine.m_cb] = '\0';

    return g_ScriptManager.ProgLangIdOfLangName((LPCSTR) szProgLang, pProgLangId);
    }

/*  ****************************************************************************
    CByteRange member functions
*/

/*  ========================================================
    CByteRange::Advance
    Advances a byte range.
*/
void
CByteRange::Advance(UINT i)
    {
    if(i >= m_cb)
        {
        Nullify();
        }
    else
        {
        m_pb += i;
        m_cb -= i;
        }
    }

/*  ========================================================
    CByteRange::FMatchesSz
    Compares a byte range with a string, case-insensitively
*/
BOOLB
CByteRange::FMatchesSz
(
LPCSTR psz
)
    {
    if(IsNull() || (psz == NULL))
        return FALSE;
    if((ULONG)strlen(psz) != m_cb)
        return FALSE;
    return !_strnicmp((const char*)m_pb, psz, m_cb);
    }

/*  ============================================================================
    CByteRange::PbString
    Finds a case-insensitive string within a byte range

    Returns:
        Ptr to first case-insensitive occurrence of the string in this byte range;
        NULL if none found.
    Side effects:
        None
*/
BYTE*
CByteRange::PbString
(
LPSTR   psz,
LONG    lCodePage
)
    {
    UINT cch = strlen(psz);
    if(cch == 0)
        return NULL;

    BYTE *pbLocal  = m_pb;
    UINT  cbLocal  = m_cb;
    char  ch0 = psz[0];
    BYTE *pbTemp = NULL;
    UINT cbAdvanced = 0;

    if (IsCharAlpha(ch0))
        {
        // cannot use strchr
        while (cbLocal >= cch)
            {
            if (_strnicmp((const char *)pbLocal, psz, cch) == 0)
                return pbLocal;

            // The following code simply performs a DBCS-enabled ByteRange.Advance() action.
            pbTemp = pbLocal;
            pbLocal = *pbLocal? (BYTE *)AspCharNextA((WORD)lCodePage, (const char *)pbLocal) : pbLocal + 1;
            cbAdvanced = DIFF(pbLocal - pbTemp);
            if (cbAdvanced >= cbLocal)
                {
                cbLocal = 0;
                pbLocal = NULL;
                }
            else
                cbLocal -= cbAdvanced;
            }
        }
    else
        {
        // can use strchr
        while (cbLocal >= cch)
            {
            pbTemp = (BYTE *)memchr(pbLocal, ch0, cbLocal);
            if (pbTemp == NULL)
                break;
            UINT cbOffset = DIFF(pbTemp - pbLocal);
            if (cbOffset >= cbLocal)
                break;
            pbLocal = pbTemp;
            cbLocal -= cbOffset;
            if (cch <= cbLocal && _strnicmp((const char *)pbLocal, psz, cch) == 0)
                return pbLocal;
            // The following code simply performs a DBCS-enabled ByteRange.Advance() action.
            pbTemp = pbLocal;
            pbLocal = *pbLocal? (BYTE *)AspCharNextA((WORD)lCodePage, (const char *)pbLocal) : pbLocal + 1;
            cbAdvanced = DIFF(pbLocal - pbTemp);
            if (cbAdvanced >= cbLocal)
                {
                cbLocal = 0;
                pbLocal = NULL;
                }
            else
                cbLocal -= cbAdvanced;
            }
        }

    return NULL;
    }

/*  ============================================================================
    CByteRange::PbOneOfAspOpenerStringTokens
    Finds a case-insensitive string within a byte range
        that matches one of the strings passed

!!! WILL ONLY WORK IF THE FOLLOWING IS TRUE:
        1) All the tokens start with the same charater (for example '<')
        2) This character is not alpha (so that strchr() would work)
!!! THE ABOVE ASSUMPTIONS MAKE THE CODE WORK FASTER

    Returns:
        Ptr to first case-insensitive occurrence of the string in this byte range;
        NULL if none found.
        *pcindex is set to the index of string found
    Side effects:
        None
*/
BYTE*
CByteRange::PbOneOfAspOpenerStringTokens
(
LPSTR rgszTokens[],
UINT rgcchTokens[],
UINT nTokens,
UINT *pidToken
)
{
    if (nTokens == 0)
        return NULL;

    BYTE *pb  = m_pb;               // pointer to unsearched remainder of the range
    UINT  cbRemainder = m_cb;       // remaining byte range length
    char  ch0 = rgszTokens[0][0];   // first char of every token

    while (cbRemainder > 0) {
        // BUG 82331: avoid strchr() because byte range is not null-terminated
        while (cbRemainder > 0 && *pb != ch0)
            {
            ++pb;
            --cbRemainder;
            }

        if (cbRemainder == 0)
            break;

        for (UINT i = 0; i < nTokens; i++) {

            if ((rgcchTokens[i] <= cbRemainder)
                && (rgszTokens[i] != NULL)
                && (_strnicmp((const char *)pb, rgszTokens[i], rgcchTokens[i]) == 0)) {

                *pidToken = i;
                return pb;
            }
        }
        ++pb;
        --cbRemainder;
    }

    return NULL;
}


/*  ============================================================================
    CByteRange::FEarlierInSourceThan
    Does this byte range occur earlier in source than parameter byte range?

    Returns
        TRUE or FALSE
    Side effects
        None
*/
BOOLB
CByteRange::FEarlierInSourceThan(CByteRange& br)
    {
    if(br.IsNull())
        return TRUE;
    return(m_idSequence < br.m_idSequence);
    }

/*  ****************************************************************************
    CTemplate member functions
*/

/*  ============================================================================
    CTemplate::InitClass
    Initilaizes CTemplate static members

    Returns:
        hresult
    Side effects:
        allocates memory for static members
*/
HRESULT
CTemplate::InitClass
(
)
    {
    HRESULT hr = S_OK;

    TRY
        // init heaps
        sm_hSmallHeap = ::HeapCreate(0, 0, 0);
        sm_hLargeHeap = ::HeapCreate(0, 0, 0);

        // Init token list
        gm_pTokenList = new CTokenList;
                if (gm_pTokenList == NULL)
                        return E_OUTOFMEMORY;

        gm_pTokenList->Init();

    CATCH(hrException)
        hr = hrException;
    END_TRY

    return hr;
    }

/*  ============================================================================
    CTemplate::UnInitClass
    Un-initilaizes CTemplate static members

    Returns:
        Nothing
    Side effects:
        None
*/
void
CTemplate::UnInitClass()
    {
    delete gm_pTokenList;
    gm_pTokenList = NULL;

    ::HeapDestroy(sm_hLargeHeap);
    if (sm_hLargeHeap != sm_hSmallHeap)
        ::HeapDestroy(sm_hSmallHeap);
    sm_hLargeHeap = sm_hSmallHeap = NULL;
    }


/*  ============================================================================
    CTemplate::Init
    Inits template in preparation for calling Compile
    Does the minimum needed

    Returns:
        Success or failure code
    Side effects:
        Allocates memory
*/
HRESULT
CTemplate::Init
(
CHitObj            *pHitObj,            // ptr to template's hit object
BOOL                fGlobalAsa,         // is this the global.asa file?
const CTemplateKey &rTemplateKey        // hash table key
)
    {
    HRESULT hr;

    // Create debug critical section
    ErrInitCriticalSection(&m_csDebuggerDetach, hr);
    if (FAILED(hr))
        return hr;

    // note critical section creation success
    m_fDebuggerDetachCSInited = TRUE;

    // Create event: manual-reset, ready-for-use event; non-signaled
    m_hEventReadyForUse = IIS_CREATE_EVENT(
                              "CTemplate::m_hEventReadyForUse",
                              this,
                              TRUE,     // flag for manual-reset event
                              FALSE     // flag for initial state
                              );
    if (!m_hEventReadyForUse)
        return E_OUTOFMEMORY;

    // cache GlobalAsp flag
    m_fGlobalAsa = BOOLB(fGlobalAsa);

    // CIsapiReqInfo better be present
    if (pHitObj->PIReq() == NULL)
        return E_POINTER;

    // Initialize the template's code page

    m_wCodePage = pHitObj->PAppln()->QueryAppConfig()->uCodePage();
    m_lLCID = pHitObj->PAppln()->QueryAppConfig()->uLCID();

    STACK_BUFFER( serverNameBuff, 32 );
    STACK_BUFFER( serverPortBuff, 10 );
    STACK_BUFFER( portSecureBuff, 8 );

    DWORD cbServerName;
    DWORD cbServerPort;
        DWORD cbServerPortSecure;

    // Construct a URL for the application

    // Get the server name and port
    if (!SERVER_GET(pHitObj->PIReq(), "SERVER_NAME", &serverNameBuff, &cbServerName)
        || !SERVER_GET(pHitObj->PIReq(), "SERVER_PORT", &serverPortBuff, &cbServerPort)) {

        if (GetLastError() == E_OUTOFMEMORY) {
            hr = E_OUTOFMEMORY;
        }
        else {
            hr = E_FAIL;
        }
        return hr;
    }

    char *szServerPort = (char *)serverPortBuff.QueryPtr();
    char *szServerName = (char *)serverNameBuff.QueryPtr();

    BOOL fServerPortSecure = FALSE;

	// determine if server port is secure
    if (SERVER_GET(pHitObj->PIReq(), "SERVER_PORT_SECURE", &portSecureBuff, &cbServerPortSecure)) {
	    char *szServerPortSecure = (char *)portSecureBuff.QueryPtr();
        fServerPortSecure = (szServerPortSecure[0] == '1');
    }

    // Get the application virtual path
    TCHAR szApplnVirtPath[256];
    if (FAILED(hr = FindApplicationPath(pHitObj->PIReq(), szApplnVirtPath, sizeof szApplnVirtPath)))
        return hr;

    TCHAR   *szServerNameT;
    TCHAR   *szServerPortT;

#if UNICODE
    CMBCSToWChar convServer;
    if (FAILED(hr = convServer.Init(szServerName))) {
        return hr;
    }
    szServerNameT = convServer.GetString();
#else
    szServerNameT = szServerName;
#endif

#if UNICODE
    CMBCSToWChar convPort;
    if (FAILED(hr = convPort.Init(szServerPort))) {
        return hr;
    }
    szServerPortT = convPort.GetString();
#else
    szServerPortT = szServerPort;
#endif

    // Allocate space for and construct the application URL
    m_szApplnURL = new TCHAR [(9 /* sizeof "https://:" */ + _tcslen(szServerNameT) + _tcslen(szServerPortT) + _tcslen(szApplnVirtPath) + 1)];
    if (m_szApplnURL == NULL)
        return E_OUTOFMEMORY;

    TCHAR *pT;

    // start with the protocol prefix...

    pT = strcpyEx(m_szApplnURL, fServerPortSecure? _T("https://") : _T("http://"));

    // next add the servername

    pT = strcpyEx(pT, szServerNameT);

    // next the colon between the servername and the serverport

    pT = strcpyEx(pT, _T(":"));

    // next the server port

    pT = strcpyEx(pT, szServerPortT);

    // now the applURL is built up to the appln path.  The next step will be to
    // add the virtpath.  

    m_szApplnVirtPath = pT;

    _tcscpy(m_szApplnVirtPath, szApplnVirtPath);

    m_LKHashKey.dwInstanceID = rTemplateKey.dwInstanceID;
    if ((m_LKHashKey.szPathTranslated = StringDup((TCHAR *)rTemplateKey.szPathTranslated)) == NULL)
    	return E_OUTOFMEMORY;

    return S_OK;
    }

/*  ============================================================================
    CTemplate::Compile
    Compiles the template from its source file and include files, if any,
    by calling GetSegmentsFromFile (to populate WorkStore),
    followed by WriteTemplate (to create the template from WorkStore).

    Returns:
        HRESULT indicating success or type of failure
    Side effects:
        Indirectly allocates memory (via WriteTemplate)
        Indirectly frees memory on error (via FreeGoodTemplateMemory)
*/
HRESULT
CTemplate::Compile
(
CHitObj*    pHitObj
)
    {
    HRESULT hr = S_OK;

    // The following code moved from Init() (to make Init() lighter)

    Assert(pHitObj);

    // Create and Init WorkStore

    if (SUCCEEDED(hr))
        {
        // construct the workstore - bail on fail
        if(NULL == (m_pWorkStore = new CWorkStore))
            hr = E_OUTOFMEMORY;
        }

    if (SUCCEEDED(hr))
        {
        hr = (m_pWorkStore->m_ScriptStore).Init(pHitObj->QueryAppConfig()->szScriptLanguage(),
                                                pHitObj->QueryAppConfig()->pCLSIDDefaultEngine());

        if (hr == TYPE_E_ELEMENTNOTFOUND)
            {
            // default script language in registry is bogus - send error msg to browser
            HandleCTemplateError(
                                NULL,                                   // source file map
                                NULL,                                   // ptr to source location where error occurred
                                IDE_TEMPLATE_BAD_PROGLANG_IN_REGISTRY,  // error message id
                                0,                                      // count of insert strings for error msg
                                NULL,                                   // array of ptrs to error msg insert strings
                                pHitObj                                 // Browser Request
                                );
            }

        if (FAILED(hr))
            {
            delete m_pWorkStore;
            m_pWorkStore = NULL;
            }
        }

    // Try to init the workstore and map main file - this can fail with oom, etc or user lacks permissions

    if (SUCCEEDED(hr))
        {
        TRY
            m_pWorkStore->Init();
            AppendMapFile(
                        NULL,       // file spec for this file - NULL means get filespec from pHitObj
                        NULL,       // ptr to filemap of parent file
                        FALSE,      // don't care
                        pHitObj,    // ptr to template's hit object
                        m_fGlobalAsa    // is this the global.asa file?
                        );

        CATCH(hrException)
            delete m_pWorkStore;
            m_pWorkStore = NULL;

            hr = hrException;

            if(hr == E_USER_LACKS_PERMISSIONS)
                HandleAccessFailure(pHitObj,
                                                                        (m_rgpFilemaps && m_rgpFilemaps[0])? m_rgpFilemaps[0]->m_szPathTranslated : NULL);

            if (m_rgpFilemaps && m_rgpFilemaps[0])
                {
                // empty file will fail to map but will have a handle, so we check for it here
                if (0 == GetFileSize(m_rgpFilemaps[0]->m_hFile, NULL))
                    hr = E_SOURCE_FILE_IS_EMPTY;

                m_rgpFilemaps[0]->UnmapFile();
                }

            if (SUCCEEDED(hr))
                hr = E_FAIL;    // make sure the error is set
        END_TRY
        }

    if (SUCCEEDED(hr))
        {
        Assert(m_rgpFilemaps[0]);
        Assert(m_rgpFilemaps[0]->m_szPathTranslated);
        Assert(FImplies(!m_fGlobalAsa, (0 == _tcscmp(m_rgpFilemaps[0]->m_szPathTranslated, pHitObj->PSzCurrTemplatePhysPath()))));
        Assert(FImplies(m_fGlobalAsa, (0 == _tcscmp(m_rgpFilemaps[0]->m_szPathTranslated, pHitObj->GlobalAspPath()))));
        Assert(0 < m_rgpFilemaps[0]->GetSize());
        }

    if (FAILED(hr))
        {
        m_fDontCache = TRUE;
        // OK, cache HR if m_fDontCache is true
        // later, another thread might find this template from the cache even if the template
        // has some error and marked as DontCache.
        m_hrOnNoCache = hr;
        m_fReadyForUse = TRUE;
        SetEvent(m_hEventReadyForUse);
        return hr;
        }

    // End of Code moved from Init()


    // By default we are not in a transaction
    m_ttTransacted = ttUndefined;
    // By default session is required
    m_fSession = TRUE;
    // By default assume script exists
    m_fScriptless = FALSE;

    // we assert, in effect, that template is already init'ed
    Assert(FImplies(!m_fGlobalAsa, (0 == _tcscmp(m_rgpFilemaps[0]->m_szPathTranslated, pHitObj->PSzCurrTemplatePhysPath()))));
    Assert(FImplies(m_fGlobalAsa, (0 == _tcscmp(m_rgpFilemaps[0]->m_szPathTranslated, pHitObj->GlobalAspPath()))));

    TRY
        // Get source segments from source file
        GetSegmentsFromFile(*(m_rgpFilemaps[0]), *m_pWorkStore, pHitObj);

        /*  get "language equivalents" for primary languagefrom registry
            NOTE we do this here because the user can reset the primary language in the script file,
            so we must wait until after GetSegmentsFromFile()
        */
        GetLanguageEquivalents();

        // Call WriteTemplate, which writes out template components to contiguous memory,
        // resulting in a compiled template
        WriteTemplate(*m_pWorkStore, pHitObj);

        // Calculate the # of characters in a filemap before we unmap the file for all time.
        for (unsigned i = 0; i < m_cFilemaps; ++i)
            m_rgpFilemaps[i]->CountChars((WORD)m_wCodePage);

        // Wrap typelibs into single IDispatch*
        WrapTypeLibs(pHitObj);

        m_fIsValid = TRUE;

    CATCH(hrException)
        // NOTE: we used to free template memory here.  Now we do not because if the
        // error was E_USER_LACKS_PERMISSIONS, and template is in cache, we don't want
        // to sabotage future requests. There's no need to decache the template.
        //
        // The template destructor will free this memory anyway.
        //
        hr = hrException;
    END_TRY

    // check if scriptless
    if (!m_fGlobalAsa)
        {
        // count various stuff to make the determination
        DWORD cScriptEngines         = m_pWorkStore->m_ScriptStore.CountPreliminaryEngines();
        DWORD cPrimaryScriptSegments = (cScriptEngines > 0) ? m_pWorkStore->m_ScriptStore.m_ppbufSegments[0]->Count() : 0;
        DWORD cObjectTags            = m_pWorkStore->m_ObjectInfoStore.Count();
        DWORD cHtmlSegments          = m_pWorkStore->m_bufHTMLSegments.Count();
        DWORD c449Cookies            = m_rgp449.length();
        BOOL  fPageCommandsPresent   = m_pWorkStore->m_fPageCommandsExecuted;

        if (cScriptEngines <= 1         &&
            cPrimaryScriptSegments == 0 &&
            cObjectTags == 0            &&
            cHtmlSegments == 1          &&
            c449Cookies == 0            &&
            !fPageCommandsPresent)
            {
            m_fScriptless = TRUE;
            }
        }

    // free working storage - no longer needed
    delete m_pWorkStore;
    m_pWorkStore = NULL;

    // un-map filemaps - NOTE filemaps stay around for possible post-compile errors (e.g., script failure)
    UnmapFiles();

    // Debugging: print data structure to debugger
        IF_DEBUG(SCRIPT_DEBUGGER)
                {
                if (SUCCEEDED(hr))
                        {
                        DBGPRINTF((DBG_CONTEXT, "Script Compiled\n"));

                        for (UINT i = 0; i < m_cScriptEngines; ++i)
                                {
                                char *szEngineName;
                                PROGLANG_ID *pProgLangID;
                                const wchar_t *wszScriptText;

                                GetScriptBlock(i, &szEngineName, &pProgLangID, &wszScriptText);
                                DBGPRINTF((DBG_CONTEXT, "Engine %d, Language=\"%s\":\n", i, szEngineName));
#ifndef _NO_TRACING_
                DBGINFO((DBG_CONTEXT, (char *) wszScriptText));
                DBGINFO((DBG_CONTEXT, "\n"));
#else
                OutputDebugStringW(wszScriptText);
                OutputDebugStringA("\n");
#endif
				}
#if 0
			OutputDebugTables();
#endif
			}
        }

    if (hr == E_TEMPLATE_COMPILE_FAILED_DONT_CACHE)
                {
        m_fDontCache = TRUE;
                m_hrOnNoCache = hr;
                }

    // Set ready-for-use flag true and event to signaled
    // NOTE we do this whether success or failure, since even a failed-compile template
    // will remain in the cache to allow template cache mgr to satisfy requests on it
    m_fReadyForUse = TRUE;
    SetEvent(m_hEventReadyForUse);

    // Note whether the template currently is debuggable
    // BUG BUG: Template is debuggable or not based on first app. If shared between a debug
    //          & non-debug app, the first application wins.
    m_fDebuggable = (BOOLB)!!pHitObj->PAppln()->FDebuggable();

    return hr;
    }

/*  ============================================================================
    CTemplate::Deliver
    Delivers template to caller once template is ready for use
    NOTE 'compile failure' == template is 'ready for use' but did not compile successfully;
    this allows cache mgr to keep a failed template in cache in case it gets requested again

    Returns
        success or failure
    Side effects
        none
*/
HRESULT
CTemplate::Deliver
(
CHitObj*    pHitObj
)
    {
    // NOTE: There was a compiler bug where 'ps' would not be correctly aligned,
    //       EVEN if it was declared to be a DWORD array, if 'ps' was nested in
    //       a block.  Thus declare it here.
    //
    BYTE    ps[SIZE_PRIVILEGE_SET];                     // privilege set
    HRESULT hr = S_OK;

    // if ready flag is not yet set block until template is ready for use
    if(!m_fReadyForUse)
        {
        WaitForSingleObject(m_hEventReadyForUse, INFINITE);
        Assert(m_fReadyForUse); // when event unblocks, flag will be set
        }

    if (m_pbStart == NULL)
        {
        if (m_fDontCache && m_dwLastErrorMask == 0)
            {
            DBGPRINTF((DBG_CONTEXT, "template compile failed with %08x\n", m_hrOnNoCache));
            DBG_ASSERT(FAILED(m_hrOnNoCache));

                        // Safety net: always fail, even if "m_hrOnNoCache" did not get set somehow.
            hr = m_hrOnNoCache;
                        if (SUCCEEDED(m_hrOnNoCache))
                                hr = E_FAIL;

            if(hr == E_USER_LACKS_PERMISSIONS)
                HandleAccessFailure(pHitObj,
                                                                        (m_rgpFilemaps && m_rgpFilemaps[0])? m_rgpFilemaps[0]->m_szPathTranslated : NULL);
            return hr;
            }
        // template compile failed  - NOTE null start-of-template ptr == template compile failed
        // use cached error info
        SendToLog(  m_dwLastErrorMask,
                    m_pszLastErrorInfo[ILE_szFileName],
                    m_pszLastErrorInfo[ILE_szLineNum],
                    m_pszLastErrorInfo[ILE_szEngine],
                    m_pszLastErrorInfo[ILE_szErrorCode],
                    m_pszLastErrorInfo[ILE_szShortDes],
                    m_pszLastErrorInfo[ILE_szLongDes],
                    pHitObj);
        hr = E_TEMPLATE_COMPILE_FAILED;
        }
    else if (!pHitObj->FIsBrowserRequest())
        {
        return hr;
        }
    else if (Glob(fWinNT))
        // template compile succeeded  - check user's file permissions
        // ACLs: the following code should in future be shared with IIS (see creatfil.cxx in IIS project)
        {
        HANDLE          hUserAccessToken = pHitObj->HImpersonate(); // current user's access token
        DWORD           dwPS = sizeof(ps);                          // privilege set size
        DWORD           dwGrantedAccess;                            // granted access mask
        BOOL            fAccessGranted;                             // access granted flag
        GENERIC_MAPPING gm = {                                      // generic mapping struct
                                FILE_GENERIC_READ,
                                FILE_GENERIC_WRITE,
                                FILE_GENERIC_EXECUTE,
                                FILE_ALL_ACCESS
                            };

        ((PRIVILEGE_SET*)&ps)->PrivilegeCount = 0;                  // set privilege count to 0

        Assert(NULL != hUserAccessToken);

        for(UINT i = 0; i < m_cFilemaps; i++)
            {

            if(NULL == m_rgpFilemaps[i]->m_pSecurityDescriptor)
                continue;

            if(!AccessCheck(
                            m_rgpFilemaps[i]->m_pSecurityDescriptor,    // pointer to security descriptor
                            hUserAccessToken,       // handle to client access token
                            FILE_GENERIC_READ,      // access mask to request
                            &gm,                    // address of generic-mapping structure
                            (PRIVILEGE_SET*)ps,     // address of privilege-set structure
                            &dwPS,                  // address of size of privilege-set structure
                            &dwGrantedAccess,       // address of granted access mask
                            &fAccessGranted         // address of flag indicating whether access granted
                            ))
                return E_FAIL;

            if(!fAccessGranted)
                {
                // if access is denied on any file, handle the failure and return
                HandleAccessFailure(pHitObj, m_rgpFilemaps[0]->m_szPathTranslated);
                return E_USER_LACKS_PERMISSIONS;
                }
            }
        }

    // Reset the Session.CodePage to the script compilation-time codepage
    // only if a code page directive was found during compilation
    if (m_fCodePageSet && (!pHitObj->FHasSession() || !pHitObj->PSession()->FCodePageSet()))
        {
        pHitObj->SetCodePage(m_wCodePage);
        }

    // Reset the Session.LCID to the script compilation-time LCID
    // only if an LCID directive was found during compilation
    if (m_fLCIDSet && (!pHitObj->FHasSession() || !pHitObj->PSession()->FLCIDSet()))
        {
        pHitObj->SetLCID(m_lLCID);
        }

    return hr;
    }


/*  ============================================================================
    CTemplate::CTemplate
    Ctor
*/
CTemplate::CTemplate()
: m_pWorkStore(NULL),
  m_fGlobalAsa(FALSE),
  m_fReadyForUse(FALSE),
  m_fDontAttach(FALSE),
  m_hEventReadyForUse(NULL),
  m_fDebuggerDetachCSInited(FALSE),
  m_pbStart(NULL),
  m_cbTemplate(0),
  m_cRefs(1),                           // NOTE ctor AddRefs implicitly
  m_pbErrorLocation(NULL),
  m_idErrMsg(0),
  m_cMsgInserts(0),
  m_ppszMsgInserts(NULL),
  m_cScriptEngines(0),
  m_rgrgSourceInfos(NULL),
  m_rgpDebugScripts(NULL),
  m_rgpFilemaps(NULL),
  m_cFilemaps(0),
  m_rgpSegmentFilemaps(NULL),
  m_cSegmentFilemapSlots(0),
  m_wCodePage(CP_ACP),
  m_lLCID(LOCALE_SYSTEM_DEFAULT),
  m_ttTransacted(ttUndefined),
  m_fSession(TRUE),
  m_fScriptless(FALSE),
  m_fDebuggable(FALSE),
  m_fIsValid(FALSE),
  m_fDontCache(FALSE),
  m_fZombie(FALSE),
  m_fCodePageSet(FALSE),
  m_fLCIDSet(FALSE),
  m_fIsPersisted(FALSE),
  m_szPersistTempName(NULL),
  m_szApplnVirtPath(NULL),
  m_szApplnURL(NULL),
  m_CPTextEvents(this, IID_IDebugDocumentTextEvents),
  m_pdispTypeLibWrapper(NULL),
  m_dwLastErrorMask(S_OK),
  m_hrOnNoCache(S_OK),
  m_cbTargetOffsetPrevT(0),
  m_pHashTable(NULL),
  m_pServicesConfig(NULL) {

    m_wCodePage = GetACP();

     for (UINT i = 0; i < ILE_MAX; i++)
    {
        m_pszLastErrorInfo[i] = NULL;
    }

     IF_DEBUG(TEMPLATE)
     {
        WriteRefTraceLog(gm_pTraceLog, m_cRefs, this);
     }
#if PER_TEMPLATE_REFLOG
     m_pTraceLog = CreateRefTraceLog (100,0);
     WriteRefTraceLog (m_pTraceLog,m_cRefs, this);
#endif
  }

/*  ============================================================================
    CTemplate::~CTemplate
    Destructor

    Returns:
        Nothing
    Side effects:
        None
*/
CTemplate::~CTemplate()
    {
    DBGPRINTF(( DBG_CONTEXT, "Deleting template, m_cFilemaps = %d,  m_rgpFilemaps %p\n", m_cFilemaps, m_rgpFilemaps));

    // first, remove this template from its inc-files' template lists
    // NOTE must do this before freeing template memory
    RemoveFromIncFiles();

    // Remove the template from the debugger's list of documents
    Detach();

    PersistCleanup();

    if(m_rgpFilemaps)
        {
        for(UINT i = 0; i < m_cFilemaps; i++)
            delete m_rgpFilemaps[i];
        SmallTemplateFreeNullify((void**) &m_rgpFilemaps);
        }

    FreeGoodTemplateMemory();

    if (m_pWorkStore)
        delete m_pWorkStore;

    //FileName, LineNum, Engine, ErrorCode, ShortDes, LongDes
    for(UINT iErrInfo = 0; iErrInfo < ILE_MAX; iErrInfo++)
        {
        FreeNullify((void**) &m_pszLastErrorInfo[iErrInfo]);
        }

    if(m_hEventReadyForUse != NULL)
        CloseHandle(m_hEventReadyForUse);

    if (m_LKHashKey.szPathTranslated)
		free((void *)m_LKHashKey.szPathTranslated);

    if (m_szApplnURL)
        delete [] m_szApplnURL;

    if (m_fDebuggerDetachCSInited)
        DeleteCriticalSection(&m_csDebuggerDetach);

    if (m_pdispTypeLibWrapper)
        m_pdispTypeLibWrapper->Release();

    if (m_szPersistTempName)
        CTemplate::LargeFree(m_szPersistTempName);

    if (m_pServicesConfig)
        m_pServicesConfig->Release();

    m_pServicesConfig = NULL;

#if PER_TEMPLATE_REFLOG
    DestroyRefTraceLog (m_pTraceLog);
#endif
}

/*  ============================================================================
    CTemplate::QueryInterface
    Provides QueryInterface implementation for CTemplate

    NOTE: It is arbitrary which vtable we return for IDebugDocument & IDebugDocumentInfo.
*/
HRESULT
CTemplate::QueryInterface(const GUID &uidInterface, void **ppvObj)
    {
    if (uidInterface == IID_IUnknown || uidInterface == IID_IDebugDocumentProvider)
        *ppvObj = static_cast<IDebugDocumentProvider *>(this);

    else if (uidInterface == IID_IDebugDocument || uidInterface == IID_IDebugDocumentInfo || uidInterface == IID_IDebugDocumentText)
        *ppvObj = static_cast<IDebugDocumentText *>(this);

    else if (uidInterface == IID_IConnectionPointContainer)
        *ppvObj = static_cast<IConnectionPointContainer *>(this);

    else
        *ppvObj = NULL;

    if (*ppvObj)
        {
        AddRef();
        return S_OK;
        }
    else
        return E_NOINTERFACE;
    }

/*  ============================================================================
    CTemplate::AddRef
    Adds a ref to this template, thread-safely
*/
ULONG
CTemplate::AddRef()
    {
    LONG cRefs = InterlockedIncrement(&m_cRefs);

    Assert(FImplies(m_fIsValid,FImplies(cRefs > 1, m_pbStart != NULL)));
    IF_DEBUG(TEMPLATE)
    {
        WriteRefTraceLog(gm_pTraceLog, cRefs, this);
    }

#if PER_TEMPLATE_REFLOG
    WriteRefTraceLog(m_pTraceLog, cRefs, this);
#endif

    return cRefs;
    }

/*  ============================================================================
    CTemplate::Release
    Releases a ref to this template, thread-safely
*/
ULONG
CTemplate::Release()
{
    LONG cRefs = InterlockedDecrement(&m_cRefs);
    IF_DEBUG(TEMPLATE)
    {
        WriteRefTraceLog(gm_pTraceLog, cRefs, this);
    }
    
#if PER_TEMPLATE_REFLOG
    WriteRefTraceLog(m_pTraceLog, cRefs, this);
#endif

    if (cRefs == 0)
        delete this;

    return cRefs;
}

/*  ============================================================================
    CTemplate::RemoveIncFile
    Removes (by setting to null) an inc-file ptr from this template's inc-file list.

    Returns:
        Nothing
    Side effects:
        None
*/
void
CTemplate::RemoveIncFile
(
CIncFile*   pIncFile
)
    {

    // If the filemap count is non-zero the pointer to
    // the array of filemaps has better not be null
    DBGPRINTF(( DBG_CONTEXT, "m_cFilemaps = %d,  m_rgpFilemaps %p\n", m_cFilemaps, m_rgpFilemaps));
    Assert((m_cFilemaps <= 0) || (m_rgpFilemaps != NULL));

    // find the inc-file in list
    for(UINT i = 1; (i < m_cFilemaps) && (m_rgpFilemaps[i]->m_pIncFile != pIncFile); i++)
        ;

    // assert that we found the inc-file in list
    Assert((i < m_cFilemaps) && (m_rgpFilemaps[i]->m_pIncFile == pIncFile));

    // set inc-file ptr null
    m_rgpFilemaps[i]->m_pIncFile = NULL;
    }

/*===================================================================
CTemplate::FTemplateObsolete

Test to see if the files this template depends on have changed since it
was compiled.

We use this in cases where we may have missed a change notification,
for example, when there were too many changes to record in our change
notification buffer. We check the last time the file was written too,
and the security descriptor, since changes to the security descriptor
aren't noted in the file last write time.

Parameters:
    None

Returns:
    TRUE if the template is obsolete, else FALSE
*/
BOOL CTemplate::FTemplateObsolete(VOID)
    {
    BOOL fStatus = FALSE;

    // On Windows 95 files should not be cached
    // so assume the template has changed
    if (!FIsWinNT())
        {
        return TRUE;
        }

    for (UINT i = 0; i < m_cFilemaps; i++)
        {
        if (FFileChangedSinceCached(m_rgpFilemaps[i]->m_szPathTranslated, m_rgpFilemaps[i]->m_ftLastWriteTime))
            {
            // If the file write time has changed we know enough
            // and can quit here
            fStatus = TRUE;
            break;
            }
        else
            {
            // The file hasn't been writen to, but the security descriptor may
            // have chagned

            // Assert on non-valid security descriptor

            if (NULL != m_rgpFilemaps[i]->m_pSecurityDescriptor)
                {

                PSECURITY_DESCRIPTOR pSecurityDescriptor = NULL;
                DWORD dwSize = m_rgpFilemaps[i]->m_dwSecDescSize;

                if( 0 == GetSecDescriptor(m_rgpFilemaps[i]->m_szPathTranslated, &pSecurityDescriptor, &dwSize))
                    {
                    if (pSecurityDescriptor)
                        {
                        // if the size is not the same then set fStatus to TRUE no need to compare memory blocks.

                        if(dwSize != GetSecurityDescriptorLength(m_rgpFilemaps[i]->m_pSecurityDescriptor))
                            {
                            fStatus = TRUE;
                            }
                        else
                            {
                            // The size of the security descriptor hasn't changed
                            // but we have to compare the contents to make sure they haven't changed
                            fStatus = !(0 == memcmp(m_rgpFilemaps[i]->m_pSecurityDescriptor, pSecurityDescriptor, dwSize));
                            }

                        // We are done with the descriptor
                        free(pSecurityDescriptor);

                        }
                    else
                        {
                        // Since we failed to get a security descriptor
                        // assume the file has changed.
                        fStatus = TRUE;
                        }
                    }
                }
            }

        // Quit as soon as we find a change
        if (fStatus)
            {
            break;
            }
        }

    return fStatus;
    }


/*  ============================================================================
    CTemplate::GetSourceFileName
    Returns name of source file on which this template is based

    Returns
        source file name
    Side effects
        none
*/
LPTSTR
CTemplate::GetSourceFileName(SOURCEPATHTYPE pathtype)
    {
    if (!m_rgpFilemaps)
        {
        return NULL;
        }

    switch (pathtype)
        {
    case SOURCEPATHTYPE_PHYSICAL:
        return((m_rgpFilemaps[0] ? m_rgpFilemaps[0]->m_szPathTranslated : NULL));

    case SOURCEPATHTYPE_VIRTUAL:
        return((m_rgpFilemaps[0] ? m_rgpFilemaps[0]->m_szPathInfo : NULL));

    default:
        return(NULL);
        }
    }

/*  ============================================================================
    CTemplate::Count
    Returns count of components of type tcomp contained in this template

    Returns:
        Count of components of type tcomp
    Side effects:
        None
*/
USHORT
CTemplate::Count
(
TEMPLATE_COMPONENT  tcomp
)
    {
    Assert(NULL != m_pbStart);

    // script engines and script blocks have the same count, stored in same slot
    if(tcomp == tcompScriptEngine)
        tcomp = tcompScriptBlock;

    // counts are stored at start of template in sequential slots, starting with script blocks count
    return * (USHORT*) ((USHORT*)m_pbStart + (tcomp - tcompScriptBlock));
    }

/*  ============================================================================
    CTemplate::GetScriptBlock
    Gets ptrs to script engine name, prog lang id and script text of i-th script block.

    Returns:
        Out-parameters; see below
    Side effects:
        None
*/
void
CTemplate::GetScriptBlock
(
UINT            i,                  // script block id
LPSTR*          pszScriptEngine,    // ptr to script engine name    (out-parameter)
PROGLANG_ID**   ppProgLangId,       // ptr to prog lang id          (out-parameter)
LPCOLESTR*      pwstrScriptText     // ptr to wstr script text      (out-parameter)
)
    {
    CByteRange  brEngine;       // engine name
    CByteRange  brScriptText;   // script text
    UINT        cbAlignment;    // count of bytes guid was shifted in WriteTemplate() to make it dword-aligned
    BYTE*       pbEngineInfo = GetAddress(tcompScriptEngine, (USHORT)i);    // ptr to engine info

    Assert(pbEngineInfo != NULL);
    Assert(i < CountScriptEngines());

    // Get engine name from start of engine info
    ByteRangeFromPb(pbEngineInfo, brEngine);

    ByteRangeFromPb(GetAddress(tcompScriptBlock, (USHORT)i), brScriptText);

    Assert(!brEngine.IsNull());
    Assert(!brScriptText.IsNull());

    // Advance ptr past name to prog lang id
    //           length of prefix + length of name  + NULL
    pbEngineInfo += (sizeof(UINT) + (*pbEngineInfo) + 1);

    // Get prog lang id - it will be on the next pointer sized boundary
    cbAlignment = (UINT) (((DWORD_PTR) pbEngineInfo) % sizeof(DWORD));
    if(cbAlignment > 0)
       {pbEngineInfo += (sizeof(DWORD) - cbAlignment);}

    *pszScriptEngine = (LPSTR)brEngine.m_pb;
    *ppProgLangId = (PROGLANG_ID*)pbEngineInfo;
    *pwstrScriptText = (LPCOLESTR)brScriptText.m_pb;
    }

/*  ============================================================================
    CTemplate::GetObjectInfo
    Returns i-th object-info in template as object name and
    its clsid, scope, model

    Returns:
        HRESULT
        Out-parameters; see below
    Side effects:
*/
HRESULT
CTemplate::GetObjectInfo
(
UINT        i,              // object index
LPSTR*      ppszObjectName, // address of object name ptr   (out-parameter)
CLSID*      pClsid,         // address of object clsid
CompScope*  pcsScope,       // address of object scope
CompModel*  pcmModel        // address of object threading model
)
    {
    BYTE*       pbObjectInfo = GetAddress(tcompObjectInfo, (USHORT)i);  // ptr to current read location
    CByteRange  brName;         // object name
    UINT        cbAlignment;    // count of bytes guid was shifted in WriteTemplate() to make it dword-aligned

    Assert(i < Count(tcompObjectInfo));

    // Get name from start of object-info
    ByteRangeFromPb(pbObjectInfo, brName);
    Assert(!brName.IsNull());

    // Advance ptr past name
    //           length of prefix + length of name  + NULL
    pbObjectInfo += (sizeof(UINT) + (*pbObjectInfo) + 1);

    // Get clsid - it will be on the next DWORD boundary
    cbAlignment = (UINT)(((DWORD_PTR) pbObjectInfo) % sizeof(DWORD));
    if(cbAlignment > 0)
        pbObjectInfo += (sizeof(DWORD) - cbAlignment);

    *pClsid = *(CLSID*)pbObjectInfo;
    pbObjectInfo += sizeof(CLSID);

    // Get scope
    *pcsScope = *(CompScope*)pbObjectInfo;
    pbObjectInfo += sizeof(CompScope);

    // Get model
    *pcmModel = *(CompModel*)pbObjectInfo;
    pbObjectInfo += sizeof(CompModel);

    *ppszObjectName = (LPSTR)brName.m_pb;
    return S_OK;
    }

/*  ============================================================================
    CTemplate::GetHTMLBlock
    Returns i-th HTML block

    Parameters:
        UINT   i             block number
        LPSTR* pszHTML       [out] html text
        ULONG* pcbHTML       [out] html text length
        ULONG* pcbSrcOffs    [out] offset in the source file
        LPSTR* pszSrcIncFile [out] include source file name

    Returns:
        Nothing
    Side effects:
        None
*/
HRESULT
CTemplate::GetHTMLBlock
(
UINT i,
LPSTR* pszHTML,
ULONG* pcbHTML,
ULONG* pcbSrcOffs,
LPSTR* pszSrcIncFile
)
    {
    Assert(i < Count(tcompHTMLBlock));

    // this was added due to user attempt to access the method with an invalid array offset
    //
    if ( i >= Count(tcompHTMLBlock) )
        return E_FAIL;

    // get address of the block start in template memory
    BYTE *pbBlock = GetAddress(tcompHTMLBlock, (USHORT)i);
    Assert(pbBlock);

    // retrieve the byte range of the html code
    CByteRange brHTML;
    ByteRangeFromPb(pbBlock, brHTML);
    *pszHTML = (LPSTR)brHTML.m_pb;
    *pcbHTML = brHTML.m_cb;

    // advance to the source offset
    pbBlock += sizeof(ULONG);   // skip prefix
    pbBlock += brHTML.m_cb+1;   // skip html bytes (incl. '\0')

    // Add byte aligment which is done in ByteAlignOffset()
    if ((reinterpret_cast<ULONG_PTR>(pbBlock)) & 3)
        pbBlock = reinterpret_cast<BYTE *>((reinterpret_cast<ULONG_PTR>(pbBlock) + 4) & ~3);

    *pcbSrcOffs = *((ULONG*)pbBlock);

    // advance to the source name length
    pbBlock += sizeof(ULONG);   // skip source offset prefix
    ULONG cbSrcIncFile = *((ULONG *)pbBlock); // inc file name length
    pbBlock += sizeof(ULONG);   // skip inc file name length
    *pszSrcIncFile = (cbSrcIncFile > 0) ? (LPSTR)pbBlock : NULL;
    return S_OK;
    }

/*  ============================================================================
    CTemplate::GetScriptSourceInfo
    Returns line number and source file name a given target line in a given script engine.

    Returns
        line number and source file name (as out-parameters)
    Side effects:
        None
*/
void
CTemplate::GetScriptSourceInfo
(
UINT    idEngine,           // script engine id
int     iTargetLine,        // target line number
LPTSTR* pszPathInfo,        // ptr to source file virtual path      (out-parameter)
LPTSTR* pszPathTranslated,  // ptr to source file real path         (out-parameter)
ULONG*  piSourceLine,       // ptr to source line number            (out-parameter)
ULONG*  pichSourceLine,     // ptr to source file offset            (out-parameter)
BOOLB*  pfGuessedLine       // ptr to flag: did we guess the source line?
)
    {
    // Initialize some out parameters
    if (pszPathInfo)
        *pszPathInfo = _T("?"); // In case we don't ever find the path

    if (pszPathTranslated)
        *pszPathTranslated = _T("?"); // In case we don't ever find the path

    if (piSourceLine)
        *piSourceLine = 0;

    if (pichSourceLine)
        *pichSourceLine = 0;

    if (pfGuessedLine)
        *pfGuessedLine = FALSE;

    if (iTargetLine <=0)
        {
        return;
        }

    // CHANGE: The rgSourceInfo array is now ZERO based.  Decrement target line
    //           to convert.
    --iTargetLine;

    // CONSIDER: Make these assertions?
    if(!m_rgrgSourceInfos)
        return;
    if(idEngine > (m_cScriptEngines - 1))   // bug 375: check vs. array bound
        return;
    if(size_t(iTargetLine) >= m_rgrgSourceInfos[idEngine].length()) // bug 375: check vs. array bound
        return;

    vector<CSourceInfo> *prgSourceInfos = &m_rgrgSourceInfos[idEngine];

    // bug 379: move backwards through target lines, starting with the caller's, until we find one whose
    // fIsHTML flag is false.  this handles the case where vbs flags a manufactured line as in error;
    // we assume the actual error occurred at the most recent authored line
    while (iTargetLine >= 0 && (*prgSourceInfos)[iTargetLine].m_fIsHTML)
        {
        --iTargetLine;
        if (pfGuessedLine)
            *pfGuessedLine = TRUE;
        }


    if (iTargetLine >= 0)
        {
        if (pszPathInfo && (*prgSourceInfos)[iTargetLine].m_pfilemap != NULL)
            *pszPathInfo = (*prgSourceInfos)[iTargetLine].m_pfilemap->m_szPathInfo;

        if (pszPathTranslated && (*prgSourceInfos)[iTargetLine].m_pfilemap != NULL)
            *pszPathTranslated = (*prgSourceInfos)[iTargetLine].m_pfilemap->m_szPathTranslated;

        if (piSourceLine)
            *piSourceLine = (*prgSourceInfos)[iTargetLine].m_idLine;

        if (pichSourceLine)
            *pichSourceLine = (*prgSourceInfos)[iTargetLine].m_cchSourceOffset;
        }
    }

/*  ============================================================================
    CTemplate::GetPositionOfLine
    Get the character offset of a line of source
    (Debugger API Extended to specify a filemap)
*/
HRESULT
CTemplate::GetPositionOfLine
(
CFileMap *pFilemap,
ULONG cLineNumber,
ULONG *pcCharacterPosition
)
    {
    // NOTE:
    //    The table is not binary-searchable because include files
    //    will start a new line ordering
    //
    // Algorithm:
    //
    //   Find the largest source line N across all engines, such that
    //   N <= cLineNumber and the line corresponds to an line
    //   in the appropriate file.
    //
    CSourceInfo *pSourceInfoLE = NULL;
    ++cLineNumber;                  // Convert zero-based line # to one-based

    // Find the correct offset
    for (unsigned idEngine = 0; idEngine < m_cScriptEngines; ++idEngine)
        {
        vector<CSourceInfo> *prgSourceInfos = &m_rgrgSourceInfos[idEngine];

        // Loop through all lines EXCEPT the EOF line
        for (unsigned j = 0; j < prgSourceInfos->length() - 1; ++j)
            {
            CSourceInfo *pSourceInfo = &(*prgSourceInfos)[j];
            if (pFilemap == pSourceInfo->m_pfilemap &&
                pSourceInfo->m_idLine <= cLineNumber &&
                (pSourceInfoLE == NULL || pSourceInfo->m_idLine > pSourceInfoLE->m_idLine))
                {
                pSourceInfoLE = pSourceInfo;
                }
            }
        }

    // We had better be able to map all line numbers to offsets, unless they passed a bogus line
    // (in which case we still find an offset)
    //
    Assert (pSourceInfoLE != NULL);

    if (pSourceInfoLE == NULL) {
        return E_FAIL;
    }
    *pcCharacterPosition = pSourceInfoLE->m_cchSourceOffset;
#if 0
	IF_DEBUG(SCRIPT_DEBUGGER)
		{
		wchar_t wszSourceText[SNIPPET_SIZE + 1], wszTargetText[SNIPPET_SIZE + 1], wszDebugMessage[256];
		GetScriptSnippets(
						pSourceInfoLE->m_cchSourceOffset, pSourceInfoLE->m_pfilemap,
						0, 0,
						wszSourceText, NULL
						 );

		DBGPRINTF((
				DBG_CONTEXT,
				"Source Line %d corresponds to source offset %d (Text: \"%S\")\n",
				cLineNumber - 1, pSourceInfoLE->m_cchSourceOffset,
				wszSourceText
				));
		}
#endif
    return S_OK;
    }

/*  ============================================================================
    CTemplate::GetLineOfPosition
    Get the line # & offset in line of an arbitrary character offset in source
    (Debugger API Extended to specify a filemap)
*/
HRESULT CTemplate::GetLineOfPosition
(
CFileMap *pFilemap,
ULONG cCharacterPosition,
ULONG *pcLineNumber,
ULONG *pcCharacterOffsetInLine
)
    {
    // FAIL if source offset totally off-base
    if (cCharacterPosition >= pFilemap->m_cChars)
        return E_FAIL;

    // NOTE:
    //    The table is not binary-searchable because include files
    //    will start a new line ordering
    //
    // Algorithm:
    //
    //   Find the largest source line N across all engines, such that
    //   N <= cLineNumber and the line corresponds to an line
    //   in the appropriate file.
    //
    CSourceInfo *pSourceInfoLE = NULL;

    // Find the correct offset
    for (unsigned idEngine = 0; idEngine < m_cScriptEngines; ++idEngine)
        {
        vector<CSourceInfo> *prgSourceInfos = &m_rgrgSourceInfos[idEngine];

        // Loop through all lines EXCEPT the EOF line
        for (unsigned j = 0; j < prgSourceInfos->length() - 1; ++j)
            {
            CSourceInfo *pSourceInfo = &(*prgSourceInfos)[j];
            if (pFilemap == pSourceInfo->m_pfilemap &&
                pSourceInfo->m_cchSourceOffset <= cCharacterPosition &&
                (pSourceInfoLE == NULL || pSourceInfo->m_cchSourceOffset > pSourceInfoLE->m_cchSourceOffset))
                {
                pSourceInfoLE = pSourceInfo;
                }
            }
        }

    // We had better be able to map all offsets to line numbers, unless they passed a bogus offset
    // (in which case we still find a line #, but may go out of range for the offset in line.
    //  That case is handled later)
    //
    Assert (pSourceInfoLE != NULL);

    if (pSourceInfoLE == NULL) {
        return E_FAIL;
    }

    *pcLineNumber = pSourceInfoLE->m_idLine - 1;    // Convert to zero-based line #
    *pcCharacterOffsetInLine = cCharacterPosition - pSourceInfoLE->m_cchSourceOffset;
#if 0
	IF_DEBUG(SCRIPT_DEBUGGER)
		{
		wchar_t wszSourceText[SNIPPET_SIZE + 1], wszTargetText[SNIPPET_SIZE + 1], wszDebugMessage[256];
		GetScriptSnippets(
						pSourceInfoLE->m_cchSourceOffset, pSourceInfoLE->m_pfilemap,
						0, 0,
						wszSourceText, NULL
						 );

        DBGPRINTF((
                                DBG_CONTEXT,
                                "Source offset %d corresponds to source line %d (Text: \"%S\")\n",
                                pSourceInfoLE->m_cchSourceOffset, *pcLineNumber,
                                wszSourceText
                                ));
                }

		DBGPRINTF((
				DBG_CONTEXT,
				"Source offset %d corresponds to source line %d (Text: \"%S\")\n",
				pSourceInfoLE->m_cchSourceOffset, *pcLineNumber,
				wszSourceText
				));
		}
#endif
    return S_OK;
    }

/*  ============================================================================
    CTemplate::GetSourceOffset
    Convert a character offset relative to the target script to the appropriate
    offset in the source.

    NOTE:   offsets in the middle of a target line are converted to the
            offset relative to the beginning of source line - NOT to the
            precise source offset.

            this is OK because debugger ultimately wants the offset of the
            beginning of line.  It is a lot of work to do the precise conversion
            due to the translation of "=" to Response.Write & HTML to
            Response.WriteBlock

            Also, because of these translations, we return the length of the segment
            calculated during compilation, and throw away the length the scripting
            engine sent to us.
*/
void
CTemplate::GetSourceOffset
(
ULONG idEngine,
ULONG cchTargetOffset,
TCHAR **pszSourceFile,
ULONG *pcchSourceOffset,
ULONG *pcchSourceText
)
    {
    Assert (idEngine < m_cScriptEngines);
    vector<CSourceInfo> *prgSourceInfos = &m_rgrgSourceInfos[idEngine];

    // Find the closest offset in the source
    // This is the largest target offset N, such that N <= cchTargetOffset
    CSourceInfo *pSourceInfo;
    GetBracketingPair(
            cchTargetOffset,                                    // value to search for
            prgSourceInfos->begin(), prgSourceInfos->end(),     // array to search
            CTargetOffsetOrder(),                               // ordering predicate
            &pSourceInfo, static_cast<CSourceInfo **>(NULL)     // return values
            );

    // Since the first offset is zero, which is less than all other conceivable offsets,
    // the offset must have been found or else there is a bug.
    Assert (pSourceInfo != NULL);
    Assert (cchTargetOffset >= pSourceInfo->m_cchTargetOffset);
#if 0
	IF_DEBUG(SCRIPT_DEBUGGER)
		{
		wchar_t wszSourceText[SNIPPET_SIZE + 1], wszTargetText[SNIPPET_SIZE + 1], wszDebugMessage[256];
		GetScriptSnippets(
						pSourceInfo->m_cchSourceOffset, pSourceInfo->m_pfilemap,
						cchTargetOffset, idEngine,
						wszSourceText, wszTargetText
						 );
		DBGPRINTF((
				DBG_CONTEXT,
				"Target offset %d (Text: \"%S\") corresponds to source offset %d (Text: \"%S\")  (Length is %d)\n",
				cchTargetOffset, wszTargetText,
				pSourceInfo->m_cchSourceOffset, wszSourceText,
				pSourceInfo->m_cchSourceText
				));
		}
#endif
    *pszSourceFile = pSourceInfo->m_pfilemap->m_szPathTranslated;
    *pcchSourceOffset = pSourceInfo->m_cchSourceOffset;
    *pcchSourceText = pSourceInfo->m_cchSourceText;
    }

/*  ============================================================================
    CTemplate::GetTargetOffset
    Convert a character offset relative to the source script to the appropriate
    offset in the target.

    Returns:
        TRUE  - source offset corresponds to script
        FALSE - source offset corresponds to HTML

    NOTES:
        1.  This function is very slow. consider caching the value of this function
            (The CTemplateDocumentContext class does this.)

        2.  This function returns the source offset in the master include file -
            if the target offset corresponds to an offset in a header file, then
            the offset to the #include line in the source is returned.

        3.  offsets in the middle of a target line are converted to the
            offset relative to the beginning of source line - NOT to the
            precise source offset.

            this is OK because the debugger ultimately wants the offset of the
            beginning of line.  It is a lot of work to do the precise conversion
            due to the translation of "=" to Response.Write & HTML to
            Response.WriteBlock

    CONSIDER:
        Figure out a better way to do this
*/
BOOL CTemplate::GetTargetOffset
(
TCHAR *szSourceFile,
ULONG cchSourceOffset,
/* [out] */ ULONG *pidEngine,
/* [out] */ ULONG *pcchTargetOffset
)
    {
    // NOTE:
    //    The table is not binary-searchable because of two factors:
    //       1. Include files will start a new line ordering
    //       2. For engine 0, tagged scripts will be re-arranged in
    //          the target code to reside after all primary script in
    //          engine 0.
    //
    // Algorithm:
    //
    //   Find the largest source offset N across all engines, such that
    //   N <= cchSourceOffset and the offset corresponds to an offset
    //   in the appropriate file.
    //
    CSourceInfo *pSourceInfoLE = NULL;
    unsigned idEngineLE = 0;

    // Find the correct offset
    for (unsigned idEngine = 0; idEngine < m_cScriptEngines; ++idEngine)
        {
        vector<CSourceInfo> *prgSourceInfos = &m_rgrgSourceInfos[idEngine];

        // Loop through all lines EXCEPT the EOF line
        for (unsigned j = 0; j < prgSourceInfos->length() - 1; ++j)
            {
            CSourceInfo *pSourceInfo = &(*prgSourceInfos)[j];
            if (_tcscmp(pSourceInfo->m_pfilemap->m_szPathTranslated, szSourceFile) == 0 &&
                pSourceInfo->m_cchSourceOffset <= cchSourceOffset &&
                (pSourceInfoLE == NULL || pSourceInfo->m_cchSourceOffset > pSourceInfoLE->m_cchSourceOffset))
                {
                pSourceInfoLE = pSourceInfo;
                idEngineLE = idEngine;
                }
            }
        }

    // There won't be a valid offset in the case where there is no
    // code corresponding to the first line in the file (this only
    // occurs when the first line is whitespace, because there is no
    // corresponding "Response.WriteBlock" call there)
    //
    // In that case, return FALSE, which will cause the caller to fail
    //
    if (pSourceInfoLE == NULL)
        {
        *pidEngine = 0;
        *pcchTargetOffset = 0;
        return FALSE;
        }

    *pidEngine = idEngineLE;
    *pcchTargetOffset = pSourceInfoLE->m_cchTargetOffset;
#if 0
	IF_DEBUG(SCRIPT_DEBUGGER)
		{
		wchar_t wszSourceText[SNIPPET_SIZE + 1], wszTargetText[SNIPPET_SIZE + 1], wszDebugMessage[256];
		GetScriptSnippets(
						cchSourceOffset, pSourceInfoLE->m_pfilemap,
						*pcchTargetOffset, *pidEngine,
						wszSourceText, wszTargetText
						 );
		DBGPRINTF((
				DBG_CONTEXT,
				"Source offset %d (Text: \"%S\") corresponds to target offset %d (Text: \"%S\")\n",
				cchSourceOffset, wszSourceText,
				*pcchTargetOffset, wszTargetText
				));
		}
#endif
    return !pSourceInfoLE->m_fIsHTML;
    }

/*  ============================================================================
    CTemplate::GetActiveScript
    Return a cached script from the template - only used in debug mode
*/
CActiveScriptEngine *CTemplate::GetActiveScript(ULONG idEngine)
    {
    if (m_rgpDebugScripts == NULL)
        return NULL;

    else
        {
        Assert (idEngine < m_cScriptEngines);
        CActiveScriptEngine *pEng = m_rgpDebugScripts[idEngine];
        if (pEng)
            pEng->AddRef();

        return pEng;
        }
    }

/*  ============================================================================
    CTemplate::AddScript
    add an active script to the template object
*/
HRESULT CTemplate::AddScript(ULONG idEngine, CActiveScriptEngine *pScriptEngine)
    {
    if (m_rgpDebugScripts == NULL)
        {
        if (
            (m_rgpDebugScripts = new CActiveScriptEngine *[m_cScriptEngines])
            == NULL
           )
            {
            return E_OUTOFMEMORY;
            }

        memset(m_rgpDebugScripts, 0, m_cScriptEngines * sizeof(CActiveScriptEngine *));
        }

    Assert (idEngine < m_cScriptEngines);
    CActiveScriptEngine **ppScriptElem = &m_rgpDebugScripts[idEngine];

    if (*ppScriptElem != NULL)
        (*ppScriptElem)->Release();

    *ppScriptElem = pScriptEngine;
    pScriptEngine->AddRef();

    // Initialize the script engine now (is currently uninitialized)
    // so that the debugger user can set breakpoints.
    IActiveScript *pActiveScript = pScriptEngine->GetActiveScript();
    HRESULT  hr;

    TRY
        hr = pActiveScript->SetScriptSite(static_cast<IActiveScriptSite *>(pScriptEngine));
    CATCH(nExcept)
        HandleErrorMissingFilename(IDE_SCRIPT_ENGINE_GPF,
                                   NULL,
                                   TRUE,
                                   nExcept,
                                   "IActiveScript::SetScriptSite()",
                                   "CTemplate::AddScript()");
        hr = nExcept;
    END_TRY

    if (FAILED(hr))
        {
        *ppScriptElem = NULL;
        return E_FAIL;
        }

    TRY
        hr = pActiveScript->SetScriptState(SCRIPTSTATE_INITIALIZED);
    CATCH(nExcept)
        HandleErrorMissingFilename(IDE_SCRIPT_ENGINE_GPF,
                                   NULL,
                                   TRUE,
                                   nExcept,
                                   "IActiveScript::SetScriptState()",
                                   "CTemplate::AddScript()");
        hr = nExcept;
    END_TRY

    if (FAILED(hr))
        return E_FAIL;

    return S_OK;
    }

/*  ============================================================================
    CTemplate::AppendMapFile
    Appends a filemap to the workstore and memory-maps its file

    Returns:
        Nothing
    Side effects:
        Allocates memory; throws exception on error
*/
void
CTemplate::AppendMapFile
(
LPCTSTR     szFileSpec,         // file spec for this file
CFileMap*   pfilemapCurrent,    // ptr to filemap of parent file
BOOLB       fVirtual,           // is file spec virtual or relative?
CHitObj*    pHitObj,            // ptr to template's hit object
BOOLB       fGlobalAsa          // is this file the global.asa file?
)
    {
    // alloc or realloc as needed
    if(m_cFilemaps++ == 0)
        m_rgpFilemaps = (CFileMap**) CTemplate::SmallMalloc(sizeof(CFileMap*));
    else
        m_rgpFilemaps = (CFileMap**) CTemplate::SmallReAlloc(m_rgpFilemaps, m_cFilemaps * sizeof(CFileMap*));

    if(NULL == m_rgpFilemaps)
        THROW(E_OUTOFMEMORY);

    if(NULL == (m_rgpFilemaps[m_cFilemaps - 1] = new CFileMap))
        THROW(E_OUTOFMEMORY);

    // map the file
    m_rgpFilemaps[m_cFilemaps - 1]->MapFile(
                                            szFileSpec,
                                            m_szApplnVirtPath,
                                            pfilemapCurrent,
                                            fVirtual,
                                            pHitObj,
                                            fGlobalAsa
                                            );
    }

/*  ============================================================================
    CTemplate::GetSegmentsFromFile
    Gets source segments from a source file by calling ExtractAndProcessSegment
    until there are no more segments; populates WorkStore with info on source segments.

    Returns:
        Nothing
    Side effects:
        None
*/
void
CTemplate::GetSegmentsFromFile
(
CFileMap&   filemap,        // this file's file map
CWorkStore& WorkStore,      // working storage for source segments
CHitObj*    pHitObj,        // Browser request object
BOOL        fIsHTML
)
    {
    CByteRange  brSearch;       // byte range to search for source segments
    _TOKEN      rgtknOpeners[TOKEN_OPENERS_MAX]; // array of permitted open tokens
    UINT        ctknOpeners;    // count of permitted open tokens
    SOURCE_SEGMENT ssegThisFile = ssegHTML; // Either HTML or <SCRIPT> segment
    BOOL        fPrevCodePageSet = FALSE;
    UINT        wPrevCodePage;

    // init search range to all of file - NOTE we ignore high dword of file size
    brSearch.m_pb = filemap.m_pbStartOfFile;
    brSearch.m_cb = filemap.GetSize();

    if (fIsHTML)
        {
                // populate array of permitted open tokens
                ctknOpeners = 4;
                rgtknOpeners[0] = CTokenList::tknOpenPrimaryScript;
                rgtknOpeners[1] = CTokenList::tknOpenTaggedScript;
                rgtknOpeners[2] = CTokenList::tknOpenObject;
                rgtknOpeners[3] = CTokenList::tknOpenHTMLComment;
                }
        else
                {
                ctknOpeners = 1;
                rgtknOpeners[0] = CTokenList::tknOpenHTMLComment;
        ssegThisFile = ssegTaggedScript;
                }

    TRY

        if ((brSearch.m_cb >= 2)
            && (((brSearch.m_pb[0] == 0xff) && (brSearch.m_pb[1] == 0xfe))
                || ((brSearch.m_pb[0] == 0xfe) && (brSearch.m_pb[1] == 0xff)))) {
            ThrowError(brSearch.m_pb,IDE_TEMPLATE_UNICODE_NOTSUP);
            return;
        }

        // check for the UTF-8 BOM mark.  If present, then treat this similar to
        // seeing @CODEPAGE=65001.  Note that previous values are retained in the
        // event that there are differing @CODEPAGE settings.  This probably should
        // be an error in itself, but I can imagine that this might break a lot of
        // apps as more and more UTF8 files are put into use.

        if ((brSearch.m_cb >= 3)
            && (brSearch.m_pb[0] == 0xEF) 
            && (brSearch.m_pb[1] == 0xBB)
            && (brSearch.m_pb[2] == 0xBF)) {

            pHitObj->SetCodePage(65001);

            fPrevCodePageSet = m_fCodePageSet;
            wPrevCodePage = m_wCodePage;

            m_fCodePageSet = TRUE;
            m_wCodePage = 65001;
            brSearch.Advance(3);
        }


        // Process source segments until we run out of them, i.e. until search segment is empty
        // NOTE we pass current filemap as 'parent file' to ExtractAndProcessSegment
        // NOTE ExtractAndProcessSegment appends source segments to WorkStore, advancing brSearch as it goes
        while(!brSearch.IsNull())
            ExtractAndProcessSegment(
                                        brSearch,
                                        ssegThisFile,
                                        rgtknOpeners,
                                        ctknOpeners,
                                        &filemap,
                                        WorkStore,
                                        pHitObj,
                                        ssegThisFile == ssegTaggedScript,
                                        fIsHTML
                                    );

    CATCH(hrException)
        /*
            NOTE we indicate 'generic error' by m_idErrMsg == 0; this happens as we move
            up the 'include file stack' after processing a specific error (m_idErrMsg != 0).
            Only the specific error is processed; generic error, we simply re-throw exception.
        */
        if(m_idErrMsg != 0)
            {
            // process specific error
            ProcessSpecificError(filemap, pHitObj);

            // reset err message so next msg will be generic as we move up the stack
            m_idErrMsg = 0;
            }

        THROW(hrException);

    END_TRY

    if (fPrevCodePageSet){
        m_wCodePage = wPrevCodePage;
        pHitObj->SetCodePage(wPrevCodePage);
    }
    }


#define SZ_REG_LANGUAGE_ENGINES "SYSTEM\\CurrentControlSet\\Services\\W3SVC\\ASP\\LanguageEngines\\"
/*  ============================================================================
    CTemplate::GetLanguageEquivalents
    Gets the "Write", "WriteBlock", etc. equivalents from registry for primary scripting language

    Returns
        Nothing
    Side effects
        Throws on error
*/
void
CTemplate::GetLanguageEquivalents
(
)
    {
    CByteRange  brPrimaryEngine;
    m_pWorkStore->m_ScriptStore.m_bufEngineNames.GetItem(0, brPrimaryEngine);   // 0-th engine is primary

#if DBG

    /*  DEBUG ONLY - to test the reg lookup code you must:
        1) create the key HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\W3SVC\ASP\LanguageEngines\Debug
        2) put the language reg values for WriteBlock and Write under the language you want to test
    */
    HANDLE  hKey;
    if(ERROR_SUCCESS != RegOpenKeyExA(
                                        HKEY_LOCAL_MACHINE,
                                        "SYSTEM\\CurrentControlSet\\Services\\W3SVC\\ASp\\LanguageEngines\\Debug",
                                        0,
                                        KEY_READ,
                                        (PHKEY)&hKey
                                    ))
        {
        return;
        }

    RegCloseKey((HKEY)hKey);

#else

    //  if the primary language is one of the big two, return; we don't need to look up equivalents
    if(brPrimaryEngine.FMatchesSz("VBScript"))
        return;
    if(brPrimaryEngine.FMatchesSz("JScript"))
        return;
    if(brPrimaryEngine.FMatchesSz("JavaScript"))
        return;
    if(brPrimaryEngine.FMatchesSz("LiveScript"))
        return;

#endif  // DBG

    /*  query the registry; language equivalents are stored in:
        HKEY_LOCAL_MACHINE
            key: SYSTEM
                key: CurrentControlSet
                    key: Services
                        key: W3SVC
                            key: ASP
                                key: LanguageEngines
                                    key: <LanguageName>
                                        value: Write        data: <replacement syntax for Response.Write(|)>
                                        value: WriteBlock   data: <replacement syntax for Response.WriteBlock(|)>
    */
    STACK_BUFFER( tempRegKeyPath, 512 );

    UINT    cchRegKeyPath = strlen(SZ_REG_LANGUAGE_ENGINES);

    if (!tempRegKeyPath.Resize(cchRegKeyPath + brPrimaryEngine.m_cb + 1)) {
        SetLastError(E_OUTOFMEMORY);
        return;
    }

    LPSTR   szRegKeyPath = static_cast<LPSTR> (tempRegKeyPath.QueryPtr());

    LPSTR   pch = szRegKeyPath;

    strcpy(pch, SZ_REG_LANGUAGE_ENGINES);
    pch += cchRegKeyPath;
    strncpy(pch, (const char *) brPrimaryEngine.m_pb, brPrimaryEngine.m_cb);
    pch += brPrimaryEngine.m_cb;
    *pch = '\0';

    HANDLE      hKeyScriptLanguage; // handle of script language reg key

    if(ERROR_SUCCESS == RegOpenKeyExA(
                                        HKEY_LOCAL_MACHINE, // handle constant
                          (const char*) szRegKeyPath,       // LPCSTR lpSubKey     subkey to open
                                        0,                  // DWORD ulOptions      reserved; must be zero
                                        KEY_QUERY_VALUE,    // REGSAM samDesired    security access mask
                                        (PHKEY) &hKeyScriptLanguage // PHKEY phkResult      address of handle of open key
                                    ))
        {
        SetLanguageEquivalent(hKeyScriptLanguage, "Write",      &(m_pWorkStore->m_szWriteOpen),      &(m_pWorkStore->m_szWriteClose));
        SetLanguageEquivalent(hKeyScriptLanguage, "WriteBlock", &(m_pWorkStore->m_szWriteBlockOpen), &(m_pWorkStore->m_szWriteBlockClose));
        RegCloseKey((HKEY) hKeyScriptLanguage);
        }

    }

/*  ============================================================================
    CTemplate::SetLanguageEquivalent
    Sets a "language equivalent" from the registry.

    Returns:
        language item opener and closer as out-parameters
        Ex: "Response.Write(" and ")"
    Side effects:
        Throws on error
*/
void
CTemplate::SetLanguageEquivalent
(
HANDLE  hKeyScriptLanguage, // reg key
LPSTR   szLanguageItem,     // reg value name - "Write", "WriteBlock", etc.
LPSTR*  pszOpen,            // ptr to language item opener, e.g. "Response.Write("  (out-parameter)
LPSTR*  pszClose            // ptr to language item closer, e.g. ")"                (out-parameter)
)
    {
    LONG    lError;
    DWORD   cbSyntax;
    LPSTR   szSyntax;
    char*   pchInsert;
    UINT    cchOpen;
    UINT    cchClose;

    // query registry to get buffer size
    lError = RegQueryValueExA(
                                (HKEY) hKeyScriptLanguage,  // handle of key to query
                                szLanguageItem,     // name of value to query
                                NULL,               // reserved; must be NULL
                                NULL,               // ptr to value type; not required
                                NULL,               // ptr to data buffer
                                &cbSyntax           // ptr to data buffer size
                            );

    if(ERROR_FILE_NOT_FOUND == lError)
        // if we don't find szLanguageItem in registry, return silently, leaving *pszOpen and *pszClose unchanged
        return;
    else if((ERROR_MORE_DATA != lError) && (ERROR_SUCCESS != lError))
        THROW(lError);

    Assert(cbSyntax > 0);

    // allocate buffer and re-query registry to get syntax string
    // NOTE RegQueryValueEx returns cbSyntax that includes room for '\0' terminator

    STACK_BUFFER(tempSyntax, 64);

    if (!tempSyntax.Resize(cbSyntax)) {
        THROW(E_OUTOFMEMORY);
    }
    szSyntax = static_cast<LPSTR> (tempSyntax.QueryPtr());
    lError = RegQueryValueExA(
                                (HKEY) hKeyScriptLanguage,  // handle of key to query
                                szLanguageItem,     // name of value to query
                                NULL,               // reserved; must be NULL
                                NULL,               // ptr to value type; not required
                       (LPBYTE) szSyntax,           // ptr to data buffer
                                &cbSyntax           // ptr to data buffer size
                            );

    /*  NOTE there is the slight possibility of ERROR_FILE_NOT_FOUND or ERROR_MORE_DATA
        if the registry value was deleted or changed between the first and second calls to RegQueryValueEx.
        Since this occurs with vanishingly small probability, we throw (instead of coding the re-try logic).
    */
    if(ERROR_SUCCESS != lError)
        THROW(lError);

    pchInsert = szSyntax;

    while(*pchInsert != '|' && *pchInsert != '\0')
        pchInsert++;

    cchOpen = DIFF(pchInsert - szSyntax);

    cchClose =  *pchInsert == '|'
                ? cbSyntax - cchOpen - 2    // found insert symbol: deduct 2 chars, 1 for insert symbol, 1 for '\0'
                : cbSyntax - cchOpen - 1;   // didn't find insert symbol: deduct 1 char for '\0'

    Assert(FImplies(cchOpen == 0, *szSyntax == '|'));
    Assert(FImplies(*pchInsert == '\0', cchClose == 0));

    if(cchOpen == 0)
        // opener is empty - set caller's opener ptr null
        *pszOpen = NULL;
    else if(cchOpen > 0)
        {
        // opener is non-empty - set caller's opener to opener in registry
        if(NULL == (*pszOpen = (LPSTR) CTemplate::SmallMalloc(cchOpen + 1)))
            THROW(E_OUTOFMEMORY);

        strncpy(*pszOpen, szSyntax, cchOpen);
        (*pszOpen)[cchOpen] = '\0';
        }

    if(cchClose == 0)
        // closer is empty - set caller's closer ptr null
        *pszClose = NULL;
    else if(cchClose > 0)
        {
        // closer is non-empty - set caller's closer to closer in registry
        if(NULL == (*pszClose = (LPSTR) CTemplate::SmallMalloc(cchClose + 1)))
            THROW(E_OUTOFMEMORY);

        strncpy(*pszClose, (pchInsert + 1), cchClose);
        (*pszClose)[cchClose] = '\0';
        }

    }

/*  ============================================================================
    CTemplate::ThrowError
    Sets up for processing a compile failure.

    Returns:
        Nothing
    Side effects:
        Throws error
*/
void
CTemplate::ThrowError
(
BYTE*   pbErrorLocation,    // ptr to error location in source file
UINT    idErrMsg            // error id
)
    {
    m_pbErrorLocation = pbErrorLocation;
    m_idErrMsg = idErrMsg;

    // bug 80745: always throw compile-failed-don't-cache
    THROW(E_TEMPLATE_COMPILE_FAILED_DONT_CACHE);
    }

/*  ============================================================================
    CTemplate::AppendErrorMessageInsert
    Appends an error message insert to member array.

    Returns:
        Nothing
    Side effects:
        Appends to inserts array
*/
void
CTemplate::AppendErrorMessageInsert
(
BYTE*   pbInsert,   // ptr to insert
UINT    cbInsert    // length of insert
)
    {
    if (m_ppszMsgInserts == NULL)
        {
        m_ppszMsgInserts = new char*;
        m_cMsgInserts = 0;

        if (m_ppszMsgInserts == NULL)
            return;
        }

    m_ppszMsgInserts[m_cMsgInserts] = new char[cbInsert + 1];
    if (m_ppszMsgInserts[m_cMsgInserts] == NULL)
        return;

    strncpy(m_ppszMsgInserts[m_cMsgInserts], (const char*)pbInsert, cbInsert);
    m_ppszMsgInserts[m_cMsgInserts++][cbInsert] = NULL;
    }

/*  ============================================================================
    CTemplate::ThrowErrorSingleInsert
    Appends a single message insert to member array and throws a compile error.

    Returns:
        Nothing
    Side effects:
        Throws error indirectly
*/
void
CTemplate::ThrowErrorSingleInsert
(
BYTE*   pbErrorLocation,    // ptr to error location in source file
UINT    idErrMsg,           // error id
BYTE*   pbInsert,           // ptr to insert
UINT    cbInsert            // length of insert
)
    {
    AppendErrorMessageInsert(pbInsert, cbInsert);
    ThrowError(pbErrorLocation, idErrMsg);
    }

/*  ============================================================================
    CTemplate::ProcessSpecificError
    Processes a specific compile failure.

    Returns:
        Nothing
    Side effects:
        None
*/
void
CTemplate::ProcessSpecificError
(
CFileMap&   filemap,        // source file map
CHitObj*    pHitObj         // Browser request object
)
    {
    // no error msg for generic failures
    if(m_idErrMsg == E_FAIL || m_idErrMsg == E_OUTOFMEMORY)
        return;

    HandleCTemplateError(
                            &filemap,
                            m_pbErrorLocation,
                            m_idErrMsg,
                            m_cMsgInserts,
                            m_ppszMsgInserts,
                            pHitObj
                        );
    }


/*  ============================================================================
    CTemplate::ShowErrorInDebugger
    Display a runtime error by invoking the JIT debugger

    Returns:
        failure if debugger won't start

    Side effects:
        None.
*/
HRESULT
CTemplate::ShowErrorInDebugger
(
CFileMap* pfilemap,
UINT cchErrorLocation,
char* szDescription,
CHitObj *pHitObj,
BOOL fAttachDocument
)
    {
    HRESULT hr = S_OK;
    char szDebugTitle[64];

    if (pfilemap == NULL || szDescription == NULL || pHitObj == NULL)
        return E_POINTER;

    // Create a new document context for this statement
    // CONSIDER: character count that we return is bogus - however our debugging
    //           client (Caesar's) does not use this information anyway.
    //
    CTemplateDocumentContext *pDebugContext = new CTemplateDocumentContext(this, cchErrorLocation, 1);
    if (pDebugContext == NULL)
        return E_OUTOFMEMORY;

    // Make sure debug document is attached to debugger
    if (fAttachDocument)
                AttachTo(pHitObj->PAppln());

    // Yes it does, bring up the debugger on this line
    hr =  InvokeDebuggerWithThreadSwitch(g_pDebugApp, DEBUGGER_UI_BRING_DOC_CONTEXT_TO_TOP, pDebugContext);
    if (FAILED(hr))
        goto LExit;

    // Load the compiler message string
    CchLoadStringOfId(IDE_TEMPLATE_ERRMSG_TITLE, szDebugTitle, sizeof szDebugTitle);

    // pop up a message box with the error description
    MessageBoxA(NULL, szDescription, szDebugTitle, MB_SERVICE_NOTIFICATION | MB_TOPMOST | MB_OK | MB_ICONEXCLAMATION);

LExit:
    if (pDebugContext)
        pDebugContext->Release();

    return hr;
    }

/*  ============================================================================
    CTemplate::HandleCTemplateError
    Handles template compilation errors

    Returns:
        Nothing

    Side effects:
        None.
*/
void
CTemplate::HandleCTemplateError
(
CFileMap*   pfilemap,           // ptr to source file map
BYTE*       pbErrorLocation,    // ptr to source location where error occurred
UINT        idErrMsg,           // error message id
UINT        cMsgInserts,        // count of insert strings for error msg
char**      ppszMsgInserts,     // array of ptrs to error msg insert strings
CHitObj*    pHitObj             // Browser Request
)
    {
    char    szErrMsgPattern[MAX_RESSTRINGSIZE]; // error message pattern
    CHAR    szLineNum[12];
    TCHAR   szFileName[512];
    CHAR    szShortDes[256];
    CHAR    szEngine[256];
    CHAR    szErrCode[20];
    CHAR    szLongDes[MAX_RESSTRINGSIZE];
    CHAR    szCombinedDes[sizeof szShortDes + sizeof szLongDes];    // long & short desc
    DWORD   dwMask;
    UINT    cch;


    // if request ptr or ecb ptr is null, bail; we won't be able to write error msg anyway
    if(pHitObj == NULL)
        return;

    /*  if this was a security error, process it specially and bail
        NOTE security error causes exception, rather than true error id
        NOTE template will be destroyed anyway in this case, so no need to maintain m_pszLastErrorMessage
    */
    if(idErrMsg == E_USER_LACKS_PERMISSIONS)
        {
        Assert(cMsgInserts == 1);
        HandleAccessFailure(pHitObj,
                                                        (m_rgpFilemaps && m_rgpFilemaps[0])? m_rgpFilemaps[0]->m_szPathTranslated : NULL);

        return;
        }

    // get error resource message
    LoadErrResString(idErrMsg, &dwMask, szErrCode, szShortDes, szLongDes);

    // if we have a specific error location, construct msg prefix
    if(pbErrorLocation != NULL) {
        Assert(pfilemap != NULL);
        // get line number of error location as string
        _itoa(SourceLineNumberFromPb(pfilemap, pbErrorLocation), szLineNum, 10);
    }
    else {
        szLineNum[0] = NULL;
    }

    if(pfilemap != NULL) {
        cch = _tcslen(pfilemap->m_szPathInfo);
        _tcsncpy(szFileName, pfilemap->m_szPathInfo, cch);
    }
    else {
        cch = 0;
    }

    szFileName[cch] = '\0';

    //Load Default Engine from resource
    cch = CchLoadStringOfId(IDS_ENGINE, szEngine, sizeof szEngine);
    szEngine[cch] = '\0';

    // resolve error msg pattern and inserts into actual error msg
    cch = strlen(szLongDes);
    memcpy(szErrMsgPattern, szLongDes, cch);
    szErrMsgPattern[cch] = '\0';

    // get an idea of the possibility of a buffer overrunn
    UINT dwTotalLen=0;
        BOOL fTooBig = FALSE;

    if (cMsgInserts) {
        // allow 32 characters for space, etc.
        dwTotalLen = 32 + strlen(szErrMsgPattern);
		for (UINT i = 0; i < cMsgInserts; i++)
			dwTotalLen += strlen(ppszMsgInserts[i]);

		if (dwTotalLen > sizeof szLongDes) {
			cch = CchLoadStringOfId(IDE_TOOBIG, szLongDes, sizeof szLongDes);
			szLongDes[cch] = '\0';
			fTooBig = TRUE;
        }
    }

    if (!fTooBig)
        GetSzFromPatternInserts(szErrMsgPattern, cMsgInserts, ppszMsgInserts, szLongDes);
    
    // attempt to bring up debugger to display the error - if we cannot then log the error

    /* Find the character offset closest to cbErrorLocation.  This will be
     * the place where we start looping with CharNext() to get the full
     * character offset.
     *
     * NOTE: compilation is done in two phases.
     *          Errors are detected and reported in phase 1.
     *          The DBCS mapping is created in phase 2.
     *
     *    Therefore, we don't have the benefit of the rgByte2DBCS table
     *    because it doesn't exist yet.  Therefore we are left with a SLOW
     *    loop starting at BOF.  To make things not so abysmal, we don't
     *    do the loop on SBCS charsets.  We also don't do this conversion
     *    unless debugging is enabled.
     */

    if (FCaesars() && pHitObj->PAppln()->FDebuggable()) {
        unsigned cchErrorLocation = CharAdvDBCS(
                                        (WORD)m_wCodePage,
                                        reinterpret_cast<char *>(pfilemap->m_pbStartOfFile),
                                        reinterpret_cast<char *>(pbErrorLocation),
                                        INFINITE,
                                        NULL);

        // Create the description string
        char *szEnd = strcpyExA(szCombinedDes, szShortDes);
        *szEnd++ = '\n';
        *szEnd++ = '\n';
        strcpy(szEnd, szLongDes);

        ShowErrorInDebugger(pfilemap, cchErrorLocation, szCombinedDes, pHitObj, idErrMsg != IDE_TEMPLATE_CYCLIC_INCLUDE);
    }

    //cache the info in case we need to use later.
    m_dwLastErrorMask = dwMask;
    //delay NULL check to caller who use this info.
#if UNICODE
    m_pszLastErrorInfo[ILE_szFileName]  = StringDupUTF8(szFileName);
#else
    m_pszLastErrorInfo[ILE_szFileName]  = StringDupA(szFileName);
#endif
    m_pszLastErrorInfo[ILE_szLineNum]   = StringDupA(szLineNum);
    m_pszLastErrorInfo[ILE_szEngine]    = StringDupA(szEngine);
    m_pszLastErrorInfo[ILE_szErrorCode] = StringDupA(szErrCode);
    m_pszLastErrorInfo[ILE_szShortDes]  = StringDupA(szShortDes);
    m_pszLastErrorInfo[ILE_szLongDes]   = StringDupA(szLongDes);

    SendToLog(  m_dwLastErrorMask,
                m_pszLastErrorInfo[ILE_szFileName],
                m_pszLastErrorInfo[ILE_szLineNum],
                m_pszLastErrorInfo[ILE_szEngine],
                m_pszLastErrorInfo[ILE_szErrorCode],
                m_pszLastErrorInfo[ILE_szShortDes],
                m_pszLastErrorInfo[ILE_szLongDes],
                pHitObj);
    }

/*  ============================================================================
    CTemplate::FreeGoodTemplateMemory
    Frees memory allocated for a 'good' (successfully compiled) template.
    This includes the template itself, memory to support compile-time errors
    (since the entire concatenated compile-time error message is cached in
    last-err-msg member), and memory to support run-time errors (since if the
    template didn't compile, it can't run).

    Returns
        Nothing
    Side effects
        None
*/
void
CTemplate::FreeGoodTemplateMemory
(
)
    {
    UINT    i;

        LargeTemplateFreeNullify((void**) &m_pbStart);
    SmallTemplateFreeNullify((void**) &m_rgpSegmentFilemaps);

    delete[] m_rgrgSourceInfos;
    m_rgrgSourceInfos = NULL;

    if(m_ppszMsgInserts)
        {
        for(i = 0; i < m_cMsgInserts; i++)
            delete m_ppszMsgInserts[i];
        delete m_ppszMsgInserts;
        m_ppszMsgInserts = NULL;
        }

    // release the collected type libs
    ReleaseTypeLibs();

    // release any 449-echo-cookie objects
    Release449();
    }

/*  ============================================================================
    CTemplate::UnmapFiles
    Unmaps the template's filemaps.
    NOTE: we keep filemap objects around so that filenames will be available for runtime errors

    Returns
        Nothing
    Side effects
        Unmaps template's filemaps
*/
void
CTemplate::UnmapFiles
(
)
    {
    UINT    i;
    for(i = 0; i < m_cFilemaps; i++)
        m_rgpFilemaps[i]->UnmapFile();
    }

/*===================================================================
    CTemplate::ExtractAndProcessSegment
    Extracts and processes leading source segment and first contained
    source segment from search range.

    Returns
        Nothing
    Side effects
        None
*/
void
CTemplate::ExtractAndProcessSegment
(
CByteRange&             brSearch,           // byte range to search for next segment-opening token
const SOURCE_SEGMENT&   ssegLeading,        // type of 'leading', i.e. pre-token, source segment
_TOKEN*                 rgtknOpeners,       // array of permitted open tokens
UINT                    ctknOpeners,        // count of permitted open tokens
CFileMap*               pfilemapCurrent,    // ptr to filemap of parent file
CWorkStore&             WorkStore,          // working storage for source segments
CHitObj*                pHitObj,            // Browser request object
BOOL                    fScriptTagProcessed,// has script tag been processed?
BOOL                    fIsHTML             // are we in HTML segment?
)
    {
    CByteRange      brLeadSegment;      // byte range of leading source segment
    SOURCE_SEGMENT  ssegContained;      // type of 'contained', i.e. post-token, source segment
    CByteRange      brContainedSegment; // byte range of contained source segment
    _TOKEN          tknOpen;            // opening token
    BYTE*           pbTokenOpen;        // ptr to opening token
    _TOKEN          tknClose;           // closing token
    BYTE*           pbTokenClose;       // ptr to closing token

    // NOTE: If "fScriptTagProcessed" is TRUE, then "fIsHTML" must be FALSE.  The reason for
    // both flags is that if "fScriptTagProcessed" is FALSE, then "fIsHTML" may be either TRUE
    // or FALSE (indeterminate)
    //
    Assert (FImplies(fScriptTagProcessed, !fIsHTML));

    // If search range is empty, return
    if(brSearch.IsNull())
        return;

    // Set ptr of leading segment to start of search segment
    brLeadSegment.m_pb = brSearch.m_pb;

    // get open token for contained segment
    pbTokenOpen = GetOpenToken(
                                brSearch,
                                ssegLeading,
                                rgtknOpeners,
                                ctknOpeners,
                                &tknOpen
                            );

    // Set count of leading segment to distance between start of search range and token
    brLeadSegment.m_cb = DIFF(pbTokenOpen - brSearch.m_pb);

    // Process leading segment
    ProcessSegment(ssegLeading, brLeadSegment, pfilemapCurrent, WorkStore, fScriptTagProcessed, pHitObj, fIsHTML);

    // If open token was 'EOF', empty out search range and return
    if(tknOpen == CTokenList::tknEOF)
        {
        brSearch.Nullify();
        return;
        }

    // Set contained segment type and close token based upon the opener we found
    tknClose = GetComplementToken(tknOpen);
    ssegContained = GetSegmentOfOpenToken(tknOpen);

    if(ssegContained == ssegHTMLComment)
        // for html comment segments, advance search range to open token
        // NOTE keep html comment tags in segment because they must be sent to client
        brSearch.Advance(DIFF(pbTokenOpen - brSearch.m_pb));
    else
        // for all but html comment segments, advance search range to just past open token
        gm_pTokenList->MovePastToken(tknOpen, pbTokenOpen, brSearch);

    // Get closing token - if none, throw error
    if(NULL == (pbTokenClose = GetCloseToken(brSearch, tknClose)))
        {
        if(tknOpen == CTokenList::tknOpenPrimaryScript)
            ThrowError(pbTokenOpen, IDE_TEMPLATE_NO_CLOSE_PSCRIPT);
        else if(tknOpen == CTokenList::tknOpenTaggedScript)
            ThrowError(pbTokenOpen, IDE_TEMPLATE_NO_CLOSE_TSCRIPT);
        else if(tknOpen == CTokenList::tknOpenObject)
            ThrowError(pbTokenOpen, IDE_TEMPLATE_NO_CLOSE_OBJECT);
        else if(tknOpen == CTokenList::tknOpenHTMLComment)
            ThrowError(pbTokenOpen, IDE_TEMPLATE_NO_CLOSE_HTML_COMMENT);
        }

    // calc contained segment
    brContainedSegment.m_pb = brSearch.m_pb;
    brContainedSegment.m_cb = DIFF(pbTokenClose - brSearch.m_pb);

    // advance search range to just past close token
    gm_pTokenList->MovePastToken(tknClose, pbTokenClose, brSearch);

    // if an html comment segment, get actual segment type (e.g. might be a server-side include command)
    // NOTE call may also change contained segment byte range
    if(ssegContained == ssegHTMLComment)
        ssegContained = SsegFromHTMLComment(brContainedSegment);

    // if an html comment segment, add its close tag to contained segment
    // NOTE we keep html comment tags as part of segment so we can process like any other html segment
    if(ssegContained == ssegHTMLComment)
        brContainedSegment.m_cb += CCH_TOKEN(tknClose);

    if(ssegContained == ssegMetadata)
        {
        // METADATA comments are used by DESIGN time controls and we don't send
        // them to the client.

        // We process metadata to get to the typelib info
        UINT idError = 0;
        HRESULT hr = ProcessMetadataSegment(brContainedSegment, &idError, pHitObj);

        if (FAILED(hr))
            ThrowError(brContainedSegment.m_pb, idError);
        }
    else if (ssegContained == ssegFPBot)
        {
        }
    else
        {
        // process contained segment
        ProcessSegment(ssegContained, brContainedSegment, pfilemapCurrent, WorkStore, fScriptTagProcessed, pHitObj, fIsHTML);
        }
    }

/*  ============================================================================
    CTemplate::SsegFromHTMLComment
    Determines source segment type of HTML comment.

    Returns
        Source segment type
    Side effects
        May advance segment byte range
*/
CTemplate::SOURCE_SEGMENT
CTemplate::SsegFromHTMLComment
(
CByteRange& brSegment   // source segment
)
    {
    SOURCE_SEGMENT  ssegRet = ssegHTMLComment;  // return value
    BYTE*           pbToken;                    // ptr to token

    if(NULL != (pbToken = gm_pTokenList->GetToken(CTokenList::tknCommandINCLUDE, brSegment, m_wCodePage)))
        {
        gm_pTokenList->MovePastToken(CTokenList::tknCommandINCLUDE, pbToken, brSegment);
        ssegRet = ssegInclude;
        }
    else if(NULL != (pbToken = gm_pTokenList->GetToken(CTokenList::tknTagMETADATA, brSegment, m_wCodePage)))
        {
        gm_pTokenList->MovePastToken(CTokenList::tknTagMETADATA, pbToken, brSegment);
        ssegRet = ssegMetadata;
        }
    else if(NULL != (pbToken = gm_pTokenList->GetToken(CTokenList::tknTagFPBot, brSegment, m_wCodePage)))
        {
        gm_pTokenList->MovePastToken(CTokenList::tknTagFPBot, pbToken, brSegment);
        ssegRet = ssegFPBot;
        }

    return ssegRet;
    }

/*  ============================================================================
    CTemplate::ProcessSegment
    Processes a source segment based on its type.

    Returns
        Nothing
    Side effects
        None
*/
void
CTemplate::ProcessSegment
(
SOURCE_SEGMENT  sseg,                   // segment type
CByteRange&     brSegment,              // segment byte range
CFileMap*       pfilemapCurrent,        // ptr to filemap of parent file
CWorkStore&     WorkStore,              // working storage for source segments
BOOL            fScriptTagProcessed,    // has script tag been processed?
CHitObj*        pHitObj,                // Browser request object
BOOL            fIsHTML                 // Is segment in HTML block or script?
)
    {
    UINT        idSequence; // sequence id for this segment

    // if segment is entirely white space, silently return
    if(FByteRangeIsWhiteSpace(brSegment))
        return;

    // set local sequence id and increment member
    idSequence = WorkStore.m_idCurSequence++;

    // Process segment based on its type
    if(sseg == ssegHTML)
        ProcessHTMLSegment(brSegment, WorkStore.m_bufHTMLSegments, idSequence, pfilemapCurrent);
    else if(sseg == ssegHTMLComment)
        ProcessHTMLCommentSegment(brSegment, pfilemapCurrent, WorkStore, pHitObj);
    else if(sseg == ssegPrimaryScript || sseg == ssegTaggedScript)
        ProcessScriptSegment(sseg, brSegment, pfilemapCurrent, WorkStore, idSequence, (BOOLB)!!fScriptTagProcessed, pHitObj);
    else if(sseg == ssegObject)
        ProcessObjectSegment(brSegment, pfilemapCurrent, WorkStore, idSequence);
    else if(sseg == ssegInclude)
        {
        if (! fIsHTML)
                ThrowError(brSegment.m_pb, IDE_TEMPLATE_BAD_SSI_COMMAND);

        ProcessIncludeFile(brSegment, pfilemapCurrent, WorkStore, idSequence, pHitObj, fIsHTML);
        }

    // malloc/realloc array if needed
    if(m_cSegmentFilemapSlots == 0)
        {
        m_cSegmentFilemapSlots = C_SCRIPTSEGMENTSDEFAULT + C_HTMLSEGMENTSDEFAULT;
        if(NULL == (m_rgpSegmentFilemaps = (CFileMap**) CTemplate::SmallMalloc(m_cSegmentFilemapSlots * sizeof(CFileMap*))))
            THROW(E_OUTOFMEMORY);
        }
    else if(idSequence >= m_cSegmentFilemapSlots)
        {
        // grab twice what we had before
        m_cSegmentFilemapSlots *= 2;
        if(NULL == (m_rgpSegmentFilemaps = (CFileMap**) CTemplate::SmallReAlloc(m_rgpSegmentFilemaps,
                                                            m_cSegmentFilemapSlots * sizeof(CFileMap*))))
            THROW(E_OUTOFMEMORY);
        }

    // set filemap ptr for this segment - NOTE 'parent' filemap is also current file map
    m_rgpSegmentFilemaps[idSequence] = pfilemapCurrent;
    }

/*  ========================================================
    CTemplate::ProcessHTMLSegment

    Processes an HTML segment.

    Returns
        Nothing
    Side effects
        None
*/
void
CTemplate::ProcessHTMLSegment
(
CByteRange& brHTML,         // html segment
CBuffer&    bufHTMLBlocks,  // working storage for html blocks
UINT        idSequence,     // segment sequence id
CFileMap*   pfilemapCurrent // current filemap
)
    {
    if(!(brHTML.IsNull()))
        // If byte range is non-empty, store it in html buffer (non-local)
        bufHTMLBlocks.Append(brHTML, FALSE, idSequence, pfilemapCurrent);
    }

/*  ========================================================
    CTemplate::ProcessHTMLCommentSegment
    Processes an HTML comment segment: within an HTML comment we
    honor plain text (passed through as HTML comment) and primary script.
    See bug 182 for istudio scenarios that require this behavior.

    Returns
        Nothing
    Side effects
        None
*/
void
CTemplate::ProcessHTMLCommentSegment
(
CByteRange&     brSegment,          // segment byte range
CFileMap*       pfilemapCurrent,    // ptr to filemap of parent file
CWorkStore&     WorkStore,          // working storage for source segments
CHitObj*        pHitObj             // Browser request object
)
    {
    _TOKEN*     rgtknOpeners;   // array of permitted open tokens
    UINT        ctknOpeners;    // count of permitted open tokens

    // populate array of permitted open tokens
    ctknOpeners = 1;
    _TOKEN  tknOpeners[1];
    rgtknOpeners = tknOpeners;
    rgtknOpeners[0] = CTokenList::tknOpenPrimaryScript;

    // Process source segments embedded within HTML comment segment
    while(!brSegment.IsNull())
        ExtractAndProcessSegment(
                                    brSegment,      // byte range to search for next segment-opening token
                                    ssegHTML,       // type of 'leading', i.e. pre-token, source segment
                                    rgtknOpeners,   // array of permitted open tokens
                                    ctknOpeners,    // count of permitted open tokens
                                    pfilemapCurrent,// ptr to filemap of parent file
                                    WorkStore,      // working storage for source segments
                                    pHitObj         // Browser request object
                                );
    }

/*  ============================================================================
    CTemplate::ProcessScriptSegment
    Processes a script segment.

    Returns
        Nothing
    Side effects
        None
*/
void
CTemplate::ProcessScriptSegment
(
SOURCE_SEGMENT  sseg,               // segment type
CByteRange&     brSegment,          // segment byte range
CFileMap*       pfilemapCurrent,    // ptr to filemap of parent file
CWorkStore&     WorkStore,          // working storage for scripts
UINT            idSequence,         // segment sequence id
BOOLB           fScriptTagProcessed,// has script tag been processed?
CHitObj*        pHitObj             // Browser request object
)
    {
    CByteRange  brEngine;       // script engine name - NOTE constructed null

    if(m_fGlobalAsa)
        if(sseg == ssegPrimaryScript)
            // error out on primary script if we are processing global.asa
            ThrowError(brSegment.m_pb, IDE_TEMPLATE_BAD_GLOBAL_PSCRIPT);

    if(sseg == ssegPrimaryScript)
        {
        CByteRange  brTemp = brSegment;

        LTrimWhiteSpace(brTemp);

        if(*brTemp.m_pb == '@') // CONSIDER: tknTagSetPriScriptLang
            {
            // impossible condition: page-level @ commands can't be allowed if they have already been executed
            Assert(!(WorkStore.m_fPageCommandsAllowed && WorkStore.m_fPageCommandsExecuted));

            if(!WorkStore.m_fPageCommandsAllowed)
                {
                if(WorkStore.m_fPageCommandsExecuted)
                    // error out if trying to re-execute page-level @ commands
                    ThrowError(brSegment.m_pb, IDE_TEMPLATE_PAGE_COMMAND_REPEATED);
                else
                    // error out if trying to execute page-level @ commands when not allowed
                    ThrowError(brSegment.m_pb, IDE_TEMPLATE_PAGE_COMMAND_NOT_FIRST);
                }

            // if we made it here, must be allowed to execute page-level @ commands AND they have not been executed
            Assert((WorkStore.m_fPageCommandsAllowed && !WorkStore.m_fPageCommandsExecuted));

            /*  set primary script language if required
                NOTE we call GetTagName to see if LANGUAGE tag occurs in tags segment; this is somewhat wasteful,
                since BrValueOfTag must simply call GetTagName again.  However, this scheme is easier than changing
                BrValueOfTag to return a BOOL and amending all its other callers, who don't need this info.
            */

            // Flags and counters used to track and validate the @ command directive
            //
            int     nFirstPass = 1;
            int     nOffset     = 0;
            BOOLB   fTagLanguage    = TRUE;
            BOOLB   fTagCodePage    = TRUE;
            BOOLB   fTagLCID        = TRUE;
            BOOLB   fTagTransacted  = TRUE;
            BOOLB   fTagSession     = TRUE;

            while( GetTag( brSegment, nFirstPass) )
                {
                nFirstPass =2;
                nOffset = 0;

                if ( fTagLanguage && CompTagName( brSegment, CTokenList::tknTagLanguage ) )
                    {
                    fTagLanguage = FALSE;
                    brEngine = BrValueOfTag(brSegment, CTokenList::tknTagLanguage);
                    if ( brEngine.IsNull() )
                        ThrowError(brSegment.m_pb, IDE_TEMPLATE_NO_ENGINE_NAME);

                    // get prog lang id
                    PROGLANG_ID ProgLangId;
                    HRESULT hr = GetProgLangId(brEngine, &ProgLangId);

                    if(hr == TYPE_E_ELEMENTNOTFOUND)
                        // if prog lang not found, throw error
                        ThrowErrorSingleInsert(
                                            brEngine.m_pb,
                                            IDE_TEMPLATE_BAD_PROGLANG,
                                            brEngine.m_pb,
                                            brEngine.m_cb
                                            );
                    else if(FAILED(hr))
                        // other failure: re-throw exception code
                        THROW(hr);

                    Assert(WorkStore.m_ScriptStore.CountPreliminaryEngines() >= 1);

                    // Set 0-th (primary) script engine to user-specified value
                    WorkStore.m_ScriptStore.m_bufEngineNames.SetItem(
                                                                0,          // index of item to set
                                                                brEngine,   // engine name
                                                                FALSE,      // item is non-local
                                                                0,          // sequence id (don't care)
                                                                NULL        // filemap ptr (don't care)
                                                                );

                    // Set 0-th (primary) prog lang id to engine's
                    WorkStore.m_ScriptStore.m_rgProgLangId[0] = ProgLangId;
                    brSegment.Advance(DIFF(brEngine.m_pb - brSegment.m_pb));

                    }

                /*  set code page if required
                    see NOTE above for why we call we call GetTagName.
                */
                else if ( fTagCodePage && CompTagName( brSegment, CTokenList::tknTagCodePage ) )
                    {
                    fTagCodePage = FALSE;
                    CByteRange brCodePage = BrValueOfTag( brSegment, CTokenList::tknTagCodePage );
                    if ( brCodePage.IsNull() )
                        ThrowError(brSegment.m_pb, IDE_TEMPLATE_NO_CODEPAGE);

                    if ( brCodePage.m_cb > 10 )
                        ThrowError(brSegment.m_pb, IDE_TEMPLATE_BAD_CODEPAGE);

                    char    szCodePage[31];
                    strncpy( szCodePage, (char*) brCodePage.m_pb, brCodePage.m_cb );
                    szCodePage[ brCodePage.m_cb ] = '\0';

                                        char   *pchEnd;
                                        UINT    uCodePage = UINT( strtoul( szCodePage, &pchEnd, 10 ) );

                                        // verify that pchEnd is the NULL
                                        if (*pchEnd != 0)
                                                ThrowError(brSegment.m_pb, IDE_TEMPLATE_BAD_CODEPAGE);

                    if ( FAILED( pHitObj->SetCodePage( uCodePage ) ) )
                        ThrowError(brSegment.m_pb, IDE_TEMPLATE_BAD_CODEPAGE);
                    else
                        {
                        m_wCodePage = uCodePage;
                        m_fCodePageSet = TRUE;
                        }

                    brSegment.Advance(DIFF(brCodePage.m_pb - brSegment.m_pb));
                    }
                /*  set LCID if required
                    see NOTE above for why we call we call GetTagName.
                */
                else if ( fTagLCID && CompTagName( brSegment, CTokenList::tknTagLCID ) )
                    {
                    fTagLCID = FALSE;
                    CByteRange brLCID = BrValueOfTag( brSegment, CTokenList::tknTagLCID );
                    if ( brLCID.IsNull() )
                        ThrowError(brSegment.m_pb, IDE_TEMPLATE_NO_LCID);

                    char    szLCID[31];
                    strncpy( szLCID, (char*) brLCID.m_pb, brLCID.m_cb );
                    szLCID[ brLCID.m_cb ] = '\0';

                                        char   *pchEnd;
                                        UINT    uLCID = UINT( strtoul( szLCID, &pchEnd, 10 ) );

                                        // verify that pchEnd is the NULL
                                        if (*pchEnd != 0)
                                                ThrowError(brSegment.m_pb, IDE_TEMPLATE_BAD_LCID);

                    if ( FAILED( pHitObj->SetLCID( uLCID ) ) )
                        ThrowError(brSegment.m_pb, IDE_TEMPLATE_BAD_LCID);
                    else
                        {
                        m_lLCID = uLCID;
                        m_fLCIDSet = TRUE;
                        }

                    brSegment.Advance(DIFF(brLCID.m_pb - brSegment.m_pb));
                    }
                /* Set transacted if requiured
                   see NOTE above for why we call GetTagName
                */
                else if ( fTagTransacted && CompTagName( brSegment, CTokenList::tknTagTransacted ) )
                    {

                    STACK_BUFFER( tempTransValue, 32 );

                    fTagTransacted = FALSE;
                    CByteRange brTransacted = BrValueOfTag( brSegment, CTokenList::tknTagTransacted );
                    if ( brTransacted.IsNull() )
                        ThrowError(brSegment.m_pb, IDE_TEMPLATE_BAD_TRANSACTED_VALUE);

                    if (!tempTransValue.Resize(brTransacted.m_cb + 1)) {
                        ThrowError(brSegment.m_pb, IDE_OOM);
                    }

                    LPSTR szTransacted = static_cast<LPSTR> (tempTransValue.QueryPtr());
                    strncpy(szTransacted, (LPCSTR)brTransacted.m_pb, brTransacted.m_cb);
                    szTransacted[brTransacted.m_cb]='\0';
                    if (!strcmpi(szTransacted, "REQUIRED"))
                        m_ttTransacted = ttRequired;
                    else if (!strcmpi(szTransacted, "REQUIRES_NEW"))
                        m_ttTransacted = ttRequiresNew;
                    else if (!strcmpi(szTransacted, "SUPPORTED"))
                        m_ttTransacted = ttSupported;
                    else if (!strcmpi(szTransacted, "NOT_SUPPORTED"))
                        m_ttTransacted = ttNotSupported;
                    else
                        ThrowError(brSegment.m_pb, IDE_TEMPLATE_BAD_TRANSACTED_VALUE);

                    brSegment.Advance(DIFF(brTransacted.m_pb - brSegment.m_pb));
                    }
                /* Set session flag
                   see NOTE above for why we call GetTagName
                */
                else if ( fTagSession && CompTagName( brSegment, CTokenList::tknTagSession ) )
                    {

                    STACK_BUFFER( tempSession, 16 );

                    fTagSession = FALSE;
                    CByteRange brSession = BrValueOfTag( brSegment, CTokenList::tknTagSession );
                    if ( brSession.IsNull() )
                        ThrowError(brSegment.m_pb, IDE_TEMPLATE_BAD_SESSION_VALUE);

                    if (!tempSession.Resize(brSession.m_cb + 1))
                        ThrowError(brSegment.m_pb, IDE_OOM);

                    LPSTR szSession = static_cast<LPSTR> (tempSession.QueryPtr());
                    strncpy(szSession, (LPCSTR)brSession.m_pb, brSession.m_cb);
                    szSession[brSession.m_cb]='\0';
                    if (strcmpi(szSession, "TRUE") == 0)
						{
                        m_fSession = TRUE;
						if (!pHitObj->PAppln()->QueryAppConfig()->fAllowSessionState())
							ThrowError(brSegment.m_pb, IDE_TEMPLATE_CANT_ENABLE_SESSIONS);
						}
                    else if (strcmpi(szSession, "FALSE") == 0)
                        m_fSession = FALSE;
                    else
                        ThrowError(brSegment.m_pb, IDE_TEMPLATE_BAD_SESSION_VALUE);

                    brSegment.Advance(DIFF(brSession.m_pb - brSegment.m_pb));
                    }
                else
                    ThrowErrorSingleInsert( brSegment.m_pb,
                                            IDE_TEMPLATE_BAD_AT_COMMAND,
                                            brSegment.m_pb,
                                            brSegment.m_cb
                                            );
                }

                if (nFirstPass == 1)
                    ThrowErrorSingleInsert( brSegment.m_pb,
                                            IDE_TEMPLATE_BAD_AT_COMMAND,
                                            brSegment.m_pb,
                                            brSegment.m_cb
                                            );



            // set flag true and ignore remainder of segment, since we only use this segment for page-level @ commands
            WorkStore.m_fPageCommandsExecuted = TRUE;
            goto LExit;
            }

        }

    if(sseg == ssegTaggedScript)
        {
        if(!fScriptTagProcessed)
            {
            /*  semantics of script-tag-processed flag:
                - if false, we have a 'fresh' tagged script block, so we need to get its engine name
                  (which also advances past the script tag header) and then process the tagged segment
                  via indirect recursive call
                - if true, we have aleady been called recursively, so we bypass further recursion
                  and simply append to store
            */
            CByteRange brIncludeFile;
            GetScriptEngineOfSegment(brSegment, WorkStore.m_brCurEngine, brIncludeFile);
            if (! brIncludeFile.IsNull())
                {

                STACK_BUFFER( tempInclude, 256 );

                if (!tempInclude.Resize(brIncludeFile.m_cb + 1)) {
                    ThrowError(brSegment.m_pb, IDE_OOM);
                }

                                // Create Null-terminated string from brIncludeFile
                                char *szFileSpec = reinterpret_cast<char *>(tempInclude.QueryPtr());
                                memcpy(szFileSpec, brIncludeFile.m_pb, brIncludeFile.m_cb);
                                szFileSpec[brIncludeFile.m_cb] = 0;
                                if (szFileSpec[0] == '\\')      // metabase stuff chokes on initial '\' char
                                    szFileSpec[0] = '/';

                                // read the include file (szFileSpec & brIncludeFile in this case point to same string contents.
                                // however, "brIncludeFile" is used as an error location.
                                //
                TRY
                                    ProcessIncludeFile2(szFileSpec, brIncludeFile, pfilemapCurrent, WorkStore, idSequence, pHitObj, FALSE);
                CATCH(hrException)

                    // The TRY/CATCH below may re-throw a IDE_TEMPLATE_BAD_PROGLANG when the
                    // segment being processed is tagged script with a SRC file.  The reason being
                    // that to properly report the error, the ThrowErrorSingleInsert must be called
                    // from the template which contained the script tag with the bad prog lang.  If
                    // called from the template created containing the included script, then the
                    // brEngine assigned below is not pointing into the included script's filemap
                    // which results in AVs because we can't do the pointer math to determine the
                    // line number.

                    if(hrException == IDE_TEMPLATE_BAD_PROGLANG)
                        // exception code is really an error message id: set err id to it
                        ThrowErrorSingleInsert(
                                                WorkStore.m_brCurEngine.m_pb,
                                                IDE_TEMPLATE_BAD_PROGLANG,
                                                WorkStore.m_brCurEngine.m_pb,
                                                WorkStore.m_brCurEngine.m_cb
                                                );
                    else

                        // other exception: re-throw
                        THROW(hrException);

                END_TRY


                                // done - don't process script text
                                return;
                }
            else
                                ProcessTaggedScriptSegment(brSegment, pfilemapCurrent, WorkStore, pHitObj);
            }

        brEngine = WorkStore.m_brCurEngine;
        }

    TRY
        // append script segment to store
        WorkStore.m_ScriptStore.AppendScript(brSegment, brEngine, (sseg == ssegPrimaryScript), idSequence, pfilemapCurrent);

    CATCH(hrException)
        // NOTE exception code from AppendScript() is overloaded: it can be an error message id or a true exception

        // if the brEngine does not point to memory within the current filemap, then
        // we must have come into here because of a tagged script statement with a SRC=
        // attrib.  In which case, we won't call ThrowError from here but will re-throw
        // the error to be caught above.

        if((hrException == IDE_TEMPLATE_BAD_PROGLANG)
           && (brEngine.m_pb >= pfilemapCurrent->m_pbStartOfFile)
           && (brEngine.m_pb <  (pfilemapCurrent->m_pbStartOfFile + pfilemapCurrent->GetSize()))) {
            // exception code is really an error message id: set err id to it
            ThrowErrorSingleInsert(
                                    brEngine.m_pb,
                                    IDE_TEMPLATE_BAD_PROGLANG,
                                    brEngine.m_pb,
                                    brEngine.m_cb
                                    );
        }
        else
            // other exception: re-throw
            THROW(hrException);

    END_TRY

LExit:
    // set flag to say we can no longer set primary language (must be in first script segment, if at all)
    WorkStore.m_fPageCommandsAllowed = FALSE;
    }


/*  ========================================================
    CTemplate::ProcessMetadataSegment
    Parses the metadata comment for typelib information.

    Returns
        HRESULT
*/
HRESULT
CTemplate::ProcessMetadataSegment
(
const CByteRange& brSegment,
UINT *pidError,
CHitObj *pHitObj
)
    {
    // TYPELIB
    if (FTagHasValue(brSegment,
                     CTokenList::tknTagType,
                     CTokenList::tknValueTypeLib))
        {
        return ProcessMetadataTypelibSegment(brSegment, pidError, pHitObj);
        }
        // METADATA INVALID in Global.asa
        else if (m_fGlobalAsa)
                {
                ThrowError(brSegment.m_pb, IDE_TEMPLATE_METADATA_IN_GLOBAL_ASA);
                return E_TEMPLATE_COMPILE_FAILED_DONT_CACHE;   // to keep compiler happy; in reality doesn't return.
                }
    // COOKIE
    else if (FTagHasValue(brSegment,
                     CTokenList::tknTagType,
                     CTokenList::tknValueCookie))
        {
        return ProcessMetadataCookieSegment(brSegment, pidError, pHitObj);
        }
    // Ignore everything else
    else
        {
        return S_OK;
        }
    }


/*  ========================================================
    CTemplate::ProcessMetadataTypelibSegment
    Parses the metadata comment for typelib information.

    Returns
        HRESULT
*/
HRESULT
CTemplate::ProcessMetadataTypelibSegment
(
const CByteRange& brSegment,
UINT *pidError,
CHitObj *pHitObj
)
    {
    // Ignore ENDSPAN segments
    if (GetTagName(brSegment, CTokenList::tknTagEndspan))
        {
        // ENDSPAN found - ignore
        return S_OK;
        }

    HRESULT hr;
    char  szFile[MAX_PATH+1];
    DWORD cbFile;

    // Try to get the filename
    CByteRange br = BrValueOfTag(brSegment, CTokenList::tknTagFile);
    if (!br.IsNull())
        {
        // filename present
        if (br.m_cb > MAX_PATH)
            {
            // file too long
            *pidError = IDE_TEMPLATE_BAD_TYPELIB_SPEC;
            return E_FAIL;
            }
        memcpy(szFile, br.m_pb, br.m_cb);
        cbFile = br.m_cb;
        szFile[cbFile] = '\0';
        }
    else
        {
        // No filename - use GUID, version, LCID to get file

        char szUUID[44]; // {} + hex chars + dashes
        char szVers[16]; // "1.0", etc
        char szLCID[16]; // locale id - a number

        br = BrValueOfTag(brSegment, CTokenList::tknTagUUID);
        if (br.IsNull() || br.m_cb > sizeof(szUUID)-3)
            {
            // no filename and no uuid -> invalid typelib spec
            *pidError = IDE_TEMPLATE_BAD_TYPELIB_SPEC;
            return E_FAIL;
            }

        if (br.m_pb[0] == '{')
            {
            // already in braces
            memcpy(szUUID, br.m_pb, br.m_cb);
            szUUID[br.m_cb] = '\0';
            }
        else
            {
            // enclose in {}
            szUUID[0] = '{';
            memcpy(szUUID+1, br.m_pb, br.m_cb);
            szUUID[br.m_cb+1] = '}';
            szUUID[br.m_cb+2] = '\0';
            }

        // Optional Version
        szVers[0] = '\0';
        br = BrValueOfTag(brSegment, CTokenList::tknTagVersion);
        if (!br.IsNull() && br.m_cb < sizeof(szVers)-1)
            {
            memcpy(szVers, br.m_pb, br.m_cb);
            szVers[br.m_cb] = '\0';
            }

        // Optional LCID
        LCID lcid;
        br = BrValueOfTag(brSegment, CTokenList::tknTagLCID);
        if (!br.IsNull() && br.m_cb < sizeof(szLCID)-1)
            {
            memcpy(szLCID, br.m_pb, br.m_cb);
            szLCID[br.m_cb] = '\0';
            lcid = strtoul(szLCID, NULL, 16);
            }
        else
            {
            // if the LCID is not defined -> use system's
            lcid = GetSystemDefaultLCID();
            }

        // Get TYPELIB filename from registry
        hr = GetTypelibFilenameFromRegistry
            (
            szUUID,
            szVers,
            lcid,
            szFile,
            MAX_PATH
            );

        if (FAILED(hr))
            {
            *pidError = IDE_TEMPLATE_BAD_TYPELIB_REG_SPEC;
            return hr;
            }

        cbFile = strlen(szFile);
        }
    
    // Convert filename to double-byte to call LoadTypeLib()

    STACK_BUFFER( tempFile, MAX_PATH * sizeof(WCHAR) );

    if (!tempFile.Resize((cbFile+1) * sizeof(WCHAR))) {
        *pidError = IDE_OOM;
        return E_FAIL;
    }

    LPWSTR wszFile = (LPWSTR)tempFile.QueryPtr();

    if (MultiByteToWideChar(pHitObj->GetCodePage(), MB_ERR_INVALID_CHARS,
                            szFile, cbFile, wszFile, cbFile) == 0)
        {
        *pidError = IDE_OOM;
        return E_FAIL;
        }
    wszFile[cbFile] = L'\0';

    // LoadTypeLib() to get ITypeLib*
    ITypeLib *ptlb = NULL;
    hr = LoadTypeLib(wszFile, &ptlb);

    if (FAILED(hr))
        {
        *pidError = IDE_TEMPLATE_LOAD_TYPELIB_FAILED;
        return hr;
        }

    // Remember ITypeLib* in the array
    Assert(ptlb);
    hr = m_rgpTypeLibs.append(ptlb);
    if (FAILED(hr))
        {
        *pidError = IDE_TEMPLATE_LOAD_TYPELIB_FAILED;
        return hr;
        }


    return S_OK;
    }


/*  ========================================================
    CTemplate::ProcessMetadataCookieSegment
    Parses the metadata comment for cookie information.

    Returns
        HRESULT
*/
HRESULT
CTemplate::ProcessMetadataCookieSegment
(
const CByteRange& brSegment,
UINT *pidError,
CHitObj *pHitObj
)
    {
    HRESULT hr;
    CByteRange br;
    char  *pszName;
    char  szFile[MAX_PATH+1];
    TCHAR sztFile[MAX_PATH+1];
    CMBCSToWChar    convStr;

    STACK_BUFFER( tempCookie, 64 );
    STACK_BUFFER( tempFile, 64 );    

    // Try to get the cookie name
    br = BrValueOfTag(brSegment, CTokenList::tknTagName);
    if (br.IsNull() || (br.m_cb == 0)) {
        *pidError = IDE_TEMPLATE_BAD_COOKIE_SPEC_NAME;
        return E_FAIL;
    }

    if (!tempCookie.Resize(br.m_cb + 1)) {
        *pidError = IDE_OOM;
        return E_FAIL;
    }

    pszName = (char *)tempCookie.QueryPtr();
    if (!pszName)
        {
        *pidError = IDE_OOM;
        return E_FAIL;
        }
    memcpy(pszName, br.m_pb, br.m_cb);
    pszName[br.m_cb] = '\0';


    // Try to get the path to the script
    br = BrValueOfTag(brSegment, CTokenList::tknTagSrc);
    if (br.IsNull() || (br.m_cb >= MAX_PATH) || (br.m_cb == 0))
        {
        *pidError = IDE_TEMPLATE_BAD_COOKIE_SPEC_SRC;
        return E_FAIL;
        }
    memcpy(szFile, br.m_pb, br.m_cb);
    szFile[br.m_cb] = '\0';

    // Convert file to physical path
    Assert(pHitObj->PServer());

    WCHAR   *pCookieFile;
#if _IIS_5_1
    // just use CP_ACP for 5.1 since the Core can't handle anything else anyway
    if (FAILED (convStr.Init (szFile))) {
#else 
    // 6.0 can handle UNICODE. Convert using script code page
    if (FAILED (convStr.Init (szFile,pHitObj->GetCodePage()))) {
#endif
        *pidError = IDE_OOM;
        return E_FAIL;
    }

    pCookieFile = convStr.GetString();
    if (FAILED(pHitObj->PServer()->MapPathInternal(0, pCookieFile, sztFile)))
        {
        *pidError = IDE_TEMPLATE_BAD_COOKIE_SPEC_SRC;
        return E_FAIL;
        }
    Normalize(sztFile);

    // Construct 449-echo-cookie object
    C449Cookie *p449 = NULL;
    hr = Create449Cookie(pszName, sztFile, &p449);
    if (FAILED(hr))
        {
        *pidError = IDE_TEMPLATE_LOAD_COOKIESCRIPT_FAILED;
        return hr;
    }

    // Remember 449 cookie in the array
    Assert(p449);
    hr = m_rgp449.append(p449);
    if (FAILED(hr)) {
        *pidError = IDE_TEMPLATE_LOAD_COOKIESCRIPT_FAILED;
        return hr;
    }

    return S_OK;
}


/*  ========================================================
    CTemplate::GetScriptEngineOfSegment
    Returns script engine name for a script segment.

    Returns
        Byte range containing script engine name
    Side effects
        Advances segment byte range past close tag token
*/
void
CTemplate::GetScriptEngineOfSegment
(
CByteRange&                     brSegment,                      // segment byte range
CByteRange&                     brEngine,                       // script engine name
CByteRange&                     brInclude                       // value of SRC tag
)
    {
    BYTE*       pbCloseTag;     // ptr to close of start tag
                                // tags contained in start tag
    CByteRange  brTags = BrTagsFromSegment(brSegment, CTokenList::tknCloseTaggedScript, &pbCloseTag);

    // if no close found, throw error
    if(pbCloseTag == NULL)
        ThrowError(brSegment.m_pb, IDE_TEMPLATE_NO_CLOSE_TSCRIPT);

    Assert(FTagHasValue(brTags, CTokenList::tknTagRunat, CTokenList::tknValueServer));

    // get engine name from tags
    brEngine = BrValueOfTag(brTags, CTokenList::tknTagLanguage);
    if(brEngine.IsNull())
        ThrowError(brSegment.m_pb, IDE_TEMPLATE_NO_ENGINE_NAME);

    // Get SRC attribute from tags
    brInclude = BrValueOfTag(brTags, CTokenList::tknTagSrc);

    // advance segment past close tag token
    gm_pTokenList->MovePastToken(CTokenList::tknCloseTag, pbCloseTag, brSegment);
    }

/*  ========================================================
    CTemplate::ProcessTaggedScriptSegment
    Processes a tagged script segment: within tagged script we
    honor plain text (passed through as script text) and HTML comments.
    See bug 423 for istudio scenarios that require this behavior.

    Returns
        Nothing
    Side effects
        None
*/
void
CTemplate::ProcessTaggedScriptSegment
(
CByteRange&     brSegment,      // segment byte range
CFileMap*       pfilemapCurrent,// ptr to filemap of parent file
CWorkStore&     WorkStore,      // working storage for source segments
CHitObj*        pHitObj         // Browser request object
)
    {
    _TOKEN*     rgtknOpeners;   // array of permitted open tokens
    _TOKEN      tknOpeners[1];
    UINT        ctknOpeners;    // count of permitted open tokens

    // populate array of permitted open tokens
    ctknOpeners = 1;
    rgtknOpeners = tknOpeners;
    rgtknOpeners[0] = CTokenList::tknOpenHTMLComment;

    // Process source segments embedded within tagged script segment
    while(!brSegment.IsNull())
        ExtractAndProcessSegment(
                                    brSegment,          // byte range to search for next segment-opening token
                                    ssegTaggedScript,   // type of 'leading', i.e. pre-token, source segment
                                    rgtknOpeners,       // array of permitted open tokens
                                    ctknOpeners,        // count of permitted open tokens
                                    pfilemapCurrent,    // ptr to filemap of parent file
                                    WorkStore,          // working storage for source segments
                                    pHitObj,            // Browser request object
                                    TRUE,               // script tag has been processed
                                    FALSE               // NOT in HTML segment
                                );
    }

/*  ============================================================================
    CTemplate::ProcessObjectSegment
    Processes an object segment.

    Returns
        Nothing
    Side effects
        throws on error
*/
void
CTemplate::ProcessObjectSegment
(
CByteRange&     brSegment,      // segment byte range
CFileMap*       pfilemapCurrent,// ptr to filemap of parent file
CWorkStore&     WorkStore,      // working storage for source segments
UINT            idSequence      // segment sequence id
)
    {
    BYTE*       pbCloseTag;     // ptr to close of start tag
                                // tags contained in start tag
    CByteRange  brTags = BrTagsFromSegment(brSegment, CTokenList::tknCloseObject, &pbCloseTag);

    // if no close found, bail on error
    if(pbCloseTag == NULL)
        ThrowError(brSegment.m_pb, IDE_TEMPLATE_NO_CLOSE_OBJECT);

    // if this is a server object (RUNAT=Server), process its tags
    if(FTagHasValue(brTags, CTokenList::tknTagRunat, CTokenList::tknValueServer))
        {
        CLSID   ClsId;  // clsid

        // get name value
        CByteRange brName = BrValueOfTag(brTags, CTokenList::tknTagID);

        // if name is null, error out
        if(brName.IsNull())
            ThrowError(brSegment.m_pb, IDE_TEMPLATE_NO_OBJECT_NAME);

        if(!FValidObjectName(brName))
            ThrowErrorSingleInsert(brName.m_pb, IDE_TEMPLATE_INVALID_OBJECT_NAME, brName.m_pb, brName.m_cb);

        // get values for ClassID and ProgID tags
        CByteRange brClassIDText = BrValueOfTag(brTags, CTokenList::tknTagClassID);
        CByteRange brProgIDText = BrValueOfTag(brTags, CTokenList::tknTagProgID);

        if(!brClassIDText.IsNull())
            // if we find a text class id, set clsid with it
            // NOTE progid tag is ignored if classid tag exists
            GetCLSIDFromBrClassIDText(brClassIDText, &ClsId);
        else if(!brProgIDText.IsNull())
            // else if we find a prog id, resolve it into a class id
            GetCLSIDFromBrProgIDText(brProgIDText, &ClsId);
        else
            // else, throw error; can't create an object without at least one of classid or progid
            ThrowErrorSingleInsert(brTags.m_pb, IDE_TEMPLATE_NO_CLASSID_PROGID, brName.m_pb, brName.m_cb);

        // set scope; bail if bogus
        CompScope csScope = csUnknown;
        CByteRange brScope = BrValueOfTag(brTags, CTokenList::tknTagScope);
        if(brScope.FMatchesSz(SZ_TOKEN(CTokenList::tknValuePage)) || brScope.IsNull())
            // non-existent scope tag defaults to page scope
            csScope = csPage;
        else if(brScope.FMatchesSz(SZ_TOKEN(CTokenList::tknValueApplication)))
            csScope = csAppln;
        else if(brScope.FMatchesSz(SZ_TOKEN(CTokenList::tknValueSession)))
            csScope = csSession;
        else
            ThrowError(brTags.m_pb, IDE_TEMPLATE_BAD_OBJECT_SCOPE);

        if(!m_fGlobalAsa && csScope != csPage)
            // error out on non-page-level object if we are processing anything but global.asa
            ThrowErrorSingleInsert(brTags.m_pb, IDE_TEMPLATE_BAD_PAGE_OBJECT_SCOPE, brName.m_pb, brName.m_cb);
        else if(m_fGlobalAsa && csScope == csPage)
            // error out on page-level object if we are processing global.asa
            ThrowErrorSingleInsert(brTags.m_pb, IDE_TEMPLATE_BAD_GLOBAL_OBJECT_SCOPE, brName.m_pb, brName.m_cb);

        // set threading model
        CompModel cmModel = cmSingle;
        CompModelFromCLSID(ClsId, &cmModel);

        // append object-info to store
        WorkStore.m_ObjectInfoStore.AppendObject(brName, ClsId, csScope, cmModel, idSequence);

        }

    }

/*  ============================================================================
    CTemplate::GetCLSIDFromBrClassIDText
    Sets a clsid from a byte range containing an ANSI text version of a class id

    Returns
        ptr to clsid (out-parameter)
    Side effects
        throws on error
*/
void
CTemplate::GetCLSIDFromBrClassIDText
(
CByteRange& brClassIDText,
LPCLSID pclsid
)
    {
    // if class id text starts with its standard object tag prefix, advance past it
    if(!_strnicmp((char*)brClassIDText.m_pb, "clsid:", 6))
        brClassIDText.Advance(6);

    // if class id text is bracketed with {}, adjust byte range to strip them
    // NOTE we always add {} below, because normal case is that they are missing from input text
    if(*brClassIDText.m_pb == '{')
        brClassIDText.Advance(1);
    if(*(brClassIDText.m_pb + brClassIDText.m_cb - 1) == '}')
        brClassIDText.m_cb--;

    // Allocate a wide char string for the string version of class id
    // NOTE we add 3 characters to hold {} and null terminator
    OLECHAR* pszWideClassID = new WCHAR[brClassIDText.m_cb + 3];
    if (NULL == pszWideClassID)
        THROW(E_OUTOFMEMORY);

    // start wide string class id with left brace
    pszWideClassID[0] = '{';

    // Convert the string class id to wide chars
    if (0 == MultiByteToWideChar(   CP_ACP,                     // ANSI code page
                                    MB_ERR_INVALID_CHARS,       // err on invalid chars
                                    (LPCSTR)brClassIDText.m_pb, // input ANSI string version of class id
                                    brClassIDText.m_cb,         // length of input string
                                    pszWideClassID + 1,         // location for output wide string class id
                                    brClassIDText.m_cb          // size of output buffer
                                ))
        {
        delete [] pszWideClassID;
        THROW(E_FAIL);
        }

    // append right brace to wide string
    pszWideClassID[brClassIDText.m_cb + 1] = '}';

    // Null terminate the wide string
    pszWideClassID[brClassIDText.m_cb + 2] = NULL;

    // Now get the clsid from wide string class id
    if(FAILED(CLSIDFromString(pszWideClassID, pclsid)))
        {
        delete [] pszWideClassID;
        ThrowErrorSingleInsert(brClassIDText.m_pb, IDE_TEMPLATE_BAD_CLASSID, brClassIDText.m_pb, brClassIDText.m_cb);
        }

    if(NULL != pszWideClassID)
        delete [] pszWideClassID;
    }

/*  ===================================================================
    CTemplate::GetCLSIDFromBrProgIDText
    Gets a clsid from the registry given a ProgID

    Returns
        ptr to clsid (out-parameter)
    Side effects
        throws on error
*/
void
CTemplate::GetCLSIDFromBrProgIDText
(
CByteRange& brProgIDText,
LPCLSID pclsid
)
    {
    // allocate a wide char string for ProgID plus null terminator
    OLECHAR* pszWideProgID = new WCHAR[brProgIDText.m_cb + 1];
    if (NULL == pszWideProgID)
        THROW(E_OUTOFMEMORY);

    // Convert the string class id to wide chars
    if (0 == MultiByteToWideChar(   CP_ACP,                     // ANSI code page
                                    MB_ERR_INVALID_CHARS,       // err on invalid chars
                                    (LPCSTR)brProgIDText.m_pb,  // input ANSI string version of prog id
                                    brProgIDText.m_cb,          // length of input string
                                    pszWideProgID,              // location for output wide string prog id
                                    brProgIDText.m_cb           // size of output buffer
                                ))
        {
        delete [] pszWideProgID; pszWideProgID = NULL;
        THROW(E_FAIL);
        }

    // Null terminate the wide string
    pszWideProgID[brProgIDText.m_cb] = NULL;

    // Now get clsid from ProgID
    if(FAILED(CLSIDFromProgID(pszWideProgID, pclsid)))
        {
        delete [] pszWideProgID; pszWideProgID = NULL;
        ThrowErrorSingleInsert(brProgIDText.m_pb, IDE_TEMPLATE_BAD_PROGID, brProgIDText.m_pb, brProgIDText.m_cb);
        }

    // Cache ProgId to CLSID mapping
    g_TypelibCache.RememberProgidToCLSIDMapping(pszWideProgID, *pclsid);

    if (NULL != pszWideProgID)
        delete [] pszWideProgID;
}

/*  ============================================================================
    CTemplate::FValidObjectName
    Determines whether an object name clashes with a Denali intrinsic object name.

    Returns
        TRUE or FALSE
    Side effects
        None
*/
BOOLB
CTemplate::FValidObjectName
(
CByteRange& brName  // object name
)
    {
    if(brName.FMatchesSz(SZ_OBJ_APPLICATION))
        return FALSE;
    if(brName.FMatchesSz(SZ_OBJ_REQUEST))
        return FALSE;
    if(brName.FMatchesSz(SZ_OBJ_RESPONSE))
        return FALSE;
    if(brName.FMatchesSz(SZ_OBJ_SERVER))
        return FALSE;
    if(brName.FMatchesSz(SZ_OBJ_CERTIFICATE))
        return FALSE;
    if(brName.FMatchesSz(SZ_OBJ_SESSION))
        return FALSE;
    if(brName.FMatchesSz(SZ_OBJ_SCRIPTINGNAMESPACE))
        return FALSE;

    return TRUE;
    }

/*  ============================================================================
    CTemplate::ProcessIncludeFile

    Processes an include file.

    Returns
        Nothing
*/
void
CTemplate::ProcessIncludeFile
(
CByteRange& brSegment,          // segment byte range
CFileMap*   pfilemapCurrent,    // ptr to filemap of parent file
CWorkStore& WorkStore,          // current working storage
UINT        idSequence,         // sequence #
CHitObj*    pHitObj,            // Browser request object pointer
BOOL        fIsHTML
)
    {
    CByteRange  brFileSpec;             // filespec of include file
    BOOLB       fVirtual = FALSE;       // is include filespec virtual?
                                        // filespec of include file (sz)
    CHAR        szFileSpec[MAX_PATH + 1];
    LPSTR       szTemp = szFileSpec;    // temp ptr to filespec

    // get value of FILE tag
    brFileSpec = BrValueOfTag(brSegment, CTokenList::tknTagFile);

    if(brFileSpec.IsNull())
        {
        // if we found no FILE tag, get value of VIRTUAL tag
        brFileSpec = BrValueOfTag(brSegment, CTokenList::tknTagVirtual);
        fVirtual = TRUE;
        }

    if(brFileSpec.IsNull())
        // if we found neither, error out
        ThrowError(brSegment.m_pb, IDE_TEMPLATE_NO_INCLUDE_NAME);

    if (brFileSpec.m_cb>MAX_PATH)
    {
    	// return the last MAX_PATH chars of the file name.  This is done
        // this way to avoid a Error Too Long message when the include
        // file spec is exceedingly long.

    	char fileNameLast[MAX_PATH+4];
    	strcpy(fileNameLast, "...");
    	strcpy(fileNameLast+3, (LPSTR)(brFileSpec.m_pb+brFileSpec.m_cb-MAX_PATH));
    	
        ThrowErrorSingleInsert(brFileSpec.m_pb,
                               IDE_TEMPLATE_BAD_INCLUDE,
                               brFileSpec.m_pb,
                               brFileSpec.m_cb);

    }

    // NOTE we manipulate temp sz to preserve szFileSpec
    if(fVirtual)
        {
        if(*brFileSpec.m_pb == '\\')
            {
            // if VIRTUAL path starts with backslash, replace it with fwd slash
            *szTemp++ = '/';
            brFileSpec.Advance(1);
            }
        else if(*brFileSpec.m_pb != '/')
            // if VIRTUAL path starts with anything other than fwd slash or backslash, prepend fwd slash
            *szTemp++ = '/';
        }

    // append supplied path to temp sz
    strncpy(szTemp, (LPCSTR) brFileSpec.m_pb, brFileSpec.m_cb);
    szTemp[brFileSpec.m_cb] = NULL;

    if(!fVirtual)
        {
        // if FILE filespec starts with \ or /, hurl
        if(*szFileSpec == '\\' || *szFileSpec == '/')
            ThrowErrorSingleInsert(
                                    brFileSpec.m_pb,
                                    IDE_TEMPLATE_BAD_FILE_TAG,
                                    brFileSpec.m_pb,
                                    brFileSpec.m_cb
                                  );
        }

    // NOTE: szFileSpec is the doctored path (it possibly has "/" prepended.
    //       brFileSpec is used as the error location.
    //
    ProcessIncludeFile2(szFileSpec, brFileSpec, pfilemapCurrent, WorkStore, idSequence, pHitObj, fIsHTML);
    }

/*  ============================================================================
    CTemplate::ProcessIncludeFile2

    adds a #include file to the CTemplate and starts the template to processing
    the file.

    Returns
        Nothing
    Side effects
        Calls GetSegmentsFromFile recursively

    NOTE - kind of an oddball thing here.  The szFileSpec in this case is
    intentionally ANSI as it came from the ASP script content.  It may need
    to be converted to UNICODE.
*/
void
CTemplate::ProcessIncludeFile2
(
CHAR *      szAnsiFileSpec,			// file to include
CByteRange&	brErrorLocation,	// ByteRange in source where errors should be reported
CFileMap*   pfilemapCurrent,    // ptr to filemap of parent file
CWorkStore& WorkStore,          // current working storage
UINT        idSequence,         // sequence #
CHitObj*    pHitObj,            // Browser request object pointer
BOOL        fIsHTML
)
{
    HRESULT     hr;
    TCHAR      *szFileSpec;

#if UNICODE
    CMBCSToWChar    convFileSpec;

    if (FAILED(hr = convFileSpec.Init(szAnsiFileSpec, pHitObj->GetCodePage()))) {
        THROW(hr);
    }
    szFileSpec = convFileSpec.GetString();
#else
    szFileSpec = szAnsiFileSpec;
#endif
    // if parent paths are disallowed and filespec contains parent dir reference, hurl
    if (!pHitObj->QueryAppConfig()->fEnableParentPaths() && _tcsstr(szFileSpec, _T("..")))
            ThrowErrorSingleInsert(
                                    brErrorLocation.m_pb,
                                    IDE_TEMPLATE_DISALLOWED_PARENT_PATH,
                                    brErrorLocation.m_pb,
                                    brErrorLocation.m_cb
                                  );

    TRY
        AppendMapFile(
                        szFileSpec,
                        pfilemapCurrent,
                        (szFileSpec[0] == _T('/')) || (szFileSpec[0] == _T('\\')),  // fVirtual
                        pHitObj,        // main file's hit object
                        FALSE           // not the global.asa file
                    );
    CATCH(hrException)

        // MapFile() threw an exception: delete last filemap's memory and decrement filemap counter
        // NOTE this is a bit hokey, but we need to do it here rather than AppendMapFile (where we allocated)
        // because its other caller(s) may not want this behavior
        delete m_rgpFilemaps[m_cFilemaps-- - 1];

        /*  NOTE exception code from MapFile() is overloaded: it can sometimes
            be an error message id, sometimes a true exception
            NOTE security error causes exception E_USER_LACKS_PERMISSIONS, rather than error id,
            but we pass it thru as if it were an error id because the various error-catch routines
            know how to handle E_USER_LACKS_PERMISSIONS specially.
        */
        UINT    idErrMsg;
        if(hrException == IDE_TEMPLATE_CYCLIC_INCLUDE || hrException == E_USER_LACKS_PERMISSIONS)
            // exception code is really an error message id: set err id to it
            idErrMsg = hrException;
        else if(hrException == E_COULDNT_OPEN_SOURCE_FILE)
            // exception is generic couldn't-open-file : set err id to generic bad-file error
            idErrMsg = IDE_TEMPLATE_BAD_INCLUDE;
        else
            // other exception: re-throw
            THROW(hrException);

        ThrowErrorSingleInsert(
                                brErrorLocation.m_pb,
                                idErrMsg,
                                brErrorLocation.m_pb,
                                brErrorLocation.m_cb
                              );
    END_TRY

    // store ptr to current file map in local before recursive call (which may increment m_cFilemaps)
    CFileMap*   pfilemap = m_rgpFilemaps[m_cFilemaps - 1];

    // get inc-file object from cache
    CIncFile*   pIncFile;

    if(FAILED(hr = g_IncFileMap.GetIncFile(pfilemap->m_szPathTranslated, &pIncFile)))
        THROW(hr);

    // add this template to inc-file's template list
    if (FAILED(hr = pIncFile->AddTemplate(this)))
        THROW(hr);

    // set filemap's inc-file ptr
    pfilemap->m_pIncFile = pIncFile;

    // get source segments from include file
    // bugs 1363, 1364: process include file only after we establish dependencies;
    // required for cache flushing to work correctly after compile errors
    GetSegmentsFromFile(*pfilemap, WorkStore, pHitObj, fIsHTML);
}

/*  ===================================================================
    CTemplate::GetOpenToken
    Returns the token index of and a ptr to the first valid open token
    in search range.  For the open token to be valid, we must bypass
    segments we should not process, e.g. scripts or objects not tagged as 'server'

    Returns
        ptr to open token; ptr to open token enum value (out-parameter)
    Side effects
        None
*/
BYTE*
CTemplate::GetOpenToken
(
CByteRange  brSearch,       // (ByVal) byte range to search for next segment-opening token
SOURCE_SEGMENT ssegLeading, // type of 'leading', i.e. pre-token, source segment
                            //  (only used when deciding to ignore non-SSI comments)
_TOKEN*     rgtknOpeners,   // array of permitted open tokens
UINT        ctknOpeners,    // count of permitted open tokens
_TOKEN*     ptknOpen        // ptr to open token enum value (out-parameter)
)
    {
    BYTE*   pbTokenOpen = NULL;     // ptr to opening token

    // keep getting segment-opening tokens until we find one that we need to process
    while(TRUE)
        {
        // Get next open token in search range
        *ptknOpen = gm_pTokenList->NextOpenToken(
                                                    brSearch,
                                                    rgtknOpeners,
                                                    ctknOpeners,
                                                    &pbTokenOpen,
                                                    m_wCodePage
                                                );

        /*  Certain tokens must be followed immediately by white space; others need not.
            NOTE it is pure coincidence that the 'white-space tokens' are also those that
            get special processing below; hence we handle white space issue there.
            If we ever add another 'white-space token' that doesn't require the special processing,
            we will need to handle the white space issue here.
        */

        /*  Similar thing applies to non-include and non-metadata HTML
            comments. We really don't care for them to generate their
            own segments -- we can reduce number of Response.WriteBlock()
            calls by considering them part of the preceding HTML segment.
        */

        if (*ptknOpen == CTokenList::tknOpenHTMLComment)
            {
            if (ssegLeading != ssegHTML)  // if not inside HTML
                break;                    // generate a new segment

            // for HTML comments check if it is an include or metadata
            // and if not, this is not a separate segment - keep on looking
            // for the next opener

            // advance search range to just past open token
            gm_pTokenList->MovePastToken(*ptknOpen, pbTokenOpen, brSearch);

            // find end of comment
            BYTE *pbClose = gm_pTokenList->GetToken(CTokenList::tknCloseHTMLComment,
                                                    brSearch, m_wCodePage);
            if (pbClose == NULL)
                {
                // Error -- let other code handle this
                break;
                }

            // construct comment byte range to limit search to it
            CByteRange brComment = brSearch;
            brComment.m_cb = DIFF(pbClose - brSearch.m_pb);

            // look for metadata and include (only inside the comment)

            if (gm_pTokenList->GetToken(CTokenList::tknCommandINCLUDE,
                                        brComment, m_wCodePage))
                {
                // SSI inclide -- keep it
                break;
                }
            else if (gm_pTokenList->GetToken(CTokenList::tknTagMETADATA,
                                             brComment, m_wCodePage))
                {
                // METADATA -- keep it
                break;
                }
            else if (gm_pTokenList->GetToken(CTokenList::tknTagFPBot,
                                             brComment, m_wCodePage))
                {
                // METADATA -- keep it
                break;
                }
            else
                {
                // Regular comment - ignore it
                goto LKeepLooking;
                }
            }
        else if (*ptknOpen == CTokenList::tknOpenTaggedScript || *ptknOpen == CTokenList::tknOpenObject)
            {
            /*  if token was script or object tag, check to see if:
                a) it is followed immediately by white space; if not keep looking
                b) it opens a well-formed segment, i.e. one with a proper close tag; if not, throw error
                c) it is designated runat-server; if not keep looking
            */

            // advance search range to just past open token
            gm_pTokenList->MovePastToken(*ptknOpen, pbTokenOpen, brSearch);

            // bug 760: if token is not followed immediately by white space, keep looking
            if(!brSearch.IsNull())
                if(!FWhiteSpace(*brSearch.m_pb))
                    goto LKeepLooking;

            // ptr to close of start tag
            BYTE*       pbCloseTag;
            // tags contained in start tag
            CByteRange  brTags = BrTagsFromSegment(
                                                    brSearch,
                                                    GetComplementToken(*ptknOpen),
                                                    &pbCloseTag
                                                );

            if(pbCloseTag == NULL)
                {
                // if no close tag, throw error
                if(*ptknOpen == CTokenList::tknOpenObject)
                    ThrowError(pbTokenOpen, IDE_TEMPLATE_NO_CLOSE_OBJECT);
                else if(*ptknOpen == CTokenList::tknOpenTaggedScript)
                    ThrowError(pbTokenOpen, IDE_TEMPLATE_NO_CLOSE_TSCRIPT);
                }

            // if this is a server object (RUNAT=Server), we will process it; else keep looking
            if(FTagHasValue(brTags, CTokenList::tknTagRunat, CTokenList::tknValueServer))
                break;

            }
        else
            {
            // if token was other than script or object tag, or comment
            // we should process segment;
            // hence we have found our open token, so break
            break;
            }

LKeepLooking: ;
        }

    return pbTokenOpen;
    }

/*  ===================================================================
    CTemplate::GetCloseToken
    Returns a ptr to the next token of type tknClose.

    Returns
        ptr to close token
    Side effects
        Detects and errors out on attempt to nest tagged script or object blocks.
*/
BYTE*
CTemplate::GetCloseToken
(
CByteRange  brSearch,       // (ByVal) byte range to search
_TOKEN      tknClose        // close token
)
    {
    BYTE*   pbTokenClose = gm_pTokenList->GetToken(tknClose, brSearch, m_wCodePage);

    if(pbTokenClose != NULL)
        if(tknClose == CTokenList::tknCloseTaggedScript || tknClose == CTokenList::tknCloseObject)
            {
            CByteRange  brSegment;
            BYTE*       pbTokenOpen;

            brSegment.m_pb = brSearch.m_pb;
            brSegment.m_cb = DIFF(pbTokenClose - brSearch.m_pb);

            if(NULL != (pbTokenOpen = gm_pTokenList->GetToken(GetComplementToken(tknClose), brSegment, m_wCodePage)))
                {
                if(tknClose == CTokenList::tknCloseTaggedScript)
                    ThrowError(pbTokenOpen, IDE_TEMPLATE_NESTED_TSCRIPT);
                else if(tknClose == CTokenList::tknCloseObject)
                    ThrowError(pbTokenOpen, IDE_TEMPLATE_NESTED_OBJECT);
                }
            }

    return pbTokenClose;
    }

/*===================================================================
    CTemplate::GetComplementToken

    Returns a token's compement token.

    Returns
        Complement token
    Side effects
        None
*/
_TOKEN
CTemplate::GetComplementToken
(
_TOKEN  tkn
)
    {
    switch(tkn)
        {
    // open tokens
    case CTokenList::tknOpenPrimaryScript:
        return CTokenList::tknClosePrimaryScript;
    case CTokenList::tknOpenTaggedScript:
        return CTokenList::tknCloseTaggedScript;
    case CTokenList::tknOpenObject:
        return CTokenList::tknCloseObject;
    case CTokenList::tknOpenHTMLComment:
        return CTokenList::tknCloseHTMLComment;

    // close tokens
    case CTokenList::tknClosePrimaryScript:
        return CTokenList::tknOpenPrimaryScript;
    case CTokenList::tknCloseTaggedScript:
        return CTokenList::tknOpenTaggedScript;
    case CTokenList::tknCloseObject:
        return CTokenList::tknOpenObject;
    case CTokenList::tknCloseHTMLComment:
        return CTokenList::tknOpenHTMLComment;
        }

    Assert(FALSE);
    return CTokenList::tknEOF;
    }

/*===================================================================
    CTemplate::GetSegmentOfOpenToken

    Returns the segment type of an open token.

    Returns
        source segment type of open token
    Side effects
        None
*/
CTemplate::SOURCE_SEGMENT
CTemplate::GetSegmentOfOpenToken
(
_TOKEN tknOpen
)
    {
    switch(tknOpen)
        {
    case CTokenList::tknOpenPrimaryScript:
        return ssegPrimaryScript;
    case CTokenList::tknOpenTaggedScript:
        return ssegTaggedScript;
    case CTokenList::tknOpenObject:
        return ssegObject;
    case CTokenList::tknOpenHTMLComment:
        return ssegHTMLComment;
        }

    return ssegHTML;
    }

/*  ========================================================
    CTemplate::BrTagsFromSegment

    Returns the tag range from an HTML start tag

    Returns
        tag byte range
    Side effects
        none
*/
CByteRange
CTemplate::BrTagsFromSegment
(
CByteRange  brSegment,  // segment byte range
_TOKEN      tknClose,   // close token
BYTE**      ppbCloseTag // ptr-to-ptr to close tag - returned to caller
)
    {
    CByteRange  brTags; // tags return value - NOTE constructed null
                        // ptr to close token - NOTE null if none within segment byte range
    BYTE*       pbTokenClose = GetCloseToken(brSegment, tknClose);

    // if no close tag found, return null tags
    if(NULL == (*ppbCloseTag = gm_pTokenList->GetToken(CTokenList::tknCloseTag, brSegment, m_wCodePage)))
        goto Exit;

    // if next non-null close token occurs before close tag, close tag is invalid; return nulls
    if((pbTokenClose != NULL) && (*ppbCloseTag > pbTokenClose ))
        {
        *ppbCloseTag = NULL;
        goto Exit;
        }

    // crack tags from header tag
    brTags.m_pb = brSegment.m_pb;
    brTags.m_cb = DIFF(*ppbCloseTag - brSegment.m_pb);

Exit:
    return brTags;
    }

/*  ========================================================
    CTemplate::BrValueOfTag

    Returns a tag's value from a byte range; null if tag is not found
    NOTE value search algorithm per W3 HTML spec - see www.w3.org

    Returns
        byte range of tag's value
        pfTagExists - does the tag exist in tags byte range?    (out-parameter)
            NOTE we default *pfTagExists = TRUE; most callers don't care and omit this parameter
    Side effects
        none
*/
CByteRange
CTemplate::BrValueOfTag
(
CByteRange  brTags,     // tags byte range
_TOKEN      tknTagName  // tag name token
)
    {
    CByteRange  brTemp = brTags;        // temp byte range
    CByteRange  brValue;                // byte range of value for the given tag - NOTE constructed null
    char        chDelimiter = NULL;     // value delimiter
                                        // ptr to tag name
    BYTE*       pbTagName = GetTagName(brTags, tknTagName);

    // If we did not find tag, return
    if(pbTagName == NULL)
        return brValue;

    // Move past tag name token and pre-separator white space
    brTemp.Advance(DIFF(pbTagName - brTags.m_pb) + CCH_TOKEN(tknTagName));
    LTrimWhiteSpace(brTemp);
    if(brTemp.IsNull())
        goto Exit;

    // If we did not find separator, return
    if(*brTemp.m_pb != CH_ATTRIBUTE_SEPARATOR)
        goto Exit;

    // Move past separator and post-separator white space
    brTemp.Advance(sizeof(CH_ATTRIBUTE_SEPARATOR));
    LTrimWhiteSpace(brTemp);
    if(brTemp.IsNull())
        goto Exit;

    // If value begins with a quote mark, cache it as delimiter
    if((*brTemp.m_pb == CH_SINGLE_QUOTE) || (*brTemp.m_pb == CH_DOUBLE_QUOTE))
        chDelimiter = *brTemp.m_pb;

    if(chDelimiter)
        {
        // move past delimiter
        brTemp.Advance(sizeof(chDelimiter));
        if(brTemp.IsNull())
            goto Exit;
        }

    // provisionally set value to temp byte range
    brValue = brTemp;

    // advance temp byte range to end of value range
    while(
            (chDelimiter && (*brTemp.m_pb != chDelimiter))  // if we have a delimiter, find next delimiter
         || (!chDelimiter && (!FWhiteSpace(*brTemp.m_pb)))  // if we have no delimiter, find next white space
         )
        {
        // advance temp byte range
        brTemp.Advance(1);
        if(brTemp.IsNull())
            {
            if(chDelimiter)
                // we found no closing delimiter, so error out
                ThrowErrorSingleInsert(brValue.m_pb, IDE_TEMPLATE_NO_ATTRIBUTE_DELIMITER,
                                            pbTagName, CCH_TOKEN(tknTagName));
            else
                // value runs to end of temp byte range, so exit (since we already init'ed to temp)
                goto Exit;
            }
        }

    // set byte count so that value points to delimited range
    brValue.m_cb = DIFF(brTemp.m_pb - brValue.m_pb);

Exit:
    // if tag is empty, raise an error
    if (brValue.IsNull())
        {
        ThrowErrorSingleInsert(brTags.m_pb, IDE_TEMPLATE_VALUE_REQUIRED, pbTagName, CCH_TOKEN(tknTagName));
        }

    // enforce mandatory tag values if required
    if(tknTagName == CTokenList::tknTagRunat)
        {
        if(!brValue.FMatchesSz(SZ_TOKEN(CTokenList::tknValueServer)))
            ThrowError(brTags.m_pb, IDE_TEMPLATE_RUNAT_NOT_SERVER);
        }

    return brValue;
    }

/*  ============================================================================
    CTemplate::CompTagName

    Compares characters in two buffers (case-insensitive) and returns TRUE or FALSE

    Side effects
        none
*/
BOOL
CTemplate::CompTagName
(
CByteRange  &brTags,        // tags byte range
_TOKEN      tknTagName  // tag name token
)
    {
    CByteRange  brTemp = brTags;                            // local byte range, so we don't change tags byte range
    UINT        cbAttributeName = CCH_TOKEN(tknTagName);    // length of tag name
    LPSTR       pszAttributeName = SZ_TOKEN(tknTagName);    // tag name string

    // search for potential matches on tag name string, case-insensitive
    if(!brTemp.IsNull())
        if( 0 == _memicmp( brTemp.m_pb, pszAttributeName, cbAttributeName ))
            return TRUE;
    return FALSE;
    }


/*  ============================================================================
    CTemplate::GetTagName

    Returns a ptr to a tag name in a byte range; null if not found

    Returns
        ptr to tag name
    Side effects
        none
*/
BYTE*
CTemplate::GetTagName
(
CByteRange  brTags,     // tags byte range
_TOKEN      tknTagName  // tag name token
)
    {
    CByteRange  brTemp = brTags;                            // local byte range, so we don't change tags byte range
    UINT        cbAttributeName = CCH_TOKEN(tknTagName);    // length of tag name
    LPSTR       pszAttributeName = SZ_TOKEN(tknTagName);    // tag name string

        // PREFIX: pszAttributeName could be NULL, though I don't think that can happen.
        Assert (pszAttributeName != NULL);

    while(TRUE)
        {
        // search for potential matches on tag name string, case-insensitive
        while(!brTemp.IsNull())
            {
            if(0 == _strnicmp((char*)brTemp.m_pb, pszAttributeName, cbAttributeName ))
                break;
            brTemp.Advance(1);
            }

        // if we did not find tag name string at all, return 'not found'
        if(brTemp.IsNull())
            goto NotFound;

        // if it is a valid HTML tag name, return it
        if(FTagName(brTemp.m_pb, cbAttributeName))
            goto Exit;

        // if we found a matching but invalid substring, advance beyond it so we can search again
        brTemp.Advance(cbAttributeName);

        // if we have exhausted search range, return 'not found'
        if(brTemp.IsNull())
            goto NotFound;
        }

Exit:
    return brTemp.m_pb;

NotFound:
    return NULL;
    }

/*  ============================================================================
    CTemplate::GetTag

    Returns a ptr to a tag name in a byte range; null if not found

    Returns
        ptr to tag name
    Side effects
        none
*/
BOOL
CTemplate::GetTag
(
CByteRange  &brTags,        // tags byte range
int         nIndex
)
    {
    CByteRange  brTemp      = brTags;                           // local byte range, so we don't change tags byte range
    int         nTIndex     = 0;

    while(TRUE)
        {
        // locate the start of a tag by skipping past the script tag "<%" and any leading white space
        //
        while(!brTemp.IsNull())
            {
            if( *brTemp.m_pb == '<' ||
                *brTemp.m_pb == '%' ||
                *brTemp.m_pb == '@' ||
                FWhiteSpace(*brTemp.m_pb))
                {
                brTemp.Advance(1);
                brTags.Advance(1);
                }
            else
                break;
            }



        // search for potential matches on tag name string, case-insensitive
        //
        while(!brTemp.IsNull())
            {
            if( *brTemp.m_pb == '=' || FWhiteSpace(*brTemp.m_pb))
                {
                nTIndex++;
                break;
                }
            brTemp.Advance(1);
            }

        // if we did not find tag name string at all, return 'not found'
        if(brTemp.IsNull())
            goto NotFound;

        // if it is a valid HTML tag name, return it
        if(FTagName(brTags.m_pb, DIFF(brTemp.m_pb - brTags.m_pb)))
            if(nTIndex >= nIndex)
                goto Exit;

        // position past named pair data and reset start and if end of byte range then
        // goto NotFound
        //
        while(!brTemp.IsNull() && !FWhiteSpace(*brTemp.m_pb))
            brTemp.Advance(1);

        if(brTemp.IsNull())
            goto NotFound;
        else
            brTags.Advance(DIFF(brTemp.m_pb - brTags.m_pb));
        }
Exit:
    return TRUE;

NotFound:
    return FALSE;
    }


/*  ============================================================================
    CTemplate::FTagHasValue

    Do tags include tknTag=tknValue?

    Returns
        TRUE if tags include value, else FALSE
    Side effects
        none
*/
BOOLB
CTemplate::FTagHasValue
(
const CByteRange&   brTags,     // tags byte range to search
_TOKEN              tknTag,     // tag token
_TOKEN              tknValue    // value token
)
    {
    return (BrValueOfTag(brTags, tknTag)    // byte range of value
            .FMatchesSz(SZ_TOKEN(tknValue)));
    }

/*  =========================
    CTemplate::CopySzAdv

    Copies a string to a ptr and advances the ptr just beyond the copied string.

    Returns
        Nothing
    Side effects
        advances ptr beyond copied string
*/
void
CTemplate::CopySzAdv
(
char*   pchWrite,   // write location ptr
LPSTR   psz         // string to copy
)
    {
    strcpy(pchWrite, psz);
    pchWrite += strlen(psz);
    }

/*  ============================================================================
    CTemplate::WriteTemplate

    Writes the template out to a contiguous block of memory.

    Returns:
        nothing
    Side effects:
        Allocates, and possibly re-allocates, memory for the template.

    HERE IS HOW IT WORKS
    --------------------
    - an 'offset' is the count of bytes from start-of-template to a location
      within template memory
    - at the start of the template are 3 USHORTs, the counts of script blocks,
      object-infos and HTML blocks, respectively
    - next are 4 ULONGs, each an offset to a block of offsets; in order, these are:
        offset-to-offset to first script engine name
        offset-to-offset to first script block (the script text itself)
        offset-to-offset to first object-info
        offset-to-offset to first HTML block
    - next are a variable number of ULONGs, each an offset to a particular
      template component.  In order these ULONGs are:
        Offsets to                  Count of offsets
        ----------                  ----------------
        script engine names         cScriptBlocks
        script blocks               cScriptBlocks
        object-infos                cObjectInfos
        HTML blocks                 cHTMLBlocks
    - next are the template components themselves, stored sequentially
      in the following order:
        script engine names
        script blocks
        object-infos
        HTML blocks

    HERE IS HOW IT LOOKS
    --------------------
    |--|--|--|                      3 template component counts (USHORTs)

    |-- --|-- --|                   4 offsets to template component offsets (ULONGs)

    |-- --|-- --|-- --|-- --|-- --| template component offsets (ULONGs)
    |-- --| ............... |-- --|
    |-- --|-- --|-- --|-- --|-- --|

    | ........................... | template components
    | ........................... |
    | ........................... |
    | ........................... |

    or, mnemonically:

     cS cO cH                       3 template component counts (USHORTs)

     offSE offSB offOb offHT        4 offsets to template component offsets (ULONGs)

    |-- --|-- --|-- --|-- --|-- --| template component offsets (ULONGs)
    |-- --| ............... |-- --|
    |-- --|-- --|-- --|-- --|-- --|

    | ........................... | template components
    | ........................... |
    | ........................... |
    | ........................... |
*/
void
CTemplate::WriteTemplate
(
CWorkStore& WorkStore,          // working storage for source segments
CHitObj*    pHitObj
)
    {
    USHORT      i;              // loop index
    CByteRange  brWrite;        // general-purpose byte range for writing stuff out

    USHORT cScriptBlocks = WorkStore.CRequiredScriptEngines(m_fGlobalAsa);  // count of script blocks - 1 per required engine
    USHORT cObjectInfos = WorkStore.m_ObjectInfoStore.Count();  // count of object-infos
    USHORT cHTMLBlocks = WorkStore.m_bufHTMLSegments.Count();   // count of HTML segments

    // Calc count of offset-to-offsets == total count of all scripts, objects, etc
    // NOTE we keep separate offset-to-offsets for script engine names and script text, hence 2x
    USHORT cBlockPtrs = (2 * cScriptBlocks) + cObjectInfos + cHTMLBlocks;

    // Calc total memory required
    // NOTE header includes counts and ptr-ptrs
    UINT    cbRequiredHeader = (C_COUNTS_IN_HEADER * sizeof(USHORT)) + (C_OFFOFFS_IN_HEADER * sizeof(BYTE**));
    UINT    cbRequiredBlockPtrs = cBlockPtrs * sizeof(BYTE*);

    // Init write-offset locations
    // offset to location for writing the next header information; header is at start of template
    UINT    cbHeaderOffset = 0;
    // offset to location for writing the next offset-to-offset; immediately follows header
    UINT    cbOffsetToOffset = cbRequiredHeader;
    // offset to location for writing the next block of data; immediately follows offset-to-offsets
    UINT    cbDataOffset = cbOffsetToOffset + cbRequiredBlockPtrs;

    // offset in source file (for html blocks)
    ULONG   cbSourceOffset;
    // source filename (only if include file)
    BYTE   *pbIncFilename;
    ULONG   cbIncFilename;

    // Allocate memory and init start-ptr; bail on fail
    // NOTE here we init template member variables m_pbStart and m_cbTemplate
    if(NULL == (m_pbStart = (BYTE*) CTemplate::LargeMalloc(m_cbTemplate = CB_TEMPLATE_DEFAULT)))
        THROW(E_OUTOFMEMORY);

    // write out template header
    WriteHeader(cScriptBlocks, cObjectInfos, cHTMLBlocks, &cbHeaderOffset, &cbOffsetToOffset);

    // Reset offset-to-offset ptr to beginning of its section
    cbOffsetToOffset = cbRequiredHeader;

    // write script engine names and prog lang ids at current of data section
    for(i = 0; i < WorkStore.m_ScriptStore.CountPreliminaryEngines(); i++)
        {
        // bug 933: only write non-empty script engines
        if(WorkStore.FScriptEngineRequired(i, m_fGlobalAsa))
            {
            WorkStore.m_ScriptStore.m_bufEngineNames.GetItem(i, brWrite);
            WriteByteRangeAdv(brWrite, TRUE, &cbDataOffset, &cbOffsetToOffset);
            MemCpyAdv(&cbDataOffset, &(WorkStore.m_ScriptStore.m_rgProgLangId[i]), sizeof(PROGLANG_ID), sizeof(DWORD));
            }
        }
   
    // write the script blocks for each engine at current of data section
    // NOTE we sequence this after script engine names (rather than interleave)
    USHORT  idEngine = 0;
    for(i = 0; i < WorkStore.m_ScriptStore.CountPreliminaryEngines(); i++)
        {
        // bug 933: only write non-empty script engines
        if(WorkStore.FScriptEngineRequired(i, m_fGlobalAsa))
            {
            // bug 933: we need to pass both 'preliminary' engine id (i) and id of instantiated engine (idEngine)
            WriteScriptBlockOfEngine(i, idEngine, WorkStore, &cbDataOffset, &cbOffsetToOffset, pHitObj);
            idEngine++;
            }
        }

    // Write object-infos at current of data section
    for(i = 0; i < cObjectInfos; i++)
        {
        // get i-th object info from work store
        WorkStore.m_ObjectInfoStore.m_bufObjectNames.GetItem(i, brWrite);
        // write object name
        WriteByteRangeAdv(brWrite, TRUE, &cbDataOffset, &cbOffsetToOffset);
        // write clsid, scope and model
        /*  CONSIDER include if we need to byte-align clsid
        // NOTE byte-align clsid (16-byte), which then byte-aligns scope and model (both 4-byte)
        MemCpyAdv(&cbDataOffset, &(WorkStore.m_ObjectInfoStore.m_pObjectInfos[i].m_clsid), sizeof(CLSID), TRUE); */
        MemCpyAdv(&cbDataOffset, &(WorkStore.m_ObjectInfoStore.m_pObjectInfos[i].m_clsid), sizeof(CLSID), sizeof(DWORD));
        MemCpyAdv(&cbDataOffset, &(WorkStore.m_ObjectInfoStore.m_pObjectInfos[i].m_scope), sizeof(CompScope));
        MemCpyAdv(&cbDataOffset, &(WorkStore.m_ObjectInfoStore.m_pObjectInfos[i].m_model), sizeof(CompModel));
        }

    // if other than globals template, write HTML blocks at current of data section
    if(!m_fGlobalAsa)
        for(i = 0; i < cHTMLBlocks; i++)
            {
            // write byterange with html code
            WorkStore.m_bufHTMLSegments.GetItem(i, brWrite);
            WriteByteRangeAdv(brWrite, TRUE, &cbDataOffset, &cbOffsetToOffset);

            // source offset and include file
            cbSourceOffset = 0;
            pbIncFilename = NULL;
            cbIncFilename = 0;

            if (brWrite.m_pfilemap)
                {
                // calculate offset from filemap
                CFileMap *pFileMap = (CFileMap *)brWrite.m_pfilemap;
                if (pFileMap->m_pbStartOfFile) // mapped?
                    {
                    cbSourceOffset = DIFF(brWrite.m_pb - pFileMap->m_pbStartOfFile) + 1;

                    if (pFileMap->GetParent() != NULL && // is include file?
                        pFileMap->m_szPathInfo)  // path exists
                        {
                        pbIncFilename = (BYTE *)pFileMap->m_szPathInfo;
                        cbIncFilename = _tcslen(pFileMap->m_szPathInfo)*sizeof(TCHAR);
                        }
                    }
                }

            // write them
            MemCpyAdv(&cbDataOffset, &cbSourceOffset, sizeof(ULONG));
            MemCpyAdv(&cbDataOffset, &cbIncFilename, sizeof(ULONG));
            if (cbIncFilename > 0)
                MemCpyAdv(&cbDataOffset, pbIncFilename, cbIncFilename+sizeof(TCHAR));
            }

    // trim template memory to exactly what we used
    // NOTE cbDataOffset now contains maximum reach we have written to
    if(NULL == (m_pbStart = (BYTE*) CTemplate::LargeReAlloc(m_pbStart, m_cbTemplate = cbDataOffset)))
        THROW(E_OUTOFMEMORY);
  
    }

/*  ============================================================================
    CTemplate::WriteHeader

    Writes template header, and writes vesrion stamp and source file name into
    template data region.

    Returns
        nothing
    Side effects
        none
*/
void
CTemplate::WriteHeader
(
USHORT  cScriptBlocks,      // count of script blocks
USHORT  cObjectInfos,       // count of object-infos
USHORT  cHTMLBlocks,        // count of HTML blocks
UINT*   pcbHeaderOffset,    // ptr to offset value for header write location
UINT*   pcbOffsetToOffset   // ptr to offset value for offset-to-offset write location
)
    {
    // Write template component counts out at start of header
    WriteShortAdv(cScriptBlocks,    pcbHeaderOffset);
    WriteShortAdv(cObjectInfos,     pcbHeaderOffset);
    WriteShortAdv(cHTMLBlocks,      pcbHeaderOffset);

    // Write offsets-to-offset to script engine names, script blocks, object-infos, HTML blocks
    // NOTE counts of script engine names and script blocks are identical
    WriteOffsetToOffset(cScriptBlocks,  pcbHeaderOffset, pcbOffsetToOffset);
    WriteOffsetToOffset(cScriptBlocks,  pcbHeaderOffset, pcbOffsetToOffset);
    WriteOffsetToOffset(cObjectInfos,   pcbHeaderOffset, pcbOffsetToOffset);
    WriteOffsetToOffset(cHTMLBlocks,    pcbHeaderOffset, pcbOffsetToOffset);
    }

/*  ============================================================================
    CTemplate::WriteScriptBlockOfEngine

    Writes out script block for idEngine-th script engine.
    NOTE segment buffer [0] contains primary script segments
         segment buffer [1] contains tagged script segments of default engine
         segment buffer [i] contains tagged script segments of (i-1)th engine, for i >= 2

    Returns
        nothing
    Side effects
        none
*/
void
CTemplate::WriteScriptBlockOfEngine
(
USHORT      idEnginePrelim,     // preliminary script engine id (assigned during template pre-processing)
USHORT      idEngine,           // actual script engine id (written into compiled template)
CWorkStore& WorkStore,          // working storage for source segments
UINT*       pcbDataOffset,      // ptr to write location offset value
UINT*       pcbOffsetToOffset,  // ptr to offset-to-offset offset value
CHitObj*    pHitObj
)
    {
                                            // NOTE works for all id's - see comment above
    USHORT      iTSegBuffer = idEnginePrelim + 1;   // index of tagged segment buffer
    CByteRange  brSegment;                  // current script segment
    UINT        i;                          // loop index
    UINT        cbScriptBlockOffset;        // offset to script block write-location
                                            // count of tagged script segments
    UINT        cTaggedSegments = WorkStore.m_ScriptStore.m_ppbufSegments[iTSegBuffer]->Count();

    // Byte-align data offset location, since next thing we will write there is script block length
    // NOTE we use brSegment.m_cb generically; we really want CByteRange::m_cb
    ByteAlignOffset(pcbDataOffset, sizeof(brSegment.m_cb));
    // Cache current data offset location as offset to start of script block
    cbScriptBlockOffset = *pcbDataOffset;
    // Write offset to start of script block at current offset-to-offset offset
    WriteLongAdv(cbScriptBlockOffset, pcbOffsetToOffset);
    // advance data ptr (by init'ing script length value to 0)
    WriteLongAdv(0, pcbDataOffset);
    // reset counter that AppendSourceInfo uses
    m_cbTargetOffsetPrevT = 0;

    // if other than globals template and this is default script engine (prelim engine 0),
    // write primary script procedure at current of data section
    if(!m_fGlobalAsa)
        if(idEnginePrelim == 0)
            WritePrimaryScriptProcedure(0, WorkStore, pcbDataOffset, cbScriptBlockOffset + sizeof(long));

    // write out tagged script segments at current of data section
    for(i = 0; i < cTaggedSegments; i++)
        {
        WorkStore.m_ScriptStore.m_ppbufSegments[iTSegBuffer]->GetItem(i, brSegment);
        WriteScriptSegment(
                            idEngine,
                            m_rgpSegmentFilemaps[brSegment.m_idSequence],
                            brSegment,
                            pcbDataOffset,
                            cbScriptBlockOffset + sizeof(long),
                            FALSE       /* fAllowExprWrite - disallowed for tagged script */
                          );
        }

    // Write out null terminator
    MemCpyAdv(pcbDataOffset, SZ_NULL, 1);

    // convert script text to unicode, so script engine won't have to do this at runtime

    // ptr to start of script is:
    //           ptr start of template + offset to script    + size of script length
    LPSTR szScript = (LPSTR) m_pbStart + cbScriptBlockOffset + sizeof(ULONG);
    /*  script block length is:
        == EndOfScriptText                           - StartOfScriptText
        == (current of data ptr - length of null )   - (start of primary script byte range + length of br.m_cb)
    */
    ULONG cbScript = (*pcbDataOffset - sizeof(BYTE)) - (cbScriptBlockOffset + sizeof(ULONG));

    /*  bug 887: we append one extra "pseudo-line" to the end of source-infos array
        to cover the case where the script engine reports back an error line number
        that falls after end of script. We always want the "pseudo-line" to point to the
        main file, so that the debugger can display something reasonable, so we pass
        m_rgpFilemaps[0] as the source file, which is the main file.
    */
    AppendSourceInfo(idEngine, m_rgpFilemaps[0],
                     NULL,              // Don't calculate line #
                     UINT_MAX,          // Don't care & calculation is expensive
                     UINT_MAX,                  // Start of script blocks
                     UINT_MAX,                  // Really don't care
                     0,                 // zero characters exist past EOF
                     TRUE);             // Line is HTML (bogus)

    // get wide string version of script text, using hitobj's code page
    // NOTE we may slightly over-allocate space for wstrScript by using cbScript (e.g. if script contains DBCS).
    // However, this won't matter since we call MultiByteToWideChar with -1, telling it to calc length of szScript
    LPOLESTR wstrScript = NULL;
    DWORD cbConvert = ( cbScript + 1 ) * 2;

    STACK_BUFFER( tempScript, 2048 );

    if (!tempScript.Resize(cbConvert)) {
        THROW(E_OUTOFMEMORY);
    }

    wstrScript = (LPOLESTR)tempScript.QueryPtr();

    MultiByteToWideChar( m_wCodePage, 0, szScript, -1, wstrScript, (cbScript + 1) );

    // reset data offset location to start of script
    *pcbDataOffset = cbScriptBlockOffset + sizeof(ULONG);
    // write wide string script text over top of ansi version
    MemCpyAdv(pcbDataOffset, wstrScript, sizeof(WCHAR) * cbScript);
    // write wide string null terminator
    MemCpyAdv(pcbDataOffset, WSTR_NULL, sizeof(WCHAR));

    //  write script length at start of script byte range
    // NOTE we do this here because script length was initially unknown
    WriteLongAdv(sizeof(WCHAR) * cbScript, &cbScriptBlockOffset);

    }

/*  ============================================================================
    CTemplate::WritePrimaryScriptProcedure

    Writes out default-engine primary script procedure.
    If VBScript is default-engine, the primary script procedure contains
    interleaved script commands and HTML block-writes, like this:
        Sub Main
            ...
            [script segment]
            Response.WriteBlock([HTML block id])
            ...
            [script segment]
            Response.WriteBlock([HTML block id])
            ...
            [script segment]
            Response.WriteBlock([HTML block id])
            ...
        End Sub

    NOTE segment buffer [0] == primary script segments

    Returns
        nothing
    Side effects
        none
*/
void
CTemplate::WritePrimaryScriptProcedure
(
USHORT      idEngine,           // script engine id
CWorkStore& WorkStore,          // working storage for source segments
UINT*       pcbDataOffset,      // ptr to write location offset value
UINT        cbScriptBlockOffset // ptr to start of script engine code
)
    {
    USHORT      cScriptSegmentsProcessed = 0;   // count of script blocks processed
    USHORT      cHTMLBlocksProcessed = 0;       // count of HTML blocks processed
    CByteRange  brScriptNext;                   // next script block to write out
    CByteRange  brHTMLNext;                     // next HTML block to write out
    char        szHTMLBlockID[6];               // sz representation of HTML block ID - NOTE limited to 5 digits
                                                // count of primary script segments
    USHORT      cPrimaryScriptSegments = WorkStore.m_ScriptStore.m_ppbufSegments[0]->Count();
                                                // count of HTML blocks
    USHORT      cHTMLBlocks = WorkStore.m_bufHTMLSegments.Count();
    CFileMap*   pfilemap;                       // file where HTML segment lives in

    // get initial script segment and initial html segment
    if(cPrimaryScriptSegments)
        WorkStore.m_ScriptStore.m_ppbufSegments[0]->GetItem(0, brScriptNext);
    if(cHTMLBlocks)
        WorkStore.m_bufHTMLSegments.GetItem(0, brHTMLNext);

    // While HTML block(s) or primary script segment(s) remain to be processed ...
    while((cHTMLBlocksProcessed < cHTMLBlocks) || (cScriptSegmentsProcessed < cPrimaryScriptSegments))
        {
        // If HTML block(s) remain to be processed ...
        if(cHTMLBlocksProcessed < cHTMLBlocks)
            while (TRUE)
                {
                // Write out write-block command for each HTML segment earlier in source than next script segment
                if(brHTMLNext.FEarlierInSourceThan(brScriptNext) || (cScriptSegmentsProcessed >= cPrimaryScriptSegments))
                    {
                    // append source-info for the target script line we just manufactured
                    pfilemap = m_rgpSegmentFilemaps[brHTMLNext.m_idSequence];
                    AppendSourceInfo(idEngine, pfilemap,
                                     NULL,                                              // Don't calculate line #
                                     DIFF(brHTMLNext.m_pb - pfilemap->m_pbStartOfFile), // line offset
                                     cbScriptBlockOffset,
                                     *pcbDataOffset - cbScriptBlockOffset,              // character offset in target script
                                     CharAdvDBCS((WORD)m_wCodePage,                     // length of the segment
                                                 reinterpret_cast<char *>(brHTMLNext.m_pb),
                                                 reinterpret_cast<char *>(brHTMLNext.m_pb + brHTMLNext.m_cb),
                                                 INFINITE, NULL),
                                     TRUE);                                             // Line is HTML text

                    // Get block number as an sz
                    _itoa(cHTMLBlocksProcessed, szHTMLBlockID, 10);
                    // Write out write-block opener
                    WriteSzAsBytesAdv(WorkStore.m_szWriteBlockOpen, pcbDataOffset);
                    // Write out block number
                    WriteSzAsBytesAdv(szHTMLBlockID, pcbDataOffset);
                    // Write out write-block closer and newline
                    WriteSzAsBytesAdv(WorkStore.m_szWriteBlockClose, pcbDataOffset);
                    WriteSzAsBytesAdv(SZ_NEWLINE, pcbDataOffset);

                    if(++cHTMLBlocksProcessed >= cHTMLBlocks)
                        break;

                    // Get next HTML block
                    WorkStore.m_bufHTMLSegments.GetItem(cHTMLBlocksProcessed, brHTMLNext);
                    }
                    else
                        break;
                }

        // if primary script segment(s) remain to be processed ...
        if(cScriptSegmentsProcessed < cPrimaryScriptSegments)
            while (TRUE)
                {
                // Write out each primary script segment earlier in the source file than the next HTML block
                if(brScriptNext.FEarlierInSourceThan(brHTMLNext) || (cHTMLBlocksProcessed >= cHTMLBlocks))
                    {
                    WriteScriptSegment(
                                        idEngine,
                                        m_rgpSegmentFilemaps[brScriptNext.m_idSequence],
                                        brScriptNext,
                                        pcbDataOffset,
                                        cbScriptBlockOffset,
                                        TRUE        /* fAllowExprWrite - allowed for primary script */
                                      );

                    if(++cScriptSegmentsProcessed >= cPrimaryScriptSegments)
                        break;

                    // Get next script segment
                    WorkStore.m_ScriptStore.m_ppbufSegments[0]->GetItem(cScriptSegmentsProcessed, brScriptNext);
                    }
                else
                    break;
                }
        }
    }


/*  ============================================================================
    CTemplate::WriteScriptSegment

    Writes a script segment to template memory line-by-line.
    NOTE a 'script segment' is a piece (possibly all) of a 'script block'

    Returns
        nothing
    Side effects
        none
*/
void
CTemplate::WriteScriptSegment
(
USHORT      idEngine,       // script engine id
CFileMap*   pfilemap,       // ptr to source file map
CByteRange& brScript,       // byte range containing script segment
UINT*       pcbDataOffset,  // ptr to write location offset value
UINT        cbScriptBlockOffset,// ptr to beginning of the script text
BOOL        fAllowExprWrite // allow short-hand expression write?
)
    {
    CByteRange  brLine;                 // byte range containing next line
    UINT        cbPtrOffset = 0;        // ptr offset - 0 tells WriteByteRangeAdv 'ignore this'
    BOOL        fExpression = FALSE;    // is current line an expression?
    BOOL        fCalcLineNumber = TRUE; // calc source line number?
    BOOL        fFirstLine = TRUE;      // first line in script segment?

    if(FByteRangeIsWhiteSpace(brScript))
        return;

    // trim white space from beginning of script segment
    if (FIsLangVBScriptOrJScript(idEngine))
        LTrimWhiteSpace(brScript);

    while(!(brScript.IsNull()))
        {
        // fetch next line from byte range
        // NOTE LineFromByteRangeAdv advances through brScript until brScript is null
        LineFromByteRangeAdv(brScript, brLine);

        if(FByteRangeIsWhiteSpace(brLine))
            {
            // if line is blank, don't process it; simply force calc of line number on next non-blank line
            fCalcLineNumber = TRUE;
            continue;
            }

        // line is non-blank; trim its white space
        if (FIsLangVBScriptOrJScript(idEngine))
            LTrimWhiteSpace(brLine);
        RTrimWhiteSpace(brLine);

        // append source-info to array; if flag is set, calc line number
        // from location in source file; else, simply increment previous line number (NULL indicates this)
        AppendSourceInfo(idEngine, pfilemap,
                         fCalcLineNumber? brLine.m_pb : NULL,           // info to calc line #
                         DIFF(brLine.m_pb - pfilemap->m_pbStartOfFile), // line offset
                         cbScriptBlockOffset,
                         *pcbDataOffset - cbScriptBlockOffset,          // character offset in target script
                         CharAdvDBCS((WORD)m_wCodePage,                 // statement length
                                     reinterpret_cast<char *>(brLine.m_pb),
                                     reinterpret_cast<char *>(brLine.m_pb + brLine.m_cb),
                                     INFINITE, NULL),
                         FALSE);                                        // HTML?

        /*  if it's true, set calc-line-number flag false
            NOTE this is purely an optimization, to make the call to AppendSourceInfo faster
            on subsequent calls within a contiguous block of non-blank lines
        */
        if(fCalcLineNumber)
            fCalcLineNumber = FALSE;

        if(fAllowExprWrite && fFirstLine)
            {
            // bug 912: test for remainder of script segment null on temp copy of script byte range, not on actual
            CByteRange  brTemp = brScript;
            LTrimWhiteSpace(brTemp);    // NOTE will nullify brScript if it is all white space

            if(brTemp.IsNull())
                {
                /*  if
                      a) expr-write is allowed AND
                      b) this is only script line in this segment (i.e. first line in segment and remainder of segment is null)
                    then, test this line to see if it is an expression.
                    NOTE test (b) fixes bug 785

                    if this line is an expression, create a script command that reads
                        Response.Write([line contents])
                */
                if(fExpression = FExpression(brLine))
                    {
                    Assert(idEngine == 0);  // =expr is only enabled for primary engine
                    WriteSzAsBytesAdv(m_pWorkStore->m_szWriteOpen, pcbDataOffset);
                    }

                // in this case only, set actual script to (now null) temp copy, since brScript governs while loop termination
                brScript = brTemp;
                }
            }

        Assert(FImplies(fExpression, fFirstLine));          // if an expr, must be first line in segment
        Assert(FImplies(fExpression, brScript.IsNull()));   // if an expr, no more script lines remain
        Assert(FImplies(!fFirstLine, !fExpression));            // if not first line in segment, line cannot be expr
        Assert(FImplies(!brScript.IsNull(), !fExpression)); // if script lines remain, line cannot be expr

        // write out line contents
        WriteScriptMinusEscapeChars(brLine, pcbDataOffset, &cbPtrOffset);

        // if this line is an expression, close script command
        if(fExpression)
            WriteSzAsBytesAdv(m_pWorkStore->m_szWriteClose, pcbDataOffset);

        // write new-line and set first-line flag false
        WriteSzAsBytesAdv(SZ_NEWLINE, pcbDataOffset);
        fFirstLine = FALSE;
        }
    }

/*  ============================================================================
    CTemplate::WriteScriptMinusEscapeChars
    Writes a script byte range to memory, minus its escape characters, if any.

    Returns:
        Nothing.
    Side effects:
        None.
*/
void
CTemplate::WriteScriptMinusEscapeChars
(
CByteRange  brScript,       // (ByVal) script byte range
UINT*       pcbDataOffset,  // offset where data will be written
UINT*       pcbPtrOffset    // offset where ptr will be written
)
    {
    BYTE*   pbToken;

    while(NULL != (pbToken = gm_pTokenList->GetToken(CTokenList::tknEscapedClosePrimaryScript, brScript, m_wCodePage)))
        {
        CByteRange  brTemp = brScript;

        // set temp range to source range up to escaped-token
        brTemp.m_cb = DIFF(pbToken - brTemp.m_pb);

        // write out temp range and actual-token - this replaces escaped-token with actual-token
        WriteByteRangeAdv(brTemp, FALSE, pcbDataOffset, pcbPtrOffset);
        WriteSzAsBytesAdv(SZ_TOKEN(CTokenList::tknClosePrimaryScript), pcbDataOffset);

        //advance source range past escaped-token
        brScript.Advance(DIFF(pbToken - brScript.m_pb) + CCH_TOKEN(CTokenList::tknEscapedClosePrimaryScript));
        }

    // write remainder of source range
    WriteByteRangeAdv(brScript, FALSE, pcbDataOffset, pcbPtrOffset);
    }

/*  ============================================================================
    CTemplate::FVbsComment
    Determines whether a script line is a VBS comment.
    NOTE caller must ensure that brLine is non-blank and has no leading white space

    Returns
        TRUE if the line is a VBS comment, else FALSE
    Side effects
        none
*/
BOOLB
CTemplate::FVbsComment(CByteRange& brLine)
    {
    // CONSIDER: SCRIPTLANG generic comment token
    if(!_strnicmp((LPCSTR)brLine.m_pb, SZ_TOKEN(CTokenList::tknVBSCommentSQuote), CCH_TOKEN(CTokenList::tknVBSCommentSQuote)))
        return TRUE;
    if(!_strnicmp((LPCSTR)brLine.m_pb, SZ_TOKEN(CTokenList::tknVBSCommentRem), CCH_TOKEN(CTokenList::tknVBSCommentRem)))
        return TRUE;

    return FALSE;
    }

/*  ============================================================================
    CTemplate::FExpression

    Determines whether a script line is an expression, and if so returns
    just the expression in brLine.
    NOTE caller must ensure that brLine has no leading white space

    Returns
        TRUE if the line is an expression, else FALSE
    Side effects
        none
*/
BOOLB
CTemplate::FExpression(CByteRange& brLine)
    {
        // may be whitespace (other languages besides VB & JScript will have whitespace)
        char *pchLine = reinterpret_cast<char *>(brLine.m_pb);
        int cchLine = brLine.m_cb;

        while (cchLine > 0 && FWhiteSpace(*pchLine))
                {
                --cchLine;
                ++pchLine;
                }

    // if line starts with =, it is an expression: bypass =, left-trim whitespace and return true
    if(cchLine > 0 && *pchLine == '=')
        {
        brLine.Advance(1 + DIFF(reinterpret_cast<BYTE *>(pchLine) - brLine.m_pb));  // OK to advance past whitespace now.
        LTrimWhiteSpace(brLine);
        return TRUE;
        }

    // else return false
    return FALSE;
    }

/**
 **     In the following function names:
 **         'Adv' == 'advance offset after writing'
 **/

/*  ============================================================================
    CTemplate::WriteOffsetToOffset

    Writes a offset-to-offset offset (0 if no blocks) into header,
    and advances header offset and offset-to-offset.

    Returns:
        Nothing.
    Side effects:
        Advances offsets.
*/
void
CTemplate::WriteOffsetToOffset
(
USHORT  cBlocks,            // count of blocks
UINT*   pcbHeaderOffset,    // ptr to header offset value
UINT*   pcbOffsetToOffset   // ptr to offset-to-offset value
)
    {
    // if blocks of this type, write offset to first of them into header;
    // if no blocks of this type, write 0 into header
    WriteLongAdv((cBlocks > 0) ? *pcbOffsetToOffset : 0, pcbHeaderOffset);

    // advance offset-to-offset offset
    *pcbOffsetToOffset += cBlocks * sizeof(ULONG);
    }

/*  ============================================================================
    CTemplate::WriteSzAsBytesAdv

    Writes a null-terminated string as bytes, i.e. without its null terminator
    and advances offset

    Returns:
        Nothing.
    Side effects:
        Advances offset.
*/
void
CTemplate::WriteSzAsBytesAdv
(
LPCSTR  szSource,       // source string
UINT*   pcbDataOffset   // ptr to offset value
)
    {
    if((szSource == NULL) || (*szSource == '\0'))
        return;
    MemCpyAdv(pcbDataOffset, (void*) szSource, strlen(szSource));
    }

/*  ============================================================================
    CTemplate::WriteByteRangeAdv

    Writes a byte range to memory at template offset location *pcbDataOffset and, optionally,
    writes a ptr to the written data at template offset location *pcbPtrOffset
    (pass *pcbPtrOffset == 0 to avoid this)

    fWriteAsBsz == FALSE -->    write only byte range's data
    fWriteAsBsz == TRUE  -->    write length, followed by data, followed by NULL
                                NOTE bsz == length-prefixed, null-terminated string

    Returns:
        Nothing.
    Side effects:
        Advances offset(s).
*/
void
CTemplate::WriteByteRangeAdv
(
CByteRange& brSource,       // source data
BOOLB       fWriteAsBsz,    // write as bsz?
UINT*       pcbDataOffset,  // offset where data will be written
UINT*       pcbPtrOffset    // offset where ptr will be written
)
    {
    // bail if source is empty
    if(brSource.IsNull())
        return;

    // If writing as a bsz, write length prefix
    if(fWriteAsBsz)
        WriteLongAdv(brSource.m_cb, pcbDataOffset);

    // Write data
    MemCpyAdv(pcbDataOffset, brSource.m_pb, brSource.m_cb);

    // If writing as a bsz, write null terminator and advance target ptr
    if(fWriteAsBsz)
        MemCpyAdv(pcbDataOffset, SZ_NULL, 1);

    // If caller passed a non-zero ptr offset, write offset to data there
    if(*pcbPtrOffset > 0)
        {
        if(fWriteAsBsz)
            /* if writing as a bsz ...
                offset to start of data == current data offset
                                          - null terminator
                                          - data length
                                          - sizeof length prefix
            */
            WriteLongAdv(*pcbDataOffset - 1 - brSource.m_cb - sizeof(brSource.m_cb), pcbPtrOffset);
        else
            // else, offset to start of data == current data offset - data length
            WriteLongAdv(*pcbDataOffset - brSource.m_cb, pcbPtrOffset);
        }
    }

/*===================================================================
    CTemplate::MemCpyAdv

    Copies from a memory location to a template offset location,
    and advances offset.

    Returns:
        Nothing.
    Side effects:
        Advances offset.
        Re-allocates memory if required.
*/
void
CTemplate::MemCpyAdv
(
UINT*   pcbOffset,  // ptr to offset value
void*   pbSource,   // ptr to source
ULONG   cbSource,   // length of source
UINT    cbByteAlign // align bytes on short/long/dword boundary?
)
    {
    // byte-align offset location before write, if specified by caller
    if(cbByteAlign > 0)
        ByteAlignOffset(pcbOffset, cbByteAlign);

    // calc number of bytes by which to grow allocated template memory:
    // if projected reach exceeds current reach, we need to grow by the difference;
    // else, no need to grow
    if((*pcbOffset + cbSource) > m_cbTemplate)
        {
        // Reallocate space for storing local data - we grab twice what we had before
        // or twice current growth requirement, whichever is more
        m_cbTemplate = 2 * max(m_cbTemplate, (*pcbOffset + cbSource) - m_cbTemplate);
        if(NULL == (m_pbStart = (BYTE*) CTemplate::LargeReAlloc(m_pbStart, m_cbTemplate)))
            THROW(E_OUTOFMEMORY);
        }

    // copy source to template offset location
    memcpy(m_pbStart + *pcbOffset, pbSource, cbSource);
    // advance offset location
    *pcbOffset += cbSource;
    }

/*  ============================================================================
    CTemplate::GetAddress
    Returns a ptr to the i-th object of type tcomp
*/
BYTE*
CTemplate::GetAddress
(
TEMPLATE_COMPONENT  tcomp,
USHORT              i
)
    {
    DWORD*  pdwBase;

    Assert(NULL != m_pbStart);

    // refer to CTemplate::WriteTemplate comments for the structure of what this is dealing with

    pdwBase = (DWORD*)(m_pbStart + (C_COUNTS_IN_HEADER * sizeof(USHORT)));

    // tcomp types are ptr-to-ptrs
    DWORD* pdwTcompBase = (DWORD *) (m_pbStart + pdwBase[tcomp]);

    return m_pbStart + pdwTcompBase[i];
    }




/*  ============================================================================
    CTemplate::AppendSourceInfo
    Appends a source line number for the current target line
    NOTE if caller passes null source ptr, we append prev source line number + 1

    Returns
        Nothing
    Side effects
        allocates memory first time thru; may realloc
*/
void
CTemplate::AppendSourceInfo
(
USHORT      idEngine,            // script engine id
CFileMap*   pfilemap,            // ptr to source file map
BYTE*       pbSource,            // ptr to current location in source file
ULONG       cbSourceOffset,      // byte offset of line in source file
ULONG           cbScriptBlockOffset, // pointer to start of script text
ULONG       cbTargetOffset,      // character offset of line in target file
ULONG       cchSourceText,       // # of characters in source text
BOOL        fIsHTML              // TRUE if manufactured line
)
    {
    UINT                i;                  // loop index
    CSourceInfo         si;                 // temporary CSourceInfo structure
    vector<CSourceInfo> *prgSourceInfos;    // pointer to line mapping table for the engine
    ULONG               cchSourceOffset = 0;// cch corresponding to cbSourceOffset
    HRESULT             hr = S_OK;

    // if arrays are not yet allocated, allocate them
    if (m_rgrgSourceInfos == NULL)
        {
        // transfer count of script engines from workstore to template
        m_cScriptEngines = m_pWorkStore->CRequiredScriptEngines(m_fGlobalAsa);

        // one source-info array per engine
        if ((m_rgrgSourceInfos = new vector<CSourceInfo>[m_cScriptEngines]) == NULL)
            THROW (E_OUTOFMEMORY);
        }

    // new script engine must be allocated in IdEngineFromBr (way upstream of this point),
    // so we assert that current engine must already be covered
    Assert(idEngine < m_pWorkStore->CRequiredScriptEngines(m_fGlobalAsa));

    /*  set current target line's source line number (SLN):
        a) if caller passed a source ptr, calc SLN from the source ptr;
        b) else if caller passed a filemap ptr, set SLN to prev target line's SLN plus one;
        c) else set SLN to 0

        semantics:
        a) we have a source file location, but must calc a line # for that location
        b) caller tells us (by passing NULL source file location) that this target line
           immediately follows prev target line.  This is an optimization because
           SourceLineNumberFromPb is very slow.

        change:
            caller used to pass NULL filemap ptr that target line is 'manufactured'
            i.e. has no corresponding authored line in source file

            HOWEVER - now filemap ptr must NOT be NULL because 'manufactured' lines
            are also stored in the file map array
    */

    Assert (pfilemap != NULL);

    prgSourceInfos = &m_rgrgSourceInfos[idEngine];
    
    if (pbSource == NULL)
        {
        if (prgSourceInfos->length() == 0)
            si.m_idLine = 1;
        else
            si.m_idLine = (*prgSourceInfos)[prgSourceInfos->length() - 1].m_idLine + 1;
        }
    else
        si.m_idLine = SourceLineNumberFromPb(pfilemap, pbSource);

    // The EOF line does not have a source offset (caller passes -1 (UINT_MAX)).  For this case, no
    // DBCS calculations etc. should be done.  (set cchSourceOffset to UINT_MAX).
    if (cbSourceOffset == UINT_MAX)
        cchSourceOffset = UINT_MAX;
    else
        {
        // BUG 80901: Source offset needs to point to the beginning of leading white space on the line
        //            Adjust source length by one as we decrement source offset
        // Note: whitepsace is never trailing byte, so loop will work with DBCS encoded character sets
        while (cbSourceOffset > 0 && strchr(" \t\v\a\f", pfilemap->m_pbStartOfFile[cbSourceOffset - 1]))
            {
            --cbSourceOffset;
            ++cchSourceText;
            }

        // BUG 95859
        // If the cursor is on the opening token of a script block (the "<%" part of a line), the
        // BP is set in the previous HTML, not in the script block, as is desired.
        //
        // To correct this, if we are in a script block, scan back two characters, see if it is the open
        // token.  If it is, set the offset back two, and add two to the length.
        //
        if (!fIsHTML)
            {
            // Skip whitespace (including newlines -- the previous step did not skip newlines)
            //
            ULONG cbOpen = cbSourceOffset;
            while (cbOpen > 0 && strchr(" \t\v\a\f\r\n", pfilemap->m_pbStartOfFile[cbOpen - 1]))
                --cbOpen;

            if (cbOpen >= 2 && strncmp(reinterpret_cast<char *>(&pfilemap->m_pbStartOfFile[cbOpen - 2]), "<%", 2) == 0)
                {
                cbOpen -= 2;
                cchSourceText += cbSourceOffset - cbOpen;
                cbSourceOffset = cbOpen;
                }

            // Look for trailing "%>" in this snippet, and if it exists then include the end delimiter in
            // the length.  NOTE: No DBCS awareness needed here - if we find a lead byte we just get out
            // of the loop.  We are looking for <whitespace>*"%>" which is totally SBCS chars.
            //
            ULONG cbClose = cbSourceOffset + cchSourceText;
            ULONG cbFile = pfilemap->GetSize();
            while (cbClose < cbFile && strchr(" \t\v\a\f\r\n", pfilemap->m_pbStartOfFile[cbClose]))
                ++cbClose;

            if (cbClose < cbFile && strncmp(reinterpret_cast<char *>(&pfilemap->m_pbStartOfFile[cbClose]), "%>", 2) == 0)
                cchSourceText += cbClose - (cbSourceOffset + cchSourceText) + 2;
            }

        // BUG 82222, 85584
        // Compiler marks HTML segments starting with the newline on the previous line
        // if the line ends with %>.
        //
        // This screws up the debugger, becasue when you press <F9>, the pointer is placed
        // on the line above when it should point to the start of the whitespace on the next line.
        if (fIsHTML)
            {
            UINT cbEOF = pfilemap->GetSize(), cbRover = cbSourceOffset;

            // Skip initial whitespace
            while (cbRover < cbEOF && strchr(" \t\a\f", pfilemap->m_pbStartOfFile[cbRover]))
                ++cbRover;

            // If what's left is a CR/LF pair, then advance cbSourceOffset to next line
            BOOL fCR = FALSE, fLF = FALSE;
            if (cbRover < cbEOF && strchr("\r\n", pfilemap->m_pbStartOfFile[cbRover]))
                {
                fCR = pfilemap->m_pbStartOfFile[cbRover] == '\r';
                fLF = pfilemap->m_pbStartOfFile[cbRover] == '\n';

                ++cbRover;
                Assert (fCR || fLF);
                }

            // we allow either <CR>, <LF>, <CR><LF>, or <LF><CR> to terminate a line,
            // so look for its opposite terminator if one is found (but don't require it)

            if (fCR && cbRover < cbEOF && pfilemap->m_pbStartOfFile[cbRover] == '\n')
                ++cbRover;

            if (fLF && cbRover < cbEOF && pfilemap->m_pbStartOfFile[cbRover] == '\r')
                ++cbRover;

            // OK, adjust cbSourceOffset now

            if ((fCR || fLF) && cbRover < cbEOF)
                {
                cchSourceText -= cbRover - cbSourceOffset;  // adjust # of chars to select
                cbSourceOffset = cbRover;
                }
            }

        // Now that we have the source offset, calculate its CCH by finding
        // the last time we sampled the value, then add that to the number
        // of DBCS characters from that point to the current offset.
        //
        // For the case of includes, it's possible offset already exists
        // (if the entry was previously generated by another instance of
        //  #include - therefore we have to search)

        COffsetInfo *pOffsetInfoLE, *pOffsetInfoGE;
        GetBracketingPair(
                        cbSourceOffset,                     // value to find
                        pfilemap->m_rgByte2DBCS.begin(),    // beginning of array
                        pfilemap->m_rgByte2DBCS.end(),      // end of array
                        CByteOffsetOrder(),                 // search for byte offset
                        &pOffsetInfoLE, &pOffsetInfoGE      // return values
                        );

        // If we find an equal match, don't insert any duplicates
        if (pOffsetInfoLE == NULL || pOffsetInfoLE->m_cbOffset < cbSourceOffset)
            {
            // if pOffsetInfoLE is NULL, it means that the array is empty -
            // create the mapping of offset 0 to offset 0.
            //
            // In the case of the first line of a file being an include directive,
            // the first executable line from the file may not start at offset zero,
            // so in this case we need to create this entry AND execute the next "if"
            // block.
            //
            if (pOffsetInfoLE == NULL)
                {
                COffsetInfo oiZero;         // ctor will init
                if (FAILED(hr = pfilemap->m_rgByte2DBCS.append(oiZero)))
                    THROW(hr);
                pOffsetInfoLE = pfilemap->m_rgByte2DBCS.begin();
                Assert (pOffsetInfoLE != NULL);
                }

            // If cbSourceOffset is zero, we handled it above
            if (cbSourceOffset != 0)
                {
                cchSourceOffset = pOffsetInfoLE->m_cchOffset +
                                    CharAdvDBCS
                                     (
                                     (WORD)m_wCodePage,
                                     reinterpret_cast<char *>(pfilemap->m_pbStartOfFile + pOffsetInfoLE->m_cbOffset),
                                     reinterpret_cast<char *>(pfilemap->m_pbStartOfFile + cbSourceOffset),
                                     INFINITE,
                                     NULL
                                     );

                // Now add the value to the table
                COffsetInfo oi;

                oi.m_cchOffset = cchSourceOffset;
                oi.m_cbOffset  = cbSourceOffset;

                if (pOffsetInfoGE == NULL)              // No offset greater
                    hr = pfilemap->m_rgByte2DBCS.append(oi);
                else
                    hr = pfilemap->m_rgByte2DBCS.insertAt(DIFF(pOffsetInfoGE - pfilemap->m_rgByte2DBCS.begin()), oi);

                if (FAILED(hr))
                    THROW(hr);
                }
            }
        else
            {
            // If we're not adding anything for the table, Assert it's because there's
            // a duplicate item
            Assert (cbSourceOffset == pOffsetInfoLE->m_cbOffset);
            cchSourceOffset = pOffsetInfoLE->m_cchOffset;
            }
        }

        UINT cchTargetOffset = UINT_MAX;
        if (cbTargetOffset != UINT_MAX)
                {
                // ptr to start of script is:
                //           ptr start of template + offset to script    + size of script length
                LPSTR szScript = (LPSTR) m_pbStart + cbScriptBlockOffset;

                // Calculate cchTargetOffset (have the cb).  The cch is the number of characters since the
                // last cch calculated in the end of the array.
                //
                if (prgSourceInfos->length() > 0)
                        cchTargetOffset = (*prgSourceInfos)[prgSourceInfos->length() - 1].m_cchTargetOffset;
                else
                        cchTargetOffset = 0;

                cchTargetOffset += CharAdvDBCS
                                                         (
                                                         (WORD) m_wCodePage,
                                                         &szScript[m_cbTargetOffsetPrevT],
                                                         &szScript[cbTargetOffset],
                                                         INFINITE,
                                                         NULL
                                                         );

                // Keeps track of offsets during compilation
                //
                m_cbTargetOffsetPrevT = cbTargetOffset;
                }

    // Store this record and move on.
    //
    si.m_pfilemap        = pfilemap;
    si.m_fIsHTML         = fIsHTML;
    si.m_cchSourceOffset = cchSourceOffset;
    si.m_cchTargetOffset = cchTargetOffset;
    si.m_cchSourceText   = cchSourceText;

    if (FAILED(prgSourceInfos->append(si)))
        THROW(hr);
    }

/*  ============================================================================
    CTemplate::SourceLineNumberFromPb
    Returns the starting source line number for the given source file location
*/
UINT
CTemplate::SourceLineNumberFromPb
(
CFileMap*   pfilemap,   // ptr to source file map
BYTE*       pbSource    // ptr to current location in source file
)
    {
    UINT        cSourceLines = 1;   // count of lines into source file
    CByteRange  brScan;             // byte range to scan for newlines
    CByteRange  brSOL;              // start-of-line ptr

    if(pbSource == NULL || pfilemap == NULL)
        return 0;

    // Determine if there was a state stored on this ASP script earlier. If yes, then restore state.
    // If the line being requested is prior to the saved state...Bail out and restart from the begining.
    if(m_pWorkStore->m_cPrevSourceLines && 
        (m_pWorkStore->m_pbPrevSource && (m_pWorkStore->m_pbPrevSource < pbSource)) &&        
         (m_pWorkStore->m_hPrevFile && (pfilemap->m_hFile==m_pWorkStore->m_hPrevFile)))
    {
        // The file handles match:with means that we are evaluating the current file. Restore state.
        brScan.m_pb = m_pWorkStore->m_pbPrevSource;        
        brScan.m_cb = max(DIFF(pbSource - brScan.m_pb), 0);
        cSourceLines = m_pWorkStore->m_cPrevSourceLines;        
    }
    else
    {    
        // set scan range to run from start-of-template to caller's ptr
        brScan.m_pb = pfilemap->m_pbStartOfFile;
        brScan.m_cb = max(DIFF(pbSource - brScan.m_pb), 0);
    }
   
    // get newlines in scan range
    brSOL = BrNewLine(brScan);
    
    while(!brSOL.IsNull())
    {
        // advance start-of-line ptr and scan byte range
        brScan.Advance(DIFF((brSOL.m_pb + brSOL.m_cb) - brScan.m_pb));

        // increment source line counter
        cSourceLines++;    

        // find next newline
        brSOL = BrNewLine(brScan);
    }

    // Store the state for the next call.
    m_pWorkStore->m_pbPrevSource = pbSource;
    m_pWorkStore->m_cPrevSourceLines = cSourceLines;
    m_pWorkStore->m_hPrevFile = pfilemap->m_hFile;
    
    return cSourceLines;
    }

/*  ============================================================================
    CTemplate::RemoveFromIncFiles
    Removes this template from inc-files on which it depends

    Returns:
        Nothing
    Side effects:
        None
*/
void
CTemplate::RemoveFromIncFiles
(
)
    {
    // NOTE we loop from 1 to count, since 0-th filemap is for main file
    for(UINT i = 1; i < m_cFilemaps; i++)
        {
        if(NULL != m_rgpFilemaps[i]->m_pIncFile)
            m_rgpFilemaps[i]->m_pIncFile->RemoveTemplate(this);
        }
    }

/*  ****************************************************************************
    IDebugDocumentProvider implementation
*/

/*  ============================================================================
    CTemplate::GetDocument
    Return a pointer to the IDebugDocument implementation. (same object in this case)

    Returns:
        *ppDebugDoc is set to "this".
    Notes:
        always succeeds
*/
HRESULT CTemplate::GetDocument
(
IDebugDocument **ppDebugDoc
)
    {
    return QueryInterface(IID_IDebugDocument, reinterpret_cast<void **>(ppDebugDoc));
    }

/*  ============================================================================
    CTemplate::GetName
    Return the various names of a document.
*/

HRESULT CTemplate::GetName
(
/* [in] */ DOCUMENTNAMETYPE doctype,
/* [out] */ BSTR *pbstrName
)
{
    TCHAR *szPathInfo = m_rgpFilemaps[0]->m_szPathInfo;
    switch (doctype) {
        case DOCUMENTNAMETYPE_APPNODE:
        case DOCUMENTNAMETYPE_FILE_TAIL:
        case DOCUMENTNAMETYPE_TITLE:
            // Skip application path portion of the filename
        {
            // Make sure the template remembers the virtual path
            // from the same application (it could be different
            // if template is shared between two applications)
            //
            int cch = _tcslen(m_szApplnVirtPath);
            if (_tcsncicmp(szPathInfo, m_szApplnVirtPath, cch) == 0)
                szPathInfo += cch;

            // Strip leading '/'
            if (*szPathInfo == _T('/'))
                szPathInfo++;
#if UNICODE
            *pbstrName = SysAllocString(szPathInfo);
            if (*pbstrName == NULL)
                return E_OUTOFMEMORY;
            return S_OK;
#else
            return SysAllocStringFromSz(szPathInfo, 0, pbstrName, m_wCodePage);
#endif
        }

        case DOCUMENTNAMETYPE_URL:
            // prefix with the URL, use szPathInfo for the rest of the path
        {
            STACK_BUFFER( tempName, MAX_PATH );

            int cbURLPrefix = DIFF(m_szApplnVirtPath - m_szApplnURL) * sizeof (TCHAR);
            if (!tempName.Resize(cbURLPrefix + (_tcslen(szPathInfo)*sizeof(TCHAR)) + sizeof(TCHAR))) {
                return E_OUTOFMEMORY;
            }

            TCHAR *szURL = (TCHAR *)tempName.QueryPtr();

            memcpy(szURL, m_szApplnURL, cbURLPrefix);
            _tcscpy(&szURL[cbURLPrefix/sizeof(TCHAR)], szPathInfo);

#if UNICODE
            *pbstrName = SysAllocString(szURL);
            if (*pbstrName == NULL)
                return E_OUTOFMEMORY;
            return S_OK;
#else
            return SysAllocStringFromSz(szURL, 0, pbstrName, m_wCodePage);
#endif
        }

        default:
            return E_FAIL;
    }
}

/*  ****************************************************************************
    IDebugDocumentText implementation
*/

/*  ============================================================================
    CTemplate::GetSize
    Return the number of lines & characters in the document
*/
HRESULT CTemplate::GetSize
(
/* [out] */ ULONG *pcLines,
/* [out] */ ULONG *pcChars
)
    {
    /*
     * NOTE: compilation is done in two phases.
     *          Errors are detected and reported in phase 1.
     *          The DBCS mapping is created in phase 2.
     *
     * If an error occurred during compilation, m_cChars will be equal to zero
     * (Since zero length files are not compiled, m_cChars == 0 means "size
     * is unknown", not "size is zero").
     */
    if (m_rgpFilemaps[0]->m_cChars == 0)
        {
        // Likely need to remap the file, then count
        BOOL fRemapTemplate = !m_rgpFilemaps[0]->FIsMapped();
        if (fRemapTemplate)
            TRY
                m_rgpFilemaps[0]->RemapFile();
            CATCH (dwException)
                return E_FAIL;
            END_TRY

        m_rgpFilemaps[0]->CountChars((WORD)m_wCodePage);

        if (fRemapTemplate)
            TRY
                m_rgpFilemaps[0]->UnmapFile();
            CATCH (dwException)
                return E_FAIL;
            END_TRY

        // let's hope client is not relying on # of lines - expensive to compute

        *pcChars = m_rgpFilemaps[0]->m_cChars;
        *pcLines = ULONG_MAX;
        }
    else
        {
        /* The last line in the line mapping array of each engine is the <<EOF>> line
         * for that engine.  Therefore, the # of lines is the largest <<EOF>> line
         * number - 1.  The EOF line always points into the main file, so there are no
         * include file glitches here.
         */
        ULONG cLinesMax = 0;
        for (UINT i = 0; i < m_cScriptEngines; ++i)
            {
            ULONG cLinesCurrentEngine = m_rgrgSourceInfos[0][m_rgrgSourceInfos[0].length() - 1].m_idLine - 1;
            if (cLinesCurrentEngine > cLinesMax)
                cLinesMax = cLinesCurrentEngine;
            }

        *pcLines = cLinesMax;
        *pcChars = m_rgpFilemaps[0]->m_cChars;
        }

    IF_DEBUG(SCRIPT_DEBUGGER) {
#if UNICODE
		DBGPRINTF((DBG_CONTEXT, "GetSize(\"%S\") returns %lu characters (%lu lines)\n", m_rgpFilemaps[0]->m_szPathTranslated, *pcChars, *pcLines));
#else
		DBGPRINTF((DBG_CONTEXT, "GetSize(\"%s\") returns %lu characters (%lu lines)\n", m_rgpFilemaps[0]->m_szPathTranslated, *pcChars, *pcLines));
#endif
    }

    return S_OK;
}

/*  ============================================================================
    CTemplate::GetDocumentAttributes
    Return doc attributes
*/
HRESULT CTemplate::GetDocumentAttributes
(
/* [out] */ TEXT_DOC_ATTR *ptextdocattr
)
    {
    // Easy way to tell debugger that we don't support editing.
    *ptextdocattr = TEXT_DOC_ATTR_READONLY;
    return S_OK;
    }

/*  ============================================================================
    CTemplate::GetPositionOfLine
    From a line number, return the character offset of the beginning
*/
HRESULT CTemplate::GetPositionOfLine
(
/* [in] */ ULONG cLineNumber,
/* [out] */ ULONG *pcCharacterPosition
)
    {
    return GetPositionOfLine(m_rgpFilemaps[0], cLineNumber, pcCharacterPosition);
    }

/*  ============================================================================
    CTemplate::GetLineOfPosition
    From a character offset, return the line number and offset within the line
*/
HRESULT CTemplate::GetLineOfPosition
(
/* [in] */ ULONG cCharacterPosition,
/* [out] */ ULONG *pcLineNumber,
/* [out] */ ULONG *pcCharacterOffsetInLine
)
    {
    return GetLineOfPosition(m_rgpFilemaps[0], cCharacterPosition, pcLineNumber, pcCharacterOffsetInLine);
    }

/*  ============================================================================
    CTemplate::GetText
    From a character offset and length, return the document text
*/
HRESULT CTemplate::GetText
(
ULONG cchSourceOffset,
WCHAR *pwchText,
SOURCE_TEXT_ATTR *pTextAttr,
ULONG *pcChars,
ULONG cMaxChars
)
    {
    return m_rgpFilemaps[0]->GetText((WORD)m_wCodePage, cchSourceOffset, pwchText, pTextAttr, pcChars, cMaxChars);
    }

/*  ============================================================================
    CTemplate::GetPositionOfContext
    Decompose a document context into the document offset & length
*/
HRESULT CTemplate::GetPositionOfContext
(
/* [in] */ IDebugDocumentContext *pUnknownDocumentContext,
/* [out] */ ULONG *pcchSourceOffset,
/* [out] */ ULONG *pcchText
)
    {
    // Make sure that the context is one of ours
    CTemplateDocumentContext *pDocumentContext;
    if (FAILED(pUnknownDocumentContext->QueryInterface(IID_IDenaliTemplateDocumentContext, reinterpret_cast<void **>(&pDocumentContext))))
        return E_FAIL;

    if (pcchSourceOffset)
        *pcchSourceOffset = pDocumentContext->m_cchSourceOffset;

    if (pcchText)
        *pcchText = pDocumentContext->m_cchText;

    pDocumentContext->Release();
    return S_OK;
    }

/*  ============================================================================
    CTemplate::GetContextOfPosition
    Given the character position & number of characters in the document,
    encapsulate this into a document context object.
*/
HRESULT CTemplate::GetContextOfPosition
(
/* [in] */ ULONG cchSourceOffset,
/* [in] */ ULONG cchText,
/* [out] */ IDebugDocumentContext **ppDocumentContext
)
    {
    if (
        (*ppDocumentContext = new CTemplateDocumentContext(this, cchSourceOffset, cchText))
        == NULL
       )
        return E_OUTOFMEMORY;

    return S_OK;
    }

/*  ****************************************************************************
    IConnectionPointContainer implementation
*/

/*  ============================================================================
    CTemplate::FindConnectionPoint
    From a character offset and length, return the document text
*/
HRESULT CTemplate::FindConnectionPoint
(
const GUID &uidConnection,
IConnectionPoint **ppCP
)
    {
    if (uidConnection == IID_IDebugDocumentTextEvents)
        return m_CPTextEvents.QueryInterface(IID_IConnectionPoint, reinterpret_cast<void **>(ppCP));
    else
        {
        *ppCP = NULL;
        return E_NOINTERFACE;
        }
    }

/*  ============================================================================
    CTemplate::AttachTo
    attach this to the debugger UI tree view.
*/
HRESULT CTemplate::AttachTo
(
CAppln *pAppln
)
    {
    if (!m_fDontAttach && pAppln->FDebuggable())
        {
        // If we are already attached to this application, then ignore 2nd request
        CDblLink *pNodeCurr = m_listDocNodes.PNext();
        while (pNodeCurr != &m_listDocNodes)
            {
            if (pAppln == static_cast<CDocNodeElem *>(pNodeCurr)->m_pAppln)
                return S_OK;

            pNodeCurr = pNodeCurr->PNext();
            }

        // Create the node and store it in the linked list.
        HRESULT hr;
        IDebugApplicationNode *pDocRoot;
        CDocNodeElem *pDocNodeElem;

        // Create a document tree, showing the include file hierarchy
        if (FAILED(hr = CreateDocumentTree(m_rgpFilemaps[0], &pDocRoot)))
            return hr;

        if (FAILED(hr = pDocRoot->Attach(pAppln->PAppRoot())))
            return hr;

        if ((pDocNodeElem = new CDocNodeElem(pAppln, pDocRoot)) == NULL)
            return E_OUTOFMEMORY;

        pDocNodeElem->AppendTo(m_listDocNodes);
        pDocRoot->Release();
        m_fDebuggable = TRUE;
        }

    return S_OK;
    }

/*  ============================================================================
    CTemplate::DetachFrom
    detach this from the debugger UI tree view.
*/
HRESULT CTemplate::DetachFrom
(
CAppln *pAppln
)
    {
    // Enter the CS to prevent Detach() from detaching while we are scanning
    // the list (causes application ptr to be deleted twice if this occurs)
    DBG_ASSERT(m_fDebuggerDetachCSInited);
    EnterCriticalSection(&m_csDebuggerDetach);

    // Look for the node that has this application
    CDblLink *pNodeCurr = m_listDocNodes.PNext();
    while (pNodeCurr != &m_listDocNodes)
        {
        if (pAppln == static_cast<CDocNodeElem *>(pNodeCurr)->m_pAppln)
            break;

        pNodeCurr = pNodeCurr->PNext();
        }

    // If not found (pNodeCurr points back to head), then fail
    if (pNodeCurr == &m_listDocNodes)
        {
        LeaveCriticalSection(&m_csDebuggerDetach);
        return E_FAIL;
        }

    // Detach the node by deleting the current element
    delete pNodeCurr;

    // Turn off "Debuggable" flag if last application is detached
    m_fDebuggable = !m_listDocNodes.FIsEmpty();

    // At this point CS not needed
    LeaveCriticalSection(&m_csDebuggerDetach);

    // If we have just removed ourselves from the last application,
    // then we call Detach(), to remove all cached script engines now.
    if (!m_fDebuggable)
         Detach();

    return S_OK;
    }

/*  ============================================================================
    CTemplate::Detach
    detach this from the debugger UI tree view.
*/
HRESULT CTemplate::Detach
(
)
    {
    // Enter the CS to prevent DetachFrom() from detaching while we are clearing
    // the list (causes application ptr to be deleted twice if this occurs)
    if (m_fDebuggerDetachCSInited)
                EnterCriticalSection(&m_csDebuggerDetach);

    // Detach all nodes
    while (! m_listDocNodes.FIsEmpty())
        delete m_listDocNodes.PNext();

    // Done with CS
    if (m_fDebuggerDetachCSInited)
                LeaveCriticalSection(&m_csDebuggerDetach);

    // Since we are not debuggable now, remove any script engines we may
    // be holding on to.  If we are detaching from change notification
    // thread, queue engines to be released from debugger thread.
    //
    if (m_rgpDebugScripts)
        {
        Assert (g_dwDebugThreadId != 0);
        BOOL fCalledFromDebugActivity = GetCurrentThreadId() == g_dwDebugThreadId;

        for (UINT i = 0; i < m_cScriptEngines; i++)
            {
            CActiveScriptEngine *pEngine = m_rgpDebugScripts[i];
            if (pEngine)
                {
                if (fCalledFromDebugActivity)
                    {
                    pEngine->FinalRelease();
                    }
                else
                    {
                    g_ApplnMgr.AddEngine(pEngine);
                    pEngine->Release();
                    }
                }
            }
        delete[] m_rgpDebugScripts;
        m_rgpDebugScripts = NULL;
        }

    m_fDebuggable = FALSE;
    return S_OK;
    }

/*  ============================================================================
    CTemplate::CreateDocumentTree
    Traverse the tree that we have embedded in the filemap structures,
    and use it to create the include file structure
*/
HRESULT CTemplate::CreateDocumentTree
(
CFileMap *pfilemapRoot,
IDebugApplicationNode **ppDocRoot
)
    {
    IDebugApplicationNode *pDocNode;
    HRESULT hr = S_OK;

    if (pfilemapRoot == NULL || ppDocRoot == NULL)
        return E_POINTER;

    // Create the root node
    if (FAILED(hr = g_pDebugApp->CreateApplicationNode(ppDocRoot)))
        return hr;

    // From the filemap information, match it up with the correct provider
    //  "This" is the provider for the root document, others come from Inc file cache
    if (pfilemapRoot == m_rgpFilemaps[0])
        {
        if (FAILED(hr = (*ppDocRoot)->SetDocumentProvider(this)))
            return hr;
        }
    else
        {
        CIncFile *pIncFile;
        if (FAILED(hr = g_IncFileMap.GetIncFile(pfilemapRoot->m_szPathTranslated, &pIncFile)))
            return hr;

        if (FAILED(hr = (*ppDocRoot)->SetDocumentProvider(pIncFile)))
            return hr;

        // SetDocumentProvider AddRef'ed
        pIncFile->Release();
        }

    // Create a node from all of the children and attach it to this node
    CFileMap *pfilemapChild = pfilemapRoot->m_pfilemapChild;
    while (pfilemapChild != NULL)
        {
        IDebugApplicationNode *pDocChild;
        if (FAILED(hr = CreateDocumentTree(pfilemapChild, &pDocChild)))
            return hr;

        if (FAILED(hr = pDocChild->Attach(*ppDocRoot)))
            return hr;

        pfilemapChild = pfilemapChild->m_fHasSibling? pfilemapChild->m_pfilemapSibling : NULL;
        }

    return S_OK;
    }

/*  ============================================================================
    CTemplate::End

    Place template in non-usable state (after this is called, last ref. should
    be the any currently executing scripts.  The count will naturally vanish
    as the scripts finish.  The template should never be recycled in cache after
    this call.)

    REF COUNTING NOTE:
        Since debugging client has a reference to the template, the template needs
        to dis-associate with the debugger at a point in time before destruction.
        Otherwise, the reference will never go to zero.
*/
ULONG
CTemplate::End
(
)
    {
    // Flag template as non-usable (for debugging)
    m_fIsValid = FALSE;

    Detach();

    if (!m_CPTextEvents.FIsEmpty() && g_pDebugApp != NULL)
        {
        IEnumConnections *pConnIterator;
        if (SUCCEEDED(m_CPTextEvents.EnumConnections(&pConnIterator)))
            {
            CONNECTDATA ConnectData;
            while (pConnIterator->Next(1, &ConnectData, NULL) == S_OK)
                {
                IDebugDocumentTextEvents *pTextEventSink;
                if (SUCCEEDED(ConnectData.pUnk->QueryInterface(IID_IDebugDocumentTextEvents, reinterpret_cast<void **>(&pTextEventSink))))
                    {
                    InvokeDebuggerWithThreadSwitch(g_pDebugApp, DEBUGGER_ON_DESTROY, pTextEventSink);
                    pTextEventSink->Release();
                    }
                ConnectData.pUnk->Release();
                }

            pConnIterator->Release();
            }
        }

    return Release();
    }

/*  ============================================================================
    CTemplate::NotifyDebuggerOnPageEvent
    Let debugger know about page start/end
*/
HRESULT
CTemplate::NotifyDebuggerOnPageEvent
(
BOOL fStart     // TRUE = StartPage, FALSE = EndPage
)
    {
    CTemplateDocumentContext *pDebugContext = new CTemplateDocumentContext(this, 0, 0);
    if (pDebugContext == NULL)
        return E_OUTOFMEMORY;

    HRESULT hr = S_OK;

    if (g_pDebugApp)
        hr = InvokeDebuggerWithThreadSwitch
            (
            g_pDebugApp,
            fStart ? DEBUGGER_EVENT_ON_PAGEBEGIN : DEBUGGER_EVENT_ON_PAGEEND,
            static_cast<IUnknown *>(pDebugContext)
            );

    pDebugContext->Release();
    return hr;
    }

/*  ============================================================================
    CTemplate::ReleaseTypeLibs
    Release all typelibs collected from metadata
*/
void
CTemplate::ReleaseTypeLibs()
    {
    if (m_rgpTypeLibs.length() > 0)
        {
        for (UINT i = 0; i < m_rgpTypeLibs.length(); i++)
            {
            m_rgpTypeLibs[i]->Release();
            }

        m_rgpTypeLibs.reshape(0);
        }
    }

/*  ============================================================================
    CTemplate::WrapTypeLibs
    Wrap all typelibs collected from metadata into single IDispatch *
*/
void
CTemplate::WrapTypeLibs(CHitObj *pHitObj)
    {
    HRESULT hr = S_OK;

    Assert(m_pdispTypeLibWrapper == NULL);

    if (m_rgpTypeLibs.length() > 0)
        {
        hr = ::WrapTypeLibs
            (
            m_rgpTypeLibs.begin(),
            m_rgpTypeLibs.length(),
            &m_pdispTypeLibWrapper
            );

        ReleaseTypeLibs();
        }

    if (FAILED(hr))
        {
        m_pbErrorLocation = NULL;
        m_idErrMsg = IDE_TEMPLATE_WRAP_TYPELIB_FAILED;
        ProcessSpecificError(*(m_rgpFilemaps[0]), pHitObj);
        THROW(E_TEMPLATE_COMPILE_FAILED_DONT_CACHE);
        }
    }

/*  ============================================================================
    CTemplate::Release449
    Release all 449-echo-cookie objects collected from metadata
*/
void
CTemplate::Release449()
    {
    if (m_rgp449.length() > 0)
        {
        for (UINT i = 0; i < m_rgp449.length(); i++)
            {
            m_rgp449[i]->Release();
            }

        m_rgp449.reshape(0);
        }
    }

/*  ============================================================================
    CTemplate::Do449Processing
    Generate 449 response in cookie negotiations with IE when needed
*/
HRESULT
CTemplate::Do449Processing
(
CHitObj *pHitObj
)
    {
    if (m_rgp449.length() == 0 || pHitObj->F449Done())
        return S_OK;

    HRESULT hr = ::Do449Processing
        (
        pHitObj,
        m_rgp449.begin(),
        m_rgp449.length()
        );

    pHitObj->Set449Done();
    return hr;
    }
#if 0
/*  ============================================================================
    CTemplate::OutputDebugTables
    print the debugging data structures to the debug window
*/
void
CTemplate::OutputDebugTables()
    {
    unsigned        i, j;
    wchar_t         wszDebugLine[256];
    CWCharToMBCS    convTarget;
    CWCharToMBCS    convSource;

    // print line mapping table

    DBGPRINTF((DBG_CONTEXT, "\nEngine HTML? Line# SourceOffset Length TargetOffset TargetText__________ SourceText__________ File\n"));

    for (i = 0; i < m_cScriptEngines; ++i)
        for (j = 0; j < m_rgrgSourceInfos[i].length(); ++j)
            {
            wchar_t wszSourceText[SNIPPET_SIZE + 1], wszTargetText[SNIPPET_SIZE + 1];
            CSourceInfo *pSourceInfo = &m_rgrgSourceInfos[i][j];

            // DON'T display sample script text on last line of each engine
            if (j == m_rgrgSourceInfos[i].length() - 1)
                {
                wszTargetText[0] = 0;
                wszSourceText[0] = 0;
                }
            else
                {
                // Get source & target text sample
                GetScriptSnippets(
                                pSourceInfo->m_cchSourceOffset, pSourceInfo->m_pfilemap,
                                pSourceInfo->m_cchTargetOffset, i,
                                wszSourceText, wszTargetText
                                 );

                // Actually display each line
#if 0
#ifndef _NO_TRACING_
                convTarget.Init(wszTargetText);
                convSource.Init(wszSourceText);

                DBGINFO((DBG_CONTEXT,
                         "%-6d %-5s %-5d %-12d %-6d %-12d %-20s %-20s %s\n",
                         i,
                         pSourceInfo->m_fIsHTML? "Yes" : "No",
                         pSourceInfo->m_idLine,
                         pSourceInfo->m_cchSourceOffset,
                         pSourceInfo->m_cchSourceText,
                         pSourceInfo->m_cchTargetOffset,
                         convTarget.GetString(),
                         convSource.GetString(),
                         pSourceInfo->m_pfilemap->m_szPathTranslated));
#else
                CMBCSToWChar    convPath;
                convPath.Init(pSourceInfo->m_pfilemap->m_szPathTranslated);
                wsprintfW(
                        wszDebugLine,
                        L"%-6d %-5s %-5d %-12d %-6d %-12d %-20s %-20s %s\n",
                        i,
                        pSourceInfo->m_fIsHTML? L"Yes" : L"No",
                        pSourceInfo->m_idLine,
                        pSourceInfo->m_cchSourceOffset,
                        pSourceInfo->m_cchSourceText,
                        pSourceInfo->m_cchTargetOffset,
                        wszTargetText,
                        wszSourceText,
                        convPath.GetString());

                OutputDebugStringW(wszDebugLine);
#endif
#endif
            }
            }

        OutputDebugStringA("\n\n");

    for (i = 0; i < m_cFilemaps; ++i)
        {
        CFileMap *pFilemap = m_rgpFilemaps[i];

#if UNICODE
        DBGPRINTF((DBG_CONTEXT, "DBCS mapping table for File %S:\n", pFilemap->m_szPathTranslated));
#else
        DBGPRINTF((DBG_CONTEXT, "DBCS mapping table for File %s:\n", pFilemap->m_szPathTranslated));
#endif
        DBGPRINTF((DBG_CONTEXT, "ByteOffset CharOffset\n"));

        for (COffsetInfo *pOffsetInfo = pFilemap->m_rgByte2DBCS.begin();
             pOffsetInfo < pFilemap->m_rgByte2DBCS.end();
             ++pOffsetInfo)
            DebugPrintf("%-10d %-10d\n", pOffsetInfo->m_cbOffset, pOffsetInfo->m_cchOffset);

        DBGPRINTF((DBG_CONTEXT, "\n\n"));
    }

    DBGPRINTF((DBG_CONTEXT, "Include File Hierarchy\n"));
    OutputIncludeHierarchy(m_rgpFilemaps[0], 0);
    DBGPRINTF((DBG_CONTEXT, "\n"));
}

/*  ============================================================================
    CTemplate::OutputIncludeHierarchy
    print the lineage information that we keep around for include files.
    Print all nodes on one level at the current indentation, then descend for
    nested includes.
*/

void
CTemplate::OutputIncludeHierarchy
(
CFileMap*   pfilemap,
int         cchIndent
)
    {
    TCHAR szDebugString[256], *pchEnd;

    for (;;)
        {
        pchEnd = szDebugString;
        for (int i = 0; i < cchIndent; ++i)
            *pchEnd++ = _T(' ');

        pchEnd = strcpyEx(pchEnd, pfilemap->m_szPathTranslated);
        *pchEnd++ = _T('\n');
        *pchEnd = _T('\0');

        DBGPRINTF((DBG_CONTEXT, szDebugString));

        // Print anything that this file includes
        if (pfilemap->m_pfilemapChild)
            OutputIncludeHierarchy(pfilemap->m_pfilemapChild, cchIndent + 3);

        // Stop when there are no more siblings on this level
        if (! pfilemap->m_fHasSibling)
            break;

        // Advance to next sibling
        pfilemap = pfilemap->m_pfilemapSibling;
        }
    }

/*  ============================================================================
    CTemplate::OutputScriptSnippets
    print some script from both the source offset & its corresponding target.
    Good way to visually see if the offset conversions are working.
*/

void
CTemplate::GetScriptSnippets
(
ULONG cchSourceOffset,
CFileMap *pFilemapSource,
ULONG cchTargetOffset,
ULONG idTargetEngine,
wchar_t *wszSourceText,
wchar_t *wszTargetText
)
    {
    // Get target text sample
    if (wszTargetText)
        {
        char *szEngineName;
        PROGLANG_ID *pProgLangID;
        const wchar_t *wszScriptText;

        GetScriptBlock(idTargetEngine, &szEngineName, &pProgLangID, &wszScriptText);
        wszScriptText += cchTargetOffset;
        int cch = wcslen(wszScriptText);
        wcsncpy(wszTargetText, wszScriptText, min(cch, SNIPPET_SIZE) + 1);
        wszTargetText[min(cch, SNIPPET_SIZE)] = 0;

        // Convert newlines to space
        wchar_t *pwch = wszTargetText;
        while (*pwch != 0)
            if (iswspace(*pwch++))
                pwch[-1] = ' ';
        }

    // Get source text sample
    if (wszSourceText)
        {
        ULONG cchMax = 0;
        pFilemapSource->GetText((WORD)m_wCodePage, cchSourceOffset, wszSourceText, NULL, &cchMax, SNIPPET_SIZE);
        wszSourceText[cchMax] = 0;

        // Convert newlines to space
        wchar_t *pwch = wszSourceText;
        while (*pwch != 0)
            if (iswspace(*pwch++))
                pwch[-1] = ' ';
        }
    }
#endif
/*  ============================================================================
    CTemplate::BuildPersistedDACL

    Builds a DACL based on the SECURITY_DESCRIPTOR already
    associated with the template.  The PersistedDACL is modified to include
    full access for administrators and delete access for everyone.
*/

HRESULT  CTemplate::BuildPersistedDACL(PACL  *ppRetDACL)
{
    HRESULT                     hr = S_OK;
    BOOL                        bDaclPresent;
    BOOL                        bDaclDefaulted;
    PACL                        pSrcDACL = NULL;
    EXPLICIT_ACCESS             ea;
    SID_IDENTIFIER_AUTHORITY    WorldAuthority = SECURITY_WORLD_SID_AUTHORITY;

    *ppRetDACL = NULL;

    ZeroMemory(&ea, sizeof(EXPLICIT_ACCESS));

    ea.grfAccessPermissions = SYNCHRONIZE | DELETE;
    ea.grfAccessMode = GRANT_ACCESS;
    ea.grfInheritance= SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    ea.Trustee.TrusteeForm = TRUSTEE_IS_SID;

    if (m_rgpFilemaps[0]->m_pSecurityDescriptor == NULL) {
        return S_OK;
    }

    if (!AllocateAndInitializeSid(&WorldAuthority,
                                  1,
                                  SECURITY_WORLD_RID,
                                  0,0,0,0,0,0,0,
                                  (PSID *)(&ea.Trustee.ptstrName)))

        hr = HRESULT_FROM_WIN32(GetLastError());

    else if (!GetSecurityDescriptorDacl(m_rgpFilemaps[0]->m_pSecurityDescriptor,
                                   &bDaclPresent,
                                   &pSrcDACL,
                                   &bDaclDefaulted))

        hr = HRESULT_FROM_WIN32(GetLastError());

    else if ((hr = SetEntriesInAcl(1, 
                                   &ea, 
                                   bDaclPresent ? pSrcDACL : NULL, 
                                   ppRetDACL)) != ERROR_SUCCESS)

        hr = HRESULT_FROM_WIN32(hr);

    if (ea.Trustee.ptstrName)
        FreeSid(ea.Trustee.ptstrName);

    return hr;
}

/*  ============================================================================
    CTemplate::PersistData
    Attempts to write the contents of the template memory to disk.  Note that
    the memory isn't freed here but later when the template ref count falls to
    1 (indicating that the only reference to the template is the one that the
    cache has on it).
*/

HRESULT  CTemplate::PersistData(char    *pszTempFilePath)
{
    HRESULT                 hr = S_OK;
    DWORD                   winErr = 0;
    HANDLE                  hFile = NULL;
    DWORD                   dwWritten;
    HANDLE                  hImpersonationToken = NULL;
    HANDLE                  hThread;
    PACL                    pPersistDACL = NULL;

#if DBG_PERSTEMPL    
    DBGPRINTF((DBG_CONTEXT, 
               "CTemplate::PersistData() enterred.\n\tTemplate is %s\n\tPersistTempName is %s\n",
               GetSourceFileName(),
               m_szPersistTempName ? m_szPersistTempName : "<none>"));
#endif
              
    // if for some reason this template has been marked as invalid, then it is
    // not persistable

    if (m_fIsValid == FALSE) {
        hr = E_FAIL;
        goto end;
    }

    // if it is already persisted, there is nothing to do

    if (m_fIsPersisted) {
        goto end;
    }

    // check to see if we already have a persist temp name.  If a template moves
    // from the persisted cache back to the memory cache, then the persisted flag
    // will have been lifted but the cache name will remain as an optimization for
    // future persisting.

    if (m_szPersistTempName == NULL) {

        hThread = GetCurrentThread();

        if (OpenThreadToken( hThread,
                             TOKEN_READ | TOKEN_IMPERSONATE,
                             TRUE,           
                             &hImpersonationToken )) {

           RevertToSelf();
        }

        // allocate memory for this temp path
    
        if (!(m_szPersistTempName = (LPSTR)CTemplate::LargeMalloc(MAX_PATH))) {
            hr = E_OUTOFMEMORY;
        }

        // create the temp file.  The location of the temp directory was passed
        // in as an argument.  The resulting tempfile name in m_szPersistTempName
        // will include this path.

        else if (GetTempFileNameA(pszTempFilePath,
                                 "ASPTemplate",
                                 0,
                                 m_szPersistTempName) == 0) {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }

        // build a security descriptor to use with this persisted file.  It is
        // comprised of the .asp's security descriptor plus a couple of DACLs
        // to allow administrators full access and everyone delete access.

        else if (FAILED(hr = BuildPersistedDACL(&pPersistDACL)));

        else if (pPersistDACL
                 && (winErr = SetNamedSecurityInfoA((LPSTR)m_szPersistTempName,
                                                    SE_FILE_OBJECT,
                                                    DACL_SECURITY_INFORMATION,
                                                    NULL,
                                                    NULL,
                                                    pPersistDACL,
                                                    NULL)))
            hr = HRESULT_FROM_WIN32(winErr);

        // create the file

        else if ((hFile = CreateFileA(m_szPersistTempName, 
                                     GENERIC_WRITE,
                                     0,
                                     NULL,
                                     CREATE_ALWAYS,
                                     FILE_ATTRIBUTE_NORMAL,
                                     NULL)) == INVALID_HANDLE_VALUE) {

            hr = HRESULT_FROM_WIN32(GetLastError());
        }

        // slam out the entire contents of the template memory to the file

        else if (WriteFile(hFile,
                           m_pbStart,
                           m_cbTemplate,
                           &dwWritten,
                           NULL) == 0) {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }

        // close

        else if (CloseHandle(hFile) == 0) {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }
        else {
            hFile = NULL;
        }
        if (FAILED(hr));

        // make sure that the entire amount was written out

        else if (dwWritten != m_cbTemplate) {
            hr = E_FAIL;
        }

        if (hImpersonationToken) {
            SetThreadToken(&hThread, hImpersonationToken);
            CloseHandle(hImpersonationToken);
        }
    }
    
    if (FAILED(hr));

    else {

        // if successfull, then note that the template is now persisted.
        // Do an AddRef and Release as a safe way to check to see if the
        // template memory can be freed.
        
        m_fIsPersisted = TRUE;
        AddRef();
        Release();
    }
    
    // if errors occurred, clean up any resources.

    if (hr != S_OK) {
        if (hFile)
            CloseHandle(hFile);
        if (m_szPersistTempName)
            CTemplate::LargeFree(m_szPersistTempName);
        m_szPersistTempName = NULL;
    }

    // free the persisted SECURITY_DESCRIPTOR if allocated

    if (pPersistDACL) {
        LocalFree(pPersistDACL);
    }

end:

#if DBG_PERSTEMPL
    if (hr == S_OK) {
        DBGPRINTF((DBG_CONTEXT,
                   "Persist Successful.  TempName is %s\n",
                   m_szPersistTempName));
    }
    else {
        DBGPRINTF((DBG_CONTEXT,
                   "Persist failed.  hr = %x",
                   hr));
    }
#endif

    return hr;
}

/*  ============================================================================
    CTemplate::UnPersistData
    Restores the template memory from disk.
*/

HRESULT  CTemplate::UnPersistData()
{
    HRESULT     hr = S_OK;
    HANDLE      hFile = NULL;
    DWORD       dwRead;
    HANDLE      hImpersonationToken = NULL;
    HANDLE      hThread;

#if DEB_PERSTEMPL
    DBGPRINTF((DBG_CONTEXT,
               "CTemplate::UnPersistData() enterred.\n\tTemplate is %s\n\tTempName is %s\n",
               m_rgpFilemaps[0]->m_szPathTranslated,
               m_szPersistTempName));
#endif

    // check to see if the template is already loaded into memory.  If so, then
    // all this routine needs to do is lift the IsPersisted flag.

    if (m_pbStart != NULL) {
        m_fIsPersisted = FALSE;
        goto end;
    }

    hThread = GetCurrentThread();

    if (OpenThreadToken( hThread,
                         TOKEN_READ | TOKEN_IMPERSONATE,
                         TRUE,           
                         &hImpersonationToken )) {

       RevertToSelf();
    }

    // open the temp file for read

    if ((hFile = CreateFileA(m_szPersistTempName, 
                            GENERIC_READ,
                            0,
                            NULL,
                            OPEN_EXISTING,
                            0,
                            NULL)) == INVALID_HANDLE_VALUE) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    // allocate the template memory

    else if (!(m_pbStart = (BYTE *)CTemplate::LargeMalloc(m_cbTemplate))) {
        hr = E_OUTOFMEMORY;
    }

    // read in the entire file

    else if (ReadFile(hFile,
                      m_pbStart,
                      m_cbTemplate,
                      &dwRead,
                      NULL) == 0) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    // we're done with the file

    else if (CloseHandle(hFile) == 0) {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    else {
        hFile = NULL;
    }

    if (FAILED(hr));

    // check to make sure we got everything

    else if (m_cbTemplate != dwRead) {
        hr = E_FAIL;
    }
    else {

        // if not, pretend like this is no longer persisted.  Prevents errors
        // in the future.

        m_fIsPersisted = FALSE;
    }

    if (hr != S_OK) {

        // make sure that the file handle was cleaned up

        if (hFile)
            CloseHandle(hFile);
    }
end:

    if (hImpersonationToken) {
        SetThreadToken(&hThread, hImpersonationToken);
        CloseHandle(hImpersonationToken);
    }

#if DBG_PERSTEMPL
    if (hr == S_OK) {
        DBGPRINTF((DBG_CONTEXT,
                   "UnPersist Successful\n"));
    }
    else {
        DBGPRINTF((DBG_CONTEXT,
                   "UnPersist failed.  hr = %x",
                   hr));
    }
#endif

    return hr;
}

/*  ============================================================================
    CTemplate::PersistCleanup
    Cleans up the temp file and the memory holding the temp file name.
*/

HRESULT CTemplate::PersistCleanup()
{
    HRESULT     hr = S_OK;
    HANDLE      hImpersonationToken = NULL;
    HANDLE      hThread;

    if (m_szPersistTempName == NULL) {
        return (S_OK);
    }


    hThread = GetCurrentThread();

    if (OpenThreadToken( hThread,
                         TOKEN_READ | TOKEN_IMPERSONATE,
                         TRUE,           
                         &hImpersonationToken )) {

       RevertToSelf();
    }

    if (DeleteFileA(m_szPersistTempName) == 0) {
        hr = GetLastError();
    }
    else {
        m_fIsPersisted = FALSE;
        CTemplate::LargeFree(m_szPersistTempName);
        m_szPersistTempName = NULL;
    }   

    if (hImpersonationToken) {
        SetThreadToken(&hThread, hImpersonationToken);
        CloseHandle(hImpersonationToken);
    }

    return hr;
}


/*  ============================================================================
    CTemplate::CreateTransServiceConfig
    Creates the ServicesConfig object for a transacted page
*/

HRESULT CTemplate::CreateTransServiceConfig(BOOL fEnableTracker)
{
    HRESULT                     hr;
    IServiceInheritanceConfig   *pIInheritConfig = NULL;
    IServiceTransactionConfig   *pITransConfig = NULL;
    IServiceTrackerConfig       *pITracker = NULL;

    // see if there is any reason to create the object...

    if ((fEnableTracker == FALSE) && (m_ttTransacted == ttUndefined)) {
        return S_OK;
    }

	hr = CoCreateInstance(CLSID_CServiceConfig, 
                          NULL, 
                          CLSCTX_INPROC_SERVER, 
                          IID_IUnknown, 
                          (void **)&m_pServicesConfig); 
    if (FAILED(hr)) {
		DBGWARN((DBG_CONTEXT, "CTemplate::CreateTransServiceConfig() - Could not CCI ServicesConfig, hr = %#08x\n", hr));
		goto LCleanup;
    }

    hr = m_pServicesConfig->QueryInterface(IID_IServiceInheritanceConfig, (void **)&pIInheritConfig);
    if (FAILED(hr)) {
		DBGWARN((DBG_CONTEXT, "CTemplate::CreateTransServiceConfig() - Could not QI for IServiceInheritanceConfig, hr = %#08x\n", hr));
		goto LCleanup;
    }

    hr = pIInheritConfig->ContainingContextTreatment(CSC_Inherit);
    if (FAILED(hr)) {
		DBGWARN((DBG_CONTEXT, "CTemplate::CreateTransServiceConfig() - Could not set Inherit mode, hr = %#08x\n", hr));
		goto LCleanup;
    }

    if (m_ttTransacted != ttUndefined) {

        CSC_TransactionConfig   transConfig;

        switch (m_ttTransacted) {
            case ttNotSupported:
                transConfig = CSC_NoTransaction;
                break;
            case ttSupported:
                transConfig = CSC_IfContainerIsTransactional;
                break;
            case ttRequired:
                transConfig = CSC_CreateTransactionIfNecessary;
                break;
            case ttRequiresNew:
                transConfig = CSC_NewTransaction;
                break;
        }

        hr = m_pServicesConfig->QueryInterface(IID_IServiceTransactionConfig, (void **)&pITransConfig);
        if (FAILED(hr)) {
		    DBGWARN((DBG_CONTEXT, "CTemplate::CreateTransServiceConfig() - Could not QI for IID_IServiceTransactionConfig, hr = %#08x\n", hr));
		    goto LCleanup;
        }

        hr = pITransConfig->ConfigureTransaction(transConfig);
        if (FAILED(hr)) {
		    DBGWARN((DBG_CONTEXT, "CTemplate::CreateTransServiceConfig() - Could not set transaction type, hr = %#08x\n", hr));
		    goto LCleanup;
        }
    }

    if (fEnableTracker) {
        hr = m_pServicesConfig->QueryInterface(IID_IServiceTrackerConfig, (void **)&pITracker);
        if (FAILED(hr)) {
		    DBGWARN((DBG_CONTEXT, "CTemplate::CreateTransServiceConfig() - Could not QI for IID_IServiceTrackerConfig, hr = %#08x\n", hr));
		    goto LCleanup;
        }
        LPWSTR  pwszAppURL;
        LPWSTR  pwszASPName;
#if UNICODE
        pwszAppURL = m_szApplnVirtPath;
        pwszASPName = GetSourceFileName(SOURCEPATHTYPE_VIRTUAL);
#else
        CMBCSToWChar    convAppln;
        CMBCSToWChar    convASPName;

        hr = convAppln.Init(m_szApplnVirtPath);
        if (FAILED(hr)) {
            goto LCleanup;
        }
        hr = convASPName.Init(GetSourceFileName(SOURCEPATHTYPE_VIRTUAL));
        if (FAILED(hr)) {
            goto LCleanup;
        }
        pwszAppURL = convAppln.GetString();
        pwszASPName = convASPName.GetString();
#endif
        pwszASPName += wcslen(pwszAppURL) + 1;

        hr = pITracker->TrackerConfig(CSC_UseTracker, pwszAppURL, pwszASPName);
        if (FAILED(hr)) {
		    DBGWARN((DBG_CONTEXT, "CTemplate::CreateTransServiceConfig() - Could not set Inherit mode, hr = %#08x\n", hr));
		    goto LCleanup;
        }
    }
LCleanup:

    if (pIInheritConfig)
        pIInheritConfig->Release();

    if (pITransConfig)
        pITransConfig->Release();

    return hr;
}

/*  ****************************************************************************
    CIncFile member functions
*/

/*  ============================================================================
    CIncFile::CIncFile
    Constructor

    Returns:
        Nothing
    Side effects:
        None
*/
CIncFile::CIncFile
(
)
: m_szIncFile(NULL),
  m_fCsInited(FALSE),
  m_CPTextEvents(this, IID_IDebugDocumentTextEvents),
  m_cRefs(0)
    {   }

/*  ============================================================================
    CIncFile::Init
    Inits the CIncFile object

    Returns:
        HRESULT
    Side effects:
        None
*/
HRESULT
CIncFile::Init
(
const TCHAR* szIncFile   // file name
)
{
    HRESULT                     hr = S_OK;
    WIN32_FILE_ATTRIBUTE_DATA   fad;                // win32 file attributes data structure

    ErrInitCriticalSection(&m_csUpdate, hr);
    m_fCsInited = TRUE;

    if(NULL == (m_szIncFile = (LPTSTR) CTemplate::SmallMalloc((_tcslen(szIncFile) + 1)*sizeof(TCHAR)))) {
        hr = E_OUTOFMEMORY;
        goto LExit;
    }

    _tcscpy(m_szIncFile, szIncFile);

    // init hash table element base class
    if(FAILED(hr = CLinkElem::Init(m_szIncFile, _tcslen(m_szIncFile)*sizeof(TCHAR))))
        goto LExit;

LExit:
    return hr;
}

/*  ============================================================================
    CIncFile::~CIncFile
    Destructor

    Returns:
        Nothing
    Side effects:
        None
*/
CIncFile::~CIncFile
(
)
    {
#if UNICODE
    DBGPRINTF((DBG_CONTEXT, "Include file deleted: %S\n", m_szIncFile));
#else
    DBGPRINTF((DBG_CONTEXT, "Include file deleted: %s\n", m_szIncFile));
#endif
    Assert(m_cRefs == 0);
    SmallTemplateFreeNullify((void**) &m_szIncFile);
    if(m_fCsInited)
        DeleteCriticalSection(&m_csUpdate);
    }

/*  ============================================================================
    CIncFile::GetTemplate
    Get i'th template user from CIncFile

    Returns:
        NULL if "iTemplate" is out of range, m_rgpTemplates[iTemplate] otherwise

    Side effects:
        None
*/
CTemplate*
CIncFile::GetTemplate
(
int iTemplate
)
    {
    if (iTemplate < 0 || iTemplate >= (signed int) m_rgpTemplates.length())
        return NULL;

    else
        return m_rgpTemplates[iTemplate];
    }

/*  ============================================================================
    CIncFile::QueryInterface
    Provides QueryInterface implementation for CIncFile

    NOTE: It is arbitrary which vtable we return for IDebugDocument & IDebugDocumentInfo.
*/
HRESULT
CIncFile::QueryInterface(const GUID &uidInterface, void **ppvObj)
    {
    if (uidInterface == IID_IUnknown || uidInterface == IID_IDebugDocumentProvider)
        *ppvObj = static_cast<IDebugDocumentProvider *>(this);

    else if (uidInterface == IID_IDebugDocument || uidInterface == IID_IDebugDocumentInfo || uidInterface == IID_IDebugDocumentText)
        *ppvObj = static_cast<IDebugDocumentText *>(this);

    else if (uidInterface == IID_IConnectionPointContainer)
        *ppvObj = static_cast<IConnectionPointContainer *>(this);

    else
        *ppvObj = NULL;

    if (*ppvObj)
        {
        AddRef();
        return S_OK;
        }
    else
        return E_NOINTERFACE;
    }

/*  ============================================================================
    CIncFile::AddRef
    Adds a ref to this IncFile, thread-safely
*/
ULONG
CIncFile::AddRef()
    {
    InterlockedIncrement(&m_cRefs);
    return m_cRefs;
    }

/*  ============================================================================
    CIncFile::Release
    Releases a ref to this IncFile, thread-safely
*/
ULONG
CIncFile::Release()
{
    if (InterlockedDecrement(&m_cRefs) == 0)
        {
        delete this;
        return 0;
        }

    return m_cRefs;
}

/*  ****************************************************************************
    IDebugDocumentProvider implementation for includes
*/

/*  ============================================================================
    CIncFile::GetDocument
    Return a pointer to the IDebugDocument implementation. (same object in this case)

    Returns:
        *ppDebugDoc is set to "this".
    Notes:
        always succeeds
*/
HRESULT CIncFile::GetDocument
(
IDebugDocument **ppDebugDoc
)
    {
    return QueryInterface(IID_IDebugDocument, reinterpret_cast<void **>(ppDebugDoc));
    }

/*  ============================================================================
    CIncFile::GetName
    Return the various names of a document.
*/

HRESULT CIncFile::GetName
(
/* [in] */ DOCUMENTNAMETYPE doctype,
/* [out] */ BSTR *pbstrName
)
{
    switch (doctype) {
        case DOCUMENTNAMETYPE_APPNODE:
        case DOCUMENTNAMETYPE_FILE_TAIL:
        case DOCUMENTNAMETYPE_TITLE:
            // Use the name of the include file (char after last back-slash) converted to lower case.
        {
            TCHAR *szFilePart = _tcsrchr(m_szIncFile, _T('\\'));
            Assert (szFilePart != NULL);

#if UNICODE
            *pbstrName = SysAllocString(szFilePart + 1);
            if (*pbstrName == NULL) {
                return E_OUTOFMEMORY;
            }
#else
            if (FAILED(SysAllocStringFromSz(szFilePart + 1, 0, pbstrName, CP_ACP)))
                return E_FAIL;
#endif
            if (*pbstrName != NULL)
                _wcslwr(*pbstrName);
            return S_OK;
        }

        case DOCUMENTNAMETYPE_URL:
            // prefix with the URL, use szPathInfo for the rest of the path
        {
            CTemplate::CFileMap *pFilemap = GetFilemap();
            if (pFilemap->FHasVirtPath()) {
                STACK_BUFFER( tempName, MAX_PATH );

                CTemplate *pTemplate = m_rgpTemplates[0];
                int cbURLPrefix = DIFF(pTemplate->m_szApplnVirtPath - pTemplate->m_szApplnURL)*sizeof(TCHAR);

                if (!tempName.Resize(cbURLPrefix + ((_tcslen(pFilemap->m_szPathInfo) + 1)*sizeof(TCHAR)))) {
                    return E_OUTOFMEMORY;
                }

                TCHAR *szURL = (TCHAR *)tempName.QueryPtr();

                memcpy(szURL, pTemplate->m_szApplnURL, cbURLPrefix);
                _tcscpy(&szURL[cbURLPrefix/sizeof(TCHAR)], pFilemap->m_szPathInfo);
#if UNICODE
                *pbstrName = SysAllocString(szURL);
                if (*pbstrName == NULL) {
                    return (E_OUTOFMEMORY);
                }
                return S_OK;
#else
                return SysAllocStringFromSz(szURL, 0, pbstrName, pTemplate->m_wCodePage);
#endif
            }
            else {
                *pbstrName = NULL;
                return E_FAIL;
            }
        }

        default:
            return E_FAIL;
        }
}

/*  ****************************************************************************
    IDebugDocumentText implementation
*/

/*  ============================================================================
    CIncFile::GetSize
    Return the number of lines & characters in the document
*/
HRESULT CIncFile::GetSize
(
/* [out] */ ULONG *pcLines,
/* [out] */ ULONG *pcChars
)
    {
    CTemplate::CFileMap *pfilemap = GetFilemap();

    *pcLines = ULONG_MAX;
    *pcChars = pfilemap->m_cChars;
#if UNICODE
    DBGPRINTF((DBG_CONTEXT, "GetSize(\"%S\") returns %lu characters (%lu lines)\n", pfilemap->m_szPathTranslated, *pcChars, *pcLines));
#else
    DBGPRINTF((DBG_CONTEXT, "GetSize(\"%s\") returns %lu characters (%lu lines)\n", pfilemap->m_szPathTranslated, *pcChars, *pcLines));
#endif
    return S_OK;
    }

/*  ============================================================================
    CTemplate::GetDocumentAttributes
    Return doc attributes
*/
HRESULT CIncFile::GetDocumentAttributes
(
/* [out] */ TEXT_DOC_ATTR *ptextdocattr
)
    {
    // Easy way to tell debugger that we don't support editing.
    *ptextdocattr = TEXT_DOC_ATTR_READONLY;
    return S_OK;
    }

/*  ============================================================================
    CIncFile::GetPositionOfLine
    From a line number, return the character offset of the beginning

    I don't think we need this function.  It is meant to support line oriented
    debuggers, of which Caesar is not one.
*/
HRESULT CIncFile::GetPositionOfLine
(
/* [in] */ ULONG cLineNumber,
/* [out] */ ULONG *pcCharacterPosition
)
    {
    return m_rgpTemplates[0]->GetPositionOfLine(GetFilemap(), cLineNumber, pcCharacterPosition);
    }

/*  ============================================================================
    CIncFile::GetLineOfPosition
    From a character offset, return the line number and offset within the line

    I don't think we need this function.  It is meant to support line oriented
    debuggers, of which Caesar is not one.
*/
HRESULT CIncFile::GetLineOfPosition
(
/* [in] */ ULONG cCharacterPosition,
/* [out] */ ULONG *pcLineNumber,
/* [out] */ ULONG *pcCharacterOffsetInLine
)
    {
    return m_rgpTemplates[0]->GetLineOfPosition(GetFilemap(), cCharacterPosition, pcLineNumber, pcCharacterOffsetInLine);
    }

/*  ============================================================================
    CIncFile::GetText
    From a character offset and length, return the document text
*/
HRESULT CIncFile::GetText
(
ULONG cchSourceOffset,
WCHAR *pwchText,
SOURCE_TEXT_ATTR *pTextAttr,
ULONG *pcChars,
ULONG cMaxChars
)
    {
    return GetFilemap()->GetText((WORD)m_rgpTemplates[0]->m_wCodePage, cchSourceOffset, pwchText, pTextAttr, pcChars, cMaxChars);
    }

/*  ============================================================================
    CIncFile::GetPositionOfContext
    Decompose a document context into the document offset & length
*/
HRESULT CIncFile::GetPositionOfContext
(
/* [in] */ IDebugDocumentContext *pUnknownDocumentContext,
/* [out] */ ULONG *pcchSourceOffset,
/* [out] */ ULONG *pcchText
)
    {
    // Make sure that the context is one of ours
    CIncFileDocumentContext *pDocumentContext;
    if (FAILED(pUnknownDocumentContext->QueryInterface(IID_IDenaliIncFileDocumentContext, reinterpret_cast<void **>(&pDocumentContext))))
        return E_FAIL;

    if (pcchSourceOffset)
        *pcchSourceOffset = pDocumentContext->m_cchSourceOffset;

    if (pcchText)
        *pcchText = pDocumentContext->m_cchText;

    pDocumentContext->Release();
    return S_OK;
    }

/*  ============================================================================
    CIncFile::GetContextOfPosition
    Given the character position & number of characters in the document,
    encapsulate this into a document context object.
*/
HRESULT CIncFile::GetContextOfPosition
(
/* [in] */ ULONG cchSourceOffset,
/* [in] */ ULONG cchText,
/* [out] */ IDebugDocumentContext **ppDocumentContext
)
    {
    if (
        (*ppDocumentContext = new CIncFileDocumentContext(this, cchSourceOffset, cchText))
        == NULL
       )
        return E_OUTOFMEMORY;

    return S_OK;
    }

/*  ****************************************************************************
    IConnectionPointContainer implementation
*/

/*  ============================================================================
    CIncFile::FindConnectionPoint
    From a character offset and length, return the document text
*/
HRESULT CIncFile::FindConnectionPoint
(
const GUID &uidConnection,
IConnectionPoint **ppCP
)
    {
    if (uidConnection == IID_IDebugDocumentTextEvents)
        return m_CPTextEvents.QueryInterface(IID_IConnectionPoint, reinterpret_cast<void **>(ppCP));
    else
        {
        *ppCP = NULL;
        return E_NOINTERFACE;
        }
    }

/*  ============================================================================
    CIncFile::GetFilemap
    Returns a CFileMap pointer for this include file.  (Note: There are several
    CFileMaps that may be used, corresponding to each template.  This function
    selects one of them.)

    Returns:
        Corresponding CFileMap
    Side effects:
        None
*/
CTemplate::CFileMap *
CIncFile::GetFilemap
(
)
    {
    // Get pointer to first template's filemaps
    CTemplate::CFileMap **ppFilemapInc = &m_rgpTemplates[0]->m_rgpFilemaps[1];
    BOOL fFoundInc = FALSE;

    // Look for the filemap whose name corresponds to this IncFile.  It had better exist
    // in all template filemaps.
    //    NOTE: Start searching at position 1, because position 0 is the template itself.
    //
    for (unsigned i = 1; i < m_rgpTemplates[0]->m_cFilemaps && !fFoundInc; ++i)
        if (_tcscmp(m_szIncFile, (*ppFilemapInc++)->m_szPathTranslated) == 0)
            fFoundInc = TRUE;

    Assert (fFoundInc);
    return ppFilemapInc[-1];
    }

/*  ============================================================================
    CIncFile::AddTemplate
    Adds a template to the list of templates that include this inc-file

    Returns:
        HRESULT
    Side effects:
        None
*/
HRESULT
CIncFile::AddTemplate
(
CTemplate*  pTemplate
)
    {
    EnterCriticalSection(&m_csUpdate);

    // Add the template to the list only if it does not exist
    if (m_rgpTemplates.find(pTemplate) == -1)
        {
        if (FAILED(m_rgpTemplates.append(pTemplate)))
            {
            LeaveCriticalSection(&m_csUpdate);
            return E_OUTOFMEMORY;
            }

        // Notify the debugger that template dependency has changed
        //  (Ignore failure)
        //
        if (g_pDebugApp)
            {
            IF_DEBUG(SCRIPT_DEBUGGER)
                                DBGPRINTF((DBG_CONTEXT, "AddTemplate: Notifying debugger to refresh breakpoints\n"));

            InvokeDebuggerWithThreadSwitch
                                    (
                                    g_pDebugApp,
                                    DEBUGGER_EVENT_ON_REFRESH_BREAKPOINT,
                                    static_cast<IDebugDocument *>(this)
                                    );
            }
        }

    LeaveCriticalSection(&m_csUpdate);
    return S_OK;
    }

/*  ============================================================================
    CIncFile::RemoveTemplate
    Removes a template from the template list

    Returns:
        Nothing
    Side effects:
        Compresses the removed template's ptr out of template ptrs array (see "back-copy", below)
        Decrements template count
*/
void
CIncFile::RemoveTemplate
(
CTemplate*  pTemplate
)
    {
    EnterCriticalSection(&m_csUpdate);

    // find the template in list
    int i = m_rgpTemplates.find(pTemplate);

    // Remove the element (If we found it - possible that this is 2nd instance of #include and was previously removed)
    if (i != -1)
        {
        m_rgpTemplates.removeAt(i);

        // Notify the debugger that template dependency has changed
        //  (Ignore failure)
        //
        if (g_pDebugApp)
            {
            IF_DEBUG(SCRIPT_DEBUGGER)
                DBGPRINTF((DBG_CONTEXT, "RemoveTemplate: Notifying debugger to refresh breakpoints\n"));

            InvokeDebuggerWithThreadSwitch
                                    (
                                    g_pDebugApp,
                                    DEBUGGER_EVENT_ON_REFRESH_BREAKPOINT,
                                    static_cast<IDebugDocument *>(this)
                                    );
            }
        }

    LeaveCriticalSection(&m_csUpdate);
    }

/*  ============================================================================
    CIncFile::FlushTemplates
    Flushes all of this inc-file's templates from the global template cache

    Returns:
        TRUE if all templates flushed, FALSE if some left
    Side effects:
        None
*/
BOOL
CIncFile::FlushTemplates
(
)
    {
    /*  NOTE we have a cross-dependency with RemoveTemplate() because the following call chain
        occurs when an inc-file gets flushed:

            CIncFileMap::Flush
                CIncFile::FlushTemplates
                    CTemplateCacheManager::Flush
                        CTemplate::RemoveFromIncFiles
                            CIncFile::RemoveTemplate

        The problem is that RemoveTemplate() updates m_cTemplates and m_rgTemplates, so these members
        will not be stable during the loop within FlushTemplates.

        To get around this, we make a local copy of m_rgTemplates.
    */
    EnterCriticalSection(&m_csUpdate);

    STACK_BUFFER( tempTemplates, 128 );

    STACK_BUFFER( tempFile, MAX_PATH );

    UINT        cTemplates = m_rgpTemplates.length();

    if (!tempTemplates.Resize(cTemplates * sizeof(CTemplate*))) {

        // failed to get memory.  The best we can do is return FALSE to indicate
        // that not all templates where flushed.

        LeaveCriticalSection(&m_csUpdate);

        return FALSE;
    }

    CTemplate** rgpTemplates = static_cast<CTemplate**> (tempTemplates.QueryPtr());
    memcpy(rgpTemplates, m_rgpTemplates.vec(), sizeof(CTemplate *) * cTemplates);
    UINT cTemplatesFlushed = 0;

    for(UINT i = 0; i < cTemplates; i++)
        {
        // If the template is ready now, flush it
        if(rgpTemplates[i]->m_fReadyForUse && !(rgpTemplates[i]->m_fDontCache))
            {
            // bug 917: make a local copy of template file name, since the member gets freed part way through g_TemplateCache.Flush
            TCHAR*   szTemp = NULL;
            szTemp = rgpTemplates[i]->GetSourceFileName();
            if (szTemp)
                {

                if (!tempFile.Resize((_tcslen(szTemp) + 1)*sizeof(TCHAR))) {

                    // failed on this one.  Continue and try to flush as many
                    // as we can.
                    continue;
                }
                TCHAR *szTemplateFile = (TCHAR *)tempFile.QueryPtr();
                _tcscpy(szTemplateFile, szTemp);
                g_TemplateCache.Flush(szTemplateFile, MATCH_ALL_INSTANCE_IDS);
                cTemplatesFlushed++;
                }
            }

         // If the template was not ready, we don't flush. It will probably
         // pick up the current include file anyway
        }

    LeaveCriticalSection(&m_csUpdate);

    return (cTemplates == cTemplatesFlushed);
    }

/*  ============================================================================
    CIncFile::OnIncFileDecache

    Callback which we use to call onDestroy events in the debugger just before
    we are removed from the IncFile cache.

    REF COUNTING NOTE:
        Since debugging client has a reference to the IDebugDocument, the include needs
        to dis-associate with the debugger at a point in time before destruction.
        Otherwise, the reference will never go to zero.
*/
void
CIncFile::OnIncFileDecache
(
)
    {
    if (m_CPTextEvents.FIsEmpty() || g_pDebugApp == NULL)
        return;

    IEnumConnections *pConnIterator;
    if (SUCCEEDED(m_CPTextEvents.EnumConnections(&pConnIterator)))
        {
        CONNECTDATA ConnectData;
        while (pConnIterator->Next(1, &ConnectData, NULL) == S_OK)
            {
            IDebugDocumentTextEvents *pTextEventSink;
            if (SUCCEEDED(ConnectData.pUnk->QueryInterface(IID_IDebugDocumentTextEvents, reinterpret_cast<void **>(&pTextEventSink))))
                {
                InvokeDebuggerWithThreadSwitch(g_pDebugApp, DEBUGGER_ON_DESTROY, pTextEventSink);
                pTextEventSink->Release();
                }
            ConnectData.pUnk->Release();
            }

        pConnIterator->Release();
        }
    }

/*  ****************************************************************************
    CTemplate::CBuffer member functions
*/

/*  ============================================================================
    CTemplate::CBuffer::CBuffer
    Ctor
*/
CTemplate::CBuffer::CBuffer()
:
  m_pItems(NULL),
  m_cSlots(0),
  m_cItems(0),
  m_pbData(NULL),
  m_cbData(0),
  m_cbDataUsed(0)
    {
    }

/*  ============================================================================
    CTemplate::CBuffer::~CBuffer
    Dtor
*/
CTemplate::CBuffer::~CBuffer()
    {
    if(m_pItems)
        CTemplate::SmallFree(m_pItems);
    if(m_pbData)
        CTemplate::LargeFree(m_pbData);
    }

/*  ============================================================================
    CTemplate::CBuffer::Init
    Inits a CBuffer
*/
void
CTemplate::CBuffer::Init
(
USHORT cSlots,
ULONG cbData
)
    {
    m_cSlots = cSlots;
    m_cbData = cbData;

    // Allocate space for storing byte range items
    if(!(m_pItems = (CByteRange*) CTemplate::SmallMalloc(m_cSlots * sizeof(CByteRange))))
        THROW(E_OUTOFMEMORY);

    // Allocate space for storing local data, if there is any
    if(m_cbData > 0)
        {
        if(!(m_pbData = (BYTE*) CTemplate::LargeMalloc(m_cbData)))
            THROW(E_OUTOFMEMORY);
        }

    }

/*  ============================================================================
    CTemplate::CBuffer::Append
    Appends to a CBuffer
*/
void
CTemplate::CBuffer::Append
(
const CByteRange&   br,             // byte range to append
BOOL                fLocal,         // append local?
UINT                idSequence,     // segment sequence id
CFileMap*           pfilemap,
BOOL                fLocalString    // append local as a string? (length-prefixed, null-terminated)
)
    {
    // calc bytes required to store byte range; allow for length prefix and null if a local string
    ULONG cbRequired = (ULONG)(br.m_cb + (fLocalString ? sizeof(br.m_cb) + 1 : 0));

    // If caller passed a non-local zero-length byte range, no-op and return;
    // allows callers to ignore byte range size
    // NOTE we store empty local byte ranges - required by token list
    if(!fLocal && br.m_cb == 0)
        return;

    if(fLocal)
        {
        if((m_cbData - m_cbDataUsed) < cbRequired)
            {
            // Reallocate space for storing local data - we grab twice what we had before
            // or twice current requirement, whichever is more
            m_cbData = 2 * (m_cbData > cbRequired ? m_cbData : cbRequired);
            if(!(m_pbData = (BYTE*) CTemplate::LargeReAlloc(m_pbData, m_cbData)))
                THROW(E_OUTOFMEMORY);
            }

        // if appending as a local string, copy length-prefix to buffer
        if(fLocalString)
            {
            memcpy(m_pbData + m_cbDataUsed, &(br.m_cb), sizeof(br.m_cb));
            m_cbDataUsed += sizeof(br.m_cb);
            }

        // copy data to buffer
        memcpy(m_pbData + m_cbDataUsed, br.m_pb, br.m_cb);
        m_cbDataUsed += br.m_cb;

        // if appending as a local string, copy null terminator to buffer
        if(fLocalString)
            *(m_pbData + m_cbDataUsed++) = NULL;

        }

    if(m_cItems >= m_cSlots)
        {
        // Reallocate space for storing byte range items - we grab twice what we had before
        m_cSlots *= 2;
        if(!(m_pItems = (CByteRange*) CTemplate::SmallReAlloc(m_pItems, m_cSlots * sizeof(*m_pItems))))
            THROW(E_OUTOFMEMORY);
        }

    // Set the (new) last item to this byte range
    SetItem(m_cItems++, br, fLocal, idSequence, pfilemap, fLocalString);
    }

/*  ============================================================================
    CTemplate::CBuffer::GetItem
    Gets an item from a CBuffer, as a byte range

    Returns:
        Nothing

    Side effects:
        None
*/
void
CTemplate::CBuffer::GetItem
(
UINT        i,  // index of item
CByteRange& br  // byte range containing returned item (out-parameter)
)
    {
    Assert(i < m_cItems);

    // for local data, ptr is offset only; must add it to base ptr
    br.m_pb =  m_pItems[i].m_pb + (m_pItems[i].m_fLocal ? (DWORD_PTR) m_pbData : 0);

    br.m_cb = m_pItems[i].m_cb;
    br.m_fLocal = m_pItems[i].m_fLocal;
    br.m_idSequence = m_pItems[i].m_idSequence;
    br.m_pfilemap = m_pItems[i].m_pfilemap;
    }

/*  ============================================================================
    CTemplate::CBuffer::SetItem
    Sets a CBuffer item to a new value

    Returns
        Nothing
    Side effects
        Throws error on non-existent item index
*/
void
CTemplate::CBuffer::SetItem
(
UINT                i,
const CByteRange&   br,             // byte range to set item to
BOOL                fLocal,         // is item local in buffer?
UINT                idSequence,     // segment sequence id
CFileMap *          pfilemap,       // file where segment came from
BOOL                fLocalString    // append local as a string? (length-prefixed, null-terminated)
)
    {
    // If buffer item i does not exist, fail
    if(i >= m_cSlots)
        THROW(E_FAIL);

    // for local data, store ptr as offset only - avoids fixup after realloc
    // NOTE offset == data used offset - length of data - null terminator (if local string)
    m_pItems[i].m_pb = (fLocal
                        ? (BYTE*)(m_cbDataUsed - br.m_cb -
                            (fLocalString
                             ? sizeof(BYTE)
                             : 0
                            ))
                        : (BYTE*)br.m_pb);

    m_pItems[i].m_cb = br.m_cb;
    m_pItems[i].m_fLocal = fLocal;
    m_pItems[i].m_idSequence = idSequence;
    m_pItems[i].m_pfilemap = pfilemap;
    }

/*  ============================================================================
    CTemplate::CBuffer::PszLocal
    Gets i-th locally-buffered string within the buffer.

    Returns:
        Ptr to locally-buffered string; NULL if not found
    Side effects:
        None
*/
LPSTR
CTemplate::CBuffer::PszLocal
(
UINT i  // index of item to retrieve
)
    {
    CByteRange  br;

    GetItem(i, br);

    if(!br.m_fLocal)
        return NULL;

    return (LPSTR) br.m_pb;
    }

/*  ****************************************************************************
    CTemplate::CScriptStore member functions
*/

/*  ============================================================================
    CTemplate::CScriptStore::~CScriptStore
    Destructor - frees memory

    Returns:
        nothing
    Side effects:
        none
*/
CTemplate::CScriptStore::~CScriptStore()
    {
    UINT i;

    for(i = 0; i < m_cSegmentBuffers; i++)
        delete m_ppbufSegments[i];

    if(m_ppbufSegments != NULL)
        CTemplate::SmallFree(m_ppbufSegments);
    if(m_rgProgLangId != NULL)
        CTemplate::SmallFree(m_rgProgLangId);
    }

/*  ============================================================================
    CTemplate::CScriptStore::Init
    Inits the script store

    Returns:
        nothing
    Side effects:
        allocates memory
*/
HRESULT
CTemplate::CScriptStore::Init
(
LPCSTR szDefaultScriptLanguage,
CLSID *pCLSIDDefaultEngine
)
    {
    HRESULT hr = S_OK;
    UINT    i;
    CByteRange  brDefaultScriptLanguage;

        // Check for NULL pointers - can happen if Application has invalid default lang
        if (szDefaultScriptLanguage == NULL || pCLSIDDefaultEngine == NULL)
                return TYPE_E_ELEMENTNOTFOUND;

    /*  init segment buffers count based on:
        - two for default engine (one primary, one tagged)
        - one each for other engines (tagged only)
    */
    m_cSegmentBuffers = C_SCRIPTENGINESDEFAULT + 1;

    // init segments buffers
    if(NULL == (m_ppbufSegments = (CBuffer**) CTemplate::SmallMalloc(m_cSegmentBuffers * sizeof(CBuffer*))))
        {
        hr = E_OUTOFMEMORY;
        goto LExit;
        }

    for(i = 0; i < m_cSegmentBuffers; i++)
        {
        if(NULL == (m_ppbufSegments[i] = new CBuffer))
            {
            hr = E_OUTOFMEMORY;
            goto LExit;
            }
        m_ppbufSegments[i]->Init((C_SCRIPTSEGMENTSDEFAULT), 0);
        }

    // Append default engine to script store
    brDefaultScriptLanguage.m_cb = strlen(szDefaultScriptLanguage);
    brDefaultScriptLanguage.m_pb = (unsigned char *)szDefaultScriptLanguage;
    hr = AppendEngine(brDefaultScriptLanguage, pCLSIDDefaultEngine, /* idSequence */ 0);

LExit:
    return hr;
    }

/*  ============================================================================
    CTemplate::CScriptStore::AppendEngine
    Appends a script engine to the script store

    Returns:
        HRESULT
    Side effects:
        None
*/
HRESULT
CTemplate::CScriptStore::AppendEngine
(
CByteRange&     brEngine,       // engine name
PROGLANG_ID*    pProgLangId,    // ptr to prog lang id - pass NULL to have this function get proglangid from registry
UINT            idSequence      // segment sequence id
)
    {
    HRESULT     hr = S_OK;
    USHORT      cEngines;   // count of engines

    TRY
        // if no engines yet, init engine names buffer
        if(CountPreliminaryEngines() == 0)
            m_bufEngineNames.Init(C_SCRIPTENGINESDEFAULT, 0);

        // Append engine name to buffer
        m_bufEngineNames.Append(brEngine, FALSE, idSequence, NULL);

    CATCH(hrException)
        hr = hrException;
        goto LExit;
    END_TRY

    Assert(CountPreliminaryEngines() >= 1);

    //  malloc or realloc prog lang ids array
    if((cEngines = CountPreliminaryEngines()) == 1)
        m_rgProgLangId = (PROGLANG_ID*) CTemplate::SmallMalloc(cEngines * sizeof(PROGLANG_ID));
    else
        m_rgProgLangId = (PROGLANG_ID*) CTemplate::SmallReAlloc(m_rgProgLangId, cEngines * sizeof(PROGLANG_ID));

    if(NULL == m_rgProgLangId)
        {
        hr = E_OUTOFMEMORY;
        goto LExit;
        }

    if(NULL == pProgLangId)
        // caller passed null progid ptr - get prog id from registry
        hr = GetProgLangId(brEngine, &(m_rgProgLangId[cEngines - 1]));
    else
        // caller passed non-null progid ptr - set prog id from it
        m_rgProgLangId[cEngines - 1] = *pProgLangId;

LExit:
    return hr;
    }

/*  ============================================================================
    CTemplate::CScriptStore::IdEngineFromBr
    Determines the id of a script engine from its engine name

    Returns:
        id of script engine whose name is passed in
    Side effects:
        appends a new script engine name to engine names buffer
*/
USHORT
CTemplate::CScriptStore::IdEngineFromBr
(
CByteRange& brEngine,   // engine name
UINT        idSequence  // segment sequence id
)
    {
    Assert(!brEngine.IsNull()); // NOTE we trap/error null engine name earlier

    USHORT cKnownEngines = CountPreliminaryEngines();

    // search existing names for a match; return id if found
    for(USHORT i = 0; i < cKnownEngines; i++)
        {
        Assert(m_bufEngineNames[i]);
        Assert(m_bufEngineNames[i]->m_pb);
        if(FByteRangesAreEqual(*(m_bufEngineNames[i]), brEngine))
            return i;
        }

    // if not found by name try to find by engine id
    // (some engines with different names share the same id, like J[ava]Script)

    if (cKnownEngines > 0)
        {
        PROGLANG_ID ProgLandId;

        // we will get the prog lang id again inside AppendEngine() but
        // because it's cached and this only happens when > 1 engine,  it's alright

        if (SUCCEEDED(GetProgLangId(brEngine, &ProgLandId)))
            {
            for(i = 0; i < cKnownEngines; i++)
                {
                // If matches don't append -- just return the index
                if (m_rgProgLangId[i] == ProgLandId)
                    return i;
                }
            }
        }

    /*  if we did not find engine among those already buffered
        - append engine to script store
        - realloc segment buffers array if necessary
        - return index of last engine (the one we just appended)
    */

    // append engine to script store
    HRESULT hr = AppendEngine(brEngine, NULL, idSequence);

    if(hr == TYPE_E_ELEMENTNOTFOUND)
        // if prog lang not found, throw bad prog lang error id
        THROW(IDE_TEMPLATE_BAD_PROGLANG);
    else if(FAILED(hr))
        // other failure: re-throw hresult
        THROW(hr);

    // realloc segment buffers array if necessary
    if(CountPreliminaryEngines() > (m_cSegmentBuffers - 1))
        {
        // increment count of segment buffers
        m_cSegmentBuffers++;
        Assert(CountPreliminaryEngines() == m_cSegmentBuffers - 1);

        // realloc array of ptrs
        if(NULL == (m_ppbufSegments = (CBuffer**) CTemplate::SmallReAlloc(m_ppbufSegments, m_cSegmentBuffers * sizeof(CBuffer*))))
            THROW(E_OUTOFMEMORY);

        // allocate the new buffer
        if(NULL == (m_ppbufSegments[m_cSegmentBuffers - 1] = new CBuffer))
            THROW(E_OUTOFMEMORY);

        // init the new buffer
        m_ppbufSegments[m_cSegmentBuffers - 1]->Init(C_SCRIPTSEGMENTSDEFAULT, 0);
        }

    // return index of last engine (the one we just appended)
    return (CountPreliminaryEngines() - 1);

    }

/*  ============================================================================
    CTemplate::CScriptStore::AppendScript
    Appends a script/engine pair to the store.

    Returns:
        Nothing
    Side effects:
        None
*/
void
CTemplate::CScriptStore::AppendScript
(
CByteRange& brScript,   // script text
CByteRange& brEngine,   // script engine name
BOOLB       fPrimary,   // primary or tagged script?
UINT        idSequence, // segment sequence id
CFileMap*   pfilemapCurrent
)
    {
    USHORT  iBuffer;    // buffer id

    Assert(fPrimary || !brEngine.IsNull()); // NOTE we trap/error null engine name earlier
    Assert(m_bufEngineNames[0]);            // page's primary engine must be known by this point
    Assert(m_bufEngineNames[0]->m_pb);

    if(fPrimary)
        // if primary script (not tagged), buffer id is 0
        iBuffer = 0;
    else if((!fPrimary) && FByteRangesAreEqual(brEngine, /* bug 1008: primary script engine name */ *(m_bufEngineNames[0])))
        // if tagged script and engine is primary, buffer id is 1
        iBuffer = 1;
    else
        // else, buffer id is engine id plus 1
        iBuffer = IdEngineFromBr(brEngine, idSequence) + 1;

    // append script segment to iBuffer-th segments buffer
    m_ppbufSegments[iBuffer]->Append(brScript, FALSE, idSequence, pfilemapCurrent);
    }

/*  ****************************************************************************
    CTemplate::CObjectInfoStore member functions
*/
/*  ============================================================================
    CTemplate::CObjectInfoStore::~CObjectInfoStore
*/
CTemplate::CObjectInfoStore::~CObjectInfoStore
(
)
    {
    if(m_pObjectInfos)
        CTemplate::SmallFree(m_pObjectInfos);
    }

/*  ============================================================================
    CTemplate::CObjectInfoStore::Init
    Inits the object-info store
*/
void
CTemplate::CObjectInfoStore::Init()
    {
    m_bufObjectNames.Init(C_OBJECTINFOS_DEFAULT, 0);

    // init object-infos array
    if(NULL == (m_pObjectInfos = (CObjectInfo*) CTemplate::SmallMalloc(m_bufObjectNames.CountSlots() * sizeof(CObjectInfo))))
        THROW(E_OUTOFMEMORY);

    }

/*  ============================================================================
    CTemplate::CObjectInfoStore::AppendObject
    Appends an object-info to the object-info store
*/
void
CTemplate::CObjectInfoStore::AppendObject
(
CByteRange& brObjectName,
CLSID       clsid,
CompScope   scope,
CompModel   model,
UINT        idSequence
)
    {

    USHORT iObject = m_bufObjectNames.Count();
    if(iObject >= m_bufObjectNames.CountSlots())
        {
        // Reallocate space for storing object-infos - we grab twice what we had before
        // NOTE we keep no object count in CObjectInfoStore, but instead use count in object names buffer
        (m_pObjectInfos = (CObjectInfo*)CTemplate::SmallReAlloc(m_pObjectInfos,
                                                2 * m_bufObjectNames.CountSlots() * sizeof(CObjectInfo)));

                if (m_pObjectInfos == NULL)
                        THROW(E_OUTOFMEMORY);
        }

    m_pObjectInfos[iObject].m_clsid = clsid;
    m_pObjectInfos[iObject].m_scope = scope;
    m_pObjectInfos[iObject].m_model = model;

    m_bufObjectNames.Append(brObjectName, FALSE, idSequence, NULL);
    }

/*  ****************************************************************************
    CTemplate::CWorkStore member functions
*/

/*  ============================================================================
    CTemplate::CWorkStore::CWorkStore
    Constructor

    Returns:
        Nothing
    Side effects:
        None
*/
CTemplate::CWorkStore::CWorkStore
(
)
:
  m_idCurSequence(0),
  m_fPageCommandsExecuted(FALSE),
  m_fPageCommandsAllowed(TRUE),
  m_szWriteBlockOpen(g_szWriteBlockOpen),
  m_szWriteBlockClose(g_szWriteBlockClose),
  m_szWriteOpen(g_szWriteOpen),
  m_szWriteClose(g_szWriteClose),
  m_pbPrevSource(NULL),
  m_cPrevSourceLines(0),
  m_hPrevFile (NULL)
    {   }

/*  ============================================================================
    CTemplate::CWorkStore::~CWorkStore
    Destructor

    Returns:
        Nothing
    Side effects:
        None
*/
CTemplate::CWorkStore::~CWorkStore
(
)
    {
    /*  if language element ptrs are anything but their constant defaults or null,
        they must have been allocated during compilation - free them now
    */
    if(m_szWriteBlockOpen != g_szWriteBlockOpen  && m_szWriteBlockOpen != NULL)
        CTemplate::SmallFree(m_szWriteBlockOpen);

    if(m_szWriteBlockClose != g_szWriteBlockClose  && m_szWriteBlockClose != NULL)
        CTemplate::SmallFree(m_szWriteBlockClose);

    if(m_szWriteOpen != g_szWriteOpen  && m_szWriteOpen != NULL)
        CTemplate::SmallFree(m_szWriteOpen);

    if(m_szWriteClose != g_szWriteClose  && m_szWriteClose != NULL)
        CTemplate::SmallFree(m_szWriteClose);
    }



/*  ============================================================================
    CTemplate::CWorkStore::Init
    Inits the workstore

    Returns:
        Nothing
    Side effects:
        None
*/
void
CTemplate::CWorkStore::Init
(
)
    {
/*
        NOTE init we the scriptstore separately from rest of workstore
        because try-catch in CTemplate::Init() apparently doesn't work to detect
        bogus script engine name; we need to get an hr back instead.

    m_ScriptStore.Init(brDefaultEngine);
*/
    m_ObjectInfoStore.Init();
    m_bufHTMLSegments.Init(C_HTMLSEGMENTSDEFAULT, 0);
    }

/*  ============================================================================
    CTemplate::CWorkStore::CRequiredScriptEngines
    Returns the count of script engines in the script store that are required
    to run the template.

    NOTE this function is part of the fix for bug 933

    Returns:
        Count of non-empty script engines
    Side effects:
        None
*/
USHORT
CTemplate::CWorkStore::CRequiredScriptEngines
(
BOOL    fGlobalAsa  // bug 1394: is template global.asa?
)
    {
    USHORT  cPreliminaryEngines = m_ScriptStore.CountPreliminaryEngines();
    USHORT  cRequiredEngines =  0;

    for(USHORT i = 0; i < cPreliminaryEngines; i++)
        {
        if(FScriptEngineRequired(i, fGlobalAsa))
            cRequiredEngines++;
        }

    return cRequiredEngines;
    }

/*  ============================================================================
    CTemplate::CWorkStore::FScriptEngineRequired
    Is a given preliminary script engine required to run the template?

    NOTE this function is part of the fix for bug 933

    Returns:
        TRUE or FALSE
    Side effects:
        None
*/
BOOLB
CTemplate::CWorkStore::FScriptEngineRequired
(
USHORT  idEnginePrelim,
BOOL    fGlobalAsa      // bug 1394: is template global.asa?
)
    {
    if(idEnginePrelim == 0)
        return (                                                        // primary engine (id 0) required if
                    (m_ScriptStore.m_ppbufSegments[0]->Count() > 0)     // ... script buffer 0 has segments
                    || (m_ScriptStore.m_ppbufSegments[1]->Count() > 0)  // ... or script buffer 1 has segments
                    || ((m_bufHTMLSegments.Count() > 0) && !fGlobalAsa) // ... or html buffer has segments and (bug 1394) template is not global.asa
                );

    // non-primary engine required if script buffer id+1 has segments
    return (m_ScriptStore.m_ppbufSegments[idEnginePrelim + 1]->Count() > 0);
    }


/*  ****************************************************************************
    CTemplate::CFileMap member functions
*/

/*  ============================================================================
    CTemplate::CFileMap::CFileMap
    Constructor

    Returns
        Nothing
    Side effects
        None
*/
CTemplate::CFileMap::CFileMap()
:
  m_szPathInfo(NULL),
  m_szPathTranslated(NULL),
  m_pfilemapSibling(NULL),
  m_pfilemapChild(NULL),
  m_hFile(NULL),
  m_hMap(NULL),
  m_pbStartOfFile(NULL),
  m_pIncFile(NULL),
  m_pSecurityDescriptor(NULL),
  m_dwSecDescSize(0),
  m_cChars(0),
  m_pDME(NULL)
    {
    m_ftLastWriteTime.dwLowDateTime = 0;
    m_ftLastWriteTime.dwHighDateTime = 0;
    }

/*  ============================================================================
    CTemplate::CFileMap::~CFileMap
    Destructor

    Returns
        Nothing
    Side effects
        None
*/
CTemplate::CFileMap::~CFileMap()
    {
    if (m_pDME)
        {
        m_pDME->Release();
        m_pDME = NULL;
        }
    if(m_szPathInfo != NULL)
        CTemplate::SmallFree(m_szPathInfo);
    if(m_szPathTranslated != NULL)
        CTemplate::SmallFree(m_szPathTranslated);
    if(m_pSecurityDescriptor != NULL)
        CTemplate::SmallFree(m_pSecurityDescriptor);
    if (m_pIncFile != NULL)
        m_pIncFile->Release();
    }

/*  ============================================================================
    CTemplate::CFileMap::MapFile
    Memory-maps a file.

    Returns
        Nothing
    Side effects
        Throws **overloaded** exception on error: exception code can sometimes be
        an error message id, sometimes a true exception.  Caller must handle.
*/
void
CTemplate::CFileMap::MapFile
(
LPCTSTR     szFileSpec,     // file spec for this file
LPCTSTR     szApplnPath,    // application path (in case its global.asa)
CFileMap*   pfilemapParent, // ptr to filemap of parent file
BOOL        fVirtual,       // is file spec virtual or relative?
CHitObj*    pHitObj,        // ptr to template's hit object
BOOL        fGlobalAsa      // is this file the global.asa file?
)
    {
    BOOL        fMustNormalize = TRUE;
    BOOL        fImpersonatedUser = FALSE;
    HANDLE      hVirtIncImpToken = NULL;
    HANDLE      hCurImpToken = NULL;

    Assert((pfilemapParent != NULL) || (pHitObj->PIReq() != NULL) || fGlobalAsa);

    /*  three possible cases:
        1) we are processing global.asa file
        2) we are processing the "main" .asp file
        3) we are processing an include file
    */
    if(fGlobalAsa)
    {
        // case 1) we are processing global.asa file
        Assert(pHitObj->GlobalAspPath());

        DWORD cchPathTranslated = _tcslen(pHitObj->GlobalAspPath());
        m_szPathTranslated = (TCHAR *)CTemplate::SmallMalloc((cchPathTranslated+1)*sizeof(TCHAR));
        if (!m_szPathTranslated)
            THROW(E_OUTOFMEMORY);
        _tcscpy(m_szPathTranslated, pHitObj->GlobalAspPath());

        DWORD cchPathInfo = _tcslen(szApplnPath) + 11; // "/global.asa"
        m_szPathInfo = (TCHAR *)CTemplate::SmallMalloc((cchPathInfo+1) * sizeof(TCHAR));
        if (!m_szPathInfo)
            THROW(E_OUTOFMEMORY);
        _tcscpy(strcpyEx(m_szPathInfo, szApplnPath), _T("/global.asa"));

        // no need to normalize in this case, since global.asa path is already normalized
        Assert(IsNormalized((const TCHAR*)m_szPathTranslated));
        fMustNormalize = FALSE;
        m_fHasVirtPath = TRUE;
    }
    else if(pfilemapParent == NULL)
    {
        // case 2) we are processing the "main" .asp file: get path-info and path-tran from ecb
        Assert(pHitObj->PIReq());

        TCHAR *szVirtPath = pHitObj->PSzCurrTemplateVirtPath();
        TCHAR *szPhysPath = pHitObj->PSzCurrTemplatePhysPath();

        m_szPathInfo       = static_cast<LPTSTR>(CTemplate::SmallMalloc((_tcslen(szVirtPath) + 1)*sizeof(TCHAR)));
        m_szPathTranslated = static_cast<LPTSTR>(CTemplate::SmallMalloc((_tcslen(szPhysPath) + 1)*sizeof(TCHAR)));
        if (!m_szPathInfo || !m_szPathTranslated)
            THROW(E_OUTOFMEMORY);

        _tcscpy(m_szPathInfo,       szVirtPath);
        _tcscpy(m_szPathTranslated, szPhysPath);

        // no need to normalize in this case, since ecb's path-tran is already normalized
        Assert(IsNormalized((const TCHAR*)m_szPathTranslated));
        fMustNormalize = FALSE;
        m_fHasVirtPath = TRUE;
    }
    else
    {
        /*  case 3) we are processing an include file: resolve filespec into path-info and path-tran
            based on whether file was included with VIRTUAL tag or FILE tag
        */
        Assert(szFileSpec);

        // in this case, we don't know path lengths up front so we alloc the max and realloc below
        m_szPathInfo = static_cast<LPTSTR> (CTemplate::SmallMalloc((MAX_PATH + 1)*sizeof(TCHAR)));
        m_szPathTranslated = static_cast<LPTSTR> (CTemplate::SmallMalloc((MAX_PATH + 1)*sizeof(TCHAR)));
        if (!m_szPathInfo || !m_szPathTranslated)
            THROW(E_OUTOFMEMORY);

        STACK_BUFFER(tempPathT, (MAX_PATH+1)*sizeof(TCHAR) );

        if (!tempPathT.Resize((_tcslen(szFileSpec) + 1)*sizeof(TCHAR))) {
            THROW(E_OUTOFMEMORY);
        }

        LPTSTR szPathTranslatedT = (TCHAR *)tempPathT.QueryPtr();   // temp path-tran

        if(fVirtual) {
            DWORD   dwSzLength = tempPathT.QuerySize();  // length of path string buffer

			if (_tcslen(szFileSpec) > MAX_PATH)
				THROW(E_FAIL);
			
            // VIRTUAL: path-info is simply virtual filespec
            _tcscpy(m_szPathInfo, szFileSpec);

            // VIRTUAL: path-tran is translation of path-info
            _tcscpy(szPathTranslatedT, m_szPathInfo);

            if (!pHitObj->PIReq()->MapUrlToPath(szPathTranslatedT, &dwSzLength))
                THROW(E_FAIL);

            // Check the translated path for a UNC specified path

            if ((dwSzLength >= (2*sizeof(TCHAR)))
                && (szPathTranslatedT[0] == _T('\\'))
                && (szPathTranslatedT[1] == _T('\\'))) {

                // if UNC, then ask WAM for the impersonation token for
                // this UNC VRoot.  Silently fail.

                if (pHitObj->PIReq()->ServerSupportFunction(
                                        HSE_REQ_GET_VIRTUAL_PATH_TOKEN,
                                        (void *)szFileSpec,
                                        (DWORD *) &hVirtIncImpToken,
                                        NULL)) {
                    
                    // set the impersonation token and note that we did so
                    // NOTE - there is intentionally no error checking.  The
                    // assumption being that we are doing best effort at the
                    // impersonation because throwing an error here could be
                    // tricky for the user to interpret the problem.  However,
                    // if the impersonation fails, and ASP can still open the
                    // file (e.g. passthru authentication), then everyone's
                    // happy.

                   AspDoRevertHack(&hCurImpToken);

                   fImpersonatedUser = ImpersonateLoggedOnUser(hVirtIncImpToken)
                                         ? TRUE
                                         : FALSE;

                   if (!fImpersonatedUser)
                   {
                       AspUndoRevertHack(&hCurImpToken);
                   }
                }
            }

            m_fHasVirtPath = TRUE;
        }
        else
        {
            TCHAR szParentDir[MAX_PATH], *szT;
            _tcscpy(szParentDir, pfilemapParent->m_szPathInfo);
            if ((szT = _tcsrchr(szParentDir, _T('/'))) != NULL)
                *szT = _T('\0');

            // If we don't allow parent paths, we can save lots of time (Always have a valid virtual path)
            if (!pHitObj->QueryAppConfig()->fEnableParentPaths())
            {
                int strlen_szParentDir = (int)(szT - szParentDir);
                if ((strlen_szParentDir + 1 + _tcslen(szFileSpec)) > MAX_PATH)
                	THROW(E_FAIL);
                
                strcpyEx(strcpyEx(strcpyEx(m_szPathInfo, szParentDir), _T("/")), szFileSpec);
                m_fHasVirtPath = TRUE;
            }
            else
            {
                // NOTE: If we must translate ".." paths, there is no need to verify them (by remapping)
                //       because: If the file does not exist, that case will show up when the file is mapped
                //       If we ".." ourselves out of the vroot space, (out of the app or into another app)
                //          DotPathToPath will detect this.
                //
                if (DotPathToPath(m_szPathInfo, szFileSpec, szParentDir))
                    m_fHasVirtPath = TRUE;
                else
                {
                    GetPathFromParentAndFilespec(pfilemapParent->m_szPathTranslated, szFileSpec, &m_szPathInfo);
                    m_fHasVirtPath = FALSE;
                }

            }

            GetPathFromParentAndFilespec(pfilemapParent->m_szPathTranslated, szFileSpec, &szPathTranslatedT);
        }

        // bug 1214: get canonical path-tran, without . and ..
        // CONSIDER check for . or .. in name before calling GetFullPathName?  UNCs?  what else?
        GetFullPathName(
                        szPathTranslatedT,  // LPCSTR lpFileName,  // address of name of file to find path for
                        MAX_PATH + 1,       // DWORD nBufferLength, // size, in characters, of path buffer
                        m_szPathTranslated, // LPSTR lpBuffer,     // address of path buffer
                        NULL                // LPSTR *lpFilePart   // address of filename in path
                        );

        // realloc path strings to only use required memory (see note above)
        m_szPathInfo = static_cast<LPTSTR> (CTemplate::SmallReAlloc(m_szPathInfo, (_tcslen(m_szPathInfo) + 1)*sizeof(TCHAR)));
        m_szPathTranslated = static_cast<LPTSTR> (CTemplate::SmallReAlloc(m_szPathTranslated, (_tcslen(m_szPathTranslated) + 1)*sizeof(TCHAR)));
        if (!m_szPathInfo || !m_szPathTranslated) {

            if (fImpersonatedUser)
                AspUndoRevertHack(&hCurImpToken);
            if (hVirtIncImpToken)
                CloseHandle(hVirtIncImpToken);
            THROW(E_OUTOFMEMORY);
        }
    }

    // if required, normalize path-tran so that
    // a) cyclic include check can ignore case; b) inc-file cache lookups will work
    if(fMustNormalize)
        Normalize(m_szPathTranslated);

    Assert(IsNormalized(m_szPathTranslated));

    // Bug 99071: Attempt to open the file **BEFORE** we add it to the tree of file
    //            dependencies.  Otherwise if it fails to open, we will have
    //            dangling references.  Since FCyclicInclude depends on us adding
    //            to the tree, if it is cyclic, we need to unmap then.  Since that
    //            is a very uncommon error case, the extra overhead is probably OK
    //
    // RemapFile will throw if it fails. If the exception is that the source file is empty
    // and we are trying to process an include file, we will handle the exception here.
    // in all other cases, rethrow the exception. We do this so that an empty include file
    // will be harmless, but an empty primary file will fail.
    TRY

        RemapFile();

    CATCH(hrException)

        if (hrException != E_SOURCE_FILE_IS_EMPTY || pfilemapParent == NULL) {
            if (fImpersonatedUser)
                AspUndoRevertHack(&hCurImpToken);
            if (hVirtIncImpToken)
                CloseHandle(hVirtIncImpToken);
            THROW(hrException);
        }

    END_TRY

    if (fImpersonatedUser)
        AspUndoRevertHack(&hCurImpToken);
    if (hVirtIncImpToken)
        CloseHandle(hVirtIncImpToken);

    // Create the tree structure for this file
    if (pfilemapParent != NULL)
    {
        // See if this file is already included once on this level. (Don't show duplicates in the
        // debugger tree view)
        //
        BOOL fDuplicateExists = FALSE;
        CFileMap *pFilemap = pfilemapParent->m_pfilemapChild;
        while (pFilemap != NULL && !fDuplicateExists)
        {
            if (_tcscmp(pFilemap->m_szPathTranslated, m_szPathTranslated) == 0)
                fDuplicateExists = TRUE;

            pFilemap = pFilemap->m_fHasSibling? pFilemap->m_pfilemapSibling : NULL;
        }

        // If the include file is #include'd more than once, don't add it as a sibling.
        // Rather orphan the pfilemap and just set the parent pointer.
        //
        if (!fDuplicateExists)
        {
            if (pfilemapParent->m_pfilemapChild == NULL)
                pfilemapParent->m_pfilemapChild = this;
            else
                pfilemapParent->m_pfilemapChild->AddSibling(this);
        }
    }

    // in both of the above code paths, we are always added as the LAST child, (or we are an orphan node)
    // so it is safe to set the parent without calling SetParent()
    m_fHasSibling = FALSE; // Paranoia
    m_pfilemapParent = pfilemapParent;

    // hurl if this file is being included by itself (perhaps indirectly)
    if(FCyclicInclude(m_szPathTranslated)) {
        UnmapFile();
        THROW(IDE_TEMPLATE_CYCLIC_INCLUDE);
    }
}

/*  ============================================================================
    CTemplate::CFileMap::RemapFile
    map a file that was previously mapped.

    Returns
        Nothing
    Side effects
        Throws **overloaded** exception on error: exception code can sometimes be
        an error message id, sometimes a true exception.  Caller must handle.

    Does not decrypt EASPs on remapping. Caller must decrypt if required.  This
    function is called by the debugger, and the debugger does not allow access
    to decrypted files, so decryption is a waste of time.
*/
void
CTemplate::CFileMap::RemapFile
(
)
    {
    WIN32_FILE_ATTRIBUTE_DATA   fad;    // win32 file attributes data structure

    if (FIsMapped())
        return;

    if(INVALID_HANDLE_VALUE == (m_hFile =
                                CreateFile(
                                            m_szPathTranslated,     // file name
                                            GENERIC_READ,           // access (read-write) mode
                                            FILE_SHARE_READ,        // share mode
                                            NULL,                   // pointer to security descriptor
                                            OPEN_EXISTING,          // how to create
                                            FILE_ATTRIBUTE_NORMAL,  // file attributes
                                            NULL                    // handle to file with attributes to copy
                                           )))
        {
        DWORD dwLastError = GetLastError();
        if(dwLastError == ERROR_ACCESS_DENIED)
            {
            // typically, we end up here if the user has no permissions on the file
            // bug 1007: however, we also end up here if the user gave us a directory name, instead of a file name

            if(FAILED(AspGetFileAttributes(m_szPathTranslated, &fad)))
                {
                // bug 1495: file in a secured directory will end up here - we need to re-GetLastError to see if access is denied
                dwLastError = GetLastError();
                if(dwLastError == ERROR_ACCESS_DENIED)
                    {
                    THROW(E_USER_LACKS_PERMISSIONS);
                    }
                // GetFileAttributes call failed; don't know why
                THROW(E_FAIL);
                }
            else if(FILE_ATTRIBUTE_DIRECTORY & fad.dwFileAttributes)
                {
                // bug 1007: the user gave us a directory name
#if UNICODE
                DBGPRINTF((DBG_CONTEXT, "Failed to open file %S because it is a directory.\n", m_szPathTranslated));
#else
                DBGPRINTF((DBG_CONTEXT, "Failed to open file %s because it is a directory.\n", m_szPathTranslated));
#endif
                THROW(E_COULDNT_OPEN_SOURCE_FILE);
                }
            else
                {
                THROW(E_USER_LACKS_PERMISSIONS);
                }
            }
        else
                        {
#if DBG
			char szError[128];
			if (!FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM,
								NULL,
								dwLastError,
								0L,			// lang ID - defaults to LANG_NEUTRAL
								szError,
								sizeof szError,
								NULL) )
				{
				sprintf(szError, "%d", dwLastError);
				}
#if UNICODE
            DBGPRINTF((DBG_CONTEXT, "Failed to open file %S\n", m_szPathTranslated));
#else
            DBGPRINTF((DBG_CONTEXT, "Failed to open file %s\n", m_szPathTranslated));
#endif
            DBGPRINTF((DBG_CONTEXT, "  The error returned was: %s\n", szError));
#endif
            THROW(E_COULDNT_OPEN_SOURCE_FILE);
            }
        }

    // Get the file's last access time. Only do this for NT
    if (Glob(fWinNT))
        {
        if (SUCCEEDED(AspGetFileAttributes(m_szPathTranslated, &fad)))
            {
            m_ftLastWriteTime.dwLowDateTime = fad.ftLastWriteTime.dwLowDateTime;
            m_ftLastWriteTime.dwHighDateTime = fad.ftLastWriteTime.dwHighDateTime;
            }
        }

    // get file's security descriptor
    if(!GetSecurityDescriptor())
        THROW(E_COULDNT_OPEN_SOURCE_FILE);

    // map the file
    if(NULL == (m_hMap =
                CreateFileMapping(
                                    m_hFile,        // handle to file to map
                                    NULL,           // optional security attributes
                                    PAGE_READONLY,  // protection for mapping object
                                    0,              // high-order 32 bits of object size
                                    0,              // low-order 32 bits of object size
                                    NULL            // name of file-mapping object
                                )))
        {
        if (SUCCEEDED(AspGetFileAttributes(m_szPathTranslated, &fad)))
            {
           if(fad.nFileSizeHigh == 0 && fad.nFileSizeLow == 0)
                {
#if UNICODE
                DBGPRINTF((DBG_CONTEXT, "Empty source file %S\n", m_szPathTranslated));
#else
                DBGPRINTF((DBG_CONTEXT, "Empty source file %s\n", m_szPathTranslated));
#endif
                THROW(E_SOURCE_FILE_IS_EMPTY);
                }
            }
        else
            {
            THROW(E_COULDNT_OPEN_SOURCE_FILE);
            }
        }

    // set file's start-of-file ptr
    if(NULL == (m_pbStartOfFile =
                (PBYTE) MapViewOfFile(
                                        m_hMap,         // file-mapping object to map into address space
                                        FILE_MAP_READ,  // access mode
                                        0,              // high-order 32 bits of file offset
                                        0,              // low-order 32 bits of file offset
                                        0               // number of bytes to map
                                    )))
        THROW(E_COULDNT_OPEN_SOURCE_FILE);
    }

/*  ============================================================================
    CTemplate::CFileMap::SetParent
    Set the parent for this filemap
*/
void
CTemplate::CFileMap::SetParent
(
CFileMap* pfilemapParent
)
    {
    CFileMap *pfilemap = this;

    while (pfilemap->m_fHasSibling)
        pfilemap = pfilemap->m_pfilemapSibling;

    pfilemap->m_pfilemapParent = pfilemapParent;
    }

/*  ============================================================================
    CTemplate::CFileMap::GetParent
    Get the parent for this filemap
*/
CTemplate::CFileMap*
CTemplate::CFileMap::GetParent
(
)
    {
    register CFileMap *pfilemap = this;

    while (pfilemap->m_fHasSibling)
        pfilemap = pfilemap->m_pfilemapSibling;

    return pfilemap->m_pfilemapParent;
    }

/*  ============================================================================
    CTemplate::CFileMap::AddSibling
    Add a new node as a sibling of this
*/
void
CTemplate::CFileMap::AddSibling
(
register CFileMap* pfilemapSibling
)
    {
    register CFileMap *pfilemap = this;

    while (pfilemap->m_fHasSibling)
        pfilemap = pfilemap->m_pfilemapSibling;

    pfilemapSibling->m_fHasSibling = FALSE;
    pfilemapSibling->m_pfilemapParent = pfilemap->m_pfilemapParent;

    pfilemap->m_fHasSibling = TRUE;
    pfilemap->m_pfilemapSibling = pfilemapSibling;
    }

/*  ============================================================================
    CTemplate::CFileMap::FCyclicInclude
    Is a file among this filemap's ancestors?  (i.e. does it occur anywhere
    in the filemap's parent chain?)

    Returns
        TRUE or FALSE
    Side effects
        None
*/
BOOL
CTemplate::CFileMap::FCyclicInclude
(
LPCTSTR  szPathTranslated
)
    {
    CFileMap *pfilemapParent = GetParent();

    if(pfilemapParent == NULL)
        return FALSE;

    // NOTE we ignore case because path-tran was normalized
    if(_tcscmp(szPathTranslated, pfilemapParent->m_szPathTranslated) == 0)
        return TRUE;

    return pfilemapParent->FCyclicInclude(szPathTranslated);
    }

/*  ============================================================================
    CTemplate::CFileMap::GetSecurityDescriptor
    Gets a file's security descriptor

    Returns
        TRUE if we got security descriptor, else FALSE
    Side effects
        allocates memory
*/
BOOL
CTemplate::CFileMap::GetSecurityDescriptor
(
)
    // ACLs: the following code should in future be shared with IIS (see creatfil.cxx in IIS project)
    {
    BOOL                    fRet = TRUE;                            // return value
    BOOL                    fGotSecurityDescriptor;                 // did we get a security descriptor?
    DWORD                   dwSecDescSizeNeeded = 0;                // required size of security descriptor
    DWORD                   dwLastError;                            // last error code
    const SECURITY_INFORMATION  si =    OWNER_SECURITY_INFORMATION      // security info struct
                                        | GROUP_SECURITY_INFORMATION
                                        | DACL_SECURITY_INFORMATION;

    // we dont support security on win95
    if (!Glob(fWinNT))
        return(TRUE);

    // get required buffer size before malloc
    // NOTE this costs us an extra system call, but means the cached template will often use less memory
    // we must do this up front by passing 0 buffer size because when the call succeeds it returns
    // dwSecDescSizeNeeded == 0 (i.e. we can't realloc to shrink after successful call)
    GetKernelObjectSecurity(
                            m_hFile,                // handle of object to query
                            si,                     // requested information
                            NULL,                   // address of security descriptor
                            0,                      // size of buffer for security descriptor
                            &dwSecDescSizeNeeded    // address of required size of buffer
                            );

    if((dwLastError = GetLastError()) != ERROR_INSUFFICIENT_BUFFER)
        {
        // pretend everything's fine -- just NULL security descriptor
        if(m_pSecurityDescriptor != NULL)
            CTemplate::SmallFree(m_pSecurityDescriptor);
        m_pSecurityDescriptor = NULL;
        m_dwSecDescSize = 0;
        if (dwLastError == ERROR_NOT_SUPPORTED)
            return TRUE;
        else
            return FALSE;
        }

    // set member buffer size to just enough chunks to accommodate security descriptor size needed
    m_dwSecDescSize = ((dwSecDescSizeNeeded + SECURITY_DESC_GRANULARITY - 1) / SECURITY_DESC_GRANULARITY)
                                * SECURITY_DESC_GRANULARITY;

    // allocate memory for security descriptor
    //  (Note: security descriptor may already be allocated if this is a remap)
    if (m_pSecurityDescriptor == NULL)
        if(NULL == (m_pSecurityDescriptor = (PSECURITY_DESCRIPTOR) CTemplate::SmallMalloc(m_dwSecDescSize)))
            THROW(E_OUTOFMEMORY);

    // try to get security descriptor until we succeed, or until we fail for some reason other than buffer-too-small
    while(TRUE)
        {
        // attempt to get security descriptor
        fGotSecurityDescriptor = GetKernelObjectSecurity(
                                    m_hFile,                // handle of object to query
                                    si,                     // requested information
                                    m_pSecurityDescriptor,  // address of security descriptor
                                    m_dwSecDescSize,        // size of buffer for security descriptor
                                    &dwSecDescSizeNeeded    // address of required size of buffer
                                );

        // get last error immediately after call
        dwLastError =   fGotSecurityDescriptor
                        ?   0                       // we got a security descriptor: set last error to 0
                        :   GetLastError();         // we didn't get a security descriptor: get last error

        if(fGotSecurityDescriptor)
            // we got a security descriptor, so break
            // NOTE we can't realloc m_pSecurityDescriptor to free its unused memory
            // because dwSecDescSizeNeeded is 0 after successful call
            break;

        else if(dwLastError == ERROR_INSUFFICIENT_BUFFER)
            {
            // we didn't get a security descriptor because buffer was too small: increase buffer size, realloc and continue.
            Assert(m_dwSecDescSize < dwSecDescSizeNeeded);

            // set member buffer size to just enough chunks to accommodate security descriptor size needed
            m_dwSecDescSize = ((dwSecDescSizeNeeded + SECURITY_DESC_GRANULARITY - 1) / SECURITY_DESC_GRANULARITY)
                                    * SECURITY_DESC_GRANULARITY;

            if(NULL == (m_pSecurityDescriptor = (PSECURITY_DESCRIPTOR) CTemplate::SmallReAlloc(m_pSecurityDescriptor, m_dwSecDescSize)))
                THROW(E_OUTOFMEMORY);
            }

        else
            {
            // we didn't get a security descriptor for some random reason: return failure
            fRet = FALSE;
            break;
            }

        }

    return fRet;
    }


/*  ============================================================================
    CTemplate::CFileMap::UnmapFile
    Unmaps a memory-mapped file
    NOTE this leaves the filemap's path-info and path-tran members intact

    Returns
        Nothing
    Side effects
        None
*/
void
CTemplate::CFileMap::UnmapFile
(
)
    {
    if(m_pbStartOfFile != NULL)
        if(!UnmapViewOfFile(m_pbStartOfFile)) THROW(E_FAIL);

    if(m_hMap!= NULL)
        if(!CloseHandle(m_hMap)) THROW(E_FAIL);

    if(m_hFile != NULL && m_hFile != INVALID_HANDLE_VALUE)
        if(!CloseHandle(m_hFile)) THROW(E_FAIL);

    // Null-ify ptr and handles, since MapFile checks for non-null
    m_pbStartOfFile = NULL;
    m_hMap = NULL;
    m_hFile = NULL;
    }

/*  ============================================================================
    CTemplate::CFileMap::CountChars
    Count the number of characters in the (open) filemap

    Returns:
        # of characters in the file
*/
DWORD
CTemplate::CFileMap::CountChars
(
WORD wCodePage
)
    {
    // Bug 84284: Scripts containing object tags only do not have the DBCS table built
    //             (Because there is no line mapping table to base it from)
    //
    CTemplate::COffsetInfo *pOffsetInfoLast, oiZero;
    pOffsetInfoLast = (m_rgByte2DBCS.length() == 0)
                            ? &oiZero
                            : &m_rgByte2DBCS[m_rgByte2DBCS.length() - 1];

    // If GetSize() fails don't count the remaining DBCS characters - otherwise an AV
    DWORD cchFilemap = GetSize();
    if (cchFilemap != 0xFFFFFFFF && cchFilemap != 0)
        {
        // Count DBCS characters
        m_cChars = pOffsetInfoLast->m_cchOffset +
                      CharAdvDBCS(wCodePage,
                                  reinterpret_cast<char *>(m_pbStartOfFile + pOffsetInfoLast->m_cbOffset),
                                  reinterpret_cast<char *>(m_pbStartOfFile + cchFilemap),
                                  INFINITE, NULL);

        }
    else
        {
        m_cChars = 0;
        }

    // Done counting DBCS characters
    return m_cChars;
    }

/*  ============================================================================
    CTemplate::CFileMap::GetText
    From a character offset and length, return the document text

    File must be mapped
*/
HRESULT CTemplate::CFileMap::GetText
(
WORD wCodePage,
ULONG cchSourceOffset,
WCHAR *pwchText,
SOURCE_TEXT_ATTR *pTextAttr,
ULONG *pcChars,
ULONG cMaxChars
)
    {
    ULONG cCharsCopied;
    if (pcChars == NULL)
        pcChars = &cCharsCopied;

    // Map the file (temporarily) if not mapped
    BOOL fRemapFile = !FIsMapped();
    TRY
        RemapFile();
    CATCH (dwException)
        return E_FAIL;
    END_TRY

    /* Find the byte offset closest to cchSourceOffset.  This will be
     * the place where we start looping with CharNext() to get the full
     * byte offset.
     */
    COffsetInfo *pOffsetInfoLE = NULL, OffsetInfoT;

    /*
     * NOTE: compilation is done in two phases.
     *          Errors are detected and reported in phase 1.
     *          The DBCS mapping is created in phase 2.
     *
     * If an error occurred during compilation, the DBCS table does not exist.
     * If there is no DBCS mapping table, then pretend like we found entry with
     * nearest offset == 0.  (unless this is SBCS in which case nearest
     * offset == cchSourceOffset)
     */
    if (m_rgByte2DBCS.length() == 0)
        {
        CPINFO  CpInfo;
        GetCPInfo(wCodePage, &CpInfo);
        OffsetInfoT.m_cbOffset = OffsetInfoT.m_cchOffset = (CpInfo.MaxCharSize == 1)? cchSourceOffset : 0;
        pOffsetInfoLE = &OffsetInfoT;
        }
    else
        GetBracketingPair(
                cchSourceOffset,                        // value to search for
                m_rgByte2DBCS.begin(),                  // beginning of array to search
                m_rgByte2DBCS.end(),                    // end of array
                CCharOffsetOrder(),                     // order by character offsets
                &pOffsetInfoLE,                         // desired offset
                static_cast<COffsetInfo **>(NULL)       // don't care
                );

    /* OK - pOffsetLE->cbOffset contains the closest offset not exceeding
     *      cchSourceOffset.  Iterate over the remainder of the characters
     *      to convert the cch to a cb.  It had better exist!
     */
    Assert (pOffsetInfoLE != NULL);

    // Advance over remaining characters
    char *pchStart;
    CharAdvDBCS(wCodePage,
                reinterpret_cast<char *>(m_pbStartOfFile + pOffsetInfoLE->m_cbOffset),
                reinterpret_cast<char *>(m_pbStartOfFile + GetSize()),
                cchSourceOffset - pOffsetInfoLE->m_cchOffset,
                &pchStart
                );

    // Compute # of Characters to copy
    Assert (m_cChars >= cchSourceOffset);
    *pcChars = min(cMaxChars, m_cChars - cchSourceOffset);

    // Compute # of Bytes to copy
    char *pchEnd;
    CharAdvDBCS(wCodePage,
                pchStart,
                reinterpret_cast<char *>(m_pbStartOfFile + GetSize()),
                *pcChars,
                &pchEnd
                );

    if (pwchText)
        MultiByteToWideChar(
                        (WORD)wCodePage,
                        0,
                        pchStart,
                        DIFF(pchEnd - pchStart),
                        pwchText,
                        cMaxChars
                        );

    // We don't support syntax coloring, so set all the character attributes to
    // default color (black)
    if (pTextAttr)
        memset(pTextAttr, 0, *pcChars);

    // Unmap the file (but only if we previously remapped it)
    if (fRemapFile)
        TRY
            UnmapFile();
        CATCH (dwException)
            return E_FAIL;
        END_TRY

    return S_OK;
    }

/*  ****************************************************************************
    CTemplate::CTokenList member functions
*/

/*  ============================================================================
    CTemplate::CTokenList::Init
    Populates token list with tokens

    Returns
        Nothing
    Side effects
        None
*/
void
CTemplate::CTokenList::Init
(
)
    {
    // Init tokens buffer for local storage
    m_bufTokens.Init(tkncAll, CB_TOKENS_DEFAULT);

    // append tokens to buffer
    // NOTE *** TOKENS MUST BE IN SAME ORDER AS ENUM TYPE VALUES ***
    // NOTE 'superset' token must precede 'subset' token (e.g. <!--#INCLUDE before <!--)
    AppendToken(tknOpenPrimaryScript,   "<%");
    AppendToken(tknOpenTaggedScript,    "<SCRIPT");
    AppendToken(tknOpenObject,          "<OBJECT");
    AppendToken(tknOpenHTMLComment,     "<!--");

    AppendToken(tknNewLine,             SZ_NEWLINE);

    AppendToken(tknClosePrimaryScript,  "%>");
    AppendToken(tknCloseTaggedScript,   "</SCRIPT>");
    AppendToken(tknCloseObject,         "</OBJECT>");
    AppendToken(tknCloseHTMLComment,    "-->");
    AppendToken(tknEscapedClosePrimaryScript,   "%\\>");

    AppendToken(tknCloseTag,            ">");

    AppendToken(tknCommandINCLUDE,      "#INCLUDE");

    AppendToken(tknTagRunat,            "RUNAT");
    AppendToken(tknTagLanguage,         "LANGUAGE");
    AppendToken(tknTagCodePage,         "CODEPAGE");
    AppendToken(tknTagCodePage,         "LCID");
    AppendToken(tknTagTransacted,       "TRANSACTION");
    AppendToken(tknTagSession,          "ENABLESESSIONSTATE");
    AppendToken(tknTagID,               "ID");
    AppendToken(tknTagClassID,          "CLASSID");
    AppendToken(tknTagProgID,           "PROGID");
    AppendToken(tknTagScope,            "SCOPE");
    AppendToken(tknTagVirtual,          "VIRTUAL");
    AppendToken(tknTagFile,             "FILE");
    AppendToken(tknTagMETADATA,         "METADATA");
//  AppendToken(tknTagSetPriScriptLang, "@");
    AppendToken(tknTagName,             "NAME");
    AppendToken(tknValueTypeLib,        "TYPELIB");
    AppendToken(tknTagType,             "TYPE");
    AppendToken(tknTagUUID,             "UUID");
    AppendToken(tknTagVersion,          "VERSION");
    AppendToken(tknTagStartspan,        "STARTSPAN");
    AppendToken(tknTagEndspan,          "ENDSPAN");
    AppendToken(tknValueCookie,         "COOKIE");
    AppendToken(tknTagSrc,              "SRC");

    AppendToken(tknValueServer,         "Server");
    AppendToken(tknValueApplication,    "Application");
    AppendToken(tknValueSession,        "Session");
    AppendToken(tknValuePage,           "Page");

    AppendToken(tknVBSCommentSQuote,    "'");
    AppendToken(tknVBSCommentRem,       "REM ");    // NOTE ends with space character
    AppendToken(tknTagFPBot,            "webbot");

    AppendToken(tknEOF,                 "");

    AppendToken(tkncAll,                "");

    }

/*  ============================================================================
    CTemplate::CTokenList::AppendToken
    Appends a string to tokens buffer
    NOTE we keep the unused tkn parameter because it enforces consistency and
    readability in CTemplate::CTokenList::Init(), e.g.
        AppendToken(tknOpenPrimaryScript,   "<%");
    rather than
        AppendToken("<%");

    Returns:
        Nothing
    Side effects:
        None
*/
void
CTemplate::CTokenList::AppendToken
(
_TOKEN  tkn,    // token value
char*   sz      // token string
)
    {
    // construct byte range from token string
    CByteRange  br;
    br.m_pb = (BYTE*) sz;
    br.m_cb = strlen(sz);

    // append to tokens buffer as local string
    m_bufTokens.Append(br, TRUE, 0, NULL, TRUE);
    }

/*  ============================================================================
    CTemplate::CTokenList::NextOpenToken
    Returns value of next open token in search range

    Returns
        token value of next open token in search range; ptr to ptr to open token (out-parameter)
    Side effects
        None
*/
_TOKEN
CTemplate::CTokenList::NextOpenToken
(
CByteRange& brSearch,       // search byte range
TOKEN*      rgtknOpeners,   // array of permitted open tokens
UINT        ctknOpeners,    // count of permitted open tokens
BYTE**      ppbToken,       // ptr to ptr to open token (out-parameter)
LONG        lCodePage
)
    {
    BYTE*       pbTemp = NULL;  // temp pointer
    _TOKEN      tkn = tknEOF;   // return value
    USHORT      i;              // loop index

    // Init caller's token ptr to null
    *ppbToken = NULL;

    // If input is empty, return
    if (brSearch.IsNull())
        return tkn;

    // Prepare array of LPSTR pointers to tokens.
    // Do it here once, because to get LPSTR is not free.
    LPSTR rgszTokens[TOKEN_OPENERS_MAX];
    UINT  rgcchTokens[TOKEN_OPENERS_MAX];
    Assert(ctknOpeners <= TOKEN_OPENERS_MAX);

    for (i = 0; i < ctknOpeners; i++)
        {
        LPSTR pszStr = m_bufTokens.PszLocal((UINT)(rgtknOpeners[i]));
        rgszTokens[i]  = pszStr;
        rgcchTokens[i] = (pszStr != NULL) ? strlen(pszStr) : 0;
        }

    // Call a method to find one of the strings in the range
    UINT idToken;
    pbTemp = brSearch.PbOneOfAspOpenerStringTokens(
        rgszTokens, rgcchTokens, ctknOpeners, &idToken);
    if (pbTemp != NULL)
        {
        *ppbToken = pbTemp;
        tkn = rgtknOpeners[idToken];
        }

    // If we found no open token, position token pointer at end of search range
    if (tkn == tknEOF)
        *ppbToken = brSearch.m_pb + brSearch.m_cb;

    return tkn;
    }

/*  ============================================================================
    CTemplate::CTokenList::MovePastToken
    Moves a byte range past a token contained within it
*/
void
CTemplate::CTokenList::MovePastToken
(
_TOKEN      tkn,
BYTE*       pbToken,
CByteRange& brSearch
)
    {
    Assert(pbToken >= brSearch.m_pb);
    Assert(brSearch.m_cb >= (DIFF(pbToken - brSearch.m_pb) + CCH_TOKEN_X(tkn)));
    brSearch.Advance(DIFF(pbToken - brSearch.m_pb) + CCH_TOKEN_X(tkn));
    }

/*  ============================================================================
    CTemplate::CTokenList::GetToken
    Gets the next occurrence of a token within a byte range.

    Returns:
        ptr to token
    Side effects
        none
*/
BYTE*
CTemplate::CTokenList::GetToken
(
TOKEN       tkn,
CByteRange& brSearch,
LONG        lCodePage
)
    {
    return brSearch.PbString(m_bufTokens.PszLocal((UINT)tkn), lCodePage);
    }

/*  ============================================================================
    The Big Three for CTemplateConnPt

    NOTES:
        Since this interface is embedded in CTemplate,
        AddRef() and Release() delegate to the container object (because that
        is the CTemplate pointer)
*/
HRESULT
CTemplateConnPt::QueryInterface(const GUID &uidInterface, void **ppvObj)
    {
    if (uidInterface == IID_IUnknown || uidInterface == IID_IConnectionPoint)
        {
        *ppvObj = this;
        AddRef();
        return S_OK;
        }
    else
        {
        *ppvObj = NULL;
        return E_NOINTERFACE;
        }
    }

ULONG
CTemplateConnPt::AddRef()
    {
    return m_pUnkContainer->AddRef();
    }

ULONG
CTemplateConnPt::Release()
    {
    return m_pUnkContainer->Release();
    }

/*  ============================================================================
    Constructor for CDocNode
*/
CTemplate::CDocNodeElem::CDocNodeElem(CAppln *pAppln, IDebugApplicationNode *pDocRoot)
    {
    Assert (pAppln != NULL);
    Assert (pDocRoot != NULL);

    (m_pAppln = pAppln)->AddRef();
    (m_pDocRoot = pDocRoot)->AddRef();
    }

/*  ============================================================================
    Destructor for CDocNode
*/
CTemplate::CDocNodeElem::~CDocNodeElem()
    {
    m_pAppln->Release();
    DestroyDocumentTree(m_pDocRoot);
    }

/*  ============================================================================
    CTemplate::fIsLangVBScriptOrJScript(USHORT idEngine)

    This function returns T/F to determine if the requested script engine
    is VBScript or JScript. This function is used as an indicator to determin
    if spaces need to be preserved for non MS Scripting languages

    There is an assumption here that the GUIDs for VBScript and JScript will not change

    Inputs
        Index to a script engine

    Returns
        BOOL
*/
BOOLB CTemplate::FIsLangVBScriptOrJScript(USHORT idEngine)
    {
    // {b54f3741-5b07-11cf-a4b0-00aa004a55e8} VBScript
    static const GUID uid_VBScript  = {0xb54f3741, 0x5b07, 0x11cf, {0xa4, 0xb0, 0x00, 0xaa, 0x00, 0x4a, 0x55, 0xe8}};

    // {f414c260-6ac0-11cf-b6d1-00aa00bbbb58} JavaScript
    static const GUID uid_JScript   = {0xf414c260, 0x6ac0, 0x11cf, {0xb6, 0xd1, 0x00, 0xaa, 0x00, 0xbb, 0xbb, 0x58}};

        // {b54f3743-5b07-11cf-a4b0-00aa004a55e8} VBScript.Encode
        static const GUID uid_VBScriptEncode = {0xb54f3743, 0x5b07, 0x11cf, {0xa4, 0xb0, 0x00, 0xaa, 0x00, 0x4a, 0x55, 0xe8}};

        // {f414c262-6ac0-11cf-b6d1-00aa00bbbb58} JavaScript.Encode
        static const GUID uid_JScriptEncode = {0xf414c262, 0x6ac0, 0x11cf, {0xb6, 0xd1, 0x00, 0xaa, 0x00, 0xbb, 0xbb, 0x58}};

        GUID &uidLang = m_pWorkStore->m_ScriptStore.m_rgProgLangId[idEngine];
        return
                uidLang == uid_VBScript || uidLang == uid_VBScriptEncode ||
                uidLang == uid_JScript  || uidLang == uid_JScriptEncode;
    }


SIZE_T
_RoundUp(
    SIZE_T dwBytes)
{
#if 1
    // 16KB <= dwBytes? Round up to next multiple of 4KB
    if (16*1024 <= dwBytes)
        dwBytes = ((dwBytes + (1<<12) - 1) >> 12) << 12;

    // 4KB <= dwBytes < 16KB? Round up to next multiple of 1KB
    else if (4*1024 <= dwBytes)
        dwBytes = ((dwBytes + (1<<10) - 1) >> 10) << 10;

    // 1KB <= dwBytes < 4KB? Round up to next multiple of 256 bytes
    else if (1024 <= dwBytes)
        dwBytes = ((dwBytes + (1<<8) - 1) >> 8) << 8;

    // dwBytes < 1KB? Round up to next multiple of 32 bytes
    else
        dwBytes = ((dwBytes + (1<<5) - 1) >> 5) << 5;
#endif

    return dwBytes;
}

void*
CTemplate::SmallMalloc(SIZE_T dwBytes)
{
    DBG_ASSERT(sm_hSmallHeap != NULL);
    dwBytes = _RoundUp(dwBytes);
    return ::HeapAlloc(sm_hSmallHeap, 0, dwBytes);
}


void*
CTemplate::SmallReAlloc(void* pvMem, SIZE_T dwBytes)
{
    DBG_ASSERT(sm_hSmallHeap != NULL);
    dwBytes = _RoundUp(dwBytes);
    return ::HeapReAlloc(sm_hSmallHeap, 0, pvMem, dwBytes);
}


void
CTemplate::SmallFree(void* pvMem)
{
    DBG_ASSERT(sm_hSmallHeap != NULL);
    ::HeapFree(sm_hSmallHeap, 0, pvMem);
}

void*
CTemplate::LargeMalloc(SIZE_T dwBytes)
{
    DBG_ASSERT(sm_hLargeHeap != NULL);
    dwBytes = _RoundUp(dwBytes);
    return ::HeapAlloc(sm_hLargeHeap, 0, dwBytes);
}


void*
CTemplate::LargeReAlloc(void* pvMem, SIZE_T dwBytes)
{
    DBG_ASSERT(sm_hLargeHeap != NULL);
    dwBytes = _RoundUp(dwBytes);
    return ::HeapReAlloc(sm_hLargeHeap, 0, pvMem, dwBytes);
}


void
CTemplate::LargeFree(void* pvMem)
{
    DBG_ASSERT(sm_hLargeHeap != NULL);
    ::HeapFree(sm_hLargeHeap, 0, pvMem);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\templcap.h ===
/*==============================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996-1999 Microsoft Corporation. All Rights Reserved.

File:			templcap.h
Maintained by:	DaveK
Component:		include file for CTemplate 'captive' classes
				'captive' == only used internally within CTemplate
	
==============================================================================*/

// forward refs
class CBuffer;
class CFileMap;
class DIR_MONTIOR_ENTRY;

/*	============================================================================
	Enum type:	SOURCE_SEGMENT
	Synopsis:	A contiguous segment of a source template, e.g. primary script, html, etc.
*/
enum SOURCE_SEGMENT
	{
	ssegHTML,
	ssegPrimaryScript,
	ssegTaggedScript,
	ssegObject,
	ssegInclude,
	ssegMetadata,
	ssegHTMLComment,
        ssegFPBot,
	};

/*	****************************************************************************
	Class:		CSourceInfo
	Synopsis:	Info on the source of an output

	NOTE: The target offsets are strictly increasing, so it is binary
	      searchable.  (This is good because this is the search key
	      used by the debugger workhorse API, GetSourceContextOfPosition)
	      Beware, however, that source offsets and line #s are not, in
	      general, binary searchable because of #include files being thrown
	      into the mix.

		TODO DBCS:
	      Both the corresponding byte AND character offsets for the source are
	      stored in this table.  Character offsets are used by all of the API
	      interfaces, but the GetText() API must know what byte offset corresponds
	      to a character offset.  To figure this out, GetText() looks for the
	      closest character offset in the file and uses that as its base for
	      figuring out the byte offset.
*/
class CSourceInfo
	{
	public:
		CFileMap *		m_pfilemap;			// filemap to source file
		unsigned		m_cchTargetOffset;	// target offset (target line # implicit)
		unsigned		m_cchSourceOffset;	// character offset of the source line
		unsigned		m_cchSourceText;	// # of characters in the source statement
		unsigned		m_idLine:31;		// line number in source file
		unsigned		m_fIsHTML:1;		// line number is start of HTML block

		// UNSAFE if virtual functions ever added to this class!
		CSourceInfo() { memset(this, 0, sizeof(*this)); }
	};

/*	****************************************************************************
	Class:		CTargetOffsetOrder
	Synopsis:	provides ordering function for GetBracketingPair() based on
	            target offsets in the CSourceInfo array
*/
class CTargetOffsetOrder
	{
	public:
		BOOL operator()(const CSourceInfo &si, ULONG ul)
			{ return si.m_cchTargetOffset < ul; }

		BOOL operator()(ULONG ul, const CSourceInfo &si)
			{ return ul < si.m_cchTargetOffset; }
	};

/*	****************************************************************************
	Class:		CBuffer
	Synopsis:	A self-sizing memory buffer
*/
class CBuffer
	{
	private:
		CByteRange*	m_pItems;		// ptr to items (i.e. byte ranges)
		USHORT		m_cSlots;		// count of item slots allocated
		USHORT		m_cItems;		// count of items actually stored
		BYTE*		m_pbData;		// ptr to local data storage for items
		ULONG		m_cbData;		// size of local data storage for items
		ULONG		m_cbDataUsed;	// amount of local data storage actually used

	public:
		CBuffer();
		~CBuffer();
		void		Init(USHORT cItems, ULONG cbData);
		USHORT		Count()	{	return m_cItems;	}
		USHORT		CountSlots()	{	return m_cSlots;	}
		void		GetItem(UINT i, CByteRange& br);
		CByteRange* operator[](UINT i) { return &m_pItems[i]; }
		void		SetItem(UINT i, const CByteRange& br, BOOL fLocal, UINT idSequence, CFileMap *pfilemap, BOOL fLocalString = FALSE);
		void		Append(const CByteRange& br, BOOL fLocal, UINT idSequence, CFileMap *pfilemap, BOOL fLocalString = FALSE);
		LPSTR		PszLocal(UINT i);

        // Cache on per-class basis
        // ACACHE_INCLASS_DEFINITIONS()
	};

/*	****************************************************************************
	Class:		CScriptStore
	Synopsis:	Working storage for script segments during compilation.

	Terminology
	-----------
	Engine		== a particular script engine (VBScript, JavaScript, etc)
	Segment		== a contiguous chunk of script text in the source file
*/
class CScriptStore
	{
public:
	CBuffer**		m_ppbufSegments;	// ptr to array of ptrs to script segment buffers, one per engine
	UINT			m_cSegmentBuffers;	// count of script segment buffers
	CBuffer			m_bufEngineNames;	// buffer of engine names, one per engine
	PROGLANG_ID* 	m_rgProgLangId;		// array of prog lang ids, one per engine
	
	CScriptStore(): m_ppbufSegments(NULL), m_cSegmentBuffers(0), m_rgProgLangId(NULL) {}
	~CScriptStore();
	HRESULT	Init(LPCSTR szDefaultScriptLanguage, CLSID *pCLSIDDefaultEngine);
	USHORT 	CountPreliminaryEngines() { return m_bufEngineNames.Count(); }
	HRESULT	AppendEngine(CByteRange& brEngine, PROGLANG_ID*	pProgLangId, UINT idSequence);
	USHORT 	IdEngineFromBr(CByteRange& brEngine, UINT idSequence);
	void	AppendScript(CByteRange& brScript, CByteRange& brEngine, BOOLB fPrimary, UINT idSequence, CFileMap* pfilemap);

	};

/*	****************************************************************************
	Class:		CObjectInfo
	Synopsis:	Information about an object which can be determined at compile time
*/
class CObjectInfo
	{
public:
	CLSID	    m_clsid;	// clsid
	CompScope	m_scope;	// scope: application, session, page
	CompModel	m_model;	// threading model: single, apt, free
	};

/*	****************************************************************************
	Class:		CObjectInfoStore
	Synopsis:	Working storage for object-infos during compilation.
*/
class CObjectInfoStore
	{
public:
	CObjectInfo*	m_pObjectInfos;		// array of object infos
	CBuffer			m_bufObjectNames;	// buffer of object names

	CObjectInfoStore(): m_pObjectInfos(NULL) {}
	~CObjectInfoStore();
	void	Init();
	void	AppendObject(CByteRange& brObjectName, CLSID clsid, CompScope scope, CompModel model, UINT idSequence);
	USHORT	Count() { return m_bufObjectNames.Count(); }

	};

/*	****************************************************************************
	Class:		CWorkStore
	Synopsis:	Working storage for template components
*/
class CWorkStore
	{
public:
	CBuffer				m_bufHTMLSegments;	// buffer of HTML segments
	CObjectInfoStore	m_ObjectInfoStore;	// object-infos store
	CScriptStore		m_ScriptStore;		// script store
	UINT				m_idCurSequence;	// sequence number for current segment
	CByteRange			m_brCurEngine;		// current script engine
	BOOLB				m_fPageCommandsExecuted;	// have we executed page-level @ commands yet?
	BOOLB				m_fPageCommandsAllowed;		// are we allowed to execute page-level @ commands?
													// (will be true iff we have not yet compiled any line of script)
	LPSTR				m_szWriteBlockOpen;			// open  for Response.WriteBlock() equivalent
	LPSTR				m_szWriteBlockClose;		// close for Response.WriteBlock() equivalent
	LPSTR				m_szWriteOpen;				// open  for Response.Write() equivalent
	LPSTR				m_szWriteClose;				// close for Response.Write() equivalent

	// Adding fields to maintain state of the line number calculations (Raid Bug 330171)
	BYTE*				m_pbPrevSource;				// pointer to the location of the last Calc line number call in source file
	UINT				m_cPrevSourceLines;			// corresponding line number to the previous call.
	HANDLE				m_hPrevFile;				// Corresponding file Handle. (Identifing a unique file)

	
	
	
			CWorkStore();
			~CWorkStore();
	void 	Init();
	USHORT 	CRequiredScriptEngines(BOOL	fGlobalAsa);
	BOOLB 	FScriptEngineRequired(USHORT idEnginePrelim, BOOL	fGlobalAsa);

	};

/*	****************************************************************************
	Class:		COffsetInfo
	Synopsis:	map byte offsets to character offsets (different for DBCS)
				on line boundaries

	Each CFileMap has an array of these COffsetInfo structures at each line boundary.
	It stores these at the same offsets in the CSourceInfo array so that a simple
	binary search is all that's needed to convert offsets.
*/
class COffsetInfo
	{
	public:
		unsigned		m_cchOffset;		// character offset in file
		unsigned		m_cbOffset;			// byte offset in file

		// UNSAFE if virtual functions ever added to this class!
		COffsetInfo() { memset(this, 0, sizeof(*this)); }
	};

/*	****************************************************************************
	Class:		CByteOffsetOrder
	Synopsis:	provides ordering function for GetBracketingPair() based on
				byte offsets in the COffsetInfo array
*/
class CByteOffsetOrder
	{
	public:
		BOOL operator()(const COffsetInfo &oi, ULONG ul)
			{ return oi.m_cbOffset < ul; }

		BOOL operator()(ULONG ul, const COffsetInfo &oi)
			{ return ul < oi.m_cbOffset; }
	};

/*	****************************************************************************
	Class:		CCharOffsetOrder
	Synopsis:	provides ordering function for GetBracketingPair() based on
				character offsets in the COffsetInfo array
*/
class CCharOffsetOrder
	{
	public:
		BOOL operator()(const COffsetInfo &oi, ULONG ul)
			{ return oi.m_cchOffset < ul; }

		BOOL operator()(ULONG ul, const COffsetInfo &oi)
			{ return ul < oi.m_cchOffset; }
	};

/*	****************************************************************************
	Class:		CFileMap
	Synopsis:	A memory-mapping of a file

	NOTE: We store an incfile-template dependency by storing an incfile ptr in m_pIncFile.
	This is efficient but ***will break if we ever change Denali to move its memory around***
*/
class CFileMap
	{
public:
	TCHAR *					m_szPathInfo;			// file's virtual path (from www root)
	TCHAR *					m_szPathTranslated;		// file's actual file system path
	union {											// NOTE: m_fHasSibling is used to disambiguate these two
		CFileMap*			m_pfilemapParent;		// ptr to filemap of parent file
		CFileMap*			m_pfilemapSibling;		// ptr to next filemap in same level of hierarchy
	};
	CFileMap*				m_pfilemapChild;		// index of first filemap in next lower level of hierarchy
	HANDLE					m_hFile;				// file handle
	HANDLE					m_hMap;					// file map handle
	BYTE*					m_pbStartOfFile;		// ptr to start of file
	CIncFile*				m_pIncFile;				// ptr to inc-file object
	PSECURITY_DESCRIPTOR	m_pSecurityDescriptor;	// ptr to file's security descriptor
	unsigned long			m_dwSecDescSize:30;		// size of security descriptor
	unsigned long			m_fHasSibling:1;		// Does a sibling exist for this node?
	unsigned long			m_fHasVirtPath:1;		// Is m_szPathInfo the virtual or physical path?
	FILETIME	            m_ftLastWriteTime;		// last time the file was written to
	DWORD					m_cChars;				// # of characters in the file
	vector<COffsetInfo>		m_rgByte2DBCS;			// line-by-line map of byte offsets to DBCS
	CDirMonitorEntry*		m_pDME;				// pointer to directory monitor entry for this file

				CFileMap();
				~CFileMap();
	void 		MapFile(LPCTSTR szFileSpec, LPCTSTR szApplnPath, CFileMap* pfilemapParent, BOOL fVirtual, CHitObj* pRequest, BOOL fGlobalAsp);
	void		RemapFile();
	void 		UnmapFile();

	CFileMap*	GetParent();
	void		SetParent(CFileMap *);

	void		AddSibling(CFileMap *);
	CFileMap*	NextSibling() { return m_fHasSibling? m_pfilemapSibling : NULL; }

	BOOL		FIsMapped()
					{ return m_pbStartOfFile != NULL; }

	BOOL		FHasVirtPath() 
					{ return m_fHasVirtPath; }

	BOOL		FCyclicInclude(LPCTSTR szPathTranslated);
	BOOL		GetSecurityDescriptor();
	DWORD       GetSize() { return GetFileSize(m_hFile, NULL); }		// return # of bytes
	DWORD		CountChars(WORD wCodePage);							// return # of chars

	// implementation of debugging iterface - CTemplate & CIncFile eventually delegate to this function
	HRESULT		GetText(WORD wCodePage, ULONG cchSourceOffset, WCHAR *pwchText, SOURCE_TEXT_ATTR *pTextAttr, ULONG *pcChars, ULONG cMaxChars);

	// Cache on per-class basis
	ACACHE_INCLASS_DEFINITIONS()
	};

/*	****************************************************************************
	Class:		CTokenList
	Synopsis:	A list of tokens.
*/
class CTokenList
{
public:
	/*	========================================================================
	Enum type:	TOKEN
	Synopsis:	Token type.
				NOTE: keep sync'ed with CTokenList::Init()
	*/
	enum TOKEN
	{
		//======== Opener tokens ==================================
		tknOpenPrimaryScript,	// open primary script segment
		tknOpenTaggedScript,	// open tagged script segment
		tknOpenObject,			// open object segment
		tknOpenHTMLComment,		// open HTML comment
		
		//======== Non-opener tokens ==============================
		tknNewLine,				// new line

		tknClosePrimaryScript,	// close primary script segment
		tknCloseTaggedScript,	// close primary script segment
		tknCloseObject,			// close object segment
		tknCloseHTMLComment,	// close HTML comment
		tknEscapedClosePrimaryScript,	// escaped close-primary-script symbol

		tknCloseTag,			// close object or script tag

		tknCommandINCLUDE,		// server-side include (SSI) INCLUDE command
		
		tknTagRunat,			// RUNAT script/object attribute
		tknTagLanguage,			// LANGUAGE tag: page-level compiler directive or script block attribute
		tknTagCodePage,			// CODEPAGE tag: page-level compiler directive
		tknTagLCID,				// LCID tag: page-level compiler directive
		tknTagTransacted,		// TRANSACTED tag: page-level compiler directive
		tknTagSession,		    // SESSION tag: page-level compiler directive
		tknTagID,				// ID object attribute
		tknTagClassID,			// CLASSID object attribute
		tknTagProgID,			// PROGID object attribute
		tknTagScope,			// SCOPE object attribute
		tknTagVirtual,			// VIRTUAL include file attribute
		tknTagFile,				// FILE include file attribute
		tknTagMETADATA,			// METADATA tag - used by IStudio
//		tknTagSetPriScriptLang,	// sets primary script language, as in <% @ LANGUAGE = VBScript %>
        tknTagName,             // NAME inside METADATA
		tknValueTypeLib,        // TypeLib inside METADATA (has to be before TYPE in the list)
        tknTagType,             // TYPE inside METADATA
        tknTagUUID,             // UUID inside METADATA
        tknTagVersion,          // VERSION inside METADATA
        tknTagStartspan,        // STARTSPAN inside METADATA
        tknTagEndspan,          // ENDSPAN inside METADATA
        tknValueCookie,         // TYPE=Cookie inside METADATA
        tknTagSrc,              // SRC= inside METADATA
		
		tknValueServer,			// Server value - e.g. RUNAT=Server
		tknValueApplication,	// SCOPE=Application
		tknValueSession,		// SCOPE=Session
		tknValuePage,			// SCOPE=Page

		tknVBSCommentSQuote,	// VBS comment symbol
		tknVBSCommentRem,		// VBS comment symbol (alternate)

        tknTagFPBot,            // Front Page webbot tag
		
		tknEOF,					// end-of-file pseudo-token

		tkncAll					// pseudo-token: count of all tokens
	};

	void		Init();
	CByteRange* operator[](UINT i) { return m_bufTokens[i]; }
	CByteRange* operator[](TOKEN tkn) { return operator[]((UINT) tkn); }
	void		AppendToken(TOKEN	tkn, char* psz);
	TOKEN		NextOpenToken(CByteRange& brSearch, TOKEN* rgtknOpeners, UINT ctknOpeners, BYTE** ppbToken, LONG lCodePage);
	void		MovePastToken(TOKEN tkn, BYTE* pbToken, CByteRange& brSearch);
	BYTE*		GetToken(TOKEN tkn, CByteRange& brSearch, LONG lCodePage);

public:
	CBuffer		m_bufTokens;	// tokens buffer
};

/*	****************************************************************************
	Class:		CDocNodeElem
	Synopsis:	contains a pair of document nodes & application it belongs to
*/
class CDocNodeElem : public CDblLink
{
public:
	CAppln                *m_pAppln;
//	IDebugApplicationNode *m_pFileRoot;					// root of directory hierarchy
	IDebugApplicationNode *m_pDocRoot;					// root of template document hierarchy

	// ctor
	CDocNodeElem(CAppln *pAppln, /*IDebugApplicationNode *pFileRoot,*/ IDebugApplicationNode *pDocRoot);

	// dtor
	~CDocNodeElem();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\tlbcache.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Typelibrary cache

File: tlbcache.cpp

Owner: DmitryR

This is the typelibrary cache source file.
===================================================================*/

#include "denpre.h"
#pragma hdrstop

#include "tlbcache.h"
#include "memchk.h"

/*===================================================================
  Globals
===================================================================*/

CTypelibCache g_TypelibCache;

/*===================================================================
  C  T y p e l i b  C a c h e  E n t r y
===================================================================*/

/*===================================================================
CTypelibCacheEntry::CTypelibCacheEntry

Constructor
===================================================================*/
CTypelibCacheEntry::CTypelibCacheEntry()
    :
    m_fInited(FALSE), m_fIdsCached(FALSE), m_fStrAllocated(FALSE),
    m_wszProgId(NULL), m_clsid(CLSID_NULL), m_cmModel(cmUnknown), 
    m_idOnStartPage(DISPID_UNKNOWN), m_idOnEndPage(DISPID_UNKNOWN),
    m_gipTypelib(NULL_GIP_COOKIE)
    {
    }

/*===================================================================
CTypelibCacheEntry::~CTypelibCacheEntry

Destructor
===================================================================*/
CTypelibCacheEntry::~CTypelibCacheEntry()
    {
    if (m_gipTypelib != NULL_GIP_COOKIE)
        {
        g_GIPAPI.Revoke(m_gipTypelib);
        }
        
    if (m_fStrAllocated)
        {
        Assert(m_wszProgId);
		free(m_wszProgId);
        }
    }

/*===================================================================
CTypelibCacheEntry::StoreProgID

Store ProgID with the structure

Parameters
    wszProgId       ProgId
    cbProgId        ProgId byte length

Returns
    HRESULT
===================================================================*/
HRESULT CTypelibCacheEntry::StoreProgID
(
LPWSTR wszProgId, 
DWORD  cbProgId
)
    {
    Assert(wszProgId);
    Assert(*wszProgId != L'\0');
    Assert(cbProgId == (wcslen(wszProgId) * sizeof(WCHAR)));

    // required buffer length
    DWORD cbBuffer = cbProgId + sizeof(WCHAR);
    WCHAR *wszBuffer = (WCHAR *)m_rgbStrBuffer;

    if (cbBuffer > sizeof(m_rgbStrBuffer))
        {
        // the prog id doesn't fit into the member buffer -> allocate
        wszBuffer = (WCHAR *)malloc(cbBuffer);
        if (!wszBuffer)
            return E_OUTOFMEMORY;
        m_fStrAllocated = TRUE;
        }
    
    memcpy(wszBuffer, wszProgId, cbBuffer);
    m_wszProgId = wszBuffer;
    return S_OK;
    }

/*===================================================================
CTypelibCacheEntry::InitByProgID

Real constructor.
Store ProgID. Init CLinkElem portion with ProgID.

Parameters
    wszProgId       ProgId
    cbProgId        ProgId byte length

Returns
    HRESULT
===================================================================*/
HRESULT CTypelibCacheEntry::InitByProgID
(
LPWSTR wszProgId, 
DWORD  cbProgId
)
    {
    StoreProgID(wszProgId, cbProgId);
    
    // init link with prog id as key (length excludes null term)
	CLinkElem::Init(m_wszProgId, cbProgId);
	m_fInited = TRUE;
	return S_OK;
    }


/*===================================================================
CTypelibCacheEntry::InitByCLSID

Real constructor.
Store ProgID. Init CLinkElem portion with CLSID.

Parameters
    clsid           CLSID
    wszProgId       ProgId

Returns
    HRESULT
===================================================================*/
HRESULT CTypelibCacheEntry::InitByCLSID
(
const CLSID &clsid, 
LPWSTR wszProgid
)
    {
    StoreProgID(wszProgid, CbWStr(wszProgid));
    m_clsid = clsid;
        
    // init link with CLSID id as key
	CLinkElem::Init(&m_clsid, sizeof(m_clsid));
	m_fInited = TRUE;
	return S_OK;
    }

/*===================================================================
  C  T y p e l i b  C a c h e
===================================================================*/

/*===================================================================
CTypelibCache::CTypelibCache

Constructor
===================================================================*/
CTypelibCache::CTypelibCache()
    :
    m_fInited(FALSE)
    {
    }
    
/*===================================================================
CTypelibCache::~CTypelibCache

Destructor
===================================================================*/
CTypelibCache::~CTypelibCache()
    {
    UnInit();
    }

/*===================================================================
CTypelibCache::Init

Init

Returns
    HRESULT
===================================================================*/
HRESULT CTypelibCache::Init()
    {
    HRESULT hr;

    hr = m_htProgIdEntries.Init(199);
    if (FAILED(hr))
        return hr;

    hr = m_htCLSIDEntries.Init(97);
    if (FAILED(hr))
        return hr;

    ErrInitCriticalSection(&m_csLock, hr);
    if (FAILED(hr))
        return(hr);
        
    m_fInited = TRUE;
    return S_OK;
    }
    
/*===================================================================
CTypelibCache::UnInit

UnInit

Returns
    HRESULT
===================================================================*/
HRESULT CTypelibCache::UnInit()
    {
    CTypelibCacheEntry *pEntry;
    CLinkElem *pLink;

    // ProgID Hash table
    pLink = m_htProgIdEntries.Head();
    while (pLink)
        {
        pEntry = static_cast<CTypelibCacheEntry *>(pLink);
        pLink = pLink->m_pNext;

        // remove the entry
        delete pEntry;
        }
    m_htProgIdEntries.UnInit();

    // CLSID Hash table
    pLink = m_htCLSIDEntries.Head();
    while (pLink)
        {
        pEntry = static_cast<CTypelibCacheEntry *>(pLink);
        pLink = pLink->m_pNext;

        // remove the entry
        delete pEntry;
        }
    m_htCLSIDEntries.UnInit();

    // Critical section
    if (m_fInited)
        {
        DeleteCriticalSection(&m_csLock);
        m_fInited = FALSE;
        }

    return S_OK;
    }

/*===================================================================
CTypelibCache::CreateComponent

Create the component using the cached info.
Adds cache entry if needed.
To be called from Server.CreateObject

Parameters
    bstrProgID      prog id
    pHitObj         HitObj needed for creation
    ppdisp          [out] IDispatch *
    pclsid          [out] CLSID

Returns
    HRESULT
===================================================================*/
HRESULT CTypelibCache::CreateComponent
(
BSTR         bstrProgID,
CHitObj     *pHitObj,
IDispatch  **ppdisp,
CLSID       *pclsid
)
    {
    HRESULT hr;
    CLinkElem *pElem;
    CTypelibCacheEntry *pEntry;
    CComponentObject *pObj;
    COnPageInfo OnPageInfo;
    CompModel cmModel; 

    *pclsid = CLSID_NULL;
    *ppdisp = NULL;

    if (bstrProgID == NULL || *bstrProgID == L'\0')
        return E_FAIL;

    WCHAR *wszProgId = bstrProgID;
    DWORD  cbProgId  = CbWStr(wszProgId);    // do strlen once

    BOOL fFound = FALSE;
    BOOL bDispIdsCached = FALSE;
    
    Lock();
    pElem = m_htProgIdEntries.FindElem(wszProgId, cbProgId);
    if (pElem)
        {
        // remember the elements of the entry while inside lock
        pEntry = static_cast<CTypelibCacheEntry *>(pElem);

        // return clsid
        *pclsid = pEntry->m_clsid;

        // prepate OnPageInfo with DispIds to pass to the creation function
        if (pEntry->m_fIdsCached)
            {
            OnPageInfo.m_rgDispIds[ONPAGEINFO_ONSTARTPAGE] = pEntry->m_idOnStartPage;
            OnPageInfo.m_rgDispIds[ONPAGEINFO_ONENDPAGE] = pEntry->m_idOnEndPage;
            bDispIdsCached = TRUE;
            }
        // remember the model
        cmModel = pEntry->m_cmModel;

        fFound = TRUE;
        }
    UnLock();

    if (fFound)
        {
        // create the object
        hr = pHitObj->PPageComponentManager()->AddScopedUnnamedInstantiated
            (
            csPage,
            *pclsid,
            cmModel,
            bDispIdsCached ? &OnPageInfo : NULL,
            &pObj
            );

        // get IDispatch*
        if (SUCCEEDED(hr))
            hr = pObj->GetAddRefdIDispatch(ppdisp);

        // return if succeeded
        if (SUCCEEDED(hr))
            {
            // don't keep the object around unless needed
            if (pObj->FEarlyReleaseAllowed())
                pHitObj->PPageComponentManager()->RemoveComponent(pObj);
            return S_OK;
            }

        // on failure remove from the cache and pretend
        // as if it was never found

        Lock();
        pElem = m_htProgIdEntries.DeleteElem(wszProgId, cbProgId);
        UnLock();

        if (pElem)
            {
            // Element removed from cache - delete the CacheEntry
            pEntry = static_cast<CTypelibCacheEntry *>(pElem);
            delete pEntry;
            }

        // don't return bogus CLSID
        *pclsid = CLSID_NULL;
        }

    // Not found in the cache. Create the object, get the info, and
    // insert the new cache entry.

   	hr = CLSIDFromProgID((LPCOLESTR)wszProgId, pclsid);
   	if (FAILED(hr))
   	    return hr;  // couldn't even get clsid - don't cache

    hr = pHitObj->PPageComponentManager()->AddScopedUnnamedInstantiated
        (
        csPage,
        *pclsid,
        cmUnknown,
        NULL,
        &pObj
        );
   	if (FAILED(hr))
   	    return hr;  // couldn't create object - don't cache

    // object created - get IDispatch*
    if (SUCCEEDED(hr))
        hr = pObj->GetAddRefdIDispatch(ppdisp);
   	if (FAILED(hr))
   	    return hr;  // couldn't get IDispatch* - don't cache

    // create new CTypelibCacheEntry
    pEntry = new CTypelibCacheEntry;
    if (!pEntry)
        return S_OK; // no harm

    // init link entry
    if (FAILED(pEntry->InitByProgID(wszProgId, cbProgId)))
        {
        delete pEntry;
        return S_OK; // no harm
        }
        
    // remember stuff in pEntry
    pEntry->m_clsid = *pclsid;
    pEntry->m_cmModel = pObj->GetModel();

    const COnPageInfo *pOnPageInfo = pObj->GetCachedOnPageInfo();
    if (pOnPageInfo)
        {
        pEntry->m_fIdsCached = TRUE;
        pEntry->m_idOnStartPage = pOnPageInfo->m_rgDispIds[ONPAGEINFO_ONSTARTPAGE];
        pEntry->m_idOnEndPage = pOnPageInfo->m_rgDispIds[ONPAGEINFO_ONENDPAGE];
        }
    else
        {
        pEntry->m_fIdsCached = FALSE;
        pEntry->m_idOnStartPage = DISPID_UNKNOWN;
        pEntry->m_idOnEndPage = DISPID_UNKNOWN;
        }

    // try to get the typelib
    pEntry->m_gipTypelib = NULL_GIP_COOKIE;
    if (FIsWinNT())  // don't do GIP cookies on Win95
        {
        ITypeInfo *ptinfo;
        if (SUCCEEDED((*ppdisp)->GetTypeInfo(0, 0, &ptinfo)))
            {
            ITypeLib *ptlib;
            UINT idx;
            if (SUCCEEDED(ptinfo->GetContainingTypeLib(&ptlib, &idx)))
                {
                // got it! convert to gip cookie
                DWORD gip;
                if (SUCCEEDED(g_GIPAPI.Register(ptlib, IID_ITypeLib, &gip)))
                    {
                    // remember the gip cookie with pEntry
                    pEntry->m_gipTypelib = gip;
                    }
                
                ptlib->Release();
                }
            ptinfo->Release();
            }
        }
        
    // pEntry is ready -- try to insert it into cache
    BOOL fInserted = FALSE;
    Lock();
    // make sure some other thread didn't insert it already
    if (m_htProgIdEntries.FindElem(wszProgId, cbProgId) == NULL)
        {
        if (m_htProgIdEntries.AddElem(pEntry))
            fInserted = TRUE;
        }
    UnLock();

    // cleanup
    if (!fInserted)
        delete pEntry;
        
    // don't keep the object around unless needed
    if (pObj->FEarlyReleaseAllowed())
        pHitObj->PPageComponentManager()->RemoveComponent(pObj);

    return S_OK;
    }

/*===================================================================
CTypelibCache::RememberProgidToCLSIDMapping

Adds an entry to CLSID hashtable.
To be called from template after mapping ProgId to CLSID.

Parameters
    wszProgID      prog id
    clsid          clsid

Returns
    HRESULT
===================================================================*/
HRESULT CTypelibCache::RememberProgidToCLSIDMapping
(
WCHAR *wszProgid, 
const CLSID &clsid
)
    {
    HRESULT hr;
    CLinkElem *pElem;
    CTypelibCacheEntry *pEntry;

    // check if already there first
    BOOL fFound = FALSE;
    Lock();
    if (m_htCLSIDEntries.FindElem(&clsid, sizeof(CLSID)) != NULL)
        fFound = TRUE;
    UnLock();
    if (fFound)
        return S_OK;
    
    // create new entry    
    pEntry = new CTypelibCacheEntry;
    if (!pEntry)
        return E_OUTOFMEMORY;

    BOOL fInserted = FALSE;
    
    // remember prog id and init link entry
    hr = pEntry->InitByCLSID(clsid, wszProgid);
    
    if (SUCCEEDED(hr))
        {
        Lock();
        // make sure some other thread didn't insert it already
        if (m_htCLSIDEntries.FindElem(&clsid, sizeof(CLSID)) == NULL)
            {
            if (m_htCLSIDEntries.AddElem(pEntry))
                fInserted = TRUE;
            }
        UnLock();
        }

    // cleanup
    if (!fInserted)
        delete pEntry;
        
    return hr;
    }

/*===================================================================
CTypelibCache::UpdateMappedCLSID

Update CLSID since remembered.

To be called from object creation code to update CLSID
if the object creation failed.

Parameters
    *pclsid         [in, out] CLSID

Returns
    HRESULT
        S_FALSE = didn't change
        S_OK    = did change and the new one found
===================================================================*/
HRESULT CTypelibCache::UpdateMappedCLSID
(
CLSID *pclsid
)
    {
    HRESULT hr = S_FALSE; // not found
    CLinkElem *pElem;
    CTypelibCacheEntry *pEntry;
    CLSID clsidNew;
    
    Lock();
    // Do everything under lock so the ProgID stored in
    // the entry is still valid.
    // Not very perfomant -- but is is an error path anyway
    
    pElem = m_htCLSIDEntries.FindElem(pclsid, sizeof(CLSID));
    if (pElem)
        {
        pEntry = static_cast<CTypelibCacheEntry *>(pElem);

        // find new mapping
        if (SUCCEEDED(CLSIDFromProgID(pEntry->m_wszProgId, &clsidNew)))
            {
            // compare with the old one
            if (!IsEqualCLSID(clsidNew, *pclsid))
                {
                // the mapping did change!
                *pclsid = clsidNew;
                hr = S_OK;
                }
            }
        }
        
    UnLock();

    return hr;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\thrdgate.h ===
/*===================================================================
Microsoft IIS 5.0 (ASP)

Microsoft Confidential.
Copyright 1998 Microsoft Corporation. All Rights Reserved.

Component: Thread Gate header

File: thrdgate.h

Owner: DmitryR

This file contains the definitons for the Thread Gate
===================================================================*/

#ifndef THRDGATE_H
#define THRDGATE_H

typedef struct _THREADGATE_CONFIG {

    BOOL  fEnabled;
    DWORD msTimeSlice;
    DWORD msSleepDelay;
    DWORD nSleepMax;
    DWORD nLoadLow;
    DWORD nLoadHigh;
    DWORD nMinProcessorThreads;
    DWORD nMaxProcessorThreads;

}   THREADGATE_CONFIG;

HRESULT InitThreadGate(THREADGATE_CONFIG *);

void UnInitThreadGate();

void EnterThreadGate(DWORD msCurrentTickCount);
void LeaveThreadGate();

#endif // THRDGATE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\tlbcache.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1997 Microsoft Corporation. All Rights Reserved.

Component: Typelibrary cache

File: tlbcache.h

Owner: DmitryR

This is the typelibrary cache header file.
===================================================================*/

#ifndef _ASP_TLBCACHE_H
#define _ASP_TLBCACHE_H

/*===================================================================
  Includes
===================================================================*/

#include "compcol.h"
#include "hashing.h"
#include "idhash.h"
#include "dbllink.h"
#include "util.h"
#include "viperint.h"
#include "memcls.h"

/*===================================================================
  Defines
===================================================================*/

class CHitObj;

/*===================================================================
  C  T y p e l i b  C a c h e  E n t r y
===================================================================*/

class CTypelibCacheEntry : public CLinkElem
    {
    
friend class CTypelibCache;
    
private:
    DWORD       m_fInited : 1;
    DWORD       m_fIdsCached : 1;
    DWORD       m_fStrAllocated : 1;

    WCHAR      *m_wszProgId;
    CLSID       m_clsid;
    CompModel   m_cmModel;
    DISPID      m_idOnStartPage;
    DISPID      m_idOnEndPage;
    DWORD       m_gipTypelib;

    // buffer to keep prog id (when it fits)
    WCHAR       m_rgbStrBuffer[60];


    CTypelibCacheEntry();
    ~CTypelibCacheEntry();

    HRESULT StoreProgID(LPWSTR wszProgid, DWORD cbProgid);
    HRESULT InitByProgID(LPWSTR wszProgid, DWORD cbProgid);
    HRESULT InitByCLSID(const CLSID &clsid, LPWSTR wszProgid);
    
    // Cache on per-class basis
    ACACHE_INCLASS_DEFINITIONS()
    };

/*===================================================================
  C  T y p e l i b  C a c h e
===================================================================*/

class CTypelibCache
    {
private:
    DWORD m_fInited : 1;
    CHashTableStr m_htProgIdEntries;
    CHashTableCLSID m_htCLSIDEntries;
    CRITICAL_SECTION m_csLock;

    void Lock()   { EnterCriticalSection(&m_csLock); }
    void UnLock() { LeaveCriticalSection(&m_csLock); }

public:
    CTypelibCache();
    ~CTypelibCache();

    HRESULT Init();
    HRESULT UnInit();

    // to be called from Server.CreateObject
    HRESULT CreateComponent
        (
        BSTR         bstrProgID,
        CHitObj     *pHitObj,
        IDispatch  **ppdisp,
        CLSID       *pclsid
        );

    // to be called from template after mapping ProgId to CLSID
    HRESULT RememberProgidToCLSIDMapping
        (
        WCHAR *wszProgid, 
        const CLSID &clsid
        );
    // to be called from object creation code to update CLSID
    // if changed since mapping
    HRESULT UpdateMappedCLSID
        (
        CLSID *pclsid
        );
        
    };


/*===================================================================
  Globals
===================================================================*/

extern CTypelibCache g_TypelibCache;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\util.h ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: misc

File: util.h

Owner: AndrewS

This file contains random useful utility macros.
===================================================================*/

#ifndef _UTIL_H
#define _UTIL_H

#include <dbgutil.h>

// Generally useful
#define PPVOID VOID **
#define BOOLB BYTE

/* S E R V E R _ G E T
 *
 * Get a server variable from ISAPI.  Automatically queries for the buffer
 * size and increases the BUFFER object.
 *
 * Usage:
 *		DWORD dwLen;
 *		char *szValue = SERVER_GET(<ecb>, <szKey>, bufferObj, &dwLen)
 *
 * bufferObj is a STACK_BUFFER object than can be dynamically resized as necessary
 *
 * On return,
 *       bufferObj.QueryPtr() points to data.  dwLen is the real length of the variable.
 */
class CIsapiReqInfo;
BOOL Server_FindKey(CIsapiReqInfo *pIReq, char *szBuffer, DWORD *dwBufLen, const char *szKey);

inline BOOL SERVER_GET(CIsapiReqInfo *pIReq, const char *szKey, BUFFER *pBuffer, DWORD *pdwBufLen) {

    DWORD   dwBufLen = pBuffer->QuerySize();

    if (Server_FindKey(pIReq, (char *)pBuffer->QueryPtr(), &dwBufLen, szKey)) {
        *pdwBufLen = dwBufLen;
        return TRUE;
    }

    if (!pBuffer->Resize(dwBufLen)) {
        SetLastError(E_OUTOFMEMORY);
        return FALSE;
    }

    *pdwBufLen = dwBufLen;

    return Server_FindKey(pIReq, (char *)pBuffer->QueryPtr(), pdwBufLen, szKey);
}

/* V a r i a n t R e s o l v e D i s p a t c h
 *
 * Convert an IDispatch pointer to a Variant by calling IDispatch::Invoke
 * on dispid(0) repeatedly until a non-IDispatch Variant is returned
 */

HRESULT VariantResolveDispatch(VARIANT *pVarOut, VARIANT *pVarIn, const GUID &iidObj, int nObjId);

/* V a r i a n t G e t B S T R
 *
 * Get BSTR from a variant when available
 */

BSTR VariantGetBSTR(const VARIANT *pvar);

/* F i n d A p p l i c a t i o n P a t h
 *
 *  Find the application path for this request.
 */

HRESULT FindApplicationPath(CIsapiReqInfo *pIReq, TCHAR *szPath, int cbPath);

/* N o r m a l i z e
 *
 * Convert filenames to a uniform format
 */
int Normalize(TCHAR *szSrc);
#ifdef DBG
BOOLB IsNormalized(const TCHAR* sz);
#endif	// DBG

/* H T M L E n c o d e L e n
 *
 * Returns the storage requirements to HTML encode a string.
 */
int HTMLEncodeLen(const char *szSrc, UINT uCodePage, BSTR bstrIn, BOOL fEncodeExtCharOnly = FALSE);


/* H T M L E n c o d e
 *
 * HTML encoeds a string.
 */
char *HTMLEncode(char *szDest, const char *szSrc, UINT uCodePage, BSTR bstrIn, BOOL fEncodeExtCharOnly = FALSE);


/* U R L E n c o d e L e n
 *
 * Returns the storage requirements to URL encode a string
 */
int URLEncodeLen(const char *szSrc);


/* U R L E n c o d e
 *
 * Hex escape non alphanumeric characters and change spaces to '+'.
 */
char *URLEncode(char *szDest, const char *szSrc);


/* D B C S E n c o d e L e n
 *
 * Returns the storage requirements to DBCS encode a string
 */

int DBCSEncodeLen(const char *szSrc);

/* D B C S E n c o d e
 *
 * Hex escape characters with the upper bit set - this will encode DBCS.
 */
char *DBCSEncode(char *szDest, const char *szSrc);


/* U R L P a t h E n c o d e L e n
 *
 * Returns the storage requirements to URL path encode a string
 */
int URLPathEncodeLen(const char *szSrc);


/* U R L P a t h E n c o d e
 *
 * Hex escape non alphanumeric or syntax characters until a ? is reached.
 */
char *URLPathEncode(char *szDest, const char *szSrc);


/* s t r c p y E x
 *
 * Like strcpy() but returns a pointer to the NUL character on return
 */
char *strcpyExA(char *szDest, const char *szSrc);


/* w c s c p y E x
 *
 * strcpyEx for wide strings
 */
wchar_t *strcpyExW(wchar_t *szDest, const wchar_t *szSrc);

#if UNICODE
#define strcpyEx    strcpyExW
#else
#define strcpyEx    strcpyExA
#endif

/* G e t B r a c k e t i n g P a i r
 *
 * searches an ordered array and returns the bracketing pair of 'n', i.e.
 * the largest value <= 'n', and the smallest value >= 'n', or points
 * to end() if no bracketing pair exists.
 *
 * Note: STL is not supported with NT build - when such support is added,
 *       replace this function with either 'lower_bound' or 'upper_bound'.
 */
template<class EleType, class ValType, class Ordering>
void GetBracketingPair(const ValType &value, EleType *pBegin, EleType *pEnd, Ordering FIsLess, EleType **ppLB, EleType **ppUB)
	{
	EleType *pT1, *pT2;
	if (ppLB == NULL) ppLB = &pT1;
	if (ppUB == NULL) ppUB = &pT2;

	*ppLB = pBegin;					// Temporary use to see if we've moved pBegin
	*ppUB = pEnd;					// Temporary use to see if we've moved pEnd

	while (pBegin < pEnd)
		{
		EleType *pMidpt = &pBegin[(pEnd - pBegin) >> 1];
		if (FIsLess(*pMidpt, value))
			pBegin = pMidpt + 1;

		else if (FIsLess(value, *pMidpt))
			pEnd = pMidpt;

		else
			{
			*ppLB = *ppUB = pMidpt;
			return;
			}
		}

	if (pBegin == *ppUB)		// at end, no upper bound
		{
		if (pBegin == *ppLB)	// low bound was initially equal to upper bound
			*ppLB = NULL;		// lower bound does not exits
		else
			*ppLB = pEnd - 1;	// lower bound is pEnd - 1

		*ppUB = NULL;
		}

	else if (pBegin != *ppLB)	// pBegin was moved; pBegin-1 is the lower bound
		{
		*ppLB = pBegin - 1;
		*ppUB = pBegin;
		}

	else						// pBegin was not moved - no lower bound exists
		{
		*ppLB = NULL;
		*ppUB = pBegin;
		}
	}


/* V a r i a n t D a t e T o C T i m e
 *
 * Converts a timestamp stored as a Variant date to the format C && C++ use.
 */
HRESULT VariantDateToCTime(DATE dt, time_t *ptResult);


/* C T i m e T o V a r i a n t D a t e
 *
 * Converts a timestamp stored as a time_t to a Variant Date
 */
HRESULT CTimeToVariantDate(const time_t *ptNow, DATE *pdtResult);


/* C T i m e T o S t r i n g G M T
 *
 * Converts a C language time_t value to a string using the format required for
 * the internet
 */
const DATE_STRING_SIZE = 30;	// date strings will not be larger than this size
HRESULT CTimeToStringGMT(const time_t *ptNow, char szBuffer[DATE_STRING_SIZE], BOOL fFunkyCookieFormat = FALSE);


//DeleteInterfaceImp calls 'delete' and NULLs the pointer
#define DeleteInterfaceImp(p)\
			{\
			if (NULL!=p)\
				{\
				delete p;\
				p=NULL;\
				}\
			}

//ReleaseInterface calls 'Release' and NULLs the pointer
#define ReleaseInterface(p)\
			{\
			if (NULL!=p)\
				{\
				p->Release();\
				p=NULL;\
				}\
			}

/*
 * String handling stuff
 */
HRESULT SysAllocStringFromSz(CHAR *sz, DWORD cch, BSTR *pbstrRet, UINT lCodePage = CP_ACP);

/*
 * A simple class to convert WideChar to Multibyte.  Uses object memory, if sufficient,
 * else allocates memory from the heap.  Intended to be used on the stack.
 */

class CWCharToMBCS
{
private:

    LPSTR    m_pszResult;
    char     m_resMemory[256];
    INT      m_cbResult;

public:

    CWCharToMBCS() { m_pszResult = m_resMemory; m_cbResult = 0; }
    ~CWCharToMBCS();
    
    // Init(): converts the widechar string at pWSrc to an MBCS string in memory 
    // managed by CWCharToMBCS

    HRESULT Init(LPCWSTR  pWSrc, UINT lCodePage = CP_ACP, int cch = -1);

    // GetString(): returns a pointer to the converted string.  Passing TRUE
    // gives the ownership of the memory to the caller.  Passing TRUE has the
    // side effect of clearing the object's contents with respect to the
    // converted string.  Subsequent calls to GetString(). after which a TRUE
    // value was passed, will result in a pointer to an empty string being
    // returned.

    LPSTR GetString(BOOL fTakeOwnerShip = FALSE);

    // returns the number of bytes in the converted string - NOT including the
    // NULL terminating byte.  Note that this is the number of bytes in the
    // string and not the number of characters.

    INT   GetStringLen() { return (m_cbResult ? m_cbResult - 1 : 0); }
};

/*
 * A simple class to convert Multibyte to Widechar.  Uses object memory, if sufficient,
 * else allocates memory from the heap.  Intended to be used on the stack.
 */

class CMBCSToWChar
{
private:

    LPWSTR   m_pszResult;
    WCHAR    m_resMemory[256];
    INT      m_cchResult;

public:

    CMBCSToWChar() { m_pszResult = m_resMemory; m_cchResult = 0; }
    ~CMBCSToWChar();
    
    // Init(): converts the MBCS string at pSrc to a Wide string in memory 
    // managed by CMBCSToWChar

    HRESULT Init(LPCSTR  pSrc, UINT lCodePage = CP_ACP, int cch = -1);

    // GetString(): returns a pointer to the converted string.  Passing TRUE
    // gives the ownership of the memory to the caller.  Passing TRUE has the
    // side effect of clearing the object's contents with respect to the
    // converted string.  Subsequent calls to GetString(). after which a TRUE
    // value was passed, will result in a pointer to an empty string being
    // returned.

    LPWSTR GetString(BOOL fTakeOwnerShip = FALSE);

    // returns the number of WideChars in the converted string, not bytes.

    INT   GetStringLen() { return (m_cchResult ? m_cchResult - 1 : 0); }
};

/*
 * Output Debug String should occur in Debug only
 */

inline void DebugOutputDebugString(LPCSTR x)
    {
#ifndef _NO_TRACING_
    DBGPRINTF((DBG_CONTEXT, x));
#else
#ifdef DBG
    OutputDebugStringA(x); 
#endif
#endif
    }

inline void __cdecl DebugFilePrintf(LPCSTR fname, LPCSTR fmt, ...)
    {
#ifdef DBG
    FILE *f = fopen(fname, "a");
    if (f)
        {
        va_list marker;
        va_start(marker, fmt);
        vfprintf(f, fmt, marker);
        va_end(marker);
        fclose(f);
        }
#endif
    }

/*
 * Duplicate CHAR String using proper malloc (moved from error.h)
 */

CHAR *StringDupA(CHAR *pszStrIn, BOOL fDupEmpty = FALSE);


/*
 * Duplicate WCHAR String using proper malloc
 */

WCHAR *StringDupW(WCHAR *pwszStrIn, BOOL fDupEmpty = FALSE);

#if UNICODE
#define StringDup   StringDupW
#else
#define StringDup   StringDupA
#endif

/*
 * Duplicate WCHAR String into a UTF-8 string
 */
CHAR *StringDupUTF8(WCHAR  *pwszStrIn, BOOL fDupEmpty = FALSE);

/*
 * The same using macro to allocate memory from stack:

WSTR_STACK_DUP
(
wsz     -- string to copy
buf     -- user supplied buffer (to use before trying alloca())
pwszDup -- [out] the pointer to copy (could be buffer or alloca())
)
    
 *
 */

inline HRESULT WSTR_STACK_DUP(WCHAR *wsz, BUFFER *buf, WCHAR **ppwszDup) {

    HRESULT     hr = S_OK;
    DWORD cbwsz = wsz && *wsz ? (wcslen(wsz)+1)*sizeof(WCHAR) : 0;

    *ppwszDup = NULL;

    if (cbwsz == 0);

    else if (!buf->Resize(cbwsz)) {

        hr = E_OUTOFMEMORY;
    }
    else {
        *ppwszDup = (WCHAR *)buf->QueryPtr();
        memcpy(*ppwszDup, wsz, cbwsz);
    }

    return hr;
}

/*
 * String length (in bytes) of a WCHAR String
 */

DWORD CbWStr(WCHAR *pwszStrIn);

/*
 * Parent path support function
 */

BOOL DotPathToPath(TCHAR *szDest, const TCHAR *szFileSpec, const TCHAR *szParentDirectory);

/*
 * Check if is global.asa
 */

BOOL FIsGlobalAsa(const TCHAR *szPath, DWORD cchPath = 0);

/*
 * Encode/decode cookie
 */

HRESULT EncodeSessionIdCookie(DWORD dw1, DWORD dw2, DWORD dw3, char *pszCookie);
HRESULT DecodeSessionIdCookie(const char *pszCookie, DWORD *pdw1, DWORD *pdw2, DWORD *pdw3);

/*
 * Typelibrary name from the registry
 */

HRESULT GetTypelibFilenameFromRegistry(const char *szUUID, const char *szVersion,
                                       LCID lcid, char *szName, DWORD cbName);

/*
 * Get security descriptor for file
 */
DWORD GetSecDescriptor(LPCTSTR lpFileName, PSECURITY_DESCRIPTOR *ppSecurityDescriptor, DWORD *pnLength);


/*
 * Get File Attributes (Ex)
 */
HRESULT AspGetFileAttributes(LPCTSTR szFileName, WIN32_FILE_ATTRIBUTE_DATA *pfad = NULL);

/*
 * Fix for UTF8 CharNext
 */
char *AspCharNextA(WORD wCodePage, const char *pchNext);

VOID AspDoRevertHack( HANDLE * phToken );
VOID AspUndoRevertHack( HANDLE * phToken );

#endif // _UTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\txnsup.h ===
/*++

   Copyright    (c)    2001    Microsoft Corporation

   Module  Name :

       txnsup.h

   Abstract:
       Defines class for implementation of transaction routines SetAbort
	   and SetComplete.

   Author:

       Andy Morrison    ( andymorr )     April-2001 

   Revision History:

--*/
#ifndef _TXNSUP_H
#define _TXNSUP_H

#include "asptxn.h"

class CASPObjectContext : public IASPObjectContextImpl, public CFTMImplementation, public ITransactionStatus
{
private:
    LONG        m_cRefs;
    BOOL        m_fAborted;

public:

    CASPObjectContext() { 
        m_cRefs = 1;  
        m_fAborted = FALSE;
        CDispatch::Init(IID_IASPObjectContext, Glob(pITypeLibTxn));
    };

   	//Non-delegating object IUnknown

	STDMETHODIMP		 QueryInterface(REFIID, PPVOID);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

    // IASPObjectContext

	STDMETHOD(SetAbort)();
	STDMETHOD(SetComplete)();

    // ITransactionStatus
    STDMETHODIMP SetTransactionStatus(HRESULT   hr);
    STDMETHODIMP GetTransactionStatus(HRESULT  *pHrStatus);

    BOOL    FAborted()  { return m_fAborted; };

};


inline HRESULT CASPObjectContext::SetAbort()
{
    HRESULT             hr = E_NOTIMPL;
    IObjectContext *    pContext = NULL;

    hr = GetObjectContext(&pContext);
    if( SUCCEEDED(hr) )
    {
        hr = pContext->SetAbort();

        pContext->Release();

        m_fAborted = TRUE;
    }
    
    return hr;
}

inline HRESULT CASPObjectContext::SetComplete()
{
    HRESULT             hr = E_NOTIMPL;
    IObjectContext *    pContext = NULL;

    hr = GetObjectContext(&pContext);
    if( SUCCEEDED(hr) )
    {
        hr = pContext->SetComplete();

        pContext->Release();

        m_fAborted = FALSE;
    }
    
    return hr;
}

inline HRESULT CASPObjectContext::SetTransactionStatus(HRESULT  hr)
{
    // if m_fAborted is already set, this indicates that the
    // script set it and we should not reset it.

    if (m_fAborted == TRUE);
    
    else if (hr == XACT_E_ABORTED) {
        m_fAborted = TRUE;
    }
    else if (hr == S_OK) {
        m_fAborted = FALSE;
    }

    return S_OK;
}

inline HRESULT CASPObjectContext::GetTransactionStatus(HRESULT  *pHrResult)
{
    if (m_fAborted == TRUE) {
        *pHrResult = XACT_E_ABORTED;
    }
    else {
        *pHrResult = S_OK;
    }

    return S_OK;
}

/*===================================================================
CASPObjectContext::QueryInterface
CASPObjectContext::AddRef
CASPObjectContext::Release

IUnknown members for CASPObjectContext object.

===================================================================*/
inline HRESULT CASPObjectContext::QueryInterface
(
REFIID riid,
PPVOID ppv
)
    {
    *ppv = NULL;

    /*
     * The only calls for IUnknown are either in a nonaggregated
     * case or when created in an aggregation, so in either case
     * always return our IUnknown for IID_IUnknown.
     */

    if (IID_IUnknown == riid 
        || IID_IDispatch == riid 
        || IID_IASPObjectContext == riid)
        *ppv = static_cast<IASPObjectContext *>(this);

    else if (IID_ITransactionStatus == riid)
        *ppv = static_cast<ITransactionStatus *>(this);

    else if (IID_IMarshal == riid) {
        *ppv = static_cast<IMarshal *>(this);
    }

    //AddRef any interface we'll return.
    if (NULL != *ppv) {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }

    return ResultFromScode(E_NOINTERFACE);
}


inline STDMETHODIMP_(ULONG) CASPObjectContext::AddRef(void) {

    return InterlockedIncrement(&m_cRefs);
}


inline STDMETHODIMP_(ULONG) CASPObjectContext::Release(void) {

    LONG cRefs = InterlockedDecrement(&m_cRefs);
    if (cRefs)
        return cRefs;

    delete this;
    return 0;
}

class CASPDummyObjectContext : public IASPObjectContextImpl, public CFTMImplementation
{

private:
    LONG        m_cRefs;

public:

    CASPDummyObjectContext() { m_cRefs = 1; };

   	//Non-delegating object IUnknown

	STDMETHODIMP		 QueryInterface(REFIID, PPVOID);
	STDMETHODIMP_(ULONG) AddRef(void);
	STDMETHODIMP_(ULONG) Release(void);

    // IASPObjectContext

	STDMETHOD(SetAbort)();
	STDMETHOD(SetComplete)();
};

/*===================================================================
CASPDummyObjectContext::QueryInterface
CASPDummyObjectContext::AddRef
CASPDummyObjectContext::Release

IUnknown members for CASPDummyObjectContext object.

===================================================================*/
inline HRESULT CASPDummyObjectContext::QueryInterface
(
REFIID riid,
PPVOID ppv
)
    {
    *ppv = NULL;

    /*
     * The only calls for IUnknown are either in a nonaggregated
     * case or when created in an aggregation, so in either case
     * always return our IUnknown for IID_IUnknown.
     */

    if (IID_IUnknown == riid 
        || IID_IDispatch == riid 
        || IID_IASPObjectContext == riid)
        *ppv = static_cast<CASPDummyObjectContext *>(this);

    else if (IID_IMarshal == riid) {
        *ppv = static_cast<IMarshal *>(this);
    }

    //AddRef any interface we'll return.
    if (NULL != *ppv) {
        ((LPUNKNOWN)*ppv)->AddRef();
        return S_OK;
    }

    return ResultFromScode(E_NOINTERFACE);
}


inline STDMETHODIMP_(ULONG) CASPDummyObjectContext::AddRef(void) {
    return InterlockedIncrement(&m_cRefs);
}


inline STDMETHODIMP_(ULONG) CASPDummyObjectContext::Release(void) {

    LONG cRefs = InterlockedDecrement(&m_cRefs);
    if (cRefs)
        return cRefs;

    delete this;
    return 0;
}

inline HRESULT CASPDummyObjectContext::SetAbort()
{
    ExceptionId(IID_IASPObjectContext, IDE_OBJECTCONTEXT, IDE_OBJECTCONTEXT_NOT_TRANSACTED);
    return E_FAIL;
}

inline HRESULT CASPDummyObjectContext::SetComplete()
{
    ExceptionId(IID_IASPObjectContext, IDE_OBJECTCONTEXT, IDE_OBJECTCONTEXT_NOT_TRANSACTED);
    return E_FAIL;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\iis\svcs\cmp\asp\util.cpp ===
/*===================================================================
Microsoft Denali

Microsoft Confidential.
Copyright 1996 Microsoft Corporation. All Rights Reserved.

Component: misc

File: util.cpp

Owner: AndrewS

This file contains random useful utility functions
===================================================================*/
#include "denpre.h"
#pragma hdrstop

#include "MemChk.h"
#include "locale.h"
#include <malloc.h>
#include <mbstring.h>
#include <mbctype.h>

extern  CPINFO  g_SystemCPInfo;     // global System CodePage default info.

// ***************************************************************************
// M I S C
// ***************************************************************************

/*===================================================================
Server_ValSize
Server_FindKey

This helper function assists in the implementation of the
SERVER_GET macro

Parameters:
    PIReq        pointer to CIsapiReqInfo
    szBuffer    Buffer to write to
    pdwBufLen   On entry: size of the buffer
                On Exit, actual size of the buffer
                    (required size if buffer was too small)
    szKey       Key to search for

Returns:
    TRUE - it succeeded, string in szBuffer
    FALSE - buffer was too small, *pdwBufLen has required size
===================================================================*/
BOOL Server_FindKey
(
CIsapiReqInfo *PIReq,
char *szBuffer,
DWORD *pdwBufLen,
const char *szKey
)
    {
    // If no buffer, then just calculate the size (old behavior)
    Assert (szBuffer != NULL);

    if (PIReq && PIReq->GetServerVariableA(const_cast<char *>(szKey), szBuffer, pdwBufLen))
        return TRUE;

    szBuffer[0] = '\0';

    // Bug 965: If malicious request comes, do not _alloca, and pretend like we
    //          didn't get anything.  This is OK - the rest of Denali will just assume
    //          there were no cookies, request parameters or client headers.
    //
    if (!PIReq || GetLastError() == ERROR_INVALID_INDEX || *pdwBufLen > REQUEST_ALLOC_MAX)
        {
        *pdwBufLen = 1;
        return TRUE;
        }

    return FALSE;
    }


/*===================================================================
 * F i n d A p p l i c a t i o n P a t h
 *
 * Get application path from CIsapiReqInfo. It gets the metabase key and
 * strips it of prefix.
 *
 * Parameters:
 *    PIReq      - CIsapiReqInfo
 *    pszPath   - [out] the application path (URL)
 *
 * Returns:
 *    HRESULT
 *
 * Allocates pszPath using malloc()
===================================================================*/
HRESULT FindApplicationPath
(
CIsapiReqInfo *PIReq,
TCHAR *szPath,
int cbPath
)
    {
    if (!PIReq)
        return E_FAIL;

    // Extract virtual path from the metabase path
    TCHAR *pch = NULL;
    int   cch = 0;

    // Get the metabase path
    TCHAR *szMDPath = PIReq->QueryPszApplnMDPath();
    if (szMDPath)
        {
        Assert(szMDPath[0] == _T('/'));

        pch = szMDPath;

        // find 4th '/' in "/LM/w3svc/X/root/vroot" after starting '/'
        for (int i = 0; i < 4 && pch != NULL; i++)
            pch = _tcschr(pch+1, _T('/'));

        if (pch)
            cch = _tcslen(pch);
        else
            cch = 1;  // special case of default app -- assume /
        }
    else
        {
        // assume /
        pch = NULL;
        cch = 1;
        }

    if (cch >= (int)(cbPath/sizeof(TCHAR)))
        return E_FAIL;

    _tcscpy(szPath, pch ? pch : _T("/"));

    // remove trailing / if any
    if (cch > 1)
        {
        pch = &szPath[cch - 1];
        if (*pch == _T('/'))
            *pch = _T('\0');
        }

    return S_OK;
    }

/*===================================================================
VariantResolveDispatch

    Convert an IDispatch VARIANT to a (non-Dispatch) VARIANT by
    invoking its default property until the object that remains
    is not an IDispatch.  If the original VARIANT is not an IDispatch
    then the behavior is identical to VariantCopyInd(), with the
    exception that arrays are copied.

Parameters:
    pVarOut      - if successful, the return value is placed here
    pVarIn       - the variant to copy
    GUID *iidObj - the calling interface (for error reporting)
    nObjID       - the Object's name from the resource file

    pVarOut need not be initialized.  Since pVarOut is a new
    variant, the caller must VariantClear this object.

Returns:
    The result of calling IDispatch::Invoke.  (either S_OK or
    the error resulting from the call to Invoke)   may also return
    E_OUTOFMEMORY if an allocation fails

    This function always calls Exception() if an error occurs -
    this is because we need to call Exception() if an IDispatch
    method raises an exception.  Instead of having the client
    worry about whether we called Exception() on its behalf or
    not, we always raise the exception.
===================================================================*/

HRESULT VariantResolveDispatch(VARIANT *pVarOut, VARIANT *pVarIn, const GUID &iidObj, int nObjID)
    {
    VARIANT     varResolved;        // value of IDispatch::Invoke
    DISPPARAMS  dispParamsNoArgs = {NULL, NULL, 0, 0};
    EXCEPINFO   ExcepInfo;
    HRESULT     hrCopy;

    Assert (pVarIn != NULL && pVarOut != NULL);

    VariantInit(pVarOut);
    if (V_VT(pVarIn) & VT_BYREF)
        hrCopy = VariantCopyInd(pVarOut, pVarIn);
    else
        hrCopy = VariantCopy(pVarOut, pVarIn);

    if (FAILED(hrCopy))
        {
        ExceptionId(iidObj, nObjID, (hrCopy == E_OUTOFMEMORY)? IDE_OOM : IDE_UNEXPECTED);
        return hrCopy;
        }

    // follow the IDispatch chain.
    //
    while (V_VT(pVarOut) == VT_DISPATCH)
        {
        HRESULT hrInvoke = S_OK;

        // If the variant is equal to Nothing, then it can be argued
        // with certainty that it does not have a default property!
        // hence we return DISP_E_MEMBERNOTFOUND for this case.
        //
        if (V_DISPATCH(pVarOut) == NULL)
            hrInvoke = DISP_E_MEMBERNOTFOUND;
        else
            {
            VariantInit(&varResolved);
            hrInvoke = V_DISPATCH(pVarOut)->Invoke(
                                                DISPID_VALUE,
                                                IID_NULL,
                                                LOCALE_SYSTEM_DEFAULT,
                                                DISPATCH_PROPERTYGET | DISPATCH_METHOD,
                                                &dispParamsNoArgs,
                                                &varResolved,
                                                &ExcepInfo,
                                                NULL);
            }

        if (FAILED(hrInvoke))
            {
            if (hrInvoke == DISP_E_EXCEPTION)
                {
                //
                // forward the ExcepInfo from Invoke to caller's ExcepInfo
                //
                Exception(iidObj, ExcepInfo.bstrSource, ExcepInfo.bstrDescription);
                SysFreeString(ExcepInfo.bstrHelpFile);
                }

            else
                ExceptionId(iidObj, nObjID, IDE_UTIL_NO_VALUE);

            VariantClear(pVarOut);
            return hrInvoke;
            }

        // The correct code to restart the loop is:
        //
        //      VariantClear(pVar)
        //      VariantCopy(pVar, &varResolved);
        //      VariantClear(&varResolved);
        //
        // however, the same affect can be achieved by:
        //
        //      VariantClear(pVar)
        //      *pVar = varResolved;
        //      VariantInit(&varResolved)
        //
        // this avoids a copy.  The equivalence rests in the fact that
        // *pVar will contain the pointers of varResolved, after we
        // trash varResolved (WITHOUT releasing strings or dispatch
        // pointers), so the net ref count is unchanged. For strings,
        // there is still only one pointer to the string.
        //
        // NOTE: the next interation of the loop will do the VariantInit.
        //
        VariantClear(pVarOut);
        *pVarOut = varResolved;
        }

    return S_OK;
    }

/*===============================