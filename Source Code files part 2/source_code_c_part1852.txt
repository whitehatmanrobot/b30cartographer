                   }
                }
#endif

                // if VkKeyScanW fails (char is not in kbd layout), we must
                // emulate the key being input through the numpad

                if (KeyState == -1) {
                    CHAR CharString[4];
                    UCHAR OemChar;
                    PCHAR pCharString;

                    ConvertToOem(Console->OutputCP,
                                 &Char,
                                 1,
                                 &OemChar,
                                 1
                                );

                    _itoa(OemChar, CharString, 10);

                    EventsWritten++;
                    LoadKeyEvent(CurRecord,TRUE,0,VK_MENU,0x38,LEFT_ALT_PRESSED);
                    CurRecord++;

                    for (pCharString=CharString;*pCharString;pCharString++) {
                        WORD wVirtualKey, wScancode;
                        EventsWritten++;
                        wVirtualKey = *pCharString-'0'+VK_NUMPAD0;
                        wScancode = (WORD)MapVirtualKey(wVirtualKey, 0);
                        LoadKeyEvent(CurRecord,TRUE,0,wVirtualKey,wScancode,LEFT_ALT_PRESSED);
                        CurRecord++;
                        EventsWritten++;
                        LoadKeyEvent(CurRecord,FALSE,0,wVirtualKey,wScancode,LEFT_ALT_PRESSED);
                        CurRecord++;
                    }

                    EventsWritten++;
                    LoadKeyEvent(CurRecord,FALSE,Char,VK_MENU,0x38,0);
                    CurRecord++;
                } else {
                    KeyFlags = HIBYTE(KeyState);

                    // handle yucky alt-gr keys
                    if ((KeyFlags & 6) == 6) {
                        AltGr=TRUE;
                        EventsWritten++;
                        LoadKeyEvent(CurRecord,TRUE,0,VK_MENU,0x38,ENHANCED_KEY | LEFT_CTRL_PRESSED | RIGHT_ALT_PRESSED);
                        CurRecord++;
                    } else if (KeyFlags & 1) {
                        Shift=TRUE;
                        EventsWritten++;
                        LoadKeyEvent(CurRecord,TRUE,0,VK_SHIFT,0x2a,SHIFT_PRESSED);
                        CurRecord++;
                    }

                    EventsWritten++;
                    LoadKeyEvent(CurRecord,
                                 TRUE,
                                 Char,
                                 LOBYTE(KeyState),
                                 (WORD)MapVirtualKey(CurRecord->Event.KeyEvent.wVirtualKeyCode,0),
                                 0);
                    if (KeyFlags & 1)
                        CurRecord->Event.KeyEvent.dwControlKeyState |= SHIFT_PRESSED;
                    if (KeyFlags & 2)
                        CurRecord->Event.KeyEvent.dwControlKeyState |= LEFT_CTRL_PRESSED;
                    if (KeyFlags & 4)
                        CurRecord->Event.KeyEvent.dwControlKeyState |= RIGHT_ALT_PRESSED;
                    CurRecord++;

                    EventsWritten++;
                    *CurRecord = *(CurRecord-1);
                    CurRecord->Event.KeyEvent.bKeyDown = FALSE;
                    CurRecord++;

                    // handle yucky alt-gr keys
                    if (AltGr) {
                        EventsWritten++;
                        LoadKeyEvent(CurRecord,FALSE,0,VK_MENU,0x38,ENHANCED_KEY);
                        CurRecord++;
                    } else if (Shift) {
                        EventsWritten++;
                        LoadKeyEvent(CurRecord,FALSE,0,VK_SHIFT,0x2a,0);
                        CurRecord++;
                    }
                }
            }
            CurChar++;
        }
        EventsWritten = WriteInputBuffer(Console,
                                         &Console->InputBuffer,
                                         StringData,
                                         EventsWritten
                                         );
    }
    ConsoleHeapFree(StringData);
    return;
}

VOID
DoPaste(
    IN PCONSOLE_INFORMATION Console
    )

/*++

  Perform paste request into old app by pulling out clipboard
        contents and writing them to the console's input buffer

--*/

{
    BOOL Success;
    HANDLE ClipboardDataHandle;

    if (Console->Flags & CONSOLE_SCROLLING) {
        return;
    }

    //
    // Get paste data from clipboard
    //

    Success = OpenClipboard(Console->hWnd);
    if (!Success)
        return;

    if (Console->CurrentScreenBuffer->Flags & CONSOLE_TEXTMODE_BUFFER) {
        PWCHAR pwstr;

        ClipboardDataHandle = GetClipboardData(CF_UNICODETEXT);
        if (ClipboardDataHandle == NULL) {
            CloseClipboard();   // Close clipboard
            return;
        }
        pwstr = GlobalLock(ClipboardDataHandle);
        DoStringPaste(Console,pwstr,(ULONG)GlobalSize(ClipboardDataHandle)/sizeof(WCHAR));
        GlobalUnlock(ClipboardDataHandle);

    } else {
        HBITMAP hBitmapSource,hBitmapTarget;
        HDC hDCMemSource,hDCMemTarget;
        BITMAP bm;
        PSCREEN_INFORMATION ScreenInfo;

        hBitmapSource = GetClipboardData(CF_BITMAP);
        if (hBitmapSource) {

            ScreenInfo = Console->CurrentScreenBuffer;
            NtWaitForSingleObject(ScreenInfo->BufferInfo.GraphicsInfo.hMutex,
                                  FALSE, NULL);

            hBitmapTarget = CreateDIBitmap(Console->hDC,
                                     &ScreenInfo->BufferInfo.GraphicsInfo.lpBitMapInfo->bmiHeader,
                                     CBM_INIT,
                                     ScreenInfo->BufferInfo.GraphicsInfo.BitMap,
                                     ScreenInfo->BufferInfo.GraphicsInfo.lpBitMapInfo,
                                     ScreenInfo->BufferInfo.GraphicsInfo.dwUsage
                                    );
            if (hBitmapTarget) {
                hDCMemTarget = CreateCompatibleDC ( Console->hDC );
                if (hDCMemTarget != NULL) {
                    hDCMemSource = CreateCompatibleDC ( Console->hDC );
                    if (hDCMemSource != NULL) {
                        SelectObject( hDCMemTarget, hBitmapTarget );
                        SelectObject( hDCMemSource, hBitmapSource );
                        GetObjectW(hBitmapSource, sizeof (BITMAP), (LPSTR) &bm);
                        BitBlt ( hDCMemTarget, 0, 0, bm.bmWidth, bm.bmHeight,
                             hDCMemSource, 0, 0, SRCCOPY);
                        GetObjectW(hBitmapTarget, sizeof (BITMAP), (LPSTR) &bm);

                        // copy the bits from the DC to memory

                        GetDIBits(hDCMemTarget, hBitmapTarget, 0, bm.bmHeight,
                                  ScreenInfo->BufferInfo.GraphicsInfo.BitMap,
                                  ScreenInfo->BufferInfo.GraphicsInfo.lpBitMapInfo,
                                  ScreenInfo->BufferInfo.GraphicsInfo.dwUsage);
                        DeleteDC(hDCMemSource);
                    }
                    DeleteDC(hDCMemTarget);
                }
                DeleteObject(hBitmapTarget);
                InvalidateRect(Console->hWnd,NULL,FALSE); // force repaint
            }
            NtReleaseMutant(ScreenInfo->BufferInfo.GraphicsInfo.hMutex, NULL);
        }
    }
    CloseClipboard();
    return;
}

VOID
InitSelection(
    IN PCONSOLE_INFORMATION Console
    )

/*++

    This routine initializes the selection process.  It is called
    when the user selects the Mark option from the system menu.

--*/

{
    COORD Position;
    PSCREEN_INFORMATION ScreenInfo;

    //
    // if already selecting, cancel selection.
    //

    if (Console->Flags & CONSOLE_SELECTING) {
        if (Console->SelectionFlags & CONSOLE_MOUSE_SELECTION) {
            CancelMouseSelection(Console);
        } else {
            CancelKeySelection(Console,FALSE);
        }
    }

    //
    // set flags
    //

    Console->Flags |= CONSOLE_SELECTING;
    Console->SelectionFlags = 0;

    //
    // save old cursor position and
    // make console cursor into selection cursor.
    //

    ScreenInfo = Console->CurrentScreenBuffer;
    Console->TextCursorPosition = ScreenInfo->BufferInfo.TextInfo.CursorPosition;
    Console->TextCursorVisible = (BOOLEAN)ScreenInfo->BufferInfo.TextInfo.CursorVisible;
    Console->TextCursorSize =   ScreenInfo->BufferInfo.TextInfo.CursorSize;
    ConsoleHideCursor(ScreenInfo);
    SetCursorInformation(ScreenInfo,
                         100,
                         TRUE
                        );
    Position.X = ScreenInfo->Window.Left;
    Position.Y = ScreenInfo->Window.Top;
    SetCursorPosition(ScreenInfo,
                      Position,
                      TRUE
                     );
    ConsoleShowCursor(ScreenInfo);

    //
    // init select rect
    //

    Console->SelectionAnchor = Position;

    //
    // set win text
    //

    SetWinText(Console,msgMarkMode,TRUE);

}

VOID
DoMark(
    IN PCONSOLE_INFORMATION Console
    )
{
    InitSelection(Console);        // initialize selection
}

VOID
DoSelectAll(
    IN PCONSOLE_INFORMATION Console
    )
{
    COORD Position;
    COORD WindowOrigin;
    PSCREEN_INFORMATION ScreenInfo;

    // clear any old selections
    if (Console->Flags & CONSOLE_SELECTING) {
        ClearSelection(Console);
    }

    // save the old window position
    ScreenInfo = Console->CurrentScreenBuffer;
    WindowOrigin.X = ScreenInfo->Window.Left;
    WindowOrigin.Y = ScreenInfo->Window.Top;

    // initialize selection
    Console->Flags |= CONSOLE_SELECTING;
    Console->SelectionFlags = CONSOLE_MOUSE_SELECTION | CONSOLE_SELECTION_NOT_EMPTY;
    Position.X = Position.Y = 0;
    InitializeMouseSelection(Console, Position);
    MyInvert(Console,&Console->SelectionRect);
    SetWinText(Console,msgSelectMode,TRUE);

    // extend selection
    Position.X = ScreenInfo->ScreenBufferSize.X - 1;
    Position.Y = ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y;
    ExtendSelection(Console, Position);

    // restore the old window position
    SetWindowOrigin(ScreenInfo, TRUE, WindowOrigin);
}

VOID
DoScroll(
    IN PCONSOLE_INFORMATION Console
    )
{
    if (!(Console->Flags & CONSOLE_SCROLLING)) {
        SetWinText(Console,msgScrollMode,TRUE);
        Console->Flags |= CONSOLE_SCROLLING;
    }
}

VOID
ClearScroll(
    IN PCONSOLE_INFORMATION Console
    )
{
    SetWinText(Console,msgScrollMode,FALSE);
    Console->Flags &= ~CONSOLE_SCROLLING;
}

VOID
ScrollIfNecessary(
    IN PCONSOLE_INFORMATION Console,
    IN PSCREEN_INFORMATION ScreenInfo
    )
{
    POINT CursorPos;
    RECT ClientRect;
    COORD MousePosition;

    if (Console->Flags & CONSOLE_SELECTING &&
        Console->SelectionFlags & CONSOLE_MOUSE_DOWN) {
        if (!GetCursorPos(&CursorPos)) {
            return;
        }
        if (!GetClientRect(Console->hWnd,&ClientRect)) {
            return;
        }
        MapWindowPoints(Console->hWnd,NULL,(LPPOINT)&ClientRect,2);
        if (!(PtInRect(&ClientRect,CursorPos))) {
            ScreenToClient(Console->hWnd,&CursorPos);
            MousePosition.X = (SHORT)CursorPos.x;
            MousePosition.Y = (SHORT)CursorPos.y;
            if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
                MousePosition.X /= SCR_FONTSIZE(ScreenInfo).X;
                MousePosition.Y /= SCR_FONTSIZE(ScreenInfo).Y;
            }
            MousePosition.X += ScreenInfo->Window.Left;
            MousePosition.Y += ScreenInfo->Window.Top;

            ExtendSelection(Console,
                            MousePosition
                           );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\server\bitmap.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    bitmap.c

Abstract:

        This file implements bitmap video buffer management.

Author:

    Therese Stowell (thereses) 4-Sept-1991

Revision History:

Notes:

--*/

#include "precomp.h"
#pragma hdrstop

NTSTATUS
CreateConsoleBitmap(
    IN OUT PCONSOLE_GRAPHICS_BUFFER_INFO GraphicsInfo,
    IN OUT PSCREEN_INFORMATION ScreenInfo,
    OUT PVOID *lpBitmap,
    OUT HANDLE *hMutex
    )
{
    NTSTATUS Status;
    LARGE_INTEGER MaximumSize;
    SIZE_T ViewSize;

    //
    // adjust bitmap info
    //


    if (GraphicsInfo->lpBitMapInfo->bmiHeader.biHeight > 0)
    {
#if DBG
        DbgPrint("*************** Negating biHeight\n");
#endif
        GraphicsInfo->lpBitMapInfo->bmiHeader.biHeight =
            -GraphicsInfo->lpBitMapInfo->bmiHeader.biHeight;
    }

    if (GraphicsInfo->lpBitMapInfo->bmiHeader.biCompression != BI_RGB)
    {
#if DBG
        DbgPrint("*************** setting Compression to BI_RGB)\n");
#endif
        GraphicsInfo->lpBitMapInfo->bmiHeader.biCompression = BI_RGB;
    }

    //
    // allocate screeninfo buffer data and copy it
    //

    ScreenInfo->BufferInfo.GraphicsInfo.lpBitMapInfo = (LPBITMAPINFO)ConsoleHeapAlloc(MAKE_TAG( BMP_TAG ),GraphicsInfo->dwBitMapInfoLength);
    if (ScreenInfo->BufferInfo.GraphicsInfo.lpBitMapInfo == NULL) {
        return STATUS_NO_MEMORY;
    }
    ScreenInfo->BufferInfo.GraphicsInfo.BitMapInfoLength = GraphicsInfo->dwBitMapInfoLength;
    RtlCopyMemory(ScreenInfo->BufferInfo.GraphicsInfo.lpBitMapInfo,
           GraphicsInfo->lpBitMapInfo,
           GraphicsInfo->dwBitMapInfoLength
          );
    ASSERT((GraphicsInfo->lpBitMapInfo->bmiHeader.biWidth *
            -GraphicsInfo->lpBitMapInfo->bmiHeader.biHeight / 8 *
            GraphicsInfo->lpBitMapInfo->bmiHeader.biBitCount) ==
           (LONG)GraphicsInfo->lpBitMapInfo->bmiHeader.biSizeImage);

    //
    // create bitmap section
    //

    MaximumSize.QuadPart = GraphicsInfo->lpBitMapInfo->bmiHeader.biSizeImage;
    Status = NtCreateSection(&ScreenInfo->BufferInfo.GraphicsInfo.hSection,
                             SECTION_ALL_ACCESS,
                             NULL,
                             &MaximumSize,
                             PAGE_READWRITE,
                             SEC_COMMIT,
                             NULL
                            );
    if (!NT_SUCCESS(Status)) {
        ConsoleHeapFree(ScreenInfo->BufferInfo.GraphicsInfo.lpBitMapInfo);
        return Status;
    }

    //
    // map server view of section
    //

    ViewSize = GraphicsInfo->lpBitMapInfo->bmiHeader.biSizeImage;
    ScreenInfo->BufferInfo.GraphicsInfo.BitMap = 0;
    Status = NtMapViewOfSection(ScreenInfo->BufferInfo.GraphicsInfo.hSection,
                                NtCurrentProcess(),
                                &ScreenInfo->BufferInfo.GraphicsInfo.BitMap,
                                0L,
                                GraphicsInfo->lpBitMapInfo->bmiHeader.biSizeImage,
                                NULL,
                                &ViewSize,
                                ViewUnmap,
                                0L,
                                PAGE_READWRITE
                               );
    if (!NT_SUCCESS(Status)) {
        ConsoleHeapFree(ScreenInfo->BufferInfo.GraphicsInfo.lpBitMapInfo);
        NtClose(ScreenInfo->BufferInfo.GraphicsInfo.hSection);
        return Status;
    }

    //
    // map client view of section
    //

    ViewSize = GraphicsInfo->lpBitMapInfo->bmiHeader.biSizeImage;
    *lpBitmap = 0;
    Status = NtMapViewOfSection(ScreenInfo->BufferInfo.GraphicsInfo.hSection,
                                CONSOLE_CLIENTPROCESSHANDLE(),
                                lpBitmap,
                                0L,
                                GraphicsInfo->lpBitMapInfo->bmiHeader.biSizeImage,
                                NULL,
                                &ViewSize,
                                ViewUnmap,
                                0L,
                                PAGE_READWRITE
                               );
    if (!NT_SUCCESS(Status)) {
        ConsoleHeapFree(ScreenInfo->BufferInfo.GraphicsInfo.lpBitMapInfo);
        NtUnmapViewOfSection(NtCurrentProcess(),ScreenInfo->BufferInfo.GraphicsInfo.BitMap);
        NtClose(ScreenInfo->BufferInfo.GraphicsInfo.hSection);
        return Status;
    }
    ScreenInfo->BufferInfo.GraphicsInfo.ClientProcess = CONSOLE_CLIENTPROCESSHANDLE();
    ScreenInfo->BufferInfo.GraphicsInfo.ClientBitMap = *lpBitmap;

    //
    // create mutex to serialize access to bitmap, then map handle to mutex to client side
    //

    NtCreateMutant(&ScreenInfo->BufferInfo.GraphicsInfo.hMutex,
                   MUTANT_ALL_ACCESS, NULL, FALSE);
    MapHandle(CONSOLE_CLIENTPROCESSHANDLE(),
              ScreenInfo->BufferInfo.GraphicsInfo.hMutex,
              hMutex
             );

    ScreenInfo->BufferInfo.GraphicsInfo.dwUsage = GraphicsInfo->dwUsage;
    ScreenInfo->ScreenBufferSize.X = (WORD)GraphicsInfo->lpBitMapInfo->bmiHeader.biWidth;
    ScreenInfo->ScreenBufferSize.Y = (WORD)-GraphicsInfo->lpBitMapInfo->bmiHeader.biHeight;
    ScreenInfo->Window.Left = 0;
    ScreenInfo->Window.Top = 0;
    ScreenInfo->Window.Right = (SHORT)(ScreenInfo->Window.Left+ScreenInfo->ScreenBufferSize.X-1);
    ScreenInfo->Window.Bottom = (SHORT)(ScreenInfo->Window.Top+ScreenInfo->ScreenBufferSize.Y-1);
    return STATUS_SUCCESS;
}


ULONG
SrvInvalidateBitMapRect(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Routine Description:

    This routine is called to indicate that the application has modified a region
    in the bitmap.  We update the region to the screen.

Arguments:

    m - message containing api parameters

    ReplyStatus - Indicates whether to reply to the dll port.

Return Value:

--*/

{
    PCONSOLE_INVALIDATERECT_MSG a = (PCONSOLE_INVALIDATERECT_MSG)&m->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    NTSTATUS Status;
    UINT Codepage;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE | CONSOLE_GRAPHICS_OUTPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (!NT_SUCCESS(Status)) {
        UnlockConsole(Console);
        return((ULONG) Status);
    }
    if (HandleData->HandleType & CONSOLE_OUTPUT_HANDLE) {
        //ASSERT(Console->Flags & CONSOLE_VDM_REGISTERED);
        //ASSERT(!(Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE));
        ASSERT(Console->VDMBuffer != NULL);
        if (Console->VDMBuffer != NULL) {
            //ASSERT(HandleData->Buffer.ScreenBuffer->ScreenBufferSize.X <= Console->VDMBufferSize.X);
            //ASSERT(HandleData->Buffer.ScreenBuffer->ScreenBufferSize.Y <= Console->VDMBufferSize.Y);
            if (HandleData->Buffer.ScreenBuffer->ScreenBufferSize.X <= Console->VDMBufferSize.X &&
                HandleData->Buffer.ScreenBuffer->ScreenBufferSize.Y <= Console->VDMBufferSize.Y) {
                COORD TargetPoint;

                TargetPoint.X = a->Rect.Left;
                TargetPoint.Y = a->Rect.Top;
                // VDM can sometimes get out of sync with window size
                //ASSERT(a->Rect.Left >= 0);
                //ASSERT(a->Rect.Top >= 0);
                //ASSERT(a->Rect.Right < HandleData->Buffer.ScreenBuffer->ScreenBufferSize.X);
                //ASSERT(a->Rect.Bottom < HandleData->Buffer.ScreenBuffer->ScreenBufferSize.Y);
                //ASSERT(a->Rect.Left <= a->Rect.Right);
                //ASSERT(a->Rect.Top <= a->Rect.Bottom);
                if ((a->Rect.Left >= 0) &&
                    (a->Rect.Top >= 0) &&
                    (a->Rect.Right < HandleData->Buffer.ScreenBuffer->ScreenBufferSize.X) &&
                    (a->Rect.Bottom < HandleData->Buffer.ScreenBuffer->ScreenBufferSize.Y) &&
                    (a->Rect.Left <= a->Rect.Right) &&
                    (a->Rect.Top <= a->Rect.Bottom) ) {

                    if ((Console->CurrentScreenBuffer->Flags & CONSOLE_OEMFONT_DISPLAY) && ((Console->FullScreenFlags & CONSOLE_FULLSCREEN) == 0)) {
#if defined(FE_SB)
                        if (CONSOLE_IS_DBCS_ENABLED() &&
                            Console->OutputCP != WINDOWSCP )
                        {
                            Codepage = USACP;
                        }
                        else

#endif
                        // we want UnicodeOem characters
                        Codepage = WINDOWSCP;
                    } else {
#if defined(FE_SB)
                        if (CONSOLE_IS_DBCS_ENABLED()) {
                            Codepage = Console->OutputCP;
                        }
                        else
#endif
                        // we want real Unicode characters
                        Codepage = Console->CP;
                    }

                    WriteRectToScreenBuffer((PBYTE)Console->VDMBuffer,
                            Console->VDMBufferSize, &a->Rect,
                            HandleData->Buffer.ScreenBuffer, TargetPoint,
                            Codepage);
                    WriteToScreen(HandleData->Buffer.ScreenBuffer,&a->Rect);
                } else {
                    Status = STATUS_INVALID_PARAMETER;
                }
            } else {
                Status = STATUS_INVALID_PARAMETER;
            }
        } else {
            Status = STATUS_INVALID_PARAMETER;
        }
    } else {

        //
        // write data to screen
        //

        WriteToScreen(HandleData->Buffer.ScreenBuffer,&a->Rect);
    }

    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

NTSTATUS
WriteRegionToScreenBitMap(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT Region
    )
{
    DWORD NumScanLines;
    int   Height;
    //
    // if we have a selection, turn it off.
    //

    InvertSelection(ScreenInfo->Console,TRUE);

    NtWaitForSingleObject(ScreenInfo->BufferInfo.GraphicsInfo.hMutex,
                          FALSE, NULL);

    // The origin of (xSrc, ySrc) passed to SetDIBitsToDevice is located
    // at the DIB's bottom-left corner no matter if the DIB is
    // a top-down or bottom-up. Thus, if the DIB is a top-down, we have
    // to translate ySrc accordingly:
    // if (height < 0) {        // top-down
    //      ySrc = abs(height) - rect.Bottom -1;
    //
    // else
    //      ySrc = rect.Bottom;
    //
    Height = ScreenInfo->BufferInfo.GraphicsInfo.lpBitMapInfo->bmiHeader.biHeight;

    NumScanLines = SetDIBitsToDevice(ScreenInfo->Console->hDC,
                      Region->Left - ScreenInfo->Window.Left,
                      Region->Top - ScreenInfo->Window.Top,
                      Region->Right - Region->Left + 1,
                      Region->Bottom - Region->Top + 1,
                      Region->Left,
              Height < 0 ? -Height - Region->Bottom - 1 : Region->Bottom,
                      0,
                      ScreenInfo->ScreenBufferSize.Y,
                      ScreenInfo->BufferInfo.GraphicsInfo.BitMap,
                      ScreenInfo->BufferInfo.GraphicsInfo.lpBitMapInfo,
                      ScreenInfo->BufferInfo.GraphicsInfo.dwUsage
                     );

    NtReleaseMutant(ScreenInfo->BufferInfo.GraphicsInfo.hMutex, NULL);

    //
    // if we have a selection, turn it on.
    //

    InvertSelection(ScreenInfo->Console,FALSE);

    if (NumScanLines == 0) {
        return STATUS_UNSUCCESSFUL;
    }
    return STATUS_SUCCESS;
}




VOID
FreeConsoleBitmap(
    IN PSCREEN_INFORMATION ScreenInfo
    )
{
    NtUnmapViewOfSection(NtCurrentProcess(),
                         ScreenInfo->BufferInfo.GraphicsInfo.BitMap);
    NtUnmapViewOfSection(ScreenInfo->BufferInfo.GraphicsInfo.ClientProcess,
                         ScreenInfo->BufferInfo.GraphicsInfo.ClientBitMap);
    NtClose(ScreenInfo->BufferInfo.GraphicsInfo.hSection);
    NtClose(ScreenInfo->BufferInfo.GraphicsInfo.hMutex);
    ConsoleHeapFree(ScreenInfo->BufferInfo.GraphicsInfo.lpBitMapInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\server\cmdline.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    cmdline.h

Abstract:

    This file contains the internal structures and definitions used
    by command line input and editing.

Author:

    Therese Stowell (thereses) 15-Nov-1991

Revision History:

--*/

typedef struct _COMMAND {
    USHORT CommandLength;
    WCHAR Command[1];
} COMMAND, *PCOMMAND;

typedef
ULONG
(*PCLE_POPUP_INPUT_ROUTINE)(
    IN PVOID CookedReadData,
    IN PCSR_API_MSG WaitReplyMessage,
    IN PCSR_THREAD WaitingThread,
    IN BOOLEAN WaitRoutine
    );

/*
 * CLE_POPUP Flags
 */
#define CLEPF_FALSE_UNICODE 0x0001

typedef struct _CLE_POPUP {
    LIST_ENTRY ListLink;    // pointer to next popup
    SMALL_RECT Region;      // region popup occupies
    WORD  Attributes;       // text attributes
    WORD  Flags;            // CLEPF_ flags
    PCHAR_INFO OldContents; // contains data under popup
    SHORT BottomIndex;      // number of command displayed on last line of popup
    SHORT CurrentCommand;
    WCHAR NumberBuffer[6];
    SHORT NumberRead;
    PCLE_POPUP_INPUT_ROUTINE PopupInputRoutine; // routine to call when input is received
#if defined(FE_SB)
    COORD OldScreenSize;
#endif
} CLE_POPUP, *PCLE_POPUP;

#define POPUP_SIZE_X(POPUP) (SHORT)(((POPUP)->Region.Right - (POPUP)->Region.Left - 1))
#define POPUP_SIZE_Y(POPUP) (SHORT)(((POPUP)->Region.Bottom - (POPUP)->Region.Top - 1))
#define COMMAND_NUMBER_SIZE 8   // size of command number buffer


/*
 * COMMAND_HISTORY Flags
 */
#define CLE_ALLOCATED 0x00000001
#define CLE_RESET     0x00000002

typedef struct _COMMAND_HISTORY {
    DWORD Flags;
    LIST_ENTRY ListLink;
    PWCHAR AppName;
    SHORT NumberOfCommands;
    SHORT LastAdded;
    SHORT LastDisplayed;
    SHORT FirstCommand;     // circular buffer
    SHORT MaximumNumberOfCommands;
    HANDLE ProcessHandle;
    LIST_ENTRY PopupList;    // pointer to top-level popup
    PCOMMAND Commands[1];
} COMMAND_HISTORY, *PCOMMAND_HISTORY;

#define DEFAULT_NUMBER_OF_COMMANDS 25
#define DEFAULT_NUMBER_OF_BUFFERS 4

typedef struct _COOKED_READ_DATA {
    PINPUT_INFORMATION InputInfo;
    PSCREEN_INFORMATION ScreenInfo;
    PCONSOLE_INFORMATION Console;
    HANDLE_DATA TempHandle;
    ULONG UserBufferSize;   // doubled size in ansi case
    PWCHAR UserBuffer;
    ULONG BufferSize;
    ULONG BytesRead;
    ULONG CurrentPosition;  // char position, not byte position
    PWCHAR BufPtr;
    PWCHAR BackupLimit;
    COORD OriginalCursorPosition;
    DWORD NumberOfVisibleChars;
    PCOMMAND_HISTORY CommandHistory;
    BOOLEAN Echo;
    BOOLEAN Processed;
    BOOLEAN Line;
    BOOLEAN InsertMode;
    PCONSOLE_PER_PROCESS_DATA ProcessData;
    HANDLE HandleIndex;
    PWCHAR ExeName;
    USHORT ExeNameLength;   // in bytes
    ULONG CtrlWakeupMask;
    ULONG ControlKeyState;
} COOKED_READ_DATA, *PCOOKED_READ_DATA;

#define COMMAND_NUM_TO_INDEX(NUM,CMDHIST) (SHORT)(((NUM+(CMDHIST)->FirstCommand)%((CMDHIST)->MaximumNumberOfCommands)))
#define COMMAND_INDEX_TO_NUM(INDEX,CMDHIST) (SHORT)(((INDEX+((CMDHIST)->MaximumNumberOfCommands)-(CMDHIST)->FirstCommand)%((CMDHIST)->MaximumNumberOfCommands)))

/*
 * COMMAND_IND_NEXT and COMMAND_IND_PREV go to the next and prev command
 * COMMAND_IND_INC  and COMMAND_IND_DEC  go to the next and prev slots
 *
 * Don't get the two confused - it matters when the cmd history is not full!
 */

#define COMMAND_IND_PREV(IND,CMDHIST)               \
{                                                   \
    if (IND <= 0) {                                 \
        IND = (CMDHIST)->NumberOfCommands;          \
    }                                               \
    IND--;                                          \
}

#define COMMAND_IND_NEXT(IND,CMDHIST)               \
{                                                   \
    ++IND;                                          \
    if (IND >= (CMDHIST)->NumberOfCommands){        \
        IND = 0;                                    \
    }                                               \
}

#define COMMAND_IND_DEC(IND,CMDHIST)                \
{                                                   \
    if (IND <= 0) {                                 \
        IND = (CMDHIST)->MaximumNumberOfCommands;   \
    }                                               \
    IND--;                                          \
}

#define COMMAND_IND_INC(IND,CMDHIST)                \
{                                                   \
    ++IND;                                          \
    if (IND >= (CMDHIST)->MaximumNumberOfCommands){ \
        IND = 0;                                    \
    }                                               \
}

#define CLE_NO_POPUPS(COMMAND_HISTORY) (&(COMMAND_HISTORY)->PopupList == (COMMAND_HISTORY)->PopupList.Blink)

//
// aliases are grouped per console, per exe.
//

typedef struct _ALIAS {
    LIST_ENTRY ListLink;
    USHORT SourceLength; // in bytes
    USHORT TargetLength; // in bytes
    PWCHAR Source;
    PWCHAR Target;
} ALIAS, *PALIAS;

typedef struct _EXE_ALIAS_LIST {
    LIST_ENTRY ListLink;
    USHORT ExeLength;   // in bytes
    PWCHAR ExeName;
    LIST_ENTRY AliasList;
} EXE_ALIAS_LIST, *PEXE_ALIAS_LIST;

NTSTATUS
ProcessCommandLine(
    IN PCOOKED_READ_DATA CookedReadData,
    IN WCHAR Char,
    IN DWORD KeyState,
    IN PCSR_API_MSG WaitReplyMessage,
    IN PCSR_THREAD WaitingThread,
    IN BOOLEAN WaitRoutine
    );

VOID
DeleteCommandLine(
    IN OUT PCOOKED_READ_DATA CookedReadData,
    IN BOOL UpdateFields
    );

VOID
RedrawCommandLine(
    IN PCOOKED_READ_DATA CookedReadData
    );

VOID
EmptyCommandHistory(
    IN PCOMMAND_HISTORY CommandHistory
    );

PCOMMAND_HISTORY
ReallocCommandHistory(
    IN PCONSOLE_INFORMATION Console,
    IN PCOMMAND_HISTORY CurrentCommandHistory,
    IN DWORD NumCommands
    );

PCOMMAND_HISTORY
FindExeCommandHistory(
    IN PCONSOLE_INFORMATION Console,
    IN PVOID AppName,
    IN DWORD AppNameLength,
    IN BOOLEAN UnicodeExe
    );

PCOMMAND_HISTORY
FindCommandHistory(
    IN PCONSOLE_INFORMATION Console,
    IN HANDLE ProcessHandle
    );

ULONG
RetrieveNumberOfSpaces(
    IN SHORT OriginalCursorPositionX,
    IN PWCHAR Buffer,
    IN ULONG CurrentPosition
#if defined(FE_SB)
    ,
    IN PCONSOLE_INFORMATION Console,
    IN DWORD CodePage
#endif
    );

ULONG
RetrieveTotalNumberOfSpaces(
    IN SHORT OriginalCursorPositionX,
    IN PWCHAR Buffer,
    IN ULONG CurrentPosition
#if defined(FE_SB)
    ,
    IN PCONSOLE_INFORMATION Console
#endif
    );

NTSTATUS
GetChar(
    IN PINPUT_INFORMATION InputInfo,
    OUT PWCHAR Char,
    IN BOOLEAN Wait,
    IN PCONSOLE_INFORMATION Console,
    IN PHANDLE_DATA HandleData,
    IN PCSR_API_MSG Message OPTIONAL,
    IN CSR_WAIT_ROUTINE WaitRoutine OPTIONAL,
    IN PVOID WaitParameter OPTIONAL,
    IN ULONG WaitParameterLength  OPTIONAL,
    IN BOOLEAN WaitBlockExists OPTIONAL,
    OUT PBOOLEAN CommandLineEditingKeys OPTIONAL,
    OUT PBOOLEAN CommandLinePopupKeys OPTIONAL,
    OUT PBOOLEAN EnableScrollMode OPTIONAL,
    OUT PDWORD KeyState OPTIONAL
    );

BOOL
IsCommandLinePopupKey(
    IN OUT PKEY_EVENT_RECORD KeyEvent
    );

BOOL
IsCommandLineEditingKey(
    IN OUT PKEY_EVENT_RECORD KeyEvent
    );

VOID
CleanUpPopups(
    IN PCOOKED_READ_DATA CookedReadData
    );

BOOL
ProcessCookedReadInput(
    IN PCOOKED_READ_DATA CookedReadData,
    IN WCHAR Char,
    IN DWORD KeyState,
    OUT PNTSTATUS Status
    );

VOID
DrawCommandListBorder(
    IN PCLE_POPUP Popup,
    IN PSCREEN_INFORMATION ScreenInfo
    );

PCOMMAND
GetLastCommand(
    IN PCOMMAND_HISTORY CommandHistory
    );

SHORT
FindMatchingCommand(
    IN PCOMMAND_HISTORY CommandHistory,
    IN PWCHAR CurrentCommand,
    IN ULONG CurrentCommandLength,
    IN SHORT CurrentIndex,
    IN DWORD Flags
    );

#define FMCFL_EXACT_MATCH   1
#define FMCFL_JUST_LOOKING  2

NTSTATUS
CommandNumberPopup(
    IN PCOOKED_READ_DATA CookedReadData,
    IN PCSR_API_MSG WaitReplyMessage,
    IN PCSR_THREAD WaitingThread,
    IN BOOLEAN WaitRoutine
    );

BOOLEAN
CookedReadWaitRoutine(
    IN PLIST_ENTRY WaitQueue,
    IN PCSR_THREAD WaitingThread,
    IN PCSR_API_MSG WaitReplyMessage,
    IN PVOID WaitParameter,
    IN PVOID SatisfyParameter1,
    IN PVOID SatisfyParameter2,
    IN ULONG WaitFlags
    );

VOID
ReadRectFromScreenBuffer(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN COORD SourcePoint,
    IN PCHAR_INFO Target,
    IN COORD TargetSize,
    IN PSMALL_RECT TargetRect
    );

NTSTATUS
WriteCharsFromInput(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PWCHAR lpBufferBackupLimit,
    IN PWCHAR lpBuffer,
    IN PWCHAR lpString,
    IN OUT PDWORD NumBytes,
    OUT PLONG NumSpaces OPTIONAL,
    IN SHORT OriginalXPosition,
    IN DWORD dwFlags,
    OUT PSHORT ScrollY OPTIONAL
    );

//
// Values for WriteChars(),WriteCharsFromInput() dwFlags
//
#define WC_DESTRUCTIVE_BACKSPACE 0x01
#define WC_KEEP_CURSOR_VISIBLE   0x02
#define WC_ECHO                  0x04
#define WC_FALSIFY_UNICODE       0x08
#define WC_LIMIT_BACKSPACE       0x10


VOID
DrawCommandListPopup(
    IN PCLE_POPUP Popup,
    IN SHORT CurrentCommand,
    IN PCOMMAND_HISTORY CommandHistory,
    IN PSCREEN_INFORMATION ScreenInfo
    );

VOID
UpdateCommandListPopup(
    IN SHORT Delta,
    IN OUT PSHORT CurrentCommand,
    IN PCOMMAND_HISTORY CommandHistory,
    IN PCLE_POPUP Popup,
    IN PSCREEN_INFORMATION ScreenInfo,
    IN DWORD Flags
    );

#define UCLP_WRAP   1


//
// InitExtendedEditKey
// If lpwstr is NULL, the default value will be used.
//
VOID InitExtendedEditKeys(CONST ExtKeyDefBuf* lpbuf);

//
// IsPauseKey
// returns TRUE if pKeyEvent is pause.
// The default key is Ctrl-S if extended edit keys are not specified.
//
BOOL IsPauseKey(IN PKEY_EVENT_RECORD pKeyEvent);


//
// Word delimiters
//

#define IS_WORD_DELIM(wch)  ((wch) == L' ' || (gaWordDelimChars[0] && IsWordDelim(wch)))

extern WCHAR gaWordDelimChars[];
extern CONST WCHAR gaWordDelimCharsDefault[];
extern BOOL IsWordDelim(WCHAR);

#define WORD_DELIM_MAX  32
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\server\cmdline.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    cmdline.c

Abstract:

        This file implements command line editing and aliasing.

Author:

    Therese Stowell (thereses) 22-Mar-1991

Revision History:

Notes:

    The input model for the command line editing popups is complex.
    Here is the relevant pseudocode:

    CookedReadWaitRoutine
        if (CookedRead->Popup)
            Status = (*CookedRead->Popup->PopupInputRoutine)();
            if (Status == CONSOLE_STATUS_READ_COMPLETE)
                return STATUS_SUCCESS;
            return Status;

    CookedRead
        if (Command Line Editing Key)
            ProcessCommandLine
        else
            process regular key

    ProcessCommandLine
        if F7
            return CommandLinePopup

    CommandLinePopup
        draw popup
        return ProcessCommandListInput

    ProcessCommandListInput
        while (TRUE)
            GetChar
            if (wait)
                return wait
            switch (char)
                .
                .
                .


--*/

#include "precomp.h"
#pragma hdrstop

#define COPY_TO_CHAR_PROMPT_LENGTH 26
#define COPY_FROM_CHAR_PROMPT_LENGTH 28

#define COMMAND_NUMBER_PROMPT_LENGTH 22
#define COMMAND_NUMBER_LENGTH 5
#define MINIMUM_COMMAND_PROMPT_SIZE COMMAND_NUMBER_LENGTH

#if defined(FE_SB)
#define CHAR_COUNT(cch) cch
#else
#define CHAR_COUNT(cch) ((cch)/sizeof(WCHAR))
#endif


#define ALT_PRESSED     (RIGHT_ALT_PRESSED | LEFT_ALT_PRESSED)
#define CTRL_PRESSED    (RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED)

#define CTRL_BUT_NOT_ALT(n) \
        (((n) & (LEFT_CTRL_PRESSED | RIGHT_CTRL_PRESSED)) && \
        !((n) & (LEFT_ALT_PRESSED | RIGHT_ALT_PRESSED)))

//
// Extended Edit Key
//

ExtKeyDefTable gaKeyDef;

CONST ExtKeyDefTable gaDefaultKeyDef = {
    {   // A
        0,                  VK_HOME,        0,      // Ctrl
        LEFT_CTRL_PRESSED,  VK_HOME,        0,      // Alt
        0,                  0,              0,      // Ctrl+Alt
    },
    {   // B
        0,                  VK_LEFT,        0,      // Ctrl
        LEFT_CTRL_PRESSED,  VK_LEFT,        0,      // Alt
    },
    {   // C
        0,
    },
    {   // D
        0,                  VK_DELETE,      0,      // Ctrl
        LEFT_CTRL_PRESSED,  VK_DELETE,      0,      // Alt
        0,                  0,              0,      // Ctrl+Alt
    },
    {   // E
        0,                  VK_END,         0,      // Ctrl
        LEFT_CTRL_PRESSED,  VK_END,         0,      // Alt
        0,                  0,              0,      // Ctrl+Alt
    },
    {   // F
        0,                  VK_RIGHT,       0,      // Ctrl
        LEFT_CTRL_PRESSED,  VK_RIGHT,       0,      // Alt
        0,                  0,              0,      // Ctrl+Alt
    },
    {   // G
        0,
    },
    {   // H
        0,
    },
    {   // I
        0,
    },
    {   // J
        0,
    },
    {   // K
        LEFT_CTRL_PRESSED,  VK_END,         0,      // Ctrl
    },
    {   // L
        0,
    },
    {   // M
        0,
    },
    {   // N
        0,                  VK_DOWN,        0,      // Ctrl
    },
    {   // O
        0,
    },
    {   // P
        0,                  VK_UP,          0,      // Ctrl
    },
    {   // Q
        0,
    },
    {   // R
        0,                  VK_F8,          0,      // Ctrl
    },
    {   // S
        0,                  VK_PAUSE,       0,      // Ctrl
    },
    {   // T
        LEFT_CTRL_PRESSED,  VK_DELETE,      0,      // Ctrl
    },
    {   // U
        0,                  VK_ESCAPE,      0,      // Ctrl
    },
    {   // V
        0,
    },
    {   // W
        LEFT_CTRL_PRESSED,  VK_BACK,        EXTKEY_ERASE_PREV_WORD,    // Ctrl
    },
    {   // X
        0,
    },
    {   // Y
        0,
    },
    {   // Z
        0,
    },
};

//
// InitExtendedEditKeys
//
// Initialize the extended edit key table.
// If pKeyDefbuf is NULL, the internal default table is used.
// Otherwise, lpbyte should point to a valid ExtKeyDefBuf.
//

VOID InitExtendedEditKeys(CONST ExtKeyDefBuf* pKeyDefBuf)
{
    CONST BYTE* lpbyte;
    int i;
    DWORD dwCheckSum;

    //
    // Sanity check
    // If pKeyDefBuf is NULL, give it the default value.
    // If the version is not supported, just use the default and bail.
    //
    if (pKeyDefBuf == NULL || pKeyDefBuf->dwVersion != 0) {
#if DBG
        if (pKeyDefBuf != NULL) {
            DbgPrint("InitExtendedEditKeys: Unsupported version number(%d)\n", pKeyDefBuf->dwVersion);
        }
#endif
retry_clean:
        memcpy(gaKeyDef, gaDefaultKeyDef, sizeof gaKeyDef);
        return;
    }

    //
    // Calculate check sum
    //
    dwCheckSum = 0;
    for (lpbyte = (CONST BYTE*)pKeyDefBuf, i = FIELD_OFFSET(ExtKeyDefBuf, table); i < sizeof *pKeyDefBuf; ++i) {
        dwCheckSum += lpbyte[i];
    }
    if (dwCheckSum != pKeyDefBuf->dwCheckSum) {
#if DBG
        DbgPrint("InitExtendedEditKeys: Checksum(%d) does not match.\n", pKeyDefBuf->dwCheckSum);
#endif
        goto retry_clean;
    }

    //
    // Copy the entity
    //

    memcpy(gaKeyDef, pKeyDefBuf->table, sizeof gaKeyDef);
}

CONST ExtKeySubst* ParseEditKeyInfo(IN OUT PKEY_EVENT_RECORD pKeyEvent)
{
    CONST ExtKeyDef* pKeyDef;
    CONST ExtKeySubst* pKeySubst;

    //
    // If not extended mode, or Control key or Alt key is not pressed,
    // or virtual keycode is out of range, just bail.
    //
    if (!gExtendedEditKey ||
            (pKeyEvent->dwControlKeyState & (CTRL_PRESSED | ALT_PRESSED)) == 0 ||
            pKeyEvent->wVirtualKeyCode < 'A' || pKeyEvent->wVirtualKeyCode > 'Z') {

        return NULL;
    }

    //
    // Get the corresponding KeyDef.
    //
    pKeyDef = &gaKeyDef[pKeyEvent->wVirtualKeyCode - 'A'];

    //
    // Get the KeySubst based on the modifier status.
    //
    if (pKeyEvent->dwControlKeyState & ALT_PRESSED) {
        if (pKeyEvent->dwControlKeyState & CTRL_PRESSED) {
            pKeySubst = &pKeyDef->keys[2];
        } else {
            pKeySubst = &pKeyDef->keys[1];
        }
    } else {
        ASSERT(pKeyEvent->dwControlKeyState & CTRL_PRESSED);
        pKeySubst = &pKeyDef->keys[0];
    }

    ASSERT(pKeySubst);

    //
    // If the conbination is not defined, just bail.
    //
    if (pKeySubst->wVirKey == 0) {
        return NULL;
    }

    //
    // Substitute the input with ext key.
    //
    pKeyEvent->dwControlKeyState = pKeySubst->wMod;
    pKeyEvent->wVirtualKeyCode = pKeySubst->wVirKey;
    pKeyEvent->uChar.UnicodeChar = pKeySubst->wUnicodeChar;

    return pKeySubst;
}

//
// IsPauseKey
// returns TRUE if pKeyEvent is pause.
// The default key is Ctrl-S if extended edit keys are not specified.
//

BOOL IsPauseKey(IN PKEY_EVENT_RECORD pKeyEvent)
{
    if (gExtendedEditKey) {
        KEY_EVENT_RECORD KeyEvent = *pKeyEvent;
        CONST ExtKeySubst* pKeySubst = ParseEditKeyInfo(&KeyEvent);

        return pKeySubst != NULL && pKeySubst->wVirKey == VK_PAUSE;
    }

    return pKeyEvent->wVirtualKeyCode == L'S' && CTRL_BUT_NOT_ALT(pKeyEvent->dwControlKeyState);
}


//
// Word delimiters
//

WCHAR gaWordDelimChars[WORD_DELIM_MAX];
CONST WCHAR gaWordDelimCharsDefault[WORD_DELIM_MAX] = L"\\" L"+!:=/.<>;|&";

BOOL IsWordDelim(WCHAR wch)
{
    int i;

    //
    // Before it reaches here, L' ' case should have beeen already detected,
    // and gaWordDelimChars is specified.
    //
    ASSERT(wch != L' ' && gaWordDelimChars[0]);

    for (i = 0; gaWordDelimChars[i] && i < WORD_DELIM_MAX; ++i) {
        if (wch == gaWordDelimChars[i]) {
            return TRUE;
        }
    }

    return FALSE;
}

PEXE_ALIAS_LIST
AddExeAliasList(
    IN PCONSOLE_INFORMATION Console,
    IN LPVOID ExeName,
    IN USHORT ExeLength, // in bytes
    IN BOOLEAN UnicodeExe
    )
{
    PEXE_ALIAS_LIST AliasList;

    AliasList = (PEXE_ALIAS_LIST)ConsoleHeapAlloc(MAKE_TAG( ALIAS_TAG ),sizeof(EXE_ALIAS_LIST));
    if (AliasList == NULL) {
        return NULL;
    }
    if (UnicodeExe) {
        AliasList->ExeName = (PWCHAR)ConsoleHeapAlloc(MAKE_TAG( ALIAS_TAG ),ExeLength);
        if (AliasList->ExeName == NULL) {
            ConsoleHeapFree(AliasList);
            return NULL;
        }
        RtlCopyMemory(AliasList->ExeName,ExeName,ExeLength);
        AliasList->ExeLength = ExeLength;
    } else {
        AliasList->ExeName = (PWCHAR)ConsoleHeapAlloc(MAKE_TAG( ALIAS_TAG ),ExeLength*sizeof(WCHAR));
        if (AliasList->ExeName == NULL) {
            ConsoleHeapFree(AliasList);
            return NULL;
        }
        AliasList->ExeLength = (USHORT)ConvertInputToUnicode(Console->CP,
                                                 ExeName,
                                                 ExeLength,
                                                 AliasList->ExeName,
                                                 ExeLength);
        AliasList->ExeLength *= 2;
    }
    InitializeListHead(&AliasList->AliasList);
    InsertHeadList(&Console->ExeAliasList,&AliasList->ListLink);
    return AliasList;
}

int
MyStringCompareW(
    IN LPWSTR Str1,
    IN LPWSTR Str2,
    IN USHORT Length, // in bytes
    IN BOOLEAN bCaseInsensitive
    )
{
    UNICODE_STRING String1;
    UNICODE_STRING String2;

    String1.Length = Length;
    String1.MaximumLength = Length;
    String1.Buffer = Str1;
    String2.Length = Length;
    String2.MaximumLength = Length;
    String2.Buffer = Str2;
    return RtlCompareUnicodeString(&String1,
                                   &String2,
                                   bCaseInsensitive);
}

#define my_wcsncmpi(p1, p2, n) MyStringCompareW(p1, p2, n, TRUE)
#define my_wcsncmp(p1, p2, n)  MyStringCompareW(p1, p2, n, FALSE)

PEXE_ALIAS_LIST
FindExe(
    IN PCONSOLE_INFORMATION Console,
    IN LPVOID ExeName,
    IN USHORT ExeLength, // in bytes
    IN BOOLEAN UnicodeExe
    )

/*++

    This routine searches for the specified exe alias list.  It returns
    a pointer to the exe list if found, NULL if not found.

--*/

{
    PEXE_ALIAS_LIST AliasList;
    PLIST_ENTRY ListHead, ListNext;
    LPWSTR UnicodeExeName;


    if (UnicodeExe) {
        UnicodeExeName = ExeName;
    } else {
        UnicodeExeName = (LPWSTR)ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ),ExeLength*sizeof(WCHAR));
        if (UnicodeExeName == NULL)
            return NULL;
        ExeLength = (USHORT)ConvertInputToUnicode(Console->CP,
                                      ExeName,
                                      ExeLength,
                                      UnicodeExeName,
                                      ExeLength);
        ExeLength *= 2;
    }
    ListHead = &Console->ExeAliasList;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        AliasList = CONTAINING_RECORD( ListNext, EXE_ALIAS_LIST, ListLink );
        if (AliasList->ExeLength == ExeLength &&
            !my_wcsncmpi(AliasList->ExeName,UnicodeExeName,ExeLength)) {
            if (!UnicodeExe) {
                ConsoleHeapFree(UnicodeExeName);
            }
            return AliasList;
        }
        ListNext = ListNext->Flink;
    }
    if (!UnicodeExe) {
        ConsoleHeapFree(UnicodeExeName);
    }
    return NULL;
}

PALIAS
FindAlias(
    IN PEXE_ALIAS_LIST AliasList,
    IN LPWSTR AliasName,
    IN USHORT AliasLength // in bytes
    )

/*++

    This routine searches for the specified alias.  If it finds one,
    it moves it to the head of the list and returns a pointer to the
    alias. Otherwise it returns NULL.

--*/

{
    PALIAS Alias;
    PLIST_ENTRY ListHead, ListNext;

    ListHead = &AliasList->AliasList;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        Alias = CONTAINING_RECORD( ListNext, ALIAS, ListLink );
        if (Alias->SourceLength == AliasLength &&
            !my_wcsncmpi(Alias->Source,AliasName,AliasLength)) {
            if (ListNext != ListHead->Flink) {
                RemoveEntryList(ListNext);
                InsertHeadList(ListHead,ListNext);
            }
            return Alias;
        }
        ListNext = ListNext->Flink;
    }
    return NULL;
}

NTSTATUS
AddAlias(
    IN PEXE_ALIAS_LIST ExeAliasList,
    IN LPWSTR Source,
    IN USHORT SourceLength,  // in bytes
    IN LPWSTR Target,
    IN USHORT TargetLength   // in bytes
    )

/*++

    This routine creates an alias and inserts it into the exe alias list.

--*/

{
    PALIAS Alias;

    Alias = (PALIAS)ConsoleHeapAlloc(MAKE_TAG( ALIAS_TAG ),sizeof(ALIAS));
    if (Alias == NULL) {
        return STATUS_NO_MEMORY;
    }
    Alias->Source = (LPWSTR)ConsoleHeapAlloc(MAKE_TAG( ALIAS_TAG ),SourceLength);
    if (Alias->Source == NULL) {
        ConsoleHeapFree(Alias);
        return STATUS_NO_MEMORY;
    }
    Alias->Target = (LPWSTR)ConsoleHeapAlloc(MAKE_TAG( ALIAS_TAG ),TargetLength);
    if (Alias->Target == NULL) {
        ConsoleHeapFree(Alias->Source);
        ConsoleHeapFree(Alias);
        return STATUS_NO_MEMORY;
    }
    Alias->SourceLength = SourceLength;
    Alias->TargetLength = TargetLength;
    RtlCopyMemory(Alias->Source,Source,SourceLength);
    RtlCopyMemory(Alias->Target,Target,TargetLength);
    InsertHeadList(&ExeAliasList->AliasList,&Alias->ListLink);
    return STATUS_SUCCESS;
}

NTSTATUS
ReplaceAlias(
    IN PALIAS Alias,
    IN LPWSTR Target,
    IN USHORT TargetLength // in bytes
    )

/*++

    This routine replaces an existing target with a new target.

--*/

{
    LPWSTR NewTarget;

    NewTarget = (LPWSTR)ConsoleHeapAlloc(MAKE_TAG( ALIAS_TAG ),TargetLength);
    if (NewTarget == NULL) {
        return STATUS_NO_MEMORY;
    }
    ConsoleHeapFree(Alias->Target);
    Alias->Target = NewTarget;
    Alias->TargetLength = TargetLength;
    RtlCopyMemory(Alias->Target,Target,TargetLength);
    return STATUS_SUCCESS;
}


NTSTATUS
RemoveAlias(
    IN PALIAS Alias
    )

/*++

    This routine removes an alias.

--*/

{
    RemoveEntryList(&Alias->ListLink);
    ConsoleHeapFree(Alias->Source);
    ConsoleHeapFree(Alias->Target);
    ConsoleHeapFree(Alias);
    return STATUS_SUCCESS;
}

VOID
FreeAliasList(
    IN PEXE_ALIAS_LIST ExeAliasList
    )
{
    PLIST_ENTRY ListHead, ListNext;
    PALIAS Alias;

    ListHead = &ExeAliasList->AliasList;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        Alias = CONTAINING_RECORD( ListNext, ALIAS, ListLink );
        ListNext = ListNext->Flink;
        RemoveAlias(Alias);
    }
    RemoveEntryList(&ExeAliasList->ListLink);
    ConsoleHeapFree(ExeAliasList->ExeName);
    ConsoleHeapFree(ExeAliasList);
}

VOID
FreeAliasBuffers(
    IN PCONSOLE_INFORMATION Console
    )
{
    PEXE_ALIAS_LIST AliasList;
    PLIST_ENTRY ListHead, ListNext;

    ListHead = &Console->ExeAliasList;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        AliasList = CONTAINING_RECORD( ListNext, EXE_ALIAS_LIST, ListLink );
        ListNext = ListNext->Flink;
        FreeAliasList(AliasList);
    }
}

ULONG
SrvAddConsoleAlias(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Routine Description:

    This routine adds a command line alias to the global set.

Arguments:

    m - message containing api parameters

    ReplyStatus - Indicates whether to reply to the dll port.

Return Value:

--*/

{

    PCONSOLE_ADDALIAS_MSG a = (PCONSOLE_ADDALIAS_MSG)&m->u.ApiMessageData;
    PALIAS Alias;
    PCONSOLE_INFORMATION Console;
    PEXE_ALIAS_LIST ExeAliasList;
    NTSTATUS Status;
    LPWSTR Source,Target;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (!CsrValidateMessageBuffer(m, &a->Source, a->SourceLength, sizeof(BYTE)) ||
        !CsrValidateMessageBuffer(m, &a->Target,a->TargetLength, sizeof(BYTE)) ||
        !CsrValidateMessageBuffer(m, &a->Exe, a->ExeLength, sizeof(BYTE))) {

        UnlockConsole(Console);
        return STATUS_INVALID_PARAMETER;
    }

    if (a->Unicode) {
        Source = a->Source;
        Target = a->Target;
    } else {
        Source = (LPWSTR)ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ),a->SourceLength*sizeof(WCHAR));
        if (Source == NULL) {
            UnlockConsole(Console);
            return (ULONG)STATUS_NO_MEMORY;
        }
        Target = (LPWSTR)ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ),a->TargetLength*sizeof(WCHAR));
        if (Target == NULL) {
            ConsoleHeapFree(Source);
            UnlockConsole(Console);
            return (ULONG)STATUS_NO_MEMORY;
        }
        a->SourceLength = (USHORT)ConvertInputToUnicode(Console->CP,
                                            a->Source,
                                            a->SourceLength,
                                            Source,
                                            a->SourceLength);
        a->SourceLength *= 2;
        a->TargetLength = (USHORT)ConvertInputToUnicode(Console->CP,
                                            a->Target,
                                            a->TargetLength,
                                            Target,
                                            a->TargetLength);
        a->TargetLength *= 2;
    }

    //
    // find specified exe.  if it's not there, add it if we're not
    // removing an alias.
    //

    ExeAliasList = FindExe(Console,a->Exe,a->ExeLength,a->UnicodeExe);
    if (ExeAliasList) {
        Alias = FindAlias(ExeAliasList,Source,a->SourceLength);
        if (a->TargetLength) {
            if (Alias) {
                Status = ReplaceAlias(Alias,
                                      Target,
                                      a->TargetLength);
            } else {
                Status = AddAlias(ExeAliasList,
                                  Source,
                                  a->SourceLength,
                                  Target,
                                  a->TargetLength);
            }
        } else {
            if (Alias) {
                Status = RemoveAlias(Alias);
            }
        }
    } else {
        if (a->TargetLength) {
            ExeAliasList = AddExeAliasList(Console,a->Exe,a->ExeLength,a->UnicodeExe);
            if (ExeAliasList) {
                Status = AddAlias(ExeAliasList,
                                  Source,
                                  a->SourceLength,
                                  Target,
                                  a->TargetLength);
            } else {
                Status = STATUS_NO_MEMORY;
            }
        }
    }
    UnlockConsole(Console);
    if (!a->Unicode) {
        ConsoleHeapFree(Source);
        ConsoleHeapFree(Target);
    }
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvGetConsoleAlias(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Routine Description:

    This routine get a command line alias from the global set.

Arguments:

    m - message containing api parameters

    ReplyStatus - Indicates whether to reply to the dll port.

Return Value:

--*/

{

    NTSTATUS Status;
    PCONSOLE_GETALIAS_MSG a = (PCONSOLE_GETALIAS_MSG)&m->u.ApiMessageData;
    PALIAS Alias;
    PCONSOLE_INFORMATION Console;
    PEXE_ALIAS_LIST ExeAliasList;
    LPWSTR Source,Target;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (!CsrValidateMessageBuffer(m, &a->Source, a->SourceLength, sizeof(BYTE)) ||
        !CsrValidateMessageBuffer(m, &a->Target, a->TargetLength, sizeof(BYTE)) ||
        !CsrValidateMessageBuffer(m, &a->Exe, a->ExeLength, sizeof(BYTE))) {

        UnlockConsole(Console);
        return STATUS_INVALID_PARAMETER;
    }

    if (a->Unicode) {
        Source = a->Source;
        Target = a->Target;
    } else {
        Source = (LPWSTR)ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ),a->SourceLength*sizeof(WCHAR));
        if (Source == NULL) {
            UnlockConsole(Console);
            return (ULONG)STATUS_NO_MEMORY;
        }
        Target = (LPWSTR)ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ),a->TargetLength*sizeof(WCHAR));
        if (Target == NULL) {
            ConsoleHeapFree(Source);
            UnlockConsole(Console);
            return (ULONG)STATUS_NO_MEMORY;
        }
        a->TargetLength = (USHORT)(a->TargetLength * sizeof(WCHAR));
        a->SourceLength = (USHORT)ConvertInputToUnicode(Console->CP,
                                            a->Source,
                                            a->SourceLength,
                                            Source,
                                            a->SourceLength);
        a->SourceLength *= 2;
    }
    ExeAliasList = FindExe(Console,a->Exe,a->ExeLength,a->UnicodeExe);
    if (ExeAliasList) {
        Alias = FindAlias(ExeAliasList,Source,a->SourceLength);
        if (Alias) {
            if (Alias->TargetLength + sizeof(WCHAR) > a->TargetLength) {
                Status = STATUS_BUFFER_TOO_SMALL;
            } else {
                a->TargetLength = Alias->TargetLength + sizeof(WCHAR);
                RtlCopyMemory(Target,Alias->Target,Alias->TargetLength);
                Target[Alias->TargetLength/sizeof(WCHAR)] = L'\0';
            }
        } else {
            Status = STATUS_UNSUCCESSFUL;
        }
    } else {
        Status = STATUS_UNSUCCESSFUL;
    }
    if (!a->Unicode) {
        if (NT_SUCCESS(Status)) {
            a->TargetLength = (USHORT)ConvertToOem(Console->CP,
                                             Target,
                                             a->TargetLength / sizeof(WCHAR),
                                             a->Target,
                                             CHAR_COUNT(a->TargetLength)
                                             );
        }
        ConsoleHeapFree(Source);
        ConsoleHeapFree(Target);
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

DWORD
SrvGetConsoleAliasesLength(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_GETALIASESLENGTH_MSG a = (PCONSOLE_GETALIASESLENGTH_MSG)&m->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;
    PEXE_ALIAS_LIST ExeAliasList;
    PALIAS Alias;
    PLIST_ENTRY ListHead, ListNext;
    NTSTATUS Status;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (!CsrValidateMessageBuffer(m, &a->Exe, a->ExeLength, sizeof(BYTE))) {
        UnlockConsole(Console);
        return STATUS_INVALID_PARAMETER;
    }

    a->AliasesLength = 0;
    ExeAliasList = FindExe(Console,a->Exe,a->ExeLength,a->UnicodeExe);
    if (ExeAliasList) {
        ListHead = &ExeAliasList->AliasList;
        ListNext = ListHead->Flink;
        while (ListNext != ListHead) {
            Alias = CONTAINING_RECORD( ListNext, ALIAS, ListLink );
            a->AliasesLength += Alias->SourceLength + Alias->TargetLength + (2*sizeof(WCHAR));  // +2 is for = and term null
            ListNext = ListNext->Flink;
        }
    }
    if (!a->Unicode) {
        a->AliasesLength /= sizeof(WCHAR);
    }
    UnlockConsole(Console);
    return STATUS_SUCCESS;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

VOID
ClearAliases(
    IN PCONSOLE_INFORMATION Console
    )
{
    PEXE_ALIAS_LIST ExeAliasList;
    PLIST_ENTRY ListHead, ListNext;
    PALIAS Alias;

    ExeAliasList = FindExe(Console,
                           L"cmd.exe",
                           14,
                           TRUE);
    if (ExeAliasList == NULL) {
        return;
    }
    ListHead = &ExeAliasList->AliasList;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        Alias = CONTAINING_RECORD( ListNext, ALIAS, ListLink );
        ListNext = ListNext->Flink;
        RemoveAlias(Alias);
    }
}

DWORD
SrvGetConsoleAliases(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_GETALIASES_MSG a = (PCONSOLE_GETALIASES_MSG)&m->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;
    PEXE_ALIAS_LIST ExeAliasList;
    PALIAS Alias;
    PLIST_ENTRY ListHead, ListNext;
    DWORD AliasesBufferLength;
    LPWSTR AliasesBufferPtrW;
    LPSTR  AliasesBufferPtrA;
    NTSTATUS Status;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (!CsrValidateMessageBuffer(m, &a->AliasesBuffer, a->AliasesBufferLength, sizeof(BYTE)) ||
        !CsrValidateMessageBuffer(m, &a->Exe, a->ExeLength, sizeof(BYTE))) {

        UnlockConsole(Console);
        return STATUS_INVALID_PARAMETER;
    }

    AliasesBufferLength = a->AliasesBufferLength;
    if (a->Unicode) {
        AliasesBufferPtrW = a->AliasesBuffer;
    } else {
        AliasesBufferPtrA = a->AliasesBuffer;
    }
    a->AliasesBufferLength = 0;
    ExeAliasList = FindExe(Console,a->Exe,a->ExeLength,a->UnicodeExe);
    if (ExeAliasList) {
        ListHead = &ExeAliasList->AliasList;
        ListNext = ListHead->Flink;
        while (ListNext != ListHead) {
            Alias = CONTAINING_RECORD( ListNext, ALIAS, ListLink );
            if (a->Unicode) {
                if ((a->AliasesBufferLength + Alias->SourceLength + Alias->TargetLength + (2*sizeof(WCHAR)))
                    <= AliasesBufferLength) {
                    RtlCopyMemory(AliasesBufferPtrW,Alias->Source,Alias->SourceLength);
                    AliasesBufferPtrW+=Alias->SourceLength/sizeof(WCHAR);
                    *AliasesBufferPtrW++= (WCHAR)'=';
                    RtlCopyMemory(AliasesBufferPtrW,Alias->Target,Alias->TargetLength);
                    AliasesBufferPtrW+=Alias->TargetLength/sizeof(WCHAR);
                    *AliasesBufferPtrW++= (WCHAR)'\0';
                    a->AliasesBufferLength += Alias->SourceLength + Alias->TargetLength + (2*sizeof(WCHAR));  // +2 is for = and term null
                } else {
                    UnlockConsole(Console);
                    return (ULONG)STATUS_BUFFER_OVERFLOW;
                }
            } else {
                if ((a->AliasesBufferLength + ((Alias->SourceLength + Alias->TargetLength)/sizeof(WCHAR)) + (2*sizeof(CHAR)))
                    <= AliasesBufferLength) {
                    USHORT SourceLength,TargetLength;
                    SourceLength = (USHORT)ConvertToOem(Console->CP,
                                                 Alias->Source,
                                                 Alias->SourceLength / sizeof(WCHAR),
                                                 AliasesBufferPtrA,
                                                 CHAR_COUNT(Alias->SourceLength)
                                                 );
                    AliasesBufferPtrA+=SourceLength;
                    *AliasesBufferPtrA++ = '=';
                    TargetLength = (USHORT)ConvertToOem(Console->CP,
                                                 Alias->Target,
                                                 Alias->TargetLength / sizeof(WCHAR),
                                                 AliasesBufferPtrA,
                                                 CHAR_COUNT(Alias->TargetLength)
                                                 );
                    AliasesBufferPtrA+=TargetLength;
                    *AliasesBufferPtrA++= '\0';
                    a->AliasesBufferLength += SourceLength + TargetLength + (2*sizeof(CHAR));  // +2 is for = and term null
                } else {
                    UnlockConsole(Console);
                    return (ULONG)STATUS_BUFFER_OVERFLOW;
                }
            }
            ListNext = ListNext->Flink;
        }
    }
    UnlockConsole(Console);
    return STATUS_SUCCESS;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

DWORD
SrvGetConsoleAliasExesLength(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_GETALIASEXESLENGTH_MSG a = (PCONSOLE_GETALIASEXESLENGTH_MSG)&m->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;
    PEXE_ALIAS_LIST AliasList;
    PLIST_ENTRY ListHead, ListNext;
    NTSTATUS Status;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    a->AliasExesLength = 0;
    ListHead = &Console->ExeAliasList;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        AliasList = CONTAINING_RECORD( ListNext, EXE_ALIAS_LIST, ListLink );
        a->AliasExesLength += AliasList->ExeLength + (1*sizeof(WCHAR)); // +1 for term null
        ListNext = ListNext->Flink;
    }
    if (!a->Unicode) {
        a->AliasExesLength /= sizeof(WCHAR);
    }
    UnlockConsole(Console);
    return STATUS_SUCCESS;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

DWORD
SrvGetConsoleAliasExes(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_GETALIASEXES_MSG a = (PCONSOLE_GETALIASEXES_MSG)&m->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;
    PEXE_ALIAS_LIST AliasList;
    PLIST_ENTRY ListHead, ListNext;
    DWORD AliasExesBufferLength;
    LPWSTR AliasExesBufferPtrW;
    LPSTR  AliasExesBufferPtrA;
    NTSTATUS Status;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (!CsrValidateMessageBuffer(m, &a->AliasExesBuffer, a->AliasExesBufferLength, sizeof(BYTE))) {
        UnlockConsole(Console);
        return STATUS_INVALID_PARAMETER;
    }

    AliasExesBufferLength = a->AliasExesBufferLength;
    if (a->Unicode) {
        AliasExesBufferPtrW = a->AliasExesBuffer;
    } else {
        AliasExesBufferPtrA = a->AliasExesBuffer;
    }
    a->AliasExesBufferLength = 0;
    ListHead = &Console->ExeAliasList;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        AliasList = CONTAINING_RECORD( ListNext, EXE_ALIAS_LIST, ListLink );
        if (a->Unicode) {
            if ((a->AliasExesBufferLength + AliasList->ExeLength + (1*sizeof(WCHAR)))
                <= AliasExesBufferLength) {
                RtlCopyMemory(AliasExesBufferPtrW,AliasList->ExeName,AliasList->ExeLength);
                AliasExesBufferPtrW+=AliasList->ExeLength/sizeof(WCHAR);
                *AliasExesBufferPtrW++= (WCHAR)'\0';
                a->AliasExesBufferLength += AliasList->ExeLength + (1*sizeof(WCHAR));  // +1 is term null
            } else {
                UnlockConsole(Console);
                return (ULONG)STATUS_BUFFER_OVERFLOW;
            }
        } else {
            if ((a->AliasExesBufferLength + (AliasList->ExeLength/sizeof(WCHAR)) + (1*sizeof(CHAR)))
                <= AliasExesBufferLength) {
                USHORT Length;
                Length = (USHORT)ConvertToOem(Console->CP,
                                        AliasList->ExeName,
                                        AliasList->ExeLength / sizeof(WCHAR),
                                        AliasExesBufferPtrA,
                                        CHAR_COUNT(AliasList->ExeLength)
                                        );
                AliasExesBufferPtrA+=Length;
                *AliasExesBufferPtrA++= (WCHAR)'\0';
                a->AliasExesBufferLength += Length + (1*sizeof(CHAR));  // +1 is term null
            } else {
                UnlockConsole(Console);
                return (ULONG)STATUS_BUFFER_OVERFLOW;
            }
        }
        ListNext = ListNext->Flink;
    }
    UnlockConsole(Console);
    return STATUS_SUCCESS;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

#define MAX_ARGS 9

NTSTATUS
MatchandCopyAlias(
    IN PCONSOLE_INFORMATION Console,
    IN PWCHAR Source,
    IN USHORT SourceLength,
    OUT PWCHAR TargetBuffer,
    IN OUT PUSHORT TargetLength,
    IN LPWSTR Exe,
    IN USHORT ExeLength,
    OUT PDWORD LineCount
    )

/*++

Routine Description:

    This routine matches the input string with an alias and copies the
    alias to the input buffer.

Arguments:

    Source - string to match

    SourceLength - length of Source in bytes

    TargetBuffer - where to store matched string

    TargetLength - on input, contains size of TargetBuffer.  On output,
    contains length of alias stored in TargetBuffer.

    SourceIsCommandLine - if true, source buffer is a command line, where
        the first blank separate token is to be check for an alias, and if
        it matches, replaced with the value of the alias.  if false, then
        the source string is a null terminated alias name.

    LineCount - aliases can contain multiple commands.  $T is the command
        separator

Return Value:

    SUCCESS - match was found and alias was copied to buffer.

--*/

{
    PALIAS Alias;
    NTSTATUS Status = STATUS_SUCCESS;
    USHORT SourceUpToFirstBlank=0;  // in chars
    PWCHAR Tmp;
    PEXE_ALIAS_LIST ExeAliasList;
    LPWSTR Args[MAX_ARGS];
    USHORT ArgsLength[MAX_ARGS];    // in bytes
    USHORT NumSourceArgs;
    LPWSTR SourcePtr;
    USHORT ArgCount,i,j,NewTargetLength;
    USHORT SourceRemainderLength;   // in chars
    PWCHAR Buffer,TargetAlias;
    PWCHAR TmpBuffer;

    //
    // alloc of exename may have failed.
    //

    if (Exe == NULL)
        return STATUS_UNSUCCESSFUL;

    //
    // find exe
    //

    ExeAliasList = FindExe(Console,Exe,ExeLength,TRUE);
    if (!ExeAliasList) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // find first blank
    //

    for (Tmp=Source,SourceUpToFirstBlank=0;
         *Tmp!=(WCHAR)' ' && SourceUpToFirstBlank<(USHORT)(SourceLength/sizeof(WCHAR));
         Tmp++,SourceUpToFirstBlank++) ;

    //
    // find char past first blank
    //

    j=SourceUpToFirstBlank;
    while (j<(USHORT)(SourceLength/sizeof(WCHAR)) && *Tmp==(WCHAR)' ') {
        Tmp++;
        j++;
    }
    SourcePtr = Tmp;
    SourceRemainderLength = (USHORT)((SourceLength/sizeof(WCHAR)) - j);

    //
    // find alias
    //

    Alias = FindAlias(ExeAliasList,Source,(USHORT)(SourceUpToFirstBlank*sizeof(WCHAR)));
    if (!Alias) {
        return STATUS_UNSUCCESSFUL;
    }

    TmpBuffer = (PWCHAR)ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ),*TargetLength);
    if (!TmpBuffer)
        return STATUS_NO_MEMORY;

    //
    // count args in target
    //

    ArgCount=0;
    *LineCount=1;
    Tmp=Alias->Target;
    for (i=0;(USHORT)(i+1)<(USHORT)(Alias->TargetLength/sizeof(WCHAR));i++) {
        if (*Tmp == (WCHAR)'$' && *(Tmp+1) >= (WCHAR)'1' && *(Tmp+1) <= (WCHAR)'9') {
            USHORT ArgNum = *(Tmp+1) - (WCHAR)'0';
            if (ArgNum > ArgCount) {
                ArgCount = ArgNum;
            }
            Tmp++;
            i++;
        } else if (*Tmp == (WCHAR)'$' && *(Tmp+1) == (WCHAR)'*') {
            if (ArgCount==0) {
                ArgCount = 1;
            }
            Tmp++;
            i++;
        }
        Tmp++;
    }

    //
    // package up space separated strings in source into array
    // of args
    //
    //

    NumSourceArgs=0;
    Tmp = SourcePtr;
    for (i=0,j=0;i<ArgCount;i++) {
        if (j<SourceRemainderLength) {
            Args[NumSourceArgs] = Tmp;
            ArgsLength[NumSourceArgs] = 0;
            while (j++<SourceRemainderLength && *Tmp++ != (WCHAR)' ') {
                ArgsLength[NumSourceArgs] += sizeof(WCHAR);
            }
            while (j<SourceRemainderLength && *Tmp == (WCHAR)' ') {
                j++;
                Tmp++;
            }
            NumSourceArgs++;
        } else {
            break;
        }
    }

    //
    // put together the target string
    //
    // while (target)
    //     if ($)
    //        if arg && arg# <= ArgCount
    //            copy arg
    //        else if *
    //            copy arg
    //        else
    //            replace with < > etc
    //     else
    //        copy text up to next ' '
    //

    Buffer = TmpBuffer;
    NewTargetLength = 2*sizeof(WCHAR);    // for CRLF
    TargetAlias=Alias->Target;
    for (i=0;i<(USHORT)(Alias->TargetLength/sizeof(WCHAR));i++) {
        if (NewTargetLength >= *TargetLength) {
            *TargetLength = NewTargetLength;
            Status = STATUS_BUFFER_TOO_SMALL;
            break;
        }
        if (*TargetAlias == (WCHAR)'$' && (USHORT)(i+1)<(USHORT)(Alias->TargetLength/sizeof(WCHAR))) {
            TargetAlias++;
            i++;
            if (*TargetAlias >= (WCHAR)'1' && *TargetAlias <= (WCHAR)'9') {

                //
                // do numbered parameter substitution
                //

                USHORT ArgNumber;

                ArgNumber = (USHORT)(*TargetAlias - (WCHAR)'1');
                if (ArgNumber < NumSourceArgs) {
                    if ((NewTargetLength+ArgsLength[ArgNumber])<=*TargetLength) {
                        RtlCopyMemory(Buffer,Args[ArgNumber],ArgsLength[ArgNumber]);
                        Buffer+=ArgsLength[ArgNumber]/sizeof(WCHAR);
                        NewTargetLength+=ArgsLength[ArgNumber];
                    } else {
                        Status = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }
                }
            } else if (*TargetAlias == (WCHAR)'*') {

                //
                // do * parameter substitution
                //

                if (NumSourceArgs) {
                    if ((USHORT)(NewTargetLength+(SourceRemainderLength*sizeof(WCHAR)))<=*TargetLength) {
                        RtlCopyMemory(Buffer,Args[0],SourceRemainderLength*sizeof(WCHAR));
                        Buffer+=SourceRemainderLength;
                        NewTargetLength+=SourceRemainderLength*sizeof(WCHAR);
                    } else {
                        Status = STATUS_BUFFER_TOO_SMALL;
                        break;
                    }
                }
            } else if (*TargetAlias == (WCHAR)'l' || *TargetAlias == (WCHAR)'L') {

                //
                // do < substitution
                //

                *Buffer++ = (WCHAR)'<';
                NewTargetLength+=sizeof(WCHAR);
            } else if (*TargetAlias == (WCHAR)'g' || *TargetAlias == (WCHAR)'G') {

                //
                // do > substitution
                //

                *Buffer++ = (WCHAR)'>';
                NewTargetLength+=sizeof(WCHAR);
            } else if (*TargetAlias == (WCHAR)'b' || *TargetAlias == (WCHAR)'B') {

                //
                // do | substitution
                //

                *Buffer++ = (WCHAR)'|';
                NewTargetLength+=sizeof(WCHAR);
            } else if (*TargetAlias == (WCHAR)'t' || *TargetAlias == (WCHAR)'T') {

                //
                // do newline substitution
                //

                if ((USHORT)(NewTargetLength+(sizeof(WCHAR)*2))>*TargetLength) {
                    Status = STATUS_BUFFER_TOO_SMALL;
                }

                *LineCount += 1;
                *Buffer++ = UNICODE_CARRIAGERETURN;
                *Buffer++ = UNICODE_LINEFEED;
                NewTargetLength+=sizeof(WCHAR)*2;
            } else {

                //
                // copy $X
                //

                *Buffer++ = (WCHAR)'$';
                NewTargetLength+=sizeof(WCHAR);
                *Buffer++ = *TargetAlias;
                NewTargetLength+=sizeof(WCHAR);
            }
            TargetAlias++;
        } else {

            //
            // copy char
            //

            *Buffer++ = *TargetAlias++;
            NewTargetLength+=sizeof(WCHAR);
        }
    }
    *Buffer++ = UNICODE_CARRIAGERETURN;
    *Buffer++ = UNICODE_LINEFEED;
    RtlCopyMemory(TargetBuffer,TmpBuffer,NewTargetLength);
    ConsoleHeapFree(TmpBuffer);
    *TargetLength = NewTargetLength;
    return Status;
}

DWORD
SrvExpungeConsoleCommandHistory(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_EXPUNGECOMMANDHISTORY_MSG a = (PCONSOLE_EXPUNGECOMMANDHISTORY_MSG)&m->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;
    NTSTATUS Status;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (!CsrValidateMessageBuffer(m, &a->Exe, a->ExeLength, sizeof(BYTE))) {
        UnlockConsole(Console);
        return STATUS_INVALID_PARAMETER;
    }

    EmptyCommandHistory(FindExeCommandHistory(Console,
                                              a->Exe,
                                              a->ExeLength,
                                              a->UnicodeExe));
    UnlockConsole(Console);
    return STATUS_SUCCESS;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

DWORD
SrvSetConsoleNumberOfCommands(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_SETNUMBEROFCOMMANDS_MSG a = (PCONSOLE_SETNUMBEROFCOMMANDS_MSG)&m->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;
    NTSTATUS Status;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (!CsrValidateMessageBuffer(m, &a->Exe, a->ExeLength, sizeof(BYTE))) {
        UnlockConsole(Console);
        return STATUS_INVALID_PARAMETER;
    }

    ReallocCommandHistory(Console,
                          FindExeCommandHistory(Console,
                                                a->Exe,
                                                a->ExeLength,
                                                a->UnicodeExe),
                          a->NumCommands
                         );
    UnlockConsole(Console);
    return STATUS_SUCCESS;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

DWORD
SrvGetConsoleCommandHistoryLength(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_GETCOMMANDHISTORYLENGTH_MSG a = (PCONSOLE_GETCOMMANDHISTORYLENGTH_MSG)&m->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;
    NTSTATUS Status;
    SHORT i;
    PCOMMAND_HISTORY CommandHistory;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (!CsrValidateMessageBuffer(m, &a->Exe, a->ExeLength, sizeof(BYTE))) {
        UnlockConsole(Console);
        return STATUS_INVALID_PARAMETER;
    }

    a->CommandHistoryLength=0;
    CommandHistory=FindExeCommandHistory(Console,
                                         a->Exe,
                                         a->ExeLength,
                                         a->UnicodeExe);
    if (CommandHistory) {
        for (i=0;i<CommandHistory->NumberOfCommands;i++) {
            a->CommandHistoryLength+=CommandHistory->Commands[i]->CommandLength+sizeof(WCHAR);
        }
    }
    if (!a->Unicode) {
        a->CommandHistoryLength /= sizeof(WCHAR);
    }
    UnlockConsole(Console);
    return STATUS_SUCCESS;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

DWORD
SrvGetConsoleCommandHistory(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_GETCOMMANDHISTORY_MSG a = (PCONSOLE_GETCOMMANDHISTORY_MSG)&m->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;
    NTSTATUS Status;
    SHORT i,CommandHistoryLength;
    PCOMMAND_HISTORY CommandHistory;
    PWCHAR CommandBufferW;
    PCHAR CommandBufferA;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (!CsrValidateMessageBuffer(m, &a->CommandBuffer, a->CommandBufferLength, sizeof(BYTE)) ||
        !CsrValidateMessageBuffer(m, &a->Exe, a->ExeLength, sizeof(BYTE))) {

        UnlockConsole(Console);
        return STATUS_INVALID_PARAMETER;
    }

    if (a->Unicode) {
        CommandBufferW=a->CommandBuffer;
    } else {
        CommandBufferA=a->CommandBuffer;
    }
    CommandHistoryLength=0;
    CommandHistory=FindExeCommandHistory(Console,
                                         a->Exe,
                                         a->ExeLength,
                                         a->UnicodeExe);
    if (CommandHistory) {
        for (i=0;i<CommandHistory->NumberOfCommands;i++) {
            if (a->Unicode) {
                if ((CommandHistoryLength+CommandHistory->Commands[i]->CommandLength+sizeof(WCHAR)) <= a->CommandBufferLength) {
                    RtlCopyMemory(CommandBufferW,CommandHistory->Commands[i]->Command,CommandHistory->Commands[i]->CommandLength);
                    CommandBufferW+=CommandHistory->Commands[i]->CommandLength/sizeof(WCHAR);
                    *CommandBufferW++=(WCHAR)'\0';
                    CommandHistoryLength+=CommandHistory->Commands[i]->CommandLength+sizeof(WCHAR);
                } else {
                    Status = STATUS_BUFFER_OVERFLOW;
                    break;
                }
            } else {
                if ((CommandHistoryLength+(CommandHistory->Commands[i]->CommandLength/sizeof(WCHAR))+sizeof(CHAR)) <= a->CommandBufferLength) {
                    USHORT Length;
                    Length = (USHORT)ConvertToOem(Console->CP,
                                            CommandHistory->Commands[i]->Command,
                                            CommandHistory->Commands[i]->CommandLength / sizeof(WCHAR),
                                            CommandBufferA,
                                            CHAR_COUNT(CommandHistory->Commands[i]->CommandLength)
                                            );
                    CommandBufferA+=Length;
                    *CommandBufferA++=(WCHAR)'\0';
                    CommandHistoryLength+=CommandHistory->Commands[i]->CommandLength+sizeof(WCHAR);
                } else {
                    Status = STATUS_BUFFER_OVERFLOW;
                    break;
                }
            }
        }
    }
    a->CommandBufferLength=CommandHistoryLength;
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

DWORD
SrvSetConsoleCommandHistoryMode(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_SETCOMMANDHISTORYMODE_MSG a = (PCONSOLE_SETCOMMANDHISTORYMODE_MSG)&m->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;
    NTSTATUS Status;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Console->InsertMode = (BOOLEAN) (a->Flags != CONSOLE_OVERSTRIKE);
    UnlockConsole(Console);
    return STATUS_SUCCESS;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

PCOMMAND_HISTORY
ReallocCommandHistory(
    IN PCONSOLE_INFORMATION Console,
    IN PCOMMAND_HISTORY CurrentCommandHistory,
    IN DWORD NumCommands
    )
{
    PCOMMAND_HISTORY History;
    int i;

    if (CurrentCommandHistory == NULL ||
        CurrentCommandHistory->MaximumNumberOfCommands==(SHORT)NumCommands) {
        return CurrentCommandHistory;
    }
    History = (PCOMMAND_HISTORY)ConsoleHeapAlloc(MAKE_TAG( HISTORY_TAG ),sizeof(COMMAND_HISTORY) + ((NumCommands-1) * sizeof(PCOMMAND)));
    if (History == NULL) {
        return CurrentCommandHistory;
    }
    *History=*CurrentCommandHistory;
    History->Flags |= CLE_RESET;
    History->NumberOfCommands = min(History->NumberOfCommands, (SHORT)NumCommands);
    History->LastAdded = History->NumberOfCommands - 1;
    History->LastDisplayed = History->NumberOfCommands - 1;
    History->FirstCommand = 0;
    History->MaximumNumberOfCommands=(SHORT)NumCommands;
    for (i=0; i<History->NumberOfCommands; i++) {
        History->Commands[i] = CurrentCommandHistory->Commands[COMMAND_NUM_TO_INDEX(i,CurrentCommandHistory)];
    }
    for (; i<CurrentCommandHistory->NumberOfCommands; i++) {
        ConsoleHeapFree(CurrentCommandHistory->Commands[COMMAND_NUM_TO_INDEX(i,CurrentCommandHistory)]);
    }

    RemoveEntryList(&CurrentCommandHistory->ListLink);
    InitializeListHead(&History->PopupList);
    InsertHeadList(&Console->CommandHistoryList,&History->ListLink);

    ConsoleHeapFree(CurrentCommandHistory);
    return History;
}

PCOMMAND_HISTORY
FindExeCommandHistory(
    IN PCONSOLE_INFORMATION Console,
    IN PVOID AppName,
    IN DWORD AppNameLength,
    IN BOOLEAN Unicode
    )
{
    PCOMMAND_HISTORY History;
    PLIST_ENTRY ListHead, ListNext;
    PWCHAR AppNamePtr;

    if (!Unicode) {
        AppNamePtr = (PWCHAR)ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ),AppNameLength * sizeof(WCHAR));
        if (AppNamePtr == NULL) {
            return NULL;
        }
        AppNameLength = ConvertInputToUnicode(Console->CP,
                                  AppName,
                                  AppNameLength,
                                  AppNamePtr,
                                  AppNameLength);
        AppNameLength *= 2;
    } else {
        AppNamePtr = AppName;
    }
    ListHead = &Console->CommandHistoryList;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        History = CONTAINING_RECORD( ListNext, COMMAND_HISTORY, ListLink );
        ListNext = ListNext->Flink;

        if (History->Flags & CLE_ALLOCATED &&
            !my_wcsncmpi(History->AppName,AppNamePtr,(USHORT)AppNameLength)) {
            if (!Unicode) {
                ConsoleHeapFree(AppNamePtr);
            }
            return History;
        }
    }
    if (!Unicode) {
        ConsoleHeapFree(AppNamePtr);
    }
    return NULL;
}

PCOMMAND_HISTORY
AllocateCommandHistory(
    IN PCONSOLE_INFORMATION Console,
    IN DWORD AppNameLength,
    IN PWCHAR AppName,
    IN HANDLE ProcessHandle
    )

/*++

Routine Description:

    This routine returns the LRU command history buffer, or the command history
    buffer that corresponds to the app name.

Arguments:

    Console - pointer to console.

Return Value:

    Pointer to command history buffer.  if none are available, returns NULL.

--*/

{
    PCOMMAND_HISTORY History,BestCandidate;
    PLIST_ENTRY ListHead, ListNext;
    BOOL SameApp;

    //
    // Reuse a history buffer.  The buffer must be !CLE_ALLOCATED.
    // If possible, the buffer should have the same app name.
    //

    ListHead = &Console->CommandHistoryList;
    ListNext = ListHead->Blink;
    BestCandidate = NULL;
    SameApp = FALSE;
    while (ListNext != ListHead) {
        History = CONTAINING_RECORD( ListNext, COMMAND_HISTORY, ListLink );
        ListNext = ListNext->Blink;

        if ((History->Flags & CLE_ALLOCATED) == 0) {

            //
            // use LRU history buffer with same app name
            //

            if (History->AppName && !my_wcsncmpi(History->AppName,AppName,(USHORT)AppNameLength)) {
                BestCandidate = History;
                SameApp = TRUE;
                break;
            }

            //
            // second best choice is LRU history buffer
            //

            if (BestCandidate == NULL) {
                BestCandidate = History;
            }
        }
    }

    //
    // if there isn't a free buffer for the app name and the maximum number of
    // command history buffers hasn't been allocated, allocate a new one.
    //

    if (!SameApp && Console->NumCommandHistories < Console->MaxCommandHistories) {
        History = (PCOMMAND_HISTORY)ConsoleHeapAlloc(MAKE_TAG( HISTORY_TAG ),sizeof(COMMAND_HISTORY) + ((Console->CommandHistorySize-1) * sizeof(PCOMMAND)));
        if (History == NULL) {
            return NULL;
        }
        History->AppName = (LPWSTR)ConsoleHeapAlloc(MAKE_TAG( HISTORY_TAG ),AppNameLength);
        if (History->AppName == NULL) {
            ConsoleHeapFree(History);
            return NULL;
        }
        RtlCopyMemory(History->AppName,AppName,AppNameLength);
        History->Flags = CLE_ALLOCATED;
        History->NumberOfCommands = 0;
        History->LastAdded = -1;
        History->LastDisplayed = -1;
        History->FirstCommand = 0;
        History->MaximumNumberOfCommands = Console->CommandHistorySize;
        InsertHeadList(&Console->CommandHistoryList,&History->ListLink);
        Console->NumCommandHistories+=1;
        History->ProcessHandle = ProcessHandle;
        InitializeListHead(&History->PopupList);
        return History;
    }

    //
    // if the app name doesn't match, copy in the new app name and free the old commands.
    //

    if (BestCandidate) {
        History = BestCandidate;
        ASSERT(CLE_NO_POPUPS(History));
        if (!SameApp) {
            SHORT i;
            if (History->AppName) {
                DBGPRINT(("Reusing %ls command history\n", History->AppName));
                ConsoleHeapFree(History->AppName);
            }
            for (i=0;i<History->NumberOfCommands;i++) {
                ConsoleHeapFree(History->Commands[i]);
            }
            History->NumberOfCommands = 0;
            History->LastAdded = -1;
            History->LastDisplayed = -1;
            History->FirstCommand = 0;
            History->AppName = (LPWSTR)ConsoleHeapAlloc(MAKE_TAG( HISTORY_TAG ),AppNameLength);
            if (History->AppName == NULL) {
                History->Flags &= ~CLE_ALLOCATED;
                return NULL;
            }
            RtlCopyMemory(History->AppName,AppName,AppNameLength);
        }
        History->ProcessHandle = ProcessHandle;
        History->Flags |= CLE_ALLOCATED;

        //
        // move to the front of the list
        //

        RemoveEntryList(&BestCandidate->ListLink);
        InsertHeadList(&Console->CommandHistoryList,&BestCandidate->ListLink);
    }
    return BestCandidate;
}

NTSTATUS
BeginPopup(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PCOMMAND_HISTORY CommandHistory,
    IN COORD PopupSize
    )
{
    COORD Origin;
    COORD Size;
    PCLE_POPUP Popup;
    SMALL_RECT TargetRect;

    // determine popup dimensions

    Size = PopupSize;
    Size.X += 2;    // add borders
    Size.Y += 2;    // add borders
    if (Size.X >= (SHORT)(CONSOLE_WINDOW_SIZE_X(ScreenInfo))) {
        Size.X = (SHORT)(CONSOLE_WINDOW_SIZE_X(ScreenInfo));
    }
    if (Size.Y >= (SHORT)(CONSOLE_WINDOW_SIZE_Y(ScreenInfo))) {
        Size.Y = (SHORT)(CONSOLE_WINDOW_SIZE_Y(ScreenInfo));
    }

    // make sure there's enough room for the popup borders

    if (Size.X < 2 || Size.Y < 2) {
        return STATUS_BUFFER_TOO_SMALL;
    }

    // determine origin.  center popup on window
    Origin.X = (SHORT)((CONSOLE_WINDOW_SIZE_X(ScreenInfo) - Size.X) / 2 + ScreenInfo->Window.Left);
    Origin.Y = (SHORT)((CONSOLE_WINDOW_SIZE_Y(ScreenInfo) - Size.Y) / 2 + ScreenInfo->Window.Top);

    // allocate a popup structure

    Popup = (PCLE_POPUP)ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ),sizeof(CLE_POPUP));
    if (Popup == NULL) {
        return STATUS_NO_MEMORY;
    }

    // allocate a buffer

#if !defined(FE_SB)
    Popup->OldContents = (PCHAR_INFO)ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ),Size.X * Size.Y * sizeof(CHAR_INFO));
#else
    Popup->OldScreenSize = ScreenInfo->ScreenBufferSize;
    Popup->OldContents = (PCHAR_INFO)ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ),Popup->OldScreenSize.X * Size.Y * sizeof(CHAR_INFO));
#endif
    if (Popup->OldContents == NULL) {
        ConsoleHeapFree(Popup);
        return STATUS_NO_MEMORY;
    }
    if ((ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) &&
            !(ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN)) {
        Popup->Flags |= CLEPF_FALSE_UNICODE;
    } else {
        Popup->Flags &= ~CLEPF_FALSE_UNICODE;
    }

    //
    // fill in popup structure
    //

    InsertHeadList(&CommandHistory->PopupList,&Popup->ListLink);
    Popup->Region.Left = Origin.X;
    Popup->Region.Top = Origin.Y;
    Popup->Region.Right = (SHORT)(Origin.X + Size.X - 1);
    Popup->Region.Bottom = (SHORT)(Origin.Y + Size.Y - 1);
    Popup->Attributes = ScreenInfo->PopupAttributes;
    Popup->BottomIndex = COMMAND_INDEX_TO_NUM(CommandHistory->LastDisplayed,CommandHistory);

    //
    // copy old contents
    //

#if !defined(FE_SB)
    TargetRect = Popup->Region;
#else
    TargetRect.Left = 0;
    TargetRect.Top = Popup->Region.Top;
    TargetRect.Right = Popup->OldScreenSize.X - 1;
    TargetRect.Bottom = Popup->Region.Bottom;
#endif
    ReadScreenBuffer(ScreenInfo,
                     Popup->OldContents,
                     &TargetRect);

    ScreenInfo->Console->PopupCount++;
    DrawCommandListBorder(Popup,ScreenInfo);
    return STATUS_SUCCESS;
}

NTSTATUS
EndPopup(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PCOMMAND_HISTORY CommandHistory
    )
{
    COORD Size;
    SMALL_RECT SourceRect;
    PCLE_POPUP Popup;

    ASSERT(!CLE_NO_POPUPS(CommandHistory));
    if (CLE_NO_POPUPS(CommandHistory))
        return STATUS_UNSUCCESSFUL;

    ConsoleHideCursor(ScreenInfo);
    Popup = CONTAINING_RECORD( CommandHistory->PopupList.Flink, CLE_POPUP, ListLink );

    //
    // restore previous contents to screen
    //

#if !defined(FE_SB)
    Size.X = (SHORT)(Popup->Region.Right - Popup->Region.Left + 1);
    Size.Y = (SHORT)(Popup->Region.Bottom - Popup->Region.Top + 1);
    SourceRect = Popup->Region;
#else
    Size.X = Popup->OldScreenSize.X;
    Size.Y = (SHORT)(Popup->Region.Bottom - Popup->Region.Top + 1);
    SourceRect.Left = 0;
    SourceRect.Top = Popup->Region.Top;
    SourceRect.Right = Popup->OldScreenSize.X - 1;
    SourceRect.Bottom = Popup->Region.Bottom;
#endif
    if ((ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) &&
            !(ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN)) {
        /*
         * Screen buffer wants fake Unicode
         */
        if (!(Popup->Flags & CLEPF_FALSE_UNICODE)) {
#if !defined(FE_SB)
            TranslateOutputToAnsiUnicode(ScreenInfo->Console,
                    Popup->OldContents, Size);
#else
            TranslateOutputToAnsiUnicode(ScreenInfo->Console,
                    Popup->OldContents, Size,
                    NULL);
#endif
        }
    } else {
        /*
         * Screen buffer wants real Unicode
         */
        if (Popup->Flags & CLEPF_FALSE_UNICODE) {
#if !defined(FE_SB)
            TranslateOutputToOemUnicode(ScreenInfo->Console,
                    Popup->OldContents, Size);
#else
            TranslateOutputToOemUnicode(ScreenInfo->Console,
                    Popup->OldContents, Size, FALSE);
#endif
        }
    }
    WriteScreenBuffer(ScreenInfo,
                      Popup->OldContents,
                      &SourceRect
                     );
    WriteToScreen(ScreenInfo,
                  &SourceRect
                 );

    ConsoleShowCursor(ScreenInfo);

    //
    // free popup structure
    //

    RemoveEntryList(&Popup->ListLink);
    ConsoleHeapFree(Popup->OldContents);
    ConsoleHeapFree(Popup);
    ScreenInfo->Console->PopupCount--;
    return STATUS_SUCCESS;
}

VOID
CleanUpPopups(
    IN PCOOKED_READ_DATA CookedReadData
    )
{
    PCOMMAND_HISTORY CommandHistory;

    CommandHistory = CookedReadData->CommandHistory;
    if (!CommandHistory)
        return;
    while (!CLE_NO_POPUPS(CommandHistory)) {
        EndPopup(CookedReadData->ScreenInfo,CommandHistory);
    }
}


VOID
DeleteCommandLine(
    IN OUT PCOOKED_READ_DATA CookedReadData,
    IN BOOL UpdateFields
    )
{
    DWORD CharsToWrite = CookedReadData->NumberOfVisibleChars;
    COORD Coord = CookedReadData->OriginalCursorPosition;

    //
    // catch the case where the current command has scrolled off the
    // top of the screen.
    //

    if (Coord.Y < 0) {
        CharsToWrite += CookedReadData->ScreenInfo->ScreenBufferSize.X * Coord.Y;
        CharsToWrite += CookedReadData->OriginalCursorPosition.X;   // account for prompt
        CookedReadData->OriginalCursorPosition.X = 0;
        CookedReadData->OriginalCursorPosition.Y = 0;
        Coord.X = 0;
        Coord.Y = 0;
    }
#if defined(FE_SB)
    if (CONSOLE_IS_DBCS_OUTPUTCP(CookedReadData->ScreenInfo->Console) &&
        !CheckBisectStringW(CookedReadData->ScreenInfo,
                           CookedReadData->ScreenInfo->Console->CP,
                           CookedReadData->BackupLimit,
                           CharsToWrite,
                           CookedReadData->ScreenInfo->ScreenBufferSize.X
                            -CookedReadData->OriginalCursorPosition.X
                           )) {
        CharsToWrite++;
    }
#endif
    FillOutput(CookedReadData->ScreenInfo,
               (WCHAR)' ',
               Coord,
               CONSOLE_FALSE_UNICODE, // faster than real unicode
               &CharsToWrite
              );
    if (UpdateFields) {
        CookedReadData->BufPtr=CookedReadData->BackupLimit;
        CookedReadData->BytesRead=0;
        CookedReadData->CurrentPosition=0;
        CookedReadData->NumberOfVisibleChars = 0;
    }
    SetCursorPosition(CookedReadData->ScreenInfo,
                      CookedReadData->OriginalCursorPosition,
                      TRUE
                     );
}

VOID
RedrawCommandLine(
    IN OUT PCOOKED_READ_DATA CookedReadData
    )
{
    NTSTATUS Status;
    COORD CursorPosition;
    SHORT ScrollY=0;

    if (CookedReadData->Echo) {
        //
        // Draw the command line
        //
        CookedReadData->OriginalCursorPosition = CookedReadData->ScreenInfo->BufferInfo.TextInfo.CursorPosition;
        Status = WriteCharsFromInput(CookedReadData->ScreenInfo,
                                     CookedReadData->BackupLimit,
                                     CookedReadData->BackupLimit,
                                     CookedReadData->BackupLimit,
                                     &CookedReadData->BytesRead,
                                     &CookedReadData->NumberOfVisibleChars,
                                     CookedReadData->OriginalCursorPosition.X,
                                     WC_DESTRUCTIVE_BACKSPACE | WC_KEEP_CURSOR_VISIBLE | WC_ECHO,
                                     &ScrollY);
        ASSERT(NT_SUCCESS(Status));
        CookedReadData->OriginalCursorPosition.Y += ScrollY;

        //
        // Move the cursor back to the right position
        //
        CursorPosition = CookedReadData->OriginalCursorPosition;
        CursorPosition.X += (SHORT)RetrieveTotalNumberOfSpaces(CookedReadData->OriginalCursorPosition.X,
                                                   CookedReadData->BackupLimit,
                                                   CookedReadData->CurrentPosition,
                                                   CookedReadData->ScreenInfo->Console);
        if (CheckBisectStringW(CookedReadData->ScreenInfo,
                               CookedReadData->ScreenInfo->Console->CP,
                               CookedReadData->BackupLimit,
                               CookedReadData->CurrentPosition,
                               CookedReadData->ScreenInfo->ScreenBufferSize.X
                                -CookedReadData->OriginalCursorPosition.X)) {
            CursorPosition.X++;
        }
        Status = AdjustCursorPosition(CookedReadData->ScreenInfo,
                                      CursorPosition,
                                      TRUE,
                                      NULL);
        ASSERT(NT_SUCCESS(Status));
    }
}

NTSTATUS
RetrieveNthCommand(
    IN PCOMMAND_HISTORY CommandHistory,
    IN SHORT Index, // index, not command number
    IN PWCHAR Buffer,
    IN ULONG BufferSize,
    OUT PULONG CommandSize
    )
{
    PCOMMAND CommandRecord;

    ASSERT (Index < CommandHistory->NumberOfCommands);
    CommandHistory->LastDisplayed = Index;
    CommandRecord = CommandHistory->Commands[Index];
    if (CommandRecord->CommandLength > (USHORT)BufferSize) {
        *CommandSize = (USHORT)BufferSize;  // room for CRLF?
    }
    else {
        *CommandSize = CommandRecord->CommandLength;
    }
    RtlCopyMemory(Buffer,CommandRecord->Command,*CommandSize);
    return STATUS_SUCCESS;
}


VOID
SetCurrentCommandLine(
    IN PCOOKED_READ_DATA CookedReadData,
    IN SHORT Index  // index, not command number
    )
/*++

    This routine copies the commandline specified by Index
    into the cooked read buffer

--*/
{
    DWORD CharsToWrite;
    NTSTATUS Status;
    SHORT ScrollY=0;

    DeleteCommandLine(CookedReadData,
                      TRUE);
    Status = RetrieveNthCommand(CookedReadData->CommandHistory,
                                Index,
                                CookedReadData->BackupLimit,
                                CookedReadData->BufferSize,
                                &CookedReadData->BytesRead);
    ASSERT(NT_SUCCESS(Status));
    ASSERT(CookedReadData->BackupLimit == CookedReadData->BufPtr);
    if (CookedReadData->Echo) {
        Status = WriteCharsFromInput(CookedReadData->ScreenInfo,
                CookedReadData->BackupLimit,
                CookedReadData->BufPtr,
                CookedReadData->BufPtr,
                &CookedReadData->BytesRead,
                (PLONG)&CookedReadData->NumberOfVisibleChars,
                CookedReadData->OriginalCursorPosition.X,
                WC_DESTRUCTIVE_BACKSPACE | WC_KEEP_CURSOR_VISIBLE | WC_ECHO,
                &ScrollY);
        ASSERT(NT_SUCCESS(Status));
        CookedReadData->OriginalCursorPosition.Y += ScrollY;
    }
    CharsToWrite = CookedReadData->BytesRead/sizeof(WCHAR);
    CookedReadData->CurrentPosition = CharsToWrite;
    CookedReadData->BufPtr = CookedReadData->BackupLimit + CharsToWrite;
}

BOOL
IsCommandLinePopupKey(
    IN OUT PKEY_EVENT_RECORD KeyEvent
    )
{
    if (!(KeyEvent->dwControlKeyState &
            (RIGHT_ALT_PRESSED | LEFT_ALT_PRESSED |
             RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED))) {
        switch (KeyEvent->wVirtualKeyCode) {
        case VK_ESCAPE:
        case VK_PRIOR:
        case VK_NEXT:
        case VK_END:
        case VK_HOME:
        case VK_LEFT:
        case VK_UP:
        case VK_RIGHT:
        case VK_DOWN:
        case VK_F9:
            return TRUE;
        default:
            break;
        }
    }

    //
    // Extended key handling
    //
    if (gExtendedEditKey && ParseEditKeyInfo(KeyEvent)) {
        return KeyEvent->uChar.UnicodeChar == 0;
    }

    return FALSE;
}

BOOL
IsCommandLineEditingKey(
    IN PKEY_EVENT_RECORD KeyEvent
    )
{
    if (!(KeyEvent->dwControlKeyState &
            (RIGHT_ALT_PRESSED | LEFT_ALT_PRESSED |
             RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED))) {
        switch (KeyEvent->wVirtualKeyCode) {
        case VK_ESCAPE:
        case VK_PRIOR:
        case VK_NEXT:
        case VK_END:
        case VK_HOME:
        case VK_LEFT:
        case VK_UP:
        case VK_RIGHT:
        case VK_DOWN:
        case VK_INSERT:
        case VK_DELETE:
        case VK_F1:
        case VK_F2:
        case VK_F3:
        case VK_F4:
        case VK_F5:
        case VK_F6:
        case VK_F7:
        case VK_F8:
        case VK_F9:
            return TRUE;
        default:
            break;
        }
    }
    if ((KeyEvent->dwControlKeyState &
            (RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED))) {
        switch (KeyEvent->wVirtualKeyCode) {
        case VK_END:
        case VK_HOME:
        case VK_LEFT:
        case VK_RIGHT:
            return TRUE;
        default:
            break;
        }
    }

    //
    // Extended edit key handling
    //
    if (gExtendedEditKey && ParseEditKeyInfo(KeyEvent)) {
        //
        // If wUnicodeChar is specified in KeySubst,
        // the key should be handled as a normal key.
        // Basically this is for VK_BACK keys.
        //
        return KeyEvent->uChar.UnicodeChar == 0;
    }

    if ((KeyEvent->dwControlKeyState &
            (RIGHT_ALT_PRESSED | LEFT_ALT_PRESSED))) {
        switch (KeyEvent->wVirtualKeyCode) {
        case VK_F7:
        case VK_F10:
            return TRUE;
        default:
            break;
        }
    }
    return FALSE;
}


NTSTATUS
ProcessCommandListInput(
    IN PVOID CookedReadDataPtr,
    IN PCSR_API_MSG WaitReplyMessage,
    IN PCSR_THREAD WaitingThread,
    IN BOOLEAN WaitRoutine
    )

/*++

    This routine handles the command list popup.  It returns
    when we're out of input or the user has selected a command line.

    Return Value:

        CONSOLE_STATUS_WAIT - we ran out of input, so
            a wait block was created

        CONSOLE_STATUS_READ_COMPLETE - user hit return

--*/

{
    NTSTATUS Status;
    PCLE_POPUP Popup;
    PCOMMAND_HISTORY CommandHistory;
    PCOOKED_READ_DATA CookedReadData=(PCOOKED_READ_DATA)CookedReadDataPtr;
    WCHAR Char;
    BOOLEAN CommandLinePopupKeys = FALSE;
    PCONSOLE_READCONSOLE_MSG a;
    PHANDLE_DATA HandleData;
    SHORT Index;

    CommandHistory = CookedReadData->CommandHistory;
    Popup = CONTAINING_RECORD( CommandHistory->PopupList.Flink, CLE_POPUP, ListLink );
    Status = DereferenceIoHandleNoCheck(CookedReadData->ProcessData,
                                        CookedReadData->HandleIndex,
                                        &HandleData
                                       );
    ASSERT (NT_SUCCESS(Status));
    while (TRUE) {
        Status = GetChar(CookedReadData->InputInfo,
                         &Char,
                         TRUE,
                         CookedReadData->Console,
                         HandleData,
                         WaitReplyMessage,
                         CookedReadWaitRoutine,
                         CookedReadData,
                         sizeof(*CookedReadData),
                         WaitRoutine,
                         NULL,
                         &CommandLinePopupKeys,
                         NULL,
                         NULL
                        );
        if (!NT_SUCCESS(Status)) {
            if (Status != CONSOLE_STATUS_WAIT) {
                CookedReadData->BytesRead = 0;
            }
            return Status;
        }

        if (CommandLinePopupKeys) {
            switch (Char) {
            case VK_F9:

                //
                // prompt the user to enter the desired command number.
                // copy that command to the command line.
                //

                {
                COORD PopupSize;

                if (CookedReadData->CommandHistory &&
                    CookedReadData->ScreenInfo->ScreenBufferSize.X >= MINIMUM_COMMAND_PROMPT_SIZE+2) {  // 2 is for border
                    PopupSize.X = COMMAND_NUMBER_PROMPT_LENGTH+COMMAND_NUMBER_LENGTH;
                    PopupSize.Y = 1;
                    Status = BeginPopup(CookedReadData->ScreenInfo,
                                        CookedReadData->CommandHistory,
                                        PopupSize
                                       );
                    if (NT_SUCCESS(Status)) {
                        // CommandNumberPopup does EndPopup call
                        return CommandNumberPopup(CookedReadData,
                                                  WaitReplyMessage,
                                                  WaitingThread,
                                                  WaitRoutine
                                                 );
                    }
                }
                }
                break;
            case VK_ESCAPE:
                EndPopup(CookedReadData->ScreenInfo,CommandHistory);
                HandleData->InputReadData->ReadCount += 1;
                return CONSOLE_STATUS_WAIT_NO_BLOCK;
            case VK_UP:
                UpdateCommandListPopup(-1,
                                       &Popup->CurrentCommand,
                                       CommandHistory,
                                       Popup,
                                       CookedReadData->ScreenInfo, 0);
                break;
            case VK_DOWN:
                UpdateCommandListPopup(1,
                                       &Popup->CurrentCommand,
                                       CommandHistory,
                                       Popup,
                                       CookedReadData->ScreenInfo, 0);
                break;
            case VK_END:
                /*
                 * Move waaay forward, UpdateCommandListPopup() can handle it.
                 */
                UpdateCommandListPopup((SHORT)(CommandHistory->NumberOfCommands),
                                       &Popup->CurrentCommand,
                                       CommandHistory,
                                       Popup,
                                       CookedReadData->ScreenInfo, 0);
                break;
            case VK_HOME:
                /*
                 * Move waaay back, UpdateCommandListPopup() can handle it.
                 */
                UpdateCommandListPopup((SHORT)-(CommandHistory->NumberOfCommands),
                                       &Popup->CurrentCommand,
                                       CommandHistory,
                                       Popup,
                                       CookedReadData->ScreenInfo, 0);
                break;
            case VK_PRIOR:
                UpdateCommandListPopup((SHORT)-POPUP_SIZE_Y(Popup),
                                       &Popup->CurrentCommand,
                                       CommandHistory,
                                       Popup,
                                       CookedReadData->ScreenInfo, 0);
                break;
            case VK_NEXT:
                UpdateCommandListPopup(POPUP_SIZE_Y(Popup),
                                       &Popup->CurrentCommand,
                                       CommandHistory,
                                       Popup,
                                       CookedReadData->ScreenInfo, 0);
                break;
            case VK_LEFT:
            case VK_RIGHT:
                Index = Popup->CurrentCommand;
                EndPopup(CookedReadData->ScreenInfo,CommandHistory);
                SetCurrentCommandLine(CookedReadData,Index);
                HandleData->InputReadData->ReadCount += 1;
                return CONSOLE_STATUS_WAIT_NO_BLOCK;
            default:
                break;
            }
        } else if (Char == UNICODE_CARRIAGERETURN) {
            ULONG i,lStringLength;
            DWORD LineCount=1;
            Index = Popup->CurrentCommand;
            EndPopup(CookedReadData->ScreenInfo,CommandHistory);
            SetCurrentCommandLine(CookedReadData,Index);
            lStringLength = CookedReadData->BytesRead;
            ProcessCookedReadInput(CookedReadData,
                                   UNICODE_CARRIAGERETURN,
                                   0,
                                   &Status);
            //
            // complete read
            //

            if (CookedReadData->Echo) {

                //
                // check for alias
                //

                i = CookedReadData->BufferSize;
                if (NT_SUCCESS(MatchandCopyAlias(CookedReadData->Console,
                                                 CookedReadData->BackupLimit,
                                                 (USHORT)lStringLength,
                                                 CookedReadData->BackupLimit,
                                                 (PUSHORT)&i,
                                                 CookedReadData->ExeName,
                                                 CookedReadData->ExeNameLength,
                                                 &LineCount
                                                ))) {
                  CookedReadData->BytesRead = i;
                }
                CloseOutputHandle(CONSOLE_FROMTHREADPERPROCESSDATA(WaitingThread),
                                  CookedReadData->Console,
                                  &CookedReadData->TempHandle,
                                  NULL,
                                  FALSE
                                 );
            }
            WaitReplyMessage->ReturnValue = STATUS_SUCCESS;
            a = (PCONSOLE_READCONSOLE_MSG)&WaitReplyMessage->u.ApiMessageData;
            if (CookedReadData->BytesRead > CookedReadData->UserBufferSize || LineCount > 1) {
                if (LineCount > 1) {
                    PWSTR Tmp;
                    HandleData->InputReadData->InputHandleFlags |= HANDLE_MULTI_LINE_INPUT;
                    for (Tmp=CookedReadData->BackupLimit;*Tmp!=UNICODE_LINEFEED;Tmp++)
                        ASSERT(Tmp<(CookedReadData->BackupLimit+CookedReadData->BytesRead));
                    a->NumBytes = (ULONG)(Tmp-CookedReadData->BackupLimit+1)*sizeof(*Tmp);
                } else {
                    a->NumBytes = CookedReadData->UserBufferSize;
                }
                HandleData->InputReadData->InputHandleFlags |= HANDLE_INPUT_PENDING;
                HandleData->InputReadData->BufPtr = CookedReadData->BackupLimit;
                HandleData->InputReadData->BytesAvailable = CookedReadData->BytesRead - a->NumBytes;
                HandleData->InputReadData->CurrentBufPtr=(PWCHAR)((PBYTE)CookedReadData->BackupLimit+a->NumBytes);
                RtlCopyMemory(CookedReadData->UserBuffer,CookedReadData->BackupLimit,a->NumBytes);
            }
            else {
                a->NumBytes = CookedReadData->BytesRead;
                RtlCopyMemory(CookedReadData->UserBuffer,CookedReadData->BackupLimit,a->NumBytes);
            }
            if (!a->Unicode) {

                //
                // if ansi, translate string.
                //

                PCHAR TransBuffer;

                TransBuffer = (PCHAR)ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ), CHAR_COUNT(a->NumBytes));
                if (TransBuffer == NULL) {
                    return STATUS_NO_MEMORY;
                }

                a->NumBytes = (ULONG)ConvertToOem(CookedReadData->Console->CP,
                                            CookedReadData->UserBuffer,
                                            a->NumBytes / sizeof(WCHAR),
                                            TransBuffer,
                                            CHAR_COUNT(a->NumBytes)
                                            );
                RtlCopyMemory(CookedReadData->UserBuffer,TransBuffer,a->NumBytes);
                ConsoleHeapFree(TransBuffer);
            }

            return CONSOLE_STATUS_READ_COMPLETE;

        } else {
            Index = FindMatchingCommand(CookedReadData->CommandHistory,
                    &Char, 1 * sizeof(WCHAR),
                    Popup->CurrentCommand, FMCFL_JUST_LOOKING);
            if (Index != -1) {
                UpdateCommandListPopup(
                        (SHORT)(Index - Popup->CurrentCommand),
                        &Popup->CurrentCommand,
                        CommandHistory,
                        Popup,
                        CookedReadData->ScreenInfo, UCLP_WRAP);
            }
        }
    }
}

NTSTATUS
ProcessCopyFromCharInput(
    IN PVOID CookedReadDataPtr,
    IN PCSR_API_MSG WaitReplyMessage,
    IN PCSR_THREAD WaitingThread,
    IN BOOLEAN WaitRoutine
    )

/*++

    This routine handles the delete from cursor to char char popup.  It returns
    when we're out of input or the user has entered a char.

    Return Value:

        CONSOLE_STATUS_WAIT - we ran out of input, so
            a wait block was created

        CONSOLE_STATUS_READ_COMPLETE - user hit return

--*/

{
    NTSTATUS Status;
    PCOOKED_READ_DATA CookedReadData=(PCOOKED_READ_DATA)CookedReadDataPtr;
    WCHAR Char;
    PHANDLE_DATA HandleData;
    int i;  // char index (not byte)

    Status = DereferenceIoHandleNoCheck(CookedReadData->ProcessData,
                                        CookedReadData->HandleIndex,
                                        &HandleData
                                       );
    ASSERT (NT_SUCCESS(Status));
    while (TRUE) {
        Status = GetChar(CookedReadData->InputInfo,
                         &Char,
                         TRUE,
                         CookedReadData->Console,
                         HandleData,
                         WaitReplyMessage,
                         CookedReadWaitRoutine,
                         CookedReadData,
                         sizeof(*CookedReadData),
                         WaitRoutine,
                         NULL,
                         NULL,
                         NULL,
                         NULL
                        );
        if (!NT_SUCCESS(Status)) {
            if (Status != CONSOLE_STATUS_WAIT) {
                CookedReadData->BytesRead = 0;
            }
            return Status;
        }

        EndPopup(CookedReadData->ScreenInfo,CookedReadData->CommandHistory);

        //
        // delete from cursor up to specified char
        //

        for (i=CookedReadData->CurrentPosition+1;
             i<(int)(CookedReadData->BytesRead/sizeof(WCHAR));
             i++) {
            if (CookedReadData->BackupLimit[i] == Char) {
                break;
            }
        }
        if (i!=(int)(CookedReadData->BytesRead/sizeof(WCHAR)+1)) {
                COORD CursorPosition;

                //
                // save cursor position
                //

                CursorPosition = CookedReadData->ScreenInfo->BufferInfo.TextInfo.CursorPosition;

                //
                // deletecommandline
                //

                DeleteCommandLine(CookedReadData,
                                  FALSE);
                //
                // delete chars
                //

                RtlCopyMemory(&CookedReadData->BackupLimit[CookedReadData->CurrentPosition],
                              &CookedReadData->BackupLimit[i],
                              CookedReadData->BytesRead-(i*sizeof(WCHAR))
                              );
                CookedReadData->BytesRead -= (i-CookedReadData->CurrentPosition)*sizeof(WCHAR);

                //
                // write commandline
                //

                if (CookedReadData->Echo) {
                    Status = WriteCharsFromInput(CookedReadData->ScreenInfo,
                                        CookedReadData->BackupLimit,
                                        CookedReadData->BackupLimit,
                                        CookedReadData->BackupLimit,
                                        &CookedReadData->BytesRead,
                                        (PLONG)&CookedReadData->NumberOfVisibleChars,
                                        CookedReadData->OriginalCursorPosition.X,
                                        WC_DESTRUCTIVE_BACKSPACE |
                                                WC_KEEP_CURSOR_VISIBLE | WC_ECHO,
                                        NULL
                                        );
                    ASSERT(NT_SUCCESS(Status));
                }

                //
                // restore cursor position
                //

                Status = SetCursorPosition(CookedReadData->ScreenInfo,
                                           CursorPosition,
                                           TRUE
                                          );
                ASSERT(NT_SUCCESS(Status));
        }

        HandleData->InputReadData->ReadCount += 1;
        return CONSOLE_STATUS_WAIT_NO_BLOCK;
    }
    UNREFERENCED_PARAMETER(WaitingThread);
}

NTSTATUS
ProcessCopyToCharInput(
    IN PVOID CookedReadDataPtr,
    IN PCSR_API_MSG WaitReplyMessage,
    IN PCSR_THREAD WaitingThread,
    IN BOOLEAN WaitRoutine
    )

/*++

    This routine handles the delete char popup.  It returns
    when we're out of input or the user has entered a char.

    Return Value:

        CONSOLE_STATUS_WAIT - we ran out of input, so
            a wait block was created

        CONSOLE_STATUS_READ_COMPLETE - user hit return

--*/

{
    NTSTATUS Status;
    PCOOKED_READ_DATA CookedReadData=(PCOOKED_READ_DATA)CookedReadDataPtr;
    WCHAR Char;
    PCOMMAND LastCommand;
    DWORD NumSpaces;
    SHORT ScrollY=0;
    PHANDLE_DATA HandleData;

    Status = DereferenceIoHandleNoCheck(CookedReadData->ProcessData,
                                        CookedReadData->HandleIndex,
                                        &HandleData
                                       );
    ASSERT (NT_SUCCESS(Status));
    while (TRUE) {
        Status = GetChar(CookedReadData->InputInfo,
                         &Char,
                         TRUE,
                         CookedReadData->Console,
                         HandleData,
                         WaitReplyMessage,
                         CookedReadWaitRoutine,
                         CookedReadData,
                         sizeof(*CookedReadData),
                         WaitRoutine,
                         NULL,
                         NULL,
                         NULL,
                         NULL
                        );
        if (!NT_SUCCESS(Status)) {
            if (Status != CONSOLE_STATUS_WAIT) {
                CookedReadData->BytesRead = 0;
            }
            return Status;
        }

        EndPopup(CookedReadData->ScreenInfo,CookedReadData->CommandHistory);

        //
        // copy up to specified char
        //

        LastCommand = GetLastCommand(CookedReadData->CommandHistory);
        if (LastCommand) {
            int i,j;

            //
            // find specified char in last command
            //

            for (i=CookedReadData->CurrentPosition+1;i<(int)(LastCommand->CommandLength/sizeof(WCHAR));i++) {
                if (LastCommand->Command[i] == Char)
                    break;
            }

            //
            // if we found it, copy up to it
            //

            if (i<(int)(LastCommand->CommandLength/sizeof(WCHAR)) && (USHORT)(LastCommand->CommandLength/sizeof(WCHAR)) > (USHORT)CookedReadData->CurrentPosition) {
                j=i-CookedReadData->CurrentPosition;
                ASSERT(j>0);
                RtlCopyMemory(CookedReadData->BufPtr,
                       &LastCommand->Command[CookedReadData->CurrentPosition],
                       j*sizeof(WCHAR));
                CookedReadData->CurrentPosition += j;
                j*=sizeof(WCHAR);
                CookedReadData->BytesRead = max(CookedReadData->BytesRead,
                                                CookedReadData->CurrentPosition * sizeof(WCHAR));
                if (CookedReadData->Echo) {
                    Status = WriteCharsFromInput(CookedReadData->ScreenInfo,
                                        CookedReadData->BackupLimit,
                                        CookedReadData->BufPtr,
                                        CookedReadData->BufPtr,
                                        (PDWORD) &j,
                                        (PLONG)&NumSpaces,
                                        CookedReadData->OriginalCursorPosition.X,
                                        WC_DESTRUCTIVE_BACKSPACE |
                                                WC_KEEP_CURSOR_VISIBLE | WC_ECHO,
                                        &ScrollY
                                        );
                    ASSERT(NT_SUCCESS(Status));
                    CookedReadData->OriginalCursorPosition.Y += ScrollY;
                    CookedReadData->NumberOfVisibleChars += NumSpaces;
                }
                CookedReadData->BufPtr+=j/sizeof(WCHAR);
            }
        }
        HandleData->InputReadData->ReadCount += 1;
        return CONSOLE_STATUS_WAIT_NO_BLOCK;
    }
    UNREFERENCED_PARAMETER(WaitingThread);
}

NTSTATUS
ProcessCommandNumberInput(
    IN PVOID CookedReadDataPtr,
    IN PCSR_API_MSG WaitReplyMessage,
    IN PCSR_THREAD WaitingThread,
    IN BOOLEAN WaitRoutine
    )

/*++

    This routine handles the delete char popup.  It returns
    when we're out of input or the user has entered a char.

    Return Value:

        CONSOLE_STATUS_WAIT - we ran out of input, so
            a wait block was created

        CONSOLE_STATUS_READ_COMPLETE - user hit return

--*/

{
    NTSTATUS Status;
    PCLE_POPUP Popup;
    PCOMMAND_HISTORY CommandHistory;
    PCOOKED_READ_DATA CookedReadData=(PCOOKED_READ_DATA)CookedReadDataPtr;
    WCHAR Char;
    DWORD NumSpaces;
    BOOLEAN CommandLinePopupKeys;
    SHORT CommandNumber;
    PHANDLE_DATA HandleData;

    CommandHistory = CookedReadData->CommandHistory;
    Popup = CONTAINING_RECORD( CommandHistory->PopupList.Flink, CLE_POPUP, ListLink );
    Status = DereferenceIoHandleNoCheck(CookedReadData->ProcessData,
                                        CookedReadData->HandleIndex,
                                        &HandleData
                                       );
    ASSERT (NT_SUCCESS(Status));
    while (TRUE) {
        Status = GetChar(CookedReadData->InputInfo,
                         &Char,
                         TRUE,
                         CookedReadData->Console,
                         HandleData,
                         WaitReplyMessage,
                         CookedReadWaitRoutine,
                         CookedReadData,
                         sizeof(*CookedReadData),
                         WaitRoutine,
                         NULL,
                         &CommandLinePopupKeys,
                         NULL,
                         NULL
                        );
        if (!NT_SUCCESS(Status)) {
            if (Status != CONSOLE_STATUS_WAIT) {
                CookedReadData->BytesRead = 0;
            }
            return Status;
        }

        if (Char >= (WCHAR)0x30 && Char <= (WCHAR)0x39) {
            if (Popup->NumberRead < 5) {
                DWORD CharsToWrite;
                WORD RealAttributes;

                RealAttributes = CookedReadData->ScreenInfo->Attributes;
                CookedReadData->ScreenInfo->Attributes = Popup->Attributes;
                CharsToWrite = sizeof(WCHAR);
                Status = WriteCharsFromInput(CookedReadData->ScreenInfo,
                                    Popup->NumberBuffer,
                                    &Popup->NumberBuffer[Popup->NumberRead],
                                    &Char,
                                    &CharsToWrite,
                                    (PLONG)&NumSpaces,
                                    CookedReadData->OriginalCursorPosition.X,
                                    WC_DESTRUCTIVE_BACKSPACE |
                                            WC_KEEP_CURSOR_VISIBLE | WC_ECHO,
                                    NULL
                                    );
                ASSERT(NT_SUCCESS(Status));
                CookedReadData->ScreenInfo->Attributes = RealAttributes;
                Popup->NumberBuffer[Popup->NumberRead] = Char;
                Popup->NumberRead += 1;
            }
        } else if (Char == UNICODE_BACKSPACE) {
            if (Popup->NumberRead > 0) {
                DWORD CharsToWrite;
                WORD RealAttributes;

                RealAttributes = CookedReadData->ScreenInfo->Attributes;
                CookedReadData->ScreenInfo->Attributes = Popup->Attributes;
                CharsToWrite = sizeof(WCHAR);
                Status = WriteCharsFromInput(CookedReadData->ScreenInfo,
                                    Popup->NumberBuffer,
                                    &Popup->NumberBuffer[Popup->NumberRead],
                                    &Char,
                                    &CharsToWrite,
                                    (PLONG)&NumSpaces,
                                    CookedReadData->OriginalCursorPosition.X,
                                    WC_DESTRUCTIVE_BACKSPACE |
                                            WC_KEEP_CURSOR_VISIBLE | WC_ECHO,
                                    NULL
                                    );
                ASSERT(NT_SUCCESS(Status));
                CookedReadData->ScreenInfo->Attributes = RealAttributes;
                Popup->NumberBuffer[Popup->NumberRead] = (WCHAR)' ';
                Popup->NumberRead -= 1;
            }
        } else if (Char == (WCHAR)VK_ESCAPE) {
            EndPopup(CookedReadData->ScreenInfo,CookedReadData->CommandHistory);
            if (!CLE_NO_POPUPS(CommandHistory)) {
                EndPopup(CookedReadData->ScreenInfo,CookedReadData->CommandHistory);
            }
            DeleteCommandLine(CookedReadData,
                              TRUE);
        } else if (Char == UNICODE_CARRIAGERETURN) {
            CHAR NumberBuffer[6];
            int i;

            for (i=0;i<Popup->NumberRead;i++) {
                NumberBuffer[i] = (CHAR)Popup->NumberBuffer[i];
            }
            NumberBuffer[i] = 0;
            CommandNumber = (SHORT)atoi(NumberBuffer);
            if ((WORD)CommandNumber >= (WORD)CookedReadData->CommandHistory->NumberOfCommands) {
                CommandNumber = (SHORT)(CookedReadData->CommandHistory->NumberOfCommands-1);
            }
            EndPopup(CookedReadData->ScreenInfo,CookedReadData->CommandHistory);
            if (!CLE_NO_POPUPS(CommandHistory)) {
                EndPopup(CookedReadData->ScreenInfo,CookedReadData->CommandHistory);
            }
            SetCurrentCommandLine(CookedReadData,COMMAND_NUM_TO_INDEX(CommandNumber,CookedReadData->CommandHistory));
        }
        HandleData->InputReadData->ReadCount += 1;
        return CONSOLE_STATUS_WAIT_NO_BLOCK;
    }
    UNREFERENCED_PARAMETER(WaitingThread);
}

NTSTATUS
CommandListPopup(
    IN PCOOKED_READ_DATA CookedReadData,
    IN PCSR_API_MSG WaitReplyMessage,
    IN PCSR_THREAD WaitingThread,
    IN BOOLEAN WaitRoutine
    )

/*++

    This routine handles the command list popup.  It puts up the
    popup, then calls ProcessCommandListInput to get and process
    input.

    Return Value:

        CONSOLE_STATUS_WAIT - we ran out of input, so
            a wait block was created

        STATUS_SUCCESS - read was fully completed (user hit return)

--*/

{
    SHORT CurrentCommand;
    PCLE_POPUP Popup;
    PCOMMAND_HISTORY CommandHistory;

    CommandHistory = CookedReadData->CommandHistory;
    Popup = CONTAINING_RECORD( CommandHistory->PopupList.Flink, CLE_POPUP, ListLink );

    CurrentCommand = COMMAND_INDEX_TO_NUM(CommandHistory->LastDisplayed,CommandHistory);

    if (CurrentCommand < (SHORT)(CommandHistory->NumberOfCommands - POPUP_SIZE_Y(Popup))) {
        Popup->BottomIndex = (SHORT)(max(CurrentCommand,POPUP_SIZE_Y(Popup)-1));
    } else {
        Popup->BottomIndex = (SHORT)(CommandHistory->NumberOfCommands-1);
    }
    Popup->CurrentCommand = CommandHistory->LastDisplayed;
    DrawCommandListPopup(Popup,
                         CommandHistory->LastDisplayed,
                         CommandHistory,
                         CookedReadData->ScreenInfo);
    Popup->PopupInputRoutine = (PCLE_POPUP_INPUT_ROUTINE) ProcessCommandListInput;
    return ProcessCommandListInput(CookedReadData,
                                   WaitReplyMessage,
                                   WaitingThread,
                                   WaitRoutine
                                  );
}

VOID
DrawPromptPopup(
    IN PCLE_POPUP Popup,
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PWCHAR Prompt,
    IN ULONG PromptLength   // in chars
    )
{
    ULONG lStringLength;
    COORD WriteCoord;
    SHORT i;

    //
    // draw empty popup
    //

    WriteCoord.X = (SHORT)(Popup->Region.Left+1);
    WriteCoord.Y = (SHORT)(Popup->Region.Top+1);
    lStringLength = POPUP_SIZE_X(Popup);
    for (i=0;i<POPUP_SIZE_Y(Popup);i++) {
        FillOutput(ScreenInfo,
                   Popup->Attributes,
                   WriteCoord,
                   CONSOLE_ATTRIBUTE,
                   &lStringLength
                  );
        FillOutput(ScreenInfo,
                   (WCHAR)' ',
                   WriteCoord,
                   CONSOLE_FALSE_UNICODE, // faster that real unicode
                   &lStringLength
                  );
        WriteCoord.Y += 1;
    }

    WriteCoord.X = (SHORT)(Popup->Region.Left+1);
    WriteCoord.Y = (SHORT)(Popup->Region.Top+1);

    //
    // write prompt to screen
    //

    lStringLength = PromptLength;
    if (lStringLength > (ULONG)POPUP_SIZE_X(Popup))
    lStringLength = (ULONG)(POPUP_SIZE_X(Popup));
    WriteOutputString(ScreenInfo,
                      Prompt,
                      WriteCoord,
                      CONSOLE_REAL_UNICODE,
                      &lStringLength,
                      NULL
                     );
}

NTSTATUS
CopyFromCharPopup(
    IN PCOOKED_READ_DATA CookedReadData,
    IN PCSR_API_MSG WaitReplyMessage,
    IN PCSR_THREAD WaitingThread,
    IN BOOLEAN WaitRoutine
    )

/*++

    This routine handles the "delete up to this char" popup.  It puts up the
    popup, then calls ProcessCopyFromCharInput to get and process
    input.

    Return Value:

        CONSOLE_STATUS_WAIT - we ran out of input, so
            a wait block was created

        STATUS_SUCCESS - read was fully completed (user hit return)

--*/

{
    PCLE_POPUP Popup;
    PCOMMAND_HISTORY CommandHistory;
    WCHAR ItemString[70];
    int ItemLength;
    NTSTATUS Status;
    LANGID   LangId;

    Status = GetConsoleLangId(CookedReadData->ScreenInfo->Console->OutputCP, &LangId);
    if (NT_SUCCESS(Status)) {
        ItemLength = LoadStringEx(ghInstance,msgCmdLineF4,ItemString,70,LangId);
    }
    if (!NT_SUCCESS(Status) || ItemLength == 0) {
        ItemLength = LoadString(ghInstance,msgCmdLineF4,ItemString,70);
    }

    CommandHistory = CookedReadData->CommandHistory;
    Popup = CONTAINING_RECORD( CommandHistory->PopupList.Flink, CLE_POPUP, ListLink );

    DrawPromptPopup(Popup,
                    CookedReadData->ScreenInfo,
                    ItemString,
                    ItemLength
                   );
    Popup->PopupInputRoutine = (PCLE_POPUP_INPUT_ROUTINE) ProcessCopyFromCharInput;
    return ProcessCopyFromCharInput(CookedReadData,
                                  WaitReplyMessage,
                                  WaitingThread,
                                  WaitRoutine
                                 );
}


NTSTATUS
CopyToCharPopup(
    IN PCOOKED_READ_DATA CookedReadData,
    IN PCSR_API_MSG WaitReplyMessage,
    IN PCSR_THREAD WaitingThread,
    IN BOOLEAN WaitRoutine
    )

/*++

    This routine handles the "delete up to this char" popup.  It puts up the
    popup, then calls ProcessCopyToCharInput to get and process
    input.

    Return Value:

        CONSOLE_STATUS_WAIT - we ran out of input, so
            a wait block was created

        STATUS_SUCCESS - read was fully completed (user hit return)

--*/

{
    PCLE_POPUP Popup;
    PCOMMAND_HISTORY CommandHistory;
    WCHAR ItemString[70];
    int ItemLength;
    NTSTATUS Status;
    LANGID   LangId;

    Status = GetConsoleLangId(CookedReadData->ScreenInfo->Console->OutputCP, &LangId);
    if (NT_SUCCESS(Status)) {
        ItemLength = LoadStringEx(ghInstance,msgCmdLineF2,ItemString,70,LangId);
    }
    if (!NT_SUCCESS(Status) || ItemLength == 0) {
        ItemLength = LoadString(ghInstance,msgCmdLineF2,ItemString,70);
    }

    CommandHistory = CookedReadData->CommandHistory;
    Popup = CONTAINING_RECORD( CommandHistory->PopupList.Flink, CLE_POPUP, ListLink );
    DrawPromptPopup(Popup,
                    CookedReadData->ScreenInfo,
                    ItemString,
                    ItemLength
                   );
    Popup->PopupInputRoutine = (PCLE_POPUP_INPUT_ROUTINE) ProcessCopyToCharInput;
    return ProcessCopyToCharInput(CookedReadData,
                                  WaitReplyMessage,
                                  WaitingThread,
                                  WaitRoutine
                                 );
}

NTSTATUS
CommandNumberPopup(
    IN PCOOKED_READ_DATA CookedReadData,
    IN PCSR_API_MSG WaitReplyMessage,
    IN PCSR_THREAD WaitingThread,
    IN BOOLEAN WaitRoutine
    )

/*++

    This routine handles the "enter command number" popup.  It puts up the
    popup, then calls ProcessCommandNumberInput to get and process
    input.

    Return Value:

        CONSOLE_STATUS_WAIT - we ran out of input, so
            a wait block was created

        STATUS_SUCCESS - read was fully completed (user hit return)

--*/

{
    PCLE_POPUP Popup;
    PCOMMAND_HISTORY CommandHistory;
    COORD CursorPosition;
    WCHAR ItemString[70];
    int ItemLength;
    NTSTATUS Status;
    LANGID   LangId;

    CommandHistory = CookedReadData->CommandHistory;
    Popup = CONTAINING_RECORD( CommandHistory->PopupList.Flink, CLE_POPUP, ListLink );

    Status = GetConsoleLangId(CookedReadData->ScreenInfo->Console->OutputCP, &LangId);
    if (NT_SUCCESS(Status)) {
        ItemLength = LoadStringEx(ghInstance,msgCmdLineF9,ItemString,70,LangId);
    }
    if (!NT_SUCCESS(Status) || ItemLength == 0) {
        ItemLength = LoadString(ghInstance,msgCmdLineF9,ItemString,70);
    }

    if (ItemLength > POPUP_SIZE_X(Popup) - COMMAND_NUMBER_LENGTH) {
        ItemLength = POPUP_SIZE_X(Popup) - COMMAND_NUMBER_LENGTH;
    }
    DrawPromptPopup(Popup,
                    CookedReadData->ScreenInfo,
                    ItemString,
                    ItemLength
                   );
    CursorPosition.X = (SHORT)(Popup->Region.Right - MINIMUM_COMMAND_PROMPT_SIZE);
    CursorPosition.Y = (SHORT)(Popup->Region.Top+1);
    SetCursorPosition(CookedReadData->ScreenInfo,
                      CursorPosition,
                      TRUE
                     );
    Popup->NumberRead=0;
    Popup->PopupInputRoutine = (PCLE_POPUP_INPUT_ROUTINE) ProcessCommandNumberInput;
    return ProcessCommandNumberInput(CookedReadData,
                                     WaitReplyMessage,
                                     WaitingThread,
                                     WaitRoutine
                                    );
}


PCOMMAND
GetLastCommand(
    IN PCOMMAND_HISTORY CommandHistory
    )
{
    if (CommandHistory->NumberOfCommands == 0)
        return NULL;
    return CommandHistory->Commands[CommandHistory->LastDisplayed];
}

VOID
EmptyCommandHistory(
    IN PCOMMAND_HISTORY CommandHistory
    )
{
    SHORT i;
    if (CommandHistory==NULL)
        return;
    for (i=0;i<CommandHistory->NumberOfCommands;i++) {
        ConsoleHeapFree(CommandHistory->Commands[i]);
    }
    CommandHistory->NumberOfCommands = 0;
    CommandHistory->LastAdded = -1;
    CommandHistory->LastDisplayed = -1;
    CommandHistory->FirstCommand = 0;
    CommandHistory->Flags = CLE_RESET;
}

BOOL
AtFirstCommand(
    IN PCOMMAND_HISTORY CommandHistory
    )
{
    SHORT i;

    if (CommandHistory==NULL)
        return FALSE;
    if (CommandHistory->Flags & CLE_RESET)
        return FALSE;
    i = (SHORT)(CommandHistory->LastDisplayed - 1);
    if (i==-1)
        i=(SHORT)(CommandHistory->NumberOfCommands-1);
    return (i == CommandHistory->LastAdded);
}

BOOL
AtLastCommand(
    IN PCOMMAND_HISTORY CommandHistory
    )
{
    if (CommandHistory==NULL)
        return FALSE;
    return (CommandHistory->LastDisplayed == CommandHistory->LastAdded);
}

NTSTATUS
ProcessCommandLine(
    IN
    PCOOKED_READ_DATA CookedReadData,
    IN WCHAR Char,
    IN DWORD KeyState,
    IN PCSR_API_MSG WaitReplyMessage,
    IN PCSR_THREAD WaitingThread,
    IN BOOLEAN WaitRoutine
    )

/*++

    This routine process command line editing keys.

    Return Value:

    CONSOLE_STATUS_WAIT - CommandListPopup ran out of input
    CONSOLE_STATUS_READ_COMPLETE - user hit <enter> in CommandListPopup
    STATUS_SUCCESS - everything's cool

--*/

{
    COORD CurrentPosition;
    DWORD CharsToWrite;
    NTSTATUS Status;
    BOOL UpdateCursorPosition;
    SHORT ScrollY=0;
    BOOL fStartFromDelim;

    UpdateCursorPosition = FALSE;
    if (Char == VK_F7 &&
        !(KeyState & (RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED | RIGHT_ALT_PRESSED | LEFT_ALT_PRESSED))) {
        COORD PopupSize;

        if (CookedReadData->CommandHistory &&
            CookedReadData->CommandHistory->NumberOfCommands) {
            PopupSize.X = 40;
            PopupSize.Y = 10;
            Status = BeginPopup(CookedReadData->ScreenInfo,
                       CookedReadData->CommandHistory,
                       PopupSize
                      );
            if (NT_SUCCESS(Status)) {
                // CommandListPopup does EndPopup call
                return CommandListPopup(CookedReadData,
                                        WaitReplyMessage,
                                        WaitingThread,
                                        WaitRoutine
                                       );
            }
        }
    } else {
        switch (Char) {
            case VK_ESCAPE:
                DeleteCommandLine(CookedReadData,
                                  TRUE);
                break;
            case VK_UP:
            case VK_DOWN:
            case VK_F5:
                if (Char == VK_F5)
                    Char = VK_UP;
                // for doskey compatibility, buffer isn't circular
                if (Char==VK_UP && !AtFirstCommand(CookedReadData->CommandHistory) ||
                    Char==VK_DOWN && !AtLastCommand(CookedReadData->CommandHistory)) {
                    DeleteCommandLine(CookedReadData,
                                      TRUE);
                    Status = RetrieveCommand(CookedReadData->CommandHistory,
                                             Char,
                                             CookedReadData->BackupLimit,
                                             CookedReadData->BufferSize,
                                             &CookedReadData->BytesRead);
                    ASSERT(CookedReadData->BackupLimit == CookedReadData->BufPtr);
                    if (CookedReadData->Echo) {
                        Status = WriteCharsFromInput(CookedReadData->ScreenInfo,
                                CookedReadData->BackupLimit,
                                CookedReadData->BufPtr,
                                CookedReadData->BufPtr,
                                &CookedReadData->BytesRead,
                                (PLONG)&CookedReadData->NumberOfVisibleChars,
                                CookedReadData->OriginalCursorPosition.X,
                                WC_DESTRUCTIVE_BACKSPACE |
                                        WC_KEEP_CURSOR_VISIBLE | WC_ECHO,
                                &ScrollY );
                        ASSERT(NT_SUCCESS(Status));
                        CookedReadData->OriginalCursorPosition.Y += ScrollY;
                    }
                    CharsToWrite = CookedReadData->BytesRead/sizeof(WCHAR);
                    CookedReadData->CurrentPosition = CharsToWrite;
                    CookedReadData->BufPtr = CookedReadData->BackupLimit + CharsToWrite;
                }
                break;
            case VK_PRIOR:
            case VK_NEXT:
                if (CookedReadData->CommandHistory &&
                    CookedReadData->CommandHistory->NumberOfCommands) {

                //
                // display oldest or newest command
                //

                SHORT CommandNumber;
                if (Char == VK_PRIOR) {
                    CommandNumber = 0;
                } else {
                    CommandNumber = (SHORT)(CookedReadData->CommandHistory->NumberOfCommands-1);
                }
                DeleteCommandLine(CookedReadData,
                                  TRUE);
                Status = RetrieveNthCommand(CookedReadData->CommandHistory,
                                            COMMAND_NUM_TO_INDEX(CommandNumber,CookedReadData->CommandHistory),
                                            CookedReadData->BackupLimit,
                                            CookedReadData->BufferSize,
                                            &CookedReadData->BytesRead);
                ASSERT(CookedReadData->BackupLimit == CookedReadData->BufPtr);
                if (CookedReadData->Echo) {
                    Status = WriteCharsFromInput(CookedReadData->ScreenInfo,
                                        CookedReadData->BackupLimit,
                                        CookedReadData->BufPtr,
                                        CookedReadData->BufPtr,
                                        &CookedReadData->BytesRead,
                                        (PLONG)&CookedReadData->NumberOfVisibleChars,
                                        CookedReadData->OriginalCursorPosition.X,
                                        WC_DESTRUCTIVE_BACKSPACE |
                                                WC_KEEP_CURSOR_VISIBLE | WC_ECHO,
                                        &ScrollY
                                        );
                    ASSERT(NT_SUCCESS(Status));
                    CookedReadData->OriginalCursorPosition.Y += ScrollY;
                }
                CharsToWrite = CookedReadData->BytesRead/sizeof(WCHAR);
                CookedReadData->CurrentPosition = CharsToWrite;
                CookedReadData->BufPtr = CookedReadData->BackupLimit + CharsToWrite;
                }
                break;
            case VK_END:
                if (KeyState & (RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED)) {
                    DeleteCommandLine(CookedReadData,
                                      FALSE);
                    CookedReadData->BytesRead = CookedReadData->CurrentPosition*sizeof(WCHAR);
                    if (CookedReadData->Echo) {
                        Status = WriteCharsFromInput(CookedReadData->ScreenInfo,
                                            CookedReadData->BackupLimit,
                                            CookedReadData->BackupLimit,
                                            CookedReadData->BackupLimit,
                                            &CookedReadData->BytesRead,
                                            (PLONG)&CookedReadData->NumberOfVisibleChars,
                                            CookedReadData->OriginalCursorPosition.X,
                                            WC_DESTRUCTIVE_BACKSPACE |
                                                WC_KEEP_CURSOR_VISIBLE | WC_ECHO,
                                            NULL
                                            );
                        ASSERT(NT_SUCCESS(Status));
                    }
                } else {
                    CookedReadData->CurrentPosition = CookedReadData->BytesRead/sizeof(WCHAR);
                    CookedReadData->BufPtr = CookedReadData->BackupLimit + CookedReadData->CurrentPosition;
                    CurrentPosition.X = (SHORT)(CookedReadData->OriginalCursorPosition.X + CookedReadData->NumberOfVisibleChars);
                    CurrentPosition.Y = CookedReadData->OriginalCursorPosition.Y;
#if defined(FE_SB)
                    if (CheckBisectProcessW(CookedReadData->ScreenInfo,
                                            CookedReadData->ScreenInfo->Console->CP,
                                            CookedReadData->BackupLimit,
                                            CookedReadData->CurrentPosition,
                                            CookedReadData->ScreenInfo->ScreenBufferSize.X-CookedReadData->OriginalCursorPosition.X,
                                            CookedReadData->OriginalCursorPosition.X,
                                            TRUE)) {
                        CurrentPosition.X++;
                    }
#endif
                    UpdateCursorPosition = TRUE;
                }
                break;
            case VK_HOME:
                if (KeyState & (RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED)) {
                    DeleteCommandLine(CookedReadData,
                                      FALSE);
                    CookedReadData->BytesRead -= CookedReadData->CurrentPosition*sizeof(WCHAR);
                    CookedReadData->CurrentPosition = 0;
                    RtlCopyMemory(CookedReadData->BackupLimit,
                           CookedReadData->BufPtr,
                           CookedReadData->BytesRead
                           );
                    CookedReadData->BufPtr = CookedReadData->BackupLimit;
                    if (CookedReadData->Echo) {
                        Status = WriteCharsFromInput(CookedReadData->ScreenInfo,
                                            CookedReadData->BackupLimit,
                                            CookedReadData->BackupLimit,
                                            CookedReadData->BackupLimit,
                                            &CookedReadData->BytesRead,
                                            (PLONG)&CookedReadData->NumberOfVisibleChars,
                                            CookedReadData->OriginalCursorPosition.X,
                                            WC_DESTRUCTIVE_BACKSPACE |
                                                WC_KEEP_CURSOR_VISIBLE | WC_ECHO,
                                            NULL
                                            );
                        ASSERT(NT_SUCCESS(Status));
                    }
                    CurrentPosition = CookedReadData->OriginalCursorPosition;
                    UpdateCursorPosition = TRUE;
                } else {
                    CookedReadData->CurrentPosition = 0;
                    CookedReadData->BufPtr = CookedReadData->BackupLimit;
                    CurrentPosition = CookedReadData->OriginalCursorPosition;
                    UpdateCursorPosition = TRUE;
                }
                break;
            case VK_LEFT:
                if (KeyState & (RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED)) {
                    PWCHAR LastWord;
                    BOOL NonSpaceCharSeen=FALSE;
                    if (CookedReadData->BufPtr != CookedReadData->BackupLimit) {
                        if (!gExtendedEditKey) {
                            LastWord = CookedReadData->BufPtr-1;
                            while (LastWord != CookedReadData->BackupLimit) {
                                if (!IS_WORD_DELIM(*LastWord))
                                    NonSpaceCharSeen=TRUE;
                                else
                                    if (NonSpaceCharSeen)
                                        break;
                                LastWord--;
                            }
                            if (LastWord != CookedReadData->BackupLimit) {
                                CookedReadData->BufPtr = LastWord+1;
                            } else {
                                CookedReadData->BufPtr = LastWord;
                            }
                        } else {
                            /*
                             * A bit better word skipping.
                             */
                            LastWord = CookedReadData->BufPtr - 1;
                            if (LastWord != CookedReadData->BackupLimit) {
                                if (*LastWord == L' ') {
                                    /*
                                     * Skip spaces, until the non-space character is found.
                                     */
                                    while (--LastWord != CookedReadData->BackupLimit) {
                                        UserAssert(LastWord > CookedReadData->BackupLimit);
                                        if (*LastWord != L' ') {
                                            break;
                                        }
                                    }
                                }
                                if (LastWord != CookedReadData->BackupLimit) {
                                    if (IS_WORD_DELIM(*LastWord)) {
                                        /*
                                         * Skip WORD_DELIMs until space or non WORD_DELIM is found.
                                         */
                                        while (--LastWord != CookedReadData->BackupLimit) {
                                            UserAssert(LastWord > CookedReadData->BackupLimit);
                                            if (*LastWord == L' ' || !IS_WORD_DELIM(*LastWord)) {
                                                break;
                                            }
                                        }
                                    } else {
                                        /*
                                         * Skip the regular words
                                         */
                                        while (--LastWord != CookedReadData->BackupLimit) {
                                            UserAssert(LastWord > CookedReadData->BackupLimit);
                                            if (IS_WORD_DELIM(*LastWord)) {
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                            UserAssert(LastWord >= CookedReadData->BackupLimit);
                            if (LastWord != CookedReadData->BackupLimit) {
                                /*
                                 * LastWord is currently pointing to the last character
                                 * of the previous word, unless it backed up to the beginning
                                 * of the buffer.
                                 * Let's increment LastWord so that it points to the expeced
                                 * insertion point.
                                 */
                                ++LastWord;
                            }
                            CookedReadData->BufPtr = LastWord;
                        }
                        CookedReadData->CurrentPosition=(ULONG)(CookedReadData->BufPtr-CookedReadData->BackupLimit);
                        CurrentPosition = CookedReadData->OriginalCursorPosition;
                        // FE_SB
                        CurrentPosition.X = (SHORT)(CurrentPosition.X +
                            RetrieveTotalNumberOfSpaces(CookedReadData->OriginalCursorPosition.X,
                                                        CookedReadData->BackupLimit,
                                                        CookedReadData->CurrentPosition,
                                                        CookedReadData->ScreenInfo->Console));
                        if (CheckBisectStringW(CookedReadData->ScreenInfo,
                                               CookedReadData->ScreenInfo->Console->CP,
                                               CookedReadData->BackupLimit,
                                               CookedReadData->CurrentPosition+1,
                                               CookedReadData->ScreenInfo->ScreenBufferSize.X
                                                -CookedReadData->OriginalCursorPosition.X
                                               )) {
                            CurrentPosition.X++;
                        }
                        // end FE_SB
                        UpdateCursorPosition = TRUE;
                    }
                } else {
                    if (CookedReadData->BufPtr != CookedReadData->BackupLimit) {
                        CookedReadData->BufPtr--;
                        CookedReadData->CurrentPosition--;
                        CurrentPosition.X = CookedReadData->ScreenInfo->BufferInfo.TextInfo.CursorPosition.X;
                        CurrentPosition.Y = CookedReadData->ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y;
#if defined(FE_SB)
                        CurrentPosition.X = (SHORT)(CurrentPosition.X -
                            RetrieveNumberOfSpaces(CookedReadData->OriginalCursorPosition.X,
                                                   CookedReadData->BackupLimit,
                                                   CookedReadData->CurrentPosition,
                                                   CookedReadData->ScreenInfo->Console,
                                                   CookedReadData->ScreenInfo->Console->CP));
                        if (CheckBisectProcessW(CookedReadData->ScreenInfo,
                                                CookedReadData->ScreenInfo->Console->CP,
                                                CookedReadData->BackupLimit,
                                                CookedReadData->CurrentPosition+2,
                                                CookedReadData->ScreenInfo->ScreenBufferSize.X
                                                 -CookedReadData->OriginalCursorPosition.X,
                                                CookedReadData->OriginalCursorPosition.X,
                                                TRUE)) {
                            if ((CurrentPosition.X == -2) ||
                                (CurrentPosition.X == -1)) {
                                CurrentPosition.X--;
                            }
                        }
#else
                        CurrentPosition.X = (SHORT)(CurrentPosition.X - RetrieveNumberOfSpaces(CookedReadData->OriginalCursorPosition.X,
                                                                    CookedReadData->BackupLimit,
                                                                    CookedReadData->CurrentPosition));
#endif
                        UpdateCursorPosition = TRUE;
                    }
                }
                break;
            case VK_RIGHT:
            case VK_F1:

                //
                // we don't need to check for end of buffer here because we've
                // already done it.
                //

                if (KeyState & (RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED)) {
                    if (Char != VK_F1) {
                        if (CookedReadData->CurrentPosition < (CookedReadData->BytesRead/sizeof(WCHAR))) {
                            PWCHAR NextWord = CookedReadData->BufPtr;

                            if (!gExtendedEditKey) {
                                SHORT i;

                                for (i=(SHORT)(CookedReadData->CurrentPosition);
                                     i<(SHORT)((CookedReadData->BytesRead-1)/sizeof(WCHAR));
                                     i++) {
                                    if (IS_WORD_DELIM(*NextWord)) {
                                        i++;
                                        NextWord++;
                                        while ((i<(SHORT)((CookedReadData->BytesRead-1)/sizeof(WCHAR))) &&
                                               IS_WORD_DELIM(*NextWord)) {
                                            i++;
                                            NextWord++;
                                        }
                                        break;
                                    }
                                    NextWord++;
                                }
                            } else {
                                /*
                                 * A bit better word skipping.
                                 */
                                PWCHAR BufLast = CookedReadData->BackupLimit + CookedReadData->BytesRead / sizeof(WCHAR);

                                UserAssert(NextWord < BufLast);
                                if (*NextWord == L' ') {
                                    /*
                                     * If the current character is space,
                                     * skip to the next non-space character.
                                     */
                                    while (NextWord < BufLast) {
                                        if (*NextWord != L' ') {
                                            break;
                                        }
                                        ++NextWord;
                                    }
                                } else {
                                    /*
                                     * Skip the body part.
                                     */
                                    BOOL fStartFromDelim = IS_WORD_DELIM(*NextWord);

                                    while (++NextWord < BufLast) {
                                        if (fStartFromDelim != IS_WORD_DELIM(*NextWord)) {
                                            break;
                                        }
                                    }
                                    /*
                                     * Skip the space block.
                                     */
                                    if (NextWord < BufLast && *NextWord == L' ') {
                                        while (++NextWord < BufLast) {
                                            if (*NextWord != L' ') {
                                                break;
                                            }
                                        }
                                    }
                                }
                            }

                            CookedReadData->BufPtr = NextWord;
                            CookedReadData->CurrentPosition=(ULONG)(CookedReadData->BufPtr-CookedReadData->BackupLimit);
                            // FE_SB
                            CurrentPosition = CookedReadData->OriginalCursorPosition;
                            CurrentPosition.X = (SHORT)(CurrentPosition.X +
                                RetrieveTotalNumberOfSpaces(CookedReadData->OriginalCursorPosition.X,
                                                            CookedReadData->BackupLimit,
                                                            CookedReadData->CurrentPosition,
                                                            CookedReadData->ScreenInfo->Console));
                            if (CheckBisectStringW(CookedReadData->ScreenInfo,
                                                   CookedReadData->ScreenInfo->Console->CP,
                                                   CookedReadData->BackupLimit,
                                                   CookedReadData->CurrentPosition+1,
                                                   CookedReadData->ScreenInfo->ScreenBufferSize.X
                                                    -CookedReadData->OriginalCursorPosition.X
                                                   )) {
                                CurrentPosition.X++;
                            }
                            // end FE_SB
                            UpdateCursorPosition = TRUE;
                        }
                    }
                } else {

                    //
                    // if not at the end of the line, move cursor position right
                    //

                    if (CookedReadData->CurrentPosition < (CookedReadData->BytesRead/sizeof(WCHAR))) {
                        CurrentPosition = CookedReadData->ScreenInfo->BufferInfo.TextInfo.CursorPosition;
#if defined(FE_SB)
                        CurrentPosition.X = (SHORT)(CurrentPosition.X +
                            RetrieveNumberOfSpaces(CookedReadData->OriginalCursorPosition.X,
                                                   CookedReadData->BackupLimit,
                                                   CookedReadData->CurrentPosition,
                                                   CookedReadData->ScreenInfo->Console,
                                                   CookedReadData->ScreenInfo->Console->CP));
                        if (CheckBisectProcessW(CookedReadData->ScreenInfo,
                                                CookedReadData->ScreenInfo->Console->CP,
                                                CookedReadData->BackupLimit,
                                                CookedReadData->CurrentPosition+2,
                                                CookedReadData->ScreenInfo->ScreenBufferSize.X
                                                 -CookedReadData->OriginalCursorPosition.X,
                                                CookedReadData->OriginalCursorPosition.X,
                                                TRUE)) {
                            if (CurrentPosition.X == (CookedReadData->ScreenInfo->ScreenBufferSize.X-1))
                                CurrentPosition.X++;
                        }
#else
                        CurrentPosition.X = (SHORT)(CurrentPosition.X + RetrieveNumberOfSpaces(CookedReadData->OriginalCursorPosition.X,
                                                                    CookedReadData->BackupLimit,
                                                                    CookedReadData->CurrentPosition));
#endif
                        CookedReadData->BufPtr++;
                        CookedReadData->CurrentPosition++;
                        UpdateCursorPosition = TRUE;

                    //
                    // if at the end of the line, copy a character from the
                    // same position in the last command
                    //

                    } else if (CookedReadData->CommandHistory) {
                        PCOMMAND LastCommand;
                        DWORD NumSpaces;
                        LastCommand = GetLastCommand(CookedReadData->CommandHistory);
                        if (LastCommand && (USHORT)(LastCommand->CommandLength/sizeof(WCHAR)) > (USHORT)CookedReadData->CurrentPosition) {
                            *CookedReadData->BufPtr = LastCommand->Command[CookedReadData->CurrentPosition];
                            CookedReadData->BytesRead += sizeof(WCHAR);
                            CookedReadData->CurrentPosition++;
                            if (CookedReadData->Echo) {
                                CharsToWrite = sizeof(WCHAR);
                                Status = WriteCharsFromInput(
                                        CookedReadData->ScreenInfo,
                                        CookedReadData->BackupLimit,
                                        CookedReadData->BufPtr,
                                        CookedReadData->BufPtr,
                                        &CharsToWrite,
                                        (PLONG)&NumSpaces,
                                        CookedReadData->OriginalCursorPosition.X,
                                        WC_DESTRUCTIVE_BACKSPACE |
                                                WC_KEEP_CURSOR_VISIBLE | WC_ECHO,
                                        &ScrollY);
                                ASSERT(NT_SUCCESS(Status));
                                CookedReadData->OriginalCursorPosition.Y += ScrollY;
                                CookedReadData->NumberOfVisibleChars += NumSpaces;
                            }
                            CookedReadData->BufPtr+=1;
                        }
                    }
                }
                break;
            case VK_F2:

                //
                // copy the previous command to the current command, up to but
                // not including the character specified by the user.  the user
                // is prompted via popup to enter a character.
                //

                if (CookedReadData->CommandHistory) {
                    COORD PopupSize;

                    PopupSize.X = COPY_TO_CHAR_PROMPT_LENGTH+2;
                    PopupSize.Y = 1;
                    Status = BeginPopup(CookedReadData->ScreenInfo,
                               CookedReadData->CommandHistory,
                               PopupSize
                              );
                    if (NT_SUCCESS(Status)) {
                        // CopyToCharPopup does EndPopup call
                        return CopyToCharPopup(CookedReadData,
                                               WaitReplyMessage,
                                               WaitingThread,
                                               WaitRoutine
                                              );
                    }
                }
                break;
            case VK_F3:

                //
                // copy the remainder of the previous command to the current command.
                //

                if (CookedReadData->CommandHistory) {
                    PCOMMAND LastCommand;
                    DWORD NumSpaces;
                    int j;  // chars, not bytes
                    LastCommand = GetLastCommand(CookedReadData->CommandHistory);
                    if (LastCommand && (USHORT)(LastCommand->CommandLength/sizeof(WCHAR)) > (USHORT)CookedReadData->CurrentPosition) {
                        j = (LastCommand->CommandLength/sizeof(WCHAR)) - CookedReadData->CurrentPosition;
                        RtlCopyMemory(CookedReadData->BufPtr,
                                &LastCommand->Command[CookedReadData->CurrentPosition],
                                j*sizeof(WCHAR)
                               );
                        CookedReadData->CurrentPosition += j;
                        j *= sizeof(WCHAR);
                        CookedReadData->BytesRead += j;
                        if (CookedReadData->Echo) {
                            Status = WriteCharsFromInput(CookedReadData->ScreenInfo,
                                    CookedReadData->BackupLimit,
                                    CookedReadData->BufPtr,
                                    CookedReadData->BufPtr,
                                    (PDWORD) &j,
                                    (PLONG)&NumSpaces,
                                    CookedReadData->OriginalCursorPosition.X,
                                    WC_DESTRUCTIVE_BACKSPACE |
                                            WC_KEEP_CURSOR_VISIBLE | WC_ECHO,
                                    &ScrollY);
                            ASSERT(NT_SUCCESS(Status));
                            CookedReadData->OriginalCursorPosition.Y += ScrollY;
                            CookedReadData->NumberOfVisibleChars += NumSpaces;
                        }
                        CookedReadData->BufPtr+=j/sizeof(WCHAR);
                    }
                }
                break;
            case VK_F4:

                //
                // copy the previous command to the current command, from
                // the letter specified by the user.   the user
                // is prompted via popup to enter a character.
                //

                if (CookedReadData->CommandHistory) {
                    COORD PopupSize;

                    PopupSize.X = COPY_FROM_CHAR_PROMPT_LENGTH+2;
                    PopupSize.Y = 1;
                    Status = BeginPopup(CookedReadData->ScreenInfo,
                               CookedReadData->CommandHistory,
                               PopupSize
                              );
                    if (NT_SUCCESS(Status)) {
                        // CopyFromCharPopup does EndPopup call
                        return CopyFromCharPopup(CookedReadData,
                                               WaitReplyMessage,
                                               WaitingThread,
                                               WaitRoutine
                                              );
                    }
                }
                break;
            case VK_F6:

                //
                // place a ctrl-z in the current command line
                //

                {
                DWORD NumSpaces;
                *CookedReadData->BufPtr = (WCHAR)0x1a; // ctrl-z
                CookedReadData->BytesRead += sizeof(WCHAR);
                CookedReadData->CurrentPosition++;
                if (CookedReadData->Echo) {
                    CharsToWrite = sizeof(WCHAR);
                    Status = WriteCharsFromInput(CookedReadData->ScreenInfo,
                                        CookedReadData->BackupLimit,
                                        CookedReadData->BufPtr,
                                        CookedReadData->BufPtr,
                                        &CharsToWrite,
                                        (PLONG)&NumSpaces,
                                        CookedReadData->OriginalCursorPosition.X,
                                        WC_DESTRUCTIVE_BACKSPACE |
                                                WC_KEEP_CURSOR_VISIBLE | WC_ECHO,
                                        &ScrollY
                                        );
                    ASSERT(NT_SUCCESS(Status));
                    CookedReadData->OriginalCursorPosition.Y += ScrollY;
                    CookedReadData->NumberOfVisibleChars += NumSpaces;
                }
                CookedReadData->BufPtr+=1;
                }
                break;
            case VK_F7:
                if (KeyState & (RIGHT_ALT_PRESSED | LEFT_ALT_PRESSED)) {
                    if (CookedReadData->CommandHistory) {
                        EmptyCommandHistory(CookedReadData->CommandHistory);
                        CookedReadData->CommandHistory->Flags |= CLE_ALLOCATED;
                    }
                }
                break;
            case VK_F8:
                if (CookedReadData->CommandHistory) {
                    SHORT i;

                    //
                    // cycles through the stored commands that start with
                    // the characters in the current command
                    //

                    i = FindMatchingCommand(CookedReadData->CommandHistory,
                            CookedReadData->BackupLimit,
                            CookedReadData->CurrentPosition*sizeof(WCHAR),
                            CookedReadData->CommandHistory->LastDisplayed, 0);
                    if (i!=-1) {
                        SHORT CurrentPosition;
                        COORD CursorPosition;

                        //
                        // save cursor position
                        //

                        CurrentPosition = (SHORT)CookedReadData->CurrentPosition;
                        CursorPosition = CookedReadData->ScreenInfo->BufferInfo.TextInfo.CursorPosition;

                        DeleteCommandLine(CookedReadData,
                                          TRUE);
                        Status = RetrieveNthCommand(CookedReadData->CommandHistory,
                                                    i,
                                                    CookedReadData->BackupLimit,
                                                    CookedReadData->BufferSize,
                                                    &CookedReadData->BytesRead);
                        ASSERT(CookedReadData->BackupLimit == CookedReadData->BufPtr);
                        if (CookedReadData->Echo) {
                            Status = WriteCharsFromInput(CookedReadData->ScreenInfo,
                                    CookedReadData->BackupLimit,
                                    CookedReadData->BufPtr,
                                    CookedReadData->BufPtr,
                                    &CookedReadData->BytesRead,
                                    (PLONG)&CookedReadData->NumberOfVisibleChars,
                                    CookedReadData->OriginalCursorPosition.X,
                                    WC_DESTRUCTIVE_BACKSPACE |
                                            WC_KEEP_CURSOR_VISIBLE | WC_ECHO,
                                    &ScrollY);
                            ASSERT(NT_SUCCESS(Status));
                            CookedReadData->OriginalCursorPosition.Y += ScrollY;
                        }
                        CursorPosition.Y += ScrollY;

                        //
                        // restore cursor position
                        //

                        CookedReadData->BufPtr = CookedReadData->BackupLimit + CurrentPosition;
                        CookedReadData->CurrentPosition = CurrentPosition;
                        Status = SetCursorPosition(CookedReadData->ScreenInfo,
                                                   CursorPosition,
                                                   TRUE
                                                  );
                        ASSERT(NT_SUCCESS(Status));
                    }
                }
                break;
            case VK_F9:

                //
                // prompt the user to enter the desired command number.
                // copy that command to the command line.
                //

                {
                COORD PopupSize;

                if (CookedReadData->CommandHistory &&
                    CookedReadData->CommandHistory->NumberOfCommands &&
                    CookedReadData->ScreenInfo->ScreenBufferSize.X >= MINIMUM_COMMAND_PROMPT_SIZE+2) {  // 2 is for border
                    PopupSize.X = COMMAND_NUMBER_PROMPT_LENGTH+COMMAND_NUMBER_LENGTH;
                    PopupSize.Y = 1;
                    Status = BeginPopup(CookedReadData->ScreenInfo,
                                        CookedReadData->CommandHistory,
                                        PopupSize
                                       );
                    if (NT_SUCCESS(Status)) {
                        // CommandNumberPopup does EndPopup call
                        return CommandNumberPopup(CookedReadData,
                                                  WaitReplyMessage,
                                                  WaitingThread,
                                                  WaitRoutine
                                                 );
                    }
                }
                }
                break;
            case VK_F10:
                if (KeyState & (RIGHT_ALT_PRESSED | LEFT_ALT_PRESSED)) {
                    ClearAliases(CookedReadData->Console);
                }
                break;
            case VK_INSERT:
                CookedReadData->InsertMode = !CookedReadData->InsertMode;
                SetCursorMode(CookedReadData->ScreenInfo,
                              (BOOLEAN)(CookedReadData->InsertMode != CookedReadData->Console->InsertMode));
                break;
        case VK_DELETE:
                if (!AT_EOL(CookedReadData)) {
                    COORD CursorPosition;

                    fStartFromDelim = IS_WORD_DELIM(*CookedReadData->BufPtr);

del_repeat:
                    //
                    // save cursor position
                    //

                    CursorPosition = CookedReadData->ScreenInfo->BufferInfo.TextInfo.CursorPosition;

                    //
                    // deletecommandline
                    //

                    DeleteCommandLine(CookedReadData,
                                      FALSE);
                    //
                    // delete char
                    //

                    CookedReadData->BytesRead -= sizeof(WCHAR);
                    RtlCopyMemory(CookedReadData->BufPtr,
                           CookedReadData->BufPtr+1,
                           CookedReadData->BytesRead - (CookedReadData->CurrentPosition*sizeof(WCHAR))
                          );

#if defined(FE_SB)
                    {
                        PWCHAR buf = (PWCHAR)((PBYTE)CookedReadData->BackupLimit +
                                                     CookedReadData->BytesRead    );
                        *buf = (WCHAR)' ';
                    }
#endif
                    //
                    // write commandline
                    //

                    if (CookedReadData->Echo) {
                        Status = WriteCharsFromInput(CookedReadData->ScreenInfo,
                                CookedReadData->BackupLimit,
                                CookedReadData->BackupLimit,
                                CookedReadData->BackupLimit,
                                &CookedReadData->BytesRead,
                                (PLONG)&CookedReadData->NumberOfVisibleChars,
                                CookedReadData->OriginalCursorPosition.X,
                                WC_DESTRUCTIVE_BACKSPACE |
                                        WC_KEEP_CURSOR_VISIBLE | WC_ECHO,
                                NULL);
                        ASSERT(NT_SUCCESS(Status));
                    }

                    //
                    // restore cursor position
                    //

                    if (CONSOLE_IS_DBCS_ENABLED() && CONSOLE_IS_DBCS_CP(CookedReadData->Console)) {
                        if (CheckBisectProcessW(CookedReadData->ScreenInfo,
                                                CookedReadData->ScreenInfo->Console->CP,
                                                CookedReadData->BackupLimit,
                                                CookedReadData->CurrentPosition+1,
                                                CookedReadData->ScreenInfo->ScreenBufferSize.X
                                                 -CookedReadData->OriginalCursorPosition.X,
                                                CookedReadData->OriginalCursorPosition.X,
                                                TRUE)) {
                            CursorPosition.X++;
                        }
                        CurrentPosition = CursorPosition;
                        if (CookedReadData->Echo) {
                            Status = AdjustCursorPosition(CookedReadData->ScreenInfo,
                                                          CurrentPosition,
                                                          TRUE,
                                                          NULL);
                            ASSERT(NT_SUCCESS(Status));
                        }
                    }
                    else {
                        Status = SetCursorPosition(CookedReadData->ScreenInfo,
                                                   CursorPosition,
                                                   TRUE
                                                  );
                        ASSERT(NT_SUCCESS(Status));
                    }

                    // If Ctrl key is pressed, delete a word.
                    // If the start point was word delimiter, just remove delimiters portion only.
                    if ((KeyState & CTRL_PRESSED) && !AT_EOL(CookedReadData) &&
                            fStartFromDelim ^ !IS_WORD_DELIM(*CookedReadData->BufPtr)) {
                        DBGPRINT(("Repeating it(%x).\n", *CookedReadData->BufPtr));
                        goto del_repeat;
                    }
                }
                break;
            default:
                ASSERT(FALSE);
                break;
        }
    }
    if (UpdateCursorPosition && CookedReadData->Echo) {
        Status = AdjustCursorPosition(CookedReadData->ScreenInfo,
                                      CurrentPosition,
                                      TRUE,
                                      NULL);
        ASSERT(NT_SUCCESS(Status));
    }
    return STATUS_SUCCESS;
}

PCOMMAND RemoveCommand(
    IN PCOMMAND_HISTORY CommandHistory,
    IN SHORT iDel)
{
    SHORT iFirst, iLast, iDisp, nDel;
    PCOMMAND *ppcFirst, *ppcDel, pcmdDel;

    iFirst = CommandHistory->FirstCommand;
    iLast = CommandHistory->LastAdded;
    iDisp = CommandHistory->LastDisplayed;

    if (CommandHistory->NumberOfCommands == 0) {
        return NULL;
    }

    nDel = COMMAND_INDEX_TO_NUM(iDel, CommandHistory);
    if ((nDel < COMMAND_INDEX_TO_NUM(iFirst, CommandHistory)) ||
            (nDel > COMMAND_INDEX_TO_NUM(iLast, CommandHistory))) {
        return NULL;
    }

    if (iDisp == iDel) {
        CommandHistory->LastDisplayed = -1;
    }

    ppcFirst = &(CommandHistory->Commands[iFirst]);
    ppcDel = &(CommandHistory->Commands[iDel]);
    pcmdDel = *ppcDel;

    if (iDel < iLast) {
        RtlCopyMemory(ppcDel, ppcDel+1, (iLast - iDel) * sizeof(PCOMMAND));
        if ((iDisp > iDel) && (iDisp <= iLast)) {
            COMMAND_IND_DEC(iDisp, CommandHistory);
        }
        COMMAND_IND_DEC(iLast, CommandHistory);
    } else if (iFirst <= iDel) {
        RtlMoveMemory(ppcFirst+1, ppcFirst, (iDel - iFirst) * sizeof(PCOMMAND));
        if ((iDisp >= iFirst) && (iDisp < iDel)) {
            COMMAND_IND_INC(iDisp, CommandHistory);
        }
        COMMAND_IND_INC(iFirst, CommandHistory);
    }

    CommandHistory->FirstCommand = iFirst;
    CommandHistory->LastAdded = iLast;
    CommandHistory->LastDisplayed = iDisp;
    CommandHistory->NumberOfCommands--;
    return pcmdDel;
}


SHORT
FindMatchingCommand(
    IN PCOMMAND_HISTORY CommandHistory,
    IN PWCHAR pwszIn,
    IN ULONG cbIn,                   // in bytes (!)
    IN SHORT CommandIndex,           // where to start from
    IN DWORD Flags
    )

/*++

    this routine finds the most recent command that starts with
    the letters already in the current command.  it returns the
    array index (no mod needed).

--*/

{
    SHORT i;

    if (CommandHistory->NumberOfCommands == 0) {
        return -1;
    }
    if (!(Flags & FMCFL_JUST_LOOKING) && (CommandHistory->Flags & CLE_RESET)) {
        CommandHistory->Flags &= ~CLE_RESET;
    } else {
        COMMAND_IND_PREV(CommandIndex, CommandHistory);
    }
    if (cbIn == 0) {
        return CommandIndex;
    }
    for (i=0;i<CommandHistory->NumberOfCommands;i++) {
        PCOMMAND pcmdT = CommandHistory->Commands[CommandIndex];

        if ((!(Flags & FMCFL_EXACT_MATCH) && (cbIn <= pcmdT->CommandLength)) ||
                ((USHORT)cbIn == pcmdT->CommandLength)) {
            if (!my_wcsncmp(pcmdT->Command, pwszIn, (USHORT)cbIn)) {
                return CommandIndex;
            }
        }
        COMMAND_IND_PREV(CommandIndex, CommandHistory);
    }
    return -1;
}

VOID
DrawCommandListBorder(
    IN PCLE_POPUP Popup,
    IN PSCREEN_INFORMATION ScreenInfo
    )
{
    COORD WriteCoord;
    ULONG Length;
    SHORT i;

    //
    // fill attributes of top line
    //
    WriteCoord.X = Popup->Region.Left;
    WriteCoord.Y = Popup->Region.Top;
    Length = POPUP_SIZE_X(Popup) + 2;
    FillOutput(ScreenInfo,
               Popup->Attributes,
               WriteCoord,
               CONSOLE_ATTRIBUTE,
               &Length
              );
    //
    // draw upper left corner
    //
    Length = 1;
    FillOutput(ScreenInfo,
#if defined(FE_SB)
               ScreenInfo->LineChar[UPPER_LEFT_CORNER],
#else
               (WCHAR)0x250c,
#endif
               WriteCoord,
               CONSOLE_REAL_UNICODE,
               &Length
              );

    //
    // draw upper bar
    //

    WriteCoord.X += 1;
    Length = POPUP_SIZE_X(Popup);
    FillOutput(ScreenInfo,
#if defined(FE_SB)
               ScreenInfo->LineChar[HORIZONTAL_LINE],
#else
               (WCHAR)0x2500,
#endif
               WriteCoord,
               CONSOLE_REAL_UNICODE,
               &Length
              );

    //
    // draw upper right corner
    //

    WriteCoord.X = Popup->Region.Right;
    Length = 1;
    FillOutput(ScreenInfo,
#if defined(FE_SB)
               ScreenInfo->LineChar[UPPER_RIGHT_CORNER],
#else
               (WCHAR)0x2510,
#endif
               WriteCoord,
               CONSOLE_REAL_UNICODE,
               &Length
              );

    for (i=0;i<POPUP_SIZE_Y(Popup);i++) {
        WriteCoord.Y += 1;
        WriteCoord.X = Popup->Region.Left;

        //
        // fill attributes
        //

        Length = POPUP_SIZE_X(Popup) + 2;
        FillOutput(ScreenInfo,
                   Popup->Attributes,
                   WriteCoord,
                   CONSOLE_ATTRIBUTE,
                   &Length
                  );
        Length = 1;
        FillOutput(ScreenInfo,
#if defined(FE_SB)
                   ScreenInfo->LineChar[VERTICAL_LINE],
#else
                   (WCHAR)0x2502,
#endif
                   WriteCoord,
                   CONSOLE_REAL_UNICODE,
                   &Length
                  );
        WriteCoord.X = Popup->Region.Right;
        Length = 1;
        FillOutput(ScreenInfo,
#if defined(FE_SB)
                   ScreenInfo->LineChar[VERTICAL_LINE],
#else
                   (WCHAR)0x2502,
#endif
                   WriteCoord,
                   CONSOLE_REAL_UNICODE,
                   &Length
                  );
    }

    //
    // draw bottom line
    //
    // fill attributes of top line
    //

    WriteCoord.X = Popup->Region.Left;
    WriteCoord.Y = Popup->Region.Bottom;
    Length = POPUP_SIZE_X(Popup) + 2;
    FillOutput(ScreenInfo,
               Popup->Attributes,
               WriteCoord,
               CONSOLE_ATTRIBUTE,
               &Length
              );
    //
    // draw bottom left corner
    //

    Length = 1;
    WriteCoord.X = Popup->Region.Left;
    FillOutput(ScreenInfo,
#if defined(FE_SB)
               ScreenInfo->LineChar[BOTTOM_LEFT_CORNER],
#else
               (WCHAR)0x2514,
#endif
               WriteCoord,
               CONSOLE_REAL_UNICODE,
               &Length
              );

    //
    // draw lower bar
    //

    WriteCoord.X += 1;
    Length = POPUP_SIZE_X(Popup);
    FillOutput(ScreenInfo,
#if defined(FE_SB)
               ScreenInfo->LineChar[HORIZONTAL_LINE],
#else
               (WCHAR)0x2500,
#endif
               WriteCoord,
               CONSOLE_REAL_UNICODE,
               &Length
              );

    //
    // draw lower right corner
    //

    WriteCoord.X = Popup->Region.Right;
    Length = 1;
    FillOutput(ScreenInfo,
#if defined(FE_SB)
               ScreenInfo->LineChar[BOTTOM_RIGHT_CORNER],
#else
               (WCHAR)0x2518,
#endif
               WriteCoord,
               CONSOLE_REAL_UNICODE,
               &Length
              );
}

VOID
UpdateHighlight(
    IN PCLE_POPUP Popup,
    IN SHORT OldCurrentCommand, // command number, not index
    IN SHORT NewCurrentCommand,
    IN PSCREEN_INFORMATION ScreenInfo
    )
{
    COORD WriteCoord;
    ULONG lStringLength;
    WORD Attributes;
    SHORT TopIndex;

    if (Popup->BottomIndex < POPUP_SIZE_Y(Popup)) {
        TopIndex = 0;
    } else {
        TopIndex = (SHORT)(Popup->BottomIndex-POPUP_SIZE_Y(Popup)+1);
    }
    WriteCoord.X = (SHORT)(Popup->Region.Left+1);
    lStringLength = POPUP_SIZE_X(Popup);

    WriteCoord.Y = (SHORT)(Popup->Region.Top+1+OldCurrentCommand-TopIndex);
    FillOutput(ScreenInfo,
               Popup->Attributes,
               WriteCoord,
               CONSOLE_ATTRIBUTE,
               &lStringLength
              );

    //
    // highlight new command
    //

    WriteCoord.Y = (SHORT)(Popup->Region.Top+1+NewCurrentCommand-TopIndex);
    // inverted attributes
    Attributes = (WORD)(((Popup->Attributes << 4) & 0xf0) |
                        ((Popup->Attributes >> 4) & 0x0f));
    FillOutput(ScreenInfo,
               Attributes,
               WriteCoord,
               CONSOLE_ATTRIBUTE,
               &lStringLength
              );
}

VOID
DrawCommandListPopup(
    IN PCLE_POPUP Popup,
    IN SHORT CurrentCommand,
    IN PCOMMAND_HISTORY CommandHistory,
    IN PSCREEN_INFORMATION ScreenInfo
    )
{
    WORD Attributes;
    ULONG lStringLength,CommandNumberLength;
    CHAR CommandNumber[COMMAND_NUMBER_SIZE];
    PCHAR CommandNumberPtr;
    COORD WriteCoord;
    SHORT i;

    //
    // draw empty popup
    //

    WriteCoord.X = (SHORT)(Popup->Region.Left+1);
    WriteCoord.Y = (SHORT)(Popup->Region.Top+1);
    lStringLength = POPUP_SIZE_X(Popup);
    for (i=0;i<POPUP_SIZE_Y(Popup);i++) {
        FillOutput(ScreenInfo,
                   Popup->Attributes,
                   WriteCoord,
                   CONSOLE_ATTRIBUTE,
                   &lStringLength
                  );
        FillOutput(ScreenInfo,
                   (WCHAR)' ',
                   WriteCoord,
                   CONSOLE_FALSE_UNICODE, // faster than real unicode
                   &lStringLength
                  );
        WriteCoord.Y += 1;
    }

    WriteCoord.Y = (SHORT)(Popup->Region.Top+1);
    for (i=max((SHORT)(Popup->BottomIndex-POPUP_SIZE_Y(Popup)+1),0);i<=Popup->BottomIndex;i++) {

        //
        // write command number to screen
        //

        CommandNumberPtr = _itoa(i,CommandNumber,10);
        CommandNumberLength = (SHORT)lstrlenA(CommandNumberPtr);
        CommandNumber[CommandNumberLength] = ':';
        CommandNumber[CommandNumberLength+1] = ' ';
        CommandNumberLength+=2;
        if (CommandNumberLength > (ULONG)POPUP_SIZE_X(Popup))
            CommandNumberLength = (ULONG)POPUP_SIZE_X(Popup);
        WriteCoord.X = (SHORT)(Popup->Region.Left+1);
        WriteOutputString(ScreenInfo,
                          CommandNumberPtr,
                          WriteCoord,
                          CONSOLE_ASCII,
                          &CommandNumberLength,
                          NULL
                         );

        //
        // write command to screen
        //

        lStringLength = CommandHistory->Commands[COMMAND_NUM_TO_INDEX(i,CommandHistory)]->CommandLength/sizeof(WCHAR);
#if defined(FE_SB)
        {
            DWORD lTmpStringLength;
            LONG lPopupLength;
            LPWSTR lpStr;

            lTmpStringLength = lStringLength;
            lPopupLength = POPUP_SIZE_X(Popup) - CommandNumberLength;
            lpStr = CommandHistory->Commands[COMMAND_NUM_TO_INDEX(i,CommandHistory)]->Command;
            while (lTmpStringLength--) {
                if (IsConsoleFullWidth(ScreenInfo->Console->hDC,
                                       ScreenInfo->Console->OutputCP,*lpStr++)) {
                    lPopupLength -= 2;
                }
                else {
                    lPopupLength--;
                }
                if (lPopupLength <= 0) {
                    lStringLength -= lTmpStringLength;
                    if (lPopupLength < 0)
                        lStringLength--;
                    break;
                }
            }
        }
#else
        if ((lStringLength+CommandNumberLength) > (ULONG)POPUP_SIZE_X(Popup))
            lStringLength = (ULONG)(POPUP_SIZE_X(Popup)-CommandNumberLength);
#endif
        WriteCoord.X = (SHORT)(WriteCoord.X + CommandNumberLength);
#if defined(FE_SB)
        {
            PWCHAR TransBuffer;

            TransBuffer = ConsoleHeapAlloc(MAKE_TAG( TMP_DBCS_TAG ),lStringLength * sizeof(WCHAR));
            if (TransBuffer == NULL) {
                return;
            }

            RtlCopyMemory(TransBuffer,CommandHistory->Commands[COMMAND_NUM_TO_INDEX(i,CommandHistory)]->Command,lStringLength * sizeof(WCHAR));
            WriteOutputString(ScreenInfo,
                              TransBuffer,
                              WriteCoord,
                              CONSOLE_REAL_UNICODE,
                              &lStringLength,
                              NULL
                             );
            ConsoleHeapFree(TransBuffer);
        }
#else
        WriteOutputString(ScreenInfo,
                          CommandHistory->Commands[COMMAND_NUM_TO_INDEX(i,CommandHistory)]->Command,
                          WriteCoord,
                          CONSOLE_REAL_UNICODE,
                          &lStringLength,
                          NULL
                         );
        // convert back to true unicode (got converted by WriteOutputString)
        if ((ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) &&
                !(ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN)) {
            FalseUnicodeToRealUnicode(CommandHistory->Commands[COMMAND_NUM_TO_INDEX(i,CommandHistory)]->Command,
                    lStringLength,
                    ScreenInfo->Console->OutputCP);
        }
#endif

        //
        // write attributes to screen
        //

        if (COMMAND_NUM_TO_INDEX(i,CommandHistory) == CurrentCommand) {
            WriteCoord.X = (SHORT)(Popup->Region.Left+1);
            // inverted attributes
            Attributes = (WORD)(((Popup->Attributes << 4) & 0xf0) |
                                ((Popup->Attributes >> 4) & 0x0f));
            lStringLength = POPUP_SIZE_X(Popup);
            FillOutput(ScreenInfo,
                       Attributes,
                       WriteCoord,
                       CONSOLE_ATTRIBUTE,
                       &lStringLength
                      );
        }

        WriteCoord.Y += 1;
    }
}

VOID
UpdateCommandListPopup(
    IN SHORT Delta,
    IN OUT PSHORT CurrentCommand,   // real index, not command #
    IN PCOMMAND_HISTORY CommandHistory,
    IN PCLE_POPUP Popup,
    IN PSCREEN_INFORMATION ScreenInfo,
    IN DWORD Flags
    )
{
    SHORT Size;
    SHORT CurCmdNum;
    SHORT NewCmdNum;
    BOOL Scroll=FALSE;

    if (Delta == 0) {
        return;
    }
    Size = POPUP_SIZE_Y(Popup);

    if (Flags & UCLP_WRAP) {
        CurCmdNum = *CurrentCommand;
        NewCmdNum = CurCmdNum + Delta;
        NewCmdNum = COMMAND_INDEX_TO_NUM(NewCmdNum, CommandHistory);
        CurCmdNum = COMMAND_INDEX_TO_NUM(CurCmdNum, CommandHistory);
    } else {
        CurCmdNum = COMMAND_INDEX_TO_NUM(*CurrentCommand, CommandHistory);
        NewCmdNum = CurCmdNum + Delta;
        if (NewCmdNum >= CommandHistory->NumberOfCommands) {
            NewCmdNum = (SHORT)(CommandHistory->NumberOfCommands-1);
        } else if (NewCmdNum < 0) {
            NewCmdNum = 0;
        }
    }
    Delta = NewCmdNum - CurCmdNum;

    // determine amount to scroll, if any

    if (NewCmdNum <= Popup->BottomIndex-Size) {
        Popup->BottomIndex += Delta;
        if (Popup->BottomIndex < (SHORT)(Size-1)) {
            Popup->BottomIndex = (SHORT)(Size-1);
        }
        Scroll = TRUE;
    } else if (NewCmdNum > Popup->BottomIndex) {
        Popup->BottomIndex += Delta;
        if (Popup->BottomIndex >= CommandHistory->NumberOfCommands) {
            Popup->BottomIndex = (SHORT)(CommandHistory->NumberOfCommands-1);
        }
        Scroll = TRUE;
    }


    //
    // write commands to popup
    //
    if (Scroll) {
        DrawCommandListPopup(Popup,COMMAND_NUM_TO_INDEX(NewCmdNum,CommandHistory),CommandHistory,ScreenInfo);
    } else {
        UpdateHighlight(Popup,COMMAND_INDEX_TO_NUM((*CurrentCommand),CommandHistory),NewCmdNum,ScreenInfo);
    }
    *CurrentCommand = COMMAND_NUM_TO_INDEX(NewCmdNum,CommandHistory);
}

PCOMMAND_HISTORY
FindCommandHistory(
    IN PCONSOLE_INFORMATION Console,
    IN HANDLE ProcessHandle
    )

/*++

Routine Description:

    This routine marks the command history buffer freed.

Arguments:

    Console - pointer to console.

    ProcessHandle - handle to client process.

Return Value:

    none.

--*/

{
    PCOMMAND_HISTORY History;
    PLIST_ENTRY ListHead, ListNext;

    ListHead = &Console->CommandHistoryList;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        History = CONTAINING_RECORD( ListNext, COMMAND_HISTORY, ListLink );
        ListNext = ListNext->Flink;
        if (History->ProcessHandle == ProcessHandle) {
            ASSERT(History->Flags & CLE_ALLOCATED);
            return History;
        }
    }
    return NULL;
}

VOID
FreeCommandHistory(
    IN PCONSOLE_INFORMATION Console,
    IN HANDLE ProcessHandle
    )

/*++

Routine Description:

    This routine marks the command history buffer freed.

Arguments:

    Console - pointer to console.

    ProcessHandle - handle to client process.

Return Value:

    none.

--*/

{
    PCOMMAND_HISTORY History;

    History = FindCommandHistory(Console,ProcessHandle);
    if (History) {
        History->Flags &= ~CLE_ALLOCATED;
        History->ProcessHandle = NULL;
    }
}


VOID
FreeCommandHistoryBuffers(
    IN OUT PCONSOLE_INFORMATION Console
    )
{
    PCOMMAND_HISTORY History;
    PLIST_ENTRY ListHead, ListNext;
    SHORT i;

    ListHead = &Console->CommandHistoryList;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        History = CONTAINING_RECORD( ListNext, COMMAND_HISTORY, ListLink );
        ListNext = ListNext->Flink;
        RemoveEntryList(&History->ListLink);
        if (History->AppName) {
            ConsoleHeapFree(History->AppName);
        }
        for (i=0;i<History->NumberOfCommands;i++) {
            ConsoleHeapFree(History->Commands[i]);
        }
        ConsoleHeapFree(History);
    }
}

VOID
ResizeCommandHistoryBuffers(
    IN PCONSOLE_INFORMATION Console,
    IN UINT NumCommands
    )
{
    PCOMMAND_HISTORY History;
    PLIST_ENTRY ListHead, ListNext;
#if defined(FE_SB)
    PCOOKED_READ_DATA CookedReadData;
    PCOMMAND_HISTORY NewHistory;
#endif

    Console->CommandHistorySize = (SHORT)NumCommands;

    ListHead = &Console->CommandHistoryList;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        History = CONTAINING_RECORD( ListNext, COMMAND_HISTORY, ListLink );
        ListNext = ListNext->Flink;

#if defined(FE_SB)
        NewHistory = ReallocCommandHistory(Console, History, NumCommands);
        CookedReadData = Console->lpCookedReadData;
        if (CookedReadData && CookedReadData->CommandHistory == History) {
            CookedReadData->CommandHistory = NewHistory;
        }
#else
        if (!(History->Flags & CLE_ALLOCATED)) {
            ReallocCommandHistory(Console, History, NumCommands);
         }
#endif
    }
}

VOID
InitializeConsoleCommandData(
    IN PCONSOLE_INFORMATION Console
    )

/*++

Routine Description:

    This routine initializes the per-console commandline recall data structures.

Arguments:

    Console - pointer to console.

Return Value:

    none

--*/

{
    Console->NumCommandHistories = 0;
    InitializeListHead(&Console->CommandHistoryList);
}

VOID
ResetCommandHistory(
    IN PCOMMAND_HISTORY CommandHistory
    )

/*++
    This routine is called when escape is entered or a command is added.

--*/

{
    if (CommandHistory == NULL) {
        return;
    }
    CommandHistory->LastDisplayed = CommandHistory->LastAdded;
    CommandHistory->Flags |= CLE_RESET;
}

NTSTATUS
AddCommand(
    IN PCOMMAND_HISTORY CommandHistory,
    IN PWCHAR Command,
    IN USHORT Length,
    IN BOOL HistoryNoDup
    )
{
    PCOMMAND *ppCmd;
    //PWCHAR LastChar;

    // only add if doesn't match current command

    if (CommandHistory == NULL || CommandHistory->MaximumNumberOfCommands == 0) {
        return STATUS_NO_MEMORY;
    }
    ASSERT(CommandHistory->Flags & CLE_ALLOCATED);

    //
    // don't remove trailing blanks - prompt "asdf  " won't work.
    //
    //LastChar=Command+(Length/sizeof(WCHAR))-1;
    //while (Length && *LastChar--==(WCHAR)' ') Length-=2;

    if (Length == 0) {
        return STATUS_SUCCESS;
    }

    if (CommandHistory->NumberOfCommands == 0 ||
        CommandHistory->Commands[CommandHistory->LastAdded]->CommandLength != Length ||
        memcmp(CommandHistory->Commands[CommandHistory->LastAdded]->Command,Command,Length)) {

        PCOMMAND pCmdReuse = NULL;

        if (HistoryNoDup) {
            SHORT i;
            i = FindMatchingCommand(CommandHistory, Command, Length,
                    CommandHistory->LastDisplayed, FMCFL_EXACT_MATCH);
            if (i != -1) {
                pCmdReuse = RemoveCommand(CommandHistory, i);
            }
        }


        //
        // find free record.  if all records are used, free the lru one.
        //

        if (CommandHistory->NumberOfCommands < CommandHistory->MaximumNumberOfCommands) {
            CommandHistory->LastAdded += 1;
            CommandHistory->NumberOfCommands++;
        }
        else {
            COMMAND_IND_INC(CommandHistory->LastAdded, CommandHistory);
            COMMAND_IND_INC(CommandHistory->FirstCommand, CommandHistory);
            ConsoleHeapFree(CommandHistory->Commands[CommandHistory->LastAdded]);
            if (CommandHistory->LastDisplayed == CommandHistory->LastAdded) {
                CommandHistory->LastDisplayed = -1;
            }
        }

        if (CommandHistory->LastDisplayed == -1 ||
            CommandHistory->Commands[CommandHistory->LastDisplayed]->CommandLength != Length ||
                memcmp(CommandHistory->Commands[CommandHistory->LastDisplayed]->Command,Command,Length)) {
            ResetCommandHistory(CommandHistory);
        }

        //
        // add command to array
        //

        ppCmd = &CommandHistory->Commands[CommandHistory->LastAdded];
        if (pCmdReuse) {
            *ppCmd = pCmdReuse;
        } else {
            *ppCmd = (PCOMMAND)ConsoleHeapAlloc( MAKE_TAG(HISTORY_TAG),
                    Length - sizeof(WCHAR) + sizeof(COMMAND));
            if (*ppCmd == NULL) {
                COMMAND_IND_PREV(CommandHistory->LastAdded, CommandHistory);
                CommandHistory->NumberOfCommands -= 1;
                return STATUS_NO_MEMORY;
            }
            (*ppCmd)->CommandLength = Length;
            RtlCopyMemory((*ppCmd)->Command,Command,Length);
        }
    }
    CommandHistory->Flags |= CLE_RESET; // remember that we've returned a cmd
    return STATUS_SUCCESS;
}

NTSTATUS
RetrieveCommand(
    IN PCOMMAND_HISTORY CommandHistory,
    IN WORD VirtualKeyCode,
    IN PWCHAR Buffer,
    IN ULONG BufferSize,
    OUT PULONG CommandSize
    )
{

    if (CommandHistory == NULL) {
        return STATUS_UNSUCCESSFUL;
    }
    ASSERT(CommandHistory->Flags & CLE_ALLOCATED);
    if (CommandHistory->NumberOfCommands == 0) {
        return STATUS_UNSUCCESSFUL;
    }
    if (CommandHistory->NumberOfCommands == 1) {
        CommandHistory->LastDisplayed = 0;
    }
    else if (VirtualKeyCode == VK_UP) {

        //
        // if this is the first time for this read that a command has
        // been retrieved, return the current command.  otherwise, return
        // the previous command.
        //

        if (CommandHistory->Flags & CLE_RESET) {
            CommandHistory->Flags &= ~CLE_RESET;
        } else {
            COMMAND_IND_PREV(CommandHistory->LastDisplayed, CommandHistory);
        }
    }
    else {
        COMMAND_IND_NEXT(CommandHistory->LastDisplayed, CommandHistory);
    }
    return RetrieveNthCommand(CommandHistory,
                              CommandHistory->LastDisplayed,
                              Buffer,
                              BufferSize,
                              CommandSize
                             );
}

ULONG
SrvGetConsoleTitle(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_GETTITLE_MSG a = (PCONSOLE_GETTITLE_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (!CsrValidateMessageBuffer(m, &a->Title, a->TitleLength, sizeof(BYTE))) {
        UnlockConsole(Console);
        return STATUS_INVALID_PARAMETER;
    }

    // a->TitleLength contains length in bytes
    if (a->Unicode) {
        if ((USHORT)a->TitleLength > Console->TitleLength) {
            a->TitleLength = Console->TitleLength;
        }
        RtlCopyMemory(a->Title,Console->Title,a->TitleLength);
    } else {
#if defined(FE_SB)
        a->TitleLength = (USHORT)ConvertToOem(OEMCP,
                                        Console->Title,
                                        Console->TitleLength / sizeof(WCHAR),
                                        a->Title,
                                        a->TitleLength
                                        );
#else
        a->TitleLength = (USHORT)ConvertToOem(Console->CP,
                                        Console->Title,
                                        Console->TitleLength / sizeof(WCHAR),
                                        a->Title,
                                        a->TitleLength
                                        );
#endif
    }
    UnlockConsole(Console);
    return STATUS_SUCCESS;
    UNREFERENCED_PARAMETER(ReplyStatus);    // get rid of unreferenced parameter warning message
}

ULONG
SrvSetConsoleTitle(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_SETTITLE_MSG a = (PCONSOLE_SETTITLE_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    LPWSTR NewTitle;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (!CsrValidateMessageBuffer(m, &a->Title, a->TitleLength, sizeof(BYTE))) {
        UnlockConsole(Console);
        return STATUS_INVALID_PARAMETER;
    }

    if (!a->Unicode) {
        NewTitle = (LPWSTR)ConsoleHeapAlloc(MAKE_TAG( TITLE_TAG ),a->TitleLength*sizeof(WCHAR)+sizeof(WCHAR));
        if (NewTitle == NULL) {
            UnlockConsole(Console);
            return (ULONG)STATUS_NO_MEMORY;
        }

        // convert title to unicode

#if defined(FE_SB)
        Console->TitleLength = (USHORT)ConvertInputToUnicode(OEMCP,
                                                 a->Title,
                                                 a->TitleLength,
                                                 NewTitle,
                                                 a->TitleLength);
#else
        Console->TitleLength = (USHORT)ConvertInputToUnicode(Console->CP,
                                                 a->Title,
                                                 a->TitleLength,
                                                 NewTitle,
                                                 a->TitleLength);
#endif
        Console->TitleLength *= 2;
    } else {
        // a->TitleLength contains length in bytes

        NewTitle = (LPWSTR)ConsoleHeapAlloc(MAKE_TAG( TITLE_TAG ),a->TitleLength+sizeof(WCHAR));
        if (NewTitle == NULL) {
            UnlockConsole(Console);
            return (ULONG)STATUS_NO_MEMORY;
        }
        Console->TitleLength = (USHORT)a->TitleLength;
        RtlCopyMemory(NewTitle,a->Title,a->TitleLength);
    }
    NewTitle[Console->TitleLength/sizeof(WCHAR)] = 0;   // NULL terminate
    ConsoleHeapFree(Console->Title);
    Console->Title = NewTitle;
    PostMessage(Console->hWnd, CM_UPDATE_TITLE, 0, 0);
    UnlockConsole(Console);
    return STATUS_SUCCESS;
    UNREFERENCED_PARAMETER(ReplyStatus);    // get rid of unreferenced parameter warning message
}

int
LoadStringExW(
    IN HINSTANCE hModule,
    IN UINT      wID,
    OUT LPWSTR   lpBuffer,
    IN int       cchBufferMax,
    IN WORD      wLangId
    )
{
    HANDLE hResInfo;
    HANDLE hStringSeg;
    LPTSTR lpsz;
    int cch;

    /*
     * Make sure the parms are valid.
     */
    if (lpBuffer == NULL) {
        return 0;
    }

    cch = 0;

    /*
     * String Tables are broken up into 16 string segments.  Find the segment
     * containing the string we are interested in.
     */
    if (hResInfo = FindResourceEx(hModule,
                                  RT_STRING,
                                  (LPTSTR)((LONG_PTR)(((USHORT)wID >> 4) + 1)),
                                  wLangId)) {

        /*
         * Load that segment.
         */
        hStringSeg = LoadResource(hModule, hResInfo);

        /*
         * Lock the resource.
         */
        if (lpsz = (LPTSTR)LockResource(hStringSeg)) {

            /*
             * Move past the other strings in this segment.
             * (16 strings in a segment -> & 0x0F)
             */
            wID &= 0x0F;
            while (TRUE) {
                cch = *((UTCHAR *)lpsz++);      // PASCAL like string count
                                                // first UTCHAR is count if TCHARs
                if (wID-- == 0) break;
                lpsz += cch;                    // Step to start if next string
            }

            /*
             * chhBufferMax == 0 means return a pointer to the read-only resource buffer.
             */
            if (cchBufferMax == 0) {
                *(LPTSTR *)lpBuffer = lpsz;
            } else {

                /*
                 * Account for the NULL
                 */
                cchBufferMax--;

                /*
                 * Don't copy more than the max allowed.
                 */
                if (cch > cchBufferMax)
                    cch = cchBufferMax;

                /*
                 * Copy the string into the buffer.
                 */
                RtlCopyMemory(lpBuffer, lpsz, cch*sizeof(WCHAR));
            }
        }
    }

    /*
     * Append a NULL.
     */
    if (cchBufferMax != 0) {
        lpBuffer[cch] = 0;
    }

    return cch;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\server\consrv.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    consrv.h

Abstract:

    This module contains the include files and definitions for the
    console server DLL.

Author:

    Therese Stowell (thereses) 16-Nov-1990

Revision History:

--*/

#if DBG && defined(DEBUG_PRINT)
  #define _DBGFONTS   0x00000001
  #define _DBGFONTS2  0x00000002
  #define _DBGCHARS   0x00000004
  #define _DBGOUTPUT  0x00000008
  #define _DBGFULLSCR 0x00000008
  #define _DBGALL     0xFFFFFFFF
  extern ULONG gDebugFlag;

  #define DBGFONTS(_params_)   {if (gDebugFlag & _DBGFONTS)  DbgPrint _params_ ; }
  #define DBGFONTS2(_params_)  {if (gDebugFlag & _DBGFONTS2) DbgPrint _params_ ; }
  #define DBGCHARS(_params_)   {if (gDebugFlag & _DBGCHARS)  DbgPrint _params_ ; }
  #define DBGOUTPUT(_params_)  {if (gDebugFlag & _DBGOUTPUT) DbgPrint _params_ ; }
  #define DBGFULLSCR(_params_) {if (gDebugFlag & _DBGFULLSCR)DbgPrint _params_ ; }
  #define DBGPRINT(_params_)  DbgPrint _params_
#else
  #define DBGFONTS(_params_)
  #define DBGFONTS2(_params_)
  #define DBGCHARS(_params_)
  #define DBGOUTPUT(_params_)
  #define DBGFULLSCR(_params_)
  #define DBGPRINT(_params_)
#endif

#ifdef LATER
#if DBG
#undef  RIP_COMPONENT
#define RIP_COMPONENT RIP_CONSRV
#undef  ASSERT
#define ASSERT(exp) UserAssert(exp)
#endif
#endif

#define CONSOLE_MAX_FONT_NAME_LENGTH 256

#define DATA_CHUNK_SIZE 8192


#define MAKE_TAG( t ) (RTL_HEAP_MAKE_TAG( dwConBaseTag, t ))

#define TMP_TAG 0
#define BMP_TAG 1
#define ALIAS_TAG 2
#define HISTORY_TAG 3
#define TITLE_TAG 4
#define HANDLE_TAG 5
#define CONSOLE_TAG 6
#define ICON_TAG 7
#define BUFFER_TAG 8
#define WAIT_TAG 9
#define FONT_TAG 10
#define SCREEN_TAG 11
#if defined(FE_SB)
#define TMP_DBCS_TAG 12
#define SCREEN_DBCS_TAG 13
#define EUDC_TAG 14
#define CONVAREA_TAG 15
#define IME_TAG 16
#endif


#define GetWindowConsole(hWnd)          (PCONSOLE_INFORMATION)GetWindowLongPtr((hWnd), GWLP_USERDATA)

/*
 * Used to store some console attributes for the console.  This is a means
 * to cache the color in the extra-window-bytes, so USER/KERNEL can get
 * at it for hungapp drawing.  The window-offsets are defined in NTUSER\INC.
 *
 * The other macros are just convenient means for setting the other window
 * bytes.
 */
#define SetConsoleBkColor(hw,clr) SetWindowLong(hw, GWL_CONSOLE_BKCOLOR, clr)
#define SetConsolePid(hw,pid)     SetWindowLong(hw, GWL_CONSOLE_PID, pid)
#define SetConsoleTid(hw,tid)     SetWindowLong(hw, GWL_CONSOLE_TID, tid)


/*
 * helpful macros
 */
#define NELEM(array) (sizeof(array)/sizeof(array[0]))
#define PACKCOORD(pt)   (MAKELONG(((pt).X), ((pt).Y)))

// Text Information from PSCREEN_INFORMATION
__inline BYTE SCR_FAMILY(PSCREEN_INFORMATION pScreen) {
    return pScreen->BufferInfo.TextInfo.CurrentTextBufferFont.Family;
}

__inline DWORD SCR_FONTNUMBER(PSCREEN_INFORMATION pScreen) {
    return pScreen->BufferInfo.TextInfo.CurrentTextBufferFont.FontNumber;
}

__inline LPWSTR SCR_FACENAME(PSCREEN_INFORMATION pScreen) {
    return pScreen->BufferInfo.TextInfo.CurrentTextBufferFont.FaceName;
}

__inline COORD SCR_FONTSIZE(PSCREEN_INFORMATION pScreen) {
    return pScreen->BufferInfo.TextInfo.CurrentTextBufferFont.FontSize;
}

__inline LONG SCR_FONTWEIGHT(PSCREEN_INFORMATION pScreen) {
    return pScreen->BufferInfo.TextInfo.CurrentTextBufferFont.Weight;
}

__inline UINT SCR_FONTCODEPAGE(PSCREEN_INFORMATION pScreen) {
    return pScreen->BufferInfo.TextInfo.CurrentTextBufferFont.FontCodePage;
}


// Text Information from PCONSOLE_INFORMATION
#define CON_FAMILY(pCon)       SCR_FAMILY((pCon)->CurrentScreenBuffer)
#define CON_FONTNUMBER(pCon)   SCR_FONTNUMBER((pCon)->CurrentScreenBuffer)
#define CON_FACENAME(pCon)     SCR_FACENAME((pCon)->CurrentScreenBuffer)
#define CON_FONTSIZE(pCon)     SCR_FONTSIZE((pCon)->CurrentScreenBuffer)
#define CON_FONTWEIGHT(pCon)   SCR_FONTWEIGHT((pCon)->CurrentScreenBuffer)
#define CON_FONTCODEPAGE(pCon) SCR_FONTCODEPAGE((pCon)->CurrentScreenBuffer)

#if defined(FE_SB)

extern BOOLEAN    gfIsDBCSACP;      // TRUE if System ACP is associated with DBCS font

#define CONSOLE_IS_DBCS_ENABLED()   (gfIsDBCSACP)
#define CONSOLE_IS_IME_ENABLED()    (gfIsDBCSACP)

#define CONSOLE_IS_DBCS_OUTPUTCP(Console)   ((Console)->fIsDBCSOutputCP)
#define CONSOLE_IS_DBCS_CP(Console)         ((Console)->fIsDBCSCP)

#else   // FE_SB

#define CONSOLE_IS_DBCS_ENABLED()   (FALSE)
#define CONSOLE_IS_IME_ENABLED()    (FALSE)

#endif  // FE_SB

#ifdef UNICODE
#define LoadStringEx    LoadStringExW
#else
#define LoadStringEx    LoadStringExA
#endif

//
//  Cache the heap pointer for use by memory routines.
//

extern PWIN32HEAP pConHeap;
extern DWORD      dwConBaseTag;

//
// Make sure the console heap is still valid.
//

#define ValidateConsoleHeap()               \
    if (NtCurrentPeb()->BeingDebugged) {    \
        RtlValidateHeap(Win32HeapGetHandle(pConHeap), 0, NULL); \
    }

//
// Wrappers for console heap code.
//

#define ConsoleHeapAlloc(Flags, Size)                   \
    Win32HeapAlloc(pConHeap, Size, Flags, Flags)

#define ConsoleHeapReAlloc(Flags, Address, Size)        \
    Win32HeapReAlloc(pConHeap, Address, Size, Flags)

#if DBG
#define ConsoleHeapFree(Address)                        \
{                                                       \
    Win32HeapFree(pConHeap, Address);                   \
    Address = IntToPtr(0xBAADF00D);                     \
}
#else
#define ConsoleHeapFree(Address)                        \
{                                                       \
    Win32HeapFree(pConHeap, Address);                   \
}
#endif

#define ConsoleHeapSize(Address)                        \
    Win32HeapSize(pConHeap, Address)

//
//  handle.c
//

NTSTATUS
ConsoleAddProcessRoutine(
    IN PCSR_PROCESS ParentProcess,
    IN PCSR_PROCESS Process
    );

NTSTATUS
DereferenceConsoleHandle(
    IN HANDLE ConsoleHandle,
    OUT PCONSOLE_INFORMATION *Console
    );

NTSTATUS
AllocateConsoleHandle(
    OUT PHANDLE Handle
    );

NTSTATUS
FreeConsoleHandle(
    IN HANDLE Handle
    );

NTSTATUS
ValidateConsole(
    IN PCONSOLE_INFORMATION Console
    );

NTSTATUS
ApiPreamble(
    IN HANDLE ConsoleHandle,
    OUT PCONSOLE_INFORMATION *Console
    );

NTSTATUS
RevalidateConsole(
    IN HANDLE ConsoleHandle,
    OUT PCONSOLE_INFORMATION *Console
    );

NTSTATUS
InitializeConsoleHandleTable( VOID );

#if DBG

VOID LockConsoleHandleTable(VOID);
VOID UnlockConsoleHandleTable(VOID);
VOID LockConsole(
    IN PCONSOLE_INFORMATION Console
    );

#else

#define LockConsoleHandleTable()   RtlEnterCriticalSection(&ConsoleHandleLock)
#define UnlockConsoleHandleTable() RtlLeaveCriticalSection(&ConsoleHandleLock)
#define LockConsole(Con)           RtlEnterCriticalSection(&(Con)->ConsoleLock)

#endif // DBG

#define ConvertAttrToRGB(Con, Attr) ((Con)->ColorTable[(Attr) & 0x0F])


BOOLEAN
UnProtectHandle(
    HANDLE hObject
    );

NTSTATUS
MapEventHandles(
    IN HANDLE ClientProcessHandle,
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCONSOLE_INFO ConsoleInfo
    );

NTSTATUS
AllocateConsole(
    IN HANDLE ConsoleHandle,
    IN LPWSTR Title,
    IN USHORT TitleLength,
    IN HANDLE ClientProcessHandle,
    OUT PHANDLE StdIn,
    OUT PHANDLE StdOut,
    OUT PHANDLE StdErr,
    OUT PCONSOLE_PER_PROCESS_DATA ProcessData,
    IN OUT PCONSOLE_INFO ConsoleInfo,
    IN BOOLEAN WindowVisible,
    IN DWORD ConsoleThreadId
    );

VOID
DestroyConsole(
    IN PCONSOLE_INFORMATION Console
    );

VOID
FreeCon(
    IN PCONSOLE_INFORMATION Console
    );

VOID
InsertScreenBuffer(
    IN PCONSOLE_INFORMATION Console,
    IN PSCREEN_INFORMATION ScreenInfo
    );

VOID
RemoveScreenBuffer(
    IN PCONSOLE_INFORMATION Console,
    IN PSCREEN_INFORMATION ScreenInfo
    );

VOID
FreeProcessData(
    IN PCONSOLE_PER_PROCESS_DATA ProcessData
    );

NTSTATUS
AllocateIoHandle(
    IN PCONSOLE_PER_PROCESS_DATA ProcessData,
    IN ULONG HandleType,
    OUT PHANDLE Handle
    );

NTSTATUS
GrowIoHandleTable(
    IN PCONSOLE_PER_PROCESS_DATA ProcessData
    );

NTSTATUS
FreeIoHandle(
    IN PCONSOLE_PER_PROCESS_DATA ProcessData,
    IN HANDLE Handle
    );

NTSTATUS
DereferenceIoHandleNoCheck(
    IN PCONSOLE_PER_PROCESS_DATA ProcessData,
    IN HANDLE Handle,
    OUT PHANDLE_DATA *HandleData
    );

NTSTATUS
DereferenceIoHandle(
    IN PCONSOLE_PER_PROCESS_DATA ProcessData,
    IN HANDLE Handle,
    IN ULONG HandleType,
    IN ACCESS_MASK Access,
    OUT PHANDLE_DATA *HandleData
    );

BOOLEAN
InitializeInputHandle(
    PHANDLE_DATA HandleData,
    PINPUT_INFORMATION InputBuffer
    );

VOID
InitializeOutputHandle(
    PHANDLE_DATA HandleData,
    PSCREEN_INFORMATION ScreenBuffer
    );

ULONG
SrvVerifyConsoleIoHandle(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

//
// share.c
//

NTSTATUS
ConsoleAddShare(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PCONSOLE_SHARE_ACCESS ShareAccess,
    IN OUT PHANDLE_DATA HandleData
    );


NTSTATUS
ConsoleDupShare(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PCONSOLE_SHARE_ACCESS ShareAccess,
    IN OUT PHANDLE_DATA TargetHandleData
    );


NTSTATUS
ConsoleRemoveShare(
    IN ULONG DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PCONSOLE_SHARE_ACCESS ShareAccess
    );

//
// find.c
//

VOID
DoFind(
   IN PCONSOLE_INFORMATION Console
   );

//
// output.c
//

VOID
ScrollScreen(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT ScrollRect,
    IN PSMALL_RECT MergeRect,
    IN COORD TargetPoint
    );

VOID
SetProcessForegroundRights(
    IN PCSR_PROCESS Process,
    IN BOOL Foreground
    );

VOID
SetProcessFocus(
    IN PCSR_PROCESS Process,
    IN BOOL Foreground
    );

VOID
ModifyConsoleProcessFocus(
    IN PCONSOLE_INFORMATION Console,
    IN BOOL Foreground
    );

VOID
InitializeSystemMetrics( VOID );

VOID
InitializeScreenInfo( VOID );

NTSTATUS
ReadScreenBuffer(
    IN PSCREEN_INFORMATION ScreenInformation,
    OUT PCHAR_INFO Buffer,
    IN OUT PSMALL_RECT ReadRegion
    );

NTSTATUS
WriteScreenBuffer(
    IN PSCREEN_INFORMATION ScreenInformation,
    OUT PCHAR_INFO Buffer,
    IN OUT PSMALL_RECT WriteRegion
    );

NTSTATUS
DoCreateScreenBuffer(
    IN PCONSOLE_INFORMATION Console,
    IN PCONSOLE_INFO ConsoleInfo
    );

NTSTATUS
CreateScreenBuffer(
    OUT PSCREEN_INFORMATION *ScreenInformation,
    IN COORD dwWindowSize OPTIONAL,
    IN DWORD nFont OPTIONAL,
    IN COORD dwScreenBufferSize OPTIONAL,
    IN CHAR_INFO Fill,
    IN CHAR_INFO PopupFill,
    IN PCONSOLE_INFORMATION Console,
    IN DWORD Flags,
    IN PCONSOLE_GRAPHICS_BUFFER_INFO GraphicsBufferInfo OPTIONAL,
    OUT PVOID *lpBitmap,
    OUT HANDLE *hMutex,
    IN UINT CursorSize,
    IN LPWSTR FaceName
    );

VOID
AbortCreateConsole(
    IN PCONSOLE_INFORMATION Console
    );

NTSTATUS
CreateWindowsWindow(
    IN PCONSOLE_INFORMATION Console
    );

VOID
DestroyWindowsWindow(
    IN PCONSOLE_INFORMATION Console
    );

NTSTATUS
FreeScreenBuffer(
    IN PSCREEN_INFORMATION ScreenInformation
    );

NTSTATUS
ReadOutputString(
    IN PSCREEN_INFORMATION ScreenInfo,
    OUT PVOID Buffer,
    IN COORD ReadCoord,
    IN ULONG StringType,
    IN OUT PULONG NumRecords // this value is valid even for error cases
    );

NTSTATUS
InitializeScrollBuffer( VOID );

NTSTATUS
GetScreenBufferInformation(
    IN PSCREEN_INFORMATION ScreenInfo,
    OUT PCOORD Size,
    OUT PCOORD CursorPosition,
    OUT PCOORD ScrollPosition,
    OUT PWORD  Attributes,
    OUT PCOORD CurrentWindowSize,
    OUT PCOORD MaximumWindowSize
    );

VOID
GetWindowLimits(
    IN PSCREEN_INFORMATION ScreenInfo,
    OUT PWINDOW_LIMITS WindowLimits
    );

NTSTATUS
ResizeWindow(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT WindowDimensions,
    IN BOOL DoScrollBarUpdate
    );

NTSTATUS
ResizeScreenBuffer(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN COORD NewScreenSize,
    IN BOOL DoScrollBarUpdate
    );

NTSTATUS
ScrollRegion(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT ScrollRectangle,
    IN PSMALL_RECT ClipRectangle OPTIONAL,
    IN COORD  DestinationOrigin,
    IN CHAR_INFO Fill
    );

NTSTATUS
SetWindowOrigin(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN BOOLEAN Absolute,
    IN OUT COORD  WindowOrigin
    );

VOID
SetWindowSize(
    IN PSCREEN_INFORMATION ScreenInfo
    );

NTSTATUS
SetActiveScreenBuffer(
    IN PSCREEN_INFORMATION ScreenInfo
    );

NTSTATUS
QueueConsoleMessage(
    PCONSOLE_INFORMATION Console,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

VOID
ConsoleNotifyWinEvent(
    IN PCONSOLE_INFORMATION Console,
    IN DWORD Event,
    IN LONG idObjectType,
    IN LONG idObject);

LRESULT APIENTRY
ConsoleWindowProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

VOID
VerticalScroll(
    IN PCONSOLE_INFORMATION Console,
    IN PSCREEN_INFORMATION ScreenInfo,
    IN WORD ScrollCommand,
    IN WORD AbsoluteChange
    );

VOID
HorizontalScroll(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN WORD ScrollCommand,
    IN WORD AbsoluteChange
    );

VOID
StreamScrollRegion(
    IN PSCREEN_INFORMATION ScreenInfo
    );

#if defined(FE_SB)
VOID
FindAttrIndex(
    IN PATTR_PAIR String,
    IN SHORT Index,
    OUT PATTR_PAIR *IndexedAttr,
    OUT PSHORT CountOfAttr
    );

VOID
UpdateComplexRegion(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN COORD FontSize
    );

SHORT
ScrollEntireScreen(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN SHORT ScrollValue,
    IN BOOL UpdateRowIndex
    );

VOID
UpdateScrollBars(
    IN PSCREEN_INFORMATION ScreenInfo
    );
#endif

VOID
ReadRectFromScreenBuffer(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN COORD SourcePoint,
    IN PCHAR_INFO Target,
    IN COORD TargetSize,
    IN PSMALL_RECT TargetRect
    );


VOID
InitializeThreadMessages(VOID);

NTSTATUS
QueueThreadMessage(
    DWORD dwThreadId,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
UnqueueThreadMessage(
    DWORD dwThreadId,
    UINT* pMessage,
    WPARAM* pwParam,
    LPARAM* plParam
    );


//
// Drag/Drop on console windows (output.c)
//

UINT ConsoleDragQueryFile(
    IN HANDLE hDrop,
    IN PVOID lpFile,
    IN UINT cb
    );


VOID
DoDrop (
    IN WPARAM wParam,
    IN PCONSOLE_INFORMATION Console
    );


//
// input.c
//

NTSTATUS
ReadBuffer(
    IN PINPUT_INFORMATION InputInformation,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG EventsRead,
    IN BOOL Peek,
    IN BOOL StreamRead,
    OUT PBOOL ResetWaitEvent,
    IN BOOLEAN Unicode
    );

VOID
ConsoleInputThread(
    IN PINPUT_THREAD_INIT_INFO pInputThreadInitInfo
    );

VOID
StoreKeyInfo(
    IN PMSG msg
    );

VOID
RetrieveKeyInfo(
    IN HWND hWnd,
    OUT PWORD pwVirtualKeyCode,
    OUT PWORD pwVirtualScanCode,
    IN BOOL FreeKeyInfo
    );

VOID
ClearKeyInfo(
    IN HWND hWnd
    );

NTSTATUS
ReadInputBuffer(
    IN PINPUT_INFORMATION InputInformation,
    OUT PINPUT_RECORD lpBuffer,
    IN OUT PDWORD nLength,
    IN BOOL Peek,
    IN BOOL WaitForData,
    IN BOOL StreamRead,
    IN PCONSOLE_INFORMATION Console,
    IN PHANDLE_DATA HandleData OPTIONAL,
    IN PCSR_API_MSG Message OPTIONAL,
    IN CSR_WAIT_ROUTINE WaitRoutine OPTIONAL,
    IN PVOID WaitParameter OPTIONAL,
    IN ULONG WaitParameterLength  OPTIONAL,
    IN BOOLEAN WaitBlockExists OPTIONAL
#if defined(FE_SB)
    ,
    IN BOOLEAN Unicode
#endif
    );

DWORD
WriteInputBuffer(
    PCONSOLE_INFORMATION Console,
    PINPUT_INFORMATION InputBufferInformation,
    PINPUT_RECORD lpBuffer,
    DWORD nLength
    );

DWORD
PrependInputBuffer(
    PCONSOLE_INFORMATION Console,
    PINPUT_INFORMATION InputBufferInformation,
    PINPUT_RECORD lpBuffer,
    DWORD nLength
    );

NTSTATUS
CreateInputBuffer(
    IN ULONG NumberOfEvents OPTIONAL,
    IN PINPUT_INFORMATION InputBufferInformation
#if defined(FE_SB)
    ,
    IN PCONSOLE_INFORMATION Console
#endif
    );

NTSTATUS
ReinitializeInputBuffer(
    OUT PINPUT_INFORMATION InputBufferInformation
    );

VOID
FreeInputBuffer(
    IN PINPUT_INFORMATION InputBufferInformation
    );

#if defined(FE_SB)
VOID
ProcessCreateConsoleWindow(
    IN LPMSG lpMsg
    );

NTSTATUS
WaitForMoreToRead(
    IN PINPUT_INFORMATION InputInformation,
    IN PCSR_API_MSG Message OPTIONAL,
    IN CSR_WAIT_ROUTINE WaitRoutine OPTIONAL,
    IN PVOID WaitParameter OPTIONAL,
    IN ULONG WaitParameterLength  OPTIONAL,
    IN BOOLEAN WaitBlockExists OPTIONAL
    );

ULONG
GetControlKeyState(
    LPARAM lParam
    );

VOID
TerminateRead(
    IN PCONSOLE_INFORMATION Console,
    IN PINPUT_INFORMATION InputInfo,
    IN DWORD Flag
    );
#endif

NTSTATUS
GetNumberOfReadyEvents(
    IN PINPUT_INFORMATION InputInformation,
    OUT PULONG NumberOfEvents
    );

NTSTATUS
FlushInputBuffer(
    IN PINPUT_INFORMATION InputInformation
    );

NTSTATUS
FlushAllButKeys(
    PINPUT_INFORMATION InputInformation
    );

NTSTATUS
SetInputBufferSize(
    IN PINPUT_INFORMATION InputInformation,
    IN ULONG Size
    );

BOOL
HandleSysKeyEvent(
    IN PCONSOLE_INFORMATION Console,
    IN HWND hWnd,
    IN UINT Message,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

VOID
HandleKeyEvent(
    IN PCONSOLE_INFORMATION Console,
    IN HWND hWnd,
    IN UINT Message,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

BOOL
HandleMouseEvent(
    IN PCONSOLE_INFORMATION Console,
    IN PSCREEN_INFORMATION ScreenInfo,
    IN UINT Message,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

VOID
HandleMenuEvent(
    IN PCONSOLE_INFORMATION Console,
    IN DWORD wParam
    );

VOID
HandleFocusEvent(
    IN PCONSOLE_INFORMATION Console,
    IN BOOL bSetFocus
    );

VOID
HandleCtrlEvent(
    IN PCONSOLE_INFORMATION Console,
    IN DWORD EventType
    );

#define CONSOLE_SHUTDOWN_FAILED 0
#define CONSOLE_SHUTDOWN_SUCCEEDED 1
#define CONSOLE_SHUTDOWN_SYSTEM 2

int
CreateCtrlThread(
    IN PCONSOLE_PROCESS_TERMINATION_RECORD ProcessHandleList,
    IN ULONG ProcessHandleListLength,
    IN PWCHAR Title,
    IN DWORD EventType,
    IN BOOL fForce
    );

VOID
UnlockConsole(
    IN PCONSOLE_INFORMATION Console
    );

ULONG
ShutdownConsole(
    IN HANDLE ConsoleHandle,
    IN DWORD dwFlags
    );

//
// link.c
//

#define LINK_NOINFO      0
#define LINK_SIMPLEINFO  1
#define LINK_FULLINFO    2

DWORD
GetLinkProperties(
    LPWSTR pszLinkName,
    LPVOID lpvBuffer,
    UINT cb
   );

DWORD
GetTitleFromLinkName(
    IN  LPWSTR szLinkName,
    OUT LPWSTR szTitle
    );

//
// misc.c
//

VOID
InitializeFonts( VOID );

BOOL
InitializeCustomCP( VOID );

#define EF_NEW         0x0001 // a newly available face
#define EF_OLD         0x0002 // a previously available face
#define EF_ENUMERATED  0x0004 // all sizes have been enumerated
#define EF_OEMFONT     0x0008 // an OEM face
#define EF_TTFONT      0x0010 // a TT face
#define EF_DEFFACE     0x0020 // the default face

NTSTATUS
EnumerateFonts( DWORD Flags );

VOID
InitializeMouseButtons( VOID );

NTSTATUS
GetMouseButtons(
    PULONG NumButtons
    );

NTSTATUS
FindTextBufferFontInfo(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN UINT CodePage,
    OUT PTEXT_BUFFER_FONT_INFO TextFontInfo
    );

NTSTATUS
StoreTextBufferFontInfo(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN ULONG FontIndex,
    IN COORD FontSize,
    IN BYTE  FontFamily,
    IN LONG  FontWeight,
    IN LPWSTR FaceName,
    IN UINT CodePage
    );

NTSTATUS
RemoveTextBufferFontInfo(
    IN PSCREEN_INFORMATION ScreenInfo
    );

NTSTATUS
GetNumFonts(
    OUT PULONG NumberOfFonts
    );

NTSTATUS
GetAvailableFonts(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN BOOLEAN MaximumWindow,
    OUT PVOID Buffer,
    IN OUT PULONG NumFonts
    );

NTSTATUS
GetFontSize(
    IN DWORD  FontIndex,
    OUT PCOORD FontSize
    );

NTSTATUS
GetCurrentFont(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN BOOLEAN MaximumWindow,
    OUT PULONG FontIndex,
    OUT PCOORD FontSize
    );

NTSTATUS
SetFont(
    IN PSCREEN_INFORMATION ScreenInfo
    );

NTSTATUS
SetScreenBufferFont(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN ULONG FontIndex
#if defined(FE_SB)
    ,
    IN UINT CodePage
#endif
    );

int
ConvertToOem(
    IN UINT Codepage,
    IN LPWSTR Source,
    IN int SourceLength,
    OUT LPSTR Target,
    IN int TargetLength
    );

int
ConvertInputToUnicode(
    IN UINT Codepage,
    IN LPSTR Source,
    IN int SourceLength,
    OUT LPWSTR Target,
    IN int TargetLength
    );

#if defined(FE_SB)
WCHAR
SB_CharToWcharGlyph(
    IN UINT Codepage,
    IN char Ch
    );

WCHAR
SB_CharToWchar(
    IN UINT Codepage,
    IN char Ch
    );

#else
WCHAR
CharToWcharGlyph(
    IN UINT Codepage,
    IN char Ch
    );

WCHAR
CharToWchar(
    IN UINT Codepage,
    IN char Ch
    );
#endif

char
WcharToChar(
    IN UINT Codepage,
    IN WCHAR Wchar
    );

int
ConvertOutputToUnicode(
    IN UINT Codepage,
    IN LPSTR Source,
    IN int SourceLength,
    OUT LPWSTR Target,
    IN int TargetLength
    );

int
ConvertOutputToOem(
    IN UINT Codepage,
    IN LPWSTR Source,
    IN int SourceLength,    // in chars
    OUT LPSTR Target,
    IN int TargetLength     // in chars
    );

NTSTATUS
RealUnicodeToFalseUnicode(
    IN OUT LPWSTR Source,
    IN int SourceLength, // in chars
    IN UINT Codepage
    );

NTSTATUS
FalseUnicodeToRealUnicode(
    IN OUT LPWSTR Source,
    IN int SourceLength, // in chars
    IN UINT Codepage
    );

VOID
InitializeSubst( VOID );

VOID
ShutdownSubst( VOID );

ULONG
SrvConsoleSubst(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

typedef struct tagFACENODE {
     struct tagFACENODE *pNext;
     DWORD  dwFlag;
     WCHAR  awch[];
} FACENODE, *PFACENODE;

BOOL DoFontEnum(
    IN HDC hDC OPTIONAL,
    IN LPWSTR pwszFace OPTIONAL,
    IN SHORT TTPointSize);

#if defined(FE_SB)
VOID
SetConsoleCPInfo(
    IN PCONSOLE_INFORMATION Console,
    IN BOOL Output
    );

BOOL
CheckBisectStringW(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN DWORD CodePage,
    IN PWCHAR Buffer,
    IN DWORD NumWords,
    IN DWORD NumBytes
    );

BOOL
CheckBisectProcessW(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN DWORD CodePage,
    IN PWCHAR Buffer,
    IN DWORD NumWords,
    IN DWORD NumBytes,
    IN SHORT OriginalXPosition,
    IN BOOL Echo
    );
#endif // FE_SB

//
// directio.c
//


ULONG
SrvGetConsoleInput(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvWriteConsoleInput(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvReadConsoleOutput(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvWriteConsoleOutput(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvReadConsoleOutputString(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvWriteConsoleOutputString(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvFillConsoleOutput(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvCreateConsoleScreenBuffer(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

NTSTATUS
TranslateOutputToPaddingUnicode(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size,
    IN OUT PCHAR_INFO OutputBufferR
    );

//
// getset.c
//

ULONG
SrvGetConsoleMode(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvGetConsoleNumberOfFonts(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvGetConsoleNumberOfInputEvents(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvGetLargestConsoleWindowSize(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvGetConsoleScreenBufferInfo(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvGetConsoleCursorInfo(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvGetConsoleSelectionInfo(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvGetConsoleMouseInfo(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvGetConsoleFontInfo(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvGetConsoleFontSize(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvGetConsoleCurrentFont(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvSetConsoleMode(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvGenerateConsoleCtrlEvent(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvSetConsoleActiveScreenBuffer(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvFlushConsoleInputBuffer(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvSetConsoleScreenBufferSize(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvSetConsoleCursorPosition(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvSetConsoleCursorInfo(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvSetConsoleWindowInfo(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvScrollConsoleScreenBuffer(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvSetConsoleTextAttribute(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvSetConsoleFont(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvSetConsoleIcon(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

NTSTATUS
SetScreenColors(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN WORD Attributes,
    IN WORD PopupAttributes,
    IN BOOL UpdateWholeScreen
    );

ULONG
SrvSetConsoleCP(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvGetConsoleCP(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvGetConsoleKeyboardLayoutName(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvGetConsoleWindow(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );


//
// stream.c
//

NTSTATUS
CookedRead(
    IN PCOOKED_READ_DATA CookedReadData,
    IN PCSR_API_MSG WaitReplyMessage,
    IN PCSR_THREAD WaitingThread,
    IN BOOLEAN WaitRoutine
    );

NTSTATUS
ReadChars(
    IN PINPUT_INFORMATION InputInfo,
    IN PCONSOLE_INFORMATION Console,
    IN PCONSOLE_PER_PROCESS_DATA ProcessData,
    IN PSCREEN_INFORMATION ScreenInfo,
    IN OUT PWCHAR lpBuffer,
    IN OUT PDWORD NumBytes,
    IN DWORD InitialNumBytes,
    IN DWORD CtrlWakeupMask,
    IN PHANDLE_DATA HandleData,
    IN PCOMMAND_HISTORY CommandHistory,
    IN PCSR_API_MSG Message OPTIONAL,
    IN HANDLE HandleIndex,
    IN USHORT ExeNameLength,
    IN PWCHAR ExeName,
    IN BOOLEAN Unicode
    );

ULONG
SrvOpenConsole(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvReadConsole(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvWriteConsole(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvDuplicateHandle(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvGetHandleInformation(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvSetHandleInformation(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

VOID
UnblockWriteConsole(
    IN PCONSOLE_INFORMATION Console,
    IN DWORD Reason);

NTSTATUS
CloseInputHandle(
    IN PCONSOLE_PER_PROCESS_DATA ProcessData,
    IN PCONSOLE_INFORMATION Console,
    IN PHANDLE_DATA HandleData,
    IN HANDLE Handle
    );

NTSTATUS
CloseOutputHandle(
    IN PCONSOLE_PER_PROCESS_DATA ProcessData,
    IN PCONSOLE_INFORMATION Console,
    IN PHANDLE_DATA HandleData,
    IN HANDLE Handle,
    IN BOOLEAN FreeHandle
    );

ULONG
SrvCloseHandle(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

VOID
MakeCursorVisible(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN COORD CursorPosition
    );

#if defined(FE_SB)
HANDLE
FindActiveScreenBufferHandle(
    IN PCONSOLE_PER_PROCESS_DATA ProcessData,
    IN PCONSOLE_INFORMATION Console
    );

NTSTATUS
WriteString(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PWCHAR String,
    IN ULONG NumChars,
    IN BOOL KeepCursorVisible,
    OUT PSHORT ScrollY OPTIONAL
    );
#endif

//
// cursor.c
//

NTSTATUS
SetCursorInformation(
    PSCREEN_INFORMATION ScreenInfo,
    ULONG Size,
    BOOLEAN Visible
    );

NTSTATUS
SetCursorPosition(
    IN OUT PSCREEN_INFORMATION ScreenInfo,
    IN COORD Position,
    IN BOOL  TurnOn
    );

NTSTATUS
SetCursorMode(
    PSCREEN_INFORMATION ScreenInfo,
    BOOLEAN DoubleCursor
    );

VOID
CursorTimerRoutine(
    IN PSCREEN_INFORMATION ScreenInfo
    );

#if defined(FE_SB)
VOID
SB_InvertPixels(
    IN PSCREEN_INFORMATION ScreenInfo
    );
#endif

VOID
ConsoleHideCursor(
    IN PSCREEN_INFORMATION ScreenInfo
    );

VOID
ConsoleShowCursor(
    IN PSCREEN_INFORMATION ScreenInfo
    );

#ifdef i386
NTSTATUS
SetCursorInformationHW(
    PSCREEN_INFORMATION ScreenInfo,
    ULONG Size,
    BOOLEAN Visible
    );

NTSTATUS
SetCursorPositionHW(
    IN OUT PSCREEN_INFORMATION ScreenInfo,
    IN COORD Position
    );
#endif

//
// cmdline.c
//

VOID
InitializeConsoleCommandData(
    IN PCONSOLE_INFORMATION Console
    );

ULONG
SrvAddConsoleAlias(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvGetConsoleAlias(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

DWORD
SrvGetConsoleAliasesLength(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

DWORD
SrvGetConsoleAliasExesLength(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

DWORD
SrvGetConsoleAliases(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

DWORD
SrvGetConsoleAliasExes(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

DWORD
SrvExpungeConsoleCommandHistory(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

DWORD
SrvSetConsoleNumberOfCommands(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

DWORD
SrvGetConsoleCommandHistoryLength(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

DWORD
SrvGetConsoleCommandHistory(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

DWORD
SrvSetConsoleCommandHistoryMode(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

NTSTATUS
MatchandCopyAlias(
    IN PCONSOLE_INFORMATION Console,
    IN PWCHAR Source,
    IN USHORT SourceLength,
    OUT PWCHAR TargetBuffer,
    IN OUT PUSHORT TargetLength,
    IN LPWSTR Exe,
    IN USHORT ExeLength,
    OUT PDWORD LineCount
    );

NTSTATUS
AddCommand(
    IN PCOMMAND_HISTORY CommandHistory,
    IN PWCHAR Command,
    IN USHORT Length,
    IN BOOL HistoryNoDup
    );

NTSTATUS
RetrieveCommand(
    IN PCOMMAND_HISTORY CommandHistory,
    IN WORD VirtualKeyCode,
    IN PWCHAR Buffer,
    IN ULONG BufferSize,
    OUT PULONG CommandSize
    );

PCOMMAND_HISTORY
AllocateCommandHistory(
    IN PCONSOLE_INFORMATION Console,
    IN DWORD AppNameLength,
    IN PWCHAR AppName,
    IN HANDLE ProcessHandle
    );

VOID
ResetCommandHistory(
    IN PCOMMAND_HISTORY CommandHistory
    );

ULONG
SrvGetConsoleTitle(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvSetConsoleTitle(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

VOID
FreeAliasBuffers(
    IN PCONSOLE_INFORMATION Console
    );

VOID
FreeCommandHistory(
    IN PCONSOLE_INFORMATION Console,
    IN HANDLE ProcessHandle
    );

VOID
FreeCommandHistoryBuffers(
    IN OUT PCONSOLE_INFORMATION Console
    );

VOID
ResizeCommandHistoryBuffers(
    IN PCONSOLE_INFORMATION Console,
    IN UINT NumCommands
    );

int
MyStringCompareW(
    IN LPWSTR Str1,
    IN LPWSTR Str2,
    IN USHORT Length,
    IN BOOLEAN bCaseInsensitive
    );

int
LoadStringExW(
    IN HINSTANCE hModule,
    IN UINT      wID,
    OUT LPWSTR   lpBuffer,
    IN int       cchBufferMax,
    IN WORD      wLangId
    );

//
// srvinit.c
//

ULONG
SrvAllocConsole(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvFreeConsole(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvAttachConsole(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvGetConsoleProcessList(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

NTSTATUS
RemoveConsole(
    IN PCONSOLE_PER_PROCESS_DATA ProcessData,
    IN HANDLE ProcessHandle,
    IN HANDLE ProcessId
    );

BOOL
MapHandle(
    IN HANDLE ClientProcessHandle,
    IN HANDLE ServerHandle,
    OUT PHANDLE ClientHandle
    );

VOID
InitializeConsoleAttributes( VOID );

VOID
GetRegistryValues(
    IN LPWSTR ConsoleTitle,
    OUT PCONSOLE_REGISTRY_INFO RegInfo
    );

#if defined(FE_SB)
NTSTATUS
MyRegOpenKey(
    IN HANDLE hKey,
    IN LPWSTR lpSubKey,
    OUT PHANDLE phResult
    );

NTSTATUS
MyRegQueryValue(
    IN HANDLE hKey,
    IN LPWSTR lpValueName,
    IN DWORD dwValueLength,
    OUT LPBYTE lpData
    );

NTSTATUS
MyRegQueryValueEx(
    IN HANDLE hKey,
    IN LPWSTR lpValueName,
    IN DWORD dwValueLength,
    OUT LPBYTE lpData,
    OUT LPDWORD lpDataLength
    );

NTSTATUS
MyRegEnumValue(
    IN HANDLE hKey,
    IN DWORD dwIndex,
    OUT DWORD dwValueLength,
    OUT LPWSTR lpValueName,
    OUT DWORD dwDataLength,
    OUT LPBYTE lpData
    );
#endif

LPWSTR
TranslateConsoleTitle(
    LPWSTR ConsoleTitle,
    PUSHORT pcbTranslatedLength,
    BOOL Unexpand,
    BOOL Substitute
    );

NTSTATUS
GetConsoleLangId(
    IN UINT OutputCP,
    OUT LANGID* pLangId
    );

ULONG
SrvGetConsoleLangId(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

//
// bitmap.c
//

NTSTATUS
CreateConsoleBitmap(
    IN OUT PCONSOLE_GRAPHICS_BUFFER_INFO GraphicsInfo,
    IN OUT PSCREEN_INFORMATION ScreenInfo,
    OUT PVOID *lpBitmap,
    OUT HANDLE *hMutex
    );

NTSTATUS
WriteRegionToScreenBitMap(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT Region
    );

ULONG
SrvInvalidateBitMapRect(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvVDMConsoleOperation(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );


//
// private.c
//

VOID
UpdateMousePosition(
    PSCREEN_INFORMATION ScreenInfo,
    COORD Position
    );

ULONG
SrvSetConsoleCursor(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvShowConsoleCursor(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvConsoleMenuControl(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvSetConsolePalette(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvSetConsoleDisplayMode(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

VOID
SetActivePalette(
    IN PSCREEN_INFORMATION ScreenInfo
    );

VOID
UnsetActivePalette(
    IN PSCREEN_INFORMATION ScreenInfo
    );

ULONG
SrvRegisterConsoleVDM(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

NTSTATUS
SrvConsoleNotifyLastClose(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvGetConsoleHardwareState(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvSetConsoleHardwareState(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvGetConsoleDisplayMode(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvSetConsoleMenuClose(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvSetConsoleKeyShortcuts(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

#ifdef i386

VOID
ReadRegionFromScreenHW(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT Region,
    IN PCHAR_INFO ReadBufPtr
    );

VOID
ScrollHW(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT ScrollRect,
    IN PSMALL_RECT MergeRect,
    IN COORD TargetPoint
    );

ULONG
MatchWindowSize(
#if defined(FE_SB)
    IN UINT CodePage,
#endif
    IN COORD WindowSize,
    OUT PCOORD pWindowSize
    );

BOOL
SetVideoMode(
    IN PSCREEN_INFORMATION ScreenInfo
    );

NTSTATUS
DisplayModeTransition(
    IN BOOL Foreground,
    IN PCONSOLE_INFORMATION Console,
    IN PSCREEN_INFORMATION ScreenInfo
    );

NTSTATUS
ConvertToWindowed(
    IN PCONSOLE_INFORMATION Console
    );

NTSTATUS
ConvertToFullScreen(
    IN PCONSOLE_INFORMATION Console
    );

NTSTATUS
SetROMFontCodePage(
    IN UINT wCodePage,
    IN ULONG ModeIndex
    );

#endif

BOOL
InitializeFullScreen( VOID );

NTSTATUS
ChangeDispSettings(
    PCONSOLE_INFORMATION Console,
    HWND hwnd,
    DWORD dwFlags
    );

#define SCREEN_BUFFER_POINTER(X,Y,XSIZE,CELLSIZE) (((XSIZE * (Y)) + (X)) * (ULONG)CELLSIZE)

//
// menu.c
//

VOID
InitSystemMenu(
    IN PCONSOLE_INFORMATION Console
    );

VOID
InitializeMenu(
    IN PCONSOLE_INFORMATION Console
    );

VOID
SetWinText(
    IN PCONSOLE_INFORMATION Console,
    IN UINT wID,
    IN BOOL Add
    );

VOID
PropertiesDlgShow(
    IN PCONSOLE_INFORMATION Console,
    IN BOOL fCurrent
    );

VOID
PropertiesUpdate(
    IN PCONSOLE_INFORMATION Console,
    IN HANDLE hClientSection
    );

//
// fontdlg.c
//

int
FindCreateFont(
    DWORD Family,
    LPWSTR pwszTTFace,
    COORD Size,
    LONG Weight,
    UINT CodePage);

//
// clipbrd.c
//

VOID
DoCopy(
    IN PCONSOLE_INFORMATION Console
    );

VOID
DoMark(
    IN PCONSOLE_INFORMATION Console
    );

VOID
DoSelectAll(
    IN PCONSOLE_INFORMATION Console
    );

VOID
DoStringPaste(
    IN PCONSOLE_INFORMATION Console,
    IN PWCHAR pwStr,
    IN UINT DataSize
    );

VOID
DoPaste(
    IN PCONSOLE_INFORMATION Console
    );

VOID
InitializeMouseSelection(
    IN PCONSOLE_INFORMATION Console,
    IN COORD CursorPosition
    );

VOID
ExtendSelection(
    IN PCONSOLE_INFORMATION Console,
    IN COORD CursorPosition
    );

VOID
ClearSelection(
    IN PCONSOLE_INFORMATION Console
    );

VOID
StoreSelection(
    IN PCONSOLE_INFORMATION Console
    );

VOID
ColorSelection(
    IN PCONSOLE_INFORMATION Console,
    IN ULONG                Attr
    );

VOID
InvertSelection(
    IN PCONSOLE_INFORMATION Console,
    BOOL Inverting
    );

#if defined(FE_SB)
BOOL
SB_MyInvert(
    IN PCONSOLE_INFORMATION Console,
    IN PSMALL_RECT SmallRect
    );
#else
BOOL
MyInvert(
    IN PCONSOLE_INFORMATION Console,
    IN PSMALL_RECT SmallRect
    );
#endif

VOID
ConvertToMouseSelect(
    IN PCONSOLE_INFORMATION Console,
    IN COORD MousePosition
    );

VOID
DoScroll(
    IN PCONSOLE_INFORMATION Console
    );

VOID
ClearScroll(
    IN PCONSOLE_INFORMATION Console
    );


//
// External private functions used by consrv
//

BOOL
SetConsoleReserveKeys(
    HWND hWnd,
    DWORD fsReserveKeys
    );

int APIENTRY
GreGetDIBitsInternal(
    HDC hdc,
    HBITMAP hBitmap,
    UINT iStartScan,
    UINT cNumScan,
    LPBYTE pjBits,
    LPBITMAPINFO pBitsInfo,
    UINT iUsage,
    UINT cjMaxBits,
    UINT cjMaxInfo
    );


#if defined(FE_SB)
//
// constubs.c
//
ULONG
SrvGetConsoleCharType(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvSetConsoleLocalEUDC(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );


ULONG
SrvSetConsoleCursorMode(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvGetConsoleCursorMode(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvRegisterConsoleOS2(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvSetConsoleOS2OemFormat(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

#if defined(FE_IME)
ULONG
SrvGetConsoleNlsMode(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvSetConsoleNlsMode(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvRegisterConsoleIME(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );

ULONG
SrvUnregisterConsoleIME(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    );
#endif // FE_IME

//
// dispatch.c
//

VOID
InvertPixels(
    IN PSCREEN_INFORMATION ScreenInfo
    );

WCHAR
CharToWchar(
    IN PCONSOLE_INFORMATION Console,
    IN UINT Codepage,
    IN char *Ch
    );

BOOL
MyInvert(
    IN PCONSOLE_INFORMATION Console,
    IN PSMALL_RECT SmallRect
    );

#endif // FE_SB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\server\convarea.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    convarea.c

Abstract:

Author:

    KazuM Mar.8,1993

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#if defined(FE_IME)




VOID
LinkConversionArea(
    IN PCONSOLE_INFORMATION Console,
    IN PCONVERSIONAREA_INFORMATION ConvAreaInfo
    )
{
    PCONVERSIONAREA_INFORMATION PrevConvAreaInfo;

    if (Console->ConsoleIme.ConvAreaRoot == NULL) {
        Console->ConsoleIme.ConvAreaRoot = ConvAreaInfo;
    }
    else {
        PrevConvAreaInfo = Console->ConsoleIme.ConvAreaRoot;
        while (PrevConvAreaInfo->ConvAreaNext)
            PrevConvAreaInfo = PrevConvAreaInfo->ConvAreaNext;
        PrevConvAreaInfo->ConvAreaNext = ConvAreaInfo;
    }
}


NTSTATUS
FreeConvAreaScreenBuffer(
    IN PSCREEN_INFORMATION ScreenInfo
    )

/*++

Routine Description:

    This routine frees the memory associated with a screen buffer.

Arguments:

    ScreenInfo - screen buffer data to free.

Return Value:

Note: console handle table lock must be held when calling this routine

--*/

{
    return FreeScreenBuffer(ScreenInfo);
}



NTSTATUS
AllocateConversionArea(
    IN PCONSOLE_INFORMATION Console,
    IN COORD dwScreenBufferSize,
    OUT PCONVERSIONAREA_INFORMATION *ConvAreaInfo
    )
{
    COORD dwWindowSize;
    CHAR_INFO Fill, PopupFill;
    PCONVERSIONAREA_INFORMATION ca;
    int FontIndex;
    NTSTATUS Status;

    //
    // allocate console data
    //

    if (Console->CurrentScreenBuffer == NULL) {
        return STATUS_UNSUCCESSFUL;
    }

    ca = (PCONVERSIONAREA_INFORMATION)ConsoleHeapAlloc(
                                                MAKE_TAG( CONVAREA_TAG ),
                                                sizeof(CONVERSIONAREA_INFORMATION));
    if (ca == NULL) {
        return STATUS_NO_MEMORY;
    }

    dwWindowSize.X = CONSOLE_WINDOW_SIZE_X(Console->CurrentScreenBuffer);
    dwWindowSize.Y = CONSOLE_WINDOW_SIZE_Y(Console->CurrentScreenBuffer);
    Fill.Attributes = Console->CurrentScreenBuffer->Attributes;
    PopupFill.Attributes = Console->CurrentScreenBuffer->PopupAttributes;
    FontIndex = FindCreateFont(CON_FAMILY(Console),
                               CON_FACENAME(Console),
                               CON_FONTSIZE(Console),
                               CON_FONTWEIGHT(Console),
                               CON_FONTCODEPAGE(Console)
                              );
    Status = CreateScreenBuffer(&ca->ScreenBuffer,
                                dwWindowSize,
                                FontIndex,
                                dwScreenBufferSize,
                                Fill,
                                PopupFill,
                                Console,
                                CONSOLE_TEXTMODE_BUFFER,
                                NULL,
                                NULL,
                                NULL,
                                CURSOR_SMALL_SIZE,
                                NULL
                               );
    if (!NT_SUCCESS(Status)) {
        ConsoleHeapFree(ca);
        return Status;
    }

    *ConvAreaInfo = ca;

    return STATUS_SUCCESS;
}



NTSTATUS
SetUpConversionArea(
    IN PCONSOLE_INFORMATION Console,
    IN COORD coordCaBuffer,
    IN SMALL_RECT rcViewCaWindow,
    IN COORD coordConView,
    IN DWORD dwOption,
    OUT PCONVERSIONAREA_INFORMATION *ConvAreaInfo
    )
{
    NTSTATUS Status;
    PCONVERSIONAREA_INFORMATION ca;

    Status = AllocateConversionArea(Console, coordCaBuffer, &ca);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    ca->ConversionAreaMode    = dwOption;
    ca->CaInfo.coordCaBuffer  = coordCaBuffer;
    ca->CaInfo.rcViewCaWindow = rcViewCaWindow;
    ca->CaInfo.coordConView   = coordConView;

    ca->ConvAreaNext = NULL;

    ca->ScreenBuffer->ConvScreenInfo = ca;

    LinkConversionArea(Console, ca);

    SetUndetermineAttribute( Console ) ;

    *ConvAreaInfo = ca;

    return STATUS_SUCCESS;
}










VOID
WriteConvRegionToScreen(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PCONVERSIONAREA_INFORMATION ConvAreaInfo,
    IN PSMALL_RECT ConvRegion
    )

/*++

Routine Description:

Arguments:

    ClippedRegion - Rectangle of region by screen coordinate.

Return Value:

--*/

{
    SMALL_RECT Region;
    SMALL_RECT ClippedRegion;

    if (ScreenInfo->Console->CurrentScreenBuffer->Flags & CONSOLE_GRAPHICS_BUFFER)
        return;

    while (ConvAreaInfo) {

        if ((ConvAreaInfo->ConversionAreaMode & (CA_HIDDEN+CA_HIDE_FOR_SCROLL))==0) {
            //
            // Do clipping region
            //
            Region.Left   = ScreenInfo->Window.Left +
                            ConvAreaInfo->CaInfo.rcViewCaWindow.Left +
                            ConvAreaInfo->CaInfo.coordConView.X;
            Region.Right  = Region.Left +
                            (ConvAreaInfo->CaInfo.rcViewCaWindow.Right -
                             ConvAreaInfo->CaInfo.rcViewCaWindow.Left);
            Region.Top    = ScreenInfo->Window.Top +
                            ConvAreaInfo->CaInfo.rcViewCaWindow.Top +
                            ConvAreaInfo->CaInfo.coordConView.Y;
            Region.Bottom = Region.Top +
                            (ConvAreaInfo->CaInfo.rcViewCaWindow.Bottom -
                             ConvAreaInfo->CaInfo.rcViewCaWindow.Top);
            ClippedRegion.Left   = max(Region.Left,   ScreenInfo->Window.Left);
            ClippedRegion.Top    = max(Region.Top,    ScreenInfo->Window.Top);
            ClippedRegion.Right  = min(Region.Right,  ScreenInfo->Window.Right);
            ClippedRegion.Bottom = min(Region.Bottom, ScreenInfo->Window.Bottom);
            if (ClippedRegion.Right < ClippedRegion.Left ||
                ClippedRegion.Bottom < ClippedRegion.Top) {
                ;
            }
            else {
                Region = ClippedRegion;
                ClippedRegion.Left   = max(Region.Left,   ConvRegion->Left);
                ClippedRegion.Top    = max(Region.Top,    ConvRegion->Top);
                ClippedRegion.Right  = min(Region.Right,  ConvRegion->Right);
                ClippedRegion.Bottom = min(Region.Bottom, ConvRegion->Bottom);
                if (ClippedRegion.Right < ClippedRegion.Left ||
                    ClippedRegion.Bottom < ClippedRegion.Top) {
                    ;
                }
                else {
                    ConvAreaInfo->ScreenBuffer->BufferInfo.TextInfo.Flags &= ~TEXT_VALID_HINT;
                    ConvAreaInfo->ScreenBuffer->BufferInfo.TextInfo.Flags |= CONSOLE_CONVERSION_AREA_REDRAW;
                    WriteRegionToScreen(ConvAreaInfo->ScreenBuffer,
                                        &ClippedRegion
                                       );
                    ConvAreaInfo->ScreenBuffer->BufferInfo.TextInfo.Flags &= ~CONSOLE_CONVERSION_AREA_REDRAW;
                }
            }
        }
        ConvAreaInfo = ConvAreaInfo->ConvAreaNext;
    }
}


BOOL
ConsoleImeBottomLineUse(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN SHORT ScrollOffset
    )

/*++

Routine Description:

Arguments:

    ScreenInfo -

    ScrollOffset -

Return Value:

--*/

{
    SMALL_RECT ScrollRectangle;
    COORD DestinationOrigin;
    CHAR_INFO Fill;
    PCONVERSIONAREA_INFORMATION ConvAreaInfo;
    SMALL_RECT WriteRegion;
    BOOL fRedraw = FALSE;

    if (!(ScreenInfo->Console->ConsoleIme.ScrollFlag & HIDE_FOR_SCROLL)) {
        ScreenInfo->Console->ConsoleIme.ScrollFlag |= HIDE_FOR_SCROLL;
        if (ConvAreaInfo = ScreenInfo->Console->ConsoleIme.ConvAreaRoot) {
            do {
                if ((ConvAreaInfo->ConversionAreaMode & (CA_STATUS_LINE))==0) {
                    ConvAreaInfo->ConversionAreaMode |= CA_HIDE_FOR_SCROLL;
                    fRedraw = TRUE;
                }
            } while (ConvAreaInfo = ConvAreaInfo->ConvAreaNext);

            if (fRedraw) {
                // Check code for must CONSOLE_TEXTMODE_BUFFER !!
                if (ScreenInfo->Flags & CONSOLE_GRAPHICS_BUFFER)
                {
                    ASSERT(FALSE);
                }
                else {
                    WriteRegion = ScreenInfo->Window;
                    WriteRegion.Bottom--;
                    ScreenInfo->BufferInfo.TextInfo.Flags &= ~TEXT_VALID_HINT;
                    ScreenInfo->BufferInfo.TextInfo.Flags |= CONSOLE_CONVERSION_AREA_REDRAW;
                    WriteToScreen(ScreenInfo,&WriteRegion);
                    ScreenInfo->BufferInfo.TextInfo.Flags &= ~CONSOLE_CONVERSION_AREA_REDRAW;
                }
            }
        }
    }

    if (ScrollOffset) {
        ScrollRectangle.Top = 1 ;
        ScrollRectangle.Left = 0 ;
        ScrollRectangle.Right = ScreenInfo->ScreenBufferSize.X-1;
        ScrollRectangle.Bottom = ScreenInfo->ScreenBufferSize.Y-1;
        ScrollRectangle.Bottom -= (ScrollOffset-1);
        DestinationOrigin.X = ScrollRectangle.Left;
        DestinationOrigin.Y = ScrollRectangle.Top-1;
        Fill.Char.UnicodeChar = '\0';
        Fill.Attributes = 0;
        ScrollRegion(ScreenInfo,
                     &ScrollRectangle,
                     NULL,
                     DestinationOrigin,
                     Fill
                    );
#if defined(FE_SB)
#if defined(FE_IME)
        if ( ! (ScreenInfo->Console->InputBuffer.ImeMode.Disable) &&
             ! (ScreenInfo->Console->InputBuffer.ImeMode.Unavailable) &&
             (ScreenInfo->Console->InputBuffer.ImeMode.Open) &&
             (ScrollRectangle.Left == ScreenInfo->Window.Left) &&
             (ScrollRectangle.Right == ScreenInfo->Window.Right) ) {
            ScrollRectangle.Top = ScreenInfo->Window.Bottom ;
            ScrollRectangle.Bottom = ScreenInfo->Window.Bottom ;
            WriteToScreen(ScreenInfo,&ScrollRectangle);
            WriteConvRegionToScreen(ScreenInfo,
                                    ScreenInfo->Console->ConsoleIme.ConvAreaRoot,
                                    &ScrollRectangle);
        }
#endif
#endif
    }
    else {
        ScreenInfo->Console->ConsoleIme.ScrollWaitCountDown = ScreenInfo->Console->ConsoleIme.ScrollWaitTimeout;
    }
    return TRUE;
}



VOID
ConsoleImeBottomLineInUse(
    IN PSCREEN_INFORMATION ScreenInfo
    )

/*++

Routine Description:

Arguments:

    ScreenInfo -

Return Value:

--*/

{
    PCONVERSIONAREA_INFORMATION ConvAreaInfo;
    SMALL_RECT WriteRegion;
    BOOL fRedraw = FALSE;
    COORD CursorPosition;

    ScreenInfo->Console->ConsoleIme.ScrollFlag &= ~HIDE_FOR_SCROLL;
    if (ConvAreaInfo = ScreenInfo->Console->ConsoleIme.ConvAreaRoot) {
        do {
            if (ConvAreaInfo->ConversionAreaMode & CA_HIDE_FOR_SCROLL) {
                ConvAreaInfo->ConversionAreaMode &= ~CA_HIDE_FOR_SCROLL;
                fRedraw = TRUE;
            }
        } while (ConvAreaInfo = ConvAreaInfo->ConvAreaNext);

        if (fRedraw) {
            // Check code for must CONSOLE_TEXTMODE_BUFFER !!
            if (ScreenInfo->Flags & CONSOLE_GRAPHICS_BUFFER)
            {
                ASSERT(FALSE);
            }
            else {
                if (ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y == (ScreenInfo->ScreenBufferSize.Y-1)) {
                    ConsoleHideCursor(ScreenInfo);
                    ConsoleImeBottomLineUse(ScreenInfo,1);
                    CursorPosition = ScreenInfo->BufferInfo.TextInfo.CursorPosition;
                    CursorPosition.Y--;
                    SetCursorPosition(ScreenInfo,CursorPosition,TRUE);
                    if (ScreenInfo->Console->lpCookedReadData) {
                        ((PCOOKED_READ_DATA)(ScreenInfo->Console->lpCookedReadData))->OriginalCursorPosition.Y--;
                    }
                    ConsoleShowCursor(ScreenInfo);
                }
                else if (ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y == ScreenInfo->Window.Bottom) {
                    ;
                }

                WriteRegion.Top = 0;
                WriteRegion.Bottom = (SHORT)(ScreenInfo->ScreenBufferSize.Y-1);
                WriteRegion.Left = 0;
                WriteRegion.Right = (SHORT)(ScreenInfo->ScreenBufferSize.X-1);
                ScreenInfo->BufferInfo.TextInfo.Flags &= ~TEXT_VALID_HINT;
                ScreenInfo->BufferInfo.TextInfo.Flags |= CONSOLE_CONVERSION_AREA_REDRAW;
                WriteToScreen(ScreenInfo,&WriteRegion);
                ScreenInfo->BufferInfo.TextInfo.Flags &= ~CONSOLE_CONVERSION_AREA_REDRAW;
            }
        }
    }
}



NTSTATUS
CreateConvAreaUndetermine(
    PCONSOLE_INFORMATION Console
    )
{
    PCONSOLE_IME_INFORMATION ConsoleIme = &Console->ConsoleIme;
    NTSTATUS Status;
    COORD coordCaBuffer;
    SMALL_RECT rcViewCaWindow;
    COORD coordConView;
    PCONVERSIONAREA_INFORMATION ConvAreaInfo;

    if (ConsoleIme->ConvAreaCompStr) {
        ConsoleIme->ConvAreaCompStr =
            ConsoleHeapReAlloc(
                        0,
                        ConsoleIme->ConvAreaCompStr,
                        ConsoleHeapSize(
                                 ConsoleIme->ConvAreaCompStr)+sizeof(PCONVERSIONAREA_INFORMATION));
        if (ConsoleIme->ConvAreaCompStr == NULL)
            return STATUS_NO_MEMORY;
    }
    else {
        ConsoleIme->ConvAreaCompStr =
            ConsoleHeapAlloc(
                      MAKE_TAG( CONVAREA_TAG ),
                      sizeof(PCONVERSIONAREA_INFORMATION));
        if (ConsoleIme->ConvAreaCompStr == NULL)
            return STATUS_NO_MEMORY;
    }

    coordCaBuffer = Console->CurrentScreenBuffer->ScreenBufferSize;
    coordCaBuffer.Y = 1;
    rcViewCaWindow.Top    = 0;
    rcViewCaWindow.Left   = 0;
    rcViewCaWindow.Bottom = 0;
    rcViewCaWindow.Right  = 0;
    coordConView.X = 0;
    coordConView.Y = 0;
    Status = SetUpConversionArea(Console,
                                 coordCaBuffer,
                                 rcViewCaWindow,
                                 coordConView,
                                 (Console->ConsoleIme.ScrollFlag & HIDE_FOR_SCROLL) ?
                                     CA_HIDE_FOR_SCROLL :
                                     CA_HIDDEN,
                                 &ConvAreaInfo
                                );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    ConsoleIme->ConvAreaCompStr[ConsoleIme->NumberOfConvAreaCompStr] = ConvAreaInfo;
    ConsoleIme->NumberOfConvAreaCompStr++;

    return Status;
}


NTSTATUS
CreateConvAreaModeSystem(
    PCONSOLE_INFORMATION Console
    )
{
    PCONSOLE_IME_INFORMATION ConsoleIme = &Console->ConsoleIme;
    NTSTATUS Status;
    COORD coordCaBuffer;
    SMALL_RECT rcViewCaWindow;
    COORD coordConView;
    PCONVERSIONAREA_INFORMATION ConvAreaInfo;

    if (Console->CurrentScreenBuffer == NULL) {
        return STATUS_UNSUCCESSFUL;
    }

    /*
     * Create mode text buffer
     */
    coordCaBuffer = Console->CurrentScreenBuffer->ScreenBufferSize;
    coordCaBuffer.Y = 1;
    rcViewCaWindow.Top    = 0;
    rcViewCaWindow.Left   = 0;
    rcViewCaWindow.Bottom = 0;
    rcViewCaWindow.Right  = 0;
    coordConView.X = 0;
    coordConView.Y = 0;
    Status = SetUpConversionArea(Console,
                                 coordCaBuffer,
                                 rcViewCaWindow,
                                 coordConView,
                                 CA_HIDDEN+CA_STATUS_LINE,
                                 &ConvAreaInfo
                                );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    ConsoleIme->ConvAreaMode = ConvAreaInfo;

    /*
     * Create system text buffer
     */
    Status = SetUpConversionArea(Console,
                                 coordCaBuffer,
                                 rcViewCaWindow,
                                 coordConView,
                                 CA_HIDDEN+CA_STATUS_LINE,
                                 &ConvAreaInfo
                                );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    ConsoleIme->ConvAreaSystem = ConvAreaInfo;

    return Status;
}


#define LOCAL_BUFFER_SIZE 100
NTSTATUS
WriteUndetermineChars(
    PCONSOLE_INFORMATION Console,
    LPWSTR lpString,
    PBYTE  lpAtr,
    PWORD  lpAtrIdx,
    DWORD  NumChars  // character count
    )
{
    PSCREEN_INFORMATION ScreenInfo;
    PSCREEN_INFORMATION ConvScreenInfo;
    WCHAR LocalBuffer[LOCAL_BUFFER_SIZE];
    BYTE LocalBufferA[LOCAL_BUFFER_SIZE];
    PWCHAR LocalBufPtr;
    PBYTE LocalBufPtrA;
    DWORD BufferSize;
    COORD Position;
    ULONG i;
    SMALL_RECT Region;
    COORD CursorPosition;
    WCHAR Char;
    WORD Attr;
    PCONSOLE_IME_INFORMATION ConsoleIme;
    PCONVERSIONAREA_INFORMATION ConvAreaInfo;
    DWORD ConvAreaIndex;
    NTSTATUS Status;
    ULONG NumStr ;
    int WholeLen ;
    int WholeRow ;
    SHORT PosY ;
    BOOL UndetAreaUp = FALSE ;

    ConsoleIme = &Console->ConsoleIme;
    ScreenInfo = Console->CurrentScreenBuffer;

    // Check code for must CONSOLE_TEXTMODE_BUFFER !!
    ASSERT(!(ScreenInfo->Flags & CONSOLE_GRAPHICS_BUFFER));

    Position = ScreenInfo->BufferInfo.TextInfo.CursorPosition;

        if ((ScreenInfo->Window.Left <= Position.X && Position.X <= ScreenInfo->Window.Right) &&
            (ScreenInfo->Window.Top  <= Position.Y && Position.Y <= ScreenInfo->Window.Bottom)  ) {
            Position.X = ScreenInfo->BufferInfo.TextInfo.CursorPosition.X - ScreenInfo->Window.Left;
            Position.Y = ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y - ScreenInfo->Window.Top;
        }
        else {
            Position.X = 0;
            Position.Y = CONSOLE_WINDOW_SIZE_Y(ScreenInfo) - 2;
        }

    PosY = Position.Y ;
    RtlUnicodeToMultiByteSize(&NumStr, lpString, NumChars*sizeof(WCHAR));

    WholeLen = (int)Position.X + (int)NumStr ;
    WholeRow = WholeLen / CONSOLE_WINDOW_SIZE_X(ScreenInfo);
    if ( ( PosY + WholeRow ) > ( CONSOLE_WINDOW_SIZE_Y(ScreenInfo) - 2) ) {
        PosY = CONSOLE_WINDOW_SIZE_Y(ScreenInfo) - 2 - WholeRow ;
        if (PosY < 0) {
            PosY = ScreenInfo->Window.Top ;
        }
    }
    if (PosY != Position.Y) {
        Position.Y = PosY ;
        UndetAreaUp = TRUE ;
    }

    ConvAreaIndex = 0;

    BufferSize = NumChars;
    NumChars = 0;

    for (ConvAreaIndex = 0; NumChars < BufferSize; ConvAreaIndex++) {

        if (ConvAreaIndex+1 > ConsoleIme->NumberOfConvAreaCompStr) {
            Status = CreateConvAreaUndetermine(Console);
            if (!NT_SUCCESS(Status)) {
                return Status;
            }
        }
        ConvAreaInfo = ConsoleIme->ConvAreaCompStr[ConvAreaIndex];
        ConvScreenInfo = ConvAreaInfo->ScreenBuffer;
        ConvScreenInfo->BufferInfo.TextInfo.CursorPosition.X = Position.X;

        if ((ConvAreaInfo->ConversionAreaMode & CA_HIDDEN) ||
            (UndetAreaUp)) {
            /*
             * This conversion area need positioning onto cursor position.
             */
            CursorPosition.X = 0;
            CursorPosition.Y = (SHORT)(Position.Y + ConvAreaIndex);
            ConsoleImeViewInfo(Console,ConvAreaInfo,CursorPosition);
        }

        Region.Left = ConvScreenInfo->BufferInfo.TextInfo.CursorPosition.X;
        Region.Top = 0;
        Region.Bottom = 0;

        while (NumChars < BufferSize) {
            i=0;
            LocalBufPtr = LocalBuffer;
            LocalBufPtrA = LocalBufferA;

            while (NumChars < BufferSize &&
                   i < LOCAL_BUFFER_SIZE &&
                   Position.X < CONSOLE_WINDOW_SIZE_X(ScreenInfo)) {
                Char = *lpString;
                Attr = *lpAtr;
                if (Char >= (WCHAR)' ') {
                    if (IsConsoleFullWidth(Console->hDC,Console->OutputCP,Char)) {
                        if (i < (LOCAL_BUFFER_SIZE-1) &&
                            Position.X < CONSOLE_WINDOW_SIZE_X(ScreenInfo)-1) {
                            *LocalBufPtr++ = Char;
                            *LocalBufPtrA++ = ATTR_LEADING_BYTE;
                            *LocalBufPtr++ = Char;
                            *LocalBufPtrA++ = ATTR_TRAILING_BYTE;
                            Position.X+=2;
                            i+=2;
                        }
                        else {
                            Position.X++;
                            break;
                        }
                    }
                    else {
                        *LocalBufPtr++ = Char;
                        *LocalBufPtrA++ = 0;
                        Position.X++;
                        i++;
                    }
                }
                lpString++;
                lpAtr++;
                NumChars++;

                if (NumChars < BufferSize &&
                    Attr != *lpAtr)
                    break;
            }
            if (i != 0) {
                ConvScreenInfo->Attributes = lpAtrIdx[Attr & 0x07];
                if (Attr & 0x10)
                    ConvScreenInfo->Attributes |= (COMMON_LVB_GRID_SINGLEFLAG + COMMON_LVB_GRID_RVERTICAL) ;
                else if (Attr & 0x20)
                    ConvScreenInfo->Attributes |= (COMMON_LVB_GRID_SINGLEFLAG + COMMON_LVB_GRID_LVERTICAL) ;
                StreamWriteToScreenBufferIME(LocalBuffer,
                                          (SHORT)i,
                                          ConvScreenInfo,
                                          LocalBufferA
                                         );

                ConvScreenInfo->BufferInfo.TextInfo.CursorPosition.X += (SHORT)i;

                if (NumChars == BufferSize ||
                    Position.X >= CONSOLE_WINDOW_SIZE_X(ScreenInfo) ||
                    ( (Char >= (WCHAR)' ' &&
                      IsConsoleFullWidth(Console->hDC,Console->OutputCP,Char) &&
                      Position.X >= CONSOLE_WINDOW_SIZE_X(ScreenInfo)-1) )
                   ) {

                    Region.Right = (SHORT)(ConvScreenInfo->BufferInfo.TextInfo.CursorPosition.X - 1);
                    ConsoleImeWindowInfo(Console,ConvAreaInfo,Region);

                    ConvAreaInfo->ConversionAreaMode &= ~CA_HIDDEN;

                    ConsoleImePaint(Console,ConvAreaInfo);

                    Position.X = 0;
                    break;
                }

                if (NumChars == BufferSize) {
                    return STATUS_SUCCESS;
                }
                continue;

            } else if (NumChars == BufferSize) {
                return STATUS_SUCCESS;
            }
            if (!NT_SUCCESS(Status)) {
                return Status;
            }
            if (Position.X >= CONSOLE_WINDOW_SIZE_X(ScreenInfo)) {
                Position.X = 0;
                break;
            }
        }

    }

    for ( ; ConvAreaIndex < ConsoleIme->NumberOfConvAreaCompStr; ConvAreaIndex++) {
        ConvAreaInfo = ConsoleIme->ConvAreaCompStr[ConvAreaIndex];
        if (!(ConvAreaInfo->ConversionAreaMode & CA_HIDDEN)) {
            ConvAreaInfo->ConversionAreaMode |= CA_HIDDEN;
            ConsoleImePaint(Console,ConvAreaInfo);
        }
    }

    return STATUS_SUCCESS;
}


VOID
WriteModeSystemChars(
    PCONSOLE_INFORMATION Console,
    PCONVERSIONAREA_INFORMATION ConvAreaInfo,
    PCHAR_INFO Buffer,
    DWORD NumberOfChars,
    DWORD ViewPosition
    )
{
    SMALL_RECT CharRegion;
    COORD CursorPosition;

    if (Buffer) {
        CharRegion.Left   = 0;
        CharRegion.Top    = 0;
        CharRegion.Right  = CalcWideCharToColumn(Console,Buffer,NumberOfChars);
        CharRegion.Right  = (CharRegion.Right ? CharRegion.Right-1 : 0);
        CharRegion.Bottom = 0;
    }
    else {
        CharRegion = ConvAreaInfo->CaInfo.rcViewCaWindow;
    }
    if (ConvAreaInfo) {
        if (!(ConvAreaInfo->ConversionAreaMode & CA_HIDDEN)) {
            if (CharRegion.Left   != ConvAreaInfo->CaInfo.rcViewCaWindow.Left ||
                CharRegion.Top    != ConvAreaInfo->CaInfo.rcViewCaWindow.Top ||
                CharRegion.Right  != ConvAreaInfo->CaInfo.rcViewCaWindow.Right ||
                CharRegion.Bottom != ConvAreaInfo->CaInfo.rcViewCaWindow.Bottom) {
                switch (ViewPosition) {
                    case VIEW_LEFT:
                        CursorPosition.X = 0;
                        break;
                    case VIEW_RIGHT:
                        CursorPosition.X = CONSOLE_WINDOW_SIZE_X(Console->CurrentScreenBuffer) - (CharRegion.Right + 1);
                        break;
                }
                CursorPosition.Y = CONSOLE_WINDOW_SIZE_Y(Console->CurrentScreenBuffer) - 1;
                ConsoleImeViewInfo(Console,ConvAreaInfo,CursorPosition);

                ConsoleImeWindowInfo(Console,ConvAreaInfo,CharRegion);
            }
        }
        else {
            /*
             * This conversion area need positioning onto cursor position.
             */
            switch (ViewPosition) {
                case VIEW_LEFT:
                    CursorPosition.X = 0;
                    break;
                case VIEW_RIGHT:
                    CursorPosition.X = CONSOLE_WINDOW_SIZE_X(Console->CurrentScreenBuffer) - (CharRegion.Right + 1);
                    break;
            }
            CursorPosition.Y = CONSOLE_WINDOW_SIZE_Y(Console->CurrentScreenBuffer) - 1;
            ConsoleImeViewInfo(Console,ConvAreaInfo,CursorPosition);

            ConsoleImeWindowInfo(Console,ConvAreaInfo,CharRegion);
        }

        if (Buffer) {
            ConvAreaInfo->ConversionAreaMode &= ~CA_HIDDEN;
            ConsoleImeWriteOutput(Console,ConvAreaInfo,Buffer,CharRegion,TRUE);
        }
        else {
            ConsoleImePaint(Console,ConvAreaInfo);
        }
    }
}


NTSTATUS
FillUndetermineChars(
    PCONSOLE_INFORMATION Console,
    PCONVERSIONAREA_INFORMATION ConvAreaInfo
    )
{
    COORD Coord;
    DWORD CharsToWrite;

    ConvAreaInfo->ConversionAreaMode |= CA_HIDDEN;
    Coord.X = 0;
    Coord.Y = 0;
    CharsToWrite = ConvAreaInfo->ScreenBuffer->ScreenBufferSize.X;
    FillOutput(ConvAreaInfo->ScreenBuffer,
               (WCHAR)' ',
               Coord,
               CONSOLE_FALSE_UNICODE, // faster than real unicode
               &CharsToWrite
              );
    CharsToWrite = ConvAreaInfo->ScreenBuffer->ScreenBufferSize.X;
    FillOutput(ConvAreaInfo->ScreenBuffer,
               Console->CurrentScreenBuffer->Attributes,
               Coord,
               CONSOLE_ATTRIBUTE,
               &CharsToWrite
              );
    ConsoleImePaint(Console,ConvAreaInfo);
    return STATUS_SUCCESS;
}


NTSTATUS
ConsoleImeCompStr(
    IN PCONSOLE_INFORMATION Console,
    IN LPCONIME_UICOMPMESSAGE CompStr
    )
{
    UINT i;
    PCONVERSIONAREA_INFORMATION ConvAreaInfo;

    if (CompStr->dwCompStrLen == 0 ||
        CompStr->dwResultStrLen != 0
       ) {

        // Cursor turn ON.
        if ((Console->CurrentScreenBuffer->Flags & CONSOLE_TEXTMODE_BUFFER) &&
             Console->ConsoleIme.SavedCursorVisible                             )
        {
            Console->ConsoleIme.SavedCursorVisible = FALSE;
            SetCursorInformation(Console->CurrentScreenBuffer,
                                 Console->CurrentScreenBuffer->BufferInfo.TextInfo.CursorSize,
                                 TRUE);
        }

        /*
         * Determine string.
         */
        for (i=0; i<Console->ConsoleIme.NumberOfConvAreaCompStr; i++) {
            ConvAreaInfo = Console->ConsoleIme.ConvAreaCompStr[i];
            if (ConvAreaInfo &&
                (!(ConvAreaInfo->ConversionAreaMode & CA_HIDDEN))) {
                FillUndetermineChars(Console,ConvAreaInfo);
            }
        }

        if (CompStr->dwResultStrLen != 0)
        {
            if (!InsertConverTedString(Console, (LPWSTR)((PBYTE)CompStr + CompStr->dwResultStrOffset))) {
                return STATUS_INVALID_HANDLE;
            }
        }
        if (Console->ConsoleIme.CompStrData) {
            ConsoleHeapFree(Console->ConsoleIme.CompStrData);
            Console->ConsoleIme.CompStrData = NULL;
        }
    }
    else {
        LPWSTR lpStr;
        PBYTE  lpAtr;
        PWORD  lpAtrIdx;

        // Cursor turn OFF.
        if ((Console->CurrentScreenBuffer->Flags & CONSOLE_TEXTMODE_BUFFER) &&
             Console->CurrentScreenBuffer->BufferInfo.TextInfo.CursorVisible  )
        {
            Console->ConsoleIme.SavedCursorVisible = TRUE;
            SetCursorInformation(Console->CurrentScreenBuffer,
                                 Console->CurrentScreenBuffer->BufferInfo.TextInfo.CursorSize,
                                 FALSE);
        }

        /*
         * Composition string.
         */
        for (i=0; i<Console->ConsoleIme.NumberOfConvAreaCompStr; i++) {
            ConvAreaInfo = Console->ConsoleIme.ConvAreaCompStr[i];
            if (ConvAreaInfo &&
                (!(ConvAreaInfo->ConversionAreaMode & CA_HIDDEN))) {
                FillUndetermineChars(Console,ConvAreaInfo);
            }
        }

        lpStr = (LPWSTR)((PBYTE)CompStr + CompStr->dwCompStrOffset);
        lpAtr = (PBYTE)CompStr + CompStr->dwCompAttrOffset;
        lpAtrIdx = (PWORD)CompStr->CompAttrColor ;
        WriteUndetermineChars(Console, lpStr, lpAtr, lpAtrIdx, CompStr->dwCompStrLen / sizeof(WCHAR));
    }

    return STATUS_SUCCESS;
}




NTSTATUS
ConsoleImeResizeModeSystemView(
    PCONSOLE_INFORMATION Console,
    SMALL_RECT WindowRect
    )
{
    PCONVERSIONAREA_INFORMATION ConvAreaInfo;
    SMALL_RECT CharRegion;
    COORD CursorPosition;

    /*
     * Mode string
     */

    ConvAreaInfo = Console->ConsoleIme.ConvAreaMode;

    if (ConvAreaInfo &&
        (!(ConvAreaInfo->ConversionAreaMode & CA_HIDDEN))) {
        ConvAreaInfo->ConversionAreaMode |= CA_HIDDEN;
        ConsoleImePaint(Console,ConvAreaInfo);
        CharRegion = ConvAreaInfo->CaInfo.rcViewCaWindow;

        if (Console->ConsoleIme.ConvAreaModePosition == VIEW_LEFT){
            CursorPosition.X = 0;
        }
        else{
            CursorPosition.X = CONSOLE_WINDOW_SIZE_X(Console->CurrentScreenBuffer) - (CharRegion.Right + 1);
        }

        CursorPosition.Y = CONSOLE_WINDOW_SIZE_Y(Console->CurrentScreenBuffer) - 1;
        ConsoleImeViewInfo(Console,ConvAreaInfo,CursorPosition);
        ConsoleImeWindowInfo(Console,ConvAreaInfo,CharRegion);
        ConvAreaInfo->ConversionAreaMode &= ~CA_HIDDEN;

        WriteModeSystemChars(Console,
                             Console->ConsoleIme.ConvAreaMode,
                             NULL,
                             0,
                             Console->ConsoleIme.ConvAreaModePosition);
    }

    /*
     * System string
     */
    ConvAreaInfo = Console->ConsoleIme.ConvAreaSystem;
    if (ConvAreaInfo &&
        (!(ConvAreaInfo->ConversionAreaMode & CA_HIDDEN))) {

        ConvAreaInfo->ConversionAreaMode |= CA_HIDDEN;
        ConsoleImePaint(Console,ConvAreaInfo);

        CharRegion = ConvAreaInfo->CaInfo.rcViewCaWindow;
        CursorPosition.X = 0;
        CursorPosition.Y = CONSOLE_WINDOW_SIZE_Y(Console->CurrentScreenBuffer) - 1;
        ConsoleImeViewInfo(Console,ConvAreaInfo,CursorPosition);
        ConsoleImeWindowInfo(Console,ConvAreaInfo,CharRegion);
        ConvAreaInfo->ConversionAreaMode &= ~CA_HIDDEN;

        WriteModeSystemChars(Console,
                             Console->ConsoleIme.ConvAreaSystem,
                             NULL,
                             0,
                             VIEW_LEFT);
    }

    return STATUS_SUCCESS;
    UNREFERENCED_PARAMETER(WindowRect);
}


NTSTATUS
ConsoleImeResizeCompStrView(
    PCONSOLE_INFORMATION Console,
    SMALL_RECT WindowRect
    )
{
    UINT i;
    PCONVERSIONAREA_INFORMATION ConvAreaInfo;
    LPCONIME_UICOMPMESSAGE CompStr;
    LPWSTR lpStr;
    PBYTE  lpAtr;
    PWORD  lpAtrIdx;

    /*
     * Compositon string
     */
    CompStr = Console->ConsoleIme.CompStrData;
    if (CompStr) {
        for (i=0; i<Console->ConsoleIme.NumberOfConvAreaCompStr; i++) {
            ConvAreaInfo = Console->ConsoleIme.ConvAreaCompStr[i];
            if (ConvAreaInfo &&
                (!(ConvAreaInfo->ConversionAreaMode & CA_HIDDEN))) {
                FillUndetermineChars(Console,ConvAreaInfo);
            }
        }

        lpStr = (LPWSTR)((PBYTE)CompStr + CompStr->dwCompStrOffset);
        lpAtr = (PBYTE)CompStr + CompStr->dwCompAttrOffset;
        lpAtrIdx = (PWORD)CompStr->CompAttrColor ;

        WriteUndetermineChars(Console, lpStr, lpAtr, lpAtrIdx, CompStr->dwCompStrLen / sizeof(WCHAR));
    }
    return STATUS_SUCCESS;
    UNREFERENCED_PARAMETER(WindowRect);
}


NTSTATUS
ConsoleImeResizeModeSystemScreenBuffer(
    PCONSOLE_INFORMATION Console,
    COORD NewScreenSize
    )
{
    NTSTATUS Status;
    PCONVERSIONAREA_INFORMATION ConvAreaInfo;

    /*
     * Mode string
     */
    ConvAreaInfo = Console->ConsoleIme.ConvAreaMode;
    if (ConvAreaInfo) {
        if (!(ConvAreaInfo->ConversionAreaMode & CA_HIDDEN)) {
            ConvAreaInfo->ConversionAreaMode |= CA_HIDDEN;
            ConsoleImePaint(Console,ConvAreaInfo);
            ConvAreaInfo->ConversionAreaMode &= ~CA_HIDDEN;
        }

        Status = ConsoleImeResizeScreenBuffer(ConvAreaInfo->ScreenBuffer,NewScreenSize,ConvAreaInfo);
        if (! NT_SUCCESS(Status))
            return Status;
    }

    /*
     * System string
     */
    ConvAreaInfo = Console->ConsoleIme.ConvAreaSystem;
    if (ConvAreaInfo) {
        if (!(ConvAreaInfo->ConversionAreaMode & CA_HIDDEN)) {
            ConvAreaInfo->ConversionAreaMode |= CA_HIDDEN;
            ConsoleImePaint(Console,ConvAreaInfo);
            ConvAreaInfo->ConversionAreaMode &= ~CA_HIDDEN;
        }

        Status = ConsoleImeResizeScreenBuffer(ConvAreaInfo->ScreenBuffer,NewScreenSize,ConvAreaInfo);
        if (! NT_SUCCESS(Status))
            return Status;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
ConsoleImeResizeCompStrScreenBuffer(
    PCONSOLE_INFORMATION Console,
    COORD NewScreenSize
    )
{
    NTSTATUS Status;
    UINT i;
    PCONVERSIONAREA_INFORMATION ConvAreaInfo;

    /*
     * Compositon string
     */
    for (i=0; i<Console->ConsoleIme.NumberOfConvAreaCompStr; i++) {
        ConvAreaInfo = Console->ConsoleIme.ConvAreaCompStr[i];

        if (ConvAreaInfo) {
            if (!(ConvAreaInfo->ConversionAreaMode & CA_HIDDEN)) {
                ConvAreaInfo->ConversionAreaMode |= CA_HIDDEN;
                ConsoleImePaint(Console,ConvAreaInfo);
            }

            Status = ConsoleImeResizeScreenBuffer(ConvAreaInfo->ScreenBuffer,NewScreenSize,ConvAreaInfo);
            if (! NT_SUCCESS(Status))
                return Status;
        }

    }
    return STATUS_SUCCESS;
}


SHORT
CalcWideCharToColumn(
    IN PCONSOLE_INFORMATION Console,
    IN PCHAR_INFO Buffer,
    IN DWORD NumberOfChars
    )
{
    SHORT Column = 0;

    while (NumberOfChars--) {
        if (IsConsoleFullWidth(Console->hDC,Console->OutputCP,Buffer->Char.UnicodeChar))
            Column += 2;
        else
            Column++;
        Buffer++;
    }
    return Column;
}













LONG
ConsoleImePaint(
    IN PCONSOLE_INFORMATION Console,
    IN PCONVERSIONAREA_INFORMATION ConvAreaInfo
    )

/*++

    This routine

--*/

{
    PSCREEN_INFORMATION ScreenInfo;
    SMALL_RECT WriteRegion;
    COORD CursorPosition;

    if (!ConvAreaInfo)
        return FALSE;

    ScreenInfo = Console->CurrentScreenBuffer;
    if (!ScreenInfo)
        return FALSE;

    // Check code for must CONSOLE_TEXTMODE_BUFFER !!
    ASSERT(!(ScreenInfo->Flags & CONSOLE_GRAPHICS_BUFFER));

    WriteRegion.Left   = ScreenInfo->Window.Left
                         + ConvAreaInfo->CaInfo.coordConView.X
                         + ConvAreaInfo->CaInfo.rcViewCaWindow.Left;
    WriteRegion.Right  = WriteRegion.Left
                         + (ConvAreaInfo->CaInfo.rcViewCaWindow.Right - ConvAreaInfo->CaInfo.rcViewCaWindow.Left);
    WriteRegion.Top    = ScreenInfo->Window.Top
                         + ConvAreaInfo->CaInfo.coordConView.Y
                         + ConvAreaInfo->CaInfo.rcViewCaWindow.Top;
    WriteRegion.Bottom = WriteRegion.Top
                         + (ConvAreaInfo->CaInfo.rcViewCaWindow.Bottom - ConvAreaInfo->CaInfo.rcViewCaWindow.Top);

    if ((ConvAreaInfo->ConversionAreaMode & (CA_HIDDEN+CA_STATUS_LINE))==(CA_STATUS_LINE)) {
        if (ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y == (ScreenInfo->ScreenBufferSize.Y-1)) {
            ConsoleHideCursor(ScreenInfo);
            ConsoleImeBottomLineUse(ScreenInfo,1);
            CursorPosition = ScreenInfo->BufferInfo.TextInfo.CursorPosition;
            CursorPosition.Y--;
            SetCursorPosition(ScreenInfo,CursorPosition,TRUE);
            if (ScreenInfo->Console->lpCookedReadData) {
                ((PCOOKED_READ_DATA)(ScreenInfo->Console->lpCookedReadData))->OriginalCursorPosition.Y--;
            }
            ConsoleShowCursor(ScreenInfo);
        }
        else if (ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y == ScreenInfo->Window.Bottom) {
            WriteRegion.Top    = ScreenInfo->Window.Top
                                 + ConvAreaInfo->CaInfo.coordConView.Y
                                 + ConvAreaInfo->CaInfo.rcViewCaWindow.Top;
            WriteRegion.Bottom = WriteRegion.Top
                                 + (ConvAreaInfo->CaInfo.rcViewCaWindow.Bottom - ConvAreaInfo->CaInfo.rcViewCaWindow.Top);
        }
    }

    ScreenInfo->BufferInfo.TextInfo.Flags &= ~TEXT_VALID_HINT;
    ScreenInfo->BufferInfo.TextInfo.Flags |= CONSOLE_CONVERSION_AREA_REDRAW;
    if (!(ConvAreaInfo->ConversionAreaMode & (CA_HIDDEN | CA_HIDE_FOR_SCROLL))) {
        WriteConvRegionToScreen(ScreenInfo,
                                ConvAreaInfo,
                                &WriteRegion
                               );
    }
    else {
        WriteToScreen(ScreenInfo,&WriteRegion);
    }
    ScreenInfo->BufferInfo.TextInfo.Flags &= ~CONSOLE_CONVERSION_AREA_REDRAW;

    return TRUE;
}

VOID
ConsoleImeViewInfo(
    IN PCONSOLE_INFORMATION Console,
    IN PCONVERSIONAREA_INFORMATION ConvAreaInfo,
    IN COORD coordConView
    )
{
    SMALL_RECT OldRegion;
    SMALL_RECT NewRegion;

    if (ConvAreaInfo->ConversionAreaMode & CA_HIDDEN) {
        ConvAreaInfo->CaInfo.coordConView = coordConView;
        NewRegion = ConvAreaInfo->CaInfo.rcViewCaWindow;
        NewRegion.Left   += ConvAreaInfo->CaInfo.coordConView.X;
        NewRegion.Right  += ConvAreaInfo->CaInfo.coordConView.X;
        NewRegion.Top    += ConvAreaInfo->CaInfo.coordConView.Y;
        NewRegion.Bottom += ConvAreaInfo->CaInfo.coordConView.Y;
    }
    else {
        OldRegion = ConvAreaInfo->CaInfo.rcViewCaWindow;
        OldRegion.Left   += ConvAreaInfo->CaInfo.coordConView.X;
        OldRegion.Right  += ConvAreaInfo->CaInfo.coordConView.X;
        OldRegion.Top    += ConvAreaInfo->CaInfo.coordConView.Y;
        OldRegion.Bottom += ConvAreaInfo->CaInfo.coordConView.Y;
        ConvAreaInfo->CaInfo.coordConView = coordConView;

        // Check code for must CONSOLE_TEXTMODE_BUFFER !!
        ASSERT(!(Console->CurrentScreenBuffer->Flags & CONSOLE_GRAPHICS_BUFFER));

        Console->CurrentScreenBuffer->BufferInfo.TextInfo.Flags &= ~TEXT_VALID_HINT;
        Console->CurrentScreenBuffer->BufferInfo.TextInfo.Flags |= CONSOLE_CONVERSION_AREA_REDRAW;
        WriteToScreen(Console->CurrentScreenBuffer,&OldRegion);

        NewRegion = ConvAreaInfo->CaInfo.rcViewCaWindow;
        NewRegion.Left   += ConvAreaInfo->CaInfo.coordConView.X;
        NewRegion.Right  += ConvAreaInfo->CaInfo.coordConView.X;
        NewRegion.Top    += ConvAreaInfo->CaInfo.coordConView.Y;
        NewRegion.Bottom += ConvAreaInfo->CaInfo.coordConView.Y;
        Console->CurrentScreenBuffer->BufferInfo.TextInfo.Flags &= ~TEXT_VALID_HINT;
        WriteToScreen(Console->CurrentScreenBuffer,&NewRegion);
        Console->CurrentScreenBuffer->BufferInfo.TextInfo.Flags &= ~CONSOLE_CONVERSION_AREA_REDRAW;
    }
}

VOID
ConsoleImeWindowInfo(
    IN PCONSOLE_INFORMATION Console,
    IN PCONVERSIONAREA_INFORMATION ConvAreaInfo,
    IN SMALL_RECT rcViewCaWindow
    )
{
    if (rcViewCaWindow.Left   != ConvAreaInfo->CaInfo.rcViewCaWindow.Left ||
        rcViewCaWindow.Top    != ConvAreaInfo->CaInfo.rcViewCaWindow.Top ||
        rcViewCaWindow.Right  != ConvAreaInfo->CaInfo.rcViewCaWindow.Right ||
        rcViewCaWindow.Bottom != ConvAreaInfo->CaInfo.rcViewCaWindow.Bottom) {
        if (!(ConvAreaInfo->ConversionAreaMode & CA_HIDDEN)) {
            ConvAreaInfo->ConversionAreaMode |= CA_HIDDEN;
            ConsoleImePaint(Console,ConvAreaInfo);

            ConvAreaInfo->CaInfo.rcViewCaWindow = rcViewCaWindow;
            ConvAreaInfo->ConversionAreaMode &= ~CA_HIDDEN;
            ConvAreaInfo->ScreenBuffer->BisectFlag &= ~(BISECT_LEFT | BISECT_RIGHT | BISECT_TOP | BISECT_BOTTOM);
            ConsoleImePaint(Console,ConvAreaInfo);
        }
        else
            ConvAreaInfo->CaInfo.rcViewCaWindow = rcViewCaWindow;
    }
}

NTSTATUS
ConsoleImeResizeScreenBuffer(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN COORD NewScreenSize,
    PCONVERSIONAREA_INFORMATION ConvAreaInfo
    )
{
    NTSTATUS Status;

    Status = ResizeScreenBuffer(ScreenInfo,
                                NewScreenSize,
                                FALSE);
    if (NT_SUCCESS(Status)) {
        ConvAreaInfo->CaInfo.coordCaBuffer = NewScreenSize;
        if (ConvAreaInfo->CaInfo.rcViewCaWindow.Left   > NewScreenSize.X-1)
            ConvAreaInfo->CaInfo.rcViewCaWindow.Left   = NewScreenSize.X-1;
        if (ConvAreaInfo->CaInfo.rcViewCaWindow.Right  > NewScreenSize.X-1)
            ConvAreaInfo->CaInfo.rcViewCaWindow.Right  = NewScreenSize.X-1;
        if (ConvAreaInfo->CaInfo.rcViewCaWindow.Top    > NewScreenSize.Y-1)
            ConvAreaInfo->CaInfo.rcViewCaWindow.Top    = NewScreenSize.Y-1;
        if (ConvAreaInfo->CaInfo.rcViewCaWindow.Bottom > NewScreenSize.Y-1)
            ConvAreaInfo->CaInfo.rcViewCaWindow.Bottom = NewScreenSize.Y-1;

    }

    return Status;
}

NTSTATUS
ConsoleImeWriteOutput(
    IN PCONSOLE_INFORMATION Console,
    IN PCONVERSIONAREA_INFORMATION ConvAreaInfo,
    IN PCHAR_INFO Buffer,
    IN SMALL_RECT CharRegion,
    IN BOOL fUnicode
    )
{
    NTSTATUS Status;
    PSCREEN_INFORMATION ScreenInfo;
    COORD BufferSize;
    SMALL_RECT ConvRegion;
    COORD CursorPosition;

    BufferSize.X = (SHORT)(CharRegion.Right - CharRegion.Left + 1);
    BufferSize.Y = (SHORT)(CharRegion.Bottom - CharRegion.Top + 1);

    ConvRegion = CharRegion;

    ScreenInfo = ConvAreaInfo->ScreenBuffer;

    if (!fUnicode) {
        TranslateOutputToUnicode(Console,
                                 Buffer,
                                 BufferSize
                                );
        Status = WriteScreenBuffer(ScreenInfo,
                                   Buffer,
                                   &ConvRegion
                                  );
    } else {
        CHAR_INFO StackBuffer[STACK_BUFFER_SIZE * 2];
        PCHAR_INFO TransBuffer;
        BOOL StackBufferF = FALSE;

        if (BufferSize.Y * BufferSize.X <= STACK_BUFFER_SIZE) {
            TransBuffer = StackBuffer;
            StackBufferF = TRUE;
        } else {
            TransBuffer = (PCHAR_INFO)ConsoleHeapAlloc(MAKE_TAG( TMP_DBCS_TAG ),(BufferSize.Y * BufferSize.X) * 2 * sizeof(CHAR_INFO));
            if (TransBuffer == NULL) {
                return STATUS_NO_MEMORY;
            }
        }
        if ((Console->CurrentScreenBuffer->Flags & CONSOLE_OEMFONT_DISPLAY) &&
                ((Console->FullScreenFlags & CONSOLE_FULLSCREEN) == 0)) {
            TranslateOutputToAnsiUnicode(Console,
                                         Buffer,
                                         BufferSize,
                                         &TransBuffer[0]
                                        );
        }
        else {
            TranslateOutputToPaddingUnicode(Console,
                                            Buffer,
                                            BufferSize,
                                            &TransBuffer[0]
                                           );
        }

        Status = WriteScreenBuffer(ScreenInfo,
                                   &TransBuffer[0],
                                   &ConvRegion
                                  );
        if (!StackBufferF)
            ConsoleHeapFree(TransBuffer);
    }

    if (NT_SUCCESS(Status)) {

        ScreenInfo = Console->CurrentScreenBuffer;


        // Check code for must CONSOLE_TEXTMODE_BUFFER !!
        if (ScreenInfo->Flags & CONSOLE_GRAPHICS_BUFFER) {
            ASSERT(FALSE);
        }
        else if ((ConvAreaInfo->ConversionAreaMode & (CA_HIDDEN+CA_STATUS_LINE))==(CA_STATUS_LINE)) {
            if (ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y == (ScreenInfo->ScreenBufferSize.Y-1)
               )
            {
                ConsoleHideCursor(ScreenInfo);
                ConsoleImeBottomLineUse(ScreenInfo,1);
                CursorPosition = ScreenInfo->BufferInfo.TextInfo.CursorPosition;
                CursorPosition.Y--;
                SetCursorPosition(ScreenInfo,CursorPosition,TRUE);
                if (ScreenInfo->Console->lpCookedReadData) {
                    ((PCOOKED_READ_DATA)(ScreenInfo->Console->lpCookedReadData))->OriginalCursorPosition.Y--;
                }
                ConsoleShowCursor(ScreenInfo);
            }
            else if (ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y == ScreenInfo->Window.Bottom) {
                COORD WindowOrigin ;
                WindowOrigin.X = ScreenInfo->Window.Left ;
                WindowOrigin.Y = ScreenInfo->Window.Top+1 ;
                SetWindowOrigin(ScreenInfo, TRUE, WindowOrigin) ;
                if ( ! (ScreenInfo->Console->InputBuffer.ImeMode.Disable) &&
                     ! (ScreenInfo->Console->InputBuffer.ImeMode.Unavailable) &&
                     (ScreenInfo->Console->InputBuffer.ImeMode.Open) ) {
                    SMALL_RECT Rectangle;
                    Rectangle.Left = ScreenInfo->Window.Left ;
                    Rectangle.Right = ScreenInfo->Window.Right ;
                    Rectangle.Top = ScreenInfo->Window.Bottom ;
                    Rectangle.Bottom = ScreenInfo->Window.Bottom ;
                    ScreenInfo->BufferInfo.TextInfo.Flags &= ~TEXT_VALID_HINT;
                    WriteToScreen(ScreenInfo,&Rectangle);
                    ScreenInfo->BufferInfo.TextInfo.Flags |= TEXT_VALID_HINT;
                    WriteConvRegionToScreen(ScreenInfo,
                                            ScreenInfo->Console->ConsoleIme.ConvAreaRoot,
                                            &Rectangle);
                }
            }
        }

        //
        // cause screen to be updated
        //
        ConvRegion.Left   += (ScreenInfo->Window.Left + ConvAreaInfo->CaInfo.coordConView.X);
        ConvRegion.Right  += (ScreenInfo->Window.Left + ConvAreaInfo->CaInfo.coordConView.X);
        ConvRegion.Top    += (ScreenInfo->Window.Top + ConvAreaInfo->CaInfo.coordConView.Y);
        ConvRegion.Bottom += (ScreenInfo->Window.Top + ConvAreaInfo->CaInfo.coordConView.Y);


        // Check code for must CONSOLE_TEXTMODE_BUFFER !!
        if (ScreenInfo->Flags & CONSOLE_GRAPHICS_BUFFER) {
            ASSERT(FALSE);
        }
        else
            ScreenInfo->BufferInfo.TextInfo.Flags &= ~TEXT_VALID_HINT;
        WriteConvRegionToScreen(ScreenInfo,
                                ConvAreaInfo,
                                &ConvRegion
                               );
        ConvAreaInfo->ScreenBuffer->BisectFlag &= ~(BISECT_LEFT | BISECT_RIGHT | BISECT_TOP | BISECT_BOTTOM);
    }
    return Status;
}








NTSTATUS
ImeControl(
    IN PCONSOLE_INFORMATION Console,
    IN HWND hWndConsoleIME,
    IN PCOPYDATASTRUCT lParam
    )

/*++

Routine Description:

    This routine handle WM_COPYDATA message.

Arguments:

    Console - Pointer to console information structure.

    wParam -

    lParam -

Return Value:

--*/

{
    PSCREEN_INFORMATION ScreenInfo;
    PCONVERSIONAREA_INFORMATION ConvAreaInfo;
    PCHAR_INFO SystemString ;
    DWORD i ;
    DWORD j ;

    if (lParam == NULL) {
        // fail safe.
        return STATUS_SUCCESS;
    }

    ScreenInfo = Console->CurrentScreenBuffer;
    switch ((LONG)lParam->dwData) {
        case CI_CONIMECOMPOSITION:
            if (lParam->cbData >= sizeof(CONIME_UICOMPMESSAGE)) {
                LPCONIME_UICOMPMESSAGE CompStr;

                DBGPRINT(("CONSRV: Get IR_CONIMECOMPOSITION Message\n"));
                CompStr = (LPCONIME_UICOMPMESSAGE)lParam->lpData;
                if (CompStr && CompStr->dwSize == lParam->cbData) {
                    if (Console->ConsoleIme.CompStrData)
                        ConsoleHeapFree(Console->ConsoleIme.CompStrData);
                    Console->ConsoleIme.CompStrData = ConsoleHeapAlloc(
                                                                MAKE_TAG( IME_TAG ),
                                                                CompStr->dwSize);
                    if (Console->ConsoleIme.CompStrData == NULL)
                        break;
                    memmove(Console->ConsoleIme.CompStrData,CompStr,CompStr->dwSize);
                    ConsoleImeCompStr(Console, Console->ConsoleIme.CompStrData);
                }
            }
            break;
        case CI_CONIMEMODEINFO:
            if (lParam->cbData == sizeof(CONIME_UIMODEINFO)) {
                LPCONIME_UIMODEINFO lpModeInfo ;

                DBGPRINT(("CONSRV: Get IR_CONIMEMODEINFO Message\n"));

                lpModeInfo = (LPCONIME_UIMODEINFO)lParam->lpData ;
                if (lpModeInfo != NULL) {
                    if (! Console->InputBuffer.ImeMode.Disable) {
                        if (lpModeInfo->ModeStringLen != 0){
                            for (j = 0 ; j < lpModeInfo->ModeStringLen ; j++ )
                                lpModeInfo->ModeString[j].Attributes = Console->CurrentScreenBuffer->Attributes ;
                            Console->ConsoleIme.ConvAreaModePosition = lpModeInfo->Position;
                            WriteModeSystemChars(Console,
                                                 Console->ConsoleIme.ConvAreaMode,
                                                 (PCHAR_INFO)&lpModeInfo->ModeString,
                                                 lpModeInfo->ModeStringLen,
                                                 Console->ConsoleIme.ConvAreaModePosition);
                        }
                        else{
                            ConvAreaInfo = Console->ConsoleIme.ConvAreaMode;
                            if (ConvAreaInfo &&
                                (!(ConvAreaInfo->ConversionAreaMode & CA_HIDDEN))) {
                                FillUndetermineChars(Console,ConvAreaInfo);
                            }
                            ConvAreaInfo = Console->ConsoleIme.ConvAreaSystem ;
                            if (ConvAreaInfo &&
                                (!(ConvAreaInfo->ConversionAreaMode & CA_HIDDEN))) {
                                FillUndetermineChars(Console,ConvAreaInfo);
                            }
                        }
                    }
                }
            }
            break;
        case CI_CONIMESYSINFO: {
            PWCHAR SourceString ;

            DBGPRINT(("CONSRV: Get IR_CONIMESYSINFO Message\n"));

            if ((lParam->cbData != 0) &&
                (lParam->lpData != NULL) &&
                (! Console->InputBuffer.ImeMode.Disable)) {
                i = (lParam->cbData / sizeof(WCHAR))-1 ;
                SourceString = ((LPCONIME_UIMESSAGE)(lParam->lpData))->String ;
                SystemString = (PCHAR_INFO)ConsoleHeapAlloc(
                                                 MAKE_TAG( IME_TAG ),
                                                 sizeof(CHAR_INFO)*i) ;
                if (SystemString == NULL) {
                    break ;
                }
                for (j = 0 ; j < i ; j++ ) {
                    SystemString[j].Char.UnicodeChar = *SourceString ;
                    SystemString[j].Attributes = Console->CurrentScreenBuffer->Attributes ;
                    SourceString++ ;
                }
                WriteModeSystemChars(Console,
                                     Console->ConsoleIme.ConvAreaSystem,
                                     (PCHAR_INFO)SystemString,
                                     i,
                                     VIEW_LEFT);
                ConsoleHeapFree(SystemString);
            }
            else {
                ConvAreaInfo = Console->ConsoleIme.ConvAreaSystem ;
                if (ConvAreaInfo &&
                    (!(ConvAreaInfo->ConversionAreaMode & CA_HIDDEN))) {
                    FillUndetermineChars(Console,ConvAreaInfo);
                }
            }
            break;
        }
        case CI_CONIMECANDINFO:{
            PWCHAR SourceString;
            PUCHAR SourceAttr;
            DWORD LengthToWrite;
            LPCONIME_CANDMESSAGE CandInfo = (LPCONIME_CANDMESSAGE)(lParam->lpData);

            DBGPRINT(("CONSRV: Get IR_CONIMESYSINFO Message\n"));

            if ((lParam->cbData != 0) &&
                (CandInfo != NULL) ){
                SourceString = CandInfo->String;
                SourceAttr = (PUCHAR)((PBYTE)CandInfo + CandInfo->AttrOff);
                LengthToWrite = lstrlenW(SourceString);
                SystemString = (PCHAR_INFO)ConsoleHeapAlloc(
                                                 MAKE_TAG( IME_TAG ),
                                                 sizeof(CHAR_INFO) * LengthToWrite);
                if (SystemString == NULL) {
                    break ;
                }
                for (j = 0 ; j < LengthToWrite ; j++ ) {
                    SystemString[j].Char.UnicodeChar = *SourceString ;
                    if (*SourceAttr == 1 &&
                        Console->ConsoleIme.CompStrData != NULL) {
                        SystemString[j].Attributes = Console->ConsoleIme.CompStrData->CompAttrColor[1];
                    }
                    else {
                        SystemString[j].Attributes = Console->CurrentScreenBuffer->Attributes ;
                    }
                    SourceString++ ;
                    SourceAttr++ ;
                }
                WriteModeSystemChars(Console,
                                     Console->ConsoleIme.ConvAreaSystem,
                                     (PCHAR_INFO)SystemString,
                                     LengthToWrite,
                                     VIEW_LEFT);
                ConsoleHeapFree(SystemString);
            }
            else {
                ConvAreaInfo = Console->ConsoleIme.ConvAreaSystem;
                if (ConvAreaInfo) {
                    SMALL_RECT rcViewCaWindow = {0, 0, 0, 0};
                    FillUndetermineChars(Console,ConvAreaInfo);
                    ConvAreaInfo->ConversionAreaMode |= CA_HIDDEN;
                    ConsoleImeWindowInfo(Console,ConvAreaInfo,rcViewCaWindow);
                }
            }
            break;
        }
        case CI_CONIMEPROPERTYINFO:{
            WPARAM* wParam = (WPARAM*)(lParam->lpData);

            if ((lParam->cbData != 0) &&
                (wParam != NULL) ){
                switch (*wParam) {
                    case IMS_OPENPROPERTYWINDOW:
                        Console->InputBuffer.hWndConsoleIME = hWndConsoleIME;
                        break;
                    case IMS_CLOSEPROPERTYWINDOW:
                        Console->InputBuffer.hWndConsoleIME = NULL;
                        SetFocus(Console->hWnd);
                        break;
                }
            }
            break;
        }
    }

    return STATUS_SUCCESS;
}

BOOL
InsertConverTedString(
    IN PCONSOLE_INFORMATION Console,
    LPWSTR lpStr
    )
{
    ULONG EventsWritten;
    PINPUT_RECORD InputEvent,TmpInputEvent;
    DWORD dwControlKeyState;
    DWORD dwLen;
    DWORD dwConversion;
    BOOL fResult = FALSE;

    // Check code for must CONSOLE_TEXTMODE_BUFFER !!
    if (Console->CurrentScreenBuffer->Flags & CONSOLE_GRAPHICS_BUFFER) {
        ASSERT(FALSE);
    }
    else if(Console->CurrentScreenBuffer->BufferInfo.TextInfo.CursorOn){
        CursorTimerRoutine(Console->CurrentScreenBuffer) ;
    }

    dwLen = wcslen(lpStr)+1;
    InputEvent = ConsoleHeapAlloc(MAKE_TAG( IME_TAG ),sizeof(INPUT_RECORD)*dwLen);
    if (InputEvent == NULL) {
        return FALSE;
    }

    TmpInputEvent = InputEvent;
    dwControlKeyState = GetControlKeyState(0);

    if (!NT_SUCCESS(GetImeKeyState(Console, &dwConversion))) {
        goto skip_and_return;
    }

    dwControlKeyState |= ImmConversionToConsole(dwConversion);

    while (*lpStr) {
        TmpInputEvent->EventType = KEY_EVENT;
        TmpInputEvent->Event.KeyEvent.bKeyDown = TRUE;
        TmpInputEvent->Event.KeyEvent.wVirtualKeyCode = 0;
        TmpInputEvent->Event.KeyEvent.wVirtualScanCode = 0;
        TmpInputEvent->Event.KeyEvent.dwControlKeyState = dwControlKeyState;
        TmpInputEvent->Event.KeyEvent.uChar.UnicodeChar = *lpStr++;
        TmpInputEvent->Event.KeyEvent.wRepeatCount = 1;
        TmpInputEvent++;
    }

    EventsWritten = WriteInputBuffer( Console,
                                      &Console->InputBuffer,
                                      InputEvent,
                                      dwLen-1
                                     );

    fResult = TRUE;

skip_and_return:
    ConsoleHeapFree(InputEvent);
    return fResult;
}


VOID
SetUndetermineAttribute(
    IN PCONSOLE_INFORMATION Console
    )
{

    PSCREEN_INFORMATION ScreenInfo;
    PCONVERSIONAREA_INFORMATION ConvAreaInfo ;

    ScreenInfo = Console->CurrentScreenBuffer;

    ConvAreaInfo = Console->ConsoleIme.ConvAreaRoot ;
    if (ConvAreaInfo != NULL) {
        do {
            ConvAreaInfo->ScreenBuffer->Attributes = ScreenInfo->Attributes;
            ConvAreaInfo = ConvAreaInfo->ConvAreaNext ;
        } while (ConvAreaInfo != NULL);
    }

    if (Console->ConsoleIme.ConvAreaMode != NULL)
        Console->ConsoleIme.ConvAreaMode->ScreenBuffer->Attributes = ScreenInfo->Attributes;

    if (Console->ConsoleIme.ConvAreaSystem != NULL)
        Console->ConsoleIme.ConvAreaSystem->ScreenBuffer->Attributes = ScreenInfo->Attributes;
}


VOID
StreamWriteToScreenBufferIME(
    IN PWCHAR String,
    IN SHORT StringLength,
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PCHAR StringA
    )
{
    SHORT RowIndex;
    PROW Row;
    PWCHAR Char;
    COORD TargetPoint;

    DBGOUTPUT(("StreamWriteToScreenBuffer\n"));

    // Check code for must CONSOLE_TEXTMODE_BUFFER !!
    ASSERT(!(ScreenInfo->Flags & CONSOLE_GRAPHICS_BUFFER));

    ScreenInfo->BufferInfo.TextInfo.Flags |= TEXT_VALID_HINT;
    TargetPoint = ScreenInfo->BufferInfo.TextInfo.CursorPosition;
    RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+TargetPoint.Y) % ScreenInfo->ScreenBufferSize.Y;
    Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
    DBGOUTPUT(("RowIndex = %lx, Row = %lx, TargetPoint = (%d,%d)\n",
            RowIndex, Row, TargetPoint.X, TargetPoint.Y));

    //
    // copy chars
    //

//#if defined(FE_SB)
    BisectWrite(StringLength,TargetPoint,ScreenInfo);
    if (TargetPoint.Y == ScreenInfo->ScreenBufferSize.Y-1 &&
        TargetPoint.X+StringLength >= ScreenInfo->ScreenBufferSize.X &&
        *(StringA+ScreenInfo->ScreenBufferSize.X-TargetPoint.X-1) & ATTR_LEADING_BYTE
       ) {
        *(String+ScreenInfo->ScreenBufferSize.X-TargetPoint.X-1) = UNICODE_SPACE;
        *(StringA+ScreenInfo->ScreenBufferSize.X-TargetPoint.X-1) = 0;
        if (StringLength > ScreenInfo->ScreenBufferSize.X-TargetPoint.X-1) {
            *(String+ScreenInfo->ScreenBufferSize.X-TargetPoint.X) = UNICODE_SPACE;
            *(StringA+ScreenInfo->ScreenBufferSize.X-TargetPoint.X) = 0;
        }
    }
//#endif
    RtlCopyMemory(&Row->CharRow.Chars[TargetPoint.X],String,StringLength*sizeof(WCHAR));
//#if defined(FE_SB)
    RtlCopyMemory(&Row->CharRow.KAttrs[TargetPoint.X],StringA,StringLength*sizeof(CHAR));
//#endif

    // recalculate first and last non-space char

    Row->CharRow.OldLeft = Row->CharRow.Left;
    if (TargetPoint.X < Row->CharRow.Left) {
//#if defined(FE_SB)
        /*
         * CharRow.Left is leftmost bound of chars in Chars array (array will be full width)
         * i.e. type is COORD
         */
        PWCHAR LastChar = &Row->CharRow.Chars[ScreenInfo->ScreenBufferSize.X-1];
//#else
//        PWCHAR LastChar = &Row->CharRow.Chars[ScreenInfo->ScreenBufferSize.X];
//#endif

        for (Char=&Row->CharRow.Chars[TargetPoint.X];Char < LastChar && *Char==(WCHAR)' ';Char++)
            ;
        Row->CharRow.Left = (SHORT)(Char-Row->CharRow.Chars);
    }

    Row->CharRow.OldRight = Row->CharRow.Right;
    if ((TargetPoint.X+StringLength) >= Row->CharRow.Right) {
        PWCHAR FirstChar = Row->CharRow.Chars;

        for (Char=&Row->CharRow.Chars[TargetPoint.X+StringLength-1];*Char==(WCHAR)' ' && Char >= FirstChar;Char--)
            ;
        Row->CharRow.Right = (SHORT)(Char+1-FirstChar);
    }

    //
    // see if attr string is different.  if so, allocate a new
    // attr buffer and merge the two strings.
    //

    if (Row->AttrRow.Length != 1 ||
        Row->AttrRow.Attrs->Attr != ScreenInfo->Attributes) {
        PATTR_PAIR NewAttrs;
        WORD NewAttrsLength;
        ATTR_PAIR Attrs;

//#if defined(FE_SB) && defined(FE_IME)
        if ((ScreenInfo->Attributes & (COMMON_LVB_GRID_SINGLEFLAG + COMMON_LVB_GRID_RVERTICAL)) ==
            (COMMON_LVB_GRID_SINGLEFLAG + COMMON_LVB_GRID_RVERTICAL)){
            SHORT i ;
            for (i = 0 ; i < StringLength ; i++ ) {
                Attrs.Length = 1 ;
                if (*(StringA + i) & ATTR_LEADING_BYTE)
                    Attrs.Attr = ScreenInfo->Attributes & ~(COMMON_LVB_GRID_SINGLEFLAG + COMMON_LVB_GRID_RVERTICAL) ;
                else
                    Attrs.Attr = ScreenInfo->Attributes & ~COMMON_LVB_GRID_SINGLEFLAG ;

                if (!NT_SUCCESS(MergeAttrStrings(Row->AttrRow.Attrs,
                                 Row->AttrRow.Length,
                                 &Attrs,
                                 1,
                                 &NewAttrs,
                                 &NewAttrsLength,
                                 (SHORT)(TargetPoint.X+i),
                                 (SHORT)(TargetPoint.X+i),
                                 Row,
                                 ScreenInfo
                                ))) {
                    return;
                }
                if (Row->AttrRow.Length > 1) {
                    ConsoleHeapFree(Row->AttrRow.Attrs);
                }
                else {
                    ASSERT(Row->AttrRow.Attrs == &Row->AttrRow.AttrPair);
                }
                Row->AttrRow.Attrs = NewAttrs;
                Row->AttrRow.Length = NewAttrsLength;
            }
            Row->CharRow.OldLeft = INVALID_OLD_LENGTH;
            Row->CharRow.OldRight = INVALID_OLD_LENGTH;
        }
        else if ((ScreenInfo->Attributes & (COMMON_LVB_GRID_SINGLEFLAG + COMMON_LVB_GRID_LVERTICAL)) ==
            (COMMON_LVB_GRID_SINGLEFLAG + COMMON_LVB_GRID_LVERTICAL)){
            SHORT i ;
            for (i = 0 ; i < StringLength ; i++ ) {
                Attrs.Length = 1 ;
                if (*(StringA + i) & ATTR_TRAILING_BYTE)
                    Attrs.Attr = ScreenInfo->Attributes & ~(COMMON_LVB_GRID_SINGLEFLAG + COMMON_LVB_GRID_LVERTICAL);
                else
                    Attrs.Attr = ScreenInfo->Attributes & ~COMMON_LVB_GRID_SINGLEFLAG ;

                if (!NT_SUCCESS(MergeAttrStrings(Row->AttrRow.Attrs,
                                 Row->AttrRow.Length,
                                 &Attrs,
                                 1,
                                 &NewAttrs,
                                 &NewAttrsLength,
                                 (SHORT)(TargetPoint.X+i),
                                 (SHORT)(TargetPoint.X+i),
                                 Row,
                                 ScreenInfo
                                ))) {
                    return;
                }
                if (Row->AttrRow.Length > 1) {
                    ConsoleHeapFree(Row->AttrRow.Attrs);
                }
                else {
                    ASSERT(Row->AttrRow.Attrs == &Row->AttrRow.AttrPair);
                }
                Row->AttrRow.Attrs = NewAttrs;
                Row->AttrRow.Length = NewAttrsLength;
            }
            Row->CharRow.OldLeft = INVALID_OLD_LENGTH;
            Row->CharRow.OldRight = INVALID_OLD_LENGTH;
        }
        else{
//#endif
        Attrs.Length = StringLength;
        Attrs.Attr = ScreenInfo->Attributes;
        if (!NT_SUCCESS(MergeAttrStrings(Row->AttrRow.Attrs,
                         Row->AttrRow.Length,
                         &Attrs,
                         1,
                         &NewAttrs,
                         &NewAttrsLength,
                         TargetPoint.X,
                         (SHORT)(TargetPoint.X+StringLength-1),
                         Row,
                         ScreenInfo
                        ))) {
            return;
        }
        if (Row->AttrRow.Length > 1) {
            ConsoleHeapFree(Row->AttrRow.Attrs);
        }
        else {
            ASSERT(Row->AttrRow.Attrs == &Row->AttrRow.AttrPair);
        }
        Row->AttrRow.Attrs = NewAttrs;
        Row->AttrRow.Length = NewAttrsLength;
        Row->CharRow.OldLeft = INVALID_OLD_LENGTH;
        Row->CharRow.OldRight = INVALID_OLD_LENGTH;
//#if defined(FE_SB) && defined(FE_IME)
    }
//#endif
    }
    ResetTextFlags(ScreenInfo,
                   TargetPoint.X,
                   TargetPoint.Y,
                   TargetPoint.X + StringLength - 1,
                   TargetPoint.Y);
}

#endif // FE_IME
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\server\cursor.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    cursor.c

Abstract:

        This file implements the NT console server cursor routines.

Author:

    Therese Stowell (thereses) 5-Dec-1990

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//#define PROFILE_GDI
#ifdef PROFILE_GDI
LONG InvertCount;
#define INVERT_CALL InvertCount++
#else
#define INVERT_CALL
#endif

extern UINT guCaretBlinkTime;

VOID
InvertPixels(
    IN PSCREEN_INFORMATION ScreenInfo
    )

/*++

Routine Description:

    This routine inverts the cursor pixels, making it either visible or
    invisible.

Arguments:

    ScreenInfo - pointer to screen info structure.

Return Value:

    none.

--*/

{
#ifdef FE_SB
    if (CONSOLE_IS_DBCS_OUTPUTCP(ScreenInfo->Console)) {
        PCONVERSIONAREA_INFORMATION ConvAreaInfo;
        SMALL_RECT Region;
        SMALL_RECT CursorRegion;
        SMALL_RECT ClippedRegion;

#ifdef DBG_KATTR
//        BeginKAttrCheck(ScreenInfo);
#endif

        ConvAreaInfo = ScreenInfo->Console->ConsoleIme.ConvAreaRoot;
        CursorRegion.Left = CursorRegion.Right  = ScreenInfo->BufferInfo.TextInfo.CursorPosition.X;
        CursorRegion.Top  = CursorRegion.Bottom = ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y;
        while (ConvAreaInfo) {

            if ((ConvAreaInfo->ConversionAreaMode & (CA_HIDDEN+CA_HIDE_FOR_SCROLL))==0) {
                //
                // Do clipping region
                //
                Region.Left   = ScreenInfo->Window.Left +
                                ConvAreaInfo->CaInfo.rcViewCaWindow.Left +
                                ConvAreaInfo->CaInfo.coordConView.X;
                Region.Right  = Region.Left +
                                (ConvAreaInfo->CaInfo.rcViewCaWindow.Right -
                                 ConvAreaInfo->CaInfo.rcViewCaWindow.Left);
                Region.Top    = ScreenInfo->Window.Top +
                                ConvAreaInfo->CaInfo.rcViewCaWindow.Top +
                                ConvAreaInfo->CaInfo.coordConView.Y;
                Region.Bottom = Region.Top +
                                (ConvAreaInfo->CaInfo.rcViewCaWindow.Bottom -
                                 ConvAreaInfo->CaInfo.rcViewCaWindow.Top);
                ClippedRegion.Left   = max(Region.Left,   ScreenInfo->Window.Left);
                ClippedRegion.Top    = max(Region.Top,    ScreenInfo->Window.Top);
                ClippedRegion.Right  = min(Region.Right,  ScreenInfo->Window.Right);
                ClippedRegion.Bottom = min(Region.Bottom, ScreenInfo->Window.Bottom);
                if (ClippedRegion.Right < ClippedRegion.Left ||
                    ClippedRegion.Bottom < ClippedRegion.Top) {
                    ;
                }
                else {
                    Region = ClippedRegion;
                    ClippedRegion.Left   = max(Region.Left,   CursorRegion.Left);
                    ClippedRegion.Top    = max(Region.Top,    CursorRegion.Top);
                    ClippedRegion.Right  = min(Region.Right,  CursorRegion.Right);
                    ClippedRegion.Bottom = min(Region.Bottom, CursorRegion.Bottom);
                    if (ClippedRegion.Right < ClippedRegion.Left ||
                        ClippedRegion.Bottom < ClippedRegion.Top) {
                        ;
                    }
                    else {
                        return;
                    }
                }
            }
            ConvAreaInfo = ConvAreaInfo->ConvAreaNext;
        }
    }
#endif  // FE_SB

    {
        ULONG CursorYSize;
        POLYPATBLT PolyData;
#ifdef FE_SB
        SHORT RowIndex;
        PROW Row;
        COORD TargetPoint;
        int iTrailing = 0;
        int iDBCursor = 1;
#endif

        INVERT_CALL;
        CursorYSize = ScreenInfo->BufferInfo.TextInfo.CursorYSize;
        if (ScreenInfo->BufferInfo.TextInfo.DoubleCursor) {
            if (ScreenInfo->BufferInfo.TextInfo.CursorSize > 50)
                CursorYSize = CursorYSize >> 1;
            else
                CursorYSize = CursorYSize << 1;
        }
#ifdef FE_SB
        if (CONSOLE_IS_DBCS_OUTPUTCP(ScreenInfo->Console))
        {
            TargetPoint = ScreenInfo->BufferInfo.TextInfo.CursorPosition;
            RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+TargetPoint.Y) % ScreenInfo->ScreenBufferSize.Y;
            Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
            ASSERT(Row);

            if ((Row->CharRow.KAttrs[TargetPoint.X] & ATTR_TRAILING_BYTE) &&
                ScreenInfo->BufferInfo.TextInfo.CursorDBEnable) {

                iTrailing = 1;
                iDBCursor = 2;
            } else if ((Row->CharRow.KAttrs[TargetPoint.X] & ATTR_LEADING_BYTE) &&
                ScreenInfo->BufferInfo.TextInfo.CursorDBEnable) {

                iDBCursor = 2;
            }
        }

        PolyData.x  = (ScreenInfo->BufferInfo.TextInfo.CursorPosition.X -
                    ScreenInfo->Window.Left - iTrailing) * SCR_FONTSIZE(ScreenInfo).X;
        PolyData.y  = (ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y -
                    ScreenInfo->Window.Top) * SCR_FONTSIZE(ScreenInfo).Y +
                    (CURSOR_Y_OFFSET_IN_PIXELS(SCR_FONTSIZE(ScreenInfo).Y,CursorYSize));
        PolyData.cx = SCR_FONTSIZE(ScreenInfo).X * iDBCursor;
        PolyData.cy = CursorYSize;
#else
        PolyData.x  = (ScreenInfo->BufferInfo.TextInfo.CursorPosition.X-ScreenInfo->Window.Left)*SCR_FONTSIZE(ScreenInfo).X;
        PolyData.y  = (ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y-ScreenInfo->Window.Top)*SCR_FONTSIZE(ScreenInfo).Y+(CURSOR_Y_OFFSET_IN_PIXELS(SCR_FONTSIZE(ScreenInfo).Y,CursorYSize));
        PolyData.cx = SCR_FONTSIZE(ScreenInfo).X;
        PolyData.cy = CursorYSize;
#endif
        PolyData.BrClr.hbr = GetStockObject(LTGRAY_BRUSH);

        PolyPatBlt(ScreenInfo->Console->hDC, PATINVERT, &PolyData, 1, PPB_BRUSH);

        GdiFlush();
    }
}

VOID
ConsoleShowCursor(
    IN PSCREEN_INFORMATION ScreenInfo
    )

/*++

Routine Description:

    This routine makes the cursor visible both in the data structures
    and on the screen.

Arguments:

    ScreenInfo - pointer to screen info structure.

Return Value:

    none.

--*/

{
    if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
        ASSERT (ScreenInfo->BufferInfo.TextInfo.UpdatingScreen>0);
        if (--ScreenInfo->BufferInfo.TextInfo.UpdatingScreen == 0) {
            ScreenInfo->BufferInfo.TextInfo.CursorOn = FALSE;
        }
    }
}

VOID
ConsoleHideCursor(
    IN PSCREEN_INFORMATION ScreenInfo
    )

/*++

Routine Description:

    This routine makes the cursor invisible both in the data structures
    and on the screen.

Arguments:

    ScreenInfo - pointer to screen info structure.

Return Value:

    none.

--*/

{
    if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
        if (++ScreenInfo->BufferInfo.TextInfo.UpdatingScreen == 1) {
            if (ScreenInfo->BufferInfo.TextInfo.CursorVisible &&
                ScreenInfo->BufferInfo.TextInfo.CursorOn &&
                ScreenInfo->Console->CurrentScreenBuffer == ScreenInfo &&
                !(ScreenInfo->Console->Flags & CONSOLE_IS_ICONIC)) {
                InvertPixels(ScreenInfo);
                ScreenInfo->BufferInfo.TextInfo.CursorOn = FALSE;
            }
        }
    }
}

NTSTATUS
SetCursorInformation(
    IN PSCREEN_INFORMATION ScreenInfo,
    ULONG Size,
    BOOLEAN Visible
    )

/*++

Routine Description:

    This routine sets the cursor size and visibility both in the data structures
    and on the screen.

Arguments:

    ScreenInfo - pointer to screen info structure.

    Size - cursor size

    Visible - cursor visibility

Return Value:

    Status

--*/

{
    if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
        ConsoleHideCursor(ScreenInfo);
        ScreenInfo->BufferInfo.TextInfo.CursorSize = Size;
        ScreenInfo->BufferInfo.TextInfo.CursorVisible = Visible;
        ScreenInfo->BufferInfo.TextInfo.CursorYSize = (WORD)CURSOR_SIZE_IN_PIXELS(SCR_FONTSIZE(ScreenInfo).Y,ScreenInfo->BufferInfo.TextInfo.CursorSize);
#ifdef i386
        if ((!(ScreenInfo->Console->Flags & CONSOLE_VDM_REGISTERED)) &&
            ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) {
            SetCursorInformationHW(ScreenInfo,Size,Visible);
        }
#endif
        ConsoleShowCursor(ScreenInfo);
    }
    return STATUS_SUCCESS;
}

NTSTATUS
SetCursorMode(
    IN PSCREEN_INFORMATION ScreenInfo,
    BOOLEAN DoubleCursor
    )

/*++

Routine Description:

    This routine sets a flag saying whether the cursor should be displayed
    with it's default size or it should be modified to indicate the
    insert/overtype mode has changed.

Arguments:

    ScreenInfo - pointer to screen info structure.

    DoubleCursor - should we indicated non-normal mode

Return Value:

    Status

--*/

{
    if ((ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) &&
        (ScreenInfo->BufferInfo.TextInfo.DoubleCursor != DoubleCursor)) {
        ConsoleHideCursor(ScreenInfo);
        ScreenInfo->BufferInfo.TextInfo.DoubleCursor = DoubleCursor;
#ifdef i386
        if ((!(ScreenInfo->Console->Flags & CONSOLE_VDM_REGISTERED)) &&
            ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) {
            SetCursorInformationHW(ScreenInfo,
                       ScreenInfo->BufferInfo.TextInfo.CursorSize,
                       ScreenInfo->BufferInfo.TextInfo.CursorVisible);
        }
#endif
        ConsoleShowCursor(ScreenInfo);
    }
    return STATUS_SUCCESS;
}

VOID
CursorTimerRoutine(
    IN PSCREEN_INFORMATION ScreenInfo
    )

/*++

Routine Description:

    This routine is called when the timer in the console with the focus
    goes off.  It blinks the cursor.

Arguments:

    ScreenInfo - pointer to screen info structure.

Return Value:

    none.

--*/

{
    if (!(ScreenInfo->Console->Flags & CONSOLE_HAS_FOCUS))
        return;

    if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {

        //
        // Update the cursor pos in USER so accessibility will work
        //

        if (ScreenInfo->BufferInfo.TextInfo.CursorMoved) {

            CONSOLE_CARET_INFO ConsoleCaretInfo;
            DWORD dwFlags = 0;

            ScreenInfo->BufferInfo.TextInfo.CursorMoved = FALSE;
            ConsoleCaretInfo.hwnd = ScreenInfo->Console->hWnd;
            ConsoleCaretInfo.rc.left = (ScreenInfo->BufferInfo.TextInfo.CursorPosition.X - ScreenInfo->Window.Left) * SCR_FONTSIZE(ScreenInfo).X;
            ConsoleCaretInfo.rc.top = (ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y - ScreenInfo->Window.Top) * SCR_FONTSIZE(ScreenInfo).Y;
            ConsoleCaretInfo.rc.right = ConsoleCaretInfo.rc.left + SCR_FONTSIZE(ScreenInfo).X;
            ConsoleCaretInfo.rc.bottom = ConsoleCaretInfo.rc.top + SCR_FONTSIZE(ScreenInfo).Y;
            NtUserConsoleControl(ConsoleSetCaretInfo,
                                 &ConsoleCaretInfo,
                                 sizeof(ConsoleCaretInfo));
            if (ScreenInfo->BufferInfo.TextInfo.CursorVisible) {
                dwFlags |= CONSOLE_CARET_VISIBLE;
            }
            if (ScreenInfo->Console->Flags & CONSOLE_SELECTING) {
                dwFlags |= CONSOLE_CARET_SELECTION;
            }
            ConsoleNotifyWinEvent(ScreenInfo->Console,
                                  EVENT_CONSOLE_CARET,
                                  dwFlags,
                                  PACKCOORD(ScreenInfo->BufferInfo.TextInfo.CursorPosition));
        }

        // if the DelayCursor flag has been set, wait one more tick before toggle.
        // This is used to guarantee the cursor is on for a finite period of time
        // after a move and off for a finite period of time after a WriteString

        if (ScreenInfo->BufferInfo.TextInfo.DelayCursor) {
            ScreenInfo->BufferInfo.TextInfo.DelayCursor = FALSE;
            return;
        }

        // don't blink the cursor for remote sessions
        if ((NtCurrentPeb()->SessionId != WTSGetActiveConsoleSessionId() ||
                guCaretBlinkTime == (UINT)-1) &&
            ScreenInfo->BufferInfo.TextInfo.CursorOn) {
            return;
        }

        if (ScreenInfo->BufferInfo.TextInfo.CursorVisible &&
            !ScreenInfo->BufferInfo.TextInfo.UpdatingScreen) {
            InvertPixels(ScreenInfo);
            ScreenInfo->BufferInfo.TextInfo.CursorOn = !ScreenInfo->BufferInfo.TextInfo.CursorOn;
        }
    }
}

#ifdef i386
NTSTATUS
SetCursorPositionHW(
    IN OUT PSCREEN_INFORMATION ScreenInfo,
    IN COORD Position
    )

/*++

Routine Description:

    This routine moves the cursor.

Arguments:

    ScreenInfo - Pointer to screen buffer information.

    Position - Contains the new position of the cursor in screen buffer
    coordinates.

Return Value:

    none.

--*/

{
#if defined(FE_SB)
    FSVIDEO_CURSOR_POSITION CursorPosition;
    SHORT RowIndex;
    PROW Row;
    COORD TargetPoint;

    if (ScreenInfo->ConvScreenInfo)
        return STATUS_SUCCESS;

    TargetPoint.X = Position.X;
    TargetPoint.Y = Position.Y;
    RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+TargetPoint.Y) % ScreenInfo->ScreenBufferSize.Y;
    Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];

    if (!CONSOLE_IS_DBCS_OUTPUTCP(ScreenInfo->Console))
        CursorPosition.dwType = CHAR_TYPE_SBCS;
    else if (Row->CharRow.KAttrs[TargetPoint.X] & ATTR_TRAILING_BYTE)
        CursorPosition.dwType = CHAR_TYPE_TRAILING;
    else if (Row->CharRow.KAttrs[TargetPoint.X] & ATTR_LEADING_BYTE)
        CursorPosition.dwType = CHAR_TYPE_LEADING;
    else
        CursorPosition.dwType = CHAR_TYPE_SBCS;

    // set cursor position

    CursorPosition.Coord.Column = Position.X - ScreenInfo->Window.Left;
    CursorPosition.Coord.Row    = Position.Y - ScreenInfo->Window.Top;
#else
    VIDEO_CURSOR_POSITION CursorPosition;

    // set cursor position

    CursorPosition.Column = Position.X - ScreenInfo->Window.Left;
    CursorPosition.Row = Position.Y - ScreenInfo->Window.Top;
#endif

    return GdiFullscreenControl(FullscreenControlSetCursorPosition,
                                   (PVOID)&CursorPosition,
                                   sizeof(CursorPosition),
                                   NULL,
                                   0);
}
#endif

NTSTATUS
SetCursorPosition(
    IN OUT PSCREEN_INFORMATION ScreenInfo,
    IN COORD Position,
    IN BOOL  TurnOn
    )

/*++

Routine Description:

    This routine sets the cursor position in the data structures and on
    the screen.

Arguments:

    ScreenInfo - pointer to screen info structure.

    Position - new position of cursor

    TurnOn - true if cursor should be left on, false if should be left off

Return Value:

    Status

--*/

{
    //
    // Ensure that the cursor position is within the constraints of the
    // screen buffer.
    //
    if (Position.X >= ScreenInfo->ScreenBufferSize.X ||
        Position.Y >= ScreenInfo->ScreenBufferSize.Y ||
        Position.X < 0 || Position.Y < 0) {
        return STATUS_INVALID_PARAMETER;
    }

    ConsoleHideCursor(ScreenInfo);
    ScreenInfo->BufferInfo.TextInfo.CursorPosition = Position;
#ifdef i386
    if ((!(ScreenInfo->Console->Flags & CONSOLE_VDM_REGISTERED)) &&
        ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) {
        SetCursorPositionHW(ScreenInfo,Position);
    }
#endif
    ConsoleShowCursor(ScreenInfo);

// if we have the focus, adjust the cursor state

    if (ScreenInfo->Console->Flags & CONSOLE_HAS_FOCUS) {

        if (TurnOn) {
            ScreenInfo->BufferInfo.TextInfo.DelayCursor = FALSE;
            CursorTimerRoutine(ScreenInfo);
        } else {
            ScreenInfo->BufferInfo.TextInfo.DelayCursor = TRUE;
        }
        ScreenInfo->BufferInfo.TextInfo.CursorMoved = TRUE;
    }

    return STATUS_SUCCESS;
}

#ifdef i386
NTSTATUS
SetCursorInformationHW(
    PSCREEN_INFORMATION ScreenInfo,
    ULONG Size,
    BOOLEAN Visible
    )
{
    VIDEO_CURSOR_ATTRIBUTES CursorAttr;
    ULONG FontSizeY;

    if (ScreenInfo->BufferInfo.TextInfo.DoubleCursor) {
        if (Size > 50)
            Size = Size >> 1;
        else
            Size = Size << 1;
    }
    ASSERT (Size <= 100 && Size > 0);
    FontSizeY = CONSOLE_WINDOW_SIZE_Y(ScreenInfo) > 25 ? 8 : 16;
    CursorAttr.Height = (USHORT)CURSOR_PERCENTAGE_TO_TOP_SCAN_LINE(FontSizeY,Size);
    CursorAttr.Width = 31;
    CursorAttr.Enable = Visible;

    return GdiFullscreenControl(FullscreenControlSetCursorAttributes,
                                   (PVOID)&CursorAttr,
                                   sizeof(CursorAttr),
                                   NULL,
                                   0);

}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\server\dbcs.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    dbcs.c

Abstract:

Author:

    KazuM Mar.05.1992

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#pragma alloc_text(FE_TEXT, CheckBisectStringA)
#pragma alloc_text(FE_TEXT, BisectWrite)
#pragma alloc_text(FE_TEXT, BisectClipbrd)
#pragma alloc_text(FE_TEXT, BisectWriteAttr)
#pragma alloc_text(FE_TEXT, IsDBCSLeadByteConsole)
#pragma alloc_text(FE_TEXT, TextOutEverything)
#pragma alloc_text(FE_TEXT, TextOutCommonLVB)
#ifdef i386
#pragma alloc_text(FE_TEXT, RealUnicodeToNEC_OS2_Unicode)
#pragma alloc_text(FE_TEXT, InitializeNEC_OS2_CP)
#endif
#pragma alloc_text(FE_TEXT, ProcessCreateConsoleIME)
#pragma alloc_text(FE_TEXT, InitConsoleIMEStuff)
#pragma alloc_text(FE_TEXT, WaitConsoleIMEStuff)
#pragma alloc_text(FE_TEXT, ConSrvRegisterConsoleIME)
#pragma alloc_text(FE_TEXT, RemoveConsoleIME)
#pragma alloc_text(FE_TEXT, ConsoleImeMessagePump)
#pragma alloc_text(FE_TEXT, RegisterKeisenOfTTFont)
#pragma alloc_text(FE_TEXT, ImmConversionToConsole)
#pragma alloc_text(FE_TEXT, ImmConversionFromConsole)
#pragma alloc_text(FE_TEXT, TranslateUnicodeToOem)


#if defined(FE_SB)

SINGLE_LIST_ENTRY gTTFontList;    // This list contain TTFONTLIST data.

#if defined(i386)
ULONG  gdwMachineId;
#endif

LPTHREAD_START_ROUTINE ConsoleIMERoutine;  // client side console IME routine
CRITICAL_SECTION ConIMEInitWindowsLock;

#if defined(i386)
/*
 * NEC PC-98 OS/2 OEM character set
 * When FormatID is 0 or 80, Convert SBCS (00h-1Fh) font.
 */
PCPTABLEINFO pGlyph_NEC_OS2_CP;
PUSHORT pGlyph_NEC_OS2_Table;
#endif // i386



#if defined(FE_IME)


#if defined(i386)
NTSTATUS
ImeWmFullScreen(
    IN BOOL Foreground,
    IN PCONSOLE_INFORMATION Console,
    IN PSCREEN_INFORMATION ScreenInfo
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    if(Foreground) {
        ULONG ModeIndex;
        PCONVERSIONAREA_INFORMATION ConvAreaInfo;

        if (!NT_SUCCESS(ConsoleImeMessagePump(Console,
                              CONIME_SETFOCUS,
                              (WPARAM)Console->ConsoleHandle,
                              (LPARAM)Console->hklActive
                             ))) {
            return STATUS_INVALID_HANDLE;
        }

        if (ConvAreaInfo = Console->ConsoleIme.ConvAreaRoot) {
            if (!(ScreenInfo->Flags & CONSOLE_GRAPHICS_BUFFER))
                ModeIndex = ScreenInfo->BufferInfo.TextInfo.ModeIndex;
            else if (!(Console->CurrentScreenBuffer->Flags & CONSOLE_GRAPHICS_BUFFER))
                ModeIndex = Console->CurrentScreenBuffer->BufferInfo.TextInfo.ModeIndex;
            else
                ModeIndex = 0;
            do {
#ifdef FE_SB
                // Check code for must CONSOLE_TEXTMODE_BUFFER !!
                if (! (ConvAreaInfo->ScreenBuffer->Flags & CONSOLE_GRAPHICS_BUFFER))
                    ConvAreaInfo->ScreenBuffer->BufferInfo.TextInfo.ModeIndex = ModeIndex;
                else
                    ASSERT(FALSE);
#else
                ConvAreaInfo->ScreenBuffer->BufferInfo.TextInfo.ModeIndex = ModeIndex;
#endif
            } while (ConvAreaInfo = ConvAreaInfo->ConvAreaNext);
        }
    }
    else
    {
        if (!NT_SUCCESS(ConsoleImeMessagePump(Console,
                              CONIME_KILLFOCUS,
                              (WPARAM)Console->ConsoleHandle,
                              (LPARAM)Console->hklActive
                             ))) {
            return STATUS_INVALID_HANDLE;
        }
    }

    return Status;
}
#endif // i386




NTSTATUS
GetImeKeyState(
    IN PCONSOLE_INFORMATION Console,
    IN PDWORD pdwConversion
    )

/*++

Routine Description:

    This routine get IME mode for KEY_EVENT_RECORD.

Arguments:

    ConsoleInfo - Pointer to console information structure.

Return Value:

--*/

{
    DWORD dwDummy;

    /*
     * If pdwConversion is NULL, the caller doensn't want
     * the result --- but for code efficiency, let it
     * point to the dummy dword variable, so that
     * we don't have to care from here.
     */
    if (pdwConversion == NULL) {
        pdwConversion = &dwDummy;
    }

    if (Console->InputBuffer.ImeMode.Disable)
    {
        *pdwConversion = 0;
    }
    else
    {
        PINPUT_THREAD_INFO InputThreadInfo;     // console thread info

        InputThreadInfo = TlsGetValue(InputThreadTlsIndex);

        if (InputThreadInfo != NULL)
        {
            LRESULT lResult;

            /*
             * This thread is in InputThread()
             * We can try message pump.
             */

            if (!NT_SUCCESS(ConsoleImeMessagePumpWorker(Console,
                    CONIME_GET_NLSMODE,
                    (WPARAM)Console->ConsoleHandle,
                    (LPARAM)0,
                    &lResult))) {

                *pdwConversion = IME_CMODE_DISABLE;
                return STATUS_INVALID_HANDLE;
            }


            *pdwConversion = (DWORD)lResult;

            if (Console->InputBuffer.ImeMode.ReadyConversion == FALSE)
                Console->InputBuffer.ImeMode.ReadyConversion = TRUE;
        }
        else
        {
            /*
             * This thread is in CsrApiRequestThread()
             * We can not try message pump.
             */
            if (Console->InputBuffer.ImeMode.ReadyConversion == FALSE) {
                *pdwConversion = 0;
                return STATUS_SUCCESS;
            }

            *pdwConversion = Console->InputBuffer.ImeMode.Conversion;
        }


        if (*pdwConversion & IME_CMODE_OPEN)
            Console->InputBuffer.ImeMode.Open = TRUE;
        else
            Console->InputBuffer.ImeMode.Open = FALSE;
        if (*pdwConversion & IME_CMODE_DISABLE)
            Console->InputBuffer.ImeMode.Disable = TRUE;
        else
            Console->InputBuffer.ImeMode.Disable = FALSE;

        Console->InputBuffer.ImeMode.Conversion = *pdwConversion;

    }

    return STATUS_SUCCESS;
}




NTSTATUS
SetImeKeyState(
    IN PCONSOLE_INFORMATION Console,
    IN DWORD fdwConversion
    )

/*++

Routine Description:

    This routine get IME mode for KEY_EVENT_RECORD.

Arguments:

    Console - Pointer to console information structure.

    fdwConversion - IME conversion status.

Return Value:

--*/

{
    PCONVERSIONAREA_INFORMATION ConvAreaInfo;

    if ( (fdwConversion & IME_CMODE_DISABLE) && (! Console->InputBuffer.ImeMode.Disable) ) {
        Console->InputBuffer.ImeMode.Disable = TRUE;
        if ( Console->InputBuffer.ImeMode.Open ) {
            ConvAreaInfo = Console->ConsoleIme.ConvAreaMode;
            if (ConvAreaInfo)
                ConvAreaInfo->ConversionAreaMode |= CA_HIDDEN;
            ConvAreaInfo = Console->ConsoleIme.ConvAreaSystem;
            if (ConvAreaInfo)
                ConvAreaInfo->ConversionAreaMode |= CA_HIDDEN;
            if (Console->InputBuffer.ImeMode.Open && CONSOLE_IS_DBCS_OUTPUTCP(Console))
                ConsoleImePaint(Console, Console->ConsoleIme.ConvAreaRoot);
        }
    }
    else if ( (! (fdwConversion & IME_CMODE_DISABLE)) && Console->InputBuffer.ImeMode.Disable) {
        Console->InputBuffer.ImeMode.Disable = FALSE;
        if ( fdwConversion & IME_CMODE_OPEN ) {
            ConvAreaInfo = Console->ConsoleIme.ConvAreaMode;
            if (ConvAreaInfo)
                ConvAreaInfo->ConversionAreaMode &= ~CA_HIDDEN;
            ConvAreaInfo = Console->ConsoleIme.ConvAreaSystem;
            if (ConvAreaInfo)
                ConvAreaInfo->ConversionAreaMode &= ~CA_HIDDEN;
            if (Console->InputBuffer.ImeMode.Open && CONSOLE_IS_DBCS_OUTPUTCP(Console))
                ConsoleImePaint(Console, Console->ConsoleIme.ConvAreaRoot);
        }
    }
    else if ( (fdwConversion & IME_CMODE_DISABLE) && (Console->InputBuffer.ImeMode.Disable) ) {
        return STATUS_SUCCESS;
    }

    if ( (fdwConversion & IME_CMODE_OPEN) && (! Console->InputBuffer.ImeMode.Open)) {
        Console->InputBuffer.ImeMode.Open = TRUE;
    }
    else if ( (! (fdwConversion & IME_CMODE_OPEN)) && Console->InputBuffer.ImeMode.Open) {
        Console->InputBuffer.ImeMode.Open = FALSE;
    }

    Console->InputBuffer.ImeMode.Conversion = fdwConversion;

    if (Console->InputBuffer.ImeMode.ReadyConversion == FALSE)
        Console->InputBuffer.ImeMode.ReadyConversion = TRUE;

    if (!NT_SUCCESS(ConsoleImeMessagePump(Console,
                          CONIME_SET_NLSMODE,
                          (WPARAM)Console->ConsoleHandle,
                          (LPARAM)fdwConversion
                         ))) {
        return STATUS_INVALID_HANDLE;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
SetImeCodePage(
    IN PCONSOLE_INFORMATION Console
    )
{
    DWORD CodePage = Console->OutputCP;
    DWORD fdwConversion;

    if (!CONSOLE_IS_DBCS_CP(Console))
    {
        if (!NT_SUCCESS(GetImeKeyState(Console, &fdwConversion))) {
            return STATUS_INVALID_HANDLE;
        }

        fdwConversion |= IME_CMODE_DISABLE;

    }
    else {
        fdwConversion = Console->InputBuffer.ImeMode.Conversion & ~IME_CMODE_DISABLE;
    }

    if (!NT_SUCCESS(SetImeKeyState(Console, fdwConversion))) {
        return STATUS_INVALID_HANDLE;
    }

    if (CONSOLE_IS_IME_ENABLED()) {
        if (!NT_SUCCESS(ConsoleImeMessagePump(Console,
                              CONIME_NOTIFY_CODEPAGE,
                              (WPARAM)Console->ConsoleHandle,
                              (LPARAM)MAKELPARAM(FALSE, CodePage)
                             ))) {
            return STATUS_INVALID_HANDLE;
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
SetImeOutputCodePage(
    IN PCONSOLE_INFORMATION Console,
    IN PSCREEN_INFORMATION ScreenInfo,
    IN DWORD PrevCodePage
    )
{
    DWORD CodePage = Console->OutputCP;

    // Output code page
    if ((ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) &&
        (IsAvailableFarEastCodePage(CodePage) || IsAvailableFarEastCodePage(PrevCodePage)))
    {
        ConvertToCodePage(Console, PrevCodePage);
        AdjustFont(Console, CodePage);
    }
    // load special ROM font, if necessary
#ifdef i386
    if ( (Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) &&
         !(ScreenInfo->Flags & CONSOLE_GRAPHICS_BUFFER))
    {
        SetROMFontCodePage(CodePage,
                           ScreenInfo->BufferInfo.TextInfo.ModeIndex);
        SetCursorInformationHW(ScreenInfo,
                        ScreenInfo->BufferInfo.TextInfo.CursorSize,
                        ScreenInfo->BufferInfo.TextInfo.CursorVisible);
        WriteRegionToScreenHW(ScreenInfo,
                &ScreenInfo->Window);
    }
#endif

    if (CONSOLE_IS_IME_ENABLED()) {
        if (!NT_SUCCESS(ConsoleImeMessagePump(Console,
                              CONIME_NOTIFY_CODEPAGE,
                              (WPARAM)Console->ConsoleHandle,
                              (LPARAM)MAKELPARAM(TRUE, CodePage)
                             ))) {
            return STATUS_INVALID_HANDLE;
        }
    }

    return STATUS_SUCCESS;
}
#endif // FE_IME

















VOID
SetLineChar(
    IN PSCREEN_INFORMATION ScreenInfo
    )

/*++

Routine Description:

    This routine setup of line character code.

Arguments:

    ScreenInfo - Pointer to screen information structure.

Return Value:

    none.

--*/

{
    if (CONSOLE_IS_DBCS_OUTPUTCP(ScreenInfo->Console))
    {
        if (OEMCP == JAPAN_CP || OEMCP == KOREAN_CP)
        {
            /*
             * This is Japanese/Korean case,
             * These characters maps grid of half width.
             * so, same as U+2500.
             */
            ScreenInfo->LineChar[UPPER_LEFT_CORNER]   = 0x0001;
            ScreenInfo->LineChar[UPPER_RIGHT_CORNER]  = 0x0002;
            ScreenInfo->LineChar[HORIZONTAL_LINE]     = 0x0006;
            ScreenInfo->LineChar[VERTICAL_LINE]       = 0x0005;
            ScreenInfo->LineChar[BOTTOM_LEFT_CORNER]  = 0x0003;
            ScreenInfo->LineChar[BOTTOM_RIGHT_CORNER] = 0x0004;
        }
        else
        {
            /*
             * This is FE case,
             * FE don't uses U+2500 because these grid characters
             * maps to full width.
             */
            ScreenInfo->LineChar[UPPER_LEFT_CORNER]   = L'+';
            ScreenInfo->LineChar[UPPER_RIGHT_CORNER]  = L'+';
            ScreenInfo->LineChar[HORIZONTAL_LINE]     = L'-';
            ScreenInfo->LineChar[VERTICAL_LINE]       = L'|';
            ScreenInfo->LineChar[BOTTOM_LEFT_CORNER]  = L'+';
            ScreenInfo->LineChar[BOTTOM_RIGHT_CORNER] = L'+';
        }
    }
    else {
        ScreenInfo->LineChar[UPPER_LEFT_CORNER]   = 0x250c;
        ScreenInfo->LineChar[UPPER_RIGHT_CORNER]  = 0x2510;
        ScreenInfo->LineChar[HORIZONTAL_LINE]     = 0x2500;
        ScreenInfo->LineChar[VERTICAL_LINE]       = 0x2502;
        ScreenInfo->LineChar[BOTTOM_LEFT_CORNER]  = 0x2514;
        ScreenInfo->LineChar[BOTTOM_RIGHT_CORNER] = 0x2518;
    }
}

BOOL
CheckBisectStringA(
    IN DWORD CodePage,
    IN PCHAR Buffer,
    IN DWORD NumBytes,
    IN LPCPINFO lpCPInfo
    )

/*++

Routine Description:

    This routine check bisected on Ascii string end.

Arguments:

    CodePage - Value of code page.

    Buffer - Pointer to Ascii string buffer.

    NumBytes - Number of Ascii string.

Return Value:

    TRUE - Bisected character.

    FALSE - Correctly.

--*/

{
    UNREFERENCED_PARAMETER(CodePage);

    while(NumBytes) {
        if (IsDBCSLeadByteConsole(*Buffer,lpCPInfo)) {
            if (NumBytes <= 1)
                return TRUE;
            else {
                Buffer += 2;
                NumBytes -= 2;
            }
        }
        else {
            Buffer++;
            NumBytes--;
        }
    }
    return FALSE;
}



VOID
BisectWrite(
    IN SHORT StringLength,
    IN COORD TargetPoint,
    IN PSCREEN_INFORMATION ScreenInfo
    )

/*++

Routine Description:

    This routine write buffer with bisect.

Arguments:

Return Value:

--*/

{
    SHORT RowIndex;
    PROW Row;
    PROW RowPrev;
    PROW RowNext;

#if defined(DBG) && defined(DBG_KATTR)
    BeginKAttrCheck(ScreenInfo);
#endif

#ifdef FE_SB
    // Check code for must CONSOLE_TEXTMODE_BUFFER !!
    ASSERT(!(ScreenInfo->Flags & CONSOLE_GRAPHICS_BUFFER));
#endif

    RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+TargetPoint.Y) % ScreenInfo->ScreenBufferSize.Y;
    Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];

    if (RowIndex > 0) {
        RowPrev = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex-1];
    } else {
        RowPrev = &ScreenInfo->BufferInfo.TextInfo.Rows[ScreenInfo->ScreenBufferSize.Y-1];
    }

    if (RowIndex+1 < ScreenInfo->ScreenBufferSize.Y) {
        RowNext = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex+1];
    } else {
        RowNext = &ScreenInfo->BufferInfo.TextInfo.Rows[0];
    }

    //
    // Check start position of strings
    //
    if (Row->CharRow.KAttrs[TargetPoint.X] & ATTR_TRAILING_BYTE)
    {
        if (TargetPoint.X == 0) {
            RowPrev->CharRow.Chars[ScreenInfo->ScreenBufferSize.X-1] = UNICODE_SPACE;
            RowPrev->CharRow.KAttrs[ScreenInfo->ScreenBufferSize.X-1] = 0;
            ScreenInfo->BisectFlag |= BISECT_TOP;
        }
        else {
            Row->CharRow.Chars[TargetPoint.X-1] = UNICODE_SPACE;
            Row->CharRow.KAttrs[TargetPoint.X-1] = 0;
            ScreenInfo->BisectFlag |= BISECT_LEFT;
        }
    }

    //
    // Check end position of strings
    //
    if (TargetPoint.X+StringLength < ScreenInfo->ScreenBufferSize.X) {
        if (Row->CharRow.KAttrs[TargetPoint.X+StringLength] & ATTR_TRAILING_BYTE)
          {
            Row->CharRow.Chars[TargetPoint.X+StringLength] = UNICODE_SPACE;
            Row->CharRow.KAttrs[TargetPoint.X+StringLength] = 0;
            ScreenInfo->BisectFlag |= BISECT_RIGHT;
        }
    }
    else if (TargetPoint.Y+1 < ScreenInfo->ScreenBufferSize.Y) {
        if (RowNext->CharRow.KAttrs[0] & ATTR_TRAILING_BYTE)
        {
            RowNext->CharRow.Chars[0] = UNICODE_SPACE;
            RowNext->CharRow.KAttrs[0] = 0;
            ScreenInfo->BisectFlag |= BISECT_BOTTOM;
        }
    }
}

VOID
BisectClipbrd(
    IN SHORT StringLength,
    IN COORD TargetPoint,
    IN PSCREEN_INFORMATION ScreenInfo,
    OUT PSMALL_RECT SmallRect
    )

/*++

Routine Description:

    This routine check bisect for clipboard process.

Arguments:

Return Value:

--*/

{
    SHORT RowIndex;
    PROW Row;
    PROW RowNext;

#if defined(DBG) && defined(DBG_KATTR)
//    BeginKAttrCheck(ScreenInfo);
#endif

#ifdef FE_SB
    // Check code for must CONSOLE_TEXTMODE_BUFFER !!
    ASSERT(!(ScreenInfo->Flags & CONSOLE_GRAPHICS_BUFFER));
#endif

    RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+TargetPoint.Y) % ScreenInfo->ScreenBufferSize.Y;
    Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];

    if (RowIndex+1 < ScreenInfo->ScreenBufferSize.Y) {
        RowNext = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex+1];
    } else {
        RowNext = &ScreenInfo->BufferInfo.TextInfo.Rows[0];
    }

    //
    // Check start position of strings
    //
    ASSERT(CONSOLE_IS_DBCS_OUTPUTCP(ScreenInfo->Console));
    if (Row->CharRow.KAttrs[TargetPoint.X] & ATTR_TRAILING_BYTE)
    {
        if (TargetPoint.X == 0) {
            SmallRect->Left++;
        }
        else {
            SmallRect->Left--;
        }
    }
    //
    // Check end position of strings
    //
    if (TargetPoint.X+StringLength < ScreenInfo->ScreenBufferSize.X) {
        if (Row->CharRow.KAttrs[TargetPoint.X+StringLength] & ATTR_TRAILING_BYTE)
        {
            SmallRect->Right++;
        }
    }
    else if (TargetPoint.Y+1 < ScreenInfo->ScreenBufferSize.Y) {
        if (RowNext->CharRow.KAttrs[0] & ATTR_TRAILING_BYTE)
        {
            SmallRect->Right--;
        }
    }
}


VOID
BisectWriteAttr(
    IN SHORT StringLength,
    IN COORD TargetPoint,
    IN PSCREEN_INFORMATION ScreenInfo
    )

/*++

Routine Description:

    This routine write buffer with bisect.

Arguments:

Return Value:

--*/

{
    SHORT RowIndex;
    PROW Row;
    PROW RowNext;

#if defined(DBG) && defined(DBG_KATTR)
    BeginKAttrCheck(ScreenInfo);
#endif

#ifdef FE_SB
    // Check code for must CONSOLE_TEXTMODE_BUFFER !!
    ASSERT(!(ScreenInfo->Flags & CONSOLE_GRAPHICS_BUFFER));
#endif

    RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+TargetPoint.Y) % ScreenInfo->ScreenBufferSize.Y;
    Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];

    if (RowIndex+1 < ScreenInfo->ScreenBufferSize.Y) {
        RowNext = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex+1];
    } else {
        RowNext = &ScreenInfo->BufferInfo.TextInfo.Rows[0];
    }

    //
    // Check start position of strings
    //
    if (Row->CharRow.KAttrs[TargetPoint.X] & ATTR_TRAILING_BYTE){
        if (TargetPoint.X == 0) {
            ScreenInfo->BisectFlag |= BISECT_TOP;
        }
        else {
            ScreenInfo->BisectFlag |= BISECT_LEFT;
        }
    }

    //
    // Check end position of strings
    //
    if (TargetPoint.X+StringLength < ScreenInfo->ScreenBufferSize.X) {
        if (Row->CharRow.KAttrs[TargetPoint.X+StringLength] & ATTR_TRAILING_BYTE){
            ScreenInfo->BisectFlag |= BISECT_RIGHT;
        }
    }
    else if (TargetPoint.Y+1 < ScreenInfo->ScreenBufferSize.Y) {
        if (RowNext->CharRow.KAttrs[0] & ATTR_TRAILING_BYTE){
            ScreenInfo->BisectFlag |= BISECT_BOTTOM;
        }
    }
}



/***************************************************************************\
* BOOL IsConsoleFullWidth(HDC hDC,DWORD CodePage,WCHAR wch)
*
* Determine if the given Unicode char is fullwidth or not.
*
* Return:
*     FASLE : half width. Uses 1 column per one character
*     TRUE  : full width. Uses 2 columns per one character
*
* History:
* 04-08-92 ShunK       Created.
* Jul-27-1992 KazuM    Added Screen Information and Code Page Information.
* Jan-29-1992 V-Hirots Substruct Screen Information.
* Oct-06-1996 KazuM    Not use RtlUnicodeToMultiByteSize and WideCharToMultiByte
*                      Because 950 only defined 13500 chars,
*                      and unicode defined almost 18000 chars.
*                      So there are almost 4000 chars can not be mapped to big5 code.
\***************************************************************************/

BOOL IsConsoleFullWidth(
    IN HDC hDC,
    IN DWORD CodePage,
    IN WCHAR wch
    )
{
    INT Width;
    TEXTMETRIC tmi;

    if (! IsAvailableFarEastCodePage(CodePage))
        return FALSE;

    if (0x20 <= wch && wch <= 0x7e)
        /* ASCII */
        return FALSE;
    else if (0x3041 <= wch && wch <= 0x3094)
        /* Hiragana */
        return TRUE;
    else if (0x30a1 <= wch && wch <= 0x30f6)
        /* Katakana */
        return TRUE;
    else if (0x3105 <= wch && wch <= 0x312c)
        /* Bopomofo */
        return TRUE;
    else if (0x3131 <= wch && wch <= 0x318e)
        /* Hangul Elements */
        return TRUE;
    else if (0xac00 <= wch && wch <= 0xd7a3)
        /* Korean Hangul Syllables */
        return TRUE;
    else if (0xff01 <= wch && wch <= 0xff5e)
        /* Fullwidth ASCII variants */
        return TRUE;
    else if (0xff61 <= wch && wch <= 0xff9f)
        /* Halfwidth Katakana variants */
        return FALSE;
    else if ( (0xffa0 <= wch && wch <= 0xffbe) ||
              (0xffc2 <= wch && wch <= 0xffc7) ||
              (0xffca <= wch && wch <= 0xffcf) ||
              (0xffd2 <= wch && wch <= 0xffd7) ||
              (0xffda <= wch && wch <= 0xffdc)   )
        /* Halfwidth Hangule variants */
        return FALSE;
    else if (0xffe0 <= wch && wch <= 0xffe6)
        /* Fullwidth symbol variants */
        return TRUE;
    else if (0x4e00 <= wch && wch <= 0x9fa5)
        /* Han Ideographic */
        return TRUE;
    else if (0xf900 <= wch && wch <= 0xfa2d)
        /* Han Compatibility Ideographs */
        return TRUE;
    else
    {
        BOOL ret;

        /* Unknown character */

        ret = GetTextMetricsW(hDC, &tmi);
        if (! ret) {
            KdPrint(("CONSRV: IsConsoleFullWidth: GetTextMetricsW failed 0x%x\n",GetLastError()));
            return FALSE;
        }
        if (IS_ANY_DBCS_CHARSET(tmi.tmCharSet))
            tmi.tmMaxCharWidth /= 2;

        ret = GetCharWidth32(hDC, wch, wch, &Width);
        if (! ret) {
            KdPrint(("CONSRV: IsConsoleFullWidth: GetCharWidth32 failed 0x%x\n",GetLastError()));
            return FALSE;
        }
        if (Width == tmi.tmMaxCharWidth)
            return FALSE;
        else if (Width == tmi.tmMaxCharWidth*2)
            return TRUE;
    }
    ASSERT(FALSE);
    return FALSE;
}


/*++

Routine Description:

    This routine remove DBCS padding code.

Arguments:

    Dst - Pointer to destination.

    Src - Pointer to source.

    NumBytes - Number of string.

    OS2OemFormat -

Return Value:

--*/

DWORD
RemoveDbcsMark(
    IN PWCHAR Dst,
    IN PWCHAR Src,
    IN DWORD NumBytes,
    IN PCHAR SrcA,
    IN BOOL OS2OemFormat
    )
{
    PWCHAR Tmp = Dst;

    if (NumBytes == 0 || NumBytes >= 0xffffffff)
        return( 0 );

#if defined(i386)
    if (OS2OemFormat) {
        RealUnicodeToNEC_OS2_Unicode(Src, NumBytes);
    }
#endif

    if (SrcA) {
        while (NumBytes--)
        {
            if (!(*SrcA++ & ATTR_TRAILING_BYTE))
                *Dst++ = *Src;
            Src++;
        }
        return (ULONG)(Dst - Tmp);
    }
    else {
        RtlCopyMemory(Dst,Src,NumBytes * sizeof(WCHAR)) ;
        return(NumBytes) ;
    }
#if !defined(i386)
    UNREFERENCED_PARAMETER(OS2OemFormat);
#endif
}

/*++

Routine Description:

    This routine remove DBCS padding code for cell format.

Arguments:

    Dst - Pointer to destination.

    Src - Pointer to source.

    NumBytes - Number of string.

Return Value:

--*/

DWORD
RemoveDbcsMarkCell(
    IN PCHAR_INFO Dst,
    IN PCHAR_INFO Src,
    IN DWORD NumBytes
    )
{
    PCHAR_INFO Tmp = Dst;
    DWORD TmpByte;

    TmpByte = NumBytes;
    while (NumBytes--) {
        if (!(Src->Attributes & COMMON_LVB_TRAILING_BYTE)){
            *Dst = *Src;
            Dst->Attributes &= ~COMMON_LVB_SBCSDBCS;
            Dst++;
        }
        Src++;
    }
    NumBytes = (ULONG)(TmpByte - (Dst - Tmp));
    RtlZeroMemory(Dst, NumBytes * sizeof(CHAR_INFO));
    Dst += NumBytes;

    return (ULONG)(Dst - Tmp);
}

DWORD
RemoveDbcsMarkAll(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PROW Row,
    IN PSHORT LeftChar,
    IN PRECT TextRect,
    IN int *TextLeft,
    IN PWCHAR Buffer,
    IN SHORT NumberOfChars
    )
{
    BOOL OS2OemFormat = FALSE;

#if defined(i386)
    if ((ScreenInfo->Console->Flags & CONSOLE_OS2_REGISTERED) &&
        (ScreenInfo->Console->Flags & CONSOLE_OS2_OEM_FORMAT) &&
        (ScreenInfo->Console->OutputCP == OEMCP)) {
        OS2OemFormat = TRUE;
    }
#endif // i386

    if (NumberOfChars <= 0)
        return NumberOfChars;

    if ( !CONSOLE_IS_DBCS_OUTPUTCP(ScreenInfo->Console))
    {
        return RemoveDbcsMark(Buffer,
                              &Row->CharRow.Chars[*LeftChar],
                              NumberOfChars,
                              NULL,
                              OS2OemFormat
                             );
    }
    else if ( *LeftChar > ScreenInfo->Window.Left &&  Row->CharRow.KAttrs[*LeftChar] & ATTR_TRAILING_BYTE)
    {
        TextRect->left -= SCR_FONTSIZE(ScreenInfo).X;
        --*LeftChar;
        if (TextLeft)
            *TextLeft = TextRect->left;
        return RemoveDbcsMark(Buffer,
                              &Row->CharRow.Chars[*LeftChar],
                              NumberOfChars+1,
                              &Row->CharRow.KAttrs[*LeftChar],
                              OS2OemFormat
                             );
    }
    else if (*LeftChar == ScreenInfo->Window.Left && Row->CharRow.KAttrs[*LeftChar] & ATTR_TRAILING_BYTE)
    {
        *Buffer = UNICODE_SPACE;
        return RemoveDbcsMark(Buffer+1,
                              &Row->CharRow.Chars[*LeftChar+1],
                              NumberOfChars-1,
                              &Row->CharRow.KAttrs[*LeftChar+1],
                              OS2OemFormat
                             ) + 1;
    }
    else
    {
        return RemoveDbcsMark(Buffer,
                              &Row->CharRow.Chars[*LeftChar],
                              NumberOfChars,
                              &Row->CharRow.KAttrs[*LeftChar],
                              OS2OemFormat
                             );
    }
}


BOOL
IsDBCSLeadByteConsole(
    IN BYTE AsciiChar,
    IN LPCPINFO lpCPInfo
    )
{
    int i;

    i = 0;
    while (lpCPInfo->LeadByte[i]) {
        if (lpCPInfo->LeadByte[i] <= AsciiChar && AsciiChar <= lpCPInfo->LeadByte[i+1])
            return TRUE;
        i += 2;
    }
    return FALSE;
}


NTSTATUS
AdjustFont(
    IN PCONSOLE_INFORMATION Console,
    IN UINT CodePage
    )
{
    PSCREEN_INFORMATION ScreenInfo = Console->CurrentScreenBuffer;
    ULONG FontIndex;
    static const COORD NullCoord = {0, 0};
    TEXT_BUFFER_FONT_INFO TextFontInfo;
    NTSTATUS Status;

    Status = FindTextBufferFontInfo(ScreenInfo,
                                    CodePage,
                                    &TextFontInfo);
    if (NT_SUCCESS(Status)) {
        FontIndex = FindCreateFont(TextFontInfo.Family,
                                   TextFontInfo.FaceName,
                                   TextFontInfo.FontSize,
                                   TextFontInfo.Weight,
                                   CodePage);
    }
    else {
        FontIndex = FindCreateFont(0,
                                   SCR_FACENAME(ScreenInfo),
                                   NullCoord,                  // sets new font by FontSize=0
                                   0,
                                   CodePage);
    }
#ifdef i386
    if (! (Console->FullScreenFlags & CONSOLE_FULLSCREEN)) {
        SetScreenBufferFont(Console->CurrentScreenBuffer,FontIndex, CodePage);
    }
    else {
        BOOL fChange = FALSE;

        if ((Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) &&
            (GetForegroundWindow() == Console->hWnd)                    )
        {
            ChangeDispSettings(Console, Console->hWnd, 0);
            fChange = TRUE;
        }
        SetScreenBufferFont(Console->CurrentScreenBuffer,FontIndex, CodePage);
        ConvertToFullScreen(Console);
        if (fChange &&
            (GetForegroundWindow() == Console->hWnd))
            ChangeDispSettings(Console, Console->hWnd, CDS_FULLSCREEN);
    }
#else
    SetScreenBufferFont(Console->CurrentScreenBuffer,FontIndex, CodePage);
#endif
    return STATUS_SUCCESS;
}


NTSTATUS
ConvertToCodePage(
    IN PCONSOLE_INFORMATION Console,
    IN UINT PrevCodePage
    )
{
    PSCREEN_INFORMATION Cur;

    if (Console->OutputCP != OEMCP && PrevCodePage == OEMCP)
    {

        for (Cur=Console->ScreenBuffers;Cur!=NULL;Cur=Cur->Next) {

            if (Cur->Flags & CONSOLE_GRAPHICS_BUFFER) {
                continue;
            }

            ConvertOutputOemToNonOemUnicode(
                Cur->BufferInfo.TextInfo.TextRows,
                Cur->BufferInfo.TextInfo.DbcsScreenBuffer.KAttrRows,
                Cur->ScreenBufferSize.X * Cur->ScreenBufferSize.Y,
                Console->OutputCP);

            if ((Cur->Flags & CONSOLE_OEMFONT_DISPLAY) &&
                ((Console->FullScreenFlags & CONSOLE_FULLSCREEN) == 0)) {
                RealUnicodeToFalseUnicode(
                    Cur->BufferInfo.TextInfo.TextRows,
                    Cur->ScreenBufferSize.X * Cur->ScreenBufferSize.Y,
                    Console->OutputCP);
            }
        }

        if (Console->CurrentScreenBuffer->Flags & CONSOLE_TEXTMODE_BUFFER) {
            PCONVERSIONAREA_INFORMATION ConvAreaInfo;
            ConvAreaInfo = Console->ConsoleIme.ConvAreaRoot;
            while (ConvAreaInfo) {
                Cur = ConvAreaInfo->ScreenBuffer;

                if (!(Cur->Flags & CONSOLE_GRAPHICS_BUFFER)) {

                    ConvertOutputOemToNonOemUnicode(
                        Cur->BufferInfo.TextInfo.TextRows,
                        Cur->BufferInfo.TextInfo.DbcsScreenBuffer.KAttrRows,
                        Cur->ScreenBufferSize.X * Cur->ScreenBufferSize.Y,
                        Console->OutputCP);

                    if ((Cur->Flags & CONSOLE_OEMFONT_DISPLAY) &&
                        ((Console->FullScreenFlags & CONSOLE_FULLSCREEN) == 0)) {
                        RealUnicodeToFalseUnicode(
                            Cur->BufferInfo.TextInfo.TextRows,
                            Cur->ScreenBufferSize.X * Cur->ScreenBufferSize.Y,
                            Console->OutputCP);
                    }
                }

                ConvAreaInfo = ConvAreaInfo->ConvAreaNext;
            }

            Console->CurrentScreenBuffer->BufferInfo.TextInfo.Flags &= ~TEXT_VALID_HINT;
        }

#ifdef FE_SB
        else
        {
            // Check code for must CONSOLE_TEXTMODE_BUFFER !!
            ASSERT(FALSE);
        }
#endif

        SetWindowSize(Console->CurrentScreenBuffer);
        WriteToScreen(Console->CurrentScreenBuffer,&Console->CurrentScreenBuffer->Window);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
ConvertOutputOemToNonOemUnicode(
    IN OUT LPWSTR Source,
    IN OUT PBYTE KAttrRows,
    IN int SourceLength, // in chars
    IN UINT Codepage
    )
{
    NTSTATUS Status;
    LPSTR  pTemp;
    LPWSTR pwTemp;
    ULONG TempLength;
    ULONG Length;
    BOOL NormalChars;
    int i;

    if (SourceLength == 0 )
        return STATUS_SUCCESS;

    NormalChars = TRUE;
    for (i=0;i<SourceLength;i++) {
        if (Source[i] > 0x7f) {
            NormalChars = FALSE;
            break;
        }
    }
    if (NormalChars) {
        return STATUS_SUCCESS;
    }

    pTemp = (LPSTR)ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ),SourceLength);
    if (pTemp == NULL) {
        return STATUS_NO_MEMORY;
    }

    pwTemp = (LPWSTR)ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ),SourceLength * sizeof(WCHAR));
    if (pwTemp == NULL) {
        ConsoleHeapFree(pTemp);
        return STATUS_NO_MEMORY;
    }

    TempLength = RemoveDbcsMark(pwTemp,
                                Source,
                                SourceLength,
                                KAttrRows,
                                FALSE);

    Status = RtlUnicodeToOemN(pTemp,
                              (ULONG)ConsoleHeapSize(pTemp),
                              &Length,
                              pwTemp,
                              TempLength * sizeof(WCHAR)
                             );
    if (!NT_SUCCESS(Status)) {
        ConsoleHeapFree(pTemp);
        ConsoleHeapFree(pwTemp);
        return Status;
    }

    MultiByteToWideChar(Codepage,
                        0,
                        pTemp,
                        Length,
                        Source,
                        SourceLength
                       );
    ConsoleHeapFree(pTemp);
    ConsoleHeapFree(pwTemp);

    if (!NT_SUCCESS(Status)) {
        return Status;
    } else {
        if (KAttrRows) {
            RtlZeroMemory(KAttrRows, SourceLength);
        }
        return STATUS_SUCCESS;
    }
}






VOID
TextOutEverything(
    IN PCONSOLE_INFORMATION Console,
    IN PSCREEN_INFORMATION ScreenInfo,
    IN SHORT LeftWindowPos,
    IN OUT PSHORT RightWindowPos,
    IN OUT PSHORT CountOfAttr,
    IN SHORT CountOfAttrOriginal,
    IN OUT PBOOL DoubleColorDBCS,
    IN BOOL LocalEUDCFlag,
    IN PROW Row,
    IN PATTR_PAIR Attr,
    IN SHORT LeftTextPos,
    IN SHORT RightTextPos,
    IN int WindowRectLeft,
    IN RECT WindowRect,
    IN SHORT NumberOfChars
    )

/*++

Routine Description:

    This routine text out everything.

Arguments:

Return Value:

--*/

{
    int   j = LeftWindowPos;
    int   TextLeft = WindowRectLeft;
    RECT TextRect = WindowRect;
    SHORT LeftChar = LeftTextPos;
    SHORT RightChar = RightTextPos;
    BOOL  DoubleColorDBCSBefore;
    BOOL  LocalEUDCFlagBefore;
    PEUDC_INFORMATION EudcInfo;

    int   RightPos  = j + *CountOfAttr - 1;
    int   RightText = LeftChar + *CountOfAttr - 1;
    BOOL  OS2OemFormat = FALSE;

#ifdef FE_SB
    // Check code for must CONSOLE_TEXTMODE_BUFFER !!
    ASSERT(!(ScreenInfo->Flags & CONSOLE_GRAPHICS_BUFFER));
#endif

#if defined(i386)
    if ((ScreenInfo->Console->Flags & CONSOLE_OS2_REGISTERED) &&
        (ScreenInfo->Console->Flags & CONSOLE_OS2_OEM_FORMAT) &&
        (ScreenInfo->Console->OutputCP == OEMCP)) {
        OS2OemFormat = TRUE;
    }
#endif // i386

#if defined(DBG) && defined(DBG_KATTR)
    BeginKAttrCheck(ScreenInfo);
#endif

    RightText = min(RightText,(ScreenInfo->ScreenBufferSize.X-1));

    LocalEUDCFlagBefore = LocalEUDCFlag ;
    EudcInfo = (PEUDC_INFORMATION)Console->EudcInformation;

    DoubleColorDBCSBefore = *DoubleColorDBCS ;
    if (DoubleColorDBCSBefore){
        RECT TmpRect;

        if (Console->FonthDC == NULL) {
            Console->FonthDC = CreateCompatibleDC(Console->hDC);
            Console->hBitmap = CreateBitmap(DEFAULT_FONTSIZE, DEFAULT_FONTSIZE, BITMAP_PLANES, BITMAP_BITS_PIXEL, NULL);
            SelectObject(Console->FonthDC, Console->hBitmap);
        }

        if (LocalEUDCFlagBefore){
            if (EudcInfo->hDCLocalEudc == NULL) {
                EudcInfo->hDCLocalEudc = CreateCompatibleDC(Console->hDC);
                EudcInfo->hBmpLocalEudc = CreateBitmap(EudcInfo->LocalEudcSize.X,
                                                       EudcInfo->LocalEudcSize.Y,
                                                       BITMAP_PLANES, BITMAP_BITS_PIXEL, NULL);
                SelectObject(EudcInfo->hDCLocalEudc, EudcInfo->hBmpLocalEudc);
            }
            GetFitLocalEUDCFont(Console,
                                Row->CharRow.Chars[LeftChar-1]);
            BitBlt(Console->hDC,
                   TextRect.left,
                   TextRect.top,
                   SCR_FONTSIZE(ScreenInfo).X,
                   SCR_FONTSIZE(ScreenInfo).Y,
                   EudcInfo->hDCLocalEudc,
                   SCR_FONTSIZE(ScreenInfo).X,
                   0,
                   SRCCOPY
                  );
            TextRect.left += SCR_FONTSIZE(ScreenInfo).X;
            TextLeft +=  SCR_FONTSIZE(ScreenInfo).X;
            TextRect.right += SCR_FONTSIZE(ScreenInfo).X;
            (*CountOfAttr)++;
            NumberOfChars = 0;
        }
        else{
            TmpRect.left = 0;
            TmpRect.top = 0;
            TmpRect.right = SCR_FONTSIZE(ScreenInfo).X;
            TmpRect.bottom = SCR_FONTSIZE(ScreenInfo).Y;

            SelectObject(Console->FonthDC,
                         FontInfo[SCR_FONTNUMBER(ScreenInfo)].hFont
                        );

            ExtTextOutW(Console->FonthDC,
                        0,
                        0,
                        ETO_OPAQUE,
                        &TmpRect,
                        &Row->CharRow.Chars[LeftChar-1],
                        1,
                        NULL
                       );
            BitBlt(Console->hDC,
                   TextRect.left,
                   TextRect.top,
                   SCR_FONTSIZE(ScreenInfo).X,
                   SCR_FONTSIZE(ScreenInfo).Y,
                   Console->FonthDC,
                   SCR_FONTSIZE(ScreenInfo).X,
                   0,
                   SRCCOPY
                  );
            TextRect.left += SCR_FONTSIZE(ScreenInfo).X;
            TextLeft += SCR_FONTSIZE(ScreenInfo).X;
            NumberOfChars = (SHORT)RemoveDbcsMark(ScreenInfo->BufferInfo.TextInfo.DbcsScreenBuffer.TransBufferCharacter,
                                                  &Row->CharRow.Chars[LeftChar+1],
                                                  NumberOfChars-1,
                                                  &Row->CharRow.KAttrs[LeftChar+1],
                                                  OS2OemFormat);
        }

    }
    else {
        NumberOfChars = (SHORT)RemoveDbcsMarkAll(ScreenInfo,
                                                 Row,
                                                 &LeftChar,
                                                 &TextRect,
                                                 &TextLeft,
                                                 ScreenInfo->BufferInfo.TextInfo.DbcsScreenBuffer.TransBufferCharacter,
                                                 NumberOfChars);
    }


    *DoubleColorDBCS = FALSE ;
    if ((NumberOfChars != 0) && (Row->CharRow.KAttrs[RightText] & ATTR_LEADING_BYTE)){
        if (RightPos >= ScreenInfo->Window.Right)
            *(ScreenInfo->BufferInfo.TextInfo.DbcsScreenBuffer.TransBufferCharacter+NumberOfChars-1) = UNICODE_SPACE;
        else if(TextRect.right <= ScreenInfo->Window.Right * SCR_FONTSIZE(ScreenInfo).X) {
            *DoubleColorDBCS = TRUE;
            TextRect.right += SCR_FONTSIZE(ScreenInfo).X;
            if((j == *RightWindowPos)&&
               (*RightWindowPos < ScreenInfo->Window.Right))
            *RightWindowPos++;
        }
    }

    if( TextRect.left < TextRect.right){
        ExtTextOutW(Console->hDC,
                    TextLeft,
                    TextRect.top,
                    ETO_OPAQUE,
                    &TextRect,
                    ScreenInfo->BufferInfo.TextInfo.DbcsScreenBuffer.TransBufferCharacter,
                    NumberOfChars,
                    NULL
                   );
    }
    if (LocalEUDCFlagBefore){
        DWORD dwFullWidth = (IsConsoleFullWidth(Console->hDC,
                                                Console->OutputCP,
                                                Row->CharRow.Chars[RightText+1]) ? 2 : 1);

        if (EudcInfo->hDCLocalEudc == NULL) {
            EudcInfo->hDCLocalEudc = CreateCompatibleDC(Console->hDC);
            EudcInfo->hBmpLocalEudc = CreateBitmap(EudcInfo->LocalEudcSize.X,
                                                   EudcInfo->LocalEudcSize.Y,
                                                   BITMAP_PLANES, BITMAP_BITS_PIXEL, NULL);
            SelectObject(EudcInfo->hDCLocalEudc, EudcInfo->hBmpLocalEudc);
        }
        GetFitLocalEUDCFont(Console,
                            Row->CharRow.Chars[RightText+1]);
        BitBlt(Console->hDC,                      // hdcDest
               TextRect.right,                    // nXDest
               TextRect.top,                      // nYDest
               SCR_FONTSIZE(ScreenInfo).X * dwFullWidth, // nWidth
               SCR_FONTSIZE(ScreenInfo).Y,    // nHeight
               EudcInfo->hDCLocalEudc,            // hdcSrc
               0,                                 // nXSrc
               0,                                 // nYSrc
               SRCCOPY
              );

        TextRect.right += (SCR_FONTSIZE(ScreenInfo).X * dwFullWidth);
        (*CountOfAttr) += (SHORT)dwFullWidth;
        if (CountOfAttrOriginal < *CountOfAttr ){
            *DoubleColorDBCS = TRUE ;
            (*CountOfAttr)--;
            TextRect.right -= SCR_FONTSIZE(ScreenInfo).X;
        }
    }
    if (DoubleColorDBCSBefore){
        TextRect.left -= SCR_FONTSIZE(ScreenInfo).X;
    }

    TextOutCommonLVB(Console, Attr->Attr, TextRect);

}

VOID
TextOutCommonLVB(
    IN PCONSOLE_INFORMATION Console,
    IN WORD Attributes,
    IN RECT CommonLVBRect
    )
{
    HBRUSH hbrSave;
    HGDIOBJ hbr;
    int GridX;

    if (Attributes & (COMMON_LVB_GRID_HORIZONTAL |
                      COMMON_LVB_GRID_LVERTICAL  |
                      COMMON_LVB_GRID_RVERTICAL  |
                      COMMON_LVB_UNDERSCORE       )
       )
    {
        if(Attributes & COMMON_LVB_UNDERSCORE){
            if(Attributes & COMMON_LVB_REVERSE_VIDEO)
                hbr = CreateSolidBrush(ConvertAttrToRGB(Console, LOBYTE(Attributes >> 4)));
            else
                hbr = CreateSolidBrush(ConvertAttrToRGB(Console, LOBYTE(Attributes)));
            hbrSave = SelectObject(Console->hDC, hbr);
            PatBlt(Console->hDC,
                   CommonLVBRect.left,
                   CommonLVBRect.bottom-1,
                   CommonLVBRect.right-CommonLVBRect.left,
                   1,
                   PATCOPY
                  );
            SelectObject(Console->hDC, hbrSave);
            DeleteObject(hbr);
        }

        if(Attributes & (COMMON_LVB_GRID_HORIZONTAL | COMMON_LVB_GRID_LVERTICAL | COMMON_LVB_GRID_RVERTICAL)){
            hbr = CreateSolidBrush(ConvertAttrToRGB(Console, 0x0007));
            hbrSave = SelectObject(Console->hDC, hbr);

            if(Attributes & COMMON_LVB_GRID_HORIZONTAL){
                PatBlt(Console->hDC,
                       CommonLVBRect.left,
                       CommonLVBRect.top,
                       CommonLVBRect.right-CommonLVBRect.left,
                       1,
                       PATCOPY
                      );
            }
            if(Attributes & COMMON_LVB_GRID_LVERTICAL){
                for ( GridX = CommonLVBRect.left ;
                      GridX < CommonLVBRect.right ;
                      GridX += CON_FONTSIZE(Console).X){
                    PatBlt(Console->hDC,
                           GridX,
                           CommonLVBRect.top,
                           1,
                           CON_FONTSIZE(Console).Y,
                           PATCOPY
                          );
                }
            }
            if(Attributes & COMMON_LVB_GRID_RVERTICAL){
                for ( GridX = CommonLVBRect.left + CON_FONTSIZE(Console).X-1 ;
                      GridX < CommonLVBRect.right ;
                      GridX += CON_FONTSIZE(Console).X){
                    PatBlt(Console->hDC,
                           GridX,
                           CommonLVBRect.top,
                           1,
                           CON_FONTSIZE(Console).Y,
                           PATCOPY
                          );
                }
            }
            SelectObject(Console->hDC, hbrSave);
            DeleteObject(hbr);
        }
    }
}

NTSTATUS
MakeAltRasterFont(
    UINT CodePage,
    COORD DefaultFontSize,
    COORD *AltFontSize,
    BYTE  *AltFontFamily,
    ULONG *AltFontIndex,
    LPWSTR AltFaceName
    )
{
    DWORD i;
    DWORD Find;
    ULONG FontIndex;
    COORD FontSize = DefaultFontSize;
    COORD FontDelta;
    BOOL  fDbcsCharSet = IsAvailableFarEastCodePage(CodePage);

    FontIndex = 0;
    Find = (DWORD)-1;
    for (i=0; i < NumberOfFonts; i++)
    {
        if (!TM_IS_TT_FONT(FontInfo[i].Family) &&
            IS_ANY_DBCS_CHARSET(FontInfo[i].tmCharSet) == fDbcsCharSet
           )
        {
            FontDelta.X = (SHORT)abs(FontSize.X - FontInfo[i].Size.X);
            FontDelta.Y = (SHORT)abs(FontSize.Y - FontInfo[i].Size.Y);
            if (Find > (DWORD)(FontDelta.X + FontDelta.Y))
            {
                Find = (DWORD)(FontDelta.X + FontDelta.Y);
                FontIndex = i;
            }
        }
    }

    *AltFontIndex = FontIndex;
    wcscpy(AltFaceName, FontInfo[*AltFontIndex].FaceName);
    *AltFontSize = FontInfo[*AltFontIndex].Size;
    *AltFontFamily = FontInfo[*AltFontIndex].Family;

    DBGFONTS(("MakeAltRasterFont : AltFontIndex = %ld\n", *AltFontIndex));

    return STATUS_SUCCESS;
}


NTSTATUS
InitializeDbcsMisc(
    VOID
    )
{
    HANDLE hkRegistry = NULL;
    NTSTATUS Status;
    WCHAR awchValue[ 512 ];
    WCHAR awchData[ 512 ];
    BYTE  Buffer[ 512 ];
    DWORD Length;
    DWORD dwIndex;
    LPWSTR pwsz;

    ASSERT(gTTFontList.Next==NULL);
    ASSERT(gRegFullScreenCodePage.Next==NULL);

    gTTFontList.Next = NULL;
    gRegFullScreenCodePage.Next = NULL;

    /*
     * Get TrueType Font Face name from registry.
     */
    Status = MyRegOpenKey(NULL,
                          MACHINE_REGISTRY_CONSOLE_TTFONT,
                          &hkRegistry);
    if (!NT_SUCCESS( Status )) {
        DBGPRINT(("CONSRV: NtOpenKey failed %ws\n", MACHINE_REGISTRY_CONSOLE_TTFONT));
    }
    else {
        LPTTFONTLIST pTTFontList;

        for( dwIndex = 0; ; dwIndex++) {
            Status = MyRegEnumValue(hkRegistry,
                                    dwIndex,
                                    sizeof(awchValue), (LPWSTR)&awchValue,
                                    sizeof(awchData),  (PBYTE)&awchData);
            if (!NT_SUCCESS( Status )) {
                break;
            }

            pTTFontList = ConsoleHeapAlloc(
                                    MAKE_TAG( SCREEN_DBCS_TAG ),
                                    sizeof(TTFONTLIST));
            if (pTTFontList == NULL) {
                break;
            }

            pTTFontList->List.Next = NULL;
            pTTFontList->CodePage = ConvertStringToDec(awchValue, NULL);
            pwsz = awchData;
            if (*pwsz == BOLD_MARK) {
                pTTFontList->fDisableBold = TRUE;
                pwsz++;
            }
            else
                pTTFontList->fDisableBold = FALSE;
            wcscpy(pTTFontList->FaceName1, pwsz);

            pwsz += wcslen(pwsz) + 1;
            if (*pwsz == BOLD_MARK) {
                pTTFontList->fDisableBold = TRUE;
                pwsz++;
            }
            wcscpy(pTTFontList->FaceName2, pwsz);

            PushEntryList(&gTTFontList, &(pTTFontList->List));
        }

        NtClose(hkRegistry);
    }

    /*
     * Get Full Screen from registry.
     */
    Status = MyRegOpenKey(NULL,
                          MACHINE_REGISTRY_CONSOLE_FULLSCREEN,
                          &hkRegistry);
    if (!NT_SUCCESS( Status )) {
        DBGPRINT(("CONSRV: NtOpenKey failed %ws\n", MACHINE_REGISTRY_CONSOLE_FULLSCREEN));
    }
    else {
        /*
         * InitialPalette
         */
        Status = MyRegQueryValueEx(hkRegistry,
                                   MACHINE_REGISTRY_INITIAL_PALETTE,
                                   sizeof( Buffer ), Buffer, &Length);
        if (NT_SUCCESS( Status ) && Length > sizeof(DWORD)) {
            DWORD PaletteLength = ((LPDWORD)Buffer)[0];
            PUSHORT Palette;

            if (PaletteLength * sizeof(USHORT) >= (Length - sizeof(DWORD)))
            {
                Palette = ConsoleHeapAlloc(
                                    MAKE_TAG( BUFFER_TAG ),
                                    Length);
                if (Palette != NULL)
                {
                    RtlCopyMemory(Palette, Buffer, Length);
                    RegInitialPalette = Palette;
                }
            }
        }

        /*
         * ColorBuffer
         */
        Status = MyRegQueryValueEx(hkRegistry,
                                   MACHINE_REGISTRY_COLOR_BUFFER,
                                   sizeof( Buffer ), Buffer, &Length);
        if (NT_SUCCESS( Status ) && Length > sizeof(DWORD)) {
            DWORD ColorBufferLength = ((LPDWORD)Buffer)[0];
            PUCHAR Color;

            if (ColorBufferLength * sizeof(DWORD) >= (Length - sizeof(DWORD)))
            {
                Color = ConsoleHeapAlloc(
                                  MAKE_TAG( BUFFER_TAG ),
                                  Length);
                if (Color != NULL)
                {
                    RtlCopyMemory(Color, Buffer, Length);
                    RegColorBuffer = Color;
                }
            }
        }

        /*
         * ColorBufferNoTranslate
         */
        Status = MyRegQueryValueEx(hkRegistry,
                                   MACHINE_REGISTRY_COLOR_BUFFER_NO_TRANSLATE,
                                   sizeof( Buffer ), Buffer, &Length);
        if (NT_SUCCESS( Status ) && Length > sizeof(DWORD)) {
            DWORD ColorBufferLength = ((LPDWORD)Buffer)[0];
            PUCHAR Color;

            if (ColorBufferLength * sizeof(DWORD) >= (Length - sizeof(DWORD)))
            {
                Color = ConsoleHeapAlloc(
                                  MAKE_TAG( BUFFER_TAG ),
                                  Length);
                if (Color != NULL)
                {
                    RtlCopyMemory(Color, Buffer, Length);
                    RegColorBufferNoTranslate = Color;
                }
            }
        }

        /*
         * ModeFontPairs
         */
        Status = MyRegQueryValueEx(hkRegistry,
                                   MACHINE_REGISTRY_MODE_FONT_PAIRS,
                                   sizeof( Buffer ), Buffer, &Length);
        if (NT_SUCCESS( Status ) && Length > sizeof(DWORD)) {
            DWORD NumOfEntries = ((LPDWORD)Buffer)[0];
            PMODE_FONT_PAIR ModeFont;

            if (NumOfEntries * sizeof(MODE_FONT_PAIR) >= (Length - sizeof(DWORD)))
            {
                ModeFont = ConsoleHeapAlloc(
                                     MAKE_TAG( BUFFER_TAG ),
                                     Length);
                if (ModeFont != NULL)
                {
                    Length -= sizeof(DWORD);
                    RtlCopyMemory(ModeFont, &Buffer[sizeof(DWORD)], Length);
                    RegModeFontPairs = ModeFont;
                    NUMBER_OF_MODE_FONT_PAIRS = NumOfEntries;
                }
            }
        }

        /*
         * FullScreen\CodePage
         */
        {
            HANDLE hkRegCP = NULL;

            Status = MyRegOpenKey(hkRegistry,
                                  MACHINE_REGISTRY_FS_CODEPAGE,
                                  &hkRegCP);
            if (!NT_SUCCESS( Status )) {
                DBGPRINT(("CONSRV: NtOpenKey failed %ws\n", MACHINE_REGISTRY_FS_CODEPAGE));
            }
            else {
                PFS_CODEPAGE pFsCodePage;

                for( dwIndex = 0; ; dwIndex++) {
                    Status = MyRegEnumValue(hkRegCP,
                                            dwIndex,
                                            sizeof(awchValue), (LPWSTR)&awchValue,
                                            sizeof(awchData),  (PBYTE)&awchData);
                    if (!NT_SUCCESS( Status )) {
                        break;
                    }

                    pFsCodePage = ConsoleHeapAlloc(
                                            MAKE_TAG( BUFFER_TAG ),
                                            sizeof(FS_CODEPAGE));
                    if (pFsCodePage == NULL) {
                        break;
                    }

                    pFsCodePage->List.Next = NULL;
                    pFsCodePage->CodePage = ConvertStringToDec(awchValue, NULL);

                    PushEntryList(&gRegFullScreenCodePage, &(pFsCodePage->List));
                }

                NtClose(hkRegCP);
            }
        }


        NtClose(hkRegistry);
    }


#if defined(i386)
    Status = NtGetMachineIdentifierValue(&gdwMachineId);
    if (!NT_SUCCESS(Status)) {
        gdwMachineId = MACHINEID_MS_PCAT;
    }
#endif

    Status = RtlInitializeCriticalSectionAndSpinCount(&ConIMEInitWindowsLock,
                                                      0x80000000);

    return Status;
}

#if defined(i386)
NTSTATUS
RealUnicodeToNEC_OS2_Unicode(
    IN OUT LPWSTR Source,
    IN int SourceLength      // in chars
    )

/*

    this routine converts a unicode string from the real unicode characters
    to the NEC OS/2 unicode characters.

*/

{
    NTSTATUS Status;
    LPSTR Temp;
    ULONG TempLength;
    ULONG Length;
    CHAR StackBuffer[STACK_BUFFER_SIZE];
    BOOL NormalChars;
    int i;

    DBGCHARS(("RealUnicodeToNEC_OS2_Unicode U->ACP:???->U %.*ls\n",
            SourceLength > 10 ? 10 : SourceLength, Source));
    NormalChars = TRUE;

    if (pGlyph_NEC_OS2_CP == NULL || pGlyph_NEC_OS2_CP->MultiByteTable == NULL) {
        DBGCHARS(("RealUnicodeToNEC_OS2_Unicode  xfer buffer null\n"));
        return STATUS_SUCCESS;  // there's nothing we can do
    }

    /*
     * Test for characters < 0x20.  If none are found, we don't have
     * any conversion to do!
     */
    for (i=0;i<SourceLength;i++) {
        if ((USHORT)(Source[i]) < 0x20) {
            NormalChars = FALSE;
            break;
        }
    }
    if (NormalChars) {
        return STATUS_SUCCESS;
    }

    TempLength = SourceLength;
    if (TempLength > STACK_BUFFER_SIZE) {
        Temp = (LPSTR)ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ),TempLength);
        if (Temp == NULL) {
            return STATUS_NO_MEMORY;
        }
    } else {
        Temp = StackBuffer;
    }
    Status = RtlUnicodeToMultiByteN(Temp,
                                    TempLength,
                                    &Length,
                                    Source,
                                    SourceLength * sizeof(WCHAR)
                                   );
    if (!NT_SUCCESS(Status)) {
        if (TempLength > STACK_BUFFER_SIZE) {
            ConsoleHeapFree(Temp);
        }
        return Status;
    }
    ASSERT(pGlyph_NEC_OS2_CP != NULL && pGlyph_NEC_OS2_CP->MultiByteTable != NULL);
    Status = RtlCustomCPToUnicodeN(pGlyph_NEC_OS2_CP,
                                   Source,
                                   SourceLength * sizeof(WCHAR),
                                   &Length,
                                   Temp,
                                   TempLength
                                  );
    if (TempLength > STACK_BUFFER_SIZE) {
        ConsoleHeapFree(Temp);
    }
    if (!NT_SUCCESS(Status)) {
        return Status;
    } else {
        return STATUS_SUCCESS;
    }
}

BOOL
InitializeNEC_OS2_CP(
    VOID
    )
{
    PPEB pPeb;

    pPeb = NtCurrentPeb();
    if ((pPeb == NULL) || (pPeb->OemCodePageData == NULL)) {
        return FALSE;
    }

    /*
     * Fill in the CPTABLEINFO struct
     */
    if (pGlyph_NEC_OS2_CP == NULL) {
        pGlyph_NEC_OS2_CP = (PCPTABLEINFO)ConsoleHeapAlloc( MAKE_TAG(SCREEN_DBCS_TAG), sizeof(CPTABLEINFO));
        if (pGlyph_NEC_OS2_CP == NULL) {
            return FALSE;
        }
    }
    RtlInitCodePageTable(pPeb->OemCodePageData, pGlyph_NEC_OS2_CP);

    /*
     * Make a copy of the MultiByteToWideChar table
     */
    if (pGlyph_NEC_OS2_Table == NULL) {
        pGlyph_NEC_OS2_Table = (PUSHORT)ConsoleHeapAlloc( MAKE_TAG(SCREEN_DBCS_TAG), 256 * sizeof(USHORT));
        if (pGlyph_NEC_OS2_Table == NULL) {
            return FALSE;
        }
    }
    RtlCopyMemory(pGlyph_NEC_OS2_Table, pGlyph_NEC_OS2_CP->MultiByteTable, 256 * sizeof(USHORT));

    /*
     * Modify the first 0x20 bytes so that they are glyphs.
     */
    MultiByteToWideChar(CP_OEMCP, MB_USEGLYPHCHARS,
            "\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20"
            "\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x20\x1E\x1F\x1C\x07",
            0x20, pGlyph_NEC_OS2_Table, 0x20);


    /*
     * Point the Custom CP at the glyph table
     */
    pGlyph_NEC_OS2_CP->MultiByteTable = pGlyph_NEC_OS2_Table;

    return TRUE;
}
#endif // i386

BYTE
CodePageToCharSet(
    UINT CodePage
    )
{
    CHARSETINFO csi;

    if (!TranslateCharsetInfo(IntToPtr(CodePage), &csi, TCI_SRCCODEPAGE))
        csi.ciCharset = OEM_CHARSET;

    return (BYTE)csi.ciCharset;
}

BOOL
IsAvailableFarEastCodePage(
    UINT CodePage
    )
{
    BYTE CharSet = CodePageToCharSet(CodePage);

    return IS_ANY_DBCS_CHARSET(CharSet);
}

LPTTFONTLIST
SearchTTFont(
    LPWSTR pwszFace,
    BOOL   fCodePage,
    UINT   CodePage
    )
{
    PSINGLE_LIST_ENTRY pTemp = gTTFontList.Next;

    if (pwszFace) {
        while (pTemp != NULL) {
            LPTTFONTLIST pTTFontList = (LPTTFONTLIST)pTemp;

            if (wcscmp(pwszFace, pTTFontList->FaceName1) == 0 ||
                wcscmp(pwszFace, pTTFontList->FaceName2) == 0    ) {
                if (fCodePage)
                    if (pTTFontList->CodePage == CodePage )
                        return pTTFontList;
                    else
                        return NULL;
                else
                    return pTTFontList;
            }

            pTemp = pTemp->Next;
        }
    }

    return NULL;
}

BOOL
IsAvailableTTFont(
    LPWSTR pwszFace
    )
{
    if (SearchTTFont(pwszFace, FALSE, 0))
        return TRUE;
    else
        return FALSE;
}

BOOL
IsAvailableTTFontCP(
    LPWSTR pwszFace,
    UINT CodePage
    )
{
    if (SearchTTFont(pwszFace, TRUE, CodePage))
        return TRUE;
    else
        return FALSE;
}

LPWSTR
GetAltFaceName(
    LPWSTR pwszFace
    )
{
    LPTTFONTLIST pTTFontList;

    pTTFontList = SearchTTFont(pwszFace, FALSE, 0);
    if (pTTFontList != NULL) {
        if (wcscmp(pwszFace, pTTFontList->FaceName1) == 0) {
            return pTTFontList->FaceName2;
        }
        if (wcscmp(pwszFace, pTTFontList->FaceName2) == 0) {
            return pTTFontList->FaceName1;
        }
        return NULL;
    }
    else
        return NULL;
}

BOOL
IsAvailableFsCodePage(
    UINT CodePage
    )
{
    PSINGLE_LIST_ENTRY pTemp = gRegFullScreenCodePage.Next;

    while (pTemp != NULL) {
        PFS_CODEPAGE pFsCodePage = (PFS_CODEPAGE)pTemp;

        if (pFsCodePage->CodePage == CodePage) {
            return TRUE;
        }

        pTemp = pTemp->Next;
    }

    return FALSE;
}


#if defined(FE_IME)
/*
 * Console IME executing logic.
 *
 * KERNEL32:ConDllInitialize
 *            If Reason is DLL_PROCESS_ATTACH
 *            |
 *            V
 * WINSRV:ConsoleClientConnectRoutine
 *          |
 *          V
 *          SetUpConsole
 *            |
 *            V
 *            AllocateConsole
 *              PostThreadMessage(CM_CREATE_CONSOLE_WINDOW)
 *          |
 *          V
 *          UnlockConsoleHandleTable
 *          InitConsoleIMEStuff
 *            |
 *            V
 *            If never register console IME
 *              hThread = InternalCreateCallbackThread(ConsoleIMERoutine)
 *              QueueThreadMessage(CM_WAIT_CONIME_PROCESS)
 *            |
 *            V
 *            QueueThreadMessage(CM_CONIME_CREATE)
 *          |
 *          V
 * KERNEL32:NtWaitForMultipleObjects(InitEvents)
 *
 *
 * WINSRV:InputThread
 *          |
 *          V
 *          GetMessage
 *            Receive CM_CREATE_CONSOLE_WINDOW
 *              |
 *              V
 *              ProcessCreateConsoleWindow
 *                |
 *                V
 *                CreateWindowsWindow
 *                  |
 *                  V
 *                  CreateWindowEx
 *                  NtSetEvent(InitEvents)
 *          |
 *          V
 *          GetMessage
 *            Receive CM_WAIT_CONIME_PROCESS (this case is never register console IME)
 *              |
 *              V
 *              WaitConsoleIMEStuff
 *                If never register console IME
 *                  NtWaitForSingleObject(hThread, 20 sec)
 *
 *
 * KERNEL32:ConsoleIMERoutine
 *            |
 *            V
 *            hEvent = CreateEvent(CONSOLEIME_EVENT)
 *            If not exist named event
 *              CreateProcess(conime.exe)
 *              WaitForSingleObject(hEvent, 10 sec)
 *              If WAIT_TIMEOUT
 *                TerminateProcess
 *            |
 *            V
 *            TerminateThread(hThread)
 *
 *
 * CONIME:WinMain
 *          |
 *          V
 *          CreateWindow
 *          RegisterConsoleIME
 *            |
 *            V
 *            WINSRV:ConSrvRegisterConsoleIME
 *                     |
 *                     V
 *                     QueueThreadMessage(CM_SET_CONSOLEIME_WINDOW)
 *          |
 *          V
 *          AttachThreadInput
 *          SetEvent(CONSOLEIME_EVENT)
 *
 *
 * WINSRV:InputThread
 *          |
 *          V
 *          GetMessage
 *            Receive CM_CONIME_CREATE
 *              |
 *              V
 *              ProcessCreateConsoleIME
 *                If available hWndConsoleIME
 *                  hIMC = SendMessage(console IME, CONIME_CREATE)
 *                Else
 *                  PostMessage(CM_CONIME_CREATE)
 *          |
 *          V
 *          GetMessage
 *            Receive CM_SET_CONSOLEIME_WINDOW
 *              TlsGetValue()->hWndConsoleIME = wParam
 *
 *
 * TerminateProcess of Console IME
 *   WINSRV:ConsoleClientDisconnectRoutine
 *            |
 *            V
 *            RemoveConsoleIME
 */

VOID
ProcessCreateConsoleIME(
    IN LPMSG lpMsg,
    DWORD dwConsoleThreadId
    )
{
    NTSTATUS Status;
    HANDLE ConsoleHandle = (HANDLE)lpMsg->wParam;
    PCONSOLE_INFORMATION pConsole;
    HWND hwndConIme;

    Status = RevalidateConsole(ConsoleHandle, &pConsole);
    if (!NT_SUCCESS(Status)) {
        return;  // STATUS_PROCESS_IS_TERMINATING
    }

    hwndConIme = pConsole->InputThreadInfo->hWndConsoleIME;

    if (pConsole->InputThreadInfo->hWndConsoleIME != NULL) {
        LRESULT lResult;

        if (!NT_SUCCESS(ConsoleImeMessagePumpWorker(pConsole,
                                  CONIME_CREATE,
                                  (WPARAM)pConsole->ConsoleHandle,
                                  (LPARAM)pConsole->hWnd,
                                  &lResult
                                 ))) {
            goto TerminateConsoleIme;
        }

        if (lResult)
        {
            DBGPRINT(("ConsoleIME connected(Create)\n")) ;

            if (!CONSOLE_IS_DBCS_CP(pConsole))
                pConsole->InputBuffer.ImeMode.Disable = TRUE;

            CreateConvAreaModeSystem(pConsole);

            if ((pConsole->Flags & CONSOLE_HAS_FOCUS) ||
                (pConsole->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE))
            {
                if (!NT_SUCCESS(ConsoleImeMessagePump(pConsole,
                                      CONIME_SETFOCUS,
                                      (WPARAM)pConsole->ConsoleHandle,
                                      (LPARAM)pConsole->hklActive
                                     ))) {
                    goto TerminateConsoleIme;
                }
            }

            if (pConsole->CurrentScreenBuffer->Flags & CONSOLE_TEXTMODE_BUFFER)
            {
                if (!NT_SUCCESS(ConsoleImeMessagePump(pConsole,
                                      CONIME_NOTIFY_SCREENBUFFERSIZE,
                                      (WPARAM)pConsole->ConsoleHandle,
                                      (LPARAM)MAKELPARAM(pConsole->CurrentScreenBuffer->ScreenBufferSize.X,
                                                         pConsole->CurrentScreenBuffer->ScreenBufferSize.Y)
                                     ))) {
                    goto TerminateConsoleIme;
                }
            }
            if (!NT_SUCCESS(ConsoleImeMessagePump(pConsole,
                                  CONIME_NOTIFY_CODEPAGE,
                                  (WPARAM)pConsole->ConsoleHandle,
                                  (LPARAM)MAKELPARAM(FALSE, pConsole->CP)
                                 ))) {
                goto TerminateConsoleIme;
            }
            if (!NT_SUCCESS(ConsoleImeMessagePump(pConsole,
                                  CONIME_NOTIFY_CODEPAGE,
                                  (WPARAM)pConsole->ConsoleHandle,
                                  (LPARAM)MAKELPARAM(TRUE, pConsole->OutputCP)
                                 ))) {
                goto TerminateConsoleIme;
            }

            if (!NT_SUCCESS(GetImeKeyState(pConsole, NULL))) {
                goto TerminateConsoleIme;
            }
        }
    }
    else if (lpMsg->lParam) {
        /*
         * This case, First = TRUE
         * Again post message of CM_CONIME_CREATE.
         * Becase hWndConsoleIME available when CM_SET_CONSOLEIME_WINDOW message
         * and it message will be run after this.
         */
        Status = QueueThreadMessage(dwConsoleThreadId,
                                    CM_CONIME_CREATE,
                                    (WPARAM)ConsoleHandle,
                                    (LPARAM)FALSE
                                    );

        if (!NT_SUCCESS(Status)) {
                RIPMSG1(RIP_WARNING, "QueueThreadMessage(CM_CONIME_CREATE) failed (%08x)\n", Status);
        }
    }
    UnlockConsole(pConsole);

    return;

TerminateConsoleIme:
    if (IsWindow(hwndConIme)) {
        PostMessage(hwndConIme, CONIME_DESTROY, (WPARAM)ConsoleHandle, (LPARAM)NULL);
    }
}

NTSTATUS
InitConsoleIMEStuff(
    HDESK hDesktop,
    DWORD dwConsoleThreadId,
    PCONSOLE_INFORMATION Console
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    CONSOLE_REGISTER_CONSOLEIME RegConIMEInfo;
    HANDLE hThread = NULL;
    BOOL First = FALSE;

    if (!gfLoadConIme) {
        KdPrint(("CONSRV: InitConsoleIMEStuff is skipping conime loading\n"));
        return STATUS_UNSUCCESSFUL; // the return value does not really matter...
    }

    RtlEnterCriticalSection(&ConIMEInitWindowsLock);

    RegConIMEInfo.hdesk      = hDesktop;
    RegConIMEInfo.dwThreadId = 0;
    RegConIMEInfo.dwAction   = REGCONIME_QUERY;
    NtUserConsoleControl(ConsoleRegisterConsoleIME, &RegConIMEInfo, sizeof(RegConIMEInfo));
    if (RegConIMEInfo.dwThreadId == 0)
    {
        /*
         * Create a Remote Thread on client side.
         * This remote thread do create a console IME process.
         */
        hThread = InternalCreateCallbackThread(CONSOLE_CLIENTPROCESSHANDLE(),
                                               (ULONG_PTR)ConsoleIMERoutine,
                                               (ULONG_PTR)0);
        if (hThread == NULL) {
            KdPrint(("CONSRV: CreateRemoteThread failed %x\n",GetLastError()));
        }
        else
        {
            /*
             * CM_WAIT_CONIME_PROCESS
             * This message wait for ready to go console IME process.
             */
            Status = QueueThreadMessage(dwConsoleThreadId,
                                        CM_WAIT_CONIME_PROCESS,
                                        (WPARAM)hDesktop,
                                        (LPARAM)hThread
                                        );
            if (!NT_SUCCESS(Status)) {
                RIPMSG1(RIP_WARNING, "QueueThreadMessage(CM_WAIT_CONIME_PROCESS) failed (%08x)\n", Status);
            } else {
                First = TRUE;
            }
        }
    }

    Status = QueueThreadMessage(dwConsoleThreadId,
                                CM_CONIME_CREATE,
                                (WPARAM)Console->ConsoleHandle,
                                (LPARAM)First
                                );
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "InitConsoleIMEStuff: QueueThreadMessage(CM_CONIME_CREATE) failed (%08x)\n", Status);
    }

    RtlLeaveCriticalSection(&ConIMEInitWindowsLock);

    return Status;
}

NTSTATUS
WaitConsoleIMEStuff(
    HDESK hDesktop,
    HANDLE hThread
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    CONSOLE_REGISTER_CONSOLEIME RegConIMEInfo;

    RtlEnterCriticalSection(&ConIMEInitWindowsLock);

    RegConIMEInfo.hdesk      = hDesktop;
    RegConIMEInfo.dwThreadId = 0;
    RegConIMEInfo.dwAction   = REGCONIME_QUERY;
    NtUserConsoleControl(ConsoleRegisterConsoleIME, &RegConIMEInfo, sizeof(RegConIMEInfo));

    RtlLeaveCriticalSection(&ConIMEInitWindowsLock);

    if (RegConIMEInfo.dwThreadId == 0)
    {
        int cLoops;
        LARGE_INTEGER li;

        /*
         * Do wait for ready to go console IME process.
         *
         * This wait code should after the CreateWindowsWindow
         * because doesn't finish DLL attach on client side
         * for wait a Console->InitEvents.
         */
        cLoops = 80;
        li.QuadPart = (LONGLONG)-10000 * 250;
        while (cLoops--)
        {
            /*
             * Sleep for a second.
             */
            Status = NtWaitForSingleObject(hThread, FALSE, &li);
            if (Status != STATUS_TIMEOUT) {
                break;
            }

            RtlEnterCriticalSection(&ConIMEInitWindowsLock);
            RegConIMEInfo.hdesk      = hDesktop;
            RegConIMEInfo.dwThreadId = 0;
            RegConIMEInfo.dwAction   = REGCONIME_QUERY;
            NtUserConsoleControl(ConsoleRegisterConsoleIME, &RegConIMEInfo, sizeof(RegConIMEInfo));
            RtlLeaveCriticalSection(&ConIMEInitWindowsLock);
            if (RegConIMEInfo.dwThreadId != 0) {
                break;
            }
        }
    }

    NtClose(hThread);

    return Status;
}

NTSTATUS
ConSrvRegisterConsoleIME(
    PCSR_PROCESS Process,
    HDESK hDesktop,
    HWINSTA hWinSta,
    HWND  hWndConsoleIME,
    DWORD dwConsoleIMEThreadId,
    DWORD dwAction,
    DWORD *dwConsoleThreadId
    )
{
    NTSTATUS Status;
    CONSOLE_REGISTER_CONSOLEIME RegConIMEInfo;
    PCONSOLE_PER_PROCESS_DATA ProcessData;

    RtlEnterCriticalSection(&ConIMEInitWindowsLock);

    ProcessData = CONSOLE_FROMPROCESSPERPROCESSDATA(Process);

    RegConIMEInfo.hdesk      = hDesktop;
    RegConIMEInfo.dwThreadId = 0;
    RegConIMEInfo.dwAction   = REGCONIME_QUERY;
    NtUserConsoleControl(ConsoleRegisterConsoleIME, &RegConIMEInfo, sizeof(RegConIMEInfo));
    if (RegConIMEInfo.dwConsoleInputThreadId == 0)
    {
        Status = STATUS_UNSUCCESSFUL;
        goto ErrorExit;
    }

    if (RegConIMEInfo.dwThreadId == 0)
    {
        /*
         * never registered console ime thread.
         */
        if (dwAction == REGCONIME_REGISTER)
        {
            /*
             * register
             */
            RegConIMEInfo.hdesk      = hDesktop;
            RegConIMEInfo.dwThreadId = dwConsoleIMEThreadId;
            RegConIMEInfo.dwAction   = dwAction;
            Status = NtUserConsoleControl(ConsoleRegisterConsoleIME, &RegConIMEInfo, sizeof(RegConIMEInfo));
            if (NT_SUCCESS(Status)) {
                Status = QueueThreadMessage(RegConIMEInfo.dwConsoleInputThreadId,
                                            CM_SET_CONSOLEIME_WINDOW,
                                            (WPARAM)hWndConsoleIME,
                                            0
                                            );
                if (!NT_SUCCESS(Status)) {
                    RIPMSG1(RIP_WARNING, "ConSrvRegisterConsoleIME: QueueThreadMessage failed (%08x)\n", Status);
                    Status = STATUS_UNSUCCESSFUL;
                    goto ErrorExit;
                }

                ProcessData->hDesk = hDesktop;
                ProcessData->hWinSta = hWinSta;

                if (dwConsoleThreadId)
                    *dwConsoleThreadId = RegConIMEInfo.dwConsoleInputThreadId;
            }
        }
        else
        {
            Status = STATUS_UNSUCCESSFUL;
            goto ErrorExit;
        }
    }
    else
    {
        /*
         * do registered console ime thread.
         */
        if ( (dwAction == REGCONIME_UNREGISTER) ||
             (dwAction == REGCONIME_TERMINATE)     )
        {
            /*
             * unregister
             */
            RegConIMEInfo.hdesk      = hDesktop;
            RegConIMEInfo.dwThreadId = dwConsoleIMEThreadId;
            RegConIMEInfo.dwAction   = dwAction;
            Status = NtUserConsoleControl(ConsoleRegisterConsoleIME, &RegConIMEInfo, sizeof(RegConIMEInfo));
            if (NT_SUCCESS(Status)) {
                Status = QueueThreadMessage(RegConIMEInfo.dwConsoleInputThreadId,
                                            CM_SET_CONSOLEIME_WINDOW,
                                            (WPARAM)NULL,
                                            0
                                            );
                if (!NT_SUCCESS(Status)) {
                    RIPMSG1(RIP_WARNING, "ConSrvRegisterConsoleIME: QueueThreadMessage failed (%08x)\n", Status);
                    Status = STATUS_UNSUCCESSFUL;
                    goto ErrorExit;
                }

                CloseDesktop(ProcessData->hDesk);
                CloseWindowStation(ProcessData->hWinSta);

                ProcessData->hDesk = NULL;
                ProcessData->hWinSta = NULL;

                if (dwConsoleThreadId)
                    *dwConsoleThreadId = RegConIMEInfo.dwConsoleInputThreadId;
            }
        }
        else
        {
            Status = STATUS_UNSUCCESSFUL;
            goto ErrorExit;
        }
    }

ErrorExit:
    if (! NT_SUCCESS(Status))
    {
        CloseDesktop(hDesktop);
        CloseWindowStation(hWinSta);
    }

    RtlLeaveCriticalSection(&ConIMEInitWindowsLock);

    return Status;
}


VOID
RemoveConsoleIME(
    PCSR_PROCESS Process,
    DWORD dwConsoleIMEThreadId
    )
{
    NTSTATUS Status;
    CONSOLE_REGISTER_CONSOLEIME RegConIMEInfo;
    PCONSOLE_PER_PROCESS_DATA ProcessData;

    ProcessData = CONSOLE_FROMPROCESSPERPROCESSDATA(Process);

    //
    // This is console IME process
    //
    RtlEnterCriticalSection(&ConIMEInitWindowsLock);

    RegConIMEInfo.hdesk      = ProcessData->hDesk;
    RegConIMEInfo.dwThreadId = 0;
    RegConIMEInfo.dwAction   = REGCONIME_QUERY;
    NtUserConsoleControl(ConsoleRegisterConsoleIME, &RegConIMEInfo, sizeof(RegConIMEInfo));
    if (RegConIMEInfo.dwConsoleInputThreadId == 0)
    {
        Status = STATUS_UNSUCCESSFUL;
    }
    else
    if (dwConsoleIMEThreadId == RegConIMEInfo.dwThreadId)
    {
        /*
         * Unregister console IME
         */
        Status = ConSrvRegisterConsoleIME(Process,
                                          ProcessData->hDesk,
                                          ProcessData->hWinSta,
                                          NULL,
                                          dwConsoleIMEThreadId,
                                          REGCONIME_TERMINATE,
                                          NULL
                                         );
    }
    RtlLeaveCriticalSection(&ConIMEInitWindowsLock);

    return;
}


/*
 * Console IME message pump.
 *
 * Note for NT5 --- this function is build on bogus assumptions
 * (also has some nasty workaround for sloppy conime).
 * There's a chance that pConsole goes away while sendmessage
 * is processed by conime.
 * Keep in mind, anybody who calls this function should validate
 * the return status as appropriate.
 */

NTSTATUS
ConsoleImeMessagePumpWorker(
    PCONSOLE_INFORMATION Console,
    UINT    Message,
    WPARAM  wParam,
    LPARAM  lParam,
    LRESULT* lplResult)
{
    HWND    hWndConsoleIME = Console->InputThreadInfo->hWndConsoleIME;
    LRESULT fNoTimeout;
    PINPUT_THREAD_INFO InputThreadInfo;     // console thread info

    *lplResult = 0;

    if (hWndConsoleIME == NULL)
    {
        return STATUS_SUCCESS;
    }

    InputThreadInfo = TlsGetValue(InputThreadTlsIndex);

    if (InputThreadInfo != NULL)
    {
        HWND hWnd = Console->hWnd;

        /*
         * This thread is in InputThread()
         * We can try message pump.
         */

        fNoTimeout = SendMessageTimeout(hWndConsoleIME,
                                        Message,
                                        wParam,
                                        lParam,
                                        SMTO_ABORTIFHUNG | SMTO_NORMAL,
                                        CONIME_SENDMSG_TIMEOUT,
                                        lplResult);
        if (fNoTimeout)
        {
            return STATUS_SUCCESS;
        }

        if ((Console = GetWindowConsole(hWnd)) == NULL ||
                (Console->Flags & CONSOLE_TERMINATING)) {

            // This console is terminated.
            // ConsoleImeMessagePump gives up SendMessage to conime.

            return STATUS_INVALID_HANDLE;
        }

        /*
         * Timeout return from SendMessageTimeout
         * Or, Hung hWndConsoleIME.
         */
    }

    /*
     * This thread is in CsrApiRequestThread()
     * We can not try message pump.
     */

    DBGPRINT(("ConsoleImeMessagePumpWorker::PostMessage(0x%x)\n",Message));
    PostMessage(hWndConsoleIME,
                Message,
                wParam,
                lParam);

    return STATUS_SUCCESS;
}

NTSTATUS
ConsoleImeMessagePump(
    PCONSOLE_INFORMATION Console,
    UINT   Message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    LRESULT lResultDummy;

    return ConsoleImeMessagePumpWorker(Console, Message, wParam, lParam, &lResultDummy);
}

#endif // FE_IME




BOOL
RegisterKeisenOfTTFont(
    IN PSCREEN_INFORMATION ScreenInfo
    )
{
    NTSTATUS Status;
    COORD FontSize;
    DWORD BuffSize;
    LPSTRINGBITMAP StringBitmap;
    WCHAR wChar;
    WCHAR wCharBuf[2];
    ULONG ulNumFonts;
    DWORD dwFonts;
    PCONSOLE_INFORMATION Console = ScreenInfo->Console;

    GetNumFonts(&ulNumFonts);
    for (dwFonts=0; dwFonts < ulNumFonts; dwFonts++) {
        if (!TM_IS_TT_FONT(FontInfo[dwFonts].Family) &&
            IS_ANY_DBCS_CHARSET(FontInfo[dwFonts].tmCharSet)
           ) {
            GetFontSize(dwFonts, &FontSize);
            BuffSize = CalcBitmapBufferSize(FontSize,BYTE_ALIGN);
            StringBitmap = ConsoleHeapAlloc( MAKE_TAG( TMP_DBCS_TAG ), sizeof(STRINGBITMAP) + BuffSize);
            if (StringBitmap == NULL) {
                RIPMSG1(RIP_WARNING, "RegisterKeisenOfTTFont: cannot allocate memory (%d bytes)",
                          sizeof(STRINGBITMAP) + BuffSize);
                return FALSE;
            }

            if (SelectObject(Console->hDC,FontInfo[dwFonts].hFont)==0) {
                goto error_return;
            }

            for (wChar=0; wChar < UNICODE_SPACE; wChar++) {
                wCharBuf[0] = wChar;
                wCharBuf[1] = TEXT('\0');;
                if (GetStringBitmapW(Console->hDC,
                                     wCharBuf,
                                     1,
                                     sizeof(STRINGBITMAP) + BuffSize,
                                     (BYTE*)StringBitmap
                                    ) == 0) {
                    goto error_return;
                }
                FontSize.X = (WORD)StringBitmap->uiWidth;
                FontSize.Y = (WORD)StringBitmap->uiHeight;
                Status = RegisterLocalEUDC(Console,wChar,FontSize,StringBitmap->ajBits);
                if (! NT_SUCCESS(Status)) {
error_return:
                    ConsoleHeapFree(StringBitmap);
                    return FALSE;
                }
            }

            ConsoleHeapFree(StringBitmap);
        }
        ((PEUDC_INFORMATION)(Console->EudcInformation))->LocalKeisenEudcMode = TRUE ;
    }
    return TRUE;
}

ULONG
TranslateUnicodeToOem(
    IN PCONSOLE_INFORMATION Console,
    IN PWCHAR UnicodeBuffer,
    IN ULONG UnicodeCharCount,
    OUT PCHAR AnsiBuffer,
    IN ULONG AnsiByteCount,
    OUT PINPUT_RECORD DbcsLeadInpRec
    )
{
    ULONG i,j;
    PWCHAR TmpUni;
    BYTE AsciiDbcs[2];
    ULONG NumBytes;

    TmpUni = ConsoleHeapAlloc(MAKE_TAG( TMP_DBCS_TAG ),UnicodeCharCount*sizeof(WCHAR));
    if (TmpUni == NULL)
        return 0;

    memcpy(TmpUni,UnicodeBuffer,UnicodeCharCount*sizeof(WCHAR));
    AsciiDbcs[1] = 0;
    for (i=0,j=0; i<UnicodeCharCount; i++,j++) {
        if (IsConsoleFullWidth(Console->hDC,Console->CP,TmpUni[i])) {
            NumBytes = sizeof(AsciiDbcs);
            ConvertToOem(Console->CP,
                   &TmpUni[i],
                   1,
                   &AsciiDbcs[0],
                   NumBytes
                   );
            if (IsDBCSLeadByteConsole(AsciiDbcs[0],&Console->CPInfo)) {
                if (j < AnsiByteCount-1) {  // -1 is safe DBCS in buffer
                    AnsiBuffer[j] = AsciiDbcs[0];
                    j++;
                    AnsiBuffer[j] = AsciiDbcs[1];
                    AsciiDbcs[1] = 0;
                }
                else if (j == AnsiByteCount-1) {
                    AnsiBuffer[j] = AsciiDbcs[0];
                    j++;
                    break;
                }
                else {
                    AsciiDbcs[1] = 0;
                    break;
                }
            }
            else {
                AnsiBuffer[j] = AsciiDbcs[0];
                AsciiDbcs[1] = 0;
            }
        }
        else {
            ConvertToOem(Console->CP,
                   &TmpUni[i],
                   1,
                   &AnsiBuffer[j],
                   1
                   );
        }
    }
    if (DbcsLeadInpRec) {
        if (AsciiDbcs[1]) {
            DbcsLeadInpRec->EventType = KEY_EVENT;
            DbcsLeadInpRec->Event.KeyEvent.uChar.AsciiChar = AsciiDbcs[1];
        }
        else {
            RtlZeroMemory(DbcsLeadInpRec,sizeof(INPUT_RECORD));
        }
    }
    ConsoleHeapFree(TmpUni);
    return j;
}


DWORD
ImmConversionToConsole(
    DWORD fdwConversion
    )
{
    DWORD dwNlsMode;

    if (GetKeyState(VK_KANA) & KEY_TOGGLED) {
        fdwConversion = (fdwConversion & ~IME_CMODE_LANGUAGE) | (IME_CMODE_NATIVE | IME_CMODE_KATAKANA);
    }

    dwNlsMode = 0;
    if (fdwConversion & IME_CMODE_NATIVE) {
        if (fdwConversion & IME_CMODE_KATAKANA)
            dwNlsMode |= NLS_KATAKANA;
        else
            dwNlsMode |= NLS_HIRAGANA;
    }
    else {
        dwNlsMode |= NLS_ALPHANUMERIC;
    }

    if (fdwConversion & IME_CMODE_FULLSHAPE)
        dwNlsMode |= NLS_DBCSCHAR;

    if (fdwConversion & IME_CMODE_ROMAN)
        dwNlsMode |= NLS_ROMAN;

    if (fdwConversion & IME_CMODE_OPEN)
        dwNlsMode |= NLS_IME_CONVERSION;

    if (fdwConversion & IME_CMODE_DISABLE)
        dwNlsMode |= NLS_IME_DISABLE;

    return dwNlsMode;
}

DWORD
ImmConversionFromConsole(
    DWORD dwNlsMode
    )
{
    DWORD fdwConversion;

    fdwConversion = 0;
    if (dwNlsMode & (NLS_KATAKANA | NLS_HIRAGANA)) {
        fdwConversion |= IME_CMODE_NATIVE;
        if (dwNlsMode & NLS_KATAKANA)
            fdwConversion |= IME_CMODE_KATAKANA;
    }

    if (dwNlsMode & NLS_DBCSCHAR)
        fdwConversion |= IME_CMODE_FULLSHAPE;

    if (dwNlsMode & NLS_ROMAN)
        fdwConversion |= IME_CMODE_ROMAN;

    if (dwNlsMode & NLS_IME_CONVERSION)
        fdwConversion |= IME_CMODE_OPEN;

    if (dwNlsMode & NLS_IME_DISABLE)
        fdwConversion |= IME_CMODE_DISABLE;

    return fdwConversion;
}












#if defined(DBG) && defined(DBG_KATTR)
VOID
BeginKAttrCheck(
    IN PSCREEN_INFORMATION ScreenInfo
    )
{
    SHORT RowIndex;
    PROW Row;
    SHORT i;

    RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow) % ScreenInfo->ScreenBufferSize.Y;
    Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];

    for (i=0;i<ScreenInfo->ScreenBufferSize.Y;i++) {
        ASSERT (Row->CharRow.KAttrs);
        if (++RowIndex == ScreenInfo->ScreenBufferSize.Y) {
            RowIndex = 0;
        }
    }
}
#endif // DBG && DBG_KATTR

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\server\constubs.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    constubs.c

Abstract:

Author:

    KazuM Mar.05.1992

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


#if defined(FE_SB)
ULONG
SrvGetConsoleCharType(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Routine Description:

    This routine check character type.

Arguments:

    m - message containing api parameters

    ReplyStatus - Indicates whether to reply to the dll port.

Return Value:

--*/

{
    NTSTATUS Status;
    PCONSOLE_CHAR_TYPE_MSG a = (PCONSOLE_CHAR_TYPE_MSG)&m->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;
    PSCREEN_INFORMATION ScreenInfo;
    PHANDLE_DATA HandleData;
    SHORT RowIndex;
    PROW Row;
    PWCHAR Char;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->Handle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_READ,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {

        ScreenInfo = HandleData->Buffer.ScreenBuffer;

#if defined(DBG) && defined(DBG_KATTR)
        BeginKAttrCheck(ScreenInfo);
#endif

        if (a->coordCheck.X >= ScreenInfo->ScreenBufferSize.X ||
            a->coordCheck.Y >= ScreenInfo->ScreenBufferSize.Y) {
            Status = STATUS_INVALID_PARAMETER;
        }
        else {
            RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+a->coordCheck.Y) % ScreenInfo->ScreenBufferSize.Y;
            Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
            Char = &Row->CharRow.Chars[a->coordCheck.X];
            if (!CONSOLE_IS_DBCS_OUTPUTCP(ScreenInfo->Console))
                a->dwType = CHAR_TYPE_SBCS;
            else if (Row->CharRow.KAttrs[a->coordCheck.X] & ATTR_TRAILING_BYTE)
                a->dwType = CHAR_TYPE_TRAILING;
            else if (Row->CharRow.KAttrs[a->coordCheck.X] & ATTR_LEADING_BYTE)
                a->dwType = CHAR_TYPE_LEADING;
            else
                a->dwType = CHAR_TYPE_SBCS;
        }
    }

    UnlockConsole(Console);
    return((ULONG) Status);
    UNREFERENCED_PARAMETER(ReplyStatus);    // get rid of unreferenced parameter warning message
}

ULONG
SrvSetConsoleLocalEUDC(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Routine Description:

    This routine sets Local EUDC Font.

Arguments:

    m - message containing api parameters

    ReplyStatus - Indicates whether to reply to the dll port.

Return Value:

--*/

{
    PCONSOLE_LOCAL_EUDC_MSG a = (PCONSOLE_LOCAL_EUDC_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    CHAR Source[4];
    WCHAR Target[2];

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->Handle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (!NT_SUCCESS(Status)) {
        UnlockConsole(Console);
        return((ULONG) Status);
    }

    if (!CsrValidateMessageBuffer(m, &a->FontFace, ((a->FontSize.X + 7) / 8), a->FontSize.Y)) {
        UnlockConsole(Console);
        return STATUS_INVALID_PARAMETER;
    }

    Source[0] = (char)(a->CodePoint >> 8) ;
    Source[1] = (char)(a->CodePoint & 0x00ff) ;
    Source[2] = 0 ;
    ConvertOutputToUnicode(Console->OutputCP,Source,2,Target,1);

    if (IsEudcRange(Console,Target[0]))
    {
        Status = RegisterLocalEUDC(Console,Target[0],a->FontSize,a->FontFace);
        if (NT_SUCCESS(Status)) {
            ((PEUDC_INFORMATION)(Console->EudcInformation))->LocalVDMEudcMode = TRUE;
        }
    }
    else {
        UnlockConsole(Console);
        return (ULONG)STATUS_INVALID_PARAMETER;
    }

    UnlockConsole(Console);
    return STATUS_SUCCESS;
    UNREFERENCED_PARAMETER(ReplyStatus);    // get rid of unreferenced parameter warning message
}

ULONG
SrvSetConsoleCursorMode(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Routine Description:

    This routine sets Cursor Mode.

Arguments:

    m - message containing api parameters

    ReplyStatus - Indicates whether to reply to the dll port.

Return Value:

--*/

{
    PCONSOLE_CURSOR_MODE_MSG a = (PCONSOLE_CURSOR_MODE_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->Handle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (!NT_SUCCESS(Status)) {
        UnlockConsole(Console);
        return((ULONG) Status);
    }

    HandleData->Buffer.ScreenBuffer->BufferInfo.TextInfo.CursorBlink = (BOOLEAN)a->Blink ;
    HandleData->Buffer.ScreenBuffer->BufferInfo.TextInfo.CursorDBEnable = (BOOLEAN)a->DBEnable ;

    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);    // get rid of unreferenced parameter warning message
}


ULONG
SrvGetConsoleCursorMode(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Routine Description:

    This routine gets Cursor Mode.

Arguments:

    m - message containing api parameters

    ReplyStatus - Indicates whether to reply to the dll port.

Return Value:

--*/

{
    PCONSOLE_CURSOR_MODE_MSG a = (PCONSOLE_CURSOR_MODE_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->Handle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_READ,
                                 &HandleData
                                );
    if (!NT_SUCCESS(Status)) {
        UnlockConsole(Console);
        return((ULONG) Status);
    }

    a->Blink = HandleData->Buffer.ScreenBuffer->BufferInfo.TextInfo.CursorBlink ;
    a->DBEnable = HandleData->Buffer.ScreenBuffer->BufferInfo.TextInfo.CursorDBEnable ;

    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);    // get rid of unreferenced parameter warning message
}

ULONG
SrvRegisterConsoleOS2(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

  This function calls NEC PC-98 machine's only.

--*/

{
    PCONSOLE_REGISTEROS2_MSG a = (PCONSOLE_REGISTEROS2_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    HANDLE hEvent = NULL;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
#if defined(i386)
    {
        if (!a->fOs2Register) {
            Console->Flags &= ~ CONSOLE_OS2_REGISTERED;
            ResizeWindow(Console->CurrentScreenBuffer, &Console->Os2SavedWindowRect, FALSE);
        }
        else {
            Console->Flags |= CONSOLE_OS2_REGISTERED;
            Console->Os2SavedWindowRect = Console->CurrentScreenBuffer->Window;
        }
    }
#endif // i386

    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);    // get rid of unreferenced parameter warning message
}

ULONG
SrvSetConsoleOS2OemFormat(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

  This function calls NEC PC-98 machine's only.

--*/

{
    PCONSOLE_SETOS2OEMFORMAT_MSG a = (PCONSOLE_SETOS2OEMFORMAT_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
#if defined(i386)
    {
        if (!a->fOs2OemFormat) {
            Console->Flags &= ~CONSOLE_OS2_OEM_FORMAT;
        }
        else {
            Console->Flags |= CONSOLE_OS2_OEM_FORMAT;
        }
    }
#endif // i386

    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);    // get rid of unreferenced parameter warning message
}

#if defined(FE_IME)
ULONG
SrvGetConsoleNlsMode(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Routine Description:

    This routine gets NLS mode for input.

Arguments:

    m - message containing api parameters

    ReplyStatus - Indicates whether to reply to the dll port.

Return Value:

--*/

{
    NTSTATUS Status;
    PCONSOLE_NLS_MODE_MSG a = (PCONSOLE_NLS_MODE_MSG)&m->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    HANDLE hEvent = NULL;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->Handle,
                                 CONSOLE_INPUT_HANDLE,
                                 GENERIC_READ,
                                 &HandleData
                                );
    if (!NT_SUCCESS(Status)) {
        goto SrvGetConsoleNlsModeFailure;
    }

    Status = NtDuplicateObject(CONSOLE_CLIENTPROCESSHANDLE(),
                       a->hEvent,
                       NtCurrentProcess(),
                       &hEvent,
                       0,
                       FALSE,
                       DUPLICATE_SAME_ACCESS
                       );
    if (!NT_SUCCESS(Status)) {
        goto SrvGetConsoleNlsModeFailure;
    }

    /*
     * Caller should set FALSE on a->Ready.
     */
    if (a->Ready == FALSE)
    {
        a->Ready = HandleData->Buffer.InputBuffer->ImeMode.ReadyConversion;

        if (a->Ready == FALSE)
        {
            /*
             * If not ready ImeMode.Conversion,
             * then get conversion status from ConIME.
             */
            Status = QueueConsoleMessage(Console,
                        CM_GET_NLSMODE,
                        (WPARAM)hEvent,
                        0L
                       );
            if (!NT_SUCCESS(Status)) {
                goto SrvGetConsoleNlsModeFailure;
            }
        }
        else
        {
            if (! HandleData->Buffer.InputBuffer->ImeMode.Disable) {
                a->NlsMode = ImmConversionToConsole(
                                 HandleData->Buffer.InputBuffer->ImeMode.Conversion );
            }
            else {
                a->NlsMode = 0;
            }
            NtSetEvent(hEvent, NULL);
            NtClose(hEvent);
        }
    }
    else
    {
        if (! HandleData->Buffer.InputBuffer->ImeMode.Disable) {
            a->NlsMode = ImmConversionToConsole(
                             HandleData->Buffer.InputBuffer->ImeMode.Conversion );
        }
        else {
            a->NlsMode = 0;
        }
        NtSetEvent(hEvent, NULL);
        NtClose(hEvent);
    }

    UnlockConsole(Console);
    return((ULONG) Status);

SrvGetConsoleNlsModeFailure:
    if (hEvent) {
        NtSetEvent(hEvent, NULL);
        NtClose(hEvent);
    }
    UnlockConsole(Console);
    return((ULONG) Status);

    UNREFERENCED_PARAMETER(ReplyStatus);    // get rid of unreferenced parameter warning message
}

ULONG
SrvSetConsoleNlsMode(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Routine Description:

    This routine sets NLS mode for input.

Arguments:

    m - message containing api parameters

    ReplyStatus - Indicates whether to reply to the dll port.

Return Value:

--*/

{
    PCONSOLE_NLS_MODE_MSG a = (PCONSOLE_NLS_MODE_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    HANDLE hEvent = NULL;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->Handle,
                                 CONSOLE_INPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (!NT_SUCCESS(Status)) {
        goto SrvSetConsoleNlsModeFailure;
    }

    Status = NtDuplicateObject(CONSOLE_CLIENTPROCESSHANDLE(),
                       a->hEvent,
                       NtCurrentProcess(),
                       &hEvent,
                       0,
                       FALSE,
                       DUPLICATE_SAME_ACCESS
                       );
    if (!NT_SUCCESS(Status)) {
        goto SrvSetConsoleNlsModeFailure;
    }

    Status = QueueConsoleMessage(Console,
                CM_SET_NLSMODE,
                (WPARAM)hEvent,
                a->NlsMode
               );
    if (!NT_SUCCESS(Status)) {
        goto SrvSetConsoleNlsModeFailure;
    }

    UnlockConsole(Console);
    return Status;

SrvSetConsoleNlsModeFailure:
    if (hEvent) {
        NtSetEvent(hEvent, NULL);
        NtClose(hEvent);
    }
    UnlockConsole(Console);
    return Status;

    UNREFERENCED_PARAMETER(ReplyStatus);    // get rid of unreferenced parameter warning message
}

ULONG
SrvRegisterConsoleIME(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Routine Description:

    This routine register console IME on the current desktop.

Arguments:

    m - message containing api parameters

    ReplyStatus - Indicates whether to reply to the dll port.

Return Value:

--*/

{
    PCONSOLE_REGISTER_CONSOLEIME_MSG a = (PCONSOLE_REGISTER_CONSOLEIME_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCSR_PROCESS Process;
    HDESK hdesk;
    HWINSTA hwinsta;
    UNICODE_STRING strDesktopName;

    a->dwConsoleThreadId = 0;

    if (!CsrValidateMessageBuffer(m, &a->Desktop, a->DesktopLength, sizeof(BYTE))) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Connect to the windowstation and desktop.
    //

    if (!CsrImpersonateClient(NULL)) {
        return (ULONG)STATUS_BAD_IMPERSONATION_LEVEL;
    }

    Process = (PCSR_PROCESS)(CSR_SERVER_QUERYCLIENTTHREAD()->Process);
    if (a->DesktopLength)
        RtlInitUnicodeString(&strDesktopName, a->Desktop);
    else
        RtlInitUnicodeString(&strDesktopName, L"Default");
    hdesk = NtUserResolveDesktop(
            Process->ProcessHandle,
            &strDesktopName, FALSE, &hwinsta);

    CsrRevertToSelf();

    if (hdesk == NULL) {
        return (ULONG)STATUS_UNSUCCESSFUL;
    }

    Status = ConSrvRegisterConsoleIME(Process,
                                      hdesk,
                                      hwinsta,
                                      a->hWndConsoleIME,
                                      a->dwConsoleIMEThreadId,
                                      REGCONIME_REGISTER,
                                      &a->dwConsoleThreadId
                                     );


    return ((ULONG)Status);
    UNREFERENCED_PARAMETER(ReplyStatus);    // get rid of unreferenced parameter warning message
}

ULONG
SrvUnregisterConsoleIME(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Routine Description:

    This routine unregister console IME on the current desktop.

Arguments:

    m - message containing api parameters

    ReplyStatus - Indicates whether to reply to the dll port.

Return Value:

--*/

{
    PCONSOLE_UNREGISTER_CONSOLEIME_MSG a = (PCONSOLE_UNREGISTER_CONSOLEIME_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCSR_PROCESS Process;
    PCONSOLE_PER_PROCESS_DATA ProcessData;

    Process = (PCSR_PROCESS)(CSR_SERVER_QUERYCLIENTTHREAD()->Process);
    ProcessData = CONSOLE_FROMPROCESSPERPROCESSDATA(Process);

    Status = ConSrvRegisterConsoleIME(Process,
                                      ProcessData->hDesk,
                                      ProcessData->hWinSta,
                                      NULL,
                                      a->dwConsoleIMEThreadId,
                                      REGCONIME_UNREGISTER,
                                      NULL
                                     );


    return ((ULONG)Status);
    UNREFERENCED_PARAMETER(ReplyStatus);    // get rid of unreferenced parameter warning message
}
#endif // FE_IME

#endif // FE_SB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\server\conv.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    conv.h

Abstract:

    This module contains the internal structures and definitions used
    by the conversion area.

Author:

    KazuM Mar.8,1993

Revision History:

--*/

#ifndef _CONV_H_
#define _CONV_H_

#if defined(FE_IME)
//
//  Externs
//


//
// Attributes flags:
//
#define COMMON_LVB_GRID_SINGLEFLAG 0x2000 // DBCS: Grid attribute: use for ime cursor.

/*
 * Exported function
 */

/*
 * Internal function
 */

DWORD
NtUserCheckImeHotKey(
    UINT uVKey,
    LPARAM lParam
    );

BOOL
NtUserGetImeHotKey(
    IN DWORD dwID,
    OUT PUINT puModifiers,
    OUT PUINT puVKey,
    OUT HKL  *phkl);


/*
 * Prototype definition
 */

VOID
LinkConversionArea(
    IN PCONSOLE_INFORMATION Console,
    IN PCONVERSIONAREA_INFORMATION ConvAreaInfo
    );

NTSTATUS
FreeConvAreaScreenBuffer(
    IN PSCREEN_INFORMATION ScreenInfo
    );

NTSTATUS
AllocateConversionArea(
    IN PCONSOLE_INFORMATION Console,
    IN COORD dwScreenBufferSize,
    OUT PCONVERSIONAREA_INFORMATION *ConvAreaInfo
    );

NTSTATUS
SetUpConversionArea(
    IN PCONSOLE_INFORMATION Console,
    IN COORD coordCaBuffer,
    IN SMALL_RECT rcViewCaWindow,
    IN COORD coordConView,
    IN DWORD dwOption,
    OUT PCONVERSIONAREA_INFORMATION *ConvAreaInfo
    );


VOID
WriteConvRegionToScreen(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PCONVERSIONAREA_INFORMATION ConvAreaInfo,
    IN PSMALL_RECT ClippedRegion
    );

BOOL
ConsoleImeBottomLineUse(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN SHORT ScrollOffset
    );

VOID
ConsoleImeBottomLineInUse(
    IN PSCREEN_INFORMATION ScreenInfo
    );


NTSTATUS
CreateConvAreaUndetermine(
    PCONSOLE_INFORMATION Console
    );

NTSTATUS
CreateConvAreaModeSystem(
    PCONSOLE_INFORMATION Console
    );

NTSTATUS
WriteUndetermineChars(
    PCONSOLE_INFORMATION Console,
    LPWSTR lpString,
    PBYTE  lpAtr,
    PWORD  lpAtrIdx,
    DWORD  NumChars
    );

NTSTATUS
FillUndetermineChars(
    PCONSOLE_INFORMATION Console,
    PCONVERSIONAREA_INFORMATION ConvAreaInfo
    );

NTSTATUS
ConsoleImeCompStr(
    IN PCONSOLE_INFORMATION Console,
    IN LPCONIME_UICOMPMESSAGE CompStr
    );

NTSTATUS
ConsoleImeResizeModeSystemView(
    PCONSOLE_INFORMATION Console,
    SMALL_RECT WindowRect
    );

NTSTATUS
ConsoleImeResizeCompStrView(
    PCONSOLE_INFORMATION Console,
    SMALL_RECT WindowRect
    );

NTSTATUS
ConsoleImeResizeModeSystemScreenBuffer(
    PCONSOLE_INFORMATION Console,
    COORD NewScreenSize
    );

NTSTATUS
ConsoleImeResizeCompStrScreenBuffer(
    PCONSOLE_INFORMATION Console,
    COORD NewScreenSize
    );

SHORT
CalcWideCharToColumn(
    IN PCONSOLE_INFORMATION Console,
    IN PCHAR_INFO Buffer,
    IN DWORD NumberOfChars
    );




LONG
ConsoleImePaint(
    IN PCONSOLE_INFORMATION Console,
    IN PCONVERSIONAREA_INFORMATION ConvAreaInfo
    );




VOID
ConsoleImeViewInfo(
    IN PCONSOLE_INFORMATION Console,
    IN PCONVERSIONAREA_INFORMATION ConvAreaInfo,
    IN COORD coordConView
    );

VOID
ConsoleImeWindowInfo(
    IN PCONSOLE_INFORMATION Console,
    IN PCONVERSIONAREA_INFORMATION ConvAreaInfo,
    IN SMALL_RECT rcViewCaWindow
    );

NTSTATUS
ConsoleImeResizeScreenBuffer(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN COORD NewScreenSize,
    PCONVERSIONAREA_INFORMATION ConvAreaInfo
    );

NTSTATUS
ConsoleImeWriteOutput(
    IN PCONSOLE_INFORMATION Console,
    IN PCONVERSIONAREA_INFORMATION ConvAreaInfo,
    IN PCHAR_INFO Buffer,
    IN SMALL_RECT CharRegion,
    IN BOOL fUnicode
    );


NTSTATUS
ImeControl(
    IN PCONSOLE_INFORMATION Console,
    IN HWND hWndConsoleIME,
    IN PCOPYDATASTRUCT lParam
    ) ;

BOOL
InsertConverTedString(
    IN PCONSOLE_INFORMATION Console,
    LPWSTR lpStr
    ) ;


VOID
SetUndetermineAttribute(
    IN PCONSOLE_INFORMATION Console
    ) ;

VOID
StreamWriteToScreenBufferIME(
    IN PWCHAR String,
    IN SHORT StringLength,
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PCHAR StringA
    ) ;


//
// windows\imm\server\hotkey.c
//
DWORD
CheckImeHotKey(
    UINT uVKey,         // virtual key
    LPARAM lParam       // lparam of WM_KEYxxx message
    ) ;

//
// output.c (for use convarea.c\StreamWriteToScreenBufferIME() )
//

NTSTATUS
MergeAttrStrings(
    IN PATTR_PAIR Source,
    IN WORD SourceLength,
    IN PATTR_PAIR Merge,
    IN WORD MergeLength,
    OUT PATTR_PAIR *Target,
    OUT LPWORD TargetLength,
    IN SHORT StartIndex,
    IN SHORT EndIndex,
    IN PROW Row,
    IN PSCREEN_INFORMATION ScreenInfo
    ) ;


VOID
ResetTextFlags(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN SHORT StartX,
    IN SHORT StartY,
    IN SHORT EndX,
    IN SHORT EndY
    ) ;

#endif // FE_IME

#endif  // _CONV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\server\directio.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    directio.h

Abstract:

        This file implements the NT console direct I/O API

Author:

    KazuM Apr.19.1996

Revision History:

--*/

typedef struct _DIRECT_READ_DATA {
    PINPUT_INFORMATION InputInfo;
    PCONSOLE_INFORMATION Console;
    PCONSOLE_PER_PROCESS_DATA ProcessData;
    HANDLE HandleIndex;
} DIRECT_READ_DATA, *PDIRECT_READ_DATA;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\server\dbcs.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    dbcs.h

Abstract:

Author:

Revision History:

--*/


#define UNICODE_DBCS_PADDING 0xffff

#define DEFAULT_FONTSIZE   256
#define DEFAULT_EUDCSIZE   1

#define VDM_EUDC_FONT_SIZE_X 16
#define VDM_EUDC_FONT_SIZE_Y 16

#define USACP     1252
#define KOREAN_CP 949
#define JAPAN_CP  932

#if defined(FE_SB)
#define MIN_SCRBUF_WIDTH  12    // for suport display IME status
#define MIN_SCRBUF_HEIGHT  2    // for suport display IME status
#define MIN_WINDOW_HEIGHT  1
#endif



#if defined(i386)
extern ULONG  gdwMachineId;
#endif


extern ULONG DefaultFontIndex;
extern COORD DefaultFontSize;
extern BYTE  DefaultFontFamily;


typedef struct _MODE_FONT_PAIR {
    DWORD Mode;
        #define FS_MODE_TEXT     0x0001
        #define FS_MODE_GRAPHICS 0x0002
        #define FS_MODE_FIND     0x8000
        #define FS_TEXT          (FS_MODE_FIND+FS_MODE_TEXT)
        #define FS_GRAPHICS      (FS_MODE_FIND+FS_MODE_GRAPHICS)
    COORD ScreenSize;
    COORD Resolution;
    COORD FontSize;
} MODE_FONT_PAIR, *PMODE_FONT_PAIR;

typedef struct _FS_CODEPAGE {
    SINGLE_LIST_ENTRY List;
    UINT CodePage;
} FS_CODEPAGE, *PFS_CODEPAGE;

extern PUSHORT RegInitialPalette;
extern PUCHAR RegColorBuffer;
extern PUCHAR RegColorBufferNoTranslate;
extern DWORD NUMBER_OF_MODE_FONT_PAIRS;
extern PMODE_FONT_PAIR RegModeFontPairs;
extern SINGLE_LIST_ENTRY gRegFullScreenCodePage;    // This list contain FS_CODEPAGE data.



typedef struct tagSTRINGBITMAP
{
    UINT uiWidth;
    UINT uiHeight;
    BYTE ajBits[1];
} STRINGBITMAP, *LPSTRINGBITMAP;

UINT
GetStringBitmapW(
    HDC             hdc,
    LPWSTR          pwc,
    UINT            cwc,
    UINT            cbData,
    BYTE            *pSB
    );



//
// dbcs.c
//

#if defined(FE_IME)

#if defined(i386)
NTSTATUS
ImeWmFullScreen(
    IN BOOL Foreground,
    IN PCONSOLE_INFORMATION Console,
    IN PSCREEN_INFORMATION ScreenInfo
    );
#endif // i386


NTSTATUS
GetImeKeyState(
    IN PCONSOLE_INFORMATION Console,
    IN PDWORD pdwConversion
    );


NTSTATUS
SetImeKeyState(
    IN PCONSOLE_INFORMATION Console,
    IN DWORD fdwConversion
    );

NTSTATUS
SetImeCodePage(
    IN PCONSOLE_INFORMATION Console
    );

NTSTATUS
SetImeOutputCodePage(
    IN PCONSOLE_INFORMATION Console,
    IN PSCREEN_INFORMATION ScreenInfo,
    IN DWORD CodePage
    );
#endif // FE_IME

VOID
SetLineChar(
    IN PSCREEN_INFORMATION ScreenInfo
    );

BOOL
CheckBisectStringA(
    IN DWORD CodePage,
    IN PCHAR Buffer,
    IN DWORD NumBytes,
    IN LPCPINFO lpCPInfo
    );

VOID
BisectWrite(
    IN SHORT StringLength,
    IN COORD TargetPoint,
    IN PSCREEN_INFORMATION ScreenInfo
    );

VOID
BisectClipbrd(
    IN SHORT StringLength,
    IN COORD TargetPoint,
    IN PSCREEN_INFORMATION ScreenInfo,
    OUT PSMALL_RECT SmallRect
    );

VOID
BisectWriteAttr(
    IN SHORT StringLength,
    IN COORD TargetPoint,
    IN PSCREEN_INFORMATION ScreenInfo
    );

DWORD
RemoveDbcsMark(
    IN PWCHAR Dst,
    IN PWCHAR Src,
    IN DWORD NumBytes,
    IN PCHAR SrcA,
    IN BOOL OS2OemFormat
    );

DWORD
RemoveDbcsMarkCell(
    IN PCHAR_INFO Dst,
    IN PCHAR_INFO Src,
    IN DWORD NumBytes
    );

DWORD
RemoveDbcsMarkAll(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PROW Row,
    IN PSHORT LeftChar,
    IN PRECT TextRect,
    IN int *TextLeft,
    IN PWCHAR Buffer,
    IN SHORT NumberOfChars
    );

BOOL
IsDBCSLeadByteConsole(
    IN BYTE AsciiChar,
    IN LPCPINFO lpCPInfo
    );

NTSTATUS
AdjustFont(
    IN PCONSOLE_INFORMATION Console,
    IN UINT CodePage
    );

NTSTATUS
ConvertToCodePage(
    IN PCONSOLE_INFORMATION Console,
    IN UINT PrevCodePage
    );

NTSTATUS
ConvertOutputOemToNonOemUnicode(
    IN OUT LPWSTR Source,
    IN OUT PBYTE KAttrRows,
    IN int SourceLength, // in chars
    IN UINT Codepage
    );


VOID
TextOutEverything(
    IN PCONSOLE_INFORMATION Console,
    IN PSCREEN_INFORMATION ScreenInfo,
    IN SHORT LeftWindowPos,
    IN OUT PSHORT RightWindowPos,
    IN OUT PSHORT CountOfAttr,
    IN SHORT CountOfAttrOriginal,
    IN OUT PBOOL DoubleColorDBCS,
    IN BOOL LocalEUDCFlag,
    IN PROW Row,
    IN PATTR_PAIR Attr,
    IN SHORT LeftTextPos,
    IN SHORT RightTextPos,
    IN int WindowRectLeft,
    IN RECT WindowRect,
    IN SHORT NumberOfChars
    );

VOID
TextOutCommonLVB(
    IN PCONSOLE_INFORMATION Console,
    IN WORD Attributes,
    IN RECT CommonLVBRect
    );

NTSTATUS
MakeAltRasterFont(
    UINT CodePage,
    COORD DefaultFontSize,
    COORD *AltFontSize,
    BYTE  *AltFontFamily,
    ULONG *AltFontIndex,
    LPWSTR AltFaceName
    );

NTSTATUS
InitializeDbcsMisc(
    VOID
    );

#if defined(i386)
NTSTATUS
RealUnicodeToNEC_OS2_Unicode(
    IN OUT LPWSTR Source,
    IN int SourceLength      // in chars
    );

BOOL
InitializeNEC_OS2_CP(
    VOID
    );
#endif

BYTE
CodePageToCharSet(
    UINT CodePage
    );

BOOL
IsAvailableFarEastCodePage(
    UINT CodePage
    );

LPTTFONTLIST
SearchTTFont(
    LPWSTR pwszFace,
    BOOL   fCodePage,
    UINT   CodePage
    );

BOOL
IsAvailableTTFont(
    LPWSTR pwszFace
    );

BOOL
IsAvailableTTFontCP(
    LPWSTR pwszFace,
    UINT CodePage
    );

LPWSTR
GetAltFaceName(
    LPWSTR pwszFace
    );

BOOL
IsAvailableFsCodePage(
    UINT CodePage
    );

#if defined(FE_IME)

VOID
ProcessCreateConsoleIME(
    IN LPMSG lpMsg,
    DWORD dwConsoleThreadId
    );

NTSTATUS
InitConsoleIMEStuff(
    HDESK hDesktop,
    DWORD dwConsoleThreadId,
    PCONSOLE_INFORMATION Console
    );

NTSTATUS
WaitConsoleIMEStuff(
    HDESK hDesktop,
    HANDLE hThread
    );

NTSTATUS
ConSrvRegisterConsoleIME(
    PCSR_PROCESS Process,
    HDESK hDesktop,
    HWINSTA hWinSta,
    HWND  hWndConsoleIME,
    DWORD dwConsoleIMEThreadId,
    DWORD dwAction,
    DWORD *dwConsoleThreadId
    );

VOID
RemoveConsoleIME(
    PCSR_PROCESS Process,
    DWORD dwConsoleIMEThreadId
    );

NTSTATUS
ConsoleImeMessagePumpWorker(
    PCONSOLE_INFORMATION Console,
    UINT    Message,
    WPARAM  wParam,
    LPARAM  lParam,
    LRESULT* lplResult);


NTSTATUS
ConsoleImeMessagePump(
    PCONSOLE_INFORMATION Console,
    UINT   Message,
    WPARAM wParam,
    LPARAM lParam
    );
#endif // FE_IME


BOOL
RegisterKeisenOfTTFont(
    IN PSCREEN_INFORMATION ScreenInfo
    );

ULONG
TranslateUnicodeToOem(
    IN PCONSOLE_INFORMATION Console,
    IN PWCHAR UnicodeBuffer,
    IN ULONG UnicodeCharCount,
    OUT PCHAR AnsiBuffer,
    IN ULONG AnsiByteCount,
    OUT PINPUT_RECORD DbcsLeadInpRec
    );

DWORD
ImmConversionToConsole(
    DWORD fdwConversion
    );

DWORD
ImmConversionFromConsole(
    DWORD dwNlsMode
    );

//#define DBG_KAZUM
//#define DBG_KATTR

#if defined(DBG) && defined(DBG_KATTR)
VOID
BeginKAttrCheck(
    IN PSCREEN_INFORMATION ScreenInfo
    );
#endif


//
// output.c
//
BOOL
CreateDbcsScreenBuffer(
    IN PCONSOLE_INFORMATION Console,
    IN COORD dwScreenBufferSize,
    OUT PDBCS_SCREEN_BUFFER DbcsScreenBuffer
    );

BOOL
DeleteDbcsScreenBuffer(
    IN PDBCS_SCREEN_BUFFER DbcsScreenBuffer
    );

BOOL
ReCreateDbcsScreenBuffer(
    IN PCONSOLE_INFORMATION Console,
    IN UINT OldCodePage
    );

BOOL
FE_PolyTextOutCandidate(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT Region
    );

VOID
FE_ConsolePolyTextOut(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT Region
    );


//
// private.c
//
NTSTATUS
SetRAMFontCodePage(
    IN PSCREEN_INFORMATION ScreenInfo
    );

NTSTATUS
SetRAMFont(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PCHAR_INFO ScreenBufPtr,
    IN DWORD Length
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\server\directio.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    directio.c

Abstract:

        This file implements the NT console direct I/O API

Author:

    Therese Stowell (thereses) 6-Nov-1990

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


#if defined(FE_SB)
#define WWSB_FE
#include "dispatch.h" // get the FE_ prototypes
#undef  WWSB_FE
#pragma alloc_text(FE_TEXT, FE_TranslateInputToOem)
#pragma alloc_text(FE_TEXT, FE_TranslateInputToUnicode)
#pragma alloc_text(FE_TEXT, FE_TranslateOutputToOem)
#pragma alloc_text(FE_TEXT, FE_TranslateOutputToOemUnicode)
#pragma alloc_text(FE_TEXT, FE_TranslateOutputToUnicode)
#pragma alloc_text(FE_TEXT, FE_TranslateOutputToAnsiUnicode)
#endif


#if defined(FE_SB)
ULONG
SB_TranslateInputToOem
#else
NTSTATUS
TranslateInputToOem
#endif
    (
    IN PCONSOLE_INFORMATION Console,
    IN OUT PINPUT_RECORD InputRecords,
    IN ULONG NumRecords
    )
{
    ULONG i;

    DBGCHARS(("TranslateInputToOem\n"));
    for (i=0;i<NumRecords;i++) {
        if (InputRecords[i].EventType == KEY_EVENT) {
            InputRecords[i].Event.KeyEvent.uChar.AsciiChar = WcharToChar(
                    Console->CP, InputRecords[i].Event.KeyEvent.uChar.UnicodeChar);
        }
    }
#if defined(FE_SB)
    return NumRecords;
#else
    return STATUS_SUCCESS;
#endif
}

#if defined(FE_SB)
ULONG
FE_TranslateInputToOem(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PINPUT_RECORD InputRecords,
    IN ULONG NumRecords,    // in : ASCII byte count
    IN ULONG UnicodeLength, // in : Number of events (char count)
    OUT PINPUT_RECORD DbcsLeadInpRec
    )
{
    ULONG i,j;
    PINPUT_RECORD TmpInpRec;
    BYTE AsciiDbcs[2];
    ULONG NumBytes;

    ASSERT(NumRecords >= UnicodeLength);

    TmpInpRec = ConsoleHeapAlloc(MAKE_TAG( TMP_DBCS_TAG ),NumRecords*sizeof(INPUT_RECORD));
    if (TmpInpRec == NULL)
        return 0;

    memcpy(TmpInpRec,InputRecords,NumRecords*sizeof(INPUT_RECORD));
    AsciiDbcs[1] = 0;
    for (i=0,j=0; i<UnicodeLength; i++,j++) {
        if (TmpInpRec[i].EventType == KEY_EVENT) {
            if (IsConsoleFullWidth(Console->hDC,
                                   Console->CP,TmpInpRec[i].Event.KeyEvent.uChar.UnicodeChar)) {
                NumBytes = sizeof(AsciiDbcs);
                ConvertToOem(Console->CP,
                       &TmpInpRec[i].Event.KeyEvent.uChar.UnicodeChar,
                       1,
                       &AsciiDbcs[0],
                       NumBytes
                       );
                if (IsDBCSLeadByteConsole(AsciiDbcs[0],&Console->CPInfo)) {
                    if (j < NumRecords-1) {  // -1 is safe DBCS in buffer
                        InputRecords[j] = TmpInpRec[i];
                        InputRecords[j].Event.KeyEvent.uChar.UnicodeChar = 0;
                        InputRecords[j].Event.KeyEvent.uChar.AsciiChar = AsciiDbcs[0];
                        j++;
                        InputRecords[j] = TmpInpRec[i];
                        InputRecords[j].Event.KeyEvent.uChar.UnicodeChar = 0;
                        InputRecords[j].Event.KeyEvent.uChar.AsciiChar = AsciiDbcs[1];
                        AsciiDbcs[1] = 0;
                    }
                    else if (j == NumRecords-1) {
                        InputRecords[j] = TmpInpRec[i];
                        InputRecords[j].Event.KeyEvent.uChar.UnicodeChar = 0;
                        InputRecords[j].Event.KeyEvent.uChar.AsciiChar = AsciiDbcs[0];
                        j++;
                        break;
                    }
                    else {
                        AsciiDbcs[1] = 0;
                        break;
                    }
                }
                else {
                    InputRecords[j] = TmpInpRec[i];
                    InputRecords[j].Event.KeyEvent.uChar.UnicodeChar = 0;
                    InputRecords[j].Event.KeyEvent.uChar.AsciiChar = AsciiDbcs[0];
                    AsciiDbcs[1] = 0;
                }
            }
            else {
                InputRecords[j] = TmpInpRec[i];
                ConvertToOem(Console->CP,
                       &InputRecords[j].Event.KeyEvent.uChar.UnicodeChar,
                       1,
                       &InputRecords[j].Event.KeyEvent.uChar.AsciiChar,
                       1
                       );
            }
        }
    }
    if (DbcsLeadInpRec) {
        if (AsciiDbcs[1]) {
            *DbcsLeadInpRec = TmpInpRec[i];
            DbcsLeadInpRec->Event.KeyEvent.uChar.AsciiChar = AsciiDbcs[1];
        }
        else {
            RtlZeroMemory(DbcsLeadInpRec,sizeof(INPUT_RECORD));
        }
    }
    ConsoleHeapFree(TmpInpRec);
    return j;
}
#endif



#if defined(FE_SB)
ULONG
SB_TranslateInputToUnicode
#else
NTSTATUS
TranslateInputToUnicode
#endif
    (
    IN PCONSOLE_INFORMATION Console,
    IN OUT PINPUT_RECORD InputRecords,
    IN ULONG NumRecords
    )
{
    ULONG i;
    DBGCHARS(("TranslateInputToUnicode\n"));
    for (i=0;i<NumRecords;i++) {
        if (InputRecords[i].EventType == KEY_EVENT) {
#if defined(FE_SB)
            InputRecords[i].Event.KeyEvent.uChar.UnicodeChar = SB_CharToWchar(
                    Console->CP, InputRecords[i].Event.KeyEvent.uChar.AsciiChar);
#else
            InputRecords[i].Event.KeyEvent.uChar.UnicodeChar = CharToWchar(
                    Console->CP, InputRecords[i].Event.KeyEvent.uChar.AsciiChar);
#endif
        }
    }
#if defined(FE_SB)
    return i;
#else
    return STATUS_SUCCESS;
#endif
}

#if defined(FE_SB)
ULONG
FE_TranslateInputToUnicode(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PINPUT_RECORD InputRecords,
    IN ULONG NumRecords,
    IN OUT PINPUT_RECORD DBCSLeadByte
    )
{
    ULONG i,j;
    INPUT_RECORD AsciiDbcs[2];
    CHAR Strings[2];
    WCHAR UnicodeDbcs[2];
    PWCHAR Uni;
    ULONG NumBytes;

    if (DBCSLeadByte->Event.KeyEvent.uChar.AsciiChar) {
        AsciiDbcs[0] = *DBCSLeadByte;
        Strings[0] = DBCSLeadByte->Event.KeyEvent.uChar.AsciiChar;
    }
    else{
        RtlZeroMemory(AsciiDbcs,sizeof(AsciiDbcs));
    }
    for (i=j=0; i<NumRecords; i++) {
        if (InputRecords[i].EventType == KEY_EVENT) {
            if (AsciiDbcs[0].Event.KeyEvent.uChar.AsciiChar) {
                AsciiDbcs[1] = InputRecords[i];
                Strings[1] = InputRecords[i].Event.KeyEvent.uChar.AsciiChar;
                NumBytes = sizeof(Strings);
                NumBytes = ConvertInputToUnicode(Console->CP,
                                                 &Strings[0],
                                                 NumBytes,
                                                 &UnicodeDbcs[0],
                                                 NumBytes);
                Uni = &UnicodeDbcs[0];
                while (NumBytes--) {
                    InputRecords[j] = AsciiDbcs[0];
                    InputRecords[j].Event.KeyEvent.uChar.UnicodeChar = *Uni++;
                    j++;
                }
                RtlZeroMemory(AsciiDbcs,sizeof(AsciiDbcs));
                if (DBCSLeadByte->Event.KeyEvent.uChar.AsciiChar)
                    RtlZeroMemory(DBCSLeadByte,sizeof(INPUT_RECORD));
            }
            else if (IsDBCSLeadByteConsole(InputRecords[i].Event.KeyEvent.uChar.AsciiChar,&Console->CPInfo)) {
                if (i < NumRecords-1) {
                    AsciiDbcs[0] = InputRecords[i];
                    Strings[0] = InputRecords[i].Event.KeyEvent.uChar.AsciiChar;
                }
                else {
                    *DBCSLeadByte = InputRecords[i];
                    break;
                }
            }
            else {
                CHAR c;
                InputRecords[j] = InputRecords[i];
                c = InputRecords[i].Event.KeyEvent.uChar.AsciiChar;
                ConvertInputToUnicode(Console->CP,
                      &c,
                      1,
                      &InputRecords[j].Event.KeyEvent.uChar.UnicodeChar,
                      1);
                j++;
            }
        }
        else {
            InputRecords[j++] = InputRecords[i];
        }
    }
    return j;
}
#endif


BOOLEAN
DirectReadWaitRoutine(
    IN PLIST_ENTRY WaitQueue,
    IN PCSR_THREAD WaitingThread,
    IN PCSR_API_MSG WaitReplyMessage,
    IN PVOID WaitParameter,
    IN PVOID SatisfyParameter1,
    IN PVOID SatisfyParameter2,
    IN ULONG WaitFlags
    )

/*++

Routine Description:

    This routine is called to complete a direct read that blocked in
    ReadInputBuffer.  The context of the read was saved in the DirectReadData
    structure.  This routine is called when events have been written to
    the input buffer.  It is called in the context of the writing thread.

Arguments:

    WaitQueue - Pointer to queue containing wait block.

    WaitingThread - Pointer to waiting thread.

    WaitReplyMessage - Pointer to reply message to return to dll when
        read is completed.

    DirectReadData - Context of read.

    SatisfyParameter1 - Unused.

    SatisfyParameter2 - Unused.

    WaitFlags - Flags indicating status of wait.

Return Value:

--*/

{
    PCONSOLE_GETCONSOLEINPUT_MSG a;
    PINPUT_RECORD Buffer;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PDIRECT_READ_DATA DirectReadData;
    PHANDLE_DATA HandleData;
    BOOLEAN RetVal = TRUE;
#if defined(FE_SB)
    BOOLEAN fAddDbcsLead = FALSE;
    PDWORD  nLength;
#endif

    a = (PCONSOLE_GETCONSOLEINPUT_MSG)&WaitReplyMessage->u.ApiMessageData;
    DirectReadData = (PDIRECT_READ_DATA) WaitParameter;

    Status = DereferenceIoHandleNoCheck(DirectReadData->ProcessData,
                                        DirectReadData->HandleIndex,
                                        &HandleData
                                       );
    ASSERT (NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status)) {
        return TRUE;
    }

    //
    // see if this routine was called by CloseInputHandle.  if it
    // was, see if this wait block corresponds to the dying handle.
    // if it doesn't, just return.
    //

    if (SatisfyParameter1 != NULL &&
        SatisfyParameter1 != HandleData) {
        return FALSE;
    }

    //
    // if ctrl-c or ctrl-break was seen, ignore it.
    //

    if ((ULONG_PTR)SatisfyParameter2 & (CONSOLE_CTRL_C_SEEN | CONSOLE_CTRL_BREAK_SEEN)) {
        return FALSE;
    }

    Console = DirectReadData->Console;

#if defined(FE_SB)
    if (CONSOLE_IS_DBCS_CP(Console) && !a->Unicode) {
        if (HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte.Event.KeyEvent.uChar.AsciiChar) {
            if (a->NumRecords == 1) {
                Buffer = &a->Record[0];
                *Buffer = HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte;
                if (!(a->Flags & CONSOLE_READ_NOREMOVE))
                    RtlZeroMemory(&HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte,sizeof(INPUT_RECORD));
                return TRUE;
            }
        }
    }
#endif

    //
    // this routine should be called by a thread owning the same
    // lock on the same console as we're reading from.
    //

    try {
        LockReadCount(HandleData);
        ASSERT(HandleData->InputReadData->ReadCount);
        HandleData->InputReadData->ReadCount -= 1;
        UnlockReadCount(HandleData);

        //
        // see if called by CsrDestroyProcess or CsrDestroyThread
        // via CsrNotifyWaitBlock.   if so, just decrement the ReadCount
        // and return.
        //

        if (WaitFlags & CSR_PROCESS_TERMINATING) {
            Status = STATUS_THREAD_IS_TERMINATING;
            leave;
        }

        //
        // We must see if we were woken up because the handle is being
        // closed.  if so, we decrement the read count.  if it goes to
        // zero, we wake up the close thread.  otherwise, we wake up any
        // other thread waiting for data.
        //

        if (HandleData->InputReadData->InputHandleFlags & HANDLE_CLOSING) {
            ASSERT (SatisfyParameter1 == HandleData);
            Status = STATUS_ALERTED;
            leave;
        }

        //
        // if we get to here, this routine was called either by the input
        // thread or a write routine.  both of these callers grab the
        // current console lock.
        //

        //
        // this routine should be called by a thread owning the same
        // lock on the same console as we're reading from.
        //

        ASSERT (ConsoleLocked(Console));

        //
        // if the read buffer is contained within the message, we need to
        // reset the buffer pointer because the message copied from the
        // stack to heap space when the wait block was created.
        //

        if (a->NumRecords <= INPUT_RECORD_BUFFER_SIZE) {
            Buffer = a->Record;
        } else {
            Buffer = a->BufPtr;
        }
#if defined(FE_SB)
        if (CONSOLE_IS_DBCS_CP(Console) ) {
            Console->ReadConInpNumBytesUnicode = a->NumRecords;
            if (!a->Unicode) {
                /*
                 * ASCII : a->NumRecords is ASCII byte count
                 */
                if (HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte.Event.KeyEvent.uChar.AsciiChar) {
                    /*
                     * Saved DBCS Traling byte
                     */
                    if (Console->ReadConInpNumBytesUnicode != 1) {
                        Console->ReadConInpNumBytesUnicode--;
                        Buffer++;
                        fAddDbcsLead = TRUE;
                        nLength = &Console->ReadConInpNumBytesUnicode;
                    }
                    else {
                        ASSERT(Console->ReadConInpNumBytesUnicode==1);
                    }
                }
                else {
                    nLength = &Console->ReadConInpNumBytesUnicode;
                }
            }
            else {
                nLength = &a->NumRecords;
            }
        }
        else {
            nLength = &a->NumRecords;
        }
        Status = ReadInputBuffer(DirectReadData->InputInfo,
                                 Buffer,
                                 nLength,
                                 !!(a->Flags & CONSOLE_READ_NOREMOVE),
                                 !(a->Flags & CONSOLE_READ_NOWAIT),
                                 FALSE,
                                 Console,
                                 HandleData,
                                 WaitReplyMessage,
                                 DirectReadWaitRoutine,
                                 &DirectReadData,
                                 sizeof(DirectReadData),
                                 TRUE,
                                 a->Unicode
                                );
#else
        Status = ReadInputBuffer(DirectReadData->InputInfo,
                                 Buffer,
                                 &a->NumRecords,
                                 !!(a->Flags & CONSOLE_READ_NOREMOVE),
                                 !(a->Flags & CONSOLE_READ_NOWAIT),
                                 FALSE,
                                 Console,
                                 HandleData,
                                 WaitReplyMessage,
                                 DirectReadWaitRoutine,
                                 &DirectReadData,
                                 sizeof(DirectReadData),
                                 TRUE
                                );
#endif
        if (Status == CONSOLE_STATUS_WAIT) {
            RetVal = FALSE;
        }
    } finally {

        //
        // if the read was completed (status != wait), free the direct read
        // data.
        //

        if (Status != CONSOLE_STATUS_WAIT) {
            if (Status == STATUS_SUCCESS && !a->Unicode) {
#if defined(FE_SB)
                if (CONSOLE_IS_DBCS_CP(Console) ) {
                    if (fAddDbcsLead &&
                        HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte.Event.KeyEvent.uChar.AsciiChar) {
                        a->NumRecords--;
                    }
                    a->NumRecords = FE_TranslateInputToOem(
                                        Console,
                                        Buffer,
                                        a->NumRecords,
                                        Console->ReadConInpNumBytesUnicode,
                                        a->Flags & CONSOLE_READ_NOREMOVE ?
                                            NULL :
                                            &HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte);
                    if (fAddDbcsLead &&
                        HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte.Event.KeyEvent.uChar.AsciiChar) {
                        *(Buffer-1) = HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte;
                        if (!(a->Flags & CONSOLE_READ_NOREMOVE))
                            RtlZeroMemory(&HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte,sizeof(INPUT_RECORD));
                        a->NumRecords++;
                        Buffer--;
                    }
                }
                else {
                    TranslateInputToOem(Console,
                                         Buffer,
                                         a->NumRecords,
                                         Console->ReadConInpNumBytesUnicode,
                                         a->Flags & CONSOLE_READ_NOREMOVE ?
                                             NULL :
                                             &HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte
                                        );
                }
#else
                TranslateInputToOem(Console,
                                     Buffer,
                                     a->NumRecords
                                    );
#endif
            }
            WaitReplyMessage->ReturnValue = Status;
            ConsoleHeapFree(DirectReadData);
        }
    }

    return RetVal;

    //
    // satisfy the unreferenced parameter warnings.
    //

    UNREFERENCED_PARAMETER(WaitQueue);
    UNREFERENCED_PARAMETER(WaitingThread);
    UNREFERENCED_PARAMETER(SatisfyParameter2);
}


ULONG
SrvGetConsoleInput(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Routine Description:

    This routine reads or peeks input events.  In both cases, the events
    are copied to the user's buffer.  In the read case they are removed
    from the input buffer and in the peek case they are not.

Arguments:

    m - message containing api parameters

    ReplyStatus - Indicates whether to reply to the dll port.

Return Value:

--*/

{
    PCONSOLE_GETCONSOLEINPUT_MSG a = (PCONSOLE_GETCONSOLEINPUT_MSG)&m->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    NTSTATUS Status;
    PINPUT_RECORD Buffer;
    DIRECT_READ_DATA DirectReadData;
#ifdef FE_SB
    BOOLEAN fAddDbcsLead = FALSE;
    PDWORD  nLength;
#endif

    if (a->Flags & ~CONSOLE_READ_VALID) {
        return (ULONG)STATUS_INVALID_PARAMETER;
    }

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->InputHandle,
                                 CONSOLE_INPUT_HANDLE,
                                 GENERIC_READ,
                                 &HandleData
                                );
    if (!NT_SUCCESS(Status)) {
        a->NumRecords = 0;
    } else {

        if (a->NumRecords <= INPUT_RECORD_BUFFER_SIZE) {
            Buffer = a->Record;
        } else {
            Buffer = a->BufPtr;
            if (!CsrValidateMessageBuffer(m, &a->BufPtr, a->NumRecords, sizeof(*Buffer))) {
                UnlockConsole(Console);
                return STATUS_INVALID_PARAMETER;
            }
        }

        //
        // if we're reading, wait for data.  if we're peeking, don't.
        //

        DirectReadData.InputInfo = HandleData->Buffer.InputBuffer;
        DirectReadData.Console = Console;
        DirectReadData.ProcessData = CONSOLE_PERPROCESSDATA();
        DirectReadData.HandleIndex = HANDLE_TO_INDEX(a->InputHandle);
#if defined(FE_SB)
        if (CONSOLE_IS_DBCS_CP(Console) ) {
            Console->ReadConInpNumBytesUnicode = a->NumRecords;
            if (!a->Unicode) {
                /*
                 * ASCII : a->NumRecords is ASCII byte count
                 */
                if (HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte.Event.KeyEvent.uChar.AsciiChar) {
                    /*
                     * Saved DBCS Traling byte
                     */
                    *Buffer = HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte;
                    if (!(a->Flags & CONSOLE_READ_NOREMOVE))
                        RtlZeroMemory(&HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte,sizeof(INPUT_RECORD));

                    if (Console->ReadConInpNumBytesUnicode == 1) {
                        UnlockConsole(Console);
                        return STATUS_SUCCESS;
                    }
                    else {
                        Console->ReadConInpNumBytesUnicode--;
                        Buffer++;
                        fAddDbcsLead = TRUE;
                        nLength = &Console->ReadConInpNumBytesUnicode;
                    }
                }
                else {
                    nLength = &Console->ReadConInpNumBytesUnicode;
                }
            }
            else {
                nLength = &a->NumRecords;
            }
        }
        else {
            nLength = &a->NumRecords;
        }
        Status = ReadInputBuffer(HandleData->Buffer.InputBuffer,
                                 Buffer,
                                 nLength,
                                 !!(a->Flags & CONSOLE_READ_NOREMOVE),
                                 !(a->Flags & CONSOLE_READ_NOWAIT),
                                 FALSE,
                                 Console,
                                 HandleData,
                                 m,
                                 DirectReadWaitRoutine,
                                 &DirectReadData,
                                 sizeof(DirectReadData),
                                 FALSE,
                                 a->Unicode
                                );
        if (Status == CONSOLE_STATUS_WAIT) {
            *ReplyStatus = CsrReplyPending;
        } else if (!a->Unicode) {
            a->NumRecords = TranslateInputToOem(Console,
                                                Buffer,
                                                fAddDbcsLead ?
                                                    a->NumRecords-1 :
                                                    a->NumRecords,
                                                Console->ReadConInpNumBytesUnicode,
                                                a->Flags & CONSOLE_READ_NOREMOVE ?
                                                    NULL :
                                                    &HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte
                                               );
            if (fAddDbcsLead)
            {
                a->NumRecords++;
                Buffer--;
            }
        }
#else
        Status = ReadInputBuffer(HandleData->Buffer.InputBuffer,
                                 Buffer,
                                 &a->NumRecords,
                                 !!(a->Flags & CONSOLE_READ_NOREMOVE),
                                 !(a->Flags & CONSOLE_READ_NOWAIT),
                                 FALSE,
                                 Console,
                                 HandleData,
                                 m,
                                 DirectReadWaitRoutine,
                                 &DirectReadData,
                                 sizeof(DirectReadData),
                                 FALSE
                                );
        if (Status == CONSOLE_STATUS_WAIT) {
            *ReplyStatus = CsrReplyPending;
        } else if (!a->Unicode) {
            TranslateInputToOem(Console,
                                 Buffer,
                                 a->NumRecords
                                );
        }
#endif
    }
    UnlockConsole(Console);
    return Status;
}

ULONG
SrvWriteConsoleInput(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_WRITECONSOLEINPUT_MSG a = (PCONSOLE_WRITECONSOLEINPUT_MSG)&m->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    NTSTATUS Status;
    PINPUT_RECORD Buffer;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->InputHandle,
                                 CONSOLE_INPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (!NT_SUCCESS(Status)) {
        a->NumRecords = 0;
    } else {
        if (a->NumRecords <= INPUT_RECORD_BUFFER_SIZE) {
            Buffer = a->Record;
        } else {
            Buffer = a->BufPtr;
            if (!CsrValidateMessageBuffer(m, &a->BufPtr, a->NumRecords, sizeof(*Buffer))) {
                UnlockConsole(Console);
                return STATUS_INVALID_PARAMETER;
            }
        }
        if (!a->Unicode) {
#if defined(FE_SB)
            a->NumRecords = TranslateInputToUnicode(Console,
                                    Buffer,
                                    a->NumRecords,
                                    &HandleData->Buffer.InputBuffer->WriteConInpDbcsLeadByte[0]
                                   );
#else
            TranslateInputToUnicode(Console,
                                    Buffer,
                                    a->NumRecords
                                   );
#endif
        }
        if (a->Append) {
            a->NumRecords = WriteInputBuffer(Console,
                                             HandleData->Buffer.InputBuffer,
                                             Buffer,
                                             a->NumRecords
                                            );
        } else {
            a->NumRecords = PrependInputBuffer(Console,
                                             HandleData->Buffer.InputBuffer,
                                             Buffer,
                                             a->NumRecords
                                            );

        }
    }
    UnlockConsole(Console);
    return((ULONG) Status);
    UNREFERENCED_PARAMETER(ReplyStatus);    // get rid of unreferenced parameter warning message
}

NTSTATUS
SB_TranslateOutputToOem
    (
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size
    )
// this is used when the app reads oem from the output buffer
// the app wants real OEM characters.  We have real Unicode or UnicodeOem.
{
    SHORT i,j;
    UINT Codepage;
    DBGCHARS(("SB_TranslateOutputToOem(Console=%lx, OutputBuffer=%lx)\n",
            Console, OutputBuffer));

    j = Size.X * Size.Y;

    if ((Console->CurrentScreenBuffer->Flags & CONSOLE_OEMFONT_DISPLAY) &&
            ((Console->FullScreenFlags & CONSOLE_FULLSCREEN) == 0)) {
#if defined(FE_SB)
        if (CONSOLE_IS_DBCS_ENABLED() &&
            Console->OutputCP != WINDOWSCP ) {
                Codepage = USACP;
        }
        else
#endif
        // we have UnicodeOem characters
        Codepage = WINDOWSCP;
    } else {
        // we have real Unicode characters
        Codepage = Console->OutputCP;    // BUG FIX by KazuM Jun.2.97
    }

    for (i=0;i<j;i++,OutputBuffer++) {
        OutputBuffer->Char.AsciiChar = WcharToChar(Codepage,
                OutputBuffer->Char.UnicodeChar);
    }
    return STATUS_SUCCESS;
}

#if defined(FE_SB)
NTSTATUS
FE_TranslateOutputToOem(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size
    )
// this is used when the app reads oem from the output buffer
// the app wants real OEM characters.  We have real Unicode or UnicodeOem.
{
    SHORT i,j;
    UINT Codepage;
    PCHAR_INFO TmpBuffer,SaveBuffer;
    CHAR  AsciiDbcs[2];
    ULONG NumBytes;
    DBGCHARS(("FE_TranslateOutputToOem(Console=%lx, OutputBuffer=%lx)\n",
            Console, OutputBuffer));

    SaveBuffer = TmpBuffer =
        ConsoleHeapAlloc(MAKE_TAG( TMP_DBCS_TAG ), Size.X * Size.Y * sizeof(CHAR_INFO) * 2);
    if (TmpBuffer == NULL) {
        return STATUS_NO_MEMORY;
    }

    if ((Console->CurrentScreenBuffer->Flags & CONSOLE_OEMFONT_DISPLAY) &&
            ((Console->FullScreenFlags & CONSOLE_FULLSCREEN) == 0)) {
        if (CONSOLE_IS_DBCS_ENABLED() &&
            Console->OutputCP != WINDOWSCP ) {
                Codepage = USACP;
        }
        else
            // we have UnicodeOem characters
            Codepage = WINDOWSCP;
    } else {
        // we have real Unicode characters
        Codepage = Console->OutputCP;
    }

    memcpy(TmpBuffer,OutputBuffer,Size.X * Size.Y * sizeof(CHAR_INFO));
    for (i=0; i < Size.Y; i++) {
        for (j=0; j < Size.X; j++) {
            if (TmpBuffer->Attributes & COMMON_LVB_LEADING_BYTE) {
                if (j < Size.X-1) {  // -1 is safe DBCS in buffer
                    j++;
                    NumBytes = sizeof(AsciiDbcs);
                    NumBytes = ConvertOutputToOem(Codepage,
                                   &TmpBuffer->Char.UnicodeChar,
                                   1,
                                   &AsciiDbcs[0],
                                   NumBytes);
                    OutputBuffer->Char.AsciiChar = AsciiDbcs[0];
                    OutputBuffer->Attributes = TmpBuffer->Attributes;
                    OutputBuffer++;
                    TmpBuffer++;
                    OutputBuffer->Char.AsciiChar = AsciiDbcs[1];
                    OutputBuffer->Attributes = TmpBuffer->Attributes;
                    OutputBuffer++;
                    TmpBuffer++;
                }
                else {
                    OutputBuffer->Char.AsciiChar = ' ';
                    OutputBuffer->Attributes = TmpBuffer->Attributes & ~COMMON_LVB_SBCSDBCS;
                    OutputBuffer++;
                    TmpBuffer++;
                }
            }
            else if (!(TmpBuffer->Attributes & COMMON_LVB_SBCSDBCS)){
                ConvertOutputToOem(Codepage,
                    &TmpBuffer->Char.UnicodeChar,
                    1,
                    &OutputBuffer->Char.AsciiChar,
                    1);
                OutputBuffer->Attributes = TmpBuffer->Attributes;
                OutputBuffer++;
                TmpBuffer++;
            }
        }
    }
    ConsoleHeapFree(SaveBuffer);
    return STATUS_SUCCESS;
}
#endif

NTSTATUS
SB_TranslateOutputToOemUnicode
    (
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size
    )
// this is used when the app reads unicode from the output buffer
{
    SHORT i,j;
    DBGCHARS(("SB_TranslateOutputToOemUnicode\n"));

    j = Size.X * Size.Y;

    for (i=0;i<j;i++,OutputBuffer++) {
        FalseUnicodeToRealUnicode(&OutputBuffer->Char.UnicodeChar,
                                1,
                                Console->OutputCP
                                );
    }
    return STATUS_SUCCESS;
}

#if defined(FE_SB)
NTSTATUS
FE_TranslateOutputToOemUnicode(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size,
    IN BOOL fRemoveDbcsMark
    )
// this is used when the app reads unicode from the output buffer
{
    SHORT i,j;
    DBGCHARS(("FE_TranslateOutputToOemUnicode\n"));

    j = Size.X * Size.Y;

    if (fRemoveDbcsMark)
        RemoveDbcsMarkCell(OutputBuffer,OutputBuffer,j);

    for (i=0;i<j;i++,OutputBuffer++) {
        FalseUnicodeToRealUnicode(&OutputBuffer->Char.UnicodeChar,
                                1,
                                Console->OutputCP
                                );
    }
    return STATUS_SUCCESS;
}
#endif


NTSTATUS
SB_TranslateOutputToUnicode
    (
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size
    )
// this is used when the app writes oem to the output buffer
// we want UnicodeOem or Unicode in the buffer, depending on font & fullscreen
{
    SHORT i,j;
    UINT Codepage;
    DBGCHARS(("SB_TranslateOutputToUnicode %lx %lx (%lx,%lx)\n",
            Console, OutputBuffer, Size.X, Size.Y));

    j = Size.X * Size.Y;

    if ((Console->CurrentScreenBuffer->Flags & CONSOLE_OEMFONT_DISPLAY) &&
            ((Console->FullScreenFlags & CONSOLE_FULLSCREEN) == 0)) {
#if defined(FE_SB)
        if (CONSOLE_IS_DBCS_ENABLED() &&
            (Console->OutputCP != WINDOWSCP) ) {
                Codepage = USACP;
        }
        else
#endif
        // we want UnicodeOem characters
        Codepage = WINDOWSCP;
    } else {
        // we want real Unicode characters
        Codepage = Console->OutputCP;    // BUG FIX by KazuM Jun.2.97
    }
    for (i = 0; i < j; i++, OutputBuffer++) {
#if defined(FE_SB)
        OutputBuffer->Char.UnicodeChar = SB_CharToWchar(
                Codepage, OutputBuffer->Char.AsciiChar);
#else
        OutputBuffer->Char.UnicodeChar = CharToWchar(
                Codepage, OutputBuffer->Char.AsciiChar);
#endif
    }
    return STATUS_SUCCESS;
}

#if defined(FE_SB)
NTSTATUS
FE_TranslateOutputToUnicode(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size
    )
// this is used when the app writes oem to the output buffer
// we want UnicodeOem or Unicode in the buffer, depending on font & fullscreen
{
    SHORT i,j;
    UINT Codepage;
    CHAR  AsciiDbcs[2];
    WCHAR UnicodeDbcs[2];
    DBGCHARS(("FE_TranslateOutputToUnicode %lx %lx (%lx,%lx)\n",
            Console, OutputBuffer, Size.X, Size.Y));

    if ((Console->CurrentScreenBuffer->Flags & CONSOLE_OEMFONT_DISPLAY) &&
            ((Console->FullScreenFlags & CONSOLE_FULLSCREEN) == 0)) {
        if (CONSOLE_IS_DBCS_ENABLED() &&
            (Console->OutputCP != WINDOWSCP) ) {
                Codepage = USACP;
        }
        else
            // we want UnicodeOem characters
            Codepage = WINDOWSCP;
    } else {
        // we want real Unicode characters
        Codepage = Console->OutputCP;
    }

    for (i=0; i < Size.Y; i++) {
        for (j=0; j < Size.X; j++) {
            OutputBuffer->Attributes &= ~COMMON_LVB_SBCSDBCS;
            if (IsDBCSLeadByteConsole(OutputBuffer->Char.AsciiChar,&Console->OutputCPInfo)) {
                if (j < Size.X-1) {  // -1 is safe DBCS in buffer
                    j++;
                    AsciiDbcs[0] = OutputBuffer->Char.AsciiChar;
                    AsciiDbcs[1] = (OutputBuffer+1)->Char.AsciiChar;
                    ConvertOutputToUnicode(Codepage,
                                           &AsciiDbcs[0],
                                           2,
                                           &UnicodeDbcs[0],
                                           2);
                    OutputBuffer->Char.UnicodeChar = UnicodeDbcs[0];
                    OutputBuffer->Attributes |= COMMON_LVB_LEADING_BYTE;
                    OutputBuffer++;
                    OutputBuffer->Char.UnicodeChar = UNICODE_DBCS_PADDING;
                    OutputBuffer->Attributes &= ~COMMON_LVB_SBCSDBCS;
                    OutputBuffer->Attributes |= COMMON_LVB_TRAILING_BYTE;
                    OutputBuffer++;
                }
                else {
                    OutputBuffer->Char.UnicodeChar = UNICODE_SPACE;
                    OutputBuffer++;
                }
            }
            else {
                CHAR c;
                c=OutputBuffer->Char.AsciiChar;
                ConvertOutputToUnicode(Codepage,
                                       &c,
                                       1,
                                       &OutputBuffer->Char.UnicodeChar,
                                       1);
                OutputBuffer++;
            }
        }
    }
    return STATUS_SUCCESS;
}
#endif


NTSTATUS
SB_TranslateOutputToAnsiUnicode (
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size
    )
// this is used when the app writes unicode to the output buffer
{
    SHORT i,j;
    DBGCHARS(("TranslateOutputToAnsiUnicode\n"));

    j = Size.X * Size.Y;

    for (i=0;i<j;i++,OutputBuffer++) {
        RealUnicodeToFalseUnicode(&OutputBuffer->Char.UnicodeChar,
                                1,
                                Console->OutputCP
                                );
    }
    return STATUS_SUCCESS;
}

NTSTATUS
FE_TranslateOutputToAnsiUnicodeInternal(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size,
    IN OUT PCHAR_INFO OutputBufferR,
    IN BOOL fRealUnicodeToFalseUnicode
    )
// this is used when the app writes unicode to the output buffer
{
    SHORT i,j;
    DBGCHARS(("TranslateOutputToAnsiUnicode\n"));

    for (i=0; i < Size.Y; i++) {
        for (j=0; j < Size.X; j++) {
            WCHAR wch = OutputBuffer->Char.UnicodeChar;

            if (fRealUnicodeToFalseUnicode) {
                RealUnicodeToFalseUnicode(&OutputBuffer->Char.UnicodeChar,
                                          1,
                                          Console->OutputCP
                                         );
            }

            if (OutputBufferR) {
                OutputBufferR->Attributes = OutputBuffer->Attributes & ~COMMON_LVB_SBCSDBCS;
                if (IsConsoleFullWidth(Console->hDC,
                                       Console->OutputCP,OutputBuffer->Char.UnicodeChar)) {
                    if (j == Size.X-1){
                        OutputBufferR->Char.UnicodeChar = UNICODE_SPACE;
                    }
                    else{
                        OutputBufferR->Char.UnicodeChar = OutputBuffer->Char.UnicodeChar;
                        OutputBufferR->Attributes |= COMMON_LVB_LEADING_BYTE;
                        OutputBufferR++;
                        OutputBufferR->Char.UnicodeChar = UNICODE_DBCS_PADDING;
                        OutputBufferR->Attributes = OutputBuffer->Attributes & ~COMMON_LVB_SBCSDBCS;
                        OutputBufferR->Attributes |= COMMON_LVB_TRAILING_BYTE;
                    }
                }
                else{
                    OutputBufferR->Char.UnicodeChar = OutputBuffer->Char.UnicodeChar;
                }
                OutputBufferR++;
            }

            if (IsConsoleFullWidth(Console->hDC,
                                   Console->OutputCP,
                                   wch)) {
                if (j != Size.X-1){
                    j++;
                }
            }
            OutputBuffer++;
        }
    }
    return STATUS_SUCCESS;
}

NTSTATUS
FE_TranslateOutputToAnsiUnicode(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size,
    IN OUT PCHAR_INFO OutputBufferR
    )
// this is used when the app writes unicode to the output buffer
{
    return FE_TranslateOutputToAnsiUnicodeInternal(Console,
                                                   OutputBuffer,
                                                   Size,
                                                   OutputBufferR,
                                                   TRUE
                                                   );
}

NTSTATUS
TranslateOutputToPaddingUnicode(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size,
    IN OUT PCHAR_INFO OutputBufferR
    )
{
    return FE_TranslateOutputToAnsiUnicodeInternal(Console,
                                                   OutputBuffer,
                                                   Size,
                                                   OutputBufferR,
                                                   FALSE
                                                   );
}

ULONG
SrvReadConsoleOutput(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_READCONSOLEOUTPUT_MSG a = (PCONSOLE_READCONSOLEOUTPUT_MSG)&m->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    NTSTATUS Status;
    PCHAR_INFO Buffer;

    DBGOUTPUT(("SrvReadConsoleOutput\n"));
    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_READ,
                                 &HandleData
                                );
    if (!NT_SUCCESS(Status)) {
        //
        // a region of zero size is indicated by the right and bottom
        // coordinates being less than the left and top.
        //

        a->CharRegion.Right = (USHORT) (a->CharRegion.Left-1);
        a->CharRegion.Bottom = (USHORT) (a->CharRegion.Top-1);
    }
    else {
        COORD BufferSize;

        BufferSize.X = (SHORT)(a->CharRegion.Right - a->CharRegion.Left + 1);
        BufferSize.Y = (SHORT)(a->CharRegion.Bottom - a->CharRegion.Top + 1);

        if ((BufferSize.X == 1) && (BufferSize.Y == 1)) {
            Buffer = &a->Char;
        }
        else {
            Buffer = a->BufPtr;
            if (!CsrValidateMessageBuffer(m, &a->BufPtr, BufferSize.X * BufferSize.Y, sizeof(*Buffer))) {
                UnlockConsole(Console);
                return STATUS_INVALID_PARAMETER;
            }
        }

        Status = ReadScreenBuffer(HandleData->Buffer.ScreenBuffer,
                                  Buffer,
                                  &a->CharRegion
                                 );
        if (!a->Unicode) {
            TranslateOutputToOem(Console,
                                  Buffer,
                                  BufferSize
                                 );
        } else if ((Console->CurrentScreenBuffer->Flags & CONSOLE_OEMFONT_DISPLAY) &&
                !(Console->FullScreenFlags & CONSOLE_FULLSCREEN)) {
            TranslateOutputToOemUnicode(Console,
                                        Buffer,
                                        BufferSize
#if defined(FE_SB)
                                        ,
                                        TRUE
#endif
                                       );
        }
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);    // get rid of unreferenced parameter warning message
}

ULONG
SrvWriteConsoleOutput(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_WRITECONSOLEOUTPUT_MSG a = (PCONSOLE_WRITECONSOLEOUTPUT_MSG)&m->u.ApiMessageData;
    PSCREEN_INFORMATION ScreenBufferInformation;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    NTSTATUS Status;
    PCHAR_INFO Buffer;
#if defined(FE_SB)
    PCHAR_INFO TransBuffer = NULL;
#endif

    DBGOUTPUT(("SrvWriteConsoleOutput\n"));
    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (!NT_SUCCESS(Status)) {

        //
        // a region of zero size is indicated by the right and bottom
        // coordinates being less than the left and top.
        //

        a->CharRegion.Right = (USHORT) (a->CharRegion.Left-1);
        a->CharRegion.Bottom = (USHORT) (a->CharRegion.Top-1);
    } else {

        COORD BufferSize;
        ULONG NumBytes;

        BufferSize.X = (SHORT)(a->CharRegion.Right - a->CharRegion.Left + 1);
        BufferSize.Y = (SHORT)(a->CharRegion.Bottom - a->CharRegion.Top + 1);
        NumBytes = BufferSize.X * BufferSize.Y * sizeof(*Buffer);

        if ((BufferSize.X == 1) && (BufferSize.Y == 1)) {
            Buffer = &a->Char;
        } else if (a->ReadVM) {
            Buffer = ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ),NumBytes);
            if (Buffer == NULL) {
                UnlockConsole(Console);
                return (ULONG)STATUS_NO_MEMORY;
            }
            Status = NtReadVirtualMemory(CONSOLE_CLIENTPROCESSHANDLE(),
                                         a->BufPtr,
                                         Buffer,
                                         NumBytes,
                                         NULL
                                        );
            if (!NT_SUCCESS(Status)) {
                ConsoleHeapFree(Buffer);
                UnlockConsole(Console);
                return (ULONG)STATUS_NO_MEMORY;
            }
        } else {
            Buffer = a->BufPtr;
            if (!CsrValidateMessageBuffer(m, &a->BufPtr, NumBytes, sizeof(BYTE))) {
                UnlockConsole(Console);
                return STATUS_INVALID_PARAMETER;
            }
        }
        ScreenBufferInformation = HandleData->Buffer.ScreenBuffer;

        if (!a->Unicode) {
            TranslateOutputToUnicode(Console,
                                     Buffer,
                                     BufferSize
                                    );
#if defined(FE_SB)
            Status = WriteScreenBuffer(ScreenBufferInformation,
                                       Buffer,
                                       &a->CharRegion
                                      );
#endif
        } else if ((Console->CurrentScreenBuffer->Flags & CONSOLE_OEMFONT_DISPLAY) &&
                ((Console->FullScreenFlags & CONSOLE_FULLSCREEN) == 0)) {
#if defined(FE_SB)
            if (CONSOLE_IS_DBCS_OUTPUTCP(Console)) {
                TransBuffer = (PCHAR_INFO)ConsoleHeapAlloc(MAKE_TAG( TMP_DBCS_TAG ),(BufferSize.Y * BufferSize.X) * 2 * sizeof(CHAR_INFO));
                if (TransBuffer == NULL) {
                    UnlockConsole(Console);
                    return (ULONG)STATUS_NO_MEMORY;
                }
                FE_TranslateOutputToAnsiUnicode(Console,
                                            Buffer,
                                            BufferSize,
                                            &TransBuffer[0]
                                           );
                Status = WriteScreenBuffer(ScreenBufferInformation,
                                            &TransBuffer[0],
                                            &a->CharRegion
                                           );
                ConsoleHeapFree(TransBuffer);
            }
            else {
                SB_TranslateOutputToAnsiUnicode(Console,
                                                Buffer,
                                                BufferSize
                                               );
                Status = WriteScreenBuffer(ScreenBufferInformation,
                                            Buffer,
                                            &a->CharRegion
                                           );
            }
#else
            TranslateOutputToAnsiUnicode(Console,
                                        Buffer,
                                        BufferSize
                                       );
#endif
        }
#if defined(FE_SB)
        else
#endif
        Status = WriteScreenBuffer(ScreenBufferInformation,
                                    Buffer,
                                    &a->CharRegion
                                   );

        if (a->ReadVM) {
            ConsoleHeapFree(Buffer);
        }
        if (NT_SUCCESS(Status)) {

            //
            // cause screen to be updated
            //

#if defined(FE_SB)
            if (CONSOLE_IS_DBCS_OUTPUTCP(Console) &&
                Console->Flags & CONSOLE_JUST_VDM_UNREGISTERED ){
                int MouseRec;
                MouseRec = Console->InputBuffer.InputMode;
                Console->InputBuffer.InputMode &= ~ENABLE_MOUSE_INPUT;
                Console->CurrentScreenBuffer->BufferInfo.TextInfo.Flags &= ~TEXT_VALID_HINT;
                WriteToScreen(ScreenBufferInformation,&a->CharRegion );
                Console->CurrentScreenBuffer->BufferInfo.TextInfo.Flags |= TEXT_VALID_HINT;
                Console->InputBuffer.InputMode = MouseRec;
            }
            else
#endif
            WriteToScreen(ScreenBufferInformation,
                          &a->CharRegion
                         );
        }
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);    // get rid of unreferenced parameter warning message
}


ULONG
SrvReadConsoleOutputString(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    PVOID Buffer;
    PCONSOLE_READCONSOLEOUTPUTSTRING_MSG a = (PCONSOLE_READCONSOLEOUTPUTSTRING_MSG)&m->u.ApiMessageData;
    ULONG nSize;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_READ,
                                 &HandleData
                                );
    if (!NT_SUCCESS(Status)) {

        //
        // a region of zero size is indicated by the right and bottom
        // coordinates being less than the left and top.
        //

        a->NumRecords = 0;
    } else {
        if (a->StringType == CONSOLE_ASCII)
            nSize = sizeof(CHAR);
        else
            nSize = sizeof(WORD);
        if ((a->NumRecords*nSize) > sizeof(a->String)) {
            Buffer = a->BufPtr;
            if (!CsrValidateMessageBuffer(m, &a->BufPtr, a->NumRecords, nSize)) {
                UnlockConsole(Console);
                return STATUS_INVALID_PARAMETER;
            }
        }
        else {
            Buffer = a->String;
        }
        Status = ReadOutputString(HandleData->Buffer.ScreenBuffer,
                                Buffer,
                                a->ReadCoord,
                                a->StringType,
                                &a->NumRecords
                               );
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);    // get rid of unreferenced parameter warning message
}

ULONG
SrvWriteConsoleOutputString(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_WRITECONSOLEOUTPUTSTRING_MSG a = (PCONSOLE_WRITECONSOLEOUTPUTSTRING_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    PVOID Buffer;
    ULONG nSize;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (!NT_SUCCESS(Status)) {
        a->NumRecords = 0;
    } else {
        if (a->WriteCoord.X < 0 ||
            a->WriteCoord.Y < 0) {
            Status = STATUS_INVALID_PARAMETER;
        } else {
            if (a->StringType == CONSOLE_ASCII)
                nSize = sizeof(CHAR);
            else
                nSize = sizeof(WORD);
            if ((a->NumRecords*nSize) > sizeof(a->String)) {
                Buffer = a->BufPtr;
                if (!CsrValidateMessageBuffer(m, &a->BufPtr, a->NumRecords, nSize)) {
                    UnlockConsole(Console);
                    return STATUS_INVALID_PARAMETER;
                }
            }
            else {
                Buffer = a->String;
            }
            Status = WriteOutputString(HandleData->Buffer.ScreenBuffer,
                                     Buffer,
                                     a->WriteCoord,
                                     a->StringType,
                                     &a->NumRecords,
                                     NULL
                                    );
        }
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);    // get rid of unreferenced parameter warning message
}

ULONG
SrvFillConsoleOutput(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_FILLCONSOLEOUTPUT_MSG a = (PCONSOLE_FILLCONSOLEOUTPUT_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (!NT_SUCCESS(Status)) {
        a->Length = 0;
    } else {
        Status = FillOutput(HandleData->Buffer.ScreenBuffer,
                          a->Element,
                          a->WriteCoord,
                          a->ElementType,
                          &a->Length
                         );
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);    // get rid of unreferenced parameter warning message
}


ULONG
SrvCreateConsoleScreenBuffer(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Routine Description:

    This routine creates a screen buffer and returns a handle to it.

Arguments:

    ApiMessageData - Points to parameter structure.

Return Value:

--*/

{
    PCONSOLE_CREATESCREENBUFFER_MSG a = (PCONSOLE_CREATESCREENBUFFER_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    HANDLE Handle;
    PHANDLE_DATA HandleData;
    PCONSOLE_SHARE_ACCESS ShareAccess;
    CHAR_INFO Fill;
    COORD WindowSize;
    PSCREEN_INFORMATION ScreenInfo;
    PCONSOLE_PER_PROCESS_DATA ProcessData;
    ULONG HandleType;
    int FontIndex;

    DBGOUTPUT(("SrvCreateConsoleScreenBuffer\n"));

    /*
     * Verify that the Flags value is legit, or malicious code could make us
     * fault. Windows Bug #209416.
     */
    if (a->Flags != CONSOLE_TEXTMODE_BUFFER &&
        a->Flags != CONSOLE_GRAPHICS_BUFFER) {
        return STATUS_INVALID_PARAMETER;
    }

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (a->Flags & CONSOLE_GRAPHICS_BUFFER) {
        if (!CsrValidateMessageBuffer(m, &a->GraphicsBufferInfo.lpBitMapInfo, a->GraphicsBufferInfo.dwBitMapInfoLength, sizeof(BYTE))) {
            UnlockConsole(Console);
            return STATUS_INVALID_PARAMETER;
        }
    }

    try {
        Handle = INVALID_HANDLE_VALUE;
        ProcessData = CONSOLE_PERPROCESSDATA();
        HandleType = (a->Flags & CONSOLE_GRAPHICS_BUFFER) ?
                      CONSOLE_GRAPHICS_OUTPUT_HANDLE : CONSOLE_OUTPUT_HANDLE;
        if (a->InheritHandle)
            HandleType |= CONSOLE_INHERITABLE;
        Status = AllocateIoHandle(ProcessData,
                                  HandleType,
                                  &Handle
                                 );
        if (!NT_SUCCESS(Status)) {
            leave;
        }
        Status = DereferenceIoHandleNoCheck(ProcessData,
                                     Handle,
                                     &HandleData
                                    );
        ASSERT (NT_SUCCESS(Status));
        if (!NT_SUCCESS(Status)) {
            leave;
        }

        //
        // create new screen buffer
        //

        Fill.Char.UnicodeChar = (WCHAR)' ';
        Fill.Attributes = Console->CurrentScreenBuffer->Attributes;
        WindowSize.X = (SHORT)CONSOLE_WINDOW_SIZE_X(Console->CurrentScreenBuffer);
        WindowSize.Y = (SHORT)CONSOLE_WINDOW_SIZE_Y(Console->CurrentScreenBuffer);
        FontIndex = FindCreateFont(CON_FAMILY(Console),
                                   CON_FACENAME(Console),
                                   CON_FONTSIZE(Console),
                                   CON_FONTWEIGHT(Console),
                                   CON_FONTCODEPAGE(Console)
                                  );
        Status = CreateScreenBuffer(&ScreenInfo,WindowSize,
                                    FontIndex,
                                    WindowSize,
                                    Fill,Fill,Console,
                                    a->Flags,&a->GraphicsBufferInfo,
                                    &a->lpBitmap,&a->hMutex,
                                    CURSOR_SMALL_SIZE,
                                    NULL);
        if (!NT_SUCCESS(Status)) {
            leave;
        }
        InitializeOutputHandle(HandleData,ScreenInfo);
        ShareAccess = &ScreenInfo->ShareAccess;

        Status = ConsoleAddShare(a->DesiredAccess,
                                 a->ShareMode,
                                 ShareAccess,
                                 HandleData
                                );
        if (!NT_SUCCESS(Status)) {
            HandleData->Buffer.ScreenBuffer->RefCount--;
            FreeScreenBuffer(ScreenInfo);
            leave;
        }
        InsertScreenBuffer(Console, ScreenInfo);
        a->Handle = INDEX_TO_HANDLE(Handle);
    } finally {
        if (!NT_SUCCESS(Status) && Handle != INVALID_HANDLE_VALUE) {
            FreeIoHandle(ProcessData,
                         Handle
                        );
        }
        UnlockConsole(Console);
    }
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);    // get rid of unreferenced parameter warning message
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\server\foncache.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    foncache.c

Abstract:

        This file is EUDC font cache

Author:

    Kazuhiko  Matsubara  21-June-1994

Revision History:

Notes:

--*/

#include "precomp.h"
#pragma hdrstop

#if defined(FE_SB)


VOID
RebaseFontImageList(
    IN PFONT_IMAGE NewFontImage,
    IN PBYTE OldFontImage
    )
{
    PLIST_ENTRY ImageList;
    PBYTE BaseImage = (PBYTE)NewFontImage;

    do {
        ImageList = &NewFontImage->ImageList;
        if (ImageList->Blink)
            ImageList->Blink = (PLIST_ENTRY)((PBYTE)ImageList->Blink - OldFontImage + BaseImage);
        if (ImageList->Flink)
            ImageList->Flink = (PLIST_ENTRY)((PBYTE)ImageList->Flink - OldFontImage + BaseImage);
    } while (NewFontImage = (PFONT_IMAGE)ImageList->Flink);
}





ULONG
CreateFontCache(
    OUT PFONT_CACHE_INFORMATION *FontCache
    )
{
    //
    // allocate font cache data
    //

    *FontCache = ConsoleHeapAlloc(HEAP_ZERO_MEMORY,sizeof(FONT_CACHE_INFORMATION));
    if (*FontCache == NULL) {
        return (ULONG)STATUS_NO_MEMORY;
    }

    return (ULONG)(STATUS_SUCCESS);
}


ULONG
DestroyFontCache(
    IN PFONT_CACHE_INFORMATION FontCache
    )
{
    if (FontCache != NULL)
    {
        PFONT_HIGHLOW_OFFSET FontOffsetHighLow;
        PFONT_LOW_OFFSET     FontOffsetLow;
        PFONT_IMAGE          FontImage;
        UINT i, j, k;

        for (i=0;
             i < sizeof(FontCache->FontTable.FontOffsetHighHigh)/sizeof(PFONT_HIGHLOW_OFFSET);
             i++)
        {
            if (FontOffsetHighLow = FontCache->FontTable.FontOffsetHighHigh[i])
            {
                for (j=0;
                     j < sizeof(FontOffsetHighLow->FontOffsetHighLow)/sizeof(PFONT_LOW_OFFSET);
                     j++)
                {
                    if (FontOffsetLow = FontOffsetHighLow->FontOffsetHighLow[j])
                    {
                        for (k=0;
                             k < sizeof(FontOffsetLow->FontOffsetLow)/sizeof(PFONT_IMAGE);
                             k++)
                        {
                            if (FontImage = FontOffsetLow->FontOffsetLow[k])
                            {
                                ConsoleHeapFree(FontImage);
                            }
                        }
                        ConsoleHeapFree(FontOffsetLow);
                    }
                }
                ConsoleHeapFree(FontOffsetHighLow);
            }
        }
        if (FontCache->BaseImageBits) {
            ConsoleHeapFree(FontCache->BaseImageBits);
        }
        ConsoleHeapFree(FontCache);
    }
    return (ULONG)(STATUS_SUCCESS);
}

ULONG
RebaseFontCache(
    IN PFONT_CACHE_INFORMATION FontCache,
    IN PBYTE OldBaseImage
    )
{
    if (FontCache != NULL)
    {
        PFONT_HIGHLOW_OFFSET FontOffsetHighLow;
        PFONT_LOW_OFFSET     FontOffsetLow;
        PFONT_IMAGE          FontImage;
        UINT i, j, k;

        for (i=0;
             i < sizeof(FontCache->FontTable.FontOffsetHighHigh)/sizeof(PFONT_HIGHLOW_OFFSET);
             i++)
        {
            if (FontOffsetHighLow = FontCache->FontTable.FontOffsetHighHigh[i])
            {
                for (j=0;
                     j < sizeof(FontOffsetHighLow->FontOffsetHighLow)/sizeof(PFONT_LOW_OFFSET);
                     j++)
                {
                    if (FontOffsetLow = FontOffsetHighLow->FontOffsetHighLow[j])
                    {
                        for (k=0;
                             k < sizeof(FontOffsetLow->FontOffsetLow)/sizeof(PFONT_IMAGE);
                             k++)
                        {
                            if (FontImage = FontOffsetLow->FontOffsetLow[k])
                            {
                                LIST_ENTRY ImageList;

                                do {
                                    ImageList = FontImage->ImageList;
                                    if (FontImage->ImageBits) {
                                        FontImage->ImageBits = FontImage->ImageBits - OldBaseImage
                                                               + FontCache->BaseImageBits;
                                    }
                                } while (FontImage = (PFONT_IMAGE)ImageList.Flink);
                            }
                        }
                    }
                }
            }
        }
    }
    return (ULONG)(STATUS_SUCCESS);
}



#define CALC_BITMAP_BITS_FOR_X( FontSizeX, dwAlign ) \
    ( ( ( FontSizeX * BITMAP_BITS_PIXEL + (dwAlign-1) ) & ~(dwAlign-1)) >> BITMAP_ARRAY_BYTE )




DWORD
CalcBitmapBufferSize(
    IN COORD FontSize,
    IN DWORD dwAlign
    )
{
    DWORD uiCount;

    uiCount = CALC_BITMAP_BITS_FOR_X(FontSize.X,
                                     (dwAlign==BYTE_ALIGN ? BITMAP_BITS_BYTE_ALIGN : BITMAP_BITS_WORD_ALIGN));
    uiCount = uiCount * BITMAP_PLANES * FontSize.Y;
    return uiCount;
}

VOID
AlignCopyMemory(
    OUT PBYTE pDestBits,
    IN DWORD dwDestAlign,
    IN PBYTE pSrcBits,
    IN DWORD dwSrcAlign,
    IN COORD FontSize
    )
{
    DWORD dwDestBufferSize;
    COORD coord;

    if (dwDestAlign == dwSrcAlign) {
        dwDestBufferSize = CalcBitmapBufferSize(FontSize, dwDestAlign);
        RtlCopyMemory(pDestBits, pSrcBits, dwDestBufferSize);
        return;
    }

    switch (dwDestAlign) {
        default:
        case WORD_ALIGN:
            switch (dwSrcAlign) {
                default:
                //
                // pDest = WORD, pSrc = WORD
                //
                case WORD_ALIGN:
                    dwDestBufferSize = CalcBitmapBufferSize(FontSize, dwDestAlign);
                    RtlCopyMemory(pDestBits, pSrcBits, dwDestBufferSize);
                    break;
                //
                // pDest = WORD, pSrc = BYTE
                //
                case BYTE_ALIGN:
                    dwDestBufferSize = CalcBitmapBufferSize(FontSize, dwDestAlign);
                    if (((FontSize.X % BITMAP_BITS_BYTE_ALIGN) == 0) &&
                        ((FontSize.X % BITMAP_BITS_WORD_ALIGN) == 0)   ) {
                        RtlCopyMemory(pDestBits, pSrcBits, dwDestBufferSize);
                    }
                    else {
                        RtlZeroMemory(pDestBits, dwDestBufferSize);
                        for (coord.Y=0; coord.Y < FontSize.Y; coord.Y++) {
                            for (coord.X=0;
                                 coord.X < CALC_BITMAP_BITS_FOR_X(FontSize.X, BITMAP_BITS_BYTE_ALIGN);
                                 coord.X++) {
                                *pDestBits++ = *pSrcBits++;
                            }
                            if (CALC_BITMAP_BITS_FOR_X(FontSize.X, BITMAP_BITS_BYTE_ALIGN) & 1)
                                pDestBits++;
                        }
                    }
                    break;
            }
            break;
        case BYTE_ALIGN:
            switch (dwSrcAlign) {
                //
                // pDest = BYTE, pSrc = BYTE
                //
                case BYTE_ALIGN:
                    dwDestBufferSize = CalcBitmapBufferSize(FontSize, dwDestAlign);
                    RtlCopyMemory(pDestBits, pSrcBits, dwDestBufferSize);
                    break;
                default:
                //
                // pDest = BYTE, pSrc = WORD
                //
                case WORD_ALIGN:
                    dwDestBufferSize = CalcBitmapBufferSize(FontSize, dwDestAlign);
                    if (((FontSize.X % BITMAP_BITS_BYTE_ALIGN) == 0) &&
                        ((FontSize.X % BITMAP_BITS_WORD_ALIGN) == 0)   ) {
                        RtlCopyMemory(pDestBits, pSrcBits, dwDestBufferSize);
                    }
                    else {
                        RtlZeroMemory(pDestBits, dwDestBufferSize);
                        for (coord.Y=0; coord.Y < FontSize.Y; coord.Y++) {
                            for (coord.X=0;
                                 coord.X < CALC_BITMAP_BITS_FOR_X(FontSize.X, BITMAP_BITS_BYTE_ALIGN);
                                 coord.X++) {
                                *pDestBits++ = *pSrcBits++;
                            }
                            if (CALC_BITMAP_BITS_FOR_X(FontSize.X, BITMAP_BITS_BYTE_ALIGN) & 1)
                                pSrcBits++;
                        }
                    }
                    break;
            }
            break;
    }
}



NTSTATUS
GetStretchImage(
    IN COORD FontSize,
    IN PFONT_IMAGE FontImage,
    OUT PFONT_IMAGE *pFontImage
    )
{
    PFONT_IMAGE NearFont;
    DWORD Find;
    COORD FontDelta;
    HDC hDC;
    HDC hSrcMemDC, hDestMemDC;
    HBITMAP hSrcBmp, hDestBmp;
    DWORD BufferSize;
    NTSTATUS Status = STATUS_NO_MEMORY;

    Find = (DWORD)-1;
    NearFont = NULL;
    do {
        FontDelta.X = (SHORT) abs(FontSize.X - FontImage->FontSize.X);
        FontDelta.Y = (SHORT) abs(FontSize.Y - FontImage->FontSize.Y);
        if (Find > (DWORD)(FontDelta.X + FontDelta.Y))
        {
            Find = (DWORD)(FontDelta.X + FontDelta.Y);
            NearFont = FontImage;
        }
    }
    while (FontImage = (PFONT_IMAGE)FontImage->ImageList.Flink);

    if (NearFont == NULL)
        return STATUS_ACCESS_DENIED;

    if ((hDC = CreateDC(TEXT("DISPLAY"),NULL,NULL,NULL)) != NULL) {
        hSrcMemDC  = CreateCompatibleDC(hDC);
        hDestMemDC = CreateCompatibleDC(hDC);

        hSrcBmp  = CreateBitmap(NearFont->FontSize.X,
                                NearFont->FontSize.Y,
                                BITMAP_PLANES, BITMAP_BITS_PIXEL,
                                NearFont->ImageBits);
        hDestBmp = CreateBitmap(FontSize.X,
                                FontSize.Y,
                                BITMAP_PLANES, BITMAP_BITS_PIXEL,
                                NULL);
        if (hSrcMemDC && hSrcBmp && hDestMemDC && hDestBmp) {
            SelectObject(hSrcMemDC,  hSrcBmp);
            SelectObject(hDestMemDC, hDestBmp);

            if (! StretchBlt(hDestMemDC, 0, 0, FontSize.X, FontSize.Y,
                             hSrcMemDC,  0, 0, NearFont->FontSize.X, NearFont->FontSize.Y,
                             SRCCOPY)) {
                Status = GetLastError();
            } else {
                BufferSize = CalcBitmapBufferSize(FontSize, WORD_ALIGN);
                GetBitmapBits(hDestBmp, BufferSize, (*pFontImage)->ImageBits);
                Status = STATUS_SUCCESS;
            }
        }

        if (hSrcMemDC) {
            DeleteDC(hSrcMemDC);
        }
        if (hDestMemDC) {
            DeleteDC(hDestMemDC);
        }
        if (hSrcBmp) {
            DeleteObject(hSrcBmp);
        }
        if (hDestBmp) {
            DeleteObject(hDestBmp);
        }
        DeleteDC(hDC);
    }

    return Status;
}



NTSTATUS
GetFontImageInternal(
    IN PFONT_CACHE_INFORMATION FontCache,
    IN WCHAR wChar,
    IN COORD FontSize,
    OUT PFONT_IMAGE *pFontImage,
    IN DWORD GetFlag
    )
{
    PFONT_HIGHLOW_OFFSET FontOffsetHighLow;
    PFONT_LOW_OFFSET     FontOffsetLow;
    PFONT_IMAGE          FontImage;
    WORD  HighHighIndex, HighLowIndex;
    WORD  LowIndex;
    DWORD Flag;

    HighHighIndex = (HIBYTE(wChar)) >> 4;
    HighLowIndex  = (HIBYTE(wChar)) & 0x0f;
    LowIndex      = LOBYTE(wChar);

    FontOffsetHighLow = FontCache->FontTable.FontOffsetHighHigh[HighHighIndex];
    if (FontOffsetHighLow == NULL)
        return STATUS_ACCESS_DENIED;

    FontOffsetLow = FontOffsetHighLow->FontOffsetHighLow[HighLowIndex];
    if (FontOffsetLow == NULL)
        return STATUS_ACCESS_DENIED;

    FontImage = FontOffsetLow->FontOffsetLow[LowIndex];
    if (FontImage == NULL)
        return STATUS_ACCESS_DENIED;


    Flag = ADD_IMAGE;
    do {
        if (FontImage->FontSize.X == FontSize.X &&
            FontImage->FontSize.Y == FontSize.Y   ) {
            //
            // Replace font image
            //
            Flag = REPLACE_IMAGE;
            break;
        }
    }
    while (FontImage = (PFONT_IMAGE)FontImage->ImageList.Flink);

    switch (GetFlag)
    {
        //
        // Get matched size font.
        //
        case FONT_MATCHED:
            if (Flag != REPLACE_IMAGE)
                return STATUS_ACCESS_DENIED;

            *pFontImage = FontImage;
            break;

        //
        // Get stretched size font.
        //
        case FONT_STRETCHED:
            if (Flag == REPLACE_IMAGE &&
                FontImage->ImageBits != NULL) {

                *pFontImage = FontImage;

            }
            else {
                GetStretchImage(FontSize,
                                FontOffsetLow->FontOffsetLow[LowIndex],
                                pFontImage
                               );
            }
            break;
    }

    return STATUS_SUCCESS;
}

//
// See Raid #362907, stress failure
//

VOID UnlinkAndShrinkFontImagesByOne(
    PFONT_IMAGE* ppFontImage,
    PFONT_IMAGE pFontImageRemove)
{
    PFONT_IMAGE OldFontImage = *ppFontImage;
    SIZE_T OldFontSize = ConsoleHeapSize(OldFontImage);
    PFONT_IMAGE NewFontImage;

    RIPMSG0(RIP_WARNING, "UnlinkAndShrinkFontImagesByOne entered.");

    if (OldFontImage== NULL) {
        RIPMSG0(RIP_ERROR, "UnlinkAndShrinkFontImagesByOne: *ppFontImage is NULL.");
        //
        // There's nothing to shrink.
        //
        return;
    }

    if (OldFontImage == pFontImageRemove) {
        RIPMSG0(RIP_WARNING, "UnlinkAndShrinkFontImagesByOne: unshrinking just one element.");
        //
        // There's just one entry. Let's free it and set
        // ppFontImage as NULL, and bail out.
        //
        UserAssert(OldFontSize < sizeof(FONT_IMAGE) * 2);

        *ppFontImage = NULL;
        ConsoleHeapFree(OldFontImage);
        return;
    }

#if DBG
    //
    // Double check the integrity of the linked list.
    //
    {
        PFONT_IMAGE FontImageTmp;

        //
        // Search the tail element
        //
        for (FontImageTmp = OldFontImage; FontImageTmp->ImageList.Flink; FontImageTmp = (PFONT_IMAGE)FontImageTmp->ImageList.Flink)
            ;

        UserAssert(FontImageTmp == pFontImageRemove);
    }
#endif

    //
    // Remove the tail element
    //
    pFontImageRemove->ImageList.Blink->Flink = NULL;

    //
    // Shrink the contiguous memory chunk
    //
    // Note: this code assumes sizeof(FONT_IMAGE) is larger than
    // HEAP_GRANULARITY. If not, the heap block actually does not
    // shrink, and the assert below will hit.
    //
    NewFontImage = ConsoleHeapReAlloc(HEAP_ZERO_MEMORY,
                               OldFontImage,
                               OldFontSize - sizeof(FONT_IMAGE));
    if (NewFontImage == NULL) {
        //
        // Win32HeapRealloc firstly allocates a new memory and then
        // copies the content. If the allocation fails, it leaves the
        // original heap as is.
        //
        // Even though the realloc fails, the last element (pFontImageRemove) is
        // already removed from the linked list. The next time SetImageFontInternal
        // is called, a new FontImage might be added to this memory chunk, but the
        // the code always links the newly extended memory.
        // This leaves the sizeof(FONT_IMAGE) memory unused, but it's safe. Assuming
        // sizeof(FONT_IMAGE) is small, memory waste should be minimum.
        //
        // It's OK for us to just bail out here.
        //
        RIPMSG0(RIP_WARNING, "UnlinkAndShrinkFontImagesByOne: failed to shrink ppFontImage.");
        return;
    }
    UserAssert(ConsoleHeapSize(NewFontImage) != OldFontSize);

    if (NewFontImage != OldFontImage) {
        //
        // Rebase Font Image Linked List
        //
        RebaseFontImageList(NewFontImage, (PBYTE)OldFontImage);
        *ppFontImage = NewFontImage;
    }
}

NTSTATUS
SetFontImageInternal(
    IN PFONT_CACHE_INFORMATION FontCache,
    IN WCHAR wChar,
    IN COORD FontSize,
    IN DWORD dwAlign,
    IN CONST VOID *ImageBits
    )
{
    PFONT_HIGHLOW_OFFSET FontOffsetHighLow;
    PFONT_LOW_OFFSET     FontOffsetLow;
    PFONT_IMAGE          FontImage;
    PFONT_IMAGE          FontImageTmp;
    WORD  HighHighIndex, HighLowIndex;
    WORD  LowIndex;
    DWORD Flag;
    DWORD BufferSize;

    HighHighIndex = (HIBYTE(wChar)) >> 4;
    HighLowIndex  = (HIBYTE(wChar)) & 0x0f;
    LowIndex      = LOBYTE(wChar);

    /*
     * When Console is being destroyed, all font cache information
     * will be freed (see DestroyFontCache), so no memory leak
     * is expected on those, even if we cleanup everything on
     * error return...
     */

    FontOffsetHighLow = FontCache->FontTable.FontOffsetHighHigh[HighHighIndex];
    if (FontOffsetHighLow == NULL) {
        FontOffsetHighLow = ConsoleHeapAlloc( HEAP_ZERO_MEMORY, sizeof(FONT_HIGHLOW_OFFSET));
        if (FontOffsetHighLow == NULL) {
            RIPMSG1(RIP_WARNING, "SetFontImageInternal: cannot allocate memory (%d bytes)",
                      sizeof(FONT_HIGHLOW_OFFSET));
            return STATUS_NO_MEMORY;
        }

        FontCache->FontTable.FontOffsetHighHigh[HighHighIndex] = FontOffsetHighLow;
    }

    FontOffsetLow = FontOffsetHighLow->FontOffsetHighLow[HighLowIndex];
    if (FontOffsetLow == NULL) {
        FontOffsetLow = ConsoleHeapAlloc( HEAP_ZERO_MEMORY, sizeof(FONT_LOW_OFFSET));
        if (FontOffsetLow == NULL) {
            RIPMSG0(RIP_WARNING, "SetFontImageInternal: failed to allocate FontOffsetLow.");
            return STATUS_NO_MEMORY;
        }

        FontOffsetHighLow->FontOffsetHighLow[HighLowIndex] = FontOffsetLow;
    }

    FontImage = FontOffsetLow->FontOffsetLow[LowIndex];
    if (FontImage == NULL) {
        FontImage = ConsoleHeapAlloc( HEAP_ZERO_MEMORY, sizeof(FONT_IMAGE));
        if (FontImage == NULL) {
            RIPMSG0(RIP_WARNING, "SetFontImageInternal: failed to allocate FontImage");
            return STATUS_NO_MEMORY;
        }
    }

    if (FontSize.X == 0 &&
        FontSize.Y == 0   ) {
        //
        // Reset registered font
        //
        if (FontImage != NULL)
        {
            ConsoleHeapFree(FontImage);
            FontOffsetLow->FontOffsetLow[LowIndex] = NULL;
        }
        return STATUS_SUCCESS;
    }

    Flag = ADD_IMAGE;
    FontImageTmp = FontImage;
    do {
        if (FontImageTmp->FontSize.X == FontSize.X &&
            FontImageTmp->FontSize.Y == FontSize.Y   ) {
            //
            // Replace font image
            //
            Flag = REPLACE_IMAGE;
            FontImage = FontImageTmp;
            break;
        }
    }
    while (FontImageTmp = (PFONT_IMAGE)FontImageTmp->ImageList.Flink);

    switch (Flag) {
        case ADD_IMAGE:
            if (FontOffsetLow->FontOffsetLow[LowIndex] != NULL)
            {
                PFONT_IMAGE OldFontImage = FontOffsetLow->FontOffsetLow[LowIndex];
                SIZE_T OldFontSize = ConsoleHeapSize(OldFontImage);
                PFONT_IMAGE NewFontImage;

                NewFontImage = ConsoleHeapReAlloc(HEAP_ZERO_MEMORY,
                                           OldFontImage,
                                           OldFontSize + sizeof(FONT_IMAGE));
                if (NewFontImage == NULL) {
                    RIPMSG0(RIP_WARNING, "SetFontImageInternal: failed to allocate NewFontImage");
                    return STATUS_NO_MEMORY;
                }

                FontOffsetLow->FontOffsetLow[LowIndex] = NewFontImage;

                // Rebase Font Image List
                RebaseFontImageList(NewFontImage, (PBYTE)OldFontImage);

                NewFontImage = (PFONT_IMAGE)((PBYTE)NewFontImage + OldFontSize);

                NewFontImage->FontSize = FontSize;

                //
                // Connect link list.
                //
                (NewFontImage-1)->ImageList.Flink = (PLIST_ENTRY)NewFontImage;
                NewFontImage->ImageList.Blink = (PLIST_ENTRY)(NewFontImage-1);

                FontImage = NewFontImage;
            }
            else
            {
                FontImage->FontSize = FontSize;
                FontOffsetLow->FontOffsetLow[LowIndex] = FontImage;
            }

            //
            // Allocate Image Buffer
            //
            BufferSize = CalcBitmapBufferSize(FontSize,WORD_ALIGN);

            if (FontCache->BaseImageBits == NULL)
            {
                FontCache->BaseImageBits = ConsoleHeapAlloc( HEAP_ZERO_MEMORY, BufferSize);
                if (FontCache->BaseImageBits == NULL) {
                    RIPMSG0(RIP_WARNING, "SetFontImageInternal: failed to allocate FontCache->BaseImageBits");
                    UnlinkAndShrinkFontImagesByOne(&FontOffsetLow->FontOffsetLow[LowIndex], FontImage);
                    return STATUS_NO_MEMORY;
                }

                FontImage->ImageBits = FontCache->BaseImageBits;
            }
            else
            {
                PBYTE OldBaseImage = FontCache->BaseImageBits;
                SIZE_T OldImageSize = ConsoleHeapSize(OldBaseImage);
                FontCache->BaseImageBits = ConsoleHeapReAlloc(HEAP_ZERO_MEMORY,
                                                       OldBaseImage,
                                                       OldImageSize + BufferSize);
                if (FontCache->BaseImageBits == NULL) {
                    RIPMSG0(RIP_WARNING, "SetFontImageInternal: failed to reallocate FontCache->BaseImageBits");
                    //
                    // When reallocation fails, we preserve the old baseImageBits
                    // so that other FontImage->ImageBits can be still valid.
                    //
                    FontCache->BaseImageBits = OldBaseImage;
                    //
                    // Remove the tail element that we failed to add image.
                    //
                    UnlinkAndShrinkFontImagesByOne(&FontOffsetLow->FontOffsetLow[LowIndex], FontImage);
                    return STATUS_NO_MEMORY;
                }

                // Rebase font image pointer
                RebaseFontCache(FontCache, OldBaseImage);

                FontImage->ImageBits = FontCache->BaseImageBits + OldImageSize;
            }

            AlignCopyMemory(FontImage->ImageBits,// pDestBits
                            WORD_ALIGN,          // dwDestAlign
                            (PVOID)ImageBits,    // pSrcBits
                            dwAlign,             // dwSrcAlign
                            FontSize);

            break;

        case REPLACE_IMAGE:
            if (FontImage->ImageBits == NULL) {
                RIPMSG0(RIP_WARNING, "SetFontImageInternal: FontImage->ImageBits is NULL.");
                return STATUS_NO_MEMORY;
            }

            AlignCopyMemory(FontImage->ImageBits,// pDestBits
                            WORD_ALIGN,          // dwDestAlign
                            (PVOID)ImageBits,    // pSrcBits
                            dwAlign,             // dwSrcAlign
                            FontSize);

            break;
    }

    return STATUS_SUCCESS;
}





ULONG
GetFontImage(
    IN PFONT_CACHE_INFORMATION FontCache,
    IN WCHAR wChar,
    IN COORD FontSize,
    IN DWORD dwAlign,
    OUT VOID *ImageBits
    )
{
    NTSTATUS Status;
    PFONT_IMAGE FontImage;

    if (FontSize.X == 0 &&
        FontSize.Y == 0   ) {
        return (ULONG)(STATUS_INVALID_PARAMETER);
    }

    Status = GetFontImageInternal(FontCache,wChar,FontSize,&FontImage,FONT_MATCHED);
    if (! NT_SUCCESS(Status) )
        return (ULONG)Status;

    if (FontImage->ImageBits == NULL ||
        ImageBits == NULL)
        return STATUS_SUCCESS;

    AlignCopyMemory((PVOID)ImageBits,    // pDestBits
                    dwAlign,             // dwDestAlign
                    FontImage->ImageBits,// pSrcBits
                    WORD_ALIGN,          // dwSrcAlign
                    FontSize);

    return STATUS_SUCCESS;
}

ULONG
GetStretchedFontImage(
    IN PFONT_CACHE_INFORMATION FontCache,
    IN WCHAR wChar,
    IN COORD FontSize,
    IN DWORD dwAlign,
    OUT VOID *ImageBits
    )
{
    NTSTATUS Status;
    PFONT_IMAGE FontImage;
    FONT_IMAGE  FontBuff;
    DWORD BufferSize;

    if (FontSize.X == 0 &&
        FontSize.Y == 0   ) {
        return (ULONG)(STATUS_INVALID_PARAMETER);
    }

    FontImage = &FontBuff;

    BufferSize = CalcBitmapBufferSize(FontSize,WORD_ALIGN);
    FontImage->ImageBits = ConsoleHeapAlloc( HEAP_ZERO_MEMORY, BufferSize);
    if (FontImage->ImageBits == NULL) {
        RIPMSG0(RIP_WARNING, "GetStretchedFontImage: failed to allocate FontImage->ImageBits");
        return (ULONG)STATUS_NO_MEMORY;
    }

    Status = GetFontImageInternal(FontCache,wChar,FontSize,&FontImage,FONT_STRETCHED);
    if (! NT_SUCCESS(Status) )
    {
        ConsoleHeapFree(FontBuff.ImageBits);
        return (ULONG)Status;
    }

    if (FontImage->ImageBits == NULL)
    {
        ConsoleHeapFree(FontBuff.ImageBits);
        return (ULONG)STATUS_SUCCESS;
    }

    AlignCopyMemory((PVOID)ImageBits,    // pDestBits
                    dwAlign,             // dwDestAlign
                    FontImage->ImageBits,// pSrcBits
                    WORD_ALIGN,          // dwSrcAlign
                    FontSize);

    ConsoleHeapFree(FontBuff.ImageBits);

    return (ULONG)STATUS_SUCCESS;
}

ULONG
GetFontImagePointer(
    IN PFONT_CACHE_INFORMATION FontCache,
    IN WCHAR wChar,
    IN COORD FontSize,
    OUT PFONT_IMAGE *FontImage
    )
{
    NTSTATUS Status;

    if (FontSize.X == 0 &&
        FontSize.Y == 0   ) {
        return (ULONG)(STATUS_INVALID_PARAMETER);
    }

    Status = GetFontImageInternal(FontCache,wChar,FontSize,(PFONT_IMAGE*)FontImage,FONT_MATCHED);
    if (! NT_SUCCESS(Status) )
        return (ULONG)Status;

    if ((*FontImage)->ImageBits == NULL)
        return (ULONG)STATUS_ACCESS_DENIED;

    return Status;
}

ULONG
SetFontImage(
    IN PFONT_CACHE_INFORMATION FontCache,
    IN WCHAR wChar,
    IN COORD FontSize,
    IN DWORD dwAlign,
    IN CONST VOID *ImageBits
    )
{
    return SetFontImageInternal(FontCache,wChar,FontSize,dwAlign,ImageBits);
}


NTSTATUS
GetExpandImage(
    COORD InputFontSize,
    PWORD InputFontImage,
    COORD OutputFontSize,
    PWORD OutputFontImage
    )
{
    NTSTATUS Status;
    DWORD InputRow = CALC_BITMAP_BITS_FOR_X(InputFontSize.X, BITMAP_BITS_WORD_ALIGN);
    DWORD OutputRow = CALC_BITMAP_BITS_FOR_X(OutputFontSize.X, BITMAP_BITS_WORD_ALIGN);
    DWORD InputBufferSize = CalcBitmapBufferSize(InputFontSize,WORD_ALIGN);
    DWORD OutputBufferSize = CalcBitmapBufferSize(OutputFontSize,WORD_ALIGN);

    Status = STATUS_NO_MEMORY;

    RtlZeroMemory(OutputFontImage,OutputBufferSize);

    ASSERT(InputRow==OutputRow);

    if (InputFontSize.Y < OutputFontSize.Y)
        RtlCopyMemory(OutputFontImage, InputFontImage, InputBufferSize);
    else
        RtlCopyMemory(OutputFontImage, InputFontImage, OutputBufferSize);

    return STATUS_SUCCESS;
}

NTSTATUS
GetExpandFontImage(
    PFONT_CACHE_INFORMATION FontCache,
    WCHAR wChar,
    COORD InputFontSize,
    COORD OutputFontSize,
    PWORD OutputFontImage
    )
{
    NTSTATUS Status;
    DWORD InputBufferSize;
    PWORD InputFontImage;

    if (InputFontSize.X == 0 &&
        InputFontSize.Y == 0   ) {
        return (ULONG)(STATUS_INVALID_PARAMETER);
    }

    if (OutputFontSize.X == 0 &&
        OutputFontSize.Y == 0   ) {
        return (ULONG)(STATUS_INVALID_PARAMETER);
    }

    InputBufferSize = CalcBitmapBufferSize(InputFontSize,WORD_ALIGN);
    InputFontImage = ConsoleHeapAlloc( HEAP_ZERO_MEMORY, InputBufferSize);
    if (InputFontImage==NULL)
        return STATUS_NO_MEMORY;


    Status = GetFontImage(FontCache,
                          wChar,
                          InputFontSize,
                          WORD_ALIGN,
                          InputFontImage);
    if (! NT_SUCCESS(Status) )
    {
        ConsoleHeapFree(InputFontImage);
        return Status;
    }

    Status = GetExpandImage(InputFontSize,
                            InputFontImage,
                            OutputFontSize,
                            OutputFontImage);

    ConsoleHeapFree(InputFontImage);

    return Status;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\server\eudc.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    eudc.c

Abstract:

Author:

    KazuM Apr.19.1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


#if defined(FE_SB)


NTSTATUS
CreateEUDC(
    PCONSOLE_INFORMATION Console
    )
{
    PEUDC_INFORMATION EudcInfo;

    EudcInfo = ConsoleHeapAlloc( MAKE_TAG( EUDC_TAG ), sizeof(EUDC_INFORMATION));
    if (EudcInfo == NULL) {
        return STATUS_NO_MEMORY;
    }
    EudcInfo->LocalVDMEudcMode = FALSE;
    EudcInfo->LocalKeisenEudcMode = FALSE;
    EudcInfo->hDCLocalEudc = NULL;
    EudcInfo->hBmpLocalEudc = NULL;
    EudcInfo->EudcFontCacheInformation = NULL;
    EudcInfo->LocalEudcSize.X = DEFAULT_EUDCSIZE;
    EudcInfo->LocalEudcSize.Y = DEFAULT_EUDCSIZE;

    RtlZeroMemory(&EudcInfo->EudcRange,sizeof(EudcInfo->EudcRange));
    EudcInfo->EudcRangeSize = GetSystemEUDCRangeW(EudcInfo->EudcRange, EUDC_RANGE_SIZE);
    if (EudcInfo->EudcRangeSize)
        EudcInfo->EudcRangeSize--;    // remove terminator

    Console->EudcInformation = (PVOID)EudcInfo;

    return STATUS_SUCCESS;
}

VOID
DeleteEUDC(
    PCONSOLE_INFORMATION Console
    )
{
    PEUDC_INFORMATION EudcInfo = Console->EudcInformation;

    if (EudcInfo->hDCLocalEudc) {
         ReleaseDC(NULL, EudcInfo->hDCLocalEudc);
         DeleteObject(EudcInfo->hBmpLocalEudc);
    }
}

NTSTATUS
RegisterLocalEUDC(
    IN PCONSOLE_INFORMATION Console,
    IN WCHAR wChar,
    IN COORD FontSize,
    IN PCHAR FontFace
    )
{
    NTSTATUS Status;
    PCHAR TmpBuff;
    DWORD BuffSize;
    PEUDC_INFORMATION EudcInfo = Console->EudcInformation;

    if (EudcInfo->EudcFontCacheInformation == NULL) {
        Status = (NTSTATUS)CreateFontCache(&(PFONT_CACHE_INFORMATION)EudcInfo->EudcFontCacheInformation);
        if (!NT_SUCCESS(Status)) {
            RIPMSG1(RIP_WARNING, "RegisterLocalEUDC: failed in CreateFontCache, Status is %08x", Status);
            return Status;
        }
    }

    BuffSize = CalcBitmapBufferSize(FontSize, BYTE_ALIGN);
    TmpBuff = FontFace;
    while(BuffSize--)
        *TmpBuff++ = ~(*TmpBuff);

    return (NTSTATUS)SetFontImage(EudcInfo->EudcFontCacheInformation,
                                  wChar,
                                  FontSize,
                                  BYTE_ALIGN,
                                  FontFace
                                 );
}

VOID
FreeLocalEUDC(
    IN PCONSOLE_INFORMATION Console
    )
{
    PEUDC_INFORMATION EudcInfo = Console->EudcInformation;

    if (EudcInfo->EudcFontCacheInformation != NULL) {
        DestroyFontCache((PFONT_CACHE_INFORMATION)EudcInfo->EudcFontCacheInformation);
    }

    ConsoleHeapFree(Console->EudcInformation);
}

VOID
GetFitLocalEUDCFont(
    IN PCONSOLE_INFORMATION Console,
    IN WCHAR wChar
    )
{
    NTSTATUS Status;
    COORD FontSize;
    VOID *FontFace;
    DWORD BuffSize;
    PEUDC_INFORMATION EudcInfo;
    PFONT_CACHE_INFORMATION FontCacheInfo;

    EudcInfo = (PEUDC_INFORMATION)Console->EudcInformation;
    FontCacheInfo = (PFONT_CACHE_INFORMATION)EudcInfo->EudcFontCacheInformation;

    FontSize = CON_FONTSIZE(Console);
    if (IsConsoleFullWidth(Console->hDC,Console->OutputCP,wChar)) {
        FontSize.X *= 2;
    }

    if ((EudcInfo->LocalEudcSize.X != FontSize.X) ||
        (EudcInfo->LocalEudcSize.Y != FontSize.Y)   ) {
        ReleaseDC(NULL, EudcInfo->hDCLocalEudc);
        DeleteObject(EudcInfo->hBmpLocalEudc);
        EudcInfo->hDCLocalEudc = CreateCompatibleDC(Console->hDC);
        EudcInfo->hBmpLocalEudc = CreateBitmap(FontSize.X, FontSize.Y, BITMAP_PLANES, BITMAP_BITS_PIXEL, NULL);
        SelectObject(EudcInfo->hDCLocalEudc, EudcInfo->hBmpLocalEudc);
        EudcInfo->LocalEudcSize.X = FontSize.X;
        EudcInfo->LocalEudcSize.Y = FontSize.Y;
    }

    BuffSize = CalcBitmapBufferSize(FontSize,WORD_ALIGN);
    FontFace = ConsoleHeapAlloc( MAKE_TAG( TMP_DBCS_TAG ), BuffSize);
    if (FontFace == NULL) {
        RIPMSG0(RIP_WARNING, "GetFitLocalEUDCFont: failed to allocate FontFace.");
        return;
    }

    Status = (NTSTATUS)GetFontImage(FontCacheInfo,
                                    wChar,
                                    FontSize,
                                    WORD_ALIGN,
                                    FontFace
                                   );
    if (! NT_SUCCESS(Status)) {

        if ((Console->Flags & CONSOLE_VDM_REGISTERED) &&
            FontSize.X == DefaultFontSize.X * 2       &&
            FontSize.Y == DefaultFontSize.Y           &&
            FontSize.X == VDM_EUDC_FONT_SIZE_X        &&
            FontSize.Y - 2 == VDM_EUDC_FONT_SIZE_Y      ) {

            COORD TmpFontSize = FontSize;

            TmpFontSize.Y -= 2;
            RtlFillMemory((PVOID)FontFace,BuffSize,0xff);
            Status = (NTSTATUS)GetFontImage(FontCacheInfo,
                                            wChar,
                                            TmpFontSize,
                                            WORD_ALIGN,
                                            FontFace
                                           );
            if (! NT_SUCCESS(Status)) {
                Status = (NTSTATUS)GetStretchedFontImage(FontCacheInfo,
                                                         wChar,
                                                         FontSize,
                                                         WORD_ALIGN,
                                                         FontFace
                                                        );
                if (! NT_SUCCESS(Status)) {
                    ASSERT(FALSE);
                    ConsoleHeapFree(FontFace);
                    return;
                }
            }
        }
        else {
            Status = (NTSTATUS)GetStretchedFontImage(FontCacheInfo,
                                                     wChar,
                                                     FontSize,
                                                     WORD_ALIGN,
                                                     FontFace
                                                    );
            if (! NT_SUCCESS(Status)) {
                ASSERT(FALSE);
                ConsoleHeapFree(FontFace);
                return;
            }
        }

        Status = (NTSTATUS)SetFontImage(FontCacheInfo,
                                        wChar,
                                        FontSize,
                                        WORD_ALIGN,
                                        FontFace
                                       );
        if (! NT_SUCCESS(Status)) {
            ASSERT(FALSE);
            ConsoleHeapFree(FontFace);
            return;
        }
    }

    SetBitmapBits(EudcInfo->hBmpLocalEudc, BuffSize, (PBYTE)FontFace);

    ConsoleHeapFree(FontFace);
}

BOOL
IsEudcRange(
    IN PCONSOLE_INFORMATION Console,
    IN WCHAR ch
    )
{
    PEUDC_INFORMATION EudcInfo;
    int i;

    EudcInfo = (PEUDC_INFORMATION)Console->EudcInformation;

    for (i=0; i < EudcInfo->EudcRangeSize; i+=2)
    {
        if (EudcInfo->EudcRange[i] <= ch && ch <= EudcInfo->EudcRange[i+1])
            return TRUE;
    }
    return FALSE;
}

BOOL
CheckEudcRangeInString(
    IN PCONSOLE_INFORMATION Console,
    IN  PWCHAR string,
    IN  SHORT  len,
    OUT SHORT  *find_pos
    )
{
    SHORT i;

    for (i = 0; i < len; i++,string++)
    {
        if (IsEudcRange(Console, *string))
        {
            *find_pos = i;
            return TRUE;
        }
    }
    return FALSE;
}

LPWSTR
SkipWhite(
    LPWSTR lpch
    )
{
    if( lpch == NULL )
        return( NULL );

    for ( ; ; lpch++ )
    {
        switch (*lpch)
        {
            case L' ':
            case L'\t':
            case L'\r':
            case L'\n':
                break;

            default:
                return(lpch);
        }
    }
}

WORD
ConvertStringToHex(
    LPWSTR lpch,
    LPWSTR *endptr
    )
{
    WCHAR ch;
    WORD val = 0;

    while ( (ch=*lpch) != L'\0')
    {
        if (L'0' <= ch && ch <= L'9')
            val = (val << 4) + (ch - L'0');
        else if (L'A' <= ch && ch <= L'F')
            val = (val << 4) + (ch - L'A' + 10);
        else if (L'a' <= ch && ch <= L'f')
            val = (val << 4) + (ch - L'a' + 10);
        else
            break;

        lpch++;
    }

    if (endptr)
        *endptr = lpch;
    return val;
}

WORD
ConvertStringToDec(
    LPWSTR lpch,
    LPWSTR *endptr
    )
{
    WCHAR ch;
    WORD val = 0;

    while ( (ch=*lpch) != L'\0')
    {
        if (L'0' <= ch && ch <= L'9')
            val = (val * 10) + (ch - L'0');
        else
            break;

        lpch++;
    }

    if (endptr)
        *endptr = lpch;
    return val;
}

INT
GetSystemEUDCRangeW(
    WORD  *pwEUDCCharTable,
    UINT   cjSize
    )
{
    NTSTATUS Status;
    HKEY     hkRegistry;
    UNICODE_STRING SystemACPString;
    WCHAR    awcACP[10];
    WCHAR    awchBuffer[ 512 ];
    INT      iEntry = 0;

    /*
     * Check parameter
     *
     * If pwEUDCWideCharTable == NULL && cjSize == 0
     * We have to return the needed buffer size to store data
     */
    if( ( pwEUDCCharTable == NULL && cjSize != 0 ) ||
        ( pwEUDCCharTable != NULL && cjSize == 0 )
      )
    {
        return 0;
    }

    /*
     * Open registry key
     */
    Status = MyRegOpenKey(NULL,
                          MACHINE_REGISTRY_EUDC,
                          &hkRegistry);
    if (!NT_SUCCESS( Status )) {
        DBGPRINT(("CONSRV:GetSystemEUDCRangeW() RegOpenKeyExW( %ws ) fail\n", MACHINE_REGISTRY_EUDC));
        return 0;
    }

    /*
     * Convert ACP to Unicode string..
     */
    SystemACPString.Length        = 0;
    SystemACPString.MaximumLength = sizeof(awcACP)/sizeof(WCHAR);
    SystemACPString.Buffer        = awcACP;
    RtlIntegerToUnicodeString( WINDOWSCP, 10, &SystemACPString );

    /*
     * Read registry data
     */
    Status = MyRegQueryValue(hkRegistry,
                             awcACP,
                             sizeof(awchBuffer), (PBYTE)&awchBuffer);
    if (!NT_SUCCESS( Status )) {
        DBGPRINT(("CONSRV:GetSystemEUDCRangeW NtQueryValueKey failed %ws\n", awcACP));
    }
    else {
        LPWSTR pwszBuf = awchBuffer;

        /*
         *  Perse the data
         */
        while( pwszBuf != NULL && *pwszBuf != L'\0' )
        {
            WORD ch1,ch2;

            // Get Start Range value

            pwszBuf = SkipWhite( pwszBuf );
            ch1 = ConvertStringToHex( pwszBuf, &pwszBuf );

            pwszBuf = SkipWhite( pwszBuf );
            if (*pwszBuf != L'-')
            {
                DBGPRINT(("CONSRV:GetSystemEUDCRangeW() Invalid format\n"));
                return( 0 );
            }

            // Get End Range value

            pwszBuf = SkipWhite( pwszBuf+1 );
            ch2 = ConvertStringToHex( pwszBuf, &pwszBuf );

            // Confirm the data sort order is correct

            if( ch1 > ch2 )
            {
                DBGPRINT(("CONSRV:GetSystemEUDCRangeW() Sort order is incorrect\n"));
                return( 0 );
            }

            // Move pointer to next

            pwszBuf = SkipWhite( pwszBuf );
            if( *pwszBuf == L',' )
                pwszBuf = SkipWhite( pwszBuf+1 );

            // Above , if pwszBuf is NULL , We reach the EOD

            iEntry ++;

            // If caller buffer is enough to store the data , store it.
            // If even not so, We have to continue perse data to compute the number of entry.

            // 3 - Because we have to store NULL as a mark of EOD

            if( cjSize >= 3 )
            {
                *pwEUDCCharTable++ = ch1;
                *pwEUDCCharTable++ = ch2;
                cjSize -= 2;
            }
        }

        *pwEUDCCharTable = L'\0';


        iEntry = iEntry * 2 + 1;

    }

    /*
     * Close registry handle
     */
    NtClose( hkRegistry );

    return (iEntry);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\server\getset.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    getset.c

Abstract:

        This file implements the NT console server console state API

Author:

    Therese Stowell (thereses) 5-Dec-1990

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef i386
VOID
ReverseMousePointer(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT Region
    );
#endif

ULONG
SrvGetConsoleMode(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_MODE_MSG a = (PCONSOLE_MODE_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->Handle,
                                 CONSOLE_ANY_HANDLE,
                                 GENERIC_READ,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {

        //
        // check handle type and access
        //

        if (HandleData->HandleType & CONSOLE_INPUT_HANDLE) {
            a->Mode = HandleData->Buffer.InputBuffer->InputMode;
            if (Console->Flags & CONSOLE_USE_PRIVATE_FLAGS) {
                a->Mode |= ENABLE_PRIVATE_FLAGS;
                if (Console->InsertMode) {
                    a->Mode |= ENABLE_INSERT_MODE;
                }
                if (Console->Flags & CONSOLE_QUICK_EDIT_MODE) {
                    a->Mode |= ENABLE_QUICK_EDIT_MODE;
                }
            }
        } else {
            a->Mode = HandleData->Buffer.ScreenBuffer->OutputMode;
        }
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvGetConsoleNumberOfFonts(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_GETNUMBEROFFONTS_MSG a = (PCONSOLE_GETNUMBEROFFONTS_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    if (Console->FullScreenFlags & CONSOLE_FULLSCREEN) {
        Status = STATUS_FULLSCREEN_MODE;
    } else {
        Status = GetNumFonts(&a->NumberOfFonts);
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvGetConsoleNumberOfInputEvents(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_GETNUMBEROFINPUTEVENTS_MSG a = (PCONSOLE_GETNUMBEROFINPUTEVENTS_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->InputHandle,
                                 CONSOLE_INPUT_HANDLE,
                                 GENERIC_READ,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {
        Status = GetNumberOfReadyEvents(HandleData->Buffer.InputBuffer,
                                      &a->ReadyEvents
                                     );
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvGetConsoleScreenBufferInfo(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_GETSCREENBUFFERINFO_MSG a = (PCONSOLE_GETSCREENBUFFERINFO_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_READ,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {
        Status = GetScreenBufferInformation(HandleData->Buffer.ScreenBuffer,
                                          &a->Size,
                                          &a->CursorPosition,
                                          &a->ScrollPosition,
                                          &a->Attributes,
                                          &a->CurrentWindowSize,
                                          &a->MaximumWindowSize
                                         );
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvGetConsoleCursorInfo(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_GETCURSORINFO_MSG a = (PCONSOLE_GETCURSORINFO_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_READ,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {
        a->CursorSize = HandleData->Buffer.ScreenBuffer->BufferInfo.TextInfo.CursorSize;
        a->Visible = (BOOLEAN) HandleData->Buffer.ScreenBuffer->BufferInfo.TextInfo.CursorVisible;
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvGetConsoleSelectionInfo(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_GETSELECTIONINFO_MSG a = (PCONSOLE_GETSELECTIONINFO_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (NT_SUCCESS(Status)) {
        if (Console->Flags & CONSOLE_SELECTING) {
            a->SelectionInfo.dwFlags = (CONSOLE_SELECTION_IN_PROGRESS |
                (Console->SelectionFlags & CONSOLE_SELECTION_VALID));
            a->SelectionInfo.dwSelectionAnchor = Console->SelectionAnchor;
            a->SelectionInfo.srSelection = Console->SelectionRect;
        } else {
            RtlZeroMemory(&a->SelectionInfo, sizeof(a->SelectionInfo));
        }

        UnlockConsole(Console);
    }
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvGetConsoleMouseInfo(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_GETMOUSEINFO_MSG a = (PCONSOLE_GETMOUSEINFO_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = GetMouseButtons(&a->NumButtons);
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvGetConsoleFontInfo(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_GETFONTINFO_MSG a = (PCONSOLE_GETFONTINFO_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (!CsrValidateMessageBuffer(m, &a->BufPtr, a->NumFonts, sizeof(*a->BufPtr))) {
        UnlockConsole(Console);
        return STATUS_INVALID_PARAMETER;
    }

    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_READ,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {
        if (HandleData->Buffer.ScreenBuffer->Console->FullScreenFlags & CONSOLE_FULLSCREEN) {
            Status = STATUS_FULLSCREEN_MODE;
        } else {
            Status = GetAvailableFonts(HandleData->Buffer.ScreenBuffer,
                                     a->MaximumWindow,
                                     a->BufPtr,
                                     &a->NumFonts
                                    );
        }
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvGetConsoleFontSize(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_GETFONTSIZE_MSG a = (PCONSOLE_GETFONTSIZE_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_READ,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {
        if (HandleData->Buffer.ScreenBuffer->Console->FullScreenFlags & CONSOLE_FULLSCREEN) {
            Status = STATUS_FULLSCREEN_MODE;
        } else {
            Status = GetFontSize(a->FontIndex,
                               &a->FontSize
                              );
        }
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvGetConsoleCurrentFont(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_GETCURRENTFONT_MSG a = (PCONSOLE_GETCURRENTFONT_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_READ,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {
        if (HandleData->Buffer.ScreenBuffer->Console->FullScreenFlags & CONSOLE_FULLSCREEN) {
            Status = STATUS_FULLSCREEN_MODE;
        } else {
            Status = GetCurrentFont(HandleData->Buffer.ScreenBuffer,
                                  a->MaximumWindow,
                                  &a->FontIndex,
                                  &a->FontSize
                                 );
        }
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvSetConsoleMode(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_MODE_MSG a = (PCONSOLE_MODE_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    try {
        Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                     a->Handle,
                                     CONSOLE_ANY_HANDLE,
                                     GENERIC_WRITE,
                                     &HandleData
                                    );
        if (!NT_SUCCESS(Status)) {
            leave;
        }

        if (HandleData->HandleType & CONSOLE_INPUT_HANDLE) {
            if (a->Mode & ~(INPUT_MODES | PRIVATE_MODES)) {
                Status = STATUS_INVALID_PARAMETER;
                leave;
            }
            if ((a->Mode & (ENABLE_LINE_INPUT | ENABLE_ECHO_INPUT)) == ENABLE_ECHO_INPUT) {
                Status = STATUS_INVALID_PARAMETER;
                leave;
            }
            if (a->Mode & PRIVATE_MODES) {
                Console->Flags |= CONSOLE_USE_PRIVATE_FLAGS;
                if (a->Mode & ENABLE_QUICK_EDIT_MODE) {
                    Console->Flags |= CONSOLE_QUICK_EDIT_MODE;
                } else {
                    Console->Flags &= ~CONSOLE_QUICK_EDIT_MODE;
                }
                if (a->Mode & ENABLE_INSERT_MODE) {
                    Console->InsertMode = TRUE;
                } else {
                    Console->InsertMode = FALSE;
                }
            } else {
                Console->Flags &= ~CONSOLE_USE_PRIVATE_FLAGS;
            }

#ifdef i386
            if (Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE &&
                Console->CurrentScreenBuffer->Flags & CONSOLE_TEXTMODE_BUFFER &&
                (a->Mode & ENABLE_MOUSE_INPUT) != (HandleData->Buffer.InputBuffer->InputMode & ENABLE_MOUSE_INPUT)) {
                if (a->Mode & ENABLE_MOUSE_INPUT) {
                    HandleData->Buffer.InputBuffer->InputMode |= ENABLE_MOUSE_INPUT;
                }
#if defined(FE_SB)
                // Korean HBIOS doesn't like to reverse mouse pointer.
                // Because HBIOS will initialize full screen mode again.
                // 949 = Korea WanSung Code Page.
                if (Console->OutputCP != 949) {
                    ReverseMousePointer(Console->CurrentScreenBuffer,
                                        &Console->CurrentScreenBuffer->Window);
                }
#else
                ReverseMousePointer(Console->CurrentScreenBuffer,
                                    &Console->CurrentScreenBuffer->Window);
#endif
            }
#endif
            HandleData->Buffer.InputBuffer->InputMode = a->Mode & ~PRIVATE_MODES;
        }
        else {
            if (a->Mode & ~OUTPUT_MODES) {
                Status = STATUS_INVALID_PARAMETER;
                leave;
            }
            HandleData->Buffer.ScreenBuffer->OutputMode = a->Mode;
        }
    } finally {
        UnlockConsole(Console);
    }
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvGenerateConsoleCtrlEvent(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_CTRLEVENT_MSG a = (PCONSOLE_CTRLEVENT_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    try {
        //
        // Make sure the process group id is valid
        //
        if (a->ProcessGroupId) {
            PCONSOLE_PROCESS_HANDLE ProcessHandleRecord;
            PLIST_ENTRY ListHead, ListNext;

            Status = STATUS_INVALID_PARAMETER;
            ListHead = &Console->ProcessHandleList;
            ListNext = ListHead->Flink;
            while (ListNext != ListHead) {
                ProcessHandleRecord = CONTAINING_RECORD( ListNext, CONSOLE_PROCESS_HANDLE, ListLink );
                ListNext = ListNext->Flink;
                if (ProcessHandleRecord->Process->ProcessGroupId == a->ProcessGroupId) {
                    Status = STATUS_SUCCESS;
                    break;
                }
            }
        }
        if (NT_SUCCESS(Status)) {
            Console->LimitingProcessId = a->ProcessGroupId;
            HandleCtrlEvent(Console, a->CtrlEvent);
        }

    } finally {
        UnlockConsole(Console);
    }
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvSetConsoleActiveScreenBuffer(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_SETACTIVESCREENBUFFER_MSG a = (PCONSOLE_SETACTIVESCREENBUFFER_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_GRAPHICS_OUTPUT_HANDLE | CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {
        Status = SetActiveScreenBuffer(HandleData->Buffer.ScreenBuffer);
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}


ULONG
SrvFlushConsoleInputBuffer(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_FLUSHINPUTBUFFER_MSG a = (PCONSOLE_FLUSHINPUTBUFFER_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->InputHandle,
                                 CONSOLE_INPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {
        Status = FlushInputBuffer(HandleData->Buffer.InputBuffer);
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvGetLargestConsoleWindowSize(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_GETLARGESTWINDOWSIZE_MSG a = (PCONSOLE_GETLARGESTWINDOWSIZE_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    PSCREEN_INFORMATION ScreenInfo;
    WINDOW_LIMITS WindowLimits;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {
        COORD FontSize;

        ScreenInfo = HandleData->Buffer.ScreenBuffer;
        if (ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) {
            a->Size.X = 80;
#if defined(FE_SB)
            a->Size.Y = CONSOLE_IS_DBCS_OUTPUTCP(Console)?25:50;
#else
            a->Size.Y = 50;
#endif
        } else {
            if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
                FontSize = SCR_FONTSIZE(ScreenInfo);
            } else {
                FontSize.X = 1;
                FontSize.Y = 1;
            }
            GetWindowLimits(ScreenInfo, &WindowLimits);
            a->Size.X = (SHORT)(WindowLimits.FullScreenSize.X / FontSize.X);
            a->Size.Y = (SHORT)(WindowLimits.FullScreenSize.Y / FontSize.Y);
        }
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvSetConsoleScreenBufferSize(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_SETSCREENBUFFERSIZE_MSG a = (PCONSOLE_SETSCREENBUFFERSIZE_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    PSCREEN_INFORMATION ScreenInfo;
    WINDOW_LIMITS WindowLimits;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {

        ScreenInfo = HandleData->Buffer.ScreenBuffer;

        //
        // make sure requested screen buffer size isn't smaller than the window
        //

        GetWindowLimits(ScreenInfo, &WindowLimits);
        if (a->Size.X < CONSOLE_WINDOW_SIZE_X(ScreenInfo) ||
            a->Size.Y < CONSOLE_WINDOW_SIZE_Y(ScreenInfo) ||
            a->Size.Y < WindowLimits.MinimumWindowSize.Y ||
            a->Size.X < WindowLimits.MinimumWindowSize.X) {
            Status = STATUS_INVALID_PARAMETER;
        }
        else if (a->Size.X == ScreenInfo->ScreenBufferSize.X &&
                 a->Size.Y == ScreenInfo->ScreenBufferSize.Y) {
            Status = STATUS_SUCCESS;
        } else {
            Status = ResizeScreenBuffer(ScreenInfo,
                                  a->Size,
                                  TRUE);
        }
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvSetConsoleCursorPosition(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_SETCURSORPOSITION_MSG a = (PCONSOLE_SETCURSORPOSITION_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    COORD WindowOrigin;
    PSCREEN_INFORMATION ScreenInfo;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {

        ScreenInfo = HandleData->Buffer.ScreenBuffer;

        if (a->CursorPosition.X >= ScreenInfo->ScreenBufferSize.X ||
            a->CursorPosition.Y >= ScreenInfo->ScreenBufferSize.Y ||
            a->CursorPosition.X < 0 ||
            a->CursorPosition.Y < 0) {
            Status = STATUS_INVALID_PARAMETER;
        } else {
            Status = SetCursorPosition(ScreenInfo,
                                       a->CursorPosition,
                                       TRUE
                                      );
        }
        if (NT_SUCCESS(Status)) {
#if defined(FE_IME)
            if (ScreenInfo->Console->Flags & CONSOLE_JUST_VDM_UNREGISTERED){
                if( ScreenInfo->Console->InputBuffer.ImeMode.Open ){
                    SHORT ScrollY = 0;
                    AdjustCursorPosition(ScreenInfo,a->CursorPosition,TRUE,&ScrollY);
                    a->CursorPosition.Y += ScrollY;
                }
                Console->Flags &= ~CONSOLE_JUST_VDM_UNREGISTERED;
            }
#endif
            WindowOrigin.X = 0;
            WindowOrigin.Y = 0;
            if (ScreenInfo->Window.Left > a->CursorPosition.X) {
                WindowOrigin.X = a->CursorPosition.X - ScreenInfo->Window.Left;
            }
            else if (ScreenInfo->Window.Right < a->CursorPosition.X) {
                WindowOrigin.X = a->CursorPosition.X - ScreenInfo->Window.Right;
            }
            if (ScreenInfo->Window.Top > a->CursorPosition.Y) {
                WindowOrigin.Y = a->CursorPosition.Y - ScreenInfo->Window.Top;
            }
            else if (ScreenInfo->Window.Bottom < a->CursorPosition.Y) {
                WindowOrigin.Y = a->CursorPosition.Y - ScreenInfo->Window.Bottom;
            }
            Status = SetWindowOrigin(ScreenInfo,
                                     FALSE,
                                     WindowOrigin
                                    );
        }
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvSetConsoleCursorInfo(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_SETCURSORINFO_MSG a = (PCONSOLE_SETCURSORINFO_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {
        if (a->CursorSize > 100 || a->CursorSize == 0) {
            Status = STATUS_INVALID_PARAMETER;
        } else {
            Status = SetCursorInformation(HandleData->Buffer.ScreenBuffer,a->CursorSize,a->Visible);
        }
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvSetConsoleWindowInfo(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_SETWINDOWINFO_MSG a = (PCONSOLE_SETWINDOWINFO_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    PSCREEN_INFORMATION ScreenInfo;
    COORD NewWindowSize;
    WINDOW_LIMITS WindowLimits;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {
        ScreenInfo = HandleData->Buffer.ScreenBuffer;
        if (!a->Absolute) {
            a->Window.Left += ScreenInfo->Window.Left;
            a->Window.Right += ScreenInfo->Window.Right;
            a->Window.Top += ScreenInfo->Window.Top;
            a->Window.Bottom += ScreenInfo->Window.Bottom;
        }
        if (a->Window.Right < a->Window.Left ||
            a->Window.Bottom < a->Window.Top) {
            Status = STATUS_INVALID_PARAMETER;
        } else {
            NewWindowSize.X = (SHORT)(WINDOW_SIZE_X(&a->Window));
            NewWindowSize.Y = (SHORT)(WINDOW_SIZE_Y(&a->Window));
            GetWindowLimits(ScreenInfo, &WindowLimits);
            if ((NewWindowSize.X > WindowLimits.MaximumWindowSize.X ||
                 NewWindowSize.Y > WindowLimits.MaximumWindowSize.Y) &&
                 !(ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN)) {
                Status = STATUS_INVALID_PARAMETER;
            } else {
#ifdef i386
                if (ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN) {
                    COORD NewOrigin;

                    if (NewWindowSize.X != (SHORT)(WINDOW_SIZE_X(&ScreenInfo->Window)) ||
                        NewWindowSize.Y != (SHORT)(WINDOW_SIZE_Y(&ScreenInfo->Window))) {
                        COORD WindowSize;
                        ULONG ModeIndex;

#if defined(FE_SB)
                        ModeIndex = MatchWindowSize(ScreenInfo->Console->OutputCP,NewWindowSize,&WindowSize);
#else
                        ModeIndex = MatchWindowSize(NewWindowSize,&WindowSize);
#endif
                        if (NewWindowSize.X != WindowSize.X ||
                            NewWindowSize.Y != WindowSize.Y ||
                            WindowSize.X > ScreenInfo->ScreenBufferSize.X ||
                            WindowSize.Y > ScreenInfo->ScreenBufferSize.Y) {
                            UnlockConsole(Console);
                            return (ULONG) STATUS_FULLSCREEN_MODE;
                        }
                        ScreenInfo->BufferInfo.TextInfo.ModeIndex = ModeIndex;
                        ResizeWindow(ScreenInfo,
                                     &a->Window,
                                     FALSE
                                    );
                        ScreenInfo->BufferInfo.TextInfo.WindowedWindowSize.X =
                                CONSOLE_WINDOW_SIZE_X(ScreenInfo);
                        ScreenInfo->BufferInfo.TextInfo.WindowedWindowSize.Y =
                                CONSOLE_WINDOW_SIZE_Y(ScreenInfo);
                        if (ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE &&
                            (!(ScreenInfo->Console->Flags & CONSOLE_VDM_REGISTERED)) ) {
                            SetVideoMode(ScreenInfo);
                            WriteToScreen(ScreenInfo,&ScreenInfo->Window);
                        }
                    } else {
                        NewOrigin.X = a->Window.Left;
                        NewOrigin.Y = a->Window.Top;
                        SetWindowOrigin(ScreenInfo,
                                        TRUE,
                                        NewOrigin
                                       );
                    }
                } else
#endif
                {
                    Status = ResizeWindow(ScreenInfo,
                                          &a->Window,
                                          TRUE
                                         );
                    if (ACTIVE_SCREEN_BUFFER(ScreenInfo)) {
                        SetWindowSize(ScreenInfo);
                        WriteToScreen(ScreenInfo,&ScreenInfo->Window);
                    }
                }
            }
        }
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvScrollConsoleScreenBuffer(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_SCROLLSCREENBUFFER_MSG a = (PCONSOLE_SCROLLSCREENBUFFER_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    PSMALL_RECT ClipRect;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {

        if (a->Clip) {
            ClipRect = &a->ClipRectangle;
        }
        else {
            ClipRect = NULL;
        }
        if (!a->Unicode) {
#if defined(FE_SB)
            a->Fill.Char.UnicodeChar = CharToWchar(Console,
                                                   Console->OutputCP,
                                                   &a->Fill.Char.AsciiChar);
#else
            a->Fill.Char.UnicodeChar = CharToWchar(
                    Console->OutputCP, a->Fill.Char.AsciiChar);
#endif
        } else if ((Console->CurrentScreenBuffer->Flags & CONSOLE_OEMFONT_DISPLAY) &&
                !(Console->FullScreenFlags & CONSOLE_FULLSCREEN)) {
            RealUnicodeToFalseUnicode(&a->Fill.Char.UnicodeChar,
                                    1,
                                    Console->OutputCP
                                    );
        }
        Status = ScrollRegion(HandleData->Buffer.ScreenBuffer,
                            &a->ScrollRectangle,
                            ClipRect,
                            a->DestinationOrigin,
                            a->Fill
                           );
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

VOID
UpdatePopups(
    IN PCONSOLE_INFORMATION Console,
    IN WORD NewAttributes,
    IN WORD NewPopupAttributes,
    IN WORD OldAttributes,
    IN WORD OldPopupAttributes
    )

/*

    this routine is called when the user changes the screen/popup
    colors.  it goes through the popup structures and changes
    the saved contents to reflect the new screen/popup colors.

*/

{
    PLIST_ENTRY HistoryListHead, HistoryListNext;
    PLIST_ENTRY PopupListHead, PopupListNext;
    PCOMMAND_HISTORY History;
    PCLE_POPUP Popup;
    SHORT i,j;
    PCHAR_INFO OldContents;
    WORD InvertedOldPopupAttributes,InvertedNewPopupAttributes;

    InvertedOldPopupAttributes = (WORD)(((OldPopupAttributes << 4) & 0xf0) |
                                ((OldPopupAttributes >> 4) & 0x0f));
    InvertedNewPopupAttributes = (WORD)(((NewPopupAttributes << 4) & 0xf0) |
                                ((NewPopupAttributes >> 4) & 0x0f));
    HistoryListHead = &Console->CommandHistoryList;
    HistoryListNext = HistoryListHead->Blink;
    while (HistoryListNext != HistoryListHead) {
        History = CONTAINING_RECORD( HistoryListNext, COMMAND_HISTORY, ListLink );
        HistoryListNext = HistoryListNext->Blink;
        if (History->Flags & CLE_ALLOCATED && !CLE_NO_POPUPS(History)) {
            PopupListHead = &History->PopupList;
            PopupListNext = PopupListHead->Blink;
            while (PopupListNext != PopupListHead) {
                Popup = CONTAINING_RECORD( PopupListNext, CLE_POPUP, ListLink );
                PopupListNext = PopupListNext->Blink;
                OldContents = Popup->OldContents;
                for (i=Popup->Region.Left;i<=Popup->Region.Right;i++) {
                    for (j=Popup->Region.Top;j<=Popup->Region.Bottom;j++) {
                        if (OldContents->Attributes == OldAttributes) {
                            OldContents->Attributes = NewAttributes;
                        } else if (OldContents->Attributes == OldPopupAttributes) {
                            OldContents->Attributes = NewPopupAttributes;
                        } else if (OldContents->Attributes == InvertedOldPopupAttributes) {
                            OldContents->Attributes = InvertedNewPopupAttributes;
                        }
                        OldContents++;
                    }
                }
            }
        }
    }
}


NTSTATUS
SetScreenColors(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN WORD Attributes,
    IN WORD PopupAttributes,
    IN BOOL UpdateWholeScreen
    )
{
    SHORT i,j;
    PROW Row;
    WORD DefaultAttributes,DefaultPopupAttributes;
    PCONSOLE_INFORMATION Console;
    COLORREF rgbBk;
    COLORREF rgbText;

    Console = ScreenInfo->Console;
    rgbBk = ConvertAttrToRGB(Console, LOBYTE(Attributes >> 4));
    rgbBk = GetNearestColor(Console->hDC, rgbBk);
    rgbText = ConvertAttrToRGB(Console, LOBYTE(Attributes));
    rgbText = GetNearestColor(Console->hDC, rgbText);
    if (ACTIVE_SCREEN_BUFFER(ScreenInfo)) {
        SetDCBrushColor(Console->hDC, rgbBk);
        SetTextColor(Console->hDC, rgbText);
        SetBkColor(Console->hDC, rgbBk);
        Console->LastAttributes = Attributes;
        SetConsoleBkColor(Console->hWnd, rgbBk);
    }

    DefaultAttributes = ScreenInfo->Attributes;
    DefaultPopupAttributes = ScreenInfo->PopupAttributes;
    ScreenInfo->Attributes = Attributes;
    ScreenInfo->PopupAttributes = PopupAttributes;
#if defined(FE_IME)
    SetUndetermineAttribute( Console );
#endif

    if (UpdateWholeScreen && ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
        WORD InvertedOldPopupAttributes,InvertedNewPopupAttributes;

        InvertedOldPopupAttributes = (WORD)(((DefaultPopupAttributes << 4) & 0xf0) |
                                    ((DefaultPopupAttributes >> 4) & 0x0f));
        InvertedNewPopupAttributes = (WORD)(((PopupAttributes << 4) & 0xf0) |
                                    ((PopupAttributes >> 4) & 0x0f));
        //
        // change all chars with default color
        //

        for (i=0;i<ScreenInfo->ScreenBufferSize.Y;i++) {
            Row = &ScreenInfo->BufferInfo.TextInfo.Rows[i];
            for (j=0;j<Row->AttrRow.Length;j++) {
                if (Row->AttrRow.Attrs[j].Attr == DefaultAttributes) {
                    Row->AttrRow.Attrs[j].Attr = Attributes;
                } else if (Row->AttrRow.Attrs[j].Attr == DefaultPopupAttributes) {
                    Row->AttrRow.Attrs[j].Attr = PopupAttributes;
                } else if (Row->AttrRow.Attrs[j].Attr == InvertedOldPopupAttributes) {
                    Row->AttrRow.Attrs[j].Attr = InvertedNewPopupAttributes;
                }
            }
        }

        if (Console->PopupCount)
            UpdatePopups(Console,
                         Attributes,
                         PopupAttributes,
                         DefaultAttributes,
                         DefaultPopupAttributes
                         );
        // force repaint of entire line
        ScreenInfo->BufferInfo.TextInfo.Flags &= ~TEXT_VALID_HINT;
        WriteToScreen(ScreenInfo,&ScreenInfo->Window);
        ScreenInfo->BufferInfo.TextInfo.Flags |= TEXT_VALID_HINT;
    }

    return STATUS_SUCCESS;
}

ULONG
SrvSetConsoleTextAttribute(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_SETTEXTATTRIBUTE_MSG a = (PCONSOLE_SETTEXTATTRIBUTE_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {

        if (a->Attributes & ~VALID_TEXT_ATTRIBUTES) {
            Status = STATUS_INVALID_PARAMETER;
        } else {
            Status = SetScreenColors(HandleData->Buffer.ScreenBuffer,
                                     a->Attributes,
                                     HandleData->Buffer.ScreenBuffer->PopupAttributes,
                                     FALSE
                                    );
        }
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvSetConsoleFont(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_SETFONT_MSG a = (PCONSOLE_SETFONT_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    PSCREEN_INFORMATION ScreenInfo;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    try {
        Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                     a->OutputHandle,
                                     CONSOLE_OUTPUT_HANDLE,
                                     GENERIC_WRITE,
                                     &HandleData
                                    );
        if (!NT_SUCCESS(Status)) {
            leave;
        }

        ScreenInfo = HandleData->Buffer.ScreenBuffer;
        if (ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN) {
            Status = STATUS_FULLSCREEN_MODE;
        } else {
#if defined(FE_SB)
            Status = SetScreenBufferFont(ScreenInfo,a->FontIndex,ScreenInfo->Console->OutputCP);
#else
            Status = SetScreenBufferFont(ScreenInfo,a->FontIndex);
#endif
        }
    } finally {
        UnlockConsole(Console);
    }
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvSetConsoleIcon(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_SETICON_MSG a = (PCONSOLE_SETICON_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    HANDLE hIcon;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (a->hIcon == NULL) {
        hIcon = ghDefaultIcon;
    } else {
        hIcon = CopyIcon(a->hIcon);
    }

    if (hIcon == NULL) {
        Status = STATUS_INVALID_PARAMETER;
    } else if (hIcon != Console->hIcon) {
        PostMessage(Console->hWnd, WM_SETICON, ICON_BIG, (LPARAM)hIcon);
        if (Console->hIcon != ghDefaultIcon) {
            DestroyIcon(Console->hIcon);
        }
        Console->hIcon = hIcon;

        /*
         * Small icon now
         */
        if (hIcon != ghDefaultIcon) {
            /*
             * The new one is not the default, clean-up
             */
            if (Console->hSmIcon != NULL && Console->hSmIcon != ghDefaultSmIcon) {
                DestroyIcon(Console->hSmIcon);
            }
            Console->hSmIcon = NULL;
            PostMessage(Console->hWnd, WM_SETICON, ICON_SMALL, (LPARAM)NULL);
        } else {
            /*
             * Change to default, so we can use the default small icon
             */
            if (Console->hSmIcon != ghDefaultSmIcon) {
                if (Console->hSmIcon != NULL) {
                    DestroyIcon(Console->hSmIcon);
                }
                Console->hSmIcon = ghDefaultSmIcon;
                PostMessage(Console->hWnd, WM_SETICON, ICON_SMALL, (LPARAM)ghDefaultSmIcon);
            }
        }
    }
    UnlockConsole(Console);

    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}


ULONG
SrvSetConsoleCP(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_SETCP_MSG a = (PCONSOLE_SETCP_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    HANDLE hEvent = NULL;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    if (a->hEvent) {
        Status = NtDuplicateObject(CONSOLE_CLIENTPROCESSHANDLE(),
                       a->hEvent,
                       NtCurrentProcess(),
                       &hEvent,
                       0,
                       FALSE,
                       DUPLICATE_SAME_ACCESS
                       );
        if (!NT_SUCCESS(Status)) {
            goto SrvSetConsoleCPFailure;
        }
    }

    if (!IsValidCodePage(a->wCodePageID)) {
        Status = STATUS_INVALID_PARAMETER;
        goto SrvSetConsoleCPFailure;
    }
    if ( IsAvailableFarEastCodePage( a->wCodePageID ) &&
         OEMCP != a->wCodePageID )
    {
        Status = STATUS_INVALID_PARAMETER;
        goto SrvSetConsoleCPFailure;
    }

    if ( (a->Output && Console->OutputCP != a->wCodePageID) ||
         (!a->Output && Console->CP != a->wCodePageID)         ) {

        UINT CodePage;

        if (a->Output) {

            // Backup old code page
            CodePage = Console->OutputCP;

            // Set new code page
            Console->OutputCP = a->wCodePageID;

            Console->fIsDBCSOutputCP = CONSOLE_IS_DBCS_ENABLED() && IsAvailableFarEastCodePage(Console->OutputCP);

            if (!ReCreateDbcsScreenBuffer(Console, CodePage) ) {
                RIPMSG1(RIP_WARNING, "SrvSetConsoleCP: ReCreateDbcsScreenBuffer failed. Restoring to CP=%d",
                        CodePage);
                Console->OutputCP = CodePage;
                Console->fIsDBCSOutputCP = CONSOLE_IS_DBCS_ENABLED() && IsAvailableFarEastCodePage(CodePage);
                Status = STATUS_NO_MEMORY;
                goto SrvSetConsoleCPFailure;
            }
            SetConsoleCPInfo(Console,a->Output);
            Status = QueueConsoleMessage(Console,
                        CM_SET_IME_CODEPAGE,
                        (WPARAM)hEvent,
                        MAKELPARAM(a->Output,CodePage)
                       );
            if (!NT_SUCCESS(Status)) {
                goto SrvSetConsoleCPFailure;
            }

            // load special ROM font, if necessary

#ifdef i386

            if (Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) {
                SetROMFontCodePage(Console->OutputCP,
                                   Console->CurrentScreenBuffer->BufferInfo.TextInfo.ModeIndex);
                WriteRegionToScreenHW(Console->CurrentScreenBuffer,
                        &Console->CurrentScreenBuffer->Window);
            }
#endif


        } else {

            // Backup old code page
            CodePage = Console->CP;

            // Set new code page
            Console->CP = a->wCodePageID;

            Console->fIsDBCSCP = CONSOLE_IS_DBCS_ENABLED() && IsAvailableFarEastCodePage(Console->CP);

            SetConsoleCPInfo(Console,a->Output);
            Status = QueueConsoleMessage(Console,
                        CM_SET_IME_CODEPAGE,
                        (WPARAM)hEvent,
                        MAKELPARAM(a->Output,CodePage)
                       );
            if (!NT_SUCCESS(Status)) {
                goto SrvSetConsoleCPFailure;
            }
        }
    }
    else {
        if (hEvent) {
            NtSetEvent(hEvent, NULL);
            NtClose(hEvent);
        }
    }

    UnlockConsole(Console);
    return STATUS_SUCCESS;

SrvSetConsoleCPFailure:
    if (hEvent) {
        NtSetEvent(hEvent, NULL);
        NtClose(hEvent);
    }
    UnlockConsole(Console);
    return Status;

    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvGetConsoleCP(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_GETCP_MSG a = (PCONSOLE_GETCP_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    if (a->Output) {
        a->wCodePageID = Console->OutputCP;
    } else {
        a->wCodePageID = Console->CP;
    }
    UnlockConsole(Console);
    return STATUS_SUCCESS;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvGetConsoleKeyboardLayoutName(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_GETKEYBOARDLAYOUTNAME_MSG a = (PCONSOLE_GETKEYBOARDLAYOUTNAME_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    if (Console->hklActive == NULL) {
        //
        // hklActive is not set yet. Let's initialize it here.
        //
        extern void GetNonBiDiKeyboardLayout(HKL * phklActive);

        RIPMSG1(RIP_WARNING, "SrvGetConsoleKeyboardLayoutName: hklActive is not initialized. pCon=%p", Console);

        SystemParametersInfo(SPI_GETDEFAULTINPUTLANG, 0, &Console->hklActive, FALSE);
        GetNonBiDiKeyboardLayout(&Console->hklActive);
    }
    ActivateKeyboardLayout(Console->hklActive, 0);
    if (a->bAnsi) {
        GetKeyboardLayoutNameA(a->achLayout);
    } else {
        GetKeyboardLayoutNameW(a->awchLayout);
    }
    UnlockConsole(Console);
    return STATUS_SUCCESS;
    UNREFERENCED_PARAMETER(ReplyStatus);
}


ULONG
SrvGetConsoleWindow(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_GETCONSOLEWINDOW_MSG a = (PCONSOLE_GETCONSOLEWINDOW_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    a->hwnd = Console->hWnd;

    UnlockConsole(Console);
    return STATUS_SUCCESS;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvGetConsoleProcessList(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_INFORMATION Console = NULL;
    NTSTATUS Status;
    PCONSOLE_PROCESS_HANDLE ProcessHandleRecord;
    PLIST_ENTRY ListHead, ListNext;
    PCONSOLE_GETCONSOLEPROCESSLIST_MSG a = (PCONSOLE_GETCONSOLEPROCESSLIST_MSG)&m->u.ApiMessageData;
    DWORD dwProcessCount = 0;
    LPDWORD lpdwProcessList;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    if (!CsrValidateMessageBuffer(m, &a->lpdwProcessList, a->dwProcessCount, sizeof(*a->lpdwProcessList))) {
        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }
    lpdwProcessList = a->lpdwProcessList;

    /*
     * Run through the console's process list to determine if the user-supplied
     * buffer is big enough to contain them all. This is requires that we make
     * two passes over the data, but it allows this function to have the same
     * semantics as GetProcessHeaps().
     */
    ListHead = &Console->ProcessHandleList;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        ++dwProcessCount;
        ListNext = ListNext->Flink;
    }

    /*
     * At this point we can't fail, so set the status accordingly.
     */
    Status = STATUS_SUCCESS;

    /*
     * There's not enough space in the array to hold all the pids, so we'll
     * inform the user of that by returning a number > than a->dwProcessCount
     * (but we still return STATUS_SUCCESS).
     */
    if (dwProcessCount > a->dwProcessCount) {
        goto Cleanup;
    }

    /*
     * Loop over the list of processes again and fill in the caller's buffer.
     */
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        ProcessHandleRecord = CONTAINING_RECORD( ListNext, CONSOLE_PROCESS_HANDLE, ListLink );
        *lpdwProcessList++ = HandleToUlong(ProcessHandleRecord->Process->ClientId.UniqueProcess);
        ListNext = ListNext->Flink;
    }

Cleanup:
    a->dwProcessCount = dwProcessCount;

    if (Console != NULL) {
        UnlockConsole(Console);
    }

    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\server\globals.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    globals.h

Abstract:

    This module contains the global variables used by the
    console server DLL.

Author:

    Jerry Shea (jerrysh) 21-Sep-1993

Revision History:

--*/

extern CONSOLE_REGISTRY_INFO DefaultRegInfo;
extern PFONT_INFO FontInfo;

extern UINT       OEMCP;
extern UINT       WINDOWSCP;
extern HANDLE     ghInstance;
extern HICON      ghDefaultIcon;
extern HICON      ghDefaultSmIcon;
extern HCURSOR    ghNormalCursor;
extern CRITICAL_SECTION ConsoleHandleLock;
extern int        DialogBoxCount;
extern LPTHREAD_START_ROUTINE CtrlRoutine;  // client side ctrl-thread routine

// IME
extern LPTHREAD_START_ROUTINE ConsoleIMERoutine;  // client side console IME routine


extern BOOL FullScreenInitialized;
extern CRITICAL_SECTION ConsoleVDMCriticalSection;
extern PCONSOLE_INFORMATION ConsoleVDMOnSwitching;

extern DWORD      InputThreadTlsIndex;

extern int        MinimumWidthX;
extern SHORT      VerticalScrollSize;
extern SHORT      HorizontalScrollSize;
extern SHORT      VerticalClientToWindow;
extern SHORT      HorizontalClientToWindow;
extern BOOL       fOneTimeInitialized;
extern UINT       ConsoleOutputCP;
extern UINT       ProgmanHandleMessage;

extern DWORD      gExtendedEditKey;
extern BOOL       gfTrimLeadingZeros;
extern BOOL       gfEnableColorSelection;

extern BOOL       gfLoadConIme;

// FE
extern ULONG NumberOfFonts;

extern CRITICAL_SECTION gInputThreadMsgLock;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\server\dispatch.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    dispatch.h

Abstract:

Author:

    KazuM Apr.19.1996

Revision History:

--*/


#undef WWSB
#if defined(WWSB_NOFE)
  #define WWSB(fn) SB_##fn
#elif defined(WWSB_FE)
  #define WWSB(fn) FE_##fn
#else
  #define WWSB(fn) fn
#endif

NTSTATUS
WWSB(DoSrvWriteConsole)(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus,
    IN PCONSOLE_INFORMATION Console,
    IN PHANDLE_DATA HandleData
    );


NTSTATUS
WWSB(WriteOutputString)(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PVOID Buffer,
    IN COORD WriteCoord,
    IN ULONG StringType,
    IN OUT PULONG NumRecords, // this value is valid even for error cases
    OUT PULONG NumColumns OPTIONAL
    );


VOID
WWSB(WriteRectToScreenBuffer)(
    PBYTE Source,
    COORD SourceSize,
    PSMALL_RECT SourceRect,
    PSCREEN_INFORMATION ScreenInfo,
    COORD TargetPoint,
    IN UINT Codepage
    );


VOID
WWSB(WriteToScreen)(
    IN PSCREEN_INFORMATION ScreenInfo,
    PSMALL_RECT Region    // region is inclusive
    );


VOID
WWSB(WriteRegionToScreen)(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT Region
    );


NTSTATUS
WWSB(FillOutput)(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN WORD Element,
    IN COORD WriteCoord,
    IN ULONG ElementType,
    IN OUT PULONG Length // this value is valid even for error cases
    );


VOID
WWSB(FillRectangle)(
    IN CHAR_INFO Fill,
    IN OUT PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT TargetRect
    );


ULONG
WWSB(DoWriteConsole)(
    IN OUT PCSR_API_MSG m,
    IN PCONSOLE_INFORMATION Console,
    IN PCSR_THREAD Thread
    );


NTSTATUS
WWSB(WriteChars)(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PWCHAR lpBufferBackupLimit,
    IN PWCHAR lpBuffer,
    IN PWCHAR lpRealUnicodeString,
    IN OUT PDWORD NumBytes,
    OUT PLONG NumSpaces OPTIONAL,
    IN SHORT OriginalXPosition,
    IN DWORD dwFlags,
    OUT PSHORT ScrollY OPTIONAL
    );


NTSTATUS
WWSB(AdjustCursorPosition)(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN COORD CursorPosition,
    IN BOOL KeepCursorVisible,
    OUT PSHORT ScrollY OPTIONAL
    );


NTSTATUS
TranslateOutputToAnsiUnicode(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size,
    IN OUT PCHAR_INFO OutputBufferR
    );
NTSTATUS
FE_TranslateOutputToAnsiUnicode(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size,
    IN OUT PCHAR_INFO OutputBufferR
    );
NTSTATUS
SB_TranslateOutputToAnsiUnicode(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size
    );


NTSTATUS
WWSB(TranslateOutputToUnicode)(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size);


NTSTATUS
TranslateOutputToOemUnicode(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size,
    IN BOOL fRemoveDbcsMark
    );
NTSTATUS
FE_TranslateOutputToOemUnicode(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size,
    IN BOOL fRemoveDbcsMark
    );
NTSTATUS
SB_TranslateOutputToOemUnicode(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size
    );


NTSTATUS
WWSB(TranslateOutputToOem)(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size
    );


ULONG
TranslateInputToUnicode(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PINPUT_RECORD InputRecords,
    IN ULONG NumRecords,
    IN OUT PINPUT_RECORD DBCSLeadByte
    );
ULONG
FE_TranslateInputToUnicode(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PINPUT_RECORD InputRecords,
    IN ULONG NumRecords,
    IN OUT PINPUT_RECORD DBCSLeadByte
    );
ULONG
SB_TranslateInputToUnicode(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PINPUT_RECORD InputRecords,
    IN ULONG NumRecords
    );


ULONG
TranslateInputToOem(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PINPUT_RECORD InputRecords,
    IN ULONG NumRecords,    // in : ASCII byte count
    IN ULONG UnicodeLength, // in : Number of events (char count)
    OUT PINPUT_RECORD DbcsLeadInpRec
    );
ULONG
FE_TranslateInputToOem(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PINPUT_RECORD InputRecords,
    IN ULONG NumRecords,    // in : ASCII byte count
    IN ULONG UnicodeLength, // in : Number of events (char count)
    OUT PINPUT_RECORD DbcsLeadInpRec
    );
ULONG
SB_TranslateInputToOem(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PINPUT_RECORD InputRecords,
    IN ULONG NumRecords
    );


#ifdef i386
VOID
WWSB(WriteRegionToScreenHW)(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT Region
    );
#endif


VOID
StreamWriteToScreenBuffer(
    IN PWCHAR String,
    IN SHORT StringLength,
    IN PSCREEN_INFORMATION ScreenInfo
    );
VOID
FE_StreamWriteToScreenBuffer(
    IN PWCHAR String,
    IN SHORT StringLength,
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PCHAR StringA
    );
VOID
SB_StreamWriteToScreenBuffer(
    IN PWCHAR String,
    IN SHORT StringLength,
    IN PSCREEN_INFORMATION ScreenInfo
    );

/*
 * SB/FE neutral defines for use from _stream.h and _output.h
 *
 * Each of these functions appears in dispatch.c, but we don't want SB_ or FE_
 * routines to call the dispatching subroutines, we want to call the SB_ or FE_
 * subroutines directly.  eg: There should be no calls to WriteChars from
 * anywhere in _stream.h : instead, we should call WWSB_WriteChars (etc.)
 */
#if defined(WWSB_NOFE)
  #define WWSB_WriteChars            SB_WriteChars
  #define WWSB_AdjustCursorPosition  SB_AdjustCursorPosition
  #define WWSB_DoWriteConsole        SB_DoWriteConsole
  #define WWSB_DoSrvWriteConsole     SB_DoSrvWriteConsole
  #define WWSB_WriteToScreen         SB_WriteToScreen
  #define WWSB_WriteOutputString     SB_WriteOutputString
  #define WWSB_FillOutput            SB_FillOutput
  #define WWSB_FillRectangle         SB_FillRectangle
  #define WWSB_PolyTextOutCandidate  SB_PolyTextOutCandidate
  #define WWSB_ConsolePolyTextOut    SB_ConsolePolyTextOut
  #define WWSB_WriteRegionToScreen   SB_WriteRegionToScreen
  #define WWSB_WriteRegionToScreenHW SB_WriteRegionToScreenHW
  #define WWSB_WriteRectToScreenBuffer SB_WriteRectToScreenBuffer
#endif

#if defined(WWSB_FE)
  #undef  WWSB_WriteChars
  #define WWSB_WriteChars            FE_WriteChars
  #undef  WWSB_AdjustCursorPosition
  #define WWSB_AdjustCursorPosition  FE_AdjustCursorPosition
  #undef  WWSB_DoWriteConsole
  #define WWSB_DoWriteConsole        FE_DoWriteConsole
  #undef  WWSB_DoSrvWriteConsole
  #define WWSB_DoSrvWriteConsole     FE_DoSrvWriteConsole
  #undef  WWSB_WriteToScreen
  #define WWSB_WriteToScreen         FE_WriteToScreen
  #undef  WWSB_WriteOutputString
  #define WWSB_WriteOutputString     FE_WriteOutputString
  #undef  WWSB_FillOutput
  #define WWSB_FillOutput            FE_FillOutput
  #undef  WWSB_FillRectangle
  #define WWSB_FillRectangle         FE_FillRectangle
  #undef  WWSB_PolyTextOutCandidate
  #define WWSB_PolyTextOutCandidate  FE_PolyTextOutCandidate
  #undef  WWSB_ConsolePolyTextOut
  #define WWSB_ConsolePolyTextOut    FE_ConsolePolyTextOut
  #undef  WWSB_WriteRegionToScreen
  #define WWSB_WriteRegionToScreen   FE_WriteRegionToScreen
  #undef  WWSB_WriteRegionToScreenHW
  #define WWSB_WriteRegionToScreenHW FE_WriteRegionToScreenHW
  #undef  WWSB_WriteRectToScreenBuffer
  #define WWSB_WriteRectToScreenBuffer FE_WriteRectToScreenBuffer
#endif

/*
 * define WWSB_NEUTRAL_FILE in _stream.h _output.h and _priv.h
 * This will guard against calling the dispatching versions when we can just
 * call the underlying FE_ or SB_ routine directly.
 */
#ifdef WWSB_NEUTRAL_FILE
  #define WriteChars                 Should_not_call_WriteChars
  #define AdjustCursorPosition       Should_not_call_AdjustCursorPosition
  #define DoWriteConsole             Should_not_call_DoWriteConsole
  #define DoSrvWriteConsole          Should_not_call_DoSrvWriteConsole
  #define WriteToScreen              Should_not_call_WriteToScreen
  #define WriteOutputString          Should_not_call_WriteOutputString
  #define FillOutput                 Should_not_call_FillOutput
  #define FillRectangle              Should_not_call_FillRectangle
  #define PolyTextOutCandidate       Should_not_call_PolyTextOutCandidate
  #define ConsolePolyTextOut         Should_not_call_ConsolePolyTextOut
  #define WriteRegionToScreen        Should_not_call_WriteRegionToScreen
  #define WriteRegionToScreenHW      Should_not_call_WriteRegionToScreenHW
  #define WriteRectToScreenBuffer    Should_not_call_WriteRectToScreenBuffer
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\server\find.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    find.c

Abstract:

        This file implements the search functionality.

Author:

    Jerry Shea (jerrysh) 1-May-1997

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


#define SEARCH_STRING_LENGTH    (80)

USHORT
SearchForString(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PWSTR SearchString,
    IN USHORT StringLength,
    IN BOOLEAN IgnoreCase,
    IN BOOLEAN Reverse,
    OUT PCOORD StringPosition
    )
{
    PCONSOLE_INFORMATION Console;
    COORD MaxPosition;
    COORD EndPosition;
    COORD Position;
    BOOL RecomputeRow;
    SHORT RowIndex;
    PROW Row;
    USHORT ColumnWidth;
    WCHAR SearchString2[SEARCH_STRING_LENGTH * 2 + 1];    // search string buffer
    PWSTR pStr;

    Console = ScreenInfo->Console;

    MaxPosition.X = ScreenInfo->ScreenBufferSize.X - StringLength;
    MaxPosition.Y = ScreenInfo->ScreenBufferSize.Y - 1;

    //
    // calculate starting position
    //

    if (Console->Flags & CONSOLE_SELECTING) {
        Position.X = min(Console->SelectionAnchor.X, MaxPosition.X);
        Position.Y = Console->SelectionAnchor.Y;
    } else if (Reverse) {
        Position.X = 0;
        Position.Y = 0;
    } else {
        Position.X = MaxPosition.X;
        Position.Y = MaxPosition.Y;
    }

    //
    // prepare search string
    //
    // Raid #113599 CMD:Find(Japanese strings) does not work correctly
    //

    ASSERT(StringLength == wcslen(SearchString) && StringLength < ARRAY_SIZE(SearchString2));

    pStr = SearchString2;
    while (*SearchString) {
        *pStr++ = *SearchString;
#if defined(CON_TB_MARK)
        //
        // On the screen, one FarEast "FullWidth" character occupies two columns (double width),
        // so we have to share two screen buffer elements for one DBCS character.
        // For example, if the screen shows "AB[DBC]CD", the screen buffer will be,
        //   [L'A'] [L'B'] [DBC(Unicode)] [CON_TB_MARK] [L'C'] [L'D']
        //   (DBC:: Double Byte Character)
        // CON_TB_MARK is used to indicate that the column is the trainling byte.
        //
        // Before comparing the string with the screen buffer, we need to modify the search
        // string to match the format of the screen buffer.
        // If we find a FullWidth character in the search string, put CON_TB_MARK
        // right after it so that we're able to use NLS functions.
        //
#else
        //
        // If KAttribute is used, the above example will look like:
        // CharRow.Chars: [L'A'] [L'B'] [DBC(Unicode)] [DBC(Unicode)] [L'C'] [L'D']
        // CharRow.KAttrs:    0      0   LEADING_BYTE  TRAILING_BYTE       0      0
        //
#endif
        if (IsConsoleFullWidth(Console->hDC, Console->CP, *SearchString)) {
#if defined(CON_TB_MARK)
            *pStr++ = CON_TB_MARK;
#else
            *pStr++ = *SearchString;
#endif
        }
        ++SearchString;
    }

    *pStr = L'\0';
    ColumnWidth = (USHORT)(pStr - SearchString2);
    SearchString = SearchString2;

    //
    // set the string length in byte
    //

    StringLength = ColumnWidth * sizeof(WCHAR);

    //
    // search for the string
    //

    RecomputeRow = TRUE;
    EndPosition = Position;
    do {
#if !defined(CON_TB_MARK)
#if DBG
        int nLoop = 0;
#endif
recalc:
#endif
        if (Reverse) {
            if (--Position.X < 0) {
                Position.X = MaxPosition.X;
                if (--Position.Y < 0) {
                    Position.Y = MaxPosition.Y;
                }
                RecomputeRow = TRUE;
            }
        } else {
            if (++Position.X > MaxPosition.X) {
                Position.X = 0;
                if (++Position.Y > MaxPosition.Y) {
                    Position.Y = 0;
                }
                RecomputeRow = TRUE;
            }
        }
        if (RecomputeRow) {
            RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow + Position.Y) % ScreenInfo->ScreenBufferSize.Y;
            Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
            RecomputeRow = FALSE;
        }
#if !defined(CON_TB_MARK)
        ASSERT(nLoop++ < 2);
        if (Row->CharRow.KAttrs && (Row->CharRow.KAttrs[Position.X] & ATTR_TRAILING_BYTE)) {
            goto recalc;
        }
#endif
        if (!MyStringCompareW(SearchString, &Row->CharRow.Chars[Position.X], StringLength, IgnoreCase)) {
            *StringPosition = Position;
            return ColumnWidth;
        }
    } while (!(Position.X == EndPosition.X && Position.Y == EndPosition.Y));

    return 0;   // the string was not found
}

INT_PTR
FindDialogProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    PCONSOLE_INFORMATION Console;
    PSCREEN_INFORMATION ScreenInfo;
    USHORT StringLength;
    USHORT ColumnWidth;
    WCHAR szBuf[SEARCH_STRING_LENGTH + 1];
    COORD Position;
    BOOLEAN IgnoreCase;
    BOOLEAN Reverse;

    switch (Message) {
    case WM_INITDIALOG:
        SetWindowLongPtr(hWnd, DWLP_USER, lParam);
        SendDlgItemMessage(hWnd, ID_FINDSTR, EM_LIMITTEXT, ARRAY_SIZE(szBuf)-1, 0);
        CheckRadioButton(hWnd, ID_FINDUP, ID_FINDDOWN, ID_FINDDOWN);
        return TRUE;
    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDOK:
            StringLength = (USHORT)GetDlgItemText(hWnd, ID_FINDSTR, szBuf, ARRAY_SIZE(szBuf));
            if (StringLength == 0) {
                break;
            }
            IgnoreCase = IsDlgButtonChecked(hWnd, ID_FINDCASE) == 0;
            Reverse = IsDlgButtonChecked(hWnd, ID_FINDDOWN) == 0;
            Console = (PCONSOLE_INFORMATION)GetWindowLongPtr(hWnd, DWLP_USER);
            ScreenInfo = Console->CurrentScreenBuffer;
            if ((ColumnWidth = SearchForString(ScreenInfo, szBuf, StringLength, IgnoreCase, Reverse, &Position)) != 0) {

                //
                // Clear any old selections
                //

                if (Console->Flags & CONSOLE_SELECTING) {
                    ClearSelection(Console);
                }

                //
                // Make the new selection
                //

                Console->Flags |= CONSOLE_SELECTING;
                Console->SelectionFlags = CONSOLE_MOUSE_SELECTION | CONSOLE_SELECTION_NOT_EMPTY;
                InitializeMouseSelection(Console, Position);
                Console->SelectionRect.Right = Console->SelectionRect.Left + ColumnWidth - 1;
                MyInvert(Console,&Console->SelectionRect);
                SetWinText(Console,msgSelectMode,TRUE);

                //
                // Make sure the hilited text will be visible
                //

                if (Console->SelectionRect.Left < ScreenInfo->Window.Left) {
                    Position.X = Console->SelectionRect.Left;
                } else if (Console->SelectionRect.Right > ScreenInfo->Window.Right) {
                    Position.X = Console->SelectionRect.Right - CONSOLE_WINDOW_SIZE_X(ScreenInfo) + 1;
                } else {
                    Position.X = ScreenInfo->Window.Left;
                }
                if (Console->SelectionRect.Top < ScreenInfo->Window.Top) {
                    Position.Y = Console->SelectionRect.Top;
                } else if (Console->SelectionRect.Bottom > ScreenInfo->Window.Bottom) {
                    Position.Y = Console->SelectionRect.Bottom - CONSOLE_WINDOW_SIZE_Y(ScreenInfo) + 1;
                } else {
                    Position.Y = ScreenInfo->Window.Top;
                }
                SetWindowOrigin(ScreenInfo, TRUE, Position);
                return TRUE;
            } else {

                //
                // The string wasn't found
                //

                Beep(800, 200);
            }
            break;
        case IDCANCEL:
            EndDialog(hWnd, 0);
            return TRUE;
        }
        break;
    default:
        break;
    }
    return FALSE;
}

VOID
DoFind(
   IN PCONSOLE_INFORMATION Console
   )
{
    DialogBoxParam(ghInstance,
                   MAKEINTRESOURCE(ID_FINDDLG),
                   Console->hWnd,
                   FindDialogProc,
                   (LPARAM)Console);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\server\dispatch.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    dispatch.c

Abstract:

Author:

    KazuM Apr.19.1996

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#define WWSB_NOFE
#include "dispatch.h"
#undef  WWSB_NOFE
#define WWSB_FE
#include "dispatch.h"
#undef  WWSB_FE

#if defined(FE_SB)


NTSTATUS
DoSrvWriteConsole(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus,
    IN PCONSOLE_INFORMATION Console,
    IN PHANDLE_DATA HandleData
    )
{
    if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
        return FE_DoSrvWriteConsole(m,ReplyStatus,Console,HandleData);
    else
        return SB_DoSrvWriteConsole(m,ReplyStatus,Console,HandleData);
}

NTSTATUS
WriteOutputString(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PVOID Buffer,
    IN COORD WriteCoord,
    IN ULONG StringType,
    IN OUT PULONG NumRecords, // this value is valid even for error cases
    OUT PULONG NumColumns OPTIONAL
    )
{
    PCONSOLE_INFORMATION Console = ScreenInfo->Console;

    if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
        return FE_WriteOutputString(ScreenInfo, Buffer, WriteCoord, StringType, NumRecords, NumColumns);
    else
        return SB_WriteOutputString(ScreenInfo, Buffer, WriteCoord, StringType, NumRecords, NumColumns);
}


VOID
WriteRectToScreenBuffer(
    PBYTE Source,
    COORD SourceSize,
    PSMALL_RECT SourceRect,
    PSCREEN_INFORMATION ScreenInfo,
    COORD TargetPoint,
    IN UINT Codepage
    )
{
    PCONSOLE_INFORMATION Console = ScreenInfo->Console;

    if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
        FE_WriteRectToScreenBuffer(Source,SourceSize,SourceRect,ScreenInfo,TargetPoint,Codepage);
    else
        SB_WriteRectToScreenBuffer(Source,SourceSize,SourceRect,ScreenInfo,TargetPoint,Codepage);
}

VOID
WriteToScreen(
    IN PSCREEN_INFORMATION ScreenInfo,
    PSMALL_RECT Region    // region is inclusive
    )
{
    PCONSOLE_INFORMATION Console = ScreenInfo->Console;

    if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
        FE_WriteToScreen(ScreenInfo, Region);
    else
        SB_WriteToScreen(ScreenInfo, Region);
}

VOID
WriteRegionToScreen(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT Region
    )
{
    PCONSOLE_INFORMATION Console = ScreenInfo->Console;

    if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
        FE_WriteRegionToScreen(ScreenInfo, Region);
    else
        SB_WriteRegionToScreen(ScreenInfo, Region);
}

NTSTATUS
FillOutput(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN WORD Element,
    IN COORD WriteCoord,
    IN ULONG ElementType,
    IN OUT PULONG Length // this value is valid even for error cases
    )
{
    PCONSOLE_INFORMATION Console = ScreenInfo->Console;

    if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
        return FE_FillOutput(ScreenInfo, Element, WriteCoord, ElementType, Length);
    else
        return SB_FillOutput(ScreenInfo, Element, WriteCoord, ElementType, Length);
}

VOID
FillRectangle(
    IN CHAR_INFO Fill,
    IN OUT PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT TargetRect
    )
{
    PCONSOLE_INFORMATION Console = ScreenInfo->Console;

    if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
        FE_FillRectangle(Fill, ScreenInfo, TargetRect);
    else
        SB_FillRectangle(Fill, ScreenInfo, TargetRect);
}


ULONG
DoWriteConsole(
    IN OUT PCSR_API_MSG m,
    IN PCONSOLE_INFORMATION Console,
    IN PCSR_THREAD Thread
    )
{
    if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
        return FE_DoWriteConsole(m,Console,Thread);
    else
        return SB_DoWriteConsole(m,Console,Thread);
}


NTSTATUS
WriteChars(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PWCHAR lpBufferBackupLimit,
    IN PWCHAR lpBuffer,
    IN PWCHAR lpRealUnicodeString,
    IN OUT PDWORD NumBytes,
    OUT PLONG NumSpaces OPTIONAL,
    IN SHORT OriginalXPosition,
    IN DWORD dwFlags,
    OUT PSHORT ScrollY OPTIONAL
    )
{
    PCONSOLE_INFORMATION Console = ScreenInfo->Console;

    if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
        return FE_WriteChars(ScreenInfo,lpBufferBackupLimit,lpBuffer,lpRealUnicodeString,NumBytes,NumSpaces,OriginalXPosition,dwFlags,ScrollY);
    else
        return SB_WriteChars(ScreenInfo,lpBufferBackupLimit,lpBuffer,lpRealUnicodeString,NumBytes,NumSpaces,OriginalXPosition,dwFlags,ScrollY);
}



NTSTATUS
AdjustCursorPosition(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN COORD CursorPosition,
    IN BOOL KeepCursorVisible,
    OUT PSHORT ScrollY OPTIONAL
    )
{
    PCONSOLE_INFORMATION Console = ScreenInfo->Console;

    if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
        return FE_AdjustCursorPosition(ScreenInfo, CursorPosition, KeepCursorVisible, ScrollY);
    else
        return SB_AdjustCursorPosition(ScreenInfo, CursorPosition, KeepCursorVisible, ScrollY);
}

NTSTATUS
TranslateOutputToAnsiUnicode(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size,
    IN OUT PCHAR_INFO OutputBufferR
    )
{
    if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
        return FE_TranslateOutputToAnsiUnicode(Console,OutputBuffer,Size,OutputBufferR);
    else
        return SB_TranslateOutputToAnsiUnicode(Console,OutputBuffer,Size);
}

NTSTATUS
TranslateOutputToUnicode(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size)
{
    if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
        return FE_TranslateOutputToUnicode(Console,OutputBuffer,Size);
    else
        return SB_TranslateOutputToUnicode(Console,OutputBuffer,Size);
}

NTSTATUS
TranslateOutputToOemUnicode(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size,
    IN BOOL fRemoveDbcsMark
    )
{
    if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
        return FE_TranslateOutputToOemUnicode(Console,OutputBuffer,Size,fRemoveDbcsMark);
    else
        return SB_TranslateOutputToOemUnicode(Console,OutputBuffer,Size);
}

NTSTATUS
TranslateOutputToOem(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCHAR_INFO OutputBuffer,
    IN COORD Size
    )
{
    if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
        return FE_TranslateOutputToOem(Console,OutputBuffer,Size);
    else
        return SB_TranslateOutputToOem(Console,OutputBuffer,Size);
}

ULONG
TranslateInputToUnicode(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PINPUT_RECORD InputRecords,
    IN ULONG NumRecords,
    IN OUT PINPUT_RECORD DBCSLeadByte
    )
{
    if (CONSOLE_IS_DBCS_CP(Console))
        return FE_TranslateInputToUnicode(Console,InputRecords,NumRecords,DBCSLeadByte);
    else
        return SB_TranslateInputToUnicode(Console,InputRecords,NumRecords);
}

ULONG
TranslateInputToOem(
    IN PCONSOLE_INFORMATION Console,
    IN OUT PINPUT_RECORD InputRecords,
    IN ULONG NumRecords,    // in : ASCII byte count
    IN ULONG UnicodeLength, // in : Number of events (char count)
    OUT PINPUT_RECORD DbcsLeadInpRec
    )
{
    if (CONSOLE_IS_DBCS_CP(Console))
        return FE_TranslateInputToOem(Console,InputRecords,NumRecords,UnicodeLength,DbcsLeadInpRec);
    else
        return SB_TranslateInputToOem(Console,InputRecords,NumRecords);
}

WCHAR
CharToWchar(
    IN PCONSOLE_INFORMATION Console,
    IN UINT Codepage,
    IN char *Ch
    )
{
    WCHAR wc;
    if (CONSOLE_IS_DBCS_CP(Console))
    {
        if (IsDBCSLeadByteConsole(*Ch, &Console->OutputCPInfo))
        {
            ConvertOutputToUnicode(Console->OutputCP,
                                   Ch,
                                   2,
                                   &wc,
                                   1);
        }
        else
        {
            ConvertOutputToUnicode(Console->OutputCP,
                                   Ch,
                                   1,
                                   &wc,
                                   1);
        }
    }
    else
    {
        wc = SB_CharToWchar(Codepage, *Ch);
    }
    return wc;
}


#ifdef i386
VOID
WriteRegionToScreenHW(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT Region
    )
{
    if (CONSOLE_IS_DBCS_OUTPUTCP(ScreenInfo->Console))
        FE_WriteRegionToScreenHW(ScreenInfo,Region);
    else
        SB_WriteRegionToScreenHW(ScreenInfo,Region);
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\server\handle.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    handle.c

Abstract:

    This file manages console and io handles.

Author:

    Therese Stowell (thereses) 16-Nov-1990

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
// array of pointers to consoles
//

PCONSOLE_INFORMATION  InitialConsoleHandles[CONSOLE_INITIAL_CONSOLES];
PCONSOLE_INFORMATION  *ConsoleHandles;
ULONG NumberOfConsoleHandles;

CRITICAL_SECTION ConsoleHandleLock; // serializes console handle table access

ULONG ConsoleId = 47; // unique number identifying console

//
// Macros to manipulate console handles
//

#define HandleFromIndex(i)  (LongToHandle(((i & 0xFFFF) | (ConsoleId++ << 16))))
#define IndexFromHandle(h)  ((USHORT)((ULONG_PTR)h & 0xFFFF))
#define ConsoleHandleTableLocked() (ConsoleHandleLock.OwningThread == NtCurrentTeb()->ClientId.UniqueThread)

VOID
AddProcessToList(
    IN OUT PCONSOLE_INFORMATION Console,
    IN OUT PCONSOLE_PROCESS_HANDLE ProcessHandleRecord,
    IN HANDLE ProcessHandle
    );

VOID
FreeInputHandle(
    IN PHANDLE_DATA HandleData
    );

NTSTATUS
InitializeConsoleHandleTable( VOID )

/*++

Routine Description:

    This routine initializes the global console handle table.

Arguments:

    none.

Return Value:

    none.

--*/

{
    NTSTATUS Status;

    Status = RtlInitializeCriticalSectionAndSpinCount(&ConsoleHandleLock,
                                                      0x80000000);

    RtlZeroMemory(InitialConsoleHandles, sizeof(InitialConsoleHandles));
    ConsoleHandles = InitialConsoleHandles;
    NumberOfConsoleHandles = NELEM(InitialConsoleHandles);

    return Status;
}


#if DBG

VOID
LockConsoleHandleTable( VOID )

/*++

Routine Description:

    This routine locks the global console handle table. It also verifies
    that we're not in the USER critical section. This is necessary to
    prevent potential deadlocks. This routine is only defined in debug
    builds.

Arguments:

    none.

Return Value:

    none.

--*/

{
    RtlEnterCriticalSection(&ConsoleHandleLock);
}


VOID
UnlockConsoleHandleTable( VOID )

/*++

Routine Description:

    This routine unlocks the global console handle table. This routine
    is only defined in debug builds.

Arguments:

    none.

Return Value:

    none.

--*/

{
    RtlLeaveCriticalSection(&ConsoleHandleLock);
}


VOID
LockConsole(
    IN PCONSOLE_INFORMATION Console)

/*++

Routine Description:

    This routine locks the console. This routine is only defined
    in debug builds.

Arguments:

    none.

Return Value:

    none.

--*/

{
    ASSERT(!ConsoleHandleTableLocked());
    RtlEnterCriticalSection(&(Console->ConsoleLock));
    ASSERT(ConsoleLocked(Console));
}

#endif // DBG


NTSTATUS
DereferenceConsoleHandle(
    IN HANDLE ConsoleHandle,
    OUT PCONSOLE_INFORMATION *Console)

/*++

Routine Description:

    This routine converts a console handle value into a pointer to the
    console data structure.

Arguments:

    ConsoleHandle - console handle to convert.

    Console - On output, contains pointer to the console data structure.

Return Value:

    none.

Note:

    The console handle table lock must be held when calling this routine.

--*/

{
    ULONG i;

    ASSERT(ConsoleHandleTableLocked());

    i = IndexFromHandle(ConsoleHandle);
    if ((i >= NumberOfConsoleHandles) ||
        ((*Console = ConsoleHandles[i]) == NULL) ||
        ((*Console)->ConsoleHandle != ConsoleHandle)) {
        *Console = NULL;
        return STATUS_INVALID_HANDLE;
    }
    if ((*Console)->Flags & CONSOLE_TERMINATING) {
        *Console = NULL;
        return STATUS_PROCESS_IS_TERMINATING;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
GrowConsoleHandleTable( VOID )

/*++

Routine Description:

    This routine grows the console handle table.

Arguments:

    none

Return Value:

--*/

{
    PCONSOLE_INFORMATION *NewTable;
    PCONSOLE_INFORMATION *OldTable;
    ULONG i;
    ULONG MaxConsoleHandles;

    ASSERT(ConsoleHandleTableLocked());

    MaxConsoleHandles = NumberOfConsoleHandles + CONSOLE_CONSOLE_HANDLE_INCREMENT;
    ASSERT(MaxConsoleHandles <= 0xFFFF);
    NewTable = (PCONSOLE_INFORMATION *)ConsoleHeapAlloc(MAKE_TAG( HANDLE_TAG ),MaxConsoleHandles * sizeof(PCONSOLE_INFORMATION));
    if (NewTable == NULL) {
        return STATUS_NO_MEMORY;
    }
    RtlCopyMemory(NewTable, ConsoleHandles,
                  NumberOfConsoleHandles * sizeof(PCONSOLE_INFORMATION));
    for (i=NumberOfConsoleHandles;i<MaxConsoleHandles;i++) {
        NewTable[i] = NULL;
    }
    OldTable = ConsoleHandles;
    ConsoleHandles = NewTable;
    NumberOfConsoleHandles = MaxConsoleHandles;
    if (OldTable != InitialConsoleHandles) {
        ConsoleHeapFree(OldTable);
    }
    return STATUS_SUCCESS;
}


NTSTATUS
AllocateConsoleHandle(
    OUT PHANDLE Handle)

/*++

Routine Description:

    This routine allocates a console handle from the global table.

Arguments:

    Handle - Pointer to store handle in.

Return Value:

Note:

    The console handle table lock must be held when calling this routine.

--*/

{
    ULONG i;
    NTSTATUS Status;

    ASSERT(ConsoleHandleTableLocked());

    //
    // have to start allocation at 1 because 0 indicates no console handle
    // in ConDllInitialize.
    //

    for (i=1;i<NumberOfConsoleHandles;i++) {
        if (ConsoleHandles[i] == NULL) {
            ConsoleHandles[i] = (PCONSOLE_INFORMATION) CONSOLE_HANDLE_ALLOCATED;
            *Handle = HandleFromIndex(i);
            return STATUS_SUCCESS;
        }
    }

    //
    // grow console handle table
    //

    Status = GrowConsoleHandleTable();
    if (!NT_SUCCESS(Status))
        return Status;
    for ( ;i<NumberOfConsoleHandles;i++) {
        if (ConsoleHandles[i] == NULL) {
            ConsoleHandles[i] = (PCONSOLE_INFORMATION) CONSOLE_HANDLE_ALLOCATED;
            *Handle = HandleFromIndex(i);
            return STATUS_SUCCESS;
        }
    }
    ASSERT (FALSE);
    return STATUS_UNSUCCESSFUL;
}



NTSTATUS
FreeConsoleHandle(
    IN HANDLE Handle)

/*++

Routine Description:

    This routine frees a console handle from the global table.

Arguments:

    Handle - Handle to free.

Return Value:

Note:

    The console handle table lock must be held when calling this routine.

--*/

{
    ULONG i;

    ASSERT(ConsoleHandleTableLocked());

    ASSERT (Handle != NULL);
    i = IndexFromHandle(Handle);
    if ((i >= NumberOfConsoleHandles) || (ConsoleHandles[i] == NULL)) {
        ASSERT (FALSE);
    } else {
        ConsoleHandles[i] = NULL;
    }
    return STATUS_SUCCESS;
}


NTSTATUS
ValidateConsole(
    IN PCONSOLE_INFORMATION Console)

/*++

Routine Description:

    This routine ensures that the given console pointer is valid.

Arguments:

    Console - Console pointer to validate.

--*/

{
    ULONG i;

    if (Console != NULL) {
        for (i = 0; i < NumberOfConsoleHandles; i++) {
            if (ConsoleHandles[i] == Console)
                return STATUS_SUCCESS;
        }
    }
    return STATUS_UNSUCCESSFUL;
}


NTSTATUS
InitializeIoHandleTable(
    IN OUT PCONSOLE_INFORMATION Console,
    OUT PCONSOLE_PER_PROCESS_DATA ProcessData,
    OUT PHANDLE StdIn,
    OUT PHANDLE StdOut,
    OUT PHANDLE StdErr)

/*++

Routine Description:

    This routine initializes a process's handle table for the first
    time (there is no parent process).  It also sets up stdin, stdout,
    and stderr.

Arguments:

    Console - Pointer to console information structure.

    ProcessData - Pointer to per process data structure.

    Stdin - Pointer in which to return StdIn handle.

    StdOut - Pointer in which to return StdOut handle.

    StdErr - Pointer in which to return StdErr handle.

Return Value:

--*/

{
    ULONG i;
    HANDLE Handle;
    NTSTATUS Status;
    PHANDLE_DATA HandleData;

    // HandleTablePtr gets set up by ConsoleAddProcessRoutine.
    // it will be != to HandleTable if the new process was created
    // using "start xxx" at the command line and cmd.exe has >
    // CONSOLE_INITIAL_IO_HANDLES.

    if (ProcessData->HandleTablePtr != ProcessData->HandleTable) {
        ASSERT(ProcessData->HandleTableSize != CONSOLE_INITIAL_IO_HANDLES);
        ConsoleHeapFree(ProcessData->HandleTablePtr);
        ProcessData->HandleTablePtr = ProcessData->HandleTable;
    }

    for (i=0;i<CONSOLE_INITIAL_IO_HANDLES;i++) {
        ProcessData->HandleTable[i].HandleType = CONSOLE_FREE_HANDLE;
    }

    ProcessData->HandleTableSize = CONSOLE_INITIAL_IO_HANDLES;

    //
    // set up stdin, stdout, stderr.  we don't do any cleanup in case
    // of errors because we're going to fail the console creation.
    //
    // stdin
    //

    Status = AllocateIoHandle(ProcessData,
                              CONSOLE_INPUT_HANDLE,
                              &Handle
                             );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandleNoCheck(ProcessData,
                                 Handle,
                                 &HandleData
                                );
    ASSERT (NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    if (!InitializeInputHandle(HandleData,
                               &Console->InputBuffer)) {
        return STATUS_NO_MEMORY;
    }
    HandleData->HandleType |= CONSOLE_INHERITABLE;
    Status = ConsoleAddShare(GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             &Console->InputBuffer.ShareAccess,
                             HandleData
                            );
    ASSERT(NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    *StdIn = INDEX_TO_HANDLE(Handle);

    //
    // stdout
    //

    Status = AllocateIoHandle(ProcessData,
                              CONSOLE_OUTPUT_HANDLE,
                              &Handle
                             );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandleNoCheck(ProcessData,
                                 Handle,
                                 &HandleData
                                );
    ASSERT (NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    InitializeOutputHandle(HandleData,Console->CurrentScreenBuffer);
    HandleData->HandleType |= CONSOLE_INHERITABLE;
    Status = ConsoleAddShare(GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             &Console->ScreenBuffers->ShareAccess,
                             HandleData
                            );
    ASSERT(NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    *StdOut = INDEX_TO_HANDLE(Handle);

    //
    // stderr
    //

    Status = AllocateIoHandle(ProcessData,
                              CONSOLE_OUTPUT_HANDLE,
                              &Handle
                             );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandleNoCheck(ProcessData,
                                 Handle,
                                 &HandleData
                                );
    ASSERT (NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    InitializeOutputHandle(HandleData,Console->CurrentScreenBuffer);
    HandleData->HandleType |= CONSOLE_INHERITABLE;
    Status = ConsoleAddShare(GENERIC_READ | GENERIC_WRITE,
                             FILE_SHARE_READ | FILE_SHARE_WRITE,
                             &Console->ScreenBuffers->ShareAccess,
                             HandleData
                            );
    ASSERT(NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    *StdErr = INDEX_TO_HANDLE(Handle);
    return STATUS_SUCCESS;
}

NTSTATUS
InheritIoHandleTable(
    IN PCONSOLE_INFORMATION Console,
    IN PCONSOLE_PER_PROCESS_DATA ProcessData,
    IN PCONSOLE_PER_PROCESS_DATA ParentProcessData)

/*++

Routine Description:

    This routine creates a process's handle table from the parent
    process's handle table.  ProcessData contains the process data
    copied directly from the parent to the child process by CSR.
    This routine allocates a new handle table, if necessary, then
    invalidates non-inherited handles and increments the sharing
    and reference counts for inherited handles.

Arguments:

    ProcessData - Pointer to per process data structure.

Return Value:

Note:

    The console lock must be held when calling this routine.

--*/

{
    ULONG i;
    NTSTATUS Status;

    //
    // Copy handles from parent process.  If the table size
    // is CONSOLE_INITIAL_IO_HANDLES, CSR has done the copy
    // for us.
    //

    UNREFERENCED_PARAMETER(Console);

    ASSERT(ParentProcessData->HandleTableSize != 0);
    ASSERT(ParentProcessData->HandleTableSize <= 0x0000FFFF);

    if (ParentProcessData->HandleTableSize != CONSOLE_INITIAL_IO_HANDLES) {
        ProcessData->HandleTableSize = ParentProcessData->HandleTableSize;
        ProcessData->HandleTablePtr = (PHANDLE_DATA)ConsoleHeapAlloc(MAKE_TAG( HANDLE_TAG ),ProcessData->HandleTableSize * sizeof(HANDLE_DATA));

        if (ProcessData->HandleTablePtr == NULL) {
            ProcessData->HandleTablePtr = ProcessData->HandleTable;
            ProcessData->HandleTableSize = CONSOLE_INITIAL_IO_HANDLES;
            return STATUS_NO_MEMORY;
        }
        RtlCopyMemory(ProcessData->HandleTablePtr,
            ParentProcessData->HandleTablePtr,
            ProcessData->HandleTableSize * sizeof(HANDLE_DATA));
    }

    ASSERT(!(Console->Flags & CONSOLE_SHUTTING_DOWN));

    //
    // Allocate any memory associated with each handle.
    //

    Status = STATUS_SUCCESS;
    for (i=0;i<ProcessData->HandleTableSize;i++) {

        if (NT_SUCCESS(Status) && ProcessData->HandleTablePtr[i].HandleType & CONSOLE_INHERITABLE) {

            if (ProcessData->HandleTablePtr[i].HandleType & CONSOLE_INPUT_HANDLE) {
                ProcessData->HandleTablePtr[i].InputReadData = (PINPUT_READ_HANDLE_DATA)ConsoleHeapAlloc(MAKE_TAG( HANDLE_TAG ),sizeof(INPUT_READ_HANDLE_DATA));
                if (!ProcessData->HandleTablePtr[i].InputReadData) {
                    ProcessData->HandleTablePtr[i].HandleType = CONSOLE_FREE_HANDLE;
                    Status = STATUS_NO_MEMORY;
                    continue;
                }
                ProcessData->HandleTablePtr[i].InputReadData->InputHandleFlags = 0;
                ProcessData->HandleTablePtr[i].InputReadData->ReadCount = 0;
                Status = RtlInitializeCriticalSection(&ProcessData->HandleTablePtr[i].InputReadData->ReadCountLock);
                if (!NT_SUCCESS(Status)) {
                    ConsoleHeapFree(ProcessData->HandleTablePtr[i].InputReadData);
                    ProcessData->HandleTablePtr[i].InputReadData = NULL;
                    ProcessData->HandleTablePtr[i].HandleType = CONSOLE_FREE_HANDLE;
                    continue;
                }
            }
        }
        else {
            ProcessData->HandleTablePtr[i].HandleType = CONSOLE_FREE_HANDLE;
        }
    }

    //
    // If something failed, we need to free any input data we allocated and
    // free the handle table.
    //

    if (!NT_SUCCESS(Status)) {
        for (i=0;i<ProcessData->HandleTableSize;i++) {
            if (ProcessData->HandleTablePtr[i].HandleType & CONSOLE_INPUT_HANDLE) {
                FreeInputHandle(&ProcessData->HandleTablePtr[i]);
            }
        }
        if (ProcessData->HandleTableSize != CONSOLE_INITIAL_IO_HANDLES) {
            ConsoleHeapFree(ProcessData->HandleTablePtr);
            ProcessData->HandleTablePtr = ProcessData->HandleTable;
            ProcessData->HandleTableSize = CONSOLE_INITIAL_IO_HANDLES;
        }
        return Status;
    }

    //
    // All the memory allocations succeeded. Now go through and increment the
    // object reference counts and dup the shares.
    //

    for (i=0;i<ProcessData->HandleTableSize;i++) {
        if (ProcessData->HandleTablePtr[i].HandleType != CONSOLE_FREE_HANDLE) {
            PCONSOLE_SHARE_ACCESS ShareAccess;

            if (ProcessData->HandleTablePtr[i].HandleType & CONSOLE_INPUT_HANDLE) {
                ProcessData->HandleTablePtr[i].Buffer.InputBuffer->RefCount++;
                ShareAccess = &ProcessData->HandleTablePtr[i].Buffer.InputBuffer->ShareAccess;
            }
            else {
                ProcessData->HandleTablePtr[i].Buffer.ScreenBuffer->RefCount++;
                ShareAccess = &ProcessData->HandleTablePtr[i].Buffer.ScreenBuffer->ShareAccess;
            }

            Status = ConsoleDupShare(ProcessData->HandleTablePtr[i].Access,
                                     ProcessData->HandleTablePtr[i].ShareAccess,
                                     ShareAccess,
                                     &ProcessData->HandleTablePtr[i]
                                    );
            ASSERT (NT_SUCCESS(Status));
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
ConsoleAddProcessRoutine(
    IN PCSR_PROCESS ParentProcess,
    IN PCSR_PROCESS Process)
{
    PCONSOLE_PER_PROCESS_DATA ProcessData, ParentProcessData;
    PCONSOLE_INFORMATION Console;
    PCONSOLE_PROCESS_HANDLE ProcessHandleRecord;
    NTSTATUS Status = STATUS_SUCCESS;
    ULONG i;

    ProcessData = CONSOLE_FROMPROCESSPERPROCESSDATA(Process);
    ProcessData->HandleTablePtr = ProcessData->HandleTable;
    ProcessData->HandleTableSize = CONSOLE_INITIAL_IO_HANDLES;
    CONSOLE_SETCONSOLEAPPFROMPROCESSDATA(ProcessData,FALSE);

    if (ParentProcess) {

        ProcessData->RootProcess = FALSE;
        ProcessData->ParentProcessId = HandleToUlong(ParentProcess->ClientId.UniqueProcess);
        ParentProcessData = CONSOLE_FROMPROCESSPERPROCESSDATA(ParentProcess);

        //
        // If both the parent and new processes are console apps,
        // inherit handles from the parent process.
        //

        if (ParentProcessData->ConsoleHandle != NULL &&
                (Process->Flags & CSR_PROCESS_CONSOLEAPP)) {
            if (!(NT_SUCCESS(RevalidateConsole(ParentProcessData->ConsoleHandle,
                                               &Console)))) {
                ProcessData->ConsoleHandle = NULL;
                return STATUS_PROCESS_IS_TERMINATING;
            }

            //
            // Don't add the process if the console is being shutdown.
            //

            if (Console->Flags & CONSOLE_SHUTTING_DOWN) {
                Status = STATUS_PROCESS_IS_TERMINATING;
            } else {
                ProcessHandleRecord = ConsoleHeapAlloc(MAKE_TAG( HANDLE_TAG ),sizeof(CONSOLE_PROCESS_HANDLE));
                if (ProcessHandleRecord == NULL) {
                    Status = STATUS_NO_MEMORY;
                } else {

                    //
                    // duplicate parent's handle table
                    //

                    Status = InheritIoHandleTable(Console, ProcessData, ParentProcessData);
                    if (NT_SUCCESS(Status)) {
                        ProcessHandleRecord->Process = Process;
                        ProcessHandleRecord->CtrlRoutine = NULL;
                        ProcessHandleRecord->PropRoutine = NULL;
                        AddProcessToList(Console,ProcessHandleRecord,Process->ProcessHandle);

                        //
                        // increment console reference count
                        //

                        Console->RefCount++;
                    } else {
                        ConsoleHeapFree(ProcessHandleRecord);
                    }
                }
            }
            if (!NT_SUCCESS(Status)) {
                ProcessData->ConsoleHandle = NULL;
                for (i=0;i<CONSOLE_INITIAL_IO_HANDLES;i++) {
                    ProcessData->HandleTable[i].HandleType = CONSOLE_FREE_HANDLE;
                }
            }
            UnlockConsole(Console);
        } else
            ProcessData->ConsoleHandle = NULL;
    } else {
        ProcessData->ConsoleHandle = NULL;
    }
    return Status;
}

NTSTATUS
MapEventHandles(
    IN HANDLE ClientProcessHandle,
    IN PCONSOLE_INFORMATION Console,
    IN OUT PCONSOLE_INFO ConsoleInfo)
{
    if (!MapHandle(ClientProcessHandle,
                   Console->InitEvents[INITIALIZATION_SUCCEEDED],
                   &ConsoleInfo->InitEvents[INITIALIZATION_SUCCEEDED]
                  )) {
        return STATUS_NO_MEMORY;
    }
    if (!MapHandle(ClientProcessHandle,
                   Console->InitEvents[INITIALIZATION_FAILED],
                   &ConsoleInfo->InitEvents[INITIALIZATION_FAILED]
                  )) {
        return STATUS_NO_MEMORY;
    }
    if (!MapHandle(ClientProcessHandle,
                   Console->InputBuffer.InputWaitEvent,
                   &ConsoleInfo->InputWaitHandle
                  )) {
        return STATUS_NO_MEMORY;
    }
    return STATUS_SUCCESS;
}

NTSTATUS
AllocateConsole(
    IN HANDLE ConsoleHandle,
    IN LPWSTR Title,
    IN USHORT TitleLength,
    IN HANDLE ClientProcessHandle,
    OUT PHANDLE StdIn,
    OUT PHANDLE StdOut,
    OUT PHANDLE StdErr,
    OUT PCONSOLE_PER_PROCESS_DATA ProcessData,
    IN OUT PCONSOLE_INFO ConsoleInfo,
    IN BOOLEAN WindowVisible,
    IN DWORD dwConsoleThreadId)

/*++

Routine Description:

    This routine allocates and initialized a console and its associated
    data - input buffer and screen buffer.

Arguments:

    ConsoleHandle - Handle of console to allocate.

    dwWindowSize - Initial size of screen buffer window, in rows and columns.

    nFont - Initial number of font text is displayed in.

    dwScreenBufferSize - Initial size of screen buffer, in rows and columns.

    nInputBufferSize - Initial size of input buffer, in events.

    dwWindowFlags -

    StdIn - On return, contains handle to stdin.

    StdOut - On return, contains handle to stdout.

    StdErr - On return, contains handle to stderr.

    ProcessData - On return, contains the initialized per-process data.

Return Value:

Note:

    The console handle table lock must be held when calling this routine.

--*/

{
    PCONSOLE_INFORMATION Console;
    NTSTATUS Status;
    BOOL Success;

    //
    // allocate console data
    //

    Console = (PCONSOLE_INFORMATION)ConsoleHeapAlloc( MAKE_TAG( CONSOLE_TAG ) | HEAP_ZERO_MEMORY,
                                              sizeof(CONSOLE_INFORMATION));
    if (Console == NULL) {
        return STATUS_NO_MEMORY;
    }
    ConsoleHandles[IndexFromHandle(ConsoleHandle)] = Console;

    Console->Flags = WindowVisible ? 0 : CONSOLE_NO_WINDOW;
    Console->hIcon = ConsoleInfo->hIcon;
    Console->hSmIcon = ConsoleInfo->hSmIcon;
    Console->iIconId = ConsoleInfo->iIconId;
    Console->dwHotKey = ConsoleInfo->dwHotKey;
#if !defined(FE_SB)
    Console->CP = OEMCP;
    Console->OutputCP = ConsoleOutputCP;
#endif
    Console->ReserveKeys = CONSOLE_NOSHORTCUTKEY;
    Console->ConsoleHandle = ConsoleHandle;
    Console->bIconInit = TRUE;
    Console->VerticalClientToWindow = VerticalClientToWindow;
    Console->HorizontalClientToWindow = HorizontalClientToWindow;
#if defined(FE_SB)
    SetConsoleCPInfo(Console,TRUE);
    SetConsoleCPInfo(Console,FALSE);
#endif

    //
    // must wait for window to be destroyed or client impersonation won't
    // work.
    //

    Status = NtDuplicateObject(NtCurrentProcess(),
                              CONSOLE_CLIENTTHREADHANDLE(CSR_SERVER_QUERYCLIENTTHREAD()),
                              NtCurrentProcess(),
                              &Console->ClientThreadHandle,
                              0,
                              FALSE,
                              DUPLICATE_SAME_ACCESS
                             );
    if (!NT_SUCCESS(Status)) {
        goto ErrorExit5;
    }

#if DBG
    //
    // Make sure the handle isn't protected so we can close it later
    //
    UnProtectHandle(Console->ClientThreadHandle);
#endif // DBG

    InitializeListHead(&Console->OutputQueue);
    InitializeListHead(&Console->ProcessHandleList);
    InitializeListHead(&Console->ExeAliasList);
    InitializeListHead(&Console->MessageQueue);

    Status = NtCreateEvent(&Console->InitEvents[INITIALIZATION_SUCCEEDED],
                           EVENT_ALL_ACCESS, NULL, NotificationEvent, FALSE);
    if (!NT_SUCCESS(Status)) {
        goto ErrorExit4a;
    }
    Status = NtCreateEvent(&Console->InitEvents[INITIALIZATION_FAILED],
                           EVENT_ALL_ACCESS, NULL, NotificationEvent, FALSE);
    if (!NT_SUCCESS(Status)) {
        goto ErrorExit4;
    }
    Status = RtlInitializeCriticalSection(&Console->ConsoleLock);
    if (!NT_SUCCESS(Status)) {
        goto ErrorExit3a;
    }
    InitializeConsoleCommandData(Console);

    //
    // initialize input buffer
    //

#if defined(FE_SB)
    Status = CreateInputBuffer(ConsoleInfo->nInputBufferSize,
                               &Console->InputBuffer,
                               Console);
#else
    Status = CreateInputBuffer(ConsoleInfo->nInputBufferSize,
                               &Console->InputBuffer);
#endif
    if (!NT_SUCCESS(Status)) {
        goto ErrorExit3;
    }

    Console->Title = (PWCHAR)ConsoleHeapAlloc(MAKE_TAG( TITLE_TAG ),TitleLength+sizeof(WCHAR));
    if (Console->Title == NULL) {
        Status = STATUS_NO_MEMORY;
        goto ErrorExit2;
    }
    RtlCopyMemory(Console->Title,Title,TitleLength);
    Console->Title[TitleLength/sizeof(WCHAR)] = (WCHAR)0;   // NULL terminate
    Console->TitleLength = TitleLength;

    Console->OriginalTitle = TranslateConsoleTitle(Console->Title, &Console->OriginalTitleLength, TRUE, FALSE);
    if (Console->OriginalTitle == NULL) {
        Status = STATUS_NO_MEMORY;
        goto ErrorExit1;
    }

    Status = NtCreateEvent(&Console->TerminationEvent,
                           EVENT_ALL_ACCESS, NULL, NotificationEvent, FALSE);
    if (!NT_SUCCESS(Status)) {
        goto ErrorExit1a;
    }

    //
    // initialize screen buffer. we don't call OpenConsole to do this
    // because we need to specify the font, windowsize, etc.
    //

    Status = DoCreateScreenBuffer(Console,
                                  ConsoleInfo);
    if (!NT_SUCCESS(Status)){
        goto ErrorExit1b;
    }


    Console->CurrentScreenBuffer = Console->ScreenBuffers;
#if defined(FE_SB)
#if defined(FE_IME)
    SetUndetermineAttribute(Console) ;
#endif
    Status = CreateEUDC(Console);
    if (!NT_SUCCESS(Status)){
        goto ErrorExit1c;
    }
#endif
    Status = InitializeIoHandleTable(Console,
                                     ProcessData,
                                     StdIn,
                                     StdOut,
                                     StdErr
                                    );
    if (!NT_SUCCESS(Status)) {
        goto ErrorExit0;
    }

    //
    // map event handles
    //

    Status = MapEventHandles(ClientProcessHandle,
                             Console,
                             ConsoleInfo
                            );
    if (!NT_SUCCESS(Status)) {
        goto ErrorExit0;
    }

    Success = PostThreadMessage(dwConsoleThreadId,
                                CM_CREATE_CONSOLE_WINDOW,
                                (WPARAM)ConsoleHandle,
                                (LPARAM)ClientProcessHandle
                               );
    if (!Success) {
        KdPrint(("CONSRV: PostThreadMessage failed %d\n",GetLastError()));
        Status = STATUS_UNSUCCESSFUL;
        goto ErrorExit0;
    }

    return STATUS_SUCCESS;

ErrorExit0: Console->ScreenBuffers->RefCount = 0;
#if defined(FE_SB)
            if (Console->EudcInformation != NULL) {
                ConsoleHeapFree(Console->EudcInformation);
            }
ErrorExit1c:
#endif
            FreeScreenBuffer(Console->ScreenBuffers);
ErrorExit1b: NtClose(Console->TerminationEvent);
ErrorExit1a: ConsoleHeapFree(Console->OriginalTitle);
ErrorExit1: ConsoleHeapFree(Console->Title);
ErrorExit2: Console->InputBuffer.RefCount = 0;
            FreeInputBuffer(&Console->InputBuffer);
ErrorExit3: RtlDeleteCriticalSection(&Console->ConsoleLock);

ErrorExit3a: NtClose(Console->InitEvents[INITIALIZATION_FAILED]);
ErrorExit4: NtClose(Console->InitEvents[INITIALIZATION_SUCCEEDED]);
ErrorExit4a: NtClose(Console->ClientThreadHandle);
ErrorExit5:  ConsoleHeapFree(Console);
    return Status;
}

VOID
DestroyConsole(
    IN PCONSOLE_INFORMATION Console)

/*++

Routine Description:

    This routine frees a console structure if it's not being referenced.

Arguments:

    Console - Console to free.

Return Value:


--*/

{
    HANDLE ConsoleHandle = Console->ConsoleHandle;

    //
    // Make sure we have the console locked and it really is going away.
    //

    ASSERT(ConsoleLocked(Console));
    ASSERT(Console->hWnd == NULL);

    //
    // Mark this console as being destroyed.
    //

    Console->Flags |= CONSOLE_IN_DESTRUCTION;

    //
    // Unlock this console.
    //

    RtlLeaveCriticalSection(&Console->ConsoleLock);

    //
    // If the console still exists and no one is waiting on it, free it.
    //

    LockConsoleHandleTable();
    if (Console == ConsoleHandles[IndexFromHandle(ConsoleHandle)] &&
        Console->ConsoleHandle == ConsoleHandle &&
        Console->ConsoleLock.OwningThread == NULL &&
        Console->WaitCount == 0) {

        FreeConsoleHandle(ConsoleHandle);
        RtlDeleteCriticalSection(&Console->ConsoleLock);
        ConsoleHeapFree(Console);
    }
    UnlockConsoleHandleTable();
}

VOID
FreeCon(
    IN PCONSOLE_INFORMATION Console)

/*++

Routine Description:

    This routine frees a console and its associated
    data - input buffer and screen buffer.

Arguments:

    ConsoleHandle - Handle of console to free.

Return Value:

Note:

    The console handle table lock must be held when calling this routine.

--*/

{
    HWND hWnd;
    USERTHREAD_USEDESKTOPINFO utudi;
    NTSTATUS Status;

    Console->Flags |= CONSOLE_TERMINATING;
    NtSetEvent(Console->TerminationEvent,NULL);
    hWnd = Console->hWnd;

    //
    // Wait 10 seconds or until the input thread replies
    // to synchronize the window destruction with
    // the termination of the thread
    //

    if (hWnd != NULL) {
        UnlockConsole(Console);
        utudi.hThread = NULL;
        utudi.drdRestore.pdeskRestore = NULL;

        Status = NtUserSetInformationThread(NtCurrentThread(),
                                            UserThreadUseActiveDesktop,
                                            &utudi, sizeof(utudi));
        ASSERT(NT_SUCCESS(Status));

        if (NT_SUCCESS(Status)) {
            SendMessageTimeout(hWnd, CM_DESTROY_WINDOW, 0, 0, SMTO_BLOCK, 10000, NULL);
            Status = NtUserSetInformationThread(NtCurrentThread(),
                                                UserThreadUseDesktop,
                                                &utudi,
                                                sizeof(utudi));
            ASSERT(NT_SUCCESS(Status));
        }
    } else {
        AbortCreateConsole(Console);
    }
}

VOID
InsertScreenBuffer(
    IN PCONSOLE_INFORMATION Console,
    IN PSCREEN_INFORMATION ScreenInfo)

/*++

Routine Description:

    This routine inserts the screen buffer pointer into the console's
    list of screen buffers.

Arguments:

    Console - Pointer to console information structure.

    ScreenInfo - Pointer to screen information structure.

Return Value:

Note:

    The console lock must be held when calling this routine.

--*/

{
    ScreenInfo->Next = Console->ScreenBuffers;
    Console->ScreenBuffers = ScreenInfo;
}

VOID
RemoveScreenBuffer(
    IN PCONSOLE_INFORMATION Console,
    IN PSCREEN_INFORMATION ScreenInfo)

/*++

Routine Description:

    This routine removes the screen buffer pointer from the console's
    list of screen buffers.

Arguments:

    Console - Pointer to console information structure.

    ScreenInfo - Pointer to screen information structure.

Return Value:

Note:

    The console lock must be held when calling this routine.

--*/

{
    PSCREEN_INFORMATION Prev,Cur;

    if (ScreenInfo == Console->ScreenBuffers) {
        Console->ScreenBuffers = ScreenInfo->Next;
        return;
    }
    Prev = Cur = Console->ScreenBuffers;
    while (Cur != NULL) {
        if (ScreenInfo == Cur)
            break;
        Prev = Cur;
        Cur = Cur->Next;
    }
    ASSERT (Cur != NULL);
    if (Cur != NULL) {
        Prev->Next = Cur->Next;
    }
}

NTSTATUS
GrowIoHandleTable(
    IN PCONSOLE_PER_PROCESS_DATA ProcessData)

/*++

Routine Description:

    This routine grows the per-process io handle table.

Arguments:

    ProcessData - Pointer to the per-process data structure.

Return Value:

--*/

{
    PHANDLE_DATA NewTable;
    ULONG i;
    ULONG MaxFileHandles;

    MaxFileHandles = ProcessData->HandleTableSize + CONSOLE_IO_HANDLE_INCREMENT;
    NewTable = (PHANDLE_DATA)ConsoleHeapAlloc(MAKE_TAG( HANDLE_TAG ),MaxFileHandles * sizeof(HANDLE_DATA));
    if (NewTable == NULL) {
        return STATUS_NO_MEMORY;
    }
    RtlCopyMemory(NewTable, ProcessData->HandleTablePtr,
                  ProcessData->HandleTableSize * sizeof(HANDLE_DATA));
    for (i=ProcessData->HandleTableSize;i<MaxFileHandles;i++) {
        NewTable[i].HandleType = CONSOLE_FREE_HANDLE;
    }
    if (ProcessData->HandleTableSize != CONSOLE_INITIAL_IO_HANDLES) {
        ConsoleHeapFree(ProcessData->HandleTablePtr);
    }
    ProcessData->HandleTablePtr = NewTable;
    ProcessData->HandleTableSize = MaxFileHandles;
    ASSERT(ProcessData->HandleTableSize != 0);
    ASSERT(ProcessData->HandleTableSize <= 0x0000FFFF);

    return STATUS_SUCCESS;
}

VOID
FreeProcessData(
    IN PCONSOLE_PER_PROCESS_DATA ProcessData)

/*++

Routine Description:

    This routine frees any per-process data allocated by the console.

Arguments:

    ProcessData - Pointer to the per-process data structure.

Return Value:

--*/

{
    if (ProcessData->HandleTableSize != CONSOLE_INITIAL_IO_HANDLES) {
        ConsoleHeapFree(ProcessData->HandleTablePtr);
        ProcessData->HandleTablePtr = ProcessData->HandleTable;
        ProcessData->HandleTableSize = CONSOLE_INITIAL_IO_HANDLES;
    }
}

VOID
InitializeOutputHandle(
    PHANDLE_DATA HandleData,
    PSCREEN_INFORMATION ScreenBuffer)

/*++

Routine Description:

    This routine initializes the output-specific fields of the handle data
    structure.

Arguments:

    HandleData - Pointer to handle data structure.

    ScreenBuffer - Pointer to screen buffer data structure.

Return Value:

--*/

{
    HandleData->Buffer.ScreenBuffer = ScreenBuffer;
    HandleData->Buffer.ScreenBuffer->RefCount++;
}

BOOLEAN
InitializeInputHandle(
    PHANDLE_DATA HandleData,
    PINPUT_INFORMATION InputBuffer)

/*++

Routine Description:

    This routine initializes the input-specific fields of the handle data
    structure.

Arguments:

    HandleData - Pointer to handle data structure.

    InputBuffer - Pointer to input buffer data structure.

Return Value:

--*/

{
    NTSTATUS Status;

    HandleData->InputReadData = (PINPUT_READ_HANDLE_DATA)ConsoleHeapAlloc(MAKE_TAG( HANDLE_TAG ),sizeof(INPUT_READ_HANDLE_DATA));
    if (!HandleData->InputReadData) {
        return FALSE;
    }
    Status = RtlInitializeCriticalSection(&HandleData->InputReadData->ReadCountLock);
    if (!NT_SUCCESS(Status)) {
        ConsoleHeapFree(HandleData->InputReadData);
        HandleData->InputReadData = NULL;
        return FALSE;
    }
    HandleData->InputReadData->ReadCount = 0;
    HandleData->InputReadData->InputHandleFlags = 0;
    HandleData->Buffer.InputBuffer = InputBuffer;
    HandleData->Buffer.InputBuffer->RefCount++;
    return TRUE;
}

VOID
FreeInputHandle(
    IN PHANDLE_DATA HandleData)
{
    if (HandleData->InputReadData) {
        RtlDeleteCriticalSection(&HandleData->InputReadData->ReadCountLock);
        ConsoleHeapFree(HandleData->InputReadData);
        HandleData->InputReadData = NULL;
    }
}

NTSTATUS
AllocateIoHandle(
    IN PCONSOLE_PER_PROCESS_DATA ProcessData,
    IN ULONG HandleType,
    OUT PHANDLE Handle)

/*++

Routine Description:

    This routine allocates an input or output handle from the process's
    handle table.

    This routine initializes all non-type specific fields in the handle
    data structure.

Arguments:

    ProcessData - Pointer to per process data structure.

    HandleType - Flag indicating input or output handle.

    Handle - On return, contains allocated handle.  Handle is an index
    internally.  When returned to the API caller, it is translated into
    a handle.

Return Value:

Note:

    The console lock must be held when calling this routine.  The handle
    is allocated from the per-process handle table.  Holding the console
    lock serializes both threads within the calling process and any other
    process that shares the console.

--*/

{
    ULONG i;
    NTSTATUS Status;

    for (i=0;i<ProcessData->HandleTableSize;i++) {
        if (ProcessData->HandleTablePtr[i].HandleType == CONSOLE_FREE_HANDLE) {
            ProcessData->HandleTablePtr[i].HandleType = HandleType;
            *Handle = LongToHandle(i);

            return STATUS_SUCCESS;
        }
    }
    Status = GrowIoHandleTable(ProcessData);
    if (!NT_SUCCESS(Status))
        return Status;
    for ( ;i<ProcessData->HandleTableSize;i++) {
        if (ProcessData->HandleTablePtr[i].HandleType == CONSOLE_FREE_HANDLE) {
            ProcessData->HandleTablePtr[i].HandleType = HandleType;
            *Handle = LongToHandle(i);
            return STATUS_SUCCESS;
        }
    }
    ASSERT (FALSE);
    return STATUS_UNSUCCESSFUL;
}


NTSTATUS
FreeIoHandle(
    IN PCONSOLE_PER_PROCESS_DATA ProcessData,
    IN HANDLE Handle)

/*++

Routine Description:

    This routine frees an input or output handle from the process's
    handle table.

Arguments:

    ProcessData - Pointer to per process data structure.

    Handle - Handle to free.

Return Value:

Note:

    The console lock must be held when calling this routine.  The handle
    is freed from the per-process handle table.  Holding the console
    lock serializes both threads within the calling process and any other
    process that shares the console.

--*/

{
    NTSTATUS Status;
    PHANDLE_DATA HandleData;

    Status = DereferenceIoHandleNoCheck(ProcessData,
                                 Handle,
                                 &HandleData
                                );
    ASSERT (NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (HandleData->HandleType & CONSOLE_INPUT_HANDLE) {
        FreeInputHandle(HandleData);
    }
    HandleData->HandleType = CONSOLE_FREE_HANDLE;
    return STATUS_SUCCESS;
}

NTSTATUS
DereferenceIoHandleNoCheck(
    IN PCONSOLE_PER_PROCESS_DATA ProcessData,
    IN HANDLE Handle,
    OUT PHANDLE_DATA *HandleData)

/*++

Routine Description:

    This routine verifies a handle's validity, then returns a pointer to
    the handle data structure.

Arguments:

    ProcessData - Pointer to per process data structure.

    Handle - Handle to dereference.

    HandleData - On return, pointer to handle data structure.

Return Value:

--*/

{
    if (((ULONG_PTR)Handle >= ProcessData->HandleTableSize) ||
        (ProcessData->HandleTablePtr[(ULONG_PTR)Handle].HandleType == CONSOLE_FREE_HANDLE) ) {
        return STATUS_INVALID_HANDLE;
    }
    *HandleData = &ProcessData->HandleTablePtr[(ULONG_PTR)Handle];
    return STATUS_SUCCESS;
}

NTSTATUS
DereferenceIoHandle(
    IN PCONSOLE_PER_PROCESS_DATA ProcessData,
    IN HANDLE Handle,
    IN ULONG HandleType,
    IN ACCESS_MASK Access,
    OUT PHANDLE_DATA *HandleData)

/*++

Routine Description:

    This routine verifies a handle's validity, then returns a pointer to
    the handle data structure.

Arguments:

    ProcessData - Pointer to per process data structure.

    Handle - Handle to dereference.

    HandleData - On return, pointer to handle data structure.

Return Value:

--*/

{
    ULONG_PTR Index;

    if (!CONSOLE_HANDLE(Handle)) {
        return STATUS_INVALID_HANDLE;
    }
    Index = (ULONG_PTR)HANDLE_TO_INDEX(Handle);
    if ((Index >= ProcessData->HandleTableSize) ||
        (ProcessData->HandleTablePtr[Index].HandleType == CONSOLE_FREE_HANDLE) ||
        !(ProcessData->HandleTablePtr[Index].HandleType & HandleType) ||
        !(ProcessData->HandleTablePtr[Index].Access & Access) ) {
        return STATUS_INVALID_HANDLE;
    }
    *HandleData = &ProcessData->HandleTablePtr[Index];
    return STATUS_SUCCESS;
}


ULONG
SrvVerifyConsoleIoHandle(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus)

/*++

Routine Description:

    This routine verifies that a console io handle is valid.

Arguments:

    ApiMessageData - Points to parameter structure.

Return Value:

--*/

{
    PCONSOLE_VERIFYIOHANDLE_MSG a = (PCONSOLE_VERIFYIOHANDLE_MSG)&m->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;
    NTSTATUS Status;
    PHANDLE_DATA HandleData;
    PCONSOLE_PER_PROCESS_DATA ProcessData;

    UNREFERENCED_PARAMETER(ReplyStatus);

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (NT_SUCCESS(Status)) {
        ProcessData = CONSOLE_PERPROCESSDATA();
        Status = DereferenceIoHandleNoCheck(ProcessData,
                                     HANDLE_TO_INDEX(a->Handle),
                                     &HandleData
                                    );
        UnlockConsole(Console);
    }
    a->Valid = (NT_SUCCESS(Status));
    return STATUS_SUCCESS;
}


NTSTATUS
ApiPreamble(
    IN HANDLE ConsoleHandle,
    OUT PCONSOLE_INFORMATION *Console)
{
    NTSTATUS Status;

    //
    // If this process doesn't have a console handle, bail immediately.
    //

    if (ConsoleHandle == NULL || ConsoleHandle != CONSOLE_GETCONSOLEHANDLE()) {
        return STATUS_INVALID_HANDLE;
    }

#ifdef i386
    //Do not lock the console if we are in the special case:
    //(1). we are in the middle of handshaking with ntvdm doing
    //     full-screen to windowed mode transition
    //(2). the calling process is THE ntvdm process(this implies that the
    //     the console has vdm registered.
    //(3). the console handle is the same one.
    // if (1), (2) and (3) are true then the console is already locked
    // (locked by the windowproc while processing the WM_FULLSCREEN
    // message)

    RtlEnterCriticalSection(&ConsoleVDMCriticalSection);
    if (ConsoleVDMOnSwitching != NULL &&
        ConsoleVDMOnSwitching->ConsoleHandle == ConsoleHandle &&
        ConsoleVDMOnSwitching->VDMProcessId == CONSOLE_CLIENTPROCESSID()) {
        RIPMSG1(RIP_WARNING, "ApiPreamble - Thread %lx Entered VDM CritSec", GetCurrentThreadId());
        *Console = ConsoleVDMOnSwitching;
        return STATUS_SUCCESS;
    }
    RtlLeaveCriticalSection(&ConsoleVDMCriticalSection);
#endif

    Status = RevalidateConsole(ConsoleHandle,
                               Console
                              );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Make sure the console has been initialized and the window is valid
    //

    if ((*Console)->hWnd == NULL || ((*Console)->Flags & CONSOLE_TERMINATING)) {
        KdPrint(("CONSRV: bogus window for console %lx\n", *Console));
        UnlockConsole(*Console);
        return STATUS_INVALID_HANDLE;
    }

    return Status;
}

NTSTATUS
RevalidateConsole(
    IN HANDLE ConsoleHandle,
    OUT PCONSOLE_INFORMATION *Console)
{
    NTSTATUS Status;

    LockConsoleHandleTable();
    Status = DereferenceConsoleHandle(ConsoleHandle,
                                      Console
                                     );
    if (!NT_SUCCESS(Status)) {
        UnlockConsoleHandleTable();
        return Status;
    }

    //
    // The WaitCount ensures the console won't go away between the time
    // we unlock the console handle table and we lock the console.
    //

    InterlockedIncrement(&(*Console)->WaitCount);
    UnlockConsoleHandleTable();
    try {
        LockConsole(*Console);
    } except (EXCEPTION_EXECUTE_HANDLER) {
        InterlockedDecrement(&(*Console)->WaitCount);
        return GetExceptionCode();
    }
    InterlockedDecrement(&(*Console)->WaitCount);

    //
    // If the console was marked for destruction while we were waiting to
    // lock it, try to destroy it and return.
    //

    if ((*Console)->Flags & CONSOLE_IN_DESTRUCTION) {
        DestroyConsole(*Console);
        *Console = NULL;
        return STATUS_INVALID_HANDLE;
    }

    //
    // If the console was marked for termination while we were waiting to
    // lock it, bail out.
    //

    if ((*Console)->Flags & CONSOLE_TERMINATING) {
        UnlockConsole(*Console);
        *Console = NULL;
        return STATUS_PROCESS_IS_TERMINATING;
    }

    return Status;
}


#if DBG

BOOLEAN
UnProtectHandle(
    HANDLE hObject)
{
    NTSTATUS Status;
    OBJECT_HANDLE_FLAG_INFORMATION HandleInfo;

    Status = NtQueryObject(hObject,
                           ObjectHandleFlagInformation,
                           &HandleInfo,
                           sizeof(HandleInfo),
                           NULL
                          );
    if (NT_SUCCESS(Status)) {
        HandleInfo.ProtectFromClose = FALSE;
        Status = NtSetInformationObject(hObject,
                                        ObjectHandleFlagInformation,
                                        &HandleInfo,
                                        sizeof(HandleInfo)
                                       );
        if (NT_SUCCESS(Status)) {
            return TRUE;
        }
    }

    return FALSE;
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\server\menu.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    menu.h

Abstract:

    This module contains the definitions for console system menu

Author:

    Therese Stowell (thereses) Feb-3-1992 (swiped from Win3.1)

Revision History:

--*/

/*
 * IDs of various STRINGTABLE entries
 *
 */

#define msgBufferTooBig      0x1006
#define msgNoFullScreen      0x1007
#define msgCmdLineF2         0x1008
#define msgCmdLineF4         0x1009
#define msgCmdLineF9         0x100A
#define msgSelectMode        0x100B
#define msgMarkMode          0x100C
#define msgScrollMode        0x100D

/* Menu Item strings */
#define cmCopy               0xFFF0
#define cmPaste              0xFFF1
#define cmMark               0xFFF2
#define cmScroll             0xFFF3
#define cmFind               0xFFF4
#define cmSelectAll          0xFFF5
#define cmEdit               0xFFF6
#define cmControl            0xFFF7
#define cmDefaults           0xFFF8

/*
 * MENU IDs
 *
 */
#define ID_WOMENU           500

/*
 * DIALOG IDs
 */
#define ID_FINDDLG          600
#define ID_FINDSTR          601
#define ID_FINDCASE         602
#define ID_FINDUP           603
#define ID_FINDDOWN         604
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\server\makefile.inc ===
..\precomp.h: ..\consrv.h ..\cmdline.h ..\globals.h ..\menu.h                \
              ..\..\inc\conmsg.h ..\..\inc\server.h ..\..\inc\font.h         \
              $(WINDOWS_INC_PATH)\winconp.h $(BASE_INC_PATH)\winbasep.h      \
              $(WINDOWS_INC_PATH)\winuserp.h $(NTUSER_PATH)\server\usersrv.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\server\hard.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    NtHard.c

Abstract:

Author:

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#if defined(i386)


#define REGISTRY_HARDWARE_DESCRIPTION \
        TEXT("\\Registry\\Machine\\Hardware\\DESCRIPTION\\System")

#define REGISTRY_MACHINE_IDENTIFIER   \
        TEXT("Identifier")

#define FUJITSU_FMR_NAME    TEXT("FUJITSU FMR-")
#define NEC_PC98_NAME       TEXT("NEC PC-98")



#define KEY_WORK_AREA ((sizeof(KEY_VALUE_FULL_INFORMATION) + \
                        sizeof(ULONG)) + 256)

NTSTATUS
NtGetMachineIdentifierValue(
    IN OUT PULONG Value
    )

/*++

Routine Description:

    Given a unicode value name this routine will go into the registry
    location for the machine identifier information and get the
    value.

Arguments:

    ValueName - the unicode name for the registry value located in the
                identifier location of the registry.
    Value   - a pointer to the ULONG for the result.

Return Value:

    NTSTATUS

    If STATUS_SUCCESSFUL is returned, the location *Value will be
    updated with the DWORD value from the registry.  If any failing
    status is returned, this value is untouched.

--*/

{
    HANDLE Handle;
    NTSTATUS Status;
    ULONG RequestLength;
    ULONG ResultLength;
    UCHAR Buffer[KEY_WORK_AREA];
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation;

    //
    // Set default as PC/AT
    //

    *Value = MACHINEID_MS_PCAT;

    KeyName.Buffer = REGISTRY_HARDWARE_DESCRIPTION;
    KeyName.Length = sizeof(REGISTRY_HARDWARE_DESCRIPTION) - sizeof(WCHAR);
    KeyName.MaximumLength = sizeof(REGISTRY_HARDWARE_DESCRIPTION);

    InitializeObjectAttributes(&ObjectAttributes,
                               &KeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = NtOpenKey(&Handle,
                       KEY_READ,
                       &ObjectAttributes);

    if (!NT_SUCCESS(Status)) {

        return Status;
    }

    ValueName.Buffer = REGISTRY_MACHINE_IDENTIFIER;
    ValueName.Length = sizeof(REGISTRY_MACHINE_IDENTIFIER) - sizeof(WCHAR);
    ValueName.MaximumLength = sizeof(REGISTRY_MACHINE_IDENTIFIER);

    RequestLength = KEY_WORK_AREA;

    KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION)Buffer;

    Status = NtQueryValueKey(Handle,
                             &ValueName,
                             KeyValueFullInformation,
                             KeyValueInformation,
                             RequestLength,
                             &ResultLength);

    ASSERT( Status != STATUS_BUFFER_OVERFLOW );

    NtClose(Handle);

    if (NT_SUCCESS(Status)) {

        if (KeyValueInformation->DataLength != 0) {

            PWCHAR DataPtr;
            UNICODE_STRING DetectedString, TargetString1, TargetString2;

            //
            // Return contents to the caller.
            //

            DataPtr = (PWCHAR)
              ((PUCHAR)KeyValueInformation + KeyValueInformation->DataOffset);

            //
            // Initialize strings.
            //

            RtlInitUnicodeString( &DetectedString, DataPtr );
            RtlInitUnicodeString( &TargetString1, FUJITSU_FMR_NAME );
            RtlInitUnicodeString( &TargetString2, NEC_PC98_NAME );

            //
            // Check the hardware platform
            //

            if (RtlPrefixUnicodeString( &TargetString1 , &DetectedString , TRUE)) {

                //
                // Fujitsu FMR Series.
                //

                *Value = MACHINEID_FUJITSU_FMR;

            } else if (RtlPrefixUnicodeString( &TargetString2 , &DetectedString , TRUE)) {

                //
                // NEC PC-9800 Seriss
                //

                *Value = MACHINEID_NEC_PC98;

            } else {

                //
                // Standard PC/AT comapatibles
                //

                *Value = MACHINEID_MS_PCAT;

            }

        } else {

            //
            // Treat as if no value was found
            //

            Status = STATUS_OBJECT_NAME_NOT_FOUND;
        }

    }

    return Status;
}
#endif // defined(i386)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\server\misc.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    misc.c

Abstract:

        This file implements the NT console server font routines.

Author:

    Therese Stowell (thereses) 22-Jan-1991

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#ifdef DEBUG_PRINT
ULONG gDebugFlag;
//ULONG gDebugFlag = _DBGOUTPUT | _DBGCHARS | _DBGFONTS | _DBGFONTS2 ;
#endif

ULONG NumberOfMouseButtons;

PFONT_INFO FontInfo;
ULONG FontInfoLength;
ULONG NumberOfFonts;

WCHAR DefaultFaceName[LF_FACESIZE];
COORD DefaultFontSize;
BYTE  DefaultFontFamily;
ULONG DefaultFontIndex = 0;

typedef struct _FONTENUMDC {
    HDC hDC;
    BOOL bFindFaces;
    SHORT TTPointSize;
    ULONG ulFE;
} FONTENUMDC, *PFONTENUMDC;

/*
 * Custom CP for glyph translations
 */
CPTABLEINFO GlyphCP;
USHORT GlyphTable[256];


#define FONT_BUFFER_SIZE 12

#define FE_ABANDONFONT 1
#define FE_FONTOK      2

#define CHAR_NULL      ((char)0)
/*
 * Initial default fonts and face names
 */
PFACENODE gpFaceNames;


NTSTATUS
GetMouseButtons(
    PULONG NumButtons
    )
{
    *NumButtons = NumberOfMouseButtons;
    return STATUS_SUCCESS;
}

VOID
InitializeMouseButtons( VOID )
{
    NumberOfMouseButtons = GetSystemMetrics(SM_CMOUSEBUTTONS);
}

PFACENODE AddFaceNode(PFACENODE *ppStart, LPWSTR pwsz) {
    PFACENODE pNew;
    PFACENODE *ppTmp;
    int cb;

    /*
     * Is it already here?
     */
    for (ppTmp = ppStart; *ppTmp; ppTmp = &((*ppTmp)->pNext)) {
        if (wcscmp(((*ppTmp)->awch), pwsz) == 0) {
            // already there !
            return *ppTmp;
        }
    }

    cb = (wcslen(pwsz) + 1) * sizeof(WCHAR);
    pNew = (PFACENODE)ConsoleHeapAlloc(MAKE_TAG( FONT_TAG ),sizeof(FACENODE) + cb);
    if (pNew == NULL) {
        return NULL;
    }

    pNew->pNext = NULL;
    pNew->dwFlag = 0;
    wcscpy(pNew->awch, pwsz);
    *ppTmp = pNew;
    return pNew;
}

VOID
InitializeFonts( VOID )
{
    WCHAR FontName[CONSOLE_MAX_FONT_NAME_LENGTH];
    int i;
    static CONST LPWSTR FontList[] = {L"woafont",
                                      L"ega80woa.fon",
                                      L"ega40woa.fon",
                                      L"cga80woa.fon",
                                      L"cga40woa.fon"};

    //
    // Read software.ini to get the values for "woafont",
    // "ega80woa.fon", "ega40woa.fon", "cga80woa.fon", and
    // "cga40woa.fon", respectively, to pass to AddFontResource.
    //
    // If any of the entries are empty or non-existent,
    // GetPrivateProfileString will return a NULL (empty) string.
    // If such is the case, the call to AddPermanentFontResource will
    // simply fail.
    //

    OpenProfileUserMapping();

    for (i = 0; i < NELEM(FontList); i++) {
        GetPrivateProfileString(L"386enh", FontList[i], L"",
                FontName, NELEM(FontName), L"system.ini");
        GdiAddFontResourceW(FontName, AFRW_ADD_LOCAL_FONT,NULL);
    }

    CloseProfileUserMapping();
}

/*
 * Returns bit combination
 *  FE_ABANDONFONT  - do not continue enumerating this font
 *  FE_FONTOK       - font was created and added to cache or already there
 */

/*


*/
int CALLBACK
FontEnum(
    LPENUMLOGFONTW lpLogFont,
    LPNEWTEXTMETRICW lpTextMetric,
    int nFontType,
    LPARAM lParam
    )

/*++

    Is called exactly once by GDI for each font in the system.  This
    routine is used to store the FONT_INFO structure.

--*/

{
    PFONTENUMDC pfed = (PFONTENUMDC)lParam;
    HDC hDC = pfed->hDC;
    BOOL bFindFaces = pfed->bFindFaces;
    HFONT hFont;
    TEXTMETRICW tmi;
    LONG nFont;
    LONG nFontNew;
    COORD SizeToShow;
    COORD SizeActual;
    COORD SizeWant;
    BYTE tmFamily;
    SIZE Size;
    LPWSTR pwszFace = lpLogFont->elfLogFont.lfFaceName;
    PFACENODE pFN;

    DBGFONTS(("  FontEnum \"%ls\" (%d,%d) weight 0x%lx(%d) -- %s\n",
            pwszFace,
            lpLogFont->elfLogFont.lfWidth, lpLogFont->elfLogFont.lfHeight,
            lpLogFont->elfLogFont.lfWeight, lpLogFont->elfLogFont.lfWeight,
            bFindFaces ? "Finding Faces" : "Creating Fonts"));

    //
    // reject variable width and italic fonts, also tt fonts with neg ac
    //

    if
    (
      !(lpLogFont->elfLogFont.lfPitchAndFamily & FIXED_PITCH) ||
      (lpLogFont->elfLogFont.lfItalic)                        ||
      !(lpTextMetric->ntmFlags & NTM_NONNEGATIVE_AC)
    )
    {
        if (!IsAvailableTTFont(pwszFace))
        {
            DBGFONTS(("    REJECT  face (variable pitch, italic, or neg a&c)\n"));
            return bFindFaces ? TRUE : FALSE;  // unsuitable font
        }
    }

    if (nFontType == TRUETYPE_FONTTYPE) {
        lpLogFont->elfLogFont.lfHeight = pfed->TTPointSize;
        lpLogFont->elfLogFont.lfWidth  = 0;
        lpLogFont->elfLogFont.lfWeight = FW_NORMAL;
    }

    /*
     * reject TT fonts for whoom family is not modern, that is do not use
     * FF_DONTCARE    // may be surprised unpleasantly
     * FF_DECORATIVE  // likely to be symbol fonts
     * FF_SCRIPT      // cursive, inappropriate for console
     * FF_SWISS OR FF_ROMAN // variable pitch
     */

    if ((nFontType == TRUETYPE_FONTTYPE) &&
            ((lpLogFont->elfLogFont.lfPitchAndFamily & 0xf0) != FF_MODERN)) {
        DBGFONTS(("    REJECT  face (TT but not FF_MODERN)\n"));
        return bFindFaces ? TRUE : FALSE;  // unsuitable font
    }

    /*
     * reject non-TT fonts that aren't OEM
     */
    if ((nFontType != TRUETYPE_FONTTYPE) &&
#if defined(FE_SB)
            (!CONSOLE_IS_DBCS_ENABLED() ||
            !IS_ANY_DBCS_CHARSET(lpLogFont->elfLogFont.lfCharSet)) &&
#endif
            (lpLogFont->elfLogFont.lfCharSet != OEM_CHARSET)) {
        DBGFONTS(("    REJECT  face (not TT nor OEM)\n"));
        return bFindFaces ? TRUE : FALSE;  // unsuitable font
    }

    /*
     * reject non-TT fonts that are virtical font
     */
    if ((nFontType != TRUETYPE_FONTTYPE) &&
            (pwszFace[0] == L'@')) {
        DBGFONTS(("    REJECT  face (not TT and TATEGAKI)\n"));
        return bFindFaces ? TRUE : FALSE;  // unsuitable font
    }

    /*
     * reject non-TT fonts that aren't Terminal
     */
    if (CONSOLE_IS_DBCS_ENABLED() &&
        (nFontType != TRUETYPE_FONTTYPE) &&
            (wcscmp(pwszFace, L"Terminal") != 0)) {
        DBGFONTS(("    REJECT  face (not TT nor Terminal)\n"));
        return bFindFaces ? TRUE : FALSE;  // unsuitable font
    }

    /*
     * reject Far East TT fonts that aren't Far East charset.
     */
    if (IsAvailableTTFont(pwszFace) &&
        !IS_ANY_DBCS_CHARSET(lpLogFont->elfLogFont.lfCharSet) &&
        !IsAvailableTTFontCP(pwszFace,0)
       ) {
        DBGFONTS(("    REJECT  face (Far East TT and not Far East charset)\n"));
        return TRUE;    // should be enumerate next charset.
    }

    /*
     * Add or find the facename
     */
    pFN = AddFaceNode(&gpFaceNames, pwszFace);
    if (pFN == NULL) {
        return FALSE;
    }

    if (bFindFaces) {
        if (nFontType == TRUETYPE_FONTTYPE) {
            DBGFONTS(("NEW TT FACE %ls\n", pwszFace));
            pFN->dwFlag |= EF_TTFONT;
        } else if (nFontType == RASTER_FONTTYPE) {
            DBGFONTS(("NEW OEM FACE %ls\n",pwszFace));
            pFN->dwFlag |= EF_OEMFONT;
        }
        return 0;
    }


    if (IS_BOLD(lpLogFont->elfLogFont.lfWeight)) {
        DBGFONTS2(("    A bold font (weight %d)\n", lpLogFont->elfLogFont.lfWeight));
        // return 0;
    }

    /* get font info */
    SizeWant.Y = (SHORT)lpLogFont->elfLogFont.lfHeight;
    SizeWant.X = (SHORT)lpLogFont->elfLogFont.lfWidth;
CreateBoldFont:
    lpLogFont->elfLogFont.lfQuality = DEFAULT_QUALITY;
    hFont = CreateFontIndirectW(&lpLogFont->elfLogFont);
    if (!hFont) {
        DBGFONTS(("    REJECT  font (can't create)\n"));
        RIPMSG0(RIP_WARNING, "FontEnum: CreateFontIndirectW returned NULL hFont.");
        return 0;  // same font in other sizes may still be suitable
    }

    DBGFONTS2(("    hFont = %lx\n", hFont));

    //
    // for reasons unbeknownst to me, removing this code causes GDI
    // to yack, claiming that the font is owned by another process.
    //

    SelectObject(hDC,hFont);
    if (!GetTextMetricsW(hDC, &tmi)) {
        tmi = *((LPTEXTMETRICW)lpTextMetric);
    }

    if (GetTextExtentPoint32W(hDC, L"0", 1, &Size)) {
        SizeActual.X = (SHORT)Size.cx;
    } else {
        SizeActual.X = (SHORT)(tmi.tmMaxCharWidth);
    }
    SizeActual.Y = (SHORT)(tmi.tmHeight + tmi.tmExternalLeading);
    DBGFONTS2(("    actual size %d,%d\n", SizeActual.X, SizeActual.Y));
    tmFamily = tmi.tmPitchAndFamily;
    if (TM_IS_TT_FONT(tmFamily) && (SizeWant.Y >= 0)) {
        SizeToShow = SizeWant;
        if (SizeWant.X == 0) {
            // Asking for zero width height gets a default aspect-ratio width
            // It's better to show that width rather than 0.
            SizeToShow.X = SizeActual.X;
        }
    } else {
        SizeToShow = SizeActual;
    }
    DBGFONTS2(("    SizeToShow = (%d,%d), SizeActual = (%d,%d)\n",
            SizeToShow.X, SizeToShow.Y, SizeActual.X, SizeActual.Y));

    // there's a GDI bug - this assert fails occasionally
    //ASSERT (tmi.tmw.tmMaxCharWidth == lpTextMetric->tmMaxCharWidth);

    /*
     * NOW, determine whether this font entry has already been cached
     * LATER : it may be possible to do this before creating the font, if
     * we can trust the dimensions & other info from lpTextMetric.
     * Sort by size:
     *  1) By pixelheight (negative Y values)
     *  2) By height (as shown)
     *  3) By width (as shown)
     */
    for (nFont = 0; nFont < (LONG)NumberOfFonts; ++nFont) {
        COORD SizeShown;

        if (FontInfo[nFont].hFont == NULL) {
            DBGFONTS(("!   Font %x has a NULL hFont\n", nFont));
            continue;
        }


        if (FontInfo[nFont].SizeWant.X > 0) {
            SizeShown.X = FontInfo[nFont].SizeWant.X;
        } else {
            SizeShown.X = FontInfo[nFont].Size.X;
        }

        if (FontInfo[nFont].SizeWant.Y > 0) {
            // This is a font specified by cell height.
            SizeShown.Y = FontInfo[nFont].SizeWant.Y;
        } else {
            SizeShown.Y = FontInfo[nFont].Size.Y;
            if (FontInfo[nFont].SizeWant.Y < 0) {
                // This is a TT font specified by character height.
                if (SizeWant.Y < 0 && SizeWant.Y > FontInfo[nFont].SizeWant.Y) {
                    // Requested pixelheight is smaller than this one.
                    DBGFONTS(("INSERT %d pt at %x, before %d pt\n",
                            -SizeWant.Y, nFont, -FontInfo[nFont].SizeWant.Y));
                    nFontNew = nFont;
                    goto InsertNewFont;
                }
            }
        }

        // DBGFONTS(("    SizeShown(%x) = (%d,%d)\n",nFont,SizeShown.X,SizeShown.Y));

        if (SIZE_EQUAL(SizeShown, SizeToShow) &&
                FontInfo[nFont].Family == tmFamily &&
                FontInfo[nFont].Weight == tmi.tmWeight &&
                wcscmp(FontInfo[nFont].FaceName, pwszFace) == 0) {
            /*
             * Already have this font
             */
            DBGFONTS2(("    Already have the font\n"));
            DeleteObject(hFont);
            pfed->ulFE |= FE_FONTOK;
            return TRUE;
        }


        if ((SizeToShow.Y < SizeShown.Y) ||
                (SizeToShow.Y == SizeShown.Y && SizeToShow.X < SizeShown.X)) {
            /*
             * This new font is smaller than nFont
             */
            DBGFONTS(("INSERT at %x, SizeToShow = (%d,%d)\n", nFont,
                    SizeToShow.X,SizeToShow.Y));
            nFontNew = nFont;
            goto InsertNewFont;
        }
    }

    /*
     * The font we are adding should be appended to the list,
     * since it is bigger (or equal) to the last one.
     */
    nFontNew = (LONG)NumberOfFonts;

InsertNewFont: // at nFontNew

//  ASSERT ((lpTextMetric->tmPitchAndFamily & 1) == 0);
    /* If we have to grow our font table, do it */

    if (NumberOfFonts == FontInfoLength) {
        PFONT_INFO Temp;

        FontInfoLength += FONT_INCREMENT;
        Temp = (PFONT_INFO)ConsoleHeapReAlloc(MAKE_TAG( FONT_TAG ),FontInfo,sizeof(FONT_INFO) * FontInfoLength);
        if (Temp == NULL) {
            RIPMSG0(RIP_WARNING, "FontEnum: failed to allocate PFONT_INFO");
            FontInfoLength -= FONT_INCREMENT;
            return FALSE;
        }
        FontInfo = Temp;
    }

    if (nFontNew < (LONG)NumberOfFonts) {
        RtlMoveMemory(&FontInfo[nFontNew+1],
                &FontInfo[nFontNew],
                sizeof(FONT_INFO)*(NumberOfFonts - nFontNew));
        //
        // Fix up DefaultFontIndex if nFontNew less than DefaultFontIndex.
        //
        if (nFontNew < (LONG)DefaultFontIndex &&
            DefaultFontIndex+1 < NumberOfFonts) {
            DefaultFontIndex++;
        }
    }

    /*
     * Store the font info
     */
    FontInfo[nFontNew].hFont = hFont;
    FontInfo[nFontNew].Family = tmFamily;
    FontInfo[nFontNew].Size = SizeActual;
    if (TM_IS_TT_FONT(tmFamily)) {
        FontInfo[nFontNew].SizeWant = SizeWant;
    } else {
        FontInfo[nFontNew].SizeWant.X = 0;
        FontInfo[nFontNew].SizeWant.Y = 0;
    }
    FontInfo[nFontNew].Weight = tmi.tmWeight;
    FontInfo[nFont].FaceName = pFN->awch;
#if defined(FE_SB)
    FontInfo[nFontNew].tmCharSet = tmi.tmCharSet;
#endif

    ++NumberOfFonts;

    if (nFontType == TRUETYPE_FONTTYPE && !IS_BOLD(FontInfo[nFontNew].Weight)) {
          lpLogFont->elfLogFont.lfWeight = FW_BOLD;
          goto CreateBoldFont;
    }

    pfed->ulFE |= FE_FONTOK;  // and continue enumeration
    return TRUE;
}

BOOL
DoFontEnum(
    HDC hDC,
    LPWSTR pwszFace,
    SHORT TTPointSize)
{
    ULONG ulFE = 0;
    BOOL bDeleteDC = FALSE;
    BOOL bFindFaces = (pwszFace == NULL);
    FONTENUMDC fed;
    LOGFONTW LogFont;

    DBGFONTS(("DoFontEnum \"%ls\"\n", pwszFace));
    if (hDC == NULL) {
        hDC = CreateDCW(L"DISPLAY",NULL,NULL,NULL);
        bDeleteDC = TRUE;
    }

    fed.hDC = hDC;
    fed.bFindFaces = bFindFaces;
    fed.ulFE = 0;
    fed.TTPointSize = TTPointSize;
    RtlZeroMemory(&LogFont, sizeof(LOGFONT));
    LogFont.lfCharSet = DEFAULT_CHARSET;
    if (pwszFace)
        wcscpy(LogFont.lfFaceName, pwszFace);
    /*
     * EnumFontFamiliesEx function enumerates one font in every face in every character set.
     */
    EnumFontFamiliesExW(hDC, &LogFont, (FONTENUMPROC)FontEnum, (LPARAM)&fed, 0);
    if (bDeleteDC) {
        DeleteDC(hDC);
    }
    return (fed.ulFE & FE_FONTOK) != 0;
}


NTSTATUS
EnumerateFonts(
    DWORD Flags)
{
    TEXTMETRIC tmi;
    HDC hDC;
    PFACENODE pFN;
    ULONG ulOldEnumFilter;
    DWORD FontIndex;
    DWORD dwFontType = 0;

    DBGFONTS(("EnumerateFonts %lx\n", Flags));

    dwFontType = (EF_TTFONT|EF_OEMFONT|EF_DEFFACE) & Flags;

    if (FontInfo == NULL) {
        //
        // allocate memory for the font array
        //
        NumberOfFonts = 0;

        FontInfo = (PFONT_INFO)ConsoleHeapAlloc(MAKE_TAG( FONT_TAG ),sizeof(FONT_INFO) * INITIAL_FONTS);
        if (FontInfo == NULL)
            return STATUS_NO_MEMORY;
        FontInfoLength = INITIAL_FONTS;
    }

    hDC = CreateDCW(L"DISPLAY",NULL,NULL,NULL);

    // Before enumeration, turn off font enumeration filters.
    ulOldEnumFilter = SetFontEnumeration(0);
    // restore all the other flags
    SetFontEnumeration(ulOldEnumFilter & ~FE_FILTER_TRUETYPE);

    if (Flags & EF_DEFFACE) {
        SelectObject(hDC,GetStockObject(OEM_FIXED_FONT));

        if (GetTextMetricsW(hDC, &tmi)) {
            DefaultFontSize.X = (SHORT)(tmi.tmMaxCharWidth);
            DefaultFontSize.Y = (SHORT)(tmi.tmHeight+tmi.tmExternalLeading);
            DefaultFontFamily = tmi.tmPitchAndFamily;
#if defined(FE_SB)
            if (IS_ANY_DBCS_CHARSET(tmi.tmCharSet))
                DefaultFontSize.X /= 2;
#endif
        }
        GetTextFaceW(hDC, LF_FACESIZE, DefaultFaceName);
#if defined(FE_SB)
        DBGFONTS(("Default (OEM) Font %ls (%d,%d) CharSet 0x%02X\n", DefaultFaceName,
                DefaultFontSize.X, DefaultFontSize.Y,
                tmi.tmCharSet));
#else
        DBGFONTS(("Default (OEM) Font %ls (%d,%d)\n", DefaultFaceName,
                DefaultFontSize.X, DefaultFontSize.Y));
#endif

        // Make sure we are going to enumerate the OEM face.
        pFN = AddFaceNode(&gpFaceNames, DefaultFaceName);
        if (pFN) {
            pFN->dwFlag |= EF_DEFFACE | EF_OEMFONT;
        }
    }

    // Use DoFontEnum to get all fonts from the system.  Our FontEnum
    // proc puts just the ones we want into an array
    //
    for (pFN = gpFaceNames; pFN; pFN = pFN->pNext) {
        DBGFONTS(("\"%ls\" is %s%s%s%s%s%s\n", pFN->awch,
            pFN->dwFlag & EF_NEW        ? "NEW "        : " ",
            pFN->dwFlag & EF_OLD        ? "OLD "        : " ",
            pFN->dwFlag & EF_ENUMERATED ? "ENUMERATED " : " ",
            pFN->dwFlag & EF_OEMFONT    ? "OEMFONT "    : " ",
            pFN->dwFlag & EF_TTFONT     ? "TTFONT "     : " ",
            pFN->dwFlag & EF_DEFFACE    ? "DEFFACE "    : " "));

        if ((pFN->dwFlag & dwFontType) == 0) {
            // not the kind of face we want
            continue;
        }
        if (pFN->dwFlag & EF_ENUMERATED) {
            // we already enumerated this face
            continue;
        }

        DoFontEnum(hDC, pFN->awch, DefaultFontSize.Y);
        pFN->dwFlag |= EF_ENUMERATED;
    }


    // After enumerating fonts, restore the font enumeration filter.
    SetFontEnumeration(ulOldEnumFilter);

    DeleteDC(hDC);

    // Make sure the default font is set correctly
    if (NumberOfFonts > 0 && DefaultFontSize.X == 0 && DefaultFontSize.Y == 0) {
        DefaultFontSize.X = FontInfo[0].Size.X;
        DefaultFontSize.Y = FontInfo[0].Size.Y;
        DefaultFontFamily = FontInfo[0].Family;
    }

    for (FontIndex = 0; FontIndex < NumberOfFonts; FontIndex++) {
        if (FontInfo[FontIndex].Size.X == DefaultFontSize.X &&
            FontInfo[FontIndex].Size.Y == DefaultFontSize.Y &&
            FontInfo[FontIndex].Family == DefaultFontFamily) {
#if defined(FE_SB)
            if (CONSOLE_IS_DBCS_ENABLED() &&
                !IS_ANY_DBCS_CHARSET(FontInfo[FontIndex].tmCharSet))
            {
                continue ;
            }
#endif
            break;
        }
    }
    ASSERT(FontIndex < NumberOfFonts);
    if (FontIndex < NumberOfFonts) {
        DefaultFontIndex = FontIndex;
    } else {
        DefaultFontIndex = 0;
    }
    DBGFONTS(("EnumerateFonts : DefaultFontIndex = %ld\n", DefaultFontIndex));

    return STATUS_SUCCESS;
}


/*
 * Get the font index for a new font
 * If necessary, attempt to create the font.
 * Always return a valid FontIndex (even if not correct)
 * Family:   Find/Create a font with of this Family
 *           0    - don't care
 * pwszFace: Find/Create a font with this face name.
 *           NULL or L""  - use DefaultFaceName
 * Size:     Must match SizeWant or actual Size.
 */
int
FindCreateFont(
    DWORD Family,
    LPWSTR pwszFace,
    COORD Size,
    LONG Weight,
    UINT CodePage)
{
#define NOT_CREATED_NOR_FOUND -1
#define CREATED_BUT_NOT_FOUND -2

    int i;
    int FontIndex = NOT_CREATED_NOR_FOUND;
    int BestMatch = NOT_CREATED_NOR_FOUND;
    BOOL bFontOK;
    WCHAR AltFaceName[LF_FACESIZE];
    COORD AltFontSize;
    BYTE  AltFontFamily;
    ULONG AltFontIndex = 0;
    LPWSTR pwszAltFace = NULL;

    BYTE CharSet = CodePageToCharSet(CodePage);

    DBGFONTS(("FindCreateFont Family=%x %ls (%d,%d) %d %d %x\n",
            Family, pwszFace, Size.X, Size.Y, Weight, CodePage, CharSet));

    if (CONSOLE_IS_DBCS_ENABLED() &&
        !IS_ANY_DBCS_CHARSET(CharSet))
    {
        MakeAltRasterFont(CodePage, FontInfo[DefaultFontIndex].Size,
                          &AltFontSize, &AltFontFamily, &AltFontIndex, AltFaceName);

        if (pwszFace == NULL || *pwszFace == L'\0') {
            pwszFace = AltFaceName;
        }
        if (Size.Y == 0) {
            Size.X = AltFontSize.X;
            Size.Y = AltFontSize.Y;
        }
    }
    else {
        if (pwszFace == NULL || *pwszFace == L'\0') {
            pwszFace = DefaultFaceName;
        }
        if (Size.Y == 0) {
            Size.X = DefaultFontSize.X;
            Size.Y = DefaultFontSize.Y;
        }
    }

    if (IsAvailableTTFont(pwszFace)) {
        pwszAltFace = GetAltFaceName(pwszFace);
    }
    else {
        pwszAltFace = pwszFace;
    }

    /*
     * Try to find the exact font
     */
TryFindExactFont:
    for (i=0; i < (int)NumberOfFonts; i++) {
        /*
         * If looking for a particular Family, skip non-matches
         */
        if ((Family != 0) &&
                ((BYTE)Family != FontInfo[i].Family)) {
            continue;
        }

        /*
         * Skip non-matching sizes
         */
        if ((FontInfo[i].SizeWant.Y != Size.Y) &&
             !SIZE_EQUAL(FontInfo[i].Size, Size)) {
            continue;
        }

        /*
         * Skip non-matching weights
         */
        if ((Weight != 0) && (Weight != FontInfo[i].Weight)) {
            continue;
        }
#if defined(FE_SB)
        if (!TM_IS_TT_FONT(FontInfo[i].Family) &&
                FontInfo[i].tmCharSet != CharSet) {
            continue;
        }
#endif

        /*
         * Size (and maybe Family) match.
         *  If we don't care about the name, or if it matches, use this font.
         *  Else if name doesn't match and it is a raster font, consider it.
         */
        if ((pwszFace == NULL) || (pwszFace[0] == L'\0') ||
                wcscmp(FontInfo[i].FaceName, pwszFace) == 0 ||
                wcscmp(FontInfo[i].FaceName, pwszAltFace) == 0
           ) {
            FontIndex = i;
            goto FoundFont;
        } else if (!TM_IS_TT_FONT(FontInfo[i].Family)) {
            BestMatch = i;
        }
    }

    /*
     * Didn't find the exact font, so try to create it
     */
    if (FontIndex == NOT_CREATED_NOR_FOUND) {
        ULONG ulOldEnumFilter;
        ulOldEnumFilter = SetFontEnumeration(0);
        // restore all the other flags
        SetFontEnumeration(ulOldEnumFilter & ~FE_FILTER_TRUETYPE);
        if (Size.Y < 0) {
            Size.Y = -Size.Y;
        }
        bFontOK = DoFontEnum(NULL, pwszFace, Size.Y);
        SetFontEnumeration(ulOldEnumFilter);
        if (bFontOK) {
            DBGFONTS(("FindCreateFont created font!\n"));
            FontIndex = CREATED_BUT_NOT_FOUND;
            goto TryFindExactFont;
        } else {
            DBGFONTS(("FindCreateFont failed to create font!\n"));
        }
    }

    /*
     * Failed to find exact match, but we have a close Raster Font
     * fit - only the name doesn't match.
     */
    if (BestMatch >= 0) {
        FontIndex = BestMatch;
        goto FoundFont;
    }

    /*
     * Failed to find exact match, even after enumeration, so now try
     * to find a font of same family and same size or bigger
     */
    for (i=0; i < (int)NumberOfFonts; i++) {
#if defined(FE_SB)
        if (CONSOLE_IS_DBCS_ENABLED()) {
            if ((Family != 0) &&
                    ((BYTE)Family != FontInfo[i].Family)) {
                continue;
            }

            if (!TM_IS_TT_FONT(FontInfo[i].Family) &&
                    FontInfo[i].tmCharSet != CharSet) {
                continue;
            }
        }
        else {
#endif
        if ((BYTE)Family != FontInfo[i].Family) {
            continue;
        }
#if defined(FE_SB)
        }
#endif

        if (FontInfo[i].Size.Y >= Size.Y &&
                FontInfo[i].Size.X >= Size.X) {
            // Same family, size >= desired.
            FontIndex = i;
            break;
        }
    }

    if (FontIndex < 0) {
        DBGFONTS(("FindCreateFont defaults!\n"));
#if defined(FE_SB)
        if (CONSOLE_IS_DBCS_ENABLED() &&
            !IsAvailableFarEastCodePage(CodePage))
        {
            FontIndex = AltFontIndex;
        }
        else
#endif
        FontIndex = DefaultFontIndex;
    }

FoundFont:
    DBGFONTS(("FindCreateFont returns %x : %ls (%d,%d)\n", FontIndex,
            FontInfo[FontIndex].FaceName,
            FontInfo[FontIndex].Size.X, FontInfo[FontIndex].Size.Y));
    return FontIndex;

#undef NOT_CREATED_NOR_FOUND
#undef CREATED_BUT_NOT_FOUND
}


NTSTATUS
FindTextBufferFontInfo(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN UINT CodePage,
    OUT PTEXT_BUFFER_FONT_INFO TextFontInfo
    )

/*++

Routine Description:

    This routine find a font information which correspond to code page value.

Arguments:

Return Value:

--*/

{
    PTEXT_BUFFER_FONT_INFO CurrentFont;

    CurrentFont = ScreenInfo->BufferInfo.TextInfo.ListOfTextBufferFont;

    while (CurrentFont != NULL) {
        if (CurrentFont->FontCodePage == CodePage) {
            *TextFontInfo = *CurrentFont;
            return STATUS_SUCCESS;
        }
        CurrentFont = CurrentFont->NextTextBufferFont;
    }

    return STATUS_UNSUCCESSFUL;
}

NTSTATUS
StoreTextBufferFontInfo(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN ULONG FontIndex,
    IN COORD FontSize,
    IN BYTE  FontFamily,
    IN LONG  FontWeight,
    IN LPWSTR FaceName,
    IN UINT CodePage
    )

/*++

Routine Description:

    This routine store a font information in CurrentTextBufferFont and ListOfTextBufferFont.
    If specified code page does not exist in ListOfTextBufferFont, then create new list.

Arguments:

Return Value:

--*/

{
    PTEXT_BUFFER_FONT_INFO CurrentFont, PrevFont;

    CurrentFont = ScreenInfo->BufferInfo.TextInfo.ListOfTextBufferFont;

    while (CurrentFont != NULL) {
        if (CurrentFont->FontCodePage == CodePage) {
            CurrentFont->FontNumber   = FontIndex;
            CurrentFont->FontSize     = FontSize;
            CurrentFont->Family       = FontFamily;
            CurrentFont->Weight       = FontWeight;
            // CurrentFont->FontCodePage = CodePage; // Redundant
            wcscpy(CurrentFont->FaceName, FaceName);
            break;
        }
        PrevFont    = CurrentFont;
        CurrentFont = CurrentFont->NextTextBufferFont;
    }

    if (CurrentFont == NULL) {
        CurrentFont = ConsoleHeapAlloc(MAKE_TAG( FONT_TAG ), sizeof(TEXT_BUFFER_FONT_INFO));
        if (CurrentFont == NULL) {
            return STATUS_NO_MEMORY;
        }

        CurrentFont->NextTextBufferFont = NULL;
        CurrentFont->FontNumber   = FontIndex;
        CurrentFont->FontSize     = FontSize;
        CurrentFont->Family       = FontFamily;
        CurrentFont->Weight       = FontWeight;
        CurrentFont->FontCodePage = CodePage;
        wcscpy(CurrentFont->FaceName, FaceName);

        if (ScreenInfo->BufferInfo.TextInfo.ListOfTextBufferFont == NULL) {
            ScreenInfo->BufferInfo.TextInfo.ListOfTextBufferFont = CurrentFont;
        }
        else {
            PrevFont->NextTextBufferFont = CurrentFont;
        }
    }

    ScreenInfo->BufferInfo.TextInfo.CurrentTextBufferFont = *CurrentFont;
    ScreenInfo->BufferInfo.TextInfo.CurrentTextBufferFont.NextTextBufferFont = NULL;

    return STATUS_SUCCESS;
}

NTSTATUS
RemoveTextBufferFontInfo(
    IN PSCREEN_INFORMATION ScreenInfo
    )

/*++

Routine Description:

    This routine all remove a font information in ListOfTextBufferFont.

Arguments:

Return Value:

--*/

{
    PTEXT_BUFFER_FONT_INFO CurrentFont;

    CurrentFont = ScreenInfo->BufferInfo.TextInfo.ListOfTextBufferFont;

    while (CurrentFont != NULL) {
        PTEXT_BUFFER_FONT_INFO NextFont;

        NextFont = CurrentFont->NextTextBufferFont;
        ConsoleHeapFree(CurrentFont);

        CurrentFont = NextFont;
    }

    ScreenInfo->BufferInfo.TextInfo.ListOfTextBufferFont = NULL;

    return STATUS_SUCCESS;
}

NTSTATUS
GetNumFonts(
    OUT PULONG NumFonts
    )
{
    *NumFonts = NumberOfFonts;
    return STATUS_SUCCESS;
}


NTSTATUS
GetAvailableFonts(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN BOOLEAN MaximumWindow,
    OUT PVOID Buffer,
    IN OUT PULONG NumFonts
    )
{
    PCONSOLE_FONT_INFO BufPtr;
    ULONG i;
    COORD WindowSize;
    WINDOW_LIMITS WindowLimits;

    //
    // if the buffer is too small to return all the fonts, return
    // the number that will fit.
    //

    *NumFonts = (*NumFonts > NumberOfFonts) ? NumberOfFonts : *NumFonts;

    //
    // convert font size in pixels to font size in rows/columns
    //

    BufPtr = (PCONSOLE_FONT_INFO)Buffer;

    if (MaximumWindow) {
        GetWindowLimits(ScreenInfo, &WindowLimits);
        WindowSize = WindowLimits.MaximumWindowSize;
    }
    else {
        WindowSize.X = (SHORT)CONSOLE_WINDOW_SIZE_X(ScreenInfo);
        WindowSize.Y = (SHORT)CONSOLE_WINDOW_SIZE_Y(ScreenInfo);
    }
    for (i=0;i<*NumFonts;i++,BufPtr++) {
        BufPtr->nFont = i;
        BufPtr->dwFontSize.X = WindowSize.X * SCR_FONTSIZE(ScreenInfo).X / FontInfo[i].Size.X;
        BufPtr->dwFontSize.Y = WindowSize.Y * SCR_FONTSIZE(ScreenInfo).Y / FontInfo[i].Size.Y;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
GetFontSize(
    IN DWORD  FontIndex,
    OUT PCOORD FontSize
    )
{
    if (FontIndex >= NumberOfFonts)
        return STATUS_INVALID_PARAMETER;
    *FontSize = FontInfo[FontIndex].Size;
    return STATUS_SUCCESS;
}

NTSTATUS
GetCurrentFont(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN BOOLEAN MaximumWindow,
    OUT PULONG FontIndex,
    OUT PCOORD FontSize
    )
{
    COORD WindowSize;
    WINDOW_LIMITS WindowLimits;

    if (MaximumWindow) {
        GetWindowLimits(ScreenInfo, &WindowLimits);
        WindowSize = WindowLimits.MaximumWindowSize;
    }
    else {
        WindowSize.X = (SHORT)CONSOLE_WINDOW_SIZE_X(ScreenInfo);
        WindowSize.Y = (SHORT)CONSOLE_WINDOW_SIZE_Y(ScreenInfo);
    }
    *FontIndex = SCR_FONTNUMBER(ScreenInfo);
    *FontSize = WindowSize;
    return STATUS_SUCCESS;
}

NTSTATUS
SetScreenBufferFont(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN ULONG FontIndex,
    IN UINT CodePage
    )
{
    COORD FontSize;
    WINDOW_LIMITS WindowLimits;
    NTSTATUS Status;
    ULONG ulFlagPrev;
    DBGFONTS(("SetScreenBufferFont %lx %x\n", ScreenInfo, FontIndex));

    if (ScreenInfo == NULL) {
        /* If shutdown occurs with font dlg up */
        return STATUS_SUCCESS;
    }

    /*
     * Don't try to set the font if we're not in text mode
     */
    if (!(ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER)) {
        return STATUS_UNSUCCESSFUL;
    }

    Status = GetFontSize(FontIndex, &FontSize);
    if (!NT_SUCCESS(Status)) {
        return((ULONG) Status);
    }

    ulFlagPrev = ScreenInfo->Flags;
    if (TM_IS_TT_FONT(FontInfo[FontIndex].Family)) {
        ScreenInfo->Flags &= ~CONSOLE_OEMFONT_DISPLAY;
    } else {
        ScreenInfo->Flags |= CONSOLE_OEMFONT_DISPLAY;
    }

    /*
     * Convert from UnicodeOem to Unicode or vice-versa if necessary
     */
    if ((ulFlagPrev & CONSOLE_OEMFONT_DISPLAY) != (ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY)) {
        if (ulFlagPrev & CONSOLE_OEMFONT_DISPLAY) {
            /*
             * Must convert from UnicodeOem to real Unicode
             */
            DBGCHARS(("SetScreenBufferFont converts UnicodeOem to Unicode\n"));
            FalseUnicodeToRealUnicode(
                    ScreenInfo->BufferInfo.TextInfo.TextRows,
                    ScreenInfo->ScreenBufferSize.X * ScreenInfo->ScreenBufferSize.Y,
                    ScreenInfo->Console->OutputCP);
        } else {
            /*
             * Must convert from real Unicode to UnicodeOem
             */
            DBGCHARS(("SetScreenBufferFont converts Unicode to UnicodeOem\n"));
            RealUnicodeToFalseUnicode(
                    ScreenInfo->BufferInfo.TextInfo.TextRows,
                    ScreenInfo->ScreenBufferSize.X * ScreenInfo->ScreenBufferSize.Y,
                    ScreenInfo->Console->OutputCP);
        }
    }

    /*
     * Store font properties
     */
    Status = StoreTextBufferFontInfo(ScreenInfo,
                                     FontIndex,
                                     FontSize,
                                     FontInfo[FontIndex].Family,
                                     FontInfo[FontIndex].Weight,
                                     FontInfo[FontIndex].FaceName,
                                     CodePage);
    if (!NT_SUCCESS(Status)) {
        return((ULONG) Status);
    }

    //
    // set font
    //
    Status = SetFont(ScreenInfo);
    if (!NT_SUCCESS(Status)) {
        return((ULONG) Status);
    }

    //
    // if window is growing, make sure it's not bigger than the screen.
    //

    GetWindowLimits(ScreenInfo, &WindowLimits);
    if (WindowLimits.MaximumWindowSize.X < CONSOLE_WINDOW_SIZE_X(ScreenInfo)) {
        ScreenInfo->Window.Right -= CONSOLE_WINDOW_SIZE_X(ScreenInfo) - WindowLimits.MaximumWindowSize.X;
        ScreenInfo->WindowMaximizedX = (ScreenInfo->Window.Left == 0 &&
                                        (SHORT)(ScreenInfo->Window.Right+1) == ScreenInfo->ScreenBufferSize.X);
    }
    if (WindowLimits.MaximumWindowSize.Y < CONSOLE_WINDOW_SIZE_Y(ScreenInfo)) {
        ScreenInfo->Window.Bottom -= CONSOLE_WINDOW_SIZE_Y(ScreenInfo) - WindowLimits.MaximumWindowSize.Y;
        if (ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y > ScreenInfo->Window.Bottom) {
            ScreenInfo->Window.Top += ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y - ScreenInfo->Window.Bottom;
            ScreenInfo->Window.Bottom += ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y - ScreenInfo->Window.Bottom;
        }
        ScreenInfo->WindowMaximizedY = (ScreenInfo->Window.Top == 0 &&
                                        (SHORT)(ScreenInfo->Window.Bottom+1) == ScreenInfo->ScreenBufferSize.Y);
    }
    if (WindowLimits.MinimumWindowSize.X > CONSOLE_WINDOW_SIZE_X(ScreenInfo)) {
        if (WindowLimits.MinimumWindowSize.X > ScreenInfo->ScreenBufferSize.X) {
            COORD NewBufferSize;

            NewBufferSize.X = WindowLimits.MinimumWindowSize.X;
            NewBufferSize.Y = ScreenInfo->ScreenBufferSize.Y;
            ResizeScreenBuffer(ScreenInfo,
                               NewBufferSize,
                               FALSE
                              );
        }
        if ((ScreenInfo->Window.Left+WindowLimits.MinimumWindowSize.X) > ScreenInfo->ScreenBufferSize.X) {
            ScreenInfo->Window.Left = 0;
            ScreenInfo->Window.Right = WindowLimits.MinimumWindowSize.X-1;
        } else {
            ScreenInfo->Window.Right = ScreenInfo->Window.Left+WindowLimits.MinimumWindowSize.X-1;
        }
        ScreenInfo->WindowMaximizedX = (ScreenInfo->Window.Left == 0 &&
                                        (SHORT)(ScreenInfo->Window.Right+1) == ScreenInfo->ScreenBufferSize.X);
    }

    SetLineChar(ScreenInfo);
    {
        COORD WindowedWindowSize;

        WindowedWindowSize.X = CONSOLE_WINDOW_SIZE_X(ScreenInfo);
        WindowedWindowSize.Y = CONSOLE_WINDOW_SIZE_Y(ScreenInfo);


#if defined(FE_IME)
        if (CONSOLE_IS_DBCS_OUTPUTCP(ScreenInfo->Console))
        {
            PCONVERSIONAREA_INFORMATION ConvAreaInfo;

            ConvAreaInfo = ScreenInfo->Console->ConsoleIme.ConvAreaRoot;
            while (ConvAreaInfo) {

                Status = StoreTextBufferFontInfo(ConvAreaInfo->ScreenBuffer,
                                                 SCR_FONTNUMBER(ScreenInfo),
                                                 SCR_FONTSIZE(ScreenInfo),
                                                 SCR_FAMILY(ScreenInfo),
                                                 SCR_FONTWEIGHT(ScreenInfo),
                                                 SCR_FACENAME(ScreenInfo),
                                                 SCR_FONTCODEPAGE(ScreenInfo));
                if (!NT_SUCCESS(Status)) {
                    return((ULONG) Status);
                }

                ConvAreaInfo->ScreenBuffer->Window = ScreenInfo->Window;
                ConvAreaInfo->ScreenBuffer->BufferInfo.TextInfo.ModeIndex = ScreenInfo->BufferInfo.TextInfo.ModeIndex;

                ConvAreaInfo = ConvAreaInfo->ConvAreaNext;
            }
        }
#endif // FE_IME
    }

    //
    // resize window.  this will take care of the scroll bars too.
    //

    if (ACTIVE_SCREEN_BUFFER(ScreenInfo)) {
        SetWindowSize(ScreenInfo);
    }

    //
    // adjust cursor size.
    //

    SetCursorInformation(ScreenInfo,
                         ScreenInfo->BufferInfo.TextInfo.CursorSize,
                         (BOOLEAN)ScreenInfo->BufferInfo.TextInfo.CursorVisible
                        );

    WriteToScreen(ScreenInfo,
                  &ScreenInfo->Window);
    return STATUS_SUCCESS;
}


NTSTATUS
SetFont(
    IN OUT PSCREEN_INFORMATION ScreenInfo
    )
{
    if (ACTIVE_SCREEN_BUFFER(ScreenInfo)) {
        int FontIndex = FindCreateFont(SCR_FAMILY(ScreenInfo),
                                       SCR_FACENAME(ScreenInfo),
                                       SCR_FONTSIZE(ScreenInfo),
                                       SCR_FONTWEIGHT(ScreenInfo),
                                       SCR_FONTCODEPAGE(ScreenInfo));
        if (SelectObject(ScreenInfo->Console->hDC,FontInfo[FontIndex].hFont)==0)
            return STATUS_INVALID_PARAMETER;

        if ((DWORD)FontIndex != SCR_FONTNUMBER(ScreenInfo)) {
            NTSTATUS Status;
            Status = StoreTextBufferFontInfo(ScreenInfo,
                                             FontIndex,
                                             FontInfo[FontIndex].Size,
                                             FontInfo[FontIndex].Family,
                                             FontInfo[FontIndex].Weight,
                                             FontInfo[FontIndex].FaceName,
                                             ScreenInfo->Console->OutputCP);
            if (!NT_SUCCESS(Status)) {
                return((ULONG) Status);
            }
        }

        // hack to get text realized into DC.  this is to force the
        // attribute cache to get flushed to the server side, since
        // we select the font with a client side DC and call ExtTextOut
        // with a server side DC.
        // we then need to reset the text color, since the incorrect
        // client side color has been flushed to the server.
        {
        TEXTMETRIC tmi;

        GetTextMetricsW( ScreenInfo->Console->hDC, &tmi);
        ASSERT ((tmi.tmPitchAndFamily & 1) == 0);
        ScreenInfo->Console->LastAttributes = ScreenInfo->Attributes;
        SetTextColor(ScreenInfo->Console->hDC,ConvertAttrToRGB(ScreenInfo->Console, LOBYTE(ScreenInfo->Attributes)));
        SetBkColor(ScreenInfo->Console->hDC,ConvertAttrToRGB(ScreenInfo->Console, LOBYTE(ScreenInfo->Attributes >> 4)));
        }
    }
    return STATUS_SUCCESS;
}

int
ConvertToOem(
    IN UINT Codepage,
    IN LPWSTR Source,
    IN int SourceLength,    // in chars
    OUT LPSTR Target,
    IN int TargetLength     // in chars
    )
{
    DBGCHARS(("ConvertToOem U->%d %.*ls\n", Codepage,
            SourceLength > 10 ? 10 : SourceLength, Source));
    if (Codepage == OEMCP) {
        ULONG Length;
        NTSTATUS Status;

        Status = RtlUnicodeToOemN(Target,
                                  TargetLength,
                                  &Length,
                                  Source,
                                  SourceLength * sizeof(WCHAR)
                                 );
        if (!NT_SUCCESS(Status)) {
            return 0;
        } else {
            return Length;
        }
    } else {
        return WideCharToMultiByte(Codepage,
                                   0,
                                   Source,
                                   SourceLength,
                                   Target,
                                   TargetLength,
                                   NULL,
                                   NULL);
    }
}

int
ConvertInputToUnicode(
    IN UINT Codepage,
    IN LPSTR Source,
    IN int SourceLength,    // in chars
    OUT LPWSTR Target,
    IN int TargetLength     // in chars
    )
/*
    data in the output buffer is the true unicode value
*/
{
    DBGCHARS(("ConvertInputToUnicode %d->U %.*s\n", Codepage,
            SourceLength > 10 ? 10 : SourceLength, Source));
    if (Codepage == OEMCP) {
        ULONG Length;
        NTSTATUS Status;

        Status = RtlOemToUnicodeN(Target,
                                  TargetLength * sizeof(WCHAR),
                                  &Length,
                                  Source,
                                  SourceLength
                                 );
        if (!NT_SUCCESS(Status)) {
            return 0;
        } else {
            return Length / sizeof(WCHAR);
        }
    } else {
        return MultiByteToWideChar(Codepage,
                                   0,
                                   Source,
                                   SourceLength,
                                   Target,
                                   TargetLength);
    }
}

int
ConvertOutputToUnicode(
    IN UINT Codepage,
    IN LPSTR Source,
    IN int SourceLength,    // in chars
    OUT LPWSTR Target,
    IN int TargetLength     // in chars
    )
/*
    output data is always translated via the ansi codepage
    so glyph translation works.
*/

{
    NTSTATUS Status;
    ULONG Length;
    CHAR StackBuffer[STACK_BUFFER_SIZE];
    LPSTR pszT;

    DBGCHARS(("ConvertOutputToUnicode %d->U %.*s\n", Codepage,
            SourceLength > 10 ? 10 : SourceLength, Source));
    if (Codepage == OEMCP) {
        Status = RtlCustomCPToUnicodeN(&GlyphCP,
                           Target,
                           TargetLength * sizeof(WCHAR),
                           &Length,
                           Source,
                           SourceLength
                          );
        if (!NT_SUCCESS(Status)) {
            return 0;
        } else {
            return Length / sizeof(WCHAR);
        }
    }

    if (TargetLength > STACK_BUFFER_SIZE) {
        pszT = (LPSTR)ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ),SourceLength);
        if (pszT == NULL) {
            return 0;
        }
    } else {
        pszT = StackBuffer;
    }
    RtlCopyMemory(pszT, Source, SourceLength);
    Length = MultiByteToWideChar(Codepage, MB_USEGLYPHCHARS,
            pszT, SourceLength, Target, TargetLength);
    if (pszT != StackBuffer) {
        ConsoleHeapFree(pszT);
    }
    return Length;
}

#if defined(FE_SB)
WCHAR
SB_CharToWcharGlyph(
    IN UINT Codepage,
    IN char Ch)
#else
WCHAR
CharToWcharGlyph(
    IN UINT Codepage,
    IN char Ch)
#endif
{
    WCHAR wch = UNICODE_NULL;
    if (Codepage == OEMCP) {
        RtlCustomCPToUnicodeN(&GlyphCP, &wch, sizeof(wch), NULL, &Ch, sizeof(Ch));
    } else {
        MultiByteToWideChar(Codepage, MB_USEGLYPHCHARS, &Ch, 1, &wch, 1);
    }
#ifdef DEBUG_PRINT
    if (Ch > 0x7F) {
        DBGCHARS(("CharToWcharGlyph %d 0x%02x -> 0x%04x\n",Codepage,(UCHAR)Ch,wch));
    }
#endif
    return wch;
}

#if defined(FE_SB)
WCHAR
SB_CharToWchar(
    IN UINT Codepage,
    IN char Ch)
#else
WCHAR
CharToWchar(
    IN UINT Codepage,
    IN char Ch)
#endif
{
    WCHAR wch = UNICODE_NULL;
    if (Codepage == OEMCP) {
        RtlOemToUnicodeN(&wch, sizeof(wch), NULL, &Ch, sizeof(Ch));
    } else {
        MultiByteToWideChar(Codepage, 0, &Ch, 1, &wch, 1);
    }
#ifdef DEBUG_PRINT
    if (Ch > 0x7F) {
        DBGCHARS(("CharToWchar %d 0x%02x -> 0x%04x\n",Codepage,(UCHAR)Ch,wch));
    }
#endif
    return wch;
}

char
WcharToChar(
    IN UINT Codepage,
    IN WCHAR Wchar)
{
    char ch = CHAR_NULL;
    if (Codepage == OEMCP) {
        RtlUnicodeToOemN(&ch, sizeof(ch), NULL, &Wchar, sizeof(Wchar));
    } else {
        WideCharToMultiByte(Codepage, 0, &Wchar, 1, &ch, 1, NULL, NULL);
    }
#ifdef DEBUG_PRINT
    if (Wchar > 0x007F) {
        DBGCHARS(("WcharToChar %d 0x%04x -> 0x%02x\n",Codepage,Wchar,(UCHAR)ch));
    }
#endif
    return ch;
}

int
ConvertOutputToOem(
    IN UINT Codepage,
    IN LPWSTR Source,
    IN int SourceLength,    // in chars
    OUT LPSTR Target,
    IN int TargetLength     // in chars
    )
/*
    Converts SourceLength Unicode characters from Source into
    not more than TargetLength Codepage characters at Target.
    Returns the number characters put in Target. (0 if failure)
*/

{
    if (Codepage == OEMCP) {
        NTSTATUS Status;
        ULONG Length;
        // Can do this in place
        Status = RtlUnicodeToOemN(Target,
                                  TargetLength,
                                  &Length,
                                  Source,
                                  SourceLength * sizeof(WCHAR)
                                 );
        if (NT_SUCCESS(Status)) {
            return Length;
        } else {
            return 0;
        }
    } else {
        ASSERT (Source != (LPWSTR)Target);
#ifdef SOURCE_EQ_TARGET
        LPSTR pszDestTmp;
        CHAR StackBuffer[STACK_BUFFER_SIZE];

        DBGCHARS(("ConvertOutputToOem U->%d %.*ls\n", Codepage,
                SourceLength > 10 ? 10 : SourceLength, Source));

        if (TargetLength > STACK_BUFFER_SIZE) {
            pszDestTmp = (LPSTR)ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ),TargetLength);
            if (pszDestTmp == NULL) {
                return 0;
            }
        } else {
            pszDestTmp = StackBuffer;
        }
        TargetLength = WideCharToMultiByte(Codepage, 0,
                Source, SourceLength,
                pszDestTmp, TargetLength, NULL, NULL);

        RtlCopyMemory(Target, pszDestTmp, TargetLength);
        if (pszDestTmp != StackBuffer) {
            ConsoleHeapFree(pszDestTmp);
        }
        return TargetLength;
#else
        DBGCHARS(("ConvertOutputToOem U->%d %.*ls\n", Codepage,
                SourceLength > 10 ? 10 : SourceLength, Source));
        return WideCharToMultiByte(Codepage, 0,
                Source, SourceLength, Target, TargetLength, NULL, NULL);
#endif
    }
}

NTSTATUS
RealUnicodeToFalseUnicode(
    IN OUT LPWSTR Source,
    IN int SourceLength,     // in chars
    IN UINT Codepage
    )

/*

    this routine converts a unicode string into the correct characters
    for an OEM (cp 437) font.  this code is needed because the gdi glyph
    mapper converts unicode to ansi using codepage 1252 to index
    font.  this is how the data is stored internally.

*/

{
    NTSTATUS Status;
    LPSTR Temp;
    ULONG TempLength;
    ULONG Length;
    CHAR StackBuffer[STACK_BUFFER_SIZE];
    BOOL NormalChars;
    int i;

    DBGCHARS(("RealUnicodeToFalseUnicode U->%d:ACP->U %.*ls\n", Codepage,
            SourceLength > 10 ? 10 : SourceLength, Source));
#if defined(FE_SB)
    if (OEMCP == WINDOWSCP && Codepage == WINDOWSCP)
        return STATUS_SUCCESS;
    if (SourceLength == 0 )
        return STATUS_SUCCESS;
#endif
    NormalChars = TRUE;
    for (i=0;i<SourceLength;i++) {
        if (Source[i] > 0x7f) {
            NormalChars = FALSE;
            break;
        }
    }
    if (NormalChars) {
        return STATUS_SUCCESS;
    }
    TempLength = SourceLength;
    if (TempLength > STACK_BUFFER_SIZE) {
        Temp = (LPSTR)ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ),TempLength);
        if (Temp == NULL) {
            return STATUS_NO_MEMORY;
        }
    } else {
        Temp = StackBuffer;
    }
    if (Codepage == OEMCP) {
        Status = RtlUnicodeToOemN(Temp,
                                  TempLength,
                                  &Length,
                                  Source,
                                  SourceLength * sizeof(WCHAR)
                                 );
    } else {
        Status = WideCharToMultiByte(Codepage,
                                   0,
                                   Source,
                                   SourceLength,
                                   Temp,
                                   TempLength,
                                   NULL,
                                   NULL);
    }
    if (!NT_SUCCESS(Status)) {
        if (TempLength > STACK_BUFFER_SIZE) {
            ConsoleHeapFree(Temp);
        }
        return Status;
    }

    if (CONSOLE_IS_DBCS_ENABLED()) {
        MultiByteToWideChar(USACP,
                        0,
                        Temp,
                        TempLength,
                        Source,
                        SourceLength
                       );
    } else {
        Status = RtlMultiByteToUnicodeN(Source,
                           SourceLength * sizeof(WCHAR),
                           &Length,
                           Temp,
                           TempLength
                          );
    }

    if (TempLength > STACK_BUFFER_SIZE) {
        ConsoleHeapFree(Temp);
    }
    if (!NT_SUCCESS(Status)) {
        return Status;
    } else {
        return STATUS_SUCCESS;
    }
}

NTSTATUS
FalseUnicodeToRealUnicode(
    IN OUT LPWSTR Source,
    IN int SourceLength,     // in chars
    IN UINT Codepage
    )

/*

    this routine converts a unicode string from the internally stored
    unicode characters into the real unicode characters.

*/

{
    NTSTATUS Status;
    LPSTR Temp;
    ULONG TempLength;
    ULONG Length;
    CHAR StackBuffer[STACK_BUFFER_SIZE];
    BOOL NormalChars;
    int i;

    DBGCHARS(("UnicodeAnsiToUnicodeAnsi U->ACP:%d->U %.*ls\n", Codepage,
            SourceLength > 10 ? 10 : SourceLength, Source));
#if defined(FE_SB)
    if (OEMCP == WINDOWSCP && Codepage == WINDOWSCP)
        return STATUS_SUCCESS;
    if (SourceLength == 0 )
        return STATUS_SUCCESS;
#endif
    NormalChars = TRUE;
    /*
     * Test for characters < 0x20 or >= 0x7F.  If none are found, we don't have
     * any conversion to do!
     */
    for (i=0;i<SourceLength;i++) {
        if ((USHORT)(Source[i] - 0x20) > 0x5e) {
            NormalChars = FALSE;
            break;
        }
    }
    if (NormalChars) {
        return STATUS_SUCCESS;
    }

    TempLength = SourceLength;
    if (TempLength > STACK_BUFFER_SIZE) {
        Temp = (LPSTR)ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ),TempLength);
        if (Temp == NULL) {
            return STATUS_NO_MEMORY;
        }
    } else {
        Temp = StackBuffer;
    }
    if (CONSOLE_IS_DBCS_ENABLED()) {
        Status = WideCharToMultiByte(USACP,
                                 0,
                                 Source,
                                 SourceLength,
                                 Temp,
                                 TempLength,
                                 NULL,
                                 NULL);
    } else {
        Status = RtlUnicodeToMultiByteN(Temp,
                                    TempLength,
                                    &Length,
                                    Source,
                                    SourceLength * sizeof(WCHAR)
                                   );
    }

    if (!NT_SUCCESS(Status)) {
        if (TempLength > STACK_BUFFER_SIZE) {
            ConsoleHeapFree(Temp);
        }
        return Status;
    }
    if (Codepage == OEMCP) {
        Status = RtlCustomCPToUnicodeN(&GlyphCP,
                                  Source,
                                  SourceLength * sizeof(WCHAR),
                                  &Length,
                                  Temp,
                                  TempLength
                                 );
    } else {
        Status = MultiByteToWideChar(Codepage,
                                   MB_USEGLYPHCHARS,
                                   Temp,
                                   TempLength*sizeof(WCHAR),
                                   Source,
                                   SourceLength);
    }
#if defined(FE_SB)
    if (SourceLength > STACK_BUFFER_SIZE) {
        ConsoleHeapFree(Temp);
    }
#else
    if (TempLength > STACK_BUFFER_SIZE) {
        ConsoleHeapFree(Temp);
    }
#endif
    if (!NT_SUCCESS(Status)) {
        return Status;
    } else {
        return STATUS_SUCCESS;
    }
}


BOOL InitializeCustomCP() {
    PPEB pPeb;

    pPeb = NtCurrentPeb();
    if ((pPeb == NULL) || (pPeb->OemCodePageData == NULL)) {
        return FALSE;
    }

    /*
     * Fill in the CPTABLEINFO struct
     */
    RtlInitCodePageTable(pPeb->OemCodePageData, &GlyphCP);

    /*
     * Make a copy of the MultiByteToWideChar table
     */
    RtlCopyMemory(GlyphTable, GlyphCP.MultiByteTable, 256 * sizeof(USHORT));

    /*
     * Modify the first 0x20 bytes so that they are glyphs.
     */
    MultiByteToWideChar(CP_OEMCP, MB_USEGLYPHCHARS,
            "\x20\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F"
            "\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F",
            0x20, GlyphTable, 0x20);
    MultiByteToWideChar(CP_OEMCP, MB_USEGLYPHCHARS,
            "\x7f", 1, &GlyphTable[0x7f], 1);


    /*
     * Point the Custom CP at the glyph table
     */
    GlyphCP.MultiByteTable = GlyphTable;

#if defined(FE_SB) && defined(i386)
    if (ISNECPC98(gdwMachineId)) {
        InitializeNEC_OS2_CP();
    }
#endif
    return TRUE;
}

#if defined(FE_SB)
VOID
SetConsoleCPInfo(
    IN PCONSOLE_INFORMATION Console,
    IN BOOL Output
    )
{
    if (Output) {
        if (! GetCPInfo(Console->OutputCP,
                        &Console->OutputCPInfo)) {
            Console->OutputCPInfo.LeadByte[0] = 0;
        }
    }
    else {
        if (! GetCPInfo(Console->CP,
                        &Console->CPInfo)) {
            Console->CPInfo.LeadByte[0] = 0;
        }
    }
}

BOOL
CheckBisectStringW(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN DWORD CodePage,
    IN PWCHAR Buffer,
    IN DWORD NumWords,
    IN DWORD NumBytes
    )

/*++

Routine Description:

    This routine check bisected on Unicode string end.

Arguments:

    ScreenInfo - Pointer to screen information structure.

    CodePage - Value of code page.

    Buffer - Pointer to Unicode string buffer.

    NumWords - Number of Unicode string.

    NumBytes - Number of bisect position by byte counts.

Return Value:

    TRUE - Bisected character.

    FALSE - Correctly.

--*/

{
    while(NumWords && NumBytes) {
        if (IsConsoleFullWidth(ScreenInfo->Console->hDC,CodePage,*Buffer)) {
            if (NumBytes < 2)
                return TRUE;
            else {
                NumWords--;
                NumBytes -= 2;
                Buffer++;
            }
        }
        else {
            NumWords--;
            NumBytes--;
            Buffer++;
        }
    }
    return FALSE;
}

BOOL
CheckBisectProcessW(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN DWORD CodePage,
    IN PWCHAR Buffer,
    IN DWORD NumWords,
    IN DWORD NumBytes,
    IN SHORT OriginalXPosition,
    IN BOOL Echo
    )

/*++

Routine Description:

    This routine check bisected on Unicode string end.

Arguments:

    ScreenInfo - Pointer to screen information structure.

    CodePage - Value of code page.

    Buffer - Pointer to Unicode string buffer.

    NumWords - Number of Unicode string.

    NumBytes - Number of bisect position by byte counts.

    Echo - TRUE if called by Read (echoing characters)

Return Value:

    TRUE - Bisected character.

    FALSE - Correctly.

--*/

{
    WCHAR Char;
    ULONG TabSize;

    if (ScreenInfo->OutputMode & ENABLE_PROCESSED_OUTPUT) {
        while(NumWords && NumBytes) {
            Char = *Buffer;
            if (Char >= (WCHAR)' ') {
                if (IsConsoleFullWidth(ScreenInfo->Console->hDC,CodePage,Char)) {
                    if (NumBytes < 2)
                        return TRUE;
                    else {
                        NumWords--;
                        NumBytes -= 2;
                        Buffer++;
                        OriginalXPosition += 2;
                    }
                }
                else {
                    NumWords--;
                    NumBytes--;
                    Buffer++;
                    OriginalXPosition++;
                }
            }
            else {
                NumWords--;
                Buffer++;
                switch (Char) {
                    case UNICODE_BELL:
                        if (Echo)
                            goto CtrlChar;
                        break;
                    case UNICODE_BACKSPACE:
                    case UNICODE_LINEFEED:
                    case UNICODE_CARRIAGERETURN:
                        break;
                    case UNICODE_TAB:
                        TabSize = NUMBER_OF_SPACES_IN_TAB(OriginalXPosition);
                        OriginalXPosition = (SHORT)(OriginalXPosition + TabSize);
                        if (NumBytes < TabSize)
                            return TRUE;
                        NumBytes -= TabSize;
                        break;
                    default:
                        if (Echo) {
                    CtrlChar:
                            if (NumBytes < 2)
                                return TRUE;
                            NumBytes -= 2;
                            OriginalXPosition += 2;
                        } else {
                            NumBytes--;
                            OriginalXPosition++;
                        }
                }
            }
        }
        return FALSE;
    }
    else {
        return CheckBisectStringW(ScreenInfo,
                                  CodePage,
                                  Buffer,
                                  NumWords,
                                  NumBytes);
    }
}
#endif // FE_SB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\server\input.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    input.c

Abstract:

        This file implements the circular buffer management for
        input events.

        The circular buffer is described by a header,
        which resides in the beginning of the memory allocated when the
        buffer is created.  The header contains all of the
        per-buffer information, such as reader, writer, and
        reference counts, and also holds the pointers into
        the circular buffer proper.

        When the in and out pointers are equal, the circular buffer
        is empty.  When the in pointer trails the out pointer
        by 1, the buffer is full.  Thus, a 512 byte buffer can hold
        only 511 bytes; one byte is lost so that full and empty
        conditions can be distinguished. So that the user can
        put 512 bytes in a buffer that they created with a size
        of 512, we allow for this byte lost when allocating
        the memory.

Author:

    Therese Stowell (thereses) 6-Nov-1990
    Adapted from OS/2 subsystem server\srvpipe.c

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#define CTRL_BUT_NOT_ALT(n) \
        (((n) & (LEFT_CTRL_PRESSED | RIGHT_CTRL_PRESSED)) && \
        !((n) & (LEFT_ALT_PRESSED | RIGHT_ALT_PRESSED)))

UINT ProgmanHandleMessage;

int DialogBoxCount;

LPTHREAD_START_ROUTINE CtrlRoutine;  // address of client side ctrl-thread routine

DWORD InputThreadTlsIndex;

#define MAX_CHARS_FROM_1_KEYSTROKE 6


//
// the following data structures are a hack to work around the fact that
// MapVirtualKey does not return the correct virtual key code in many cases.
// we store the correct info (from the keydown message) in the CONSOLE_KEY_INFO
// structure when a keydown message is translated.  then when we receive a
// wm_[sys][dead]char message, we retrieve it and clear out the record.
//

#define CONSOLE_FREE_KEY_INFO 0
#define CONSOLE_MAX_KEY_INFO 32

typedef struct _CONSOLE_KEY_INFO {
    HWND hWnd;
    WORD wVirtualKeyCode;
    WORD wVirtualScanCode;
} CONSOLE_KEY_INFO, *PCONSOLE_KEY_INFO;

CONSOLE_KEY_INFO ConsoleKeyInfo[CONSOLE_MAX_KEY_INFO];

VOID
UserExitWorkerThread(NTSTATUS Status);

BOOL
InitWindowClass( VOID );

#if !defined(FE_SB)
NTSTATUS
ReadBuffer(
    IN PINPUT_INFORMATION InputInformation,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG EventsRead,
    IN BOOL Peek,
    IN BOOL StreamRead,
    OUT PBOOL ResetWaitEvent
    );
#endif

NTSTATUS
CreateInputBuffer(
    IN ULONG NumberOfEvents OPTIONAL,
    IN PINPUT_INFORMATION InputBufferInformation
#if defined(FE_SB)
    ,
    IN PCONSOLE_INFORMATION Console
#endif
    )

/*++

Routine Description:

    This routine creates an input buffer.  It allocates the circular
    buffer and initializes the information fields.

Arguments:

    NumberOfEvents - Size of input buffer in events.

    InputBufferInformation - Pointer to input buffer information structure.

Return Value:


--*/

{
    ULONG BufferSize;
    NTSTATUS Status;

    if (NumberOfEvents == 0) {
        NumberOfEvents = DEFAULT_NUMBER_OF_EVENTS;
    }

    // allocate memory for circular buffer

    BufferSize =  sizeof(INPUT_RECORD) * (NumberOfEvents+1);
    InputBufferInformation->InputBuffer = (PINPUT_RECORD)ConsoleHeapAlloc(MAKE_TAG( BUFFER_TAG ),BufferSize);
    if (InputBufferInformation->InputBuffer == NULL) {
        return STATUS_NO_MEMORY;
    }
    Status = NtCreateEvent(&InputBufferInformation->InputWaitEvent,
                           EVENT_ALL_ACCESS, NULL, NotificationEvent, FALSE);
    if (!NT_SUCCESS(Status)) {
        ConsoleHeapFree(InputBufferInformation->InputBuffer);
        return STATUS_NO_MEMORY;
    }
    InitializeListHead(&InputBufferInformation->ReadWaitQueue);

    // initialize buffer header

    InputBufferInformation->InputBufferSize = NumberOfEvents;
    InputBufferInformation->ShareAccess.OpenCount = 0;
    InputBufferInformation->ShareAccess.Readers = 0;
    InputBufferInformation->ShareAccess.Writers = 0;
    InputBufferInformation->ShareAccess.SharedRead = 0;
    InputBufferInformation->ShareAccess.SharedWrite = 0;
    InputBufferInformation->InputMode = ENABLE_LINE_INPUT | ENABLE_PROCESSED_INPUT | ENABLE_ECHO_INPUT | ENABLE_MOUSE_INPUT;
    InputBufferInformation->AllocatedBufferSize = BufferSize;
    InputBufferInformation->RefCount = 0;
    InputBufferInformation->First = (ULONG_PTR) InputBufferInformation->InputBuffer;
    InputBufferInformation->In = (ULONG_PTR) InputBufferInformation->InputBuffer;
    InputBufferInformation->Out = (ULONG_PTR) InputBufferInformation->InputBuffer;
    InputBufferInformation->Last = (ULONG_PTR) InputBufferInformation->InputBuffer + BufferSize;
#if defined(FE_SB)
#if defined(FE_IME)
    InputBufferInformation->ImeMode.Disable     = FALSE;
    InputBufferInformation->ImeMode.Unavailable = FALSE;
    InputBufferInformation->ImeMode.Open        = FALSE;
    InputBufferInformation->ImeMode.ReadyConversion = FALSE;
#endif // FE_IME
    InputBufferInformation->Console = Console;
    RtlZeroMemory(&InputBufferInformation->ReadConInpDbcsLeadByte,sizeof(INPUT_RECORD));
    RtlZeroMemory(&InputBufferInformation->WriteConInpDbcsLeadByte,sizeof(INPUT_RECORD));
#endif

    return STATUS_SUCCESS;
}

NTSTATUS
ReinitializeInputBuffer(
    OUT PINPUT_INFORMATION InputBufferInformation
    )

/*++

Routine Description:

    This routine resets the input buffer information fields to their
    initial values.

Arguments:

    InputBufferInformation - Pointer to input buffer information structure.

Return Value:

Note:

    The console lock must be held when calling this routine.

--*/

{
    NtClearEvent(InputBufferInformation->InputWaitEvent);
    InputBufferInformation->ShareAccess.OpenCount = 0;
    InputBufferInformation->ShareAccess.Readers = 0;
    InputBufferInformation->ShareAccess.Writers = 0;
    InputBufferInformation->ShareAccess.SharedRead = 0;
    InputBufferInformation->ShareAccess.SharedWrite = 0;
    InputBufferInformation->InputMode = ENABLE_LINE_INPUT | ENABLE_PROCESSED_INPUT  | ENABLE_ECHO_INPUT | ENABLE_MOUSE_INPUT;
    InputBufferInformation->In = (ULONG_PTR) InputBufferInformation->InputBuffer;
    InputBufferInformation->Out = (ULONG_PTR) InputBufferInformation->InputBuffer;
    return STATUS_SUCCESS;
}

VOID
FreeInputBuffer(
    IN PINPUT_INFORMATION InputBufferInformation
    )

/*++

Routine Description:

    This routine frees the resources associated with an input buffer.

Arguments:

    InputBufferInformation - Pointer to input buffer information structure.

Return Value:


--*/

{
    ASSERT(InputBufferInformation->RefCount == 0);
    CloseHandle(InputBufferInformation->InputWaitEvent);
    ConsoleHeapFree(InputBufferInformation->InputBuffer);
}

NTSTATUS
WaitForMoreToRead(
    IN PINPUT_INFORMATION InputInformation,
    IN PCSR_API_MSG Message OPTIONAL,
    IN CSR_WAIT_ROUTINE WaitRoutine OPTIONAL,
    IN PVOID WaitParameter OPTIONAL,
    IN ULONG WaitParameterLength  OPTIONAL,
    IN BOOLEAN WaitBlockExists OPTIONAL
    )

/*++

Routine Description:

    This routine waits for a writer to add data to the buffer.

Arguments:

    InputInformation - buffer to wait for

    Console - Pointer to console buffer information.

    Message - if called from dll (not InputThread), points to api
    message.  this parameter is used for wait block processing.

    WaitRoutine - Routine to call when wait is woken up.

    WaitParameter - Parameter to pass to wait routine.

    WaitParameterLength - Length of wait parameter.

    WaitBlockExists - TRUE if wait block has already been created.

Return Value:

    STATUS_WAIT - call was from client and wait block has been created.

    STATUS_SUCCESS - call was from server and wait has been satisfied.

--*/

{
    PVOID WaitParameterBuffer;

    if (!WaitBlockExists) {
        WaitParameterBuffer = (PVOID)ConsoleHeapAlloc(MAKE_TAG( WAIT_TAG ),WaitParameterLength);
        if (WaitParameterBuffer == NULL) {
            return STATUS_NO_MEMORY;
        }
        RtlCopyMemory(WaitParameterBuffer,WaitParameter,WaitParameterLength);
#if defined(FE_SB)
        if (WaitParameterLength == sizeof(COOKED_READ_DATA) &&
            InputInformation->Console->lpCookedReadData == WaitParameter) {
            InputInformation->Console->lpCookedReadData = WaitParameterBuffer;
        }
#endif
        if (!CsrCreateWait(&InputInformation->ReadWaitQueue,
                          WaitRoutine,
                          CSR_SERVER_QUERYCLIENTTHREAD(),
                          Message,
                          WaitParameterBuffer,
                          NULL
                         )) {
            ConsoleHeapFree(WaitParameterBuffer);
#if defined(FE_SB)
            InputInformation->Console->lpCookedReadData = NULL;
#endif
            return STATUS_NO_MEMORY;
        }
    }
    return CONSOLE_STATUS_WAIT;
}

VOID
WakeUpReadersWaitingForData(
    IN PCONSOLE_INFORMATION Console,
    PINPUT_INFORMATION InputInformation
    )

/*++

Routine Description:

    This routine wakes up readers waiting for data to read.

Arguments:

    InputInformation - buffer to alert readers for

Return Value:

    TRUE - The operation was successful

    FALSE/NULL - The operation failed.

--*/

{
    BOOLEAN WaitSatisfied;
    WaitSatisfied = CsrNotifyWait(&InputInformation->ReadWaitQueue,
                  FALSE,
                  NULL,
                  NULL
                 );
    if (WaitSatisfied) {
        // #334370 under stress, WaitQueue may already hold the satisfied waits
        ASSERT ((Console->WaitQueue == NULL) ||
                (Console->WaitQueue == &InputInformation->ReadWaitQueue));
        Console->WaitQueue = &InputInformation->ReadWaitQueue;
    }
}

NTSTATUS
GetNumberOfReadyEvents(
    IN PINPUT_INFORMATION InputInformation,
    OUT PULONG NumberOfEvents
    )

/*++

Routine Description:

    This routine returns the number of events in the input buffer.

Arguments:

    InputInformation - Pointer to input buffer information structure.

    NumberOfEvents - On output contains the number of events.

Return Value:

Note:

    The console lock must be held when calling this routine.

--*/

{
    if (InputInformation->In < InputInformation->Out) {
        *NumberOfEvents = (ULONG)(InputInformation->Last - InputInformation->Out);
        *NumberOfEvents += (ULONG)(InputInformation->In - InputInformation->First);
    }
    else {
        *NumberOfEvents = (ULONG)(InputInformation->In - InputInformation->Out);
    }
    *NumberOfEvents /= sizeof(INPUT_RECORD);

    return STATUS_SUCCESS;
}

NTSTATUS
FlushAllButKeys(
    PINPUT_INFORMATION InputInformation
    )

/*++

Routine Description:

    This routine removes all but the key events from the buffer.

Arguments:

    InputInformation - Pointer to input buffer information structure.

Return Value:

Note:

    The console lock must be held when calling this routine.

--*/

{
    ULONG NumberOfEventsRead,i;
    NTSTATUS Status;
    PINPUT_RECORD TmpInputBuffer,InPtr,TmpInputBufferPtr;
    ULONG BufferSize;
    BOOL Dummy;

    if (InputInformation->In != InputInformation->Out)  {

        //
        // allocate memory for temp buffer
        //

        BufferSize =  sizeof(INPUT_RECORD) * (InputInformation->InputBufferSize+1);
        TmpInputBuffer = (PINPUT_RECORD)ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ),BufferSize);
        if (TmpInputBuffer == NULL) {
            return STATUS_NO_MEMORY;
        }
        TmpInputBufferPtr = TmpInputBuffer;

        //
        // copy input buffer.
        // let ReadBuffer do any compaction work.
        //

        Status = ReadBuffer(InputInformation,
                            TmpInputBuffer,
                            InputInformation->InputBufferSize,
                            &NumberOfEventsRead,
                            TRUE,
                            FALSE,
                            &Dummy
#if defined(FE_SB)
                            ,
                            TRUE
#endif
                           );

        if (!NT_SUCCESS(Status)) {
            ConsoleHeapFree(TmpInputBuffer);
            return Status;
        }

        InputInformation->Out = (ULONG_PTR) InputInformation->InputBuffer;
        InPtr = InputInformation->InputBuffer;
        for (i=0;i<NumberOfEventsRead;i++) {
            if (TmpInputBuffer->EventType == KEY_EVENT) {
                *InPtr = *TmpInputBuffer;
                InPtr++;
            }
            TmpInputBuffer++;
        }
        InputInformation->In = (ULONG_PTR) InPtr;
        if (InputInformation->In == InputInformation->Out) {
            NtClearEvent(InputInformation->InputWaitEvent);
        }
        ConsoleHeapFree(TmpInputBufferPtr);
    }
    return STATUS_SUCCESS;
}

NTSTATUS
FlushInputBuffer(
    PINPUT_INFORMATION InputInformation
    )

/*++

Routine Description:

    This routine empties the input buffer

Arguments:

    InputInformation - Pointer to input buffer information structure.

Return Value:

Note:

    The console lock must be held when calling this routine.

--*/

{
    InputInformation->In = (ULONG_PTR) InputInformation->InputBuffer;
    InputInformation->Out = (ULONG_PTR) InputInformation->InputBuffer;
    NtClearEvent(InputInformation->InputWaitEvent);
    return STATUS_SUCCESS;
}


NTSTATUS
SetInputBufferSize(
    IN PINPUT_INFORMATION InputInformation,
    IN ULONG Size
    )

/*++

Routine Description:

    This routine resizes the input buffer.

Arguments:

    InputInformation - Pointer to input buffer information structure.

    Size - New size in number of events.

Return Value:

Note:

    The console lock must be held when calling this routine.

--*/

{
    ULONG NumberOfEventsRead;
    NTSTATUS Status;
    PINPUT_RECORD InputBuffer;
    ULONG BufferSize;
    BOOL Dummy;

#if DBG
    ULONG_PTR NumberOfEvents;
    if (InputInformation->In < InputInformation->Out) {
        NumberOfEvents = InputInformation->Last - InputInformation->Out;
        NumberOfEvents += InputInformation->In - InputInformation->First;
    }
    else {
        NumberOfEvents = InputInformation->In - InputInformation->Out;
    }
    NumberOfEvents /= sizeof(INPUT_RECORD);
#endif
    ASSERT( Size > InputInformation->InputBufferSize );

    //
    // allocate memory for new input buffer
    //

    BufferSize =  sizeof(INPUT_RECORD) * (Size+1);
    InputBuffer = (PINPUT_RECORD)ConsoleHeapAlloc(MAKE_TAG( BUFFER_TAG ),BufferSize);
    if (InputBuffer == NULL) {
        return STATUS_NO_MEMORY;
    }

    //
    // copy old input buffer.
    // let the ReadBuffer do any compaction work.
    //

    Status = ReadBuffer(InputInformation,
                        InputBuffer,
                        Size,
                        &NumberOfEventsRead,
                        TRUE,
                        FALSE,
                        &Dummy
#if defined(FE_SB)
                        ,
                        TRUE
#endif
                       );

    if (!NT_SUCCESS(Status)) {
        ConsoleHeapFree(InputBuffer);
        return Status;
    }
    InputInformation->Out = (ULONG_PTR)InputBuffer;
    InputInformation->In = (ULONG_PTR)InputBuffer + sizeof(INPUT_RECORD) * NumberOfEventsRead;

    //
    // adjust pointers
    //

    InputInformation->First = (ULONG_PTR) InputBuffer;
    InputInformation->Last = (ULONG_PTR) InputBuffer + BufferSize;

    //
    // free old input buffer
    //

    ConsoleHeapFree(InputInformation->InputBuffer);
    InputInformation->InputBufferSize = Size;
    InputInformation->AllocatedBufferSize = BufferSize;
    InputInformation->InputBuffer = InputBuffer;
    return Status;
}


NTSTATUS
ReadBuffer(
    IN PINPUT_INFORMATION InputInformation,
    OUT PVOID Buffer,
    IN ULONG Length,
    OUT PULONG EventsRead,
    IN BOOL Peek,
    IN BOOL StreamRead,
    OUT PBOOL ResetWaitEvent
#ifdef FE_SB
    , IN BOOLEAN Unicode
#endif
    )
/*++

Routine Description:

    This routine reads from a buffer.  It does the actual circular buffer
    manipulation.

Arguments:

    InputInformation - buffer to read from

    Buffer - buffer to read into

    Length - length of buffer in events

    EventsRead - where to store number of events read

    Peek - if TRUE, don't remove data from buffer, just copy it.

    StreamRead - if TRUE, events with repeat counts > 1 are returned
    as multiple events.  also, EventsRead == 1.

    ResetWaitEvent - on exit, TRUE if buffer became empty.

Return Value:

    ??

Note:

    The console lock must be held when calling this routine.

--*/

{
    ULONG TransferLength,OldTransferLength;
    ULONG BufferLengthInBytes;
#ifdef FE_SB
    PCONSOLE_INFORMATION Console;
    ULONG Length2;
    PINPUT_RECORD BufferRecords;
    PINPUT_RECORD QueueRecords;
    WCHAR UniChar;
    WORD EventType;
#endif

#ifdef FE_SB
    Console = InputInformation->Console;
#endif
    *ResetWaitEvent = FALSE;

    //
    // if StreamRead, just return one record.  if repeat count is greater
    // than one, just decrement it.  the repeat count is > 1 if more than
    // one event of the same type was merged.  we need to expand them back
    // to individual events here.
    //

    if (StreamRead &&
        ((PINPUT_RECORD)(InputInformation->Out))->EventType == KEY_EVENT) {

        ASSERT(Length == 1);
        ASSERT(InputInformation->In != InputInformation->Out);
        RtlMoveMemory((PBYTE)Buffer,
                      (PBYTE)InputInformation->Out,
                      sizeof(INPUT_RECORD)
                     );
        InputInformation->Out += sizeof(INPUT_RECORD);
        if (InputInformation->Last == InputInformation->Out) {
            InputInformation->Out = InputInformation->First;
        }
        if (InputInformation->Out == InputInformation->In) {
            *ResetWaitEvent = TRUE;
        }
        *EventsRead = 1;
        return STATUS_SUCCESS;
    }

    BufferLengthInBytes = Length * sizeof(INPUT_RECORD);

    //
    // if in > out, buffer looks like this:
    //
    //         out     in
    //    ______ _____________
    //   |      |      |      |
    //   | free | data | free |
    //   |______|______|______|
    //
    // we transfer the requested number of events or the amount in the buffer
    //

    if (InputInformation->In > InputInformation->Out) {
        if  ((InputInformation->In - InputInformation->Out) > BufferLengthInBytes) {
            TransferLength = BufferLengthInBytes;
        }
        else {
            TransferLength = (ULONG)(InputInformation->In - InputInformation->Out);
        }
#ifdef FE_SB
        if (!Unicode) {
            BufferLengthInBytes = 0;
            OldTransferLength = TransferLength / sizeof(INPUT_RECORD);
            BufferRecords = (PINPUT_RECORD)Buffer;
            QueueRecords = (PINPUT_RECORD)InputInformation->Out;

            while (BufferLengthInBytes < Length &&
                   OldTransferLength) {
                UniChar = QueueRecords->Event.KeyEvent.uChar.UnicodeChar;
                EventType = QueueRecords->EventType;
                *BufferRecords++ = *QueueRecords++;
                if (EventType == KEY_EVENT) {
                    if (IsConsoleFullWidth(Console->hDC,
                                           Console->CP,
                                           UniChar)) {
                        BufferLengthInBytes += 2;
                    }
                    else {
                        BufferLengthInBytes++;
                    }
                }
                else {
                    BufferLengthInBytes++;
                }
                OldTransferLength--;
            }
            ASSERT(TransferLength >= OldTransferLength * sizeof(INPUT_RECORD));
            TransferLength -= OldTransferLength * sizeof(INPUT_RECORD);
        }
        else
#endif
        {
            RtlMoveMemory((PBYTE)Buffer,
                          (PBYTE)InputInformation->Out,
                          TransferLength
                         );
        }
        *EventsRead = TransferLength / sizeof(INPUT_RECORD);
#ifdef FE_SB
        ASSERT(*EventsRead <= Length);
#endif
        if (!Peek) {
            InputInformation->Out += TransferLength;
#ifdef FE_SB
            ASSERT(InputInformation->Out <= InputInformation->Last);
#endif
        }
        if (InputInformation->Out == InputInformation->In) {
            *ResetWaitEvent = TRUE;
        }
        return STATUS_SUCCESS;
    }

    //
    // if out > in, buffer looks like this:
    //
    //         in     out
    //    ______ _____________
    //   |      |      |      |
    //   | data | free | data |
    //   |______|______|______|
    //
    // we read from the out pointer to the end of the buffer then from the
    // beginning of the buffer, until we hit the in pointer or enough bytes
    // are read.
    //

    else {

        if  ((InputInformation->Last - InputInformation->Out) > BufferLengthInBytes) {
            TransferLength = BufferLengthInBytes;
        }
        else {
            TransferLength = (ULONG)(InputInformation->Last - InputInformation->Out);
        }
#ifdef FE_SB
        if (!Unicode) {
            BufferLengthInBytes = 0;
            OldTransferLength = TransferLength / sizeof(INPUT_RECORD);
            BufferRecords = (PINPUT_RECORD)Buffer;
            QueueRecords = (PINPUT_RECORD)InputInformation->Out;

            while (BufferLengthInBytes < Length &&
                   OldTransferLength) {
                UniChar = QueueRecords->Event.KeyEvent.uChar.UnicodeChar;
                EventType = QueueRecords->EventType;
                *BufferRecords++ = *QueueRecords++;
                if (EventType == KEY_EVENT) {
                    if (IsConsoleFullWidth(Console->hDC,
                                           Console->CP,
                                    UniChar)) {
                        BufferLengthInBytes += 2;
                    }
                    else {
                        BufferLengthInBytes++;
                    }
                }
                else {
                    BufferLengthInBytes++;
                }
                OldTransferLength--;
            }
            ASSERT(TransferLength >= OldTransferLength * sizeof(INPUT_RECORD));
            TransferLength -= OldTransferLength * sizeof(INPUT_RECORD);
        }
        else
#endif
        {
            RtlMoveMemory((PBYTE)Buffer,
                          (PBYTE)InputInformation->Out,
                          TransferLength
                         );
        }
        *EventsRead = TransferLength / sizeof(INPUT_RECORD);
#ifdef FE_SB
        ASSERT(*EventsRead <= Length);
#endif

        if (!Peek) {
            InputInformation->Out += TransferLength;
#ifdef FE_SB
            ASSERT(InputInformation->Out <= InputInformation->Last);
#endif
            if (InputInformation->Out == InputInformation->Last) {
                InputInformation->Out = InputInformation->First;
            }
        }
#ifdef FE_SB
        if (!Unicode) {
            if (BufferLengthInBytes >= Length) {
                if (InputInformation->Out == InputInformation->In) {
                    *ResetWaitEvent = TRUE;
                }
                return STATUS_SUCCESS;
            }
        }
        else
#endif
        if (*EventsRead == Length) {
            if (InputInformation->Out == InputInformation->In) {
                *ResetWaitEvent = TRUE;
            }
            return STATUS_SUCCESS;
        }

        //
        // hit end of buffer, read from beginning
        //

        OldTransferLength = TransferLength;
#ifdef FE_SB
        Length2 = Length;
        if (!Unicode) {
            ASSERT(Length > BufferLengthInBytes);
            Length -= BufferLengthInBytes;
            if (Length == 0) {
                if (InputInformation->Out == InputInformation->In) {
                    *ResetWaitEvent = TRUE;
                }
            return STATUS_SUCCESS;
            }
            BufferLengthInBytes = Length * sizeof(INPUT_RECORD);

            if ((InputInformation->In - InputInformation->First) > BufferLengthInBytes) {
                TransferLength = BufferLengthInBytes;
            }
            else {
                TransferLength = (ULONG)(InputInformation->In - InputInformation->First);
            }
        }
        else
#endif
        if  ((InputInformation->In - InputInformation->First) > (BufferLengthInBytes - OldTransferLength)) {
            TransferLength = BufferLengthInBytes - OldTransferLength;
        }
        else {
            TransferLength = (ULONG)(InputInformation->In - InputInformation->First);
        }
#ifdef FE_SB
        if (!Unicode) {
            BufferLengthInBytes = 0;
            OldTransferLength = TransferLength / sizeof(INPUT_RECORD);
            QueueRecords = (PINPUT_RECORD)InputInformation->First;

            while (BufferLengthInBytes < Length &&
                   OldTransferLength) {
                UniChar = QueueRecords->Event.KeyEvent.uChar.UnicodeChar;
                EventType = QueueRecords->EventType;
                *BufferRecords++ = *QueueRecords++;
                if (EventType == KEY_EVENT) {
                    if (IsConsoleFullWidth(Console->hDC,
                                           Console->CP,
                                    UniChar)) {
                        BufferLengthInBytes += 2;
                    }
                    else {
                        BufferLengthInBytes++;
                    }
                }
                else {
                    BufferLengthInBytes++;
                }
                OldTransferLength--;
            }
            ASSERT(TransferLength >= OldTransferLength * sizeof(INPUT_RECORD));
            TransferLength -= OldTransferLength * sizeof(INPUT_RECORD);
        }
        else
#endif
        {
            RtlMoveMemory((PBYTE)Buffer+OldTransferLength,
                          (PBYTE)InputInformation->First,
                          TransferLength
                         );
        }
        *EventsRead += TransferLength / sizeof(INPUT_RECORD);
#ifdef FE_SB
        ASSERT(*EventsRead <= Length2);
#endif
        if (!Peek) {
            InputInformation->Out = InputInformation->First + TransferLength;
        }
        if (InputInformation->Out == InputInformation->In) {
            *ResetWaitEvent = TRUE;
        }
        return STATUS_SUCCESS;
    }
}


NTSTATUS
ReadInputBuffer(
    IN PINPUT_INFORMATION InputInformation,
    OUT PINPUT_RECORD lpBuffer,
    IN OUT PDWORD nLength,
    IN BOOL Peek,
    IN BOOL WaitForData,
    IN BOOL StreamRead,
    IN PCONSOLE_INFORMATION Console,
    IN PHANDLE_DATA HandleData OPTIONAL,
    IN PCSR_API_MSG Message OPTIONAL,
    IN CSR_WAIT_ROUTINE WaitRoutine OPTIONAL,
    IN PVOID WaitParameter OPTIONAL,
    IN ULONG WaitParameterLength  OPTIONAL,
    IN BOOLEAN WaitBlockExists OPTIONAL
#if defined(FE_SB)
    ,
    IN BOOLEAN Unicode
#endif
    )

/*++

Routine Description:

    This routine reads from the input buffer.

Arguments:

    InputInformation - Pointer to input buffer information structure.

    lpBuffer - Buffer to read into.

    nLength - On input, number of events to read.  On output, number of
    events read.

    Peek - If TRUE, copy events to lpBuffer but don't remove them from
    the input buffer.

    WaitForData - if TRUE, wait until an event is input.  if FALSE, return
        immediately

    StreamRead - if TRUE, events with repeat counts > 1 are returned
    as multiple events.  also, EventsRead == 1.

    Console - Pointer to console buffer information.

    HandleData - Pointer to handle data structure.  This parameter is
    optional if WaitForData is false.

    Message - if called from dll (not InputThread), points to api
    message.  this parameter is used for wait block processing.

    WaitRoutine - Routine to call when wait is woken up.

    WaitParameter - Parameter to pass to wait routine.

    WaitParameterLength - Length of wait parameter.

    WaitBlockExists - TRUE if wait block has already been created.

Return Value:

Note:

    The console lock must be held when calling this routine.

--*/

{
    ULONG EventsRead;
    NTSTATUS Status;
    BOOL ResetWaitEvent;

    if (InputInformation->In == InputInformation->Out)  {
        if (!WaitForData) {
            *nLength = 0;
            return STATUS_SUCCESS;
        }
        LockReadCount(HandleData);
        HandleData->InputReadData->ReadCount += 1;
        UnlockReadCount(HandleData);
        Status = WaitForMoreToRead(InputInformation,
                                   Message,
                                   WaitRoutine,
                                   WaitParameter,
                                   WaitParameterLength,
                                   WaitBlockExists
                                  );

        if (!NT_SUCCESS(Status)) {
            if (Status != CONSOLE_STATUS_WAIT) {
                /*
                 * WaitForMoreToRead failed, restore ReadCount and bale out
                 */
                LockReadCount(HandleData);
                HandleData->InputReadData->ReadCount -= 1;
                UnlockReadCount(HandleData);
            }
            *nLength = 0;
            return Status;
        }

        //
        // we will only get to this point if we were called by GetInput.
        //
        ASSERT(FALSE); // I say we never get here !  IANJA

        LockConsole(Console);
    }

    //
    // read from buffer
    //

    Status = ReadBuffer(InputInformation,
                        lpBuffer,
                        *nLength,
                        &EventsRead,
                        Peek,
                        StreamRead,
                        &ResetWaitEvent
#if defined(FE_SB)
                        ,
                        Unicode
#endif
                       );
    if (ResetWaitEvent) {
        NtClearEvent(InputInformation->InputWaitEvent);
    }

    *nLength = EventsRead;
    return Status;
}

NTSTATUS
WriteBuffer(
    OUT PINPUT_INFORMATION InputInformation,
    IN PVOID Buffer,
    IN ULONG Length,
    OUT PULONG EventsWritten,
    OUT PBOOL SetWaitEvent
    )

/*++

Routine Description:

    This routine writes to a buffer.  It does the actual circular buffer
    manipulation.

Arguments:

    InputInformation - buffer to write to

    Buffer - buffer to write from

    Length - length of buffer in events

    BytesRead - where to store number of bytes written.

    SetWaitEvent - on exit, TRUE if buffer became non-empty.

Return Value:

    ERROR_BROKEN_PIPE - no more readers.

Note:

    The console lock must be held when calling this routine.

--*/

{
    NTSTATUS Status;
    ULONG TransferLength;
    ULONG BufferLengthInBytes;
#if defined(FE_SB)
    PCONSOLE_INFORMATION Console = InputInformation->Console;
#endif

    *SetWaitEvent = FALSE;

    //
    // windows sends a mouse_move message each time a window is updated.
    // coalesce these.
    //

    if (Length == 1 && InputInformation->Out != InputInformation->In) {
        PINPUT_RECORD InputEvent=Buffer;

        if (InputEvent->EventType == MOUSE_EVENT &&
            InputEvent->Event.MouseEvent.dwEventFlags == MOUSE_MOVED) {
            PINPUT_RECORD LastInputEvent;

            if (InputInformation->In == InputInformation->First) {
                LastInputEvent = (PINPUT_RECORD) (InputInformation->Last - sizeof(INPUT_RECORD));
            }
            else {
                LastInputEvent = (PINPUT_RECORD) (InputInformation->In - sizeof(INPUT_RECORD));
            }
            if (LastInputEvent->EventType == MOUSE_EVENT &&
                LastInputEvent->Event.MouseEvent.dwEventFlags == MOUSE_MOVED) {
                LastInputEvent->Event.MouseEvent.dwMousePosition.X =
                    InputEvent->Event.MouseEvent.dwMousePosition.X;
                LastInputEvent->Event.MouseEvent.dwMousePosition.Y =
                    InputEvent->Event.MouseEvent.dwMousePosition.Y;
                *EventsWritten = 1;
                return STATUS_SUCCESS;
            }
        }
        else if (InputEvent->EventType == KEY_EVENT &&
                 InputEvent->Event.KeyEvent.bKeyDown) {
            PINPUT_RECORD LastInputEvent;
            if (InputInformation->In == InputInformation->First) {
                LastInputEvent = (PINPUT_RECORD) (InputInformation->Last - sizeof(INPUT_RECORD));
            }
            else {
                LastInputEvent = (PINPUT_RECORD) (InputInformation->In - sizeof(INPUT_RECORD));
            }
#if defined(FE_SB)
            if (IsConsoleFullWidth(Console->hDC,
                                   Console->CP,InputEvent->Event.KeyEvent.uChar.UnicodeChar)) {
                ;
            }
            else
            if (InputEvent->Event.KeyEvent.dwControlKeyState & NLS_IME_CONVERSION) {
                if (LastInputEvent->EventType == KEY_EVENT &&
                    LastInputEvent->Event.KeyEvent.bKeyDown &&
                    (LastInputEvent->Event.KeyEvent.uChar.UnicodeChar ==
                        InputEvent->Event.KeyEvent.uChar.UnicodeChar) &&
                    (LastInputEvent->Event.KeyEvent.dwControlKeyState ==
                        InputEvent->Event.KeyEvent.dwControlKeyState) ) {
                    LastInputEvent->Event.KeyEvent.wRepeatCount +=
                        InputEvent->Event.KeyEvent.wRepeatCount;
                    *EventsWritten = 1;
                    return STATUS_SUCCESS;
                }
            }
            else
#endif
            if (LastInputEvent->EventType == KEY_EVENT &&
                LastInputEvent->Event.KeyEvent.bKeyDown &&
                (LastInputEvent->Event.KeyEvent.wVirtualScanCode == // scancode same
                    InputEvent->Event.KeyEvent.wVirtualScanCode) &&
                (LastInputEvent->Event.KeyEvent.uChar.UnicodeChar == // character same
                    InputEvent->Event.KeyEvent.uChar.UnicodeChar) &&
                (LastInputEvent->Event.KeyEvent.dwControlKeyState == // ctrl/alt/shift state same
                    InputEvent->Event.KeyEvent.dwControlKeyState) ) {
                LastInputEvent->Event.KeyEvent.wRepeatCount +=
                    InputEvent->Event.KeyEvent.wRepeatCount;
                *EventsWritten = 1;
                return STATUS_SUCCESS;
            }
        }
    }

    BufferLengthInBytes = Length*sizeof(INPUT_RECORD);
    *EventsWritten = 0;
    while (*EventsWritten < Length) {

        //
        //
        // if out > in, buffer looks like this:
        //
        //             in     out
        //        ______ _____________
        //       |      |      |      |
        //       | data | free | data |
        //       |______|______|______|
        //
        // we can write from in to out-1
        //

        if (InputInformation->Out > InputInformation->In)       {
            TransferLength = BufferLengthInBytes;
            if  ((InputInformation->Out - InputInformation->In - sizeof(INPUT_RECORD))
                   < BufferLengthInBytes) {
                Status = SetInputBufferSize(InputInformation,
                                            InputInformation->InputBufferSize+Length+INPUT_BUFFER_SIZE_INCREMENT);
                if (!NT_SUCCESS(Status)) {
                    KdPrint(("CONSRV: Couldn't grow input buffer, Status == %lX\n",Status));
                    TransferLength = (ULONG)(InputInformation->Out - InputInformation->In - sizeof(INPUT_RECORD));
                    if (TransferLength == 0) {
                        return Status;
                    }
                } else {
                    goto OutPath;   // after resizing, in > out
                }
            }
            RtlMoveMemory((PBYTE)InputInformation->In,
                          (PBYTE)Buffer,
                          TransferLength
                         );
            Buffer = (PVOID) (((PBYTE) Buffer)+TransferLength);
            *EventsWritten += TransferLength/sizeof(INPUT_RECORD);
            BufferLengthInBytes -= TransferLength;
            InputInformation->In += TransferLength;
        }

        //
        // if in >= out, buffer looks like this:
        //
        //             out     in
        //        ______ _____________
        //       |      |      |      |
        //       | free | data | free |
        //       |______|______|______|
        //
        // we write from the in pointer to the end of the buffer then from the
        // beginning of the buffer, until we hit the out pointer or enough bytes
        // are written.
        //

        else {
            if (InputInformation->Out == InputInformation->In) {
                *SetWaitEvent = TRUE;
            }
OutPath:
            if  ((InputInformation->Last - InputInformation->In) > BufferLengthInBytes) {
                TransferLength = BufferLengthInBytes;
            }
            else {
                if (InputInformation->First == InputInformation->Out &&
                    InputInformation->In == (InputInformation->Last-sizeof(INPUT_RECORD))) {
                    TransferLength = BufferLengthInBytes;
                    Status = SetInputBufferSize(InputInformation,
                                                InputInformation->InputBufferSize+Length+INPUT_BUFFER_SIZE_INCREMENT);
                    if (!NT_SUCCESS(Status)) {
                        KdPrint(("CONSRV: Couldn't grow input buffer, Status == %lX\n",Status));
                        return Status;
                    }
                }
                else {
                    TransferLength = (ULONG)(InputInformation->Last - InputInformation->In);
                    if (InputInformation->First == InputInformation->Out) {
                        TransferLength -= sizeof(INPUT_RECORD);
                    }
                }
            }
            RtlMoveMemory((PBYTE)InputInformation->In,
                          (PBYTE)Buffer,
                          TransferLength
                         );
            Buffer = (PVOID) (((PBYTE) Buffer)+TransferLength);
            *EventsWritten += TransferLength/sizeof(INPUT_RECORD);
            BufferLengthInBytes -= TransferLength;
            InputInformation->In += TransferLength;
            if (InputInformation->In == InputInformation->Last) {
                InputInformation->In = InputInformation->First;
            }
        }
        if (TransferLength == 0) {
            ASSERT (FALSE);
        }
    }
    return STATUS_SUCCESS;
}


__inline BOOL
IsSystemKey(
    WORD wVirtualKeyCode
    )
{
    switch (wVirtualKeyCode) {
    case VK_SHIFT:
    case VK_CONTROL:
    case VK_MENU:
    case VK_PAUSE:
    case VK_CAPITAL:
    case VK_LWIN:
    case VK_RWIN:
    case VK_NUMLOCK:
    case VK_SCROLL:
        return TRUE;
    }
    return FALSE;
}

DWORD
PreprocessInput(
    IN PCONSOLE_INFORMATION Console,
    IN PINPUT_RECORD InputEvent,
    IN DWORD nLength
    )

/*++

Routine Description:

    This routine processes special characters in the input stream.

Arguments:

    Console - Pointer to console structure.

    InputEvent - Buffer to write from.

    nLength - Number of events to write.

Return Value:

    Number of events to write after special characters have been stripped.

Note:

    The console lock must be held when calling this routine.

--*/

{
    ULONG NumEvents;


    for (NumEvents = nLength; NumEvents != 0; NumEvents--) {
        if (InputEvent->EventType == KEY_EVENT && InputEvent->Event.KeyEvent.bKeyDown) {
            //
            // if output is suspended, any keyboard input releases it.
            //

            if ((Console->Flags & CONSOLE_SUSPENDED) &&
                !IsSystemKey(InputEvent->Event.KeyEvent.wVirtualKeyCode)) {

                UnblockWriteConsole(Console, CONSOLE_OUTPUT_SUSPENDED);
                RtlMoveMemory(InputEvent, InputEvent + 1, (NumEvents - 1) * sizeof(INPUT_RECORD));
                nLength--;
                continue;
            }

            //
            // intercept control-s
            //

            if ((Console->InputBuffer.InputMode & ENABLE_LINE_INPUT) &&
                    (InputEvent->Event.KeyEvent.wVirtualKeyCode == VK_PAUSE ||
                     IsPauseKey(&InputEvent->Event.KeyEvent))) {

                Console->Flags |= CONSOLE_OUTPUT_SUSPENDED;
                RtlMoveMemory(InputEvent, InputEvent + 1, (NumEvents - 1) * sizeof(INPUT_RECORD));
                nLength--;
                continue;
            }
        }
        InputEvent++;
    }
    return nLength;
}


DWORD
PrependInputBuffer(
    IN PCONSOLE_INFORMATION Console,
    IN PINPUT_INFORMATION InputInformation,
    IN PINPUT_RECORD lpBuffer,
    IN DWORD nLength
    )

/*++

Routine Description:

    This routine writes to the beginning of the input buffer.

Arguments:

    InputInformation - Pointer to input buffer information structure.

    lpBuffer - Buffer to write from.

    nLength - On input, number of events to write.  On output, number of
    events written.

Return Value:

Note:

    The console lock must be held when calling this routine.

--*/

{
    NTSTATUS Status;
    ULONG EventsWritten,EventsRead;
    BOOL SetWaitEvent;
    ULONG NumExistingEvents;
    PINPUT_RECORD pExistingEvents;
    BOOL Dummy;

    nLength = PreprocessInput(Console, lpBuffer, nLength);
    if (nLength == 0) {
        return 0;
    }

    Status = GetNumberOfReadyEvents(InputInformation,
                                    &NumExistingEvents
                                   );

    if (NumExistingEvents) {

        pExistingEvents = ConsoleHeapAlloc(MAKE_TAG( BUFFER_TAG ),NumExistingEvents * sizeof(INPUT_RECORD));
        if (pExistingEvents == NULL)
            return (DWORD)STATUS_NO_MEMORY;
        Status = ReadBuffer(InputInformation,
                            pExistingEvents,
                            NumExistingEvents,
                            &EventsRead,
                            FALSE,
                            FALSE,
                            &Dummy
#if defined(FE_SB)
                            ,
                            TRUE
#endif
                           );

        if (!NT_SUCCESS(Status)) {
            ConsoleHeapFree(pExistingEvents);
            return Status;
        }
    } else {
        pExistingEvents = NULL;
    }

    //
    // write new info to buffer
    //

    Status = WriteBuffer(InputInformation,
                         lpBuffer,
                         nLength,
                         &EventsWritten,
                         &SetWaitEvent
                        );

    //
    // write existing info to buffer
    //

    if (pExistingEvents) {
        Status = WriteBuffer(InputInformation,
                             pExistingEvents,
                             EventsRead,
                             &EventsWritten,
                             &Dummy
                            );
        ConsoleHeapFree(pExistingEvents);
    }

    if (SetWaitEvent) {
        NtSetEvent(InputInformation->InputWaitEvent,NULL);
    }

    //
    // alert any writers waiting for space
    //

    WakeUpReadersWaitingForData(Console,InputInformation);

    return nLength;
}

DWORD
WriteInputBuffer(
    IN PCONSOLE_INFORMATION Console,
    IN PINPUT_INFORMATION InputInformation,
    IN PINPUT_RECORD lpBuffer,
    IN DWORD nLength
    )

/*++

Routine Description:

    This routine writes to the input buffer.

Arguments:

    InputInformation - Pointer to input buffer information structure.

    lpBuffer - Buffer to write from.

    nLength - On input, number of events to write.  On output, number of
    events written.

Return Value:

Note:

    The console lock must be held when calling this routine.

--*/

{
    ULONG EventsWritten;
    BOOL SetWaitEvent;

    nLength = PreprocessInput(Console, lpBuffer, nLength);
    if (nLength == 0) {
        return 0;
    }

    //
    // write to buffer
    //

    WriteBuffer(InputInformation,
                lpBuffer,
                nLength,
                &EventsWritten,
                &SetWaitEvent
                );

    if (SetWaitEvent) {
        NtSetEvent(InputInformation->InputWaitEvent,NULL);
    }

    //
    // alert any writers waiting for space
    //

    WakeUpReadersWaitingForData(Console,InputInformation);


    return EventsWritten;
}

VOID
StoreKeyInfo(
    IN PMSG msg
    )
{
    int i;

    for (i=0;i<CONSOLE_MAX_KEY_INFO;i++) {
        if (ConsoleKeyInfo[i].hWnd == CONSOLE_FREE_KEY_INFO ||
            ConsoleKeyInfo[i].hWnd == msg->hwnd) {
            break;
        }
    }
    if (i!=CONSOLE_MAX_KEY_INFO) {
        ConsoleKeyInfo[i].hWnd = msg->hwnd;
        ConsoleKeyInfo[i].wVirtualKeyCode = LOWORD(msg->wParam);
        ConsoleKeyInfo[i].wVirtualScanCode = (BYTE)(HIWORD(msg->lParam));
    } else {
        KdPrint(("CONSRV: ConsoleKeyInfo buffer is full\n"));
    }
}

VOID
RetrieveKeyInfo(
    IN HWND hWnd,
    OUT PWORD pwVirtualKeyCode,
    OUT PWORD pwVirtualScanCode,
    IN BOOL FreeKeyInfo
    )
{
    int i;

    for (i=0;i<CONSOLE_MAX_KEY_INFO;i++) {
        if (ConsoleKeyInfo[i].hWnd == hWnd) {
            break;
        }
    }
    if (i!=CONSOLE_MAX_KEY_INFO) {
        *pwVirtualKeyCode = ConsoleKeyInfo[i].wVirtualKeyCode;
        *pwVirtualScanCode = ConsoleKeyInfo[i].wVirtualScanCode;
        if (FreeKeyInfo)
            ConsoleKeyInfo[i].hWnd = CONSOLE_FREE_KEY_INFO;
    } else {
        *pwVirtualKeyCode = (WORD)MapVirtualKey(*pwVirtualScanCode, 3);
    }
}

VOID
ClearKeyInfo(
    IN HWND hWnd
    )
{
    int i;

    for (i=0;i<CONSOLE_MAX_KEY_INFO;i++) {
        if (ConsoleKeyInfo[i].hWnd == hWnd) {
            ConsoleKeyInfo[i].hWnd = CONSOLE_FREE_KEY_INFO;
        }
    }
}


/***************************************************************************\
* ProcessCreateConsoleWindow
*
* This routine processes a CM_CREATE_CONSOLE_WINDOW message. It is called
* from the InputThread message loop under normal circumstances and from
* the DialogHookProc if we have a dialog box up. The USER critical section
* should not be held when calling this routine.
\***************************************************************************/
VOID
ProcessCreateConsoleWindow(
    IN LPMSG lpMsg
    )
{
    NTSTATUS Status;
    // make sure this is a valid message
    PCONSOLE_INFORMATION pConsole;

    if (NT_SUCCESS(RevalidateConsole((HANDLE)lpMsg->wParam, &pConsole))) {

        //
        // Make sure the console doesn't already have a window.
        //

        if (pConsole->hWnd) {
            RIPMSG1(RIP_WARNING, "Console %#p already has a window", pConsole);
            UnlockConsole(pConsole);
            return;
        }

        pConsole->InputThreadInfo = TlsGetValue(InputThreadTlsIndex);
        DBGPRINT(("Before CreateWindowsWindow cWindows = %d\n",
                  pConsole->InputThreadInfo->WindowCount));

        Status = CreateWindowsWindow(pConsole);
        DBGPRINT(("After  CreateWindowsWindow cWindows = %d\n",
                  pConsole->InputThreadInfo->WindowCount));
        switch (Status) {
        case STATUS_SUCCESS:

            //
            // If we changed the screen buffer size, let the user know about it
            // with a message box. Make sure we don't recurse too deeply in
            // this code by limiting the number of message boxes on the screen
            // at once. If there are already a bunch up there, the user should
            // have the idea by now anyway.
            //

            if ((pConsole->Flags & CONSOLE_DEFAULT_BUFFER_SIZE) && (DialogBoxCount < 8)) {
                WCHAR ItemString[120];
                WCHAR Title[120];
                HWND hWnd = pConsole->hWnd;
                ULONG TitleLength = min(sizeof(Title)-sizeof(WCHAR), pConsole->TitleLength);
                RtlCopyMemory(Title, pConsole->Title, TitleLength);
                Title[TitleLength/sizeof(WCHAR)] = 0;
                UnlockConsole(pConsole);
                LoadString(ghInstance,msgBufferTooBig,ItemString,NELEM(ItemString));
                DialogBoxCount++;
                MessageBox(hWnd, ItemString, Title, MB_OK);
                DialogBoxCount--;
                break;
            }
            // FALL THRU
        case STATUS_NO_MEMORY:
            UnlockConsole(pConsole);
            break;
        case STATUS_INVALID_HANDLE:
            // Console is gone, don't do anything.
            break;
        default:
            KdPrint(("CONSRV: CreateWindowsWindow returned %x\n", Status));
            ASSERT(FALSE);
            break;
        }
    }
}


LRESULT
DialogHookProc(
    int nCode,
    WPARAM wParam,
    LPARAM lParam
    )

// this routine gets called to filter input to console dialogs so
// that we can do the special processing that StoreKeyInfo does.

{
    MSG *pmsg = (PMSG)lParam;

    UNREFERENCED_PARAMETER(wParam);

    if (pmsg->message == CM_CREATE_CONSOLE_WINDOW) {
        ProcessCreateConsoleWindow(pmsg);
        return TRUE;
    }

    if (CONSOLE_IS_IME_ENABLED()) {
        if (pmsg->message == CM_CONSOLE_INPUT_THREAD_MSG) {
            PINPUT_THREAD_INFO pThreadInfo = TlsGetValue(InputThreadTlsIndex);
            MSG msg;

            ASSERT(pThreadInfo);

            if (UnqueueThreadMessage(pThreadInfo->ThreadId, &msg.message, &msg.wParam, &msg.lParam)) {
                RIPMSG3(RIP_WARNING, "DialogHookProc: %04x (%08x, %08x)", msg.message, msg.wParam, msg.lParam);
                switch (msg.message) {
                case CM_CONIME_CREATE:
                    ProcessCreateConsoleIME(&msg, pThreadInfo->ThreadId);
                    return TRUE;
                case CM_WAIT_CONIME_PROCESS:
                    WaitConsoleIMEStuff((HDESK)msg.wParam, (HANDLE)msg.lParam);
                    return TRUE;
                case CM_SET_CONSOLEIME_WINDOW:
                    pThreadInfo->hWndConsoleIME = (HWND)msg.wParam;
                    return TRUE;
                default:
                    RIPMSG1(RIP_WARNING, "DialogHookProc: invalid thread message(%04x) !!", msg.message);
                    break;
                }
            }
            else {
                RIPMSG0(RIP_WARNING, "DialogHookProc: bogus thread message is posted. ignored");
            }
        }
    }

    if (nCode == MSGF_DIALOGBOX) {
        if (pmsg->message >= WM_KEYFIRST &&
            pmsg->message <= WM_KEYLAST) {
            if (pmsg->message != WM_CHAR &&
                pmsg->message != WM_DEADCHAR &&
                pmsg->message != WM_SYSCHAR &&
                pmsg->message != WM_SYSDEADCHAR) {

                // don't store key info if dialog box input
                if (GetWindowLongPtr(pmsg->hwnd, GWLP_HWNDPARENT) == 0) {
                    StoreKeyInfo(pmsg);
                }
            }
        }
    }
    return 0;
}

#undef DbgPrint  // Need this to build on free systems

ULONG InputExceptionFilter(
    PEXCEPTION_POINTERS pexi)
{
    NTSTATUS Status;
    SYSTEM_KERNEL_DEBUGGER_INFORMATION KernelDebuggerInfo;

    if (pexi->ExceptionRecord->ExceptionCode != STATUS_PORT_DISCONNECTED) {
        Status = NtQuerySystemInformation( SystemKernelDebuggerInformation,
                                           &KernelDebuggerInfo,
                                           sizeof(KernelDebuggerInfo),
                                           NULL
                                         );

        if (NT_SUCCESS(Status) && KernelDebuggerInfo.KernelDebuggerEnabled) {
            DbgPrint("Unhandled Exception hit in csrss.exe InputExceptionFilter\n");
            DbgPrint("first, enter .exr %p for the exception record\n", pexi->ExceptionRecord);
            DbgPrint("next, enter .cxr %p for the context\n", pexi->ContextRecord);
            DbgPrint("then kb to get the faulting stack\n");
            DbgBreakPoint();
        }
    }

    return EXCEPTION_EXECUTE_HANDLER;
}

/////////////////////////////////////////
// Input Thread internal Message Queue:
// Mainly used for Console IME stuff
/////////////////////////////////////////

LIST_ENTRY gInputThreadMsg;
CRITICAL_SECTION gInputThreadMsgLock;

VOID
InitializeThreadMessages()
{
    RtlEnterCriticalSection(&gInputThreadMsgLock);
    InitializeListHead(&gInputThreadMsg);
    RtlLeaveCriticalSection(&gInputThreadMsgLock);
}

VOID
CleanupInputThreadMessages(
    DWORD dwThreadId)
{
    UINT message;
    WPARAM wParam;
    LPARAM lParam;

    ASSERT(dwThreadId);

    while (UnqueueThreadMessage(dwThreadId, &message, &wParam, &lParam)) {
        RIPMSG3(RIP_WARNING, "CleanupInputThreadMessages: %04x (%08x, %08x)", message, wParam, lParam);
    }
}

//
// QueueThreadMessage
//
// Posts a message to Input Thread, specified by dwThreadId.
// CM_CONSOLE_INPUT_THEAD_MSG is used as a stub message. Actual parameters are
// stored in gInputThreadMsg. Input thread should call UnqueueThreadMessage
// when it gets CM_CONSOLE_INPUT_THREAD_MSG.
//
NTSTATUS
QueueThreadMessage(
    DWORD dwThreadId,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PCONSOLE_THREAD_MSG pConMsg;

    RIPMSG4(RIP_VERBOSE, "QueueThreadMessage: TID=%08x msg:%04x (%08x, %08x)",
            dwThreadId, message, wParam, lParam);

    pConMsg = ConsoleHeapAlloc(MAKE_TAG(TMP_TAG), sizeof *pConMsg);
    if (pConMsg == NULL) {
        RIPMSG0(RIP_WARNING, "QueueThreadMessage: failed to allocate pConMsg");
        return STATUS_NO_MEMORY;
    }

    pConMsg->dwThreadId = dwThreadId;
    pConMsg->Message = message;
    pConMsg->wParam = wParam;
    pConMsg->lParam = lParam;

    RtlEnterCriticalSection(&gInputThreadMsgLock);
    InsertHeadList(&gInputThreadMsg, &pConMsg->ListLink);
    RtlLeaveCriticalSection(&gInputThreadMsgLock);

    if (!PostThreadMessage(dwThreadId, CM_CONSOLE_INPUT_THREAD_MSG, 0, 0)) {
        RIPMSG1(RIP_WARNING, "QueueThreadMessage: failed to post thread msg(%04x)", message);
        RtlEnterCriticalSection(&gInputThreadMsgLock);
        RemoveEntryList(&pConMsg->ListLink);
        RtlLeaveCriticalSection(&gInputThreadMsgLock);
        ConsoleHeapFree(pConMsg);
        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_SUCCESS;
}

//
// UnqueueThreadMessage
//
// return value:
//  TRUE  -- a message found.
//  FALSE -- no message for dwThreadId found.
//
BOOL UnqueueThreadMessage(
    DWORD dwThreadId,
    UINT* pMessage,
    WPARAM* pwParam,
    LPARAM* plParam)
{
    BOOL fResult = FALSE;       // if message is found, set this to TRUE
    PLIST_ENTRY pEntry;

    ASSERT(dwThreadId);

    RtlEnterCriticalSection(&gInputThreadMsgLock);

    //
    // Search for dwThreadId message from the tail of the queue.
    //
    pEntry = gInputThreadMsg.Blink;

    while (pEntry != &gInputThreadMsg) {
        PCONSOLE_THREAD_MSG pConMsg = CONTAINING_RECORD(pEntry, CONSOLE_THREAD_MSG, ListLink);

        if (pConMsg->dwThreadId == dwThreadId) {
            *pMessage = pConMsg->Message;
            *pwParam = pConMsg->wParam;
            *plParam = pConMsg->lParam;

            RemoveEntryList(pEntry);
            ConsoleHeapFree(pConMsg);
            fResult = TRUE;
            break;
        }
        pEntry = pEntry->Blink;
    }

    RtlLeaveCriticalSection(&gInputThreadMsgLock);

    return fResult;
}

VOID
ConsoleInputThread(
    PINPUT_THREAD_INIT_INFO pInputThreadInitInfo)
{
    MSG msg;
    PTEB Teb;
    PCSR_THREAD pcsrt = NULL;
    INPUT_THREAD_INFO ThreadInfo;
    int i;
    HANDLE hThread = NULL;
    HHOOK hhook = NULL;
    BOOL fQuit = FALSE, fSuccess;
    CONSOLEDESKTOPCONSOLETHREAD ConsoleDesktopInfo;
    NTSTATUS Status;

    //
    // Initialize GDI accelerators.
    //

    Teb = NtCurrentTeb();

    /*
     * Set this thread's desktop to the one we just created/opened.
     * When the very first app is loaded, the desktop hasn't been
     * created yet so the above call might fail.  Make sure we don't
     * accidentally call SetThreadDesktop with a NULL pdesk.  The
     * first app will create the desktop and open it for itself.
     */
    ThreadInfo.Desktop = pInputThreadInitInfo->DesktopHandle;
    ThreadInfo.WindowCount = 0;
    ThreadInfo.ThreadHandle = pInputThreadInitInfo->ThreadHandle;
    ThreadInfo.ThreadId = HandleToUlong(Teb->ClientId.UniqueThread);
#if defined(FE_IME)
    ThreadInfo.hWndConsoleIME = NULL;
#endif
    TlsSetValue(InputThreadTlsIndex, &ThreadInfo);
    ConsoleDesktopInfo.hdesk = pInputThreadInitInfo->DesktopHandle;
    ConsoleDesktopInfo.dwThreadId = HandleToUlong(Teb->ClientId.UniqueThread);
    Status = NtUserConsoleControl(ConsoleDesktopConsoleThread, &ConsoleDesktopInfo, sizeof(ConsoleDesktopInfo));
    if (NT_SUCCESS(Status)) {

        //
        // This call forces the client-side desktop information
        // to be updated.
        //

        pcsrt = CsrConnectToUser();
        if (pcsrt == NULL ||
                !SetThreadDesktop(pInputThreadInitInfo->DesktopHandle)) {
            Status = STATUS_UNSUCCESSFUL;
        } else {

            //
            // Save our thread handle for cleanup purposes
            //

            hThread = pcsrt->ThreadHandle;

            if (!fOneTimeInitialized) {

                InitializeCustomCP();

                //
                // Initialize default screen dimensions.  we have to initialize
                // the font info here (in the input thread) so that GDI doesn't
                // get completely confused on process termination (since a
                // process that looks like it's terminating created all the
                // server HFONTS).
                //

                EnumerateFonts(EF_DEFFACE);

                InitializeScreenInfo();

                if (!InitWindowClass())
                    Status = STATUS_UNSUCCESSFUL;

                for (i=0;i<CONSOLE_MAX_KEY_INFO;i++) {
                    ConsoleKeyInfo[i].hWnd = CONSOLE_FREE_KEY_INFO;
                }

                    ProgmanHandleMessage = RegisterWindowMessage(TEXT(CONSOLE_PROGMAN_HANDLE_MESSAGE));
            }
        }
    }

    //
    // If we successfully initialized, the input thread is ready to run.
    // Otherwise, kill the thread.
    //

    pInputThreadInitInfo->InitStatus = Status;
    NtSetEvent(pInputThreadInitInfo->InitCompleteEventHandle, NULL);

    if (!NT_SUCCESS(Status)) {
        goto Cleanup;
    }

    hhook = SetWindowsHookEx(WH_MSGFILTER, DialogHookProc, NULL,
                            HandleToUlong(Teb->ClientId.UniqueThread));

    while (TRUE) {

        //
        // If a WM_QUIT has been received and all windows
        // are gone, get out.
        //

        if (fQuit && ThreadInfo.WindowCount == 0)
            break;

        //
        // Make sure we don't hold any locks while we're idle.
        //

        ASSERT(NtCurrentTeb()->CountOfOwnedCriticalSections == 0);

        GetMessage(&msg, NULL, 0, 0);

        //
        // Trap messages posted to the thread.
        //

        if (msg.message == CM_CREATE_CONSOLE_WINDOW) {
            ProcessCreateConsoleWindow(&msg);
            continue;
        } else if (msg.message == WM_QUIT) {

            //
            // The message was posted from ExitWindows.  This
            // means that it's OK to terminate the thread.
            //

            fQuit = TRUE;

            //
            // Only exit the loop if there are no windows,
            //

            if (ThreadInfo.WindowCount == 0) {
                break;
            }
            KdPrint(("WM_QUIT received by console with windows\n"));
            continue;
        } else if (CONSOLE_IS_IME_ENABLED()) {
            if (msg.message == CM_CONSOLE_INPUT_THREAD_MSG) {
                MSG msg;

                if (UnqueueThreadMessage(ThreadInfo.ThreadId, &msg.message, &msg.wParam, &msg.lParam)) {
                    RIPMSG3(RIP_VERBOSE, "InputThread: Unqueue: msg=%04x (%08x, %08x)", msg.message, msg.wParam, msg.lParam);
                    switch (msg.message) {
                    case CM_CONIME_CREATE:
                        ProcessCreateConsoleIME(&msg, ThreadInfo.ThreadId);
                        continue;
                    case CM_WAIT_CONIME_PROCESS:
                        WaitConsoleIMEStuff((HDESK)msg.wParam, (HANDLE)msg.lParam);
                        continue;
                    case CM_SET_CONSOLEIME_WINDOW:
                        ThreadInfo.hWndConsoleIME = (HWND)msg.wParam;
                        continue;
                    default:
                        RIPMSG1(RIP_WARNING, "ConsoleInputThread: invalid thread message(%04x) !!", msg.message);
                        break;
                    }
                } else {
                    RIPMSG1(RIP_WARNING, "ConsoleInputThread: Bogus thread message posted (msg = 0x%x).", msg.message);
                    continue;
                }
            }
        }

        if (!TranslateMessageEx(&msg, TM_POSTCHARBREAKS)) {
            DispatchMessage(&msg);
        } else {
            // do this so that alt-tab works while journalling
            if (msg.message == WM_SYSKEYDOWN && msg.wParam == VK_TAB &&
                (msg.lParam & 0x20000000) ) {   // alt is really down
                DispatchMessage(&msg);
            } else {
                StoreKeyInfo(&msg);
            }
        }
    }

    //
    // Cleanup the input thread messages
    //
    CleanupInputThreadMessages(ThreadInfo.ThreadId);

Cleanup:

    //
    // Free all resources used by this thread
    //

    if (hhook != NULL)
        UnhookWindowsHookEx(hhook);
    ConsoleDesktopInfo.dwThreadId = 0;
    NtUserConsoleControl(ConsoleDesktopConsoleThread,
                         &ConsoleDesktopInfo, sizeof(ConsoleDesktopInfo));

    //
    // Close the desktop handle. CSR is special cased to close
    // the handle even if the thread has windows.  The desktop
    // remains assigned to the thread.
    //

    fSuccess = CloseDesktop(ThreadInfo.Desktop);
    ASSERT(fSuccess);

    //
    // Restore thread handle so that CSR won't get confused.
    //

    if (hThread != NULL)
        pcsrt->ThreadHandle = hThread;

    if (pcsrt != NULL)
        CsrDereferenceThread(pcsrt);

    UserExitWorkerThread(STATUS_SUCCESS);
}

ULONG
GetControlKeyState(
    LPARAM lParam
    )
{
    ULONG ControlKeyState=0;

    if (GetKeyState(VK_LMENU) & KEY_PRESSED) {
        ControlKeyState |= LEFT_ALT_PRESSED;
    }
    if (GetKeyState(VK_RMENU) & KEY_PRESSED) {
        ControlKeyState |= RIGHT_ALT_PRESSED;
    }
    if (GetKeyState(VK_LCONTROL) & KEY_PRESSED) {
        ControlKeyState |= LEFT_CTRL_PRESSED;
    }
    if (GetKeyState(VK_RCONTROL) & KEY_PRESSED) {
        ControlKeyState |= RIGHT_CTRL_PRESSED;
    }
    if (GetKeyState(VK_SHIFT) & KEY_PRESSED) {
        ControlKeyState |= SHIFT_PRESSED;
    }
    if (GetKeyState(VK_NUMLOCK) & KEY_TOGGLED) {
        ControlKeyState |= NUMLOCK_ON;
    }
    if (GetKeyState(VK_OEM_SCROLL) & KEY_TOGGLED) {
        ControlKeyState |= SCROLLLOCK_ON;
    }
    if (GetKeyState(VK_CAPITAL) & KEY_TOGGLED) {
        ControlKeyState |= CAPSLOCK_ON;
    }
    if (lParam & KEY_ENHANCED) {
        ControlKeyState |= ENHANCED_KEY;
    }
    ControlKeyState |= (lParam & ALTNUMPAD_BIT);
    return ControlKeyState;
}

ULONG
ConvertMouseButtonState(
    IN ULONG Flag,
    IN ULONG State
    )
{
    if (State & MK_LBUTTON) {
        Flag |= FROM_LEFT_1ST_BUTTON_PRESSED;
    }
    if (State & MK_MBUTTON) {
        Flag |= FROM_LEFT_2ND_BUTTON_PRESSED;
    }
    if (State & MK_RBUTTON) {
        Flag |= RIGHTMOST_BUTTON_PRESSED;
    }
    return Flag;
}

VOID
TerminateRead(
    IN PCONSOLE_INFORMATION Console,
    IN PINPUT_INFORMATION InputInfo,
    IN DWORD Flag
    )

/*++

Routine Description:

    This routine wakes up any readers waiting for data when a ctrl-c
    or ctrl-break is input.

Arguments:

    InputInfo - pointer to input buffer

    Flag - flag indicating whether ctrl-break or ctrl-c was input

--*/

{
    BOOLEAN WaitSatisfied;
    WaitSatisfied = CsrNotifyWait(&InputInfo->ReadWaitQueue,
                  TRUE,
                  NULL,
                  IntToPtr(Flag)
                 );
    if (WaitSatisfied) {
        // #334370 under stress, WaitQueue may already hold the satisfied waits
        ASSERT ((Console->WaitQueue == NULL) ||
                (Console->WaitQueue == &InputInfo->ReadWaitQueue));
        Console->WaitQueue = &InputInfo->ReadWaitQueue;
    }
}

BOOL
HandleSysKeyEvent(
    IN PCONSOLE_INFORMATION Console,
    IN HWND hWnd,
    IN UINT Message,
    IN WPARAM wParam,
    IN LPARAM lParam
    )

/*

    returns TRUE if DefWindowProc should be called.

*/

{
    WORD VirtualKeyCode;
    BOOL bCtrlDown;

#if defined (FE_IME)
// Sep.16.1995 Support Console IME by v-HirShi(Hirotoshi Shimizu)
    if (Message == WM_SYSCHAR || Message == WM_SYSDEADCHAR ||
        Message == WM_SYSCHAR+CONIME_KEYDATA || Message == WM_SYSDEADCHAR+CONIME_KEYDATA)
#else
    if (Message == WM_SYSCHAR || Message == WM_SYSDEADCHAR)
#endif
    {
        VirtualKeyCode = (WORD)MapVirtualKey(LOBYTE(HIWORD(lParam)), 1);
    } else {
        VirtualKeyCode = LOWORD(wParam);
    }

    //
    // check for ctrl-esc
    //
    bCtrlDown = GetKeyState(VK_CONTROL) & KEY_PRESSED;

    if (VirtualKeyCode == VK_ESCAPE &&
        bCtrlDown &&
        !(GetKeyState(VK_MENU) & KEY_PRESSED) &&
        !(GetKeyState(VK_SHIFT) & KEY_PRESSED) &&
        !(Console->ReserveKeys & CONSOLE_CTRLESC) ) {
        return TRUE;    // call DefWindowProc
    }

    if ((lParam & 0x20000000) == 0) {   // we're iconic


        //
        // Check for ENTER while ICONic (Restore accelerator)
        //

        if (VirtualKeyCode == VK_RETURN && !(Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE)) {

            return TRUE;    // call DefWindowProc
        } else {
            HandleKeyEvent(Console,
                           hWnd,
                           Message,
                           wParam,
                           lParam
                          );
            return FALSE;
        }
    }

    if (VirtualKeyCode == VK_RETURN && !bCtrlDown &&
            !(Console->ReserveKeys & CONSOLE_ALTENTER)) {
#ifdef i386
        if (!(Message & KEY_UP_TRANSITION)) {
            if (FullScreenInitialized && !GetSystemMetrics(SM_REMOTESESSION)) {
                if (Console->FullScreenFlags == 0) {
                    ConvertToFullScreen(Console);
                    Console->FullScreenFlags = CONSOLE_FULLSCREEN;

                    ChangeDispSettings(Console, Console->hWnd,CDS_FULLSCREEN);
                } else {
                    ConvertToWindowed(Console);
                    Console->FullScreenFlags &= ~CONSOLE_FULLSCREEN;

                    ChangeDispSettings(Console, Console->hWnd,0);

                    ShowWindow(Console->hWnd, SW_RESTORE);
                }
            } else {
                WCHAR ItemString[70];
                LoadString(ghInstance,msgNoFullScreen,ItemString,70);
                MessageBoxEx(Console->hWnd,
                            ItemString,
                            Console->Title,
                            MB_SYSTEMMODAL | MB_OK,
                            0L
                           );
            }
        }
#endif
        return FALSE;
    }

    //
    // make sure alt-space gets translated so that the system
    // menu is displayed.
    //

    if (!(GetKeyState(VK_CONTROL) & KEY_PRESSED)) {
        if (VirtualKeyCode == VK_SPACE && !(Console->ReserveKeys & CONSOLE_ALTSPACE)) {
            return TRUE; // call DefWindowProc
        }

        if (VirtualKeyCode == VK_ESCAPE && !(Console->ReserveKeys & CONSOLE_ALTESC)) {
            return TRUE;  // call DefWindowProc
        }
        if (VirtualKeyCode == VK_TAB && !(Console->ReserveKeys & CONSOLE_ALTTAB)) {
            return TRUE;  // call DefWindowProc
        }
    }
    HandleKeyEvent(Console,
                   hWnd,
                   Message,
                   wParam,
                   lParam
                  );
    return FALSE;
}

VOID
HandleKeyEvent(
    IN PCONSOLE_INFORMATION Console,
    IN HWND hWnd,
    IN UINT Message,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    INPUT_RECORD InputEvent;
    BOOLEAN ContinueProcessing;
    ULONG EventsWritten;
    WORD VirtualKeyCode;
    ULONG ControlKeyState;
    BOOL bKeyDown;
    BOOL bGenerateBreak=FALSE;
#ifdef FE_SB
    BOOL KeyMessageFromConsoleIME;
#endif

#ifdef FE_SB
    // v-HirShi Sep.21.1995 For Console IME
    if ((WM_KEYFIRST+CONIME_KEYDATA) <= Message && Message <= (WM_KEYLAST+CONIME_KEYDATA)) {
        Message -= CONIME_KEYDATA ;
        KeyMessageFromConsoleIME = TRUE ;
    }
    else {
        KeyMessageFromConsoleIME = FALSE ;
    }
#endif
    /*
     * BOGUS for WM_CHAR/WM_DEADCHAR, in which LOWORD(lParam) is a character
     */
    VirtualKeyCode = LOWORD(wParam);
    ControlKeyState = GetControlKeyState(lParam);
    bKeyDown = !(lParam & KEY_TRANSITION_UP);

    //
    // Make sure we retrieve the key info first, or we could chew up
    // unneeded space in the key info table if we bail out early.
    //

    InputEvent.Event.KeyEvent.wVirtualKeyCode = VirtualKeyCode;
    InputEvent.Event.KeyEvent.wVirtualScanCode = (BYTE)(HIWORD(lParam));
    if (Message == WM_CHAR || Message == WM_SYSCHAR ||
        Message == WM_DEADCHAR || Message == WM_SYSDEADCHAR) {
        RetrieveKeyInfo(hWnd,
                        &InputEvent.Event.KeyEvent.wVirtualKeyCode,
                        &InputEvent.Event.KeyEvent.wVirtualScanCode,
                        !(Console->InputBuffer.ImeMode.Open ^ KeyMessageFromConsoleIME));
        VirtualKeyCode = InputEvent.Event.KeyEvent.wVirtualKeyCode;
    }

    //
    // If this is a key up message, should we ignore it? We do this
    // so that if a process reads a line from the input buffer, the
    // key up event won't get put in the buffer after the read
    // completes.
    //

    if (Console->Flags & CONSOLE_IGNORE_NEXT_KEYUP) {
        Console->Flags &= ~CONSOLE_IGNORE_NEXT_KEYUP;
        if (!bKeyDown)
            return;
    }

#ifdef FE_SB
    // v-HirShi Sep.21.1995 For Console IME
    if (KeyMessageFromConsoleIME) {
        goto FromConsoleIME ;
    }
#endif

    if (Console->Flags & CONSOLE_SELECTING) {

        if (!bKeyDown) {
            return;
        }

        //
        // if escape or ctrl-c, cancel selection
        //

        if (!(Console->SelectionFlags & CONSOLE_MOUSE_DOWN) ) {
            if (VirtualKeyCode == VK_ESCAPE ||
                (VirtualKeyCode == 'C' &&
                 (GetKeyState(VK_CONTROL) & KEY_PRESSED) )) {
                ClearSelection(Console);
                return;
            } else if (VirtualKeyCode == VK_RETURN) {

                // if return, copy selection

                DoCopy(Console);
                return;
            } else if (gfEnableColorSelection &&
                      ('0' <= VirtualKeyCode) && ('9' >= VirtualKeyCode) &&
                      (Console->CurrentScreenBuffer->Flags & CONSOLE_TEXTMODE_BUFFER))  {

                BOOLEAN AltPressed, CtrlPressed = FALSE;

                //
                //  It's a numeric key,  text buffer and the color selection regkey is set
                //

                AltPressed = (ControlKeyState & (LEFT_ALT_PRESSED | RIGHT_ALT_PRESSED)) != 0;

                //
                //  If CTRL + ALT together,  then we interpret as ALT (eg on French
                //  keyboards AltGr == RALT+LCTRL,  but we want it to behave as ALT).
                //

                if (!AltPressed)  {

                    CtrlPressed = (ControlKeyState & (RIGHT_CTRL_PRESSED | LEFT_CTRL_PRESSED)) != 0;
                }

                //
                //  If ALT or CTRL are pressed,  then color the selected area.
                //  ALT+n => fg,  CTRL+n => bg
                //

                if (AltPressed || CtrlPressed) {

                    ULONG Attr = VirtualKeyCode - '0' + 6;

                    if (CtrlPressed)  {

                        //
                        //  Setting background color.  Set fg color to black.
                        //

                        Attr <<= 4;
                    } else {

                        //
                        //  Set foreground color.  Maintain the current console bg color
                        //

                        Attr |= Console->CurrentScreenBuffer->Attributes & 0xf0;
                    }

                    ColorSelection(Console, Attr);
                    return;
                }
            }
        }

        if (!(Console->SelectionFlags & CONSOLE_MOUSE_SELECTION)) {
            if ((Console->CurrentScreenBuffer->Flags & CONSOLE_TEXTMODE_BUFFER) &&
                (VirtualKeyCode == VK_RIGHT ||
                 VirtualKeyCode == VK_LEFT ||
                 VirtualKeyCode == VK_UP ||
                 VirtualKeyCode == VK_DOWN ||
                 VirtualKeyCode == VK_NEXT ||
                 VirtualKeyCode == VK_PRIOR ||
                 VirtualKeyCode == VK_END ||
                 VirtualKeyCode == VK_HOME
                ) ) {
                PSCREEN_INFORMATION ScreenInfo;
#ifdef FE_SB
                SHORT RowIndex;
                PROW Row;
                BYTE KAttrs;
                SHORT NextRightX;
                SHORT NextLeftX;
#endif

                ScreenInfo = Console->CurrentScreenBuffer;

                //
                // see if shift is down.  if so, we're extending
                // the selection.  otherwise, we're resetting the
                // anchor
                //

                ConsoleHideCursor(ScreenInfo);
#ifdef FE_SB
                RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y) % ScreenInfo->ScreenBufferSize.Y;
                Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];

               if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
               {
                    KAttrs = Row->CharRow.KAttrs[ScreenInfo->BufferInfo.TextInfo.CursorPosition.X];
                    if (KAttrs & ATTR_LEADING_BYTE)
                        NextRightX = 2;
                    else
                        NextRightX = 1;
                }
                else
                {
                    NextRightX = 1;
                }
                if (ScreenInfo->BufferInfo.TextInfo.CursorPosition.X > 0) {
                    if (CONSOLE_IS_DBCS_OUTPUTCP(Console)) {
                        KAttrs = Row->CharRow.KAttrs[ScreenInfo->BufferInfo.TextInfo.CursorPosition.X-1];
                        if (KAttrs & ATTR_TRAILING_BYTE)
                            NextLeftX = 2;
                        else if (KAttrs & ATTR_LEADING_BYTE) {
                            if (ScreenInfo->BufferInfo.TextInfo.CursorPosition.X-1 > 0) {
                                KAttrs = Row->CharRow.KAttrs[ScreenInfo->BufferInfo.TextInfo.CursorPosition.X-2];
                                if (KAttrs & ATTR_TRAILING_BYTE)
                                    NextLeftX = 3;
                                else
                                    NextLeftX = 2;
                            }
                            else
                                NextLeftX = 1;
                        }
                        else
                            NextLeftX = 1;
                    }
                    else
                        NextLeftX = 1;
                }

                switch (VirtualKeyCode) {
                    case VK_RIGHT:
                        if (ScreenInfo->BufferInfo.TextInfo.CursorPosition.X+NextRightX < ScreenInfo->ScreenBufferSize.X) {
                            ScreenInfo->BufferInfo.TextInfo.CursorPosition.X+=NextRightX;
                        }
                        break;
                    case VK_LEFT:
                        if (ScreenInfo->BufferInfo.TextInfo.CursorPosition.X > 0) {
                            ScreenInfo->BufferInfo.TextInfo.CursorPosition.X-=NextLeftX;
                        }
                        break;
                    case VK_UP:
                        if (ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y > 0) {
                            ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y-=1;
                        }
                        break;
                    case VK_DOWN:
                        if (ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y+1 < ScreenInfo->ScreenBufferSize.Y) {
                            ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y+=1;
                        }
                        break;
                    case VK_NEXT:
                        ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y += CONSOLE_WINDOW_SIZE_Y(ScreenInfo)-1;
                        if (ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y >= ScreenInfo->ScreenBufferSize.Y) {
                            ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y = ScreenInfo->ScreenBufferSize.Y-1;
                        }
                        break;
                    case VK_PRIOR:
                        ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y -= CONSOLE_WINDOW_SIZE_Y(ScreenInfo)-1;
                        if (ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y < 0) {
                            ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y = 0;
                        }
                        break;
                    case VK_END:
                        ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y = ScreenInfo->ScreenBufferSize.Y-CONSOLE_WINDOW_SIZE_Y(ScreenInfo);
                        break;
                    case VK_HOME:
                        ScreenInfo->BufferInfo.TextInfo.CursorPosition.X = 0;
                        ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y = 0;
                        break;
                    default:
                        ASSERT(FALSE);
                }
#else   // FE_SB
                switch (VirtualKeyCode) {
                    case VK_RIGHT:
                        if (ScreenInfo->BufferInfo.TextInfo.CursorPosition.X+1 < ScreenInfo->ScreenBufferSize.X) {
                            ScreenInfo->BufferInfo.TextInfo.CursorPosition.X+=1;
                        }
                        break;
                    case VK_LEFT:
                        if (ScreenInfo->BufferInfo.TextInfo.CursorPosition.X > 0) {
                            ScreenInfo->BufferInfo.TextInfo.CursorPosition.X-=1;
                        }
                        break;
                    case VK_UP:
                        if (ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y > 0) {
                            ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y-=1;
                        }
                        break;
                    case VK_DOWN:
                        if (ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y+1 < ScreenInfo->ScreenBufferSize.Y) {
                            ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y+=1;
                        }
                        break;
                    case VK_NEXT:
                        ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y += CONSOLE_WINDOW_SIZE_Y(ScreenInfo)-1;
                        if (ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y >= ScreenInfo->ScreenBufferSize.Y) {
                            ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y = ScreenInfo->ScreenBufferSize.Y-1;
                        }
                        break;
                    case VK_PRIOR:
                        ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y -= CONSOLE_WINDOW_SIZE_Y(ScreenInfo)-1;
                        if (ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y < 0) {
                            ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y = 0;
                        }
                        break;
                    case VK_END:
                        ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y = ScreenInfo->ScreenBufferSize.Y-CONSOLE_WINDOW_SIZE_Y(ScreenInfo);
                        break;
                    case VK_HOME:
                        ScreenInfo->BufferInfo.TextInfo.CursorPosition.X = 0;
                        ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y = 0;
                        break;
                    default:
                        ASSERT(FALSE);
                }
#endif  // FE_SB
                ConsoleShowCursor(ScreenInfo);
                if (GetKeyState(VK_SHIFT) & KEY_PRESSED) {
                    {
                        ExtendSelection(Console,ScreenInfo->BufferInfo.TextInfo.CursorPosition);
                    }
                } else {
                    if (Console->SelectionFlags & CONSOLE_SELECTION_NOT_EMPTY) {
                        MyInvert(Console,&Console->SelectionRect);
                        Console->SelectionFlags &= ~CONSOLE_SELECTION_NOT_EMPTY;
                        ConsoleShowCursor(ScreenInfo);
                    }
                    ScreenInfo->BufferInfo.TextInfo.CursorMoved = TRUE;
                    Console->SelectionAnchor = ScreenInfo->BufferInfo.TextInfo.CursorPosition;
                    MakeCursorVisible(ScreenInfo,Console->SelectionAnchor);
                    Console->SelectionRect.Left = Console->SelectionRect.Right = Console->SelectionAnchor.X;
                    Console->SelectionRect.Top = Console->SelectionRect.Bottom = Console->SelectionAnchor.Y;
                }
                return;
            }
        } else if (!(Console->SelectionFlags & CONSOLE_MOUSE_DOWN)) {

            //
            // if in mouse selection mode and user hits a key, cancel selection
            //

            if (!IsSystemKey(VirtualKeyCode)) {
                ClearSelection(Console);
            }
        }
    } else if (Console->Flags & CONSOLE_SCROLLING) {

        if (!bKeyDown) {
            return;
        }

        //
        // if escape, enter or ctrl-c, cancel scroll
        //

        if (VirtualKeyCode == VK_ESCAPE ||
            VirtualKeyCode == VK_RETURN ||
            (VirtualKeyCode == 'C' &&
             (GetKeyState(VK_CONTROL) & KEY_PRESSED) )) {
            ClearScroll(Console);
        } else {
            WORD ScrollCommand;
            BOOL Horizontal=FALSE;
            switch (VirtualKeyCode) {
                case VK_UP:
                    ScrollCommand = SB_LINEUP;
                    break;
                case VK_DOWN:
                    ScrollCommand = SB_LINEDOWN;
                    break;
                case VK_LEFT:
                    ScrollCommand = SB_LINEUP;
                    Horizontal=TRUE;
                    break;
                case VK_RIGHT:
                    ScrollCommand = SB_LINEDOWN;
                    Horizontal=TRUE;
                    break;
                case VK_NEXT:
                    ScrollCommand = SB_PAGEDOWN;
                    break;
                case VK_PRIOR:
                    ScrollCommand = SB_PAGEUP;
                    break;
                case VK_END:
                    ScrollCommand = SB_PAGEDOWN;
                    Horizontal=TRUE;
                    break;
                case VK_HOME:
                    ScrollCommand = SB_PAGEUP;
                    Horizontal=TRUE;
                    break;
                case VK_SHIFT:
                case VK_CONTROL:
                case VK_MENU:
                    return;
                default:
                    Beep(800, 200);
                    return;
            }
            if (Horizontal)
                HorizontalScroll(Console->CurrentScreenBuffer, ScrollCommand, 0);
            else
                VerticalScroll(Console, Console->CurrentScreenBuffer,ScrollCommand,0);
        }
        return;
    }

    //
    // if the user is inputting chars at an inappropriate time, beep.
    //

    if ((Console->Flags & (CONSOLE_SELECTING | CONSOLE_SCROLLING | CONSOLE_SCROLLBAR_TRACKING)) &&
        bKeyDown &&
        !IsSystemKey(VirtualKeyCode)) {
        Beep(800, 200);
        return;
    }

    //
    // if in fullscreen mode, process PrintScreen
    //

#ifdef LATER
//
// Changed this code to get commas to work (build 485).
//
// Therese, the problem is that WM_CHAR/WM_SYSCHAR messages come through
// here - in this case, LOWORD(wParam) is a character value and not a virtual
// key. It happens that VK_SNAPSHOT == 0x2c, and the character value for a
// comma is also == 0x2c, so execution enters this conditional when a comma
// is hit. Commas aren't coming out because of the newly entered return
// statement.
//
// HandleKeyEvent() is making many virtual key comparisons - need to make
// sure that for each one, there is either no corresponding character value,
// or that you check before you compare so that you are comparing two values
// that have the same data type.
//
// I added the message comparison so that we know we're checking virtual
// keys against virtual keys and not characters.
//
// - scottlu
//

#endif

    if (Message != WM_CHAR && Message != WM_SYSCHAR &&
        VirtualKeyCode == VK_SNAPSHOT &&
        !(Console->ReserveKeys & (CONSOLE_ALTPRTSC | CONSOLE_PRTSC )) ) {
        if (Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) {
            Console->SelectionFlags |= CONSOLE_SELECTION_NOT_EMPTY;
            Console->SelectionRect = Console->CurrentScreenBuffer->Window;
            StoreSelection(Console);
            Console->SelectionFlags &= ~CONSOLE_SELECTION_NOT_EMPTY;
        }
        return;
    }

    //
    // IME stuff
    //
    if (!(Console->Flags & CONSOLE_VDM_REGISTERED)) {
        LPARAM lParamForHotKey ;
        DWORD HotkeyID ;
        lParamForHotKey = lParam ;

        HotkeyID = NtUserCheckImeHotKey( (VirtualKeyCode & 0x00ff),lParamForHotKey) ;
        //
        // If it's direct KL switching hokey, handle it here
        // regardless the system is IME enabled or not.
        //
        if (HotkeyID >= IME_HOTKEY_DSWITCH_FIRST && HotkeyID <= IME_HOTKEY_DSWITCH_LAST) {
            UINT uModifier, uVkey;
            HKL hkl;

            RIPMSG1(RIP_VERBOSE, "HandleKeyEvent: handling IME HOTKEY id=%x", HotkeyID);
            if (NtUserGetImeHotKey(HotkeyID, &uModifier, &uVkey, &hkl) && hkl != NULL) {
                BYTE bCharSetSys = CodePageToCharSet(GetACP());
                WPARAM wpSysChar = 0;
                CHARSETINFO cs;

                if (TranslateCharsetInfo((LPDWORD)LOWORD(hkl), &cs, TCI_SRCLOCALE)) {
                    if (bCharSetSys == cs.ciCharset) {
                        wpSysChar = INPUTLANGCHANGE_SYSCHARSET;
                    }
                }
                PostMessage(hWnd, WM_INPUTLANGCHANGEREQUEST, wpSysChar, (LPARAM)hkl);
            }
            return;
        }

        if (!(Console->InputBuffer.ImeMode.Disable) && CONSOLE_IS_IME_ENABLED()) {

            if (HotkeyID != IME_INVALID_HOTKEY) {
                switch(HotkeyID) {
                case IME_JHOTKEY_CLOSE_OPEN:
                    {
                        BOOL fOpen = Console->InputBuffer.ImeMode.Open;
                        if (!bKeyDown)
                            break ;

                        Console->InputBuffer.ImeMode.Open = !fOpen ;
                        if (!NT_SUCCESS(ConsoleImeMessagePump(Console,
                                              CONIME_HOTKEY,
                                              (WPARAM)Console->ConsoleHandle,
                                              HotkeyID))) {
                            break;
                        }

                        // Update in the system conversion mode buffer.
                        GetImeKeyState(Console, NULL);

                        break ;
                    }
                case IME_CHOTKEY_IME_NONIME_TOGGLE:
                case IME_THOTKEY_IME_NONIME_TOGGLE:
                case IME_CHOTKEY_SHAPE_TOGGLE:
                case IME_THOTKEY_SHAPE_TOGGLE:
                case IME_CHOTKEY_SYMBOL_TOGGLE:
                case IME_THOTKEY_SYMBOL_TOGGLE:
                case IME_KHOTKEY_SHAPE_TOGGLE:
                case IME_KHOTKEY_HANJACONVERT:
                case IME_KHOTKEY_ENGLISH:
                case IME_ITHOTKEY_RESEND_RESULTSTR:
                case IME_ITHOTKEY_PREVIOUS_COMPOSITION:
                case IME_ITHOTKEY_UISTYLE_TOGGLE:
                default:
                    {
                        if (!NT_SUCCESS(ConsoleImeMessagePump(Console,
                                              CONIME_HOTKEY,
                                              (WPARAM)Console->ConsoleHandle,
                                              HotkeyID))) {
                            break;
                        }

                        // Update in the system conversion mode buffer.
                        GetImeKeyState(Console, NULL);

                        break ;
                    }
                }
                return ;
            }

            if ( CTRL_BUT_NOT_ALT(ControlKeyState) &&
                    (bKeyDown) ) {
                if (VirtualKeyCode == 'C' &&
                        Console->InputBuffer.InputMode & ENABLE_PROCESSED_INPUT) {
                    goto FromConsoleIME ;
                }
                else if (VirtualKeyCode == VK_CANCEL) {
                    goto FromConsoleIME ;
                }
                else if (VirtualKeyCode == 'S'){
                    goto FromConsoleIME ;
                }
            }
            else if (VirtualKeyCode == VK_PAUSE ){
                goto FromConsoleIME ;
            }
            else if ( ((VirtualKeyCode == VK_SHIFT)   ||
                       (VirtualKeyCode == VK_CONTROL) ||
                       (VirtualKeyCode == VK_CAPITAL) ||
                       (VirtualKeyCode == VK_KANA)    ||    // VK_KANA == VK_HANGUL
                       (VirtualKeyCode == VK_JUNJA)   ||
                       (VirtualKeyCode == VK_HANJA)   ||
                       (VirtualKeyCode == VK_NUMLOCK) ||
                       (VirtualKeyCode == VK_SCROLL)     )
                      &&
                      !(Console->InputBuffer.ImeMode.Unavailable) &&
                      !(Console->InputBuffer.ImeMode.Open)
                    )
            {
                if (!NT_SUCCESS(ConsoleImeMessagePump(Console,
                                      Message+CONIME_KEYDATA,
                                      (WPARAM)LOWORD(wParam)<<16|LOWORD(VirtualKeyCode),
                                      lParam
                                     ))) {
                    return;
                }
                goto FromConsoleIME ;
            }

            if (!Console->InputBuffer.ImeMode.Unavailable && Console->InputBuffer.ImeMode.Open) {
                if (! (HIWORD(lParam) & KF_REPEAT))
                {
                    if (PRIMARYLANGID(LOWORD(Console->hklActive)) == LANG_JAPANESE &&
                            (BYTE)wParam == VK_KANA) {
                        if (!NT_SUCCESS(ConsoleImeMessagePump(Console,
                                              CONIME_NOTIFY_VK_KANA,
                                              0,
                                              0
                                             ))) {
                            return;
                        }
                    }
                }

                ConsoleImeMessagePump(Console,
                                      Message+CONIME_KEYDATA,
                                      LOWORD(wParam)<<16|LOWORD(VirtualKeyCode),
                                      lParam
                                     );
                return ;
            }
        }
    }
FromConsoleIME:

    //
    // ignore key strokes that will generate CHAR messages.  this is only
    // necessary while a dialog box is up.
    //

    if (DialogBoxCount > 0) {
        if (Message != WM_CHAR && Message != WM_SYSCHAR && Message != WM_DEADCHAR && Message != WM_SYSDEADCHAR) {
            WCHAR awch[MAX_CHARS_FROM_1_KEYSTROKE];
            int cwch;
            BYTE KeyState[256];

            GetKeyboardState(KeyState);
            cwch = ToUnicodeEx((UINT)wParam,HIWORD(lParam),KeyState,awch,
                               MAX_CHARS_FROM_1_KEYSTROKE,
                               //TM_POSTCHARBREAKS | (KeyState(VK_MENU) & 1));
                               TM_POSTCHARBREAKS,
                               (HKL)NULL);
            if (cwch != 0) {
                return;
            }
        } else {
            // remember to generate break
            if (Message == WM_CHAR) {
                bGenerateBreak=TRUE;
            }
        }
    }

#ifdef FE_IME
    // ignore key stroke while IME property is up.
    if (Console->InputBuffer.hWndConsoleIME)
        return;
#endif

    InputEvent.EventType = KEY_EVENT;
    InputEvent.Event.KeyEvent.bKeyDown = bKeyDown;
    InputEvent.Event.KeyEvent.wRepeatCount = LOWORD(lParam);

    if (Message == WM_CHAR || Message == WM_SYSCHAR || Message == WM_DEADCHAR || Message == WM_SYSDEADCHAR) {
        // If this is a fake character, zero the scancode.
        if (lParam & 0x02000000) {
            InputEvent.Event.KeyEvent.wVirtualScanCode = 0;
        }
        InputEvent.Event.KeyEvent.dwControlKeyState = GetControlKeyState(lParam);
        if (Message == WM_CHAR || Message == WM_SYSCHAR) {
            InputEvent.Event.KeyEvent.uChar.UnicodeChar = (WCHAR)wParam;
        } else {
            InputEvent.Event.KeyEvent.uChar.UnicodeChar = (WCHAR)0;
        }
    } else {
        // if alt-gr, ignore
        if (lParam & 0x02000000) {
            return;
        }
        InputEvent.Event.KeyEvent.dwControlKeyState = ControlKeyState;
        InputEvent.Event.KeyEvent.uChar.UnicodeChar = 0;
    }

#ifdef FE_IME
    if (CONSOLE_IS_IME_ENABLED()) {
        // MSKK August.22.1993 KazuM
        DWORD dwConversion;

        if (!NT_SUCCESS(GetImeKeyState(Console, &dwConversion))) {
            return;
        }

        InputEvent.Event.KeyEvent.dwControlKeyState |= ImmConversionToConsole(dwConversion);
    }
#endif

    ContinueProcessing=TRUE;

    if (CTRL_BUT_NOT_ALT(InputEvent.Event.KeyEvent.dwControlKeyState) &&
        InputEvent.Event.KeyEvent.bKeyDown) {

        //
        // check for ctrl-c, if in line input mode.
        //

        if (InputEvent.Event.KeyEvent.wVirtualKeyCode == 'C' &&
            Console->InputBuffer.InputMode & ENABLE_PROCESSED_INPUT) {
            HandleCtrlEvent(Console,CTRL_C_EVENT);
            if (!Console->PopupCount)
                TerminateRead(Console,&Console->InputBuffer,CONSOLE_CTRL_C_SEEN);
            if (!(Console->Flags & CONSOLE_SUSPENDED)) {
                ContinueProcessing=FALSE;
            }
        }

        //
        // check for ctrl-break.
        //

        else if (InputEvent.Event.KeyEvent.wVirtualKeyCode == VK_CANCEL) {
            FlushInputBuffer(&Console->InputBuffer);
            HandleCtrlEvent(Console,CTRL_BREAK_EVENT);
            if (!Console->PopupCount)
                TerminateRead(Console,&Console->InputBuffer,CONSOLE_CTRL_BREAK_SEEN);
            if (!(Console->Flags & CONSOLE_SUSPENDED)) {
                ContinueProcessing=FALSE;
            }
        }

        //
        // don't write ctrl-esc to the input buffer
        //

        else if (InputEvent.Event.KeyEvent.wVirtualKeyCode == VK_ESCAPE &&
                 !(Console->ReserveKeys & CONSOLE_CTRLESC)) {
            ContinueProcessing=FALSE;
        }
    } else if (InputEvent.Event.KeyEvent.dwControlKeyState & (RIGHT_ALT_PRESSED | LEFT_ALT_PRESSED) &&
               InputEvent.Event.KeyEvent.bKeyDown &&
               InputEvent.Event.KeyEvent.wVirtualKeyCode == VK_ESCAPE &&
               !(Console->ReserveKeys & CONSOLE_ALTESC)) {
        ContinueProcessing=FALSE;
    }

    if (ContinueProcessing) {
        EventsWritten = WriteInputBuffer( Console,
                                          &Console->InputBuffer,
                                          &InputEvent,
                                          1
                                         );
        if (EventsWritten && bGenerateBreak) {
            InputEvent.Event.KeyEvent.bKeyDown = FALSE;
            WriteInputBuffer( Console,
                              &Console->InputBuffer,
                              &InputEvent,
                              1
                             );
        }
    }
    return;
}

/*
 * Returns TRUE if DefWindowProc should be called.
 */
BOOL
HandleMouseEvent(
    IN PCONSOLE_INFORMATION Console,
    IN PSCREEN_INFORMATION ScreenInfo,
    IN UINT Message,
    IN WPARAM wParam,
    IN LPARAM lParam)
{
    ULONG ButtonFlags,EventFlags;
    INPUT_RECORD InputEvent;
    ULONG EventsWritten;
    COORD MousePosition;
    SHORT RowIndex;
    PROW Row;

    if (!(Console->Flags & CONSOLE_HAS_FOCUS) &&
        !(Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) &&
        !(Console->SelectionFlags & CONSOLE_MOUSE_DOWN)) {
        return TRUE;
    }

    if (Console->Flags & CONSOLE_IGNORE_NEXT_MOUSE_INPUT) {
        // only reset on up transition
        if (Message != WM_LBUTTONDOWN &&
            Message != WM_MBUTTONDOWN &&
            Message != WM_RBUTTONDOWN) {
            Console->Flags &= ~CONSOLE_IGNORE_NEXT_MOUSE_INPUT;
            return FALSE;
        }
        return TRUE;
    }

    //
    // translate mouse position into characters, if necessary.
    //

    MousePosition.X = LOWORD(lParam);
    MousePosition.Y = HIWORD(lParam);
    if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
        MousePosition.X /= SCR_FONTSIZE(ScreenInfo).X;
        MousePosition.Y /= SCR_FONTSIZE(ScreenInfo).Y;
    }
    MousePosition.X += ScreenInfo->Window.Left;
    MousePosition.Y += ScreenInfo->Window.Top;

    //
    // make sure mouse position is clipped to screen buffer
    //

    if (MousePosition.X < 0) {
        MousePosition.X = 0;
    } else if (MousePosition.X >= ScreenInfo->ScreenBufferSize.X) {
        MousePosition.X = ScreenInfo->ScreenBufferSize.X - 1;
    }
    if (MousePosition.Y < 0) {
        MousePosition.Y = 0;
    } else if (MousePosition.Y >= ScreenInfo->ScreenBufferSize.Y) {
        MousePosition.Y = ScreenInfo->ScreenBufferSize.Y - 1;
    }

    if (Console->Flags & CONSOLE_SELECTING ||
        ((Console->Flags & CONSOLE_QUICK_EDIT_MODE) &&
         (Console->FullScreenFlags == 0))) {
        if (Message == WM_LBUTTONDOWN) {

            //
            // make sure message matches button state
            //

            if (!(GetKeyState(VK_LBUTTON) & KEY_PRESSED)) {
                return FALSE;
            }

            if (Console->Flags & CONSOLE_QUICK_EDIT_MODE &&
                !(Console->Flags & CONSOLE_SELECTING)) {
                Console->Flags |= CONSOLE_SELECTING;
                Console->SelectionFlags = CONSOLE_MOUSE_SELECTION | CONSOLE_MOUSE_DOWN | CONSOLE_SELECTION_NOT_EMPTY;

                //
                // invert selection
                //

                InitializeMouseSelection(Console, MousePosition);
                MyInvert(Console,&Console->SelectionRect);
                SetWinText(Console,msgSelectMode,TRUE);
                SetCapture(Console->hWnd);
            } else {
                //
                // We now capture the mouse to our Window. We do this so that the
                // user can "scroll" the selection endpoint to an off screen
                // position by moving the mouse off the client area.
                //

                if (Console->SelectionFlags & CONSOLE_MOUSE_SELECTION) {
                    //
                    // Check for SHIFT-Mouse Down "continue previous selection"
                    // command.
                    //
                    if (GetKeyState(VK_SHIFT) & KEY_PRESSED) {
                        Console->SelectionFlags |= CONSOLE_MOUSE_DOWN;
                        SetCapture(Console->hWnd);
                        ExtendSelection(Console, MousePosition);
                    } else {
                        //
                        // Invert old selection, reset anchor, and invert
                        // new selection.
                        //

                        MyInvert(Console,&Console->SelectionRect);
                        Console->SelectionFlags |= CONSOLE_MOUSE_DOWN;
                        SetCapture(Console->hWnd);
                        InitializeMouseSelection(Console, MousePosition);
                        MyInvert(Console,&Console->SelectionRect);
                    }
                } else {
                    ConvertToMouseSelect(Console, MousePosition);
                }
            }
        } else if (Message == WM_LBUTTONUP) {
            if (Console->SelectionFlags & CONSOLE_MOUSE_SELECTION) {
                Console->SelectionFlags &= ~CONSOLE_MOUSE_DOWN;
                ReleaseCapture();
            }
        } else if (Message == WM_LBUTTONDBLCLK) {
            if ((MousePosition.X == Console->SelectionAnchor.X) &&
                (MousePosition.Y == Console->SelectionAnchor.Y)) {
                RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+MousePosition.Y) % ScreenInfo->ScreenBufferSize.Y;
                Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
                while (Console->SelectionAnchor.X > 0) {
                    if (IS_WORD_DELIM(Row->CharRow.Chars[Console->SelectionAnchor.X - 1])) {
                        break;
                    }
                    Console->SelectionAnchor.X--;
                }
                while (MousePosition.X < ScreenInfo->ScreenBufferSize.X) {
                    if (IS_WORD_DELIM(Row->CharRow.Chars[MousePosition.X])) {
                        break;
                    }
                    MousePosition.X++;
                }
                if (gfTrimLeadingZeros) {
                    //
                    // Trim the leading zeros: 000fe12 -> fe12, except 0x and 0n.
                    // Useful for debugging
                    //
                    if (MousePosition.X > Console->SelectionAnchor.X + 2 &&
                            Row->CharRow.Chars[Console->SelectionAnchor.X + 1] != L'x' &&
                            Row->CharRow.Chars[Console->SelectionAnchor.X + 1] != L'X' &&
                            Row->CharRow.Chars[Console->SelectionAnchor.X + 1] != L'n') {
                        // Don't touch the selection begins with 0x
                        while (Row->CharRow.Chars[Console->SelectionAnchor.X] == L'0' && Console->SelectionAnchor.X < MousePosition.X - 1) {
                            Console->SelectionAnchor.X++;
                        }
                    }
                }
                ExtendSelection(Console, MousePosition);
            }
        } else if ((Message == WM_RBUTTONDOWN) || (Message == WM_RBUTTONDBLCLK)) {
            if (!(Console->SelectionFlags & CONSOLE_MOUSE_DOWN)) {
                if (Console->Flags & CONSOLE_SELECTING) {
                    DoCopy(Console);
                } else if (Console->Flags & CONSOLE_QUICK_EDIT_MODE) {
                    DoPaste(Console);
                }
                Console->Flags |= CONSOLE_IGNORE_NEXT_MOUSE_INPUT;
            }
        } else if (Message == WM_MOUSEMOVE) {
            if (Console->SelectionFlags & CONSOLE_MOUSE_DOWN) {
                ExtendSelection(Console, MousePosition);
            }
        } else if (Message == WM_MOUSEWHEEL) {
            return TRUE;
        }
        return FALSE;
    }

    if (!(Console->InputBuffer.InputMode & ENABLE_MOUSE_INPUT)) {
        ReleaseCapture();
        if (Console->FullScreenFlags == 0) {
            return TRUE;
        }
        return FALSE;
    }

    InputEvent.Event.MouseEvent.dwControlKeyState = GetControlKeyState(0);

    if (Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) {
        if (MousePosition.X > ScreenInfo->Window.Right) {
            MousePosition.X = ScreenInfo->Window.Right;
        }
        if (MousePosition.Y > ScreenInfo->Window.Bottom) {
            MousePosition.Y = ScreenInfo->Window.Bottom;
        }
    }

    switch (Message) {
        case WM_LBUTTONDOWN:
            SetCapture(Console->hWnd);
            ButtonFlags = FROM_LEFT_1ST_BUTTON_PRESSED;
            EventFlags = 0;
            break;
        case WM_LBUTTONUP:
        case WM_MBUTTONUP:
        case WM_RBUTTONUP:
            ReleaseCapture();
            ButtonFlags = EventFlags = 0;
            break;
        case WM_RBUTTONDOWN:
            SetCapture(Console->hWnd);
            ButtonFlags = RIGHTMOST_BUTTON_PRESSED;
            EventFlags = 0;
            break;
        case WM_MBUTTONDOWN:
            SetCapture(Console->hWnd);
            ButtonFlags = FROM_LEFT_2ND_BUTTON_PRESSED;
            EventFlags = 0;
            break;
        case WM_MOUSEMOVE:
            ButtonFlags = 0;
            EventFlags = MOUSE_MOVED;
            break;
        case WM_LBUTTONDBLCLK:
            ButtonFlags = FROM_LEFT_1ST_BUTTON_PRESSED;
            EventFlags = DOUBLE_CLICK;
            break;
        case WM_RBUTTONDBLCLK:
            ButtonFlags = RIGHTMOST_BUTTON_PRESSED;
            EventFlags = DOUBLE_CLICK;
            break;
        case WM_MBUTTONDBLCLK:
            ButtonFlags = FROM_LEFT_2ND_BUTTON_PRESSED;
            EventFlags = DOUBLE_CLICK;
            break;
        case WM_MOUSEWHEEL:
            ButtonFlags = ((UINT)wParam & 0xFFFF0000);
            EventFlags = MOUSE_WHEELED;
            break;
        default:
            RIPMSG1(RIP_ERROR, "Invalid message 0x%x", Message);
    }
    InputEvent.EventType = MOUSE_EVENT;
    InputEvent.Event.MouseEvent.dwMousePosition = MousePosition;
    InputEvent.Event.MouseEvent.dwEventFlags = EventFlags;
    InputEvent.Event.MouseEvent.dwButtonState =
    ConvertMouseButtonState(ButtonFlags, (UINT)wParam);
    EventsWritten = WriteInputBuffer(Console,
                                     &Console->InputBuffer,
                                     &InputEvent,
                                     1
                                     );
    if (EventsWritten != 1) {
        RIPMSG1(RIP_WARNING,
                "PutInputInBuffer: EventsWritten != 1 (0x%x), 1 expected",
                EventsWritten);
    }

#ifdef i386
    if (Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) {
        UpdateMousePosition(ScreenInfo, InputEvent.Event.MouseEvent.dwMousePosition);
    }
#endif
    return FALSE;
}

VOID
HandleFocusEvent(
    IN PCONSOLE_INFORMATION Console,
    IN BOOL bSetFocus
    )
{
    INPUT_RECORD InputEvent;
    ULONG EventsWritten;
    USERTHREAD_FLAGS Flags;

    InputEvent.EventType = FOCUS_EVENT;
    InputEvent.Event.FocusEvent.bSetFocus = bSetFocus;

    Flags.dwFlags = 0;
    if (bSetFocus) {
        if (Console->Flags & CONSOLE_VDM_REGISTERED) {
            Flags.dwFlags |= TIF_VDMAPP;
        }
        if (Console->Flags & CONSOLE_CONNECTED_TO_EMULATOR) {
            Flags.dwFlags |= TIF_DOSEMULATOR;
        }
    }

    Flags.dwMask = (TIF_VDMAPP | TIF_DOSEMULATOR);
    NtUserSetInformationThread(Console->InputThreadInfo->ThreadHandle,
            UserThreadFlags, &Flags, sizeof(Flags));
    EventsWritten = WriteInputBuffer( Console,
                                      &Console->InputBuffer,
                                      &InputEvent,
                                      1
                                     );
#if DBG
    if (EventsWritten != 1) {
        DbgPrint("PutInputInBuffer: EventsWritten != 1, 1 expected\n");
    }
#endif
}

VOID
HandleMenuEvent(
    IN PCONSOLE_INFORMATION Console,
    IN DWORD wParam
    )
{
    INPUT_RECORD InputEvent;
    ULONG EventsWritten;

    InputEvent.EventType = MENU_EVENT;
    InputEvent.Event.MenuEvent.dwCommandId = wParam;
    EventsWritten = WriteInputBuffer( Console,
                                      &Console->InputBuffer,
                                      &InputEvent,
                                      1
                                     );
#if DBG
    if (EventsWritten != 1) {
        DbgPrint("PutInputInBuffer: EventsWritten != 1, 1 expected\n");
    }
#endif
}

VOID
HandleCtrlEvent(
    IN PCONSOLE_INFORMATION Console,
    IN DWORD EventType
    )
{
    switch (EventType) {
        case CTRL_C_EVENT:
            Console->CtrlFlags |= CONSOLE_CTRL_C_FLAG;
            break;
        case CTRL_BREAK_EVENT:
            Console->CtrlFlags |= CONSOLE_CTRL_BREAK_FLAG;
            break;
        case CTRL_CLOSE_EVENT:
            Console->CtrlFlags |= CONSOLE_CTRL_CLOSE_FLAG;
            break;
        default:
            RIPMSG1(RIP_ERROR, "Invalid EventType: 0x%x", EventType);
    }
}

VOID
KillProcess(
    PCONSOLE_PROCESS_TERMINATION_RECORD ProcessHandleRecord,
    ULONG_PTR ProcessId
    )
{
    NTSTATUS status;

    //
    // Just terminate the process outright.
    //

    status = NtTerminateProcess(ProcessHandleRecord->ProcessHandle,
                ProcessHandleRecord->bDebugee ? DBG_TERMINATE_PROCESS : CONTROL_C_EXIT);

#if DBG
    if (status != STATUS_SUCCESS &&
            status != STATUS_PROCESS_IS_TERMINATING &&
            status != STATUS_THREAD_WAS_SUSPENDED &&
            !(status == STATUS_ACCESS_DENIED && ProcessHandleRecord->bDebugee)) {
        DbgPrint("NtTerminateProcess failed - status = %x\n", status);
        DbgBreakPoint();
    }
#endif

    //
    // Clear any remaining hard errors for the process.
    //

    if (ProcessId)
        BoostHardError(ProcessId, BHE_FORCE);

    //
    // Give the process 5 seconds to exit.
    //

    if (NT_SUCCESS(status)) {
        LARGE_INTEGER li;

        li.QuadPart = (LONGLONG)-10000 * CMSHUNGAPPTIMEOUT;
        status = NtWaitForSingleObject(ProcessHandleRecord->ProcessHandle,
                                       FALSE,
                                       &li);
        if (status != STATUS_WAIT_0) {
            RIPMSG2(RIP_WARNING,
                    "KillProcess: wait for process %x failed with status %x",
                    ProcessId, status);
        }
    }
}

int
CreateCtrlThread(
    IN PCONSOLE_PROCESS_TERMINATION_RECORD ProcessHandleList,
    IN ULONG ProcessHandleListLength,
    IN PWCHAR Title,
    IN DWORD EventType,
    IN BOOL fForce
    )

// this routine must be called not holding the console lock.
// returns true if process is exiting

{
    HANDLE Thread;
    DWORD Status;
    NTSTATUS status;
    DWORD ShutdownFlags;
    int Success=CONSOLE_SHUTDOWN_SUCCEEDED;
    ULONG i;
    DWORD EventFlags;
    PROCESS_BASIC_INFORMATION BasicInfo;
    PCSR_PROCESS Process;
    BOOL fForceProcess;
    BOOL fExitProcess;
    BOOL fFirstPass=TRUE;
    BOOL fSecondPassNeeded=FALSE;
    BOOL fHasError;
    BOOL fFirstWait;
    BOOL fEventProcessed;
    BOOL fBreakEvent;

BigLoop:
    for (i=0;i<ProcessHandleListLength;i++) {

        //
        // If the user has already cancelled shutdown, don't try to kill
        // any more processes.
        //

        if (Success == CONSOLE_SHUTDOWN_FAILED) {
            break;
        }

        //
        // Get the process shutdown parameters here. First get the process
        // id so we can get the csr process structure pointer.
        //

        status = NtQueryInformationProcess(
                ProcessHandleList[i].ProcessHandle,
                ProcessBasicInformation,
                &BasicInfo,
                sizeof(BasicInfo),
                NULL);

        //
        // Grab the shutdown flags from the csr process structure.  If
        // the structure cannot be found, terminate the process.
        //

        ProcessHandleList[i].bDebugee = FALSE;
        ShutdownFlags = 0;
        if (NT_SUCCESS(status)) {
            CsrLockProcessByClientId(
                    (HANDLE)BasicInfo.UniqueProcessId, &Process);
            if (Process == NULL) {
                KillProcess(&ProcessHandleList[i],
                        BasicInfo.UniqueProcessId);
                continue;
            }
        } else {
            KillProcess(&ProcessHandleList[i], 0);
            continue;
        }
        ShutdownFlags = Process->ShutdownFlags;
        ProcessHandleList[i].bDebugee = Process->DebugUserInterface.UniqueProcess!=NULL;
        CsrUnlockProcess(Process);

        if (!ProcessHandleList[i].bDebugee) {
            HANDLE DebugPort;

            // see if we're a OS/2 app that's being debugged
            DebugPort = (HANDLE)NULL;
            status = NtQueryInformationProcess(
                        ProcessHandleList[i].ProcessHandle,
                        ProcessDebugPort,
                        (PVOID)&DebugPort,
                        sizeof(DebugPort),
                        NULL
                        );
            if ( NT_SUCCESS(status) && DebugPort ) {
                ProcessHandleList[i].bDebugee = TRUE;
            }
        }
        if (EventType != CTRL_C_EVENT && EventType != CTRL_BREAK_EVENT) {
            fBreakEvent = FALSE;
            if (fFirstPass) {
                if (ProcessHandleList[i].bDebugee) {
                    fSecondPassNeeded = TRUE;
                    continue;
                }
            } else {
                if (!ProcessHandleList[i].bDebugee) {
                    continue;
                }
            }
        } else {
            fBreakEvent = TRUE;
            fFirstPass=FALSE;
        }

        //
        // fForce is whether ExitWindowsEx was called with EWX_FORCE.
        // ShutdownFlags are the shutdown flags for this process. If
        // either are force (noretry is the same as force), then force:
        // which means if the app doesn't exit, don't bring up the retry
        // dialog - just force it to exit right away.
        //

        fForceProcess = fForce || (ShutdownFlags & SHUTDOWN_NORETRY);

        //
        // Only notify system security and service context processes.
        // Don't bring up retry dialogs for them.
        //

        fExitProcess = TRUE;
        EventFlags = 0;
        if (ShutdownFlags & (SHUTDOWN_SYSTEMCONTEXT | SHUTDOWN_OTHERCONTEXT)) {

            //
            // System context - make sure we don't cause it to exit, make
            // sure we don't bring up retry dialogs.
            //

            fExitProcess = FALSE;
            fForceProcess = TRUE;

            //
            // This EventFlag will be passed on down to the CtrlRoutine()
            // on the client side. That way that side knows not to exit
            // this process.
            //

            EventFlags = 0x80000000;
        }

        //
        // Is this the first time we're waiting for this process to die?
        //

        fFirstWait = TRUE;
        fEventProcessed = FALSE;

        while (!fEventProcessed) {
            DWORD ThreadExitCode;
            DWORD ProcessExitCode;
            DWORD cMsTimeout;

            Thread = InternalCreateCallbackThread(
                    ProcessHandleList[i].ProcessHandle,
                    (ULONG_PTR)ProcessHandleList[i].CtrlRoutine,
                    EventType | EventFlags);

            //
            // If the thread cannot be created, terminate the process.
            //

            if (Thread == NULL) {
                KdPrint(("CONSRV: CreateRemoteThread failed %x\n",GetLastError()));
                break;
            }

            //
            // Mark the event as processed.
            //

            fEventProcessed = TRUE;

            /*
             * if it's a ctrl-c or ctrl-break event, just close our
             * handle to the thread.  otherwise it's a close.  wait
             * for client-side thread to terminate.
             */

            if (EventType == CTRL_CLOSE_EVENT) {
                cMsTimeout = gCmsHungAppTimeout;
            } else if (EventType == CTRL_LOGOFF_EVENT) {
                cMsTimeout = gCmsWaitToKillTimeout;
            } else if (EventType == CTRL_SHUTDOWN_EVENT) {

                //
                // If we are shutting down services.exe, we need to look in the
                // registry to see how long to wait.
                //

                if (fFirstWait && BasicInfo.UniqueProcessId == gdwServicesProcessId) {
                    cMsTimeout = gdwServicesWaitToKillTimeout;
                } else {
                    cMsTimeout = gCmsWaitToKillTimeout;
                }
            } else {
                CloseHandle(Thread);
                fExitProcess = FALSE;
                break;
            }

            while (TRUE) {
                fHasError = BoostHardError(BasicInfo.UniqueProcessId,
                        (fForceProcess ? BHE_FORCE : BHE_ACTIVATE));

                //
                // Use a 1 second wait if there was a hard error, otherwise
                // wait cMsTimeout ms.
                //

                Status = InternalWaitCancel(Thread,
                        (fHasError && fForceProcess) ? 1000 : cMsTimeout);
                if (Status == WAIT_TIMEOUT) {
                    int Action;

                    //
                    // If there was a hard error, see if there is another one.
                    //

                    if (fHasError && fForceProcess) {
                        continue;
                    }

                    if (!fForceProcess) {

                        //
                        // we timed out in the handler.  ask the user what
                        // to do.
                        //

                        DialogBoxCount++;
                        Action = ThreadShutdownNotify(WMCS_CONSOLE, (ULONG_PTR)Thread, (LPARAM)Title);
                        DialogBoxCount--;

                        //
                        // If the response is Cancel or EndTask, exit the loop.
                        // Otherwise retry the wait.
                        //

                        if (Action == TSN_USERSAYSCANCEL) {
                            Success = CONSOLE_SHUTDOWN_FAILED;
                        }
                    }
                } else if (Status == 0) {
                    ThreadExitCode = 0;
                    GetExitCodeThread(Thread,&ThreadExitCode);
                    GetExitCodeProcess(ProcessHandleList[i].ProcessHandle,
                            &ProcessExitCode);

                    //
                    // if the app returned TRUE (event handled)
                    // notify the user and see if the app should
                    // be terminated anyway.
                    //

                    if (fHasError || (ThreadExitCode == EventType &&
                            ProcessExitCode == STILL_ACTIVE)) {
                        int Action;

                        if (!fForceProcess) {

                            //
                            // Wait for the process to exit.  If it does exit,
                            // don't bring up the end task dialog.
                            //

                            Status = InternalWaitCancel(ProcessHandleList[i].ProcessHandle,
                                    (fHasError || fFirstWait) ? 1000 : cMsTimeout);
                            if (Status == 0) {

                                //
                                // The process exited.
                                //

                                fExitProcess = FALSE;
                            } else if (Status == WAIT_TIMEOUT) {
                                DialogBoxCount++;
                                Action = ThreadShutdownNotify(WMCS_CONSOLE,
                                                              (ULONG_PTR)ProcessHandleList[i].ProcessHandle,
                                                               (LPARAM)Title);
                                DialogBoxCount--;

                                if (Action == TSN_USERSAYSCANCEL) {
                                    Success = CONSOLE_SHUTDOWN_FAILED;
                                }
                            }
                        }
                    } else {

                        //
                        // The process exited.
                        //

                        fExitProcess = FALSE;
                    }
                }

                //
                // If we get here, we know that all wait conditions have
                // been satisfied.  Time to finish with the process.
                //

                break;
            }

            CloseHandle(Thread);
        }

        //
        // If the process is shutting down, mark it as terminated.
        // This prevents the process from raising any hard error popups
        // after we're done shutting it down.
        //

        if (!fBreakEvent &&
                !(ShutdownFlags & (SHUTDOWN_SYSTEMCONTEXT | SHUTDOWN_OTHERCONTEXT)) &&
                Success == CONSOLE_SHUTDOWN_SUCCEEDED) {
            CsrLockProcessByClientId(
                    (HANDLE)BasicInfo.UniqueProcessId, &Process);
            if (Process) {
                Process->Flags |= CSR_PROCESS_TERMINATED;
                CsrUnlockProcess(Process);
            }

            //
            // Force the termination of the process if needed.  Otherwise,
            // acknowledge any remaining hard errors.
            //
            if (fExitProcess) {
                KillProcess(&ProcessHandleList[i],
                        BasicInfo.UniqueProcessId);
            } else {
                BoostHardError(BasicInfo.UniqueProcessId, BHE_FORCE);
            }
        }
    }

    //
    // If this was our first time through and we skipped one of the
    // processes because it was being debugged, we'll go back for a
    // second pass.
    //

    if (fFirstPass && fSecondPassNeeded) {
        fFirstPass = FALSE;
        goto BigLoop;
    }

    // if we're shutting down a system or service security context
    // thread, don't wait for the process to terminate

    if (ShutdownFlags & (SHUTDOWN_SYSTEMCONTEXT | SHUTDOWN_OTHERCONTEXT)) {
        return CONSOLE_SHUTDOWN_SYSTEM;
    }
    return Success;
}

int
ProcessCtrlEvents(
    IN PCONSOLE_INFORMATION Console
    )
/* returns TRUE if a ctrl thread was created */
{
    PWCHAR Title;
    CONSOLE_PROCESS_TERMINATION_RECORD ProcessHandles[2];
    PCONSOLE_PROCESS_TERMINATION_RECORD ProcessHandleList;
    ULONG ProcessHandleListLength,i;
    ULONG CtrlFlags;
    PLIST_ENTRY ListHead, ListNext;
    BOOL FreeTitle;
    int Success;
    PCONSOLE_PROCESS_HANDLE ProcessHandleRecord;
    DWORD EventType;
    DWORD LimitingProcessId;
    NTSTATUS Status;

    //
    // If the console was marked for destruction, do it now.
    //

    if (Console->Flags & CONSOLE_IN_DESTRUCTION) {
        DestroyConsole(Console);
        return CONSOLE_SHUTDOWN_FAILED;
    }

    //
    // make sure we don't try to process control events if this
    // console is already going away
    //

    if (Console->Flags & CONSOLE_TERMINATING) {
        Console->CtrlFlags = 0;
    }

    if (Console->CtrlFlags == 0) {
        RtlLeaveCriticalSection(&Console->ConsoleLock);
        return CONSOLE_SHUTDOWN_FAILED;
    }

    //
    // make our own copy of the console process handle list
    //

    LimitingProcessId = Console->LimitingProcessId;
    Console->LimitingProcessId = 0;

    ListHead = &Console->ProcessHandleList;
    ListNext = ListHead->Flink;
    ProcessHandleListLength = 0;
    while (ListNext != ListHead) {
        ProcessHandleRecord = CONTAINING_RECORD( ListNext, CONSOLE_PROCESS_HANDLE, ListLink );
        ListNext = ListNext->Flink;
        if ( LimitingProcessId ) {
            if ( ProcessHandleRecord->Process->ProcessGroupId == LimitingProcessId ) {
                ProcessHandleListLength += 1;
            }
        } else {
            ProcessHandleListLength += 1;
        }
    }

    //
    // Use the stack buffer to hold the process handles if there are only a
    // few, otherwise allocate a buffer from the heap.
    //

    if (ProcessHandleListLength <= NELEM(ProcessHandles)) {
        ProcessHandleList = ProcessHandles;
    } else {
        ProcessHandleList = (PCONSOLE_PROCESS_TERMINATION_RECORD)ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ),ProcessHandleListLength * sizeof(CONSOLE_PROCESS_TERMINATION_RECORD));
        if (ProcessHandleList == NULL) {
            RtlLeaveCriticalSection(&Console->ConsoleLock);
            return CONSOLE_SHUTDOWN_FAILED;
        }
    }

    ListNext = ListHead->Flink;
    i=0;
    while (ListNext != ListHead) {
        BOOLEAN ProcessIsIn;

        ASSERT(i<=ProcessHandleListLength);
        ProcessHandleRecord = CONTAINING_RECORD( ListNext, CONSOLE_PROCESS_HANDLE, ListLink );
        ListNext = ListNext->Flink;

        if ( LimitingProcessId ) {
            if ( ProcessHandleRecord->Process->ProcessGroupId == LimitingProcessId ) {
                ProcessIsIn = TRUE;
            } else {
                ProcessIsIn = FALSE;
            }
        } else {
            ProcessIsIn = TRUE;
        }

        if ( ProcessIsIn ) {
            Success = (int)DuplicateHandle(NtCurrentProcess(),
                           ProcessHandleRecord->ProcessHandle,
                           NtCurrentProcess(),
                           &ProcessHandleList[i].ProcessHandle,
                           0,
                           FALSE,
                           DUPLICATE_SAME_ACCESS);

            //
            // If the duplicate failed, the best we can do is to skip
            // including the process in the list and hope it goes
            // away.
            //
            if (!Success) {
                KdPrint(("CONSRV: dup handle failed for %d of %d in %lx\n",
                         i, ProcessHandleListLength, Console));
                continue;
            }

            if (Console->CtrlFlags & CONSOLE_CTRL_CLOSE_FLAG) {
                ProcessHandleRecord->TerminateCount++;
            } else {
                ProcessHandleRecord->TerminateCount = 0;
            }
            ProcessHandleList[i].TerminateCount = ProcessHandleRecord->TerminateCount;

            if (ProcessHandleRecord->CtrlRoutine) {
                ProcessHandleList[i].CtrlRoutine = ProcessHandleRecord->CtrlRoutine;
            } else {
                ProcessHandleList[i].CtrlRoutine = CtrlRoutine;
            }

            //
            // If this is the VDM process and we're closing the
            // console window, move it to the front of the list
            //

            if (i > 0 && Console->VDMProcessId && Console->VDMProcessId ==
                    ProcessHandleRecord->Process->ClientId.UniqueProcess &&
                    ProcessHandleRecord->TerminateCount > 0) {
                CONSOLE_PROCESS_TERMINATION_RECORD ProcessHandle;
                ProcessHandle = ProcessHandleList[0];
                ProcessHandleList[0] = ProcessHandleList[i];
                ProcessHandleList[i] = ProcessHandle;
            }

            i++;
        }
    }
    ProcessHandleListLength = i;
    ASSERT(ProcessHandleListLength > 0);

    // copy title.  titlelength does not include terminating null.

    Title = (PWCHAR)ConsoleHeapAlloc(MAKE_TAG( TITLE_TAG ),Console->TitleLength+sizeof(WCHAR));
    if (Title) {
        FreeTitle = TRUE;
        RtlCopyMemory(Title,Console->Title,Console->TitleLength+sizeof(WCHAR));
    } else {
        FreeTitle = FALSE;
        Title = L"Command Window";
    }

    // copy ctrl flags

    CtrlFlags = Console->CtrlFlags;
    ASSERT( !((CtrlFlags & (CONSOLE_CTRL_CLOSE_FLAG | CONSOLE_CTRL_BREAK_FLAG | CONSOLE_CTRL_C_FLAG)) &&
              (CtrlFlags & (CONSOLE_CTRL_LOGOFF_FLAG | CONSOLE_CTRL_SHUTDOWN_FLAG)) ));

    Console->CtrlFlags = 0;

    RtlLeaveCriticalSection(&Console->ConsoleLock);

    //
    // the ctrl flags could be a combination of the following
    // values:
    //
    //        CONSOLE_CTRL_C_FLAG
    //        CONSOLE_CTRL_BREAK_FLAG
    //        CONSOLE_CTRL_CLOSE_FLAG
    //        CONSOLE_CTRL_LOGOFF_FLAG
    //        CONSOLE_CTRL_SHUTDOWN_FLAG
    //

    Success = CONSOLE_SHUTDOWN_FAILED;

    EventType = (DWORD)-1;
    switch (CtrlFlags & (CONSOLE_CTRL_CLOSE_FLAG | CONSOLE_CTRL_BREAK_FLAG |
            CONSOLE_CTRL_C_FLAG | CONSOLE_CTRL_LOGOFF_FLAG |
            CONSOLE_CTRL_SHUTDOWN_FLAG)) {

    case CONSOLE_CTRL_CLOSE_FLAG:
        EventType = CTRL_CLOSE_EVENT;
        break;

    case CONSOLE_CTRL_BREAK_FLAG:
        EventType = CTRL_BREAK_EVENT;
        break;

    case CONSOLE_CTRL_C_FLAG:
        EventType = CTRL_C_EVENT;
        break;

    case CONSOLE_CTRL_LOGOFF_FLAG:
        EventType = CTRL_LOGOFF_EVENT;
        break;

    case CONSOLE_CTRL_SHUTDOWN_FLAG:
        EventType = CTRL_SHUTDOWN_EVENT;
        break;
    }

    if (EventType != (DWORD)-1) {

        Success = CreateCtrlThread(ProcessHandleList,
                ProcessHandleListLength,
                Title,
                EventType,
                (CtrlFlags & CONSOLE_FORCE_SHUTDOWN_FLAG) != 0
                );
    }

    if (FreeTitle) {
        ConsoleHeapFree(Title);
    }

    for (i=0;i<ProcessHandleListLength;i++) {
        Status = NtClose(ProcessHandleList[i].ProcessHandle);
        ASSERT(NT_SUCCESS(Status));
    }

    if (ProcessHandleList != ProcessHandles) {
        ConsoleHeapFree(ProcessHandleList);
    }

    return Success;
}


VOID
UnlockConsole(
    IN PCONSOLE_INFORMATION Console
    )
{
    LIST_ENTRY WaitQueue;

    //
    // Make sure the console pointer is still valid
    //
    ASSERT(NT_SUCCESS(ValidateConsole(Console)));

#ifdef i386
    //
    // do nothing if we are in screen switching(handshaking with ntvdm)
    // we don't check anything else because we are in a safe state here.
    //
    if (ConsoleVDMOnSwitching == Console &&
        ConsoleVDMOnSwitching->VDMProcessId == CONSOLE_CLIENTPROCESSID()) {
        KdPrint(("    UnlockConsole - Thread %lx is leaving VDM CritSec\n", GetCurrentThreadId()));
        RtlLeaveCriticalSection(&ConsoleVDMCriticalSection);
        return;
    }
#endif

    //
    // if we're about to release the console lock, see if there
    // are any satisfied wait blocks that need to be dereferenced.
    // this code avoids a deadlock between grabbing the console
    // lock and then grabbing the process structure lock.
    //
#if defined(_X86_) || defined(_AMD64_)
    if (Console->ConsoleLock.RecursionCount == 1) {
#endif
#if defined(_IA64_)
    if (Console->ConsoleLock.RecursionCount == 0) {
#endif
        InitializeListHead(&WaitQueue);
        if (Console->WaitQueue) {
            CsrMoveSatisfiedWait(&WaitQueue, Console->WaitQueue);
            Console->WaitQueue = NULL;
        }
        ProcessCtrlEvents(Console);

        /*
         * Can't call CsrDereferenceWait with the console locked or we could deadlock.
         */
        if (!IsListEmpty(&WaitQueue)) {
            CsrDereferenceWait(&WaitQueue);
        }
    } else {
        RtlLeaveCriticalSection(&Console->ConsoleLock);
    }
}

ULONG
ShutdownConsole(
    IN HANDLE ConsoleHandle,
    IN DWORD dwFlags
    )
/*
    returns TRUE if console shutdown.  we recurse here so we don't
    return from the WM_QUERYENDSESSION until the console is gone.

*/

{
    DWORD EventFlag;
    int WaitForShutdown;
    PCONSOLE_INFORMATION Console;

    EventFlag = 0;

    //
    // Transmit the force bit (meaning don't bring up the retry dialog
    // if the app times out.
    //

    if (dwFlags & EWX_FORCE)
        EventFlag |= CONSOLE_FORCE_SHUTDOWN_FLAG;

    //
    // Remember if this is shutdown or logoff - inquiring apps want to know.
    //

    if (dwFlags & EWX_SHUTDOWN) {
        EventFlag |= CONSOLE_CTRL_SHUTDOWN_FLAG;
    } else {
        EventFlag |= CONSOLE_CTRL_LOGOFF_FLAG;
    }

    //
    // see if console already going away
    //

    if (!NT_SUCCESS(RevalidateConsole(ConsoleHandle, &Console))) {
        KdPrint(("CONSRV: Shutting down terminating console\n"));
        return SHUTDOWN_KNOWN_PROCESS;
    }

    Console->Flags |= CONSOLE_SHUTTING_DOWN;
    Console->CtrlFlags = EventFlag;
    Console->LimitingProcessId = 0;

    WaitForShutdown = ProcessCtrlEvents(Console);
    if (WaitForShutdown == CONSOLE_SHUTDOWN_SUCCEEDED) {
        return (ULONG)STATUS_PROCESS_IS_TERMINATING;
    } else {
        if (!NT_SUCCESS(RevalidateConsole(ConsoleHandle, &Console))) {
            return SHUTDOWN_KNOWN_PROCESS;
        }
        Console->Flags &= ~CONSOLE_SHUTTING_DOWN;
        UnlockConsole(Console);
        if (WaitForShutdown == CONSOLE_SHUTDOWN_SYSTEM) {
            return SHUTDOWN_KNOWN_PROCESS;
        } else {
            return SHUTDOWN_CANCEL;
        }
    }
}

/* 
 * Exit routine for threads created with RtlCreateUserThread. These threads
 * cannot call ExitThread(). So don't do that.
 *
 */
VOID UserExitWorkerThread(NTSTATUS Status)
{
    NtCurrentTeb()->FreeStackOnTermination = TRUE;
    NtTerminateThread(NtCurrentThread(), Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\server\menu.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    menu.c

Abstract:

        This file implements the system menu management.

Author:

    Therese Stowell (thereses) Jan-24-1992 (swiped from Win3.1)

--*/

#include "precomp.h"
#pragma hdrstop


VOID
MyModifyMenuItem(
    IN PCONSOLE_INFORMATION Console,
    IN UINT ItemId
    )
/*++

   This routine edits the indicated control to one word. This is used to
        trim the Accelerator key text off of the end of the standard menu
        items because we don't support the accelerators.

--*/

{
    WCHAR ItemString[30];
    int ItemLength;
    MENUITEMINFO mii;

    ItemLength = LoadString(ghInstance,ItemId,ItemString,NELEM(ItemString));
    if (ItemLength == 0) {
        //DbgPrint("LoadString in MyModifyMenu failed %d\n",GetLastError());
        return;
    }

    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_STRING;
    mii.dwTypeData = ItemString;

    if (ItemId == SC_CLOSE) {
        mii.fMask |= MIIM_BITMAP;
        mii.hbmpItem = HBMMENU_POPUP_CLOSE;
    }

    SetMenuItemInfo(Console->hMenu, ItemId, FALSE, &mii);

}

VOID
InitSystemMenu(
    IN PCONSOLE_INFORMATION Console
    )
{
    WCHAR ItemString[30];
    int ItemLength;

    //
    // load the clipboard menu.
    //

    Console->hHeirMenu = LoadMenu(ghInstance, MAKEINTRESOURCE(ID_WOMENU));
    if (Console->hHeirMenu) {
        ItemLength = LoadString(ghInstance,cmEdit,ItemString,NELEM(ItemString));
        if (ItemLength == 0)
            RIPMSG1(RIP_WARNING, "LoadString 1 failed 0x%x", GetLastError());
    } else {
        RIPMSG1(RIP_WARNING, "LoadMenu 1 failed 0x%x", GetLastError());
    }

    //
    // Edit the accelerators off of the standard items.
    //

    MyModifyMenuItem(Console, SC_CLOSE);

    //
    // Append the clipboard menu to system menu.
    //

    if (!AppendMenu(Console->hMenu,
                    MF_POPUP | MF_STRING,
                    (ULONG_PTR)Console->hHeirMenu,
                    ItemString)) {
        RIPMSG1(RIP_WARNING, "AppendMenu 1 failed 0x%x", GetLastError());
    }

    //
    // Add other items to system menu
    //

    ItemLength = LoadString(ghInstance, cmDefaults, ItemString, ARRAY_SIZE(ItemString));
    if (ItemLength == 0)
        RIPMSG2(RIP_WARNING, "LoadString 0x%x failed 0x%x", cmDefaults, GetLastError());
    if (ItemLength) {
        if (!AppendMenu(Console->hMenu, MF_STRING, cmDefaults, ItemString)) {
            RIPMSG2(RIP_WARNING, "AppendMenu 0x%x failed 0x%x", cmDefaults, GetLastError());
        }
    }
    ItemLength = LoadString(ghInstance,cmControl,ItemString,NELEM(ItemString));
    if (ItemLength == 0)
        RIPMSG2(RIP_WARNING, "LoadString 0x%x failed 0x%x\n", cmControl, GetLastError());
    if (ItemLength) {
        if (!AppendMenu(Console->hMenu, MF_STRING, cmControl, ItemString)) {
            RIPMSG2(RIP_WARNING, "AppendMenu 0x%x failed 0x%x\n", cmControl, GetLastError());
        }
    }
}


VOID
InitializeMenu(
    IN PCONSOLE_INFORMATION Console
    )
/*++

    this initializes the system menu when a WM_INITMENU message
    is read.

--*/

{
    HMENU hMenu = Console->hMenu;
    HMENU hHeirMenu = Console->hHeirMenu;

    //
    // if we're in graphics mode, disable size menu
    //

    if (!(Console->CurrentScreenBuffer->Flags & CONSOLE_TEXTMODE_BUFFER)) {
        EnableMenuItem(hMenu,SC_SIZE,MF_GRAYED);
    }

    //
    // if the console is iconic, disable Mark and Scroll.
    //

    if (Console->Flags & CONSOLE_IS_ICONIC) {
        EnableMenuItem(hHeirMenu,cmMark,MF_GRAYED);
        EnableMenuItem(hHeirMenu,cmScroll,MF_GRAYED);
    } else {

        //
        // if the console is not iconic
        //   if there are no scroll bars
        //       or we're in mark mode
        //       disable scroll
        //   else
        //       enable scroll
        //
        //   if we're in scroll mode
        //       disable mark
        //   else
        //       enable mark

        if ((Console->CurrentScreenBuffer->WindowMaximizedX &&
             Console->CurrentScreenBuffer->WindowMaximizedY) ||
             Console->Flags & CONSOLE_SELECTING) {
            EnableMenuItem(hHeirMenu,cmScroll,MF_GRAYED);
        } else {
            EnableMenuItem(hHeirMenu,cmScroll,MF_ENABLED);
        }
        if (Console->Flags & CONSOLE_SCROLLING) {
            EnableMenuItem(hHeirMenu,cmMark,MF_GRAYED);
        } else {
            EnableMenuItem(hHeirMenu,cmMark,MF_ENABLED);
        }
    }

    //
    // if we're selecting or scrolling, disable Paste.
    // otherwise enable it.
    //

    if (Console->Flags & (CONSOLE_SELECTING | CONSOLE_SCROLLING)) {
        EnableMenuItem(hHeirMenu,cmPaste,MF_GRAYED);
    } else {
        EnableMenuItem(hHeirMenu,cmPaste,MF_ENABLED);
    }

    //
    // if app has active selection, enable copy; else disabled
    //

    if (Console->Flags & CONSOLE_SELECTING &&
        Console->SelectionFlags & CONSOLE_SELECTION_NOT_EMPTY) {
        EnableMenuItem(hHeirMenu,cmCopy,MF_ENABLED);
    } else {
        EnableMenuItem(hHeirMenu,cmCopy,MF_GRAYED);
    }

    //
    // disable close
    //

    if (Console->Flags & CONSOLE_DISABLE_CLOSE)
        EnableMenuItem(hMenu,SC_CLOSE,MF_GRAYED);
    else
        EnableMenuItem(hMenu,SC_CLOSE,MF_ENABLED);

    //
    // enable Move if not iconic
    //

    if (Console->Flags & CONSOLE_IS_ICONIC) {
        EnableMenuItem(hMenu,SC_MOVE,MF_GRAYED);
    } else {
        EnableMenuItem(hMenu,SC_MOVE,MF_ENABLED);
    }

    //
    // enable Settings if not already doing it
    //

    if (Console->hWndProperties && IsWindow(Console->hWndProperties)) {
        EnableMenuItem(hMenu,cmControl,MF_GRAYED);
    } else {
        EnableMenuItem(hMenu,cmControl,MF_ENABLED);
        Console->hWndProperties = NULL;
    }
}

VOID
SetWinText(
    IN PCONSOLE_INFORMATION Console,
    IN UINT wID,
    IN BOOL Add
    )

/*++

    This routine adds or removes the name to or from the
    beginning of the window title.  The possible names
    are "Scroll", "Mark", "Paste", and "Copy".

--*/

{
    WCHAR TextBuf[256];
    PWCHAR TextBufPtr;
    int TextLength;
    int NameLength;
    WCHAR NameString[20];

    NameLength = LoadString(ghInstance,wID,NameString,
                                  sizeof(NameString)/sizeof(WCHAR));
    if (Add) {
        RtlCopyMemory(TextBuf,NameString,NameLength*sizeof(WCHAR));
        TextBuf[NameLength] = ' ';
        TextBufPtr = TextBuf + NameLength + 1;
    } else {
        TextBufPtr = TextBuf;
    }
    TextLength = GetWindowText(Console->hWnd,
                                  TextBufPtr,
                                  sizeof(TextBuf)/sizeof(WCHAR)-NameLength-1);
    if (TextLength == 0)
        return;
    if (Add) {
        TextBufPtr = TextBuf;
    } else {
        /*
         * The window title might have already been reset, so make sure
         * the name is there before trying to remove it.
         */
        if (wcsncmp(NameString, TextBufPtr, NameLength) != 0)
            return;
        TextBufPtr = TextBuf + NameLength + 1;
    }
    SetWindowText(Console->hWnd,TextBufPtr);
}


VOID
PropertiesDlgShow(
    IN PCONSOLE_INFORMATION Console,
    IN BOOL fCurrent
    )

/*++

    Displays the properties dialog and updates the window state,
    if necessary.

--*/

{
    HANDLE hSection = NULL;
    HANDLE hClientSection = NULL;
    HANDLE hThread;
    SIZE_T ulViewSize;
    LARGE_INTEGER li;
    NTSTATUS Status;
    PCONSOLE_STATE_INFO pStateInfo;
    PCONSOLE_PROCESS_HANDLE ProcessHandleRecord;
    PSCREEN_INFORMATION ScreenInfo;
    LPTHREAD_START_ROUTINE MyPropRoutine;

    /*
     * Map the shared memory block handle into the client side process's
     * address space.
     */
    ProcessHandleRecord = CONTAINING_RECORD(Console->ProcessHandleList.Blink,
                                            CONSOLE_PROCESS_HANDLE,
                                            ListLink);
    /*
     * For global properties pass in hWnd for the hClientSection
     */
    if (!fCurrent) {
        hClientSection = Console->hWnd;
        goto PropCallback;
    }

    /*
     * Create a shared memory block.
     */
    li.QuadPart = sizeof(CONSOLE_STATE_INFO) + Console->OriginalTitleLength;
    Status = NtCreateSection(&hSection,
                             SECTION_ALL_ACCESS,
                             NULL,
                             &li,
                             PAGE_READWRITE,
                             SEC_COMMIT,
                             NULL);
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "Error 0x%x creating file mapping", Status);
        return;
    }

    /*
     * Get a pointer to the shared memory block.
     */
    pStateInfo = NULL;
    ulViewSize = 0;
    Status = NtMapViewOfSection(hSection,
                                NtCurrentProcess(),
                                &pStateInfo,
                                0,
                                0,
                                NULL,
                                &ulViewSize,
                                ViewUnmap,
                                0,
                                PAGE_READWRITE);
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "Error 0x%x mapping view of file", Status);
        NtClose(hSection);
        return;
    }

    /*
     * Fill in the shared memory block with the current values.
     */
    ScreenInfo = Console->CurrentScreenBuffer;
    pStateInfo->Length = li.LowPart;
    pStateInfo->ScreenBufferSize = ScreenInfo->ScreenBufferSize;
    pStateInfo->WindowSize.X = CONSOLE_WINDOW_SIZE_X(ScreenInfo);
    pStateInfo->WindowSize.Y = CONSOLE_WINDOW_SIZE_Y(ScreenInfo);
    pStateInfo->WindowPosX = Console->WindowRect.left;
    pStateInfo->WindowPosY = Console->WindowRect.top;
    if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
        pStateInfo->FontSize = SCR_FONTSIZE(ScreenInfo);
        pStateInfo->FontFamily = SCR_FAMILY(ScreenInfo);
        pStateInfo->FontWeight = SCR_FONTWEIGHT(ScreenInfo);
        wcscpy(pStateInfo->FaceName, SCR_FACENAME(ScreenInfo));
#if defined(FE_SB)
// if TT font has external leading, the Size.Y <> SizeWant.Y
// if we still pass actual Size.Y to console.cpl to query font,
// it will be incorrect. Jun-26-1996

        if (CONSOLE_IS_DBCS_ENABLED() &&
            TM_IS_TT_FONT(SCR_FAMILY(ScreenInfo)))
        {
            if (SCR_FONTNUMBER(ScreenInfo) < NumberOfFonts) {
                pStateInfo->FontSize = FontInfo[SCR_FONTNUMBER(ScreenInfo)].SizeWant;
            }
        }
#endif
        pStateInfo->CursorSize = ScreenInfo->BufferInfo.TextInfo.CursorSize;
    }
    pStateInfo->FullScreen = Console->FullScreenFlags & CONSOLE_FULLSCREEN;
    pStateInfo->QuickEdit = Console->Flags & CONSOLE_QUICK_EDIT_MODE;
    pStateInfo->AutoPosition = Console->Flags & CONSOLE_AUTO_POSITION;
    pStateInfo->InsertMode = Console->InsertMode;
    pStateInfo->ScreenAttributes = ScreenInfo->Attributes;
    pStateInfo->PopupAttributes = ScreenInfo->PopupAttributes;
    pStateInfo->HistoryBufferSize = Console->CommandHistorySize;
    pStateInfo->NumberOfHistoryBuffers = Console->MaxCommandHistories;
    pStateInfo->HistoryNoDup = Console->Flags & CONSOLE_HISTORY_NODUP;
    RtlCopyMemory(pStateInfo->ColorTable,
                  Console->ColorTable,
                  sizeof(Console->ColorTable));
    pStateInfo->hWnd = Console->hWnd;
    wcscpy(pStateInfo->ConsoleTitle, Console->OriginalTitle);
#if defined(FE_SB)
    pStateInfo->CodePage = Console->OutputCP;
#endif
    NtUnmapViewOfSection(NtCurrentProcess(), pStateInfo);

    Status = NtDuplicateObject(NtCurrentProcess(),
                               hSection,
                               ProcessHandleRecord->ProcessHandle,
                               &hClientSection,
                               0,
                               0,
                               DUPLICATE_SAME_ACCESS);
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "Error 0x%x mapping handle to client", Status);
        NtClose(hSection);
        return;
    }

PropCallback:
    /*
     * Get a pointer to the client-side properties routine.
     */
    MyPropRoutine = ProcessHandleRecord->PropRoutine;
    ASSERT(MyPropRoutine);

    /*
     * Call back into the client process to spawn the properties dialog.
     */
    UnlockConsole(Console);
    hThread = InternalCreateCallbackThread(ProcessHandleRecord->ProcessHandle,
                                           (ULONG_PTR)MyPropRoutine,
                                           (ULONG_PTR)hClientSection);
    if (!hThread) {
        RIPMSG1(RIP_WARNING, "CreateRemoteThread failed 0x%x", GetLastError());
    }
    LockConsole(Console);

    /*
     * Close any open handles and free allocated memory.
     */
    if (hThread)
        NtClose(hThread);
    if (hSection)
        NtClose(hSection);

    return;
}


VOID
PropertiesUpdate(
    IN PCONSOLE_INFORMATION Console,
    IN HANDLE hClientSection
    )

/*++

    Updates the console state from information sent by the properties
    dialog box.

--*/

{
    HANDLE hSection;
    SIZE_T ulViewSize;
    NTSTATUS Status;
    PCONSOLE_STATE_INFO pStateInfo;
    PCONSOLE_PROCESS_HANDLE ProcessHandleRecord;
    PSCREEN_INFORMATION ScreenInfo;
    ULONG FontIndex;
    WINDOWPLACEMENT wp;
    COORD NewSize;
    WINDOW_LIMITS WindowLimits;

    /*
     * Map the shared memory block handle into our address space.
     */
    ProcessHandleRecord = CONTAINING_RECORD(Console->ProcessHandleList.Blink,
                                            CONSOLE_PROCESS_HANDLE,
                                            ListLink);
    Status = NtDuplicateObject(ProcessHandleRecord->ProcessHandle,
                               hClientSection,
                               NtCurrentProcess(),
                               &hSection,
                               0,
                               0,
                               DUPLICATE_SAME_ACCESS);
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "Error 0x%x mapping client handle", Status);
        return;
    }

    /*
     * Get a pointer to the shared memory block.
     */
    pStateInfo = NULL;
    ulViewSize = 0;
    Status = NtMapViewOfSection(hSection,
                                NtCurrentProcess(),
                                &pStateInfo,
                                0,
                                0,
                                NULL,
                                &ulViewSize,
                                ViewUnmap,
                                0,
                                PAGE_READONLY);
    if (!NT_SUCCESS(Status)) {
        RIPMSG1(RIP_WARNING, "Error %x mapping view of file", Status);
        NtClose(hSection);
        return;
    }

    /*
     * Verify the size of the shared memory block.
     */
    if (ulViewSize < sizeof(CONSOLE_STATE_INFO)) {
        RIPMSG0(RIP_WARNING, "sizeof(hSection) < sizeof(CONSOLE_STATE_INFO)");
        NtUnmapViewOfSection(NtCurrentProcess(), pStateInfo);
        NtClose(hSection);
        return;
    }

    ScreenInfo = Console->CurrentScreenBuffer;
#if defined(FE_SB)
    if (Console->OutputCP != pStateInfo->CodePage)
    {
        UINT CodePage = Console->OutputCP;

        Console->OutputCP = pStateInfo->CodePage;
        if (CONSOLE_IS_DBCS_ENABLED())
            Console->fIsDBCSOutputCP = !!IsAvailableFarEastCodePage(Console->OutputCP);
        else
            Console->fIsDBCSOutputCP = FALSE;
        SetConsoleCPInfo(Console,TRUE);
#if defined(FE_IME)
        SetImeOutputCodePage(Console, ScreenInfo, CodePage);
#endif // FE_IME
    }
    if (Console->CP != pStateInfo->CodePage)
    {
        UINT CodePage = Console->CP;

        Console->CP = pStateInfo->CodePage;
        if (CONSOLE_IS_DBCS_ENABLED())
            Console->fIsDBCSCP = !!IsAvailableFarEastCodePage(Console->CP);
        else
            Console->fIsDBCSCP = FALSE;
        SetConsoleCPInfo(Console,FALSE);
#if defined(FE_IME)
        SetImeCodePage(Console);
#endif // FE_IME
    }
#endif // FE_SB

    /*
     * Update the console state from the supplied values.
     */
    if (!(Console->Flags & CONSOLE_VDM_REGISTERED) &&
        (pStateInfo->ScreenBufferSize.X != ScreenInfo->ScreenBufferSize.X ||
         pStateInfo->ScreenBufferSize.Y != ScreenInfo->ScreenBufferSize.Y)) {

        PCOOKED_READ_DATA CookedReadData = Console->lpCookedReadData;

        if (CookedReadData && CookedReadData->NumberOfVisibleChars) {
            DeleteCommandLine(CookedReadData, FALSE);
        }
        ResizeScreenBuffer(ScreenInfo,
                           pStateInfo->ScreenBufferSize,
                           TRUE);
        if (CookedReadData && CookedReadData->NumberOfVisibleChars) {
            RedrawCommandLine(CookedReadData);
        }
    }
#if !defined(FE_SB)
    FontIndex = FindCreateFont(pStateInfo->FontFamily,
                               pStateInfo->FaceName,
                               pStateInfo->FontSize,
                               pStateInfo->FontWeight);
#else
    FontIndex = FindCreateFont(pStateInfo->FontFamily,
                               pStateInfo->FaceName,
                               pStateInfo->FontSize,
                               pStateInfo->FontWeight,
                               pStateInfo->CodePage);
#endif

#if defined(FE_SB)
#if defined(i386)
    if (! (Console->FullScreenFlags & CONSOLE_FULLSCREEN)) {
        SetScreenBufferFont(ScreenInfo, FontIndex, pStateInfo->CodePage);
    }
    else {
        ChangeDispSettings(Console, Console->hWnd, 0);
        SetScreenBufferFont(ScreenInfo, FontIndex, pStateInfo->CodePage);
        ConvertToFullScreen(Console);
        ChangeDispSettings(Console, Console->hWnd, CDS_FULLSCREEN);
    }
#else // i386
    SetScreenBufferFont(ScreenInfo, FontIndex, pStateInfo->CodePage);
#endif
#else // FE_SB
    SetScreenBufferFont(ScreenInfo, FontIndex);
#endif // FE_SB
    SetCursorInformation(ScreenInfo,
                         pStateInfo->CursorSize,
                         ScreenInfo->BufferInfo.TextInfo.CursorVisible);

    GetWindowLimits(ScreenInfo, &WindowLimits);
    NewSize.X = min(pStateInfo->WindowSize.X, WindowLimits.MaximumWindowSize.X);
    NewSize.Y = min(pStateInfo->WindowSize.Y, WindowLimits.MaximumWindowSize.Y);
    if (NewSize.X != CONSOLE_WINDOW_SIZE_X(ScreenInfo) ||
        NewSize.Y != CONSOLE_WINDOW_SIZE_Y(ScreenInfo)) {
        wp.length = sizeof(wp);
        GetWindowPlacement(Console->hWnd, &wp);
        wp.rcNormalPosition.right += (NewSize.X - CONSOLE_WINDOW_SIZE_X(ScreenInfo)) *
                            SCR_FONTSIZE(ScreenInfo).X;
        wp.rcNormalPosition.bottom += (NewSize.Y - CONSOLE_WINDOW_SIZE_Y(ScreenInfo)) *
                             SCR_FONTSIZE(ScreenInfo).Y;
        SetWindowPlacement(Console->hWnd, &wp);
    }

#ifdef i386
    if (FullScreenInitialized && ! GetSystemMetrics(SM_REMOTESESSION)) {
        if (pStateInfo->FullScreen == FALSE) {
            if (Console->FullScreenFlags & CONSOLE_FULLSCREEN) {
                ConvertToWindowed(Console);
#if defined(FE_SB)
                /*
                 * Should not sets 0 always.
                 * because exist CONSOLE_FULLSCREEN_HARDWARE bit by avobe
                 *   else {
                 *       ChangeDispSettings(Console, Console->hWnd, 0);
                 *       SetScreenBufferFont(ScreenInfo, FontIndex, pStateInfo->CodePage);
                 *       ConvertToFullScreen(Console);
                 *       ChangeDispSettings(Console, Console->hWnd, CDS_FULLSCREEN);
                 *   }
                 * block.
                 *
                 * This block enable as follows:
                 *   1. console window is full screen
                 *   2. open property by ALT+SPACE
                 *   3. changes window mode by settings.
                 */
                Console->FullScreenFlags &= ~CONSOLE_FULLSCREEN;
#else
                ASSERT(!(Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE));
                Console->FullScreenFlags = 0;
#endif

                ChangeDispSettings(Console, Console->hWnd, 0);
            }
        } else {
            if (Console->FullScreenFlags == 0) {
                ConvertToFullScreen(Console);
                Console->FullScreenFlags |= CONSOLE_FULLSCREEN;

                ChangeDispSettings(Console, Console->hWnd, CDS_FULLSCREEN);
            }
        }
    }
#endif
    if (pStateInfo->QuickEdit) {
        Console->Flags |= CONSOLE_QUICK_EDIT_MODE;
    } else {
        Console->Flags &= ~CONSOLE_QUICK_EDIT_MODE;
    }
    if (pStateInfo->AutoPosition) {
        Console->Flags |= CONSOLE_AUTO_POSITION;
    } else {
        Console->Flags &= ~CONSOLE_AUTO_POSITION;
        SetWindowPos(Console->hWnd, NULL,
                        pStateInfo->WindowPosX,
                        pStateInfo->WindowPosY,
                        0, 0, SWP_NOZORDER | SWP_NOSIZE);
    }
    if (Console->InsertMode != pStateInfo->InsertMode) {
        SetCursorMode(ScreenInfo, FALSE);
        Console->InsertMode = (pStateInfo->InsertMode != FALSE);
#ifdef FE_SB
        if (Console->lpCookedReadData) {
            ((PCOOKED_READ_DATA)Console->lpCookedReadData)->InsertMode = Console->InsertMode;
        }
#endif
    }

    RtlCopyMemory(Console->ColorTable,
                  pStateInfo->ColorTable,
                  sizeof(Console->ColorTable));
    SetScreenColors(ScreenInfo,
                    pStateInfo->ScreenAttributes,
                    pStateInfo->PopupAttributes,
                    TRUE);

    ResizeCommandHistoryBuffers(Console, pStateInfo->HistoryBufferSize);
    Console->MaxCommandHistories = (SHORT)pStateInfo->NumberOfHistoryBuffers;
    if (pStateInfo->HistoryNoDup) {
        Console->Flags |= CONSOLE_HISTORY_NODUP;
    } else {
        Console->Flags &= ~CONSOLE_HISTORY_NODUP;
    }

#if defined(FE_IME)
    SetUndetermineAttribute(Console) ;
#endif

    NtUnmapViewOfSection(NtCurrentProcess(), pStateInfo);
    NtClose(hSection);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\server\link.c ===
//---------------------------------------------------------------------------
//
// link.c       link management routines (reading, etc.)
//
// Copyright (c) 1985 - 1999, Microsoft Corporation
//
//---------------------------------------------------------------------------



#include "precomp.h"
#pragma hdrstop


DWORD
GetTitleFromLinkName(
    IN  LPWSTR szLinkName,
    OUT LPWSTR szTitle
    )
/*++

Routine Description:

    This routine returns the title (i.e., display name of the link) in szTitle,
    and the number of bytes (not chars) in szTitle.

Arguments:

    szLinkName - fully qualified path to link file
    szTitle    - pointer to buffer to contain title (display name) of the link

    i.e.:
    "C:\nt\desktop\A Link File Name.lnk" --> "A Link File Name"

Return Value:

    number of bytes copied to szTitle

--*/
{
    DWORD dwLen;
    LPWSTR pLnk, pDot;
    LPWSTR pPath = szLinkName;

    // Error checking
    ASSERT(szLinkName);

    // find filename at end of fully qualified link name and point pLnk to it
    for (pLnk = pPath; *pPath; pPath++)
    {
        if ( (pPath[0] == L'\\' || pPath[0] == L':') &&
              pPath[1] &&
             (pPath[1] != L'\\')
            )
            pLnk = pPath + 1;
    }

    // find extension (.lnk)
    pPath = pLnk;
    for (pDot = NULL; *pPath; pPath++)
    {
        switch (*pPath) {
        case L'.':
            pDot = pPath;       // remember the last dot
            break;
        case L'\\':
        case L' ':              // extensions can't have spaces
            pDot = NULL;        // forget last dot, it was in a directory
            break;
        }
    }

    // if we found the extension, pDot points to it, if not, pDot
    // is NULL.

    if (pDot)
    {
        dwLen = (ULONG)((pDot - pLnk) * sizeof(WCHAR));
    }
    else
    {
        dwLen = lstrlenW(pLnk) * sizeof(WCHAR);
    }
    dwLen = min(dwLen, MAX_TITLE_LENGTH);

    RtlCopyMemory(szTitle, pLnk, dwLen);

    return dwLen;
}


BOOL ReadString( HANDLE hFile, LPVOID * lpVoid, BOOL bUnicode )
{

    USHORT cch;
    DWORD  dwBytesRead;
    BOOL   fResult = TRUE;

    if (bUnicode)
    {
        LPWSTR lpWStr = NULL;

        fResult &= ReadFile( hFile, (LPVOID)&cch, sizeof(cch), &dwBytesRead, NULL );
        lpWStr = (LPWSTR)ConsoleHeapAlloc( HEAP_ZERO_MEMORY, (cch+1)*sizeof(WCHAR) );
        if (lpWStr) {
            fResult &= ReadFile( hFile, (LPVOID)lpWStr, cch*sizeof(WCHAR), &dwBytesRead, NULL );
            lpWStr[cch] = L'\0';
        }
        *(LPWSTR *)lpVoid = lpWStr;
    }
    else
    {
        LPSTR lpStr = NULL;

        fResult &= ReadFile( hFile, (LPVOID)&cch, sizeof(cch), &dwBytesRead, NULL );
        lpStr = (LPSTR)ConsoleHeapAlloc( HEAP_ZERO_MEMORY, (cch+1) );
        if (lpStr) {
            fResult &= ReadFile( hFile, (LPVOID)lpStr, cch, &dwBytesRead, NULL );
            lpStr[cch] = '\0';
        }
        *(LPSTR *)lpVoid = lpStr;
    }

    return fResult;

}


BOOL LoadLink( LPWSTR pszLinkName, CShellLink * this )
{

    HANDLE hFile;
    DWORD dwBytesRead, cbSize, cbTotal, cbToRead;
    BOOL fResult = TRUE;
    LPSTR pTemp = NULL;

    // Try to open the file
    hFile = CreateFile( pszLinkName,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                       );

    ASSERT(hFile);
    if (hFile==INVALID_HANDLE_VALUE)
        return FALSE;


    // Now, read out data...

    fResult = ReadFile( hFile, (LPVOID)&this->sld, sizeof(this->sld), &dwBytesRead, NULL );
    fResult &= ((dwBytesRead == sizeof(this->sld)) && (this->sld.cbSize == sizeof(this->sld)));
    if (!fResult) {
        // This is a bad .lnk file. Bail.
        goto ErrorExit;
    }

    // read all of the members

    if (this->sld.dwFlags & SLDF_HAS_ID_LIST)
    {
        // Read the size of the IDLIST
        cbSize = 0; // need to zero out to get HIWORD 0 'cause USHORT is only 2 bytes
        fResult &= ReadFile( hFile, (LPVOID)&cbSize, sizeof(USHORT), &dwBytesRead, NULL );
        fResult &= (dwBytesRead == sizeof(USHORT));
        if (cbSize)
        {
            fResult &=
                (SetFilePointer(hFile,cbSize,NULL,FILE_CURRENT)!=0xFFFFFFFF);
        }
        else
        {
            goto ErrorExit;
        }
    }

    if (this->sld.dwFlags & (SLDF_HAS_LINK_INFO))
    {

        fResult &= ReadFile( hFile, (LPVOID)&cbSize, sizeof(cbSize), &dwBytesRead, NULL );
        fResult &= (dwBytesRead == sizeof(cbSize));
        if (cbSize >= sizeof(cbSize))
        {
            cbSize -= sizeof(cbSize);
            fResult &=
                (SetFilePointer(hFile,cbSize,NULL,FILE_CURRENT)!=0xFFFFFFFF);
        }

    }

    if (this->sld.dwFlags & SLDF_HAS_NAME)
        fResult &= ReadString( hFile, &this->pszName, this->sld.dwFlags & SLDF_UNICODE);
    if (this->sld.dwFlags & SLDF_HAS_RELPATH)
        fResult &= ReadString( hFile, &this->pszRelPath, this->sld.dwFlags & SLDF_UNICODE);
    if (this->sld.dwFlags & SLDF_HAS_WORKINGDIR)
        fResult &= ReadString( hFile, &this->pszWorkingDir, this->sld.dwFlags & SLDF_UNICODE);
    if (this->sld.dwFlags & SLDF_HAS_ARGS)
        fResult &= ReadString( hFile, &this->pszArgs, this->sld.dwFlags & SLDF_UNICODE);
    if (this->sld.dwFlags & SLDF_HAS_ICONLOCATION)
        fResult &= ReadString( hFile, &this->pszIconLocation, this->sld.dwFlags & SLDF_UNICODE);

    // Read in extra data sections
    this->pExtraData = NULL;
    cbTotal = 0;
    while (TRUE)
    {

        LPSTR pReadData = NULL;

        cbSize = 0;
        fResult &= ReadFile( hFile, (LPVOID)&cbSize, sizeof(cbSize), &dwBytesRead, NULL );

        if (cbSize < sizeof(cbSize))
            break;

        if (pTemp)
        {
            pTemp = (void *)ConsoleHeapReAlloc(
                                         HEAP_ZERO_MEMORY,
                                         this->pExtraData,
                                         cbTotal + cbSize + sizeof(DWORD)
                                        );
            if (pTemp)
            {
                this->pExtraData = pTemp;
            }
        }
        else
        {
            this->pExtraData = pTemp = ConsoleHeapAlloc( HEAP_ZERO_MEMORY, cbTotal + cbSize + sizeof(DWORD) );

        }

        if (!pTemp)
            break;

        cbToRead = cbSize - sizeof(cbSize);
        pReadData = pTemp + cbTotal;

        fResult &= ReadFile( hFile, (LPVOID)(pReadData + sizeof(cbSize)), cbToRead, &dwBytesRead, NULL );
        if (dwBytesRead==cbToRead)
        {
            // got all of the extra data, comit it
            *((UNALIGNED DWORD *)pReadData) = cbSize;
            cbTotal += cbSize;
        }
        else
            break;

    }

ErrorExit:
    CloseHandle( hFile );

    return fResult;

}



DWORD GetLinkProperties( LPWSTR pszLinkName, LPVOID lpvBuffer, UINT cb )
{
    CShellLink mld;
    DWORD fResult;
    LPNT_CONSOLE_PROPS lpExtraData;
    DWORD dwSize = 0;

    // Zero out structure on the stack
    RtlZeroMemory( &mld, sizeof(mld) );

    // Load link data
    if (!LoadLink( pszLinkName, &mld )) {
        RIPMSG1(RIP_WARNING, "LoadLink %ws failed", pszLinkName);
        fResult = LINK_NOINFO;
        goto Cleanup;
    }

    // Check return buffer -- is it big enough?
    ASSERT(cb >= sizeof( LNKPROPNTCONSOLE));

    // Zero out callers buffer
    RtlZeroMemory( lpvBuffer, cb );

    // Copy relevant shell link data into caller's buffer
    if (mld.pszName)
        lstrcpy( ((LPLNKPROPNTCONSOLE)lpvBuffer)->pszName, mld.pszName );
    if (mld.pszIconLocation)
        lstrcpy( ((LPLNKPROPNTCONSOLE)lpvBuffer)->pszIconLocation, mld.pszIconLocation );
    ((LPLNKPROPNTCONSOLE)lpvBuffer)->uIcon = mld.sld.iIcon;
    ((LPLNKPROPNTCONSOLE)lpvBuffer)->uShowCmd = mld.sld.iShowCmd;
    ((LPLNKPROPNTCONSOLE)lpvBuffer)->uHotKey = mld.sld.wHotkey;
    fResult = LINK_SIMPLEINFO;

    // Find console properties in extra data section
    for( lpExtraData = (LPNT_CONSOLE_PROPS)mld.pExtraData;
         lpExtraData && lpExtraData->cbSize;
         (LPBYTE)lpExtraData += dwSize
        )
    {
        dwSize = lpExtraData->cbSize;
        if (dwSize)
        {
            if (lpExtraData->dwSignature == NT_CONSOLE_PROPS_SIG)
            {

                RtlCopyMemory( &((LPLNKPROPNTCONSOLE)lpvBuffer)->console_props,
                               lpExtraData,
                               sizeof( NT_CONSOLE_PROPS )
                             );
                fResult = LINK_FULLINFO;
#if !defined(FE_SB)
                break;
#endif
            }
#if defined(FE_SB)
            if (lpExtraData->dwSignature == NT_FE_CONSOLE_PROPS_SIG)
            {
                LPNT_FE_CONSOLE_PROPS lpFEExtraData = (LPNT_FE_CONSOLE_PROPS)lpExtraData;

                RtlCopyMemory( &((LPLNKPROPNTCONSOLE)lpvBuffer)->fe_console_props,
                               lpFEExtraData,
                               sizeof( NT_FE_CONSOLE_PROPS )
                             );
            }
#endif
        }
    }

Cleanup:
    if (mld.pszName)
        ConsoleHeapFree( mld.pszName );
    if (mld.pszRelPath)
        ConsoleHeapFree( mld.pszRelPath );
    if (mld.pszWorkingDir)
        ConsoleHeapFree( mld.pszWorkingDir );
    if (mld.pszArgs)
        ConsoleHeapFree( mld.pszArgs );
    if (mld.pszIconLocation)
        ConsoleHeapFree( mld.pszIconLocation );
    if (mld.pExtraData)
        ConsoleHeapFree( mld.pExtraData );

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\server\output.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    output.c

Abstract:

        This file implements the video buffer management.

Author:

    Therese Stowell (thereses) 6-Nov-1990

Revision History:

Notes:

 ScreenBuffer data structure overview:

 each screen buffer has an array of ROW structures.  each ROW structure
 contains the data for one row of text.  the data stored for one row of
 text is a character array and an attribute array.  the character array
 is allocated the full length of the row from the heap, regardless of the
 non-space length. we also maintain the non-space length.  the character
 array is initialized to spaces.  the attribute
 array is run length encoded (i.e 5 BLUE, 3 RED). if there is only one
 attribute for the whole row (the normal case), it is stored in the ATTR_ROW
 structure.  otherwise the attr string is allocated from the heap.

 ROW - CHAR_ROW - CHAR string
     \          \ length of char string
      \
       ATTR_ROW - ATTR_PAIR string
                \ length of attr pair string
 ROW
 ROW
 ROW

 ScreenInfo->Rows points to the ROW array. ScreenInfo->Rows[0] is not
 necessarily the top row. ScreenInfo->BufferInfo.TextInfo.FirstRow contains the index of
 the top row.  That means scrolling (if scrolling entire screen)
 merely involves changing the FirstRow index,
 filling in the last row, and updating the screen.

--*/

#include "precomp.h"
#pragma hdrstop


//#define PROFILE_GDI
#ifdef PROFILE_GDI
LONG ScrollDCCount;
LONG ExtTextOutCount;
LONG TextColor = 1;

#define SCROLLDC_CALL ScrollDCCount++
#define TEXTOUT_CALL ExtTextOutCount++
#define TEXTCOLOR_CALL TextColor++
#else
#define SCROLLDC_CALL
#define TEXTOUT_CALL
#define TEXTCOLOR_CALL
#endif // PROFILE_GDI

#define ITEM_MAX_SIZE 256

// NOTE: we use this to communicate with progman - see Q105446 for details.
typedef struct _PMIconData {
       DWORD dwResSize;
       DWORD dwVer;
       BYTE iResource;  // icon resource
} PMICONDATA, *LPPMICONDATA;

//
// Screen dimensions
//

int ConsoleFullScreenX;
int ConsoleFullScreenY;
int ConsoleCaptionY;
int MinimumWidthX;
SHORT VerticalScrollSize;
SHORT HorizontalScrollSize;

SHORT VerticalClientToWindow;
SHORT HorizontalClientToWindow;

PCHAR_INFO ScrollBuffer;
ULONG ScrollBufferSize;
CRITICAL_SECTION ScrollBufferLock;

// this value keeps track of the number of existing console windows.
// if a window is created when this value is zero, the Face Names
// must be reenumerated because no WM_FONTCHANGE message was processed
// if there's no window.
LONG gnConsoleWindows;

BOOL gfInitSystemMetrics;

BOOL UsePolyTextOut;

HRGN ghrgnScroll;
LPRGNDATA gprgnData;

ULONG gucWheelScrollLines;

UINT guCaretBlinkTime;

#define GRGNDATASIZE  (sizeof(RGNDATAHEADER) + (6 * sizeof(RECTL)))


#define CharSizeOf(x)   (sizeof(x) / sizeof(*x))
#define LockScrollBuffer() RtlEnterCriticalSection(&ScrollBufferLock)
#define UnlockScrollBuffer() RtlLeaveCriticalSection(&ScrollBufferLock)

#define SetWindowConsole(hWnd, Console) SetWindowLongPtr((hWnd), GWLP_USERDATA, (LONG_PTR)(Console))

#ifdef LATER
#ifndef IS_IME_KBDLAYOUT
#define IS_IME_KBDLAYOUT(hkl) ((((ULONG_PTR)(hkl)) & 0xf0000000) == 0xe0000000)
#endif
#endif


void GetNonBiDiKeyboardLayout(HKL * phklActive);

VOID FreeConsoleBitmap(IN PSCREEN_INFORMATION ScreenInfo);

VOID
ScrollIfNecessary(
    IN PCONSOLE_INFORMATION Console,
    IN PSCREEN_INFORMATION ScreenInfo
    );

VOID
ProcessResizeWindow(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PCONSOLE_INFORMATION Console,
    IN LPWINDOWPOS WindowPos
    );

NTSTATUS
AllocateScrollBuffer(
    DWORD Size
    );

VOID FreeScrollBuffer ( VOID );

VOID
InternalUpdateScrollBars(
    IN PSCREEN_INFORMATION ScreenInfo
    );

#if defined(FE_SB)
BOOL
SB_PolyTextOutCandidate(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT Region
    );

VOID
SB_ConsolePolyTextOut(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT Region
    );
#endif



VOID
InitializeSystemMetrics( VOID )
{
    RECT WindowSize;

    gfInitSystemMetrics = FALSE;
    SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, &gucWheelScrollLines, FALSE);
    ConsoleFullScreenX = GetSystemMetrics(SM_CXFULLSCREEN);
    ConsoleFullScreenY = GetSystemMetrics(SM_CYFULLSCREEN);
    ConsoleCaptionY = GetSystemMetrics(SM_CYCAPTION);
    VerticalScrollSize = (SHORT)GetSystemMetrics(SM_CXVSCROLL);
    HorizontalScrollSize = (SHORT)GetSystemMetrics(SM_CYHSCROLL);
    WindowSize.left = WindowSize.top = 0;
    WindowSize.right = WindowSize.bottom = 50;
    AdjustWindowRectEx(&WindowSize,
                        CONSOLE_WINDOW_FLAGS,
                        FALSE,
                        CONSOLE_WINDOW_EX_FLAGS
                       );
    VerticalClientToWindow = (SHORT)(WindowSize.right-WindowSize.left-50);
    HorizontalClientToWindow = (SHORT)(WindowSize.bottom-WindowSize.top-50);

#ifdef LATER
    gfIsIMEEnabled = !!GetSystemMetrics(SM_IMMENABLED);
    RIPMSG1(RIP_VERBOSE, "InitializeSystemMetrics: gfIsIMEEnabled=%d", gfIsIMEEnabled);
#endif

    guCaretBlinkTime = GetCaretBlinkTime();
}

VOID
GetWindowLimits(
    IN PSCREEN_INFORMATION ScreenInfo,
    OUT PWINDOW_LIMITS WindowLimits
    )
{
    HMONITOR hMonitor;
    MONITORINFO MonitorInfo = {sizeof(MonitorInfo)};
    COORD FontSize;

    //
    // If the system metrics have changed or there aren't any console
    // windows around, reinitialize the global valeus.
    //

    if (gfInitSystemMetrics || gnConsoleWindows == 0) {
        InitializeSystemMetrics();
    }

    if (ScreenInfo->Console &&
            (ScreenInfo->Console->hWnd || !(ScreenInfo->Console->Flags & CONSOLE_AUTO_POSITION)) &&
            ((hMonitor = MonitorFromRect(&ScreenInfo->Console->WindowRect, MONITOR_DEFAULTTOPRIMARY)) != NULL) &&
            GetMonitorInfo(hMonitor, &MonitorInfo)) {
        WindowLimits->FullScreenSize.X = (SHORT)(MonitorInfo.rcWork.right - MonitorInfo.rcWork.left);
        WindowLimits->FullScreenSize.Y = (SHORT)(MonitorInfo.rcWork.bottom - MonitorInfo.rcWork.top - ConsoleCaptionY);
    } else {
        WindowLimits->FullScreenSize.X = (SHORT)ConsoleFullScreenX;
        WindowLimits->FullScreenSize.Y = (SHORT)ConsoleFullScreenY;
    }

    if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
        FontSize = SCR_FONTSIZE(ScreenInfo);
    } else {
        FontSize.X = 1;
        FontSize.Y = 1;
    }

    WindowLimits->MinimumWindowSize.X = ((MinimumWidthX - VerticalClientToWindow + FontSize.X - 1) / FontSize.X);
    WindowLimits->MinimumWindowSize.Y = 1;
    WindowLimits->MaximumWindowSize.X = min(WindowLimits->FullScreenSize.X/FontSize.X, ScreenInfo->ScreenBufferSize.X);
    WindowLimits->MaximumWindowSize.X = max(WindowLimits->MaximumWindowSize.X, WindowLimits->MinimumWindowSize.X);
    WindowLimits->MaximumWindowSize.Y = min(WindowLimits->FullScreenSize.Y/FontSize.Y, ScreenInfo->ScreenBufferSize.Y);
    WindowLimits->MaxWindow.X = WindowLimits->MaximumWindowSize.X*FontSize.X + VerticalClientToWindow;
    WindowLimits->MaxWindow.Y = WindowLimits->MaximumWindowSize.Y*FontSize.Y + HorizontalClientToWindow;
}

VOID
InitializeScreenInfo( VOID )
{
    HDC hDC;

    InitializeMouseButtons();
    MinimumWidthX = GetSystemMetrics(SM_CXMIN);

    InitializeSystemMetrics();

    hDC = CreateDCW(L"DISPLAY", NULL, NULL, NULL);
    if (hDC != NULL) {
        UsePolyTextOut = GetDeviceCaps(hDC, TEXTCAPS) & TC_SCROLLBLT;
        DeleteDC(hDC);
    }
}

NTSTATUS
DoCreateScreenBuffer(
    IN PCONSOLE_INFORMATION Console,
    IN PCONSOLE_INFO ConsoleInfo
    )

/*++

    this routine figures out what parameters to pass to CreateScreenBuffer,
    based on the data from STARTUPINFO and the defaults in win.ini,
    then calls CreateScreenBuffer.

--*/

{
    CHAR_INFO Fill,PopupFill;
    COORD dwScreenBufferSize, dwWindowSize;
    NTSTATUS Status;
    int FontIndexWant;

    if (ConsoleInfo->dwStartupFlags & STARTF_USESHOWWINDOW) {
        Console->wShowWindow = ConsoleInfo->wShowWindow;
    } else {
        Console->wShowWindow = SW_SHOWNORMAL;
    }

#if 0
    {

            INT i;

            DbgPrint("[Link Server Properties for %ws]\n", ConsoleTitle );
            DbgPrint("    wFillAttribute      = 0x%04X\n", ConsoleInfo->wFillAttribute );
            DbgPrint("    wPopupFillAttribute = 0x%04X\n", ConsoleInfo->wPopupFillAttribute );
            DbgPrint("    dwScreenBufferSize  = (%d , %d)\n", ConsoleInfo->dwScreenBufferSize.X, ConsoleInfo->dwScreenBufferSize.Y );
            DbgPrint("    dwWindowSize        = (%d , %d)\n", ConsoleInfo->dwWindowSize.X, ConsoleInfo->dwWindowSize.Y );
            DbgPrint("    dwWindowOrigin      = (%d , %d)\n", ConsoleInfo->dwWindowOrigin.X, ConsoleInfo->dwWindowOrigin.Y );
            DbgPrint("    nFont               = %d\n", ConsoleInfo->nFont );
            DbgPrint("    nInputBufferSize    = %d\n", ConsoleInfo->nInputBufferSize );
            DbgPrint("    dwFontSize          = (%d , %d)\n", ConsoleInfo->dwFontSize.X, ConsoleInfo->dwFontSize.Y );
            DbgPrint("    uFontFamily         = 0x%08X\n", ConsoleInfo->uFontFamily );
            DbgPrint("    uFontWeight         = 0x%08X\n", ConsoleInfo->uFontWeight );
            DbgPrint("    FaceName            = %ws\n", ConsoleInfo->FaceName );
            DbgPrint("    uCursorSize         = %d\n", ConsoleInfo->uCursorSize );
            DbgPrint("    bFullScreen         = %s\n", ConsoleInfo->bFullScreen ? "TRUE" : "FALSE" );
            DbgPrint("    bQuickEdit          = %s\n", ConsoleInfo->bQuickEdit  ? "TRUE" : "FALSE" );
            DbgPrint("    bInsertMode         = %s\n", ConsoleInfo->bInsertMode ? "TRUE" : "FALSE" );
            DbgPrint("    bAutoPosition       = %s\n", ConsoleInfo->bAutoPosition ? "TRUE" : "FALSE" );
            DbgPrint("    uHistoryBufferSize  = %d\n", ConsoleInfo->uHistoryBufferSize );
            DbgPrint("    uNumHistoryBuffers  = %d\n", ConsoleInfo->uNumberOfHistoryBuffers );
            DbgPrint("    bHistoryNoDup       = %s\n", ConsoleInfo->bHistoryNoDup ? "TRUE" : "FALSE" );
            DbgPrint("    ColorTable = [" );
            i=0;
            while( i < 16 )
            {
                DbgPrint("\n         ");
                DbgPrint("0x%08X ", ConsoleInfo->ColorTable[i++]);
                DbgPrint("0x%08X ", ConsoleInfo->ColorTable[i++]);
                DbgPrint("0x%08X ", ConsoleInfo->ColorTable[i++]);
                DbgPrint("0x%08X ", ConsoleInfo->ColorTable[i++]);
            }
            DbgPrint( "]\n\n" );
        }
#endif

    //
    // Get values from consoleinfo (which was initialized through link)
    //

    Fill.Attributes = ConsoleInfo->wFillAttribute;
    Fill.Char.UnicodeChar = (WCHAR)' ';
    PopupFill.Attributes = ConsoleInfo->wPopupFillAttribute;
    PopupFill.Char.UnicodeChar = (WCHAR)' ';

    dwScreenBufferSize = ConsoleInfo->dwScreenBufferSize;
    if (!(ConsoleInfo->dwStartupFlags & STARTF_USECOUNTCHARS)) {
        if (Console->Flags & CONSOLE_NO_WINDOW) {
            dwScreenBufferSize.X = min(dwScreenBufferSize.X, 80);
            dwScreenBufferSize.Y = min(dwScreenBufferSize.Y, 25);
        }
    }
    if (dwScreenBufferSize.X == 0)
        dwScreenBufferSize.X = 1;
    if (dwScreenBufferSize.Y == 0)
        dwScreenBufferSize.Y = 1;

    //
    // Grab font
    //
#if defined(FE_SB)
    FontIndexWant = FindCreateFont(ConsoleInfo->uFontFamily,
                                   ConsoleInfo->FaceName,
                                   ConsoleInfo->dwFontSize,
                                   ConsoleInfo->uFontWeight,
                                   ConsoleInfo->uCodePage
                                  );
#else
    FontIndexWant = FindCreateFont(ConsoleInfo->uFontFamily,
                                   ConsoleInfo->FaceName,
                                   ConsoleInfo->dwFontSize,
                                   ConsoleInfo->uFontWeight);
#endif

    //
    // grab window size information
    //

    dwWindowSize = ConsoleInfo->dwWindowSize;
    if (ConsoleInfo->dwStartupFlags & STARTF_USESIZE) {
        dwWindowSize.X /= FontInfo[FontIndexWant].Size.X;
        dwWindowSize.Y /= FontInfo[FontIndexWant].Size.Y;
    } else if (Console->Flags & CONSOLE_NO_WINDOW) {
        dwWindowSize.X = min(dwWindowSize.X, 80);
        dwWindowSize.Y = min(dwWindowSize.Y, 25);
    }
    if (dwWindowSize.X == 0)
        dwWindowSize.X = 1;
    if (dwWindowSize.Y == 0)
        dwWindowSize.Y = 1;

    if (dwScreenBufferSize.X < dwWindowSize.X)
        dwScreenBufferSize.X = dwWindowSize.X;
    if (dwScreenBufferSize.Y < dwWindowSize.Y)
        dwScreenBufferSize.Y = dwWindowSize.Y;

    Console->dwWindowOriginX = ConsoleInfo->dwWindowOrigin.X;
    Console->dwWindowOriginY = ConsoleInfo->dwWindowOrigin.Y;

    if (ConsoleInfo->bAutoPosition) {
        Console->Flags |= CONSOLE_AUTO_POSITION;
        Console->dwWindowOriginX = CW_USEDEFAULT;
    } else {
        Console->WindowRect.left = Console->dwWindowOriginX;
        Console->WindowRect.top = Console->dwWindowOriginY;
        Console->WindowRect.right = Console->dwWindowOriginX + dwWindowSize.X * FontInfo[FontIndexWant].Size.X;
        Console->WindowRect.bottom = Console->dwWindowOriginY + dwWindowSize.Y * FontInfo[FontIndexWant].Size.Y;
    }

#ifdef i386
    if (FullScreenInitialized && !GetSystemMetrics(SM_REMOTESESSION)) {
        if (ConsoleInfo->bFullScreen) {
            Console->FullScreenFlags = CONSOLE_FULLSCREEN;
        }
    }
#endif
    if (ConsoleInfo->bQuickEdit) {
        Console->Flags |= CONSOLE_QUICK_EDIT_MODE;
    }
    Console->Flags |= CONSOLE_USE_PRIVATE_FLAGS;

    Console->InsertMode = (ConsoleInfo->bInsertMode != FALSE);
    Console->CommandHistorySize = (SHORT)ConsoleInfo->uHistoryBufferSize;
    Console->MaxCommandHistories = (SHORT)ConsoleInfo->uNumberOfHistoryBuffers;
    if (ConsoleInfo->bHistoryNoDup) {
        Console->Flags |= CONSOLE_HISTORY_NODUP;
    } else {
        Console->Flags &= ~CONSOLE_HISTORY_NODUP;
    }
    RtlCopyMemory(Console->ColorTable, ConsoleInfo->ColorTable, sizeof( Console->ColorTable ));

#if defined(FE_SB)
    // for FarEast version, we want get the code page from registry or shell32,
    // so we can specify console codepage by console.cpl or shell32
    // default codepage is OEMCP. scotthsu
    Console->CP = ConsoleInfo->uCodePage;
    Console->OutputCP = ConsoleInfo->uCodePage;
#if 0
    if (CONSOLE_IS_DBCS_ENABLED()){
        Console->fIsDBCSCP = !!IsAvailableFarEastCodePage(Console->CP);
        Console->fIsDBCSOutputCP = !!IsAvailableFarEastCodePage(Console->OutputCP);
    }
    else {
        Console->fIsDBCSCP = FALSE;
        Console->fIsDBCSOutputCP = FALSE;
    }
#else
    Console->fIsDBCSCP = CONSOLE_IS_DBCS_ENABLED() && IsAvailableFarEastCodePage(Console->CP);
    Console->fIsDBCSOutputCP = CONSOLE_IS_DBCS_ENABLED() && IsAvailableFarEastCodePage(Console->OutputCP);
#endif
#endif
#if defined(FE_IME)
    Console->ConsoleIme.ScrollWaitTimeout = guCaretBlinkTime * 2;
#endif
TryNewSize:
    Status = CreateScreenBuffer(&Console->ScreenBuffers,
                                dwWindowSize,
                                FontIndexWant,
                                dwScreenBufferSize,
                                Fill,
                                PopupFill,
                                Console,
                                CONSOLE_TEXTMODE_BUFFER,
                                NULL,
                                NULL,
                                NULL,
                                ConsoleInfo->uCursorSize,
                                ConsoleInfo->FaceName
                               );
    if (Status == STATUS_NO_MEMORY) {
        //
        // If we failed to create a large buffer, try again with a small one.
        //
        if (dwScreenBufferSize.X > 80 || dwScreenBufferSize.Y > 50) {
            dwScreenBufferSize.X = min(dwScreenBufferSize.X, 80);
            dwScreenBufferSize.Y = min(dwScreenBufferSize.Y, 50);
            dwWindowSize.X = min(dwWindowSize.X, dwScreenBufferSize.X);
            dwWindowSize.Y = min(dwWindowSize.Y, dwScreenBufferSize.Y);
            Console->Flags |= CONSOLE_DEFAULT_BUFFER_SIZE;
            goto TryNewSize;
        }
    }

    return Status;
}

NTSTATUS
CreateScreenBuffer(
    OUT PSCREEN_INFORMATION *ScreenInformation,
    IN COORD dwWindowSize,
    IN DWORD nFont,
    IN COORD dwScreenBufferSize,
    IN CHAR_INFO Fill,
    IN CHAR_INFO PopupFill,
    IN PCONSOLE_INFORMATION Console,
    IN DWORD Flags,
    IN PCONSOLE_GRAPHICS_BUFFER_INFO GraphicsBufferInfo OPTIONAL,
    OUT PVOID *lpBitmap OPTIONAL,
    OUT HANDLE *hMutex OPTIONAL,
    IN UINT CursorSize,
    IN LPWSTR FaceName
    )

/*++

Routine Description:

    This routine allocates and initializes the data associated with a screen
    buffer.  It also creates a window.

Arguments:

    ScreenInformation - the new screen buffer.

    dwWindowSize - the initial size of screen buffer's window (in rows/columns)

    nFont - the initial font to generate text with.

    dwScreenBufferSize - the initial size of the screen buffer (in rows/columns).

Return Value:


--*/

{
    LONG i,j;
    PSCREEN_INFORMATION ScreenInfo;
    NTSTATUS Status;
    PWCHAR TextRowPtr;
#if defined(FE_SB)
    PBYTE AttrRowPtr;
#endif
    WINDOW_LIMITS WindowLimits;

    DBGPRINT(("CreateScreenBuffer(\n"
              "    OUT PSCREEN_INFORMATION = %lx\n"
              "    dwWindowSize = (%d,%d)\n"
              "    nFont = %x\n"
              "    dwScreenBufferSize = (%d,%d)\n"
              "    Fill\n"
              "    PopupFill\n",
              ScreenInformation,
              dwWindowSize.X, dwWindowSize.Y,
              nFont,
              dwScreenBufferSize.X, dwScreenBufferSize.Y
              // Fill,
              // PopupFill
              ));
    DBGPRINT(("    PCONSOLE_INFORMATION = %lx\n"
              "    Flags = %lx\n"
              "    GraphicsBufferInfo\n"
              "    lpBitmap\n"
              "    *hMutex\n"
              "    ConsoleTitle \"%ls\"\n",
              Console,
              Flags,
              // GraphicsBufferInfo,
              // lpBitmap,
              // hMutex,
              Console->Title));

    /*
     * Make sure we have a valid font. Bail if no fonts are available.
     */
    ASSERT(nFont < NumberOfFonts);
    if (NumberOfFonts == 0) {
        return STATUS_UNSUCCESSFUL;
    }

    /*
     * CONSIDER (adams): Allocate and zero memory, so
     * initialization is only of non-zero members.
     */
    ScreenInfo = (PSCREEN_INFORMATION)ConsoleHeapAlloc(MAKE_TAG( SCREEN_TAG ),sizeof(SCREEN_INFORMATION));
    if (ScreenInfo == NULL) {
        return STATUS_NO_MEMORY;
    }
    ScreenInfo->Console = Console;
    if ((ScreenInfo->Flags = Flags) & CONSOLE_TEXTMODE_BUFFER) {

        ASSERT(FontInfo[nFont].FaceName != NULL);

        ScreenInfo->BufferInfo.TextInfo.ListOfTextBufferFont = NULL;

        Status = StoreTextBufferFontInfo(ScreenInfo,
                                         nFont,
                                         FontInfo[nFont].Size,
                                         FontInfo[nFont].Family,
                                         FontInfo[nFont].Weight,
                                         FaceName ? FaceName : FontInfo[nFont].FaceName,
                                         Console->OutputCP);
        if (!NT_SUCCESS(Status)) {
            ConsoleHeapFree(ScreenInfo);
            return((ULONG) Status);
        }

        DBGFONTS(("DoCreateScreenBuffer sets FontSize(%d,%d), FontNumber=%x, Family=%x\n",
                SCR_FONTSIZE(ScreenInfo).X,
                SCR_FONTSIZE(ScreenInfo).Y,
                SCR_FONTNUMBER(ScreenInfo),
                SCR_FAMILY(ScreenInfo)));

        if (TM_IS_TT_FONT(FontInfo[nFont].Family)) {
            ScreenInfo->Flags &= ~CONSOLE_OEMFONT_DISPLAY;
        } else {
            ScreenInfo->Flags |= CONSOLE_OEMFONT_DISPLAY;
        }

        ScreenInfo->ScreenBufferSize = dwScreenBufferSize;
        GetWindowLimits(ScreenInfo, &WindowLimits);
        dwScreenBufferSize.X = max(dwScreenBufferSize.X, WindowLimits.MinimumWindowSize.X);
        dwWindowSize.X = max(dwWindowSize.X, WindowLimits.MinimumWindowSize.X);

        ScreenInfo->BufferInfo.TextInfo.ModeIndex = (ULONG)-1;
#ifdef i386
        if (Console->FullScreenFlags & CONSOLE_FULLSCREEN) {
            COORD WindowSize;
            ScreenInfo->BufferInfo.TextInfo.WindowedWindowSize = dwWindowSize;
            ScreenInfo->BufferInfo.TextInfo.WindowedScreenSize = dwScreenBufferSize;
            ScreenInfo->BufferInfo.TextInfo.ModeIndex = MatchWindowSize(Console->OutputCP,dwWindowSize,&WindowSize);
        }
#endif
        ScreenInfo->BufferInfo.TextInfo.FirstRow = 0;
        ScreenInfo->BufferInfo.TextInfo.Rows = (PROW)ConsoleHeapAlloc(MAKE_TAG( SCREEN_TAG ),dwScreenBufferSize.Y * sizeof(ROW));
        if (ScreenInfo->BufferInfo.TextInfo.Rows == NULL) {
            RemoveTextBufferFontInfo(ScreenInfo);
            ConsoleHeapFree(ScreenInfo);
            return STATUS_NO_MEMORY;
        }
        ScreenInfo->BufferInfo.TextInfo.TextRows = (PWCHAR)ConsoleHeapAlloc(MAKE_TAG( SCREEN_TAG ),dwScreenBufferSize.X*dwScreenBufferSize.Y*sizeof(WCHAR));
        if (ScreenInfo->BufferInfo.TextInfo.TextRows == NULL) {
            ConsoleHeapFree(ScreenInfo->BufferInfo.TextInfo.Rows);
            RemoveTextBufferFontInfo(ScreenInfo);
            ConsoleHeapFree(ScreenInfo);
            return STATUS_NO_MEMORY;
        }
#if defined(FE_SB)
        if (!CreateDbcsScreenBuffer(Console, dwScreenBufferSize, &ScreenInfo->BufferInfo.TextInfo.DbcsScreenBuffer)) {
            ConsoleHeapFree(ScreenInfo->BufferInfo.TextInfo.TextRows);
            ConsoleHeapFree(ScreenInfo->BufferInfo.TextInfo.Rows);
            RemoveTextBufferFontInfo(ScreenInfo);
            ConsoleHeapFree(ScreenInfo);
            return STATUS_NO_MEMORY;
        }

        AttrRowPtr=ScreenInfo->BufferInfo.TextInfo.DbcsScreenBuffer.KAttrRows;
#endif
        for (i=0,TextRowPtr=ScreenInfo->BufferInfo.TextInfo.TextRows;
             i<dwScreenBufferSize.Y;
             i++,TextRowPtr+=dwScreenBufferSize.X)
        {
            ScreenInfo->BufferInfo.TextInfo.Rows[i].CharRow.Left = dwScreenBufferSize.X;
            ScreenInfo->BufferInfo.TextInfo.Rows[i].CharRow.OldLeft = INVALID_OLD_LENGTH;
            ScreenInfo->BufferInfo.TextInfo.Rows[i].CharRow.Right = 0;
            ScreenInfo->BufferInfo.TextInfo.Rows[i].CharRow.OldRight = INVALID_OLD_LENGTH;
            ScreenInfo->BufferInfo.TextInfo.Rows[i].CharRow.Chars = TextRowPtr;
#if defined(FE_SB)
            ScreenInfo->BufferInfo.TextInfo.Rows[i].CharRow.KAttrs = AttrRowPtr;
#endif
            for (j=0;j<dwScreenBufferSize.X;j++) {
                TextRowPtr[j] = (WCHAR)' ';
            }
#if defined(FE_SB)
            if (AttrRowPtr) {
                RtlZeroMemory(AttrRowPtr, dwScreenBufferSize.X);
                AttrRowPtr+=dwScreenBufferSize.X;
            }
#endif
            ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.Length = 1;
            ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.AttrPair.Length = dwScreenBufferSize.X;
            ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.AttrPair.Attr = Fill.Attributes;
            ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.Attrs = &ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.AttrPair;

        }
        ScreenInfo->BufferInfo.TextInfo.CursorSize = CursorSize;
        ScreenInfo->BufferInfo.TextInfo.CursorPosition.X = 0;
        ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y = 0;
        ScreenInfo->BufferInfo.TextInfo.CursorMoved = FALSE;
        ScreenInfo->BufferInfo.TextInfo.CursorVisible = TRUE;
        ScreenInfo->BufferInfo.TextInfo.CursorOn = FALSE;
        ScreenInfo->BufferInfo.TextInfo.CursorYSize = (WORD)CURSOR_SIZE_IN_PIXELS(SCR_FONTSIZE(ScreenInfo).Y,ScreenInfo->BufferInfo.TextInfo.CursorSize);
        ScreenInfo->BufferInfo.TextInfo.UpdatingScreen = 0;
        ScreenInfo->BufferInfo.TextInfo.DoubleCursor = FALSE;
        ScreenInfo->BufferInfo.TextInfo.DelayCursor = FALSE;
        ScreenInfo->BufferInfo.TextInfo.Flags = SINGLE_ATTRIBUTES_PER_LINE;
        ScreenInfo->ScreenBufferSize = dwScreenBufferSize;
        ScreenInfo->Window.Left = 0;
        ScreenInfo->Window.Top = 0;
        ScreenInfo->Window.Right = dwWindowSize.X - 1;
        ScreenInfo->Window.Bottom = dwWindowSize.Y - 1;
        if (ScreenInfo->Window.Right >= WindowLimits.MaximumWindowSize.X) {
            ScreenInfo->Window.Right = WindowLimits.MaximumWindowSize.X-1;
            dwWindowSize.X = CONSOLE_WINDOW_SIZE_X(ScreenInfo);
        }
        if (ScreenInfo->Window.Bottom >= WindowLimits.MaximumWindowSize.Y) {
            ScreenInfo->Window.Bottom = WindowLimits.MaximumWindowSize.Y-1;
            dwWindowSize.Y = CONSOLE_WINDOW_SIZE_Y(ScreenInfo);
        }
        ScreenInfo->WindowMaximizedX = (dwWindowSize.X == dwScreenBufferSize.X);
        ScreenInfo->WindowMaximizedY = (dwWindowSize.Y == dwScreenBufferSize.Y);
#if defined(FE_SB)
#if defined(_X86_)
        ScreenInfo->BufferInfo.TextInfo.MousePosition.X = 0;
        ScreenInfo->BufferInfo.TextInfo.MousePosition.Y = 0;
#endif // i386

        ScreenInfo->BufferInfo.TextInfo.CursorBlink = TRUE;
        ScreenInfo->BufferInfo.TextInfo.CursorDBEnable = TRUE;
#endif

    }
    else {
        Status = CreateConsoleBitmap(GraphicsBufferInfo,
                              ScreenInfo,
                              lpBitmap,
                              hMutex
                             );
        if (!NT_SUCCESS(Status)) {
            ConsoleHeapFree(ScreenInfo);
            return Status;
        }
        ScreenInfo->WindowMaximizedX = TRUE;
        ScreenInfo->WindowMaximizedY = TRUE;
    }

    ScreenInfo->WindowMaximized = FALSE;
    ScreenInfo->RefCount = 0;
    ScreenInfo->ShareAccess.OpenCount = 0;
    ScreenInfo->ShareAccess.Readers = 0;
    ScreenInfo->ShareAccess.Writers = 0;
    ScreenInfo->ShareAccess.SharedRead = 0;
    ScreenInfo->ShareAccess.SharedWrite = 0;
    ScreenInfo->CursorHandle = ghNormalCursor;
    ScreenInfo->CursorDisplayCount = 0;
    ScreenInfo->CommandIdLow = (UINT)-1;
    ScreenInfo->CommandIdHigh = (UINT)-1;
    ScreenInfo->dwUsage = SYSPAL_STATIC;
    ScreenInfo->hPalette = NULL;

    ScreenInfo->OutputMode = ENABLE_PROCESSED_OUTPUT | ENABLE_WRAP_AT_EOL_OUTPUT;


    ScreenInfo->ResizingWindow = 0;
    ScreenInfo->Next = NULL;
    ScreenInfo->Attributes = Fill.Attributes;
    ScreenInfo->PopupAttributes = PopupFill.Attributes;

    ScreenInfo->WheelDelta = 0;

#if defined(FE_SB)
    ScreenInfo->WriteConsoleDbcsLeadByte[0] = 0;
    ScreenInfo->BisectFlag = 0;
    if (Flags & CONSOLE_TEXTMODE_BUFFER) {
        SetLineChar(ScreenInfo);
    }
    ScreenInfo->FillOutDbcsLeadChar = 0;
    ScreenInfo->ConvScreenInfo = NULL;
#endif

    *ScreenInformation = ScreenInfo;
    DBGOUTPUT(("SCREEN at %lx\n", ScreenInfo));
    return STATUS_SUCCESS;
}

VOID
PositionConsoleWindow(
    IN PCONSOLE_INFORMATION Console,
    IN BOOL Initialize
    )
{
    GetWindowRect(Console->hWnd, &Console->WindowRect);

    //
    // If this is an autoposition window being initialized, make sure it's
    // client area doesn't descend below the tray
    //

    if (Initialize && (Console->Flags & CONSOLE_AUTO_POSITION)) {
        RECT ClientRect;
        LONG dx = 0;
        LONG dy = 0;
        HMONITOR hMonitor;
        MONITORINFO MonitorInfo = {sizeof(MonitorInfo)};

        hMonitor = MonitorFromRect(&Console->WindowRect, MONITOR_DEFAULTTONULL);
        if (hMonitor && GetMonitorInfo(hMonitor, &MonitorInfo)) {
            GetClientRect(Console->hWnd, &ClientRect);
            ClientToScreen(Console->hWnd, (LPPOINT)&ClientRect.left);
            ClientToScreen(Console->hWnd, (LPPOINT)&ClientRect.right);
            if (Console->WindowRect.right > MonitorInfo.rcWork.right) {
                dx = max(min((Console->WindowRect.right - MonitorInfo.rcWork.right),
                             (Console->WindowRect.left - MonitorInfo.rcWork.left)),
                         min((ClientRect.right - MonitorInfo.rcWork.right),
                             (ClientRect.left - MonitorInfo.rcWork.left)));
            }
            if (Console->WindowRect.bottom > MonitorInfo.rcWork.bottom) {
                dy = max(min((Console->WindowRect.bottom - MonitorInfo.rcWork.bottom),
                             (Console->WindowRect.top - MonitorInfo.rcWork.top)),
                         min((ClientRect.bottom - MonitorInfo.rcWork.bottom),
                             (ClientRect.top - MonitorInfo.rcWork.top)));
            }
            if (dx || dy) {
                SetWindowPos(Console->hWnd,
                             NULL,
                             Console->WindowRect.left - dx,
                             Console->WindowRect.top - dy,
                             0,
                             0,
                             SWP_NOACTIVATE | SWP_NOSIZE | SWP_NOZORDER);
            }
        }
    }
}

/*
 * Bug 273518 - joejo
 *
 * This will allow console windows to set foreground correctly on new
 * process' it launches, as opposed it just forcing foreground.
 */
NTSTATUS
ConsoleSetActiveWindow(
    IN PCONSOLE_INFORMATION Console
    )
{
    HWND hWnd = Console->hWnd;
    HANDLE ConsoleHandle = Console->ConsoleHandle;

    UnlockConsole(Console);
    SetActiveWindow(hWnd);
    return RevalidateConsole(ConsoleHandle, &Console);
}

NTSTATUS
CreateWindowsWindow(
    IN PCONSOLE_INFORMATION Console
    )
{
    PSCREEN_INFORMATION ScreenInfo;
    SIZE WindowSize;
    DWORD Style;
    THREAD_BASIC_INFORMATION ThreadInfo;
    HWND hWnd;

    ScreenInfo = Console->ScreenBuffers;

    //
    // figure out how big to make the window, given the desired client area
    // size.  window is always created in textmode.
    //

    ASSERT(ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER);
    WindowSize.cx = CONSOLE_WINDOW_SIZE_X(ScreenInfo)*SCR_FONTSIZE(ScreenInfo).X + VerticalClientToWindow;
    WindowSize.cy = CONSOLE_WINDOW_SIZE_Y(ScreenInfo)*SCR_FONTSIZE(ScreenInfo).Y + HorizontalClientToWindow;
    Style = CONSOLE_WINDOW_FLAGS & ~WS_VISIBLE;
    if (!ScreenInfo->WindowMaximizedX) {
        WindowSize.cy += HorizontalScrollSize;
    } else {
        Style &= ~WS_HSCROLL;
    }
    if (!ScreenInfo->WindowMaximizedY) {
        WindowSize.cx += VerticalScrollSize;
    } else {
        Style &= ~WS_VSCROLL;
    }

    //
    // create the window.
    //

    Console->WindowRect.left = Console->dwWindowOriginX;
    Console->WindowRect.top = Console->dwWindowOriginY;
    Console->WindowRect.right = WindowSize.cx + Console->dwWindowOriginX;
    Console->WindowRect.bottom = WindowSize.cy + Console->dwWindowOriginY;
    hWnd = CreateWindowEx(CONSOLE_WINDOW_EX_FLAGS,
                          CONSOLE_WINDOW_CLASS,
                          Console->Title,
                          Style,
                          Console->dwWindowOriginX,
                          Console->dwWindowOriginY,
                          WindowSize.cx,
                          WindowSize.cy,
                          (Console->Flags & CONSOLE_NO_WINDOW) ? HWND_MESSAGE : HWND_DESKTOP,
                          NULL,
                          ghInstance,
                          NULL);
    if (hWnd == NULL) {
        NtSetEvent(Console->InitEvents[INITIALIZATION_FAILED],NULL);
        return STATUS_NO_MEMORY;
    }
    Console->hWnd = hWnd;

    SetWindowConsole(hWnd, Console);

    //
    // Stuff the client id into the window so USER can find it.
    //

    if (NT_SUCCESS(NtQueryInformationThread(Console->ClientThreadHandle,
            ThreadBasicInformation, &ThreadInfo,
            sizeof(ThreadInfo), NULL))) {

        SetConsolePid(Console->hWnd, HandleToUlong(ThreadInfo.ClientId.UniqueProcess));
        SetConsoleTid(Console->hWnd, HandleToUlong(ThreadInfo.ClientId.UniqueThread));
    }

    //
    // Get the dc.
    //

    Console->hDC = GetDC(Console->hWnd);

    if (Console->hDC == NULL) {
        NtSetEvent(Console->InitEvents[INITIALIZATION_FAILED],NULL);
        DestroyWindow(Console->hWnd);
        Console->hWnd = NULL;
        return STATUS_NO_MEMORY;
    }
    Console->hMenu = GetSystemMenu(Console->hWnd,FALSE);

    //
    // modify system menu to our liking.
    //

    InitSystemMenu(Console);

    gnConsoleWindows++;
    Console->InputThreadInfo->WindowCount++;

#if defined(FE_IME)
    SetUndetermineAttribute(Console);
#endif
#if defined(FE_SB)
    RegisterKeisenOfTTFont(ScreenInfo);
#endif

    //
    // Set up the hot key for this window
    //
    if ((Console->dwHotKey != 0) && !(Console->Flags & CONSOLE_NO_WINDOW)) {
        SendMessage(Console->hWnd, WM_SETHOTKEY, Console->dwHotKey, 0L);
    }

    //
    // create icon
    //

    if (Console->iIconId) {

        // We have no icon, try and get one from progman.

        PostMessage(HWND_BROADCAST,
                    ProgmanHandleMessage,
                    (WPARAM)Console->hWnd,
                    1);
    }
    if (Console->hIcon == NULL) {
        Console->hIcon = ghDefaultIcon;
        Console->hSmIcon = ghDefaultSmIcon;
    } else if (Console->hIcon != ghDefaultIcon) {
        SendMessage(Console->hWnd, WM_SETICON, ICON_BIG, (LPARAM)Console->hIcon);
        SendMessage(Console->hWnd, WM_SETICON, ICON_SMALL, (LPARAM)Console->hSmIcon);
    }

    SetBkMode(Console->hDC,OPAQUE);
    SetFont(ScreenInfo);
    SelectObject(Console->hDC, GetStockObject(DC_BRUSH));
    SetScreenColors(ScreenInfo, ScreenInfo->Attributes,
                    ScreenInfo->PopupAttributes, FALSE);
    if (Console->Flags & CONSOLE_NO_WINDOW) {
        ShowWindowAsync(Console->hWnd, SW_HIDE);
#ifdef i386
    } else if (Console->FullScreenFlags != 0) {
        if (Console->wShowWindow == SW_SHOWMINNOACTIVE) {
            ShowWindowAsync(Console->hWnd, Console->wShowWindow);
            Console->FullScreenFlags = 0;
            Console->Flags |= CONSOLE_IS_ICONIC;
        } else {
            ConvertToFullScreen(Console);
            if (!NT_SUCCESS(ConsoleSetActiveWindow(Console))) {
                return STATUS_INVALID_HANDLE;
            }

            ChangeDispSettings(Console, Console->hWnd,CDS_FULLSCREEN);
        }
#endif
    } else {
        if (Console->wShowWindow != SW_SHOWNOACTIVATE &&
            Console->wShowWindow != SW_SHOWMINNOACTIVE &&
            Console->wShowWindow != SW_HIDE) {
            if (!NT_SUCCESS(ConsoleSetActiveWindow(Console))) {
                return STATUS_INVALID_HANDLE;
            }
        } else if (Console->wShowWindow == SW_SHOWMINNOACTIVE) {
            Console->Flags |= CONSOLE_IS_ICONIC;
        }
        ShowWindowAsync(Console->hWnd, Console->wShowWindow);
    }

    //UpdateWindow(Console->hWnd);
    InternalUpdateScrollBars(ScreenInfo);
    if (!(Console->Flags & CONSOLE_IS_ICONIC) &&
         (Console->FullScreenFlags == 0) ) {

        PositionConsoleWindow(Console, TRUE);
    }

#if defined(FE_IME)
    if (CONSOLE_IS_IME_ENABLED() && !(Console->Flags & CONSOLE_NO_WINDOW)) {
        SetTimer(Console->hWnd, SCROLL_WAIT_TIMER, guCaretBlinkTime, NULL);
    }
#endif
    NtSetEvent(Console->InitEvents[INITIALIZATION_SUCCEEDED],NULL);
    return STATUS_SUCCESS;
}

NTSTATUS
FreeScreenBuffer(
    IN PSCREEN_INFORMATION ScreenInfo
    )

/*++

Routine Description:

    This routine frees the memory associated with a screen buffer.

Arguments:

    ScreenInfo - screen buffer data to free.

Return Value:

Note: console handle table lock must be held when calling this routine

--*/

{
    SHORT i;
    PCONSOLE_INFORMATION Console = ScreenInfo->Console;

    ASSERT(ScreenInfo->RefCount == 0);
    if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
        for (i=0;i<ScreenInfo->ScreenBufferSize.Y;i++) {
            if (ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.Length > 1) {
                ConsoleHeapFree(ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.Attrs);
            }
        }
        ConsoleHeapFree(ScreenInfo->BufferInfo.TextInfo.TextRows);
        ConsoleHeapFree(ScreenInfo->BufferInfo.TextInfo.Rows);
#if defined(FE_SB)
        DeleteDbcsScreenBuffer(&ScreenInfo->BufferInfo.TextInfo.DbcsScreenBuffer);
#endif
        RemoveTextBufferFontInfo(ScreenInfo);
    } else {
        if (ScreenInfo->hPalette != NULL) {
            if (GetCurrentObject(Console->hDC, OBJ_PAL) == ScreenInfo->hPalette) {
                SelectPalette(Console->hDC, Console->hSysPalette, FALSE);
            }
            DeleteObject(ScreenInfo->hPalette);
        }
        FreeConsoleBitmap(ScreenInfo);
    }
    ConsoleHeapFree(ScreenInfo);
    return STATUS_SUCCESS;
}

VOID
FindAttrIndex(
    IN PATTR_PAIR String,
    IN SHORT Index,
    OUT PATTR_PAIR *IndexedAttr,
    OUT PSHORT CountOfAttr
    )

/*++

Routine Description:

    This routine finds the nth attribute in a string.

Arguments:

    String - attribute string

    Index - which attribute to find

    IndexedAttr - pointer to attribute within string

    CountOfAttr - on output, contains corrected length of indexed attr.
    for example, if the attribute string was { 5, BLUE } and the requested
    index was 3, CountOfAttr would be 2.

Return Value:

    none.

--*/

{
    SHORT i;

    for (i=0;i<Index;) {
        i += String->Length;
        String++;
    }

    if (i>Index) {
        String--;
        *CountOfAttr = i-Index;
    }
    else {
        *CountOfAttr = String->Length;
    }
    *IndexedAttr = String;
}



NTSTATUS
MergeAttrStrings(
    IN PATTR_PAIR Source,
    IN WORD SourceLength,
    IN PATTR_PAIR Merge,
    IN WORD MergeLength,
    OUT PATTR_PAIR *Target,
    OUT LPWORD TargetLength,
    IN SHORT StartIndex,
    IN SHORT EndIndex,
    IN PROW Row,
    IN PSCREEN_INFORMATION ScreenInfo
    )

/*++

Routine Description:

    This routine merges two run-length encoded attribute strings into
    a third.

    for example, if the source string was { 4, BLUE }, the merge string
    was { 2, RED }, and the StartIndex and EndIndex were 1 and 2,
    respectively, the target string would be { 1, BLUE, 2, RED, 1, BLUE }
    and the target length would be 3.

Arguments:

    Source - pointer to source attribute string

    SourceLength - length of source.  for example, the length of
    { 4, BLUE } is 1.

    Merge - pointer to attribute string to insert into source

    MergeLength - length of merge

    Target - where to store pointer to resulting attribute string

    TargetLength - where to store length of resulting attribute string

    StartIndex - index into Source at which to insert Merge String.

    EndIndex - index into Source at which to stop insertion of Merge String

Return Value:

    none.

--*/
{
    PATTR_PAIR SrcAttr,TargetAttr,SrcEnd;
    PATTR_PAIR NewString;
    SHORT i;

    //
    // if just changing the attr for the whole row
    //

    if (MergeLength == 1 && Row->AttrRow.Length == 1) {
        if (Row->AttrRow.Attrs->Attr == Merge->Attr) {
            *TargetLength = 1;
            *Target = &Row->AttrRow.AttrPair;
            return STATUS_SUCCESS;
        }
        if (StartIndex == 0 && EndIndex == (SHORT)(ScreenInfo->ScreenBufferSize.X-1)) {
            NewString = &Row->AttrRow.AttrPair;
            NewString->Attr = Merge->Attr;
            *TargetLength = 1;
            *Target = NewString;
            return STATUS_SUCCESS;
        }
    }

    NewString = (PATTR_PAIR) ConsoleHeapAlloc(MAKE_TAG( SCREEN_TAG ),(SourceLength+MergeLength+1)*sizeof(ATTR_PAIR));
    if (NewString == NULL) {
        return STATUS_NO_MEMORY;
    }

    //
    // copy the source string, up to the start index.
    //

    SrcAttr = Source;
    SrcEnd = Source + SourceLength;
    TargetAttr = NewString;
    i=0;
    if (StartIndex != 0) {
        while (i<StartIndex) {
            i += SrcAttr->Length;
            *TargetAttr++ = *SrcAttr++;
        }

        //
        // back up to the last pair copied, in case the attribute in the first
        // pair in the merge string matches.  also, adjust TargetAttr->Length
        // based on i, the attribute
        // counter, back to the StartIndex.  i will be larger than the
        // StartIndex in the case where the last attribute pair copied had
        // a length greater than the number needed to reach StartIndex.
        //

        TargetAttr--;
        if (i>StartIndex) {
            TargetAttr->Length -= i-StartIndex;
        }
        if (Merge->Attr == TargetAttr->Attr) {
            TargetAttr->Length += Merge->Length;
            MergeLength-=1;
            Merge++;
        }
        TargetAttr++;
    }

    //
    // copy the merge string.
    //

    RtlCopyMemory(TargetAttr,Merge,MergeLength*sizeof(ATTR_PAIR));
    TargetAttr += MergeLength;

    //
    // figure out where to resume copying the source string.
    //

    while (i<=EndIndex) {
        ASSERT(SrcAttr != SrcEnd);
        i += SrcAttr->Length;
        SrcAttr++;
    }

    //
    // if not done, copy the rest of the source
    //

    if (SrcAttr != SrcEnd || i!=(SHORT)(EndIndex+1)) {

        //
        // see if we've gone past the right attribute.  if so, back up and
        // copy the attribute and the correct length.
        //

        TargetAttr--;
        if (i>(SHORT)(EndIndex+1)) {
            SrcAttr--;
            if (TargetAttr->Attr == SrcAttr->Attr) {
                TargetAttr->Length += i-(EndIndex+1);
            } else {
                TargetAttr++;
                TargetAttr->Attr = SrcAttr->Attr;
                TargetAttr->Length = (SHORT)(i-(EndIndex+1));
            }
            SrcAttr++;
        }

        //
        // see if we can merge the source and target.
        //

        else if (TargetAttr->Attr == SrcAttr->Attr) {
            TargetAttr->Length += SrcAttr->Length;
            i += SrcAttr->Length;
            SrcAttr++;
        }
        TargetAttr++;

        //
        // copy the rest of the source
        //

        if (SrcAttr < SrcEnd) {
            RtlCopyMemory(TargetAttr,SrcAttr,(SrcEnd-SrcAttr)*sizeof(ATTR_PAIR));
            TargetAttr += SrcEnd - SrcAttr;
        }
    }

    *TargetLength = (WORD)(TargetAttr - NewString);
    *Target = NewString;
    if (*TargetLength == 1) {
        *Target = &Row->AttrRow.AttrPair;
        **Target = *NewString;
        ConsoleHeapFree(NewString);
    }
    return STATUS_SUCCESS;
}

VOID
ResetTextFlags(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN SHORT StartX,
    IN SHORT StartY,
    IN SHORT EndX,
    IN SHORT EndY
    )
{
    SHORT RowIndex;
    PROW Row;
    WCHAR Char;
    PATTR_PAIR Attr;
    SHORT CountOfAttr;
    SHORT i;

    //
    // Fire off a winevent to let accessibility apps know what changed.
    //

    if (ACTIVE_SCREEN_BUFFER(ScreenInfo)) {
#if DBG
        if (StartX > EndX) {
            RIPMSG2(RIP_WARNING, "StartX (%d) > EndX (%d)", StartX, EndX);
        }
#endif
        ASSERT(EndX < ScreenInfo->ScreenBufferSize.X);
        if (StartX == EndX && StartY == EndY) {
            RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+StartY) % ScreenInfo->ScreenBufferSize.Y;
            Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
            Char = Row->CharRow.Chars[StartX];
            FindAttrIndex(Row->AttrRow.Attrs, StartX, &Attr, &CountOfAttr);
            ConsoleNotifyWinEvent(ScreenInfo->Console,
                                  EVENT_CONSOLE_UPDATE_SIMPLE,
                                  MAKELONG(StartX, StartY),
                                  MAKELONG(Char, Attr->Attr));
        } else {
            ConsoleNotifyWinEvent(ScreenInfo->Console,
                                  EVENT_CONSOLE_UPDATE_REGION,
                                  MAKELONG(StartX, StartY),
                                  MAKELONG(EndX, EndY));
        }
    }

    //
    // first see whether we wrote any lines with multiple attributes.  if
    // we did, set the flags and bail out.  also, remember if any of the
    // lines we wrote had attributes different from other lines.
    //

    RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+StartY) % ScreenInfo->ScreenBufferSize.Y;
    for (i=StartY;i<=EndY;i++) {
        Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
        if (Row->AttrRow.Length != 1) {
            ScreenInfo->BufferInfo.TextInfo.Flags &= ~SINGLE_ATTRIBUTES_PER_LINE;
            return;
        }
        if (++RowIndex == ScreenInfo->ScreenBufferSize.Y) {
            RowIndex = 0;
        }
    }

    // all of the written lines have the same attribute.

    if (ScreenInfo->BufferInfo.TextInfo.Flags & SINGLE_ATTRIBUTES_PER_LINE) {
        return;
    }

    if (StartY == 0 && EndY == (ScreenInfo->ScreenBufferSize.Y-1)) {
        ScreenInfo->BufferInfo.TextInfo.Flags |= SINGLE_ATTRIBUTES_PER_LINE;
        return;
    }

    RowIndex = ScreenInfo->BufferInfo.TextInfo.FirstRow;
    for (i=0;i<StartY;i++) {
        Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
        if (Row->AttrRow.Length != 1) {
            return;
        }
        if (++RowIndex == ScreenInfo->ScreenBufferSize.Y) {
            RowIndex = 0;
        }
        Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
    }
    RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+EndY+1) % ScreenInfo->ScreenBufferSize.Y;
    for (i=EndY+1;i<ScreenInfo->ScreenBufferSize.Y;i++) {
        Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
        if (Row->AttrRow.Length != 1) {
            return;
        }
        if (++RowIndex == ScreenInfo->ScreenBufferSize.Y) {
            RowIndex = 0;
        }
    }
    ScreenInfo->BufferInfo.TextInfo.Flags |= SINGLE_ATTRIBUTES_PER_LINE;
}


VOID
ReadRectFromScreenBuffer(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN COORD SourcePoint,
    IN PCHAR_INFO Target,
    IN COORD TargetSize,
    IN PSMALL_RECT TargetRect
    )

/*++

Routine Description:

    This routine copies a rectangular region from the screen buffer.
    no clipping is done.

Arguments:

    ScreenInfo - pointer to screen info

    SourcePoint - upper left coordinates of source rectangle

    Target - pointer to target buffer

    TargetSize - dimensions of target buffer

    TargetRect - rectangle in source buffer to copy

Return Value:

    none.

--*/

{

    PCHAR_INFO TargetPtr;
    SHORT i,j,k;
    SHORT XSize,YSize;
    BOOLEAN WholeTarget;
    SHORT RowIndex;
    PROW Row;
    PWCHAR Char;
    PATTR_PAIR Attr;
    SHORT CountOfAttr;

    DBGOUTPUT(("ReadRectFromScreenBuffer\n"));

    XSize = (SHORT)(TargetRect->Right - TargetRect->Left + 1);
    YSize = (SHORT)(TargetRect->Bottom - TargetRect->Top + 1);

    TargetPtr = Target;
    WholeTarget = FALSE;
    if (XSize == TargetSize.X) {
        ASSERT (TargetRect->Left == 0);
        if (TargetRect->Top != 0) {
            TargetPtr = (PCHAR_INFO)
                ((PBYTE)Target + SCREEN_BUFFER_POINTER(TargetRect->Left,
                                                       TargetRect->Top,
                                                       TargetSize.X,
                                                       sizeof(CHAR_INFO)));
        }
        WholeTarget = TRUE;
    }
    RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+SourcePoint.Y) % ScreenInfo->ScreenBufferSize.Y;
    for (i=0;i<YSize;i++) {
        if (!WholeTarget) {
            TargetPtr = (PCHAR_INFO)
                ((PBYTE)Target + SCREEN_BUFFER_POINTER(TargetRect->Left,
                                                       TargetRect->Top+i,
                                                       TargetSize.X,
                                                       sizeof(CHAR_INFO)));
        }

        //
        // copy the chars and attrs from their respective arrays
        //

        Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
        Char = &Row->CharRow.Chars[SourcePoint.X];
        FindAttrIndex(Row->AttrRow.Attrs,
                      SourcePoint.X,
                      &Attr,
                      &CountOfAttr
                     );
        k=0;
#if defined(FE_SB)
        if (CONSOLE_IS_DBCS_OUTPUTCP(ScreenInfo->Console)) {
            PBYTE AttrP = &Row->CharRow.KAttrs[SourcePoint.X];
            for (j=0;j<XSize;TargetPtr++) {
                BYTE AttrR;
                AttrR = *AttrP++;
                if (j==0 && AttrR & ATTR_TRAILING_BYTE)
                {
                    TargetPtr->Char.UnicodeChar = UNICODE_SPACE;
                    AttrR = 0;
                }
                else if (j+1 >= XSize && AttrR & ATTR_LEADING_BYTE)
                {
                    TargetPtr->Char.UnicodeChar = UNICODE_SPACE;
                    AttrR = 0;
                }
                else
                    TargetPtr->Char.UnicodeChar = *Char;
                Char++;
                TargetPtr->Attributes = Attr->Attr | (WCHAR)(AttrR & ATTR_DBCSSBCS_BYTE) << 8;
                j+=1;
                if (++k==CountOfAttr && j<XSize) {
                    Attr++;
                    k=0;
                    CountOfAttr = Attr->Length;
                }
            }
        }
        else{
#endif
        for (j=0;j<XSize;TargetPtr++) {
            TargetPtr->Char.UnicodeChar = *Char++;
            TargetPtr->Attributes = Attr->Attr;
            j+=1;
            if (++k==CountOfAttr && j<XSize) {
                Attr++;
                k=0;
                CountOfAttr = Attr->Length;
            }
        }
#if defined(FE_SB)
        }
#endif

        if (++RowIndex == ScreenInfo->ScreenBufferSize.Y) {
            RowIndex = 0;
        }
    }
}

VOID
CopyRectangle(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT SourceRect,
    IN COORD TargetPoint
    )

/*++

Routine Description:

    This routine copies a rectangular region from the screen buffer to
    the screen buffer.  no clipping is done.

Arguments:

    ScreenInfo - pointer to screen info

    SourceRect - rectangle in source buffer to copy

    TargetPoint - upper left coordinates of new location rectangle

Return Value:

    none.

--*/

{
    SMALL_RECT Target;
    COORD SourcePoint;
    COORD Size;
    DBGOUTPUT(("CopyRectangle\n"));


    LockScrollBuffer();

    SourcePoint.X = SourceRect->Left;
    SourcePoint.Y = SourceRect->Top;
    Target.Left = 0;
    Target.Top = 0;
    Target.Right = Size.X = SourceRect->Right - SourceRect->Left;
    Target.Bottom = Size.Y = SourceRect->Bottom - SourceRect->Top;
    Size.X++;
    Size.Y++;

    if (ScrollBufferSize < (Size.X * Size.Y * sizeof(CHAR_INFO))) {
        FreeScrollBuffer();
        if (!NT_SUCCESS(AllocateScrollBuffer(Size.X * Size.Y * sizeof(CHAR_INFO)))) {
            UnlockScrollBuffer();
            return;
        }
    }

    ReadRectFromScreenBuffer(ScreenInfo,
                             SourcePoint,
                             ScrollBuffer,
                             Size,
                             &Target
                            );

    WriteRectToScreenBuffer((PBYTE)ScrollBuffer,
                            Size,
                            &Target,
                            ScreenInfo,
                            TargetPoint,
                            0xFFFFFFFF  // ScrollBuffer won't need conversion
                           );
    UnlockScrollBuffer();
}


NTSTATUS
ReadScreenBuffer(
    IN PSCREEN_INFORMATION ScreenInformation,
    OUT PCHAR_INFO Buffer,
    IN OUT PSMALL_RECT ReadRegion
    )

/*++

Routine Description:

    This routine reads a rectangular region from the screen buffer.
    The region is first clipped.

Arguments:

    ScreenInformation - Screen buffer to read from.

    Buffer - Buffer to read into.

    ReadRegion - Region to read.

Return Value:


--*/

{
    COORD TargetSize;
    COORD TargetPoint,SourcePoint;
    SMALL_RECT Target;

    DBGOUTPUT(("ReadScreenBuffer\n"));
    //
    // calculate dimensions of caller's buffer.  have to do this calculation
    // before clipping.
    //

    TargetSize.X = (SHORT)(ReadRegion->Right - ReadRegion->Left + 1);
    TargetSize.Y = (SHORT)(ReadRegion->Bottom - ReadRegion->Top + 1);

    if (TargetSize.X <= 0 || TargetSize.Y <= 0) {
        return STATUS_SUCCESS;
    }

    // do clipping.

    if (ReadRegion->Right > (SHORT)(ScreenInformation->ScreenBufferSize.X-1)) {
        ReadRegion->Right = (SHORT)(ScreenInformation->ScreenBufferSize.X-1);
    }
    if (ReadRegion->Bottom > (SHORT)(ScreenInformation->ScreenBufferSize.Y-1)) {
        ReadRegion->Bottom = (SHORT)(ScreenInformation->ScreenBufferSize.Y-1);
    }
    if (ReadRegion->Left < 0) {
        TargetPoint.X = -ReadRegion->Left;
        ReadRegion->Left = 0;
    }
    else {
        TargetPoint.X = 0;
    }
    if (ReadRegion->Top < 0) {
        TargetPoint.Y = -ReadRegion->Top;
        ReadRegion->Top = 0;
    }
    else {
        TargetPoint.Y = 0;
    }

    SourcePoint.X = ReadRegion->Left;
    SourcePoint.Y = ReadRegion->Top;
    Target.Left = TargetPoint.X;
    Target.Top = TargetPoint.Y;
    Target.Right = TargetPoint.X + (ReadRegion->Right - ReadRegion->Left);
    Target.Bottom = TargetPoint.Y + (ReadRegion->Bottom - ReadRegion->Top);
    ReadRectFromScreenBuffer(ScreenInformation,
                             SourcePoint,
                             Buffer,
                             TargetSize,
                             &Target
                            );
    return STATUS_SUCCESS;
}

NTSTATUS
WriteScreenBuffer(
    IN PSCREEN_INFORMATION ScreenInformation,
    IN PCHAR_INFO Buffer,
    IN OUT PSMALL_RECT WriteRegion
    )

/*++

Routine Description:

    This routine write a rectangular region to the screen buffer.
    The region is first clipped.

    The region should contain Unicode or UnicodeOem chars.

Arguments:

    ScreenInformation - Screen buffer to write to.

    Buffer - Buffer to write from.

    ReadRegion - Region to write.

Return Value:


--*/

{
    COORD SourceSize;
    COORD TargetPoint;
    SMALL_RECT SourceRect;

    DBGOUTPUT(("WriteScreenBuffer\n"));
    //
    // calculate dimensions of caller's buffer.  have to do this calculation
    // before clipping.
    //

    SourceSize.X = (SHORT)(WriteRegion->Right - WriteRegion->Left + 1);
    SourceSize.Y = (SHORT)(WriteRegion->Bottom - WriteRegion->Top + 1);
    if (SourceSize.X <= 0 || SourceSize.Y <= 0) {
        return STATUS_SUCCESS;
    }

    // do clipping.

    if (WriteRegion->Left >= ScreenInformation->ScreenBufferSize.X ||
        WriteRegion->Top  >= ScreenInformation->ScreenBufferSize.Y) {
        return STATUS_SUCCESS;
    }

    if (WriteRegion->Right > (SHORT)(ScreenInformation->ScreenBufferSize.X-1))
        WriteRegion->Right = (SHORT)(ScreenInformation->ScreenBufferSize.X-1);
    SourceRect.Right = WriteRegion->Right - WriteRegion->Left;
    if (WriteRegion->Bottom > (SHORT)(ScreenInformation->ScreenBufferSize.Y-1))
        WriteRegion->Bottom = (SHORT)(ScreenInformation->ScreenBufferSize.Y-1);
    SourceRect.Bottom = WriteRegion->Bottom - WriteRegion->Top;
    if (WriteRegion->Left < 0) {
        SourceRect.Left = -WriteRegion->Left;
        WriteRegion->Left = 0;
    }
    else {
        SourceRect.Left = 0;
    }
    if (WriteRegion->Top < 0) {
        SourceRect.Top = -WriteRegion->Top;
        WriteRegion->Top = 0;
    }
    else {
        SourceRect.Top = 0;
    }

    TargetPoint.X = WriteRegion->Left;
    TargetPoint.Y = WriteRegion->Top;
    WriteRectToScreenBuffer((PBYTE)Buffer,
                            SourceSize,
                            &SourceRect,
                            ScreenInformation,
                            TargetPoint,
                            0xFFFFFFFF
                           );
    return STATUS_SUCCESS;
}




NTSTATUS
ReadOutputString(
    IN PSCREEN_INFORMATION ScreenInfo,
    OUT PVOID Buffer,
    IN COORD ReadCoord,
    IN ULONG StringType,
    IN OUT PULONG NumRecords // this value is valid even for error cases
    )

/*++

Routine Description:

    This routine reads a string of characters or attributes from the
    screen buffer.

Arguments:

    ScreenInfo - Pointer to screen buffer information.

    Buffer - Buffer to read into.

    ReadCoord - Screen buffer coordinate to begin reading from.

    StringType

        CONSOLE_ASCII         - read a string of ASCII characters.
        CONSOLE_REAL_UNICODE  - read a string of Real Unicode characters.
        CONSOLE_FALSE_UNICODE - read a string of False Unicode characters.
        CONSOLE_ATTRIBUTE     - read a string of attributes.

    NumRecords - On input, the size of the buffer in elements.  On output,
    the number of elements read.

Return Value:


--*/

{
    ULONG NumRead;
    SHORT X,Y;
    SHORT RowIndex;
    SHORT CountOfAttr;
    PATTR_PAIR Attr;
    PROW Row;
    PWCHAR Char;
    SHORT j,k;
    PWCHAR TransBuffer = NULL;
    PWCHAR BufPtr;
#if defined(FE_SB)
    PBYTE AttrP;
    PBYTE TransBufferA,BufPtrA;
    PCONSOLE_INFORMATION Console = ScreenInfo->Console;
#endif

    DBGOUTPUT(("ReadOutputString\n"));
    if (*NumRecords == 0)
        return STATUS_SUCCESS;
    NumRead = 0;
    X=ReadCoord.X;
    Y=ReadCoord.Y;
    if (X>=ScreenInfo->ScreenBufferSize.X ||
        X<0 ||
        Y>=ScreenInfo->ScreenBufferSize.Y ||
        Y<0) {
        *NumRecords = 0;
        return STATUS_SUCCESS;
    }

    RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+ReadCoord.Y) % ScreenInfo->ScreenBufferSize.Y;

    if (StringType == CONSOLE_ASCII) {
        TransBuffer = (PWCHAR)ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ),*NumRecords * sizeof(WCHAR));
        if (TransBuffer == NULL) {
            return STATUS_NO_MEMORY;
        }
        BufPtr = TransBuffer;
    } else {
        BufPtr = Buffer;
    }

#if defined(FE_SB)
    if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
    {
        TransBufferA = (PBYTE)ConsoleHeapAlloc(MAKE_TAG( TMP_DBCS_TAG ),*NumRecords * sizeof(BYTE));
        if (TransBufferA == NULL) {
            if (TransBuffer != NULL)
                ConsoleHeapFree(TransBuffer);
            return STATUS_NO_MEMORY;
        }
        BufPtrA = TransBufferA;
    }
#endif
    if ((StringType == CONSOLE_ASCII) ||
            (StringType == CONSOLE_REAL_UNICODE) ||
            (StringType == CONSOLE_FALSE_UNICODE)) {
        while (NumRead < *NumRecords) {

            //
            // copy the chars from its array
            //

            Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
            Char = &Row->CharRow.Chars[X];
#if defined(FE_SB)
            if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
                AttrP = &Row->CharRow.KAttrs[X];
#endif
            if ((ULONG)(ScreenInfo->ScreenBufferSize.X - X) > (*NumRecords - NumRead)) {
                RtlCopyMemory(BufPtr,Char,(*NumRecords - NumRead) * sizeof(WCHAR));
#if defined(FE_SB)
                if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
                    RtlCopyMemory(BufPtrA,AttrP,(*NumRecords - NumRead) * sizeof(CHAR));
#endif
                NumRead += *NumRecords - NumRead;
                break;
            }
            RtlCopyMemory(BufPtr,Char,(ScreenInfo->ScreenBufferSize.X - X) * sizeof(WCHAR));
            BufPtr = (PVOID)((PBYTE)BufPtr + ((ScreenInfo->ScreenBufferSize.X - X) * sizeof(WCHAR)));
#if defined(FE_SB)
            if (CONSOLE_IS_DBCS_OUTPUTCP(Console)) {
                RtlCopyMemory(BufPtrA,AttrP,(ScreenInfo->ScreenBufferSize.X - X) * sizeof(CHAR));
                BufPtrA = (PVOID)((PBYTE)BufPtrA + ((ScreenInfo->ScreenBufferSize.X - X) * sizeof(CHAR)));
            }
#endif
            NumRead += ScreenInfo->ScreenBufferSize.X - X;
            if (++RowIndex == ScreenInfo->ScreenBufferSize.Y) {
                RowIndex = 0;
            }
            X = 0;
            Y++;
            if (Y>=ScreenInfo->ScreenBufferSize.Y) {
                break;
            }
        }
#if defined(FE_SB)
        if (CONSOLE_IS_DBCS_OUTPUTCP(Console) && (NumRead)) {
            if (StringType == CONSOLE_ASCII) {
                Char = BufPtr = TransBuffer;
            } else {
                Char = BufPtr = Buffer;
            }
            AttrP = BufPtrA = TransBufferA;

            if (*BufPtrA & ATTR_TRAILING_BYTE)
            {
                j = k = (SHORT)(NumRead - 1);
                BufPtr++;
                *Char++ = UNICODE_SPACE;
                BufPtrA++;
                NumRead = 1;
            }
            else {
                j = k = (SHORT)NumRead;
                NumRead = 0;
            }
            while (j--) {
                if (!(*BufPtrA & ATTR_TRAILING_BYTE)) {
                    *Char++ = *BufPtr;
                    NumRead++;
                }
                BufPtr++;
                BufPtrA++;
            }
            if (k && *(BufPtrA-1) & ATTR_LEADING_BYTE)
            {
                *(Char-1) = UNICODE_SPACE;
            }
        }
#endif
    } else if (StringType == CONSOLE_ATTRIBUTE) {
        PWORD TargetPtr=BufPtr;
        while (NumRead < *NumRecords) {

            //
            // copy the attrs from its array
            //

            Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
#if defined(FE_SB)
            if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
                AttrP = &Row->CharRow.KAttrs[X];
#endif
            FindAttrIndex(Row->AttrRow.Attrs,
                          X,
                          &Attr,
                          &CountOfAttr
                         );
            k=0;
            for (j=X;j<ScreenInfo->ScreenBufferSize.X;TargetPtr++) {
#if defined(FE_SB)
                if (!CONSOLE_IS_DBCS_OUTPUTCP(Console) )
                    *TargetPtr = Attr->Attr;
                else if ((j == X) && (*AttrP & ATTR_TRAILING_BYTE))
                    *TargetPtr = Attr->Attr;
                else if (*AttrP & ATTR_LEADING_BYTE){
                    if ((NumRead == *NumRecords-1)||(j == ScreenInfo->ScreenBufferSize.X-1))
                        *TargetPtr = Attr->Attr;
                    else
                        *TargetPtr = Attr->Attr | (WCHAR)(*AttrP & ATTR_DBCSSBCS_BYTE) << 8;
                }
                else
                    *TargetPtr = Attr->Attr | (WCHAR)(*AttrP & ATTR_DBCSSBCS_BYTE) << 8;
#else
                *TargetPtr = Attr->Attr;
#endif
                NumRead++;
                j+=1;
                if (++k==CountOfAttr && j<ScreenInfo->ScreenBufferSize.X) {
                    Attr++;
                    k=0;
                    CountOfAttr = Attr->Length;
                }
                if (NumRead == *NumRecords) {
#if defined(FE_SB)
                    if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
                        ConsoleHeapFree(TransBufferA);
#endif
                    return STATUS_SUCCESS;
                }
#if defined(FE_SB)
                if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
                    AttrP++;
#endif
            }
            if (++RowIndex == ScreenInfo->ScreenBufferSize.Y) {
                RowIndex = 0;
            }
            X = 0;
            Y++;
            if (Y>=ScreenInfo->ScreenBufferSize.Y) {
                break;
            }
        }
    } else {
        *NumRecords = 0;
#if defined(FE_SB)
        if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
            ConsoleHeapFree(TransBufferA);
#endif
        return STATUS_INVALID_PARAMETER;
    }

    if (StringType == CONSOLE_ASCII) {
        UINT Codepage;
#if defined(FE_SB)
        if ((ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) &&
                !(ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN)) {
            if (ScreenInfo->Console->OutputCP != WINDOWSCP)
                Codepage = USACP;
            else
                Codepage = WINDOWSCP;
        } else {
            Codepage = ScreenInfo->Console->OutputCP;
        }
#else
        if ((ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) &&
                !(ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN)) {
            Codepage = WINDOWSCP;
        } else {
            Codepage = ScreenInfo->Console->OutputCP;
        }
#endif
#if defined(FE_SB)
        if ((NumRead == 1) && !CONSOLE_IS_DBCS_OUTPUTCP(Console))
#else
        if (NumRead == 1)
#endif
        {
            *((PBYTE)Buffer) = WcharToChar(Codepage, *TransBuffer);
        } else {
            NumRead = ConvertOutputToOem(Codepage, TransBuffer, NumRead, Buffer, *NumRecords);
        }
        ConsoleHeapFree(TransBuffer);
    } else if (StringType == CONSOLE_REAL_UNICODE &&
            (ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) &&
            !(ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN)) {
        /*
         * Buffer contains false Unicode (UnicodeOem) only in Windowed
         * RasterFont mode, so in this case, convert it to real Unicode.
         */
        FalseUnicodeToRealUnicode(Buffer,
                                NumRead,
                                ScreenInfo->Console->OutputCP
                                );
    }

#if defined(FE_SB)
    if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
        ConsoleHeapFree(TransBufferA);
#endif
    *NumRecords = NumRead;
    return STATUS_SUCCESS;
}



NTSTATUS
GetScreenBufferInformation(
    IN PSCREEN_INFORMATION ScreenInfo,
    OUT PCOORD Size,
    OUT PCOORD CursorPosition,
    OUT PCOORD ScrollPosition,
    OUT PWORD  Attributes,
    OUT PCOORD CurrentWindowSize,
    OUT PCOORD MaximumWindowSize
    )

/*++

Routine Description:

    This routine returns data about the screen buffer.

Arguments:

    ScreenInfo - Pointer to screen buffer information.

    Size - Pointer to location in which to store screen buffer size.

    CursorPosition - Pointer to location in which to store the cursor position.

    ScrollPosition - Pointer to location in which to store the scroll position.

    Attributes - Pointer to location in which to store the default attributes.

    CurrentWindowSize - Pointer to location in which to store current window size.

    MaximumWindowSize - Pointer to location in which to store maximum window size.

Return Value:

--*/

{
    WINDOW_LIMITS WindowLimits;

    *Size = ScreenInfo->ScreenBufferSize;
    *CursorPosition = ScreenInfo->BufferInfo.TextInfo.CursorPosition;
    ScrollPosition->X = ScreenInfo->Window.Left;
    ScrollPosition->Y = ScreenInfo->Window.Top;
    *Attributes = ScreenInfo->Attributes;
    CurrentWindowSize->X = (SHORT)CONSOLE_WINDOW_SIZE_X(ScreenInfo);
    CurrentWindowSize->Y = (SHORT)CONSOLE_WINDOW_SIZE_Y(ScreenInfo);
    if (ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) {
        MaximumWindowSize->X = min(80,ScreenInfo->ScreenBufferSize.X);
#if defined(FE_SB)
        if (CONSOLE_IS_DBCS_OUTPUTCP(ScreenInfo->Console)) {
            MaximumWindowSize->Y = min(25,ScreenInfo->ScreenBufferSize.Y);
        } else {
            MaximumWindowSize->Y = min(50,ScreenInfo->ScreenBufferSize.Y);
        }
#else
        MaximumWindowSize->Y = min(50,ScreenInfo->ScreenBufferSize.Y);
#endif
    } else {
        GetWindowLimits(ScreenInfo, &WindowLimits);
        *MaximumWindowSize = WindowLimits.MaximumWindowSize;
    }
    return STATUS_SUCCESS;
}


VOID
UpdateScrollBars(
    IN PSCREEN_INFORMATION ScreenInfo
    )
{
    if (!ACTIVE_SCREEN_BUFFER(ScreenInfo)) {
        return;
    }

    if (ScreenInfo->Console->Flags & CONSOLE_UPDATING_SCROLL_BARS)
        return;
    ScreenInfo->Console->Flags |= CONSOLE_UPDATING_SCROLL_BARS;
    PostMessage(ScreenInfo->Console->hWnd,
                 CM_UPDATE_SCROLL_BARS,
                 (WPARAM)ScreenInfo,
                 0
                );
}

VOID
InternalUpdateScrollBars(
    IN PSCREEN_INFORMATION ScreenInfo
    )
{
    SCROLLINFO si;

    ScreenInfo->Console->Flags &= ~CONSOLE_UPDATING_SCROLL_BARS;
    if (!ACTIVE_SCREEN_BUFFER(ScreenInfo)) {
        return;
    }

    ScreenInfo->ResizingWindow++;

    si.cbSize = sizeof(si);
    si.fMask = SIF_ALL;
    si.nPage = CONSOLE_WINDOW_SIZE_Y(ScreenInfo);
    si.nMin = 0;
    si.nMax = ScreenInfo->ScreenBufferSize.Y - 1;
    si.nPos = ScreenInfo->Window.Top;
    SetScrollInfo(ScreenInfo->Console->hWnd, SB_VERT, &si, TRUE);

    si.cbSize = sizeof(si);
    si.fMask = SIF_ALL;
    si.nPage = CONSOLE_WINDOW_SIZE_X(ScreenInfo);
    si.nMin = 0;
    si.nMax = ScreenInfo->ScreenBufferSize.X - 1;
    si.nPos = ScreenInfo->Window.Left;
    SetScrollInfo(ScreenInfo->Console->hWnd, SB_HORZ, &si, TRUE);

    //
    // Fire off an event to let accessibility apps know the layout has changed.
    //

    ConsoleNotifyWinEvent(ScreenInfo->Console,
                          EVENT_CONSOLE_LAYOUT,
                          0,
                          0);

    ScreenInfo->ResizingWindow--;
}

VOID
ScreenBufferSizeChange(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN COORD NewSize
    )
{
    INPUT_RECORD InputEvent;

    InputEvent.EventType = WINDOW_BUFFER_SIZE_EVENT;
    InputEvent.Event.WindowBufferSizeEvent.dwSize = NewSize;
    WriteInputBuffer(ScreenInfo->Console,
                     &ScreenInfo->Console->InputBuffer,
                     &InputEvent,
                     1
                     );
}

NTSTATUS
ResizeScreenBuffer(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN COORD NewScreenSize,
    IN BOOL DoScrollBarUpdate
    )

/*++

Routine Description:

    This routine resizes the screen buffer.

Arguments:

    ScreenInfo - pointer to screen buffer info.

    NewScreenSize - new size of screen.

Return Value:

--*/

{
    SHORT i,j;
    BOOLEAN WindowMaximizedX,WindowMaximizedY;
    SHORT LimitX,LimitY;
    PWCHAR TextRows,TextRowPtr;
    BOOL UpdateWindow;
    SHORT TopRow,TopRowIndex; // new top row of screen buffer
    COORD CursorPosition;
#if defined(FE_SB)
    DBCS_SCREEN_BUFFER NewDbcsScreenBuffer;
    PBYTE TextRowPtrA;
#endif

    //
    // Don't allow resize of graphics apps
    //

    if (!(ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER)) {
        return STATUS_UNSUCCESSFUL;
    }

    TextRows = (PWCHAR)ConsoleHeapAlloc(MAKE_TAG( SCREEN_TAG ),NewScreenSize.X*NewScreenSize.Y*sizeof(WCHAR));
    if (TextRows == NULL) {
        return STATUS_NO_MEMORY;
    }
#if defined(FE_SB)
    if (! CreateDbcsScreenBuffer(ScreenInfo->Console,NewScreenSize,&NewDbcsScreenBuffer))
    {
        ConsoleHeapFree(TextRows);
        return STATUS_NO_MEMORY;
    }
#endif
    LimitX = (NewScreenSize.X < ScreenInfo->ScreenBufferSize.X) ?
              NewScreenSize.X : ScreenInfo->ScreenBufferSize.X;
    LimitY = (NewScreenSize.Y < ScreenInfo->ScreenBufferSize.Y) ?
              NewScreenSize.Y : ScreenInfo->ScreenBufferSize.Y;
    TopRow = 0;
    if (NewScreenSize.Y <= ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y) {
        TopRow += ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y - NewScreenSize.Y + 1;
    }
    TopRowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+TopRow) % ScreenInfo->ScreenBufferSize.Y;
    if (NewScreenSize.Y != ScreenInfo->ScreenBufferSize.Y) {
        PROW Temp;
        SHORT NumToCopy,NumToCopy2;

        //
        // resize ROWs array.  first alloc a new ROWs array. then copy the old
        // one over, resetting the FirstRow.
        //
        //

        Temp = (PROW)ConsoleHeapAlloc(MAKE_TAG( SCREEN_TAG ),NewScreenSize.Y*sizeof(ROW));
        if (Temp == NULL) {
            ConsoleHeapFree(TextRows);
#if defined(FE_SB)
            DeleteDbcsScreenBuffer(&NewDbcsScreenBuffer);
#endif
            return STATUS_NO_MEMORY;
        }
        NumToCopy = ScreenInfo->ScreenBufferSize.Y-TopRowIndex;
        if (NumToCopy > NewScreenSize.Y)
            NumToCopy = NewScreenSize.Y;
        RtlCopyMemory(Temp,&ScreenInfo->BufferInfo.TextInfo.Rows[TopRowIndex],NumToCopy*sizeof(ROW));
        if (TopRowIndex!=0 && NumToCopy != NewScreenSize.Y) {
            NumToCopy2 = TopRowIndex;
            if (NumToCopy2 > (NewScreenSize.Y-NumToCopy))
                NumToCopy2 = NewScreenSize.Y-NumToCopy;
            RtlCopyMemory(&Temp[NumToCopy],
                   ScreenInfo->BufferInfo.TextInfo.Rows,
                   NumToCopy2*sizeof(ROW)
                  );
        }
        for (i=0;i<LimitY;i++) {
            if (Temp[i].AttrRow.Length == 1) {
                Temp[i].AttrRow.Attrs = &Temp[i].AttrRow.AttrPair;
            }
        }

        //
        // if the new screen buffer has fewer rows than the existing one,
        // free the extra rows.  if the new screen buffer has more rows
        // than the existing one, allocate new rows.
        //

        if (NewScreenSize.Y < ScreenInfo->ScreenBufferSize.Y) {
            i = (TopRowIndex+NewScreenSize.Y) % ScreenInfo->ScreenBufferSize.Y;
            for (j=NewScreenSize.Y;j<ScreenInfo->ScreenBufferSize.Y;j++) {
                if (ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.Length > 1) {
                    ConsoleHeapFree(ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.Attrs);
                }
                if (++i == ScreenInfo->ScreenBufferSize.Y) {
                    i = 0;
                }
            }
        } else if (NewScreenSize.Y > ScreenInfo->ScreenBufferSize.Y) {
            for (i=ScreenInfo->ScreenBufferSize.Y;i<NewScreenSize.Y;i++) {
                Temp[i].AttrRow.Length = 1;
                Temp[i].AttrRow.AttrPair.Length = NewScreenSize.X;
                Temp[i].AttrRow.AttrPair.Attr = ScreenInfo->Attributes;
                Temp[i].AttrRow.Attrs = &Temp[i].AttrRow.AttrPair;
            }
        }
        ScreenInfo->BufferInfo.TextInfo.FirstRow = 0;
        ConsoleHeapFree(ScreenInfo->BufferInfo.TextInfo.Rows);
        ScreenInfo->BufferInfo.TextInfo.Rows = Temp;
    }

    //
    // Realloc each row.  any horizontal growth results in the last
    // attribute in a row getting extended.
    //
#if defined(FE_SB)
    TextRowPtrA=NewDbcsScreenBuffer.KAttrRows;
#endif
    for (i=0,TextRowPtr=TextRows;i<LimitY;i++,TextRowPtr+=NewScreenSize.X)
    {
        RtlCopyMemory(TextRowPtr,
               ScreenInfo->BufferInfo.TextInfo.Rows[i].CharRow.Chars,
               LimitX*sizeof(WCHAR));
#if defined(FE_SB)
        if (TextRowPtrA) {
            RtlCopyMemory(TextRowPtrA,
                          ScreenInfo->BufferInfo.TextInfo.Rows[i].CharRow.KAttrs,
                          LimitX*sizeof(CHAR));
        }
#endif
        for (j=ScreenInfo->ScreenBufferSize.X;j<NewScreenSize.X;j++) {
            TextRowPtr[j] = (WCHAR)' ';
        }

        if (ScreenInfo->BufferInfo.TextInfo.Rows[i].CharRow.Right > NewScreenSize.X) {
            ScreenInfo->BufferInfo.TextInfo.Rows[i].CharRow.OldRight = INVALID_OLD_LENGTH;
            ScreenInfo->BufferInfo.TextInfo.Rows[i].CharRow.Right = NewScreenSize.X;
        }
        ScreenInfo->BufferInfo.TextInfo.Rows[i].CharRow.Chars = TextRowPtr;
#if defined(FE_SB)
        ScreenInfo->BufferInfo.TextInfo.Rows[i].CharRow.KAttrs = TextRowPtrA;
        if (TextRowPtrA) {
            if (NewScreenSize.X > ScreenInfo->ScreenBufferSize.X)
                RtlZeroMemory(TextRowPtrA+ScreenInfo->ScreenBufferSize.X,
                              NewScreenSize.X-ScreenInfo->ScreenBufferSize.X);
            TextRowPtrA+=NewScreenSize.X;
        }
#endif
    }
    for (;i<NewScreenSize.Y;i++,TextRowPtr+=NewScreenSize.X)
    {
        for (j=0;j<NewScreenSize.X;j++) {
            TextRowPtr[j] = (WCHAR)' ';
        }
#if defined(FE_SB)
        if (TextRowPtrA) {
           RtlZeroMemory(TextRowPtrA, NewScreenSize.X);
        }
#endif
        ScreenInfo->BufferInfo.TextInfo.Rows[i].CharRow.Chars = TextRowPtr;
        ScreenInfo->BufferInfo.TextInfo.Rows[i].CharRow.OldLeft = INVALID_OLD_LENGTH;
        ScreenInfo->BufferInfo.TextInfo.Rows[i].CharRow.OldRight = INVALID_OLD_LENGTH;
        ScreenInfo->BufferInfo.TextInfo.Rows[i].CharRow.Left = NewScreenSize.X;
        ScreenInfo->BufferInfo.TextInfo.Rows[i].CharRow.Right = 0;
#if defined(FE_SB)
        ScreenInfo->BufferInfo.TextInfo.Rows[i].CharRow.KAttrs = TextRowPtrA;
        if (TextRowPtrA) {
            TextRowPtrA+=NewScreenSize.X;
        }
#endif
    }
    ConsoleHeapFree(ScreenInfo->BufferInfo.TextInfo.TextRows);
    ScreenInfo->BufferInfo.TextInfo.TextRows = TextRows;
#if defined(FE_SB)
    DeleteDbcsScreenBuffer(&ScreenInfo->BufferInfo.TextInfo.DbcsScreenBuffer);
    ScreenInfo->BufferInfo.TextInfo.DbcsScreenBuffer = NewDbcsScreenBuffer;
#endif

    if (NewScreenSize.X != ScreenInfo->ScreenBufferSize.X) {
        for (i=0;i<LimitY;i++) {
            PATTR_PAIR IndexedAttr;
            SHORT CountOfAttr;

            if (NewScreenSize.X > ScreenInfo->ScreenBufferSize.X) {
                FindAttrIndex(ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.Attrs,
                              (SHORT)(ScreenInfo->ScreenBufferSize.X-1),
                              &IndexedAttr,
                              &CountOfAttr
                             );
  ASSERT (IndexedAttr <=
    &ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.Attrs[ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.Length-1]);
                IndexedAttr->Length += NewScreenSize.X - ScreenInfo->ScreenBufferSize.X;
            }
            else {

                FindAttrIndex(ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.Attrs,
                              (SHORT)(NewScreenSize.X-1),
                              &IndexedAttr,
                              &CountOfAttr
                             );
                IndexedAttr->Length -= CountOfAttr-1;
                if (ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.Length != 1)  {
                    ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.Length = (SHORT)(IndexedAttr - ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.Attrs + 1);
                    if (ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.Length != 1) {
                        ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.Attrs = (PATTR_PAIR)ConsoleHeapReAlloc(MAKE_TAG( SCREEN_TAG ),ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.Attrs,
                                                                         ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.Length * sizeof(ATTR_PAIR));
                    }
                    else {
                        ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.AttrPair = *IndexedAttr;
                        ConsoleHeapFree(ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.Attrs);
                        ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.Attrs = &ScreenInfo->BufferInfo.TextInfo.Rows[i].AttrRow.AttrPair;
                    }
                }
            }
        }
    }

    //
    // if the screen buffer is resized smaller than the saved
    // window size, shrink the saved window size.
    //
#ifdef i386
    if (ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN) {
        if (NewScreenSize.X < ScreenInfo->BufferInfo.TextInfo.WindowedWindowSize.X) {
            ScreenInfo->BufferInfo.TextInfo.WindowedWindowSize.X = NewScreenSize.X;
        }
        if (NewScreenSize.Y < ScreenInfo->BufferInfo.TextInfo.WindowedWindowSize.Y) {
            ScreenInfo->BufferInfo.TextInfo.WindowedWindowSize.Y = NewScreenSize.Y;
        }
        ScreenInfo->BufferInfo.TextInfo.WindowedScreenSize = NewScreenSize;
    }
#endif

    UpdateWindow = FALSE;

    //
    // if the screen buffer shrunk beyond the boundaries of the window,
    // adjust the window origin.
    //

    if (NewScreenSize.X > CONSOLE_WINDOW_SIZE_X(ScreenInfo)) {
        if (ScreenInfo->Window.Right >= NewScreenSize.X) {
            ScreenInfo->Window.Left -= ScreenInfo->Window.Right - NewScreenSize.X + 1;
            ScreenInfo->Window.Right -= ScreenInfo->Window.Right - NewScreenSize.X + 1;
            UpdateWindow = TRUE;
        }
    } else {
        ScreenInfo->Window.Left = 0;
        ScreenInfo->Window.Right = NewScreenSize.X - 1;
        UpdateWindow = TRUE;
    }
    if (NewScreenSize.Y > CONSOLE_WINDOW_SIZE_Y(ScreenInfo)) {
        if (ScreenInfo->Window.Bottom >= NewScreenSize.Y) {
            ScreenInfo->Window.Top -= ScreenInfo->Window.Bottom - NewScreenSize.Y + 1;
            ScreenInfo->Window.Bottom -= ScreenInfo->Window.Bottom - NewScreenSize.Y + 1;
            UpdateWindow = TRUE;
        }
    } else {
        ScreenInfo->Window.Top = 0;
        ScreenInfo->Window.Bottom = NewScreenSize.Y - 1;
        UpdateWindow = TRUE;
    }

#if defined(FE_SB)
    // Should be sets ScreenBufferSize before calls SetCursorPosition
    // because SetCursorPosition refer ScreenBufferSize.
    // Also, FE version refer in InvertPixels.
    //
    // kkntbug:11311
    ScreenInfo->ScreenBufferSize = NewScreenSize;
#endif

    //
    // adjust cursor position if it's no longer with screen buffer
    //

    CursorPosition=ScreenInfo->BufferInfo.TextInfo.CursorPosition;
    if (CursorPosition.X >= NewScreenSize.X) {
        if (ScreenInfo->OutputMode & ENABLE_WRAP_AT_EOL_OUTPUT) {
            CursorPosition.X = 0;
            CursorPosition.Y += 1;
        } else {
            CursorPosition.X = NewScreenSize.X-1;
        }
    }
    if (CursorPosition.Y >= NewScreenSize.Y) {
        CursorPosition.Y = NewScreenSize.Y-1;
    }
#if defined(FE_SB)
    // set cursor position Y is ZERO when expand screen buffer with IME open mode
    // from screen buffer is one line mode.
    // Because, One line screen buffer mode and IME open mode is set -1 as cursor position Y.
    if (ScreenInfo->Console->InputBuffer.ImeMode.Open && CursorPosition.Y < 0) {
        CursorPosition.Y = 0;
    }
#endif
    if (CursorPosition.X != ScreenInfo->BufferInfo.TextInfo.CursorPosition.X ||
        CursorPosition.Y != ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y) {
        SetCursorPosition(ScreenInfo,
                          CursorPosition,
                          FALSE
                          );
    }

    ASSERT (ScreenInfo->Window.Left >= 0);
    ASSERT (ScreenInfo->Window.Right < NewScreenSize.X);
    ASSERT (ScreenInfo->Window.Top >= 0);
    ASSERT (ScreenInfo->Window.Bottom < NewScreenSize.Y);

    ScreenInfo->ScreenBufferSize = NewScreenSize;
    ResetTextFlags(ScreenInfo,
                   0,
                   0,
                   (SHORT)(ScreenInfo->ScreenBufferSize.X - 1),
                   (SHORT)(ScreenInfo->ScreenBufferSize.Y - 1));
    WindowMaximizedX = (CONSOLE_WINDOW_SIZE_X(ScreenInfo) ==
                          ScreenInfo->ScreenBufferSize.X);
    WindowMaximizedY = (CONSOLE_WINDOW_SIZE_Y(ScreenInfo) ==
                          ScreenInfo->ScreenBufferSize.Y);

#if defined(FE_IME)
    if (CONSOLE_IS_IME_ENABLED()) {
        if (!NT_SUCCESS(ConsoleImeMessagePump(ScreenInfo->Console,
                              CONIME_NOTIFY_SCREENBUFFERSIZE,
                              (WPARAM)ScreenInfo->Console->ConsoleHandle,
                              (LPARAM)MAKELPARAM(NewScreenSize.X, NewScreenSize.Y)
                             ))) {
            return STATUS_INVALID_HANDLE;
        }
    }

    if ( (! ScreenInfo->ConvScreenInfo) &&
         (CONSOLE_IS_DBCS_OUTPUTCP(ScreenInfo->Console)))
    {
        if (!NT_SUCCESS(ConsoleImeResizeModeSystemScreenBuffer(ScreenInfo->Console,NewScreenSize)) ||
                !NT_SUCCESS(ConsoleImeResizeCompStrScreenBuffer(ScreenInfo->Console,NewScreenSize))) {
            /*
             * If something went wrong, just bail out.
             */
            return STATUS_INVALID_HANDLE;
        }
    }
#endif // FE_IME
    if (ScreenInfo->WindowMaximizedX != WindowMaximizedX ||
        ScreenInfo->WindowMaximizedY != WindowMaximizedY) {
        ScreenInfo->WindowMaximizedX = WindowMaximizedX;
        ScreenInfo->WindowMaximizedY = WindowMaximizedY;
        UpdateWindow = TRUE;
    }
    if (UpdateWindow) {
        SetWindowSize(ScreenInfo);
    }

    //
    // Fire off an event to let accessibility apps know the layout has changed.
    //

    if (ACTIVE_SCREEN_BUFFER(ScreenInfo)) {
        ConsoleNotifyWinEvent(ScreenInfo->Console,
                              EVENT_CONSOLE_LAYOUT,
                              0,
                              0);
    }

    if (DoScrollBarUpdate) {
         UpdateScrollBars(ScreenInfo);
    }
    if (ScreenInfo->Console->InputBuffer.InputMode & ENABLE_WINDOW_INPUT) {
        ScreenBufferSizeChange(ScreenInfo,ScreenInfo->ScreenBufferSize);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
AllocateScrollBuffer(
    DWORD Size
    )
{
    ScrollBuffer = (PCHAR_INFO)ConsoleHeapAlloc(MAKE_TAG( SCREEN_TAG ),Size);
    if (ScrollBuffer == NULL) {
        ScrollBufferSize = 0;
        return STATUS_NO_MEMORY;
    }
    ScrollBufferSize = Size;
    return STATUS_SUCCESS;
}

VOID
FreeScrollBuffer( VOID )
{
    ConsoleHeapFree(ScrollBuffer);
    ScrollBuffer = NULL;
    ScrollBufferSize = 0;
}

NTSTATUS
InitializeScrollBuffer( VOID )
{
    NTSTATUS Status;

    ghrgnScroll = CreateRectRgn(0,0,1,1);
    if (ghrgnScroll == NULL) {
        RIPMSG0(RIP_WARNING, "InitializeScrollBuffer: cannot allocate ghrgnScroll.");
        return STATUS_UNSUCCESSFUL;
    }
    gprgnData = (LPRGNDATA)ConsoleHeapAlloc(MAKE_TAG( SCREEN_TAG ),GRGNDATASIZE);
    if (gprgnData == NULL) {
        RIPMSG0(RIP_WARNING, "InitializeScrollBuffer: allocate gprgnData.");
        Status = STATUS_NO_MEMORY;
        goto error;
    }

    Status = AllocateScrollBuffer(DefaultRegInfo.ScreenBufferSize.X *
                                  DefaultRegInfo.ScreenBufferSize.Y *
                                  sizeof(CHAR_INFO));
    if (!NT_SUCCESS(Status)) {
        goto error;
    }

    Status = RtlInitializeCriticalSectionAndSpinCount(&ScrollBufferLock,
                                                      0x80000000);

error:
    if (!NT_SUCCESS(Status)) {
        //
        // NTRAID#NTBUG9-296717-2001/04/05-jasonsch.
        // This is just instrumentation to try to catch the aforementioned bug.
        // We stick this sentinel value into LockSemaphore rather than DebugInfo
        // because we want to be able to check out that pointer if we hit the
        // bug again.
        //
        ScrollBufferLock.LockSemaphore = IntToPtr(0xBAADF00D);
        RIPMSG0(RIP_WARNING, "InitializeScrollBuffer failed, cleaning up");
        if (ghrgnScroll) {
            DeleteObject(ghrgnScroll);
            ghrgnScroll = NULL;
        }
        if (gprgnData) {
            ConsoleHeapFree(gprgnData);
            gprgnData = NULL;
        }
    }

    return Status;
}

VOID
UpdateComplexRegion(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN COORD FontSize
    )
{
    int iSize,i;
    LPRECT pRect;
    SMALL_RECT UpdateRegion;
    LPRGNDATA pRgnData;

    if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
        ScreenInfo->BufferInfo.TextInfo.Flags &= ~TEXT_VALID_HINT;
    }
    pRgnData = gprgnData;

    /*
     * the dreaded complex region.
     */
    iSize = GetRegionData(ghrgnScroll, 0, NULL);
    if (iSize > GRGNDATASIZE) {
        pRgnData = (LPRGNDATA)ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ),iSize);
        if (pRgnData == NULL)
            return;
    }

    if (!GetRegionData(ghrgnScroll, iSize, pRgnData)) {
        ASSERT(FALSE);
        if (pRgnData != gprgnData) {
            ConsoleHeapFree(pRgnData);
        }
        return;
    }

    pRect = (PRECT)&pRgnData->Buffer;

    /*
     * Redraw each rectangle
     */
    for(i=0;i<(int)pRgnData->rdh.nCount;i++,pRect++) {
        /*
         * Convert to chars. We know
         * this is only get to get converted back during
         * the textout call.
         */
        UpdateRegion.Left = (SHORT)((pRect->left/FontSize.X)+ \
                            ScreenInfo->Window.Left);
        UpdateRegion.Right = (SHORT)(((pRect->right-1)/FontSize.X)+ \
                            ScreenInfo->Window.Left);
        UpdateRegion.Top = (SHORT)((pRect->top/FontSize.Y)+ \
                            ScreenInfo->Window.Top);
        UpdateRegion.Bottom = (SHORT)(((pRect->bottom-1)/FontSize.Y)+ \
                            ScreenInfo->Window.Top);
        /*
         * Fill the rectangle with goodies.
         */
        WriteToScreen(ScreenInfo, &UpdateRegion);
    }
    if (pRgnData != gprgnData) {
        ConsoleHeapFree(pRgnData);
    }
}

VOID
ScrollScreen(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT ScrollRect,
    IN PSMALL_RECT MergeRect,
    IN COORD TargetPoint
    )
{
    RECT ScrollRectGdi;
    SMALL_RECT UpdateRegion;
    COORD FontSize;
    BOOL Success;
    RECT BoundingBox;
#if defined(FE_SB)
    BYTE fBisect = 0;
    SMALL_RECT UpdateRect;
    SMALL_RECT TmpBisect;
#endif

    DBGOUTPUT(("ScrollScreen\n"));
    if (!ACTIVE_SCREEN_BUFFER(ScreenInfo)) {
        return;
    }
    if (ScreenInfo->Console->FullScreenFlags == 0 &&
        !(ScreenInfo->Console->Flags & (CONSOLE_IS_ICONIC | CONSOLE_NO_WINDOW))) {
#if defined(FE_SB)
        if (ScreenInfo->BisectFlag){
            SMALL_RECT RedrawRect;
            if (ScrollRect->Top < TargetPoint.Y){
                RedrawRect.Top = ScrollRect->Top;
                RedrawRect.Bottom = TargetPoint.Y+(ScrollRect->Bottom-ScrollRect->Top);
            }
            else{
                RedrawRect.Top = TargetPoint.Y;
                RedrawRect.Bottom = ScrollRect->Bottom;
            }
            if (ScrollRect->Left < TargetPoint.X){
                RedrawRect.Left = ScrollRect->Left;
                RedrawRect.Right = TargetPoint.X+(ScrollRect->Right-ScrollRect->Left);
            }
            else{
                RedrawRect.Left = TargetPoint.X;
                RedrawRect.Right = ScrollRect->Right;
            }
            WriteToScreen(ScreenInfo,&RedrawRect);
        }
        else{
#endif
        ScrollRectGdi.left = ScrollRect->Left-ScreenInfo->Window.Left;
        ScrollRectGdi.right = (ScrollRect->Right-ScreenInfo->Window.Left+1);
        ScrollRectGdi.top = ScrollRect->Top-ScreenInfo->Window.Top;
        ScrollRectGdi.bottom = (ScrollRect->Bottom-ScreenInfo->Window.Top+1);
        if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
            FontSize = SCR_FONTSIZE(ScreenInfo);
            ScrollRectGdi.left *= FontSize.X;
            ScrollRectGdi.right *= FontSize.X;
            ScrollRectGdi.top *= FontSize.Y;
            ScrollRectGdi.bottom *= FontSize.Y;
            ASSERT (ScreenInfo->BufferInfo.TextInfo.UpdatingScreen>0);
        } else {
            FontSize.X = 1;
            FontSize.Y = 1;
        }
        SCROLLDC_CALL;
        LockScrollBuffer();
        Success = (int)ScrollDC(ScreenInfo->Console->hDC,
                             (TargetPoint.X-ScrollRect->Left)*FontSize.X,
                             (TargetPoint.Y-ScrollRect->Top)*FontSize.Y,
                             &ScrollRectGdi,
                             NULL,
                             ghrgnScroll,
                             NULL);

        //
        // Fire off an event to let accessibility apps know we've scrolled.
        //

        ConsoleNotifyWinEvent(ScreenInfo->Console,
                              EVENT_CONSOLE_UPDATE_SCROLL,
                              TargetPoint.X - ScrollRect->Left,
                              TargetPoint.Y - ScrollRect->Top);

        if (Success) {
            /*
             * Fetch our rectangles. If this is a simple rect then
             * we have already retrieved the rectangle. Otherwise
             * we need to call gdi to get the rectangles. We are
             * optimized for speed rather than size.
             */
            switch (GetRgnBox(ghrgnScroll, &BoundingBox)) {
            case SIMPLEREGION:
                UpdateRegion.Left = (SHORT)((BoundingBox.left / FontSize.X) + \
                                    ScreenInfo->Window.Left);
                UpdateRegion.Right = (SHORT)(((BoundingBox.right-1) / FontSize.X) + \
                                    ScreenInfo->Window.Left);
                UpdateRegion.Top = (SHORT)((BoundingBox.top / FontSize.Y) + \
                                    ScreenInfo->Window.Top);
                UpdateRegion.Bottom = (SHORT)(((BoundingBox.bottom-1) / FontSize.Y) + \
                                    ScreenInfo->Window.Top);
#if defined(FE_SB)
                fBisect = ScreenInfo->BisectFlag;
#endif
                WriteToScreen(ScreenInfo, &UpdateRegion);
                break;
            case COMPLEXREGION:
                UpdateComplexRegion(ScreenInfo, FontSize);
                break;
            }

            if (MergeRect) {
#if defined(FE_SB)
                if (fBisect)
                    ScreenInfo->BisectFlag = fBisect;
                else
                    fBisect = ScreenInfo->BisectFlag;
#endif
                WriteToScreen(ScreenInfo, MergeRect);
            }
#if defined(FE_SB)
            if (CONSOLE_IS_DBCS_OUTPUTCP(ScreenInfo->Console)) {
                UpdateRect.Left = TargetPoint.X;
                UpdateRect.Right = ScrollRect->Right + (TargetPoint.X-ScrollRect->Left);
                UpdateRect.Top = TargetPoint.Y;
                UpdateRect.Bottom = ScrollRect->Bottom + (TargetPoint.Y-ScrollRect->Top);
                if (UpdateRect.Left &&
                    UpdateRect.Right+1 < ScreenInfo->ScreenBufferSize.X &&
                    UpdateRect.Right-UpdateRect.Left <= 2) {
                    TmpBisect.Left = UpdateRect.Left-1;
                    TmpBisect.Right = UpdateRect.Right+1;
                    TmpBisect.Top = UpdateRect.Top;
                    TmpBisect.Bottom = UpdateRect.Bottom;
                    WriteToScreen(ScreenInfo, &TmpBisect);
                }
                else {
                    if (UpdateRect.Left) {
                        TmpBisect.Left = UpdateRect.Left-1;
                        TmpBisect.Right = UpdateRect.Left;
                        TmpBisect.Top = UpdateRect.Top;
                        TmpBisect.Bottom = UpdateRect.Bottom;
                        WriteToScreen(ScreenInfo, &TmpBisect);
                    }
                    if (UpdateRect.Right+1 < ScreenInfo->ScreenBufferSize.X) {
                        TmpBisect.Left = UpdateRect.Right;
                        TmpBisect.Right = UpdateRect.Right+1;
                        TmpBisect.Top = UpdateRect.Top;
                        TmpBisect.Bottom = UpdateRect.Bottom;
                        WriteToScreen(ScreenInfo, &TmpBisect);
                    }
                }
            }
#endif
        } else {
#if defined(FE_SB)
            if (fBisect)
                ScreenInfo->BisectFlag = fBisect;
            else
                fBisect = ScreenInfo->BisectFlag;
#endif
            WriteToScreen(ScreenInfo, &ScreenInfo->Window);
        }
        UnlockScrollBuffer();
#if defined(FE_SB)
        }
#endif
    }
#ifdef i386
    else if (ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) {
#if defined(FE_SB)
        if (CONSOLE_IS_DBCS_OUTPUTCP(ScreenInfo->Console)) {
            if (! ScreenInfo->ConvScreenInfo) {
                if (ScreenInfo->Console->CurrentScreenBuffer == ScreenInfo) {
                    ScrollHW(ScreenInfo,
                             ScrollRect,
                             MergeRect,
                             TargetPoint
                            );
                }
            }
            else if (ScreenInfo->Console->CurrentScreenBuffer->Flags & CONSOLE_TEXTMODE_BUFFER) {
                ScrollHW(ScreenInfo,
                         ScrollRect,
                         MergeRect,
                         TargetPoint
                        );
            }
        }
        else
#endif
        ScrollHW(ScreenInfo,
                 ScrollRect,
                 MergeRect,
                 TargetPoint
                );
    }
#endif
}


void CopyRow(
    PROW Row,
    PROW PrevRow)
{
    if (PrevRow->AttrRow.Length != 1 ||
        Row->AttrRow.Length != 1 ||
        PrevRow->AttrRow.Attrs->Attr != Row->AttrRow.Attrs->Attr) {
        Row->CharRow.OldRight = INVALID_OLD_LENGTH;
        Row->CharRow.OldLeft = INVALID_OLD_LENGTH;
    } else {
        Row->CharRow.OldRight = PrevRow->CharRow.Right;
        Row->CharRow.OldLeft = PrevRow->CharRow.Left;
    }
}

SHORT
ScrollEntireScreen(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN SHORT ScrollValue,
    IN BOOL UpdateRowIndex
    )

/**++

    this routine updates FirstRow and all the OldLeft and OldRight
    values when the screen is scrolled up by ScrollValue.

--*/

{
    SHORT RowIndex;
    int i;
    int new;
    int old;

    ScreenInfo->BufferInfo.TextInfo.Flags |= TEXT_VALID_HINT;

    //
    // store index of first row
    //

    RowIndex = ScreenInfo->BufferInfo.TextInfo.FirstRow;

    //
    // update the oldright and oldleft values
    //

    new = (RowIndex + ScreenInfo->Window.Bottom + ScrollValue) %
               ScreenInfo->ScreenBufferSize.Y;
    old = (RowIndex + ScreenInfo->Window.Bottom) %
               ScreenInfo->ScreenBufferSize.Y;
    for (i = WINDOW_SIZE_Y(&ScreenInfo->Window) - 1; i >= 0; i--) {
        CopyRow(
            &ScreenInfo->BufferInfo.TextInfo.Rows[new],
            &ScreenInfo->BufferInfo.TextInfo.Rows[old]);
        if (--new < 0)
            new = ScreenInfo->ScreenBufferSize.Y - 1;
        if (--old < 0)
            old = ScreenInfo->ScreenBufferSize.Y - 1;
    }

    //
    // update screen buffer
    //

    if (UpdateRowIndex) {
        ScreenInfo->BufferInfo.TextInfo.FirstRow =
            (SHORT)((RowIndex + ScrollValue) % ScreenInfo->ScreenBufferSize.Y);
    }

    return RowIndex;
}

VOID
StreamScrollRegion(
    IN PSCREEN_INFORMATION ScreenInfo
    )

/*++

Routine Description:

    This routine is a special-purpose scroll for use by
    AdjustCursorPosition.

Arguments:

    ScreenInfo - pointer to screen buffer info.

Return Value:

--*/

{
    SHORT RowIndex;
    PROW Row;
    PWCHAR Char;
    RECT Rect;
    RECT BoundingBox;
    int ScreenWidth,ScrollHeight,ScreenHeight;
    COORD FontSize;
    SMALL_RECT UpdateRegion;
    BOOL Success;
    int i;
#if defined(FE_SB)
    PBYTE AttrP;
#endif
    PCONSOLE_INFORMATION Console = ScreenInfo->Console;

    RowIndex = ScrollEntireScreen(ScreenInfo,1,TRUE);

    Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];

    //
    // fill line with blanks
    //

    Char = &Row->CharRow.Chars[Row->CharRow.Left];
    for (i=Row->CharRow.Left;i<Row->CharRow.Right;i++) {
        *Char = (WCHAR)' ';
        Char++;
    }
#if defined(FE_SB)
    if (CONSOLE_IS_DBCS_OUTPUTCP(Console)){
        int LineWidth = Row->CharRow.Right - Row->CharRow.Left;
        AttrP = &Row->CharRow.KAttrs[Row->CharRow.Left];
        if ( LineWidth > 0 )
            RtlZeroMemory(AttrP, LineWidth);
        AttrP += LineWidth;
        Row->CharRow.OldRight = INVALID_OLD_LENGTH;
        Row->CharRow.OldLeft = INVALID_OLD_LENGTH;
        Console->ConsoleIme.ScrollWaitCountDown = Console->ConsoleIme.ScrollWaitTimeout;
    }
#endif
    Row->CharRow.Right = 0;
    Row->CharRow.Left = ScreenInfo->ScreenBufferSize.X;

    //
    // set up attributes
    //

    if (Row->AttrRow.Length != 1) {
        ConsoleHeapFree(Row->AttrRow.Attrs);
        Row->AttrRow.Attrs = &Row->AttrRow.AttrPair;
        Row->AttrRow.AttrPair.Length = ScreenInfo->ScreenBufferSize.X;
        Row->AttrRow.Length = 1;
    }
    Row->AttrRow.AttrPair.Attr = ScreenInfo->Attributes;

    //
    // update screen
    //

    if (ACTIVE_SCREEN_BUFFER(ScreenInfo) &&
        Console->FullScreenFlags == 0 &&
        !(Console->Flags & (CONSOLE_IS_ICONIC | CONSOLE_NO_WINDOW))) {

        ConsoleHideCursor(ScreenInfo);
        if (UsePolyTextOut) {
            WriteRegionToScreen(ScreenInfo, &ScreenInfo->Window);
        } else {
            FontSize = SCR_FONTSIZE(ScreenInfo);
            ScreenWidth = WINDOW_SIZE_X(&ScreenInfo->Window) * FontSize.X;
            ScreenHeight = WINDOW_SIZE_Y(&ScreenInfo->Window) * FontSize.Y;
            ScrollHeight = ScreenHeight - FontSize.Y;

            Rect.left = 0;
            Rect.right = ScreenWidth;
            Rect.top = FontSize.Y;
            Rect.bottom = ScreenHeight;

            //
            // find smallest bounding rectangle
            //

            if (ScreenInfo->BufferInfo.TextInfo.Flags & TEXT_VALID_HINT) {
                SHORT MinLeft,MaxRight;
                MinLeft = ScreenInfo->ScreenBufferSize.X;
                MaxRight = 0;
                RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+ScreenInfo->Window.Top) % ScreenInfo->ScreenBufferSize.Y;
                for (i=ScreenInfo->Window.Top+1;i<=ScreenInfo->Window.Bottom;i++) {
                    Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
                    if (Row->CharRow.OldLeft == INVALID_OLD_LENGTH) {
                        MinLeft = 0;
                    } else {
                        if (MinLeft > min(Row->CharRow.Left,Row->CharRow.OldLeft)) {
                            MinLeft = min(Row->CharRow.Left,Row->CharRow.OldLeft);
                        }
                    }
                    if (Row->CharRow.OldRight == INVALID_OLD_LENGTH) {
                        MaxRight = ScreenInfo->ScreenBufferSize.X-1;
                    } else {
                        if (MaxRight < max(Row->CharRow.Right,Row->CharRow.OldRight)) {
                            MaxRight = max(Row->CharRow.Right,Row->CharRow.OldRight);
                        }
                    }
                    if (++RowIndex == ScreenInfo->ScreenBufferSize.Y) {
                        RowIndex = 0;
                    }
                }
                Rect.left = MinLeft*FontSize.X;
                Rect.right = (MaxRight+1)*FontSize.X;
            }

            LockScrollBuffer();
            ASSERT (ScreenInfo->BufferInfo.TextInfo.UpdatingScreen>0);
            Success = (int)ScrollDC(Console->hDC,
                                0,
                                -FontSize.Y,
                                &Rect,
                                NULL,
                                ghrgnScroll,
                                NULL
                               );

            //
            // Fire off an event to let accessibility apps know we've scrolled.
            //

            ConsoleNotifyWinEvent(Console,
                                  EVENT_CONSOLE_UPDATE_SCROLL,
                                  0,
                                  -1);

            if (Success && ScreenInfo->Window.Top!=ScreenInfo->Window.Bottom) {
#if defined(FE_SB)
                if (CONSOLE_IS_DBCS_OUTPUTCP(Console) &&
                    ScreenInfo->Attributes & (COMMON_LVB_GRID_HORIZONTAL +
                                               COMMON_LVB_GRID_LVERTICAL +
                                               COMMON_LVB_GRID_RVERTICAL +
                                               COMMON_LVB_REVERSE_VIDEO  +
                                               COMMON_LVB_UNDERSCORE     )){
                    UpdateRegion = ScreenInfo->Window;
                    UpdateRegion.Top = UpdateRegion.Bottom;
                    ScreenInfo->BufferInfo.TextInfo.Flags &= ~TEXT_VALID_HINT;
                    WriteToScreen(ScreenInfo,&UpdateRegion);
                }
                else{
#endif
                switch (GetRgnBox(ghrgnScroll, &BoundingBox)) {
                case SIMPLEREGION:
                    if (BoundingBox.left == 0 &&
                        BoundingBox.right == ScreenWidth &&
                        BoundingBox.top == ScrollHeight &&
                        BoundingBox.bottom == ScreenHeight) {

                        PatBlt(Console->hDC,0,ScrollHeight,ScreenWidth,FontSize.Y,PATCOPY);
                        GdiFlush();
                    } else {
                        UpdateRegion.Left = (SHORT)((BoundingBox.left/FontSize.X)+ScreenInfo->Window.Left);
                        UpdateRegion.Right = (SHORT)(((BoundingBox.right-1)/FontSize.X)+ScreenInfo->Window.Left);
                        UpdateRegion.Top = (SHORT)((BoundingBox.top/FontSize.Y)+ScreenInfo->Window.Top);
                        UpdateRegion.Bottom = (SHORT)(((BoundingBox.bottom-1)/FontSize.Y)+ScreenInfo->Window.Top);
                        WriteToScreen(ScreenInfo,&UpdateRegion);
                    }
                    break;
                case COMPLEXREGION:
                    UpdateComplexRegion(ScreenInfo,FontSize);
                    break;
                }
#if defined(FE_SB)
                }
#endif
            } else  {
                WriteToScreen(ScreenInfo,&ScreenInfo->Window);
            }
            UnlockScrollBuffer();
        }
        ConsoleShowCursor(ScreenInfo);
    }
#ifdef i386
    else if (Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) {
        SMALL_RECT ScrollRect;
        COORD TargetPoint;

        ScrollRect = ScreenInfo->Window;
        TargetPoint.Y = ScrollRect.Top;
        ScrollRect.Top += 1;
        TargetPoint.X = 0;
#if defined(FE_SB)
        if (CONSOLE_IS_DBCS_OUTPUTCP(Console) ) {
            if (! ScreenInfo->ConvScreenInfo)  {
                if (ScreenInfo->Console->CurrentScreenBuffer == ScreenInfo) {
                    ScrollHW(ScreenInfo,
                             &ScrollRect,
                             NULL,
                             TargetPoint
                            );
                }
            }
            else if (ScreenInfo->Console->CurrentScreenBuffer->Flags & CONSOLE_TEXTMODE_BUFFER) {
                ScrollHW(ScreenInfo,
                         &ScrollRect,
                         NULL,
                         TargetPoint
                        );
            }
        }
        else
#endif
        ScrollHW(ScreenInfo,
                 &ScrollRect,
                 NULL,
                 TargetPoint
                );
        ScrollRect.Top = ScrollRect.Bottom - 1;
        WriteRegionToScreenHW(ScreenInfo,&ScrollRect);
    }
#endif
}

NTSTATUS
ScrollRegion(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN OUT PSMALL_RECT ScrollRectangle,
    IN PSMALL_RECT ClipRectangle OPTIONAL,
    IN COORD  DestinationOrigin,
    IN CHAR_INFO Fill
    )

/*++

Routine Description:

    This routine copies ScrollRectangle to DestinationOrigin then
    fills in ScrollRectangle with Fill.  The scroll region is
    copied to a third buffer, the scroll region is filled, then the
    original contents of the scroll region are copied to the destination.

Arguments:

    ScreenInfo - pointer to screen buffer info.

    ScrollRectangle - Region to copy

    ClipRectangle - Optional pointer to clip region.

    DestinationOrigin - Upper left corner of target region.

    Fill - Character and attribute to fill source region with.

Return Value:

--*/

{
    SMALL_RECT TargetRectangle, SourceRectangle;
    COORD TargetPoint;
    COORD Size;
    SMALL_RECT OurClipRectangle;
    SMALL_RECT ScrollRectangle2,ScrollRectangle3;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console = ScreenInfo->Console;

    // here's how we clip:
    //
    // Clip source rectangle to screen buffer => S
    // Create target rectangle based on S => T
    // Clip T to ClipRegion => T
    // Create S2 based on clipped T => S2
    // Clip S to ClipRegion => S3
    //
    // S2 is the region we copy to T
    // S3 is the region to fill

    if (Fill.Char.UnicodeChar == '\0' && Fill.Attributes == 0) {
        Fill.Char.UnicodeChar = (WCHAR)' ';
        Fill.Attributes = ScreenInfo->Attributes;
    }

    //
    // clip the source rectangle to the screen buffer
    //

    if (ScrollRectangle->Left < 0) {
        DestinationOrigin.X += -ScrollRectangle->Left;
        ScrollRectangle->Left = 0;
    }
    if (ScrollRectangle->Top < 0) {
        DestinationOrigin.Y += -ScrollRectangle->Top;
        ScrollRectangle->Top = 0;
    }
    if (ScrollRectangle->Right >= ScreenInfo->ScreenBufferSize.X) {
        ScrollRectangle->Right = (SHORT)(ScreenInfo->ScreenBufferSize.X-1);
    }
    if (ScrollRectangle->Bottom >= ScreenInfo->ScreenBufferSize.Y) {
        ScrollRectangle->Bottom = (SHORT)(ScreenInfo->ScreenBufferSize.Y-1);
    }

    //
    // if source rectangle doesn't intersect screen buffer, return.
    //

    if (ScrollRectangle->Bottom < ScrollRectangle->Top ||
        ScrollRectangle->Right < ScrollRectangle->Left) {
        return STATUS_SUCCESS;
    }

    //
    // clip the target rectangle
    // if a cliprectangle was provided, clip it to the screen buffer.
    // if not, set the cliprectangle to the screen buffer region.
    //

    if (ClipRectangle) {

        //
        // clip the cliprectangle.
        //

        if (ClipRectangle->Left < 0) {
            ClipRectangle->Left = 0;
        }
        if (ClipRectangle->Top < 0) {
            ClipRectangle->Top = 0;
        }
        if (ClipRectangle->Right >= ScreenInfo->ScreenBufferSize.X) {
            ClipRectangle->Right = (SHORT)(ScreenInfo->ScreenBufferSize.X-1);
        }
        if (ClipRectangle->Bottom >= ScreenInfo->ScreenBufferSize.Y) {
            ClipRectangle->Bottom = (SHORT)(ScreenInfo->ScreenBufferSize.Y-1);
        }
    }
    else {
        OurClipRectangle.Left = 0;
        OurClipRectangle.Top = 0;
        OurClipRectangle.Right = (SHORT)(ScreenInfo->ScreenBufferSize.X-1);
        OurClipRectangle.Bottom = (SHORT)(ScreenInfo->ScreenBufferSize.Y-1);
        ClipRectangle = &OurClipRectangle;
    }

    //
    // Create target rectangle based on S => T
    // Clip T to ClipRegion => T
    // Create S2 based on clipped T => S2
    //

    ScrollRectangle2 = *ScrollRectangle;
    TargetRectangle.Left = DestinationOrigin.X;
    TargetRectangle.Top = DestinationOrigin.Y;
    TargetRectangle.Right = (SHORT)(DestinationOrigin.X + (ScrollRectangle2.Right -  ScrollRectangle2.Left + 1) - 1);
    TargetRectangle.Bottom = (SHORT)(DestinationOrigin.Y + (ScrollRectangle2.Bottom - ScrollRectangle2.Top + 1) - 1);

    if (TargetRectangle.Left < ClipRectangle->Left) {
        ScrollRectangle2.Left += ClipRectangle->Left - TargetRectangle.Left;
        TargetRectangle.Left = ClipRectangle->Left;
    }
    if (TargetRectangle.Top < ClipRectangle->Top) {
        ScrollRectangle2.Top += ClipRectangle->Top - TargetRectangle.Top;
        TargetRectangle.Top = ClipRectangle->Top;
    }
    if (TargetRectangle.Right > ClipRectangle->Right) {
        ScrollRectangle2.Right -= TargetRectangle.Right - ClipRectangle->Right;
        TargetRectangle.Right = ClipRectangle->Right;
    }
    if (TargetRectangle.Bottom > ClipRectangle->Bottom) {
        ScrollRectangle2.Bottom -= TargetRectangle.Bottom - ClipRectangle->Bottom;
        TargetRectangle.Bottom = ClipRectangle->Bottom;
    }

    //
    // clip scroll rect to clipregion => S3
    //

    ScrollRectangle3 = *ScrollRectangle;
    if (ScrollRectangle3.Left < ClipRectangle->Left) {
        ScrollRectangle3.Left = ClipRectangle->Left;
    }
    if (ScrollRectangle3.Top < ClipRectangle->Top) {
        ScrollRectangle3.Top = ClipRectangle->Top;
    }
    if (ScrollRectangle3.Right > ClipRectangle->Right) {
        ScrollRectangle3.Right = ClipRectangle->Right;
    }
    if (ScrollRectangle3.Bottom > ClipRectangle->Bottom) {
        ScrollRectangle3.Bottom = ClipRectangle->Bottom;
    }

    //
    // if scroll rect doesn't intersect clip region, return.
    //

    if (ScrollRectangle3.Bottom < ScrollRectangle3.Top ||
        ScrollRectangle3.Right < ScrollRectangle3.Left) {
        return STATUS_SUCCESS;
    }

    ConsoleHideCursor(ScreenInfo);

#if defined(FE_IME)
    Console->ConsoleIme.ScrollWaitCountDown = Console->ConsoleIme.ScrollWaitTimeout;
#endif // FE_IME
    //
    // if target rectangle doesn't intersect screen buffer, skip scrolling
    // part.
    //

    if (!(TargetRectangle.Bottom < TargetRectangle.Top ||
          TargetRectangle.Right < TargetRectangle.Left)) {

        //
        // if we can, don't use intermediate scroll region buffer.  do this
        // by figuring out fill rectangle.  NOTE: this code will only work
        // if CopyRectangle copies from low memory to high memory (otherwise
        // we would overwrite the scroll region before reading it).
        //

        if (ScrollRectangle2.Right == TargetRectangle.Right &&
            ScrollRectangle2.Left == TargetRectangle.Left &&
            ScrollRectangle2.Top > TargetRectangle.Top &&
            ScrollRectangle2.Top < TargetRectangle.Bottom) {

            SMALL_RECT FillRect;
            SHORT LastRowIndex,OldRight,OldLeft;
            PROW Row;

            TargetPoint.X = TargetRectangle.Left;
            TargetPoint.Y = TargetRectangle.Top;
            if (ScrollRectangle2.Right == (SHORT)(ScreenInfo->ScreenBufferSize.X-1) &&
                ScrollRectangle2.Left == 0 &&
                ScrollRectangle2.Bottom == (SHORT)(ScreenInfo->ScreenBufferSize.Y-1) &&
                ScrollRectangle2.Top == 1 ) {
                LastRowIndex = ScrollEntireScreen(ScreenInfo,(SHORT)(ScrollRectangle2.Top-TargetRectangle.Top),TRUE);
                Row = &ScreenInfo->BufferInfo.TextInfo.Rows[LastRowIndex];
                OldRight = Row->CharRow.OldRight;
                OldLeft = Row->CharRow.OldLeft;
            } else {
                LastRowIndex = -1;
                CopyRectangle(ScreenInfo,
                              &ScrollRectangle2,
                              TargetPoint
                             );
            }
            FillRect.Left = TargetRectangle.Left;
            FillRect.Right = TargetRectangle.Right;
            FillRect.Top = (SHORT)(TargetRectangle.Bottom+1);
            FillRect.Bottom = ScrollRectangle->Bottom;
            if (FillRect.Top < ClipRectangle->Top) {
                FillRect.Top = ClipRectangle->Top;
            }
            if (FillRect.Bottom > ClipRectangle->Bottom) {
                FillRect.Bottom = ClipRectangle->Bottom;
            }
            FillRectangle(Fill,
                          ScreenInfo,
                          &FillRect
                         );

            //
            // After ScrollEntireScreen, the OldRight and OldLeft values
            // for the last row are set correctly.  however, FillRectangle
            // resets them with the previous first row of the screen.
            // reset them here.
            //

            if (LastRowIndex != -1) {
                Row->CharRow.OldRight = OldRight;
                Row->CharRow.OldLeft = OldLeft;
            }

            //
            // update to screen, if we're not iconic.  we're marked as
            // iconic if we're fullscreen, so check for fullscreen.
            //

            if (!(Console->Flags & CONSOLE_IS_ICONIC) ||
                 Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) {
                ScrollScreen(ScreenInfo,
                       &ScrollRectangle2,
                       &FillRect,
                       TargetPoint
                      );
            }
        }

        //
        // if no overlap, don't need intermediate copy
        //

        else if (ScrollRectangle3.Right < TargetRectangle.Left ||
                 ScrollRectangle3.Left > TargetRectangle.Right ||
                 ScrollRectangle3.Top > TargetRectangle.Bottom ||
                 ScrollRectangle3.Bottom < TargetRectangle.Top) {
            TargetPoint.X = TargetRectangle.Left;
            TargetPoint.Y = TargetRectangle.Top;
            CopyRectangle(ScreenInfo,
                          &ScrollRectangle2,
                          TargetPoint
                         );
            FillRectangle(Fill,
                          ScreenInfo,
                          &ScrollRectangle3
                         );

            //
            // update to screen, if we're not iconic.  we're marked as
            // iconic if we're fullscreen, so check for fullscreen.
            //

            if (!(Console->Flags & CONSOLE_IS_ICONIC) ||
                Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) {
                ScrollScreen(ScreenInfo,
                       &ScrollRectangle2,
                       &ScrollRectangle3,
                       TargetPoint
                      );
            }
        }

        //
        // for the case where the source and target rectangles overlap, we
        // copy the source rectangle, fill it, then copy it to the target.
        //

        else {
            SMALL_RECT TargetRect;
            COORD SourcePoint;

            LockScrollBuffer();
            Size.X = (SHORT)(ScrollRectangle2.Right - ScrollRectangle2.Left + 1);
            Size.Y = (SHORT)(ScrollRectangle2.Bottom - ScrollRectangle2.Top + 1);
            if (ScrollBufferSize < (Size.X * Size.Y * sizeof(CHAR_INFO))) {
                FreeScrollBuffer();
                Status = AllocateScrollBuffer(Size.X * Size.Y * sizeof(CHAR_INFO));
                if (!NT_SUCCESS(Status)) {
                    UnlockScrollBuffer();
                    ConsoleShowCursor(ScreenInfo);
                    return Status;
                }
            }

            TargetRect.Left = 0;
            TargetRect.Top = 0;
            TargetRect.Right = ScrollRectangle2.Right - ScrollRectangle2.Left;
            TargetRect.Bottom = ScrollRectangle2.Bottom - ScrollRectangle2.Top;
            SourcePoint.X = ScrollRectangle2.Left;
            SourcePoint.Y = ScrollRectangle2.Top;
            ReadRectFromScreenBuffer(ScreenInfo,
                                     SourcePoint,
                                     ScrollBuffer,
                                     Size,
                                     &TargetRect
                                    );

            FillRectangle(Fill,
                          ScreenInfo,
                          &ScrollRectangle3
                         );

            SourceRectangle.Top = 0;
            SourceRectangle.Left = 0;
            SourceRectangle.Right = (SHORT)(Size.X-1);
            SourceRectangle.Bottom = (SHORT)(Size.Y-1);
            TargetPoint.X = TargetRectangle.Left;
            TargetPoint.Y = TargetRectangle.Top;
            WriteRectToScreenBuffer((PBYTE)ScrollBuffer,
                                    Size,
                                    &SourceRectangle,
                                    ScreenInfo,
                                    TargetPoint,
                                    0xFFFFFFFF
                                   );
            UnlockScrollBuffer();

            //
            // update to screen, if we're not iconic.  we're marked as
            // iconic if we're fullscreen, so check for fullscreen.
            //

            if (!(Console->Flags & CONSOLE_IS_ICONIC) ||
                Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) {

                //
                // update regions on screen.
                //

                ScrollScreen(ScreenInfo,
                       &ScrollRectangle2,
                       &ScrollRectangle3,
                       TargetPoint
                      );
            }
        }
    }
    else {

        //
        // do fill
        //

        FillRectangle(Fill,
                      ScreenInfo,
                      &ScrollRectangle3
                     );

        //
        // update to screen, if we're not iconic.  we're marked as
        // iconic if we're fullscreen, so check for fullscreen.
        //

        if (ACTIVE_SCREEN_BUFFER(ScreenInfo) &&
            !(Console->Flags & CONSOLE_IS_ICONIC) ||
            Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) {
            WriteToScreen(ScreenInfo,&ScrollRectangle3);
        }
    }
    ConsoleShowCursor(ScreenInfo);
    return STATUS_SUCCESS;
}


NTSTATUS
SetWindowOrigin(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN BOOLEAN Absolute,
    IN COORD WindowOrigin
    )

/*++

Routine Description:

    This routine sets the window origin.

Arguments:

    ScreenInfo - pointer to screen buffer info.

    Absolute - if TRUE, WindowOrigin is specified in absolute screen
    buffer coordinates.  if FALSE, WindowOrigin is specified in coordinates
    relative to the current window origin.

    WindowOrigin - New window origin.

Return Value:

--*/

{
    SMALL_RECT NewWindow;
    COORD WindowSize;
    RECT BoundingBox;
    BOOL Success;
    RECT ScrollRect;
    SMALL_RECT UpdateRegion;
    COORD FontSize;
    PCONSOLE_INFORMATION Console = ScreenInfo->Console;

    //
    // calculate window size
    //

    WindowSize.X = (SHORT)CONSOLE_WINDOW_SIZE_X(ScreenInfo);
    WindowSize.Y = (SHORT)CONSOLE_WINDOW_SIZE_Y(ScreenInfo);

    //
    // if relative coordinates, figure out absolute coords.
    //

    if (!Absolute) {
        if (WindowOrigin.X == 0 && WindowOrigin.Y == 0) {
            return STATUS_SUCCESS;
        }
        NewWindow.Left = ScreenInfo->Window.Left + WindowOrigin.X;
        NewWindow.Top = ScreenInfo->Window.Top + WindowOrigin.Y;
    }
    else {
        if (WindowOrigin.X == ScreenInfo->Window.Left &&
            WindowOrigin.Y == ScreenInfo->Window.Top) {
            return STATUS_SUCCESS;
        }
        NewWindow.Left = WindowOrigin.X;
        NewWindow.Top = WindowOrigin.Y;
    }
    NewWindow.Right = (SHORT)(NewWindow.Left + WindowSize.X - 1);
    NewWindow.Bottom = (SHORT)(NewWindow.Top + WindowSize.Y - 1);

    //
    // see if new window origin would extend window beyond extent of screen
    // buffer
    //

    if (NewWindow.Left < 0 || NewWindow.Top < 0 ||
        NewWindow.Right < 0 || NewWindow.Bottom < 0 ||
        NewWindow.Right >= ScreenInfo->ScreenBufferSize.X ||
        NewWindow.Bottom >= ScreenInfo->ScreenBufferSize.Y) {
        return STATUS_INVALID_PARAMETER;
    }

    if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
        FontSize = SCR_FONTSIZE(ScreenInfo);
        ScreenInfo->BufferInfo.TextInfo.Flags &= ~TEXT_VALID_HINT;
    } else {
        FontSize.X = 1;
        FontSize.Y = 1;
    }
    ConsoleHideCursor(ScreenInfo);
    if (ACTIVE_SCREEN_BUFFER(ScreenInfo) &&
        Console->FullScreenFlags == 0 &&
        !(Console->Flags & (CONSOLE_IS_ICONIC | CONSOLE_NO_WINDOW))) {

        InvertSelection(Console, TRUE);
#if defined(FE_SB)
        if (CONSOLE_IS_DBCS_OUTPUTCP(Console) &&
            !(Console->ConsoleIme.ScrollFlag & HIDE_FOR_SCROLL)) {
            ConsoleImeBottomLineUse(ScreenInfo,0);
        }
#endif
        if (   ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER
            && UsePolyTextOut
            && NewWindow.Left == ScreenInfo->Window.Left
           ) {
            ScrollEntireScreen(ScreenInfo,
                (SHORT)(NewWindow.Top - ScreenInfo->Window.Top),
                FALSE);
            ScreenInfo->Window = NewWindow;
            WriteRegionToScreen(ScreenInfo, &NewWindow);
        } else {
#if defined(FE_SB)
            RECT ClipRect;
#endif
            ScrollRect.left = 0;
            ScrollRect.right = CONSOLE_WINDOW_SIZE_X(ScreenInfo)*FontSize.X;
            ScrollRect.top = 0;
#if defined(FE_SB)
            if (CONSOLE_IS_DBCS_OUTPUTCP(Console) &&
                Console->InputBuffer.ImeMode.Open )
            {
                if (ScreenInfo->Window.Top <= NewWindow.Top)
                    ScrollRect.bottom = (CONSOLE_WINDOW_SIZE_Y(ScreenInfo)-1)*FontSize.Y;
                else
                    ScrollRect.bottom = (CONSOLE_WINDOW_SIZE_Y(ScreenInfo)-2)*FontSize.Y;
                ClipRect = ScrollRect;
                ClipRect.bottom = (CONSOLE_WINDOW_SIZE_Y(ScreenInfo)-1)*FontSize.Y;
            }
            else
#endif
            ScrollRect.bottom = CONSOLE_WINDOW_SIZE_Y(ScreenInfo)*FontSize.Y;

#if defined(FE_SB)
            if (CONSOLE_IS_DBCS_OUTPUTCP(Console) &&
                ScrollRect.bottom == 0) {
                UpdateRegion.Left   = 0;
                UpdateRegion.Top    = 0;
                UpdateRegion.Right  = CONSOLE_WINDOW_SIZE_X(ScreenInfo);
                UpdateRegion.Bottom = 0;
                WriteToScreen(ScreenInfo,&UpdateRegion);
            }
            else {
#endif
            SCROLLDC_CALL;
#if defined(FE_SB)
                if (CONSOLE_IS_DBCS_OUTPUTCP(Console) &&
                     Console->InputBuffer.ImeMode.Open )
                {
                    Success = ScrollDC(Console->hDC,
                                         (ScreenInfo->Window.Left-NewWindow.Left)*FontSize.X,
                                         (ScreenInfo->Window.Top-NewWindow.Top)*FontSize.Y,
                                         &ScrollRect,
                                         &ClipRect,
                                         NULL,
                                         &BoundingBox
                                         );
                }
                else
#endif
            Success = ScrollDC(Console->hDC,
                                 (ScreenInfo->Window.Left-NewWindow.Left)*FontSize.X,
                                 (ScreenInfo->Window.Top-NewWindow.Top)*FontSize.Y,
                                 &ScrollRect,
                                 NULL,
                                 NULL,
                                 &BoundingBox
                               );

            //
            // Fire off an event to let accessibility apps know we've scrolled.
            //

            ConsoleNotifyWinEvent(Console,
                                  EVENT_CONSOLE_UPDATE_SCROLL,
                                  ScreenInfo->Window.Left - NewWindow.Left,
                                  ScreenInfo->Window.Top - NewWindow.Top);

            if (Success) {
                UpdateRegion.Left = (SHORT)((BoundingBox.left/FontSize.X)+NewWindow.Left);
                UpdateRegion.Right = (SHORT)(((BoundingBox.right-1)/FontSize.X)+NewWindow.Left);
                UpdateRegion.Top = (SHORT)((BoundingBox.top/FontSize.Y)+NewWindow.Top);
                UpdateRegion.Bottom = (SHORT)(((BoundingBox.bottom-1)/FontSize.Y)+NewWindow.Top);
            }
            else  {
                UpdateRegion = NewWindow;
            }

            //
            // new window is ok.  store it in screeninfo and refresh screen.
            //

            ScreenInfo->Window = NewWindow;

            WriteToScreen(ScreenInfo,&UpdateRegion);
#if defined(FE_SB)
            }
#endif
        }
        InvertSelection(Console, FALSE);
    }
#ifdef i386
    else if (Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE &&
             ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {


        //
        // keep mouse pointer on screen
        //

        if (ScreenInfo->BufferInfo.TextInfo.MousePosition.X < NewWindow.Left) {
            ScreenInfo->BufferInfo.TextInfo.MousePosition.X = NewWindow.Left;
        } else if (ScreenInfo->BufferInfo.TextInfo.MousePosition.X > NewWindow.Right) {
            ScreenInfo->BufferInfo.TextInfo.MousePosition.X = NewWindow.Right;
        }

        if (ScreenInfo->BufferInfo.TextInfo.MousePosition.Y < NewWindow.Top) {
            ScreenInfo->BufferInfo.TextInfo.MousePosition.Y = NewWindow.Top;
        } else if (ScreenInfo->BufferInfo.TextInfo.MousePosition.Y > NewWindow.Bottom) {
            ScreenInfo->BufferInfo.TextInfo.MousePosition.Y = NewWindow.Bottom;
        }
        ScreenInfo->Window = NewWindow;
        WriteToScreen(ScreenInfo,&ScreenInfo->Window);
    }
#endif
    else {
        // we're iconic
        ScreenInfo->Window = NewWindow;
    }

#if defined(FE_SB)
    if (CONSOLE_IS_DBCS_OUTPUTCP(Console) ) {
        ConsoleImeResizeModeSystemView(Console,ScreenInfo->Window);
        ConsoleImeResizeCompStrView(Console,ScreenInfo->Window);
    }
#endif
    ConsoleShowCursor(ScreenInfo);

    if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
         ScreenInfo->BufferInfo.TextInfo.Flags |= TEXT_VALID_HINT;
    }

    UpdateScrollBars(ScreenInfo);
    return STATUS_SUCCESS;
}

NTSTATUS
ResizeWindow(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT WindowDimensions,
    IN BOOL DoScrollBarUpdate
    )

/*++

Routine Description:

    This routine changes the console data structures to reflect the specified
    window size change.  it does not call the user component to update
    the screen.

Arguments:

    ScreenInformation - the new screen buffer.

    dwWindowSize - the initial size of screen buffer's window.

    nFont - the initial font to generate text with.

    dwScreenBufferSize - the initial size of the screen buffer.

Return Value:


--*/

{
    //
    // make sure there's something to do
    //

    if (RtlEqualMemory(&ScreenInfo->Window, WindowDimensions, sizeof(SMALL_RECT))) {
        return STATUS_SUCCESS;
    }

    if (WindowDimensions->Left < 0) {
        WindowDimensions->Right -= WindowDimensions->Left;
        WindowDimensions->Left = 0;
    }
    if (WindowDimensions->Top < 0) {
        WindowDimensions->Bottom -= WindowDimensions->Top;
        WindowDimensions->Top = 0;
    }

    if (WindowDimensions->Right >= ScreenInfo->ScreenBufferSize.X) {
        WindowDimensions->Right = ScreenInfo->ScreenBufferSize.X;
    }
    if (WindowDimensions->Bottom >= ScreenInfo->ScreenBufferSize.Y) {
        WindowDimensions->Bottom = ScreenInfo->ScreenBufferSize.Y;
    }

    ScreenInfo->Window = *WindowDimensions;
    ScreenInfo->WindowMaximizedX = (CONSOLE_WINDOW_SIZE_X(ScreenInfo) == ScreenInfo->ScreenBufferSize.X);
    ScreenInfo->WindowMaximizedY = (CONSOLE_WINDOW_SIZE_Y(ScreenInfo) == ScreenInfo->ScreenBufferSize.Y);

    if (DoScrollBarUpdate) {
        UpdateScrollBars(ScreenInfo);
    }

    if (!(ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER)) {
        return STATUS_SUCCESS;
    }

    if (ACTIVE_SCREEN_BUFFER(ScreenInfo)) {
        ScreenInfo->BufferInfo.TextInfo.Flags &= ~TEXT_VALID_HINT;
    }

#ifdef i386
    if (ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) {

        //
        // keep mouse pointer on screen
        //

        if (ScreenInfo->BufferInfo.TextInfo.MousePosition.X < WindowDimensions->Left) {
            ScreenInfo->BufferInfo.TextInfo.MousePosition.X = WindowDimensions->Left;
        } else if (ScreenInfo->BufferInfo.TextInfo.MousePosition.X > WindowDimensions->Right) {
            ScreenInfo->BufferInfo.TextInfo.MousePosition.X = WindowDimensions->Right;
        }

        if (ScreenInfo->BufferInfo.TextInfo.MousePosition.Y < WindowDimensions->Top) {
            ScreenInfo->BufferInfo.TextInfo.MousePosition.Y = WindowDimensions->Top;
        } else if (ScreenInfo->BufferInfo.TextInfo.MousePosition.Y > WindowDimensions->Bottom) {
            ScreenInfo->BufferInfo.TextInfo.MousePosition.Y = WindowDimensions->Bottom;
        }
    }
#endif

    return(STATUS_SUCCESS);
}

VOID
SetWindowSize(
    IN PSCREEN_INFORMATION ScreenInfo
    )
{
#if defined(FE_IME)
    if (ScreenInfo->ConvScreenInfo != NULL)
        return;
#endif
    if (ScreenInfo->Console->Flags & CONSOLE_SETTING_WINDOW_SIZE)
        return;
    ScreenInfo->Console->Flags |= CONSOLE_SETTING_WINDOW_SIZE;
    PostMessage(ScreenInfo->Console->hWnd,
                 CM_SET_WINDOW_SIZE,
                 (WPARAM)ScreenInfo,
                 0x47474747
                );
}

VOID
UpdateWindowSize(
    IN PCONSOLE_INFORMATION Console,
    IN PSCREEN_INFORMATION ScreenInfo
    )
{
    LONG WindowStyle;

    if (!(Console->Flags & CONSOLE_IS_ICONIC)) {
        InternalUpdateScrollBars(ScreenInfo);

        WindowStyle = GetWindowLong(Console->hWnd, GWL_STYLE);
        if (ScreenInfo->WindowMaximized) {
            WindowStyle |= WS_MAXIMIZE;
        } else {
            WindowStyle &= ~WS_MAXIMIZE;
        }
        SetWindowLong(Console->hWnd, GWL_STYLE, WindowStyle);

        SetWindowPos(Console->hWnd, NULL,
                     0,
                     0,
                     Console->WindowRect.right-Console->WindowRect.left,
                     Console->WindowRect.bottom-Console->WindowRect.top,
                     SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | SWP_DRAWFRAME
                    );
        Console->ResizeFlags &= ~SCREEN_BUFFER_CHANGE;
    } else {
        Console->ResizeFlags |= SCREEN_BUFFER_CHANGE;
    }
}

NTSTATUS
InternalSetWindowSize(
    IN PCONSOLE_INFORMATION Console,
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT Window
    )
{
    SIZE WindowSize;
    WORD WindowSizeX, WindowSizeY;

    Console->Flags &= ~CONSOLE_SETTING_WINDOW_SIZE;
    if (Console->CurrentScreenBuffer == ScreenInfo) {
        if (Console->FullScreenFlags == 0) {
            //
            // Make sure our max screen sizes reflect reality
            //

            if (gfInitSystemMetrics) {
                InitializeSystemMetrics();
            }

            //
            // figure out how big to make the window, given the desired client area
            // size.
            //

            ScreenInfo->ResizingWindow++;
            WindowSizeX = WINDOW_SIZE_X(Window);
            WindowSizeY = WINDOW_SIZE_Y(Window);
            if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
                WindowSize.cx = WindowSizeX*SCR_FONTSIZE(ScreenInfo).X;
                WindowSize.cy = WindowSizeY*SCR_FONTSIZE(ScreenInfo).Y;
            } else {
                WindowSize.cx = WindowSizeX;
                WindowSize.cy = WindowSizeY;
            }
            WindowSize.cx += VerticalClientToWindow;
            WindowSize.cy += HorizontalClientToWindow;

            if (WindowSizeY != 0) {
                if (!ScreenInfo->WindowMaximizedX) {
                    WindowSize.cy += HorizontalScrollSize;
                }
                if (!ScreenInfo->WindowMaximizedY) {
                    WindowSize.cx += VerticalScrollSize;
                }
            }

            Console->WindowRect.right = Console->WindowRect.left + WindowSize.cx;
            Console->WindowRect.bottom = Console->WindowRect.top + WindowSize.cy;

            UpdateWindowSize(Console,ScreenInfo);
            ScreenInfo->ResizingWindow--;
        } else if (Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) {
            WriteToScreen(ScreenInfo,&ScreenInfo->Window);
        }
#if defined(FE_IME)
        if ( (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) &&
             (CONSOLE_IS_DBCS_OUTPUTCP(Console)))
        {
            ConsoleImeResizeModeSystemView(Console,Console->CurrentScreenBuffer->Window);
            ConsoleImeResizeCompStrView(Console,Console->CurrentScreenBuffer->Window);
        }
#endif // FE_IME
    }
    return STATUS_SUCCESS;
}

NTSTATUS
SetActiveScreenBuffer(
    IN PSCREEN_INFORMATION ScreenInfo
    )
{
    PSCREEN_INFORMATION OldScreenInfo;
    PCONSOLE_INFORMATION Console = ScreenInfo->Console;

    OldScreenInfo = Console->CurrentScreenBuffer;
    if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {

#if !defined(_X86_)
        if (Console->FullScreenFlags & CONSOLE_FULLSCREEN) {
            return STATUS_INVALID_PARAMETER;
        }
#endif
        Console->CurrentScreenBuffer = ScreenInfo;

        if (Console->FullScreenFlags == 0) {

            //
            // initialize cursor
            //

            ScreenInfo->BufferInfo.TextInfo.CursorOn = FALSE;

            //
            // set font
            //

            SetFont(ScreenInfo);
        }
#if defined(_X86_)
        else if (Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) {

            if (!(Console->Flags & CONSOLE_VDM_REGISTERED)) {

                if ( (!(OldScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER)) ||
                     (OldScreenInfo->BufferInfo.TextInfo.ModeIndex!=ScreenInfo->BufferInfo.TextInfo.ModeIndex)) {

                    // set video mode and font
                    SetVideoMode(ScreenInfo);
                }

                //set up cursor

                SetCursorInformationHW(ScreenInfo,
                                       ScreenInfo->BufferInfo.TextInfo.CursorSize,
                                       ScreenInfo->BufferInfo.TextInfo.CursorVisible);
                SetCursorPositionHW(ScreenInfo,
                                    ScreenInfo->BufferInfo.TextInfo.CursorPosition);
            }

        }
#endif
    }
    else {
        Console->CurrentScreenBuffer = ScreenInfo;
    }

    //
    // empty input buffer
    //

    FlushAllButKeys(&Console->InputBuffer);

    if (Console->FullScreenFlags == 0) {

        SetScreenColors(ScreenInfo, ScreenInfo->Attributes,
                        ScreenInfo->PopupAttributes, FALSE);

        //
        // set window size
        //

        SetWindowSize(ScreenInfo);

        //
        // initialize the palette, if we have the focus and we're not fullscreen
        //

        if (!(Console->Flags & CONSOLE_IS_ICONIC) &&
            Console->FullScreenFlags == 0) {
            if (ScreenInfo->hPalette != NULL || OldScreenInfo->hPalette != NULL) {
                HPALETTE hPalette;
                BOOL bReset = FALSE;
                USERTHREAD_USEDESKTOPINFO utudi;

                if (GetCurrentThreadId() != Console->InputThreadInfo->ThreadId) {
                    bReset = TRUE;
                    utudi.hThread = Console->InputThreadInfo->ThreadHandle;
                    utudi.drdRestore.pdeskRestore = NULL;
                    NtUserSetInformationThread(NtCurrentThread(),
                            UserThreadUseDesktop,
                            &utudi, sizeof(utudi));
                }

                if (ScreenInfo->hPalette == NULL) {
                    hPalette = Console->hSysPalette;
                } else {
                    hPalette = ScreenInfo->hPalette;
                }
                SelectPalette(Console->hDC,
                                 hPalette,
                                 FALSE);
                SetActivePalette(ScreenInfo);

                if (bReset == TRUE) {
                    utudi.hThread = NULL;
                    NtUserSetInformationThread(NtCurrentThread(),
                            UserThreadUseDesktop, &utudi, sizeof(utudi));
                }
            }
        }
    }

#if defined(FE_IME)
    SetUndetermineAttribute(Console);
#endif
    //
    // write data to screen
    //

    ScreenInfo->BufferInfo.TextInfo.Flags &= ~TEXT_VALID_HINT;
    WriteToScreen(ScreenInfo,&ScreenInfo->Window);
    return STATUS_SUCCESS;
}

VOID
SetProcessFocus(
    IN PCSR_PROCESS Process,
    IN BOOL Foreground
    )
{
    if (Foreground) {
        CsrSetForegroundPriority(Process);
    } else {
        CsrSetBackgroundPriority(Process);
    }
}

VOID
SetProcessForegroundRights(
    IN PCSR_PROCESS Process,
    IN BOOL Foreground
    )
{
    USERTHREAD_FLAGS Flags;

    Flags.dwMask  = (W32PF_ALLOWSETFOREGROUND | W32PF_CONSOLEHASFOCUS);
    Flags.dwFlags = (Foreground ? (W32PF_ALLOWSETFOREGROUND | W32PF_CONSOLEHASFOCUS) : 0);

    NtUserSetInformationProcess(Process->ProcessHandle, UserProcessFlags, &Flags, sizeof(Flags));
}

VOID
ModifyConsoleProcessFocus(
    IN PCONSOLE_INFORMATION Console,
    IN BOOL Foreground
    )
{
    PCONSOLE_PROCESS_HANDLE ProcessHandleRecord;
    PLIST_ENTRY ListHead, ListNext;

    ListHead = &Console->ProcessHandleList;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        ProcessHandleRecord = CONTAINING_RECORD( ListNext, CONSOLE_PROCESS_HANDLE, ListLink );
        ListNext = ListNext->Flink;
        SetProcessFocus(ProcessHandleRecord->Process, Foreground);
        SetProcessForegroundRights(ProcessHandleRecord->Process, Foreground);
    }
}

VOID
TrimConsoleWorkingSet(
    IN PCONSOLE_INFORMATION Console
    )
{
    PCONSOLE_PROCESS_HANDLE ProcessHandleRecord;
    PLIST_ENTRY ListHead, ListNext;

    ListHead = &Console->ProcessHandleList;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        ProcessHandleRecord = CONTAINING_RECORD( ListNext, CONSOLE_PROCESS_HANDLE, ListLink );
        ListNext = ListNext->Flink;
        SetProcessWorkingSetSize(ProcessHandleRecord->Process->ProcessHandle, (SIZE_T)-1, (SIZE_T)-1);
    }
}

NTSTATUS
QueueConsoleMessage(
    PCONSOLE_INFORMATION Console,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam
    )

/*++

Routine Description:

    This inserts a message into the console's message queue and wakes up
    the console input thread to process it.

Arguments:

    Console - Pointer to console information structure.

    Message - Message to store in queue.

    wParam - wParam to store in queue.

    lParam - lParam to store in queue.

Return Value:

    NTSTATUS - STATUS_SUCCESS if everything is OK.

--*/

{
    PCONSOLE_MSG pConMsg;

    ASSERT(ConsoleLocked(Console));

    pConMsg = (PCONSOLE_MSG)ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ), sizeof(CONSOLE_MSG));
    if (pConMsg == NULL) {
        return STATUS_NO_MEMORY;
    }

    pConMsg->Message = Message;
    pConMsg->wParam = wParam;
    pConMsg->lParam = lParam;

    InsertHeadList(&Console->MessageQueue, &pConMsg->ListLink);

    if (!PostMessage(Console->hWnd, CM_CONSOLE_MSG, 0, 0)) {
        RemoveEntryList(&pConMsg->ListLink);
        ConsoleHeapFree(pConMsg);
        return STATUS_UNSUCCESSFUL;
    }

    return STATUS_SUCCESS;
}

BOOL
UnqueueConsoleMessage(
    PCONSOLE_INFORMATION Console,
    UINT *pMessage,
    WPARAM *pwParam,
    LPARAM *plParam
    )

/*++

Routine Description:

    This routine removes a message from the console's message queue.

Arguments:

    Console - Pointer to console information structure.

    pMessage - Pointer in which to return Message.

    pwParam - Pointer in which to return wParam.

    plParam - Pointer in which to return lParam.

Return Value:

    BOOL - TRUE if message was found and FALSE otherwise.

--*/

{
    PLIST_ENTRY pEntry;
    PCONSOLE_MSG pConMsg = NULL;

    ASSERT(ConsoleLocked(Console));

    if (IsListEmpty(&Console->MessageQueue)) {
        return FALSE;
    }

    pEntry = RemoveTailList(&Console->MessageQueue);
    pConMsg = CONTAINING_RECORD(pEntry, CONSOLE_MSG, ListLink);

    *pMessage = pConMsg->Message;
    *pwParam = pConMsg->wParam;
    *plParam = pConMsg->lParam;

    ConsoleHeapFree(pConMsg);

    return TRUE;
}

VOID
CleanupConsoleMessages(
    PCONSOLE_INFORMATION Console
    )

/*++

Routine Description:

    This routine cleans up any console messages still in the queue.

Arguments:

    Console - Pointer to console information structure.

Return Value:

    none.

--*/

{
    UINT Message;
    WPARAM wParam;
    LPARAM lParam;

    while (UnqueueConsoleMessage(Console, &Message, &wParam, &lParam)) {
        switch (Message) {
        case CM_MODE_TRANSITION:
            NtSetEvent((HANDLE)lParam, NULL);
            NtClose((HANDLE)lParam);
            break;
        case CM_SET_IME_CODEPAGE:
        case CM_SET_NLSMODE:
        case CM_GET_NLSMODE:
            if (wParam) {
                NtSetEvent((HANDLE)wParam, NULL);
                NtClose((HANDLE)wParam);
            }
            break;
        case EVENT_CONSOLE_CARET:
        case EVENT_CONSOLE_UPDATE_REGION:
        case EVENT_CONSOLE_UPDATE_SIMPLE:
        case EVENT_CONSOLE_UPDATE_SCROLL:
        case EVENT_CONSOLE_LAYOUT:
        case EVENT_CONSOLE_START_APPLICATION:
        case EVENT_CONSOLE_END_APPLICATION:
            break;
        default:
            KdPrint(("CONSRV: CleanupConsoleMessages - unknown message %x\n", Message));
            ASSERT(FALSE);
            break;
        }
    }
}

VOID
ConsoleNotifyWinEvent(
    IN PCONSOLE_INFORMATION Console,
    IN DWORD Event,
    IN LONG idObjectType,
    IN LONG idObject
    )

/*++

Routine Description:

    If this routine is called by the console input thread, it can notify the
    system about the event by calling NotifyWinEvent directly. Otherwise, it
    queues the event up for the input thread to deal with.

Arguments:

    Console - Pointer to console information structure.

    Event - Event that occurred.

    idObjectType - Additional data about the event.

    idObject - Additional data about the event.

Return Value:

    none.

--*/

{
    //
    // If no one's listening then there's no reason to send the winevent.
    //
    if (!IsWinEventHookInstalled(Event)) {
        return;
    }

    //
    // Due to the asynchronous nature of console creation, it's possible we'll get
    // here but the InputThreadInfo pointer hasn't been set yet. If that's the case,
    // we're certainly not the ConsoleInputThread, so conceptually we'd want to queue
    // up the winevent anyway.
    //
    if (Console->InputThreadInfo != NULL &&
        HandleToUlong(NtCurrentTeb()->ClientId.UniqueThread) == Console->InputThreadInfo->ThreadId) {
        NotifyWinEvent(Event, Console->hWnd, idObjectType, idObject);
    } else {
        QueueConsoleMessage(Console, Event, idObjectType, idObject);
    }
}

VOID
AbortCreateConsole(
    IN PCONSOLE_INFORMATION Console
    )
{
    //
    // Signal any process waiting for us that initialization failed
    //

    NtSetEvent(Console->InitEvents[INITIALIZATION_FAILED], NULL);

    //
    // Now clean up the console structure
    //

    CloseHandle(Console->ClientThreadHandle);
    FreeInputBuffer(&Console->InputBuffer);
    ConsoleHeapFree(Console->Title);
    ConsoleHeapFree(Console->OriginalTitle);
    NtClose(Console->InitEvents[INITIALIZATION_SUCCEEDED]);
    NtClose(Console->InitEvents[INITIALIZATION_FAILED]);
    NtClose(Console->TerminationEvent);
    FreeAliasBuffers(Console);
    FreeCommandHistoryBuffers(Console);
#if defined(FE_SB)
    FreeLocalEUDC(Console);
    DestroyFontCache(Console->FontCacheInformation);
#endif
    DestroyConsole(Console);
}

VOID
DestroyWindowsWindow(
    IN PCONSOLE_INFORMATION Console
    )
{
    PSCREEN_INFORMATION Cur,Next;
    HWND hWnd = Console->hWnd;

    gnConsoleWindows--;
    Console->InputThreadInfo->WindowCount--;

    SetWindowConsole(hWnd, NULL);

    KillTimer(Console->hWnd,CURSOR_TIMER);

    if (Console->hWndProperties) {
        SendMessage(Console->hWndProperties, WM_CLOSE, 0, 0);
    }

    // FE_SB
    if (Console->FonthDC) {
        ReleaseDC(NULL, Console->FonthDC);
        DeleteObject(Console->hBitmap);
    }
    DeleteEUDC(Console);

    // FE_IME
    if (CONSOLE_IS_IME_ENABLED()) {
        if (!(Console->Flags & CONSOLE_NO_WINDOW)) {
            // v-HirShi Jul.4.1995 For console IME
            KillTimer(Console->hWnd, SCROLL_WAIT_TIMER);
        }
        ConsoleImeMessagePump(Console,
                              CONIME_DESTROY,
                              (WPARAM)Console->ConsoleHandle,
                              (LPARAM)NULL
                             );
    }
    // end FE_IME
    // end FE_SB

    CleanupConsoleMessages(Console);

    ReleaseDC(NULL, Console->hDC);
    Console->hDC = NULL;

    DestroyWindow(Console->hWnd);
    Console->hWnd = NULL;

    //
    // Tell the worker thread that the window is destroyed.
    //

    ReplyMessage(0);

    //
    // Clear out any keyboard messages we have stored away.
    //

    ClearKeyInfo(hWnd);

    if (Console->hIcon != NULL && Console->hIcon != ghDefaultIcon) {
        DestroyIcon(Console->hIcon);
    }
    if (Console->hSmIcon != NULL && Console->hSmIcon != ghDefaultSmIcon) {
        DestroyIcon(Console->hSmIcon);
    }

    //
    // must keep this thread handle around until after the destroywindow
    // call so that impersonation will work.
    //

    CloseHandle(Console->ClientThreadHandle);

    //
    // once the sendmessage returns, there will be no more input to
    // the console so we don't need to lock it.
    // also, we've freed the console handle, so no apis may access the console.
    //

    //
    // free screen buffers
    //

    for (Cur=Console->ScreenBuffers;Cur!=NULL;Cur=Next) {
        Next = Cur->Next;
        FreeScreenBuffer(Cur);
    }

    FreeAliasBuffers(Console);
    FreeCommandHistoryBuffers(Console);

    //
    // free input buffer
    //

    FreeInputBuffer(&Console->InputBuffer);
    ConsoleHeapFree(Console->Title);
    ConsoleHeapFree(Console->OriginalTitle);
    NtClose(Console->InitEvents[INITIALIZATION_SUCCEEDED]);
    NtClose(Console->InitEvents[INITIALIZATION_FAILED]);
    NtClose(Console->TerminationEvent);
    if (Console->hWinSta != NULL) {
        CloseDesktop(Console->hDesk);
        CloseWindowStation(Console->hWinSta);
    }
    if (Console->VDMProcessHandle)
        CloseHandle(Console->VDMProcessHandle);
    ASSERT(!(Console->Flags & CONSOLE_VDM_REGISTERED));
    /*if (Console->VDMBuffer != NULL) {
        NtUnmapViewOfSection(NtCurrentProcess(),Console->VDMBuffer);
        NtClose(Console->VDMBufferSectionHandle);
    }*/
#if defined(FE_SB)
    FreeLocalEUDC(Console);
    DestroyFontCache(Console->FontCacheInformation);
#endif
    DestroyConsole(Console);
}

VOID
VerticalScroll(
    IN PCONSOLE_INFORMATION Console,
    IN PSCREEN_INFORMATION ScreenInfo,
    IN WORD ScrollCommand,
    IN WORD AbsoluteChange
    )
{
    COORD NewOrigin;

    NewOrigin.X = ScreenInfo->Window.Left;
    NewOrigin.Y = ScreenInfo->Window.Top;
    switch (ScrollCommand) {
        case SB_LINEUP:
            NewOrigin.Y--;
            break;
        case SB_LINEDOWN:
            NewOrigin.Y++;
            break;
        case SB_PAGEUP:
#if defined(FE_IME)
// MSKK July.22.1993 KazuM
// Plan of bottom line reservation for console IME.
            if (ScreenInfo->Console->InputBuffer.ImeMode.Open) {
                ASSERT(ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER);
                if (!(ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER)) {
                    return;
                }
                NewOrigin.Y-=CONSOLE_WINDOW_SIZE_Y(ScreenInfo)-2;
                ScreenInfo->BufferInfo.TextInfo.Flags &= ~TEXT_VALID_HINT;
                ScreenInfo->BufferInfo.TextInfo.Flags |= CONSOLE_CONVERSION_AREA_REDRAW;
            }
            else
#endif // FE_IME
            NewOrigin.Y-=CONSOLE_WINDOW_SIZE_Y(ScreenInfo)-1;
            break;
        case SB_PAGEDOWN:
#if defined(FE_IME)
// MSKK July.22.1993 KazuM
// Plan of bottom line reservation for console IME.
            if ( ScreenInfo->Console->InputBuffer.ImeMode.Open )
            {
                NewOrigin.Y+=CONSOLE_WINDOW_SIZE_Y(ScreenInfo)-2;
                ScreenInfo->BufferInfo.TextInfo.Flags &= ~TEXT_VALID_HINT;
                ScreenInfo->BufferInfo.TextInfo.Flags |= CONSOLE_CONVERSION_AREA_REDRAW;
            }
            else
#endif // FE_IME
            NewOrigin.Y+=CONSOLE_WINDOW_SIZE_Y(ScreenInfo)-1;
            break;
        case SB_THUMBTRACK:
            Console->Flags |= CONSOLE_SCROLLBAR_TRACKING;
            NewOrigin.Y= AbsoluteChange;
            break;
        case SB_THUMBPOSITION:
            UnblockWriteConsole(Console, CONSOLE_SCROLLBAR_TRACKING);
            NewOrigin.Y= AbsoluteChange;
            break;
        case SB_TOP:
            NewOrigin.Y=0;
            break;
        case SB_BOTTOM:
            NewOrigin.Y=(WORD)(ScreenInfo->ScreenBufferSize.Y-CONSOLE_WINDOW_SIZE_Y(ScreenInfo));
            break;

        default:
            return;
    }

    NewOrigin.Y = (WORD)(max(0,min((SHORT)NewOrigin.Y,
                            (SHORT)ScreenInfo->ScreenBufferSize.Y-(SHORT)CONSOLE_WINDOW_SIZE_Y(ScreenInfo))));
    SetWindowOrigin(ScreenInfo,
                    (BOOLEAN)TRUE,
                    NewOrigin
                   );
}

VOID
HorizontalScroll(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN WORD ScrollCommand,
    IN WORD AbsoluteChange
    )
{
    COORD NewOrigin;

    NewOrigin.X = ScreenInfo->Window.Left;
    NewOrigin.Y = ScreenInfo->Window.Top;
    switch (ScrollCommand) {
        case SB_LINEUP:
            NewOrigin.X--;
            break;
        case SB_LINEDOWN:
            NewOrigin.X++;
            break;
        case SB_PAGEUP:
            NewOrigin.X-=CONSOLE_WINDOW_SIZE_X(ScreenInfo)-1;
            break;
        case SB_PAGEDOWN:
            NewOrigin.X+=CONSOLE_WINDOW_SIZE_X(ScreenInfo)-1;
            break;
        case SB_THUMBTRACK:
        case SB_THUMBPOSITION:
            NewOrigin.X= AbsoluteChange;
            break;
        case SB_TOP:
            NewOrigin.X=0;
            break;
        case SB_BOTTOM:
            NewOrigin.X=(WORD)(ScreenInfo->ScreenBufferSize.X-CONSOLE_WINDOW_SIZE_X(ScreenInfo));
            break;

        default:
            return;
    }

    NewOrigin.X = (WORD)(max(0,min((SHORT)NewOrigin.X,
                            (SHORT)ScreenInfo->ScreenBufferSize.X-(SHORT)CONSOLE_WINDOW_SIZE_X(ScreenInfo))));
    SetWindowOrigin(ScreenInfo,
                    (BOOLEAN)TRUE,
                    NewOrigin
                   );
}

LRESULT APIENTRY
ConsoleWindowProc(
    HWND hWnd,
    UINT Message,
    WPARAM wParam,
    LPARAM lParam)
{
    HDC hDC;
    PAINTSTRUCT ps;
    PCONSOLE_INFORMATION Console;
    PSCREEN_INFORMATION ScreenInfo;
    SMALL_RECT PaintRect;
    LRESULT Status = 0;

    Console = GetWindowConsole(hWnd);
    if (Console != NULL) {

        //
        // Set up our thread so we can impersonate the client
        // while processing the message.
        //

        CSR_SERVER_QUERYCLIENTTHREAD()->ThreadHandle =
                Console->ClientThreadHandle;

        //
        // If the console is terminating, don't bother processing messages
        // other than CM_DESTROY_WINDOW.
        //
        if (Console->Flags & CONSOLE_TERMINATING) {
            LockConsole(Console);
            DestroyWindowsWindow(Console);
            return 0;
        }

        //
        // Make sure the console pointer is still valid
        //
        ASSERT(NT_SUCCESS(ValidateConsole(Console)));

        LockConsole(Console);

        ScreenInfo = Console->CurrentScreenBuffer;
    }
    try {
        if (Console == NULL || ScreenInfo == NULL) {
            switch (Message) {
            case WM_GETMINMAXINFO:
                {
                //
                // createwindow issues a WM_GETMINMAXINFO
                // message before we have the windowlong set up
                // with the console pointer.  we need to allow
                // the created window to be bigger than the
                // default size by the scroll size.
                //

                LPMINMAXINFO lpmmi = (LPMINMAXINFO)lParam;
                lpmmi->ptMaxTrackSize.y += HorizontalScrollSize;
                lpmmi->ptMaxTrackSize.x += VerticalScrollSize;
                }
                break;

            default:
                goto CallDefWin;
            }
        } else if (Message == ProgmanHandleMessage && lParam == 0) {
            //
            // NOTE: lParam will be 0 if progman is sending it and
            // 1 if console is sending it. This is a workaround for
            // a progman bug. progman sends a progmanhandlemessage
            // twice for each window in the system each time one is
            // requested (for one window).
            //
            if ((HWND)wParam != hWnd && Console->bIconInit) {
                ATOM App,Topic;
                CHAR szItem[ITEM_MAX_SIZE+1];
                PCHAR lpItem;
                ATOM aItem;
                HANDLE ConsoleHandle;

                if (!(Console->Flags & CONSOLE_TERMINATING)) {
                    ConsoleHandle = Console->ConsoleHandle;
                    Console->hWndProgMan = (HWND)wParam;
                    UnlockConsole(Console);
                    App = GlobalAddAtomA("Shell");
                    Topic = GlobalAddAtomA("AppIcon");
                    SendMessage(Console->hWndProgMan,
                                WM_DDE_INITIATE,
                                (WPARAM)hWnd,
                                MAKELONG(App, Topic)
                               );

                    // If the console is still valid, continue getting icon.
                    Status = RevalidateConsole(ConsoleHandle, &Console);
                    if (NT_SUCCESS(Status)) {
                        Console->bIconInit = FALSE;
                        lpItem = _itoa((int)Console->iIconId, szItem, 10);
                        aItem = GlobalAddAtomA(lpItem);
                        PostMessage(Console->hWndProgMan,
                          WM_DDE_REQUEST,
                          (WPARAM)hWnd,
                          MAKELONG(CF_TEXT, aItem)
                         );
                    }
                }
            }
        } else {
            switch (Message) {
            case WM_DROPFILES:
                DoDrop (wParam,Console);
                break;
            case WM_MOVE:
                if (!IsIconic(hWnd)) {
                    PositionConsoleWindow(Console, (Console->WindowRect.left == CW_USEDEFAULT));
#if defined(FE_IME)
                    if (CONSOLE_IS_DBCS_OUTPUTCP(Console)) {
                        ConsoleImeResizeModeSystemView(Console,ScreenInfo->Window);
                        ConsoleImeResizeCompStrView(Console,ScreenInfo->Window);
                    }
#endif // FE_IME
                }
                break;
            case WM_SIZE:

                if (wParam != SIZE_MINIMIZED) {

                    //
                    // both SetWindowPos and SetScrollRange cause WM_SIZE
                    // messages to be issued.  ignore them if we have already
                    // figured out what size the window should be.
                    //

                    if (!ScreenInfo->ResizingWindow) {
                        ScreenInfo->WindowMaximized = (wParam == SIZE_MAXIMIZED);

                        if (Console->ResizeFlags & SCREEN_BUFFER_CHANGE) {
                            UpdateWindowSize(Console,ScreenInfo);
                        }
                        PositionConsoleWindow(Console, (Console->WindowRect.left == CW_USEDEFAULT));
#if defined(FE_IME)
                        if (CONSOLE_IS_DBCS_OUTPUTCP(Console)) {
                            ConsoleImeResizeModeSystemView(Console,ScreenInfo->Window);
                            ConsoleImeResizeCompStrView(Console,ScreenInfo->Window);
                        }
#endif // FE_IME
                        if (Console->ResizeFlags & SCROLL_BAR_CHANGE) {
                            InternalUpdateScrollBars(ScreenInfo);
                            Console->ResizeFlags &= ~SCROLL_BAR_CHANGE;
                        }
                    }
                } else {

                    //
                    // Console is going iconic. Trim working set of all
                    // processes in the console
                    //

                    TrimConsoleWorkingSet(Console);

                }

                break;
            case WM_DDE_ACK:
                if (Console->bIconInit) {
                    Console->hWndProgMan = (HWND)wParam;
                }
                break;
            case WM_DDE_DATA:
                {
                DDEDATA *lpDDEData;
                LPPMICONDATA lpIconData;
                HICON hIcon;
                HANDLE hDdeData;
                BOOL bRelease;
                WPARAM atomTemp;

                UnpackDDElParam(WM_DDE_DATA, lParam, (WPARAM *)&hDdeData, &atomTemp);

                if (hDdeData == NULL) {
                    break;
                }
                lpDDEData = (DDEDATA *)GlobalLock(hDdeData);
                ASSERT(lpDDEData->cfFormat == CF_TEXT);
                lpIconData = (LPPMICONDATA)lpDDEData->Value;
                hIcon = CreateIconFromResourceEx(&lpIconData->iResource,
                        0, TRUE, 0x30000, 0, 0, LR_DEFAULTSIZE);
                if (hIcon) {
                    if (Console->hIcon != NULL && Console->hIcon != ghDefaultIcon) {
                        DestroyIcon(Console->hIcon);
                    }
                    Console->hIcon = hIcon;
                    SendMessage(hWnd, WM_SETICON, ICON_BIG, (LPARAM)hIcon);

                    if (Console->hSmIcon != NULL) {
                        if (Console->hSmIcon != ghDefaultSmIcon) {
                            DestroyIcon(Console->hSmIcon);
                        }
                        Console->hSmIcon = NULL;
                        SendMessage(hWnd, WM_SETICON, ICON_SMALL, (LPARAM)NULL);
                    }
                }

                if (lpDDEData->fAckReq) {

                    PostMessage(Console->hWndProgMan,
                                WM_DDE_ACK,
                                (WPARAM)hWnd,
                                ReuseDDElParam(lParam, WM_DDE_DATA, WM_DDE_ACK, 0x8000, atomTemp));
                }

                bRelease = lpDDEData->fRelease;
                GlobalUnlock(hDdeData);
                if (bRelease){
                    GlobalFree(hDdeData);
                }
                PostMessage(Console->hWndProgMan,
                            WM_DDE_TERMINATE,
                            (WPARAM)hWnd,
                            0
                           );
                if (Console->Flags & CONSOLE_IS_ICONIC) {
                    // force repaint of icon
                    InvalidateRect(hWnd, NULL, TRUE);
                }
                }
                break;
            case WM_ACTIVATE:

                //
                // if we're activated by a mouse click, remember it so
                // we don't pass the click on to the app.
                //

                if (LOWORD(wParam) == WA_CLICKACTIVE) {
                    Console->Flags |= CONSOLE_IGNORE_NEXT_MOUSE_INPUT;
                }
                goto CallDefWin;
                break;
            case WM_DDE_TERMINATE:
                break;
                // FE_IME
            case CM_CONIME_KL_ACTIVATE:
                ActivateKeyboardLayout((HKL)wParam, KLF_SETFORPROCESS);
                break;
            case WM_INPUTLANGCHANGEREQUEST:
                if (CONSOLE_IS_IME_ENABLED()) {
                    ULONG ConimeMessage;
                    LRESULT lResult;

                    if (wParam & INPUTLANGCHANGE_BACKWARD) {
                        ConimeMessage = CONIME_INPUTLANGCHANGEREQUESTBACKWARD;
                    } else if (wParam & INPUTLANGCHANGE_FORWARD) {
                        ConimeMessage = CONIME_INPUTLANGCHANGEREQUESTFORWARD;
                    } else {
                        ConimeMessage = CONIME_INPUTLANGCHANGEREQUEST;
                    }

                    if (!NT_SUCCESS(ConsoleImeMessagePumpWorker(Console,
                                              ConimeMessage,
                                              (WPARAM)Console->ConsoleHandle,
                                              (LPARAM)lParam,
                                              &lResult)) ||
                            !lResult) {

                        break;
                    }
                }
#ifdef LATER
                else if (IS_IME_KBDLAYOUT(lParam)) {
                    // IME keyboard layout should be avoided
                    // if the console is not IME enabled.
                    break;
                }
                // Call the default window proc and let it handle
                // the keyboard layout activation.
#endif
                goto CallDefWin;

                break;
                // end FE_IME

            case WM_INPUTLANGCHANGE:
                Console->hklActive = (HKL)lParam;
                // FE_IME
                if (CONSOLE_IS_IME_ENABLED()) {
                    if (!NT_SUCCESS(ConsoleImeMessagePump(Console,
                                          CONIME_INPUTLANGCHANGE,
                                          (WPARAM)Console->ConsoleHandle,
                                          (LPARAM)Console->hklActive
                                         ))) {
                        break;
                    } else{
                        GetImeKeyState(Console, NULL) ;
                    }
                }
                // end FE_IME
                goto CallDefWin;

                break;

            case WM_SETFOCUS:
                ModifyConsoleProcessFocus(Console, TRUE);
                SetConsoleReserveKeys(hWnd, Console->ReserveKeys);
                Console->Flags |= CONSOLE_HAS_FOCUS;

                SetTimer(hWnd, CURSOR_TIMER, guCaretBlinkTime, NULL);
                HandleFocusEvent(Console,TRUE);
                if (!Console->hklActive) {
                    SystemParametersInfo(SPI_GETDEFAULTINPUTLANG, 0, &Console->hklActive, FALSE);
                    GetNonBiDiKeyboardLayout(&Console->hklActive);
                }
                ActivateKeyboardLayout(Console->hklActive, 0);
                // FE_IME
                if (CONSOLE_IS_IME_ENABLED()) {
                    // v-HirShi Sep.15.1995 Support Console IME
                    if (!NT_SUCCESS(ConsoleImeMessagePump(Console,
                                          CONIME_SETFOCUS,
                                          (WPARAM)Console->ConsoleHandle,
                                          (LPARAM)Console->hklActive
                                         ))) {
                        break;
                    }

                    if (Console->InputBuffer.hWndConsoleIME) {
                        /*
                         * Open property window by ImmConfigureIME.
                         * Never set focus on console window
                         * so, set focus to property window.
                         */
                        HWND hwnd = GetLastActivePopup(Console->InputBuffer.hWndConsoleIME);
                        if (hwnd != NULL)
                            SetForegroundWindow(hwnd);
                    }
                }
                // FE_IME
                break;
            case WM_KILLFOCUS:
                ModifyConsoleProcessFocus(Console, FALSE);
                SetConsoleReserveKeys(hWnd, CONSOLE_NOSHORTCUTKEY);
                Console->Flags &= ~CONSOLE_HAS_FOCUS;

                if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
                    ConsoleHideCursor(ScreenInfo);
                    ScreenInfo->BufferInfo.TextInfo.UpdatingScreen -= 1; // counteract HideCursor
                }
                KillTimer(hWnd, CURSOR_TIMER);
                HandleFocusEvent(Console,FALSE);

                // FE_IME
                if (CONSOLE_IS_IME_ENABLED()) {
                    // v-HirShi Sep.16.1995 Support Console IME
                    if (!NT_SUCCESS(ConsoleImeMessagePump(Console,
                                          CONIME_KILLFOCUS,
                                          (WPARAM)Console->ConsoleHandle,
                                          (LPARAM)NULL
                                         ))) {
                        break;
                    }
                }
                // end FE_IME
                break;
            case WM_PAINT:

                // ICONIC bit is not set if we're fullscreen and don't
                // have the hardware

                ConsoleHideCursor(ScreenInfo);
                hDC = BeginPaint(hWnd, &ps);
                if (Console->Flags & CONSOLE_IS_ICONIC ||
                    Console->FullScreenFlags == CONSOLE_FULLSCREEN) {
                    RECT rc;
                    UINT cxIcon, cyIcon;
                    GetClientRect(hWnd, &rc);
                    cxIcon = GetSystemMetrics(SM_CXICON);
                    cyIcon = GetSystemMetrics(SM_CYICON);

                    rc.left = (rc.right - cxIcon) >> 1;
                    rc.top = (rc.bottom - cyIcon) >> 1;

                    DrawIcon(hDC, rc.left, rc.top, Console->hIcon);
                } else {
                    if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
                        PaintRect.Left = (SHORT)((ps.rcPaint.left/SCR_FONTSIZE(ScreenInfo).X)+ScreenInfo->Window.Left);
                        PaintRect.Right = (SHORT)((ps.rcPaint.right/SCR_FONTSIZE(ScreenInfo).X)+ScreenInfo->Window.Left);
                        PaintRect.Top = (SHORT)((ps.rcPaint.top/SCR_FONTSIZE(ScreenInfo).Y)+ScreenInfo->Window.Top);
                        PaintRect.Bottom = (SHORT)((ps.rcPaint.bottom/SCR_FONTSIZE(ScreenInfo).Y)+ScreenInfo->Window.Top);
                    } else {
                        PaintRect.Left = (SHORT)(ps.rcPaint.left+ScreenInfo->Window.Left);
                        PaintRect.Right = (SHORT)(ps.rcPaint.right+ScreenInfo->Window.Left);
                        PaintRect.Top = (SHORT)(ps.rcPaint.top+ScreenInfo->Window.Top);
                        PaintRect.Bottom = (SHORT)(ps.rcPaint.bottom+ScreenInfo->Window.Top);
                    }
                    ScreenInfo->BufferInfo.TextInfo.Flags &= ~TEXT_VALID_HINT;
                    WriteToScreen(ScreenInfo,&PaintRect);
                }
                EndPaint(hWnd,&ps);
                ConsoleShowCursor(ScreenInfo);
                break;
            case WM_CLOSE:
                if (!(Console->Flags & CONSOLE_NO_WINDOW) ||
                    !(Console->Flags & CONSOLE_WOW_REGISTERED)) {
                    HandleCtrlEvent(Console,CTRL_CLOSE_EVENT);
                }
                break;
            case WM_ERASEBKGND:

                // ICONIC bit is not set if we're fullscreen and don't
                // have the hardware

                if (Console->Flags & CONSOLE_IS_ICONIC ||
                    Console->FullScreenFlags == CONSOLE_FULLSCREEN) {
                    Message = WM_ICONERASEBKGND;
                    goto CallDefWin;
                }
                break;
            case WM_SETTINGCHANGE:
                /*
                 * See if the caret blink time was changed. If so, reset the
                 * timer.
                 */
                if (wParam == SPI_SETKEYBOARDDELAY) {
                    guCaretBlinkTime = GetCaretBlinkTime();
                    if (Console->Flags & CONSOLE_HAS_FOCUS) {
                        KillTimer(hWnd, CURSOR_TIMER);
                        SetTimer(hWnd, CURSOR_TIMER, guCaretBlinkTime, NULL);
                    }
                } else {
                    gfInitSystemMetrics = TRUE;
                }
                break;
            case WM_DISPLAYCHANGE:
                gfInitSystemMetrics = TRUE;
                break;
            case WM_SETCURSOR:
                if (lParam == -1) {

                    //
                    // the app changed the cursor visibility or shape.
                    // see if the cursor is in the client area.
                    //

                    POINT Point;
                    HWND hWndTmp;
                    GetCursorPos(&Point);
                    hWndTmp = WindowFromPoint(Point);
                    if (hWndTmp == hWnd) {
                        lParam = DefWindowProc(hWnd,WM_NCHITTEST,0,MAKELONG((WORD)Point.x, (WORD)Point.y));
                    }
                }
                if ((WORD)lParam == HTCLIENT) {
                    if (ScreenInfo->CursorDisplayCount < 0) {
                        SetCursor(NULL);
                    } else {
                        SetCursor(ScreenInfo->CursorHandle);
                    }
                } else {
                    goto CallDefWin;
                }
                break;
            case WM_GETMINMAXINFO:
                {
                LPMINMAXINFO lpmmi = (LPMINMAXINFO)lParam;
                COORD FontSize;
                WINDOW_LIMITS WindowLimits;

                GetWindowLimits(ScreenInfo, &WindowLimits);
                if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
                    FontSize = SCR_FONTSIZE(ScreenInfo);
                } else {
                    FontSize.X = 1;
                    FontSize.Y = 1;
                }
                lpmmi->ptMaxSize.x = lpmmi->ptMaxTrackSize.x = WindowLimits.MaxWindow.X;
                if (!ScreenInfo->WindowMaximizedY) {
                    lpmmi->ptMaxTrackSize.x += VerticalScrollSize;
                    lpmmi->ptMaxSize.x += VerticalScrollSize;
                }
                while (lpmmi->ptMaxSize.x > WindowLimits.FullScreenSize.X + VerticalClientToWindow) {
                    lpmmi->ptMaxSize.x -= FontSize.X;
                }
                lpmmi->ptMaxSize.y = lpmmi->ptMaxTrackSize.y = WindowLimits.MaxWindow.Y;
                if (!ScreenInfo->WindowMaximizedX) {
                    lpmmi->ptMaxTrackSize.y += HorizontalScrollSize;
                    lpmmi->ptMaxSize.y += HorizontalScrollSize;
                }
                while (lpmmi->ptMaxSize.y > WindowLimits.FullScreenSize.Y + HorizontalClientToWindow) {
                    lpmmi->ptMaxSize.y -= FontSize.Y;
                }
                lpmmi->ptMinTrackSize.x = WindowLimits.MinimumWindowSize.X * FontSize.X + VerticalClientToWindow;
                lpmmi->ptMinTrackSize.y = HorizontalClientToWindow;
                }
                break;
            case WM_QUERYDRAGICON:
                Status = (LRESULT)Console->hIcon;
                break;
            case WM_WINDOWPOSCHANGING:
                {
                    LPWINDOWPOS WindowPos = (LPWINDOWPOS)lParam;
                    DWORD fMinimized;

                    /*
                     * This message is sent before a SetWindowPos() operation
                     * occurs. We use it here to set/clear the CONSOLE_IS_ICONIC
                     * bit appropriately... doing so in the WM_SIZE handler
                     * is incorrect because the WM_SIZE comes after the
                     * WM_ERASEBKGND during SetWindowPos() processing, and the
                     * WM_ERASEBKGND needs to know if the console window is
                     * iconic or not.
                     */
                    fMinimized = IsIconic(hWnd);
                    if (fMinimized) {
                        if (!(Console->Flags & CONSOLE_IS_ICONIC)) {
                            Console->Flags |= CONSOLE_IS_ICONIC;

                            //
                            // If the palette is something other than default,
                            // select the default palette in. Otherwise, the
                            // screen will repaint twice each time the icon
                            // is painted.
                            //

                            if (ScreenInfo->hPalette != NULL &&
                                Console->FullScreenFlags == 0) {
                                SelectPalette(Console->hDC,
                                              Console->hSysPalette,
                                              FALSE);
                                UnsetActivePalette(ScreenInfo);
                            }
                        }
                    } else {
                        if (Console->Flags & CONSOLE_IS_ICONIC) {
                            Console->Flags &= ~CONSOLE_IS_ICONIC;

                            //
                            // If the palette is something other than default,
                            // select the default palette in. Otherwise, the
                            // screen will repaint twice each time the icon
                            // is painted.
                            //

                            if (ScreenInfo->hPalette != NULL &&
                                Console->FullScreenFlags == 0) {
                                SelectPalette(Console->hDC,
                                              ScreenInfo->hPalette,
                                              FALSE);
                                SetActivePalette(ScreenInfo);
                            }
                        }
                    }
                    if (!ScreenInfo->ResizingWindow &&
                        (WindowPos->cx || WindowPos->cy) &&
                        !fMinimized) {
                        ProcessResizeWindow(ScreenInfo,Console,WindowPos);
                    }
                }
                break;
            case WM_CONTEXTMENU:
                if (DefWindowProc(hWnd, WM_NCHITTEST, 0, lParam) == HTCLIENT) {
                    TrackPopupMenuEx(Console->hHeirMenu,
                                     TPM_RIGHTBUTTON,
                                     GET_X_LPARAM(lParam),
                                     GET_Y_LPARAM(lParam),
                                     hWnd,
                                     NULL);
                } else {
                    goto CallDefWin;
                }
                break;
            case WM_NCLBUTTONDOWN:
                // allow user to move window even when bigger than the screen
                switch (wParam & 0x00FF) {
                    case HTCAPTION:
                        UnlockConsole(Console);
                        Console = NULL;
                        SetActiveWindow(hWnd);
                        SendMessage(hWnd, WM_SYSCOMMAND,
                                       SC_MOVE | wParam, lParam);
                        break;
                    default:
                        goto CallDefWin;
                }
                break;
#if defined (FE_IME)
// Sep.16.1995 Support Console IME
            case WM_KEYDOWN    +CONIME_KEYDATA:
            case WM_KEYUP      +CONIME_KEYDATA:
            case WM_CHAR       +CONIME_KEYDATA:
            case WM_DEADCHAR   +CONIME_KEYDATA:

            case WM_SYSKEYDOWN +CONIME_KEYDATA:
            case WM_SYSKEYUP   +CONIME_KEYDATA:
            case WM_SYSCHAR    +CONIME_KEYDATA:
            case WM_SYSDEADCHAR+CONIME_KEYDATA:
#endif
            case WM_KEYDOWN:
            case WM_KEYUP:
            case WM_CHAR:
            case WM_DEADCHAR:
                HandleKeyEvent(Console,hWnd,Message,wParam,lParam);
                break;
            case WM_SYSKEYDOWN:
            case WM_SYSKEYUP:
            case WM_SYSCHAR:
            case WM_SYSDEADCHAR:
                if (HandleSysKeyEvent(Console,hWnd,Message,wParam,lParam) && Console != NULL) {
                    goto CallDefWin;
                }
                break;
            case WM_COMMAND:
                //
                // If this is an edit command from the context menu, treat
                // it like a sys command.
                //
                if ((wParam < cmCopy) || (wParam > cmSelectAll)) {
                    break;
                }
                // FALL THRU
            case WM_SYSCOMMAND:
                if (wParam >= ScreenInfo->CommandIdLow &&
                    wParam <= ScreenInfo->CommandIdHigh) {
                    HandleMenuEvent(Console, (DWORD)wParam);
                } else if (wParam == cmMark) {
                    DoMark(Console);
                } else if (wParam == cmCopy) {
                    DoCopy(Console);
                } else if (wParam == cmPaste) {
                    DoPaste(Console);
                } else if (wParam == cmScroll) {
                    DoScroll(Console);
                } else if (wParam == cmFind) {
                    DoFind(Console);
                } else if (wParam == cmSelectAll) {
                    DoSelectAll(Console);
                } else if (wParam == cmControl) {
                    PropertiesDlgShow(Console, TRUE);
                } else if (wParam == cmDefaults) {
                    PropertiesDlgShow(Console, FALSE);
                } else if ((wParam == SC_RESTORE || wParam == SC_MAXIMIZE) &&
                           Console->Flags & CONSOLE_VDM_HIDDEN_WINDOW) {
                    Console->Flags &= ~CONSOLE_VDM_HIDDEN_WINDOW;
                    SendMessage(Console->hWnd, CM_MODE_TRANSITION, FULLSCREEN, 0L);
                } else {
                    goto CallDefWin;
                }
                break;
            case WM_TIMER:
#if defined(FE_IME)
                if (wParam == SCROLL_WAIT_TIMER) {
                    ASSERT(CONSOLE_IS_IME_ENABLED());
                    if ((ScreenInfo->Console->ConsoleIme.ScrollFlag & (HIDE_FOR_SCROLL)) &&
                        (ScreenInfo->Console->ConsoleIme.ScrollWaitCountDown > 0)
                       ) {
                        if ((ScreenInfo->Console->ConsoleIme.ScrollWaitCountDown -= guCaretBlinkTime) <= 0) {
                            ConsoleImeBottomLineInUse(ScreenInfo);
                        }
                    }
                    break;
                }
#endif // FE_IME
                CursorTimerRoutine(ScreenInfo);
                ScrollIfNecessary(Console, ScreenInfo);
                break;
            case WM_HSCROLL:
                HorizontalScroll(ScreenInfo, LOWORD(wParam), HIWORD(wParam));
                break;
            case WM_VSCROLL:
                VerticalScroll(Console, ScreenInfo, LOWORD(wParam), HIWORD(wParam));
                break;
            case WM_INITMENU:
                HandleMenuEvent(Console, WM_INITMENU);
                InitializeMenu(Console);
                break;
            case WM_MENUSELECT:
                if (HIWORD(wParam) == 0xffff) {
                    HandleMenuEvent(Console, WM_MENUSELECT);
                }
                break;
            case WM_MOUSEMOVE:
            case WM_LBUTTONDOWN:
            case WM_LBUTTONUP:
            case WM_LBUTTONDBLCLK:
            case WM_RBUTTONDOWN:
            case WM_RBUTTONUP:
            case WM_RBUTTONDBLCLK:
            case WM_MBUTTONDOWN:
            case WM_MBUTTONUP:
            case WM_MBUTTONDBLCLK:
            case WM_MOUSEWHEEL:
                if (HandleMouseEvent(Console, ScreenInfo, Message, wParam, lParam)) {
                    if (Message != WM_MOUSEWHEEL) {
                        goto CallDefWin;
                    }
                } else {
                    break;
                }

                /*
                 * Don't handle zoom.
                 */
                if (wParam & MK_CONTROL) {
                    goto CallDefWin;
                }

                Status = 1;
                if (gfInitSystemMetrics) {
                    InitializeSystemMetrics();
                }

                ScreenInfo->WheelDelta -= (short)HIWORD(wParam);
                if (abs(ScreenInfo->WheelDelta) >= WHEEL_DELTA &&
                        gucWheelScrollLines > 0) {

                    COORD   NewOrigin;
                    SHORT   dy;

                    NewOrigin.X = ScreenInfo->Window.Left;
                    NewOrigin.Y = ScreenInfo->Window.Top;

                    /*
                     * Limit a roll of one (1) WHEEL_DELTA to scroll one (1)
                     * page. If in shift scroll mode then scroll one page at
                     * a time regardless.
                     */

                    if (!(wParam & MK_SHIFT)) {
                        dy = (int) min(
                                (UINT) CONSOLE_WINDOW_SIZE_Y(ScreenInfo) - 1,
                                gucWheelScrollLines);
                    } else {
                        dy = CONSOLE_WINDOW_SIZE_Y(ScreenInfo) - 1;
                    }

                    if (dy == 0) {
                        dy++;
                    }

                    dy *= (ScreenInfo->WheelDelta / WHEEL_DELTA);
                    ScreenInfo->WheelDelta %= WHEEL_DELTA;

                    NewOrigin.Y += dy;
                    if (NewOrigin.Y < 0) {
                        NewOrigin.Y = 0;
                    } else if (NewOrigin.Y + CONSOLE_WINDOW_SIZE_Y(ScreenInfo) >
                            ScreenInfo->ScreenBufferSize.Y) {
                        NewOrigin.Y = ScreenInfo->ScreenBufferSize.Y -
                                CONSOLE_WINDOW_SIZE_Y(ScreenInfo);
                    }

                    SetWindowOrigin(ScreenInfo, TRUE, NewOrigin);
                }
                break;

            case WM_PALETTECHANGED:
                if (Console->FullScreenFlags == 0) {
                    if (ScreenInfo->hPalette != NULL) {
                        SetActivePalette(ScreenInfo);
                        if (ScreenInfo->Flags & CONSOLE_GRAPHICS_BUFFER) {
                            WriteRegionToScreenBitMap(ScreenInfo,
                                                      &ScreenInfo->Window);
                        }
                    } else {
                        SetScreenColors(ScreenInfo, ScreenInfo->Attributes,
                                        ScreenInfo->PopupAttributes, TRUE);
                    }
                }
                break;
#if defined(_X86_)
            case WM_FULLSCREEN:

                //
                // This message is sent by the system to tell console that
                // the fullscreen state of a window has changed.
                // In some cases, this message will be sent in response to
                // a call from console to change to fullscreen (Atl-Enter)
                // or may also come directly from the system (switch of
                // focus from a windowed app to a fullscreen app).
                //

                KdPrint(("CONSRV: WindowProc - WM_FULLSCREEN\n"));

                Status = DisplayModeTransition(wParam,Console,ScreenInfo);
#if defined(FE_IME)
                if (NT_SUCCESS(Status)) {
                    Status = ImeWmFullScreen(wParam,Console,ScreenInfo);
                }
#endif // FE_IME
                break;
#endif
            case CM_SET_WINDOW_SIZE:
                if (lParam == 0x47474747) {
                    Status = InternalSetWindowSize(Console,
                                                   (PSCREEN_INFORMATION)wParam,
                                                   &ScreenInfo->Window
                                                   );
                }
                break;
            case CM_BEEP:
                if (lParam == 0x47474747) {
                    Beep(800, 200);
                }
                break;
            case CM_UPDATE_SCROLL_BARS:
                InternalUpdateScrollBars(ScreenInfo);
                break;
            case CM_UPDATE_TITLE:
                SetWindowText(hWnd, Console->Title);
                break;
            case CM_CONSOLE_MSG:
                if (!UnqueueConsoleMessage(Console, &Message, &wParam, &lParam)) {
                    break;
                }
                switch (Message) {

#if defined(_X86_)
                case CM_MODE_TRANSITION:

                    KdPrint(("CONSRV: WindowProc - CM_MODE_TRANSITION\n"));

                    if (wParam == FULLSCREEN) {
                        if (Console->FullScreenFlags == 0) {
                            ConvertToFullScreen(Console);
                            Console->FullScreenFlags |= CONSOLE_FULLSCREEN;
                            ChangeDispSettings(Console, hWnd, CDS_FULLSCREEN);
                        }
                    } else {
                        if (Console->FullScreenFlags & CONSOLE_FULLSCREEN) {
                            ConvertToWindowed(Console);
                            Console->FullScreenFlags &= ~CONSOLE_FULLSCREEN;
                            ChangeDispSettings(Console, hWnd, 0);

                            ShowWindow(hWnd, SW_RESTORE);
                        }
                    }

                    UnlockConsole(Console);
                    Console = NULL;

                    NtSetEvent((HANDLE)lParam, NULL);
                    NtClose((HANDLE)lParam);
                    break;
#endif
#if defined (FE_IME)
                case CM_SET_IME_CODEPAGE: {
                    if (!LOWORD(lParam)) {
                        // Input code page
                        Status = SetImeCodePage(Console);
                    } else {
                        // Output code page
                        Status = SetImeOutputCodePage(Console, ScreenInfo, HIWORD(lParam));
                    }

                    if (wParam) {
                        NtSetEvent((HANDLE)wParam, NULL);
                        NtClose((HANDLE)wParam);
                    }
                    break;
                }
                case CM_SET_NLSMODE:
                    Status = SetImeKeyState(Console, ImmConversionFromConsole((DWORD)lParam));
                    if (wParam) {
                        NtSetEvent((HANDLE)wParam, NULL);
                        NtClose((HANDLE)wParam);
                    }
                    break;
                case CM_GET_NLSMODE:
                    if (Console->InputThreadInfo->hWndConsoleIME) {
                        ASSERT(CONSOLE_IS_IME_ENABLED());

                        if (!NT_SUCCESS(GetImeKeyState(Console, NULL))) {
                            if (wParam) {
                                NtSetEvent((HANDLE)wParam, NULL);
                                NtClose((HANDLE)wParam);
                            }
                            break;
                        }
                        if (wParam) {
                            NtSetEvent((HANDLE)wParam, NULL);
                            NtClose((HANDLE)wParam);
                        }
                    } else if (lParam < 10) {
                        /*
                         * try get conversion mode until ready ConIME.
                         */
                        Status = QueueConsoleMessage(Console,
                                    CM_GET_NLSMODE,
                                    wParam,
                                    lParam+1
                                   );
                        if (!NT_SUCCESS(Status)) {
                            if (wParam) {
                                NtSetEvent((HANDLE)wParam, NULL);
                                NtClose((HANDLE)wParam);
                            }
                        }
                    } else {
                        if (wParam) {
                            NtSetEvent((HANDLE)wParam, NULL);
                            NtClose((HANDLE)wParam);
                        }
                    }
                    break;
#endif // FE_IME
                case EVENT_CONSOLE_CARET:
                case EVENT_CONSOLE_UPDATE_REGION:
                case EVENT_CONSOLE_UPDATE_SIMPLE:
                case EVENT_CONSOLE_UPDATE_SCROLL:
                case EVENT_CONSOLE_LAYOUT:
                case EVENT_CONSOLE_START_APPLICATION:
                case EVENT_CONSOLE_END_APPLICATION:
                    NotifyWinEvent(Message, hWnd, (LONG)wParam, (LONG)lParam);
                    break;
                default:
                    RIPMSG1(RIP_WARNING, "Unknown console message 0x%x", Message);
                    break;
                }
                break;

#if defined(_X86_)
            case CM_MODE_TRANSITION:
                /*
                 * This is called by win32k.sys to request a display mode
                 * transition.
                 */


                KdPrint(("CONSRV: WindowProc - CM_MODE_TRANSITION\n"));
                if (wParam == FULLSCREEN) {
                    if (Console->FullScreenFlags == 0) {
                        ConvertToFullScreen(Console);
                        Console->FullScreenFlags |= CONSOLE_FULLSCREEN;
                        ChangeDispSettings(Console, hWnd, CDS_FULLSCREEN);
                    }
                } else {
                    if (Console->FullScreenFlags & CONSOLE_FULLSCREEN) {
                        ConvertToWindowed(Console);
                        Console->FullScreenFlags &= ~CONSOLE_FULLSCREEN;
                        ChangeDispSettings(Console, hWnd, 0);

                        ShowWindow(hWnd, SW_RESTORE);
                    }
                }

                UnlockConsole(Console);
                Console = NULL;

                break;
#endif // _X86_

            case CM_HIDE_WINDOW:
                ShowWindowAsync(hWnd, SW_MINIMIZE);
                break;
            case CM_PROPERTIES_START:
                Console->hWndProperties = (HWND)wParam;
                break;
            case CM_PROPERTIES_UPDATE:
                PropertiesUpdate(Console, (HANDLE)wParam);
                break;
            case CM_PROPERTIES_END:
                Console->hWndProperties = NULL;
                break;
#if defined(FE_IME)
            case WM_COPYDATA:
                if (CONSOLE_IS_IME_ENABLED() && CONSOLE_IS_DBCS_OUTPUTCP(Console)) {
                    Status = ImeControl(Console,(HWND)wParam,(PCOPYDATASTRUCT)lParam);
                }
                break;
// v-HirShi Sep.18.1995 Support Console IME
            case WM_ENTERMENULOOP:
                if (Console->Flags & CONSOLE_HAS_FOCUS) {
                    Console->InputBuffer.ImeMode.Unavailable = TRUE;
                    if (CONSOLE_IS_IME_ENABLED()) {
                        if (!NT_SUCCESS(ConsoleImeMessagePump(Console,
                                              CONIME_KILLFOCUS,
                                              (WPARAM)Console->ConsoleHandle,
                                              (LPARAM)NULL
                                             ))) {
                            break;
                        }
                    }
                }
                break;

            case WM_EXITMENULOOP:
                if (Console->Flags & CONSOLE_HAS_FOCUS) {
                    if (CONSOLE_IS_IME_ENABLED()) {
                        if (!NT_SUCCESS(ConsoleImeMessagePump(Console,
                                              CONIME_SETFOCUS,
                                              (WPARAM)Console->ConsoleHandle,
                                              (LPARAM)Console->hklActive
                                             ))) {
                            break;
                        }
                    }
                    Console->InputBuffer.ImeMode.Unavailable = FALSE;
                }
                break;

            case WM_ENTERSIZEMOVE:
                if (Console->Flags & CONSOLE_HAS_FOCUS) {
                    Console->InputBuffer.ImeMode.Unavailable = TRUE;
                }
                break;

            case WM_EXITSIZEMOVE:
                if (Console->Flags & CONSOLE_HAS_FOCUS) {
                    Console->InputBuffer.ImeMode.Unavailable = FALSE;
                }
                break;
#endif // FE_IME

CallDefWin:
            default:
                if (Console != NULL) {
                    UnlockConsole(Console);
                    Console = NULL;
                }
                Status = DefWindowProc(hWnd,Message,wParam,lParam);
                break;
            }
        }
    } finally {
        if (Console != NULL) {
            UnlockConsole(Console);
            Console = NULL;
        }
    }

    return Status;
}


/*
* Drag and Drop support functions for console window
*/

/*++

Routine Description:

    This routine retrieves the filenames of dropped files. It was copied from
    shelldll API DragQueryFile. We didn't use DragQueryFile () because we don't
    want to load Shell32.dll in CSR

Arguments:
    Same as DragQueryFile

Return Value:


--*/
UINT ConsoleDragQueryFile(
    IN HANDLE hDrop,
    IN PVOID lpFile,
    IN UINT cb)
{
    UINT i = 0;
    LPDROPFILESTRUCT lpdfs;
    BOOL fWide;

    lpdfs = (LPDROPFILESTRUCT)GlobalLock(hDrop);

    if (lpdfs && lpdfs != hDrop) {
        try {
            fWide = (LOWORD(lpdfs->pFiles) == sizeof(DROPFILES));
            if (fWide) {
                //
                // This is a new (NT-compatible) HDROP
                //
                fWide = lpdfs->fWide;       // Redetermine fWide from struct
                                            // since it is present.
            }

            if (fWide) {
                LPWSTR lpList;

                //
                // UNICODE HDROP
                //

                lpList = (LPWSTR)((LPBYTE)lpdfs + lpdfs->pFiles);

                i = lstrlenW(lpList);

                if (!i)
                    goto Exit;

                cb--;
                if (cb < i)
                    i = cb;

                lstrcpynW((LPWSTR)lpFile, lpList, i + 1);
            } else {
                LPSTR lpList;

                //
                // This is Win31-style HDROP or an ANSI NT Style HDROP
                //
                lpList = (LPSTR)((LPBYTE)lpdfs + lpdfs->pFiles);

                i = lstrlenA(lpList);

                if (!i) {
                    goto Exit;
                }

                cb--;
                if (cb < i) {
                    i = cb;
                }

                MultiByteToWideChar(CP_ACP, 0, lpList, -1, (LPWSTR)lpFile, cb);

            }
        } except( EXCEPTION_EXECUTE_HANDLER ) {
           RIPMSG1(RIP_WARNING, "CONSRV: WM_DROPFILES raised exception 0x%x", GetExceptionCode());
           i = 0;
        }
Exit:
        GlobalUnlock(hDrop);
        GlobalFree(hDrop);
    }

    return i;
}


/*++

Routine Description:

    This routine is called when ConsoleWindowProc receives a WM_DROPFILES
    message. It initially calls ConsoleDragQueryFile() to calculate the number
    of files dropped and then ConsoleDragQueryFile() is called
    to retrieve the filename. DoStringPaste() pastes the filename to the console
    window

Arguments:
    wParam  -   Identifies the structure containing the filenames of the
                dropped files.
    Console -   Pointer to CONSOLE_INFORMATION structure


Return Value:
    None


--*/
VOID
DoDrop(
    WPARAM wParam,
    PCONSOLE_INFORMATION Console)
{
    WCHAR szPath[MAX_PATH];
    BOOL fAddQuotes;

    if (ConsoleDragQueryFile((HANDLE)wParam, szPath, CharSizeOf(szPath))) {
        fAddQuotes = (wcschr(szPath, L' ') != NULL);
        if (fAddQuotes) {
            DoStringPaste(Console, L"\"", 1);
        }
        DoStringPaste(Console, szPath, wcslen(szPath));
        if (fAddQuotes) {
            DoStringPaste(Console, L"\"", 1);
        }
    }
}

BOOL
CreateDbcsScreenBuffer(
    IN PCONSOLE_INFORMATION Console,
    IN COORD dwScreenBufferSize,
    OUT PDBCS_SCREEN_BUFFER DbcsScreenBuffer)
{
    if (CONSOLE_IS_DBCS_OUTPUTCP(Console)) {
        DbcsScreenBuffer->TransBufferCharacter =
            (PWCHAR)ConsoleHeapAlloc(
                              MAKE_TAG( SCREEN_DBCS_TAG ),
                              (dwScreenBufferSize.X*dwScreenBufferSize.Y*sizeof(WCHAR))+sizeof(WCHAR));
        if (DbcsScreenBuffer->TransBufferCharacter == NULL) {
            return FALSE;
        }

        DbcsScreenBuffer->TransBufferAttribute =
            (PBYTE)ConsoleHeapAlloc(
                             MAKE_TAG( SCREEN_DBCS_TAG ),
                             (dwScreenBufferSize.X*dwScreenBufferSize.Y*sizeof(BYTE))+sizeof(BYTE));
        if (DbcsScreenBuffer->TransBufferAttribute == NULL) {
            ConsoleHeapFree(DbcsScreenBuffer->TransBufferCharacter);
            return FALSE;
        }

        DbcsScreenBuffer->TransWriteConsole =
            (PWCHAR)ConsoleHeapAlloc(
                              MAKE_TAG( SCREEN_DBCS_TAG ),
                              (dwScreenBufferSize.X*dwScreenBufferSize.Y*sizeof(WCHAR))+sizeof(WCHAR));
        if (DbcsScreenBuffer->TransWriteConsole == NULL) {
            ConsoleHeapFree(DbcsScreenBuffer->TransBufferAttribute);
            ConsoleHeapFree(DbcsScreenBuffer->TransBufferCharacter);
            return FALSE;
        }

        DbcsScreenBuffer->KAttrRows =
            (PBYTE)ConsoleHeapAlloc(
                             MAKE_TAG( SCREEN_DBCS_TAG ),
                             dwScreenBufferSize.X*dwScreenBufferSize.Y*sizeof(BYTE));
        if (DbcsScreenBuffer->KAttrRows == NULL) {
            ConsoleHeapFree(DbcsScreenBuffer->TransWriteConsole);
            ConsoleHeapFree(DbcsScreenBuffer->TransBufferAttribute);
            ConsoleHeapFree(DbcsScreenBuffer->TransBufferCharacter);
            return FALSE;
        }
    }
    else {
        DbcsScreenBuffer->TransBufferCharacter = NULL;
        DbcsScreenBuffer->TransBufferAttribute = NULL;
        DbcsScreenBuffer->TransWriteConsole = NULL;
        DbcsScreenBuffer->KAttrRows = NULL;
    }

    return TRUE;
}

BOOL
DeleteDbcsScreenBuffer(
    IN PDBCS_SCREEN_BUFFER DbcsScreenBuffer
    )
{
    if (DbcsScreenBuffer->KAttrRows) {
        ConsoleHeapFree(DbcsScreenBuffer->TransBufferCharacter);
        ConsoleHeapFree(DbcsScreenBuffer->TransBufferAttribute);
        ConsoleHeapFree(DbcsScreenBuffer->TransWriteConsole);
        ConsoleHeapFree(DbcsScreenBuffer->KAttrRows);
    }
    return TRUE;
}

BOOL
ReCreateDbcsScreenBufferWorker(
    IN PCONSOLE_INFORMATION Console,
    IN PSCREEN_INFORMATION ScreenInfo
    )
{
    SHORT i;
    PBYTE KAttrRowPtr;
    COORD dwScreenBufferSize;
    DBCS_SCREEN_BUFFER NewDbcsScreenBuffer;

    ASSERT(ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER);
    if (!(ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER)) {
        return FALSE;
    }

    dwScreenBufferSize = ScreenInfo->ScreenBufferSize;

    if (!CreateDbcsScreenBuffer(Console,
            dwScreenBufferSize,
            &NewDbcsScreenBuffer)) {
        return FALSE;
    }

    KAttrRowPtr = NewDbcsScreenBuffer.KAttrRows;
    for (i = 0; i < dwScreenBufferSize.Y; i++) {
        ScreenInfo->BufferInfo.TextInfo.Rows[i].CharRow.KAttrs = KAttrRowPtr;
        if (KAttrRowPtr) {
            RtlZeroMemory(KAttrRowPtr, dwScreenBufferSize.X);
            KAttrRowPtr += dwScreenBufferSize.X;
        }
    }
    ScreenInfo->BufferInfo.TextInfo.DbcsScreenBuffer = NewDbcsScreenBuffer;

    return TRUE;
}


typedef struct _DBCS_SCREEN_BUFFER_TRACKER {
    DBCS_SCREEN_BUFFER data;
#if DBG
    PSCREEN_INFORMATION pScreenInfo;
#endif
} DBCS_SCREEN_BUFFER_TRACKER, *PDBCS_SCREEN_BUFFER_TRACKER;

BOOL
ReCreateDbcsScreenBuffer(
    IN PCONSOLE_INFORMATION pConsole,
    IN UINT OldCodePage)
{
    BOOL fResult = FALSE;
    PDBCS_SCREEN_BUFFER_TRACKER pDbcsScreenBuffer;
    PSCREEN_INFORMATION pScreenInfo;
    UINT nScreen;
    UINT i;
#if DBG
    UINT nScreenSave;
#endif

    //
    // If DbcsBuffers don't need to be modified, just bail out.
    //
    if (!IsAvailableFarEastCodePage(OldCodePage) == !CONSOLE_IS_DBCS_OUTPUTCP(pConsole) )
        return TRUE;

    //
    // Count the number of screens allocated.
    //
    for (nScreen = 0, pScreenInfo = pConsole->ScreenBuffers; pScreenInfo; pScreenInfo = pScreenInfo->Next) {
        //
        // Ignore graphic mode buffer.
        //
        if (pScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
            ++nScreen;
        }
    }
#if DBG
    nScreenSave = nScreen;
#endif

    //
    // Allocate the temporary buffer to store the old values
    //
    pDbcsScreenBuffer = ConsoleHeapAlloc(MAKE_TAG(TMP_DBCS_TAG), sizeof *pDbcsScreenBuffer * nScreen);
    if (pDbcsScreenBuffer == NULL) {
        RIPMSG0(RIP_WARNING, "ReCreateDbcsScreenBuffer: not enough memory.");
        return FALSE;
    }

    //
    // Try to allocate or de-allocate the necessary DBCS buffers
    //
    for (nScreen = 0, pScreenInfo = pConsole->ScreenBuffers; pScreenInfo; pScreenInfo = pScreenInfo->Next) {
        ASSERT(nScreen < nScreenSave);  // make sure ScreenBuffers are not changed

        //
        // We only handle the text mode screen buffer.
        //
        if (pScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
            //
            // Save the previous value just in case something goes bad.
            //
#if DBG
            pDbcsScreenBuffer[nScreen].pScreenInfo = pScreenInfo;
#endif
            pDbcsScreenBuffer[nScreen++].data = pScreenInfo->BufferInfo.TextInfo.DbcsScreenBuffer;

            if (!ReCreateDbcsScreenBufferWorker(pConsole, pScreenInfo)) {
                //
                // If we fail to ReCreate the DbcsScreenBuffer,
                // free all allocation to this point, and restore the orginal.
                //
                RIPMSG0(RIP_WARNING, "ReCreateDbcsScreenBuffer: failed to recreate dbcs screen buffer.");

                for (i = 0, pScreenInfo = pConsole->ScreenBuffers; i < nScreen;  pScreenInfo = pScreenInfo->Next) {
                    ASSERT(pScreenInfo);

                    if (pScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
                        ASSERT(pDbcsScreenBuffer[i].pScreenInfo == pScreenInfo);
                        if (i < nScreen - 1) {
                            ASSERT(pScreenInfo->BufferInfo.TextInfo.DbcsScreenBuffer.KAttrRows != pDbcsScreenBuffer[i].data.KAttrRows);
                            DeleteDbcsScreenBuffer(&pScreenInfo->BufferInfo.TextInfo.DbcsScreenBuffer);
                        }

                        pScreenInfo->BufferInfo.TextInfo.DbcsScreenBuffer = pDbcsScreenBuffer[i++].data;
                    }
                }
                goto exit;
            }
        }
    }

    //
    // All allocation succeeded. Now we can delete the old allocation.
    //
    for (i = 0; i < nScreen; ++i) {
        DeleteDbcsScreenBuffer(&pDbcsScreenBuffer[i].data);
    }

    fResult = TRUE;

exit:
    ConsoleHeapFree(pDbcsScreenBuffer);

    return fResult;
}

// Checks if the primary language of this keyborad layout is BiDi or not.
BOOL
IsNotBiDILayout(
    HKL hkl)
{
    BOOL bRet = TRUE;
    LANGID LangID = PRIMARYLANGID(HandleToUlong(hkl));

    if (LangID == LANG_ARABIC || LangID == LANG_HEBREW) {
        bRet = FALSE;
    }

    return bRet;
}

VOID
GetNonBiDiKeyboardLayout(
    HKL *phklActive)
{
    HKL hkl = *phklActive;
    HKL hklActive = *phklActive;

    if (IsNotBiDILayout(hkl)) {
        return;
    }

    // Start with the default one.
    ActivateKeyboardLayout(hkl, 0);
    // We know that the default is not good, activate the next.
    ActivateKeyboardLayout((HKL)HKL_NEXT, 0);

    // Loop until you find a none BiDi one or endof list.
    while (hkl = GetKeyboardLayout(0)) {
        if ((hkl == hklActive) || IsNotBiDILayout(hkl)) {
            *phklActive = hkl;
            break;
        }
        ActivateKeyboardLayout((HKL)HKL_NEXT, 0);
    }
}

#if defined(FE_SB)

#define WWSB_NOFE
#include "_output.h"
#undef  WWSB_NOFE
#define WWSB_FE
#include "_output.h"
#undef  WWSB_FE

#endif  // FE_SB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\server\resize.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    resize.c

Abstract:

        This file implements window resizing.

Author:

    Therese Stowell (thereses) 6-Oct-1991

Revision History:

Notes:

--*/

#include "precomp.h"
#pragma hdrstop


VOID
CalculateNewSize(
    IN PBOOLEAN MaximizedX,
    IN PBOOLEAN MaximizedY,
    IN OUT PSHORT DeltaX,
    IN OUT PSHORT DeltaY,
    IN SHORT WindowSizeX,
    IN SHORT WindowSizeY,
    IN COORD ScreenBufferSize,
    IN COORD FontSize
    );

VOID
ProcessResizeWindow(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PCONSOLE_INFORMATION Console,
    IN LPWINDOWPOS WindowPos
    )
{
    SHORT DeltaX,DeltaY;
    SHORT PixelDeltaX,PixelDeltaY;
    DWORD Flags=0;
    COORD FontSize;

#ifdef THERESES_DEBUG
DbgPrint("WM_WINDOWPOSCHANGING message ");
DbgPrint("  WindowSize is %d %d\n",CONSOLE_WINDOW_SIZE_X(ScreenInfo),CONSOLE_WINDOW_SIZE_Y(ScreenInfo));
DbgPrint("  WindowRect is %d %d %d %d\n",Console->WindowRect.left,
                                         Console->WindowRect.top,
                                         Console->WindowRect.right,
                                         Console->WindowRect.bottom);
DbgPrint("  window pos is %d %d %d %d\n",WindowPos->x,
                                         WindowPos->y,
                                         WindowPos->cx,
                                         WindowPos->cy);
#endif

    //
    // If the window is not being resized, don't do anything
    //

    if (WindowPos->flags & SWP_NOSIZE) {
        return;
    }

    if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
        FontSize = SCR_FONTSIZE(ScreenInfo);
    } else {
        FontSize.X = 1;
        FontSize.Y = 1;
    }

    //
    // If the frame changed, update the system metrics
    //

    if (WindowPos->flags & SWP_FRAMECHANGED) {

        InitializeSystemMetrics();
        if (Console->VerticalClientToWindow != VerticalClientToWindow ||
            Console->HorizontalClientToWindow != HorizontalClientToWindow) {

            Console->VerticalClientToWindow = VerticalClientToWindow;
            Console->HorizontalClientToWindow = HorizontalClientToWindow;
            Console->WindowRect.left = WindowPos->x;
            Console->WindowRect.top = WindowPos->y;
            Console->WindowRect.right = WindowPos->x + WindowPos->cx;
            Console->WindowRect.bottom = WindowPos->y + WindowPos->cy;
            return;
        }
    }

    PixelDeltaX = (SHORT)(WindowPos->cx - (Console->WindowRect.right - Console->WindowRect.left));
    PixelDeltaY = (SHORT)(WindowPos->cy - (Console->WindowRect.bottom - Console->WindowRect.top));

    if (WindowPos->cx >= (ScreenInfo->ScreenBufferSize.X * FontSize.X + VerticalClientToWindow) &&
        WindowPos->cy >= (ScreenInfo->ScreenBufferSize.Y * FontSize.Y + HorizontalClientToWindow)) {

        //
        // handle maximized case
        //

        ScreenInfo->WindowMaximizedX = TRUE;
        ScreenInfo->WindowMaximizedY = TRUE;
        DeltaX = (SHORT)(ScreenInfo->ScreenBufferSize.X - CONSOLE_WINDOW_SIZE_X(ScreenInfo));
        DeltaY = (SHORT)(ScreenInfo->ScreenBufferSize.Y - CONSOLE_WINDOW_SIZE_Y(ScreenInfo));
    } else {

        DeltaX = PixelDeltaX / FontSize.X;
        DeltaY = PixelDeltaY / FontSize.Y;

        //
        // the only time we will get a WM_WINDOWPOSCHANGING message to grow the
        // window larger than the maximum window size is when another app calls
        // SetWindowPos for our window.  the program manager does that when
        // the user requests Tiling.
        //

        CalculateNewSize(&ScreenInfo->WindowMaximizedX,
                         &ScreenInfo->WindowMaximizedY,
                         &DeltaX,
                         &DeltaY,
                         (SHORT)(CONSOLE_WINDOW_SIZE_X(ScreenInfo)),
                         (SHORT)(CONSOLE_WINDOW_SIZE_Y(ScreenInfo)),
                         ScreenInfo->ScreenBufferSize,
                         FontSize
                        );
#ifdef THERESES_DEBUG
DbgPrint("Delta X Y is now %d %d\n",DeltaX,DeltaY);
DbgPrint("Maximized X Y is now %d %d\n",ScreenInfo->WindowMaximizedX,ScreenInfo->WindowMaximizedY);
#endif
    }

    //
    // don't move window when resizing less than a column or row.
    //

    if (!DeltaX && !DeltaY && (PixelDeltaX || PixelDeltaY)) {
        COORD OriginDifference;

        //
        // handle tiling case.  tiling can move the window without resizing, but using
        // a size message. we detect this by checking for the window origin changed by
        // more than one character.
        //

        OriginDifference.X = (SHORT)(WindowPos->x - Console->WindowRect.left);
        OriginDifference.Y = (SHORT)(WindowPos->y - Console->WindowRect.top);
        if (OriginDifference.X < FontSize.X && OriginDifference.X > -FontSize.X &&
            OriginDifference.Y < FontSize.Y && OriginDifference.Y > -FontSize.Y) {
            WindowPos->x = Console->WindowRect.left;
            WindowPos->y = Console->WindowRect.top;
            WindowPos->cx = Console->WindowRect.right - Console->WindowRect.left;
            WindowPos->cy = Console->WindowRect.bottom - Console->WindowRect.top;
            return;
        }
    }

    Flags |= RESIZE_SCROLL_BARS;
    WindowPos->cx = (DeltaX + CONSOLE_WINDOW_SIZE_X(ScreenInfo)) * FontSize.X + (!ScreenInfo->WindowMaximizedY * VerticalScrollSize) + VerticalClientToWindow;
    WindowPos->cy = (DeltaY + CONSOLE_WINDOW_SIZE_Y(ScreenInfo)) * FontSize.Y + (!ScreenInfo->WindowMaximizedX * HorizontalScrollSize) + HorizontalClientToWindow;

    //
    // reflect the new window size in the
    // console window structure
    //

    {
    SHORT ScrollRange,ScrollPos;

    //
    // PercentFromTop = ScrollPos / ScrollRange;
    // PercentFromBottom = (ScrollRange - ScrollPos) / ScrollRange;
    //
    // if drag top border up
    //     Window.Top -= NumLines * PercentFromBottom;
    //     Window.Bottom +=  NumLines - (NumLines * PercentFromBottom);
    //
    // if drag top border down
    //     Window.Top += NumLines * PercentFromBottom;
    //     Window.Bottom -=  NumLines - (NumLines * PercentFromBottom);
    //
    // if drag bottom border up
    //     Window.Top -= NumLines * PercentFromTop;
    //     Window.Bottom +=  NumLines - (NumLines * PercentFromTop);
    //
    // if drag bottom border down
    //     Window.Top += NumLines * PercentFromTop;
    //     Window.Bottom -=  NumLines - (NumLines * PercentFromTop);
    //

    ScrollRange = (SHORT)(ScreenInfo->ScreenBufferSize.X - CONSOLE_WINDOW_SIZE_X(ScreenInfo));
    ScrollPos = ScreenInfo->Window.Left;

    if (WindowPos->x != Console->WindowRect.left) {
        SHORT NumLinesFromRight;
        if (ScrollRange) {
            NumLinesFromRight = DeltaX * (ScrollRange - ScrollPos) / ScrollRange;
        } else {
            NumLinesFromRight = DeltaX; // have scroll pos at left edge
        }
        ScreenInfo->Window.Left -= DeltaX - NumLinesFromRight;
        ScreenInfo->Window.Right += NumLinesFromRight;
    } else {
        SHORT NumLinesFromLeft;
        if (ScrollRange) {
            NumLinesFromLeft = DeltaX * ScrollPos / ScrollRange;
        } else {
            NumLinesFromLeft = 0;   // have scroll pos at left edge
        }
        ScreenInfo->Window.Left -= NumLinesFromLeft;
        ScreenInfo->Window.Right += DeltaX - NumLinesFromLeft;
    }

    ScrollRange = (SHORT)(ScreenInfo->ScreenBufferSize.Y - CONSOLE_WINDOW_SIZE_Y(ScreenInfo));
    ScrollPos = ScreenInfo->Window.Top;
    if (WindowPos->y != Console->WindowRect.top) {
        SHORT NumLinesFromBottom;
        if (ScrollRange) {
            NumLinesFromBottom = DeltaY * (ScrollRange - ScrollPos) / ScrollRange;
        } else {
            NumLinesFromBottom = DeltaY; // have scroll pos at top edge
        }
        ScreenInfo->Window.Top -= DeltaY - NumLinesFromBottom;
        ScreenInfo->Window.Bottom += NumLinesFromBottom;
    } else {
        SHORT NumLinesFromTop;
        if (ScrollRange) {
            NumLinesFromTop = DeltaY * ScrollPos / ScrollRange;
        } else {
            NumLinesFromTop = 0;   // have scroll pos at top edge
        }
        ScreenInfo->Window.Top -= NumLinesFromTop;
        ScreenInfo->Window.Bottom += DeltaY - NumLinesFromTop;
    }
    }

    if (ScreenInfo->WindowMaximizedX)
        ASSERT (CONSOLE_WINDOW_SIZE_X(ScreenInfo) == ScreenInfo->ScreenBufferSize.X);
    if (ScreenInfo->WindowMaximizedY)
        ASSERT (CONSOLE_WINDOW_SIZE_Y(ScreenInfo) == ScreenInfo->ScreenBufferSize.Y);
#ifdef THERESES_DEBUG
DbgPrint("  WindowSize is now %d %d\n",CONSOLE_WINDOW_SIZE_X(ScreenInfo),CONSOLE_WINDOW_SIZE_Y(ScreenInfo));
DbgPrint("  window pos is now %d %d %d %d\n",WindowPos->x,
                                         WindowPos->y,
                                         WindowPos->cx,
                                         WindowPos->cy);
#endif
    Console->ResizeFlags = Flags | (Console->ResizeFlags & SCREEN_BUFFER_CHANGE);
}



VOID
CalculateNewSize(
    IN PBOOLEAN MaximizedX,
    IN PBOOLEAN MaximizedY,
    IN OUT PSHORT DeltaX,
    IN OUT PSHORT DeltaY,
    IN SHORT WindowSizeX,
    IN SHORT WindowSizeY,
    IN COORD ScreenBufferSize,
    IN COORD FontSize
    )
{
    SHORT MaxDeltaX = ScreenBufferSize.X - WindowSizeX;
    SHORT MaxDeltaY = ScreenBufferSize.Y - WindowSizeY;
    SHORT MinDeltaX = 1 - WindowSizeX;
    SHORT MinDeltaY = 1 - WindowSizeY;

    while (TRUE) {

        /*
         * Do we need to remove a horizontal scroll bar?
         */
        if (!*MaximizedX && *DeltaX >= MaxDeltaX) {
            *MaximizedX = TRUE;
            *DeltaY += (VerticalScrollSize+FontSize.Y-1) / FontSize.Y;
        }

        /*
         * Do we need to remove a vertical scroll bar?
         */
        else if (!*MaximizedY && *DeltaY >= MaxDeltaY) {
            *MaximizedY = TRUE;
            *DeltaX += (HorizontalScrollSize+FontSize.X-1) / FontSize.X;
        }

        /*
         * Do we need to add a horizontal scroll bar?
         */
        else if (*MaximizedX && *DeltaX < MaxDeltaX) {
            *MaximizedX = FALSE;
            *DeltaY -= (VerticalScrollSize+FontSize.Y-1) / FontSize.Y;
        }

        /*
         * Do we need to add a vertical scroll bar?
         */
        else if (*MaximizedY && *DeltaY < MaxDeltaY) {
            *MaximizedY = FALSE;
            *DeltaX -= (HorizontalScrollSize+FontSize.X-1) / FontSize.X;
        }

        /*
         * Everything is done, so get out.
         */
        else {
            if (*DeltaX > MaxDeltaX)
                *DeltaX = MaxDeltaX;
            else if (*DeltaX < MinDeltaX)
                *DeltaX = MinDeltaX;
            if (*DeltaY > MaxDeltaY)
                *DeltaY = MaxDeltaY;
            else if (*DeltaY < MinDeltaY)
                *DeltaY = MinDeltaY;
            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\server\sources.inc ===
!IF 0

Copyright (c) 1990  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Therese Stowell (thereses) 11-Nov-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=windows
MINORCOMP=consrvl

CAIRO=1

TARGETNAME=consrvl
TARGETTYPE=LIBRARY

TARGETPATH=$(ALT_PROJECT_TARGET)\$(_OBJ_DIR)

C_DEFINES=$(C_DEFINES) -DUNICODE -DNEW_MINLOOK -D_NTDRIVER_

!IFNDEF MSC_WARNING_LEVEL
MSC_WARNING_LEVEL=/W3
!ENDIF
MSC_WARNING_LEVEL=$(MSC_WARNING_LEVEL) /WX

NTTARGETFILES=

INCLUDES=                                        \
        ..\;                                     \
        ..\..\inc;                               \
        $(WINCORE_PATH)\w32inc;                  \
        $(WINCORE_PATH)\w32inc\$(O);             \
        $(NTGDI_PATH)\inc;                       \
        $(NTUSER_PATH)\inc;                      \
        $(NTUSER_PATH)\inc\$(ALT_PROJECT)\$(O);  \
        $(NTUSER_PATH)\server;                   \
        $(NTUSER_PATH)\server\daytona\$(O);      \
        $(SHELL_INC_PATH);                       \
        $(BASE_INC_PATH)

SOURCES=..\bitmap.c    \
        ..\clipbrd.c   \
        ..\cmdline.c   \
        ..\constubs.c  \
        ..\cursor.c    \
        ..\directio.c  \
        ..\find.c      \
        ..\getset.c    \
        ..\handle.c    \
        ..\input.c     \
        ..\link.c      \
        ..\menu.c      \
        ..\misc.c      \
        ..\output.c    \
        ..\private.c   \
        ..\resize.c    \
        ..\share.c     \
        ..\srvinit.c   \
        ..\srvvdm.c    \
        ..\stream.c    \
        ..\dispatch.c  \
        ..\dbcs.c      \
        ..\convarea.c  \
        ..\eudc.c      \
        ..\foncache.c  \
        ..\hard.c

PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

SOURCES_USED=..\sources.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\server\share.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    share.c

Abstract:

    Implements sharing for input and output handles

Author:

    Therese Stowell (thereses) 11-Nov-1990

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

NTSTATUS
ConsoleAddShare(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PCONSOLE_SHARE_ACCESS ShareAccess,
    IN OUT PHANDLE_DATA HandleData
    )

{
    ULONG Ocount;
    ULONG ReadAccess;
    ULONG WriteAccess;
    ULONG SharedRead;
    ULONG SharedWrite;

    //
    // Set the access type in the file object for the current accessor.
    //

    ReadAccess = (DesiredAccess & GENERIC_READ) != 0;
    WriteAccess = (DesiredAccess & GENERIC_WRITE) != 0;

    SharedRead = (DesiredShareAccess & FILE_SHARE_READ) != 0;
    SharedWrite = (DesiredShareAccess & FILE_SHARE_WRITE) != 0;

    //
    // Now check to see whether or not the desired accesses are compatible
    // with the way that the file is currently open.
    //

    Ocount = ShareAccess->OpenCount;

    if ( (ReadAccess && (ShareAccess->SharedRead < Ocount))
         ||
         (WriteAccess && (ShareAccess->SharedWrite < Ocount))
         ||
         ((ShareAccess->Readers != 0) && !SharedRead)
         ||
         ((ShareAccess->Writers != 0) && !SharedWrite)
       ) {

        //
        // The check failed.  Simply return to the caller indicating that the
        // current open cannot access the file.
        //

        return STATUS_SHARING_VIOLATION;

    } else {

        //
        // The check was successful.  Update the counter information in the
        // shared access structure for this open request if the caller
        // specified that it should be updated.
        //

        ShareAccess->OpenCount++;

        ShareAccess->Readers += ReadAccess;
        ShareAccess->Writers += WriteAccess;

        ShareAccess->SharedRead += SharedRead;
        ShareAccess->SharedWrite += SharedWrite;
        HandleData->Access = DesiredAccess;
        HandleData->ShareAccess = DesiredShareAccess;

        return STATUS_SUCCESS;
    }
}

NTSTATUS
ConsoleDupShare(
    IN ACCESS_MASK DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PCONSOLE_SHARE_ACCESS ShareAccess,
    IN OUT PHANDLE_DATA TargetHandleData
    )

{
    ULONG ReadAccess;
    ULONG WriteAccess;
    ULONG SharedRead;
    ULONG SharedWrite;

    //
    // Set the access type in the file object for the current accessor.
    //

    ReadAccess = (DesiredAccess & GENERIC_READ) != 0;
    WriteAccess = (DesiredAccess & GENERIC_WRITE) != 0;

    SharedRead = (DesiredShareAccess & FILE_SHARE_READ) != 0;
    SharedWrite = (DesiredShareAccess & FILE_SHARE_WRITE) != 0;

    if (ShareAccess->OpenCount == 0) {
        ASSERT (FALSE);
        return STATUS_SHARING_VIOLATION;
    }

    ShareAccess->OpenCount++;

    ShareAccess->Readers += ReadAccess;
    ShareAccess->Writers += WriteAccess;

    ShareAccess->SharedRead += SharedRead;
    ShareAccess->SharedWrite += SharedWrite;

    TargetHandleData->Access = DesiredAccess;
    TargetHandleData->ShareAccess = DesiredShareAccess;

    return STATUS_SUCCESS;
}

NTSTATUS
ConsoleRemoveShare(
    IN ULONG DesiredAccess,
    IN ULONG DesiredShareAccess,
    IN OUT PCONSOLE_SHARE_ACCESS ShareAccess
    )

{
    ULONG ReadAccess;
    ULONG WriteAccess;
    ULONG SharedRead;
    ULONG SharedWrite;

    //
    // Set the access type in the file object for the current accessor.
    //

    ReadAccess = (DesiredAccess & GENERIC_READ) != 0;
    WriteAccess = (DesiredAccess & GENERIC_WRITE) != 0;

    SharedRead = (DesiredShareAccess & FILE_SHARE_READ) != 0;
    SharedWrite = (DesiredShareAccess & FILE_SHARE_WRITE) != 0;

    if (ShareAccess->OpenCount == 0) {
        ASSERT (FALSE);
        return STATUS_UNSUCCESSFUL;
    }

    ShareAccess->OpenCount--;

    ShareAccess->Readers -= ReadAccess;
    ShareAccess->Writers -= WriteAccess;

    ShareAccess->SharedRead -= SharedRead;
    ShareAccess->SharedWrite -= SharedWrite;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\server\precomp.h ===
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntcsrsrv.h>
#include <windows.h>
#include <conroute.h>
#include <ntddvdeo.h>
#include "shellapi.h"
#include "shlobj.h"
#include "shlwapi.h"
#define NO_SHLWAPI_STRFCNS
#define NO_SHLWAPI_PATH
#define NO_SHLWAPI_REG
#define NO_SHLWAPI_UALSTR
#define NO_SHLWAPI_HTTP
#define NO_SHLWAPI_INTERNAL
#include "shlwapip.h"
#include "shlobjp.h"
#undef _DROPFILES
#undef DROPFILES
#undef LPDROPFILES
#include "conapi.h"
#include "conmsg.h"
#include "usersrv.h"
#include "server.h"
#include "cmdline.h"
#include "font.h"
#include "heap.h"
#include "consrv.h"
#include "directio.h"
#include "globals.h"
#include "menu.h"
#include "stream.h"
#include "winuserp.h"
#include "winconp.h"
#include "winbasep.h"
#ifndef WIN32
#define WIN32
#endif
#include <port1632.h>
#if defined(FE_SB)
#include "dbcs.h"
#include "dispatch.h"
#include "eudc.h"
#include "foncache.h"
#include "machine.h"
#if defined(FE_IME)
#include "conv.h"
#include <immp.h>
#endif
#endif
#include <ntosp.h>
#include <w32p.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\server\stream.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    stream.c

Abstract:

        This file implements the NT console server stream API

Author:

    Therese Stowell (thereses) 6-Nov-1990

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#define IS_CONTROL_CHAR(wch)  ((wch) < L' ')
#define IS_GLYPH_CHAR(wch)   (((wch) < L' ') || ((wch) == 0x007F))

#define LINE_INPUT_BUFFER_SIZE (256 * sizeof(WCHAR))

#define CONSOLE_CTRL_2 0x0

NTSTATUS
WaitForMoreToRead(
    IN PINPUT_INFORMATION InputInformation,
    IN PCSR_API_MSG Message OPTIONAL,
    IN CSR_WAIT_ROUTINE WaitRoutine OPTIONAL,
    IN PVOID WaitParameter OPTIONAL,
    IN ULONG WaitParameterLength  OPTIONAL,
    IN BOOLEAN WaitBlockExists OPTIONAL
    );

BOOLEAN
WriteConsoleWaitRoutine(
    IN PLIST_ENTRY WaitQueue,
    IN PCSR_THREAD WaitingThread,
    IN PCSR_API_MSG WaitReplyMessage,
    IN PVOID WaitParameter,
    IN PVOID SatisfyParameter1,
    IN PVOID SatisfyParameter2,
    IN ULONG WaitFlags
    );

HANDLE
FindActiveScreenBufferHandle(
    IN PCONSOLE_PER_PROCESS_DATA ProcessData,
    IN PCONSOLE_INFORMATION Console
    )
{
    ULONG i;
    HANDLE ActiveScreenHandle;
    PHANDLE_DATA ActiveScreenHandleData;
    NTSTATUS Status;

    ActiveScreenHandle = INVALID_HANDLE_VALUE;
    for (i=0;i<ProcessData->HandleTableSize;i++) {
        Status = DereferenceIoHandleNoCheck(ProcessData,
                                     LongToHandle(i),
                                     &ActiveScreenHandleData
                                    );
        if (NT_SUCCESS(Status) &&
            Console->CurrentScreenBuffer == ActiveScreenHandleData->Buffer.ScreenBuffer) {
            ASSERT (ActiveScreenHandleData->HandleType & (CONSOLE_OUTPUT_HANDLE | CONSOLE_GRAPHICS_OUTPUT_HANDLE));
            ActiveScreenHandle = LongToHandle(i);
            break;
        }
    }
    return ActiveScreenHandle;
}

ULONG
SrvOpenConsole(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Routine Description:

    This routine returns a handle to the input buffer or active screen buffer.

Arguments:

    ApiMessageData - Points to parameter structure.

Return Value:

--*/

{
    PCONSOLE_OPENCONSOLE_MSG a = (PCONSOLE_OPENCONSOLE_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    HANDLE Handle;
    PHANDLE_DATA HandleData;
    PCONSOLE_PER_PROCESS_DATA ProcessData;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    try {
        Handle = INVALID_HANDLE_VALUE;
        ProcessData = CONSOLE_PERPROCESSDATA();
        if (a->HandleType == CONSOLE_INPUT_HANDLE) {

            Status = AllocateIoHandle(ProcessData,
                                      a->HandleType,
                                      &Handle
                                     );
            if (!NT_SUCCESS(Status)) {
                leave;
            }
            Status = DereferenceIoHandleNoCheck(ProcessData,
                                         Handle,
                                         &HandleData
                                        );
            ASSERT (NT_SUCCESS(Status));
            if (!NT_SUCCESS(Status)) {
                leave;
            }
            if (!InitializeInputHandle(HandleData, &Console->InputBuffer)) {
                Status = STATUS_NO_MEMORY;
                leave;
            }
            if (a->InheritHandle) {
                HandleData->HandleType |= CONSOLE_INHERITABLE;
            }
            Status = ConsoleAddShare(a->DesiredAccess,
                                     a->ShareMode,
                                     &HandleData->Buffer.InputBuffer->ShareAccess,
                                     HandleData
                                    );
            if (!NT_SUCCESS(Status)) {
                HandleData->Buffer.InputBuffer->RefCount--;
                leave;
            }
        } else if (a->HandleType == CONSOLE_OUTPUT_HANDLE){
            PSCREEN_INFORMATION ScreenInfo;

            //
            // open a handle to the active screen buffer.
            //

            ScreenInfo = Console->CurrentScreenBuffer;
            if (ScreenInfo == NULL) {
                Status = STATUS_OBJECT_NAME_NOT_FOUND;
                leave;
            }
            Status = AllocateIoHandle(ProcessData,
                                      a->HandleType,
                                      &Handle
                                     );
            if (!NT_SUCCESS(Status)) {
                leave;
            }
            Status = DereferenceIoHandleNoCheck(ProcessData,
                                         Handle,
                                         &HandleData
                                        );
            ASSERT (NT_SUCCESS(Status));
            if (!NT_SUCCESS(Status)) {
                leave;
            }
            InitializeOutputHandle(HandleData, ScreenInfo);
            if (a->InheritHandle) {
                HandleData->HandleType |= CONSOLE_INHERITABLE;
            }
            Status = ConsoleAddShare(a->DesiredAccess,
                                     a->ShareMode,
                                     &HandleData->Buffer.ScreenBuffer->ShareAccess,
                                     HandleData
                                    );
            if (!NT_SUCCESS(Status)) {
                HandleData->Buffer.ScreenBuffer->RefCount--;
                leave;
            }
        }
        else {
            Status = STATUS_INVALID_PARAMETER;
            leave;
        }
        a->Handle = INDEX_TO_HANDLE(Handle);
        Status = STATUS_SUCCESS;
    } finally {
        if (!NT_SUCCESS(Status) && Handle != INVALID_HANDLE_VALUE) {
            FreeIoHandle(ProcessData,
                         Handle
                        );
        }
        UnlockConsole(Console);
    }
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);    // get rid of unreferenced parameter warning message
}

/*
 * Convert real Windows NT modifier bit into bizarre Console bits
 */
#define EITHER_CTRL_PRESSED (LEFT_CTRL_PRESSED | RIGHT_CTRL_PRESSED)
#define EITHER_ALT_PRESSED (LEFT_ALT_PRESSED | RIGHT_ALT_PRESSED)
#define MOD_PRESSED (SHIFT_PRESSED | EITHER_CTRL_PRESSED | EITHER_ALT_PRESSED)

DWORD ConsKbdState[] = {
    0,
    SHIFT_PRESSED,
                    EITHER_CTRL_PRESSED,
    SHIFT_PRESSED | EITHER_CTRL_PRESSED,
                                          EITHER_ALT_PRESSED,
    SHIFT_PRESSED |                       EITHER_ALT_PRESSED,
                    EITHER_CTRL_PRESSED | EITHER_ALT_PRESSED,
    SHIFT_PRESSED | EITHER_CTRL_PRESSED | EITHER_ALT_PRESSED
};

#define KEYEVENTSTATE_EQUAL_WINMODS(Event, WinMods)\
    ((Event.Event.KeyEvent.dwControlKeyState & ConsKbdState[WinMods]) && \
    !(Event.Event.KeyEvent.dwControlKeyState & MOD_PRESSED & ~ConsKbdState[WinMods]))

BOOL IsDbcsExemptionForHighAnsi(
    UINT wCodePage,
    WORD wNumpadChar)
{
    UserAssert(HIBYTE(wNumpadChar) == 0);

    if (wCodePage == CP_JAPANESE && IS_JPN_1BYTE_KATAKANA(wNumpadChar)) {
        /*
         * If hkl is JAPANESE and NumpadChar is in KANA range,
         * NumpadChar should be handled by the input locale.
         */
        return FALSE;
    }
    else if (wNumpadChar >= 0x80 && wNumpadChar <= 0xff) {
        /*
         * Otherwise if NumpadChar is in High ANSI range,
         * use 1252 for conversion.
         */
        return TRUE;
    }

    /*
     * None of the above.
     * This case includes the compound Leading Byte and Trailing Byte,
     * which is larger than 0xff.
     */
    return FALSE;
}

NTSTATUS
GetChar(
    IN PINPUT_INFORMATION InputInfo,
    OUT PWCHAR Char,
    IN BOOLEAN Wait,
    IN PCONSOLE_INFORMATION Console,
    IN PHANDLE_DATA HandleData,
    IN PCSR_API_MSG Message OPTIONAL,
    IN CSR_WAIT_ROUTINE WaitRoutine OPTIONAL,
    IN PVOID WaitParameter OPTIONAL,
    IN ULONG WaitParameterLength  OPTIONAL,
    IN BOOLEAN WaitBlockExists OPTIONAL,
    OUT PBOOLEAN CommandLineEditingKeys OPTIONAL,
    OUT PBOOLEAN CommandLinePopupKeys OPTIONAL,
    OUT PBOOLEAN EnableScrollMode OPTIONAL,
    OUT PDWORD KeyState OPTIONAL
    )

/*++

Routine Description:

    This routine is used in stream input.  It gets input and filters it
    for unicode characters.

Arguments:

    InputInfo - Pointer to input buffer information.

    Char - Unicode char input.

    Wait - TRUE if the routine shouldn't wait for input.

    Console - Pointer to console buffer information.

    HandleData - Pointer to handle data structure.

    Message - csr api message.

    WaitRoutine - Routine to call when wait is woken up.

    WaitParameter - Parameter to pass to wait routine.

    WaitParameterLength - Length of wait parameter.

    WaitBlockExists - TRUE if wait block has already been created.

    CommandLineEditingKeys - if present, arrow keys will be returned. on
    output, if TRUE, Char contains virtual key code for arrow key.

    CommandLinePopupKeys - if present, arrow keys will be returned. on
    output, if TRUE, Char contains virtual key code for arrow key.

Return Value:

--*/

{
    ULONG NumRead;
    INPUT_RECORD Event;
    NTSTATUS Status;

    if (ARGUMENT_PRESENT(CommandLineEditingKeys)) {
        *CommandLineEditingKeys = FALSE;
    }
    if (ARGUMENT_PRESENT(CommandLinePopupKeys)) {
        *CommandLinePopupKeys = FALSE;
    }
    if (ARGUMENT_PRESENT(EnableScrollMode)) {
        *EnableScrollMode = FALSE;
    }
    if (ARGUMENT_PRESENT(KeyState)) {
        *KeyState = 0;
    }

    NumRead = 1;
    while (TRUE) {
        Status =ReadInputBuffer(InputInfo,
                                 &Event,
                                 &NumRead,
                                 FALSE,
                                 Wait,
                                 TRUE,
                                 Console,
                                 HandleData,
                                 Message,
                                 WaitRoutine,
                                 WaitParameter,
                                 WaitParameterLength,
                                 WaitBlockExists
#if defined(FE_SB)
                                 ,
                                 TRUE
#endif
                                );
        if (!NT_SUCCESS(Status)) {
            return Status;
        }
        if (NumRead == 0) {
            if (Wait) {
                ASSERT (FALSE);
            }
            else {
                return STATUS_UNSUCCESSFUL;
            }
        }
        if (Event.EventType == KEY_EVENT) {
            BOOL fCommandLineEditKey;

            if (ARGUMENT_PRESENT(CommandLineEditingKeys)) {
                fCommandLineEditKey = IsCommandLineEditingKey(&Event.Event.KeyEvent);
            } else if (ARGUMENT_PRESENT(CommandLinePopupKeys)) {
                fCommandLineEditKey = IsCommandLinePopupKey(&Event.Event.KeyEvent);
            } else {
                fCommandLineEditKey = FALSE;
            }

            //
            // Always return keystate if caller asked for it.
            //
            if (ARGUMENT_PRESENT(KeyState)) {
                *KeyState = Event.Event.KeyEvent.dwControlKeyState;
            }

            if (Event.Event.KeyEvent.uChar.UnicodeChar != 0 &&
                    !fCommandLineEditKey) {

                //
                // chars that are generated using alt+numpad
                //
                if (!Event.Event.KeyEvent.bKeyDown &&
                        Event.Event.KeyEvent.wVirtualKeyCode == VK_MENU) {
                    if (Event.Event.KeyEvent.dwControlKeyState & ALTNUMPAD_BIT)
                    {
                        if (CONSOLE_IS_DBCS_CP(Console) && HIBYTE(Event.Event.KeyEvent.uChar.UnicodeChar)) {
                            char chT[2] = {
                                HIBYTE(Event.Event.KeyEvent.uChar.UnicodeChar),
                                LOBYTE(Event.Event.KeyEvent.uChar.UnicodeChar),
                            };
                            *Char = CharToWchar(Console, Console->CP, chT);
                        } else {
                            // Because USER doesn't know our codepage, it gives us the
                            // raw OEM char and we convert it to a Unicode character.
                            char chT = LOBYTE(Event.Event.KeyEvent.uChar.UnicodeChar);
                            UINT uCodePage = Console->CP;

                            //
                            // FarEast hack for High ANSI OEM characters.
                            //
                            if (CONSOLE_IS_DBCS_CP(Console)) {
                                if (IsDbcsExemptionForHighAnsi(uCodePage, chT)) {
                                    /*
                                     * FarEast hack:
                                     * treat characters in High ANSI area as if they are
                                     * the ones of Codepage 1252.
                                     */
                                    uCodePage = 1252;
                                }
                            }
                            *Char = CharToWchar(Console, uCodePage, &chT);
                        }
                    } else {
                        *Char = Event.Event.KeyEvent.uChar.UnicodeChar;
                    }
                    return STATUS_SUCCESS;
                }
                //
                // Ignore Escape and Newline chars
                //
                else if (Event.Event.KeyEvent.bKeyDown &&
                        Event.Event.KeyEvent.wVirtualKeyCode != VK_ESCAPE &&
                        Event.Event.KeyEvent.uChar.UnicodeChar != 0x0a) {

                    *Char = Event.Event.KeyEvent.uChar.UnicodeChar;
                    return STATUS_SUCCESS;
                }
            }

            if (Event.Event.KeyEvent.bKeyDown) {
                SHORT sTmp;
                if (ARGUMENT_PRESENT(CommandLineEditingKeys) &&
                        fCommandLineEditKey) {
                    *CommandLineEditingKeys = TRUE;
                    *Char = (WCHAR) Event.Event.KeyEvent.wVirtualKeyCode;
                    return STATUS_SUCCESS;
                }
                else if (ARGUMENT_PRESENT(CommandLinePopupKeys) &&
                        fCommandLineEditKey) {
                    *CommandLinePopupKeys = TRUE;
                    *Char = (CHAR) Event.Event.KeyEvent.wVirtualKeyCode;
                    return STATUS_SUCCESS;
                }

                sTmp = VkKeyScan(0);

                if ((LOBYTE(sTmp) == Event.Event.KeyEvent.wVirtualKeyCode) &&
                    KEYEVENTSTATE_EQUAL_WINMODS(Event, HIBYTE(sTmp))) {
                    /*
                     * This really is the character 0x0000
                     */
                    *Char = Event.Event.KeyEvent.uChar.UnicodeChar;
                    return STATUS_SUCCESS;
                }
            }
        }
    }
}

BOOLEAN
RawReadWaitRoutine(
    IN PLIST_ENTRY WaitQueue,
    IN PCSR_THREAD WaitingThread,
    IN PCSR_API_MSG WaitReplyMessage,
    IN PVOID WaitParameter,
    IN PVOID SatisfyParameter1,
    IN PVOID SatisfyParameter2,
    IN ULONG WaitFlags
    )

/*++

Routine Description:

    This routine is called to complete a raw read that blocked in
    ReadInputBuffer.  The context of the read was saved in the RawReadData
    structure.  This routine is called when events have been written to
    the input buffer.  It is called in the context of the writing thread.
    ?It will be called at most once per read.?

Arguments:

    WaitQueue - pointer to queue containing wait block

    WaitingThread - pointer to waiting thread

    WaitReplyMessage - Pointer to reply message to return to dll when
        read is completed.

    RawReadData - pointer to data saved in ReadChars

    SatisfyParameter1 - not used

    SatisfyParameter2 - not used

    WaitFlags - Flags indicating status of wait.

Return Value:

--*/

{
    NTSTATUS Status;
    PWCHAR lpBuffer;
    PCONSOLE_READCONSOLE_MSG a;
    PCONSOLE_INFORMATION Console;
    PRAW_READ_DATA RawReadData;
    PHANDLE_DATA HandleData;
    BOOLEAN RetVal = TRUE;
#ifdef FE_SB
    DWORD NumBytes;
    BOOL fAddDbcsLead = FALSE;
#endif

    a = (PCONSOLE_READCONSOLE_MSG)&WaitReplyMessage->u.ApiMessageData;
    RawReadData = (PRAW_READ_DATA)WaitParameter;

    Status = DereferenceIoHandleNoCheck(RawReadData->ProcessData,
                                        RawReadData->HandleIndex,
                                        &HandleData
                                       );
    ASSERT (NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status)) {
        return TRUE;
    }

    //
    // see if this routine was called by CloseInputHandle.  if it
    // was, see if this wait block corresponds to the dying handle.
    // if it doesn't, just return.
    //

    if (SatisfyParameter1 != NULL &&
        SatisfyParameter1 != HandleData) {
        return FALSE;
    }
    if ((ULONG_PTR)SatisfyParameter2 & CONSOLE_CTRL_C_SEEN) {
        return FALSE;
    }

    Console = RawReadData->Console;

    //
    // this routine should be called by a thread owning the same
    // lock on the same console as we're reading from.
    //

    a->NumBytes = 0;
#ifdef FE_SB
    NumBytes = 0 ;
#endif
    try {
        LockReadCount(HandleData);
        ASSERT(HandleData->InputReadData->ReadCount);
        HandleData->InputReadData->ReadCount -= 1;
        UnlockReadCount(HandleData);

        //
        // if a ctrl-c is seen, don't terminate read.  if ctrl-break is seen,
        // terminate read.
        //

        if ((ULONG_PTR)SatisfyParameter2 & CONSOLE_CTRL_BREAK_SEEN) {
            WaitReplyMessage->ReturnValue = STATUS_ALERTED;
            leave;
        }

        //
        // see if called by CsrDestroyProcess or CsrDestroyThread
        // via CsrNotifyWaitBlock.   if so, just decrement the ReadCount
        // and return.
        //

        if (WaitFlags & CSR_PROCESS_TERMINATING) {
            Status = STATUS_THREAD_IS_TERMINATING;
            leave;
        }

        //
        // We must see if we were woken up because the handle is being
        // closed.  if so, we decrement the read count.  if it goes to
        // zero, we wake up the close thread.  otherwise, we wake up any
        // other thread waiting for data.
        //

        if (HandleData->InputReadData->InputHandleFlags & HANDLE_CLOSING) {
            ASSERT (SatisfyParameter1 == HandleData);
            Status = STATUS_ALERTED;
            leave;
        }

        //
        // if we get to here, this routine was called either by the input
        // thread or a write routine.  both of these callers grab the
        // current console lock.
        //

        //
        // this routine should be called by a thread owning the same
        // lock on the same console as we're reading from.
        //

        ASSERT (ConsoleLocked(Console));

        if (a->CaptureBufferSize <= BUFFER_SIZE) {
            lpBuffer = a->Buffer;
        }
        else {
            lpBuffer = RawReadData->BufPtr;
        }

        //
        // this call to GetChar may block.
        //

#ifdef FE_SB
        if (!a->Unicode && CONSOLE_IS_DBCS_CP(Console)) {
            if (HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte.Event.KeyEvent.uChar.AsciiChar) {
                fAddDbcsLead = TRUE;
                *lpBuffer = HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte.Event.KeyEvent.uChar.AsciiChar;
                RawReadData->BufferSize-=sizeof(WCHAR);
                RtlZeroMemory(&HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte,sizeof(INPUT_RECORD));
                Status = STATUS_SUCCESS;
                if (RawReadData->BufferSize == 0) {
                    a->NumBytes = 1;
                    return FALSE;
                }
            }
            else{
                Status = GetChar(RawReadData->InputInfo,
                         lpBuffer,
                         TRUE,
                         Console,
                         HandleData,
                         WaitReplyMessage,
                         RawReadWaitRoutine,
                         RawReadData,
                         sizeof(*RawReadData),
                         TRUE,
                         NULL,
                         NULL,
                         NULL,
                         NULL
                        );
            }
        }
        else
#endif
        Status = GetChar(RawReadData->InputInfo,
                         lpBuffer,
                         TRUE,
                         Console,
                         HandleData,
                         WaitReplyMessage,
                         RawReadWaitRoutine,
                         RawReadData,
                         sizeof(*RawReadData),
                         TRUE,
                         NULL,
                         NULL,
                         NULL,
                         NULL
                        );

        if (!NT_SUCCESS(Status)) {
            if (Status == CONSOLE_STATUS_WAIT) {
                RetVal = FALSE;
            }
            leave;
        }
#ifdef FE_SB
        IsConsoleFullWidth(Console->hDC,
                           Console->CP,*lpBuffer) ? NumBytes+=2 : NumBytes++;
#endif
        lpBuffer++;
        a->NumBytes += sizeof(WCHAR);
        while (a->NumBytes < RawReadData->BufferSize) {

            //
            // this call to GetChar won't block.
            //

            Status = GetChar(RawReadData->InputInfo,lpBuffer,FALSE,NULL,NULL,NULL,NULL,NULL,0,TRUE,NULL,NULL,NULL,NULL);
            if (!NT_SUCCESS(Status)) {
                Status = STATUS_SUCCESS;
                break;
            }
#ifdef FE_SB
            IsConsoleFullWidth(Console->hDC,
                               Console->CP,*lpBuffer) ? NumBytes+=2 : NumBytes++;
#endif
            lpBuffer++;
            a->NumBytes += sizeof(WCHAR);
        }
    } finally {

        //
        // if the read was completed (status != wait), free the raw read
        // data.
        //

        if (Status != CONSOLE_STATUS_WAIT) {
            if (!a->Unicode) {

                //
                // if ansi, translate string.
                //

                PCHAR TransBuffer;

#ifdef FE_SB
                TransBuffer = (PCHAR)ConsoleHeapAlloc(MAKE_TAG( TMP_DBCS_TAG ),NumBytes);
#else
                TransBuffer = (PCHAR)ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ),a->NumBytes / sizeof(WCHAR));
#endif
                if (TransBuffer == NULL) {
                    RetVal = TRUE;
                    goto EndFinally;
                }

                if (a->CaptureBufferSize <= BUFFER_SIZE) {
                    lpBuffer = a->Buffer;
                }
                else {
                    lpBuffer = RawReadData->BufPtr;
                }

#ifdef FE_SB
                if (CONSOLE_IS_DBCS_CP(Console))
                {
                    a->NumBytes = TranslateUnicodeToOem(Console,
                                                        lpBuffer,
                                                        a->NumBytes / sizeof (WCHAR),
                                                        TransBuffer,
                                                        NumBytes,
                                                        &HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte);
                }
                else
#endif
                a->NumBytes = ConvertToOem(RawReadData->Console->CP,
                                     lpBuffer,
                                     a->NumBytes / sizeof (WCHAR),
                                     TransBuffer,
                                     a->NumBytes / sizeof (WCHAR)
                                     );
                RtlCopyMemory(lpBuffer,TransBuffer,a->NumBytes);
#ifdef FE_SB
                if (fAddDbcsLead)
                    a->NumBytes++;
#endif
                ConsoleHeapFree(TransBuffer);
            }
            WaitReplyMessage->ReturnValue = Status;
            ConsoleHeapFree(RawReadData);
        }
EndFinally:;
    }
    return RetVal;

    //
    // satisfy the unreferenced parameter warnings.
    //

    UNREFERENCED_PARAMETER(WaitQueue);
    UNREFERENCED_PARAMETER(WaitingThread);
}

ULONG
RetrieveTotalNumberOfSpaces(
    IN SHORT OriginalCursorPositionX,
    IN PWCHAR Buffer,
    IN ULONG CurrentPosition
#if defined(FE_SB)
    ,
    IN PCONSOLE_INFORMATION Console
#endif
    )

/*++

    This routine returns the total number of screen spaces the characters
    up to the specified character take up.

--*/

{
    WCHAR Char;
    ULONG i,NumSpacesForChar,NumSpaces;
    SHORT XPosition;

    XPosition=OriginalCursorPositionX;
    NumSpaces=0;
    for (i=0;i<CurrentPosition;i++) {
        Char = Buffer[i];
        if (Char == UNICODE_TAB) {
            NumSpacesForChar = NUMBER_OF_SPACES_IN_TAB(XPosition);
        } else if (IS_CONTROL_CHAR(Char)) {
            NumSpacesForChar = 2;
#if defined(FE_SB)
        } else if (IsConsoleFullWidth(Console->hDC,Console->CP,Char)) {
            NumSpacesForChar = 2;
#endif
        } else {
            NumSpacesForChar = 1;
        }
        XPosition = (SHORT)(XPosition+NumSpacesForChar);
        NumSpaces += NumSpacesForChar;
    }
    return NumSpaces;
}

ULONG
RetrieveNumberOfSpaces(
    IN SHORT OriginalCursorPositionX,
    IN PWCHAR Buffer,
    IN ULONG CurrentPosition
#if defined(FE_SB)
    ,
    IN PCONSOLE_INFORMATION Console,
    IN DWORD CodePage
#endif
    )

/*++

    This routine returns the number of screen spaces the specified character
    takes up.

--*/

{
    WCHAR Char;
    ULONG i,NumSpaces;
    SHORT XPosition;

    Char = Buffer[CurrentPosition];
    if (Char == UNICODE_TAB) {
        NumSpaces=0;
        XPosition=OriginalCursorPositionX;
        for (i=0;i<=CurrentPosition;i++) {
            Char = Buffer[i];
            if (Char == UNICODE_TAB) {
                NumSpaces = NUMBER_OF_SPACES_IN_TAB(XPosition);
            } else if (IS_CONTROL_CHAR(Char)) {
                NumSpaces = 2;
#if defined(FE_SB)
            } else if (IsConsoleFullWidth(Console->hDC,CodePage,Char)) {
                NumSpaces = 2;
#endif
            } else {
                NumSpaces = 1;
            }
            XPosition = (SHORT)(XPosition+NumSpaces);
        }
        return NumSpaces;
    }
    else if (IS_CONTROL_CHAR(Char)) {
        return 2;
    }
#if defined(FE_SB)
    else if (IsConsoleFullWidth(Console->hDC,CodePage,Char)) {
        return 2;
    }
#endif
    else {
        return 1;
    }
}

BOOL
ProcessCookedReadInput(
    IN PCOOKED_READ_DATA CookedReadData,
    IN WCHAR Char,
    IN DWORD KeyState,
    OUT PNTSTATUS Status
    )

/*++

    Return Value:

        TRUE if read is completed
--*/

{
    DWORD NumSpaces;
    SHORT ScrollY=0;
    ULONG NumToWrite;
    WCHAR wchOrig = Char;
    BOOL fStartFromDelim;

    *Status = STATUS_SUCCESS;
    if (CookedReadData->BytesRead >= (CookedReadData->BufferSize-(2*sizeof(WCHAR))) &&
        Char != UNICODE_CARRIAGERETURN &&
        Char != UNICODE_BACKSPACE) {
        return FALSE;
    }

    if (CookedReadData->CtrlWakeupMask != 0 &&
        Char < L' ' && (CookedReadData->CtrlWakeupMask & (1 << Char))) {
        *CookedReadData->BufPtr = Char;
        CookedReadData->BytesRead += sizeof(WCHAR);
        CookedReadData->BufPtr+=1;
        CookedReadData->CurrentPosition+=1;
        CookedReadData->ControlKeyState = KeyState;
        return TRUE;
    }


    if (Char == EXTKEY_ERASE_PREV_WORD) {
        Char = UNICODE_BACKSPACE;

    }
    if (AT_EOL(CookedReadData)) {

        //
        // if at end of line, processing is relatively simple. just store the
        // character and write it to the screen.
        //


        if (Char == UNICODE_BACKSPACE2) {
            Char = UNICODE_BACKSPACE;
        }
        if (Char != UNICODE_BACKSPACE ||
            CookedReadData->BufPtr != CookedReadData->BackupLimit) {

            fStartFromDelim = gExtendedEditKey && IS_WORD_DELIM(CookedReadData->BufPtr[-1]);

eol_repeat:
            if (CookedReadData->Echo) {
                NumToWrite=sizeof(WCHAR);
                *Status = WriteCharsFromInput(CookedReadData->ScreenInfo,
                                    CookedReadData->BackupLimit,
                                    CookedReadData->BufPtr,
                                    &Char,
                                    &NumToWrite,
                                    (PLONG)&NumSpaces,
                                    CookedReadData->OriginalCursorPosition.X,
                                    WC_DESTRUCTIVE_BACKSPACE |
                                            WC_KEEP_CURSOR_VISIBLE | WC_ECHO,
                                    &ScrollY
                                    );
                if (NT_SUCCESS(*Status)) {
                    CookedReadData->OriginalCursorPosition.Y += ScrollY;
                } else {
                    RIPMSG1(RIP_WARNING, "WriteCharsFromInput failed %x", *Status);
                }
            }
            CookedReadData->NumberOfVisibleChars += NumSpaces;
            if (Char == UNICODE_BACKSPACE && CookedReadData->Processed) {
                CookedReadData->BytesRead -= sizeof(WCHAR);
                *CookedReadData->BufPtr=(WCHAR)' ';
                CookedReadData->BufPtr-=1;
                CookedReadData->CurrentPosition-=1;

                // Repeat until it hits the word boundary
                if (gExtendedEditKey &&
                        wchOrig == EXTKEY_ERASE_PREV_WORD &&
                        CookedReadData->BufPtr != CookedReadData->BackupLimit &&
                        fStartFromDelim ^ !IS_WORD_DELIM(CookedReadData->BufPtr[-1])) {
                    goto eol_repeat;
                }
            }
            else {
                *CookedReadData->BufPtr = Char;
                CookedReadData->BytesRead += sizeof(WCHAR);
                CookedReadData->BufPtr+=1;
                CookedReadData->CurrentPosition+=1;
            }
        }
    } else {
        BOOL CallWrite=TRUE;

        //
        // processing in the middle of the line is more complex:
        //
        //
        // calculate new cursor position
        // store new char
        // clear the current command line from the screen
        // write the new command line to the screen
        // update the cursor position
        //

        if (Char == UNICODE_BACKSPACE && CookedReadData->Processed) {

            //
            // for backspace, use writechars to calculate the new cursor position.
            // this call also sets the cursor to the right position for the
            // second call to writechars.
            //
            if (CookedReadData->BufPtr != CookedReadData->BackupLimit) {

                fStartFromDelim = gExtendedEditKey && IS_WORD_DELIM(CookedReadData->BufPtr[-1]);

bs_repeat:

                //
                // we call writechar here so that cursor position gets updated
                // correctly.  we also call it later if we're not at eol so
                // that the remainder of the string can be updated correctly.
                //

                if (CookedReadData->Echo) {
                    NumToWrite=sizeof(WCHAR);
                    *Status = WriteCharsFromInput(CookedReadData->ScreenInfo,
                             CookedReadData->BackupLimit,
                             CookedReadData->BufPtr,
                             &Char,
                             &NumToWrite,
                             NULL,
                             CookedReadData->OriginalCursorPosition.X,
                             WC_DESTRUCTIVE_BACKSPACE |
                                     WC_KEEP_CURSOR_VISIBLE | WC_ECHO,
                             NULL);

                    if (!NT_SUCCESS(*Status)) {
                        RIPMSG1(RIP_WARNING, "WriteCharsFromInput failed %x", *Status);
                    }
                }
                CookedReadData->BytesRead -= sizeof(WCHAR);
                CookedReadData->BufPtr-=1;
                CookedReadData->CurrentPosition-=1;
                RtlCopyMemory(CookedReadData->BufPtr,
                       CookedReadData->BufPtr+1,
                       CookedReadData->BytesRead - (CookedReadData->CurrentPosition * sizeof(WCHAR))
                      );
#if defined(FE_SB)
                {
                    PWCHAR buf = (PWCHAR)((PBYTE)CookedReadData->BackupLimit +
                                                 CookedReadData->BytesRead    );
                    *buf = (WCHAR)' ';
                }
#endif
                NumSpaces = 0;

                // Repeat until it hits the word boundary
                if (gExtendedEditKey &&
                        wchOrig == EXTKEY_ERASE_PREV_WORD &&
                        CookedReadData->BufPtr != CookedReadData->BackupLimit &&
                        fStartFromDelim ^ !IS_WORD_DELIM(CookedReadData->BufPtr[-1])) {
                    goto bs_repeat;
                }
            } else {
                 CallWrite = FALSE;
            }
        } else {

            //
            // store the char
            //

            if (Char == UNICODE_CARRIAGERETURN) {
                CookedReadData->BufPtr = (PWCHAR)((PBYTE)CookedReadData->BackupLimit + CookedReadData->BytesRead);
                *CookedReadData->BufPtr = Char;
                CookedReadData->BufPtr+=1;
                CookedReadData->BytesRead += sizeof(WCHAR);
                CookedReadData->CurrentPosition += 1;
            } else {
#if defined(FE_SB)
                BOOL fBisect = FALSE;
                if (CookedReadData->Echo) {
                    if (CheckBisectProcessW(CookedReadData->ScreenInfo,
                                            CookedReadData->ScreenInfo->Console->CP,
                                            CookedReadData->BackupLimit,
                                            CookedReadData->CurrentPosition+1,
                                            CookedReadData->ScreenInfo->ScreenBufferSize.X
                                             -CookedReadData->OriginalCursorPosition.X,
                                            CookedReadData->OriginalCursorPosition.X,
                                            TRUE)) {
                        fBisect = TRUE;
                    }
                }
#endif
                if (INSERT_MODE(CookedReadData)) {
                    memmove(CookedReadData->BufPtr+1,
                            CookedReadData->BufPtr,
                            CookedReadData->BytesRead - (CookedReadData->CurrentPosition * sizeof(WCHAR))
                           );
                    CookedReadData->BytesRead += sizeof(WCHAR);
                }
                *CookedReadData->BufPtr = Char;
                CookedReadData->BufPtr+=1;
                CookedReadData->CurrentPosition += 1;

                //
                // calculate new cursor position
                //

                if (CookedReadData->Echo) {
                    NumSpaces = RetrieveNumberOfSpaces(CookedReadData->OriginalCursorPosition.X,
                                                       CookedReadData->BackupLimit,
                                                       CookedReadData->CurrentPosition-1
#if defined(FE_SB)
                                                       ,
                                                       CookedReadData->ScreenInfo->Console,
                                                       CookedReadData->ScreenInfo->Console->CP
#endif
                                                      );
#if defined(FE_SB)
                    if (NumSpaces > 0 && fBisect)
                        NumSpaces--;
#endif
                }
            }
        }

        if (CookedReadData->Echo && CallWrite) {

            COORD CursorPosition;

            //
            // save cursor position
            //

            CursorPosition = CookedReadData->ScreenInfo->BufferInfo.TextInfo.CursorPosition;
            CursorPosition.X = (SHORT)(CursorPosition.X+NumSpaces);

            //
            // clear the current command line from the screen
            //

            DeleteCommandLine(CookedReadData,
                              FALSE);

            //
            // write the new command line to the screen
            //

            NumToWrite = CookedReadData->BytesRead;
            *Status = WriteCharsFromInput(CookedReadData->ScreenInfo,
                                CookedReadData->BackupLimit,
                                CookedReadData->BackupLimit,
                                CookedReadData->BackupLimit,
                                &NumToWrite,
                                (PLONG)&CookedReadData->NumberOfVisibleChars,
                                CookedReadData->OriginalCursorPosition.X,
                                (Char != UNICODE_CARRIAGERETURN) ?
                                     WC_DESTRUCTIVE_BACKSPACE | WC_ECHO :
                                     WC_DESTRUCTIVE_BACKSPACE | WC_KEEP_CURSOR_VISIBLE | WC_ECHO,
                                &ScrollY
                                );
            if (!NT_SUCCESS(*Status)) {
                RIPMSG1(RIP_WARNING, "WriteCharsFromInput failed %x", *Status);
                CookedReadData->BytesRead = 0;
                return TRUE;
            }

            //
            // update cursor position
            //

            if (Char != UNICODE_CARRIAGERETURN) {
#if defined(FE_SB)
                if (CheckBisectProcessW(CookedReadData->ScreenInfo,
                                        CookedReadData->ScreenInfo->Console->CP,
                                        CookedReadData->BackupLimit,
                                        CookedReadData->CurrentPosition+1,
                                        CookedReadData->ScreenInfo->ScreenBufferSize.X
                                         -CookedReadData->OriginalCursorPosition.X,
                                        CookedReadData->OriginalCursorPosition.X,
                                        TRUE)) {
                    if (CursorPosition.X == (CookedReadData->ScreenInfo->ScreenBufferSize.X-1))
                        CursorPosition.X++;
                }
#endif

                // adjust cursor position for WriteChars
                CookedReadData->OriginalCursorPosition.Y += ScrollY;
                CursorPosition.Y += ScrollY;
                *Status = AdjustCursorPosition(CookedReadData->ScreenInfo,
                                              CursorPosition,
                                              TRUE,
                                              NULL);
                ASSERT(NT_SUCCESS(*Status));
                if (!NT_SUCCESS(*Status)) {
                    CookedReadData->BytesRead = 0;
                    return TRUE;
                }
            }
        }
    }

    //
    // in cooked mode, enter (carriage return) is converted to
    // carriage return linefeed (0xda).  carriage return is always
    // stored at the end of the buffer.
    //

    if (Char == UNICODE_CARRIAGERETURN) {
        if (CookedReadData->Processed) {
            if (CookedReadData->BytesRead < CookedReadData->BufferSize) {
                *CookedReadData->BufPtr = UNICODE_LINEFEED;
                if (CookedReadData->Echo) {
                    NumToWrite=sizeof(WCHAR);
                    *Status = WriteCharsFromInput(CookedReadData->ScreenInfo,
                             CookedReadData->BackupLimit,
                             CookedReadData->BufPtr,
                             CookedReadData->BufPtr,
                             &NumToWrite,
                             NULL,
                             CookedReadData->OriginalCursorPosition.X,
                             WC_DESTRUCTIVE_BACKSPACE |
                                     WC_KEEP_CURSOR_VISIBLE | WC_ECHO,
                             NULL);

                    if (!NT_SUCCESS(*Status)) {
                        RIPMSG1(RIP_WARNING, "WriteCharsFromInput failed %x", *Status);
                    }
                }
                CookedReadData->BytesRead += sizeof(WCHAR);
                CookedReadData->BufPtr++;
                CookedReadData->CurrentPosition += 1;
            }
        }
        //
        // reset the cursor back to 25% if necessary
        //
        if (CookedReadData->Line) {
            if (CookedReadData->InsertMode != CookedReadData->Console->InsertMode) {
                ProcessCommandLine(CookedReadData,VK_INSERT,0,NULL,NULL,FALSE); // make cursor small
            }
            *Status = STATUS_SUCCESS;
            return TRUE;
        }
    }
    return FALSE;
}

NTSTATUS
CookedRead(
    IN PCOOKED_READ_DATA CookedReadData,
    IN PCSR_API_MSG WaitReplyMessage,
    IN PCSR_THREAD WaitingThread,
    IN BOOLEAN WaitRoutine
    )
{
    WCHAR Char;
    BOOLEAN CommandLineEditingKeys,EnableScrollMode;
    DWORD KeyState;
    NTSTATUS Status=STATUS_SUCCESS;
    PCONSOLE_READCONSOLE_MSG a;
    PHANDLE_DATA HandleData;
#ifdef FE_SB
    DWORD NumBytes;
    ULONG NumToWrite;
    BOOL fAddDbcsLead = FALSE;
#endif

    Status = DereferenceIoHandleNoCheck(CookedReadData->ProcessData,
                                        CookedReadData->HandleIndex,
                                        &HandleData
                                       );
    if (!NT_SUCCESS(Status)) {
        CookedReadData->BytesRead = 0;
        ConsoleHeapFree(CookedReadData->BackupLimit); 
        return Status;
    }

    a = (PCONSOLE_READCONSOLE_MSG)&WaitReplyMessage->u.ApiMessageData;
    while (CookedReadData->BytesRead < CookedReadData->BufferSize) {

        //
        // this call to GetChar may block.
        //

        Status = GetChar(CookedReadData->InputInfo,
                         &Char,
                         TRUE,
                         CookedReadData->Console,
                         HandleData,
                         WaitReplyMessage,
                         CookedReadWaitRoutine,
                         CookedReadData,
                         sizeof(*CookedReadData),
                         WaitRoutine,
                         &CommandLineEditingKeys,
                         NULL,
                         &EnableScrollMode,
                         &KeyState
                        );
        if (!NT_SUCCESS(Status)) {
            if (Status != CONSOLE_STATUS_WAIT) {
                CookedReadData->BytesRead = 0;
            }
            break;
        }

        //
        // we should probably set these up in GetChars, but we set them
        // up here because the debugger is multi-threaded and calls
        // read before outputting the prompt.
        //

        if (CookedReadData->OriginalCursorPosition.X == -1) {
            CookedReadData->OriginalCursorPosition = CookedReadData->ScreenInfo->BufferInfo.TextInfo.CursorPosition;
        }

        if (CommandLineEditingKeys) {
            Status = ProcessCommandLine(CookedReadData,Char,KeyState,WaitReplyMessage,WaitingThread,WaitRoutine);
            if (Status == CONSOLE_STATUS_READ_COMPLETE ||
                Status == CONSOLE_STATUS_WAIT) {
                break;
            }
            if (!NT_SUCCESS(Status)) {
                if (Status == CONSOLE_STATUS_WAIT_NO_BLOCK) {
                    Status = CONSOLE_STATUS_WAIT;
                    if (!WaitRoutine) {
                        //
                        // we have no wait block, so create one.
                        //
                        WaitForMoreToRead(CookedReadData->InputInfo,
                                          WaitReplyMessage,
                                          CookedReadWaitRoutine,
                                          CookedReadData,
                                          sizeof(*CookedReadData),
                                          FALSE
                                         );
                    }
                } else {
                    CookedReadData->BytesRead = 0;
                }
                break;
            }
        } else {
            if (ProcessCookedReadInput(CookedReadData,
                                       Char,
                                       KeyState,
                                       &Status
                                      )) {
                CookedReadData->Console->Flags |= CONSOLE_IGNORE_NEXT_KEYUP;
                break;
            }
        }
    }

    //
    // if the read was completed (status != wait), free the cooked read
    // data.  also, close the temporary output handle that was opened to
    // echo the characters read.
    //

    if (Status != CONSOLE_STATUS_WAIT) {

        DWORD LineCount=1;
        if (CookedReadData->Echo) {
            BOOLEAN FoundCR;
            ULONG i,StringLength;
            PWCHAR StringPtr;

            // figure out where real string ends (at carriage return
            // or end of buffer)

            StringPtr = CookedReadData->BackupLimit;
            StringLength = CookedReadData->BytesRead;
            FoundCR = FALSE;
            for (i=0;i<(CookedReadData->BytesRead/sizeof(WCHAR));i++) {
                if (*StringPtr++ == UNICODE_CARRIAGERETURN) {
                    StringLength = i*sizeof(WCHAR);
                    FoundCR = TRUE;
                    break;
                }
            }

            if (FoundCR) {
                //
                // add to command line recall list
                //

                AddCommand(CookedReadData->CommandHistory,CookedReadData->BackupLimit,(USHORT)StringLength,CookedReadData->Console->Flags & CONSOLE_HISTORY_NODUP);

                //
                // check for alias
                //

                i = CookedReadData->BufferSize;
                if (NT_SUCCESS(MatchandCopyAlias(CookedReadData->Console,
                                                 CookedReadData->BackupLimit,
                                                 (USHORT)StringLength,
                                                 CookedReadData->BackupLimit,
                                                 (PUSHORT)&i,
                                                 CookedReadData->ExeName,
                                                 CookedReadData->ExeNameLength,
                                                 &LineCount
                                                ))) {
                  CookedReadData->BytesRead = i;
                }
            }

            //
            // Close the handle - unless ProcessCommandListInput already did it.
            //

            if (Status != CONSOLE_STATUS_READ_COMPLETE) {
                CloseOutputHandle(CONSOLE_FROMTHREADPERPROCESSDATA(WaitingThread),
                                  CookedReadData->Console,
                                  &CookedReadData->TempHandle,
                                  NULL,
                                  FALSE
                                 );
            }
        }
        WaitReplyMessage->ReturnValue = Status;

        //
        // at this point, a->NumBytes contains the number of bytes in
        // the UNICODE string read.  UserBufferSize contains the converted
        // size of the app's buffer.
        //

        if (CookedReadData->BytesRead > CookedReadData->UserBufferSize || LineCount > 1) {
            if (LineCount > 1) {
                PWSTR Tmp;
                HandleData->InputReadData->InputHandleFlags |= HANDLE_MULTI_LINE_INPUT;
#ifdef FE_SB
                if (!a->Unicode && CONSOLE_IS_DBCS_CP(CookedReadData->Console)) {
                    if (HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte.Event.KeyEvent.uChar.AsciiChar) {
                        fAddDbcsLead = TRUE;
                        *CookedReadData->UserBuffer++ = HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte.Event.KeyEvent.uChar.AsciiChar;
                        CookedReadData->UserBufferSize-=sizeof(WCHAR);
                        RtlZeroMemory(&HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte,sizeof(INPUT_RECORD));
                    }
                    NumBytes = 0;
                    for (Tmp=CookedReadData->BackupLimit;
                         *Tmp!=UNICODE_LINEFEED && CookedReadData->UserBufferSize/sizeof(WCHAR) > NumBytes;
                         (IsConsoleFullWidth(CookedReadData->Console->hDC,
                                             CookedReadData->Console->CP,*Tmp) ? NumBytes+=2 : NumBytes++),Tmp++) ;
                }
#endif
                for (Tmp=CookedReadData->BackupLimit;*Tmp!=UNICODE_LINEFEED;Tmp++)
                    ASSERT(Tmp<(CookedReadData->BackupLimit+CookedReadData->BytesRead));
                a->NumBytes = (ULONG)(Tmp-CookedReadData->BackupLimit+1)*sizeof(*Tmp);
            } else {
#ifdef FE_SB
                if (!a->Unicode && CONSOLE_IS_DBCS_CP(CookedReadData->Console)) {
                    PWSTR Tmp;

                    if (HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte.Event.KeyEvent.uChar.AsciiChar) {
                        fAddDbcsLead = TRUE;
                        *CookedReadData->UserBuffer++ = HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte.Event.KeyEvent.uChar.AsciiChar;
                        CookedReadData->UserBufferSize-=sizeof(WCHAR);
                        RtlZeroMemory(&HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte,sizeof(INPUT_RECORD));
                    }
                    NumBytes = 0;
                    NumToWrite = CookedReadData->BytesRead;
                    for (Tmp=CookedReadData->BackupLimit;
                         NumToWrite && CookedReadData->UserBufferSize/sizeof(WCHAR) > NumBytes;
                         (IsConsoleFullWidth(CookedReadData->Console->hDC,
                                             CookedReadData->Console->CP,*Tmp) ? NumBytes+=2 : NumBytes++),Tmp++,NumToWrite-=sizeof(WCHAR)) ;
                }
#endif
                a->NumBytes = CookedReadData->UserBufferSize;
            }
            HandleData->InputReadData->InputHandleFlags |= HANDLE_INPUT_PENDING;
            HandleData->InputReadData->BufPtr = CookedReadData->BackupLimit;
            HandleData->InputReadData->BytesAvailable = CookedReadData->BytesRead - a->NumBytes;
            HandleData->InputReadData->CurrentBufPtr=(PWCHAR)((PBYTE)CookedReadData->BackupLimit+a->NumBytes);
            RtlCopyMemory(CookedReadData->UserBuffer,CookedReadData->BackupLimit,a->NumBytes);
        }
        else {
#ifdef FE_SB
            if (!a->Unicode && CONSOLE_IS_DBCS_CP(CookedReadData->Console)) {
                PWSTR Tmp;

                if (HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte.Event.KeyEvent.uChar.AsciiChar) {
                    fAddDbcsLead = TRUE;
                    *CookedReadData->UserBuffer++ = HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte.Event.KeyEvent.uChar.AsciiChar;
                    CookedReadData->UserBufferSize-=sizeof(WCHAR);
                    RtlZeroMemory(&HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte,sizeof(INPUT_RECORD));

                    if (CookedReadData->UserBufferSize == 0) {
                        a->NumBytes = 1;
                        ConsoleHeapFree(CookedReadData->BackupLimit);
                        return STATUS_SUCCESS;
                    }
                }
                NumBytes = 0;
                NumToWrite = CookedReadData->BytesRead;
                for (Tmp=CookedReadData->BackupLimit;
                     NumToWrite && CookedReadData->UserBufferSize/sizeof(WCHAR) > NumBytes;
                     (IsConsoleFullWidth(CookedReadData->Console->hDC,
                                         CookedReadData->Console->CP,*Tmp) ? NumBytes+=2 : NumBytes++),Tmp++,NumToWrite-=sizeof(WCHAR)) ;
            }
#endif
            a->NumBytes = CookedReadData->BytesRead;
            RtlCopyMemory(CookedReadData->UserBuffer,CookedReadData->BackupLimit,a->NumBytes);
            ConsoleHeapFree(CookedReadData->BackupLimit);
        }
        a->ControlKeyState = CookedReadData->ControlKeyState;

        if (!a->Unicode) {

            //
            // if ansi, translate string.
            //

            PCHAR TransBuffer;

#ifdef FE_SB
            if (CONSOLE_IS_DBCS_CP(CookedReadData->Console))
                TransBuffer = (PCHAR)ConsoleHeapAlloc(MAKE_TAG( TMP_DBCS_TAG ),NumBytes);
            else
#endif
            TransBuffer = (PCHAR)ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ),a->NumBytes / sizeof(WCHAR));
            if (TransBuffer == NULL) {
                return STATUS_NO_MEMORY;
            }

#ifdef FE_SB
            if (CONSOLE_IS_DBCS_CP(CookedReadData->Console))
            {
                a->NumBytes = TranslateUnicodeToOem(CookedReadData->Console,
                                                    CookedReadData->UserBuffer,
                                                    a->NumBytes / sizeof (WCHAR),
                                                    TransBuffer,
                                                    NumBytes,
                                                    &HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte);
            }
            else
#endif
            a->NumBytes = ConvertToOem(CookedReadData->Console->CP,
                                 CookedReadData->UserBuffer,
                                 a->NumBytes / sizeof (WCHAR),
                                 TransBuffer,
                                 a->NumBytes / sizeof (WCHAR)
                                 );
            RtlCopyMemory(CookedReadData->UserBuffer,TransBuffer,a->NumBytes);
#ifdef FE_SB
            if (fAddDbcsLead)
                a->NumBytes++;
#endif
            ConsoleHeapFree(TransBuffer);
        }
        ConsoleHeapFree(CookedReadData->ExeName);
        if (WaitRoutine) {
#ifdef FE_SB
            CookedReadData->Console->lpCookedReadData = NULL;
#endif
            ConsoleHeapFree(CookedReadData);
        }
    }
    return Status;
}

BOOLEAN
CookedReadWaitRoutine(
    IN PLIST_ENTRY WaitQueue,
    IN PCSR_THREAD WaitingThread,
    IN PCSR_API_MSG WaitReplyMessage,
    IN PVOID WaitParameter,
    IN PVOID SatisfyParameter1,
    IN PVOID SatisfyParameter2,
    IN ULONG WaitFlags
    )

/*++

Routine Description:

    This routine is called to complete a cooked read that blocked in
    ReadInputBuffer.  The context of the read was saved in the CookedReadData
    structure.  This routine is called when events have been written to
    the input buffer.  It is called in the context of the writing thread.
    It may be called more than once.

Arguments:

    WaitQueue - pointer to queue containing wait block

    WaitingThread - pointer to waiting thread

    WaitReplyMessage - pointer to reply message

    CookedReadData - pointer to data saved in ReadChars

    SatisfyParameter1 - if this routine was called (indirectly) by
    CloseInputHandle, this argument contains a HandleData pointer of
    the dying handle.  otherwise, it contains NULL.

    SatisfyParameter2 - if this routine is called because a ctrl-c or
    ctrl-break was seen, this argument contains CONSOLE_CTRL_SEEN.
    otherwise it contains NULL.

    WaitFlags - Flags indicating status of wait.

Return Value:

--*/


{
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PCOOKED_READ_DATA CookedReadData;
    PCONSOLE_READCONSOLE_MSG a;
    PHANDLE_DATA HandleData;

    a = (PCONSOLE_READCONSOLE_MSG)&WaitReplyMessage->u.ApiMessageData;
    CookedReadData = (PCOOKED_READ_DATA)WaitParameter;

    Status = DereferenceIoHandleNoCheck(CookedReadData->ProcessData,
                                        CookedReadData->HandleIndex,
                                        &HandleData
                                       );
    ASSERT (NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status)) {
        return TRUE;
    }
    ASSERT(!(HandleData->InputReadData->InputHandleFlags & HANDLE_INPUT_PENDING));

    //
    // see if this routine was called by CloseInputHandle.  if it
    // was, see if this wait block corresponds to the dying handle.
    // if it doesn't, just return.
    //

    if (SatisfyParameter1 != NULL &&
        SatisfyParameter1 != HandleData) {
        //DbgPrint("CookedReadWaitRoutine exit 1\n");
        return FALSE;
    }

    Console = CookedReadData->Console;

    //
    // this routine should be called by a thread owning the same
    // lock on the same console as we're reading from.
    //

    LockReadCount(HandleData);
    ASSERT(HandleData->InputReadData->ReadCount);
    HandleData->InputReadData->ReadCount -= 1;
    UnlockReadCount(HandleData);

    //
    // if ctrl-c or ctrl-break was seen, terminate read.
    //

    if ((ULONG_PTR)SatisfyParameter2 & (CONSOLE_CTRL_C_SEEN | CONSOLE_CTRL_BREAK_SEEN)) {
        if (CookedReadData->Echo) {
            CloseOutputHandle(CONSOLE_FROMTHREADPERPROCESSDATA(WaitingThread),
                              CookedReadData->Console,
                              &CookedReadData->TempHandle,
                              NULL,
                              FALSE
                             );
        }
        //DbgPrint("CookedReadWaitRoutine exit 2\n");
        WaitReplyMessage->ReturnValue = STATUS_ALERTED;
        ConsoleHeapFree(CookedReadData->BackupLimit);
        ConsoleHeapFree(CookedReadData->ExeName);
#if defined(FE_SB)
        CookedReadData->Console->lpCookedReadData = NULL;
#endif
        ConsoleHeapFree(CookedReadData);
        return TRUE;
    }

    //
    // see if called by CsrDestroyProcess or CsrDestroyThread
    // via CsrNotifyWaitBlock.   if so, just decrement the ReadCount
    // and return.
    //

    if (WaitFlags & CSR_PROCESS_TERMINATING) {
        if (CookedReadData->Echo) {
            CloseOutputHandle(CONSOLE_FROMTHREADPERPROCESSDATA(WaitingThread),
                              CookedReadData->Console,
                              &CookedReadData->TempHandle,
                              NULL,
                              FALSE
                             );
        }
        //DbgPrint("CookedReadWaitRoutine exit 3\n");
        WaitReplyMessage->ReturnValue = (ULONG)STATUS_THREAD_IS_TERMINATING;

        //
        // clean up popup data structures
        //

        CleanUpPopups(CookedReadData);
        ConsoleHeapFree(CookedReadData->BackupLimit);
        ConsoleHeapFree(CookedReadData->ExeName);
#if defined(FE_SB)
        CookedReadData->Console->lpCookedReadData = NULL;
#endif
        ConsoleHeapFree(CookedReadData);
        return TRUE;
    }

    //
    // We must see if we were woken up because the handle is being
    // closed.  if so, we decrement the read count.  if it goes to
    // zero, we wake up the close thread.  otherwise, we wake up any
    // other thread waiting for data.
    //

    if (HandleData->InputReadData->InputHandleFlags & HANDLE_CLOSING) {
        ASSERT (SatisfyParameter1 == HandleData);
        if (CookedReadData->Echo) {
            CloseOutputHandle(CONSOLE_FROMTHREADPERPROCESSDATA(WaitingThread),
                              CookedReadData->Console,
                              &CookedReadData->TempHandle,
                              NULL,
                              FALSE
                             );
        }
        //DbgPrint("CookedReadWaitRoutine exit 4\n");
        WaitReplyMessage->ReturnValue = STATUS_ALERTED;

        //
        // clean up popup data structures
        //

        CleanUpPopups(CookedReadData);
        ConsoleHeapFree(CookedReadData->BackupLimit);
        ConsoleHeapFree(CookedReadData->ExeName);
#if defined(FE_SB)
        CookedReadData->Console->lpCookedReadData = NULL;
#endif
        ConsoleHeapFree(CookedReadData);
        return TRUE;
    }

    //
    // if we get to here, this routine was called either by the input
    // thread or a write routine.  both of these callers grab the
    // current console lock.
    //

    //
    // this routine should be called by a thread owning the same
    // lock on the same console as we're reading from.
    //

    ASSERT (ConsoleLocked(Console));

    if (CookedReadData->CommandHistory) {
        PCLE_POPUP Popup;
        if (!CLE_NO_POPUPS(CookedReadData->CommandHistory)) {
            Popup = CONTAINING_RECORD( CookedReadData->CommandHistory->PopupList.Flink, CLE_POPUP, ListLink );
            Status = (Popup->PopupInputRoutine)(CookedReadData,
                                                WaitReplyMessage,
                                                WaitingThread,
                                                TRUE);
            if (Status == CONSOLE_STATUS_READ_COMPLETE ||
                (Status != CONSOLE_STATUS_WAIT &&
                 Status != CONSOLE_STATUS_WAIT_NO_BLOCK) ) {
                ConsoleHeapFree(CookedReadData->BackupLimit);
                ConsoleHeapFree(CookedReadData->ExeName);
#if defined(FE_SB)
                CookedReadData->Console->lpCookedReadData = NULL;
#endif
                ConsoleHeapFree(CookedReadData);
                return TRUE;
            }
            return FALSE;
        }
    }
    if (a->CaptureBufferSize <= BUFFER_SIZE &&
        CookedReadData->BytesRead == 0) {
        CookedReadData->UserBuffer = a->Buffer;
    }
    Status = CookedRead(CookedReadData,
                        WaitReplyMessage,
                        WaitingThread,
                        TRUE
                       );

    if (Status != CONSOLE_STATUS_WAIT) {
        return TRUE;
    } else {
        return FALSE;
    }

    //
    // satisfy the unreferenced parameter warnings.
    //

    UNREFERENCED_PARAMETER(WaitQueue);
    UNREFERENCED_PARAMETER(SatisfyParameter2);
}


NTSTATUS
ReadChars(
    IN PINPUT_INFORMATION InputInfo,
    IN PCONSOLE_INFORMATION Console,
    IN PCONSOLE_PER_PROCESS_DATA ProcessData,
    IN PSCREEN_INFORMATION ScreenInfo,
    IN OUT PWCHAR lpBuffer,
    IN OUT PDWORD NumBytes,
    IN DWORD InitialNumBytes,
    IN DWORD CtrlWakeupMask,
    IN PHANDLE_DATA HandleData,
    IN PCOMMAND_HISTORY CommandHistory,
    IN PCSR_API_MSG Message OPTIONAL,
    IN HANDLE HandleIndex,
    IN USHORT ExeNameLength,
    IN PWCHAR ExeName,
    IN BOOLEAN Unicode
    )

/*++

Routine Description:

    This routine reads in characters for stream input and does the
    required processing based on the input mode (line,char,echo).
    This routine returns UNICODE characters.

Arguments:

    InputInfo - Pointer to input buffer information.

    Console - Pointer to console buffer information.

    ScreenInfo - Pointer to screen buffer information.

    lpBuffer - Pointer to buffer to read into.

    NumBytes - On input, size of buffer.  On output, number of bytes
    read.

    HandleData - Pointer to handle data structure.

Return Value:

--*/

{
    DWORD BufferSize;
    NTSTATUS Status;
    HANDLE_DATA TempHandle;
    BOOLEAN Echo = FALSE;
    ULONG NumToWrite;
#ifdef FE_SB
    PCONSOLE_READCONSOLE_MSG a = (PCONSOLE_READCONSOLE_MSG)&Message->u.ApiMessageData;
    BOOL fAddDbcsLead = FALSE;
    ULONG NumToBytes;
#endif

    BufferSize = *NumBytes;
    *NumBytes = 0;

    if (HandleData->InputReadData->InputHandleFlags & HANDLE_INPUT_PENDING) {

        //
        // if we have leftover input, copy as much fits into the user's
        // buffer and return.  we may have multi line input, if a macro
        // has been defined that contains the $T character.
        //

        if (HandleData->InputReadData->InputHandleFlags & HANDLE_MULTI_LINE_INPUT) {
            PWSTR Tmp;
#ifdef FE_SB
            if (!Unicode && CONSOLE_IS_DBCS_CP(Console)) {

                if (HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte.Event.KeyEvent.uChar.AsciiChar) {
                    fAddDbcsLead = TRUE;
                    *lpBuffer++ = HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte.Event.KeyEvent.uChar.AsciiChar;
                    BufferSize--;
                    HandleData->InputReadData->BytesAvailable--;
                    RtlZeroMemory(&HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte,sizeof(INPUT_RECORD));
                }
                if (HandleData->InputReadData->BytesAvailable == 0 ||
                    BufferSize == 0) {
                    HandleData->InputReadData->InputHandleFlags &= ~(HANDLE_INPUT_PENDING | HANDLE_MULTI_LINE_INPUT);
                    ConsoleHeapFree(HandleData->InputReadData->BufPtr);
                    *NumBytes = 1;
                    return STATUS_SUCCESS;
                }
                else {
                    for (NumToWrite=0,Tmp=HandleData->InputReadData->CurrentBufPtr,NumToBytes=0;
                         NumToBytes < HandleData->InputReadData->BytesAvailable && NumToBytes < BufferSize/sizeof(WCHAR) && *Tmp!=UNICODE_LINEFEED;
                         (IsConsoleFullWidth(Console->hDC,
                                             Console->CP,*Tmp) ? NumToBytes+=2 : NumToBytes++),Tmp++,NumToWrite+=sizeof(WCHAR)) ;
                }
            }
#endif
            for (NumToWrite=0,Tmp=HandleData->InputReadData->CurrentBufPtr;
                 NumToWrite < HandleData->InputReadData->BytesAvailable && *Tmp!=UNICODE_LINEFEED;
                 Tmp++,NumToWrite+=sizeof(WCHAR)) ;
            NumToWrite += sizeof(WCHAR);
            if (NumToWrite > BufferSize) {
                NumToWrite = BufferSize;
            }
        } else {
#ifdef FE_SB
            if (!Unicode && CONSOLE_IS_DBCS_CP(Console)) {
                PWSTR Tmp;

                if (HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte.Event.KeyEvent.uChar.AsciiChar) {
                    fAddDbcsLead = TRUE;
                    *lpBuffer++ = HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte.Event.KeyEvent.uChar.AsciiChar;
                    BufferSize-=sizeof(WCHAR);
                    HandleData->InputReadData->BytesAvailable-=sizeof(WCHAR);
                    RtlZeroMemory(&HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte,sizeof(INPUT_RECORD));
                }
                if (HandleData->InputReadData->BytesAvailable == 0) {
                    HandleData->InputReadData->InputHandleFlags &= ~(HANDLE_INPUT_PENDING | HANDLE_MULTI_LINE_INPUT);
                    ConsoleHeapFree(HandleData->InputReadData->BufPtr);
                    *NumBytes = 1;
                    return STATUS_SUCCESS;
                }
                else {
                    for (NumToWrite=0,Tmp=HandleData->InputReadData->CurrentBufPtr,NumToBytes=0;
                         NumToBytes < HandleData->InputReadData->BytesAvailable && NumToBytes < BufferSize/sizeof(WCHAR);
                         (IsConsoleFullWidth(Console->hDC,
                                             Console->CP,*Tmp) ? NumToBytes+=2 : NumToBytes++),Tmp++,NumToWrite+=sizeof(WCHAR)) ;
                }
            }
#endif
            NumToWrite = (BufferSize < HandleData->InputReadData->BytesAvailable) ?
                          BufferSize : HandleData->InputReadData->BytesAvailable;
        }
        RtlCopyMemory(lpBuffer,HandleData->InputReadData->CurrentBufPtr,NumToWrite);
        HandleData->InputReadData->BytesAvailable-= NumToWrite;
        if (HandleData->InputReadData->BytesAvailable == 0) {
            HandleData->InputReadData->InputHandleFlags &= ~(HANDLE_INPUT_PENDING | HANDLE_MULTI_LINE_INPUT);
            ConsoleHeapFree(HandleData->InputReadData->BufPtr);
        }
        else {
            HandleData->InputReadData->CurrentBufPtr=(PWCHAR)((PBYTE)HandleData->InputReadData->CurrentBufPtr+NumToWrite);
        }
        if (!Unicode) {

            //
            // if ansi, translate string.  we allocated the capture buffer large
            // enough to handle the translated string.
            //

            PCHAR TransBuffer;

#ifdef FE_SB
            if (CONSOLE_IS_DBCS_CP(Console))
                TransBuffer = (PCHAR)ConsoleHeapAlloc(MAKE_TAG( TMP_DBCS_TAG ),NumToBytes);
            else
#endif
            TransBuffer = (PCHAR)ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ),NumToWrite / sizeof(WCHAR));
            if (TransBuffer == NULL) {
                return STATUS_NO_MEMORY;
            }

#ifdef FE_SB
            if (CONSOLE_IS_DBCS_CP(Console))
            {
                NumToWrite = TranslateUnicodeToOem(Console,
                                                   lpBuffer,
                                                   NumToWrite / sizeof (WCHAR),
                                                   TransBuffer,
                                                   NumToBytes,
                                                   &HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte);
            }
            else
#endif
            NumToWrite = ConvertToOem(Console->CP,
                                lpBuffer,
                                NumToWrite / sizeof (WCHAR),
                                TransBuffer,
                                NumToWrite / sizeof (WCHAR)
                                );
            RtlCopyMemory(lpBuffer,TransBuffer,NumToWrite);
#ifdef FE_SB
            if (fAddDbcsLead)
                NumToWrite++;
#endif
            ConsoleHeapFree(TransBuffer);
        }
        *NumBytes = NumToWrite;
        return STATUS_SUCCESS;
    }

    //
    // we need to create a temporary handle to the current screen buffer
    // if echo is on.
    //

    if ((InputInfo->InputMode & (ENABLE_LINE_INPUT | ENABLE_ECHO_INPUT)) ==
        (ENABLE_LINE_INPUT | ENABLE_ECHO_INPUT)) {
        HANDLE ActiveScreenHandle;

        Echo = FALSE;
        ActiveScreenHandle = FindActiveScreenBufferHandle(ProcessData,Console);
        if (ActiveScreenHandle != INVALID_HANDLE_VALUE) {
            TempHandle.HandleType = CONSOLE_OUTPUT_HANDLE;
            TempHandle.Buffer.ScreenBuffer = Console->CurrentScreenBuffer;
            if (TempHandle.Buffer.ScreenBuffer != NULL) {
                Status = ConsoleAddShare(GENERIC_WRITE,
                                         FILE_SHARE_READ | FILE_SHARE_WRITE,
                                         &TempHandle.Buffer.ScreenBuffer->ShareAccess,
                                         &TempHandle
                                        );
                if (NT_SUCCESS(Status)) {
                    Echo = TRUE;
                    TempHandle.Buffer.ScreenBuffer->RefCount++;
                }
            }
        }
    }

    if (InputInfo->InputMode & ENABLE_LINE_INPUT) {

        //
        // read in characters until the buffer is full or return is read.
        // since we may wait inside this loop, store all important variables
        // in the read data structure.  if we do wait, a read data structure
        // will be allocated from the heap and its pointer will be stored
        // in the wait block.  the CookedReadData will be copied into the
        // structure.  the data is freed when the read is completed.
        //

        COOKED_READ_DATA CookedReadData;
        ULONG i;
        PWCHAR TempBuffer;
        ULONG TempBufferSize;

        //
        // to emulate OS/2 KbdStringIn, we read into our own big buffer
        // (256 bytes) until the user types enter.  then return as many
        // chars as will fit in the user's buffer.
        //

        TempBufferSize = (BufferSize < LINE_INPUT_BUFFER_SIZE) ? LINE_INPUT_BUFFER_SIZE : BufferSize;
        TempBuffer = (PWCHAR)ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ),TempBufferSize);
        if (TempBuffer==NULL) {
            if (Echo) {
                CloseOutputHandle(ProcessData,
                                  Console,
                                  &TempHandle,
                                  NULL,
                                  FALSE
                                 );
            }
            return STATUS_NO_MEMORY;
        }

        //
        // initialize the user's buffer to spaces.  this is done so that
        // moving in the buffer via cursor doesn't do strange things.
        //

        for (i=0;i<TempBufferSize/sizeof(WCHAR);i++) {
            TempBuffer[i] = (WCHAR)' ';
        }

        CookedReadData.InputInfo = InputInfo;
        CookedReadData.ScreenInfo = ScreenInfo;
        CookedReadData.Console = Console;
        CookedReadData.TempHandle.HandleType = TempHandle.HandleType;
        CookedReadData.TempHandle.Buffer.ScreenBuffer = TempHandle.Buffer.ScreenBuffer;
        CookedReadData.BufferSize = TempBufferSize;
        CookedReadData.BytesRead = 0;
        CookedReadData.CurrentPosition = 0;
        CookedReadData.BufPtr = TempBuffer;
        CookedReadData.BackupLimit = TempBuffer;
        CookedReadData.UserBufferSize = BufferSize;
        CookedReadData.UserBuffer = lpBuffer;
        CookedReadData.OriginalCursorPosition.X = -1;
        CookedReadData.OriginalCursorPosition.Y = -1;
        CookedReadData.NumberOfVisibleChars = 0;
        CookedReadData.CtrlWakeupMask = CtrlWakeupMask;
        CookedReadData.CommandHistory = CommandHistory;
        CookedReadData.Echo = Echo;
        CookedReadData.InsertMode = Console->InsertMode;
        CookedReadData.Processed = (InputInfo->InputMode & ENABLE_PROCESSED_INPUT) != 0;
        CookedReadData.Line = (InputInfo->InputMode & ENABLE_LINE_INPUT) != 0;
        CookedReadData.ProcessData = ProcessData;
        CookedReadData.HandleIndex = HandleIndex;
        CookedReadData.ExeName = (PWCHAR)ConsoleHeapAlloc(MAKE_TAG( HISTORY_TAG ),ExeNameLength);
        if (InitialNumBytes != 0) {
            RtlCopyMemory(CookedReadData.BufPtr, CookedReadData.UserBuffer, InitialNumBytes);
            CookedReadData.BytesRead += InitialNumBytes;
            CookedReadData.NumberOfVisibleChars = (InitialNumBytes / sizeof(WCHAR));
            CookedReadData.BufPtr += (InitialNumBytes / sizeof(WCHAR));
            CookedReadData.CurrentPosition = (InitialNumBytes / sizeof(WCHAR));
            CookedReadData.OriginalCursorPosition = ScreenInfo->BufferInfo.TextInfo.CursorPosition;
            CookedReadData.OriginalCursorPosition.X -= (SHORT)CookedReadData.CurrentPosition;


            while (CookedReadData.OriginalCursorPosition.X < 0) {
                CookedReadData.OriginalCursorPosition.X += ScreenInfo->ScreenBufferSize.X;
                CookedReadData.OriginalCursorPosition.Y -= 1;
            }
        }
        if (CookedReadData.ExeName) {
            RtlCopyMemory(CookedReadData.ExeName,ExeName,ExeNameLength);
            CookedReadData.ExeNameLength = ExeNameLength;
        }
#ifdef FE_SB
        Console->lpCookedReadData = (PVOID)&CookedReadData;
#endif

        Status = CookedRead(&CookedReadData,
                            Message,
                            CSR_SERVER_QUERYCLIENTTHREAD(),
                            FALSE
                           );
#ifdef FE_SB
        if (Status != CONSOLE_STATUS_WAIT) {
            Console->lpCookedReadData = NULL;
        }
#endif
        return Status;
    }

    //
    // character (raw) mode
    //

    else {

        //
        // read at least one character in.  after one character has been
        // read, get any more available characters and return.  the first
        //  call to GetChar may wait.   if we do wait, a read data structure
        // will be allocated from the heap and its pointer will be stored
        // in the wait block.  the RawReadData will be copied into the
        // structure.  the data is freed when the read is completed.
        //

        RAW_READ_DATA RawReadData;

        RawReadData.InputInfo = InputInfo;
        RawReadData.Console = Console;
        RawReadData.BufferSize = BufferSize;
        RawReadData.BufPtr = lpBuffer;
        RawReadData.ProcessData = ProcessData;
        RawReadData.HandleIndex = HandleIndex;
        if (*NumBytes < BufferSize) {
            PWCHAR pwchT;

#ifdef FE_SB
            PWCHAR lpBufferTmp = lpBuffer;

            NumToWrite = 0;
            if (!Unicode && CONSOLE_IS_DBCS_CP(Console)) {
                if (HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte.Event.KeyEvent.uChar.AsciiChar) {
                    fAddDbcsLead = TRUE;
                    *lpBuffer++ = HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte.Event.KeyEvent.uChar.AsciiChar;
                    BufferSize-=sizeof(WCHAR);
                    RtlZeroMemory(&HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte,sizeof(INPUT_RECORD));
                    Status = STATUS_SUCCESS;
                    if (BufferSize == 0) {
                        *NumBytes = 1;
                        return STATUS_SUCCESS;
                    }
                }
                else{
                    Status = GetChar(InputInfo,
                             lpBuffer,
                             TRUE,
                             Console,
                             HandleData,
                             Message,
                             RawReadWaitRoutine,
                             &RawReadData,
                             sizeof(RawReadData),
                             FALSE,
                             NULL,
                             NULL,
                             NULL,
                             NULL
                            );
                }
            }
            else
#endif
            Status = GetChar(InputInfo,
                             lpBuffer,
                             TRUE,
                             Console,
                             HandleData,
                             Message,
                             RawReadWaitRoutine,
                             &RawReadData,
                             sizeof(RawReadData),
                             FALSE,
                             NULL,
                             NULL,
                             NULL,
                             NULL
                            );

            if (!NT_SUCCESS(Status)) {
                *NumBytes = 0;
                return Status;
            }
#ifdef FE_SB
            if (! fAddDbcsLead) {
                IsConsoleFullWidth(Console->hDC,
                                   Console->CP,*lpBuffer) ? *NumBytes+=2 : ++*NumBytes;
                NumToWrite+=sizeof(WCHAR);
                lpBuffer++;
            }
            if (CONSOLE_IS_DBCS_CP(Console)) {
                while (NumToWrite < BufferSize) {
                    Status = GetChar(InputInfo,lpBuffer,FALSE,NULL,NULL,NULL,NULL,NULL,0,FALSE,NULL,NULL,NULL,NULL);
                    if (!NT_SUCCESS(Status)) {
                        return STATUS_SUCCESS;
                    }
                    IsConsoleFullWidth(Console->hDC,
                                       Console->CP,*lpBuffer) ? *NumBytes+=2 : ++*NumBytes;
                    lpBuffer++;
                    NumToWrite+=sizeof(WCHAR);
                }
            }
            else{
#endif
            pwchT = lpBuffer + 1;
            *NumBytes += sizeof(WCHAR);
            while (*NumBytes < BufferSize) {
                Status = GetChar(InputInfo,pwchT,FALSE,NULL,NULL,NULL,NULL,NULL,0,FALSE,NULL,NULL,NULL,NULL);
                if (!NT_SUCCESS(Status)) {
                    break;
                }
                pwchT++;
                *NumBytes += sizeof(WCHAR);
            }
#ifdef FE_SB
            }
#endif

            //
            // if ansi, translate string.  we allocated the capture buffer large
            // enough to handle the translated string.
            //

            if (!Unicode) {

                PCHAR TransBuffer;

                TransBuffer = (PCHAR)ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ),*NumBytes / sizeof(WCHAR));
                if (TransBuffer == NULL) {
                    return STATUS_NO_MEMORY;
                }

#ifdef FE_SB
                lpBuffer = lpBufferTmp;
                if (CONSOLE_IS_DBCS_CP(Console))
                {
                    *NumBytes = TranslateUnicodeToOem(Console,
                                                      lpBuffer,
                                                      NumToWrite / sizeof (WCHAR),
                                                      TransBuffer,
                                                      *NumBytes,
                                                      &HandleData->Buffer.InputBuffer->ReadConInpDbcsLeadByte);
                }
                else
#endif
                *NumBytes = ConvertToOem(Console->CP,
                                   lpBuffer,
                                   *NumBytes / sizeof (WCHAR),
                                   TransBuffer,
                                   *NumBytes / sizeof (WCHAR)
                                   );
                RtlCopyMemory(lpBuffer,TransBuffer,*NumBytes);
#ifdef FE_SB
                if (fAddDbcsLead)
                    ++*NumBytes;
#endif
                ConsoleHeapFree(TransBuffer);
            }
        }
    }
    return STATUS_SUCCESS;
}


ULONG
SrvReadConsole(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Routine Description:

    This routine reads characters from the input stream.

Arguments:

    ApiMessageData - Points to parameter structure.

Return Value:

--*/

{
    PCONSOLE_READCONSOLE_MSG a = (PCONSOLE_READCONSOLE_MSG)&m->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    NTSTATUS Status;
    PWCHAR Buffer;
    PCONSOLE_PER_PROCESS_DATA ProcessData;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    ProcessData = CONSOLE_PERPROCESSDATA();
    Status = DereferenceIoHandle(ProcessData,
                                 a->InputHandle,
                                 CONSOLE_INPUT_HANDLE,
                                 GENERIC_READ,
                                 &HandleData
                                );
    if (!NT_SUCCESS(Status)) {
        a->NumBytes = 0;
    } else {

        if (a->CaptureBufferSize <= BUFFER_SIZE) {
            Buffer = a->Buffer;
        }
        else {
            Buffer = a->BufPtr;
            if (!CsrValidateMessageBuffer(m, &a->BufPtr, a->CaptureBufferSize, sizeof(BYTE))) {
                UnlockConsole(Console);
                return STATUS_INVALID_PARAMETER;
            }
        }

#if defined(FE_SB)
        Console->ReadConInpNumBytesTemp = a->NumBytes / sizeof(WCHAR);
#endif
        Status = ReadChars(HandleData->Buffer.InputBuffer,
                           Console,
                           ProcessData,
                           Console->CurrentScreenBuffer,
                           Buffer,
                           &a->NumBytes,
                           a->InitialNumBytes,
                           a->CtrlWakeupMask,
                           HandleData,
                           FindCommandHistory(Console,CONSOLE_CLIENTPROCESSHANDLE()),
                           m,
                           HANDLE_TO_INDEX(a->InputHandle),
                           a->ExeNameLength,
                           a->Buffer,
                           a->Unicode
                          );
        if (Status == CONSOLE_STATUS_WAIT) {
            *ReplyStatus = CsrReplyPending;
        }
    }

    UnlockConsole(Console);
    return Status;
}


VOID
MakeCursorVisible(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN COORD CursorPosition
    )
{
    COORD WindowOrigin;
    NTSTATUS Status;

    WindowOrigin.X = 0;
    WindowOrigin.Y = 0;
    if (CursorPosition.X > ScreenInfo->Window.Right) {
        WindowOrigin.X = CursorPosition.X - ScreenInfo->Window.Right;
    } else if (CursorPosition.X < ScreenInfo->Window.Left) {
        WindowOrigin.X = CursorPosition.X - ScreenInfo->Window.Left;
    }

    if (CursorPosition.Y > ScreenInfo->Window.Bottom) {
        WindowOrigin.Y = CursorPosition.Y - ScreenInfo->Window.Bottom;
    } else if (CursorPosition.Y < ScreenInfo->Window.Top) {
        WindowOrigin.Y = CursorPosition.Y - ScreenInfo->Window.Top;
    }

    if (WindowOrigin.X != 0 || WindowOrigin.Y != 0) {
        Status = SetWindowOrigin(ScreenInfo,
                               FALSE,
                               WindowOrigin
                              );
        if (!NT_SUCCESS(Status)) {
            return;
        }
    }
}

#define WRITE_NO_CR_LF 0
#define WRITE_CR 1
#define WRITE_CR_LF 2
#define WRITE_SPECIAL_CHARS 4
#define WRITE_UNICODE_CRLF 0x000a000d

DWORD
FastStreamWrite(
    IN PWCHAR lpString,
    IN DWORD NumChars
    )

/*++

Routine Description:

    This routine determines whether the text string contains characters
    that require special processing.  If it doesn't,
    unicode characters.  The string is also copied to the input buffer, if
    the output mode is line mode.

Arguments:

    lpString - Pointer to string to write.

    NumChars - Number of chars in buffer.

Return Value:

    WRITE_SPECIAL_CHARS - string contains characters requiring special processing

    WRITE_NO_CR_LF - string contains no special chars and no CRLF

    WRITE_CR_LF - string contains no special chars and is terminated by CRLF

    WRITE_CR - string contains no special chars and is terminated by CR

--*/

{
    DWORD UNALIGNED *Tmp;
    register PWCHAR StrPtr=lpString;
    while (NumChars) {
        if (*StrPtr < UNICODE_SPACE) {
            Tmp = (PDWORD)StrPtr;
            if (NumChars == 2 &&
                *Tmp == WRITE_UNICODE_CRLF) {
                return WRITE_CR_LF;
            } else if (NumChars == 1 &&
                *StrPtr == (WCHAR)'\r') {
                return WRITE_CR;
            } else {
                return WRITE_SPECIAL_CHARS;
            }
        }
        StrPtr++;
        NumChars--;
    }
    return WRITE_NO_CR_LF;
}

VOID UnblockWriteConsole(
    IN PCONSOLE_INFORMATION Console,
    IN DWORD Reason)
{
    Console->Flags &= ~Reason;

    if ((Console->Flags & (CONSOLE_SUSPENDED | CONSOLE_SELECTING | CONSOLE_SCROLLBAR_TRACKING)) == 0) {
        /*
         * no remain reason to suspend output, so unblock it.
         */
        if (CsrNotifyWait(&Console->OutputQueue, TRUE, NULL, NULL)) {
            // #334370 under stress, WaitQueue may already hold the satisfied waits
            ASSERT ((Console->WaitQueue == NULL) ||
                    (Console->WaitQueue == &Console->OutputQueue));
            Console->WaitQueue = &Console->OutputQueue;
        }
    }
}


ULONG
SrvWriteConsole(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Routine Description:

    This routine writes characters to the output stream.

Arguments:

    ApiMessageData - Points to parameter structure.

Return Value:

--*/

{
    NTSTATUS Status;
    PCONSOLE_WRITECONSOLE_MSG a = (PCONSOLE_WRITECONSOLE_MSG)&m->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (!a->BufferInMessage) {
        if (!CsrValidateMessageBuffer(m, &a->BufPtr, a->NumBytes, sizeof(BYTE))) {
            UnlockConsole(Console);
            return STATUS_INVALID_PARAMETER;
        }
    }
    else if (a->NumBytes > sizeof(a->Buffer)) {
        UnlockConsole(Console);
        return STATUS_INVALID_PARAMETER;
    }


    //
    // Make sure we have a valid screen buffer.
    //

    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (!NT_SUCCESS(Status)) {
        UnlockConsole(Console);
        return Status;
    }

    Status = DoSrvWriteConsole(m,ReplyStatus,Console,HandleData);

    UnlockConsole(Console);
    return Status;
}

BOOLEAN
WriteConsoleWaitRoutine(
    IN PLIST_ENTRY WaitQueue,
    IN PCSR_THREAD WaitingThread,
    IN PCSR_API_MSG WaitReplyMessage,
    IN PVOID WaitParameter,
    IN PVOID SatisfyParameter1,
    IN PVOID SatisfyParameter2,
    IN ULONG WaitFlags
    )
{
    NTSTATUS Status;
    PCONSOLE_WRITECONSOLE_MSG a = (PCONSOLE_WRITECONSOLE_MSG)&WaitReplyMessage->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;

    if (WaitFlags & CSR_PROCESS_TERMINATING) {
        WaitReplyMessage->ReturnValue = (ULONG)STATUS_THREAD_IS_TERMINATING;
        return TRUE;
    }
    LockConsoleHandleTable();
    Status = DereferenceConsoleHandle(a->ConsoleHandle,
                                      &Console
                                     );
    UnlockConsoleHandleTable();
    ASSERT (NT_SUCCESS(Status));

    //
    // if we get to here, this routine was called by the input
    // thread, which grabs the current console lock.
    //

    //
    // this routine should be called by a thread owning the same
    // lock on the same console as we're reading from.
    //

    ASSERT (ConsoleLocked(Console));

    //
    // if we're unicode, the string may still be in the message buffer.
    // since the message was reallocated and copied when the wait was
    // created, we need to fix up a->TransBuffer here.
    //

    if (a->Unicode && a->BufferInMessage) {
        a->TransBuffer = a->Buffer;
    }

    Status = DoWriteConsole(WaitReplyMessage,Console,WaitingThread);
    if (Status == CONSOLE_STATUS_WAIT) {
        return FALSE;
    }
    if (!a->Unicode) {
#ifdef FE_SB
        if (CONSOLE_IS_DBCS_OUTPUTCP(Console))
        {
            if (a->NumBytes == Console->WriteConOutNumBytesUnicode)
                a->NumBytes = Console->WriteConOutNumBytesTemp;
            else
                a->NumBytes /= sizeof(WCHAR);
            }
        else
#endif
        a->NumBytes /= sizeof(WCHAR);
        ConsoleHeapFree(a->TransBuffer);
    }
    WaitReplyMessage->ReturnValue = Status;
    return TRUE;
    UNREFERENCED_PARAMETER(WaitQueue);
    UNREFERENCED_PARAMETER(WaitParameter);
    UNREFERENCED_PARAMETER(SatisfyParameter1);
    UNREFERENCED_PARAMETER(SatisfyParameter2);
}

ULONG
SrvDuplicateHandle(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Routine Description:

    This routine duplicates an input or output handle.

Arguments:

    ApiMessageData - Points to parameter structure.

Return Value:

--*/

{
    PCONSOLE_DUPHANDLE_MSG a = (PCONSOLE_DUPHANDLE_MSG)&m->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA SourceHandleData,TargetHandleData;
    PCONSOLE_SHARE_ACCESS ShareAccess;
    NTSTATUS Status;
    PCONSOLE_PER_PROCESS_DATA ProcessData;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    ProcessData = CONSOLE_PERPROCESSDATA();
    Status = DereferenceIoHandleNoCheck(ProcessData,
                                 HANDLE_TO_INDEX(a->SourceHandle),
                                 &SourceHandleData
                                );
    if (!NT_SUCCESS(Status)) {
        goto exit;
    }
    if (a->Options & DUPLICATE_SAME_ACCESS) {
        a->DesiredAccess = SourceHandleData->Access;
    }

    //
    // make sure that requested access is a subset of source handle's access
    //

    else if ((a->DesiredAccess & SourceHandleData->Access) != a->DesiredAccess) {
        Status = STATUS_INVALID_PARAMETER;
        goto exit;
    }
    Status = AllocateIoHandle(ProcessData,
                              SourceHandleData->HandleType,
                              &a->TargetHandle
                             );
    if (!NT_SUCCESS(Status)) {
        goto exit;
    }

    //
    // it's possible that AllocateIoHandle realloced the handle table,
    // so deference SourceHandle again.
    //

    Status = DereferenceIoHandleNoCheck(ProcessData,
                                 HANDLE_TO_INDEX(a->SourceHandle),
                                 &SourceHandleData
                                );
    ASSERT (NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status)) {
        goto exit;
    }
    Status = DereferenceIoHandleNoCheck(ProcessData,
                                 a->TargetHandle,
                                 &TargetHandleData
                                );
    ASSERT (NT_SUCCESS(Status));
    if (!NT_SUCCESS(Status)) {
        FreeIoHandle(ProcessData,
                     a->TargetHandle
                    );
        goto exit;
    }
    if (SourceHandleData->HandleType & CONSOLE_INPUT_HANDLE) {
        // grab input lock
        if (!InitializeInputHandle(TargetHandleData,
                                   SourceHandleData->Buffer.InputBuffer)) {
            FreeIoHandle(ProcessData,
                         a->TargetHandle
                        );
            Status = STATUS_NO_MEMORY;
            goto exit;
        }
        ShareAccess = &SourceHandleData->Buffer.InputBuffer->ShareAccess;
    }
    else {
        // grab output lock
        InitializeOutputHandle(TargetHandleData,SourceHandleData->Buffer.ScreenBuffer);
        ShareAccess = &SourceHandleData->Buffer.ScreenBuffer->ShareAccess;
    }
    TargetHandleData->HandleType = SourceHandleData->HandleType;
    if (a->InheritHandle) {
        TargetHandleData->HandleType |= CONSOLE_INHERITABLE;
    } else {
        TargetHandleData->HandleType &= ~CONSOLE_INHERITABLE;
    }

    Status = ConsoleDupShare(a->DesiredAccess,
                             SourceHandleData->ShareAccess,
                             ShareAccess,
                             TargetHandleData
                            );
    if (!NT_SUCCESS(Status)) {
        FreeIoHandle(ProcessData,
                     a->TargetHandle
                    );
        if (SourceHandleData->HandleType & CONSOLE_INPUT_HANDLE) {
            SourceHandleData->Buffer.InputBuffer->RefCount--;
        }
        else {
            SourceHandleData->Buffer.ScreenBuffer->RefCount--;
        }
    }
    else {
        a->TargetHandle = INDEX_TO_HANDLE(a->TargetHandle);
    }

    if (a->Options & DUPLICATE_CLOSE_SOURCE) {
        if (SourceHandleData->HandleType & CONSOLE_INPUT_HANDLE)
            CloseInputHandle(ProcessData,Console,SourceHandleData,HANDLE_TO_INDEX(a->SourceHandle));
        else {
            CloseOutputHandle(ProcessData,Console,SourceHandleData,HANDLE_TO_INDEX(a->SourceHandle),TRUE);
        }
    }

exit:
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);    // get rid of unreferenced parameter warning message
}

ULONG
SrvGetHandleInformation(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Routine Description:

    This gets information about an input or output handle.

Arguments:

    ApiMessageData - Points to parameter structure.

Return Value:

--*/

{
    PCONSOLE_GETHANDLEINFORMATION_MSG a = (PCONSOLE_GETHANDLEINFORMATION_MSG)&m->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    NTSTATUS Status;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandleNoCheck(CONSOLE_PERPROCESSDATA(),
                                 HANDLE_TO_INDEX(a->Handle),
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {
        a->Flags = 0;
        if (HandleData->HandleType & CONSOLE_INHERITABLE) {
            a->Flags |= HANDLE_FLAG_INHERIT;
        }
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);    // get rid of unreferenced parameter warning message
}

ULONG
SrvSetHandleInformation(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Routine Description:

    This sets information about an input or output handle.

Arguments:

    ApiMessageData - Points to parameter structure.

Return Value:

--*/

{
    PCONSOLE_SETHANDLEINFORMATION_MSG a = (PCONSOLE_SETHANDLEINFORMATION_MSG)&m->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    NTSTATUS Status;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandleNoCheck(CONSOLE_PERPROCESSDATA(),
                                 HANDLE_TO_INDEX(a->Handle),
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {
        if (a->Mask & HANDLE_FLAG_INHERIT) {
            if (a->Flags & HANDLE_FLAG_INHERIT) {
                HandleData->HandleType |= CONSOLE_INHERITABLE;
            } else {
                HandleData->HandleType &= ~CONSOLE_INHERITABLE;
            }
        }
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);    // get rid of unreferenced parameter warning message
}

NTSTATUS
CloseInputHandle(
    IN PCONSOLE_PER_PROCESS_DATA ProcessData,
    IN PCONSOLE_INFORMATION Console,
    IN PHANDLE_DATA HandleData,
    IN HANDLE Handle
    )

/*++

Routine Description:

    This routine closes an input handle.  It decrements the input buffer's
    reference count.  If it goes to zero, the buffer is reinitialized.
    Otherwise, the handle is removed from sharing.

Arguments:

    ProcessData - Pointer to per process data.

    HandleData - Pointer to handle data structure.

    Handle - Handle to close.

Return Value:

Note:

    The console lock must be held when calling this routine.

--*/

{
    BOOLEAN WaitSatisfied = FALSE;

    if (HandleData->InputReadData->InputHandleFlags & HANDLE_INPUT_PENDING) {
        HandleData->InputReadData->InputHandleFlags &= ~HANDLE_INPUT_PENDING;
        ConsoleHeapFree(HandleData->InputReadData->BufPtr);
    }

    //
    // see if there are any reads waiting for data via this handle.  if
    // there are, wake them up.  there aren't any other outstanding i/o
    // operations via this handle because the console lock is held.
    //

    LockReadCount(HandleData);
    if (HandleData->InputReadData->ReadCount != 0) {
        UnlockReadCount(HandleData);
        HandleData->InputReadData->InputHandleFlags |= HANDLE_CLOSING;

        WaitSatisfied |= CsrNotifyWait(&HandleData->Buffer.InputBuffer->ReadWaitQueue,
                      TRUE,
                      (PVOID) HandleData,
                      NULL
                     );
        LockReadCount(HandleData);
    }
    if (WaitSatisfied) {
        // #334370 under stress, WaitQueue may already hold the satisfied waits
        ASSERT ((Console->WaitQueue == NULL) ||
                (Console->WaitQueue == &HandleData->Buffer.InputBuffer->ReadWaitQueue));
        Console->WaitQueue = &HandleData->Buffer.InputBuffer->ReadWaitQueue;
    }
    if (HandleData->InputReadData->ReadCount != 0) {
        KdPrint(("ReadCount is %lX\n",HandleData->InputReadData->ReadCount));
    }
    ASSERT (HandleData->InputReadData->ReadCount == 0);
    UnlockReadCount(HandleData);

    ASSERT (HandleData->Buffer.InputBuffer->RefCount);
    HandleData->Buffer.InputBuffer->RefCount--;
    if (HandleData->Buffer.InputBuffer->RefCount == 0) {
        ReinitializeInputBuffer(HandleData->Buffer.InputBuffer);
    }
    else {
        ConsoleRemoveShare(HandleData->Access,
                           HandleData->ShareAccess,
                           &HandleData->Buffer.InputBuffer->ShareAccess
                          );
    }
    return FreeIoHandle(ProcessData,Handle);
}

NTSTATUS
CloseOutputHandle(
    IN PCONSOLE_PER_PROCESS_DATA ProcessData,
    IN PCONSOLE_INFORMATION Console,
    IN PHANDLE_DATA HandleData,
    IN HANDLE Handle,
    IN BOOLEAN FreeHandle
    )

/*++

Routine Description:

    This routine closes an output handle.  It decrements the screen buffer's
    reference count.  If it goes to zero, the buffer is freed.  Otherwise,
    the handle is removed from sharing.

Arguments:

    ProcessData - Pointer to per process data.

    Console - Pointer to console information structure.

    HandleData - Pointer to handle data structure.

    Handle - Handle to close.

    FreeHandle - if TRUE, free handle.  used by ReadChars in echo mode
    and by process cleanup.

Return Value:

Note:

    The console lock must be held when calling this routine.

--*/

{
    NTSTATUS Status;

    ASSERT (HandleData->Buffer.ScreenBuffer->RefCount);
    HandleData->Buffer.ScreenBuffer->RefCount--;
    if (HandleData->Buffer.ScreenBuffer->RefCount == 0) {
        RemoveScreenBuffer(Console,HandleData->Buffer.ScreenBuffer);
        if (HandleData->Buffer.ScreenBuffer == Console->CurrentScreenBuffer &&
            Console->ScreenBuffers != Console->CurrentScreenBuffer) {
            if (Console->ScreenBuffers != NULL) {
                SetActiveScreenBuffer(Console->ScreenBuffers);
            } else {
                Console->CurrentScreenBuffer = NULL;
            }
        }
        Status = FreeScreenBuffer(HandleData->Buffer.ScreenBuffer);
    }
    else {
        Status = ConsoleRemoveShare(HandleData->Access,
                                    HandleData->ShareAccess,
                                    &HandleData->Buffer.ScreenBuffer->ShareAccess
                                   );
    }
    if (FreeHandle)
        Status = FreeIoHandle(ProcessData,Handle);
    return Status;
}


ULONG
SrvCloseHandle(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Routine Description:

    This routine closes an input or output handle.

Arguments:

    ApiMessageData - Points to parameter structure.

Return Value:

--*/

{
    PCONSOLE_CLOSEHANDLE_MSG a = (PCONSOLE_CLOSEHANDLE_MSG)&m->u.ApiMessageData;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    NTSTATUS Status;
    PCONSOLE_PER_PROCESS_DATA ProcessData;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    ProcessData = CONSOLE_PERPROCESSDATA();
    Status = DereferenceIoHandleNoCheck(ProcessData,
                                 HANDLE_TO_INDEX(a->Handle),
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {
        if (HandleData->HandleType & CONSOLE_INPUT_HANDLE)
            Status = CloseInputHandle(ProcessData,Console,HandleData,HANDLE_TO_INDEX(a->Handle));
        else {
            Status = CloseOutputHandle(ProcessData,Console,HandleData,HANDLE_TO_INDEX(a->Handle),TRUE);
        }
    }
    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);    // get rid of unreferenced parameter warning message
}

NTSTATUS
WriteCharsFromInput(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PWCHAR lpBufferBackupLimit,
    IN PWCHAR lpBuffer,
    IN PWCHAR lpString,
    IN OUT PDWORD NumBytes,
    OUT PLONG NumSpaces OPTIONAL,
    IN SHORT OriginalXPosition,
    IN DWORD dwFlags,
    OUT PSHORT ScrollY OPTIONAL
    )

/*++

Routine Description:

    This routine converts chars from their true unicode representation
    to the Unicode representation (UnicodeAnsi) that will generate
    the correct glyph given an OEM font and an ANSI translation by GDI.
    It then calls WriteChars.

Arguments:

    ScreenInfo - Pointer to screen buffer information structure.

    lpBufferBackupLimit - Pointer to beginning of buffer.

    lpBuffer - Pointer to buffer to copy string to.  assumed to be at least
    as long as lpString.  This pointer is updated to point to the next
    position in the buffer.

    lpString - Pointer to string to write.

    NumBytes - On input, number of bytes to write.  On output, number of
    bytes written.

    NumSpaces - On output, the number of spaces consumed by the written characters.

    dwFlags -
      WC_DESTRUCTIVE_BACKSPACE backspace overwrites characters.
      WC_KEEP_CURSOR_VISIBLE   change window origin desirable when hit rt. edge
      WC_ECHO                  if called by Read (echoing characters)
      WC_FALSIFY_UNICODE       if RealUnicodeToFalseUnicode need be called.

Return Value:

Note:

    This routine does not process tabs and backspace properly.  That code
    will be implemented as part of the line editing services.

--*/

{
    DWORD Length,i;

    if (ScreenInfo->Flags & CONSOLE_GRAPHICS_BUFFER) {
        return STATUS_UNSUCCESSFUL;
    }

    if (!(ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) ||
            (ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN)) {
        goto SimpleWrite;
    }

    Length = *NumBytes / sizeof(WCHAR);
    for (i=0;i<Length;i++) {
        if (lpString[i] > 0x7f) {
            dwFlags |= WC_FALSIFY_UNICODE;
            break;
        }
    }

SimpleWrite:
    return WriteChars(ScreenInfo,
                    lpBufferBackupLimit,
                    lpBuffer,
                    lpString,
                    NumBytes,
                    NumSpaces,
                    OriginalXPosition,
                    dwFlags,
                    ScrollY
                   );
}

#if defined(FE_SB)

#define WWSB_NOFE
#include "dispatch.h"
#include "_stream.h"
#undef  WWSB_NOFE
#define WWSB_FE
#include "dispatch.h"
#include "_stream.h"
#undef  WWSB_FE

#endif // FE_SB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\server\private.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    private.c

Abstract:

        This file implements private APIs for Hardware Desktop Support.

Author:

    Therese Stowell (thereses) 12-13-1991

Revision History:

Notes:

--*/

#include "precomp.h"
#pragma hdrstop

#if defined(FE_SB)
BOOL fFullScreenGraphics ; // Do not trun graphics mode.
#if defined(i386)
extern ULONG  gdwMachineId;
#endif // i386
#endif

//
// initial palette registers
//

#define PAL_BLACK       0
#define PAL_BLUE        1
#define PAL_GREEN       2
#define PAL_RED         4
#define PAL_YELLOW      (PAL_RED | PAL_GREEN)
#define PAL_CYAN        (PAL_GREEN | PAL_BLUE)
#define PAL_MAGENTA     (PAL_BLUE | PAL_RED)
#define PAL_WHITE       (PAL_RED | PAL_GREEN | PAL_BLUE)

#define PAL_I_BLACK     (PAL_BLACK      + (PAL_WHITE    << 3))
#define PAL_I_RED       (PAL_RED        + (PAL_RED      << 3))
#define PAL_I_GREEN     (PAL_GREEN      + (PAL_GREEN    << 3))
#define PAL_I_YELLOW    (PAL_YELLOW     + (PAL_YELLOW   << 3))
#define PAL_I_BLUE      (PAL_BLUE       + (PAL_BLUE     << 3))
#define PAL_I_CYAN      (PAL_CYAN       + (PAL_CYAN     << 3))
#define PAL_I_MAGENTA   (PAL_MAGENTA    + (PAL_MAGENTA  << 3))
#define PAL_I_WHITE     (PAL_WHITE      + (PAL_WHITE    << 3))

#define INITIAL_PALETTE_SIZE 18

USHORT InitialPalette[INITIAL_PALETTE_SIZE] = {

        16, // 16 entries
        0,  // start with first palette register
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
};

#if defined(FE_SB)
PUSHORT RegInitialPalette = InitialPalette;
#endif

UCHAR ColorBuffer[] = {

        16, // 16 entries
        0,
        0,
        0,  // start with first palette register
        0x00, 0x00, 0x00, 0x00, // black
        0x00, 0x00, 0x2A, 0x00, // blue
        0x00, 0x2A, 0x00, 0x00, // green
        0x00, 0x2A, 0x2A, 0x00, // cyan
        0x2A, 0x00, 0x00, 0x00, // red
        0x2A, 0x00, 0x2A, 0x00, // magenta
        0x2A, 0x2A, 0x00, 0x00, // mustard/brown
        0x36, 0x36, 0x36, 0x00, // light gray  39
        0x28, 0x28, 0x28, 0x00, // dark gray   2A
        0x00, 0x00, 0x3F, 0x00, // bright blue
        0x00, 0x3F, 0x00, 0x00, // bright green
        0x00, 0x3F, 0x3F, 0x00, // bright cyan
        0x3F, 0x00, 0x00, 0x00, // bright red
        0x3F, 0x00, 0x3F, 0x00, // bright magenta
        0x3F, 0x3F, 0x00, 0x00, // bright yellow
        0x3F, 0x3F, 0x3F, 0x00  // bright white
};

#if defined(FE_SB)
PUCHAR RegColorBuffer = ColorBuffer;
PUCHAR RegColorBufferNoTranslate = NULL;
#endif

#if defined(FE_SB)
MODE_FONT_PAIR ModeFontPairs[] = {
    {FS_MODE_TEXT, 80, 21, 640, 350, 8, 16},
    {FS_MODE_TEXT, 80, 25, 720, 400, 8, 16},
    {FS_MODE_TEXT, 80, 28, 720, 400, 8, 14},
    {FS_MODE_TEXT, 80, 43, 640, 350, 8, 8 },
    {FS_MODE_TEXT, 80, 50, 720, 400, 8, 8 }
};

DWORD NUMBER_OF_MODE_FONT_PAIRS = sizeof(ModeFontPairs)/sizeof(MODE_FONT_PAIR);
PMODE_FONT_PAIR RegModeFontPairs = ModeFontPairs;

SINGLE_LIST_ENTRY gRegFullScreenCodePage;    // This list contain FS_CODEPAGE data.

#else
typedef struct _MODE_FONT_PAIR {
    ULONG Height;
    COORD Resolution;
    COORD FontSize;
} MODE_FONT_PAIR, PMODE_FONT_PAIR;

#define NUMBER_OF_MODE_FONT_PAIRS 5

MODE_FONT_PAIR ModeFontPairs[NUMBER_OF_MODE_FONT_PAIRS] = {
    {21, 640, 350, 8, 16},
    {25, 720, 400, 8, 16},
    {28, 720, 400, 8, 14},
    {43, 640, 350, 8, 8 },
    {50, 720, 400, 8, 8 }
};
#endif


HANDLE hCPIFile;    // handle to font file

typedef struct _FONTFILEHEADER {
    BYTE  ffhFileTag[8]; // SHOULD BE 0FFH,"FONT___"
    BYTE  ffhReserved[8];
    WORD  ffhPointers;
    BYTE  ffhPointerType;
    BYTE  ffhOffset1;
    WORD  ffhOffset2;
    BYTE  ffhOffset3;
} FONTFILEHEADER, *LPFONTFILEHEADER;

typedef struct _FONTINFOHEADER {
    WORD  fihCodePages;
} FONTINFOHEADER, *LPFONTINFOHEADER;

typedef struct _CPENTRYHEADER {
    WORD  cpeLength;
    WORD  cpeNext1;
    WORD  cpeNext2;
    WORD  cpeDevType;
    BYTE  cpeDevSubtype[8];
    WORD  cpeCodepageID;
    BYTE  cpeReserved[6];
    DWORD cpeOffset;
} CPENTRYHEADER, *LPCPENTRYHEADER;

typedef struct _FONTDATAHEADER {
    WORD  fdhReserved;
    WORD  fdhFonts;
    WORD  fdhLength;
} FONTDATAHEADER, *LPFONTDATAHEADER;

typedef struct _SCREENFONTHEADER {
    BYTE  sfhHeight;
    BYTE  sfhWidth;
    WORD  sfhAspect;
    WORD  sfhCharacters;
} SCREENFONTHEADER, *LPSCREENFONTHEADER;

#define CONSOLE_WINDOWS_DIR_LENGTH 256
#define CONSOLE_EGACPI_LENGTH 9 // includes NULL
#define CONSOLE_EGACPI "\\ega.cpi"
#define CONSOLE_FONT_BUFFER_LENGTH 50
#define CONSOLE_DEFAULT_ROM_FONT 437


#ifdef i386
VOID
ReverseMousePointer(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT Region
    );

VOID
ReadRectFromScreenBuffer(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN COORD SourcePoint,
    IN PCHAR_INFO Target,
    IN COORD TargetSize,
    IN PSMALL_RECT TargetRect
    );

#endif

NTSTATUS
MapViewOfSection(
    PHANDLE SectionHandle,
    ULONG CommitSize,
    PVOID *BaseAddress,
    PSIZE_T ViewSize,
    HANDLE ClientHandle,
    PVOID *BaseClientAddress
    );

NTSTATUS
ConnectToEmulator(
    IN BOOL Connect,
    IN PCONSOLE_INFORMATION Console
    );


ULONG
SrvSetConsoleCursor(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Description:

    Sets the mouse pointer for the specified screen buffer.

Parameters:

    hConsoleOutput - Supplies a console output handle.

    hCursor - win32 cursor handle, should be NULL to set the default
        cursor.

Return value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    PCONSOLE_SETCURSOR_MSG a = (PCONSOLE_SETCURSOR_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;

    UNREFERENCED_PARAMETER(ReplyStatus);

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_GRAPHICS_OUTPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {
        if (a->CursorHandle == NULL) {
            HandleData->Buffer.ScreenBuffer->CursorHandle = ghNormalCursor;
        } else {
            HandleData->Buffer.ScreenBuffer->CursorHandle = a->CursorHandle;
        }
        PostMessage(HandleData->Buffer.ScreenBuffer->Console->hWnd,
                     WM_SETCURSOR,
                     0,
                     -1
                    );
    }
    UnlockConsole(Console);
    return Status;
}

#ifdef i386
VOID
FullScreenCursor(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN BOOL On
    )
{
    if (On) {
        if (ScreenInfo->CursorDisplayCount < 0) {
            ScreenInfo->CursorDisplayCount = 0;
            ReverseMousePointer(ScreenInfo, &ScreenInfo->Window);
        }
    } else {
        if (ScreenInfo->CursorDisplayCount >= 0) {
            ReverseMousePointer(ScreenInfo, &ScreenInfo->Window);
            ScreenInfo->CursorDisplayCount = -1;
        }
    }

}
#endif

ULONG
SrvShowConsoleCursor(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Description:

    Sets the mouse pointer visibility counter.  If the counter is less than
    zero, the mouse pointer is not shown.

Parameters:

    hOutput - Supplies a console output handle.

    bShow - if TRUE, the display count is to be increased. if FALSE,
        decreased.

Return value:

    The return value specifies the new display count.

--*/

{
    PCONSOLE_SHOWCURSOR_MSG a = (PCONSOLE_SHOWCURSOR_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;

    UNREFERENCED_PARAMETER(ReplyStatus);

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE | CONSOLE_GRAPHICS_OUTPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {
        if (!(Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE)) {
            if (a->bShow) {
                HandleData->Buffer.ScreenBuffer->CursorDisplayCount += 1;
            } else {
                HandleData->Buffer.ScreenBuffer->CursorDisplayCount -= 1;
            }
            if (HandleData->Buffer.ScreenBuffer == Console->CurrentScreenBuffer) {
                PostMessage(HandleData->Buffer.ScreenBuffer->Console->hWnd,
                             WM_SETCURSOR,
                             0,
                             -1
                            );
            }
        } else {
#ifdef i386
            if (HandleData->HandleType != CONSOLE_GRAPHICS_OUTPUT_HANDLE &&
                Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE &&
                HandleData->Buffer.ScreenBuffer == Console->CurrentScreenBuffer) {
                FullScreenCursor(HandleData->Buffer.ScreenBuffer, a->bShow);
            }
#endif
        }
        a->DisplayCount = HandleData->Buffer.ScreenBuffer->CursorDisplayCount;
    }
    UnlockConsole(Console);
    return Status;
}


ULONG
SrvConsoleMenuControl(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Description:

    Sets the command id range for the current screen buffer and returns the
    menu handle.

Parameters:

    hConsoleOutput - Supplies a console output handle.

    dwCommandIdLow - Specifies the lowest command id to store in the input buffer.

    dwCommandIdHigh - Specifies the highest command id to store in the input
        buffer.

Return value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    PCONSOLE_MENUCONTROL_MSG a = (PCONSOLE_MENUCONTROL_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;

    UNREFERENCED_PARAMETER(ReplyStatus);

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE | CONSOLE_GRAPHICS_OUTPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {
        a->hMenu = HandleData->Buffer.ScreenBuffer->Console->hMenu;
        HandleData->Buffer.ScreenBuffer->CommandIdLow = a->CommandIdLow;
        HandleData->Buffer.ScreenBuffer->CommandIdHigh = a->CommandIdHigh;
    }

    UnlockConsole(Console);
    return Status;
}

ULONG
SrvSetConsolePalette(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Description:

    Sets the palette for the console screen buffer.

Parameters:

    hOutput - Supplies a console output handle.

    hPalette - Supplies a handle to the palette to set.

    dwUsage - Specifies use of the system palette.

        SYSPAL_NOSTATIC - System palette contains no static colors
                          except black and white.

        SYSPAL_STATIC -   System palette contains static colors
                          which will not change when an application
                          realizes its logical palette.

Return value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    PCONSOLE_SETPALETTE_MSG a = (PCONSOLE_SETPALETTE_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    HPALETTE hOldPalette;

    UNREFERENCED_PARAMETER(ReplyStatus);

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_GRAPHICS_OUTPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {
        USERTHREAD_USEDESKTOPINFO utudi;
        BOOL bReset = FALSE;

        /*
         * Palette handle was converted in the client.
         */
        if (GetCurrentThreadId() != HandleData->Buffer.ScreenBuffer->
                Console->InputThreadInfo->ThreadId) {
            bReset = TRUE;
            utudi.hThread = HandleData->Buffer.ScreenBuffer->Console->InputThreadInfo->ThreadHandle;
            utudi.drdRestore.pdeskRestore = NULL;
            NtUserSetInformationThread(NtCurrentThread(),
                    UserThreadUseDesktop,
                    &utudi, sizeof(utudi));
        }

        NtUserConsoleControl(ConsolePublicPalette, &(a->hPalette), sizeof(HPALETTE));

        hOldPalette = SelectPalette(
                HandleData->Buffer.ScreenBuffer->Console->hDC,
                a->hPalette,
                FALSE);

        if (hOldPalette == NULL) {
            Status = STATUS_INVALID_PARAMETER;
        } else {
            if ((HandleData->Buffer.ScreenBuffer->hPalette != NULL) &&
                    (a->hPalette != HandleData->Buffer.ScreenBuffer->hPalette)) {
                DeleteObject(HandleData->Buffer.ScreenBuffer->hPalette);
            }
            HandleData->Buffer.ScreenBuffer->hPalette = a->hPalette;
            HandleData->Buffer.ScreenBuffer->dwUsage = a->dwUsage;
            if (!(HandleData->Buffer.ScreenBuffer->Console->Flags & CONSOLE_IS_ICONIC) &&
                    HandleData->Buffer.ScreenBuffer->Console->FullScreenFlags == 0) {

                SetSystemPaletteUse(HandleData->Buffer.ScreenBuffer->Console->hDC,
                        HandleData->Buffer.ScreenBuffer->dwUsage);
                RealizePalette(HandleData->Buffer.ScreenBuffer->Console->hDC);
            }
            if (HandleData->Buffer.ScreenBuffer->Console->hSysPalette == NULL) {
                    HandleData->Buffer.ScreenBuffer->Console->hSysPalette = hOldPalette;
            }
        }

        if (bReset) {
            utudi.hThread = NULL;
            NtUserSetInformationThread(NtCurrentThread(),
                    UserThreadUseDesktop, &utudi, sizeof(utudi));
        }
    }
    UnlockConsole(Console);
    return Status;
}


VOID
SetActivePalette(
    IN PSCREEN_INFORMATION ScreenInfo
    )
{
    USERTHREAD_USEDESKTOPINFO utudi;
    BOOL bReset = FALSE;

    if (GetCurrentThreadId() != ScreenInfo->Console->InputThreadInfo->ThreadId) {
        bReset = TRUE;
        utudi.hThread = ScreenInfo->Console->InputThreadInfo->ThreadHandle;
        utudi.drdRestore.pdeskRestore = NULL;
        NtUserSetInformationThread(NtCurrentThread(),
                UserThreadUseDesktop,
                &utudi, sizeof(utudi));
    }

    SetSystemPaletteUse(ScreenInfo->Console->hDC,
                        ScreenInfo->dwUsage
                       );
    RealizePalette(ScreenInfo->Console->hDC);

    if (bReset == TRUE) {
        utudi.hThread = NULL;
        NtUserSetInformationThread(NtCurrentThread(),
                UserThreadUseDesktop, &utudi, sizeof(utudi));
    }
}

VOID
UnsetActivePalette(
    IN PSCREEN_INFORMATION ScreenInfo
    )
{
    USERTHREAD_USEDESKTOPINFO utudi;
    BOOL bReset = FALSE;

    if (GetCurrentThreadId() != ScreenInfo->Console->InputThreadInfo->ThreadId) {
        bReset = TRUE;
        utudi.hThread = ScreenInfo->Console->InputThreadInfo->ThreadHandle;
        utudi.drdRestore.pdeskRestore = NULL;
        NtUserSetInformationThread(NtCurrentThread(),
                UserThreadUseDesktop,
                &utudi, sizeof(utudi));
    }

    SetSystemPaletteUse(ScreenInfo->Console->hDC,
                        SYSPAL_STATIC
                       );
    RealizePalette(ScreenInfo->Console->hDC);


    if (bReset == TRUE) {
        utudi.hThread = NULL;
        NtUserSetInformationThread(NtCurrentThread(),
                UserThreadUseDesktop, &utudi, sizeof(utudi));
    }
}

NTSTATUS
ConvertToFullScreen(
    IN PCONSOLE_INFORMATION Console
    )
{
#ifdef i386
    PSCREEN_INFORMATION Cur;
    COORD WindowedWindowSize, WindowSize;

    // for each charmode screenbuffer
    //     match window size to a mode/font
    //     grow screen buffer if necessary
    //     save old window dimensions
    //     set new window dimensions

    for (Cur=Console->ScreenBuffers;Cur!=NULL;Cur=Cur->Next) {

        if (Cur->Flags & CONSOLE_GRAPHICS_BUFFER) {
            continue;
        }

        // save old window dimensions

        WindowedWindowSize.X = CONSOLE_WINDOW_SIZE_X(Cur);
        WindowedWindowSize.Y = CONSOLE_WINDOW_SIZE_Y(Cur);

        Cur->BufferInfo.TextInfo.WindowedWindowSize = WindowedWindowSize;
        Cur->BufferInfo.TextInfo.WindowedScreenSize = Cur->ScreenBufferSize;

        // match window size to a mode/font

        Cur->BufferInfo.TextInfo.ModeIndex = MatchWindowSize(
                Console->OutputCP,
                Cur->ScreenBufferSize, &WindowSize);

        // grow screen buffer if necessary

        if (WindowSize.X > Cur->ScreenBufferSize.X ||
            WindowSize.Y > Cur->ScreenBufferSize.Y) {
            COORD NewScreenSize;

            NewScreenSize.X = max(WindowSize.X, Cur->ScreenBufferSize.X);
            NewScreenSize.Y = max(WindowSize.Y, Cur->ScreenBufferSize.Y);

            if (ResizeScreenBuffer(Cur, NewScreenSize, FALSE) == STATUS_INVALID_HANDLE) {
                return STATUS_INVALID_HANDLE;
            }
        }

        //
        // Set new window dimensions.
        // We always resize horizontally from the right (change the
        // right edge).
        // We resize vertically from the bottom, keeping the cursor visible.
        //

        if (WindowedWindowSize.X != WindowSize.X) {
            Cur->Window.Right -= WindowedWindowSize.X - WindowSize.X;
            if (Cur->Window.Right >= Cur->ScreenBufferSize.X) {
                Cur->Window.Left -= Cur->Window.Right - Cur->ScreenBufferSize.X + 1;
                Cur->Window.Right -= Cur->Window.Right - Cur->ScreenBufferSize.X + 1;
            }
        }
        if (WindowedWindowSize.Y > WindowSize.Y) {
            Cur->Window.Bottom -= WindowedWindowSize.Y - WindowSize.Y;
            if (Cur->Window.Bottom >= Cur->ScreenBufferSize.Y) {
                Cur->Window.Top -= Cur->Window.Bottom - Cur->ScreenBufferSize.Y + 1;
                Cur->Window.Bottom = Cur->ScreenBufferSize.Y - 1;
            }
        } else if (WindowedWindowSize.Y < WindowSize.Y) {
            Cur->Window.Top -= WindowSize.Y - WindowedWindowSize.Y;
            if (Cur->Window.Top < 0) {
                Cur->Window.Bottom -= Cur->Window.Top;
                Cur->Window.Top = 0;
            }
        }
        if (Cur->BufferInfo.TextInfo.CursorPosition.Y > Cur->Window.Bottom) {
            Cur->Window.Top += Cur->BufferInfo.TextInfo.CursorPosition.Y - Cur->Window.Bottom;
            Cur->Window.Bottom = Cur->BufferInfo.TextInfo.CursorPosition.Y;
        }

        ASSERT(WindowSize.X == CONSOLE_WINDOW_SIZE_X(Cur));
        ASSERT(WindowSize.Y == CONSOLE_WINDOW_SIZE_Y(Cur));
        Cur->BufferInfo.TextInfo.MousePosition.X = Cur->Window.Left;
        Cur->BufferInfo.TextInfo.MousePosition.Y = Cur->Window.Top;

        if (Cur->Flags & CONSOLE_OEMFONT_DISPLAY) {
            DBGCHARS(("ConvertToFullScreen converts UnicodeOem -> Unicode\n"));
            FalseUnicodeToRealUnicode(
                    Cur->BufferInfo.TextInfo.TextRows,
                    Cur->ScreenBufferSize.X * Cur->ScreenBufferSize.Y,
                    Console->OutputCP);
        } else {
            DBGCHARS(("ConvertToFullScreen needs no conversion\n"));
        }
        DBGCHARS(("Cur->BufferInfo.TextInfo.Rows = %lx\n",
                Cur->BufferInfo.TextInfo.Rows));
        DBGCHARS(("Cur->BufferInfo.TextInfo.TextRows = %lx\n",
                Cur->BufferInfo.TextInfo.TextRows));
    }

    Cur = Console->CurrentScreenBuffer;

    if (Cur->Flags & CONSOLE_TEXTMODE_BUFFER) {
        if (CONSOLE_IS_DBCS_OUTPUTCP(Console)) {
            PCONVERSIONAREA_INFORMATION ConvAreaInfo;
            ConvAreaInfo = Console->ConsoleIme.ConvAreaRoot;
            while (ConvAreaInfo) {
                NTSTATUS Status;

                Status = StoreTextBufferFontInfo(ConvAreaInfo->ScreenBuffer,
                                                 SCR_FONTNUMBER(Cur),
                                                 SCR_FONTSIZE(Cur),
                                                 SCR_FAMILY(Cur),
                                                 SCR_FONTWEIGHT(Cur),
                                                 SCR_FACENAME(Cur),
                                                 SCR_FONTCODEPAGE(Cur));
                if (!NT_SUCCESS(Status)) {
                    return((ULONG) Status);
                }

                ConvAreaInfo->ScreenBuffer->BufferInfo.TextInfo.ModeIndex = Cur->BufferInfo.TextInfo.ModeIndex;
                ConvAreaInfo = ConvAreaInfo->ConvAreaNext;
            }
        }
        Cur->BufferInfo.TextInfo.Flags &= ~TEXT_VALID_HINT;
    }

    SetWindowSize(Cur);
    WriteToScreen(Cur, &Console->CurrentScreenBuffer->Window);

#else
    UNREFERENCED_PARAMETER(Console);
#endif
    return STATUS_SUCCESS;
}

NTSTATUS
ConvertToWindowed(
    IN PCONSOLE_INFORMATION Console
    )
{
#ifdef i386
    PSCREEN_INFORMATION Cur;
    SMALL_RECT WindowedWindow;

    // for each charmode screenbuffer
    //     restore window dimensions

    for (Cur=Console->ScreenBuffers;Cur!=NULL;Cur=Cur->Next) {
        if ((Cur->Flags & CONSOLE_TEXTMODE_BUFFER) == 0) {
            continue;
        }

        if (ResizeScreenBuffer(Cur,
                           Cur->BufferInfo.TextInfo.WindowedScreenSize,
                           FALSE) == STATUS_INVALID_HANDLE) {
            /*
             * Something really went wrong. All we can do is just to
             * bail out.
             */
            return STATUS_INVALID_HANDLE;
        }

        WindowedWindow.Right  = Cur->Window.Right;
        WindowedWindow.Bottom = Cur->Window.Bottom;
        WindowedWindow.Left   = Cur->Window.Right + 1 -
                                Cur->BufferInfo.TextInfo.WindowedWindowSize.X;
        WindowedWindow.Top    = Cur->Window.Bottom + 1 -
                                Cur->BufferInfo.TextInfo.WindowedWindowSize.Y;
        if (WindowedWindow.Left > Cur->Window.Left) {
            WindowedWindow.Right -= WindowedWindow.Left - Cur->Window.Left;
            WindowedWindow.Left = Cur->Window.Left;
        }
        if (WindowedWindow.Right < Cur->BufferInfo.TextInfo.CursorPosition.X) {
            WindowedWindow.Left += Cur->BufferInfo.TextInfo.CursorPosition.X - WindowedWindow.Right;
            WindowedWindow.Right = Cur->BufferInfo.TextInfo.CursorPosition.X;
        }
        if (WindowedWindow.Top > Cur->Window.Top) {
            WindowedWindow.Bottom -= WindowedWindow.Top - Cur->Window.Top;
            WindowedWindow.Top = Cur->Window.Top;
        }
        if (WindowedWindow.Bottom < Cur->BufferInfo.TextInfo.CursorPosition.Y) {
            WindowedWindow.Top += Cur->BufferInfo.TextInfo.CursorPosition.Y - WindowedWindow.Bottom;
            WindowedWindow.Bottom = Cur->BufferInfo.TextInfo.CursorPosition.Y;
        }
        ResizeWindow(Cur, &WindowedWindow, FALSE);

        if (CONSOLE_IS_DBCS_OUTPUTCP(Console)) {
            SetFont(Cur);
        }

        if (Cur->Flags & CONSOLE_OEMFONT_DISPLAY) {
            DBGCHARS(("ConvertToWindowed converts Unicode -> UnicodeOem\n"));
            RealUnicodeToFalseUnicode(
                    Cur->BufferInfo.TextInfo.TextRows,
                    Cur->ScreenBufferSize.X * Cur->ScreenBufferSize.Y,
                    Console->OutputCP);
        } else {
            DBGCHARS(("ConvertToWindowed needs no conversion\n"));
        }
        DBGCHARS(("Cur->BufferInfo.TextInfo.Rows = %lx\n",
                Cur->BufferInfo.TextInfo.Rows));
        DBGCHARS(("Cur->BufferInfo.TextInfo.TextRows = %lx\n",
                Cur->BufferInfo.TextInfo.TextRows));
    }

    Cur = Console->CurrentScreenBuffer;

    if (Cur->Flags & CONSOLE_TEXTMODE_BUFFER) {
        if (CONSOLE_IS_DBCS_OUTPUTCP(Console)) {
            PCONVERSIONAREA_INFORMATION ConvAreaInfo;
            ConvAreaInfo = Console->ConsoleIme.ConvAreaRoot;
            while (ConvAreaInfo) {
                NTSTATUS Status;

                Status = StoreTextBufferFontInfo(ConvAreaInfo->ScreenBuffer,
                                                 SCR_FONTNUMBER(Cur),
                                                 SCR_FONTSIZE(Cur),
                                                 SCR_FAMILY(Cur),
                                                 SCR_FONTWEIGHT(Cur),
                                                 SCR_FACENAME(Cur),
                                                 SCR_FONTCODEPAGE(Cur));
                if (!NT_SUCCESS(Status)) {
                    return((ULONG) Status);
                }

                ConvAreaInfo->ScreenBuffer->BufferInfo.TextInfo.ModeIndex = Cur->BufferInfo.TextInfo.ModeIndex;
                ConvAreaInfo = ConvAreaInfo->ConvAreaNext;
            }
        }
        Cur->BufferInfo.TextInfo.Flags &= ~TEXT_VALID_HINT;
    }

    SetWindowSize(Cur);
    WriteToScreen(Cur, &Console->CurrentScreenBuffer->Window);

#else
    UNREFERENCED_PARAMETER(Console);
#endif
    return STATUS_SUCCESS;
}

ULONG
SrvSetConsoleDisplayMode(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )

/*++

Description:

    This routine sets the console display mode for an output buffer.
    This API is only supported on x86 machines.  Jazz consoles are always
    windowed.

Parameters:

    hConsoleOutput - Supplies a console output handle.

    dwFlags - Specifies the display mode. Options are:

        CONSOLE_FULLSCREEN_MODE - data is displayed fullscreen

        CONSOLE_WINDOWED_MODE - data is displayed in a window

    lpNewScreenBufferDimensions - On output, contains the new dimensions of
        the screen buffer.  The dimensions are in rows and columns for
        textmode screen buffers.

Return value:

    TRUE - The operation was successful.

    FALSE/NULL - The operation failed. Extended error status is available
        using GetLastError.

--*/

{
    PCONSOLE_SETDISPLAYMODE_MSG a = (PCONSOLE_SETDISPLAYMODE_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    PSCREEN_INFORMATION ScreenInfo;
    UINT State;
    HANDLE  hEvent = NULL;

    UNREFERENCED_PARAMETER(ReplyStatus);

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    Status = NtDuplicateObject(CONSOLE_CLIENTPROCESSHANDLE(),
                               a->hEvent,
                               NtCurrentProcess(),
                               &hEvent,
                               0,
                               FALSE,
                               DUPLICATE_SAME_ACCESS
                               );
    if (!NT_SUCCESS(Status)) {
        goto SrvSetConsoleDisplayModeFailure;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE | CONSOLE_GRAPHICS_OUTPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {
        ScreenInfo = HandleData->Buffer.ScreenBuffer;
        if (!ACTIVE_SCREEN_BUFFER(ScreenInfo))  {
            Status = STATUS_INVALID_PARAMETER;
            goto SrvSetConsoleDisplayModeFailure;
        }
        if (a->dwFlags == CONSOLE_FULLSCREEN_MODE) {
#if !defined(_X86_)
            if (ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER) {
                Status = STATUS_INVALID_PARAMETER;
                goto SrvSetConsoleDisplayModeFailure;
            }
#else
            if (!FullScreenInitialized || GetSystemMetrics(SM_REMOTESESSION)) {
                Status = STATUS_INVALID_PARAMETER;
                goto SrvSetConsoleDisplayModeFailure;
            }
#endif
            if (Console->FullScreenFlags & CONSOLE_FULLSCREEN) {
                KdPrint(("CONSRV: VDM converting to fullscreen twice\n"));
                Status = STATUS_INVALID_PARAMETER;
                goto SrvSetConsoleDisplayModeFailure;
            }
            State = FULLSCREEN;
        } else {
            if (Console->FullScreenFlags == 0) {
                KdPrint(("CONSRV: VDM converting to windowed twice\n"));
                Status = STATUS_INVALID_PARAMETER;
                goto SrvSetConsoleDisplayModeFailure;
            }
            State = WINDOWED;
        }
        Status = QueueConsoleMessage(Console,
                    CM_MODE_TRANSITION,
                    State,
                    (LPARAM)hEvent
                    );
        if (!NT_SUCCESS(Status)) {
            goto SrvSetConsoleDisplayModeFailure;
        }
    }
    UnlockConsole(Console);
    return Status;

SrvSetConsoleDisplayModeFailure:
    if (hEvent) {
        NtSetEvent(hEvent, NULL);
        NtClose(hEvent);
    }

    UnlockConsole(Console);
    return Status;
}

VOID
UnregisterVDM(
    IN PCONSOLE_INFORMATION Console
    )
{
// williamh, Feb 2 1994.
// catch multiple calls to unregister vdm. Believe it or not, this could
// happen
    ASSERT(Console->Flags & CONSOLE_VDM_REGISTERED);
    if (!(Console->Flags & CONSOLE_VDM_REGISTERED))
        return;

#if defined(FE_SB) && defined(i386)
// When HDOS apps exit, console screen resolution is changed to 640*400. Because HBIOS set
// Screen resolution to 640*400. So, we should replace current screen resoultion(640*480).
// 09/11/96 bklee
    {

    if ((Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE)  &&
        ( Console->OutputCP == KOREAN_CP ||
         (Console->OutputCP == JAPAN_CP && ISNECPC98(gdwMachineId) ) )) {

         ULONG Index;
         DEVMODEW Devmode;
         BOOL fGraphics = fFullScreenGraphics ? IsAvailableFsCodePage(Console->OutputCP) : FALSE;

         Index = Console->CurrentScreenBuffer->BufferInfo.TextInfo.ModeIndex;

         ZeroMemory(&Devmode, sizeof(Devmode));

         Devmode.dmSize = sizeof(Devmode);
         Devmode.dmDriverExtra = 0;
         Devmode.dmFields = DM_BITSPERPEL   |
                            DM_PELSWIDTH    |
                            DM_PELSHEIGHT   |
                            DM_DISPLAYFLAGS;

         Devmode.dmBitsPerPel   = 4;

         Devmode.dmPelsWidth  = RegModeFontPairs[Index].Resolution.X;
         Devmode.dmPelsHeight = RegModeFontPairs[Index].Resolution.Y;
         Devmode.dmDisplayFlags = (fGraphics && (RegModeFontPairs[Index].Mode & FS_MODE_GRAPHICS)) ? 0 : DMDISPLAYFLAGS_TEXTMODE;

         GdiFullscreenControl(FullscreenControlSetMode,
                              &Devmode,
                              sizeof(Devmode),
                              NULL,
                              NULL);
    }
    }
#endif
#ifdef i386
    if (Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE &&
        Console->Flags & CONSOLE_CONNECTED_TO_EMULATOR) {
    NtUserConsoleControl(ConsoleSetVDMCursorBounds, NULL, 0);
        // connect emulator
        ConnectToEmulator(FALSE, Console);
    }

    if (FullScreenInitialized) {
        CloseHandle(Console->VDMStartHardwareEvent);
        CloseHandle(Console->VDMEndHardwareEvent);
        if (Console->VDMErrorHardwareEvent) {
            CloseHandle(Console->VDMErrorHardwareEvent);
            Console->VDMErrorHardwareEvent = NULL;
        }
        NtUnmapViewOfSection(NtCurrentProcess(), Console->StateBuffer);
        NtUnmapViewOfSection(Console->VDMProcessHandle, Console->StateBufferClient);
        NtClose(Console->StateSectionHandle);
        Console->StateLength = 0;
    }

#endif

    Console->Flags &= ~CONSOLE_VDM_REGISTERED;

    if (Console->Flags & CONSOLE_HAS_FOCUS) {
        USERTHREAD_FLAGS Flags;

        Flags.dwFlags = 0;
        Flags.dwMask = (TIF_VDMAPP | TIF_DOSEMULATOR);
        NtUserSetInformationThread(Console->InputThreadInfo->ThreadHandle,
                UserThreadFlags, &Flags, sizeof(Flags));
    }
    Console->Flags &= ~CONSOLE_WOW_REGISTERED;
    ASSERT(Console->VDMBuffer != NULL);
    if (Console->VDMBuffer != NULL) {
        NtUnmapViewOfSection(Console->VDMProcessHandle, Console->VDMBufferClient);
        NtUnmapViewOfSection(NtCurrentProcess(), Console->VDMBuffer);
        NtClose(Console->VDMBufferSectionHandle);
        Console->VDMBuffer = NULL;
    }
#ifdef i386
    if (Console->CurrentScreenBuffer &&
        Console->CurrentScreenBuffer->Flags & CONSOLE_TEXTMODE_BUFFER) {
        Console->CurrentScreenBuffer->BufferInfo.TextInfo.MousePosition.X = 0;
        Console->CurrentScreenBuffer->BufferInfo.TextInfo.MousePosition.Y = 0;
    }
#endif
    ASSERT(Console->VDMProcessHandle);
    CloseHandle(Console->VDMProcessHandle);
    Console->VDMProcessHandle = NULL;

#if defined(FE_SB) && defined(FE_IME) && defined(i386)
    {
        if (Console->FullScreenFlags & CONSOLE_FULLSCREEN) {
            Console->Flags |= CONSOLE_JUST_VDM_UNREGISTERED ;
        }
        else if (Console->CurrentScreenBuffer->Flags & CONSOLE_TEXTMODE_BUFFER) {
            AdjustCursorPosition(Console->CurrentScreenBuffer,
                                 Console->CurrentScreenBuffer->BufferInfo.TextInfo.CursorPosition,
                                 TRUE,
                                 NULL);
        }
    }
#endif
}

ULONG
SrvRegisterConsoleVDM(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_REGISTERVDM_MSG a = (PCONSOLE_REGISTERVDM_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    SIZE_T ViewSize;
#ifdef i386
    VIDEO_REGISTER_VDM RegisterVdm;
    ULONG RegisterVdmSize = sizeof(RegisterVdm);
    VIDEO_VDM Vdm;
#endif  //i386
    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (a->RegisterFlags & CONSOLE_REGISTER_VDM) {
        ConsoleNotifyWinEvent(Console,
                              EVENT_CONSOLE_START_APPLICATION,
                              HandleToUlong(CONSOLE_CLIENTPROCESSID()),
                              CONSOLE_APPLICATION_16BIT);
    } else if (a->RegisterFlags == 0) {
        ConsoleNotifyWinEvent(Console,
                              EVENT_CONSOLE_END_APPLICATION,
                              HandleToUlong(CONSOLE_CLIENTPROCESSID()),
                              CONSOLE_APPLICATION_16BIT);
    }


    if (!a->RegisterFlags) {
//      williamh, Jan 28 1994
//      do not do an assert here because we may have unregistered the ntvdm
//      and the ntvdm doesn't necessarily know this(and it could post another
//      unregistervdm). Return error here so NTVDM knows what to do
//      ASSERT(Console->Flags & CONSOLE_VDM_REGISTERED);

        if (Console->Flags & CONSOLE_VDM_REGISTERED) {
            ASSERT(!(Console->Flags & CONSOLE_FULLSCREEN_NOPAINT));
            UnregisterVDM(Console);
#ifdef i386
            if (Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE &&
                Console->CurrentScreenBuffer->Flags & CONSOLE_TEXTMODE_BUFFER) {
                // SetVideoMode(Console->CurrentScreenBuffer);
                // Set up cursor
                SetCursorInformationHW(Console->CurrentScreenBuffer,
                                       Console->CurrentScreenBuffer->BufferInfo.TextInfo.CursorSize,
                                       Console->CurrentScreenBuffer->BufferInfo.TextInfo.CursorVisible);
                SetCursorPositionHW(Console->CurrentScreenBuffer,
                                    Console->CurrentScreenBuffer->BufferInfo.TextInfo.CursorPosition);
            }
#endif // i386
            Status = STATUS_SUCCESS;
        } else {
            Status = STATUS_ACCESS_DENIED;
        }
        UnlockConsole(Console);
        return Status;
    }

    if (!CsrValidateMessageBuffer(m, &a->VDMBufferSectionName, a->VDMBufferSectionNameLength, sizeof(BYTE))) {

        UnlockConsole(Console);
        return STATUS_INVALID_PARAMETER;
    }

    // check it out. A console should have only one VDM registered.
    ASSERT(!(Console->Flags & CONSOLE_VDM_REGISTERED));

    if (Console->Flags & CONSOLE_VDM_REGISTERED) {
        UnlockConsole(Console);
        return (ULONG) STATUS_ACCESS_DENIED;
    }

    ASSERT(!Console->VDMProcessHandle);

    Status = NtDuplicateObject(NtCurrentProcess(), CONSOLE_CLIENTPROCESSHANDLE(),
                               NtCurrentProcess(), &Console->VDMProcessHandle,
                               0, FALSE, DUPLICATE_SAME_ACCESS);
    if (!NT_SUCCESS(Status)) {
        UnlockConsole(Console);
        return Status;
    }
    Console->VDMProcessId = CONSOLE_CLIENTPROCESSID();

#ifdef i386

    Vdm.ProcessHandle = Console->VDMProcessHandle;

    //
    // Assume fullscreen initialization will fail.
    // have state length set to zero so that NTVDM will know
    // full screen is disabled.
    //

    a->StateLength = 0;
    Console->StateLength = 0;
    Console->StateBufferClient = NULL;
    Console->VDMErrorHardwareEvent = NULL;

    if (FullScreenInitialized) {

        Status = NtDuplicateObject(CONSOLE_CLIENTPROCESSHANDLE(),
                                   a->StartEvent,
                                   NtCurrentProcess(),
                                   &Console->VDMStartHardwareEvent,
                                   0,
                                   FALSE,
                                   DUPLICATE_SAME_ACCESS
                                  );
        if (NT_SUCCESS(Status)) {
            Status = NtDuplicateObject(CONSOLE_CLIENTPROCESSHANDLE(),
                                       a->EndEvent,
                                       NtCurrentProcess(),
                                       &Console->VDMEndHardwareEvent,
                                       0,
                                       FALSE,
                                       DUPLICATE_SAME_ACCESS
                                      );
            if (NT_SUCCESS(Status)) {
                if (a->ErrorEvent) {
                    Status = NtDuplicateObject(CONSOLE_CLIENTPROCESSHANDLE(),
                                               a->ErrorEvent,
                                               NtCurrentProcess(),
                                               &Console->VDMErrorHardwareEvent,
                                               0,
                                               FALSE,
                                               DUPLICATE_SAME_ACCESS
                                              );
                }
                if (NT_SUCCESS(Status)) {
                    Status = GdiFullscreenControl(FullscreenControlRegisterVdm,
                                                  &Vdm,
                                                  sizeof(Vdm),
                                                  &RegisterVdm,
                                                  &RegisterVdmSize
                                                 );

                    if (NT_SUCCESS(Status)) {

                        //
                        // create state section and map a view of it into server and vdm.
                        // this section is used to get/set video hardware state during
                        // the fullscreen<->windowed transition.  we create the section
                        // instead of the vdm for security purposes.
                        //

                        Status = MapViewOfSection(&Console->StateSectionHandle,
                                                  RegisterVdm.MinimumStateSize,
                                                  &Console->StateBuffer,
                                                  &ViewSize,
                                                  Console->VDMProcessHandle,
                                                  &a->StateBuffer
                                                 );

                        if (NT_SUCCESS(Status)) {
                            a->StateLength = RegisterVdm.MinimumStateSize;
                            Console->StateLength = RegisterVdm.MinimumStateSize;
                            Console->StateBufferClient = a->StateBuffer;
                        } else {
                            CloseHandle(Console->VDMStartHardwareEvent);
                            CloseHandle(Console->VDMEndHardwareEvent);
                            if (Console->VDMErrorHardwareEvent) {
                                CloseHandle(Console->VDMErrorHardwareEvent);
                            }
                        }

                    } else {

                        CloseHandle(Console->VDMStartHardwareEvent);
                        CloseHandle(Console->VDMEndHardwareEvent);
                        if (Console->VDMErrorHardwareEvent) {
                            CloseHandle(Console->VDMErrorHardwareEvent);
                        }
                    }
                } else {
                    CloseHandle(Console->VDMStartHardwareEvent);
                    CloseHandle(Console->VDMEndHardwareEvent);
                }

            } else {

                CloseHandle(Console->VDMStartHardwareEvent);
            }

        }

        //
        // If we failed to duplicate screen switch events or map
        // view to video state shared buffer, fail this API.
        //
        if (!NT_SUCCESS(Status)) {
            UnlockConsole(Console);
            return Status;
        }
    }

#endif // i386

    //
    // Create vdm char section and map a view of it into server and vdm.
    // This section is used by the vdm to update the screen when in a
    // charmode window. This is a performance optimization. We create
    // the section instead of the vdm for security purposes.
    //

    Status = MapViewOfSection(&Console->VDMBufferSectionHandle,
#ifdef i386
                              a->VDMBufferSize.X * a->VDMBufferSize.Y * 2,
#else
                              a->VDMBufferSize.X * a->VDMBufferSize.Y * 4,
#endif // i386
                              &Console->VDMBuffer,
                              &ViewSize,
                              Console->VDMProcessHandle,
                              &a->VDMBuffer
                             );
    if (!NT_SUCCESS(Status)) {

        Console->VDMBuffer = NULL;

#ifdef i386

        if (FullScreenInitialized) {

            NtUnmapViewOfSection(NtCurrentProcess(), Console->StateBuffer);
            NtUnmapViewOfSection(Console->VDMProcessHandle, Console->StateBufferClient);
            NtClose(Console->StateSectionHandle);
            CloseHandle(Console->VDMStartHardwareEvent);
            CloseHandle(Console->VDMEndHardwareEvent);
            if (Console->VDMErrorHardwareEvent) {
                CloseHandle(Console->VDMErrorHardwareEvent);
            }
        }

#endif // i386
        CloseHandle(Console->VDMProcessHandle);
        Console->VDMProcessHandle = NULL;
        UnlockConsole(Console);
        return Status;
    }
    Console->VDMBufferClient = a->VDMBuffer;

    Console->Flags |= CONSOLE_VDM_REGISTERED;

    if (Console->Flags & CONSOLE_HAS_FOCUS) {
        USERTHREAD_FLAGS Flags;

        Flags.dwFlags = TIF_VDMAPP;
        Flags.dwMask = TIF_VDMAPP;
        NtUserSetInformationThread(Console->InputThreadInfo->ThreadHandle,
                                   UserThreadFlags,
                                   &Flags,
                                   sizeof(Flags));
    }
    Console->VDMBufferSize = a->VDMBufferSize;

    if (a->RegisterFlags & CONSOLE_REGISTER_WOW) {
        Console->Flags |= CONSOLE_WOW_REGISTERED;
    } else {
        Console->Flags &= ~CONSOLE_WOW_REGISTERED;
    }

    //
    // If we're already in fullscreen and we run a DOS app for
    // the first time, connect the emulator.
    //

#ifdef i386
    if (Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) {
        RECT CursorRect = {-32767, -32767, 32767, 32767};
        NtUserConsoleControl(ConsoleSetVDMCursorBounds, &CursorRect, sizeof(RECT));

        ASSERT(!(Console->Flags & CONSOLE_CONNECTED_TO_EMULATOR));
        ConnectToEmulator(TRUE, Console);
    }
#endif

    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

NTSTATUS
SrvConsoleNotifyLastClose(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_NOTIFYLASTCLOSE_MSG a = (PCONSOLE_NOTIFYLASTCLOSE_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;

    UNREFERENCED_PARAMETER(ReplyStatus);

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Don't allow two or more processes to have last-close notify on
    // the same console.
    //
    if (Console->Flags & CONSOLE_NOTIFY_LAST_CLOSE) {
        UnlockConsole(Console);
        return STATUS_ACCESS_DENIED;
    }

    Status = NtDuplicateObject(NtCurrentProcess(), CONSOLE_CLIENTPROCESSHANDLE(),
                               NtCurrentProcess(),
                               &Console->hProcessLastNotifyClose,
                               0, FALSE, DUPLICATE_SAME_ACCESS
                               );
    if (!NT_SUCCESS(Status)) {
        UnlockConsole(Console);
        return Status;
    }

    Console->Flags |= CONSOLE_NOTIFY_LAST_CLOSE;
    Console->ProcessIdLastNotifyClose = CONSOLE_CLIENTPROCESSID();
    UnlockConsole(Console);
    return Status;
}

NTSTATUS
MapViewOfSection(
    PHANDLE SectionHandle,
    ULONG CommitSize,
    PVOID *BaseAddress,
    PSIZE_T ViewSize,
    HANDLE ClientHandle,
    PVOID *BaseClientAddress
    )
{

    OBJECT_ATTRIBUTES Obja;
    NTSTATUS Status;
    LARGE_INTEGER secSize;

    //
    // open section and map a view of it.
    //
    InitializeObjectAttributes(
        &Obja,
        NULL,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    secSize.QuadPart = CommitSize;
    Status = NtCreateSection (SectionHandle,
                              SECTION_ALL_ACCESS,
                              &Obja,
                              &secSize,
                              PAGE_READWRITE,
                              SEC_RESERVE,
                              NULL
                             );
    if (!NT_SUCCESS(Status)) {
        return((ULONG) Status);
    }

    *BaseAddress = 0;
    *ViewSize = 0;

    Status = NtMapViewOfSection(*SectionHandle,
                                NtCurrentProcess(),
                                BaseAddress,        // Receives the base
                                                    // address of the section.

                                0,                  // No specific type of
                                                    // address required.

                                CommitSize,         // Commit size. It was
                                                    // passed by the caller.
                                                    // NULL for a save, and
                                                    // size of the section
                                                    // for a set.

                                NULL,               // Section offset it NULL;
                                                    // Map from the start.

                                ViewSize,           // View Size is NULL since
                                                    // we want to map the
                                                    // entire section.

                                ViewUnmap,
                                0L,
                                PAGE_READWRITE
                               );
    if (!NT_SUCCESS(Status)) {
        NtClose(*SectionHandle);
        return Status;
    }

    *BaseClientAddress = 0;
    *ViewSize = 0;
    Status = NtMapViewOfSection(*SectionHandle,
                                ClientHandle,
                                BaseClientAddress,  // Receives the base
                                                    // address of the section.

                                0,                  // No specific type of
                                                    // address required.

                                CommitSize,         // Commit size. It was
                                                    // passed by the caller.
                                                    // NULL for a save, and
                                                    // size of the section
                                                    // for a set.

                                NULL,               // Section offset it NULL;
                                                    // Map from the start.

                                ViewSize,           // View Size is NULL since
                                                    // we want to map the
                                                    // entire section.

                                ViewUnmap,
// williamh, Jan 28 1994
// This MEM_TOP_DOWN is necessary.
// if the console has VDM registered, ntvdm would have released its video memory
// address space(0xA0000 ~ 0xBFFFF). Without the MEM_TOP_DOWN, the
// NtMapViewOfSection can grab the address space and we will have trouble of
// mapping the address space to the physical video ram. We don't do a test
// for VDM because there is no harm of doing this for non-vdm application.
                                MEM_TOP_DOWN,
                                PAGE_READWRITE
                               );
    if (!NT_SUCCESS(Status)) {
        NtClose(*SectionHandle);
    }
    return((ULONG) Status);
}

NTSTATUS
ConnectToEmulator(
    IN BOOL Connect,
    IN PCONSOLE_INFORMATION Console
    )
{
    NTSTATUS Status;
    FULLSCREENCONTROL fsctl;
    VIDEO_VDM ConnectInfo;
    HANDLE ProcessHandle = Console->VDMProcessHandle;
    USERTHREAD_FLAGS Flags;

    DBGFULLSCR(("ConnectToEmulator :  %s - entering\n", Connect ? "CONNECT" : "DISCONNECT"));

    Flags.dwMask = TIF_DOSEMULATOR;
    if (Connect) {
        fsctl = FullscreenControlEnable;
        Console->Flags |= CONSOLE_CONNECTED_TO_EMULATOR;
        Flags.dwFlags = TIF_DOSEMULATOR;
    } else {
        fsctl = FullscreenControlDisable;
        Console->Flags &= ~CONSOLE_CONNECTED_TO_EMULATOR;
        Flags.dwFlags = 0;
    }

    if (Console->Flags & CONSOLE_HAS_FOCUS) {
        NtUserSetInformationThread(Console->InputThreadInfo->ThreadHandle,
                UserThreadFlags, &Flags, sizeof(Flags));
    }

    ConnectInfo.ProcessHandle = ProcessHandle;


    Status = GdiFullscreenControl(fsctl,
                                     &ConnectInfo,
                                     sizeof(ConnectInfo),
                                     NULL,
                                     NULL);

    ASSERT(Status == STATUS_SUCCESS || Status == STATUS_PROCESS_IS_TERMINATING);

    DBGFULLSCR(("ConnectToEmulator : leaving, staus = %08lx\n", Status));

    return Status;
}

#define CONSOLE_VDM_TIMEOUT 200000

NTSTATUS
DisplayModeTransition(
    IN BOOL bForeground,
    IN PCONSOLE_INFORMATION Console,
    IN PSCREEN_INFORMATION ScreenInfo
    )
{
#ifdef i386
    NTSTATUS Status;
    LARGE_INTEGER li;
    DWORD WaitCount;
    HANDLE WaitHandles[2];

    if (!FullScreenInitialized || GetSystemMetrics(SM_REMOTESESSION))
        return STATUS_SUCCESS;

    WaitCount = 1;
    WaitHandles[0] = Console->VDMEndHardwareEvent;
    if (Console->VDMErrorHardwareEvent) {
        WaitHandles[1] = Console->VDMErrorHardwareEvent;
        WaitCount++;
    }

    if (bForeground) {

        PSCREEN_INFORMATION ScreenInfo = Console->CurrentScreenBuffer;
        LARGE_INTEGER li;
        NTSTATUS Status;

        KdPrint(("    CONSRV - Display Mode transition to fullscreen \n"));

        if (!(Console->FullScreenFlags & CONSOLE_FULLSCREEN)) {
            KdPrint(("CONSRV: received fullscreen message too early\n"));
            return STATUS_UNSUCCESSFUL;
        }

        Console->FullScreenFlags |= CONSOLE_FULLSCREEN_HARDWARE;

        //
        // Fire off an event to let accessibility apps know the layout has
        // changed. We only want to do this while going *to* full-screen;
        // on the way back we'll send this event from InternalUpdateScrollBars.
        //
        ConsoleNotifyWinEvent(ScreenInfo->Console,
                              EVENT_CONSOLE_LAYOUT,
                              0,
                              0);

        if (!(ScreenInfo->Flags & CONSOLE_GRAPHICS_BUFFER)) {
#if defined(FE_SB)
            BOOL fGraphics = fFullScreenGraphics ? IsAvailableFsCodePage(Console->OutputCP) : FALSE;
#endif
#if 1
            DEVMODEW Devmode;
            ULONG Index;

            KdPrint(("CONSRV: ChangeDispSettings fullscreen\n"));

            Index = Console->CurrentScreenBuffer->BufferInfo.TextInfo.ModeIndex;

            //
            // set mode to go to full screen
            //

            ZeroMemory(&Devmode, sizeof(Devmode));

            Devmode.dmSize = sizeof(Devmode);
            Devmode.dmDriverExtra = 0;
            Devmode.dmFields = DM_BITSPERPEL   |
                               DM_PELSWIDTH    |
                               DM_PELSHEIGHT   |
                               DM_DISPLAYFLAGS;

            Devmode.dmBitsPerPel   = 4;
#if defined(FE_SB)
            Devmode.dmPelsWidth    = RegModeFontPairs[Index].Resolution.X;
            Devmode.dmPelsHeight   = RegModeFontPairs[Index].Resolution.Y;
            Devmode.dmDisplayFlags = (fGraphics && (RegModeFontPairs[Index].Mode & FS_MODE_GRAPHICS)) ? 0 : DMDISPLAYFLAGS_TEXTMODE;
#else
            Devmode.dmPelsWidth    = ModeFontPairs[Index].Resolution.X;
            Devmode.dmPelsHeight   = ModeFontPairs[Index].Resolution.Y;
            Devmode.dmDisplayFlags = DMDISPLAYFLAGS_TEXTMODE;
#endif

            if (NT_SUCCESS(GdiFullscreenControl(FullscreenControlSetMode,
                                                   &Devmode,
                                                   sizeof(Devmode),
                                                   NULL,
                                                   NULL)))
            {
#endif
                // set video mode and font
                if (SetVideoMode(ScreenInfo)) {

#if defined(FE_SB)
                    if (!(Console->Flags & CONSOLE_VDM_REGISTERED)) {
                        int     i ;
                        for (i = 0 ; i < ScreenInfo->ScreenBufferSize.Y; i++) {
                            ScreenInfo->BufferInfo.TextInfo.Rows[i].CharRow.OldLeft = INVALID_OLD_LENGTH ;
                            ScreenInfo->BufferInfo.TextInfo.Rows[i].CharRow.OldRight = INVALID_OLD_LENGTH ;
                        }
                    }
#endif
                    //set up cursor

                    SetCursorInformationHW(ScreenInfo,
                                    ScreenInfo->BufferInfo.TextInfo.CursorSize,
                                    ScreenInfo->BufferInfo.TextInfo.CursorVisible);
                    SetCursorPositionHW(ScreenInfo,
                                    ScreenInfo->BufferInfo.TextInfo.CursorPosition);
                }
            }
        }

        // tell VDM to unmap memory

        if (Console->Flags & CONSOLE_VDM_REGISTERED) {
            li.QuadPart = (LONGLONG)-10000 * CONSOLE_VDM_TIMEOUT;
            Status = NtSetEvent(Console->VDMStartHardwareEvent, NULL);
            if (NT_SUCCESS(Status)) {
                Status = NtWaitForMultipleObjects(WaitCount, WaitHandles, WaitAny, FALSE, &li);
            }
            if (Status != 0) {
               Console->Flags &= ~CONSOLE_FULLSCREEN_NOPAINT;
               UnregisterVDM(Console);
               KdPrint(("CONSRV: VDM not responding.\n"));
            }
        }

        if (!(ScreenInfo->Flags & CONSOLE_GRAPHICS_BUFFER)) {

            WriteRegionToScreen(ScreenInfo, &ScreenInfo->Window);
        }

        if (Console->Flags & CONSOLE_VDM_REGISTERED) {

            // connect emulator and map memory into the VDMs address space.
            ASSERT(!(Console->Flags & CONSOLE_CONNECTED_TO_EMULATOR));

            Status = ConnectToEmulator(TRUE, Console);

            if (NT_SUCCESS(Status)) {

                VIDEO_HARDWARE_STATE State;
                ULONG StateSize = sizeof(State);

                State.StateHeader = Console->StateBuffer;
                State.StateLength = Console->StateLength;


                Status = GdiFullscreenControl(FullscreenControlRestoreHardwareState,
                                                 &State,
                                                 StateSize,
                                                 &State,
                                                 &StateSize);
            }

            if (Status != STATUS_SUCCESS) {
                Console->Flags &= ~CONSOLE_FULLSCREEN_NOPAINT;
                UnregisterVDM(Console);
                KdPrint(("CONSRV: set hardware state failed.\n"));
            } else {

                //
                // tell VDM that it's getting the hardware.
                //

                RECT CursorRect;
                CursorRect.left = -32767;
                CursorRect.top = -32767;
                CursorRect.right = 32767;
                CursorRect.bottom = 32767;
                NtUserConsoleControl(ConsoleSetVDMCursorBounds,
                        &CursorRect, sizeof(RECT));

                // wait for vdm to say ok. We could initiate another switch
                // (set hStartHardwareEvent which vdm is now waiting for to
                // complete the handshaking) when we return (WM_FULLSCREEN
                // could be in the message queue already). If we don't wait
                // for vdm to get signaled here, the hStartHardwareEvent
                // can get set twice and signaled once so the vdm will never
                // gets the newly switch request we may post after return.
                NtSetEvent(Console->VDMStartHardwareEvent, NULL);
                NtWaitForMultipleObjects(WaitCount, WaitHandles, WaitAny, FALSE, &li);
                // no need to check time out here
            }
        }

        //
        // let the app know that it has the focus.
        //

        HandleFocusEvent(Console, TRUE);

        // unset palette

        if (ScreenInfo->hPalette != NULL) {
            SelectPalette(ScreenInfo->Console->hDC,
                             ScreenInfo->Console->hSysPalette,
                             FALSE);
            UnsetActivePalette(ScreenInfo);
        }
        SetConsoleReserveKeys(Console->hWnd, Console->ReserveKeys);
        HandleFocusEvent(Console, TRUE);

    } else {

        KdPrint(("    CONSRV - Display Mode transition to windowed \n"));

        //
        // Check first to see if we're not already fullscreen. If we aren't,
        // don't allow this. Temporary BETA fix till USER gets fixed.
        //
        if (!(Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE)) {
            KdPrint(("CONSRV: received multiple windowed messages\n"));
            return STATUS_SUCCESS;
        }

        // turn off mouse pointer so VDM doesn't see it when saving
        // hardware
        if (!(ScreenInfo->Flags & CONSOLE_GRAPHICS_BUFFER)) {
            ReverseMousePointer(ScreenInfo, &ScreenInfo->Window);
        }


        Console->FullScreenFlags &= ~CONSOLE_FULLSCREEN_HARDWARE;
        if (Console->Flags & CONSOLE_VDM_REGISTERED) {

            //
            // tell vdm that it's losing the hardware
            //

            li.QuadPart = (LONGLONG)-10000 * CONSOLE_VDM_TIMEOUT;
            Status = NtSetEvent(Console->VDMStartHardwareEvent, NULL);
            if (NT_SUCCESS(Status)) {
                Status = NtWaitForMultipleObjects(WaitCount, WaitHandles, WaitAny, FALSE, &li);
                if (Status == STATUS_TIMEOUT || Status == 1) {
                    Status = STATUS_UNSUCCESSFUL;
                }
            }

            // if ntvdm didn't respond or we failed to save the video hardware
            // states, kick ntvdm out of our world. The ntvdm process eventually
            // would die but what choice do have here?

            if (NT_SUCCESS(Status)) {

                VIDEO_HARDWARE_STATE State;
                ULONG StateSize = sizeof(State);

                State.StateHeader = Console->StateBuffer;
                State.StateLength = Console->StateLength;


                Status = GdiFullscreenControl(FullscreenControlSaveHardwareState,
                                                 &State,
                                                 StateSize,
                                                 &State,
                                                 &StateSize);
            }

            if (NT_SUCCESS(Status)) {


                NtUserConsoleControl(ConsoleSetVDMCursorBounds, NULL, 0);

                // disconnect emulator and unmap video memory

                ASSERT(Console->Flags & CONSOLE_CONNECTED_TO_EMULATOR);
                ConnectToEmulator(FALSE, Console);

            } else {

                Console->Flags &= ~CONSOLE_FULLSCREEN_NOPAINT;
                UnregisterVDM(Console);
                if (Status != 0) {
                    KdPrint(("CONSRV: VDM not responding.\n"));
                }
                else
                    KdPrint(("CONSRV: Save Video States Failed\n"));

            }
        }

        // tell VDM to map memory

        if (Console->Flags & CONSOLE_VDM_REGISTERED) {

            // make a special case for ntvdm during switching because
            // ntvdm has to make console api calls. We don't want to
            // unlock the console at this moment because as soon as
            // we release the lock, other theads which are waiting
            // for the lock will claim the lock and the ntvdm thread doing
            // the screen switch will have to wait for the lock. In an
            // extreme case, the following NtWaitForSingleObject will time
            // out because the ntvdm may be still waiting for the lock.
            // We keep this thing in a single global variable because
            // there is only one process who can own the screen at any moment.

            RtlEnterCriticalSection(&ConsoleVDMCriticalSection);
            ConsoleVDMOnSwitching = Console;
            RtlLeaveCriticalSection(&ConsoleVDMCriticalSection);
            li.QuadPart = (LONGLONG)-10000 * CONSOLE_VDM_TIMEOUT;
            Status = NtSetEvent(Console->VDMStartHardwareEvent, NULL);
            if (NT_SUCCESS(Status)) {
                Status = NtWaitForMultipleObjects(WaitCount, WaitHandles, WaitAny, FALSE, &li);
            }

            // time to go back to normal
            RtlEnterCriticalSection(&ConsoleVDMCriticalSection);
            ConsoleVDMOnSwitching = NULL;
            RtlLeaveCriticalSection(&ConsoleVDMCriticalSection);

            if (Status != 0) {
                Console->Flags &= ~CONSOLE_FULLSCREEN_NOPAINT;
                UnregisterVDM(Console);
                KdPrint(("CONSRV: VDM not responding. - second wait\n"));
                return Status;
            }
            ScreenInfo = Console->CurrentScreenBuffer;
        }

        // set palette

        if (ScreenInfo->hPalette != NULL) {
            SelectPalette(ScreenInfo->Console->hDC,
                             ScreenInfo->hPalette,
                             FALSE);
            SetActivePalette(ScreenInfo);
        }
        SetConsoleReserveKeys(Console->hWnd, CONSOLE_NOSHORTCUTKEY);
        HandleFocusEvent(Console, FALSE);

    }

    /*
     * Boost or lower the priority if we are going fullscreen or away.
     *
     * Note that console usually boosts and lowers its priority based
     * on WM_FOCUS and WM_KILLFOCUS but when you switch to full screen
     * the implementation actually sends a WM_KILLFOCUS so we reboost the
     * correct console here.
     */
    ModifyConsoleProcessFocus(Console, bForeground);


#else
    UNREFERENCED_PARAMETER(bForeground);
    UNREFERENCED_PARAMETER(Console);
    UNREFERENCED_PARAMETER(ScreenInfo);
#endif
    return STATUS_SUCCESS;
}

#if defined(_X86_)

BOOL
SetVideoMode(
    IN PSCREEN_INFORMATION ScreenInfo
    )
{
    NTSTATUS Status;
    UINT i, j;

#if defined(FE_SB)
    //
    // load RAM font
    //

    Status = SetRAMFontCodePage(ScreenInfo);
#endif

    //
    // load ROM font
    //

    Status = SetROMFontCodePage(ScreenInfo->Console->OutputCP,
                                ScreenInfo->BufferInfo.TextInfo.ModeIndex);

    if (Status == STATUS_INVALID_PARAMETER) {
        Status = SetROMFontCodePage(GetOEMCP(),
                                    ScreenInfo->BufferInfo.TextInfo.ModeIndex);

        if (Status == STATUS_INVALID_PARAMETER) {
            Status = SetROMFontCodePage(CONSOLE_DEFAULT_ROM_FONT,
                                        ScreenInfo->BufferInfo.TextInfo.ModeIndex);
        }
    }

    //
    // initialize palette
    //

#if defined(FE_SB)
    Status = GdiFullscreenControl(FullscreenControlSetPalette,
                                  (PVOID) RegInitialPalette,
                                  RegInitialPalette[0] * sizeof(USHORT) + sizeof(DWORD),
                                  NULL,
                                  NULL);
#else
    Status = GdiFullscreenControl(FullscreenControlSetPalette,
                                  (PVOID) &InitialPalette,
                                  sizeof (InitialPalette),
                                  NULL,
                                  NULL);
#endif

    if (Status != STATUS_SUCCESS) {
        RIPMSG1(RIP_WARNING, "FullscreenControlSetPalette failed - Status = 0x%x",
                Status);
        return FALSE;
    }

    //
    // initialize color table
    //

#if defined(FE_SB)
    if (RegColorBufferNoTranslate)
    {
        Status = GdiFullscreenControl(FullscreenControlSetColors,
                                      (PVOID) RegColorBufferNoTranslate,
                                      RegColorBufferNoTranslate[0] * sizeof(DWORD) + sizeof(DWORD),
                                      NULL,
                                      NULL);
    }
    else
    {
        for (i = 0, j = 4; i < 16; i++) {
            RegColorBuffer[j++] = ((((GetRValue(ScreenInfo->Console->ColorTable[i]) +
                                      0x2A) * 0x02) / 0x55) * 0x15) / 0x02;
            RegColorBuffer[j++] = ((((GetGValue(ScreenInfo->Console->ColorTable[i]) +
                                      0x2A) * 0x02) / 0x55) * 0x15) / 0x02;
            RegColorBuffer[j++] = ((((GetBValue(ScreenInfo->Console->ColorTable[i]) +
                                      0x2A) * 0x02) / 0x55) * 0x15) / 0x02;
            RegColorBuffer[j++] = 0;
        }

        Status = GdiFullscreenControl(FullscreenControlSetColors,
                                      (PVOID) RegColorBuffer,
                                      RegColorBuffer[0] * sizeof(DWORD) + sizeof(DWORD),
                                      NULL,
                                      NULL);
    }
#else
    for (i = 0, j = 4; i < 16; i++) {
        ColorBuffer[j++] = ((((GetRValue(ScreenInfo->Console->ColorTable[i]) +
                               0x2A) * 0x02) / 0x55) * 0x15) / 0x02;
        ColorBuffer[j++] = ((((GetGValue(ScreenInfo->Console->ColorTable[i]) +
                               0x2A) * 0x02) / 0x55) * 0x15) / 0x02;
        ColorBuffer[j++] = ((((GetBValue(ScreenInfo->Console->ColorTable[i]) +
                               0x2A) * 0x02) / 0x55) * 0x15) / 0x02;
        ColorBuffer[j++] = 0;
    }

    Status = GdiFullscreenControl(FullscreenControlSetColors,
                                     (PVOID) &ColorBuffer,
                                     sizeof (ColorBuffer),
                                     NULL,
                                     NULL);
#endif

    if (Status != STATUS_SUCCESS) {
        RIPMSG1(RIP_WARNING, "FullscreenControlSetColors failed - Status = 0x%x",
                Status);
        return FALSE;
    }

    return TRUE;
}
#endif


#if defined(_X86_)

NTSTATUS
ChangeDispSettings(
    PCONSOLE_INFORMATION Console,
    HWND hwnd,
    DWORD dwFlags)
{
    DEVMODEW Devmode;
    ULONG Index;
    CONSOLE_FULLSCREEN_SWITCH switchBlock;

    if (dwFlags == CDS_FULLSCREEN)
    {
#if defined(FE_SB)
        BOOL fGraphics = fFullScreenGraphics ? IsAvailableFsCodePage(Console->OutputCP) : FALSE;
#endif

        KdPrint(("CONSRV: ChangeDispSettings fullscreen\n"));

        Index = Console->CurrentScreenBuffer->BufferInfo.TextInfo.ModeIndex;

        //
        // set mode to go to full screen
        //

        ZeroMemory(&Devmode, sizeof(Devmode));

        Devmode.dmSize = sizeof(Devmode);
        Devmode.dmDriverExtra = 0;
        Devmode.dmFields = DM_BITSPERPEL   |
                           DM_PELSWIDTH    |
                           DM_PELSHEIGHT   |
                           DM_DISPLAYFLAGS;

        Devmode.dmBitsPerPel   = 4;
#if defined(FE_SB)
        Devmode.dmPelsWidth    = RegModeFontPairs[Index].Resolution.X;
        Devmode.dmPelsHeight   = RegModeFontPairs[Index].Resolution.Y;
        Devmode.dmDisplayFlags = (fGraphics && (RegModeFontPairs[Index].Mode & FS_MODE_GRAPHICS)) ? 0 : DMDISPLAYFLAGS_TEXTMODE;
#else
        Devmode.dmPelsWidth    = ModeFontPairs[Index].Resolution.X;
        Devmode.dmPelsHeight   = ModeFontPairs[Index].Resolution.Y;
        Devmode.dmDisplayFlags = DMDISPLAYFLAGS_TEXTMODE;
#endif

        switchBlock.bFullscreenSwitch = TRUE;
        switchBlock.hwnd              = hwnd;
        switchBlock.pNewMode          = &Devmode;

    }
    else
    {
        KdPrint(("CONSRV: ChangeDispSettings windowed\n"));

        switchBlock.bFullscreenSwitch = FALSE;
        switchBlock.hwnd              = hwnd;
        switchBlock.pNewMode          = NULL;
    }

    return NtUserConsoleControl(ConsoleFullscreenSwitch,
                                &switchBlock,
                                sizeof(CONSOLE_FULLSCREEN_SWITCH));
}

#endif

BOOL
InitializeFullScreen( VOID )
{
    UNICODE_STRING vgaString;
    DEVMODEW devmode;
    ULONG   i;
#if !defined(FE_SB)
    BOOLEAN mode1 = FALSE;
    BOOLEAN mode2 = FALSE;
#else
    DWORD mode1 = 0;
    DWORD mode2 = 0;
#endif

    CHAR WindowsDir[CONSOLE_WINDOWS_DIR_LENGTH+CONSOLE_EGACPI_LENGTH];
    UINT WindowsDirLength;

    //
    // query number of available modes
    //

    ZeroMemory(&devmode, sizeof(DEVMODEW));
    devmode.dmSize = sizeof(DEVMODEW);

    RtlInitUnicodeString(&vgaString, L"VGACOMPATIBLE");

    DBGCHARS(("Number of modes = %d\n", NUMBER_OF_MODE_FONT_PAIRS));

    for (i=0; ; i++)
    {
        DBGCHARS(("EnumDisplaySettings %d\n", i));

        if (!(NT_SUCCESS(NtUserEnumDisplaySettings(&vgaString,
                                                   i,
                                                   &devmode,
                                                   0))))
        {
            break;
        }

#if defined(FE_SB)
        {
            ULONG Index;

            DBGCHARS(("Mode X = %d, Y = %d\n",
                     devmode.dmPelsWidth, devmode.dmPelsHeight));

            for (Index=0;Index<NUMBER_OF_MODE_FONT_PAIRS;Index++)
            {
                if ((SHORT)devmode.dmPelsWidth == RegModeFontPairs[Index].Resolution.X &&
                    (SHORT)devmode.dmPelsHeight == RegModeFontPairs[Index].Resolution.Y  )
                {
                    if (devmode.dmDisplayFlags & DMDISPLAYFLAGS_TEXTMODE)
                    {
                        if (RegModeFontPairs[Index].Mode & FS_MODE_TEXT)
                        {
                            RegModeFontPairs[Index].Mode |= FS_MODE_FIND;
                            mode1++;
                        }
                    }
                    else
                    {
                        if (RegModeFontPairs[Index].Mode & FS_MODE_GRAPHICS)
                        {
                            RegModeFontPairs[Index].Mode |= FS_MODE_FIND;
                            mode2++;
                        }
                    }
                }
            }

            DBGCHARS(("mode1 = %d, mode2 = %d\n", mode1, mode2));
        }
#else

        if (devmode.dmPelsWidth == 720 &&
            devmode.dmPelsHeight == 400)
        {
            mode1 = TRUE;
        }
        if (devmode.dmPelsWidth == 640 &&
            devmode.dmPelsHeight == 350)
        {
            mode2 = TRUE;
        }
#endif
    }

#if !defined(FE_SB)
    if (!(mode1 && mode2))
#else
    if (mode1 < 2)
#endif
    {
        //
        // One of the modes we expected to get was not returned.
        // lets just fail fullscreen initialization.
        //

        KdPrint(("CONSRV: InitializeFullScreen Missing text mode\n"));
        return FALSE;
    }

#if defined(FE_SB)
    if (mode2 > 0)
    {
        // Can do trun graphics mode.
        fFullScreenGraphics = TRUE;
    }
#endif

    //
    // open ega.cpi
    //

    WindowsDirLength = GetSystemDirectoryA(WindowsDir,
                                           CONSOLE_WINDOWS_DIR_LENGTH);
    if (WindowsDirLength == 0)
    {
        KdPrint(("CONSRV: InitializeFullScreen Finding Font file failed\n"));
        return FALSE;
    }

    RtlCopyMemory(&WindowsDir[WindowsDirLength],
                  CONSOLE_EGACPI,
                  CONSOLE_EGACPI_LENGTH);

    if ((hCPIFile = CreateFileA(WindowsDir,
                                GENERIC_READ,
                                FILE_SHARE_READ,
                                NULL,
                                OPEN_EXISTING,
                                0,
                                NULL)) == INVALID_HANDLE_VALUE)
    {
        KdPrint(("CONSRV: InitializeFullScreen Opening Font file failed\n"));
        return FALSE;
    }

    return TRUE;
}


ULONG
SrvGetConsoleHardwareState(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
#ifdef i386
    PCONSOLE_GETHARDWARESTATE_MSG a = (PCONSOLE_GETHARDWARESTATE_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    PSCREEN_INFORMATION ScreenInfo;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_READ,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {
        ScreenInfo = HandleData->Buffer.ScreenBuffer;
        if (ScreenInfo->BufferInfo.TextInfo.ModeIndex == -1) {
            UnlockConsole(Console);
            return STATUS_UNSUCCESSFUL;
        }
#if defined(FE_SB)
        a->Resolution = RegModeFontPairs[ScreenInfo->BufferInfo.TextInfo.ModeIndex].Resolution;
        a->FontSize = RegModeFontPairs[ScreenInfo->BufferInfo.TextInfo.ModeIndex].FontSize;
#else
        a->Resolution = ModeFontPairs[ScreenInfo->BufferInfo.TextInfo.ModeIndex].Resolution;
        a->FontSize = ModeFontPairs[ScreenInfo->BufferInfo.TextInfo.ModeIndex].FontSize;
#endif
    }
    UnlockConsole(Console);
    return Status;
#else
    return STATUS_UNSUCCESSFUL;
    UNREFERENCED_PARAMETER(m);
#endif
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvSetConsoleHardwareState(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
#ifdef i386
    PCONSOLE_SETHARDWARESTATE_MSG a = (PCONSOLE_SETHARDWARESTATE_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PHANDLE_DATA HandleData;
    PSCREEN_INFORMATION ScreenInfo;
    ULONG Index;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    if (!(Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE)) {
        UnlockConsole(Console);
        return STATUS_UNSUCCESSFUL;
    }
    Status = DereferenceIoHandle(CONSOLE_PERPROCESSDATA(),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_READ,
                                 &HandleData
                                );
    if (NT_SUCCESS(Status)) {
#if defined(FE_SB)
        BOOL fGraphics = fFullScreenGraphics ? IsAvailableFsCodePage(Console->OutputCP) : FALSE;
#endif
        ScreenInfo = HandleData->Buffer.ScreenBuffer;

        // match requested mode

        for (Index=0;Index<NUMBER_OF_MODE_FONT_PAIRS;Index++) {
#if defined(FE_SB)
            if (a->Resolution.X == RegModeFontPairs[Index].Resolution.X &&
                a->Resolution.Y == RegModeFontPairs[Index].Resolution.Y &&
                a->FontSize.Y == RegModeFontPairs[Index].FontSize.Y &&
                a->FontSize.X == RegModeFontPairs[Index].FontSize.X &&
                ( ( fGraphics && (RegModeFontPairs[Index].Mode & FS_GRAPHICS)==FS_GRAPHICS) ||
                  (!fGraphics && (RegModeFontPairs[Index].Mode & FS_TEXT)==FS_TEXT)           )
               ) {
                break;
            }
#else
            if (a->Resolution.X == ModeFontPairs[Index].Resolution.X &&
                a->Resolution.Y == ModeFontPairs[Index].Resolution.Y &&
                a->FontSize.Y == ModeFontPairs[Index].FontSize.Y &&
                a->FontSize.X == ModeFontPairs[Index].FontSize.X) {
                break;
            }
#endif
        }
        if (Index == NUMBER_OF_MODE_FONT_PAIRS) {
            Status = STATUS_INVALID_PARAMETER;
        } else {
            // set requested mode
            ScreenInfo->BufferInfo.TextInfo.ModeIndex = Index;
            SetVideoMode(ScreenInfo);
        }
    }
    UnlockConsole(Console);
    return Status;
#else
    return STATUS_UNSUCCESSFUL;
    UNREFERENCED_PARAMETER(m);
#endif
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvGetConsoleDisplayMode(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_GETDISPLAYMODE_MSG a = (PCONSOLE_GETDISPLAYMODE_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (NT_SUCCESS(Status)) {
        a->ModeFlags = Console->FullScreenFlags;
        UnlockConsole(Console);
    }
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvSetConsoleMenuClose(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_SETMENUCLOSE_MSG a = (PCONSOLE_SETMENUCLOSE_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;

    UNREFERENCED_PARAMETER(ReplyStatus);

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    if (a->Enable) {
        Console->Flags &= ~CONSOLE_DISABLE_CLOSE;
    } else {
        Console->Flags |= CONSOLE_DISABLE_CLOSE;
    }

    UnlockConsole(Console);
    return Status;
}


DWORD
ConvertHotKey(
    IN LPAPPKEY UserAppKey
    )
{
    DWORD wParam;

    wParam = MapVirtualKey(UserAppKey->ScanCode,1);
    if (UserAppKey->Modifier & CONSOLE_MODIFIER_SHIFT) {
        wParam |= 0x0100;
    }
    if (UserAppKey->Modifier & CONSOLE_MODIFIER_CONTROL) {
        wParam |= 0x0200;
    }
    if (UserAppKey->Modifier & CONSOLE_MODIFIER_ALT) {
        wParam |= 0x0400;
    }
    return wParam;
}

ULONG
SrvSetConsoleKeyShortcuts(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_SETKEYSHORTCUTS_MSG a = (PCONSOLE_SETKEYSHORTCUTS_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;

    UNREFERENCED_PARAMETER(ReplyStatus);

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    /*
     * We only call CsrCaptureMessageBuffer() in SetConsoleKeyShortcuts if
     * a->NumAppKeys != 0, so we only want to call CsrValidateMessageBuffer when
     * that condition's true.
     */
    if (a->NumAppKeys != 0 && !CsrValidateMessageBuffer(m, &a->AppKeys, a->NumAppKeys, sizeof(*a->AppKeys))) {
        UnlockConsole(Console);
        return STATUS_INVALID_PARAMETER;
    }

    if (a->NumAppKeys <= CONSOLE_MAX_APP_SHORTCUTS) {
        Console->ReserveKeys = a->ReserveKeys;
        if (Console->Flags & CONSOLE_HAS_FOCUS) {
            if (!(SetConsoleReserveKeys(Console->hWnd, a->ReserveKeys))) {
                Status = STATUS_INVALID_PARAMETER;
            }
        }
        if (a->NumAppKeys) {
            PostMessage(Console->hWnd,
                         WM_SETHOTKEY,
                         ConvertHotKey(a->AppKeys),
                         0
                        );
        }
    } else {
        Status = STATUS_INVALID_PARAMETER;
    }

    UnlockConsole(Console);
    return Status;
}

#ifdef i386
ULONG
MatchWindowSize(
#if defined(FE_SB)
    IN UINT CodePage,
#endif
    IN COORD WindowSize,
    OUT PCOORD pWindowSize
    )

/*++

    find the best match font.  it's the one that's the same size
    or slightly larger than the window size.

--*/
{
    ULONG i;
#if defined(FE_SB)
    BOOL fGraphics = fFullScreenGraphics ? IsAvailableFsCodePage(CodePage) : FALSE;
#endif

    for (i=0;i<NUMBER_OF_MODE_FONT_PAIRS;i++) {
#if defined(FE_SB)
        if (WindowSize.Y <= RegModeFontPairs[i].ScreenSize.Y &&
            ( ( fGraphics && (RegModeFontPairs[i].Mode & FS_GRAPHICS)==FS_GRAPHICS) ||
              (!fGraphics && (RegModeFontPairs[i].Mode & FS_TEXT)==FS_TEXT)           )
           )
#else
        if (WindowSize.Y <= (SHORT)ModeFontPairs[i].Height)
#endif
        {
            break;
        }
    }
    if (i == NUMBER_OF_MODE_FONT_PAIRS)
#if defined(FE_SB)
    {
        DWORD Find;
        ULONG FindIndex;
        COORD WindowSizeDelta;

        FindIndex = 0;
        Find = (DWORD)-1;
        for (i=0; i<NUMBER_OF_MODE_FONT_PAIRS;i++) {
            if ( ( fGraphics && (RegModeFontPairs[i].Mode & FS_GRAPHICS)==FS_GRAPHICS) ||
                 (!fGraphics && (RegModeFontPairs[i].Mode & FS_TEXT)==FS_TEXT)           )
            {
                WindowSizeDelta.Y = (SHORT) abs(WindowSize.Y - RegModeFontPairs[i].ScreenSize.Y);
                if (Find > (DWORD)(WindowSizeDelta.Y))
                {
                    Find = (DWORD)(WindowSizeDelta.Y);
                    FindIndex = i;
                }
            }
        }

        i = FindIndex;
    }
#else
        i-=1;
#endif
#if defined(FE_SB)
    *pWindowSize = RegModeFontPairs[i].ScreenSize;
#else
    pWindowSize->X = 80;
    pWindowSize->Y = (SHORT)ModeFontPairs[i].Height;
#endif
    return i;
}

VOID
ReadRegionFromScreenHW(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT Region,
    IN PCHAR_INFO ReadBufPtr
    )
{
    ULONG CurFrameBufPtr;   // offset in frame buffer
    SHORT FrameY;
    SHORT WindowY, WindowX, WindowSizeX;

    //
    // get pointer to start of region in frame buffer
    //

    WindowY = Region->Top - ScreenInfo->Window.Top;
    WindowX = Region->Left - ScreenInfo->Window.Left;
    WindowSizeX = CONSOLE_WINDOW_SIZE_X(ScreenInfo);

    //
    // copy the chars and attrs from the frame buffer
    //

    for (FrameY = Region->Top;
         FrameY <= Region->Bottom;
         FrameY++, WindowY++) {

        CurFrameBufPtr = SCREEN_BUFFER_POINTER(WindowX,
                                               WindowY,
                                               WindowSizeX,
                                               sizeof(VGA_CHAR));

        GdiFullscreenControl(FullscreenControlReadFromFrameBuffer,
                                (PULONG) CurFrameBufPtr,
                                (Region->Right - Region->Left + 1) *
                                    sizeof(VGA_CHAR),
                                ReadBufPtr, NULL);
        ReadBufPtr += (Region->Right - Region->Left + 1);
    }
}

VOID
ReverseMousePointer(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT Region
    )
{
    ULONG CurFrameBufPtr;   // offset in frame buffer
    SHORT WindowSizeX;

    // if (ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN) {
    //     ASSERT(FALSE);
    // }

#ifdef FE_SB
    // fail safe
    ASSERT(ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER);
    if (!(ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER)) {
        return;
    }
#endif

    WindowSizeX = CONSOLE_WINDOW_SIZE_X(ScreenInfo);

    if (ScreenInfo->BufferInfo.TextInfo.MousePosition.X < Region->Left ||
        ScreenInfo->BufferInfo.TextInfo.MousePosition.X > Region->Right ||
        ScreenInfo->BufferInfo.TextInfo.MousePosition.Y < Region->Top ||
        ScreenInfo->BufferInfo.TextInfo.MousePosition.Y > Region->Bottom ||
        ScreenInfo->CursorDisplayCount < 0 ||
        !(ScreenInfo->Console->InputBuffer.InputMode & ENABLE_MOUSE_INPUT) ||
        ScreenInfo->Console->Flags & CONSOLE_VDM_REGISTERED) {
        return;
    }

#if defined(FE_SB)
    {
        FSVIDEO_REVERSE_MOUSE_POINTER MousePointer;
        SHORT RowIndex;
        PROW Row;
        COORD TargetPoint;

        TargetPoint.X = ScreenInfo->BufferInfo.TextInfo.MousePosition.X;
        TargetPoint.Y = ScreenInfo->BufferInfo.TextInfo.MousePosition.Y;

        RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+TargetPoint.Y) % ScreenInfo->ScreenBufferSize.Y;
        Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
        if (!CONSOLE_IS_DBCS_CP(ScreenInfo->Console))
            MousePointer.dwType = CHAR_TYPE_SBCS;
        else if (Row->CharRow.KAttrs[TargetPoint.X] & ATTR_TRAILING_BYTE)
            MousePointer.dwType = CHAR_TYPE_TRAILING;
        else if (Row->CharRow.KAttrs[TargetPoint.X] & ATTR_LEADING_BYTE)
            MousePointer.dwType = CHAR_TYPE_LEADING;
        else
            MousePointer.dwType = CHAR_TYPE_SBCS;

        MousePointer.Screen.Position.X = TargetPoint.X - ScreenInfo->Window.Left;
        MousePointer.Screen.Position.Y = TargetPoint.Y - ScreenInfo->Window.Top;
        MousePointer.Screen.ScreenSize.X = WindowSizeX;
        MousePointer.Screen.ScreenSize.Y = CONSOLE_WINDOW_SIZE_Y(ScreenInfo);
        MousePointer.Screen.nNumberOfChars = 0;

        GdiFullscreenControl(FullscreenControlReverseMousePointerDB,
                             &MousePointer,
                             sizeof(MousePointer),
                             NULL,
                             NULL);

        UNREFERENCED_PARAMETER(CurFrameBufPtr);
    }
#else
    CurFrameBufPtr = SCREEN_BUFFER_POINTER(ScreenInfo->BufferInfo.TextInfo.MousePosition.X - ScreenInfo->Window.Left,
                                           ScreenInfo->BufferInfo.TextInfo.MousePosition.Y - ScreenInfo->Window.Top,
                                           WindowSizeX,
                                           sizeof(VGA_CHAR));

    GdiFullscreenControl(FullscreenControlReverseMousePointer,
                            (PULONG)CurFrameBufPtr,
                            0,
                            NULL,
                            NULL);
#endif
}

VOID
CopyVideoMemory(
    SHORT SourceY,
    SHORT TargetY,
    SHORT Length,
    IN PSCREEN_INFORMATION ScreenInfo
    )

/*++

Routine Description:

    This routine copies rows of characters in video memory.  It only copies
    complete rows.

Arguments:

    SourceY - Row to copy from.

    TargetY - Row to copy to.

    Length - Number of rows to copy.

Return Value:

--*/

{
    ULONG SourcePtr, TargetPtr;
    SHORT WindowSizeX, WindowSizeY;

    WindowSizeX = CONSOLE_WINDOW_SIZE_X(ScreenInfo);
    WindowSizeY = CONSOLE_WINDOW_SIZE_Y(ScreenInfo);

    if (max(SourceY, TargetY) + Length > WindowSizeY) {
        Length = WindowSizeY - max(SourceY, TargetY);
        if (Length <= 0 ) {
            return;
        }
    }

#if defined(FE_SB)
    {
        FSCNTL_SCREEN_INFO FsCntlSrc;
        FSCNTL_SCREEN_INFO FsCntlDest;

        FsCntlSrc.Position.X = 0;
        FsCntlSrc.Position.Y = SourceY;
        FsCntlSrc.ScreenSize.X = WindowSizeX;
        FsCntlSrc.ScreenSize.Y = CONSOLE_WINDOW_SIZE_Y(ScreenInfo);
        FsCntlSrc.nNumberOfChars = Length * WindowSizeX;

        FsCntlDest.Position.X = 0;
        FsCntlDest.Position.Y = TargetY;
        FsCntlDest.ScreenSize.X = WindowSizeX;
        FsCntlDest.ScreenSize.Y = CONSOLE_WINDOW_SIZE_Y(ScreenInfo);
        FsCntlDest.nNumberOfChars = Length * WindowSizeX;

        GdiFullscreenControl(FullscreenControlCopyFrameBufferDB,
                             &FsCntlSrc,
                             sizeof(FsCntlSrc),
                             &FsCntlDest,
                             (PULONG)sizeof(FsCntlDest));

        UNREFERENCED_PARAMETER(SourcePtr);
        UNREFERENCED_PARAMETER(TargetPtr);
    }
#else
    SourcePtr = SCREEN_BUFFER_POINTER(0,
                                      SourceY,
                                      WindowSizeX,
                                      sizeof(VGA_CHAR));

    TargetPtr = SCREEN_BUFFER_POINTER(0,
                                      TargetY,
                                      WindowSizeX,
                                      sizeof(VGA_CHAR));

    GdiFullscreenControl(FullscreenControlCopyFrameBuffer,
                            (PULONG) SourcePtr,
                            Length * WindowSizeX * sizeof(VGA_CHAR),
                            (PULONG) TargetPtr,
                            (PULONG) (Length * WindowSizeX * sizeof(VGA_CHAR)));
#endif
}

VOID
ScrollHW(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT ScrollRect,
    IN PSMALL_RECT MergeRect,
    IN COORD TargetPoint
    )
{
    SMALL_RECT TargetRectangle;
    if (ScreenInfo->Console->Flags & CONSOLE_VDM_REGISTERED)
        return;

    TargetRectangle.Left = TargetPoint.X;
    TargetRectangle.Top = TargetPoint.Y;
    TargetRectangle.Right = TargetPoint.X + ScrollRect->Right - ScrollRect->Left;
    TargetRectangle.Bottom = TargetPoint.Y + ScrollRect->Bottom - ScrollRect->Top;

    //
    // if the scroll region is as wide as the screen, we can update
    // the screen by copying the video memory.  if we scroll this
    // way, we then must clip and update the fill region.
    //

    if (ScrollRect->Left == ScreenInfo->Window.Left &&
        TargetRectangle.Left == ScreenInfo->Window.Left &&
        ScrollRect->Right == ScreenInfo->Window.Right &&
        TargetRectangle.Right == ScreenInfo->Window.Right &&
        ScrollRect->Top >= ScreenInfo->Window.Top &&
        TargetRectangle.Top >= ScreenInfo->Window.Top &&
        ScrollRect->Bottom <= ScreenInfo->Window.Bottom &&
        TargetRectangle.Bottom <= ScreenInfo->Window.Bottom) {

        //
        // we must first make the mouse pointer invisible because
        // otherwise it would get copied to another place on the
        // screen if it were part of the scroll region.
        //

        ReverseMousePointer(ScreenInfo, &ScreenInfo->Window);

        CopyVideoMemory((SHORT) (ScrollRect->Top - ScreenInfo->Window.Top),
                        (SHORT) (TargetRectangle.Top - ScreenInfo->Window.Top),
                        (SHORT) (TargetRectangle.Bottom - TargetRectangle.Top + 1),
                        ScreenInfo);

        //
        // update the fill region.  first we ensure that the scroll and
        // target regions aren't the same.  if they are, we don't fill.
        //

        if (TargetRectangle.Top != ScrollRect->Top) {

            //
            // if scroll and target regions overlap, with scroll
            // region above target region, clip scroll region.
            //

            if (TargetRectangle.Top <= ScrollRect->Bottom &&
                TargetRectangle.Bottom >= ScrollRect->Bottom) {
                ScrollRect->Bottom = (SHORT)(TargetRectangle.Top-1);
            }
            else if (TargetRectangle.Top <= ScrollRect->Top &&
                TargetRectangle.Bottom >= ScrollRect->Top) {
                ScrollRect->Top = (SHORT)(TargetRectangle.Bottom+1);
            }
            WriteToScreen(ScreenInfo, ScrollRect);

            //
            // WriteToScreen should take care of writing the mouse pointer.
            // however, the update region may be clipped so that the
            // mouse pointer is not written. in that case, we draw the
            // mouse pointer here.
            //

            if (ScreenInfo->BufferInfo.TextInfo.MousePosition.Y < ScrollRect->Top ||
                ScreenInfo->BufferInfo.TextInfo.MousePosition.Y > ScrollRect->Bottom) {
                ReverseMousePointer(ScreenInfo, &ScreenInfo->Window);
            }
        }
        if (MergeRect) {
            WriteToScreen(ScreenInfo, MergeRect);
        }
    }
    else {
        if (MergeRect) {
            WriteToScreen(ScreenInfo, MergeRect);
        }
        WriteToScreen(ScreenInfo, ScrollRect);
        WriteToScreen(ScreenInfo, &TargetRectangle);
    }
}

VOID
UpdateMousePosition(
    PSCREEN_INFORMATION ScreenInfo,
    COORD Position
    )

/*++

Routine Description:

    This routine moves the mouse pointer.

Arguments:

    ScreenInfo - Pointer to screen buffer information.

    Position - Contains the new position of the mouse in screen buffer
    coordinates.

Return Value:

    none.

--*/

// Note: CurrentConsole lock must be held in share mode when calling this routine
{
    SMALL_RECT CursorRegion;
#ifdef FE_SB
    SHORT RowIndex;
    PROW  Row;
    BOOL  fOneMore = FALSE;
#endif

    if ((ScreenInfo->Console->Flags & CONSOLE_VDM_REGISTERED) ||
            (ScreenInfo->Flags & CONSOLE_GRAPHICS_BUFFER)) {
        return;
    }

    if (Position.X < ScreenInfo->Window.Left ||
        Position.X > ScreenInfo->Window.Right ||
        Position.Y < ScreenInfo->Window.Top ||
        Position.Y > ScreenInfo->Window.Bottom) {
        return;
    }

    if (Position.X == ScreenInfo->BufferInfo.TextInfo.MousePosition.X &&
        Position.Y == ScreenInfo->BufferInfo.TextInfo.MousePosition.Y) {
        return;
    }

#ifdef FE_SB
    if (CONSOLE_IS_DBCS_CP(ScreenInfo->Console)) {
        RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+Position.Y) % ScreenInfo->ScreenBufferSize.Y;
        Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
        if (Row->CharRow.KAttrs[Position.X] & ATTR_LEADING_BYTE) {
            if (Position.X != ScreenInfo->ScreenBufferSize.X - 1) {
                fOneMore = TRUE;
            }
        } else if (Row->CharRow.KAttrs[Position.X] & ATTR_TRAILING_BYTE) {
            if (Position.X != 0) {
                fOneMore = TRUE;
                Position.X--;
            }
        }

    }
#endif

    if (ScreenInfo->CursorDisplayCount < 0 || !(ScreenInfo->Console->InputBuffer.InputMode & ENABLE_MOUSE_INPUT)) {
        ScreenInfo->BufferInfo.TextInfo.MousePosition = Position;
        return;
    }


    // turn off old mouse position.

    CursorRegion.Left = CursorRegion.Right = ScreenInfo->BufferInfo.TextInfo.MousePosition.X;
    CursorRegion.Top = CursorRegion.Bottom = ScreenInfo->BufferInfo.TextInfo.MousePosition.Y;

#ifdef FE_SB
    if (CONSOLE_IS_DBCS_CP(ScreenInfo->Console)) {
        RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+CursorRegion.Top) % ScreenInfo->ScreenBufferSize.Y;
        Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
        if (Row->CharRow.KAttrs[CursorRegion.Left] & ATTR_LEADING_BYTE) {
            if (CursorRegion.Left != ScreenInfo->ScreenBufferSize.X - 1) {
                CursorRegion.Right++;
            }
        }
    }
#endif

    // store new mouse position

    ScreenInfo->BufferInfo.TextInfo.MousePosition.X = Position.X;
    ScreenInfo->BufferInfo.TextInfo.MousePosition.Y = Position.Y;
    WriteToScreen(ScreenInfo, &CursorRegion);

    // turn on new mouse position

    CursorRegion.Left = CursorRegion.Right = Position.X;
    CursorRegion.Top = CursorRegion.Bottom = Position.Y;
#ifdef FE_SB
    if (fOneMore)
        CursorRegion.Right++;
#endif
    WriteToScreen(ScreenInfo, &CursorRegion);
}

NTSTATUS
SetROMFontCodePage(
    IN UINT wCodePage,
    IN ULONG ModeIndex
    )

/*

    this function opens ega.cpi and looks for the desired font in the
    specified codepage.  if found, it loads it into the video ROM.

*/

{
    BYTE Buffer[CONSOLE_FONT_BUFFER_LENGTH];
    DWORD dwBytesRead;
    LPFONTFILEHEADER lpFontFileHeader=(LPFONTFILEHEADER)Buffer;
    LPFONTINFOHEADER lpFontInfoHeader=(LPFONTINFOHEADER)Buffer;
    LPFONTDATAHEADER lpFontDataHeader=(LPFONTDATAHEADER)Buffer;
    LPCPENTRYHEADER lpCPEntryHeader=(LPCPENTRYHEADER)Buffer;
    LPSCREENFONTHEADER lpScreenFontHeader=(LPSCREENFONTHEADER)Buffer;
    WORD NumEntries;
    COORD FontDimensions;
    NTSTATUS Status;
    BOOL Found;
    LONG FilePtr;
    BOOL bDOS = FALSE;

    FontDimensions = ModeFontPairs[ModeIndex].FontSize;

    //
    // read FONTINFOHEADER
    //
    // do {
    //     read CPENTRYHEADER
    //     if (correct codepage)
    //         break;
    // } while (codepages)
    // if (codepage found)
    //     read FONTDATAHEADER
    //

    // read FONTFILEHEADER

    FilePtr = 0;
    if (SetFilePointer(hCPIFile, FilePtr, NULL, FILE_BEGIN) == -1) {
        Status = STATUS_INVALID_PARAMETER;
        goto DoExit;
    }

    if (!ReadFile(hCPIFile, Buffer, sizeof(FONTFILEHEADER), &dwBytesRead, NULL) ||
        dwBytesRead != sizeof(FONTFILEHEADER)) {
        Status = STATUS_INVALID_PARAMETER;
        goto DoExit;
    }

    // verify signature

    if (memcmp(lpFontFileHeader->ffhFileTag, "\xFF""FONT.NT",8) ) {
        if (memcmp(lpFontFileHeader->ffhFileTag, "\xFF""FONT   ",8) ) {
            Status = STATUS_INVALID_PARAMETER;
            goto DoExit;
        } else {
            bDOS = TRUE;
        }
    }

    // seek to FONTINFOHEADER.  jump through hoops to get the offset value.

    FilePtr = lpFontFileHeader->ffhOffset1;
    FilePtr |= (lpFontFileHeader->ffhOffset2 << 8);
    FilePtr |= (lpFontFileHeader->ffhOffset3 << 24);

    if (SetFilePointer(hCPIFile, FilePtr, NULL, FILE_BEGIN) == -1) {
        Status = STATUS_INVALID_PARAMETER;
        goto DoExit;
    }

    // read FONTINFOHEADER

    if (!ReadFile(hCPIFile, Buffer, sizeof(FONTINFOHEADER), &dwBytesRead, NULL) ||
        dwBytesRead != sizeof(FONTINFOHEADER)) {
        Status = STATUS_INVALID_PARAMETER;
        goto DoExit;
    }
    FilePtr += dwBytesRead;
    NumEntries = lpFontInfoHeader->fihCodePages;

    Found = FALSE;
    while (NumEntries &&
           ReadFile(hCPIFile, Buffer, sizeof(CPENTRYHEADER), &dwBytesRead, NULL) &&
           dwBytesRead == sizeof(CPENTRYHEADER)) {
        if (lpCPEntryHeader->cpeCodepageID == wCodePage) {
            Found = TRUE;
            break;
        }
        // seek to next CPEENTRYHEADER

        if (bDOS) {
            FilePtr = MAKELONG(lpCPEntryHeader->cpeNext1, lpCPEntryHeader->cpeNext2);
        } else {
            FilePtr += MAKELONG(lpCPEntryHeader->cpeNext1, lpCPEntryHeader->cpeNext2);
        }
        if (SetFilePointer(hCPIFile, FilePtr, NULL, FILE_BEGIN) == -1) {
            Status = STATUS_INVALID_PARAMETER;
            goto DoExit;
        }
        NumEntries -= 1;
    }
    if (!Found) {
        Status = STATUS_INVALID_PARAMETER;
        goto DoExit;
    }

    // seek to FONTDATAHEADER

    if (bDOS) {
        FilePtr = lpCPEntryHeader->cpeOffset;
    } else {
        FilePtr += lpCPEntryHeader->cpeOffset;
    }
    if (SetFilePointer(hCPIFile, FilePtr, NULL, FILE_BEGIN) == -1) {
        Status = STATUS_INVALID_PARAMETER;
        goto DoExit;
    }

    // read FONTDATAHEADER

    if (!ReadFile(hCPIFile, Buffer, sizeof(FONTDATAHEADER), &dwBytesRead, NULL) ||
        dwBytesRead != sizeof(FONTDATAHEADER)) {
        Status = STATUS_INVALID_PARAMETER;
        goto DoExit;
    }
    FilePtr += dwBytesRead;

    NumEntries = lpFontDataHeader->fdhFonts;

    while (NumEntries) {
        if (!ReadFile(hCPIFile, Buffer, sizeof(SCREENFONTHEADER), &dwBytesRead, NULL) ||
            dwBytesRead != sizeof(SCREENFONTHEADER)) {
            Status = STATUS_INVALID_PARAMETER;
            goto DoExit;
        }

        if (lpScreenFontHeader->sfhHeight == (BYTE)FontDimensions.Y &&
            lpScreenFontHeader->sfhWidth == (BYTE)FontDimensions.X) {
            PVIDEO_LOAD_FONT_INFORMATION FontInformation;

            FontInformation = (PVIDEO_LOAD_FONT_INFORMATION)ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ),
                                    lpScreenFontHeader->sfhCharacters*
                                    lpScreenFontHeader->sfhHeight+
                                    sizeof(VIDEO_LOAD_FONT_INFORMATION));
            if (FontInformation == NULL) {
                RIPMSG1(RIP_WARNING, "SetROMFontCodePage: failed to memory allocation %d bytes",
                    lpScreenFontHeader->sfhCharacters * lpScreenFontHeader->sfhHeight +
                    sizeof(VIDEO_LOAD_FONT_INFORMATION));
                return STATUS_NO_MEMORY;
            }
            if (!ReadFile(hCPIFile, FontInformation->Font,
                          lpScreenFontHeader->sfhCharacters*lpScreenFontHeader->sfhHeight,
                          &dwBytesRead, NULL) ||
                          dwBytesRead != (DWORD)(lpScreenFontHeader->sfhCharacters*lpScreenFontHeader->sfhHeight)) {
                ConsoleHeapFree(FontInformation);
                return STATUS_INVALID_PARAMETER;
            }
            FontInformation->WidthInPixels = FontDimensions.X;
            FontInformation->HeightInPixels = FontDimensions.Y;
            FontInformation->FontSize = lpScreenFontHeader->sfhCharacters*lpScreenFontHeader->sfhHeight;

            Status = GdiFullscreenControl(FullscreenControlLoadFont,
                                             FontInformation,
                                             lpScreenFontHeader->sfhCharacters*lpScreenFontHeader->sfhHeight + sizeof(VIDEO_LOAD_FONT_INFORMATION),
                                             NULL,
                                             NULL);

            ConsoleHeapFree(FontInformation);
            return Status;
        } else {
            FilePtr = lpScreenFontHeader->sfhCharacters*lpScreenFontHeader->sfhHeight;
            if (SetFilePointer(hCPIFile, FilePtr, NULL, FILE_CURRENT) == -1) {
                Status = STATUS_INVALID_PARAMETER;
                goto DoExit;
            }
        }
        NumEntries -= 1;
    }
DoExit:
    return Status;
}
#endif

NTSTATUS
GetThreadConsoleDesktop(
    DWORD dwThreadId,
    HDESK *phdeskConsole)
{
    PCSR_THREAD pcsrt;
    PCONSOLE_PER_PROCESS_DATA ProcessData;
    PCONSOLE_INFORMATION Console;
    NTSTATUS Status;
    HANDLE ConsoleHandle = NULL;

    *phdeskConsole = NULL;
    Status = CsrLockThreadByClientId(LongToHandle(dwThreadId), &pcsrt);
    if (NT_SUCCESS(Status)) {
        ProcessData = CONSOLE_FROMTHREADPERPROCESSDATA(pcsrt);
        ConsoleHandle = ProcessData->ConsoleHandle;
        CsrUnlockThread(pcsrt);
    }

    //
    // If this process is a console app, return the
    // handle to its desktop.  Otherwise, return NULL.
    //

    if (ConsoleHandle != NULL) {
        Status = RevalidateConsole(ConsoleHandle, &Console);
        if (NT_SUCCESS(Status)) {
            *phdeskConsole = Console->hDesk;
        }
        UnlockConsole(Console);
    }

    return STATUS_SUCCESS;
}


NTSTATUS
SetRAMFontCodePage(
    IN PSCREEN_INFORMATION ScreenInfo
    )
{
    FSVIDEO_SCREEN_INFORMATION ScreenInformation;
    ULONG ModeIndex = ScreenInfo->BufferInfo.TextInfo.ModeIndex;
    COORD FontSize;
    WCHAR wChar;
    WCHAR wCharBuf[2];
    LPSTRINGBITMAP StringBitmap;
    DWORD BufferSize;
    PWORD FontImage;
    PFONT_CACHE_INFORMATION FontCache;
    WCHAR AltFaceName[LF_FACESIZE];
    COORD AltFontSize;
    BYTE  AltFontFamily;
    ULONG AltFontIndex = 0;
    HFONT hOldFont;
    NTSTATUS Status;

    ScreenInformation.ScreenSize = RegModeFontPairs[ModeIndex].ScreenSize;
    ScreenInformation.FontSize = RegModeFontPairs[ModeIndex].FontSize;
    if (ScreenInfo->Console->FontCacheInformation == NULL)
    {
        Status = CreateFontCache(&FontCache);
        if (!NT_SUCCESS(Status)) {
            RIPMSG1(RIP_WARNING, "SetRAMFontCodePage: failed in CreateFontCache. Status=%08x", Status);
            return STATUS_UNSUCCESSFUL;
        }
        (PFONT_CACHE_INFORMATION)ScreenInfo->Console->FontCacheInformation = FontCache;

        MakeAltRasterFont(SCR_FONTCODEPAGE(ScreenInfo),
                          RegModeFontPairs[ModeIndex].FontSize,
                          &AltFontSize, &AltFontFamily, &AltFontIndex, AltFaceName);
        FontCache->FullScreenFontIndex = AltFontIndex;
        FontCache->FullScreenFontSize  = AltFontSize;

        BufferSize = CalcBitmapBufferSize(FontCache->FullScreenFontSize, BYTE_ALIGN);
        StringBitmap = ConsoleHeapAlloc( MAKE_TAG(TMP_DBCS_TAG),
                                 sizeof(STRINGBITMAP) + sizeof(StringBitmap->ajBits) * BufferSize);
        if (StringBitmap==NULL)
        {
            RIPMSG0(RIP_WARNING, "SetRAMFontCodePage: failed to allocate StringBitmap");
            return STATUS_UNSUCCESSFUL;
        }


        /*
         * Change GDI font to full screen font that best matched.
         */
        hOldFont = SelectObject(ScreenInfo->Console->hDC, FontInfo[FontCache->FullScreenFontIndex].hFont);


        for (wChar=0x00; wChar < 0x80; wChar++) {
            wCharBuf[0] = wChar;
            wCharBuf[1] = TEXT('\0');
            GetStringBitmapW(ScreenInfo->Console->hDC,
                             wCharBuf,
                             1,
                             (ULONG)ConsoleHeapSize(StringBitmap),
                             (BYTE*)StringBitmap
                            );

            FontSize.X = (SHORT)StringBitmap->uiWidth;
            FontSize.Y = (SHORT)StringBitmap->uiHeight;

#if defined(LATER_DBCS_FOR_GRID_CHAR)  // by kazum
            BufferSize = CalcBitmapBufferSize(FontSize, BYTE_ALIGN);
            *(StringBitmap->ajBits + BufferSize) = 0;
            *(StringBitmap->ajBits + BufferSize + 1) = 0;

            if (gpGridCharacter) {
                PGRID_CHARACTER_INFORMATION GridCharacter;
                PWCHAR CodePoint;

                GridCharacter = gpGridCharacter;
                do {
                    if (GridCharacter->CodePage == OEMCP) {
                        CodePoint = GridCharacter->CodePoint;
                        while (*CodePoint) {
                            if (*CodePoint == wChar) {
                                if (FontSize.X <= 8)
                                    *(StringBitmap->ajBits + BufferSize) = *(StringBitmap->ajBits + BufferSize - 1);
                                else {
                                    *(StringBitmap->ajBits + BufferSize) = *(StringBitmap->ajBits + BufferSize - 2);
                                    *(StringBitmap->ajBits + BufferSize + 1) = *(StringBitmap->ajBits + BufferSize - 1);
                                }
                                break;
                            }
                            else
                                CodePoint++;
                        }
                        break;
                    }
                } while (GridCharacter = GridCharacter->pNext);
            }
#endif // LATER_DBCS_FOR_GRID_CHAR  // by kazum

            Status = SetFontImage(ScreenInfo->Console->FontCacheInformation,
                                  wChar,
                                  FontSize,
                                  BYTE_ALIGN,
                                  StringBitmap->ajBits
                                 );
            if (!NT_SUCCESS(Status)) {
                RIPMSG3(RIP_WARNING, "SetRAMFontCodePage: failed to set font image. wc=%04x sz=(%x, %x).",
                        wChar, FontSize.X, FontSize.Y);
            }

            if (FontSize.X != ScreenInformation.FontSize.X ||
                FontSize.Y != ScreenInformation.FontSize.Y)
            {
                BufferSize = CalcBitmapBufferSize(ScreenInformation.FontSize, WORD_ALIGN);
                FontImage = ConsoleHeapAlloc( MAKE_TAG(TMP_DBCS_TAG),
                                      BufferSize
                                     );
                if (FontImage!=NULL) {

                    GetExpandFontImage(ScreenInfo->Console->FontCacheInformation,
                                       wChar,
                                       FontSize,
                                       ScreenInformation.FontSize,
                                       FontImage
                                      );

                    Status = SetFontImage(ScreenInfo->Console->FontCacheInformation,
                                          wChar,
                                          ScreenInformation.FontSize,
                                          WORD_ALIGN,
                                          FontImage
                                         );
                    if (!NT_SUCCESS(Status)) {
                        RIPMSG3(RIP_WARNING, "SetRAMFontCodePage: failed to set font image. wc=%04x, sz=(%x,%x)",
                                wChar, ScreenInformation.FontSize.X, ScreenInformation.FontSize.Y);
                    }

                    ConsoleHeapFree(FontImage);
                } else {
                    RIPMSG0(RIP_WARNING, "SetRAMFontCodePage: failed to allocate FontImage.");
                }
            }
        }

        ConsoleHeapFree(StringBitmap);

        /*
         * Back to GDI font
         */
        SelectObject(ScreenInfo->Console->hDC, hOldFont);
    }

    Status = GdiFullscreenControl(FullscreenControlSetScreenInformation,
                                  &ScreenInformation,
                                  sizeof(ScreenInformation),
                                  NULL,
                                  NULL);

    return Status;
}

NTSTATUS
SetRAMFont(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PCHAR_INFO ScreenBufPtr,
    IN DWORD Length
    )
{
    ULONG ModeIndex = ScreenInfo->BufferInfo.TextInfo.ModeIndex;
    COORD FsFontSize1 = RegModeFontPairs[ModeIndex].FontSize;
    COORD FsFontSize2 = FsFontSize1;
    COORD GdiFontSize1;
    COORD GdiFontSize2;
    COORD RetFontSize;
    WCHAR wCharBuf[2];
    LPSTRINGBITMAP StringBitmap;
    DWORD BufferSize;
    PWORD FontImage;
    PFONT_CACHE_INFORMATION FontCache;
    HFONT hOldFont;
    NTSTATUS Status;

    FontCache = (PFONT_CACHE_INFORMATION)ScreenInfo->Console->FontCacheInformation;
    if (FontCache==NULL)
    {
        RIPMSG0(RIP_ERROR, "SetRAMFont: ScreenInfo->Console->FontCacheInformation == NULL.");
        return STATUS_UNSUCCESSFUL;
    }

    GdiFontSize1 = FontCache->FullScreenFontSize;
    GdiFontSize2 = GdiFontSize1;
    GdiFontSize2.X *= 2;
    FsFontSize2.X *= 2;

    BufferSize = CalcBitmapBufferSize(GdiFontSize2, BYTE_ALIGN);
    StringBitmap = ConsoleHeapAlloc( MAKE_TAG(TMP_DBCS_TAG),
                             sizeof(STRINGBITMAP) + sizeof(StringBitmap->ajBits) * BufferSize);
    if (StringBitmap == NULL) {
        RIPMSG0(RIP_WARNING, "SetRAMFont: failed to allocate StringBitmap");
        return STATUS_UNSUCCESSFUL;
    }

    /*
     * Change GDI font to full screen font that best matched.
     */
    hOldFont = SelectObject(ScreenInfo->Console->hDC, FontInfo[FontCache->FullScreenFontIndex].hFont);

    while (Length--) {
        Status = GetFontImage(ScreenInfo->Console->FontCacheInformation,
                              ScreenBufPtr->Char.UnicodeChar,
                              (ScreenBufPtr->Attributes & COMMON_LVB_SBCSDBCS) ? FsFontSize2 : FsFontSize1,
                              0,
                              NULL);
        if (!NT_SUCCESS(Status)) {
            wCharBuf[0] = ScreenBufPtr->Char.UnicodeChar;
            wCharBuf[1] = TEXT('\0');
            GetStringBitmapW(ScreenInfo->Console->hDC,
                             wCharBuf,
                             1,
                             (ULONG)ConsoleHeapSize(StringBitmap),
                             (BYTE*)StringBitmap
                            );

            RetFontSize.X = (SHORT)StringBitmap->uiWidth;
            RetFontSize.Y = (SHORT)StringBitmap->uiHeight;

            Status = SetFontImage(ScreenInfo->Console->FontCacheInformation,
                                  ScreenBufPtr->Char.UnicodeChar,
                                  RetFontSize,
                                  BYTE_ALIGN,
                                  StringBitmap->ajBits
                                 );
            if (!NT_SUCCESS(Status)) {
                RIPMSG3(RIP_WARNING, "SetRAMFont: failed to set font image. wc=%04x sz=(%x,%x)",
                        ScreenBufPtr->Char.UnicodeChar, RetFontSize.X, RetFontSize.Y);
            }

            if (((ScreenBufPtr->Attributes & COMMON_LVB_SBCSDBCS) &&
                    (GdiFontSize2.X != FsFontSize2.X || GdiFontSize2.Y != FsFontSize2.Y)) ||
                 (!(ScreenBufPtr->Attributes & COMMON_LVB_SBCSDBCS) &&
                    (GdiFontSize1.X != FsFontSize1.X || GdiFontSize1.Y != FsFontSize1.Y))) {
                BufferSize = CalcBitmapBufferSize(FsFontSize2, WORD_ALIGN);
                FontImage = ConsoleHeapAlloc( MAKE_TAG(TMP_DBCS_TAG),
                                      BufferSize
                                     );
                if (FontImage != NULL) {

                    GetExpandFontImage(ScreenInfo->Console->FontCacheInformation,
                                       ScreenBufPtr->Char.UnicodeChar,
                                       (ScreenBufPtr->Attributes & COMMON_LVB_SBCSDBCS) ? GdiFontSize2 : GdiFontSize1,
                                       (ScreenBufPtr->Attributes & COMMON_LVB_SBCSDBCS) ? FsFontSize2 : FsFontSize1,
                                       FontImage
                                      );

                    Status = SetFontImage(ScreenInfo->Console->FontCacheInformation,
                                          ScreenBufPtr->Char.UnicodeChar,
                                          (ScreenBufPtr->Attributes & COMMON_LVB_SBCSDBCS) ? FsFontSize2 : FsFontSize1,
                                          WORD_ALIGN,
                                          FontImage
                                         );
                    if (!NT_SUCCESS(Status)) {
                        RIPMSG3(RIP_WARNING, "SetRAMFont: failed to set font image. wc=%04x sz=(%x,%x)",
                                ScreenBufPtr->Char.UnicodeChar,
                                ((ScreenBufPtr->Attributes & COMMON_LVB_SBCSDBCS) ? FsFontSize2 : FsFontSize1).X,
                                ((ScreenBufPtr->Attributes & COMMON_LVB_SBCSDBCS) ? FsFontSize2 : FsFontSize1).Y);
                    }

                    ConsoleHeapFree(FontImage);
                } else {
                    RIPMSG0(RIP_WARNING, "SetRAMFont: failed to allocate FontImage.");
                }
            }
        }

        if (ScreenBufPtr->Attributes & COMMON_LVB_SBCSDBCS) {
            ScreenBufPtr += 2;
            if (Length >= 1) {
                Length -= 1;
            } else {
                break;
            }
        } else {
            ScreenBufPtr++;
        }
    }

    ConsoleHeapFree(StringBitmap);

    /*
     * Back to GDI font
     */
    SelectObject(ScreenInfo->Console->hDC, hOldFont);

    return Status;
}

#ifdef i386
#if defined(FE_SB)

#define WWSB_NOFE
#include "_priv.h"
#undef  WWSB_NOFE
#define WWSB_FE
#include "_priv.h"
#undef  WWSB_FE

#endif  // FE_SB
#endif  // i386
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\server\srvvdm.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    srvvdm.c

Abstract:

    This file contains all VDM functions

Author:

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


ULONG
SrvVDMConsoleOperation(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_VDM_MSG a = (PCONSOLE_VDM_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    if (!(Console->Flags & CONSOLE_VDM_REGISTERED) ||
        (Console->VDMProcessId != CONSOLE_CLIENTPROCESSID())) {
        Status = STATUS_INVALID_PARAMETER;
    } else {
        switch (a->iFunction) {
        case VDM_HIDE_WINDOW:
                Console->Flags |= CONSOLE_VDM_HIDDEN_WINDOW;
                PostMessage(Console->hWnd,
                             CM_HIDE_WINDOW,
                             0,
                             0
                           );
                break;
            case VDM_IS_ICONIC:
                a->Bool = IsIconic(Console->hWnd);
                break;
            case VDM_CLIENT_RECT:
                GetClientRect(Console->hWnd,&a->Rect);
                break;
            case VDM_CLIENT_TO_SCREEN:
                ClientToScreen(Console->hWnd,&a->Point);
                break;
            case VDM_SCREEN_TO_CLIENT:
                ScreenToClient(Console->hWnd,&a->Point);
                break;
            case VDM_IS_HIDDEN:
                a->Bool = ((Console->Flags & CONSOLE_NO_WINDOW) != 0);
                break;
            case VDM_FULLSCREEN_NOPAINT:
                if (a->Bool) {
                    Console->Flags |= CONSOLE_FULLSCREEN_NOPAINT;
                } else {
                    Console->Flags &= ~CONSOLE_FULLSCREEN_NOPAINT;
                }
                break;
#if defined(FE_SB)
            case VDM_SET_VIDEO_MODE:
                Console->fVDMVideoMode = (a->Bool != 0);
                break;
#if defined(i386)
            case VDM_SAVE_RESTORE_HW_STATE:
                if (ISNECPC98(gdwMachineId)) {
                    // This function is used by MVDM to save/restore HW state
                    // when it executes DOS-AP on Fullscreen again.
                    // It is called from MVDM\SOFTPC\HOST\SRC\NT_FULSC.C.
                    VIDEO_HARDWARE_STATE State;
                    ULONG StateSize = sizeof(State);

                    State.StateHeader = Console->StateBuffer;
                    State.StateLength = Console->StateLength;


                    Status = GdiFullscreenControl(a->Bool ? FullscreenControlRestoreHardwareState
                                                          : FullscreenControlSaveHardwareState,
                                                  &State,
                                                  StateSize,
                                                  &State,
                                                  &StateSize);
                }
                break;
            case VDM_VIDEO_IOCTL:
                if (ISNECPC98(gdwMachineId)) {
                    // This function is used by MVDM to access CG.
                    // It is called from MVDM\SOFTPC\HOST\SRC\NT_CGW.C.
                    PVOID InBuffer;

                    if (!CsrValidateMessageBuffer(m, &a->VDMIoctlParam.lpvInBuffer, a->VDMIoctlParam.cbInBuffer, sizeof(BYTE)) ||
                        !CsrValidateMessageBuffer(m, &a->VDMIoctlParam.lpvOutBuffer, a->VDMIoctlParam.cbOutBuffer, sizeof(BYTE))) {
                        UnlockConsole(Console);
                        return STATUS_INVALID_PARAMETER;
                    }

                    InBuffer = ConsoleHeapAlloc(
                                         MAKE_TAG( TMP_DBCS_TAG ),
                                         a->VDMIoctlParam.cbInBuffer + sizeof(DWORD)
                                        );
                    if (InBuffer == NULL)
                    {
                        Status = STATUS_NO_MEMORY;
                        break;
                    }

                    *((PDWORD)InBuffer) = a->VDMIoctlParam.dwIoControlCode;
                    RtlCopyMemory((PBYTE)InBuffer + sizeof(DWORD),
                                  a->VDMIoctlParam.lpvInBuffer,
                                  a->VDMIoctlParam.cbInBuffer
                                 );

                    Status = GdiFullscreenControl(
                                 FullscreenControlSpecificVideoControl,
                                 InBuffer,
                                 ConsoleHeapSize(InBuffer),
                                 a->VDMIoctlParam.lpvOutBuffer,
                                 a->VDMIoctlParam.lpvOutBuffer ?
                                     &a->VDMIoctlParam.cbOutBuffer : 0
                                 );

                    ConsoleHeapFree(InBuffer);
                }
                break;
#endif
#endif
            default:
                ASSERT(FALSE);
        }
    }

    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);    // get rid of unreferenced parameter warning message
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\server\srvinit.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    srvinit.c

Abstract:

    This is the main initialization file for the console
    Server.

Author:

    Therese Stowell (thereses) 11-Nov-1990

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop


CONST PCSR_API_ROUTINE ConsoleServerApiDispatchTable[ ConsolepMaxApiNumber - ConsolepOpenConsole ] = {
    (PCSR_API_ROUTINE)SrvOpenConsole,
    (PCSR_API_ROUTINE)SrvGetConsoleInput,
    (PCSR_API_ROUTINE)SrvWriteConsoleInput,
    (PCSR_API_ROUTINE)SrvReadConsoleOutput,
    (PCSR_API_ROUTINE)SrvWriteConsoleOutput,
    (PCSR_API_ROUTINE)SrvReadConsoleOutputString,
    (PCSR_API_ROUTINE)SrvWriteConsoleOutputString,
    (PCSR_API_ROUTINE)SrvFillConsoleOutput,
    (PCSR_API_ROUTINE)SrvGetConsoleMode,
    (PCSR_API_ROUTINE)SrvGetConsoleNumberOfFonts,
    (PCSR_API_ROUTINE)SrvGetConsoleNumberOfInputEvents,
    (PCSR_API_ROUTINE)SrvGetConsoleScreenBufferInfo,
    (PCSR_API_ROUTINE)SrvGetConsoleCursorInfo,
    (PCSR_API_ROUTINE)SrvGetConsoleMouseInfo,
    (PCSR_API_ROUTINE)SrvGetConsoleFontInfo,
    (PCSR_API_ROUTINE)SrvGetConsoleFontSize,
    (PCSR_API_ROUTINE)SrvGetConsoleCurrentFont,
    (PCSR_API_ROUTINE)SrvSetConsoleMode,
    (PCSR_API_ROUTINE)SrvSetConsoleActiveScreenBuffer,
    (PCSR_API_ROUTINE)SrvFlushConsoleInputBuffer,
    (PCSR_API_ROUTINE)SrvGetLargestConsoleWindowSize,
    (PCSR_API_ROUTINE)SrvSetConsoleScreenBufferSize,
    (PCSR_API_ROUTINE)SrvSetConsoleCursorPosition,
    (PCSR_API_ROUTINE)SrvSetConsoleCursorInfo,
    (PCSR_API_ROUTINE)SrvSetConsoleWindowInfo,
    (PCSR_API_ROUTINE)SrvScrollConsoleScreenBuffer,
    (PCSR_API_ROUTINE)SrvSetConsoleTextAttribute,
    (PCSR_API_ROUTINE)SrvSetConsoleFont,
    (PCSR_API_ROUTINE)SrvSetConsoleIcon,
    (PCSR_API_ROUTINE)SrvReadConsole,
    (PCSR_API_ROUTINE)SrvWriteConsole,
    (PCSR_API_ROUTINE)SrvDuplicateHandle,
    (PCSR_API_ROUTINE)SrvGetHandleInformation,
    (PCSR_API_ROUTINE)SrvSetHandleInformation,
    (PCSR_API_ROUTINE)SrvCloseHandle,
    (PCSR_API_ROUTINE)SrvVerifyConsoleIoHandle,
    (PCSR_API_ROUTINE)SrvAllocConsole,
    (PCSR_API_ROUTINE)SrvFreeConsole,
    (PCSR_API_ROUTINE)SrvGetConsoleTitle,
    (PCSR_API_ROUTINE)SrvSetConsoleTitle,
    (PCSR_API_ROUTINE)SrvCreateConsoleScreenBuffer,
    (PCSR_API_ROUTINE)SrvInvalidateBitMapRect,
    (PCSR_API_ROUTINE)SrvVDMConsoleOperation,
    (PCSR_API_ROUTINE)SrvSetConsoleCursor,
    (PCSR_API_ROUTINE)SrvShowConsoleCursor,
    (PCSR_API_ROUTINE)SrvConsoleMenuControl,
    (PCSR_API_ROUTINE)SrvSetConsolePalette,
    (PCSR_API_ROUTINE)SrvSetConsoleDisplayMode,
    (PCSR_API_ROUTINE)SrvRegisterConsoleVDM,
    (PCSR_API_ROUTINE)SrvGetConsoleHardwareState,
    (PCSR_API_ROUTINE)SrvSetConsoleHardwareState,
    (PCSR_API_ROUTINE)SrvGetConsoleDisplayMode,
    (PCSR_API_ROUTINE)SrvAddConsoleAlias,
    (PCSR_API_ROUTINE)SrvGetConsoleAlias,
    (PCSR_API_ROUTINE)SrvGetConsoleAliasesLength,
    (PCSR_API_ROUTINE)SrvGetConsoleAliasExesLength,
    (PCSR_API_ROUTINE)SrvGetConsoleAliases,
    (PCSR_API_ROUTINE)SrvGetConsoleAliasExes,
    (PCSR_API_ROUTINE)SrvExpungeConsoleCommandHistory,
    (PCSR_API_ROUTINE)SrvSetConsoleNumberOfCommands,
    (PCSR_API_ROUTINE)SrvGetConsoleCommandHistoryLength,
    (PCSR_API_ROUTINE)SrvGetConsoleCommandHistory,
    (PCSR_API_ROUTINE)SrvSetConsoleCommandHistoryMode,
    (PCSR_API_ROUTINE)SrvGetConsoleCP,
    (PCSR_API_ROUTINE)SrvSetConsoleCP,
    (PCSR_API_ROUTINE)SrvSetConsoleKeyShortcuts,
    (PCSR_API_ROUTINE)SrvSetConsoleMenuClose,
    (PCSR_API_ROUTINE)SrvConsoleNotifyLastClose,
    (PCSR_API_ROUTINE)SrvGenerateConsoleCtrlEvent,
    (PCSR_API_ROUTINE)SrvGetConsoleKeyboardLayoutName,
    (PCSR_API_ROUTINE)SrvGetConsoleWindow,
#if defined(FE_SB)
    (PCSR_API_ROUTINE)SrvGetConsoleCharType,
    (PCSR_API_ROUTINE)SrvSetConsoleLocalEUDC,
    (PCSR_API_ROUTINE)SrvSetConsoleCursorMode,
    (PCSR_API_ROUTINE)SrvGetConsoleCursorMode,
    (PCSR_API_ROUTINE)SrvRegisterConsoleOS2,
    (PCSR_API_ROUTINE)SrvSetConsoleOS2OemFormat,
#if defined(FE_IME)
    (PCSR_API_ROUTINE)SrvGetConsoleNlsMode,
    (PCSR_API_ROUTINE)SrvSetConsoleNlsMode,
    (PCSR_API_ROUTINE)SrvRegisterConsoleIME,
    (PCSR_API_ROUTINE)SrvUnregisterConsoleIME,
#endif // FE_IME
#endif // FE_SB
    (PCSR_API_ROUTINE)SrvGetConsoleLangId,
    (PCSR_API_ROUTINE)SrvAttachConsole,
    (PCSR_API_ROUTINE)SrvGetConsoleSelectionInfo,
    (PCSR_API_ROUTINE)SrvGetConsoleProcessList,
};

CONST BOOLEAN ConsoleServerApiServerValidTable[ ConsolepMaxApiNumber - ConsolepOpenConsole ] = {
    FALSE,     // OpenConsole
    FALSE,     // GetConsoleInput,
    FALSE,     // WriteConsoleInput,
    FALSE,     // ReadConsoleOutput,
    FALSE,     // WriteConsoleOutput,
    FALSE,     // ReadConsoleOutputString,
    FALSE,     // WriteConsoleOutputString,
    FALSE,     // FillConsoleOutput,
    FALSE,     // GetConsoleMode,
    FALSE,     // GetNumberOfConsoleFonts,
    FALSE,     // GetNumberOfConsoleInputEvents,
    FALSE,     // GetConsoleScreenBufferInfo,
    FALSE,     // GetConsoleCursorInfo,
    FALSE,     // GetConsoleMouseInfo,
    FALSE,     // GetConsoleFontInfo,
    FALSE,     // GetConsoleFontSize,
    FALSE,     // GetCurrentConsoleFont,
    FALSE,     // SetConsoleMode,
    FALSE,     // SetConsoleActiveScreenBuffer,
    FALSE,     // FlushConsoleInputBuffer,
    FALSE,     // GetLargestConsoleWindowSize,
    FALSE,     // SetConsoleScreenBufferSize,
    FALSE,     // SetConsoleCursorPosition,
    FALSE,     // SetConsoleCursorInfo,
    FALSE,     // SetConsoleWindowInfo,
    FALSE,     // ScrollConsoleScreenBuffer,
    FALSE,     // SetConsoleTextAttribute,
    FALSE,     // SetConsoleFont,
    FALSE,     // SetConsoleIcon
    FALSE,     // ReadConsole,
    FALSE,     // WriteConsole,
    FALSE,     // DuplicateHandle,
    FALSE,     // GetHandleInformation,
    FALSE,     // SetHandleInformation,
    FALSE,     // CloseHandle
    FALSE,     // VerifyConsoleIoHandle
    FALSE,     // AllocConsole,
    FALSE,     // FreeConsole
    FALSE,     // GetConsoleTitle,
    FALSE,     // SetConsoleTitle,
    FALSE,     // CreateConsoleScreenBuffer
    FALSE,     // InvalidateConsoleBitmapRect
    FALSE,     // VDMConsoleOperation
    FALSE,     // SetConsoleCursor,
    FALSE,     // ShowConsoleCursor
    FALSE,     // ConsoleMenuControl
    FALSE,     // SetConsolePalette
    FALSE,     // SetConsoleDisplayMode
    FALSE,     // RegisterConsoleVDM,
    FALSE,     // GetConsoleHardwareState
    FALSE,     // SetConsoleHardwareState
    TRUE,      // GetConsoleDisplayMode
    FALSE,     // AddConsoleAlias,
    FALSE,     // GetConsoleAlias,
    FALSE,     // GetConsoleAliasesLength,
    FALSE,     // GetConsoleAliasExesLength,
    FALSE,     // GetConsoleAliases,
    FALSE,     // GetConsoleAliasExes
    FALSE,     // ExpungeConsoleCommandHistory,
    FALSE,     // SetConsoleNumberOfCommands,
    FALSE,     // GetConsoleCommandHistoryLength,
    FALSE,     // GetConsoleCommandHistory,
    FALSE,     // SetConsoleCommandHistoryMode
    FALSE,     // SrvGetConsoleCP,
    FALSE,     // SrvSetConsoleCP,
    FALSE,     // SrvSetConsoleKeyShortcuts,
    FALSE,     // SrvSetConsoleMenuClose
    FALSE,     // SrvConsoleNotifyLastClose
    FALSE,     // SrvGenerateConsoleCtrlEvent
    FALSE,     // SrvGetConsoleKeyboardLayoutName
    FALSE,     // SrvGetConsoleWindow,
#if defined(FE_SB)
    FALSE,     // GetConsoleCharType
    FALSE,     // SrvSetConsoleLocalEUDC,
    FALSE,     // SrvSetConsoleCursorMode,
    FALSE,     // SrvGetConsoleCursorMode
    FALSE,     // SrvRegisterConsoleOS2,
    FALSE,     // SrvSetConsoleOS2OemFormat,
#if defined(FE_IME)
    FALSE,     // GetConsoleNlsMode
    FALSE,     // SetConsoleNlsMode
    FALSE,     // RegisterConsoleIME
    FALSE,     // UnregisterConsoleIME
#endif // FE_IME
#endif // FE_SB
    FALSE,     // GetConsoleLangId
    FALSE,     // AttachConsole
    FALSE,     // GetConsoleSelectionInfo,
    FALSE,     // GetConsoleProcessList
};

#if DBG
PSZ ConsoleServerApiNameTable[ ConsolepMaxApiNumber - ConsolepOpenConsole ] = {
    "SrvOpenConsole",
    "SrvGetConsoleInput",
    "SrvWriteConsoleInput",
    "SrvReadConsoleOutput",
    "SrvWriteConsoleOutput",
    "SrvReadConsoleOutputString",
    "SrvWriteConsoleOutputString",
    "SrvFillConsoleOutput",
    "SrvGetConsoleMode",
    "SrvGetConsoleNumberOfFonts",
    "SrvGetConsoleNumberOfInputEvents",
    "SrvGetConsoleScreenBufferInfo",
    "SrvGetConsoleCursorInfo",
    "SrvGetConsoleMouseInfo",
    "SrvGetConsoleFontInfo",
    "SrvGetConsoleFontSize",
    "SrvGetConsoleCurrentFont",
    "SrvSetConsoleMode",
    "SrvSetConsoleActiveScreenBuffer",
    "SrvFlushConsoleInputBuffer",
    "SrvGetLargestConsoleWindowSize",
    "SrvSetConsoleScreenBufferSize",
    "SrvSetConsoleCursorPosition",
    "SrvSetConsoleCursorInfo",
    "SrvSetConsoleWindowInfo",
    "SrvScrollConsoleScreenBuffer",
    "SrvSetConsoleTextAttribute",
    "SrvSetConsoleFont",
    "SrvSetConsoleIcon",
    "SrvReadConsole",
    "SrvWriteConsole",
    "SrvDuplicateHandle",
    "SrvGetHandleInformation",
    "SrvSetHandleInformation",
    "SrvCloseHandle",
    "SrvVerifyConsoleIoHandle",
    "SrvAllocConsole",
    "SrvFreeConsole",
    "SrvGetConsoleTitle",
    "SrvSetConsoleTitle",
    "SrvCreateConsoleScreenBuffer",
    "SrvInvalidateBitMapRect",
    "SrvVDMConsoleOperation",
    "SrvSetConsoleCursor",
    "SrvShowConsoleCursor",
    "SrvConsoleMenuControl",
    "SrvSetConsolePalette",
    "SrvSetConsoleDisplayMode",
    "SrvRegisterConsoleVDM",
    "SrvGetConsoleHardwareState",
    "SrvSetConsoleHardwareState",
    "SrvGetConsoleDisplayMode",
    "SrvAddConsoleAlias",
    "SrvGetConsoleAlias",
    "SrvGetConsoleAliasesLength",
    "SrvGetConsoleAliasExesLength",
    "SrvGetConsoleAliases",
    "SrvGetConsoleAliasExes",
    "SrvExpungeConsoleCommandHistory",
    "SrvSetConsoleNumberOfCommands",
    "SrvGetConsoleCommandHistoryLength",
    "SrvGetConsoleCommandHistory",
    "SrvSetConsoleCommandHistoryMode",
    "SrvGetConsoleCP",
    "SrvSetConsoleCP",
    "SrvSetConsoleKeyShortcuts",
    "SrvSetConsoleMenuClose",
    "SrvConsoleNotifyLastClose",
    "SrvGenerateConsoleCtrlEvent",
    "SrvGetConsoleKeyboardLayoutName",
    "SrvGetConsoleWindow",
#if defined(FE_SB)
    "SrvGetConsoleCharType",
    "SrvSetConsoleLocalEUDC",
    "SrvSetConsoleCursorMode",
    "SrvGetConsoleCursorMode",
    "SrvRegisterConsoleOS2",
    "SrvSetConsoleOS2OemFormat",
#if defined(FE_IME)
    "SrvGetConsoleNlsMode",
    "SrvSetConsoleNlsMode",
    "SrvRegisterConsoleIME",
    "SrvUnregisterConsoleIME",
#endif // FE_IME
#endif // FE_SB
    "SrvGetConsoleLangId",
    "SrvAttachConsole",
    "SrvGetConsoleSelectionInfo",
    "SrvGetConsoleProcessList",
};
#endif // DBG

BOOL FullScreenInitialized;
CRITICAL_SECTION    ConsoleVDMCriticalSection;
PCONSOLE_INFORMATION    ConsoleVDMOnSwitching;


CRITICAL_SECTION ConsoleInitWindowsLock;
BOOL fOneTimeInitialized;

UINT OEMCP;
UINT WINDOWSCP;
UINT ConsoleOutputCP;
CONSOLE_REGISTRY_INFO DefaultRegInfo;
#if defined(FE_SB)
BOOLEAN gfIsDBCSACP;
#endif

VOID
UnregisterVDM(
    IN PCONSOLE_INFORMATION Console
    );

ULONG
NonConsoleProcessShutdown(
    PCSR_PROCESS Process,
    DWORD dwFlags
    );

ULONG
ConsoleClientShutdown(
    PCSR_PROCESS Process,
    ULONG Flags,
    BOOLEAN fFirstPass
    );

NTSTATUS
ConsoleClientConnectRoutine(
    IN PCSR_PROCESS Process,
    IN OUT PVOID ConnectionInfo,
    IN OUT PULONG ConnectionInfoLength
    );

VOID
ConsoleClientDisconnectRoutine(
    IN PCSR_PROCESS Process
    );

VOID ConsolePlaySound(
    VOID
    );



HANDLE ghInstance;
HICON ghDefaultIcon;
HICON ghDefaultSmIcon;
HCURSOR ghNormalCursor;

PWIN32HEAP pConHeap;
DWORD  dwConBaseTag;

DWORD gExtendedEditKey;
BOOL  gfTrimLeadingZeros;
BOOL  gfEnableColorSelection;

BOOL gfLoadConIme;

VOID LoadLinkInfo(
    PCONSOLE_INFO ConsoleInfo,
    LPWSTR Title,
    LPDWORD TitleLength,
    LPWSTR CurDir,
    LPWSTR AppName
    )
{
    DWORD dwLinkLen;
    WCHAR LinkName[MAX_PATH + 1];
    LNKPROPNTCONSOLE linkprops;
    LPWSTR pszIconLocation;
    int nIconIndex;

    ConsoleInfo->uCodePage = OEMCP;

    // Do some initialization
    ConsoleInfo->hIcon = ghDefaultIcon;
    ConsoleInfo->hSmIcon = ghDefaultSmIcon;
    pszIconLocation = NULL;
    nIconIndex = 0;

    // Try to impersonate the client-side thread
    if (!CsrImpersonateClient(NULL)) {
        ConsoleInfo->dwStartupFlags &= ~STARTF_TITLEISLINKNAME;
        goto DefaultInit;
    }

    // Did we get started from a link?
    if (ConsoleInfo->dwStartupFlags & STARTF_TITLEISLINKNAME) {
        DWORD Success;
        DWORD oldLen;

        // Get the filename of the link (TitleLength is BYTES, not CHARS)
        dwLinkLen = (DWORD)(min(*TitleLength,(MAX_PATH+1)*sizeof(WCHAR)));
        RtlCopyMemory(LinkName, Title, dwLinkLen);
        LinkName[ MAX_PATH ] = (WCHAR)0;


        // Get the title for the window, which is effectively the link file name
        oldLen = *TitleLength;
        *TitleLength = GetTitleFromLinkName( LinkName, Title );
        if (*TitleLength < oldLen)
            Title[ *TitleLength / sizeof(WCHAR) ] = L'\0';

        // try to get console properties from the link
        Success = GetLinkProperties( LinkName,
                                      &linkprops,
                                      sizeof(linkprops)
                                     );

        if (Success == LINK_NOINFO) {
            ConsoleInfo->dwStartupFlags &= (~STARTF_TITLEISLINKNAME);
            goto NormalInit;
        }

        if (linkprops.pszIconLocation && *linkprops.pszIconLocation) {
            pszIconLocation = linkprops.pszIconLocation;
            nIconIndex = linkprops.uIcon;
            ConsoleInfo->iIconId = 0;
        }

        // Transfer link settings
        ConsoleInfo->dwHotKey = linkprops.uHotKey;
        ConsoleInfo->wShowWindow = (WORD)linkprops.uShowCmd;

        if (Success == LINK_SIMPLEINFO) {
            ConsoleInfo->dwStartupFlags &= (~STARTF_TITLEISLINKNAME);
            goto NormalInit;
        }

        // Transfer console link settings
        ConsoleInfo->wFillAttribute = linkprops.console_props.wFillAttribute;
        ConsoleInfo->wPopupFillAttribute = linkprops.console_props.wPopupFillAttribute;

        RtlCopyMemory( &ConsoleInfo->dwScreenBufferSize,
                       &linkprops.console_props.dwScreenBufferSize,
                       sizeof(NT_CONSOLE_PROPS) - FIELD_OFFSET(NT_CONSOLE_PROPS, dwScreenBufferSize)
                      );

        ConsoleInfo->uCodePage = linkprops.fe_console_props.uCodePage;
        ConsoleInfo->dwStartupFlags &= ~(STARTF_USESIZE | STARTF_USECOUNTCHARS);
    }

NormalInit:

    //
    // Go get the icon
    //

    if (pszIconLocation == NULL) {
        dwLinkLen = RtlDosSearchPath_U(CurDir,
                                       AppName,
                                       NULL,
                                       sizeof(LinkName),
                                       LinkName,
                                       NULL);
        if (dwLinkLen > 0 && dwLinkLen < sizeof(LinkName)) {
            pszIconLocation = LinkName;
        } else {
            pszIconLocation = AppName;
        }
    }

    if (pszIconLocation != NULL) {
        HICON hIcon, hSmIcon;
        hIcon = hSmIcon = NULL;
        PrivateExtractIconExW(pszIconLocation,
                              nIconIndex,
                              &hIcon,
                              &hSmIcon,
                              1);
        /*
         * If there is no large icon, use the default ones.
         * If there is only a large icon in the resource, do not use
         * the default small one but let it be NULL so we'll stretch
         * the large one.
         */
        if (hIcon != NULL) {
            ConsoleInfo->hIcon = hIcon;
            ConsoleInfo->hSmIcon = hSmIcon;
        }
    }

    CsrRevertToSelf();

    if (!IsValidCodePage(ConsoleInfo->uCodePage)) {    // fail safe
        ConsoleInfo->uCodePage = OEMCP;
    }

    if (!(ConsoleInfo->dwStartupFlags & STARTF_TITLEISLINKNAME)) {
        CONSOLE_REGISTRY_INFO RegInfo;

DefaultInit:
        //
        // read values from the registry
        //

        RegInfo = DefaultRegInfo;
        GetRegistryValues(Title, &RegInfo);

        //
        // If a value isn't specified in STARTUPINFO, then use the one
        // from the registry.
        //

        if (!(ConsoleInfo->dwStartupFlags & STARTF_USEFILLATTRIBUTE)) {
            ConsoleInfo->wFillAttribute = RegInfo.ScreenFill.Attributes;
        }
        ConsoleInfo->wPopupFillAttribute = RegInfo.PopupFill.Attributes;

        if (!(ConsoleInfo->dwStartupFlags & STARTF_USECOUNTCHARS)) {
            ConsoleInfo->dwScreenBufferSize = RegInfo.ScreenBufferSize;
        }
        if (!(ConsoleInfo->dwStartupFlags & STARTF_USESIZE)) {
            ConsoleInfo->dwWindowSize = RegInfo.WindowSize;
        }
        if (!(ConsoleInfo->dwStartupFlags & STARTF_USEPOSITION)) {
            ConsoleInfo->dwWindowOrigin = RegInfo.WindowOrigin;
            ConsoleInfo->bAutoPosition = RegInfo.AutoPosition;
        } else {
            ConsoleInfo->bAutoPosition = FALSE;
        }
        if (!(ConsoleInfo->dwStartupFlags & STARTF_RUNFULLSCREEN)) {
            ConsoleInfo->bFullScreen = RegInfo.FullScreen;
        } else {
            ConsoleInfo->bFullScreen = TRUE;
        }

        ConsoleInfo->uFontFamily = RegInfo.FontFamily;
        ConsoleInfo->uFontWeight = RegInfo.FontWeight;
        ConsoleInfo->dwFontSize = RegInfo.FontSize;
        RtlCopyMemory(ConsoleInfo->FaceName, RegInfo.FaceName, sizeof(RegInfo.FaceName));

        ConsoleInfo->bQuickEdit = RegInfo.QuickEdit;
        ConsoleInfo->bInsertMode = RegInfo.InsertMode;

        ConsoleInfo->uCursorSize = RegInfo.CursorSize;
        ConsoleInfo->uHistoryBufferSize = RegInfo.HistoryBufferSize;
        ConsoleInfo->uNumberOfHistoryBuffers = RegInfo.NumberOfHistoryBuffers;
        ConsoleInfo->bHistoryNoDup = RegInfo.HistoryNoDup;
        RtlCopyMemory(ConsoleInfo->ColorTable, RegInfo.ColorTable, sizeof(RegInfo.ColorTable));
#ifdef FE_SB
        ConsoleInfo->uCodePage = RegInfo.CodePage;
#endif
    }
}


BOOL
InitWindowClass( VOID )
{
    WNDCLASSEX wc;
    BOOL retval;
    ATOM atomConsoleClass;

    ghNormalCursor = LoadCursor(NULL, IDC_ARROW);
    ASSERT(ghModuleWin != NULL);
    ghDefaultIcon       = LoadIcon(ghModuleWin, MAKEINTRESOURCE(IDI_CONSOLE));
    ghDefaultSmIcon     = LoadImage(ghModuleWin, MAKEINTRESOURCE(IDI_CONSOLE), IMAGE_ICON,
                                    GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON),
                                    LR_SHARED);
    wc.hIcon            = ghDefaultIcon;
    wc.cbSize           = sizeof(WNDCLASSEX);
    wc.style            = CS_HREDRAW | CS_VREDRAW | CS_OWNDC | CS_DBLCLKS;
    wc.lpfnWndProc      = ConsoleWindowProc;
    wc.cbClsExtra       = 0;
    wc.cbWndExtra       = GWL_CONSOLE_WNDALLOC;
    wc.hInstance        = ghInstance;
    wc.hCursor          = ghNormalCursor;
    wc.hbrBackground    = CreateSolidBrush(DefaultRegInfo.ColorTable[LOBYTE(DefaultRegInfo.ScreenFill.Attributes >> 4) & 0xF]);
    wc.lpszMenuName     = NULL;
    wc.lpszClassName    = CONSOLE_WINDOW_CLASS;
    wc.hIconSm          = ghDefaultSmIcon;

    atomConsoleClass = RegisterClassEx(&wc);
    retval = (atomConsoleClass != 0);

    if (retval)
        NtUserConsoleControl(ConsoleClassAtom, &atomConsoleClass, sizeof(ATOM));

    return retval;
}


NTSTATUS
InitWindowsStuff(
    HDESK hdesk,
    LPDWORD lpdwThreadId)
{
    NTSTATUS Status = STATUS_SUCCESS;
    CLIENT_ID ClientId;
    CONSOLEDESKTOPCONSOLETHREAD ConsoleDesktopInfo;
    INPUT_THREAD_INIT_INFO InputThreadInitInfo;

    //
    // This routine must be done within a critical section to ensure that
    // only one thread can initialize at a time. We need a special critical
    // section here because Csr calls into ConsoleAddProcessRoutine with
    // it's own critical section locked and then tries to grab the
    // ConsoleHandleTableLock. If we call CsrAddStaticServerThread here
    // with the ConsoleHandleTableLock locked we could get into a deadlock
    // situation. This critical section should not be used anywhere else.
    //

    RtlEnterCriticalSection(&ConsoleInitWindowsLock);

    ConsoleDesktopInfo.hdesk = hdesk;
    ConsoleDesktopInfo.dwThreadId = (DWORD)-1;
    NtUserConsoleControl(ConsoleDesktopConsoleThread, &ConsoleDesktopInfo,
            sizeof(ConsoleDesktopInfo));
    if (ConsoleDesktopInfo.dwThreadId == 0) {

        if (!fOneTimeInitialized) {

#ifdef FE_SB
            InitializeDbcsMisc();
#endif // FE_SB

            FullScreenInitialized = InitializeFullScreen();

            //
            // read the registry values
            //

            GetRegistryValues(L"", &DefaultRegInfo);

            //
            // allocate buffer for scrolling
            //

            Status = InitializeScrollBuffer();
            if (!NT_SUCCESS(Status)) {
                RIPMSG1(RIP_WARNING, "InitWindowsStuff: InitScrollBuffer failed %x", Status);
                goto ErrorExit;
            }
        }

        //
        // create GetMessage thread
        //

        Status = NtCreateEvent(&InputThreadInitInfo.InitCompleteEventHandle, EVENT_ALL_ACCESS,
                               NULL, NotificationEvent, FALSE);
        if (!NT_SUCCESS(Status)) {
            goto ErrorExit;
        }

        Status = NtDuplicateObject(NtCurrentProcess(), hdesk,
                NtCurrentProcess(), &InputThreadInitInfo.DesktopHandle, 0,
                0, DUPLICATE_SAME_ACCESS);
        if (!NT_SUCCESS(Status)) {
            NtClose(InputThreadInitInfo.InitCompleteEventHandle);
            goto ErrorExit;
        }

        // can't call CreateThread from server
        Status = RtlCreateUserThread(NtCurrentProcess(),
                                     (PSECURITY_DESCRIPTOR) NULL,
                                     TRUE,
                                     0,
                                     0,
                                     0x5000,
                                     (PUSER_THREAD_START_ROUTINE)ConsoleInputThread,
                                     &InputThreadInitInfo,
                                     &InputThreadInitInfo.ThreadHandle,
                                     &ClientId
                                    );
        if (!NT_SUCCESS(Status)) {
            NtClose(InputThreadInitInfo.InitCompleteEventHandle);
            CloseDesktop(InputThreadInitInfo.DesktopHandle);
            goto ErrorExit;
        }

        CsrAddStaticServerThread(InputThreadInitInfo.ThreadHandle, &ClientId, 0);
        NtResumeThread(InputThreadInitInfo.ThreadHandle, NULL);
        NtWaitForSingleObject(InputThreadInitInfo.InitCompleteEventHandle, FALSE, NULL);
        NtClose(InputThreadInitInfo.InitCompleteEventHandle);

        if (!NT_SUCCESS(InputThreadInitInfo.InitStatus)) {
            Status = InputThreadInitInfo.InitStatus;
            goto ErrorExit;
        }

        *lpdwThreadId = HandleToUlong(ClientId.UniqueThread);

        fOneTimeInitialized=TRUE;
    } else {
        *lpdwThreadId = ConsoleDesktopInfo.dwThreadId;
    }

ErrorExit:
    RtlLeaveCriticalSection(&ConsoleInitWindowsLock);

    return Status;
}


NTSTATUS
ConServerDllInitialization(
    PCSR_SERVER_DLL LoadedServerDll)

/*++

Routine Description:

    This routine is called to initialize the server dll.  It initializes
    the console handle table.

Arguments:

    LoadedServerDll - Pointer to console server dll data

Return Value:

--*/

{
    NTSTATUS Status;

    LoadedServerDll->ApiNumberBase = CONSRV_FIRST_API_NUMBER;
    LoadedServerDll->MaxApiNumber = ConsolepMaxApiNumber;
    LoadedServerDll->ApiDispatchTable = (PCSR_API_ROUTINE *)ConsoleServerApiDispatchTable;
    LoadedServerDll->ApiServerValidTable = (PBOOLEAN)ConsoleServerApiServerValidTable;
#if DBG
    LoadedServerDll->ApiNameTable = ConsoleServerApiNameTable;
#else
    LoadedServerDll->ApiNameTable = NULL;
#endif
    LoadedServerDll->PerProcessDataLength = sizeof(CONSOLE_PER_PROCESS_DATA);
    LoadedServerDll->ConnectRoutine = ConsoleClientConnectRoutine;
    LoadedServerDll->DisconnectRoutine = ConsoleClientDisconnectRoutine;
    LoadedServerDll->AddProcessRoutine = ConsoleAddProcessRoutine;
    LoadedServerDll->ShutdownProcessRoutine = ConsoleClientShutdown;

    ghInstance = LoadedServerDll->ModuleHandle;

    // initialize data structures

    InitWin32HeapStubs();

    pConHeap = Win32HeapCreate(
                              "CH_Head",
                              "CH_Tail",
                              HEAP_GROWABLE | HEAP_CLASS_5 |
#ifdef PRERELEASE 
                              HEAP_TAIL_CHECKING_ENABLED,
#else
                              0,
#endif // PRERELEASE
                              NULL,             // HeapBase
                              64 * 1024,        // ReserveSize
                              4096,             // CommitSize
                              NULL,             // Lock to use for serialization
                              NULL);            // GrowthThreshold

    if (pConHeap == NULL) {
        return STATUS_NO_MEMORY;
    }

    dwConBaseTag = Win32HeapCreateTag( pConHeap,
                                     0,
                                     L"CON!",
                                     L"TMP\0"
                                     L"BMP\0"
                                     L"ALIAS\0"
                                     L"HISTORY\0"
                                     L"TITLE\0"
                                     L"HANDLE\0"
                                     L"CONSOLE\0"
                                     L"ICON\0"
                                     L"BUFFER\0"
                                     L"WAIT\0"
                                     L"FONT\0"
                                     L"SCREEN\0"
#if defined(FE_SB)
                                     L"TMP DBCS\0"
                                     L"SCREEN DBCS\0"
                                     L"EUDC\0"
                                     L"CONVAREA\0"
                                     L"IME\0"
#endif
                                   );
    Status = InitializeConsoleHandleTable();
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    Status = RtlInitializeCriticalSectionAndSpinCount(&ConsoleInitWindowsLock,
                                                      0x80000000);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Initialize Input thread local message queue
    //
    Status = RtlInitializeCriticalSectionAndSpinCount(&gInputThreadMsgLock,
                                                      0x80000000);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    InitializeThreadMessages();

#ifdef i386
    Status = RtlInitializeCriticalSectionAndSpinCount(&ConsoleVDMCriticalSection,
                                                      0x80000000);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    ConsoleVDMOnSwitching = NULL;
#endif

    OEMCP = GetOEMCP();
    WINDOWSCP = GetACP();
#if !defined(FE_SB)
    ConsoleOutputCP = OEMCP;
#endif

    InitializeFonts();

    InputThreadTlsIndex = TlsAlloc();
    if (InputThreadTlsIndex == 0xFFFFFFFF) {
        return STATUS_UNSUCCESSFUL;
    }

#if defined(FE_SB)
    gfIsDBCSACP = !!IsAvailableFarEastCodePage(WINDOWSCP);
#endif

    return STATUS_SUCCESS;
}

BOOL
MapHandle(
    IN HANDLE ClientProcessHandle,
    IN HANDLE ServerHandle,
    OUT PHANDLE ClientHandle
    )
{
    //
    // map event handle into dll's handle space.
    //

    return DuplicateHandle(NtCurrentProcess(),
                           ServerHandle,
                           ClientProcessHandle,
                           ClientHandle,
                           0,
                           FALSE,
                           DUPLICATE_SAME_ACCESS
                          );
}

VOID
AddProcessToList(
    IN OUT PCONSOLE_INFORMATION Console,
    IN OUT PCONSOLE_PROCESS_HANDLE ProcessHandleRecord,
    IN HANDLE ProcessHandle
    )
{
    ASSERT(!(Console->Flags & (CONSOLE_TERMINATING | CONSOLE_SHUTTING_DOWN)));

    ProcessHandleRecord->ProcessHandle = ProcessHandle;
    ProcessHandleRecord->TerminateCount = 0;
    InsertHeadList(&Console->ProcessHandleList, &ProcessHandleRecord->ListLink);

    SetProcessFocus(ProcessHandleRecord->Process, Console->Flags & CONSOLE_HAS_FOCUS);
}

PCONSOLE_PROCESS_HANDLE
FindProcessInList(
    IN PCONSOLE_INFORMATION Console,
    IN HANDLE ProcessHandle
    )
{
    PCONSOLE_PROCESS_HANDLE ProcessHandleRecord;
    PLIST_ENTRY ListHead, ListNext;

    ListHead = &Console->ProcessHandleList;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        ProcessHandleRecord = CONTAINING_RECORD( ListNext, CONSOLE_PROCESS_HANDLE, ListLink );
        if (ProcessHandleRecord->ProcessHandle == ProcessHandle) {
            return ProcessHandleRecord;
        }
        ListNext = ListNext->Flink;
    }
    return NULL;
}

VOID
RemoveProcessFromList(
    IN OUT PCONSOLE_INFORMATION Console,
    IN HANDLE ProcessHandle
    )
{
    PCONSOLE_PROCESS_HANDLE ProcessHandleRecord;
    PLIST_ENTRY ListHead, ListNext;

    ListHead = &Console->ProcessHandleList;
    ListNext = ListHead->Flink;
    while (ListNext != ListHead) {
        ProcessHandleRecord = CONTAINING_RECORD( ListNext, CONSOLE_PROCESS_HANDLE, ListLink );
        ListNext = ListNext->Flink;
        if (ProcessHandleRecord->ProcessHandle == ProcessHandle) {
            RemoveEntryList(&ProcessHandleRecord->ListLink);
            ConsoleHeapFree(ProcessHandleRecord);
            return;
        }
    }

    RIPMSG1(RIP_ERROR, "RemoveProcessFromList: Process %#p not found", ProcessHandle);
}

NTSTATUS
SetUpConsole(
    IN OUT PCONSOLE_INFO ConsoleInfo,
    IN DWORD TitleLength,
    IN LPWSTR Title,
    IN LPWSTR CurDir,
    IN LPWSTR AppName,
    IN PCONSOLE_PER_PROCESS_DATA ProcessData,
    IN BOOLEAN WindowVisible,
    IN PUNICODE_STRING pstrDesktopName
    )
{
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    DWORD ConsoleThreadId;
    HWINSTA hwinsta;
    HDESK hdesk;
    USEROBJECTFLAGS UserObjectFlags;
    DWORD Length;

    //
    // Connect to the windowstation and desktop.
    //

    if (!CsrImpersonateClient(NULL)) {
        return STATUS_BAD_IMPERSONATION_LEVEL;
    }

    hdesk = NtUserResolveDesktop(CONSOLE_CLIENTPROCESSHANDLE(),
            pstrDesktopName, FALSE, &hwinsta);

    CsrRevertToSelf();

    if (hdesk == NULL) {
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Need to initialize windows stuff once real console app starts.
    // This is because for the time being windows expects the first
    // app to be a windows app.
    //

    Status = InitWindowsStuff(hdesk, &ConsoleThreadId);
    if (!NT_SUCCESS(Status)) {
        CloseDesktop(hdesk);
        CloseWindowStation(hwinsta);
        return Status;
    }

    //
    // If the windowstation isn't visible, then neither is the window.
    //

    if (WindowVisible) {
        if (GetUserObjectInformation(hwinsta,
                                     UOI_FLAGS,
                                     &UserObjectFlags,
                                     sizeof(UserObjectFlags),
                                     &Length)) {
            if (!(UserObjectFlags.dwFlags & WSF_VISIBLE)) {
                WindowVisible = FALSE;
            }
        }
    }

    //
    // We need to see if we were spawned from a link.  If we were, we
    // need to call back into the shell to try to get all the console
    // information from the link.
    //

    LoadLinkInfo( ConsoleInfo, Title, &TitleLength, CurDir, AppName );

    LockConsoleHandleTable();

    Status = AllocateConsoleHandle(&ConsoleInfo->ConsoleHandle);
    if (!NT_SUCCESS(Status)) {
        UnlockConsoleHandleTable();
        CloseDesktop(hdesk);
        CloseWindowStation(hwinsta);
        return Status;
    }

    Status = AllocateConsole(ConsoleInfo->ConsoleHandle,
                             Title,
                             (USHORT)TitleLength,
                             CONSOLE_CLIENTPROCESSHANDLE(),
                             &ConsoleInfo->StdIn,
                             &ConsoleInfo->StdOut,
                             &ConsoleInfo->StdErr,
                             ProcessData,
                             ConsoleInfo,
                             WindowVisible,
                             ConsoleThreadId
                             );
    if (!NT_SUCCESS(Status)) {
        FreeConsoleHandle(ConsoleInfo->ConsoleHandle);
        UnlockConsoleHandleTable();
        CloseDesktop(hdesk);
        CloseWindowStation(hwinsta);
        return Status;
    }
    CONSOLE_SETCONSOLEHANDLE(ConsoleInfo->ConsoleHandle);
    Status = DereferenceConsoleHandle(ConsoleInfo->ConsoleHandle,&Console);
    ASSERT (NT_SUCCESS(Status));

    //
    // increment console reference count
    //

    Console->RefCount++;

    //
    // Save the windowstation and desktop handles so they
    // can be used later
    //

    Console->hWinSta = hwinsta;
    Console->hDesk = hdesk;

    UnlockConsoleHandleTable();

#if defined(FE_IME)
    if (CONSOLE_IS_IME_ENABLED())
    {
        if (WindowVisible)
        {
            InitConsoleIMEStuff(Console->hDesk, ConsoleThreadId, Console);
        }
    }
#endif

    return Status;
}

NTSTATUS
ConsoleClientConnectRoutine(
    IN PCSR_PROCESS Process,
    IN OUT PVOID ConnectionInfo,
    IN OUT PULONG ConnectionInfoLength)

/*++

Routine Description:

    This routine is called when a new process is created.  For processes
    without parents, it creates the console.  For processes with
    parents, it duplicates the handle table.

Arguments:

    Process - Pointer to process structure.

    ConnectionInfo - Pointer to connection info.

    ConnectionInfoLength - Connection info length.

Return Value:

--*/

{
    NTSTATUS Status;
    PCONSOLE_API_CONNECTINFO p = (PCONSOLE_API_CONNECTINFO)ConnectionInfo;
    PCONSOLE_INFORMATION Console;
    PCONSOLE_PER_PROCESS_DATA ProcessData;
    PCONSOLE_PROCESS_HANDLE ProcessHandleRecord;
    CONSOLEWINDOWSTATIONPROCESS ConsoleWindowStationInfo;
    UNICODE_STRING strDesktopName;
    CONSOLE_PROCESS_INFO cpi;

    if (p == NULL ||
        *ConnectionInfoLength != sizeof( *p ) ||
        p->AppNameLength > sizeof(p->AppName) ||
        p->CurDirLength > sizeof(p->CurDir) ||
        p->TitleLength > sizeof(p->Title)) {

        RIPMSG0(RIP_ERROR, "CONSRV: bad connection info\n");
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Make sure the strings are NULL terminated.
    //

    p->AppName[NELEM(p->AppName) - 1] = 0;
    p->CurDir[NELEM(p->CurDir) - 1] = 0;
    p->Title[NELEM(p->Title) - 1] = 0;

    if (CtrlRoutine == NULL) {
        CtrlRoutine = p->CtrlRoutine;
    }
#if defined(FE_IME)
    if (ConsoleIMERoutine == NULL) {
        ConsoleIMERoutine = p->ConsoleIMERoutine;
    }
#endif
    ProcessData = CONSOLE_FROMPROCESSPERPROCESSDATA(Process);
    Console = NULL;

    //
    // If this process is not a console app, stop right here - no
    // initialization is needed. Just need to remember that this
    // is not a console app so that we do no work during
    // ConsoleClientDisconnectRoutine().
    //

    Status = STATUS_SUCCESS;
    if ((CONSOLE_GETCONSOLEAPPFROMPROCESSDATA(ProcessData) = p->ConsoleApp)) {

        //
        // First call off to USER so it unblocks any app waiting on a call
        // to WaitForInputIdle. This way apps calling WinExec() to exec console
        // apps will return right away.
        //


        cpi.dwProcessID = HandleToUlong(CONSOLE_CLIENTPROCESSID());
        cpi.dwFlags = (p->ConsoleInfo.ConsoleHandle != NULL) ? 0 : CPI_NEWPROCESSWINDOW;
        NtUserConsoleControl(ConsoleNotifyConsoleApplication,
                &cpi, sizeof(CONSOLE_PROCESS_INFO));

        //
        // create console
        //

        if (p->ConsoleInfo.ConsoleHandle == NULL) {
            ProcessHandleRecord = ConsoleHeapAlloc(MAKE_TAG( HANDLE_TAG ), sizeof(CONSOLE_PROCESS_HANDLE));
            if (ProcessHandleRecord == NULL) {
                Status = STATUS_NO_MEMORY;
                goto ErrorExit;
            }

            //
            // We are creating a new console, so derereference
            // the parent's console, if any.
            //

            if (ProcessData->ConsoleHandle != NULL) {
                RemoveConsole(ProcessData, Process->ProcessHandle, 0);
            }

            //
            // Get the desktop name.
            //

            if (p->DesktopLength) {
                strDesktopName.Buffer = ConsoleHeapAlloc(
                                                  MAKE_TAG( TMP_TAG ),
                                                  p->DesktopLength);
                if (strDesktopName.Buffer == NULL) {
                    Status = STATUS_NO_MEMORY;
                    goto ErrorExit;
                }
                Status = NtReadVirtualMemory(Process->ProcessHandle,
                                    (PVOID)p->Desktop,
                                    strDesktopName.Buffer,
                                    p->DesktopLength,
                                    NULL
                                   );
                if (!NT_SUCCESS(Status)) {
                    ConsoleHeapFree(strDesktopName.Buffer);
                    goto ErrorExit;
                }
                strDesktopName.MaximumLength = (USHORT)p->DesktopLength;
                strDesktopName.Length = (USHORT)(p->DesktopLength - sizeof(WCHAR));
            } else {
                RtlInitUnicodeString(&strDesktopName, L"Default");
            }

            ProcessData->RootProcess = TRUE;
            Status = SetUpConsole(&p->ConsoleInfo,
                                  p->TitleLength,
                                  p->Title,
                                  p->CurDir,
                                  p->AppName,
                                  ProcessData,
                                  p->WindowVisible,
                                  &strDesktopName);
            if (p->DesktopLength) {
                ConsoleHeapFree(strDesktopName.Buffer);
            }

            if (!NT_SUCCESS(Status)) {
                goto ErrorExit;
            }

            // Play the Open sound for console apps

            ConsolePlaySound();

            Status = RevalidateConsole(p->ConsoleInfo.ConsoleHandle, &Console);
            ASSERT (NT_SUCCESS(Status));
        } else {
            ProcessHandleRecord = NULL;
            ProcessData->RootProcess = FALSE;

            Status = STATUS_SUCCESS;
            if (!(NT_SUCCESS(RevalidateConsole(p->ConsoleInfo.ConsoleHandle, &Console))) ) {
                Status = STATUS_PROCESS_IS_TERMINATING;
                goto ErrorExit;
            }

            if (Console->Flags & CONSOLE_SHUTTING_DOWN) {
                Status = STATUS_PROCESS_IS_TERMINATING;
                goto ErrorExit;
            }

            Status = MapEventHandles(CONSOLE_CLIENTPROCESSHANDLE(),
                                     Console,
                                     &p->ConsoleInfo
                                    );
            if (!NT_SUCCESS(Status)) {
                goto ErrorExit;
            }

            ProcessHandleRecord = FindProcessInList(Console, CONSOLE_CLIENTPROCESSHANDLE());
            if (ProcessHandleRecord) {
                ProcessHandleRecord->CtrlRoutine = p->CtrlRoutine;
                ProcessHandleRecord->PropRoutine = p->PropRoutine;
                ProcessHandleRecord = NULL;
            }
        }

        if (NT_SUCCESS(Status)) {

            //
            // Associate the correct window station with client process
            // so they can do Global atom calls.
            //
            if (DuplicateHandle( NtCurrentProcess(),
                                 Console->hWinSta,
                                 Process->ProcessHandle,
                                 &ConsoleWindowStationInfo.hwinsta,
                                 0,
                                 FALSE,
                                 DUPLICATE_SAME_ACCESS
                               )
               ) {
                ConsoleWindowStationInfo.dwProcessId = HandleToUlong(CONSOLE_CLIENTPROCESSID());
                NtUserConsoleControl(ConsoleWindowStationProcess,
                        &ConsoleWindowStationInfo, sizeof(ConsoleWindowStationInfo));

                }

            if (ProcessHandleRecord) {
                ProcessHandleRecord->Process = Process;
                ProcessHandleRecord->CtrlRoutine = p->CtrlRoutine;
                ProcessHandleRecord->PropRoutine = p->PropRoutine;
                AddProcessToList(Console, ProcessHandleRecord, CONSOLE_CLIENTPROCESSHANDLE());
            }
            SetProcessForegroundRights(Process,
                                       Console->Flags & CONSOLE_HAS_FOCUS);
            AllocateCommandHistory(Console,
                                   p->AppNameLength,
                                   p->AppName,
                                   CONSOLE_CLIENTPROCESSHANDLE());
        } else {
ErrorExit:
            CONSOLE_SETCONSOLEAPPFROMPROCESSDATA(ProcessData, FALSE);
            if (ProcessHandleRecord)
                ConsoleHeapFree(ProcessHandleRecord);
            if (ProcessData->ConsoleHandle != NULL) {
                RemoveConsole(ProcessData, Process->ProcessHandle, 0);
            }
        }

        if (Console) {
            ConsoleNotifyWinEvent(Console,
                                  EVENT_CONSOLE_START_APPLICATION,
                                  HandleToULong(Process->ClientId.UniqueProcess),
                                  0);
            UnlockConsole(Console);
        }
    } else if (ProcessData->ConsoleHandle != NULL) {

        //
        // This is a non-console app with a reference to a
        // reference to a parent console.  Dereference the
        // console.
        //

        RemoveConsole(ProcessData, Process->ProcessHandle, 0);
    }

    return Status;
}

NTSTATUS
RemoveConsole(
    IN PCONSOLE_PER_PROCESS_DATA ProcessData,
    IN HANDLE ProcessHandle,
    IN HANDLE ProcessId
    )
{
    ULONG i;
    PHANDLE_DATA HandleData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;

    Status = RevalidateConsole(ProcessData->ConsoleHandle, &Console);

    //
    // If this process isn't using the console, error.
    //

    if (!NT_SUCCESS(Status)) {
        ASSERT(FALSE);
        return Status;
    }

    if (Console->Flags & CONSOLE_NOTIFY_LAST_CLOSE) {
        if (Console->ProcessIdLastNotifyClose == ProcessId) {
            // if this process is the one who wants last close notification,
            // remove it.
            Console->Flags &= ~CONSOLE_NOTIFY_LAST_CLOSE;
            NtClose(Console->hProcessLastNotifyClose);
        } else if (ProcessData->RootProcess) {
            // notify the ntvdm process to terminate if the console root
            // process is going away.
            HANDLE ConsoleHandle;
            CONSOLE_PROCESS_TERMINATION_RECORD ProcessHandleList;

            Console->Flags &= ~CONSOLE_NOTIFY_LAST_CLOSE;
            ConsoleHandle = Console->ConsoleHandle;
            ProcessHandleList.ProcessHandle = Console->hProcessLastNotifyClose;
            ProcessHandleList.TerminateCount = 0;
            ProcessHandleList.CtrlRoutine = CtrlRoutine;
            UnlockConsole(Console);
            CreateCtrlThread(&ProcessHandleList,
                            1,
                            NULL,
                            SYSTEM_ROOT_CONSOLE_EVENT,
                            TRUE);
            NtClose(ProcessHandleList.ProcessHandle);
            Status = RevalidateConsole(ConsoleHandle, &Console);
            ASSERT(NT_SUCCESS(Status));
            if (!NT_SUCCESS(Status)) {
                return STATUS_SUCCESS;
            }
        }
    }

    if (Console->VDMProcessId == ProcessId &&
        (Console->Flags & CONSOLE_VDM_REGISTERED)) {
        Console->Flags &= ~CONSOLE_FULLSCREEN_NOPAINT;
        UnregisterVDM(Console);
    }

    if (ProcessHandle != NULL) {
        RemoveProcessFromList(Console, ProcessHandle);
        FreeCommandHistory(Console, ProcessHandle);
    }

    ASSERT(Console->RefCount);

    //
    // close the process's handles.
    //

    for (i=0;i<ProcessData->HandleTableSize;i++) {
        if (ProcessData->HandleTablePtr[i].HandleType != CONSOLE_FREE_HANDLE) {
            Status = DereferenceIoHandleNoCheck(ProcessData,
                                                LongToHandle(i),
                                                &HandleData
                                               );
            ASSERT (NT_SUCCESS(Status));
            if (HandleData->HandleType & CONSOLE_INPUT_HANDLE) {
                Status = CloseInputHandle(ProcessData, Console, HandleData, LongToHandle(i));
            }
            else {
                Status = CloseOutputHandle(ProcessData, Console, HandleData, LongToHandle(i), FALSE);
            }
        }
    }
    FreeProcessData(ProcessData);
    ProcessData->ConsoleHandle = NULL;

    //
    // decrement the console reference count.  free the console if it goes to
    // zero.
    //

    Console->RefCount--;
    if (Console->RefCount == 0) {

#if defined(FE_IME)

        PCONVERSIONAREA_INFORMATION ConvAreaInfo;
        PCONVERSIONAREA_INFORMATION ConvAreaInfoNext;

        ConvAreaInfo = Console->ConsoleIme.ConvAreaRoot;
        while(ConvAreaInfo) {
            ConvAreaInfoNext = ConvAreaInfo->ConvAreaNext;
            FreeConvAreaScreenBuffer(ConvAreaInfo->ScreenBuffer);
            ConsoleHeapFree(ConvAreaInfo);
            ConvAreaInfo = ConvAreaInfoNext;
        }

        if (Console->ConsoleIme.NumberOfConvAreaCompStr) {
            ConsoleHeapFree(Console->ConsoleIme.ConvAreaCompStr);
        }
        if (Console->ConsoleIme.CompStrData) {
            ConsoleHeapFree(Console->ConsoleIme.CompStrData);
        }
#endif
        FreeCon(Console);
    }
    else {
        UnlockConsole(Console);
    }

    return STATUS_SUCCESS;
}

VOID
ConsoleClientDisconnectRoutine(
    IN PCSR_PROCESS Process)

/*++

Routine Description:

    This routine is called when a process is destroyed.  It closes the
    process's handles and frees the console if it's the last reference.

Arguments:

    Process - Pointer to process structure.

Return Value:

--*/

{
    PCONSOLE_PER_PROCESS_DATA ProcessData;
    PCONSOLE_INFORMATION Console;
    NTSTATUS Status;

    ProcessData = CONSOLE_FROMPROCESSPERPROCESSDATA(Process);

    //
    // If this process is not a console app, stop right here - no
    // disconnect processing is needed, because this app didn't create
    // or connect to an existing console.
    //

    if (ProcessData->ConsoleHandle == NULL) {
#if defined(FE_IME)
        if (ProcessData->hDesk) {
            //
            // If this process is a Console IME,
            // should unregister console IME on this desktop.
            //
            RemoveConsoleIME(Process, HandleToUlong(Process->ClientId.UniqueThread));
        }
#endif
        return;
    }

    Status = RevalidateConsole(ProcessData->ConsoleHandle, &Console);
    if (NT_SUCCESS(Status)) {
        ConsoleNotifyWinEvent(Console,
                              EVENT_CONSOLE_END_APPLICATION,
                              HandleToULong(Process->ClientId.UniqueProcess),
                              0);
        UnlockConsole(Console);
    } else {
        RIPMSG2(RIP_WARNING, "RevalidateConsole returned status 0x%x on console 0x%x", Status, ProcessData->ConsoleHandle);
    }

    RemoveConsole(ProcessData,
                  CONSOLE_FROMPROCESSPROCESSHANDLE(Process),
                  Process->ClientId.UniqueProcess);
    CONSOLE_SETCONSOLEAPPFROMPROCESSDATA(ProcessData, FALSE);
}

ULONG
SrvAllocConsole(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_ALLOC_MSG a = (PCONSOLE_ALLOC_MSG)&m->u.ApiMessageData;
    PCONSOLE_PER_PROCESS_DATA ProcessData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;
    PCONSOLE_PROCESS_HANDLE ProcessHandleRecord;
    PCSR_PROCESS Process;
    UNICODE_STRING strDesktopName;

    ProcessData = CONSOLE_PERPROCESSDATA();
    ASSERT(!CONSOLE_GETCONSOLEAPPFROMPROCESSDATA(ProcessData));

    if (!CsrValidateMessageBuffer(m, &a->Title, a->TitleLength, sizeof(BYTE)) ||
        !CsrValidateMessageBuffer(m, &a->Desktop, a->DesktopLength, sizeof(BYTE)) ||
        !CsrValidateMessageBuffer(m, &a->CurDir, a->CurDirLength, sizeof(BYTE)) ||
        !CsrValidateMessageBuffer(m, &a->AppName, a->AppNameLength, sizeof(BYTE)) ||
        !CsrValidateMessageBuffer(m, &a->ConsoleInfo, sizeof(*a->ConsoleInfo), sizeof(BYTE))) {

        return STATUS_INVALID_PARAMETER;
    }

    Process = (PCSR_PROCESS)(CSR_SERVER_QUERYCLIENTTHREAD()->Process);
    if (a->DesktopLength) {
        RtlInitUnicodeString(&strDesktopName, a->Desktop);
    } else {
        RtlInitUnicodeString(&strDesktopName, L"Default");
    }

    ProcessHandleRecord = ConsoleHeapAlloc(MAKE_TAG( HANDLE_TAG ), sizeof(CONSOLE_PROCESS_HANDLE));
    if (ProcessHandleRecord == NULL) {
        return (ULONG)STATUS_NO_MEMORY;
    }

    Status = SetUpConsole(a->ConsoleInfo,
                          a->TitleLength,
                          a->Title,
                          a->CurDir,
                          a->AppName,
                          ProcessData,
                          TRUE,
                          &strDesktopName);
    if (!NT_SUCCESS(Status)) {
        ConsoleHeapFree(ProcessHandleRecord);
        return Status;
    }
    CONSOLE_SETCONSOLEAPP(TRUE);
    Process->Flags |= CSR_PROCESS_CONSOLEAPP;
    Status = RevalidateConsole(a->ConsoleInfo->ConsoleHandle,&Console);
    ASSERT (NT_SUCCESS(Status));
    ProcessHandleRecord->Process = CSR_SERVER_QUERYCLIENTTHREAD()->Process;
    ProcessHandleRecord->CtrlRoutine = a->CtrlRoutine;
    ProcessHandleRecord->PropRoutine = a->PropRoutine;
    ASSERT (!(Console->Flags & CONSOLE_SHUTTING_DOWN));
    AddProcessToList(Console, ProcessHandleRecord, CONSOLE_CLIENTPROCESSHANDLE());
    SetProcessForegroundRights(Process, Console->Flags & CONSOLE_HAS_FOCUS);
    AllocateCommandHistory(Console,
                           a->AppNameLength,
                           a->AppName,
                           CONSOLE_CLIENTPROCESSHANDLE());

    UnlockConsole(Console);

    return STATUS_SUCCESS;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvFreeConsole(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_FREE_MSG a = (PCONSOLE_FREE_MSG)&m->u.ApiMessageData;
    PCONSOLE_PER_PROCESS_DATA ProcessData;
    NTSTATUS Status;

    ProcessData = CONSOLE_PERPROCESSDATA();
    ASSERT (CONSOLE_GETCONSOLEAPPFROMPROCESSDATA(ProcessData));

    if (CONSOLE_GETCONSOLEHANDLEFROMPROCESSDATA(ProcessData) != a->ConsoleHandle) {
        RIPMSG1(RIP_WARNING, "SrvFreeConsole: invalid console handle %x", a->ConsoleHandle);
        return STATUS_INVALID_HANDLE;
    }

    Status = RemoveConsole(ProcessData,
            CONSOLE_CLIENTPROCESSHANDLE(),
            CONSOLE_CLIENTPROCESSID());

    if (NT_SUCCESS(Status)) {
        CONSOLE_SETCONSOLEAPP(FALSE);
    }

    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

ULONG
SrvAttachConsole(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_ATTACH_MSG a = (PCONSOLE_ATTACH_MSG)&m->u.ApiMessageData;
    DWORD ProcessId;
    NTSTATUS Status;
    PCSR_PROCESS ParentProcess;
    PCSR_PROCESS Process;
    CLIENT_ID ClientId;
    OBJECT_ATTRIBUTES Obja;
    HANDLE ProcessHandle;
    PCONSOLE_INFORMATION Console;
    PCONSOLE_PER_PROCESS_DATA ProcessData;
    PCONSOLE_PER_PROCESS_DATA ParentProcessData;
    PCONSOLE_PROCESS_HANDLE ProcessHandleRecord;

    Process = (PCSR_PROCESS)(CSR_SERVER_QUERYCLIENTTHREAD()->Process);

    //
    // Make sure we have a valid buffer
    //

    if (!CsrValidateMessageBuffer(m, &a->ConsoleInfo, sizeof(*a->ConsoleInfo), sizeof(BYTE))) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Make sure we're not already attached to a console
    //

    ProcessData = CONSOLE_FROMPROCESSPERPROCESSDATA(Process);
    if (CONSOLE_GETCONSOLEAPPFROMPROCESSDATA(ProcessData)) {
        return STATUS_ACCESS_DENIED;
    }

    //
    // Figure out what process we're attaching to.
    //

    if (a->ProcessId == (DWORD)-1) {
        ProcessId = ProcessData->ParentProcessId;
    } else {
        ProcessId = a->ProcessId;
    }

    //
    // Lock the process we're attaching to so it can't go away.
    //

    Status = CsrLockProcessByClientId(LongToHandle(ProcessId), &ParentProcess);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Make sure we have access to the process.
    //

    if (!CsrImpersonateClient(NULL)) {
        CsrUnlockProcess(ParentProcess);
        return STATUS_BAD_IMPERSONATION_LEVEL;
    }

    ClientId.UniqueThread = NULL;
    ClientId.UniqueProcess = UlongToHandle(ProcessId);

    InitializeObjectAttributes(
        &Obja,
        NULL,
        0,
        NULL,
        NULL
        );

    Status = NtOpenProcess(
                &ProcessHandle,
                PROCESS_ALL_ACCESS,
                &Obja,
                &ClientId
                );

    CsrRevertToSelf();

    if (!NT_SUCCESS(Status)) {
        CsrUnlockProcess(ParentProcess);
        return Status;
    }
    NtClose(ProcessHandle);

    //
    // Add current process to parent process's console.
    //

    Process->Flags |= CSR_PROCESS_CONSOLEAPP;
    ParentProcessData = CONSOLE_FROMPROCESSPERPROCESSDATA(ParentProcess);
    *ProcessData = *ParentProcessData;
    Status = ConsoleAddProcessRoutine(ParentProcess, Process);
    if (NT_SUCCESS(Status)) {
        CONSOLE_SETCONSOLEAPP(TRUE);
        Status = RevalidateConsole(ProcessData->ConsoleHandle, &Console);
    }

    CsrUnlockProcess(ParentProcess);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Initialize per process console settings.
    //


    Status = MapEventHandles(CONSOLE_CLIENTPROCESSHANDLE(),
                             Console,
                             a->ConsoleInfo
                            );
    if (!NT_SUCCESS(Status)) {
        CONSOLE_SETCONSOLEAPPFROMPROCESSDATA(ProcessData, FALSE);
        UnlockConsole(Console);
        RemoveConsole(ProcessData, Process->ProcessHandle, 0);
        return Status;
    }

    NtCurrentPeb()->ProcessParameters->ConsoleHandle =
        a->ConsoleInfo->ConsoleHandle = ProcessData->ConsoleHandle;
    a->ConsoleInfo->StdIn  = INDEX_TO_HANDLE(0);
    a->ConsoleInfo->StdOut = INDEX_TO_HANDLE(1);
    a->ConsoleInfo->StdErr = INDEX_TO_HANDLE(2);

    ProcessHandleRecord = FindProcessInList(Console, CONSOLE_CLIENTPROCESSHANDLE());
    if (ProcessHandleRecord) {
        ProcessHandleRecord->CtrlRoutine = a->CtrlRoutine;
        ProcessHandleRecord->PropRoutine = a->PropRoutine;
    }
    SetProcessForegroundRights(Process,
                               Console->Flags & CONSOLE_HAS_FOCUS);

    UnlockConsole(Console);

    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}

NTSTATUS
MyRegOpenKey(
    IN HANDLE hKey,
    IN LPWSTR lpSubKey,
    OUT PHANDLE phResult
    )
{
    OBJECT_ATTRIBUTES   Obja;
    UNICODE_STRING      SubKey;

    //
    // Convert the subkey to a counted Unicode string.
    //

    RtlInitUnicodeString( &SubKey, lpSubKey );

    //
    // Initialize the OBJECT_ATTRIBUTES structure and open the key.
    //

    InitializeObjectAttributes(
        &Obja,
        &SubKey,
        OBJ_CASE_INSENSITIVE,
        hKey,
        NULL
        );

    return NtOpenKey(
              phResult,
              KEY_READ,
              &Obja
              );
}

NTSTATUS
MyRegQueryValue(
    IN HANDLE hKey,
    IN LPWSTR lpValueName,
    IN DWORD dwValueLength,
    OUT LPBYTE lpData
    )
{
    UNICODE_STRING ValueName;
    ULONG BufferLength;
    ULONG ResultLength;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    NTSTATUS Status;

    //
    // Convert the subkey to a counted Unicode string.
    //

    RtlInitUnicodeString( &ValueName, lpValueName );

    BufferLength = FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data) + dwValueLength;
    KeyValueInformation = ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ), BufferLength);
    if (KeyValueInformation == NULL)
        return STATUS_NO_MEMORY;

    Status = NtQueryValueKey(
                hKey,
                &ValueName,
                KeyValuePartialInformation,
                KeyValueInformation,
                BufferLength,
                &ResultLength
                );
    if (NT_SUCCESS(Status)) {
        ASSERT(KeyValueInformation->DataLength <= dwValueLength);
        RtlCopyMemory(lpData,
            KeyValueInformation->Data,
            KeyValueInformation->DataLength);
        if (KeyValueInformation->Type == REG_SZ ||
            KeyValueInformation->Type == REG_MULTI_SZ
           ) {
            if (KeyValueInformation->DataLength + sizeof(WCHAR) > dwValueLength) {
                KeyValueInformation->DataLength -= sizeof(WCHAR);
            }
            lpData[KeyValueInformation->DataLength++] = 0;
            lpData[KeyValueInformation->DataLength] = 0;
        }
    }
    ConsoleHeapFree(KeyValueInformation);
    return Status;
}

#if defined(FE_SB)
NTSTATUS
MyRegQueryValueEx(
    IN HANDLE hKey,
    IN LPWSTR lpValueName,
    IN DWORD dwValueLength,
    OUT LPBYTE lpData,
    OUT LPDWORD lpDataLength
    )
{
    UNICODE_STRING ValueName;
    ULONG BufferLength;
    ULONG ResultLength;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    NTSTATUS Status;

    //
    // Convert the subkey to a counted Unicode string.
    //

    RtlInitUnicodeString( &ValueName, lpValueName );

    BufferLength = FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data) + dwValueLength;
    KeyValueInformation = ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ), BufferLength);
    if (KeyValueInformation == NULL)
        return STATUS_NO_MEMORY;

    Status = NtQueryValueKey(
                hKey,
                &ValueName,
                KeyValuePartialInformation,
                KeyValueInformation,
                BufferLength,
                &ResultLength
                );
    if (NT_SUCCESS(Status)) {
        ASSERT(KeyValueInformation->DataLength <= dwValueLength);
        RtlCopyMemory(lpData,
            KeyValueInformation->Data,
            KeyValueInformation->DataLength);
        if (lpDataLength)
        {
            *lpDataLength = KeyValueInformation->DataLength;
        }
    }
    ConsoleHeapFree(KeyValueInformation);
    return Status;
}

NTSTATUS
MyRegEnumValue(
    IN HANDLE hKey,
    IN DWORD dwIndex,
    OUT DWORD dwValueLength,
    OUT LPWSTR lpValueName,
    OUT DWORD dwDataLength,
    OUT LPBYTE lpData
    )
{
    ULONG BufferLength;
    ULONG ResultLength;
    PKEY_VALUE_FULL_INFORMATION KeyValueInformation;
    NTSTATUS Status;

    //
    // Convert the subkey to a counted Unicode string.
    //

    BufferLength = sizeof(KEY_VALUE_FULL_INFORMATION) + dwValueLength + dwDataLength;
    KeyValueInformation = ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ), BufferLength);
    if (KeyValueInformation == NULL)
        return STATUS_NO_MEMORY;

    Status = NtEnumerateValueKey(
                hKey,
                dwIndex,
                KeyValueFullInformation,
                KeyValueInformation,
                BufferLength,
                &ResultLength
                );
    if (NT_SUCCESS(Status)) {
        ASSERT(KeyValueInformation->NameLength <= dwValueLength);
        RtlMoveMemory(lpValueName,
                      KeyValueInformation->Name,
                      KeyValueInformation->NameLength);
        lpValueName[ KeyValueInformation->NameLength >> 1 ] = UNICODE_NULL;


        ASSERT(KeyValueInformation->DataLength <= dwDataLength);
        RtlMoveMemory(lpData,
            (PBYTE)KeyValueInformation + KeyValueInformation->DataOffset,
            KeyValueInformation->DataLength);
        if (KeyValueInformation->Type == REG_SZ) {
            if (KeyValueInformation->DataLength + sizeof(WCHAR) > dwDataLength) {
                KeyValueInformation->DataLength -= sizeof(WCHAR);
            }
            lpData[KeyValueInformation->DataLength++] = 0;
            lpData[KeyValueInformation->DataLength] = 0;
        }
    }
    ConsoleHeapFree(KeyValueInformation);
    return Status;
}
#endif

#define SYSTEM_ROOT         (L"%SystemRoot%")
#define SYSTEM_ROOT_LENGTH  (sizeof(SYSTEM_ROOT) - sizeof(WCHAR))

LPWSTR
TranslateConsoleTitle(
    LPWSTR ConsoleTitle,
    PUSHORT pcbTranslatedTitle,
    BOOL Unexpand,
    BOOL Substitute
    )
/*++

Routine Description:

    This routine translates path characters into '_' characters because
    the NT registry apis do not allow the creation of keys with
    names that contain path characters. It also converts absolute paths
    into %SystemRoot% relative ones. As an example, if both behaviors were
    specified it would convert a title like C:\WINNT\System32\cmd.exe to
    %SystemRoot%_System32_cmd.exe.

Arguments:

    ConsoleTitle - Pointer to string to translate.

    pcbTranslatedTitle - On return, contains size of translated title.

    Unexpand - Convert absolute path to %SystemRoot% relative one.

    Substitute - Replace '\' with '_' in path.

Return Value:

    Pointer to translated title or NULL.

Note:

    This routine allocates a buffer that must be freed.

--*/
{
    USHORT cbConsoleTitle, i;
    USHORT cbSystemRoot;
    LPWSTR TranslatedConsoleTitle, Tmp;

    cbConsoleTitle = (USHORT)((lstrlenW(ConsoleTitle) + 1) * sizeof(WCHAR));
    cbSystemRoot = (USHORT)(lstrlenW(USER_SHARED_DATA->NtSystemRoot) * sizeof(WCHAR));

    if (Unexpand && !MyStringCompareW(ConsoleTitle,
                                      USER_SHARED_DATA->NtSystemRoot,
                                      cbSystemRoot,
                                      TRUE)) {
        cbConsoleTitle -= cbSystemRoot;
        (PBYTE)ConsoleTitle += cbSystemRoot;
        cbSystemRoot = SYSTEM_ROOT_LENGTH;
    } else {
        cbSystemRoot = 0;
    }

    Tmp = TranslatedConsoleTitle = ConsoleHeapAlloc(MAKE_TAG( TITLE_TAG ), cbSystemRoot + cbConsoleTitle);
    if (TranslatedConsoleTitle == NULL) {
        return NULL;
    }

    RtlCopyMemory(TranslatedConsoleTitle, SYSTEM_ROOT, cbSystemRoot);
    (PBYTE)TranslatedConsoleTitle += cbSystemRoot;

    for (i=0;i<cbConsoleTitle;i+=sizeof(WCHAR)) {
        if (Substitute && *ConsoleTitle == '\\') {
            *TranslatedConsoleTitle++ = (WCHAR)'_';
        } else {
            *TranslatedConsoleTitle++ = *ConsoleTitle;
        }
        ConsoleTitle++;
    }

    if (pcbTranslatedTitle) {
        *pcbTranslatedTitle = cbSystemRoot + cbConsoleTitle;
    }

    return Tmp;
}


ULONG
ConsoleClientShutdown(
    PCSR_PROCESS Process,
    ULONG Flags,
    BOOLEAN fFirstPass
    )
{
    PCONSOLE_INFORMATION Console;
    PCONSOLE_PER_PROCESS_DATA ProcessData;
    NTSTATUS Status;
    HWND hWnd;
    HANDLE TerminationEvent;
    HANDLE ConsoleHandle;
    NTSTATUS WaitStatus;
    USERTHREAD_USEDESKTOPINFO utudi;

    //
    // Find the console associated with this process
    //

    ProcessData = CONSOLE_FROMPROCESSPERPROCESSDATA(Process);

    //
    // If this process is not a console app, stop right here unless
    // this is the second pass of shutdown, in which case we'll take
    // it.
    //

    if (!ProcessData || !CONSOLE_GETCONSOLEAPPFROMPROCESSDATA(ProcessData)) {
#if defined(FE_IME)
        if (fFirstPass &&
            (ProcessData->ConsoleHandle == NULL) &&
            (ProcessData->hDesk != NULL))
        {
            //
            // If this process is a Console IME,
            // should unregister console IME on this desktop.
            //
            RemoveConsoleIME(Process, HandleToUlong(Process->ClientId.UniqueThread));
        }
#endif
        if (fFirstPass) {
            return SHUTDOWN_UNKNOWN_PROCESS;
        }
        return NonConsoleProcessShutdown(Process, Flags);
    }

    //
    // Find the console structure pointer.
    //

    ConsoleHandle = CONSOLE_GETCONSOLEHANDLEFROMPROCESSDATA(ProcessData);
    Status = RevalidateConsole(
            ConsoleHandle,
            &Console);

    if (!NT_SUCCESS(Status)) {
        return SHUTDOWN_UNKNOWN_PROCESS;
        }

    //
    // If this is the invisible WOW console, return UNKNOWN so USER
    // enumerates 16-bit gui apps.
    //

    if ((Console->Flags & CONSOLE_NO_WINDOW) &&
        (Console->Flags & CONSOLE_WOW_REGISTERED)) {
        UnlockConsole(Console);
        return SHUTDOWN_UNKNOWN_PROCESS;
        }

    //
    // Sometimes the console structure is around even though the
    // hWnd has been NULLed out. In this case, go to non-console
    // process shutdown.
    //

    hWnd = Console->hWnd;
    if (hWnd == NULL || !IsWindow(hWnd)) {
        UnlockConsole(Console);
        return NonConsoleProcessShutdown(Process, Flags);
        }

    //
    // Make a copy of the console termination event
    //

    Status = NtDuplicateObject(NtCurrentProcess(),
                               Console->TerminationEvent,
                               NtCurrentProcess(),
                               &TerminationEvent,
                               0,
                               FALSE,
                               DUPLICATE_SAME_ACCESS
                               );
    if (!NT_SUCCESS(Status)) {
        UnlockConsole(Console);
        return NonConsoleProcessShutdown(Process, Flags);
    }

    //
    // Attach to the desktop.
    //

    utudi.hThread = Console->InputThreadInfo->ThreadHandle;
    utudi.drdRestore.pdeskRestore = NULL;
    Status = NtUserSetInformationThread(NtCurrentThread(),
                                        UserThreadUseDesktop,
                                        &utudi,
                                        sizeof(utudi));

    UnlockConsole(Console);
    if (!NT_SUCCESS(Status)) {
        return NonConsoleProcessShutdown(Process, Flags);
    }

    //
    // We're done looking at this process structure, so dereference it.
    //
    CsrDereferenceProcess(Process);

    //
    // Synchronously talk to this console.
    //

    Status = ShutdownConsole(ConsoleHandle, Flags);

    //
    // Detach from the desktop.
    //

    utudi.hThread = NULL;
    NtUserSetInformationThread(NtCurrentThread(),
                               UserThreadUseDesktop,
                               &utudi,
                               sizeof(utudi));

    //
    // If Status == STATUS_PROCESS_IS_TERMINATING, then we should wait
    // for the console to exit.
    //

    if (Status == STATUS_PROCESS_IS_TERMINATING) {
        WaitStatus = InternalWaitCancel(TerminationEvent, 500000);
        if (WaitStatus == STATUS_WAIT_1) {
            Status = SHUTDOWN_CANCEL;
        } else if (WaitStatus != STATUS_TIMEOUT) {
            Status = SHUTDOWN_KNOWN_PROCESS;
        } else {
#if DBG
            PLIST_ENTRY ListHead, ListNext;
            PCONSOLE_PROCESS_HANDLE ProcessHandleRecord;
            PCSR_PROCESS Process;

            RIPMSG0(RIP_ERROR | RIP_THERESMORE, "********************************************");
            RIPMSG1(RIP_ERROR | RIP_THERESMORE, "Shutdown wait timed out on console %p", Console);
            RIPMSG1(RIP_ERROR | RIP_THERESMORE, "Reference count is %d", Console->RefCount);
            RIPMSG0(RIP_ERROR | RIP_THERESMORE, "Dump these processes and see if they're hung");
            ListHead = &Console->ProcessHandleList;
            ListNext = ListHead->Flink;
            while (ListNext != ListHead) {
                ProcessHandleRecord = CONTAINING_RECORD(ListNext, CONSOLE_PROCESS_HANDLE, ListLink);
                Process = ProcessHandleRecord->Process;
                RIPMSG2(RIP_ERROR | RIP_THERESMORE, "CsrProcess = %p ProcessId = %x", Process, Process->ClientId.UniqueProcess);
                ListNext = ListNext->Flink;
            }
            RIPMSG0(RIP_ERROR, "********************************************");
#endif
            Status = SHUTDOWN_CANCEL;
        }
    }
    NtClose(TerminationEvent);

    return Status;
}

ULONG
NonConsoleProcessShutdown(
    PCSR_PROCESS Process,
    DWORD dwFlags
    )
{
    CONSOLE_PROCESS_TERMINATION_RECORD TerminateRecord;
    DWORD EventType;
    BOOL Success;
    HANDLE ProcessHandle;

    Success = DuplicateHandle(NtCurrentProcess(),
            Process->ProcessHandle,
            NtCurrentProcess(),
            &ProcessHandle,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS);

    if (!Success)
        ProcessHandle = Process->ProcessHandle;

    TerminateRecord.ProcessHandle = ProcessHandle;
    TerminateRecord.TerminateCount = 0;
    TerminateRecord.CtrlRoutine = CtrlRoutine;

    CsrDereferenceProcess(Process);

    EventType = CTRL_LOGOFF_EVENT;
    if (dwFlags & EWX_SHUTDOWN)
        EventType = CTRL_SHUTDOWN_EVENT;

    CreateCtrlThread(&TerminateRecord,
            1,
            NULL,
            EventType,
            TRUE);

    if (Success)
        CloseHandle(ProcessHandle);

    return SHUTDOWN_KNOWN_PROCESS;
}

VOID
InitializeConsoleAttributes( VOID )

/*++

Routine Description:

    This routine initializes default attributes from the current
    user's registry values. It gets called during logon/logoff.

Arguments:

    none

Return Value:

    none

--*/

{
    //
    // Store default values in structure and mark it
    // as invalid (by resetting LastWriteTime).
    //

    DefaultRegInfo.ScreenFill.Attributes = 0x07;            // white on black
    DefaultRegInfo.ScreenFill.Char.UnicodeChar = (WCHAR)' ';
    DefaultRegInfo.PopupFill.Attributes = 0xf5;             // purple on white
    DefaultRegInfo.PopupFill.Char.UnicodeChar = (WCHAR)' ';
    DefaultRegInfo.InsertMode = FALSE;
    DefaultRegInfo.QuickEdit = FALSE;
    DefaultRegInfo.AutoPosition = TRUE;
    DefaultRegInfo.FullScreen = FALSE;
    DefaultRegInfo.ScreenBufferSize.X = 80;
    DefaultRegInfo.ScreenBufferSize.Y = 25;
    DefaultRegInfo.WindowSize.X = 80;
    DefaultRegInfo.WindowSize.Y = 25;
    DefaultRegInfo.WindowOrigin.X = 0;
    DefaultRegInfo.WindowOrigin.Y = 0;
    DefaultRegInfo.FontSize.X = 0;
    DefaultRegInfo.FontSize.Y = 0;
    DefaultRegInfo.FontFamily = 0;
    DefaultRegInfo.FontWeight = 0;
    DefaultRegInfo.FaceName[0] = L'\0';
    DefaultRegInfo.CursorSize = CURSOR_SMALL_SIZE;
    DefaultRegInfo.HistoryBufferSize = DEFAULT_NUMBER_OF_COMMANDS;
    DefaultRegInfo.NumberOfHistoryBuffers = DEFAULT_NUMBER_OF_BUFFERS;
    DefaultRegInfo.HistoryNoDup = FALSE;
    DefaultRegInfo.ColorTable[ 0] = RGB(0,   0,   0   );
    DefaultRegInfo.ColorTable[ 1] = RGB(0,   0,   0x80);
    DefaultRegInfo.ColorTable[ 2] = RGB(0,   0x80,0   );
    DefaultRegInfo.ColorTable[ 3] = RGB(0,   0x80,0x80);
    DefaultRegInfo.ColorTable[ 4] = RGB(0x80,0,   0   );
    DefaultRegInfo.ColorTable[ 5] = RGB(0x80,0,   0x80);
    DefaultRegInfo.ColorTable[ 6] = RGB(0x80,0x80,0   );
    DefaultRegInfo.ColorTable[ 7] = RGB(0xC0,0xC0,0xC0);
    DefaultRegInfo.ColorTable[ 8] = RGB(0x80,0x80,0x80);
    DefaultRegInfo.ColorTable[ 9] = RGB(0,   0,   0xFF);
    DefaultRegInfo.ColorTable[10] = RGB(0,   0xFF,0   );
    DefaultRegInfo.ColorTable[11] = RGB(0,   0xFF,0xFF);
    DefaultRegInfo.ColorTable[12] = RGB(0xFF,0,   0   );
    DefaultRegInfo.ColorTable[13] = RGB(0xFF,0,   0xFF);
    DefaultRegInfo.ColorTable[14] = RGB(0xFF,0xFF,0   );
    DefaultRegInfo.ColorTable[15] = RGB(0xFF,0xFF,0xFF);
#if defined(FE_SB) // scotthsu
    DefaultRegInfo.CodePage = OEMCP;
#endif
    DefaultRegInfo.LastWriteTime = 0;

    //
    // Get system metrics for this user
    //

    InitializeSystemMetrics();
}


VOID
GetRegistryValues(
    IN LPWSTR ConsoleTitle,
    OUT PCONSOLE_REGISTRY_INFO RegInfo
    )

/*++

Routine Description:

    This routine reads in values from the registry and places them
    in the supplied structure.

Arguments:

    ConsoleTitle - name of subkey to open

    RegInfo - pointer to structure to receive information

Return Value:

    none

--*/

{
    HANDLE hCurrentUserKey;
    HANDLE hConsoleKey;
    HANDLE hTitleKey;
    NTSTATUS Status;
    LPWSTR TranslatedConsoleTitle;
    DWORD dwValue;
    DWORD i;
    WCHAR awchFaceName[LF_FACESIZE];
    WCHAR awchBuffer[64];
    KEY_BASIC_INFORMATION KeyInfo;
    ULONG ResultLength;

    //
    // Impersonate the client process
    //

    if (!CsrImpersonateClient(NULL)) {
        KdPrint(("CONSRV: GetRegistryValues Impersonate failed\n"));
        return;
    }

    //
    // Open the current user registry key
    //

    Status = RtlOpenCurrentUser(MAXIMUM_ALLOWED, &hCurrentUserKey);
    if (!NT_SUCCESS(Status)) {
        CsrRevertToSelf();
        return;
    }

    //
    // Open the console registry key
    //

    Status = MyRegOpenKey(hCurrentUserKey,
                          CONSOLE_REGISTRY_STRING,
                          &hConsoleKey);
    if (!NT_SUCCESS(Status)) {
        NtClose(hCurrentUserKey);
        CsrRevertToSelf();
        return;
    }

    //
    // If we're not reading the default key, check if the default values
    // need to be updated
    //

    Status = NtQueryKey(hConsoleKey,
                        KeyBasicInformation,
                        &KeyInfo,
                        sizeof(KeyInfo),
                        &ResultLength);
    if (!NT_ERROR(Status)) {
        if (DefaultRegInfo.LastWriteTime != KeyInfo.LastWriteTime.QuadPart) {
            DefaultRegInfo.LastWriteTime = KeyInfo.LastWriteTime.QuadPart;
            if (RegInfo != &DefaultRegInfo) {
                GetRegistryValues(L"", &DefaultRegInfo);
                *RegInfo = DefaultRegInfo;
            }
        }
    }

    //
    // Open the console title subkey
    //

    TranslatedConsoleTitle = TranslateConsoleTitle(ConsoleTitle, NULL, TRUE, TRUE);
    if (TranslatedConsoleTitle == NULL) {
        NtClose(hConsoleKey);
        NtClose(hCurrentUserKey);
        CsrRevertToSelf();
        return;
    }
    Status = MyRegOpenKey(hConsoleKey,
                         TranslatedConsoleTitle,
                         &hTitleKey);
    ConsoleHeapFree(TranslatedConsoleTitle);
    if (!NT_SUCCESS(Status)) {
        TranslatedConsoleTitle = TranslateConsoleTitle(ConsoleTitle, NULL, FALSE, TRUE);
        if (TranslatedConsoleTitle) {
            Status = MyRegOpenKey(hConsoleKey,
                                 TranslatedConsoleTitle,
                                 &hTitleKey);
            ConsoleHeapFree(TranslatedConsoleTitle);
        }
    }
    if (!NT_SUCCESS(Status)) {
        NtClose(hConsoleKey);
        NtClose(hCurrentUserKey);
        CsrRevertToSelf();
        return;
    }

    //
    // Initial screen fill
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_FILLATTR,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        RegInfo->ScreenFill.Attributes = (WORD)dwValue;
    }

    //
    // Initial popup fill
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_POPUPATTR,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        RegInfo->PopupFill.Attributes = (WORD)dwValue;
    }

    //
    // Initial insert mode
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_INSERTMODE,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        RegInfo->InsertMode = !!dwValue;
    }

    //
    // Initial quick edit mode
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_QUICKEDIT,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        RegInfo->QuickEdit = !!dwValue;
    }

#ifdef i386
    //
    // Initial full screen mode
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_FULLSCR,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        RegInfo->FullScreen = !!dwValue;
    }
#endif

#if defined(FE_SB) // scotthsu
    //
    // Code Page
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_CODEPAGE,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        RegInfo->CodePage = (UINT)dwValue;

        // If this routine specified default settings for console property,
        // then make sure code page value when Fae East environment.
        // If code page value does not the same to OEMCP and any FE's code page then
        // we are override code page value to OEMCP on default console property.
        // Because, Far East environment has limitation that doesn not switch to
        // another FE's code page by the SetConsoleCP/SetConsoleOutputCP.
        //
        // Compare of ConsoleTitle and L"" has limit to default property of console.
        // It means, this code doesn't care user defined property.
        // Content of user defined property has responsibility to themselves.

        if (wcscmp(ConsoleTitle, L"") == 0 &&
             IsAvailableFarEastCodePage(RegInfo->CodePage) &&
             OEMCP != RegInfo->CodePage) {
            RegInfo->CodePage = OEMCP;
        }
    }
#endif // FE_SB

    //
    // Initial screen buffer size
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_BUFFERSIZE,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        RegInfo->ScreenBufferSize.X = LOWORD(dwValue);
        RegInfo->ScreenBufferSize.Y = HIWORD(dwValue);
        if (RegInfo->ScreenBufferSize.X <= 0)
            RegInfo->ScreenBufferSize.X = 1;
        if (RegInfo->ScreenBufferSize.Y <= 0)
            RegInfo->ScreenBufferSize.Y = 1;
    }

    //
    // Initial window size
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_WINDOWSIZE,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        RegInfo->WindowSize.X = LOWORD(dwValue);
        RegInfo->WindowSize.Y = HIWORD(dwValue);
        if (RegInfo->WindowSize.X <= 0)
            RegInfo->WindowSize.X = 1;
        else if (RegInfo->WindowSize.X > RegInfo->ScreenBufferSize.X)
            RegInfo->WindowSize.X = RegInfo->ScreenBufferSize.X;
        if (RegInfo->WindowSize.Y <= 0)
            RegInfo->WindowSize.Y = 1;
        else if (RegInfo->WindowSize.Y > RegInfo->ScreenBufferSize.Y)
            RegInfo->WindowSize.Y = RegInfo->ScreenBufferSize.Y;
    }

    //
    // Initial window position
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_WINDOWPOS,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        RegInfo->WindowOrigin.X = LOWORD(dwValue);
        RegInfo->WindowOrigin.Y = HIWORD(dwValue);
        RegInfo->AutoPosition = FALSE;
    }

    //
    // Initial font size
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_FONTSIZE,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        RegInfo->FontSize.X = LOWORD(dwValue);
        RegInfo->FontSize.Y = HIWORD(dwValue);
    }

    //
    // Initial font family
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_FONTFAMILY,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        RegInfo->FontFamily = dwValue;
    }

    //
    // Initial font weight
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_FONTWEIGHT,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        RegInfo->FontWeight = dwValue;
    }

    //
    // Initial font face name
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_FACENAME,
                       sizeof(awchFaceName), (PBYTE)awchFaceName))) {
        RtlCopyMemory(RegInfo->FaceName, awchFaceName, sizeof(awchFaceName));
        RegInfo->FaceName[NELEM(RegInfo->FaceName) - 1] = 0;
    }

    //
    // Initial cursor size
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_CURSORSIZE,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        RegInfo->CursorSize = dwValue;
    }

    //
    // Initial history buffer size
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_HISTORYSIZE,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        RegInfo->HistoryBufferSize = dwValue;
    }

    //
    // Initial number of history buffers
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_HISTORYBUFS,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        RegInfo->NumberOfHistoryBuffers = dwValue;
    }

    //
    // Initial history duplication mode
    //

    if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                       CONSOLE_REGISTRY_HISTORYNODUP,
                       sizeof(dwValue), (PBYTE)&dwValue))) {
        RegInfo->HistoryNoDup = dwValue;
    }

    for (i=0; i<16; i++) {
        wsprintf(awchBuffer, CONSOLE_REGISTRY_COLORTABLE, i);
        if (NT_SUCCESS(MyRegQueryValue(hTitleKey, awchBuffer,
                           sizeof(dwValue), (PBYTE)&dwValue))) {
            RegInfo->ColorTable[ i ] = dwValue;
        }
    }

    if (RegInfo == &DefaultRegInfo) {
        //
        // If the common (default) setting has been changed,
        //

        //
        // Get registry for conime flag
        //
        if (NT_SUCCESS(MyRegQueryValue(hConsoleKey, CONSOLE_REGISTRY_LOAD_CONIME, sizeof dwValue, (PBYTE)&dwValue))) {
            gfLoadConIme = (dwValue != 0);
        } else {
            gfLoadConIme = TRUE;
        }

        //
        // get extended edit mode and keys from registry.
        //
        if (NT_SUCCESS(MyRegQueryValue(hConsoleKey,
                CONSOLE_REGISTRY_EXTENDEDEDITKEY,
                sizeof dwValue,
                (PBYTE)&dwValue)) &&
                dwValue <= 1) {

            ExtKeyDefBuf buf;

            gExtendedEditKey = dwValue;

            //
            // Initialize Extended Edit keys
            //
            InitExtendedEditKeys(NULL);

            if (NT_SUCCESS(MyRegQueryValue(hConsoleKey,
                        CONSOLE_REGISTRY_EXTENDEDEDITKEY_CUSTOM,
                        sizeof buf,
                        (PBYTE)&buf))) {
                InitExtendedEditKeys(&buf);
            }
    #if DBG
            else {
                DbgPrint("Error reading ExtendedEditkeyCustom.\n");
            }
    #endif
        }
        else {
            gExtendedEditKey = 0;
            DBGPRINT(("Error reading ExtendedEditkey.\n"));
        }

        //
        // Word delimiters
        //
        if (gExtendedEditKey) {
            // If extended edit key is given, provide extended word delimiters
            // by default.
            memcpy((LPBYTE)gaWordDelimChars, (LPBYTE)gaWordDelimCharsDefault,
                    sizeof gaWordDelimChars[0] * WORD_DELIM_MAX);
        } else {
            // Otherwise, stick to the original word delimiter.
            gaWordDelimChars[0] = L'\0';
        }

        // Read word delimiters from registry
        if (NT_SUCCESS(MyRegQueryValue(hConsoleKey,
                    CONSOLE_REGISTRY_WORD_DELIM,
                    sizeof awchBuffer,
                    (PBYTE)awchBuffer))) {
            // OK, copy it to the word delimiter array.
            wcsncpy(gaWordDelimChars, awchBuffer, WORD_DELIM_MAX);
            gaWordDelimChars[WORD_DELIM_MAX - 1] = 0;
        }

        //
        // Read Trim Zero Heading flag
        //
        if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                           CONSOLE_REGISTRY_TRIMZEROHEADINGS,
                           sizeof(dwValue), (PBYTE)&dwValue))) {
            gfTrimLeadingZeros = dwValue;
        } else {
            gfTrimLeadingZeros = FALSE;
        }

        //
        // Color selected area function enable flag
        //

        if (NT_SUCCESS(MyRegQueryValue(hTitleKey,
                           CONSOLE_REGISTRY_ENABLE_COLOR_SELECTION,
                           sizeof(dwValue), (PBYTE)&dwValue))) {

            gfEnableColorSelection = !!dwValue;
        }
        else {
            gfEnableColorSelection = FALSE;
        }
    }

    //
    // Close the registry keys
    //

    NtClose(hTitleKey);
    NtClose(hConsoleKey);
    NtClose(hCurrentUserKey);
    CsrRevertToSelf();
}

NTSTATUS
GetConsoleLangId(
    IN UINT OutputCP,
    OUT LANGID* pLangId
    )
{
    NTSTATUS Status;

    if (CONSOLE_IS_DBCS_ENABLED()){
        if (pLangId != NULL) {
            switch (OutputCP) {
                case 932:
                    *pLangId = MAKELANGID(LANG_JAPANESE, SUBLANG_DEFAULT);
                    break;
                case 949:
                    *pLangId = MAKELANGID(LANG_KOREAN, SUBLANG_KOREAN);
                    break;
                case 936:
                    *pLangId = MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_SIMPLIFIED);
                    break;
                case 950:
                    *pLangId = MAKELANGID(LANG_CHINESE, SUBLANG_CHINESE_TRADITIONAL);
                    break;
                default:
                    *pLangId = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
                    break;
            }
        }
        Status = STATUS_SUCCESS;
    }
    else {
        Status = STATUS_NOT_SUPPORTED;
    }

    return Status;
}

ULONG
SrvGetConsoleLangId(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus
    )
{
    PCONSOLE_LANGID_MSG a = (PCONSOLE_LANGID_MSG)&m->u.ApiMessageData;
    NTSTATUS Status;
    PCONSOLE_INFORMATION Console;

    Status = ApiPreamble(a->ConsoleHandle,
                         &Console
                        );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    Status = GetConsoleLangId(Console->OutputCP, &a->LangId);

    UnlockConsole(Console);
    return Status;
    UNREFERENCED_PARAMETER(ReplyStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\server\daytona\makefile.inc ===
#****************************** File Header ******************************\
# File Name: makefile.inc
#
# Copyright (c) 1985-96, Microsoft Corporation
#
# Project specific MAKEFILE.INC
#
# History:
# 09-Dec-96 BradG           Created
#***************************************************************************/
!include ..\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\server\_output.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    _output.h

Abstract:

    Performance critical routine for Single Binary

    Each function will be created with two flavors FE and non FE

Author:

    KazuM Jun.11.1997

Revision History:

--*/

#define WWSB_NEUTRAL_FILE 1

#if !defined(FE_SB)
#error This header file should be included with FE_SB
#endif

#if !defined(WWSB_FE) && !defined(WWSB_NOFE)
#error Either WWSB_FE and WWSB_NOFE must be defined.
#endif

#if defined(WWSB_FE) && defined(WWSB_NOFE)
#error Both WWSB_FE and WWSB_NOFE defined.
#endif

#include "dispatch.h"

#if defined(WWSB_FE)
#pragma alloc_text(FE_TEXT, FE_StreamWriteToScreenBuffer)
#pragma alloc_text(FE_TEXT, FE_WriteRectToScreenBuffer)
#pragma alloc_text(FE_TEXT, FE_WriteRegionToScreen)
#pragma alloc_text(FE_TEXT, FE_WriteToScreen)
#pragma alloc_text(FE_TEXT, FE_WriteOutputString)
#pragma alloc_text(FE_TEXT, FE_FillOutput)
#pragma alloc_text(FE_TEXT, FE_FillRectangle)
#pragma alloc_text(FE_TEXT, FE_PolyTextOutCandidate)
#pragma alloc_text(FE_TEXT, FE_ConsolePolyTextOut)
#endif


#if defined(WWSB_NOFE)
VOID
SB_StreamWriteToScreenBuffer(
    IN PWCHAR String,
    IN SHORT StringLength,
    IN PSCREEN_INFORMATION ScreenInfo
    )
#else
VOID
FE_StreamWriteToScreenBuffer(
    IN PWCHAR String,
    IN SHORT StringLength,
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PCHAR StringA
    )
#endif
{
    SHORT RowIndex;
    PROW Row;
    PWCHAR Char;
    COORD TargetPoint;

    DBGOUTPUT(("StreamWriteToScreenBuffer\n"));
#ifdef WWSB_FE
    ASSERT(ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER);
#endif
    ScreenInfo->BufferInfo.TextInfo.Flags |= TEXT_VALID_HINT;
    TargetPoint = ScreenInfo->BufferInfo.TextInfo.CursorPosition;
    RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+TargetPoint.Y) % ScreenInfo->ScreenBufferSize.Y;
    Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
    DBGOUTPUT(("RowIndex = %x, Row = %x, TargetPoint = (%x,%x)\n",
            RowIndex, Row, TargetPoint.X, TargetPoint.Y));

    //
    // copy chars
    //
#ifdef WWSB_FE
    BisectWrite(StringLength,TargetPoint,ScreenInfo);
    if (TargetPoint.Y == ScreenInfo->ScreenBufferSize.Y-1 &&
        TargetPoint.X+StringLength >= ScreenInfo->ScreenBufferSize.X &&
        *(StringA+ScreenInfo->ScreenBufferSize.X-TargetPoint.X-1) & ATTR_LEADING_BYTE
       ) {
        *(String+ScreenInfo->ScreenBufferSize.X-TargetPoint.X-1) = UNICODE_SPACE;
        *(StringA+ScreenInfo->ScreenBufferSize.X-TargetPoint.X-1) = 0;
        if (StringLength > ScreenInfo->ScreenBufferSize.X-TargetPoint.X-1) {
            *(String+ScreenInfo->ScreenBufferSize.X-TargetPoint.X) = UNICODE_SPACE;
            *(StringA+ScreenInfo->ScreenBufferSize.X-TargetPoint.X) = 0;
        }
    }

    RtlCopyMemory(&Row->CharRow.KAttrs[TargetPoint.X],StringA,StringLength*sizeof(CHAR));
#endif

    RtlCopyMemory(&Row->CharRow.Chars[TargetPoint.X],String,StringLength*sizeof(WCHAR));

    // recalculate first and last non-space char

    Row->CharRow.OldLeft = Row->CharRow.Left;
    if (TargetPoint.X < Row->CharRow.Left) {
        PWCHAR LastChar = &Row->CharRow.Chars[ScreenInfo->ScreenBufferSize.X];

        for (Char=&Row->CharRow.Chars[TargetPoint.X];Char < LastChar && *Char==(WCHAR)' ';Char++)
            ;
        Row->CharRow.Left = (SHORT)(Char-Row->CharRow.Chars);
    }

    Row->CharRow.OldRight = Row->CharRow.Right;
    if ((TargetPoint.X+StringLength) >= Row->CharRow.Right) {
        PWCHAR FirstChar = Row->CharRow.Chars;

        for (Char=&Row->CharRow.Chars[TargetPoint.X+StringLength-1];*Char==(WCHAR)' ' && Char >= FirstChar;Char--)
            ;
        Row->CharRow.Right = (SHORT)(Char+1-FirstChar);
    }

    //
    // see if attr string is different.  if so, allocate a new
    // attr buffer and merge the two strings.
    //

    if (Row->AttrRow.Length != 1 ||
        Row->AttrRow.Attrs->Attr != ScreenInfo->Attributes) {
        PATTR_PAIR NewAttrs;
        WORD NewAttrsLength;
        ATTR_PAIR Attrs;

        Attrs.Length = StringLength;
        Attrs.Attr = ScreenInfo->Attributes;
        if (!NT_SUCCESS(MergeAttrStrings(Row->AttrRow.Attrs,
                         Row->AttrRow.Length,
                         &Attrs,
                         1,
                         &NewAttrs,
                         &NewAttrsLength,
                         TargetPoint.X,
                         (SHORT)(TargetPoint.X+StringLength-1),
                         Row,
                         ScreenInfo
                        ))) {
            return;
        }
        if (Row->AttrRow.Length > 1) {
            ConsoleHeapFree(Row->AttrRow.Attrs);
        }
        else {
            ASSERT(Row->AttrRow.Attrs == &Row->AttrRow.AttrPair);
        }
        Row->AttrRow.Attrs = NewAttrs;
        Row->AttrRow.Length = NewAttrsLength;
        Row->CharRow.OldLeft = INVALID_OLD_LENGTH;
        Row->CharRow.OldRight = INVALID_OLD_LENGTH;
    }
    ResetTextFlags(ScreenInfo,
                   TargetPoint.X,
                   TargetPoint.Y,
                   TargetPoint.X + StringLength - 1,
                   TargetPoint.Y);
}


#define CHAR_OF_PCI(p)  (((PCHAR_INFO)(p))->Char.AsciiChar)
#define WCHAR_OF_PCI(p) (((PCHAR_INFO)(p))->Char.UnicodeChar)
#define ATTR_OF_PCI(p)  (((PCHAR_INFO)(p))->Attributes)
#define SIZEOF_CI_CELL  sizeof(CHAR_INFO)

#define CHAR_OF_VGA(p)  (p[0])
#define ATTR_OF_VGA(p)  (p[1])
#ifdef i386
#define SIZEOF_VGA_CELL 2
#else // risc
#define SIZEOF_VGA_CELL 4
#endif


#define COMMON_LVB_MASK        0x33
#define ATTR_OF_COMMON_LVB(p)  (ATTR_OF_VGA(p) + (((p[2] & ~COMMON_LVB_MASK)) << 8))
#define SIZEOF_COMMON_LVB_CELL 4

VOID
WWSB_WriteRectToScreenBuffer(
    PBYTE Source,
    COORD SourceSize,
    PSMALL_RECT SourceRect,
    PSCREEN_INFORMATION ScreenInfo,
    COORD TargetPoint,
    IN UINT Codepage
    )

/*++

Routine Description:

    This routine copies a rectangular region to the screen buffer.
    no clipping is done.

    The source should contain Unicode or UnicodeOem chars.

Arguments:

    Source - pointer to source buffer (a real VGA buffer or CHAR_INFO[])

    SourceSize - dimensions of source buffer

    SourceRect - rectangle in source buffer to copy

    ScreenInfo - pointer to screen info

    TargetPoint - upper left coordinates of target rectangle

    Codepage - codepage to translate real VGA buffer from,
               0xFFFFFFF if Source is CHAR_INFO[] (not requiring translation)
Return Value:

    none.

--*/

{

    PBYTE SourcePtr;
    SHORT i,j;
    SHORT XSize,YSize;
    BOOLEAN WholeSource;
    SHORT RowIndex;
    PROW Row;
    PWCHAR Char;
    ATTR_PAIR Attrs[80];
    PATTR_PAIR AttrBuf;
    PATTR_PAIR Attr;
    SHORT AttrLength;
    BOOL bVGABuffer;
    ULONG ulCellSize;
#ifdef WWSB_FE
    PCHAR AttrP;
#endif

    DBGOUTPUT(("WriteRectToScreenBuffer\n"));
#ifdef WWSB_FE
    ASSERT(ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER);
#endif

    ScreenInfo->BufferInfo.TextInfo.Flags |= TEXT_VALID_HINT;
    XSize = (SHORT)(SourceRect->Right - SourceRect->Left + 1);
    YSize = (SHORT)(SourceRect->Bottom - SourceRect->Top + 1);


    AttrBuf = Attrs;
    if (XSize > 80) {
        AttrBuf = (PATTR_PAIR)ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ),XSize * sizeof(ATTR_PAIR));
        if (AttrBuf == NULL)
            return;
    }

    bVGABuffer = (Codepage != 0xFFFFFFFF);
    if (bVGABuffer) {
#ifdef WWSB_FE
        ulCellSize = (ScreenInfo->Console->fVDMVideoMode) ? SIZEOF_COMMON_LVB_CELL : SIZEOF_VGA_CELL;
#else
        ulCellSize = SIZEOF_VGA_CELL;
#endif
    } else {
        ulCellSize = SIZEOF_CI_CELL;
    }

    SourcePtr = Source;

    WholeSource = FALSE;
    if (XSize == SourceSize.X) {
        ASSERT (SourceRect->Left == 0);
        if (SourceRect->Top != 0) {
            SourcePtr += SCREEN_BUFFER_POINTER(SourceRect->Left,
                                               SourceRect->Top,
                                               SourceSize.X,
                                               ulCellSize);
        }
        WholeSource = TRUE;
    }
    RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+TargetPoint.Y) % ScreenInfo->ScreenBufferSize.Y;
    for (i=0;i<YSize;i++) {
        if (!WholeSource) {
            SourcePtr = Source + SCREEN_BUFFER_POINTER(SourceRect->Left,
                                                       SourceRect->Top+i,
                                                       SourceSize.X,
                                                       ulCellSize);
        }

        //
        // copy the chars and attrs into their respective arrays
        //

#ifdef WWSB_FE
        if (! bVGABuffer) {
            COORD TPoint;

            TPoint.X = TargetPoint.X;
            TPoint.Y = TargetPoint.Y + i;
            BisectWrite(XSize,TPoint,ScreenInfo);
            if (TPoint.Y == ScreenInfo->ScreenBufferSize.Y-1 &&
                TPoint.X+XSize-1 >= ScreenInfo->ScreenBufferSize.X &&
                ATTR_OF_PCI(SourcePtr+ScreenInfo->ScreenBufferSize.X-TPoint.X-1) & COMMON_LVB_LEADING_BYTE)
            {
                WCHAR_OF_PCI(SourcePtr+ScreenInfo->ScreenBufferSize.X-TPoint.X-1) = UNICODE_SPACE;
                ATTR_OF_PCI(SourcePtr+ScreenInfo->ScreenBufferSize.X-TPoint.X-1) &= ~COMMON_LVB_SBCSDBCS;
                if (XSize-1 > ScreenInfo->ScreenBufferSize.X-TPoint.X-1) {
                    WCHAR_OF_PCI(SourcePtr+ScreenInfo->ScreenBufferSize.X-TPoint.X) = UNICODE_SPACE;
                    ATTR_OF_PCI(SourcePtr+ScreenInfo->ScreenBufferSize.X-TPoint.X) &= ~COMMON_LVB_SBCSDBCS;
                }
            }
        }
#endif

        Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
        Char = &Row->CharRow.Chars[TargetPoint.X];
#ifdef WWSB_FE
        AttrP = &Row->CharRow.KAttrs[TargetPoint.X];
#endif
        Attr = AttrBuf;
        Attr->Length = 0;
        AttrLength = 1;

        /*
         * Two version of the following loop to keep it fast:
         * one for VGA buffers, one for CHAR_INFO buffers.
         */
        if (bVGABuffer) {
#ifdef WWSB_FE
            Attr->Attr = (ScreenInfo->Console->fVDMVideoMode) ? ATTR_OF_COMMON_LVB(SourcePtr) : ATTR_OF_VGA(SourcePtr);
#else
            Attr->Attr = ATTR_OF_VGA(SourcePtr);
#endif
            for (j = SourceRect->Left;
                    j <= SourceRect->Right;
                    j++,
#ifdef WWSB_FE
                    SourcePtr += (ScreenInfo->Console->fVDMVideoMode) ? SIZEOF_COMMON_LVB_CELL : SIZEOF_VGA_CELL
#else
                    SourcePtr += SIZEOF_VGA_CELL
#endif
                ) {

#ifdef WWSB_FE
                UCHAR TmpBuff[2];

                if (IsDBCSLeadByteConsole(CHAR_OF_VGA(SourcePtr),&ScreenInfo->Console->OutputCPInfo)) {
                    if (j+1 > SourceRect->Right) {
                        *Char = UNICODE_SPACE;
                        *AttrP = 0;
                    }
                    else {
                        TmpBuff[0] = CHAR_OF_VGA(SourcePtr);
                        TmpBuff[1] = CHAR_OF_VGA((SourcePtr + ((ScreenInfo->Console->fVDMVideoMode) ? SIZEOF_COMMON_LVB_CELL : SIZEOF_VGA_CELL)));
                        ConvertOutputToUnicode(Codepage,
                                               TmpBuff,
                                               2,
                                               Char,
                                               2);
                        Char++;
                        j++;
                        *AttrP++ = ATTR_LEADING_BYTE;
                        *Char++ = *(Char-1);
                        *AttrP++ = ATTR_TRAILING_BYTE;

                        if (ScreenInfo->Console->fVDMVideoMode) {
                            if (Attr->Attr == ATTR_OF_COMMON_LVB(SourcePtr)) {
                                Attr->Length += 1;
                            }
                            else {
                                Attr++;
                                Attr->Length = 1;
                                Attr->Attr = ATTR_OF_COMMON_LVB(SourcePtr);
                                AttrLength += 1;
                            }
                        }
                        else
                        {
                            if (Attr->Attr == ATTR_OF_VGA(SourcePtr)) {
                                Attr->Length += 1;
                            }
                            else {
                                Attr++;
                                Attr->Length = 1;
                                Attr->Attr = ATTR_OF_VGA(SourcePtr);
                                AttrLength += 1;
                            }
                        }

                        SourcePtr += (ScreenInfo->Console->fVDMVideoMode) ? SIZEOF_COMMON_LVB_CELL : SIZEOF_VGA_CELL;
                    }
                }
                else {
                    ConvertOutputToUnicode(Codepage,
                                           &CHAR_OF_VGA(SourcePtr),
                                           1,
                                           Char,
                                           1);
                    Char++;
                    *AttrP++ = 0;
                }
#else
                *Char++ = SB_CharToWcharGlyph(Codepage, CHAR_OF_VGA(SourcePtr));
#endif

#ifdef WWSB_FE
                if (ScreenInfo->Console->fVDMVideoMode) {
                    if (Attr->Attr == ATTR_OF_COMMON_LVB(SourcePtr)) {
                        Attr->Length += 1;
                    }
                    else {
                        Attr++;
                        Attr->Length = 1;
                        Attr->Attr = ATTR_OF_COMMON_LVB(SourcePtr);
                        AttrLength += 1;
                    }
                }
                else
#endif
                if (Attr->Attr == ATTR_OF_VGA(SourcePtr)) {
                    Attr->Length += 1;
                }
                else {
                    Attr++;
                    Attr->Length = 1;
                    Attr->Attr = ATTR_OF_VGA(SourcePtr);
                    AttrLength += 1;
                }
            }
        } else {
#ifdef WWSB_FE
            Attr->Attr = ATTR_OF_PCI(SourcePtr) & ~COMMON_LVB_SBCSDBCS;
#else
            Attr->Attr = ATTR_OF_PCI(SourcePtr);
#endif
            for (j = SourceRect->Left;
                    j <= SourceRect->Right;
                    j++, SourcePtr += SIZEOF_CI_CELL) {

                *Char++ = WCHAR_OF_PCI(SourcePtr);
#ifdef WWSB_FE
                // MSKK Apr.02.1993 V-HirotS For KAttr
                *AttrP++ = (CHAR)((ATTR_OF_PCI(SourcePtr) & COMMON_LVB_SBCSDBCS) >>8);
#endif

#ifdef WWSB_FE
                if (Attr->Attr == (ATTR_OF_PCI(SourcePtr) & ~COMMON_LVB_SBCSDBCS))
#else
                if (Attr->Attr == ATTR_OF_PCI(SourcePtr))
#endif
                {
                    Attr->Length += 1;
                }
                else {
                    Attr++;
                    Attr->Length = 1;
#ifdef WWSB_FE
                    // MSKK Apr.02.1993 V-HirotS For KAttr
                    Attr->Attr = ATTR_OF_PCI(SourcePtr) & ~COMMON_LVB_SBCSDBCS;
#else
                    Attr->Attr = ATTR_OF_PCI(SourcePtr);
#endif
                    AttrLength += 1;
                }
            }
        }

        // recalculate first and last non-space char

        Row->CharRow.OldLeft = Row->CharRow.Left;
        if (TargetPoint.X < Row->CharRow.Left) {
            PWCHAR LastChar = &Row->CharRow.Chars[ScreenInfo->ScreenBufferSize.X];

            for (Char=&Row->CharRow.Chars[TargetPoint.X];Char < LastChar && *Char==(WCHAR)' ';Char++)
                ;
            Row->CharRow.Left = (SHORT)(Char-Row->CharRow.Chars);
        }

        Row->CharRow.OldRight = Row->CharRow.Right;
        if ((TargetPoint.X+XSize) >= Row->CharRow.Right) {
            SHORT LastNonSpace;
            PWCHAR FirstChar = Row->CharRow.Chars;

            LastNonSpace = (SHORT)(TargetPoint.X+XSize-1);
            for (Char=&Row->CharRow.Chars[(TargetPoint.X+XSize-1)];*Char==(WCHAR)' ' && Char >= FirstChar;Char--)
                LastNonSpace--;

            //
            // if the attributes change after the last non-space, make the
            // index of the last attribute change + 1 the length.  otherwise
            // make the length one more than the last non-space.
            //

            Row->CharRow.Right = (SHORT)(LastNonSpace+1);
        }

        //
        // see if attr string is different.  if so, allocate a new
        // attr buffer and merge the two strings.
        //


        if (AttrLength != Row->AttrRow.Length ||
            memcmp(Row->AttrRow.Attrs,AttrBuf,AttrLength*sizeof(*Attr))) {
            PATTR_PAIR NewAttrs;
            WORD NewAttrsLength;

            if (!NT_SUCCESS(MergeAttrStrings(Row->AttrRow.Attrs,
                             Row->AttrRow.Length,
                             AttrBuf,
                             AttrLength,
                             &NewAttrs,
                             &NewAttrsLength,
                             TargetPoint.X,
                             (SHORT)(TargetPoint.X+XSize-1),
                             Row,
                             ScreenInfo
                            ))) {
                if (XSize > 80) {
                    ConsoleHeapFree(AttrBuf);
                }
                ResetTextFlags(ScreenInfo,
                               TargetPoint.X,
                               TargetPoint.Y,
                               (SHORT)(TargetPoint.X + XSize - 1),
                               (SHORT)(TargetPoint.Y + YSize - 1));
                return;
            }
            if (Row->AttrRow.Length > 1) {
                ConsoleHeapFree(Row->AttrRow.Attrs);
            }
            else {
                ASSERT(Row->AttrRow.Attrs == &Row->AttrRow.AttrPair);
            }
            Row->AttrRow.Attrs = NewAttrs;
            Row->AttrRow.Length = NewAttrsLength;
            Row->CharRow.OldLeft = INVALID_OLD_LENGTH;
            Row->CharRow.OldRight = INVALID_OLD_LENGTH;
        }
        if (++RowIndex == ScreenInfo->ScreenBufferSize.Y) {
            RowIndex = 0;
        }
    }
    ResetTextFlags(ScreenInfo,
                   TargetPoint.X,
                   TargetPoint.Y,
                   (SHORT)(TargetPoint.X + XSize - 1),
                   (SHORT)(TargetPoint.Y + YSize - 1));

    if (XSize > 80) {
        ConsoleHeapFree(AttrBuf);
    }
}

VOID
WWSB_WriteRegionToScreen(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT Region
    )
{
    COORD Window;
    int i,j;
    PATTR_PAIR Attr;
    RECT TextRect;
    SHORT RowIndex;
    SHORT CountOfAttr;
    PROW Row;
    BOOL OneLine, SimpleWrite;  // one line && one attribute per line
    PCONSOLE_INFORMATION Console = ScreenInfo->Console;
    PWCHAR TransBufferCharacter = NULL ;
#ifdef WWSB_FE
    BOOL  DoubleColorDbcs;
    SHORT CountOfAttrOriginal;
    SHORT RegionRight;
    BOOL  LocalEUDCFlag;
    SMALL_RECT CaTextRect;
    PCONVERSIONAREA_INFORMATION ConvAreaInfo = ScreenInfo->ConvScreenInfo;
#endif

    DBGOUTPUT(("WriteRegionToScreen\n"));

#ifdef WWSB_FE
    if (ConvAreaInfo) {
        CaTextRect.Left = Region->Left - ScreenInfo->Console->CurrentScreenBuffer->Window.Left - ConvAreaInfo->CaInfo.coordConView.X;
        CaTextRect.Right = CaTextRect.Left + (Region->Right - Region->Left);
        CaTextRect.Top   = Region->Top - ScreenInfo->Console->CurrentScreenBuffer->Window.Top - ConvAreaInfo->CaInfo.coordConView.Y;
        CaTextRect.Bottom = CaTextRect.Top + (Region->Bottom - Region->Top);
    }

    if (Region->Left && (ScreenInfo->BisectFlag & BISECT_LEFT)) {
        Region->Left--;
    }
    if (Region->Right+1 < ScreenInfo->ScreenBufferSize.X && (ScreenInfo->BisectFlag & BISECT_RIGHT)) {
        Region->Right++;
    }
    ScreenInfo->BisectFlag &= ~(BISECT_LEFT | BISECT_RIGHT);
    Console->ConsoleIme.ScrollWaitCountDown = Console->ConsoleIme.ScrollWaitTimeout;
#endif

    if (Console->FullScreenFlags == 0) {

        //
        // if we have a selection, turn it off.
        //

        InvertSelection(Console, TRUE);

        ASSERT(ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER);
        if (WWSB_PolyTextOutCandidate(ScreenInfo,Region)) {
            WWSB_ConsolePolyTextOut(ScreenInfo,Region);
        }
        else {

#ifdef WWSB_FE
            if (ConvAreaInfo) {
                Window.Y = Region->Top - Console->CurrentScreenBuffer->Window.Top;
                Window.X = Region->Left - Console->CurrentScreenBuffer->Window.Left;
            }
            else {
#endif
                Window.Y = Region->Top - ScreenInfo->Window.Top;
                Window.X = Region->Left - ScreenInfo->Window.Left;
#ifdef WWSB_FE
            }
#endif

#ifdef WWSB_FE
            RowIndex = (ConvAreaInfo ? CaTextRect.Top :
                                       (ScreenInfo->BufferInfo.TextInfo.FirstRow+Region->Top) % ScreenInfo->ScreenBufferSize.Y
                       );
            RegionRight = Region->Right;
#else
            RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+Region->Top) % ScreenInfo->ScreenBufferSize.Y;
#endif
            OneLine = (Region->Top==Region->Bottom);

            TransBufferCharacter = (PWCHAR)ConsoleHeapAlloc(
                                                     MAKE_TAG( TMP_DBCS_TAG ),
                                                     (ScreenInfo->ScreenBufferSize.X*sizeof(WCHAR))+sizeof(WCHAR));
            if (TransBufferCharacter == NULL)
            {
                KdPrint(("CONSRV: WriteRegionToScreen cannot allocate memory\n"));
                return ;
            }

            for (i=Region->Top;i<=Region->Bottom;i++,Window.Y++) {
#ifdef WWSB_FE
                DoubleColorDbcs = FALSE;
                Region->Right = RegionRight;
#endif

                //
                // copy the chars and attrs from their respective arrays
                //

                Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];

                if (Row->AttrRow.Length == 1) {
                    Attr = Row->AttrRow.Attrs;
                    CountOfAttr = ScreenInfo->ScreenBufferSize.X;
                    SimpleWrite = TRUE;
                } else {
                    SimpleWrite = FALSE;
                    FindAttrIndex(Row->AttrRow.Attrs,
#ifdef WWSB_FE
                                  (SHORT)(ConvAreaInfo ? CaTextRect.Left : Region->Left),
#else
                                  Region->Left,
#endif
                                  &Attr,
                                  &CountOfAttr
                                 );
                }
                if (Console->LastAttributes != Attr->Attr) {
                    TEXTCOLOR_CALL;
#ifdef WWSB_FE
                    if (Attr->Attr & COMMON_LVB_REVERSE_VIDEO)
                    {
                        SetBkColor(Console->hDC, ConvertAttrToRGB(Console, LOBYTE(Attr->Attr)));
                        SetTextColor(Console->hDC, ConvertAttrToRGB(Console, LOBYTE(Attr->Attr >> 4)));
                    }
                    else{
#endif
                        SetTextColor(Console->hDC, ConvertAttrToRGB(Console, LOBYTE(Attr->Attr)));
                        SetBkColor(Console->hDC, ConvertAttrToRGB(Console, LOBYTE(Attr->Attr >> 4)));
#ifdef WWSB_FE
                    }
#endif
                    Console->LastAttributes = Attr->Attr;
                }
                TextRect.top = Window.Y*SCR_FONTSIZE(ScreenInfo).Y;
                TextRect.bottom = TextRect.top + SCR_FONTSIZE(ScreenInfo).Y;
                for (j=Region->Left;j<=Region->Right;) {
                    SHORT NumberOfChars;
                    int TextLeft;
                    SHORT LeftChar,RightChar;

                    if (CountOfAttr > (SHORT)(Region->Right - j + 1)) {
                        CountOfAttr = (SHORT)(Region->Right - j + 1);
                    }

#ifdef WWSB_FE
                    CountOfAttrOriginal = CountOfAttr;


                    LocalEUDCFlag = FALSE;
                    if((ScreenInfo->Console->Flags & CONSOLE_VDM_REGISTERED &&
                        ((PEUDC_INFORMATION)(ScreenInfo->Console->EudcInformation))->LocalVDMEudcMode)){
                        LocalEUDCFlag = CheckEudcRangeInString(
                                            Console,
                                            &Row->CharRow.Chars[ConvAreaInfo ?
                                                                CaTextRect.Left + (j-Region->Left) : j],
                                            CountOfAttr,
                                            &CountOfAttr);
                    }
                    if (!(ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) &&
                        !(ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN) &&
                        ((PEUDC_INFORMATION)(ScreenInfo->Console->EudcInformation))->LocalKeisenEudcMode
                       ) {
                        SHORT k;
                        PWCHAR Char2;
                        Char2 = &Row->CharRow.Chars[ConvAreaInfo ? CaTextRect.Left + (j-Region->Left) : j];
                        for ( k = 0 ; k < CountOfAttr ; k++,Char2++){
                            if (*Char2 < UNICODE_SPACE){
                                CountOfAttr = k ;
                                LocalEUDCFlag = TRUE;
                                break;
                            }
                        }
                    }
#endif

                    //
                    // make the bounding rect smaller, if we can.  the TEXT_VALID_HINT
                    // flag gets set each time we write to the screen buffer.  it gets
                    // turned off any time we get asked to redraw the screen
                    // and we don't know exactly what needs to be redrawn
                    // (i.e. paint messages).
                    //
                    // we have the left and right bounds of the text on the
                    // line.  the opaqueing rectangle and the number of
                    // chars get set according to those values.
                    //
                    // if there's more than one attr per line (!SimpleWrite)
                    // we bail on the opaqueing rect.
                    //

                    if (ScreenInfo->BufferInfo.TextInfo.Flags & TEXT_VALID_HINT && SimpleWrite) {
                        if (Row->CharRow.OldLeft != INVALID_OLD_LENGTH) {
                            TextRect.left = (max(min(Row->CharRow.Left,Row->CharRow.OldLeft),j)-ScreenInfo->Window.Left) *
                                            SCR_FONTSIZE(ScreenInfo).X;
                        } else {
                            TextRect.left = Window.X*SCR_FONTSIZE(ScreenInfo).X;
                        }

                        if (Row->CharRow.OldRight != INVALID_OLD_LENGTH) {
                            TextRect.right = (min(max(Row->CharRow.Right,Row->CharRow.OldRight),j+CountOfAttr)-ScreenInfo->Window.Left) *
                                             SCR_FONTSIZE(ScreenInfo).X;
                        } else {
                            TextRect.right = TextRect.left + CountOfAttr*SCR_FONTSIZE(ScreenInfo).X;
                        }
                        LeftChar = max(Row->CharRow.Left,j);
                        RightChar = min(Row->CharRow.Right,j+CountOfAttr);
                        NumberOfChars = RightChar - LeftChar;
                        TextLeft = (LeftChar-ScreenInfo->Window.Left)*SCR_FONTSIZE(ScreenInfo).X;
                    } else {
#ifdef WWSB_FE
                        LeftChar = ConvAreaInfo ? CaTextRect.Left + (j-Region->Left) : j;
#else
                        LeftChar = (SHORT)j;
#endif
                        TextRect.left = Window.X*SCR_FONTSIZE(ScreenInfo).X;
                        TextRect.right = TextRect.left + CountOfAttr*SCR_FONTSIZE(ScreenInfo).X;
#ifdef WWSB_FE
                        if (ConvAreaInfo)
                            NumberOfChars = (Row->CharRow.Right > (SHORT)((CaTextRect.Left+(j-Region->Left)) + CountOfAttr)) ?
                                (CountOfAttr) : (SHORT)(Row->CharRow.Right-(CaTextRect.Left+(j-Region->Left)));
                        else
#endif
                            NumberOfChars = (Row->CharRow.Right > (SHORT)(j + CountOfAttr)) ? (CountOfAttr) : (SHORT)(Row->CharRow.Right-j);
                        TextLeft = TextRect.left;
                    }

                    if (NumberOfChars < 0)
                    {
                        NumberOfChars = 0;
#ifdef WWSB_FE
                        TextRect.left = Window.X*SCR_FONTSIZE(ScreenInfo).X;
                        TextRect.right = TextRect.left + CountOfAttr*SCR_FONTSIZE(ScreenInfo).X;
#endif
                    }
                    TEXTOUT_CALL;
#ifdef WWSB_FE
                    /*
                     * Text out everything (i.e. SBCS/DBCS, Common LVB attribute, Local EUDC)
                     */
                    TextOutEverything(Console,
                                      ScreenInfo,
                                      (SHORT)j,
                                      &Region->Right,
                                      &CountOfAttr,
                                      CountOfAttrOriginal,
                                      &DoubleColorDbcs,
                                      LocalEUDCFlag,
                                      Row,
                                      Attr,
                                      LeftChar,
                                      RightChar,
                                      TextLeft,
                                      TextRect,
                                      NumberOfChars);
#else
                    NumberOfChars =
                        (SHORT)RemoveDbcsMarkAll(ScreenInfo,
                                                 Row,
                                                 &LeftChar,
                                                 &TextRect,
                                                 &TextLeft,
                                                 TransBufferCharacter,
                                                 NumberOfChars);
                    ExtTextOutW(Console->hDC,
                               TextLeft,
                               TextRect.top,
                               ETO_OPAQUE,
                               &TextRect,
                               TransBufferCharacter,
                               NumberOfChars,
                               NULL
                              );
#endif
                    if (OneLine && SimpleWrite) {
                        break;
                    }
                    j+=CountOfAttr;
                    if (j <= Region->Right) {
                        Window.X += CountOfAttr;
#ifdef WWSB_FE
                        if (CountOfAttr < CountOfAttrOriginal){
                            CountOfAttr = CountOfAttrOriginal - CountOfAttr;
                        }
                        else {
#endif
                            Attr++;
                            CountOfAttr = Attr->Length;
#ifdef WWSB_FE
                        }
#endif
#ifdef WWSB_FE
                        if (Attr->Attr & COMMON_LVB_REVERSE_VIDEO)
                        {
                            SetBkColor(Console->hDC, ConvertAttrToRGB(Console, LOBYTE(Attr->Attr)));
                            SetTextColor(Console->hDC, ConvertAttrToRGB(Console, LOBYTE(Attr->Attr >> 4)));
                        }
                        else{
#endif
                            SetTextColor(Console->hDC, ConvertAttrToRGB(Console, LOBYTE(Attr->Attr)));
                            SetBkColor(Console->hDC, ConvertAttrToRGB(Console, LOBYTE(Attr->Attr >> 4)));
#ifdef WWSB_FE
                        }
#endif
                        Console->LastAttributes = Attr->Attr;
                    }
                }
                Window.X = Region->Left - ScreenInfo->Window.Left;
                if (++RowIndex == ScreenInfo->ScreenBufferSize.Y) {
                    RowIndex = 0;
                }
            }
            GdiFlush();
            ConsoleHeapFree(TransBufferCharacter);
        }

        //
        // if we have a selection, turn it on.
        //

        InvertSelection(Console, FALSE);
    }
#ifdef i386
    else if (Console->FullScreenFlags & CONSOLE_FULLSCREEN_HARDWARE) {
#ifdef WWSB_FE
        if (! ScreenInfo->ConvScreenInfo) {
            if (ScreenInfo->Console->CurrentScreenBuffer == ScreenInfo) {
                WWSB_WriteRegionToScreenHW(ScreenInfo,Region);
            }
        }
        else if (ScreenInfo->Console->CurrentScreenBuffer->Flags & CONSOLE_TEXTMODE_BUFFER)
#endif
            WWSB_WriteRegionToScreenHW(ScreenInfo,Region);
    }
#endif

#ifdef WWSB_FE
    {
        SMALL_RECT TmpRegion;

        if (ScreenInfo->BisectFlag & BISECT_TOP) {
            ScreenInfo->BisectFlag &= ~BISECT_TOP;
            if (Region->Top) {
                TmpRegion.Top = Region->Top-1;
                TmpRegion.Bottom = Region->Top-1;
                TmpRegion.Left = ScreenInfo->ScreenBufferSize.X-1;
                TmpRegion.Right = ScreenInfo->ScreenBufferSize.X-1;
                WWSB_WriteRegionToScreen(ScreenInfo,&TmpRegion);
            }
        }
        if (ScreenInfo->BisectFlag & BISECT_BOTTOM) {
            ScreenInfo->BisectFlag &= ~BISECT_BOTTOM;
            if (Region->Bottom+1 < ScreenInfo->ScreenBufferSize.Y) {
                TmpRegion.Top = Region->Bottom+1;
                TmpRegion.Bottom = Region->Bottom+1;
                TmpRegion.Left = 0;
                TmpRegion.Right = 0;
                WWSB_WriteRegionToScreen(ScreenInfo,&TmpRegion);
            }
        }
    }
#endif
}

VOID
WWSB_WriteToScreen(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT Region
    )
/*++

Routine Description:

    This routine writes a screen buffer region to the screen.

Arguments:

    ScreenInfo - Pointer to screen buffer information.

    Region - Region to write in screen buffer coordinates.  Region is
    inclusive

Return Value:

    none.

--*/

{
    SMALL_RECT ClippedRegion;

    DBGOUTPUT(("WriteToScreen\n"));
    //
    // update to screen, if we're not iconic.  we're marked as
    // iconic if we're fullscreen, so check for fullscreen.
    //

    if (!ACTIVE_SCREEN_BUFFER(ScreenInfo) ||
        (ScreenInfo->Console->Flags & (CONSOLE_IS_ICONIC | CONSOLE_NO_WINDOW) &&
         ScreenInfo->Console->FullScreenFlags == 0)) {
        return;
    }

    // clip region

    ClippedRegion.Left = max(Region->Left, ScreenInfo->Window.Left);
    ClippedRegion.Top = max(Region->Top, ScreenInfo->Window.Top);
    ClippedRegion.Right = min(Region->Right, ScreenInfo->Window.Right);
    ClippedRegion.Bottom = min(Region->Bottom, ScreenInfo->Window.Bottom);
    if (ClippedRegion.Right < ClippedRegion.Left ||
        ClippedRegion.Bottom < ClippedRegion.Top) {
        return;
    }

    if (ScreenInfo->Flags & CONSOLE_GRAPHICS_BUFFER) {
        if (ScreenInfo->Console->FullScreenFlags == 0) {
            WriteRegionToScreenBitMap(ScreenInfo, &ClippedRegion);
        }
    } else {
        ConsoleHideCursor(ScreenInfo);
        WWSB_WriteRegionToScreen(ScreenInfo, &ClippedRegion);
#ifdef WWSB_FE
        if (!(ScreenInfo->Console->ConsoleIme.ScrollFlag & HIDE_FOR_SCROLL))
        {
            PCONVERSIONAREA_INFORMATION ConvAreaInfo;

            if (! ScreenInfo->Console->CurrentScreenBuffer->ConvScreenInfo) {
                WriteConvRegionToScreen(ScreenInfo,
                                        ScreenInfo->Console->ConsoleIme.ConvAreaRoot,
                                        Region);
            }
            else if (ConvAreaInfo = ScreenInfo->Console->ConsoleIme.ConvAreaRoot) {
                do {
                    if (ConvAreaInfo->ScreenBuffer == ScreenInfo)
                        break;
                } while (ConvAreaInfo = ConvAreaInfo->ConvAreaNext);
                if (ConvAreaInfo) {
                    WriteConvRegionToScreen(ScreenInfo,
                                            ConvAreaInfo->ConvAreaNext,
                                            Region);
                }
            }
        }
#endif
        ConsoleShowCursor(ScreenInfo);
    }
}

NTSTATUS
WWSB_WriteOutputString(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PVOID Buffer,
    IN COORD WriteCoord,
    IN ULONG StringType,
    IN OUT PULONG NumRecords, // this value is valid even for error cases
    OUT PULONG NumColumns OPTIONAL
    )

/*++

Routine Description:

    This routine writes a string of characters or attributes to the
    screen buffer.

Arguments:

    ScreenInfo - Pointer to screen buffer information.

    Buffer - Buffer to write from.

    WriteCoord - Screen buffer coordinate to begin writing to.

    StringType
      One of the following:
        CONSOLE_ASCII          - write a string of ascii characters.
        CONSOLE_REAL_UNICODE   - write a string of real unicode characters.
        CONSOLE_FALSE_UNICODE  - write a string of false unicode characters.
        CONSOLE_ATTRIBUTE      - write a string of attributes.

    NumRecords - On input, the number of elements to write.  On output,
    the number of elements written.

    NumColumns - receives the number of columns output, which could be more
                 than NumRecords (FE fullwidth chars)
Return Value:


--*/

{
    ULONG NumWritten;
    SHORT X,Y,LeftX;
    SMALL_RECT WriteRegion;
    PROW Row;
    PWCHAR Char;
    SHORT RowIndex;
    SHORT j;
    PWCHAR TransBuffer;
#ifdef WWSB_NOFE
    WCHAR SingleChar;
#endif
    UINT Codepage;
#ifdef WWSB_FE
    PBYTE AttrP;
    PBYTE TransBufferA;
    PBYTE BufferA;
    ULONG NumRecordsSavedForUnicode;
    BOOL  fLocalHeap = FALSE;
#endif

    DBGOUTPUT(("WriteOutputString\n"));
#ifdef WWSB_FE
    ASSERT(ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER);
#endif

    if (*NumRecords == 0)
        return STATUS_SUCCESS;

    NumWritten = 0;
    X=WriteCoord.X;
    Y=WriteCoord.Y;
    if (X>=ScreenInfo->ScreenBufferSize.X ||
        X<0 ||
        Y>=ScreenInfo->ScreenBufferSize.Y ||
        Y<0) {
        *NumRecords = 0;
        return STATUS_SUCCESS;
    }

    ScreenInfo->BufferInfo.TextInfo.Flags |= TEXT_VALID_HINT;
    RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+WriteCoord.Y) % ScreenInfo->ScreenBufferSize.Y;

    if (StringType == CONSOLE_ASCII) {
#ifdef WWSB_FE
        PCHAR TmpBuf;
        PWCHAR TmpTrans;
        ULONG i;
        PCHAR TmpTransA;
#endif

        if ((ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) &&
            !(ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN)) {
            if (ScreenInfo->Console->OutputCP != WINDOWSCP)
                Codepage = USACP;
            else
                Codepage = WINDOWSCP;
        } else {
            Codepage = ScreenInfo->Console->OutputCP;
        }

#ifdef WWSB_FE
        if (*NumRecords > (ULONG)(ScreenInfo->ScreenBufferSize.X * ScreenInfo->ScreenBufferSize.Y)) {

            TransBuffer = ConsoleHeapAlloc(MAKE_TAG( TMP_DBCS_TAG ),*NumRecords * 2 * sizeof(WCHAR));
            if (TransBuffer == NULL) {
                return STATUS_NO_MEMORY;
            }
            TransBufferA = ConsoleHeapAlloc(MAKE_TAG( TMP_DBCS_TAG ),*NumRecords * 2 * sizeof(CHAR));
            if (TransBufferA == NULL) {
                ConsoleHeapFree(TransBuffer);
                return STATUS_NO_MEMORY;
            }

            fLocalHeap = TRUE;
        }
        else {
            TransBuffer  = ScreenInfo->BufferInfo.TextInfo.DbcsScreenBuffer.TransBufferCharacter;
            TransBufferA = ScreenInfo->BufferInfo.TextInfo.DbcsScreenBuffer.TransBufferAttribute;
        }

        TmpBuf = Buffer;
        TmpTrans = TransBuffer;
        TmpTransA = TransBufferA;      // MSKK Apr.02.1993 V-HirotS For KAttr
        for (i=0; i < *NumRecords;) {
            if (IsDBCSLeadByteConsole(*TmpBuf,&ScreenInfo->Console->OutputCPInfo)) {
                if (i+1 >= *NumRecords) {
                    *TmpTrans = UNICODE_SPACE;
                    *TmpTransA = 0;
                    i++;
                }
                else {
                    ConvertOutputToUnicode(Codepage,
                                           TmpBuf,
                                           2,
                                           TmpTrans,
                                           2);
                    *(TmpTrans+1) = *TmpTrans;
                    TmpTrans += 2;
                    TmpBuf += 2;
                    *TmpTransA++ = ATTR_LEADING_BYTE;
                    *TmpTransA++ = ATTR_TRAILING_BYTE;
                    i += 2;
                }
            }
            else {
                ConvertOutputToUnicode(Codepage,
                                       TmpBuf,
                                       1,
                                       TmpTrans,
                                       1);
                TmpTrans++;
                TmpBuf++;
                *TmpTransA++ = 0;               // MSKK APr.02.1993 V-HirotS For KAttr
                i++;
            }
        }
        BufferA = TransBufferA;
        Buffer = TransBuffer;
#else
        if (*NumRecords == 1) {
            TransBuffer = NULL;
            SingleChar = SB_CharToWcharGlyph(Codepage, *((char *)Buffer));
            Buffer = &SingleChar;
        } else {
            TransBuffer = (PWCHAR)ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ),*NumRecords * sizeof(WCHAR));
            if (TransBuffer == NULL) {
                return STATUS_NO_MEMORY;
            }
            ConvertOutputToUnicode(Codepage, Buffer, *NumRecords,
                    TransBuffer, *NumRecords);
            Buffer = TransBuffer;
        }
#endif
    } else if (StringType == CONSOLE_REAL_UNICODE &&
            (ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) &&
            !(ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN)) {
        RealUnicodeToFalseUnicode(Buffer,
                                *NumRecords,
                                ScreenInfo->Console->OutputCP
                                );
    }

#ifdef WWSB_FE
    if ((StringType == CONSOLE_REAL_UNICODE) || (StringType == CONSOLE_FALSE_UNICODE)) {
        PWCHAR TmpBuf;
        PWCHAR TmpTrans;
        PCHAR TmpTransA;
        ULONG i,j;
        WCHAR c;

        /* Avoid overflow into TransBufferCharacter , TransBufferAttribute
         * because, if hit by IsConsoleFullWidth()
         * then one unicde character needs two spaces on TransBuffer.
         */
        if ((*NumRecords*2) > (ULONG)(ScreenInfo->ScreenBufferSize.X * ScreenInfo->ScreenBufferSize.Y)) {

            TransBuffer = ConsoleHeapAlloc(MAKE_TAG( TMP_DBCS_TAG ),*NumRecords * 2 * sizeof(WCHAR));
            if (TransBuffer == NULL) {
                return STATUS_NO_MEMORY;
            }
            TransBufferA = ConsoleHeapAlloc(MAKE_TAG( TMP_DBCS_TAG ),*NumRecords * 2 * sizeof(CHAR));
            if (TransBufferA == NULL) {
                ConsoleHeapFree(TransBuffer);
                return STATUS_NO_MEMORY;
            }

            fLocalHeap = TRUE;
        }
        else {
            TransBuffer  = ScreenInfo->BufferInfo.TextInfo.DbcsScreenBuffer.TransBufferCharacter;
            TransBufferA = ScreenInfo->BufferInfo.TextInfo.DbcsScreenBuffer.TransBufferAttribute;
        }

        TmpBuf = Buffer;
        TmpTrans = TransBuffer;
        TmpTransA = TransBufferA;
        for (i=0,j=0; i < *NumRecords; i++,j++) {
            *TmpTrans++ = c = *TmpBuf++;
            *TmpTransA = 0;
            if (IsConsoleFullWidth(ScreenInfo->Console->hDC,
                                   ScreenInfo->Console->OutputCP,c)) {
                *TmpTransA++ = ATTR_LEADING_BYTE;
                *TmpTrans++ = c;
                *TmpTransA = ATTR_TRAILING_BYTE;
                j++;
            }
            TmpTransA++;
        }
        NumRecordsSavedForUnicode = *NumRecords;
        *NumRecords = j;
        Buffer = TransBuffer;
        BufferA = TransBufferA;
    }
#endif

    if ((StringType == CONSOLE_REAL_UNICODE) ||
            (StringType == CONSOLE_FALSE_UNICODE) ||
            (StringType == CONSOLE_ASCII)) {
        while (TRUE) {

            LeftX = X;

            //
            // copy the chars into their arrays
            //

            Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
            Char = &Row->CharRow.Chars[X];
#ifdef WWSB_FE
            AttrP = &Row->CharRow.KAttrs[X];
#endif
            if ((ULONG)(ScreenInfo->ScreenBufferSize.X - X) >= (*NumRecords - NumWritten)) {
                /*
                 * The text will not hit the right hand edge, copy it all
                 */
#ifdef WWSB_FE
                COORD TPoint;

                TPoint.X = X;
                TPoint.Y = Y;
                BisectWrite((SHORT)(*NumRecords-NumWritten),TPoint,ScreenInfo);
                if (TPoint.Y == ScreenInfo->ScreenBufferSize.Y-1 &&
                    (SHORT)(TPoint.X+*NumRecords-NumWritten) >= ScreenInfo->ScreenBufferSize.X &&
                    *((PCHAR)BufferA+ScreenInfo->ScreenBufferSize.X-TPoint.X-1) & ATTR_LEADING_BYTE
                   ) {
                    *((PWCHAR)Buffer+ScreenInfo->ScreenBufferSize.X-TPoint.X-1) = UNICODE_SPACE;
                    *((PCHAR)BufferA+ScreenInfo->ScreenBufferSize.X-TPoint.X-1) = 0;
                    if ((SHORT)(*NumRecords-NumWritten) > (SHORT)(ScreenInfo->ScreenBufferSize.X-TPoint.X-1)) {
                        *((PWCHAR)Buffer+ScreenInfo->ScreenBufferSize.X-TPoint.X) = UNICODE_SPACE;
                        *((PCHAR)BufferA+ScreenInfo->ScreenBufferSize.X-TPoint.X) = 0;
                    }
                }
                RtlCopyMemory(AttrP,BufferA,(*NumRecords - NumWritten) * sizeof(CHAR));
#endif
                RtlCopyMemory(Char,Buffer,(*NumRecords - NumWritten) * sizeof(WCHAR));
                X=(SHORT)(X+*NumRecords - NumWritten-1);
                NumWritten = *NumRecords;
            }
            else {
                /*
                 * The text will hit the right hand edge, copy only that much
                 */
#ifdef WWSB_FE
                COORD TPoint;

                TPoint.X = X;
                TPoint.Y = Y;
                BisectWrite((SHORT)(ScreenInfo->ScreenBufferSize.X-X),TPoint,ScreenInfo);
                if (TPoint.Y == ScreenInfo->ScreenBufferSize.Y-1 &&
                    TPoint.X+ScreenInfo->ScreenBufferSize.X-X >= ScreenInfo->ScreenBufferSize.X &&
                    *((PCHAR)BufferA+ScreenInfo->ScreenBufferSize.X-TPoint.X-1) & ATTR_LEADING_BYTE
                   ) {
                    *((PWCHAR)Buffer+ScreenInfo->ScreenBufferSize.X-TPoint.X-1) = UNICODE_SPACE;
                    *((PCHAR)BufferA+ScreenInfo->ScreenBufferSize.X-TPoint.X-1) = 0;
                    if (ScreenInfo->ScreenBufferSize.X-X > ScreenInfo->ScreenBufferSize.X-TPoint.X-1) {
                        *((PWCHAR)Buffer+ScreenInfo->ScreenBufferSize.X-TPoint.X) = UNICODE_SPACE;
                        *((PCHAR)BufferA+ScreenInfo->ScreenBufferSize.X-TPoint.X) = 0;
                    }
                }
                RtlCopyMemory(AttrP,BufferA,(ScreenInfo->ScreenBufferSize.X - X) * sizeof(CHAR));
                BufferA = (PVOID)((PBYTE)BufferA + ((ScreenInfo->ScreenBufferSize.X - X) * sizeof(CHAR)));
#endif
                RtlCopyMemory(Char,Buffer,(ScreenInfo->ScreenBufferSize.X - X) * sizeof(WCHAR));
                Buffer = (PVOID)((PBYTE)Buffer + ((ScreenInfo->ScreenBufferSize.X - X) * sizeof(WCHAR)));
                NumWritten += ScreenInfo->ScreenBufferSize.X - X;
                X = (SHORT)(ScreenInfo->ScreenBufferSize.X-1);
            }

            // recalculate first and last non-space char

            Row->CharRow.OldLeft = Row->CharRow.Left;
            if (LeftX < Row->CharRow.Left) {
                PWCHAR LastChar = &Row->CharRow.Chars[ScreenInfo->ScreenBufferSize.X];

                for (Char=&Row->CharRow.Chars[LeftX];Char < LastChar && *Char==(WCHAR)' ';Char++)
                    ;
                Row->CharRow.Left = (SHORT)(Char-Row->CharRow.Chars);
            }

            Row->CharRow.OldRight = Row->CharRow.Right;
            if ((X+1) >= Row->CharRow.Right) {
                WORD LastNonSpace;
                PWCHAR FirstChar = Row->CharRow.Chars;

                LastNonSpace = X;
                for (Char=&Row->CharRow.Chars[X];*Char==(WCHAR)' ' && Char >= FirstChar;Char--)
                    LastNonSpace--;
                Row->CharRow.Right = (SHORT)(LastNonSpace+1);
            }
            if (++RowIndex == ScreenInfo->ScreenBufferSize.Y) {
                RowIndex = 0;
            }
            if (NumWritten < *NumRecords) {
                /*
                 * The string hit the right hand edge, so wrap around to the
                 * next line by going back round the while loop, unless we
                 * are at the end of the buffer - in which case we simply
                 * abandon the remainder of the output string!
                 */
                X = 0;
                Y++;
                if (Y >= ScreenInfo->ScreenBufferSize.Y) {
                    break; // abandon output, string is truncated
                }
            } else {
                break;
            }
        }
    } else if (StringType == CONSOLE_ATTRIBUTE) {
        PWORD SourcePtr=Buffer;
        PATTR_PAIR AttrBuf;
        ATTR_PAIR Attrs[80];
        PATTR_PAIR Attr;
        SHORT AttrLength;

        AttrBuf = Attrs;
        if (ScreenInfo->ScreenBufferSize.X > 80) {
            AttrBuf = (PATTR_PAIR)ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ),ScreenInfo->ScreenBufferSize.X * sizeof(ATTR_PAIR));
            if (AttrBuf == NULL)
                return STATUS_NO_MEMORY;
        }
#ifdef WWSB_FE
        {
            COORD TPoint;
            TPoint.X = X;
            TPoint.Y = Y;
            if ((ULONG)(ScreenInfo->ScreenBufferSize.X - X) >= (*NumRecords - NumWritten)) {
                BisectWriteAttr((SHORT)(*NumRecords-NumWritten),TPoint,ScreenInfo);
            }
            else{
                BisectWriteAttr((SHORT)(ScreenInfo->ScreenBufferSize.X-X),TPoint,ScreenInfo);
            }
        }
#endif
        while (TRUE) {

            //
            // copy the attrs into the screen buffer arrays
            //

            Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
            Attr = AttrBuf;
            Attr->Length = 0;
#ifdef WWSB_FE
            Attr->Attr = *SourcePtr & ~COMMON_LVB_SBCSDBCS;
#else
            Attr->Attr = *SourcePtr;
#endif
            AttrLength = 1;
            for (j=X;j<ScreenInfo->ScreenBufferSize.X;j++,SourcePtr++) {
#ifdef WWSB_FE
                if (Attr->Attr == (*SourcePtr & ~COMMON_LVB_SBCSDBCS))
#else
                if (Attr->Attr == *SourcePtr)
#endif
                {
                    Attr->Length += 1;
                }
                else {
                    Attr++;
                    Attr->Length = 1;
#ifdef WWSB_FE
                    Attr->Attr = *SourcePtr & ~COMMON_LVB_SBCSDBCS;
#else
                    Attr->Attr = *SourcePtr;
#endif
                    AttrLength += 1;
                }
                NumWritten++;
                X++;
                if (NumWritten == *NumRecords) {
                    break;
                }
            }
            X--;

            // recalculate last non-space char

            //
            // see if attr string is different.  if so, allocate a new
            // attr buffer and merge the two strings.
            //

            if (AttrLength != Row->AttrRow.Length ||
                memcmp(Row->AttrRow.Attrs,AttrBuf,AttrLength*sizeof(*Attr))) {
                PATTR_PAIR NewAttrs;
                WORD NewAttrsLength;

                if (!NT_SUCCESS(MergeAttrStrings(Row->AttrRow.Attrs,
                                 Row->AttrRow.Length,
                                 AttrBuf,
                                 AttrLength,
                                 &NewAttrs,
                                 &NewAttrsLength,
                                 (SHORT)((Y == WriteCoord.Y) ? WriteCoord.X : 0),
                                 X,
                                 Row,
                                 ScreenInfo
                                ))) {
                    if (ScreenInfo->ScreenBufferSize.X > 80) {
                        ConsoleHeapFree(AttrBuf);
                    }
                    ResetTextFlags(ScreenInfo,
                                   WriteCoord.X,
                                   WriteCoord.Y,
                                   X,
                                   Y);
                    return STATUS_NO_MEMORY;
                }
                if (Row->AttrRow.Length > 1) {
                    ConsoleHeapFree(Row->AttrRow.Attrs);
                }
                else {
                    ASSERT(Row->AttrRow.Attrs == &Row->AttrRow.AttrPair);
                }
                Row->AttrRow.Attrs = NewAttrs;
                Row->AttrRow.Length = NewAttrsLength;
                Row->CharRow.OldLeft = INVALID_OLD_LENGTH;
                Row->CharRow.OldRight = INVALID_OLD_LENGTH;
            }

            if (++RowIndex == ScreenInfo->ScreenBufferSize.Y) {
                RowIndex = 0;
            }
            if (NumWritten < *NumRecords) {
                X = 0;
                Y++;
                if (Y>=ScreenInfo->ScreenBufferSize.Y) {
                    break;
                }
            } else {
                break;
            }
        }
        ResetTextFlags(ScreenInfo,
                       WriteCoord.X,
                       WriteCoord.Y,
                       X,
                       Y);
        if (ScreenInfo->ScreenBufferSize.X > 80) {
            ConsoleHeapFree(AttrBuf);
        }
    } else {
        *NumRecords = 0;
        return STATUS_INVALID_PARAMETER;
    }
    if ((StringType == CONSOLE_ASCII) && (TransBuffer != NULL)) {
#ifdef WWSB_FE
        if (fLocalHeap) {
            ConsoleHeapFree(TransBuffer);
            ConsoleHeapFree(TransBufferA);
        }
#else
        ConsoleHeapFree(TransBuffer);
#endif
    }
#ifdef WWSB_FE
    else if ((StringType == CONSOLE_FALSE_UNICODE) || (StringType == CONSOLE_REAL_UNICODE)) {
        if (fLocalHeap) {
            ConsoleHeapFree(TransBuffer);
            ConsoleHeapFree(TransBufferA);
        }
        NumWritten = NumRecordsSavedForUnicode - (*NumRecords - NumWritten);
    }
#endif

    //
    // determine write region.  if we're still on the same line we started
    // on, left X is the X we started with and right X is the one we're on
    // now.  otherwise, left X is 0 and right X is the rightmost column of
    // the screen buffer.
    //
    // then update the screen.
    //

    WriteRegion.Top = WriteCoord.Y;
    WriteRegion.Bottom = Y;
    if (Y != WriteCoord.Y) {
        WriteRegion.Left = 0;
        WriteRegion.Right = (SHORT)(ScreenInfo->ScreenBufferSize.X-1);
    }
    else {
        WriteRegion.Left = WriteCoord.X;
        WriteRegion.Right = X;
    }
    WWSB_WriteToScreen(ScreenInfo,&WriteRegion);
    if (NumColumns) {
        *NumColumns = X + (WriteCoord.Y - Y) * ScreenInfo->ScreenBufferSize.X - WriteCoord.X + 1;
    }
    *NumRecords = NumWritten;
    return STATUS_SUCCESS;
}

NTSTATUS
WWSB_FillOutput(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN WORD Element,
    IN COORD WriteCoord,
    IN ULONG ElementType,
    IN OUT PULONG Length // this value is valid even for error cases
    )

/*++

Routine Description:

    This routine fills the screen buffer with the specified character or
    attribute.

Arguments:

    ScreenInfo - Pointer to screen buffer information.

    Element - Element to write.

    WriteCoord - Screen buffer coordinate to begin writing to.

    ElementType

        CONSOLE_ASCII         - element is an ascii character.
        CONSOLE_REAL_UNICODE  - element is a real unicode character. These will
                                get converted to False Unicode as required.
        CONSOLE_FALSE_UNICODE - element is a False Unicode character.
        CONSOLE_ATTRIBUTE     - element is an attribute.

    Length - On input, the number of elements to write.  On output,
    the number of elements written.

Return Value:


--*/

{
    ULONG NumWritten;
    SHORT X,Y,LeftX;
    SMALL_RECT WriteRegion;
    PROW Row;
    PWCHAR Char;
    SHORT RowIndex;
    SHORT j;
#ifdef WWSB_FE
    PCHAR AttrP;
#endif

    DBGOUTPUT(("FillOutput\n"));
    if (*Length == 0)
        return STATUS_SUCCESS;
    NumWritten = 0;
    X=WriteCoord.X;
    Y=WriteCoord.Y;
    if (X>=ScreenInfo->ScreenBufferSize.X ||
        X<0 ||
        Y>=ScreenInfo->ScreenBufferSize.Y ||
        Y<0) {
        *Length = 0;
        return STATUS_SUCCESS;
    }

#ifdef WWSB_FE
    ASSERT(ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER);
#endif

    ScreenInfo->BufferInfo.TextInfo.Flags |= TEXT_VALID_HINT;
    RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+WriteCoord.Y) % ScreenInfo->ScreenBufferSize.Y;

    if (ElementType == CONSOLE_ASCII) {
        UINT Codepage;
        if ((ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) &&
                ((ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN) == 0)) {
            if (ScreenInfo->Console->OutputCP != WINDOWSCP)
                Codepage = USACP;
            else
                Codepage = WINDOWSCP;
        } else {
            Codepage = ScreenInfo->Console->OutputCP;
        }
#ifdef WWSB_FE
        if (ScreenInfo->FillOutDbcsLeadChar == 0){
            if (IsDBCSLeadByteConsole((CHAR)Element,&ScreenInfo->Console->OutputCPInfo)) {
                ScreenInfo->FillOutDbcsLeadChar = (CHAR)Element;
                *Length = 0;
                return STATUS_SUCCESS;
            }else{
                CHAR Char=(CHAR)Element;
                ConvertOutputToUnicode(Codepage,
                          &Char,
                          1,
                          &Element,
                          1);
            }
        }else{
            CHAR Char[2];
            Char[0]=ScreenInfo->FillOutDbcsLeadChar;
            Char[1]=(BYTE)Element;
            ScreenInfo->FillOutDbcsLeadChar = 0;
            ConvertOutputToUnicode(Codepage,
                      Char,
                      2,
                      &Element,
                      2);
        }
#else
        Element = SB_CharToWchar(Codepage, (CHAR)Element);
#endif
    } else if (ElementType == CONSOLE_REAL_UNICODE &&
            (ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) &&
            !(ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN)) {
        RealUnicodeToFalseUnicode(&Element,
                                1,
                                ScreenInfo->Console->OutputCP
                                );
    }

    if ((ElementType == CONSOLE_ASCII) ||
            (ElementType == CONSOLE_REAL_UNICODE) ||
            (ElementType == CONSOLE_FALSE_UNICODE)) {
#ifdef WWSB_FE
        DWORD StartPosFlag ;
        StartPosFlag = 0;
#endif
        while (TRUE) {

            //
            // copy the chars into their arrays
            //

            LeftX = X;
            Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
            Char = &Row->CharRow.Chars[X];
#ifdef WWSB_FE
            AttrP = &Row->CharRow.KAttrs[X];
#endif
            if ((ULONG)(ScreenInfo->ScreenBufferSize.X - X) >= (*Length - NumWritten)) {
#ifdef WWSB_FE
                {
                    COORD TPoint;

                    TPoint.X = X;
                    TPoint.Y = Y;
                    BisectWrite((SHORT)(*Length-NumWritten),TPoint,ScreenInfo);
                }
#endif
#ifdef WWSB_FE
                if (IsConsoleFullWidth(ScreenInfo->Console->hDC,
                                       ScreenInfo->Console->OutputCP,(WCHAR)Element)) {
                    for (j=0;j<(SHORT)(*Length - NumWritten);j++) {
                        *Char++ = (WCHAR)Element;
                        *AttrP &= ~ATTR_DBCSSBCS_BYTE;
                        if(StartPosFlag++ & 1)
                            *AttrP++ |= ATTR_TRAILING_BYTE;
                        else
                            *AttrP++ |= ATTR_LEADING_BYTE;
                    }
                    if(StartPosFlag & 1){
                        *(Char-1) = UNICODE_SPACE;
                        *(AttrP-1) &= ~ATTR_DBCSSBCS_BYTE;
                    }
                }
                else {
#endif
                    for (j=0;j<(SHORT)(*Length - NumWritten);j++) {
                        *Char++ = (WCHAR)Element;
#ifdef WWSB_FE
                        *AttrP++ &= ~ATTR_DBCSSBCS_BYTE;
#endif
                    }
#ifdef WWSB_FE
                }
#endif
                X=(SHORT)(X+*Length - NumWritten - 1);
                NumWritten = *Length;
            }
            else {
#ifdef WWSB_FE
                {
                    COORD TPoint;

                    TPoint.X = X;
                    TPoint.Y = Y;
                    BisectWrite((SHORT)(ScreenInfo->ScreenBufferSize.X-X),TPoint,ScreenInfo);
                }
#endif
#ifdef WWSB_FE
                if (IsConsoleFullWidth(ScreenInfo->Console->hDC,
                                       ScreenInfo->Console->OutputCP,(WCHAR)Element)) {
                    for (j=0;j<ScreenInfo->ScreenBufferSize.X - X;j++) {
                        *Char++ = (WCHAR)Element;
                        *AttrP &= ~ATTR_DBCSSBCS_BYTE;
                        if(StartPosFlag++ & 1)
                            *AttrP++ |= ATTR_TRAILING_BYTE;
                        else
                            *AttrP++ |= ATTR_LEADING_BYTE;
                    }
                }
                else {
#endif
                    for (j=0;j<ScreenInfo->ScreenBufferSize.X - X;j++) {
                        *Char++ = (WCHAR)Element;
#ifdef WWSB_FE
                        *AttrP++ &= ~ATTR_DBCSSBCS_BYTE;
#endif
                    }
#ifdef WWSB_FE
                }
#endif
                NumWritten += ScreenInfo->ScreenBufferSize.X - X;
                X = (SHORT)(ScreenInfo->ScreenBufferSize.X-1);
            }

            // recalculate first and last non-space char

            Row->CharRow.OldLeft = Row->CharRow.Left;
            if (LeftX < Row->CharRow.Left) {
                if (Element == UNICODE_SPACE) {
                    Row->CharRow.Left = X+1;
                } else {
                    Row->CharRow.Left = LeftX;
                }
            }
            Row->CharRow.OldRight = Row->CharRow.Right;
            if ((X+1) >= Row->CharRow.Right) {
                if (Element == UNICODE_SPACE) {
                    Row->CharRow.Right = LeftX;
                } else {
                    Row->CharRow.Right = X+1;
                }
            }
            if (++RowIndex == ScreenInfo->ScreenBufferSize.Y) {
                RowIndex = 0;
            }
            if (NumWritten < *Length) {
                X = 0;
                Y++;
                if (Y>=ScreenInfo->ScreenBufferSize.Y) {
                    break;
                }
            } else {
                break;
            }
        }
    } else if (ElementType == CONSOLE_ATTRIBUTE) {
        ATTR_PAIR Attr;

#ifdef WWSB_FE
        COORD TPoint;
        TPoint.X = X;
        TPoint.Y = Y;

        if ((ULONG)(ScreenInfo->ScreenBufferSize.X - X) >= (*Length - NumWritten)) {
            BisectWriteAttr((SHORT)(*Length-NumWritten),TPoint,ScreenInfo);
        }
        else{
            BisectWriteAttr((SHORT)(ScreenInfo->ScreenBufferSize.X-X),TPoint,ScreenInfo);
        }
#endif

        while (TRUE) {

            //
            // copy the attrs into the screen buffer arrays
            //

            Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
            if ((ULONG)(ScreenInfo->ScreenBufferSize.X - X) >= (*Length - NumWritten)) {
                X=(SHORT)(X+*Length - NumWritten - 1);
                NumWritten = *Length;
            }
            else {
                NumWritten += ScreenInfo->ScreenBufferSize.X - X;
                X = (SHORT)(ScreenInfo->ScreenBufferSize.X-1);
            }

            // recalculate last non-space char

            //
            //  merge the two attribute strings.
            //

            Attr.Length = (SHORT)((Y == WriteCoord.Y) ? (X-WriteCoord.X+1) : (X+1));
#ifdef WWSB_FE
            Attr.Attr = Element & ~COMMON_LVB_SBCSDBCS;
#else
            Attr.Attr = Element;
#endif
            if (1 != Row->AttrRow.Length ||
                memcmp(Row->AttrRow.Attrs,&Attr,sizeof(Attr))) {
                PATTR_PAIR NewAttrs;
                WORD NewAttrsLength;

                if (!NT_SUCCESS(MergeAttrStrings(Row->AttrRow.Attrs,
                                 Row->AttrRow.Length,
                                 &Attr,
                                 1,
                                 &NewAttrs,
                                 &NewAttrsLength,
                                 (SHORT)(X-Attr.Length+1),
                                 X,
                                 Row,
                                 ScreenInfo
                                ))) {
                    ResetTextFlags(ScreenInfo,
                                   WriteCoord.X,
                                   WriteCoord.Y,
                                   X,
                                   Y);
                    return STATUS_NO_MEMORY;
                }
                if (Row->AttrRow.Length > 1) {
                    ConsoleHeapFree(Row->AttrRow.Attrs);
                }
                else {
                    ASSERT(Row->AttrRow.Attrs == &Row->AttrRow.AttrPair);
                }
                Row->AttrRow.Attrs = NewAttrs;
                Row->AttrRow.Length = NewAttrsLength;
                Row->CharRow.OldLeft = INVALID_OLD_LENGTH;
                Row->CharRow.OldRight = INVALID_OLD_LENGTH;
            }

            if (++RowIndex == ScreenInfo->ScreenBufferSize.Y) {
                RowIndex = 0;
            }
            if (NumWritten < *Length) {
                X = 0;
                Y++;
                if (Y>=ScreenInfo->ScreenBufferSize.Y) {
                    break;
                }
            } else {
                break;
            }
        }
        ResetTextFlags(ScreenInfo,
                       WriteCoord.X,
                       WriteCoord.Y,
                       X,
                       Y);
    } else {
        *Length = 0;
        return STATUS_INVALID_PARAMETER;
    }

    //
    // determine write region.  if we're still on the same line we started
    // on, left X is the X we started with and right X is the one we're on
    // now.  otherwise, left X is 0 and right X is the rightmost column of
    // the screen buffer.
    //
    // then update the screen.
    //

#ifdef WWSB_FE
    if (ScreenInfo->ConvScreenInfo) {
        WriteRegion.Top = WriteCoord.Y + ScreenInfo->Window.Left + ScreenInfo->ConvScreenInfo->CaInfo.coordConView.Y;
        WriteRegion.Bottom = Y + ScreenInfo->Window.Left + ScreenInfo->ConvScreenInfo->CaInfo.coordConView.Y;
        if (Y != WriteCoord.Y) {
            WriteRegion.Left = 0;
            WriteRegion.Right = (SHORT)(ScreenInfo->Console->CurrentScreenBuffer->ScreenBufferSize.X-1);
        }
        else {
            WriteRegion.Left = WriteCoord.X + ScreenInfo->Window.Top + ScreenInfo->ConvScreenInfo->CaInfo.coordConView.X;
            WriteRegion.Right = X + ScreenInfo->Window.Top + ScreenInfo->ConvScreenInfo->CaInfo.coordConView.X;
        }
        WriteConvRegionToScreen(ScreenInfo->Console->CurrentScreenBuffer,
                                ScreenInfo->ConvScreenInfo,
                                &WriteRegion
                               );
        ScreenInfo->BisectFlag &= ~(BISECT_LEFT | BISECT_RIGHT | BISECT_TOP | BISECT_BOTTOM);
        *Length = NumWritten;
        return STATUS_SUCCESS;
    }
#endif

    WriteRegion.Top = WriteCoord.Y;
    WriteRegion.Bottom = Y;
    if (Y != WriteCoord.Y) {
        WriteRegion.Left = 0;
        WriteRegion.Right = (SHORT)(ScreenInfo->ScreenBufferSize.X-1);
    }
    else {
        WriteRegion.Left = WriteCoord.X;
        WriteRegion.Right = X;
    }
    WWSB_WriteToScreen(ScreenInfo,&WriteRegion);
    *Length = NumWritten;
    return STATUS_SUCCESS;
}

VOID
WWSB_FillRectangle(
    IN CHAR_INFO Fill,
    IN OUT PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT TargetRect
    )

/*++

Routine Description:

    This routine fills a rectangular region in the screen
    buffer.  no clipping is done.

Arguments:

    Fill - element to copy to each element in target rect

    ScreenInfo - pointer to screen info

    TargetRect - rectangle in screen buffer to fill

Return Value:

--*/

{
    SHORT i,j;
    SHORT XSize;
    SHORT RowIndex;
    PROW Row;
    PWCHAR Char;
    ATTR_PAIR Attr;
#ifdef WWSB_FE
    PCHAR AttrP;
    BOOL Width;
#endif
    DBGOUTPUT(("FillRectangle\n"));
#ifdef WWFE_SB
    ASSERT(ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER);
#endif

    XSize = (SHORT)(TargetRect->Right - TargetRect->Left + 1);

    ScreenInfo->BufferInfo.TextInfo.Flags |= TEXT_VALID_HINT;
    RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+TargetRect->Top) % ScreenInfo->ScreenBufferSize.Y;
    for (i=TargetRect->Top;i<=TargetRect->Bottom;i++) {

        //
        // copy the chars and attrs into their respective arrays
        //

#ifdef WWSB_FE
        {
            COORD TPoint;

            TPoint.X = TargetRect->Left;
            TPoint.Y = i;
            BisectWrite(XSize,TPoint,ScreenInfo);
            Width = IsConsoleFullWidth(ScreenInfo->Console->hDC,
                                       ScreenInfo->Console->OutputCP,Fill.Char.UnicodeChar);
        }
#endif

        Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
        Char = &Row->CharRow.Chars[TargetRect->Left];
#ifdef WWSB_FE
        AttrP = &Row->CharRow.KAttrs[TargetRect->Left];
#endif
        for (j=0;j<XSize;j++) {
#ifdef WWSB_FE
            if (Width){
                if (j < XSize-1){
                    *Char++ = Fill.Char.UnicodeChar;
                    *Char++ = Fill.Char.UnicodeChar;
                    *AttrP++ = ATTR_LEADING_BYTE;
                    *AttrP++ = ATTR_TRAILING_BYTE;
                    j++;
                }
                else{
                    *Char++ = UNICODE_SPACE;
                    *AttrP++ = 0 ;
                }
            }
            else{
#endif
                *Char++ = Fill.Char.UnicodeChar;
#ifdef WWSB_FE
                *AttrP++ = 0 ;
            }
#endif
        }

        // recalculate first and last non-space char

        Row->CharRow.OldLeft = Row->CharRow.Left;
        if (TargetRect->Left < Row->CharRow.Left) {
            if (Fill.Char.UnicodeChar == UNICODE_SPACE) {
                Row->CharRow.Left = (SHORT)(TargetRect->Right+1);
            }
            else {
                Row->CharRow.Left = (SHORT)(TargetRect->Left);
            }
        }

        Row->CharRow.OldRight = Row->CharRow.Right;
        if (TargetRect->Right >= Row->CharRow.Right) {
            if (Fill.Char.UnicodeChar == UNICODE_SPACE) {
                Row->CharRow.Right = (SHORT)(TargetRect->Left);
            }
            else {
                Row->CharRow.Right = (SHORT)(TargetRect->Right+1);
            }
        }

        Attr.Length = XSize;
        Attr.Attr = Fill.Attributes;

        //
        //  merge the two attribute strings.
        //

        if (1 != Row->AttrRow.Length ||
            memcmp(Row->AttrRow.Attrs,&Attr,sizeof(Attr))) {
            PATTR_PAIR NewAttrs;
            WORD NewAttrsLength;

            if (!NT_SUCCESS(MergeAttrStrings(Row->AttrRow.Attrs,
                             Row->AttrRow.Length,
                             &Attr,
                             1,
                             &NewAttrs,
                             &NewAttrsLength,
                             TargetRect->Left,
                             TargetRect->Right,
                             Row,
                             ScreenInfo
                            ))) {
                ResetTextFlags(ScreenInfo,
                               TargetRect->Left,
                               TargetRect->Top,
                               TargetRect->Right,
                               TargetRect->Bottom);
                return;
            }
            if (Row->AttrRow.Length > 1) {
                ConsoleHeapFree(Row->AttrRow.Attrs);
            }
            else {
                ASSERT(Row->AttrRow.Attrs == &Row->AttrRow.AttrPair);
            }
            Row->AttrRow.Attrs = NewAttrs;
            Row->AttrRow.Length = NewAttrsLength;
            Row->CharRow.OldLeft = INVALID_OLD_LENGTH;
            Row->CharRow.OldRight = INVALID_OLD_LENGTH;
        }
        if (++RowIndex == ScreenInfo->ScreenBufferSize.Y) {
            RowIndex = 0;
        }
    }
    ResetTextFlags(ScreenInfo,
                   TargetRect->Left,
                   TargetRect->Top,
                   TargetRect->Right,
                   TargetRect->Bottom);
}

BOOL
WWSB_PolyTextOutCandidate(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT Region
    )

/*

    This function returns TRUE if the input region is reasonable to
    pass to ConsolePolyTextOut.  The criteria are that there is only
    one attribute per line.

*/

{
    SHORT RowIndex;
    PROW Row;
    SHORT i;

#ifdef WWSB_FE
    if((ScreenInfo->Console->Flags & CONSOLE_VDM_REGISTERED &&
        ((PEUDC_INFORMATION)(ScreenInfo->Console->EudcInformation))->LocalVDMEudcMode)){
        return FALSE;
    }
    if (!(ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) &&
        !(ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN) &&
        ((PEUDC_INFORMATION)(ScreenInfo->Console->EudcInformation))->LocalKeisenEudcMode
       ) {
        return FALSE;
    }
    ASSERT(ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER);
    if (ScreenInfo->BufferInfo.TextInfo.Flags & CONSOLE_CONVERSION_AREA_REDRAW) {
        return FALSE;
    }
#endif

    if (ScreenInfo->BufferInfo.TextInfo.Flags & SINGLE_ATTRIBUTES_PER_LINE) {
        return TRUE;
    }

    //
    // make sure there is only one attr per line.
    //

    RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+Region->Top) % ScreenInfo->ScreenBufferSize.Y;
    for (i=Region->Top;i<=Region->Bottom;i++) {
        Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
        if (Row->AttrRow.Length != 1) {
            return FALSE;
        }
        if (++RowIndex == ScreenInfo->ScreenBufferSize.Y) {
            RowIndex = 0;
        }
    }
    return TRUE;
}


#define MAX_POLY_LINES 80
#define VERY_BIG_NUMBER 0x0FFFFFFF

#ifdef WWSB_FE
typedef struct _KEISEN_INFORMATION {
    COORD Coord;
    WORD n;
} KEISEN_INFORMATION, *PKEISEN_INFORMATION;
#endif

VOID
WWSB_ConsolePolyTextOut(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT Region
    )

/*

    This function calls PolyTextOut.  The only restriction is that
    there can't be more than one attribute per line in the region.

*/

{
    PROW  Row,LastRow;
    SHORT i,k;
    WORD Attr;
    POLYTEXTW TextInfo[MAX_POLY_LINES];
    RECT  TextRect;
    RECTL BoundingRect;
    int   xSize = SCR_FONTSIZE(ScreenInfo).X;
    int   ySize = SCR_FONTSIZE(ScreenInfo).Y;
    ULONG Flags = ScreenInfo->BufferInfo.TextInfo.Flags;
    int   WindowLeft = ScreenInfo->Window.Left;
    int   RegionLeft = Region->Left;
    int   RegionRight = Region->Right + 1;
    int   DefaultLeft  = (RegionLeft - WindowLeft) * xSize;
    int   DefaultRight = (RegionRight - WindowLeft) * xSize;
    PCONSOLE_INFORMATION Console = ScreenInfo->Console;
    PWCHAR TransPolyTextOut = NULL ;
#ifdef WWSB_FE
    KEISEN_INFORMATION KeisenInfo[MAX_POLY_LINES];
    SHORT j;
    WORD OldAttr;
#endif

    //
    // initialize the text rect and window position.
    //

    TextRect.top = (Region->Top - ScreenInfo->Window.Top) * ySize;
    // TextRect.bottom is invalid.
    BoundingRect.top = TextRect.top;
    BoundingRect.left = VERY_BIG_NUMBER;
    BoundingRect.right = 0;

    //
    // copy the chars and attrs from their respective arrays
    //

    Row = &ScreenInfo->BufferInfo.TextInfo.Rows
           [ScreenInfo->BufferInfo.TextInfo.FirstRow+Region->Top];
    LastRow = &ScreenInfo->BufferInfo.TextInfo.Rows[ScreenInfo->ScreenBufferSize.Y];
    if (Row >= LastRow)
        Row -= ScreenInfo->ScreenBufferSize.Y;

    Attr = Row->AttrRow.AttrPair.Attr;
    if (Console->LastAttributes != Attr) {
#ifdef WWSB_FE
        if (Attr & COMMON_LVB_REVERSE_VIDEO)
        {
            SetBkColor(Console->hDC, ConvertAttrToRGB(Console, LOBYTE(Attr)));
            SetTextColor(Console->hDC, ConvertAttrToRGB(Console, LOBYTE(Attr >> 4)));
        }
        else{
#endif
            SetTextColor(Console->hDC, ConvertAttrToRGB(Console, LOBYTE(Attr)));
            SetBkColor(Console->hDC, ConvertAttrToRGB(Console, LOBYTE(Attr >> 4)));
#ifdef WWSB_FE
        }
#endif
        Console->LastAttributes = Attr;
    }

    TransPolyTextOut = (PWCHAR)ConsoleHeapAlloc(
                                        MAKE_TAG( TMP_DBCS_TAG ),
                                        ScreenInfo->ScreenBufferSize.X*MAX_POLY_LINES*sizeof(WCHAR));
    if (TransPolyTextOut == NULL)
    {
        KdPrint(("CONSRV: ConsoleTextOut cannot allocate memory\n"));
        return ;
    }

    for (i=Region->Top;i<=Region->Bottom;) {
        PWCHAR TmpChar;
        TmpChar = TransPolyTextOut;
        for(k=0;i<=Region->Bottom&&k<MAX_POLY_LINES;i++) {
            SHORT NumberOfChars;
            SHORT LeftChar,RightChar;

            //
            // make the bounding rect smaller, if we can.  the TEXT_VALID_HINT
            // flag gets set each time we write to the screen buffer.  it gets
            // turned off any time we get asked to redraw the screen
            // and we don't know exactly what needs to be redrawn
            // (i.e. paint messages).
            //
            // we have the left and right bounds of the text on the
            // line.  the opaqueing rectangle and the number of
            // chars get set according to those values.
            //

            TextRect.left  = DefaultLeft;
            TextRect.right = DefaultRight;

            if (Flags & TEXT_VALID_HINT)
            {
            // We compute an opaquing interval.  If A is the old interval of text,
            // B is the new interval, and R is the Region, then the opaquing interval
            // must be R*(A+B), where * represents intersection and + represents union.

                if (Row->CharRow.OldLeft != INVALID_OLD_LENGTH)
                {
                // The min determines the left of (A+B).  The max intersects that with
                // the left of the region.

                    TextRect.left = (
                                      max
                                      (
                                        min
                                        (
                                          Row->CharRow.Left,
                                          Row->CharRow.OldLeft
                                        ),
                                        RegionLeft
                                      )
                                      -WindowLeft
                                    ) * xSize;
                }

                if (Row->CharRow.OldRight != INVALID_OLD_LENGTH)
                {
                // The max determines the right of (A+B).  The min intersects that with
                // the right of the region.

                    TextRect.right = (
                                       min
                                       (
                                         max
                                         (
                                           Row->CharRow.Right,
                                           Row->CharRow.OldRight
                                         ),
                                         RegionRight
                                       )
                                       -WindowLeft
                                     ) * xSize;
                }
            }

            //
            // We've got to draw any new text that appears in the region, so we just
            // intersect the new text interval with the region.
            //

            LeftChar = max(Row->CharRow.Left,RegionLeft);
            RightChar = min(Row->CharRow.Right,RegionRight);
            NumberOfChars = RightChar - LeftChar;
#ifdef WWSB_FE
            if (Row->CharRow.KAttrs[RightChar-1] & ATTR_LEADING_BYTE){
                if(TextRect.right <= ScreenInfo->Window.Right*xSize) {
                    TextRect.right += xSize;
                }
            }
#endif

            //
            // Empty rows are represented by CharRow.Right=0, CharRow.Left=MAX, so we
            // may have NumberOfChars<0 at this point if there is no text that needs
            // drawing.  (I.e. the intersection was empty.)
            //

            if (NumberOfChars < 0) {
                NumberOfChars = 0;
                LeftChar = 0;
                RightChar = 0;
            }

            //
            // We may also have TextRect.right<TextRect.left if the screen
            // is already cleared, and we really don't need to do anything at all.
            //

            if (TextRect.right > TextRect.left)
            {
                NumberOfChars = (SHORT)RemoveDbcsMarkAll(ScreenInfo,Row,&LeftChar,&TextRect,NULL,TmpChar,NumberOfChars);
                TextInfo[k].x = (LeftChar-WindowLeft) * xSize;
                TextInfo[k].y = TextRect.top;
                TextRect.bottom =  TextRect.top + ySize;
                TextInfo[k].n = NumberOfChars;
                TextInfo[k].lpstr = TmpChar;
#ifdef WWSB_FE
                if (CheckBisectStringW(ScreenInfo,
                                       Console->OutputCP,
                                       TmpChar,
                                       NumberOfChars,
                                       (TextRect.right-max(TextRect.left,TextInfo[k].x))/xSize
                                      )
                   ) {
                    TextRect.right += xSize;
                }
#endif
                TmpChar += NumberOfChars;
                TextInfo[k].rcl = TextRect;
                TextInfo[k].pdx = NULL;
                TextInfo[k].uiFlags = ETO_OPAQUE;
#ifdef WWSB_FE
                KeisenInfo[k].n = DefaultRight-DefaultLeft ;
                KeisenInfo[k].Coord.Y = (WORD)TextRect.top;
                KeisenInfo[k].Coord.X = (WORD)DefaultLeft;
#endif
                k++;

                if (BoundingRect.left > TextRect.left) {
                    BoundingRect.left = TextRect.left;
                }
                if (BoundingRect.right < TextRect.right) {
                    BoundingRect.right = TextRect.right;
                }
            }

            // Advance the high res bounds.

            TextRect.top += ySize;

            // Advance the row pointer.

            if (++Row >= LastRow)
                Row = ScreenInfo->BufferInfo.TextInfo.Rows;

            // Draw now if the attributes are about to change.

#ifdef WWSB_FE
            OldAttr = Attr ;
#endif
            if (Attr != Row->AttrRow.AttrPair.Attr) {
                Attr = Row->AttrRow.AttrPair.Attr;
                i++;
                break;
            }
        }

        if (k)
        {
            BoundingRect.bottom = TextRect.top;
            ASSERT(BoundingRect.left != VERY_BIG_NUMBER);
            ASSERT(BoundingRect.left <= BoundingRect.right);
            ASSERT(BoundingRect.top <= BoundingRect.bottom);
            GdiConsoleTextOut(Console->hDC,
                              TextInfo,
                              k,
                              &BoundingRect);
#ifdef WWSB_FE
            for ( j = 0 ; j < k ; j++){
                RECT TextRect;

                TextRect.left   = KeisenInfo[j].Coord.X;
                TextRect.top    = KeisenInfo[j].Coord.Y;
                TextRect.right  = KeisenInfo[j].n + TextRect.left;
                TextRect.bottom = KeisenInfo[j].Coord.Y + ySize;
                TextOutCommonLVB(ScreenInfo->Console, OldAttr, TextRect);
            }
#endif
        }
        if (Console->LastAttributes != Attr) {
#ifdef WWSB_FE
            if (Attr & COMMON_LVB_REVERSE_VIDEO)
            {
                SetBkColor(Console->hDC, ConvertAttrToRGB(Console, LOBYTE(Attr)));
                SetTextColor(Console->hDC, ConvertAttrToRGB(Console, LOBYTE(Attr >> 4)));
            }
            else{
#endif
                SetTextColor(Console->hDC, ConvertAttrToRGB(Console, LOBYTE(Attr)));
                SetBkColor(Console->hDC, ConvertAttrToRGB(Console, LOBYTE(Attr >> 4)));
#ifdef WWSB_FE
            }
#endif
            Console->LastAttributes = Attr;
            BoundingRect.top = TextRect.top;
            BoundingRect.left = VERY_BIG_NUMBER;
            BoundingRect.right = 0;
        }
    }
    GdiFlush();
    ConsoleHeapFree(TransPolyTextOut);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\server\stream.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    stream.h

Abstract:

        This file implements the NT console direct I/O API

Author:

    KazuM Apr.20.1996

Revision History:

--*/


typedef struct _RAW_READ_DATA {
    PINPUT_INFORMATION InputInfo;
    PCONSOLE_INFORMATION Console;
    ULONG BufferSize;
    PWCHAR BufPtr;
    PCONSOLE_PER_PROCESS_DATA ProcessData;
    HANDLE HandleIndex;
} RAW_READ_DATA, *PRAW_READ_DATA;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\server\_stream.h ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    _stream.h

Abstract:

    Performance critical routine for Single Binary

    Each function will be created with two flavors FE and non FE

Author:

    KazuM Jun.09.1997

Revision History:

--*/

#define WWSB_NEUTRAL_FILE 1

#if !defined(FE_SB)
#error This header file should be included with FE_SB
#endif

#if !defined(WWSB_FE) && !defined(WWSB_NOFE)
#error Either WWSB_FE and WWSB_NOFE must be defined.
#endif

#if defined(WWSB_FE) && defined(WWSB_NOFE)
#error Both WWSB_FE and WWSB_NOFE defined.
#endif

#ifdef WWSB_FE
#pragma alloc_text(FE_TEXT, FE_AdjustCursorPosition)
#pragma alloc_text(FE_TEXT, FE_WriteChars)
#pragma alloc_text(FE_TEXT, FE_DoWriteConsole)
#pragma alloc_text(FE_TEXT, FE_DoSrvWriteConsole)
#endif


NTSTATUS
WWSB_AdjustCursorPosition(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN COORD CursorPosition,
    IN BOOL KeepCursorVisible,
    OUT PSHORT ScrollY OPTIONAL
    )

/*++

Routine Description:

    This routine updates the cursor position.  Its input is the non-special
    cased new location of the cursor.  For example, if the cursor were being
    moved one space backwards from the left edge of the screen, the X
    coordinate would be -1.  This routine would set the X coordinate to
    the right edge of the screen and decrement the Y coordinate by one.

Arguments:

    ScreenInfo - Pointer to screen buffer information structure.

    CursorPosition - New location of cursor.

    KeepCursorVisible - TRUE if changing window origin desirable when hit right edge

Return Value:

--*/

{
    COORD WindowOrigin;
    NTSTATUS Status;
#ifdef WWSB_FE
    PCONSOLE_INFORMATION Console = ScreenInfo->Console;

    if (!(ScreenInfo->Flags & CONSOLE_TEXTMODE_BUFFER))
        return STATUS_SUCCESS;
#endif

    if (CursorPosition.X < 0) {
        if (CursorPosition.Y > 0) {
            CursorPosition.X = (SHORT)(ScreenInfo->ScreenBufferSize.X+CursorPosition.X);
            CursorPosition.Y = (SHORT)(CursorPosition.Y-1);
        }
        else {
            CursorPosition.X = 0;
        }
    }
    else if (CursorPosition.X >= ScreenInfo->ScreenBufferSize.X) {

        //
        // at end of line. if wrap mode, wrap cursor.  otherwise leave it
        // where it is.
        //

        if (ScreenInfo->OutputMode & ENABLE_WRAP_AT_EOL_OUTPUT) {
            CursorPosition.Y += CursorPosition.X / ScreenInfo->ScreenBufferSize.X;
            CursorPosition.X = CursorPosition.X % ScreenInfo->ScreenBufferSize.X;
        }
        else {
            CursorPosition.X = ScreenInfo->BufferInfo.TextInfo.CursorPosition.X;
        }
    }
#ifdef WWSB_FE
    if (CursorPosition.Y >= ScreenInfo->ScreenBufferSize.Y &&
        !(Console->InputBuffer.ImeMode.Open)
       )
#else
    if (CursorPosition.Y >= ScreenInfo->ScreenBufferSize.Y)
#endif
    {

        //
        // at end of buffer.  scroll contents of screen buffer so new
        // position is visible.
        //

        ASSERT (CursorPosition.Y == ScreenInfo->ScreenBufferSize.Y);
        StreamScrollRegion(ScreenInfo);

        if (ARGUMENT_PRESENT(ScrollY)) {
            *ScrollY += (SHORT)(ScreenInfo->ScreenBufferSize.Y - CursorPosition.Y - 1);
        }
        CursorPosition.Y += (SHORT)(ScreenInfo->ScreenBufferSize.Y - CursorPosition.Y - 1);
    }
#ifdef WWSB_FE
    else if (!(Console->InputBuffer.ImeMode.Disable) && Console->InputBuffer.ImeMode.Open)
    {
        if (CursorPosition.Y == (ScreenInfo->ScreenBufferSize.Y-1)) {
            ConsoleImeBottomLineUse(ScreenInfo,2);
            if (ARGUMENT_PRESENT(ScrollY)) {
                *ScrollY += (SHORT)(ScreenInfo->ScreenBufferSize.Y - CursorPosition.Y - 2);
            }
            CursorPosition.Y += (SHORT)(ScreenInfo->ScreenBufferSize.Y - CursorPosition.Y - 2);
            if (!ARGUMENT_PRESENT(ScrollY) && Console->lpCookedReadData) {
                ((PCOOKED_READ_DATA)(Console->lpCookedReadData))->OriginalCursorPosition.Y--;
            }
        }
        else if (CursorPosition.Y == ScreenInfo->Window.Bottom) {
            ;
        }
    }
#endif

    //
    // if at right or bottom edge of window, scroll right or down one char.
    //

#ifdef WWSB_FE
    if (CursorPosition.Y > ScreenInfo->Window.Bottom &&
        !(Console->InputBuffer.ImeMode.Open)
       )
#else
    if (CursorPosition.Y > ScreenInfo->Window.Bottom)
#endif
    {
        WindowOrigin.X = 0;
        WindowOrigin.Y = CursorPosition.Y - ScreenInfo->Window.Bottom;
        Status = SetWindowOrigin(ScreenInfo,
                               FALSE,
                               WindowOrigin
                              );
        if (!NT_SUCCESS(Status)) {
            return Status;
        }
    }
#ifdef WWSB_FE
    else if (Console->InputBuffer.ImeMode.Open)
    {
        if (CursorPosition.Y >= ScreenInfo->Window.Bottom &&
            CONSOLE_WINDOW_SIZE_Y(ScreenInfo) > 1
           ) {
            WindowOrigin.X = 0;
            WindowOrigin.Y = CursorPosition.Y - ScreenInfo->Window.Bottom + 1;
            Status = SetWindowOrigin(ScreenInfo,
                                        FALSE,
                                        WindowOrigin
                                       );
            if (!NT_SUCCESS(Status)) {
                return Status;
            }
        }
    }
#endif
    if (KeepCursorVisible) {
        MakeCursorVisible(ScreenInfo,CursorPosition);
    }
    Status = SetCursorPosition(ScreenInfo,
                               CursorPosition,
                               KeepCursorVisible
                              );
    return Status;
}

#define LOCAL_BUFFER_SIZE 100

NTSTATUS
WWSB_WriteChars(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PWCHAR lpBufferBackupLimit,
    IN PWCHAR lpBuffer,
    IN PWCHAR lpRealUnicodeString,
    IN OUT PDWORD NumBytes,
    OUT PLONG NumSpaces OPTIONAL,
    IN SHORT OriginalXPosition,
    IN DWORD dwFlags,
    OUT PSHORT ScrollY OPTIONAL
    )

/*++

Routine Description:

    This routine writes a string to the screen, processing any embedded
    unicode characters.  The string is also copied to the input buffer, if
    the output mode is line mode.

Arguments:

    ScreenInfo - Pointer to screen buffer information structure.

    lpBufferBackupLimit - Pointer to beginning of buffer.

    lpBuffer - Pointer to buffer to copy string to.  assumed to be at least
    as long as lpRealUnicodeString.  This pointer is updated to point to the
    next position in the buffer.

    lpRealUnicodeString - Pointer to string to write.

    NumBytes - On input, number of bytes to write.  On output, number of
    bytes written.

    NumSpaces - On output, the number of spaces consumed by the written characters.

    dwFlags -
      WC_DESTRUCTIVE_BACKSPACE backspace overwrites characters.
      WC_KEEP_CURSOR_VISIBLE   change window origin desirable when hit rt. edge
      WC_ECHO                  if called by Read (echoing characters)
      WC_FALSIFY_UNICODE       if RealUnicodeToFalseUnicode need be called.

Return Value:

Note:

    This routine does not process tabs and backspace properly.  That code
    will be implemented as part of the line editing services.

--*/

{
    DWORD BufferSize;
    COORD CursorPosition;
    NTSTATUS Status;
    ULONG NumChars;
    static WCHAR Blanks[TAB_SIZE] = { UNICODE_SPACE,
                                      UNICODE_SPACE,
                                      UNICODE_SPACE,
                                      UNICODE_SPACE,
                                      UNICODE_SPACE,
                                      UNICODE_SPACE,
                                      UNICODE_SPACE,
                                      UNICODE_SPACE };
    SHORT XPosition;
    WCHAR LocalBuffer[LOCAL_BUFFER_SIZE];
    PWCHAR LocalBufPtr;
    ULONG i,j;
    SMALL_RECT Region;
    ULONG TabSize;
    DWORD TempNumSpaces;
    WCHAR Char;
    WCHAR RealUnicodeChar;
    WORD Attributes;
    PWCHAR lpString;
    PWCHAR lpAllocatedString;
    BOOL fUnprocessed = ((ScreenInfo->OutputMode & ENABLE_PROCESSED_OUTPUT) == 0);
#ifdef WWSB_FE
    CHAR LocalBufferA[LOCAL_BUFFER_SIZE];
    PCHAR LocalBufPtrA;
#endif

    ConsoleHideCursor(ScreenInfo);

    Attributes = ScreenInfo->Attributes;
    BufferSize = *NumBytes;
    *NumBytes = 0;
    TempNumSpaces = 0;

    lpAllocatedString = NULL;
    if (dwFlags & WC_FALSIFY_UNICODE) {
        // translation from OEM -> ANSI -> OEM doesn't
        // necessarily yield the same value, so do
        // translation in a separate buffer.

        lpString = ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ),BufferSize);
        if (lpString == NULL) {
            Status = STATUS_NO_MEMORY;
            goto ExitWriteChars;
        }

        lpAllocatedString = lpString;
        RtlCopyMemory(lpString, lpRealUnicodeString, BufferSize);
        Status = RealUnicodeToFalseUnicode(lpString,
                                         BufferSize / sizeof(WCHAR),
                                         ScreenInfo->Console->OutputCP
                                        );
        if (!NT_SUCCESS(Status)) {
            goto ExitWriteChars;
        }
    } else {
       lpString = lpRealUnicodeString;
    }

    while (*NumBytes < BufferSize) {

        //
        // as an optimization, collect characters in buffer and
        // print out all at once.
        //

        XPosition = ScreenInfo->BufferInfo.TextInfo.CursorPosition.X;
        i=0;
        LocalBufPtr = LocalBuffer;
#ifdef WWSB_FE
        LocalBufPtrA = LocalBufferA;
#endif
        while (*NumBytes < BufferSize &&
               i < LOCAL_BUFFER_SIZE &&
               XPosition < ScreenInfo->ScreenBufferSize.X) {
            Char = *lpString;
            RealUnicodeChar = *lpRealUnicodeString;
            if (!IS_GLYPH_CHAR(RealUnicodeChar) || fUnprocessed) {
#ifdef WWSB_FE
                if (IsConsoleFullWidth(ScreenInfo->Console->hDC,
                                       ScreenInfo->Console->OutputCP,Char)) {
                    if (i < (LOCAL_BUFFER_SIZE-1) &&
                        XPosition < (ScreenInfo->ScreenBufferSize.X-1)) {
                        *LocalBufPtr++ = Char;
                        *LocalBufPtrA++ = ATTR_LEADING_BYTE;
                        *LocalBufPtr++ = Char;
                        *LocalBufPtrA++ = ATTR_TRAILING_BYTE;
                        XPosition+=2;
                        i+=2;
                        lpBuffer++;
                    }
                    else
                        goto EndWhile;
                }
                else {
#endif
                    *LocalBufPtr = Char;
                    LocalBufPtr++;
                    XPosition++;
                    i++;
                    lpBuffer++;
#ifdef WWSB_FE
                    *LocalBufPtrA++ = 0;
                }
#endif
            } else {
                ASSERT(ScreenInfo->OutputMode & ENABLE_PROCESSED_OUTPUT);
                switch (RealUnicodeChar) {
                    case UNICODE_BELL:
                        if (dwFlags & WC_ECHO) {
                            goto CtrlChar;
                        } else {
                            SendNotifyMessage(ScreenInfo->Console->hWnd,
                                              CM_BEEP,
                                              0,
                                              0x47474747);
                        }
                        break;
                    case UNICODE_BACKSPACE:

                        // automatically go to EndWhile.  this is because
                        // backspace is not destructive, so "aBkSp" prints
                        // a with the cursor on the "a". we could achieve
                        // this behavior staying in this loop and figuring out
                        // the string that needs to be printed, but it would
                        // be expensive and it's the exceptional case.

                        goto EndWhile;
                        break;
                    case UNICODE_TAB:
                        TabSize = NUMBER_OF_SPACES_IN_TAB(XPosition);
                        XPosition = (SHORT)(XPosition + TabSize);
                        if (XPosition >= ScreenInfo->ScreenBufferSize.X) {
                            goto EndWhile;
                        }
                        for (j=0;j<TabSize && i<LOCAL_BUFFER_SIZE;j++,i++) {
                            *LocalBufPtr = (WCHAR)' ';
                            LocalBufPtr++;
#ifdef WWSB_FE
                            *LocalBufPtrA++ = 0;
#endif
                        }
                        lpBuffer++;
                        break;
                    case UNICODE_LINEFEED:
                    case UNICODE_CARRIAGERETURN:
                        goto EndWhile;
                    default:

                        //
                        // if char is ctrl char, write ^char.
                        //

                        if ((dwFlags & WC_ECHO) && (IS_CONTROL_CHAR(RealUnicodeChar))) {

CtrlChar:                   if (i < (LOCAL_BUFFER_SIZE-1)) {
                                *LocalBufPtr = (WCHAR)'^';
                                LocalBufPtr++;
                                XPosition++;
                                i++;
                                *LocalBufPtr = (WCHAR)(RealUnicodeChar+(WCHAR)'@');
                                LocalBufPtr++;
                                XPosition++;
                                i++;
                                lpBuffer++;
#ifdef WWSB_FE
                                *LocalBufPtrA++ = 0;
                                *LocalBufPtrA++ = 0;
#endif
                            }
                            else {
                                goto EndWhile;
                            }
                        } else {
                            if (!(ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) ||
                                    (ScreenInfo->Console->FullScreenFlags & CONSOLE_FULLSCREEN)) {
                                /*
                                 * As a special favor to incompetent apps
                                 * that attempt to display control chars,
                                 * convert to corresponding OEM Glyph Chars
                                 */
#ifdef WWSB_FE
                                WORD CharType;

                                GetStringTypeW(CT_CTYPE1,&RealUnicodeChar,1,&CharType);
                                if (CharType == C1_CNTRL)
                                    ConvertOutputToUnicode(ScreenInfo->Console->OutputCP,
                                                           &(char)RealUnicodeChar,
                                                           1,
                                                           LocalBufPtr,
                                                           1);
                                else
                                    *LocalBufPtr = Char;
#else
                                *LocalBufPtr = SB_CharToWcharGlyph(
                                        ScreenInfo->Console->OutputCP,
                                        (char)RealUnicodeChar);
#endif
                            } else {
                                *LocalBufPtr = Char;
                            }
                            LocalBufPtr++;
                            XPosition++;
                            i++;
                            lpBuffer++;
#ifdef WWSB_FE
                            *LocalBufPtrA++ = 0;
#endif
                        }
                }
            }
            lpString++;
            lpRealUnicodeString++;
            *NumBytes += sizeof(WCHAR);
        }
EndWhile:
        if (i != 0) {

            //
            // Make sure we don't write past the end of the buffer.
            //

            if (i > (ULONG)ScreenInfo->ScreenBufferSize.X - ScreenInfo->BufferInfo.TextInfo.CursorPosition.X) {
                i = (ULONG)ScreenInfo->ScreenBufferSize.X - ScreenInfo->BufferInfo.TextInfo.CursorPosition.X;
            }

#ifdef WWSB_FE
            FE_StreamWriteToScreenBuffer(LocalBuffer,
                                         (SHORT)i,
                                         ScreenInfo,
                                         LocalBufferA
                                        );
#else
            SB_StreamWriteToScreenBuffer(LocalBuffer,
                                         (SHORT)i,
                                         ScreenInfo
                                        );
#endif
            Region.Left = ScreenInfo->BufferInfo.TextInfo.CursorPosition.X;
            Region.Right = (SHORT)(ScreenInfo->BufferInfo.TextInfo.CursorPosition.X + i - 1);
            Region.Top = ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y;
            Region.Bottom = ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y;
            WWSB_WriteToScreen(ScreenInfo,&Region);
            TempNumSpaces += i;
            CursorPosition.X = (SHORT)(ScreenInfo->BufferInfo.TextInfo.CursorPosition.X + i);
            CursorPosition.Y = ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y;
            Status = WWSB_AdjustCursorPosition(ScreenInfo,CursorPosition,
                    dwFlags & WC_KEEP_CURSOR_VISIBLE,ScrollY);
            if (*NumBytes == BufferSize) {
                ConsoleShowCursor(ScreenInfo);
                if (ARGUMENT_PRESENT(NumSpaces)) {
                    *NumSpaces = TempNumSpaces;
                }
                Status = STATUS_SUCCESS;
                goto ExitWriteChars;
            }
            continue;
        } else if (*NumBytes == BufferSize) {

            ASSERT(ScreenInfo->OutputMode & ENABLE_PROCESSED_OUTPUT);
            // this catches the case where the number of backspaces ==
            // the number of characters.
            if (ARGUMENT_PRESENT(NumSpaces)) {
                *NumSpaces = TempNumSpaces;
            }
            ConsoleShowCursor(ScreenInfo);
            Status = STATUS_SUCCESS;
            goto ExitWriteChars;
        }

        ASSERT(ScreenInfo->OutputMode & ENABLE_PROCESSED_OUTPUT);
        switch (*lpString) {
            case UNICODE_BACKSPACE:

                //
                // move cursor backwards one space. overwrite current char with blank.
                //
                // we get here because we have to backspace from the beginning of the line

                CursorPosition = ScreenInfo->BufferInfo.TextInfo.CursorPosition;
                TempNumSpaces -= 1;
                if (lpBuffer == lpBufferBackupLimit) {
                    CursorPosition.X-=1;
                }
                else {
                    PWCHAR pBuffer;
                    WCHAR TmpBuffer[LOCAL_BUFFER_SIZE];
                    PWCHAR Tmp,Tmp2;
                    WCHAR LastChar;
                    ULONG i;

                    if (lpBuffer-lpBufferBackupLimit > LOCAL_BUFFER_SIZE) {
                        pBuffer = (PWCHAR)ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ),(ULONG)(lpBuffer-lpBufferBackupLimit) * sizeof(WCHAR));
                        if (pBuffer == NULL) {
                            Status = STATUS_NO_MEMORY;
                            goto ExitWriteChars;
                        }
                    } else {
                        pBuffer = TmpBuffer;
                    }

                    for (i=0,Tmp2=pBuffer,Tmp=lpBufferBackupLimit;
                         i<(ULONG)(lpBuffer-lpBufferBackupLimit);
                         i++,Tmp++) {
                        if (*Tmp == UNICODE_BACKSPACE) {
                            if (Tmp2 > pBuffer) {
                                Tmp2--;
                            }
                        } else {
                            ASSERT(Tmp2 >= pBuffer);
                            *Tmp2++ = *Tmp;
                        }

                    }
                    if (Tmp2 == pBuffer) {
                        LastChar = (WCHAR)' ';
                    } else {
                        LastChar = *(Tmp2-1);
                    }
                    if (pBuffer != TmpBuffer) {
                        ConsoleHeapFree(pBuffer);
                    }

                    if (LastChar == UNICODE_TAB) {
                        CursorPosition.X -=
                            (SHORT)(RetrieveNumberOfSpaces(OriginalXPosition,
                                                           lpBufferBackupLimit,
                                                           (ULONG)(lpBuffer - lpBufferBackupLimit - 1),
                                                           ScreenInfo->Console,
                                                           ScreenInfo->Console->OutputCP
                                                          ));
                        if (CursorPosition.X < 0) {
                            CursorPosition.X = (ScreenInfo->ScreenBufferSize.X - 1)/TAB_SIZE;
                            CursorPosition.X *= TAB_SIZE;
                            CursorPosition.X += 1;
                            CursorPosition.Y -= 1;
                        }
                    }
                    else if (IS_CONTROL_CHAR(LastChar)) {
                        CursorPosition.X-=1;
                        TempNumSpaces -= 1;

                        //
                        // overwrite second character of ^x sequence.
                        //

                        if (dwFlags & WC_DESTRUCTIVE_BACKSPACE) {
                            NumChars = 1;
                            Status = WWSB_WriteOutputString(ScreenInfo,
                                Blanks, CursorPosition,
                                CONSOLE_FALSE_UNICODE, // faster than real unicode
                                &NumChars, NULL);
                            Status = WWSB_FillOutput(ScreenInfo,
                                Attributes, CursorPosition,
                                CONSOLE_ATTRIBUTE, &NumChars);
                        }
                        CursorPosition.X-=1;
                    }
#ifdef WWSB_FE
                    else if (IsConsoleFullWidth(ScreenInfo->Console->hDC,
                                                ScreenInfo->Console->OutputCP,LastChar))
                    {
                        CursorPosition.X-=1;
                        TempNumSpaces -= 1;

                        Status = WWSB_AdjustCursorPosition(ScreenInfo,CursorPosition,
                                     dwFlags & WC_KEEP_CURSOR_VISIBLE,ScrollY);
                        if (dwFlags & WC_DESTRUCTIVE_BACKSPACE) { // bug 7672
                            NumChars = 1;
                            Status = WWSB_WriteOutputString(ScreenInfo,
                                Blanks, ScreenInfo->BufferInfo.TextInfo.CursorPosition,
                                CONSOLE_FALSE_UNICODE, // faster than real unicode
                                &NumChars, NULL);
                            Status = WWSB_FillOutput(ScreenInfo,
                                Attributes, ScreenInfo->BufferInfo.TextInfo.CursorPosition,
                                CONSOLE_ATTRIBUTE, &NumChars);
                        }
                        CursorPosition.X-=1;
                    }
#endif
                    else {
                        CursorPosition.X--;
                    }
                }
                if ((dwFlags & WC_LIMIT_BACKSPACE) && (CursorPosition.X < 0)) {
                    CursorPosition.X = 0;
                    KdPrint(("CONSRV: Ignoring backspace to previous line\n"));
                }
                Status = WWSB_AdjustCursorPosition(ScreenInfo,CursorPosition,
                        (dwFlags & WC_KEEP_CURSOR_VISIBLE) != 0,ScrollY);
                if (dwFlags & WC_DESTRUCTIVE_BACKSPACE) {
                    NumChars = 1;
                    Status = WWSB_WriteOutputString(ScreenInfo,
                        Blanks, ScreenInfo->BufferInfo.TextInfo.CursorPosition,
                        CONSOLE_FALSE_UNICODE, //faster than real unicode
                        &NumChars, NULL);
                    Status = WWSB_FillOutput(ScreenInfo,
                        Attributes, ScreenInfo->BufferInfo.TextInfo.CursorPosition,
                        CONSOLE_ATTRIBUTE, &NumChars);
                }
#ifdef WWSB_FE
                if (ScreenInfo->BufferInfo.TextInfo.CursorPosition.X == 0 &&
                    (ScreenInfo->OutputMode & ENABLE_WRAP_AT_EOL_OUTPUT) &&
                    lpBuffer > lpBufferBackupLimit) {
                    if (CheckBisectProcessW(ScreenInfo,
                                            ScreenInfo->Console->OutputCP,
                                            lpBufferBackupLimit,
                                            (ULONG)(lpBuffer+1-lpBufferBackupLimit),
                                            ScreenInfo->ScreenBufferSize.X-OriginalXPosition,
                                            OriginalXPosition,
                                            dwFlags & WC_ECHO)) {
                        CursorPosition.X = ScreenInfo->ScreenBufferSize.X-1;
                        CursorPosition.Y = (SHORT)(ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y-1);
                        Status = WWSB_AdjustCursorPosition(ScreenInfo,CursorPosition,
                                     dwFlags & WC_KEEP_CURSOR_VISIBLE,ScrollY);
                    }
                }
#endif
                break;
            case UNICODE_TAB:
                TabSize = NUMBER_OF_SPACES_IN_TAB(ScreenInfo->BufferInfo.TextInfo.CursorPosition.X);
                CursorPosition.X = (SHORT)(ScreenInfo->BufferInfo.TextInfo.CursorPosition.X + TabSize);

                //
                // move cursor forward to next tab stop.  fill space with blanks.
                // we get here when the tab extends beyond the right edge of the
                // window.  if the tab goes wraps the line, set the cursor to the first
                // position in the next line.
                //

                lpBuffer++;

                TempNumSpaces += TabSize;
                if (CursorPosition.X >= ScreenInfo->ScreenBufferSize.X) {
                    NumChars = ScreenInfo->ScreenBufferSize.X - ScreenInfo->BufferInfo.TextInfo.CursorPosition.X;
                    CursorPosition.X = 0;
                    CursorPosition.Y = ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y+1;
                }
                else {
                    NumChars = CursorPosition.X - ScreenInfo->BufferInfo.TextInfo.CursorPosition.X;
                    CursorPosition.Y = ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y;
                }
                Status = WWSB_WriteOutputString(ScreenInfo,
                                                Blanks,
                                                ScreenInfo->BufferInfo.TextInfo.CursorPosition,
                                                CONSOLE_FALSE_UNICODE, // faster than real unicode
                                                &NumChars,
                                                NULL);
                Status = WWSB_FillOutput(ScreenInfo,
                                         Attributes, ScreenInfo->BufferInfo.TextInfo.CursorPosition,
                                         CONSOLE_ATTRIBUTE,
                                         &NumChars);
                Status = WWSB_AdjustCursorPosition(ScreenInfo,CursorPosition,
                        (dwFlags & WC_KEEP_CURSOR_VISIBLE) != 0,ScrollY);
                break;
            case UNICODE_CARRIAGERETURN:

                //
                // Carriage return moves the cursor to the beginning of the line.
                // We don't need to worry about handling cr or lf for
                // backspace because input is sent to the user on cr or lf.
                //

                lpBuffer++;
                CursorPosition.X = 0;
                CursorPosition.Y = ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y;
                Status = WWSB_AdjustCursorPosition(ScreenInfo,CursorPosition,
                        (dwFlags & WC_KEEP_CURSOR_VISIBLE) != 0,ScrollY);
                break;
            case UNICODE_LINEFEED:

                //
                // move cursor to the beginning of the next line.
                //

                lpBuffer++;
                CursorPosition.X = 0;
                CursorPosition.Y = (SHORT)(ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y+1);
                Status = WWSB_AdjustCursorPosition(ScreenInfo,CursorPosition,
                        (dwFlags & WC_KEEP_CURSOR_VISIBLE) != 0,ScrollY);
                break;
            default:
#ifdef WWSB_FE
                Char = *lpString;
                if (Char >= (WCHAR)' ' &&
                    IsConsoleFullWidth(ScreenInfo->Console->hDC,
                                       ScreenInfo->Console->OutputCP,Char) &&
                    XPosition >= (ScreenInfo->ScreenBufferSize.X-1) &&
                    (ScreenInfo->OutputMode & ENABLE_WRAP_AT_EOL_OUTPUT)) {

                    SHORT RowIndex;
                    PROW Row;
                    PWCHAR Char;
                    COORD TargetPoint;
                    PCHAR AttrP;

                    TargetPoint = ScreenInfo->BufferInfo.TextInfo.CursorPosition;
                    RowIndex = (ScreenInfo->BufferInfo.TextInfo.FirstRow+TargetPoint.Y) % ScreenInfo->ScreenBufferSize.Y;
                    Row = &ScreenInfo->BufferInfo.TextInfo.Rows[RowIndex];
                    Char = &Row->CharRow.Chars[TargetPoint.X];
                    AttrP = &Row->CharRow.KAttrs[TargetPoint.X];

                    if (*AttrP & ATTR_TRAILING_BYTE)
                    {
                        *(Char-1) = UNICODE_SPACE;
                        *Char = UNICODE_SPACE;
                        *AttrP = 0;
                        *(AttrP-1) = 0;

                        Region.Left = ScreenInfo->BufferInfo.TextInfo.CursorPosition.X-1;
                        Region.Right = (SHORT)(ScreenInfo->BufferInfo.TextInfo.CursorPosition.X);
                        Region.Top = ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y;
                        Region.Bottom = ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y;
                        WWSB_WriteToScreen(ScreenInfo,&Region);
                    }

                    CursorPosition.X = 0;
                    CursorPosition.Y = (SHORT)(ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y+1);
                    Status = WWSB_AdjustCursorPosition(ScreenInfo,CursorPosition,
                                 dwFlags & WC_KEEP_CURSOR_VISIBLE,ScrollY);
                    continue;
                }
#endif
                break;
        }
        if (!NT_SUCCESS(Status)) {
            ConsoleShowCursor(ScreenInfo);
            goto ExitWriteChars;
        }

       *NumBytes += sizeof(WCHAR);
       lpString++;
       lpRealUnicodeString++;
    }

    if (ARGUMENT_PRESENT(NumSpaces)) {
        *NumSpaces = TempNumSpaces;
    }
    ConsoleShowCursor(ScreenInfo);

    Status = STATUS_SUCCESS;

ExitWriteChars:
    if (lpAllocatedString) {
        ConsoleHeapFree(lpAllocatedString);
    }
    return Status;
}

ULONG
WWSB_DoWriteConsole(
    IN OUT PCSR_API_MSG m,
    IN PCONSOLE_INFORMATION Console,
    IN PCSR_THREAD Thread
    )

//
// NOTE: console lock must be held when calling this routine
//
// string has been translated to unicode at this point
//

{
    PCONSOLE_WRITECONSOLE_MSG a = (PCONSOLE_WRITECONSOLE_MSG)&m->u.ApiMessageData;
    PHANDLE_DATA HandleData;
    NTSTATUS Status;
    PSCREEN_INFORMATION ScreenInfo;
    DWORD NumCharsToWrite;
#ifdef WWSB_FE
    DWORD i;
    SHORT j;
#endif

    if (Console->Flags & (CONSOLE_SUSPENDED | CONSOLE_SELECTING | CONSOLE_SCROLLBAR_TRACKING)) {
        PWCHAR TransBuffer;

        TransBuffer = (PWCHAR)ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ),a->NumBytes);
        if (TransBuffer == NULL) {
            return (ULONG)STATUS_NO_MEMORY;
        }
        RtlCopyMemory(TransBuffer,a->TransBuffer,a->NumBytes);
        a->TransBuffer = TransBuffer;
        a->StackBuffer = FALSE;
        if (!CsrCreateWait(&Console->OutputQueue,
                          WriteConsoleWaitRoutine,
                          Thread,
                          m,
                          NULL,
                          NULL
                         )) {
            ConsoleHeapFree(TransBuffer);
            return (ULONG)STATUS_NO_MEMORY;
        }
        return (ULONG)CONSOLE_STATUS_WAIT;
    }

    Status = DereferenceIoHandle(CONSOLE_FROMTHREADPERPROCESSDATA(Thread),
                                 a->OutputHandle,
                                 CONSOLE_OUTPUT_HANDLE,
                                 GENERIC_WRITE,
                                 &HandleData
                                );
    if (!NT_SUCCESS(Status)) {
        a->NumBytes = 0;
        return((ULONG) Status);
    }

    ScreenInfo = HandleData->Buffer.ScreenBuffer;

    //
    // see if we're the typical case - a string containing no special
    // characters, optionally terminated with CRLF.  if so, skip the
    // special processing.
    //

    NumCharsToWrite=a->NumBytes/sizeof(WCHAR);
    if ((ScreenInfo->OutputMode & ENABLE_PROCESSED_OUTPUT) &&
        ((LONG)(ScreenInfo->BufferInfo.TextInfo.CursorPosition.X + NumCharsToWrite) <
          ScreenInfo->ScreenBufferSize.X) ) {
        SMALL_RECT Region;
        COORD CursorPosition;

        if (a->Unicode) {
#ifdef WWSB_FE
            a->WriteFlags = WRITE_SPECIAL_CHARS;
#else
            a->WriteFlags = FastStreamWrite(a->TransBuffer,NumCharsToWrite);
#endif
        }
        if (a->WriteFlags == WRITE_SPECIAL_CHARS) {
            goto ProcessedWrite;
        }

        ConsoleHideCursor(ScreenInfo);

        //
        // WriteFlags is designed so that the number of special characters
        // is also the flag value.
        //

        NumCharsToWrite -= a->WriteFlags;

        if (NumCharsToWrite) {
#ifdef WWSB_FE
            PWCHAR TransBuffer,TransBufPtr,String;
            PBYTE TransBufferA,TransBufPtrA;
            BOOL fLocalHeap = FALSE;
            COORD TargetPoint;

            if (NumCharsToWrite > (ULONG)(ScreenInfo->ScreenBufferSize.X * ScreenInfo->ScreenBufferSize.Y)) {

                TransBuffer = (PWCHAR)ConsoleHeapAlloc(MAKE_TAG( TMP_DBCS_TAG ),NumCharsToWrite * 2 * sizeof(WCHAR));
                if (TransBuffer == NULL) {
                    return (ULONG)STATUS_NO_MEMORY;
                }
                TransBufferA = (PCHAR)ConsoleHeapAlloc(MAKE_TAG( TMP_DBCS_TAG ),NumCharsToWrite * 2 * sizeof(CHAR));
                if (TransBufferA == NULL) {
                    ConsoleHeapFree(TransBuffer);
                    return (ULONG)STATUS_NO_MEMORY;
                }

                fLocalHeap = TRUE;
            }
            else {
                TransBuffer  = ScreenInfo->BufferInfo.TextInfo.DbcsScreenBuffer.TransBufferCharacter;
                TransBufferA = ScreenInfo->BufferInfo.TextInfo.DbcsScreenBuffer.TransBufferAttribute;
            }

            String = a->TransBuffer;
            TransBufPtr = TransBuffer;
            TransBufPtrA = TransBufferA;
            for (i = 0 , j = 0 ; i < NumCharsToWrite ; i++,j++){
                if (IsConsoleFullWidth(ScreenInfo->Console->hDC,
                                       ScreenInfo->Console->OutputCP,*String)){
                    *TransBuffer++ = *String ;
                    *TransBufferA++ = ATTR_LEADING_BYTE;
                    *TransBuffer++ = *String++ ;
                    *TransBufferA++ = ATTR_TRAILING_BYTE;
                    j++;
                }
                else{
                    *TransBuffer++ = *String++ ;
                    *TransBufferA++ = 0;
                }
            }
            TargetPoint = ScreenInfo->BufferInfo.TextInfo.CursorPosition;
            BisectWrite(j,TargetPoint,ScreenInfo);
            if (TargetPoint.Y == ScreenInfo->ScreenBufferSize.Y-1 &&
                TargetPoint.X+j >= ScreenInfo->ScreenBufferSize.X &&
                *(TransBufPtrA+j) & ATTR_LEADING_BYTE){
                *(TransBufPtr+ScreenInfo->ScreenBufferSize.X-TargetPoint.X-1) = UNICODE_SPACE;
                *(TransBufPtrA+ScreenInfo->ScreenBufferSize.X-TargetPoint.X-1) = 0;
                if (j > ScreenInfo->ScreenBufferSize.X-TargetPoint.X-1) {
                    *(TransBufPtr+ScreenInfo->ScreenBufferSize.X-TargetPoint.X) = UNICODE_SPACE;
                    *(TransBufPtrA+ScreenInfo->ScreenBufferSize.X-TargetPoint.X) = 0;
                }
            }
            FE_StreamWriteToScreenBuffer(TransBufPtr,
                                         (SHORT)j,
                                         ScreenInfo,
                                         TransBufPtrA
                                        );
            if (fLocalHeap){
                ConsoleHeapFree(TransBufPtr);
                ConsoleHeapFree(TransBufPtrA);
            }
#else
            SB_StreamWriteToScreenBuffer(a->TransBuffer,
                                         (SHORT)NumCharsToWrite,
                                         ScreenInfo
                                        );
#endif
            Region.Left = ScreenInfo->BufferInfo.TextInfo.CursorPosition.X;
#ifdef WWSB_FE
            Region.Right = (SHORT)(ScreenInfo->BufferInfo.TextInfo.CursorPosition.X + j - 1);
#else
            Region.Right = (SHORT)(ScreenInfo->BufferInfo.TextInfo.CursorPosition.X + NumCharsToWrite - 1);
#endif
            Region.Top = ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y;
            Region.Bottom = ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y;
            ASSERT (Region.Right < ScreenInfo->ScreenBufferSize.X);
            if (ACTIVE_SCREEN_BUFFER(ScreenInfo) &&
                !(ScreenInfo->Console->Flags & CONSOLE_IS_ICONIC && ScreenInfo->Console->FullScreenFlags == 0)) {
                WWSB_WriteRegionToScreen(ScreenInfo,&Region);
            }
        }
        switch (a->WriteFlags) {
            case WRITE_NO_CR_LF:
                CursorPosition.X = (SHORT)(ScreenInfo->BufferInfo.TextInfo.CursorPosition.X + NumCharsToWrite);
                CursorPosition.Y = ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y;
                break;
            case WRITE_CR:
                CursorPosition.X = 0;
                CursorPosition.Y = ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y;
                break;
            case WRITE_CR_LF:
                CursorPosition.X = 0;
                CursorPosition.Y = ScreenInfo->BufferInfo.TextInfo.CursorPosition.Y+1;
                break;
            default:
                ASSERT(FALSE);
                break;
        }
        Status = WWSB_AdjustCursorPosition(ScreenInfo,CursorPosition,FALSE,NULL);
        ConsoleShowCursor(ScreenInfo);
        return STATUS_SUCCESS;
    }
ProcessedWrite:
    return WWSB_WriteChars(ScreenInfo,
                      a->TransBuffer,
                      a->TransBuffer,
                      a->TransBuffer,
                      &a->NumBytes,
                      NULL,
                      ScreenInfo->BufferInfo.TextInfo.CursorPosition.X,
                      WC_LIMIT_BACKSPACE,
                      NULL
                     );
}

NTSTATUS
WWSB_DoSrvWriteConsole(
    IN OUT PCSR_API_MSG m,
    IN OUT PCSR_REPLY_STATUS ReplyStatus,
    IN PCONSOLE_INFORMATION Console,
    IN PHANDLE_DATA HandleData
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PCONSOLE_WRITECONSOLE_MSG a = (PCONSOLE_WRITECONSOLE_MSG)&m->u.ApiMessageData;
    PSCREEN_INFORMATION ScreenInfo;
    WCHAR StackBuffer[STACK_BUFFER_SIZE];
#ifdef WWSB_FE
    BOOL  fLocalHeap = FALSE;
#endif

    ScreenInfo = HandleData->Buffer.ScreenBuffer;

#ifdef WWSB_FE
    // Check code for must CONSOLE_TEXTMODE_BUFFER !!
    ASSERT(!(ScreenInfo->Flags & CONSOLE_GRAPHICS_BUFFER));
#endif

    //
    // if the string was passed in the message, rather than in
    // a capture buffer, adjust the pointer.
    //

    if (a->BufferInMessage) {
        a->BufPtr = a->Buffer;
    }

    //
    // if ansi, translate string.  for speed, we don't allocate a
    // capture buffer if the ansi string was <= 80 chars.  if it's
    // greater than 80 / sizeof(WCHAR), the translated string won't
    // fit into the capture buffer, so reset a->BufPtr to point to
    // a heap buffer and set a->CaptureBufferSize so that we don't
    // think the buffer is in the message.
    //

    if (!a->Unicode) {
        PWCHAR TransBuffer;
        DWORD Length;
        DWORD SpecialChars = 0;
        UINT Codepage;
#ifdef WWSB_FE
        PWCHAR TmpTransBuffer;
        ULONG NumBytes1 = 0;
        ULONG NumBytes2 = 0;
#endif

        if (a->NumBytes <= STACK_BUFFER_SIZE) {
            TransBuffer = StackBuffer;
            a->StackBuffer = TRUE;
#ifdef WWSB_FE
            TmpTransBuffer = TransBuffer;
#endif
        }
#ifdef WWSB_FE
        else if (a->NumBytes > (ULONG)(ScreenInfo->ScreenBufferSize.X * ScreenInfo->ScreenBufferSize.Y)) {
            TransBuffer = (PWCHAR)ConsoleHeapAlloc(MAKE_TAG( TMP_DBCS_TAG ),(a->NumBytes+2) * sizeof(WCHAR));
            if (TransBuffer == NULL) {
                return (ULONG)STATUS_NO_MEMORY;
            }
            TmpTransBuffer = TransBuffer;
            a->StackBuffer = FALSE;
            fLocalHeap = TRUE;
        }
        else {
            TransBuffer = ScreenInfo->BufferInfo.TextInfo.DbcsScreenBuffer.TransWriteConsole;
            TmpTransBuffer = TransBuffer;
        }
#else
        else {
            TransBuffer = (PWCHAR)ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ),a->NumBytes * sizeof(WCHAR));
            if (TransBuffer == NULL) {
                return (ULONG)STATUS_NO_MEMORY;
            }
            a->StackBuffer = FALSE;
        }
#endif
        //a->NumBytes = ConvertOutputToUnicode(Console->OutputCP,
        //                        Buffer,
        //                        a->NumBytes,
        //                        TransBuffer,
        //                        a->NumBytes);
        // same as ConvertOutputToUnicode
#ifdef WWSB_FE
        if (! ScreenInfo->WriteConsoleDbcsLeadByte[0]) {
            NumBytes1 = 0;
            NumBytes2 = a->NumBytes;
        }
        else {
            if (*(PUCHAR)a->BufPtr < (UCHAR)' ') {
                NumBytes1 = 0;
                NumBytes2 = a->NumBytes;
            }
            else if (a->NumBytes) {
                ScreenInfo->WriteConsoleDbcsLeadByte[1] = *(PCHAR)a->BufPtr;
                NumBytes1 = sizeof(ScreenInfo->WriteConsoleDbcsLeadByte);
                if (Console->OutputCP == OEMCP) {
                    if ((ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) &&
                            ((Console->FullScreenFlags & CONSOLE_FULLSCREEN) == 0)) {
                        /*
                         * Translate OEM characters into False Unicode for Window-mode
                         * OEM font. If OutputCP != OEMCP, characters will not appear
                         * correctly, because the OEM fonts are designed to support
                         * only OEMCP (we can't switch fonts in Windowed mode).
                         * Fullscreen or TT "Unicode" fonts should be used for
                         * non-OEMCP output
                         */
                        DBGCHARS(("SrvWriteConsole ACP->U %.*s\n",
                                min(NumBytes1,10), a->BufPtr));
                        Status = RtlConsoleMultiByteToUnicodeN(TransBuffer,
                                NumBytes1 * sizeof(WCHAR), &NumBytes1,
                                ScreenInfo->WriteConsoleDbcsLeadByte, NumBytes1, &SpecialChars);
                    } else {
                        /*
                         * Good! We have Fullscreen or TT "Unicode" fonts, so convert
                         * the OEM characters to real Unicode according to OutputCP.
                         * First find out if any special chars are involved.
                         */
                        DBGCHARS(("SrvWriteConsole %d->U %.*s\n", Console->OutputCP,
                                min(NumBytes1,10), a->BufPtr));
                        NumBytes1 = sizeof(WCHAR) * MultiByteToWideChar(Console->OutputCP,
                                0, ScreenInfo->WriteConsoleDbcsLeadByte, NumBytes1, TransBuffer, NumBytes1);
                        if (NumBytes1 == 0) {
                            Status = STATUS_UNSUCCESSFUL;
                        }
                    }
                }
                else {
                    if ((ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) &&
                        !(Console->FullScreenFlags & CONSOLE_FULLSCREEN)) {
                        if (Console->OutputCP != WINDOWSCP)
                            Codepage = USACP;
                        else
                            Codepage = WINDOWSCP;
                    } else {
                        Codepage = Console->OutputCP;
                    }

                    if ((ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) &&
                            ((Console->FullScreenFlags & CONSOLE_FULLSCREEN) == 0)) {
                        NumBytes1 = ConvertOutputToUnicode(Codepage,
                                                           ScreenInfo->WriteConsoleDbcsLeadByte,
                                                           NumBytes1,
                                                           TransBuffer,
                                                           NumBytes1);
                    }
                    else {
                        NumBytes1 = MultiByteToWideChar(Console->OutputCP,
                                0, ScreenInfo->WriteConsoleDbcsLeadByte, NumBytes1, TransBuffer, NumBytes1);
                        if (NumBytes1 == 0) {
                            Status = STATUS_UNSUCCESSFUL;
                        }
                    }
                    NumBytes1 *= sizeof(WCHAR);
                }
                TransBuffer++;
                (PCHAR)a->BufPtr += (NumBytes1 / sizeof(WCHAR));
                NumBytes2 = a->NumBytes - 1;
            }
            else {
                NumBytes2 = 0;
            }
            ScreenInfo->WriteConsoleDbcsLeadByte[0] = 0;
        }

        if (NumBytes2 &&
            CheckBisectStringA(Console->OutputCP,a->BufPtr,NumBytes2,&Console->OutputCPInfo)) {
            ScreenInfo->WriteConsoleDbcsLeadByte[0] = *((PCHAR)a->BufPtr+NumBytes2-1);
            NumBytes2--;
        }

        Length = NumBytes2;
#else
        Length = a->NumBytes;
        if (a->NumBytes >= 2 &&
            ((PCHAR)a->BufPtr)[a->NumBytes-1] == '\n' &&
            ((PCHAR)a->BufPtr)[a->NumBytes-2] == '\r') {
            Length -= 2;
            a->WriteFlags = WRITE_CR_LF;
        } else if (a->NumBytes >= 1 &&
                   ((PCHAR)a->BufPtr)[a->NumBytes-1] == '\r') {
            Length -= 1;
            a->WriteFlags = WRITE_CR;
        } else {
            a->WriteFlags = WRITE_NO_CR_LF;
        }
#endif

        if (Length != 0) {
            if (Console->OutputCP == OEMCP) {
                if ((ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) &&
                        ((Console->FullScreenFlags & CONSOLE_FULLSCREEN) == 0)) {
                    /*
                     * Translate OEM characters into UnicodeOem for the Window-mode
                     * OEM font. If OutputCP != OEMCP, characters will not appear
                     * correctly, because the OEM fonts are designed to support
                     * only OEMCP (we can't switch fonts in Windowed mode).
                     * Fullscreen or TT "Unicode" fonts should be used for
                     * non-OEMCP output
                     */
                    DBGCHARS(("SrvWriteConsole ACP->U %.*s\n",
                            min(Length,10), a->BufPtr));
                    Status = RtlConsoleMultiByteToUnicodeN(TransBuffer,
                            Length * sizeof(WCHAR), &Length,
                            a->BufPtr, Length, &SpecialChars);
                } else {
                    /*
                     * Good! We have Fullscreen or TT "Unicode" fonts, so convert
                     * the OEM characters to real Unicode according to OutputCP.
                     * First find out if any special chars are involved.
                     */
#ifdef WWSB_NOFE
                    UINT i;
                    for (i = 0; i < Length; i++) {
                        if (((PCHAR)a->BufPtr)[i] < 0x20) {
                            SpecialChars = 1;
                            break;
                        }
                    }
#endif
                    DBGCHARS(("SrvWriteConsole %d->U %.*s\n", Console->OutputCP,
                            min(Length,10), a->BufPtr));
                    Length = sizeof(WCHAR) * MultiByteToWideChar(Console->OutputCP,
                            0, a->BufPtr, Length, TransBuffer, Length);
                    if (Length == 0) {
                        Status = STATUS_UNSUCCESSFUL;
                    }
                }
            }
            else
            {
                if ((ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) &&
                    !(Console->FullScreenFlags & CONSOLE_FULLSCREEN)) {
                    if (Console->OutputCP != WINDOWSCP)
                        Codepage = USACP;
                    else
                        Codepage = WINDOWSCP;
                } else {
                    Codepage = Console->OutputCP;
                }

                if ((ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) &&
                        ((Console->FullScreenFlags & CONSOLE_FULLSCREEN) == 0)) {
                    Length = sizeof(WCHAR) * ConvertOutputToUnicode(Codepage,
                                                                    a->BufPtr,
                                                                    Length,
                                                                    TransBuffer,
                                                                    Length);
                }
                else {
                    Length = sizeof(WCHAR) * MultiByteToWideChar(Console->OutputCP,
                            0, a->BufPtr, Length, TransBuffer, Length);
                    if (Length == 0) {
                        Status = STATUS_UNSUCCESSFUL;
                    }
                }

#ifdef WWSB_NOFE
                SpecialChars = 1;
#endif
            }
        }

#ifdef WWSB_FE
        NumBytes2 = Length;

        if ((NumBytes1+NumBytes2) == 0) {
            if (!a->StackBuffer && fLocalHeap) {
                ConsoleHeapFree(a->TransBuffer);
            }
            return Status;
        }
#else
        if (!NT_SUCCESS(Status)) {
            if (!a->StackBuffer) {
                ConsoleHeapFree(TransBuffer);
            }
            return Status;
        }
#endif

#ifdef WWSB_FE
        Console->WriteConOutNumBytesTemp = a->NumBytes;
        a->NumBytes = Console->WriteConOutNumBytesUnicode = NumBytes1 + NumBytes2;
        a->WriteFlags = WRITE_SPECIAL_CHARS;
        a->TransBuffer = TmpTransBuffer;
#else
        DBGOUTPUT(("TransBuffer=%lx, Length = %x(bytes), SpecialChars=%lx\n",
                TransBuffer, Length, SpecialChars));
        a->NumBytes = Length + (a->WriteFlags * sizeof(WCHAR));
        if (a->WriteFlags == WRITE_CR_LF) {
            TransBuffer[(Length+sizeof(WCHAR))/sizeof(WCHAR)] = UNICODE_LINEFEED;
            TransBuffer[Length/sizeof(WCHAR)] = UNICODE_CARRIAGERETURN;
        } else if (a->WriteFlags == WRITE_CR) {
            TransBuffer[Length/sizeof(WCHAR)] = UNICODE_CARRIAGERETURN;
        }
        if (SpecialChars) {
            // CRLF didn't get translated
            a->WriteFlags = WRITE_SPECIAL_CHARS;
        }
        a->TransBuffer = TransBuffer;
#endif
    } else {
        if ((ScreenInfo->Flags & CONSOLE_OEMFONT_DISPLAY) &&
                    ((Console->FullScreenFlags & CONSOLE_FULLSCREEN) == 0)) {
            Status = RealUnicodeToFalseUnicode(a->BufPtr,
                    a->NumBytes / sizeof(WCHAR), Console->OutputCP);
            if (!NT_SUCCESS(Status)) {
                return Status;
            }
        }
        a->WriteFlags = (DWORD)-1;
        a->TransBuffer = a->BufPtr;
    }
    Status = WWSB_DoWriteConsole(m,Console,CSR_SERVER_QUERYCLIENTTHREAD());
    if (Status == CONSOLE_STATUS_WAIT) {
        *ReplyStatus = CsrReplyPending;
        return (ULONG)STATUS_SUCCESS;
    } else {
        if (!a->Unicode) {
#ifdef WWSB_FE
            if (a->NumBytes == Console->WriteConOutNumBytesUnicode)
                a->NumBytes = Console->WriteConOutNumBytesTemp;
            else
                a->NumBytes /= sizeof(WCHAR);
            if (!a->StackBuffer && fLocalHeap) {
                ConsoleHeapFree(a->TransBuffer);
            }
#else
            a->NumBytes /= sizeof(WCHAR);
            if (!a->StackBuffer) {
                ConsoleHeapFree(a->TransBuffer);
            }
#endif
        }
    }
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\test\alloc\alloc.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    talloc.c

Abstract:

    Test program for AllocConsole and FreeConsole

Author:

    Therese Stowell (thereses) July-15-1991

--*/

#include <windows.h>

CHAR String[11] = "teststring";

HANDLE
TestProcess(
    IN DWORD CreationFlags,
    IN LPSTR AppName
    )
{
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInformation;
    SECURITY_ATTRIBUTES ProcessAttributes;

    ProcessAttributes.nLength = sizeof(SECURITY_ATTRIBUTES);
    ProcessAttributes.lpSecurityDescriptor = NULL;
    ProcessAttributes.bInheritHandle = TRUE;

    StartupInfo.cb = sizeof(StartupInfo);
    StartupInfo.lpReserved = "UsedByShell";
    StartupInfo.lpDesktop = "TheresesDesktop";
    StartupInfo.lpTitle = "TheresesTestTitle";
    StartupInfo.dwX = 0;
    StartupInfo.dwY = 1;
    StartupInfo.dwXSize = 80;
    StartupInfo.dwYSize = 50;
    StartupInfo.dwFlags = 0;//STARTF_SHELLOVERRIDE;
    StartupInfo.wShowWindow = 0;//SW_SHOWDEFAULT;
    StartupInfo.lpReserved2 = 0;
    StartupInfo.cbReserved2 = 0;

    if  ( !CreateProcess(
                NULL,
                AppName,
                &ProcessAttributes,
                NULL,
                TRUE,
                CreationFlags,
                NULL,
                NULL,
                &StartupInfo,
                &ProcessInformation
                ) )
        OutputDebugString("TALLOC: CreateProcess failed\n");
    return ProcessInformation.hProcess;
}

BOOL
CallConsoleApi(
    IN WORD y
    )
{
    CHAR_INFO Buffer[10];
    COORD BufferSize;
    COORD BufferCoord;
    SMALL_RECT WriteRegion;
    int i;
    BOOL Success;

    BufferSize.X = 10;
    BufferSize.Y = 1;
    BufferCoord.X = 0;
    BufferCoord.Y = 0;
    WriteRegion.Left = 0;
    WriteRegion.Top = y;
    WriteRegion.Right = 14;
    WriteRegion.Bottom = y;
    for (i=0;i<10;i++) {
        Buffer[i].Char.AsciiChar = String[i];
        Buffer[i].Attributes = y;
    }
    Success = WriteConsoleOutput(GetStdHandle(STD_OUTPUT_HANDLE),
                                 Buffer,
                                 BufferSize,
                                 BufferCoord,
                                 &WriteRegion
                                );
    return Success;
}

DWORD
__cdecl main(
    int argc,
    char **argv[])
{
    if (CallConsoleApi(5))
        OutputDebugString("TALLOC: CallConsoleApi succeeded\n");

    if (!AllocConsole())
        OutputDebugString("TALLOC: AllocConsole failed\n");

    if (!CallConsoleApi(5))
        OutputDebugString("TALLOC: CallConsoleApi failed\n");

    if (AllocConsole())
        OutputDebugString("TALLOC: AllocConsole succeeded\n");

    TestProcess(DETACHED_PROCESS,"tdetach");

    TestProcess(0,"tattach");

    Sleep(10000);

    if (!CallConsoleApi(6))
        OutputDebugString("TALLOC: CallConsoleApi failed\n");

    if (!FreeConsole())
        OutputDebugString("TALLOC: FreeConsole failed\n");

    if (CallConsoleApi(5))
        OutputDebugString("TALLOC: CallConsoleApi succeeded\n");

    if (FreeConsole())
        OutputDebugString("TALLOC: FreeConsole succeeded\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\test\attach\attach.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    tdetach.c

Abstract:

    Test program for detached processes

Author:

    Therese Stowell (thereses) July-15-1991

Revision History:

--*/

#include <windows.h>

CHAR String[11] = "attachedpr";

BOOL
CallConsoleApi(
    IN WORD y
    )
{
    CHAR_INFO Buffer[10];
    COORD BufferSize;
    COORD BufferCoord;
    SMALL_RECT WriteRegion;
    int i;
    BOOL Success;

    BufferSize.X = 10;
    BufferSize.Y = 1;
    BufferCoord.X = 0;
    BufferCoord.Y = 0;
    WriteRegion.Left = 0;
    WriteRegion.Top = y;
    WriteRegion.Right = 14;
    WriteRegion.Bottom = y;
    for (i=0;i<10;i++) {
        Buffer[i].Char.AsciiChar = String[i];
        Buffer[i].Attributes = y;
    }
    Success = WriteConsoleOutput(GetStdHandle(STD_OUTPUT_HANDLE),
                                 Buffer,
                                 BufferSize,
                                 BufferCoord,
                                 &WriteRegion
                                );
    return Success;
}

DWORD
__cdecl main(
    int argc,
    char *argv[])
{
    OutputDebugString("entering tattach\n");
    if (!CallConsoleApi(5))
        OutputDebugString("TATTACH: CallConsoleApi failed\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\server\_priv.h ===
/***************************** Module Header ******************************\
* Module Name: priv.h
*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*
* Performance critical routine for Single Binary
*
* Each function will be created with two flavors FE and non FE
*
* 30-May-1997 Hiroyama   Moved from private.c
\**************************************************************************/

#define WWSB_NEUTRAL_FILE 1

#if !defined(FE_SB)
#error This header file should be included with FE_SB
#endif

#if !defined(WWSB_FE) && !defined(WWSB_NOFE)
#error Either WWSB_FE and WWSB_NOFE must be defined.
#endif

#if defined(WWSB_FE) && defined(WWSB_NOFE)
#error Both WWSB_FE and WWSB_NOFE defined.
#endif

#include "dispatch.h" // get the FE_ prototypes for alloc_text()

#ifdef WWSB_FE
#pragma alloc_text(FE_TEXT, FE_WriteRegionToScreenHW)
#endif

#if defined(WWSB_NOFE)
VOID
SB_WriteRegionToScreenHW(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT Region
    )
#else
VOID
FE_WriteRegionToScreenHW(
    IN PSCREEN_INFORMATION ScreenInfo,
    IN PSMALL_RECT Region
    )
#endif
{
    SHORT ScreenY,ScreenX;
    SHORT WindowY,WindowX,WindowSizeX;
    PCHAR_INFO ScreenBufPtr,ScreenBufPtrTmp;    // points to place to read in screen buffer
    PCHAR_INFO ScreenBufSrc;
    COORD TargetSize,SourcePoint;
    SMALL_RECT Target;
    COORD WindowOrigin;
#ifdef WWSB_FE
    PCHAR_IMAGE_INFO CharImageBufPtr,CharImageBufPtrTmp;
    PCHAR_IMAGE_INFO CharImageBufSrc;
    PFONT_IMAGE FontImage;
#endif
    ULONG ModeIndex = ScreenInfo->BufferInfo.TextInfo.ModeIndex;
    COORD FsFontSize1 = RegModeFontPairs[ModeIndex].FontSize;
    COORD FsFontSize2 = FsFontSize1;
    NTSTATUS Status;

#ifdef WWSB_FE
    SMALL_RECT CaTextRect;
    PCONVERSIONAREA_INFORMATION ConvAreaInfo = ScreenInfo->ConvScreenInfo;
    PSCREEN_INFORMATION CurrentScreenBuffer = ScreenInfo->Console->CurrentScreenBuffer;
#endif

    FsFontSize2.X *= 2;

#ifdef WWSB_NOFE
    if (ScreenInfo->Console->FontCacheInformation == NULL) {
        Status = SetRAMFontCodePage(ScreenInfo);
        if (!NT_SUCCESS(Status)) {
            return;
        }
    }
#endif

    if (ScreenInfo->Console->Flags & CONSOLE_VDM_REGISTERED) {
        return;
    }

#ifdef WWSB_FE
    if (ConvAreaInfo) {
        CaTextRect.Left = Region->Left - CurrentScreenBuffer->Window.Left - ConvAreaInfo->CaInfo.coordConView.X;
        CaTextRect.Right = CaTextRect.Left + (Region->Right - Region->Left);
        CaTextRect.Top   = Region->Top - CurrentScreenBuffer->Window.Top - ConvAreaInfo->CaInfo.coordConView.Y;
        CaTextRect.Bottom = CaTextRect.Top + (Region->Bottom - Region->Top);
    }
#endif

    TargetSize.X = Region->Right - Region->Left + 1;
    TargetSize.Y = Region->Bottom - Region->Top + 1;
    ScreenBufPtrTmp = ScreenBufPtr = (PCHAR_INFO)ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ),sizeof(CHAR_INFO) * TargetSize.X * TargetSize.Y);
    if (ScreenBufPtr == NULL)
        return;
#ifdef WWSB_FE
    CharImageBufPtrTmp = CharImageBufPtr = (PCHAR_IMAGE_INFO)ConsoleHeapAlloc(MAKE_TAG( TMP_TAG ),sizeof(CHAR_IMAGE_INFO) * TargetSize.X * TargetSize.Y);
    if (CharImageBufPtr == NULL)
    {
        ConsoleHeapFree(ScreenBufPtrTmp);
        return;
    }
    if (ConvAreaInfo) {
        SourcePoint.X = CaTextRect.Left;
        SourcePoint.Y = CaTextRect.Top;
    }
    else {
        SourcePoint.X = Region->Left;
        SourcePoint.Y = Region->Top;
    }
#else
    SourcePoint.X = Region->Left;
    SourcePoint.Y = Region->Top;
#endif
    Target.Left = 0;
    Target.Top = 0;
    Target.Right = TargetSize.X-1;
    Target.Bottom = TargetSize.Y-1;
    ReadRectFromScreenBuffer(ScreenInfo,
                             SourcePoint,
                             ScreenBufPtr,
                             TargetSize,
                             &Target
                            );

    //
    // make sure region lies within window
    //

    if (Region->Bottom > ScreenInfo->Window.Bottom) {
        WindowOrigin.X = 0;
        WindowOrigin.Y = Region->Bottom - ScreenInfo->Window.Bottom;
        SetWindowOrigin(ScreenInfo, FALSE, WindowOrigin);
    }

#ifdef WWSB_FE
    if (ConvAreaInfo) {
        WindowY = Region->Top - CurrentScreenBuffer->Window.Top;
        WindowX = Region->Left - CurrentScreenBuffer->Window.Left;
    }
    else {
        WindowY = Region->Top - ScreenInfo->Window.Top;
        WindowX = Region->Left - ScreenInfo->Window.Left;
    }
#else
    WindowY = Region->Top - ScreenInfo->Window.Top;
    WindowX = Region->Left - ScreenInfo->Window.Left;
#endif
    WindowSizeX = CONSOLE_WINDOW_SIZE_X(ScreenInfo);

    for (ScreenY = Region->Top;
         ScreenY <= Region->Bottom;
         ScreenY++, WindowY++) {

#ifdef WWSB_FE
        CharImageBufSrc = CharImageBufPtr;
        SetRAMFont(ScreenInfo, ScreenBufPtr, WINDOW_SIZE_X(Region));
#else
        ULONG CurFrameBufPtr;   // offset in frame buffer

        CurFrameBufPtr = SCREEN_BUFFER_POINTER(WindowX,
                                               WindowY,
                                               WindowSizeX,
                                               sizeof(VGA_CHAR));
#endif
        ScreenBufSrc = ScreenBufPtr;


        for (ScreenX = Region->Left;
             ScreenX <= Region->Right;
             ScreenX++, ScreenBufPtr++) {

#ifdef WWSB_FE
            CharImageBufPtr->CharInfo = *ScreenBufPtr;
            Status = GetFontImagePointer(ScreenInfo->Console->FontCacheInformation,
                                         ScreenBufPtr->Char.UnicodeChar,
                                         ScreenBufPtr->Attributes & COMMON_LVB_SBCSDBCS ?
                                             FsFontSize2 : FsFontSize1,
                                         &FontImage);
            if (! NT_SUCCESS(Status))
            {
                CharImageBufPtr->FontImageInfo.FontSize.X = 0;
                CharImageBufPtr->FontImageInfo.FontSize.Y = 0;
                CharImageBufPtr->FontImageInfo.ImageBits = NULL;
            }
            else
            {
                CharImageBufPtr->FontImageInfo.FontSize  = FontImage->FontSize;
                CharImageBufPtr->FontImageInfo.ImageBits = FontImage->ImageBits;
            }
            CharImageBufPtr++;
#else
            //
            // if the char is > 127, we have to convert it back to OEM.
            //
            if (ScreenBufPtr->Char.UnicodeChar > 127) {
                ScreenBufPtr->Char.AsciiChar = WcharToChar(
                        ScreenInfo->Console->OutputCP,
                        ScreenBufPtr->Char.UnicodeChar);
            }
#endif
        }

#ifdef WWSB_FE
        {
            FSCNTL_SCREEN_INFO FsCntl;

            FsCntl.Position.X = WindowX;
            FsCntl.Position.Y = WindowY;
            FsCntl.ScreenSize.X = WindowSizeX;
            FsCntl.ScreenSize.Y = CONSOLE_WINDOW_SIZE_Y(ScreenInfo);
            FsCntl.nNumberOfChars = WINDOW_SIZE_X(Region);
            GdiFullscreenControl(FullscreenControlWriteToFrameBufferDB,
                                 CharImageBufSrc,
                                 (Region->Right - Region->Left + 1) *
                                     sizeof(CHAR_IMAGE_INFO),
                                 &FsCntl,
                                 (PULONG)sizeof(FsCntl));

        }
#else
        GdiFullscreenControl(FullscreenControlWriteToFrameBuffer,
                                ScreenBufSrc,
                                (Region->Right - Region->Left + 1) *
                                    sizeof(CHAR_INFO),
                                (PULONG) CurFrameBufPtr,
                                (PULONG) ((Region->Right - Region->Left + 1) *
                                    sizeof(VGA_CHAR)));
#endif

    }

    ConsoleHeapFree(ScreenBufPtrTmp);
#ifdef WWSB_FE
    ConsoleHeapFree(CharImageBufPtrTmp);
#endif

    ReverseMousePointer(ScreenInfo, Region);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\test\detach\detach.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    tdetach.c

Abstract:

    Test program for detached processes

Author:

    Therese Stowell (thereses) July-15-1991

Revision History:

--*/

#include <windows.h>

CHAR String[11] = "detachedpr";

BOOL
CallConsoleApi(
    IN WORD y
    )
{
    CHAR_INFO Buffer[10];
    COORD BufferSize;
    COORD BufferCoord;
    SMALL_RECT WriteRegion;
    int i;
    BOOL Success;

    BufferSize.X = 10;
    BufferSize.Y = 1;
    BufferCoord.X = 0;
    BufferCoord.Y = 0;
    WriteRegion.Left = 0;
    WriteRegion.Top = y;
    WriteRegion.Right = 14;
    WriteRegion.Bottom = y;
    for (i=0;i<10;i++) {
        Buffer[i].Char.AsciiChar = String[i];
        Buffer[i].Attributes = y;
    }
    Success = WriteConsoleOutput(GetStdHandle(STD_OUTPUT_HANDLE),
                                 Buffer,
                                 BufferSize,
                                 BufferCoord,
                                 &WriteRegion
                                );
    return Success;
}

DWORD
__cdecl main(
    int argc,
    char *argv[])
{
    OutputDebugString("entering tdetach\n");
    if (CallConsoleApi(5))
        OutputDebugString("TDETACH: CallConsoleApi succeeded\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\test\proc_out\proc_out.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <io.h>
#include <fcntl.h>

#define STDIN  0
#define STDOUT 1
#define STDERR 2

#define CRTTONT(fh) (HANDLE)_get_osfhandle(fh)

PrintPair(
    LPWSTR pwch,
    UCHAR *pch,
    DWORD cch)
{
    DWORD cchWritten;

    SetConsoleMode(CRTTONT(STDOUT), ENABLE_PROCESSED_OUTPUT | ENABLE_WRAP_AT_EOL_OUTPUT);

    printf("%04x-%04x: ", pwch[0], pwch[cch-1]);
    WriteConsoleW(CRTTONT(STDOUT), pwch, cch, &cchWritten, NULL);
    printf("  ");
    printf("%02x-%02x: ", pch[0], pch[cch-1]);
    WriteConsoleA(CRTTONT(STDOUT), pch, cch, &cchWritten, NULL);

    printf("\n");
    SetConsoleMode(CRTTONT(STDOUT), ENABLE_WRAP_AT_EOL_OUTPUT);

    printf("%04x-%04x: ", pwch[0], pwch[cch-1]);
    WriteConsoleW(CRTTONT(STDOUT), pwch, cch, &cchWritten, NULL);
    printf("  ");
    printf("%02x-%02x: ", pch[0], pch[cch-1]);
    WriteConsoleA(CRTTONT(STDOUT), pch, cch, &cchWritten, NULL);

    SetConsoleMode(CRTTONT(STDOUT), ENABLE_PROCESSED_OUTPUT | ENABLE_WRAP_AT_EOL_OUTPUT);
    printf("\n\n");
}

int _cdecl main(int argc, char *argv[]) {
    WCHAR awch[100];
    CHAR  ach[100];
    CHAR  ch;
    DWORD i, j;

    printf("The first and second line of each pair should be identical:\n");
    printf("Unicode                       ANSI\n");
    for (i = 0xA0; i < 0xFF; i += 0x10) {
        for (j = 0; j < 16; j++) {
            awch[j] = (WCHAR)(i + j);
            ach[j] = (CHAR)(i+j);
        }
        PrintPair(awch, ach, 16);
    }

    printf("Now test line wrapping:\n");
    ch = 0x80;
    for (j = 0; j < 100; j++) {
        MultiByteToWideChar(CP_ACP, 0, &ch, 1, &awch[j], 1);
        ach[j] = ch;
        ch++;
    }
    PrintPair(awch, ach, 100);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\test\mode\mode.c ===
/*++

Copyright (c) 1985 - 1999, Microsoft Corporation

Module Name:

    tmode.c

Abstract:

    Console input and output mode test program

Author:

    Therese Stowell (thereses) 4-Oct-1991

Revision History:

--*/

#include <windows.h>
#include <stdio.h>

#define UNPROCESSED_LENGTH 7
#define PROCESSED_LENGTH 6
CHAR UnprocessedString[UNPROCESSED_LENGTH] = "a\tbcd\b\r";
CHAR ProcessedString[PROCESSED_LENGTH] = "a\tbc\r\n";

DWORD
__cdecl main(
    int argc,
    char **argv)
{
    BOOL Success;
    DWORD OldInputMode,OldOutputMode;
    DWORD NewInputMode,NewOutputMode;
    CHAR buff[512];
    DWORD n;

    //
    // test input and output modes
    //
    // Input Mode flags:
    //
    // ENABLE_PROCESSED_INPUT 0x0001
    // ENABLE_LINE_INPUT      0x0002
    // ENABLE_ECHO_INPUT      0x0004
    // ENABLE_WINDOW_INPUT    0x0008
    // ENABLE_MOUSE_INPUT     0x0010
    //
    // Output Mode flags:
    //
    // ENABLE_PROCESSED_OUTPUT  0x0001
    // ENABLE_WRAP_AT_EOL_OUTPUT  0x0002
    //

    NewInputMode = ENABLE_PROCESSED_INPUT | ENABLE_LINE_INPUT | ENABLE_ECHO_INPUT;
    Success = GetConsoleMode(GetStdHandle(STD_INPUT_HANDLE),
                             &OldInputMode
                            );
    if ((OldInputMode & NewInputMode) != NewInputMode) {
        printf("ERROR: OldInputMode is %x\n",OldInputMode);
        SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE),NewInputMode);
    }

    NewOutputMode = ENABLE_PROCESSED_OUTPUT | ENABLE_WRAP_AT_EOL_OUTPUT;
    Success = GetConsoleMode(GetStdHandle(STD_INPUT_HANDLE),
                             &OldOutputMode
                            );
    if ((OldOutputMode & NewOutputMode) != NewOutputMode) {
        printf("ERROR: OldOutputMode is %x\n",OldOutputMode);
        SetConsoleMode(GetStdHandle(STD_OUTPUT_HANDLE),NewOutputMode);
    }

    //
    // mode set:
    //
    // ENABLE_PROCESSED_INPUT - backspace, tab, cr, lf, ctrl-z
    // ENABLE_LINE_INPUT - wait for linefeed
    // ENABLE_ECHO_INPUT
    // ENABLE_PROCESSED_OUTPUT - backspace, tab, cr, lf, bell
    //
    printf("input mode is ENABLE_PROCESSED_INPUT | ENABLE_LINE_INPUT | ENABLE_ECHO_INPUT\n");
    printf("output mode is ENABLE_PROCESSED_OUTPUT\n");
    printf("type aTabbcdBackspaceCr\n");
    printf("a       bc should be output string\n");

    Success = ReadFile(GetStdHandle(STD_INPUT_HANDLE),buff,512, &n, NULL);
    if (!Success) {
        printf("ReadFile returned error %d\n",GetLastError());
        return 1;
    }
    if (n != PROCESSED_LENGTH) {
        printf("n is %d\n",n);
    }
    if (strncmp(ProcessedString,buff,n)) {
        printf("strncmp failed\n");
        printf("ProcessedString contains %s\n",ProcessedString);
        printf("buff contains %s\n",buff);
        DebugBreak();
    }

    //
    // mode set:
    //
    // ENABLE_PROCESSED_INPUT
    // ENABLE_LINE_INPUT
    // ENABLE_ECHO_INPUT

    printf("input mode is ENABLE_PROCESSED_INPUT | ENABLE_LINE_INPUT | ENABLE_ECHO_INPUT\n");
    printf("output mode is 0\n");
    SetConsoleMode(GetStdHandle(STD_OUTPUT_HANDLE),ENABLE_WRAP_AT_EOL_OUTPUT);
    printf("type aTabbcdBackspaceCr\n");
    printf("a0x90x8bc0xd0xa should be output string\n");

    Success = ReadFile(GetStdHandle(STD_INPUT_HANDLE), buff, 512, &n, NULL);
    if (!Success) {
        printf("ReadFile returned error %d\n",GetLastError());
        return 1;
    }
    if (n != PROCESSED_LENGTH) {
        printf("n is %d\n",n);
    }
    if (strncmp(ProcessedString,buff,n)) {
        printf("strncmp failed\n");
        printf("ProcessedString contains %s\n",ProcessedString);
        printf("buff contains %s\n",buff);
        DebugBreak();
    }

    //
    // mode set:
    //
    // ENABLE_LINE_INPUT
    // ENABLE_ECHO_INPUT
    // ENABLE_PROCESSED_OUTPUT

    printf("input mode is ENABLE_LINE_INPUT | ENABLE_ECHO_INPUT\n");
    printf("output mode is ENABLE_PROCESSED_OUTPUT\n");
    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE),ENABLE_LINE_INPUT | ENABLE_ECHO_INPUT);
    SetConsoleMode(GetStdHandle(STD_OUTPUT_HANDLE),ENABLE_PROCESSED_OUTPUT | ENABLE_WRAP_AT_EOL_OUTPUT);
    printf("type aTabbcdBackspaceCr\n");
    printf("a       bc should be output string\n");

    Success = ReadFile(GetStdHandle(STD_INPUT_HANDLE),buff,512, &n, NULL);
    if (!Success) {
        printf("ReadFile returned error %d\n",GetLastError());
        return 1;
    }
    if (n != UNPROCESSED_LENGTH) {
        printf("n is %d\n",n);
    }
    if (strncmp(UnprocessedString,buff,n)) {
        printf("strncmp failed\n");
        printf("UnprocessedString contains %s\n",ProcessedString);
        printf("buff contains %s\n",buff);
        DebugBreak();
    }

    //
    // mode set:
    //
    // ENABLE_PROCESSED_INPUT
    // ENABLE_PROCESSED_OUTPUT
    //

    printf("input mode is ENABLE_PROCESSED_INPUT\n");
    printf("output mode is ENABLE_PROCESSED_OUTPUT\n");
    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE),ENABLE_PROCESSED_INPUT);
    printf("type aTabbcdBackspaceCr\n");
    printf("no string should be output\n");

    Success = ReadFile(GetStdHandle(STD_INPUT_HANDLE),buff,512, &n, NULL);
    if (!Success) {
        printf("ReadFile returned error %d\n",GetLastError());
        return 1;
    }
    { DWORD i=0;
      DWORD j;
    while (Success) {
        printf("n is %d\n",n);
        for (j=0;j<n;j++,i++) {
            if (UnprocessedString[i] != buff[j]) {
                printf("strncmp failed\n");
                printf("UnprocessedString[i] is %c\n",UnprocessedString[i]);
                printf("buff[j] is %c\n",buff[j]);
                DebugBreak();
            }
        }
        Success = ReadFile(GetStdHandle(STD_INPUT_HANDLE),buff,512, &n, NULL);
        if (!Success) {
            printf("ReadFile returned error %d\n",GetLastError());
            return 1;
        }
    }
    }
    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE),OldInputMode);
    SetConsoleMode(GetStdHandle(STD_OUTPUT_HANDLE),OldOutputMode);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\test\tdisp\tdisp.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <io.h>
#include <fcntl.h>

BOOL gfNotepad = FALSE;

VOID ErrorExit(VOID) {
    fprintf(stderr, "Usage: \"tdisp [-n] hex1 [hex2] [width]\"\n");
    fprintf(stderr, "  \"tdisp hex\"\n");
    fprintf(stderr, "      Displays single Unicode char <hex>\n");
    fprintf(stderr, "  \"tdisp hex1 hex2\"\n");
    fprintf(stderr, "      Displays Unicode char <hex1> through <hex2>\n");
    fprintf(stderr, "  \"tdisp hex1 hex2 n\"\n");
    fprintf(stderr, "      Displays <hex1> thru <hex2> in lines of <width> chars\n");
    fprintf(stderr, "  -n   generates a Notepad Unicode text file on stdout\n");
    exit(2);
}

VOID NotepadPrint(LPWSTR pwsz) {
    while (*pwsz) {
        if (*pwsz == 0x000a) {
            printf("%c%c", 0x0d, 0x00);
        }
        printf("%c%c", LOBYTE(*pwsz), HIBYTE(*pwsz));
        pwsz++;
    }
}

int _cdecl main(int argc, char *argv[]) {
    WCHAR wch1, wch2;
    int n = 1;
    int i;
    LPWSTR p;
    WCHAR awch[100];
    DWORD cchWritten;

    if (argc < 2) {
        ErrorExit();
    }

    if ((*argv[1] == '/') || (*argv[1] == '-')) {
        switch (argv[1][1]) {
        case 'n':
            gfNotepad = TRUE;
            /* Set "stdin" to have binary mode: */
            _setmode( _fileno( stdout ), _O_BINARY );
            printf("%c%c", 0xff, 0xfe);  // Unicode BOM
            argv++;
            break;
        default:
            ErrorExit();
        }
    }

    wch1 = (WCHAR)strtol(argv[1], NULL, 16);
    if (argc > 2) {
        wch2 = (WCHAR)strtol(argv[2], NULL, 16);
        if (argc > 3) {
            n = atoi(argv[3]);
        }
    } else {
        wch2 = wch1;
    }

    if (gfNotepad) {
        NotepadPrint(L"=======(begin)=======\n");
    } else {
        printf("=======(begin)=======\n");
    }

    while (wch1 <= wch2) {
        i = swprintf(awch, L"0x%04x : --->", wch1);
        p = &awch[i];
        for (i = 0; i < n; i++) {
            *p++ = wch1++;
        }
        *p = L'\0';
        wcscat(awch, L"<---\n");
        if (gfNotepad) {
            NotepadPrint(awch);
        } else {
            WriteConsoleW(GetStdHandle(STD_OUTPUT_HANDLE), awch,
                    wcslen(awch), &cchWritten, NULL);
        }
    }

    if (gfNotepad) {
        NotepadPrint(L"========(end)========\n");
    } else {
        printf("========(end)========\n");
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\test\scroll\scroll.c ===
/*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

#define FOREGROUND_WHITE (FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED)

typedef
BOOL
(*PTEST_ROUTINE)(
    IN HANDLE Handle
    );

BOOL
Scroll1(
    IN HANDLE Handle
    );
BOOL
Scroll2(
    IN HANDLE Handle
    );
BOOL
Scroll3(
    IN HANDLE Handle
    );
BOOL
Scroll4(
    IN HANDLE Handle
    );
BOOL
Scroll5(
    IN HANDLE Handle
    );

#define NUM_TESTS 5
PTEST_ROUTINE Tests[NUM_TESTS] = {Scroll1,Scroll2,Scroll3,Scroll4,Scroll5};

BOOL
Scroll5(
    IN HANDLE Handle
    )
{
    SMALL_RECT ScrollRectangle;
    CHAR_INFO Fill;
    COORD DestinationOrigin;
    CONSOLE_SCREEN_BUFFER_INFO ScreenInfo;

    if (!GetConsoleScreenBufferInfo(Handle,&ScreenInfo)) {
        printf("ERROR: GetConsoleScreenBufferInfo failed\n");
    }

    ScrollRectangle = ScreenInfo.srWindow;
    Fill.Attributes = BACKGROUND_GREEN;
    Fill.Char.UnicodeChar = 'T';
    DestinationOrigin.X = 0;
    DestinationOrigin.Y = -(ScreenInfo.srWindow.Bottom - ScreenInfo.srWindow.Top + 1);
    if (!ScrollConsoleScreenBuffer(Handle,
                                   &ScrollRectangle,
                                   NULL,
                                   DestinationOrigin,
                                   &Fill)) {
        printf("ScrollConsoleScreenBuffer failed\n");
        return FALSE;
    }
    printf("scrolled entire screen\n");
    DebugBreak();
    return TRUE;
}

BOOL
Scroll4(
    IN HANDLE Handle
    )
{
    CHAR_INFO CharBuffer[20][25];
    SMALL_RECT WriteRegion;
    COORD BufferSize;
    COORD BufferCoord;
    CHAR TextAttr;
    CHAR BackgroundAttr;
    int i,j;
    CHAR Char;
    SMALL_RECT ScrollRectangle,ClipRectangle;
    CHAR_INFO Fill;
    COORD DestinationOrigin;

    BackgroundAttr = BACKGROUND_BLUE;
    TextAttr = FOREGROUND_WHITE;
    for (i=0;i<20;i++) {
        for (Char='a',j=0;j<25;j++) {
            CharBuffer[i][j].Attributes = BackgroundAttr | TextAttr;
            CharBuffer[i][j].Char.AsciiChar = Char;
            Char++;
            if (Char > 'z') Char = 'a';
        }
    }

    //
    // write square to screen
    //

    BufferSize.X = 25;
    BufferSize.Y = 20;
    BufferCoord.X = 0;
    BufferCoord.Y = 0;
    WriteRegion.Left = 5;
    WriteRegion.Right = 15;
    WriteRegion.Top = 5;
    WriteRegion.Bottom = 15;
    if (!WriteConsoleOutput(Handle,
                            (PCHAR_INFO)CharBuffer,
                            BufferSize,
                            BufferCoord,
                            &WriteRegion
                           )) {
        printf("WriteConsoleOutput failed\n");
        return FALSE;
    }
    if (WriteRegion.Left != 5 || WriteRegion.Right != 15 ||
        WriteRegion.Top != 5 || WriteRegion.Bottom != 15) {
        printf("test 1: regions don't match\n");
        printf("WriteRegion is %ld\n",&WriteRegion);
    }
    printf("wrote rectangle to 5,5\n");
    DebugBreak();

    ScrollRectangle.Left = 5;
    ScrollRectangle.Right = 15;
    ScrollRectangle.Top = 5;
    ScrollRectangle.Bottom = 15;
    ClipRectangle.Left = 9;
    ClipRectangle.Right = 25;
    ClipRectangle.Top = 9;
    ClipRectangle.Bottom = 25;
    Fill.Attributes = BACKGROUND_GREEN;
    Fill.Char.UnicodeChar = 'T';
    DestinationOrigin.X = 20;
    DestinationOrigin.Y = 20;
    if (!ScrollConsoleScreenBuffer(Handle,
                                   &ScrollRectangle,
                                   &ClipRectangle,
                                   DestinationOrigin,
                                   &Fill)) {
        printf("ScrollConsoleScreenBuffer failed\n");
        return FALSE;
    }
    printf("scrolled region (5,15)(5,15) to (20,20) with clip (9,9)(25,25)\n");
    DebugBreak();
    return TRUE;
}

BOOL
Scroll3(
    IN HANDLE Handle
    )
{
    CHAR_INFO CharBuffer[20][25];
    SMALL_RECT WriteRegion;
    COORD BufferSize;
    COORD BufferCoord;
    CHAR TextAttr;
    CHAR BackgroundAttr;
    int i,j;
    CHAR Char;
    SMALL_RECT ScrollRectangle,ClipRectangle;
    CHAR_INFO Fill;
    COORD DestinationOrigin;

    BackgroundAttr = BACKGROUND_BLUE;
    TextAttr = FOREGROUND_WHITE;
    for (i=0;i<20;i++) {
        for (Char='a',j=0;j<25;j++) {
            CharBuffer[i][j].Attributes = BackgroundAttr | TextAttr;
            CharBuffer[i][j].Char.AsciiChar = Char;
            Char++;
            if (Char > 'z') Char = 'a';
        }
    }

    //
    // write square to screen
    //

    BufferSize.X = 25;
    BufferSize.Y = 20;
    BufferCoord.X = 0;
    BufferCoord.Y = 0;
    WriteRegion.Left = 5;
    WriteRegion.Right = 15;
    WriteRegion.Top = 5;
    WriteRegion.Bottom = 15;
    if (!WriteConsoleOutput(Handle,
                            (PCHAR_INFO)CharBuffer,
                            BufferSize,
                            BufferCoord,
                            &WriteRegion
                           )) {
        printf("WriteConsoleOutput failed\n");
        return FALSE;
    }
    if (WriteRegion.Left != 5 || WriteRegion.Right != 15 ||
        WriteRegion.Top != 5 || WriteRegion.Bottom != 15) {
        printf("test 1: regions don't match\n");
        printf("WriteRegion is %ld\n",&WriteRegion);
    }
    printf("wrote rectangle to 5,5\n");
    DebugBreak();

    ScrollRectangle.Left = 5;
    ScrollRectangle.Right = 15;
    ScrollRectangle.Top = 5;
    ScrollRectangle.Bottom = 15;
    ClipRectangle.Left = 5;
    ClipRectangle.Right = 15;
    ClipRectangle.Top = 5;
    ClipRectangle.Bottom = 15;
    Fill.Attributes = BACKGROUND_GREEN;
    Fill.Char.UnicodeChar = 'T';
    DestinationOrigin.X = 5;
    DestinationOrigin.Y = 4;
    if (!ScrollConsoleScreenBuffer(Handle,
                                   &ScrollRectangle,
                                   &ClipRectangle,
                                   DestinationOrigin,
                                   &Fill)) {
        printf("ScrollConsoleScreenBuffer failed\n");
        return FALSE;
    }
    printf("scrolled region (5,15)(5,15) to (5,4)\n");
    DebugBreak();
    return TRUE;
}

BOOL
Scroll2(
    IN HANDLE Handle
    )
{
    CHAR_INFO CharBuffer[20][25];
    SMALL_RECT WriteRegion;
    COORD BufferSize;
    COORD BufferCoord;
    CHAR TextAttr;
    CHAR BackgroundAttr;
    int i,j;
    CHAR Char;
    SMALL_RECT ScrollRectangle,ClipRectangle;
    CHAR_INFO Fill;
    COORD DestinationOrigin;

    BackgroundAttr = BACKGROUND_BLUE;
    TextAttr = FOREGROUND_WHITE;
    for (i=0;i<20;i++) {
        for (Char='a',j=0;j<25;j++) {
            CharBuffer[i][j].Attributes = BackgroundAttr | TextAttr;
            CharBuffer[i][j].Char.AsciiChar = Char;
            Char++;
            if (Char > 'z') Char = 'a';
        }
    }

    //
    // write square to screen
    //

    BufferSize.X = 25;
    BufferSize.Y = 20;
    BufferCoord.X = 0;
    BufferCoord.Y = 0;
    WriteRegion.Left = 5;
    WriteRegion.Right = 15;
    WriteRegion.Top = 5;
    WriteRegion.Bottom = 15;
    if (!WriteConsoleOutput(Handle,
                            (PCHAR_INFO)CharBuffer,
                            BufferSize,
                            BufferCoord,
                            &WriteRegion
                           )) {
        printf("WriteConsoleOutput failed\n");
        return FALSE;
    }
    if (WriteRegion.Left != 5 || WriteRegion.Right != 15 ||
        WriteRegion.Top != 5 || WriteRegion.Bottom != 15) {
        printf("test 1: regions don't match\n");
        printf("WriteRegion is %ld\n",&WriteRegion);
    }
    printf("wrote rectangle to 5,5\n");
    DebugBreak();

    ScrollRectangle.Left = 5;
    ScrollRectangle.Right = 15;
    ScrollRectangle.Top = 5;
    ScrollRectangle.Bottom = 15;
    ClipRectangle.Left = 10;
    ClipRectangle.Right = 25;
    ClipRectangle.Top = 10;
    ClipRectangle.Bottom = 25;
    Fill.Attributes = BACKGROUND_GREEN;
    Fill.Char.UnicodeChar = 'T';
    DestinationOrigin.X = 10;
    DestinationOrigin.Y = 10;
    if (!ScrollConsoleScreenBuffer(Handle,
                                   &ScrollRectangle,
                                   NULL,
                                   DestinationOrigin,
                                   &Fill)) {
        printf("ScrollConsoleScreenBuffer failed\n");
        return FALSE;
    }
    printf("scrolled region (5,15)(5,15) to (10,10)\n");
    DebugBreak();
    return TRUE;
}

BOOL
Scroll1(
    IN HANDLE Handle
    )
{
    CHAR_INFO CharBuffer[20][25];
    SMALL_RECT WriteRegion;
    COORD BufferSize;
    COORD BufferCoord;
    CHAR TextAttr;
    CHAR BackgroundAttr;
    int i,j;
    CHAR Char;
    SMALL_RECT ScrollRectangle,ClipRectangle;
    CHAR_INFO Fill;
    COORD DestinationOrigin;

    BackgroundAttr = BACKGROUND_BLUE;
    TextAttr = FOREGROUND_WHITE;
    for (i=0;i<20;i++) {
        for (Char='a',j=0;j<25;j++) {
            CharBuffer[i][j].Attributes = BackgroundAttr | TextAttr;
            CharBuffer[i][j].Char.AsciiChar = Char;
            Char++;
            if (Char > 'z') Char = 'a';
        }
    }

    //
    // write square to screen
    //

    BufferSize.X = 25;
    BufferSize.Y = 20;
    BufferCoord.X = 0;
    BufferCoord.Y = 0;
    WriteRegion.Left = 0;
    WriteRegion.Right = 10;
    WriteRegion.Top = 0;
    WriteRegion.Bottom = 10;
    if (!WriteConsoleOutput(Handle,
                            (PCHAR_INFO)CharBuffer,
                            BufferSize,
                            BufferCoord,
                            &WriteRegion
                           )) {
        printf("WriteConsoleOutput failed\n");
        return FALSE;
    }
    if (WriteRegion.Left != 0 || WriteRegion.Right != 10 ||
        WriteRegion.Top != 0 || WriteRegion.Bottom != 10) {
        printf("test 1: regions don't match\n");
        printf("WriteRegion is %ld\n",&WriteRegion);
    }
    printf("wrote rectangle to 0,0\n");
    DebugBreak();

    ScrollRectangle.Left = 0;
    ScrollRectangle.Right = 10;
    ScrollRectangle.Top = 0;
    ScrollRectangle.Bottom = 10;
    ClipRectangle.Left = 25;
    ClipRectangle.Right = 30;
    ClipRectangle.Top = 25;
    ClipRectangle.Bottom = 30;
    Fill.Attributes = BACKGROUND_GREEN;
    Fill.Char.UnicodeChar = 'T';
    DestinationOrigin.X = 20;
    DestinationOrigin.Y = 20;
    if (!ScrollConsoleScreenBuffer(Handle,
                                   &ScrollRectangle,
                                   &ClipRectangle,
                                   DestinationOrigin,
                                   &Fill)) {
        printf("ScrollConsoleScreenBuffer failed\n");
        return FALSE;
    }
    printf("scrolled region (0,10)(0,10) to (20,20)\n");
    DebugBreak();
    return TRUE;
}


DWORD
__cdecl main(
    int argc,
    char *argv[])
{
    SECURITY_ATTRIBUTES SecurityAttributes;
    HANDLE Handle;
    int i;

    printf( "TSCROLL: Entering Scrolling Test Program\n" );

    for (i=0;i<NUM_TESTS;i++) {

        if (argc==2) {
            i = atoi(argv[1]);
        }

        //
        // open a new console
        //

        SecurityAttributes.bInheritHandle = FALSE;
        SecurityAttributes.lpSecurityDescriptor = NULL;
        SecurityAttributes.nLength = sizeof (SECURITY_ATTRIBUTES);
        Handle = CreateFile("CONOUT$",
                            GENERIC_READ | GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            &SecurityAttributes,
                            CREATE_ALWAYS,
                            0,
                            (HANDLE)-1
                           );
        if (Handle == (HANDLE)-1) {
            printf("CreateFile failed\n");
            return FALSE;
        }

        //
        // make it current
        //

        if (!SetConsoleActiveScreenBuffer(Handle)) {
            printf("SetConsoleActiveScreenBuffer failed\n");
            return FALSE;
        }

        if (!Tests[i](Handle)) {
            printf("Scroll%d failed\n",i+1);
        }
        else {
            printf("Scroll%d succeeded\n",i+1);
        }

        if (!SetConsoleActiveScreenBuffer(GetStdHandle(STD_OUTPUT_HANDLE))) {
            printf("SetConsoleActiveScreenBuffer failed\n");
            return FALSE;
        }

        if (!CloseHandle(Handle)) {
            printf("CloseHandle failed\n");
            return FALSE;
        }
        if (argc==2) {
            break;
        }
    }

    printf( "TCON: Exiting Test Program\n" );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\test\graph\graph.c ===
/*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*/

#include "condll.h"

#define FOREGROUND_WHITE (FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED)


typedef struct _BITMAPINFOPAT
{
    BITMAPINFOHEADER                 bmiHeader;
    RGBQUAD                          bmiColors[16];
} BITMAPINFOPAT;

BITMAPINFOPAT bmiPat =
{
    {
        sizeof(BITMAPINFOHEADER),
        128,
        32,
        1,
        1,
        BI_RGB,
        (32 * 128 / 8),
        0,
        0,
        2,
        2
    },

    {                               // B    G    R
        { 0,   0,   0x80,0 },       // 1
        { 0,   0x80,0,   0 },       // 2
        { 0,   0,   0,   0 },       // 0
        { 0,   0x80,0x80,0 },       // 3
        { 0x80,0,   0,   0 },       // 4
        { 0x80,0,   0x80,0 },       // 5
        { 0x80,0x80,0,   0 },       // 6
        { 0xC0,0xC0,0xC0,0 },       // 7

        { 0x80,0x80,0x80,0 },       // 8
        { 0,   0,   0xFF,0 },       // 9
        { 0,   0xFF,0,   0 },       // 10
        { 0,   0xFF,0xFF,0 },       // 11
        { 0xFF,0,   0,   0 },       // 12
        { 0xFF,0,   0xFF,0 },       // 13
        { 0xFF,0xFF,0,   0 },       // 14
        { 0xFF,0xFF,0xFF,0 }        // 15
    }
};

static BYTE abBigCat[] = {
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,

                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                          0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};


DWORD
__cdecl main(
    int argc,
    char *argv[])
{
    SECURITY_ATTRIBUTES SecurityAttributes;
    HANDLE Handle;
    int i;
    CONSOLE_GRAPHICS_BUFFER_INFO GraphicsInfo;
    SMALL_RECT Rect;
    BOOL Success;
    ULONG NumWritten;

    OutputDebugString("TGRAPH: Entering graphics Test Program\n");


    //
    // open a new console
    //

    SecurityAttributes.bInheritHandle = FALSE;
    SecurityAttributes.lpSecurityDescriptor = NULL;
    SecurityAttributes.nLength = sizeof (SECURITY_ATTRIBUTES);
    GraphicsInfo.dwBitMapInfoLength = sizeof(bmiPat);
    GraphicsInfo.lpBitMapInfo = (LPBITMAPINFO)&bmiPat;
    GraphicsInfo.dwUsage = DIB_RGB_COLORS;
    Handle = CreateConsoleScreenBuffer(GENERIC_READ | GENERIC_WRITE,
                                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                                       &SecurityAttributes,
                                       CONSOLE_GRAPHICS_BUFFER,
                                       &GraphicsInfo
                                      );
    if (Handle == INVALID_HANDLE_VALUE) {
        OutputDebugString("CreateConsoleScreenBuffer failed\n");
        return FALSE;
    }

    //
    // make it current
    //

    if (!SetConsoleActiveScreenBuffer(Handle)) {
        OutputDebugString("SetConsoleActiveScreenBuffer failed\n");
        return FALSE;
    }
    /*
    //
    // try to write to it.  should fail.
    //

    Success = WriteFile(Handle,"foo",3,&NumWritten,NULL);
    if (!Success) {
        OutputDebugString("WriteFile failed\n");
    }
    else {
        OutputDebugString("WriteFile succeeded\n");
        }
    */
    //
    // grab mutex
    //

    Success = WaitForSingleObject(GraphicsInfo.hMutex,-1);
    if (Success) {
        OutputDebugString("WaitForSingleObject failed\n");
    }
    else {
        OutputDebugString("WaitForSingleObject succeeded\n");
    }

    //
    // write bitmap to memory
    //

    RtlCopyMemory(GraphicsInfo.lpBitMap,abBigCat,(32*128/8));

    //
    // release mutex
    //

    ReleaseMutex(GraphicsInfo.hMutex);

    //
    // write bitmap to memory
    //

    Rect.Left = 0;
    Rect.Top =  0;
    Rect.Right = 31;
    Rect.Bottom = 31;
    Success = InvalidateConsoleDIBits(Handle,&Rect);
    if (!Success) {
        OutputDebugString("InvalidateConsoleDIBits failed\n");
    } else {
        OutputDebugString("InvalidateConsoleDIBits succeeded\n");
    }

    /*
    i=0;
    while (i<20) {
        INPUT_RECORD Buffer;
        DWORD NumRead;

        ReadConsoleInput(GetStdHandle(STD_INPUT_HANDLE),
                         &Buffer,
                         1,
                         &NumRead);
        if (Buffer.EventType == MOUSE_EVENT) {
            OutputDebugString("Mouse position is %d %d\n",
                      Buffer.Event.MouseEvent.dwMousePosition.X,
                      Buffer.Event.MouseEvent.dwMousePosition.Y);
            i++;
        }
    }
    */

    while (TRUE) {
        Sleep(10000);
    }

    if (!SetConsoleActiveScreenBuffer(GetStdHandle(STD_OUTPUT_HANDLE))) {
        OutputDebugString("SetConsoleActiveScreenBuffer failed\n");
        return FALSE;
    }

    if (!CloseHandle(Handle)) {
        OutputDebugString("CloseHandle failed\n");
        return FALSE;
    }

    OutputDebugString("TGRAPH: Exiting Test Program\n");

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\test\merge\merge.c ===
/*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*/

#include <windows.h>
#include <stdio.h>

// run-length encoded data structure for attributes

typedef struct _ATTR_PAIR {
    WORD Length;            // number of attribute appears
    WORD Attr;              // attribute
} ATTR_PAIR, *PATTR_PAIR;


#define SOURCE1_LENGTH 4
#define MERGE1_LENGTH 1
#define TARGET1_LENGTH 4
ATTR_PAIR Source1[SOURCE1_LENGTH] = { 2, 10,
                                      5, 20,
                                      3, 30,
                                      1, 40
                                    };
ATTR_PAIR Merge1[MERGE1_LENGTH] = { 2, 20 };

ATTR_PAIR Target1[TARGET1_LENGTH] = { 2, 10,
                                      5, 20,
                                      3, 30,
                                      1, 40
                                    };
#define START_INDEX1 4
#define END_INDEX1 5

//******************************************

#define SOURCE2_LENGTH 4
#define MERGE2_LENGTH 2
#define TARGET2_LENGTH 6
ATTR_PAIR Source2[SOURCE2_LENGTH] = { 2, 10,
                                      5, 20,
                                      3, 30,
                                      1, 40
                                    };
ATTR_PAIR Merge2[MERGE2_LENGTH] = { 1, 20,
                                    1, 30
                                  };
ATTR_PAIR Target2[TARGET2_LENGTH] = { 2, 10,
                                      3, 20,
                                      1, 30,
                                      1, 20,
                                      3, 30,
                                      1, 40
                                    };
#define START_INDEX2 4
#define END_INDEX2 5

//******************************************

#define SOURCE3_LENGTH 4
#define MERGE3_LENGTH 2
#define TARGET3_LENGTH 5
ATTR_PAIR Source3[SOURCE3_LENGTH] = { 2, 10,
                                      5, 20,
                                      3, 30,
                                      1, 40
                                    };
ATTR_PAIR Merge3[MERGE3_LENGTH] = { 1, 20,
                                    1, 30
                                  };
ATTR_PAIR Target3[TARGET3_LENGTH] = { 2, 10,
                                      5, 20,
                                      2, 30,
                                      1, 20,
                                      1, 30
                                    };
#define START_INDEX3 9
#define END_INDEX3 10

//******************************************

#define SOURCE4_LENGTH 4
#define MERGE4_LENGTH 4
#define TARGET4_LENGTH 4
ATTR_PAIR Source4[SOURCE4_LENGTH] = { 2, 10,
                                      5, 20,
                                      3, 30,
                                      1, 40
                                    };
ATTR_PAIR Merge4[MERGE4_LENGTH] = { 1, 20,
                                    1, 30,
                                    3, 20,
                                    6, 60
                                  };
ATTR_PAIR Target4[TARGET4_LENGTH] = { 1, 20,
                                      1, 30,
                                      3, 20,
                                      6, 60
                                    };
#define START_INDEX4 0
#define END_INDEX4 10

//******************************************

#define SOURCE5_LENGTH 4
#define MERGE5_LENGTH 3
#define TARGET5_LENGTH 6
ATTR_PAIR Source5[SOURCE5_LENGTH] = { 2, 10,
                                      5, 20,
                                      3, 30,
                                      1, 40
                                    };
ATTR_PAIR Merge5[MERGE5_LENGTH] = { 1, 10,
                                    1, 70,
                                    1, 30
                                  };
ATTR_PAIR Target5[TARGET5_LENGTH] = { 3, 10,
                                      1, 70,
                                      1, 30,
                                      2, 20,
                                      3, 30,
                                      1, 40
                                    };
#define START_INDEX5 2
#define END_INDEX5 4

//******************************************

#define SOURCE6_LENGTH 4
#define MERGE6_LENGTH 3
#define TARGET6_LENGTH 6
ATTR_PAIR Source6[SOURCE6_LENGTH] = { 2, 10,
                                      5, 20,
                                      3, 30,
                                      1, 40
                                    };
ATTR_PAIR Merge6[MERGE6_LENGTH] = { 1, 10,
                                    1, 70,
                                    1, 30
                                  };
ATTR_PAIR Target6[TARGET6_LENGTH] = { 2, 10,
                                      2, 20,
                                      1, 10,
                                      1, 70,
                                      4, 30,
                                      1, 40
                                    };
#define START_INDEX6 4
#define END_INDEX6 6

//******************************************

#define SOURCE7_LENGTH 1
#define MERGE7_LENGTH 2
#define TARGET7_LENGTH 2
ATTR_PAIR Source7[SOURCE7_LENGTH] = { 3, 10
                                    };
ATTR_PAIR Merge7[MERGE7_LENGTH] = { 1, 20,
                                    2, 70
                                  };
ATTR_PAIR Target7[TARGET7_LENGTH] = { 1, 20,
                                      2, 70
                                    };
#define START_INDEX7 0
#define END_INDEX7 2

//******************************************

#define SOURCE8_LENGTH 1
#define MERGE8_LENGTH 2
#define TARGET8_LENGTH 3
ATTR_PAIR Source8[SOURCE8_LENGTH] = { 3, 10
                                    };
ATTR_PAIR Merge8[MERGE8_LENGTH] = { 1, 20,
                                    1, 80
                                  };
ATTR_PAIR Target8[TARGET8_LENGTH] = { 1, 20,
                                      1, 80,
                                      1, 10
                                    };
#define START_INDEX8 0
#define END_INDEX8 1

//******************************************

#define SOURCE9_LENGTH 1
#define MERGE9_LENGTH 1
#define TARGET9_LENGTH 2
ATTR_PAIR Source9[SOURCE9_LENGTH] = { 3, 10
                                    };
ATTR_PAIR Merge9[MERGE9_LENGTH] = { 1, 20
                                  };
ATTR_PAIR Target9[TARGET9_LENGTH] = { 1, 20,
                                      2, 10
                                    };
#define START_INDEX9 0
#define END_INDEX9 0


//******************************************

#define SOURCE10_LENGTH 1
#define MERGE10_LENGTH 1
#define TARGET10_LENGTH 3
ATTR_PAIR Source10[SOURCE10_LENGTH] = { 3, 10
                                    };
ATTR_PAIR Merge10[MERGE10_LENGTH] = { 1, 20
                                  };
ATTR_PAIR Target10[TARGET10_LENGTH] = { 1, 10,
                                        1, 20,
                                        1, 10
                                       };
#define START_INDEX10 1
#define END_INDEX10 1


VOID MergeAttrStrings(
    PATTR_PAIR Source,
    WORD SourceLength,
    PATTR_PAIR Merge,
    WORD MergeLength,
    OUT PATTR_PAIR *Target,
    OUT LPWORD TargetLength,
    IN WORD StartIndex,
    IN WORD EndIndex
    )

/*++

--*/
{
    PATTR_PAIR SrcAttr,TargetAttr,SrcEnd;
    PATTR_PAIR NewString;
    WORD NewStringLength=0;
    WORD i;

    NewString = (PATTR_PAIR) LocalAlloc(LMEM_FIXED,(SourceLength+MergeLength+1)*sizeof(ATTR_PAIR));

    //
    // copy the source string, up to the start index.
    //

    SrcAttr = Source;
    SrcEnd = Source + SourceLength;
    TargetAttr = NewString;
    if (StartIndex != 0) {
        for (i=0;i<StartIndex;) {
            i += SrcAttr->Length;
            *TargetAttr++ = *SrcAttr++;
        }

        //
        // back up to the last pair copied, in case the attribute in the first
        // pair in the merge string matches.  also, adjust TargetAttr->Length
        // based on i, the attribute
        // counter, back to the StartIndex.  i will be larger than the
        // StartIndex in the case where the last attribute pair copied had
        // a length greater than the number needed to reach StartIndex.
        //

        TargetAttr--;
        if (i>StartIndex) {
            TargetAttr->Length -= i-StartIndex;
        }
        if (Merge->Attr == TargetAttr->Attr) {
            TargetAttr->Length += Merge->Length;
            MergeLength-=1;
            Merge++;
        }
        TargetAttr++;
    } else {
        i=0;
    }

    //
    // copy the merge string.
    //

    RtlCopyMemory(TargetAttr,Merge,MergeLength*sizeof(ATTR_PAIR));
    TargetAttr += MergeLength;

    //
    // figure out where to resume copying the source string.
    //

    while (i<=EndIndex) {
        i += SrcAttr->Length;
        SrcAttr++;
    }

    //
    // if not done, copy the rest of the source
    //

    if (SrcAttr != SrcEnd || i!=(EndIndex+1)) {

        //
        // see if we've gone past the right attribute.  if so, back up and
        // copy the attribute and the correct length.
        //

        TargetAttr--;
        if (i>(SHORT)(EndIndex+1)) {
            SrcAttr--;
            if (TargetAttr->Attr == SrcAttr->Attr) {
                TargetAttr->Length += i-(EndIndex+1);
            } else {
                TargetAttr++;
                TargetAttr->Attr = SrcAttr->Attr;
                TargetAttr->Length = i-(EndIndex+1);
            }
            SrcAttr++;
        }

        //
        // see if we can merge the source and target.
        //

        else if (TargetAttr->Attr == SrcAttr->Attr) {
            TargetAttr->Length += SrcAttr->Length;
            i += SrcAttr->Length;
            SrcAttr++;
        }
        TargetAttr++;

        //
        // copy the rest of the source
        //

        RtlCopyMemory(TargetAttr,SrcAttr,(SourceLength*sizeof(ATTR_PAIR)) - ((ULONG)SrcAttr - (ULONG)Source));
    }

    TargetAttr = (PATTR_PAIR)((ULONG)TargetAttr + (SourceLength*sizeof(ATTR_PAIR)) - ((ULONG)SrcAttr - (ULONG)Source));
    *TargetLength = (WORD)(TargetAttr - NewString);
    *Target = NewString;
}

DWORD
__cdecl main(
    int argc,
    char *argv[])
{
    PATTR_PAIR Target;
    WORD TargetLength;
    WORD i;

    MergeAttrStrings(Source1,
                     SOURCE1_LENGTH,
                     Merge1,
                     MERGE1_LENGTH,
                     &Target,
                     &TargetLength,
                     START_INDEX1,
                     END_INDEX1
                    );
    if (TargetLength != TARGET1_LENGTH) {
        printf("merge 1 failed\n");
        printf("TargetLength is %d.  expected %d\n",TargetLength,TARGET1_LENGTH);
    }

    if (memcmp(Target,Target1,TargetLength)) {
        printf("Target didn't match\n");
        for (i=0;i<TargetLength;i++) {
            printf("returned attr is %d\n",Target[i].Attr);
            printf("returned length is %d\n",Target[i].Length);
            printf("expected attr is %d\n",Target1[i].Attr);
            printf("expected length is %d\n",Target1[i].Length);
        }
    }
    MergeAttrStrings(Source2,
                     SOURCE2_LENGTH,
                     Merge2,
                     MERGE2_LENGTH,
                     &Target,
                     &TargetLength,
                     START_INDEX2,
                     END_INDEX2
                    );
    if (TargetLength != TARGET2_LENGTH) {
        printf("merge 2 failed\n");
        printf("TargetLength is %d.  expected %d\n",TargetLength,TARGET2_LENGTH);
    }
    if (memcmp(Target,Target2,TargetLength)) {
        printf("Target didn't match\n");
        for (i=0;i<TargetLength;i++) {
            printf("returned attr is %d\n",Target[i].Attr);
            printf("returned length is %d\n",Target[i].Length);
            printf("expected attr is %d\n",Target2[i].Attr);
            printf("expected length is %d\n",Target2[i].Length);
        }
    }
    MergeAttrStrings(Source3,
                     SOURCE3_LENGTH,
                     Merge3,
                     MERGE3_LENGTH,
                     &Target,
                     &TargetLength,
                     START_INDEX3,
                     END_INDEX3
                    );
    if (TargetLength != TARGET3_LENGTH) {
        printf("merge 3 failed\n");
        printf("TargetLength is %d.  expected %d\n",TargetLength,TARGET3_LENGTH);
    }
    if (memcmp(Target,Target3,TargetLength)) {
        printf("Target didn't match\n");
        for (i=0;i<TargetLength;i++) {
            printf("returned attr is %d\n",Target[i].Attr);
            printf("returned length is %d\n",Target[i].Length);
            printf("expected attr is %d\n",Target3[i].Attr);
            printf("expected length is %d\n",Target3[i].Length);
        }
    }
    MergeAttrStrings(Source4,
                     SOURCE4_LENGTH,
                     Merge4,
                     MERGE4_LENGTH,
                     &Target,
                     &TargetLength,
                     START_INDEX4,
                     END_INDEX4
                    );
    if (TargetLength != TARGET4_LENGTH) {
        printf("merge 4 failed\n");
        printf("TargetLength is %d.  expected %d\n",TargetLength,TARGET4_LENGTH);
    }
    if (memcmp(Target,Target4,TargetLength)) {
        printf("Target didn't match\n");
        for (i=0;i<TargetLength;i++) {
            printf("returned attr is %d\n",Target[i].Attr);
            printf("returned length is %d\n",Target[i].Length);
            printf("expected attr is %d\n",Target4[i].Attr);
            printf("expected length is %d\n",Target4[i].Length);
        }
    }
    MergeAttrStrings(Source5,
                     SOURCE5_LENGTH,
                     Merge5,
                     MERGE5_LENGTH,
                     &Target,
                     &TargetLength,
                     START_INDEX5,
                     END_INDEX5
                    );
    if (TargetLength != TARGET5_LENGTH) {
        printf("merge 5 failed\n");
        printf("TargetLength is %d.  expected %d\n",TargetLength,TARGET5_LENGTH);
    }
    if (memcmp(Target,Target5,TargetLength)) {
        printf("Target didn't match\n");
        for (i=0;i<TargetLength;i++) {
            printf("returned attr is %d\n",Target[i].Attr);
            printf("returned length is %d\n",Target[i].Length);
            printf("expected attr is %d\n",Target5[i].Attr);
            printf("expected length is %d\n",Target5[i].Length);
        }
    }
    MergeAttrStrings(Source6,
                     SOURCE6_LENGTH,
                     Merge6,
                     MERGE6_LENGTH,
                     &Target,
                     &TargetLength,
                     START_INDEX6,
                     END_INDEX6
                    );
    if (TargetLength != TARGET6_LENGTH) {
        printf("merge 6 failed\n");
        printf("TargetLength is %d.  expected %d\n",TargetLength,TARGET6_LENGTH);
    }
    if (memcmp(Target,Target6,TargetLength)) {
        printf("Target didn't match\n");
        for (i=0;i<TargetLength;i++) {
            printf("returned attr is %d\n",Target[i].Attr);
            printf("returned length is %d\n",Target[i].Length);
            printf("expected attr is %d\n",Target6[i].Attr);
            printf("expected length is %d\n",Target6[i].Length);
        }
    }
    MergeAttrStrings(Source7,
                     SOURCE7_LENGTH,
                     Merge7,
                     MERGE7_LENGTH,
                     &Target,
                     &TargetLength,
                     START_INDEX7,
                     END_INDEX7
                    );
    if (TargetLength != TARGET7_LENGTH) {
        printf("merge 7 failed\n");
        printf("TargetLength is %d.  expected %d\n",TargetLength,TARGET7_LENGTH);
    }
    if (memcmp(Target,Target7,TargetLength)) {
        printf("Target didn't match\n");
        for (i=0;i<TargetLength;i++) {
            printf("returned attr is %d\n",Target[i].Attr);
            printf("returned length is %d\n",Target[i].Length);
            printf("expected attr is %d\n",Target7[i].Attr);
            printf("expected length is %d\n",Target7[i].Length);
        }
    }
    MergeAttrStrings(Source8,
                     SOURCE8_LENGTH,
                     Merge8,
                     MERGE8_LENGTH,
                     &Target,
                     &TargetLength,
                     START_INDEX8,
                     END_INDEX8
                    );
    if (TargetLength != TARGET8_LENGTH) {
        printf("merge 8 failed\n");
        printf("TargetLength is %d.  expected %d\n",TargetLength,TARGET8_LENGTH);
    }
    if (memcmp(Target,Target8,TargetLength)) {
        printf("Target didn't match\n");
        for (i=0;i<TargetLength;i++) {
            printf("returned attr is %d\n",Target[i].Attr);
            printf("returned length is %d\n",Target[i].Length);
            printf("expected attr is %d\n",Target8[i].Attr);
            printf("expected length is %d\n",Target8[i].Length);
        }
    }
    MergeAttrStrings(Source9,
                     SOURCE9_LENGTH,
                     Merge9,
                     MERGE9_LENGTH,
                     &Target,
                     &TargetLength,
                     START_INDEX9,
                     END_INDEX9
                    );
    if (TargetLength != TARGET9_LENGTH) {
        printf("merge 9 failed\n");
        printf("TargetLength is %d.  expected %d\n",TargetLength,TARGET9_LENGTH);
    }
    if (memcmp(Target,Target9,TargetLength)) {
        printf("Target didn't match\n");
        for (i=0;i<TargetLength;i++) {
            printf("returned attr is %d\n",Target[i].Attr);
            printf("returned length is %d\n",Target[i].Length);
            printf("expected attr is %d\n",Target9[i].Attr);
            printf("expected length is %d\n",Target9[i].Length);
        }
    }
    MergeAttrStrings(Source10,
                     SOURCE10_LENGTH,
                     Merge10,
                     MERGE10_LENGTH,
                     &Target,
                     &TargetLength,
                     START_INDEX10,
                     END_INDEX10
                    );
    if (TargetLength != TARGET10_LENGTH) {
        printf("merge 10 failed\n");
        printf("TargetLength is %d.  expected %d\n",TargetLength,TARGET10_LENGTH);
    }
    if (memcmp(Target,Target10,TargetLength)) {
        printf("Target didn't match\n");
        for (i=0;i<TargetLength;i++) {
            printf("returned attr is %d\n",Target[i].Attr);
            printf("returned length is %d\n",Target[i].Length);
            printf("expected attr is %d\n",Target10[i].Attr);
            printf("expected length is %d\n",Target10[i].Length);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\test\palette\palette.c ===
/*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*/

#include <windows.h>
#include <string.h>
#include <stdlib.h>
#include <conapi.h>
#include <stdio.h>

#define FOREGROUND_WHITE (FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED)



BYTE MyPalette[64] =
       { 0,   0,   0x80,0 ,       // 1
         0,   0x80,0,   0 ,       // 2
         0,   0,   0,   0 ,       // 0
         0,   0x80,0x80,0 ,       // 3
         0x80,0,   0,   0 ,       // 4
         0x80,0,   0x80,0 ,       // 5
         0x80,0x80,0,   0 ,       // 6
         0xC0,0xC0,0xC0,0 ,       // 7
         0x80,0x80,0x80,0 ,       // 8
         0,   0,   0xFF,0 ,       // 9
         0,   0xFF,0,   0 ,       // 10
         0,   0xFF,0xFF,0 ,       // 11
         0xFF,0,   0,   0 ,       // 12
         0xFF,0,   0xFF,0 ,       // 13
         0xFF,0xFF,0,   0 ,       // 14
         0xFF,0xFF,0xFF,0 };      // 15


DWORD
__cdecl main(
    int argc,
    char *argv[])
{
    BOOL Success;
    int i;
    HPALETTE hPalette;
    LOGPALETTE *Palette;
    HANDLE hgo;
    CONSOLE_GRAPHICS_BUFFER_INFO cgbi;

    Palette = LocalAlloc(LMEM_FIXED,
                    sizeof(LOGPALETTE) + 256 * sizeof(PALETTEENTRY));

    Palette->palNumEntries = (WORD) 256;
    Palette->palVersion    = 0x300;

    /* Fill in the palette entries from the DIB color table and
     * create a logical color palette.
     */

    for (i = 0; i < 256; i++) {
        Palette->palPalEntry[i].peRed   = 255-i;
        Palette->palPalEntry[i].peGreen = 255-i;
        Palette->palPalEntry[i].peBlue  = 255-i;
        Palette->palPalEntry[i].peFlags = (BYTE)0;
    }

    hPalette = CreatePalette(Palette);
    if (hPalette==NULL) {
        printf("first CreatePalette failed\n");
        printf("last error is %x\n",GetLastError());
    }

#if 0
call
HANDLE
APIENTRY
CreateConsoleScreenBuffer(
    DWORD dwDesiredAccess,
    DWORD dwShareMode,
    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwFlags,  == CONSOLE_GRAPHICS_BUFFER
    PVOID lpScreenBufferData == pCONSOLE_GRAPHICS_BUFFER_INFO
    );
typedef struct _CONSOLE_GRAPHICS_BUFFER_INFO {
    DWORD dwBitMapInfoLength;
    LPBITMAPINFO lpBitMapInfo;
    DWORD dwUsage;
    HANDLE hMutex;
    PVOID lpBitMap;
} CONSOLE_GRAPHICS_BUFFER_INFO, *PCONSOLE_GRAPHICS_BUFFER_INFO;


#define CONSOLE_GRAPHICS_BUFFER  2
#endif
    hgo = CreateConsoleScreenBuffer(MAXIMUM_ALLOWED, 0, NULL,
            CONSOLE_GRAPHICS_BUFFER, &cgbi);
    if (hgo == NULL) {
        OutputDebugString("CreateConsoleScreenBuffer failed\n");
        return FALSE;
    }
    Success = SetConsolePalette(hgo,
                                hPalette,
                                SYSPAL_NOSTATIC
                               );
    if (!Success) {
        printf("first SetConsolePalette failed\n");
    }
    printf("palette should be different\n");
    Sleep(5000);
    DeleteObject(hPalette);

    /* Fill in the palette entries from the DIB color table and
     * create a logical color palette.
     */

    for (i = 0; i < 16; i++) {
        memcpy(&Palette->palPalEntry[i],
               MyPalette,
               64
              );
    }

    hPalette = CreatePalette(Palette);
    if (hPalette==NULL) {
        printf("first CreatePalette failed\n");
    }

    Success = SetConsolePalette(hgo,
                                hPalette,
                                SYSPAL_STATIC
                               );
    if (!Success) {
        printf("second SetConsolePalette failed\n");
    }
    printf("palette should be different\n");
    Sleep(5000);
    DeleteObject(hPalette);

    printf( "TCURSOR: Exiting Test Program\n" );
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\test\writescy\writescy.c ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <io.h>

PrintUsage() {
    printf("test case for bug #78891 - reported by Chris Mah, April 15th 1997\n");
    printf("Uses WriteConsoleInput() to inject keystrokes for \"ESC y\"\n");

    printf("WritEscY attempts to inject \"ESC y\" into the console input stream\n");
    printf("It does this by constructing KeyEvents with scancode and VK values for\n");
    printf("the Escape and Y key obtained via VkKeyScan() and MapVirtualKey().\n");
    printf("Usage:  writescy [-x]\n");
    printf("  -x :  use VK_ESCAPE literally\n");
    printf("        (default uses VkKeyScanEx(0x1b) to get the VK)\n");
}

int _cdecl main(int argc, char *argv[]) {
    DWORD dwNumWrites;
    INPUT_RECORD inputESC_Y[6];
    BOOL retval;
    int iArg;
    BOOL fLiteral = FALSE;

    /*
     * Compute the flags
     */
    for (iArg=1; iArg<argc; iArg++) {
        if ((argv[iArg][0] == '-') || (argv[iArg][0] == '/')) {
            switch (argv[iArg][1]) {
            case 'x':
                fLiteral = TRUE;
                break;

            default:
                printf("ERROR: Invalid flag %c\n", argv[iArg][1]);

            case '?':
                PrintUsage();
                return 0;
            }
        } else {
            PrintUsage();
            return 0;
        }
    }

    printf("VkKeyScan(0x1b) returns 0x%02x\n", VkKeyScan(0x1b));
    printf("MapVirtualKey(VkKeyScan(0x1b),0) returns 0x%02x\n", MapVirtualKey(VkKeyScan(0x1b),0));

    printf("VK_ESCAPE is 0x%02x\n", VK_ESCAPE);
    printf("MapVirtualKey(VK_ESCAPE,0) returns 0x%02x\n", MapVirtualKey(VK_ESCAPE,0));
    printf("========================================================\n\n");

  if (!fLiteral) {
    printf("Using VkKeyScan(0x1b): ");
    inputESC_Y[0].EventType = KEY_EVENT;
    inputESC_Y[0].Event.KeyEvent.bKeyDown = TRUE;
    inputESC_Y[0].Event.KeyEvent.wRepeatCount = 1;
    inputESC_Y[0].Event.KeyEvent.wVirtualKeyCode = VkKeyScan(27);
    inputESC_Y[0].Event.KeyEvent.wVirtualScanCode = (WORD)MapVirtualKey(VkKeyScan(27),0);
    inputESC_Y[0].Event.KeyEvent.uChar.AsciiChar = 27;
    inputESC_Y[0].Event.KeyEvent.dwControlKeyState = 0;

    inputESC_Y[1].EventType = KEY_EVENT;
    inputESC_Y[1].Event.KeyEvent.bKeyDown = FALSE;
    inputESC_Y[1].Event.KeyEvent.wRepeatCount = 1;
    inputESC_Y[1].Event.KeyEvent.wVirtualKeyCode = VkKeyScan(27);
    inputESC_Y[1].Event.KeyEvent.wVirtualScanCode = (WORD)MapVirtualKey(VkKeyScan(27),0);
    inputESC_Y[1].Event.KeyEvent.uChar.AsciiChar = 27;
    inputESC_Y[1].Event.KeyEvent.dwControlKeyState = 0;

    inputESC_Y[2].EventType = KEY_EVENT;
    inputESC_Y[2].Event.KeyEvent.bKeyDown = TRUE;
    inputESC_Y[2].Event.KeyEvent.wRepeatCount = 1;
    inputESC_Y[2].Event.KeyEvent.wVirtualKeyCode = VkKeyScan('y');
    inputESC_Y[2].Event.KeyEvent.wVirtualScanCode = (WORD)MapVirtualKey(VkKeyScan('y'),0);
    inputESC_Y[2].Event.KeyEvent.uChar.AsciiChar = 'y';
    inputESC_Y[2].Event.KeyEvent.dwControlKeyState = 0;

    inputESC_Y[3].EventType = KEY_EVENT;
    inputESC_Y[3].Event.KeyEvent.bKeyDown = FALSE;
    inputESC_Y[3].Event.KeyEvent.wRepeatCount = 1;
    inputESC_Y[3].Event.KeyEvent.wVirtualKeyCode = VkKeyScan('y');
    inputESC_Y[3].Event.KeyEvent.wVirtualScanCode = (WORD)MapVirtualKey(VkKeyScan('y'),0);
    inputESC_Y[3].Event.KeyEvent.uChar.AsciiChar = 'y';
    inputESC_Y[3].Event.KeyEvent.dwControlKeyState = 0;

    retval = WriteConsoleInput( GetStdHandle(STD_INPUT_HANDLE), &inputESC_Y[0], 4, &dwNumWrites );

    printf("done: value returned by WriteConsoleOutput was (BOOL)%lx\n", retval);
    return 0;
  }

  printf("Using VK_ESCAPE: ");
  inputESC_Y[0].EventType = KEY_EVENT;
  inputESC_Y[0].Event.KeyEvent.bKeyDown = TRUE;
  inputESC_Y[0].Event.KeyEvent.wRepeatCount = 1;
  inputESC_Y[0].Event.KeyEvent.wVirtualKeyCode = VK_ESCAPE;
  inputESC_Y[0].Event.KeyEvent.wVirtualScanCode = (WORD)MapVirtualKey(VK_ESCAPE,0);
  inputESC_Y[0].Event.KeyEvent.uChar.AsciiChar = 27;
  inputESC_Y[0].Event.KeyEvent.dwControlKeyState = 0;

  inputESC_Y[1].EventType = KEY_EVENT;
  inputESC_Y[1].Event.KeyEvent.bKeyDown = FALSE;
  inputESC_Y[1].Event.KeyEvent.wRepeatCount = 1;
  inputESC_Y[1].Event.KeyEvent.wVirtualKeyCode = VK_ESCAPE;
  inputESC_Y[1].Event.KeyEvent.wVirtualScanCode = (WORD)MapVirtualKey(VK_ESCAPE,0);
  inputESC_Y[1].Event.KeyEvent.uChar.AsciiChar = 27;
  inputESC_Y[1].Event.KeyEvent.dwControlKeyState = 0;

  inputESC_Y[2].EventType = KEY_EVENT;
  inputESC_Y[2].Event.KeyEvent.bKeyDown = TRUE;
  inputESC_Y[2].Event.KeyEvent.wRepeatCount = 1;
  inputESC_Y[2].Event.KeyEvent.wVirtualKeyCode = VkKeyScan('y');
  inputESC_Y[2].Event.KeyEvent.wVirtualScanCode = (WORD)MapVirtualKey(VkKeyScan('y'),0);
  inputESC_Y[2].Event.KeyEvent.uChar.AsciiChar = 'y';
  inputESC_Y[2].Event.KeyEvent.dwControlKeyState = 0;

  inputESC_Y[3].EventType = KEY_EVENT;
  inputESC_Y[3].Event.KeyEvent.bKeyDown = FALSE;
  inputESC_Y[3].Event.KeyEvent.wRepeatCount = 1;
  inputESC_Y[3].Event.KeyEvent.wVirtualKeyCode = VkKeyScan('y');
  inputESC_Y[3].Event.KeyEvent.wVirtualScanCode = (WORD)MapVirtualKey(VkKeyScan('y'),0);
  inputESC_Y[3].Event.KeyEvent.uChar.AsciiChar = 'y';
  inputESC_Y[3].Event.KeyEvent.dwControlKeyState = 0;

  retval = WriteConsoleInput( GetStdHandle(STD_INPUT_HANDLE), &inputESC_Y[0], 4, &dwNumWrites );

  printf("done: value returned by WriteConsoleOutput was (BOOL)%lx\n", retval);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\apps\gdistats\gdistats.h ===
/****************************************************************************\

Gdistat.h

\****************************************************************************/


/************************************* PROTOTYPES ****************************/

BOOL   CALLBACK GSDlgProc (HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam);

BOOL   UpdateProcessList(HWND hWnd);
VOID   UpdateIndexList(HWND hWnd);

LONG   ValidateIndexSelection (HWND hMainWindow, HWND hErrorWindow);
HANDLE ValidateProcessSelection (HWND hMainWindow, HWND hErrorWindow);

VOID   UpdateRadioButtons(HWND hWnd);
int    WhichRadioButton  (HWND hWnd);

VOID   DoQuery(HWND hWnd);
VOID   DisplayResults(HWND hResultWindow, PVOID pResults, UINT cjResultSize, LONG nIndex);
VOID   ErrorString(HWND hResultList, LPTSTR szErrorString);

//Procedures for getting information about currently running processes
LONG   FindProcessList(PVOID * ppInfo);
LONG   GetNextProcString (PVOID * pInfo, LPTSTR szProcStr, HANDLE * phProc);
LONG   GetNtProcInfo(PVOID pProcessInfo, ULONG lDataSize, ULONG * pRetSize);

/************************************* DEFINES ******************************/

//The types of queries allowed
#define NUM_INDEX_VALUES   6        //Number of defined indexes

//Must correspond with the OBJECT_OWNER_xxx defines in gre.h
#define OBJS_ALL      0x0001
#define OBJS_PUBLIC   0x0000
#define OBJS_CURRENT  0x8000

//Information about the gdi objects
//The NUMOBJS should be keep consistent with the number of objects as defined in ntgdistr.h
#define ENTRYSIZE     sizeof(DWORD)
#define NUM_GDI_OBJS  31                 //Number of GDI objects
#define NUM_USER_OBJS 18                 //Number of USER objects

//Private representation of PUBLIC and ALL for the dialog box
#define SEL_PUBLIC -1
#define SEL_ALL -2
#define SEL_ONE 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\apps\gdistats\gs_dlg.h ===
#define GD_DIALOG                       101
#define GD_EXIT                         1000
#define GD_INDEX                        1001
#define GD_RESULT                       1002
#define GD_PROCESS                      1003
#define GD_GO                           1004
#define GD_RADIO_ALL                    1005
#define GD_RADIO_PUBLIC                 1006
#define GD_RADIO_ONE                    1007
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\apps\newdisp\newdisp.c ===
/******************************Module*Header*******************************\
* Module Name: newdisp.c
*
* Contains the code to cause the current display driver to be unloaded
* and reloaded.
*
* Created: 18-Feb-1997
* Author: J. Andrew Goossen [andrewgo]
*
* Copyright (c) 1997-1998 Microsoft Corporation
*
\**************************************************************************/

#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <windows.h>

#define STR_ACCELERATIONLEVEL   (LPSTR)"Acceleration.Level"
#define DD_PRIMARY_FLAGS        (DISPLAY_DEVICE_PRIMARY_DEVICE | DISPLAY_DEVICE_ATTACHED_TO_DESKTOP)

BOOL bGetDriverKey(
    PSTR pszKey
    )
{
    BOOL            Found = FALSE;
    DISPLAY_DEVICEA DispDev;
    DWORD           iDevNum = 0;
    PSTR            pszRegPath;

    if (pszKey == NULL) return FALSE;

    DispDev.cb = sizeof(DispDev);

    while (EnumDisplayDevicesA(NULL, iDevNum, &DispDev, 0))
    {
        if ((DispDev.StateFlags & DD_PRIMARY_FLAGS) == DD_PRIMARY_FLAGS)
        {
            pszRegPath = strstr(_strupr(DispDev.DeviceKey), "SYSTEM\\");

            if (pszRegPath)
            {
                strcpy(pszKey, pszRegPath);
                Found = TRUE;
            }
            else
            {
                printf("Couldn't extract reg key.\n");
            }

            break;
        }

        iDevNum++;
    }

    return Found;
}


VOID vSetLevel(int iLevel)
{
    CHAR    szRegKey[128] = "";
    HKEY    hkey = NULL;
    DWORD   dwAction;
    DWORD   cjSize;

    cjSize = sizeof(DWORD);

    if (!bGetDriverKey(szRegKey) ||
        (RegCreateKeyExA(HKEY_LOCAL_MACHINE,
                         szRegKey,
                         0, // Reserved
                         (LPSTR) NULL,
                         REG_OPTION_NON_VOLATILE,
                         KEY_READ | KEY_WRITE,
                         (LPSECURITY_ATTRIBUTES) NULL,
                         &hkey,
                         &dwAction) != ERROR_SUCCESS) ||
        (RegSetValueExA(hkey,
                        STR_ACCELERATIONLEVEL,
                        0, // Reserved
                        REG_DWORD,
                        (BYTE *) &iLevel,
                        cjSize) != ERROR_SUCCESS))
    {
        MessageBox(0,
                   "Couldn't update acceleration level registry key",
                   "Oh no, we failed!",
                   MB_OK);
    }

    RegCloseKey(hkey);
}

DWORD dwGetLevel()
{
    CHAR    szRegKey[128] = "";
    HKEY    hkey = NULL;
    DWORD   dwAction;
    DWORD   cjSize;
    DWORD   dwLevel;
    DWORD   dwDataType;

    cjSize = sizeof(DWORD);

    if (!bGetDriverKey(szRegKey) ||
        (RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                       szRegKey,
                       0, // Reserved
                       KEY_READ,
                       &hkey) != ERROR_SUCCESS) ||
        (RegQueryValueExA(hkey,
                          STR_ACCELERATIONLEVEL,
                          (LPDWORD) NULL,
                          &dwDataType,
                          (LPBYTE) &dwLevel,
                          &cjSize) != ERROR_SUCCESS))
    {
        // The default level if the key doesn't exist is 0:

        dwLevel = 0;
    }

    RegCloseKey(hkey);

    return(dwLevel);
}

VOID vReloadDisplayDriver()
{
    DEVMODE dm;

    // First, switch to 640x480x16 colors, which is almost guaranteed to load
    // the VGA driver:

    dm.dmSize       = sizeof(dm);
    dm.dmPelsWidth  = 640;
    dm.dmPelsHeight = 480;
    dm.dmBitsPerPel = 4;
    dm.dmFields     = (DM_PELSWIDTH | DM_PELSHEIGHT | DM_BITSPERPEL);

    if (ChangeDisplaySettings(&dm, CDS_FULLSCREEN) != DISP_CHANGE_SUCCESSFUL)
    {
        MessageBox(0,
                   "For some reason we couldn't switch to VGA mode, which is necessary for this to work.",
                   "Oh no, we failed!",
                   MB_OK);
    }

    // Now restore the original mode, which will load the old display
    // driver:

    ChangeDisplaySettings(NULL, CDS_FULLSCREEN);
}

int __cdecl main(int argc, char** argv)
{
    DWORD dwLevel;
    CHAR* pchValue;
    int   iValue;

    while (--argc > 0)
    {
        CHAR* pchArg   = *++argv;

        if (strlen(pchArg) < 2 || (*pchArg != '/' && *pchArg != '-'))
        {
            printf("Illegal switch: '%s'\nTry -?\n", pchArg);
            exit(0);
        }

        // Handle '/x<n>' or '/x <n>'

        if (strlen(pchArg) == 2 && --argc > 0)
            pchValue = *++argv;
        else
            pchValue = pchArg + 2;

        iValue = atoi(pchValue);
        if (iValue < 0)
        {
            printf("Illegal value: '%s'\n", pchValue);
            exit(0);
        }

        switch(*(pchArg + 1))
        {
        case 'l':
        case 'L':
            vSetLevel(iValue);
            break;
        case '?':
            printf("NEWDISP -- Reload the display driver\n\n");
            printf("Switches:\n\n");
            printf("    /L <n> - Set the acceleration level\n\n");
            printf("        0 - Enable all accelerations\n");
            printf("        1 - Disable DrvMovePointer, DrvCreateDeviceBitmap\n");
            printf("        2 - In addition to 1, disable DrvStretchBlt, DrvPlgBlt, DrvFillPath,\n");
            printf("            DrvStrokeAndFillPath, DrvLineTo, DrvStretchBltROP,\n");
            printf("            DrvTransparentBlt, DrvAlphaBlend, DrvGradientFill\n");
            printf("        3 - In addition to 2, disable all DirectDraw and Direct3d accelerations\n");
            printf("        4 - Enable only simple DrvBitBlt, DrvTextOut, DrvCopyBits,\n");
            printf("            DrvStrokePath\n");
            printf("        5 - Disable all accelerations\n");

            exit(0);
        default:
            printf("Illegal switch: '%s'\nTry -?\n", pchArg);
            exit(0);
        }
    }

    dwLevel = dwGetLevel();

    printf("Reloading driver with acceleration level %li\n", dwLevel);

    if (dwLevel == 0)
        printf("(All driver accelerations enabled)");
    else if ((dwLevel > 0) && (dwLevel < 5))
        printf("(Some driver accelerations disabled)");
    else if (dwLevel == 5)
        printf("(All driver accelerations disabled)");
    else
        printf("(Unknown or invalid acceleration level!)");

    vReloadDisplayDriver();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntcon\test\wait\wait.c ===
/*
* Copyright (c) 1985 - 1999, Microsoft Corporation
*/

#include <windows.h>
#include <stdio.h>


DWORD
__cdecl main(
    int argc,
    char *argv[])
{
    DWORD Status;
    ULONG BytesTransferred;
    INPUT_RECORD Char;
    BOOL Success;
    HANDLE Array[1];
    int i;

    FlushConsoleInputBuffer(GetStdHandle(STD_INPUT_HANDLE));
    for (i=0;i<2;i++) {
        printf("Waiting...\n");
        Status = WaitForSingleObject(GetStdHandle(STD_INPUT_HANDLE),-1);
        if (Status != 0) {
            printf("wait failed %lx\n",Status);
            return 1;
        }
        Success = ReadConsoleInput(GetStdHandle(STD_INPUT_HANDLE),
                           &Char,
                           1,
                           &BytesTransferred
                          );
        if (Status != 0) {
            printf("read failed %lx\n",Status);
            return 1;
        }
        if (BytesTransferred != 1) {
           printf("Read returned %d chars\n",BytesTransferred);
        }
        printf("Read returned %c\n",Char.Event.KeyEvent.uChar.AsciiChar);
    }

    Array[0] = GetStdHandle(STD_INPUT_HANDLE);
    for (i=0;i<2;i++) {
        printf("Waiting...\n");
        Status = WaitForMultipleObjects(1,Array,FALSE,-1);
        if (Status != 0) {
            printf("wait failed %lx\n",Status);
            return 1;
        }
        Success = ReadConsoleInput(GetStdHandle(STD_INPUT_HANDLE),
                           &Char,
                           1,
                           &BytesTransferred
                          );
        if (Status != 0) {
            printf("read failed %lx\n",Status);
            return 1;
        }
        if (BytesTransferred != 1) {
           printf("Read returned %d chars\n",BytesTransferred);
        }
        printf("Read returned %c\n",Char.Event.KeyEvent.uChar.AsciiChar);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\apps\gdistats\gdistats.c ===
/***********************************************

Name: gdistat.c

Description:

This tool is designed to retrieve information about
GDI and USER objects from their handle managers. It runs as
an user application.

Won't work with 3.51 and earlier releases

It can retrieve the number of objects associated with each
process, as well as the total number of objects in the system
and public objects. On checked builds it can also retrieve
the same data as displayed with the !gdiexts.dumphmgr function.

Future Changes:

The following information describes the changes necessary to
add new queries in future (for example memory information):

  -Add a new entry in the indexlist array in gdistats.c
  -increment the value of NUM_INDEX_VALUES in gdistats.h
  -add a new #define GS_xxxxx to ntgdi.h
  -add code to NtGdiGetStats in hmgrapi.cxx to deal with
       the new item. Ensure that the buffer size specified in the
       indexlist array is large enough to contain this information.
   OR add code to HMGetStats in handtabl.c to add user queries
  -add code to DisplayResults() in gdistats.c to present the
       results correctly. The default is a raw hex dump.

Changes to the organization of the handle tables, or the
addition of new handle types would require changes to the
aszUserObjType or aszGdiObjType structures.

Uses Unicode. Access must be enabled in the registry
through the Session Manager/global flag/FLG_POOL_ENABLE_TAGGING bit

Other files:
    gsysqry.c

History:
  01-August-1995 -by- Andrew Skowronski [t-andsko]
Added user query, new interface, sum calculated
  14-June-1995 -by- Andrew Skowronski [t-andsko]
Wrote it

************************************************/


#include <windows.h>
#include <tchar.h>
#include "gs_dlg.h"              //dialog box child window values
#include "gdistats.h"

//These values must match with those used by NtGdiGetStats
#define GS_NUM_OBJS_ALL    0  //Gdi queries
#define GS_HANDOBJ_CURRENT 1
#define GS_HANDOBJ_MAX     2
#define GS_HANDOBJ_ALLOC   3
#define GS_LOOKASIDE_INFO  4
#define GU_NUM_OBJS_ALL    5  //User information

/***************************** GLOBALS ****************************/

//This structure gives information about all the queries that are allowed
struct
{
    UINT nIndex;       //Index value
    LPTSTR szLabel;    //String to describe function
    UINT nSize;        //Size of the buffer to store the results
    BOOL bPublic;      //These mark determine whether the radio buttons should
                       //be enabled to select Pubic Objects or a specific process
    BOOL bOneProcess;
}
indexlist [] =
{
    //Gdi object information

    GS_NUM_OBJS_ALL,   _TEXT("Gdi objects per type"),
                       sizeof(DWORD) * NUM_GDI_OBJS,TRUE,TRUE,

    //These queries get information from structures that
    //are only kept in checked builds. It fails elegantly if
    //run on the free build

    GS_HANDOBJ_CURRENT,_TEXT("Gdi Handles/Objects current"),
                       sizeof(DWORD) * NUM_GDI_OBJS * 2,FALSE,FALSE,
    GS_HANDOBJ_MAX,    _TEXT("Gdi Handles/Objects maximum"),
                       sizeof(DWORD) * NUM_GDI_OBJS * 2,FALSE,FALSE,
    GS_HANDOBJ_ALLOC,  _TEXT("Gdi Handles/Objects allocated"),
                       sizeof(DWORD) * NUM_GDI_OBJS * 2,FALSE,FALSE,

    //This information is also only for checked builds.
    //It compares the number of lookaside hits with the total
    //number of objects allocated

    GS_LOOKASIDE_INFO, _TEXT("Gdi Lookaside hit rate"),
                       sizeof(DWORD) * NUM_GDI_OBJS * 2,FALSE,FALSE,

    //The user handle table information

    GU_NUM_OBJS_ALL,   _TEXT("User objects per type"),
                       sizeof(DWORD) * NUM_USER_OBJS,FALSE,TRUE
};

//Each object type for Gdi Objects
LPTSTR aszGdiObjType[] =
{
    _TEXT("DEF             "),   // 0
    _TEXT("DC              "),   // 1
    _TEXT("LDB             "),   // 2
    _TEXT("PDB             "),   // 3
    _TEXT("RGN             "),   // 4
    _TEXT("SURF            "),   // 5
    _TEXT("XFORM           "),   // 6
    _TEXT("PATH            "),   // 7
    _TEXT("PAL             "),   // 8
    _TEXT("FD              "),   // 9
    _TEXT("LFONT           "),   // 10
    _TEXT("RFONT           "),   // 11
    _TEXT("PFE             "),   // 12
    _TEXT("PFT             "),   // 13
    _TEXT("IDB             "),   // 14
    _TEXT("XLATE           "),   // 15
    _TEXT("BRUSH           "),   // 16
    _TEXT("PFF             "),   // 17
    _TEXT("CACHE           "),   // 18
    _TEXT("SPACE           "),   // 19
    _TEXT("DBRUSH          "),   // 20
    _TEXT("META            "),   // 21
    _TEXT("EFSTA           "),   // 22
    _TEXT("BMFD            "),   // 23
    _TEXT("VTFD            "),   // 24
    _TEXT("TTFD            "),   // 25
    _TEXT("RC              "),   // 26
    _TEXT("TEMP            "),   // 27
    _TEXT("DRVOBJ          "),   // 28
    _TEXT("DCIOBJ          "),   // 29
    _TEXT("SPOOL           ")    // 30
};

//Each object type for User objects
LPTSTR aszUserObjType[] =
{
    _TEXT("Free            "),   // 0
    _TEXT("Window          "),   // 1
    _TEXT("Menu            "),   // 2
    _TEXT("Icon/Cursor     "),   // 3
    _TEXT("SWP Structure   "),   // 4
    _TEXT("Hook            "),   // 5
    _TEXT("ClipData        "),   // 6
    _TEXT("CallProcData    "),   // 7
    _TEXT("Accelerator     "),   // 8
    _TEXT("DDE Access      "),   // 9
    _TEXT("DDE Conv        "),   // 10
    _TEXT("DDE Transaction "),   // 11
    _TEXT("Monitor         "),   // 12
    _TEXT("Keyboard layout "),   // 13
    _TEXT("Keyboard File   "),   // 14
    _TEXT("Winevent        "),   // 15
    _TEXT("Timer           "),   // 16
    _TEXT("InputContext    "),   // 17
    _TEXT("Undefined       ")    // Should never occur
};

// This ones replace HMGetStats and are private in user32.dll
#define QUC_PID_TOTAL           0xffffffff
#define QUERYUSER_HANDLES       0x1

BOOL (WINAPI *QueryUserCounters)(DWORD, LPVOID, DWORD, LPVOID, DWORD );
int NtGdiGetStats(HANDLE,int,int,PVOID,UINT);

/***********************************************

Main Procedure

***********************************************/

int __cdecl main ()

{
    HANDLE hWndDialog;
    MSG    msg;

    TCHAR   szUser32DllPath[MAX_PATH+15];
    HMODULE hUser32Module;

    HANDLE hInstance;
    hInstance = GetModuleHandle(NULL);

    if (!GetSystemDirectory(szUser32DllPath, MAX_PATH+1)) {
        return 0;
    }
    wcscat( szUser32DllPath, L"\\user32.dll");

    hUser32Module = GetModuleHandle(szUser32DllPath);
    if (!hUser32Module) {
        return 0;
    }
    QueryUserCounters = (BOOL (WINAPI  *)(DWORD, LPVOID, DWORD, LPVOID, DWORD ))
                    GetProcAddress(hUser32Module, "QueryUserCounters");
    if (!QueryUserCounters) {
        return 0;
    }

    hWndDialog = CreateDialogParam (hInstance,
                                    MAKEINTRESOURCE (GD_DIALOG),
                                    NULL,
                                    (DLGPROC) GSDlgProc,
                                    (LONG) 0);

    while(GetMessage (&msg, NULL, 0, 0))
        if (!IsDialogMessage (hWndDialog, &msg))
        {
            TranslateMessage (&msg);
            DispatchMessage (&msg);
        }

    DestroyWindow (hWndDialog);
    return 0;

}


/*************************************************

Dialog Procedure

*************************************************/

BOOL CALLBACK GSDlgProc (HWND hWnd, UINT wMsg, WPARAM wParam, LPARAM lParam)
{

    switch (wMsg)
    {
        //Initialize everything
        case WM_INITDIALOG :
            SetClassLongPtr(hWnd,
                         GCLP_HICON,
                         (INT_PTR)LoadIcon((HINSTANCE)GetWindowLongPtr(hWnd, GWLP_HINSTANCE),
                                         _TEXT("GSICON")));

            if (!UpdateProcessList(hWnd))
                PostQuitMessage(0);
                UpdateIndexList(hWnd);
                UpdateRadioButtons(hWnd);
                break;


        case WM_CLOSE :
            PostQuitMessage (0);
            break;

        case WM_COMMAND:
            switch (LOWORD (wParam))
            {

                //The list box selection has been changed
                case GD_INDEX :
                    if (HIWORD(wParam) == CBN_SELCHANGE)
                    {
                        UpdateRadioButtons(hWnd);
                        DoQuery(hWnd);
                    }
                    else
                        return FALSE;
                    break;

                //Re-run the query when we double click
                //on the process
                case GD_PROCESS :
                    if (HIWORD(wParam) == CBN_DBLCLK)
                        DoQuery(hWnd);

                    //Refresh the process list every time
                    //the list is displayed to avoid
                    //the need for a refresh button
                    else if (HIWORD(wParam) == CBN_DROPDOWN)
                        UpdateProcessList(hWnd);
                    else
                        return FALSE;
                    break;

                //Exit button
                case GD_EXIT :
                    PostQuitMessage (0);
                    break;

                //Run button
                case GD_GO :
                    DoQuery(hWnd);
                    break;


                default :
                    return FALSE;
                }


        default :
            return FALSE;
    }

    return TRUE;

}



/********************************************************

UpdateProcessList

This function fills in the process combo box with the list of processes
running at the time of this call

It returns FALSE if not successful.

*********************************************************/


BOOL UpdateProcessList(HWND hWnd)
{
    HWND hProcessList;       //Handle to process list box
    PVOID pProcessInfo;      //pointer to process information
    TCHAR  szProcStr[40];    //Buffer for procedure name strings
    DWORD dwStatus;
    LONG lNotLast;
    LRESULT nIndex;          //Position of new string in list
    LRESULT lSavedPos;       //Saved position in list

    HANDLE hProc;            //Handle to the process

    hProcessList = GetDlgItem (hWnd, GD_PROCESS);

    //Remember currently selected item
    lSavedPos = SendMessage(hProcessList, CB_GETCURSEL, 0 ,0);

    SendMessage(hProcessList, WM_SETREDRAW, FALSE, 0);
    SendMessage(hProcessList, CB_RESETCONTENT, 0, 0);


    //Fill in the process information
    dwStatus = FindProcessList(&pProcessInfo);

    if (!dwStatus)
    {
        //Print the process information to screen
        do
        {
            lNotLast = GetNextProcString(&pProcessInfo,szProcStr,&hProc);
            nIndex = SendMessage(hProcessList,CB_ADDSTRING,0,(LPARAM)szProcStr);

            //Associate the handle value with the list box item
            SendMessage(hProcessList,CB_SETITEMDATA,(WPARAM) nIndex,(LPARAM) hProc);
        } while (lNotLast);
    }
    else
    {
        //Unrecoverable error - could not get process information
        MessageBox( hWnd,_TEXT("Unable to create process listing"),_TEXT("ERROR"),MB_OK );
        return FALSE;
    }

    LocalFree (pProcessInfo);

    //Attempt to restore the cursor position
    if (lSavedPos != CB_ERR)
       SendMessage(hProcessList, CB_SETCURSEL, (WPARAM) lSavedPos, 0);
    else
       SendMessage(hProcessList, CB_SETCURSEL, 0, 0);

    SendMessage(hProcessList, WM_SETREDRAW, TRUE, 0);

    return TRUE;

}

/********************************************************
UpdateIndexList

This function fills in the index list with the list of
possible strings associated with each index.

The information comes from the index list array

*********************************************************/

VOID UpdateIndexList(HWND hWnd)
{
    HWND hIndexCombo;
    LONG iCnt;


    hIndexCombo = GetDlgItem (hWnd, GD_INDEX);


    SendMessage(hIndexCombo, WM_SETREDRAW, FALSE, 0);
    SendMessage(hIndexCombo, CB_RESETCONTENT, 0, 0);


    //Fill in the names of the various predefined index values from the indexlist structure
    for (iCnt = 0; iCnt < NUM_INDEX_VALUES; iCnt++)
    {
        SendMessage(hIndexCombo, CB_ADDSTRING, 0, (LPARAM)indexlist[iCnt].szLabel);
    }

    SendMessage(hIndexCombo, CB_SETCURSEL, 0, 0); //Set the first item to be default

    SendMessage(hIndexCombo, WM_SETREDRAW, TRUE, 0);
}



/*******************************************************\
ValidateProcessSelection


Returns the handle to the process selected,
SEL_PUBLIC, SEL_ALL if PUBLIC or ALL are selected,
and 0 otherwise
\*******************************************************/

HANDLE ValidateProcessSelection (HWND hMainWindow, HWND hErrorWindow)
{

    HWND hProcessList;
    HANDLE hSelProcHandle = 0;
    LRESULT nProcIndex;

    hProcessList = GetDlgItem (hMainWindow, GD_PROCESS);

    //Check currently seleted process value
    nProcIndex = SendMessage (hProcessList, CB_GETCURSEL, 0, 0);

    if (nProcIndex != CB_ERR)
    {
        //Get the client handle
        hSelProcHandle = (PVOID) SendMessage(hProcessList,CB_GETITEMDATA,(WPARAM) nProcIndex,0L);
    }
    else
    {
        ErrorString(hErrorWindow, _TEXT("ERROR: Must select a process"));
    }

    return hSelProcHandle;

}

/*******************************************************\
ValidateIndexSelection

Takes the current selection of the index combo box, and
verifies that it is a valid item

Returns the value of the index or -1 if error
\*******************************************************/

LONG ValidateIndexSelection (HWND hMainWindow, HWND hErrorWindow)
{

    HWND hIndexCombo;
    LRESULT nListIndex;
    LONG nQueryIndex = -1;
    TCHAR IndexStr[40];  //the actual data entered in the edit box

    hIndexCombo  = GetDlgItem (hMainWindow, GD_INDEX);

    //Check currently selected Index value
    nListIndex = SendMessage (hIndexCombo, CB_GETCURSEL, 0, 0);
    if (nListIndex != CB_ERR)
    {
        //We don't use the index as the value but the actual constant
        //value from the structure
        nQueryIndex = indexlist[nListIndex].nIndex;
    }
    else  //value was not selected out of the list
    {
        //See if any string has been entered
       if (!SendMessage (hIndexCombo, WM_GETTEXT, 40, (LPARAM)IndexStr))
       {
           ErrorString(hErrorWindow, _TEXT("ERROR: Need to Select Index"));
       }
       else
       {
           //The string should be a valid number (but not zero)
           nQueryIndex = _ttoi(IndexStr);

           if (nQueryIndex == 0)
           {
               nQueryIndex = -1;
               ErrorString(hErrorWindow,_TEXT("ERROR: Index must be from list or a number"));
           }
       }
    }

    return nQueryIndex;
}


/*******************************************************
UpdateRadioButtons

Depending on the currently selected index value,
set which radio buttons are enabled. Handles
the case where nothing is set, and the case
where a selected button becomes disabled.

Assumes the "All Processes" button will never be
disabled
\*******************************************************/

VOID UpdateRadioButtons(HWND hWnd)
{
    HWND hResultList;
    HWND hRadio_All;
    HWND hRadio_One;
    HWND hRadio_Public;
    HWND hProcessList;
    LONG nQueryIndex;
    int  iCurrentChecked;

    hResultList   = GetDlgItem(hWnd, GD_RESULT);
    hRadio_All    = GetDlgItem(hWnd, GD_RADIO_ALL);
    hRadio_Public = GetDlgItem(hWnd, GD_RADIO_PUBLIC);
    hRadio_One    = GetDlgItem(hWnd, GD_RADIO_ONE);
    hProcessList  = GetDlgItem(hWnd, GD_PROCESS);

    nQueryIndex = ValidateIndexSelection(hWnd, hResultList);

    //Save current setting of radio buttons, if any
    iCurrentChecked = WhichRadioButton(hWnd);

    if (nQueryIndex != -1)
    {
        EnableWindow(hRadio_Public,indexlist[nQueryIndex].bPublic);
        EnableWindow(hRadio_One,indexlist[nQueryIndex].bOneProcess);

        //Also disable/enable process list
        EnableWindow(hProcessList,indexlist[nQueryIndex].bOneProcess);
    }

    //Return the setting if the item is not now disabled
    if ((iCurrentChecked == SEL_PUBLIC) && indexlist[nQueryIndex].bPublic)
        CheckRadioButton(hWnd,GD_RADIO_ALL,GD_RADIO_ONE,GD_RADIO_PUBLIC);
    else if ((iCurrentChecked == SEL_ONE) && indexlist[nQueryIndex].bOneProcess)
        CheckRadioButton(hWnd,GD_RADIO_ALL,GD_RADIO_ONE,GD_RADIO_ONE);
    else
        CheckRadioButton(hWnd,GD_RADIO_ALL,GD_RADIO_ONE,GD_RADIO_ALL);
}


/*******************************************************
int WhichRadioButton(HWND hWnd)

Returns the selected radio button
(and returns SEL_ALL if nothing is selected)
\*******************************************************/
int WhichRadioButton(HWND hWnd)
{
    HWND hRadio_One;
    HWND hRadio_Public;
    hRadio_Public = GetDlgItem(hWnd, GD_RADIO_PUBLIC);
    hRadio_One    = GetDlgItem(hWnd, GD_RADIO_ONE);

    if (SendMessage(hRadio_Public, BM_GETCHECK, 0, 0))
        return SEL_PUBLIC;
    else if (SendMessage(hRadio_One, BM_GETCHECK, 0, 0))
        return SEL_ONE;
    else
        return SEL_ALL;
}



/********************************************************

DoQuery

This function does error checking on the user's parameter choices,
then calls the GetGdiStats function.

In the case of an error the error message is displayed in the
result window

*********************************************************/

VOID DoQuery(HWND hWnd)
{
    HWND hResultList;
    BOOL bOk = TRUE;
    UINT nQueryResult = 0;

    //Parameters for the call
    LONG nQueryIndex;
    HANDLE hSelProcHandle = NULL; //the handle of the process selected
    UINT cjResultSize;
    PVOID pvResultBuf;
    LONG lPidType;
    TCHAR szOutputStr[40];


    //Get handles
    hResultList  = GetDlgItem (hWnd, GD_RESULT);

    //Erase results window
    SendMessage(hResultList, WM_SETREDRAW, FALSE, 0);
    SendMessage(hResultList, LB_RESETCONTENT, 0, 0);

    nQueryIndex    = ValidateIndexSelection(hWnd, hResultList);
    cjResultSize   = indexlist[nQueryIndex].nSize;

    switch (WhichRadioButton(hWnd))
    {
        case (SEL_PUBLIC) :
            lPidType = OBJS_PUBLIC;
            break;
        case (SEL_ALL) :
            lPidType = OBJS_ALL;
            break;
        default :
            lPidType = OBJS_CURRENT;
            hSelProcHandle = ValidateProcessSelection(hWnd, hResultList);
            if (!hSelProcHandle)
                bOk = FALSE;
            break;
    }


    bOk = bOk &&
          (nQueryIndex != -1) &&
          (cjResultSize);

    //Allocate memory for results
    if (bOk)
    {
        pvResultBuf = (PVOID) LocalAlloc (LMEM_FIXED | LMEM_ZEROINIT, cjResultSize);
        if (pvResultBuf == NULL)
        {
            bOk = FALSE;
            _stprintf(szOutputStr,
                     _TEXT("ERROR: Memory Allocation failed (0x%lx)"),
                     GetLastError());
            ErrorString(hResultList, szOutputStr);
        }
    }

    //Now we can make the call
    if (bOk)
    {
        if (nQueryIndex != GU_NUM_OBJS_ALL)
        {
            nQueryResult = NtGdiGetStats(hSelProcHandle,nQueryIndex,lPidType,pvResultBuf,cjResultSize);
        }
        else
        {
            DWORD pid;
            pid = (lPidType == OBJS_CURRENT) ? HandleToLong(hSelProcHandle) : QUC_PID_TOTAL;
            nQueryResult = QueryUserCounters(QUERYUSER_HANDLES,
                              &pid,
                              sizeof(DWORD),
                              pvResultBuf,
                              sizeof(DWORD) * NUM_USER_OBJS);
        }

        if (!nQueryResult)
            DisplayResults(hResultList,pvResultBuf,cjResultSize,nQueryIndex);
        else
        {
            _stprintf(szOutputStr,_TEXT("ERROR: Query failed (code 0x%lx)"),nQueryResult);
            ErrorString(hResultList, szOutputStr);
        }
    }

    LocalFree(pvResultBuf);

    //Now show what has been written onto the results list box
    SendMessage(hResultList, WM_SETREDRAW, TRUE, 0);
}

/***************************************************************\
DisplayResults

This function displays the results of the query in the
Result Window
\***************************************************************/

VOID DisplayResults(HWND hResultWindow, PVOID pResults, UINT cjResultSize, LONG nIndex)
{
    DWORD * pdwResults;
    TCHAR   szResultStr[60];
    LONG    cObjSum        = 0;
    LONG    cObjPos        = 0;

    pdwResults = (DWORD *) pResults;

    //The output format is based on the type of query we are running
    switch(nIndex)
    {
        case (GS_NUM_OBJS_ALL) :
        case (GU_NUM_OBJS_ALL) :
            while (cjResultSize)
            {
                //Only print out non-zero results
                if (*pdwResults)
                {
                    //Print out the results with the associated object's name
                    if (nIndex == GS_NUM_OBJS_ALL)
                        {
                        _stprintf(szResultStr, _TEXT("%s%6d"), aszGdiObjType[cObjPos], *pdwResults);
                        }
                    else
                        {
                        _stprintf(szResultStr, _TEXT("%s%6d"), aszUserObjType[cObjPos], *pdwResults);
                        }

                    SendMessage(hResultWindow, LB_ADDSTRING, 0, (LPARAM) szResultStr);

                    cObjSum += *pdwResults;
                }
                pdwResults++;
                cObjPos++;
                cjResultSize -= sizeof(DWORD);
            }

            //print out the sum information
            if (!cObjSum)
                _stprintf(szResultStr, _TEXT("No gdi objects"));
            else
                _stprintf(szResultStr, _TEXT("TOTAL           %6d"),cObjSum);

            SendMessage(hResultWindow, LB_ADDSTRING, 0, (LPARAM) szResultStr);
            break;

        case (GS_HANDOBJ_CURRENT) :
        case (GS_HANDOBJ_MAX)     :
        case (GS_HANDOBJ_ALLOC)   :
        case (GS_LOOKASIDE_INFO)  :
            for (cObjPos = 0; cObjPos < NUM_GDI_OBJS; cObjPos++)
            {
                 if (pdwResults[cObjPos] || pdwResults[cObjPos + NUM_GDI_OBJS])
                 {
                     _stprintf(szResultStr, _TEXT("%s  %6u %6u"),
                               aszGdiObjType[cObjPos],
                               pdwResults[cObjPos],
                               pdwResults[cObjPos + NUM_GDI_OBJS]);
                     SendMessage(hResultWindow, LB_ADDSTRING, 0, (LPARAM) szResultStr);

                     //just want to know if there is at least one entry
                     cObjSum = 1;
                 }
            }

            if (cObjSum)
            {
                if (nIndex != GS_LOOKASIDE_INFO)
                {
                    _stprintf(szResultStr, _TEXT("(Column 1 is handle count,"));
                    SendMessage(hResultWindow,LB_ADDSTRING, 0 , (LPARAM) szResultStr);
                    _stprintf(szResultStr, _TEXT("Column 2 is object count)"));
                    SendMessage(hResultWindow,LB_ADDSTRING, 0 , (LPARAM) szResultStr);
                }
                else
                {
                     _stprintf(szResultStr, _TEXT("(Column 1 is number of hits,"));
                     SendMessage(hResultWindow,LB_ADDSTRING, 0 , (LPARAM) szResultStr);
                     _stprintf(szResultStr, _TEXT("Column 2 is total allocations)"));
                     SendMessage(hResultWindow,LB_ADDSTRING, 0 , (LPARAM) szResultStr);
                }
            }
            else
            {
                //All zero results indicate that the system is not
                //checked
                _stprintf(szResultStr, _TEXT("Valid for Checked builds only"));
                SendMessage(hResultWindow,LB_ADDSTRING, 0 , (LPARAM) szResultStr);
            }
            break;

        default :
            //Raw dump
            while (cjResultSize)
            {
                _stprintf(szResultStr, _TEXT("Result: 0x%lx"), *pdwResults);
                SendMessage(hResultWindow, LB_ADDSTRING, 0, (LPARAM) szResultStr);

                pdwResults++;
                cjResultSize -= sizeof(DWORD);
            }
            break;
    }

}

/*************************************************
ErrorString

This function outputs a string into the error window.
It does not erase the entire window in case more
than one line of errorstrings are to be displayed

***************************************************/

VOID ErrorString(HWND hErrorList, LPTSTR szErrorString)
{
    SendMessage(hErrorList, LB_ADDSTRING, 0, (LPARAM) szErrorString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\apps\gdistats\gsysqry.c ===
/********************************************

gsysqry.c

This file contains all the functions for getting the
list of processes from the system.

*********************************************/

#include <nt.h>
#include <tchar.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include "gdistats.h"

#define SIZE_MEM_INIT 16 * 1024 //Initial buffer size
#define SIZE_MEM_INCR 2048    //Amount to increment buffer

/**************************************************

FindProcessList

This function finds out the list of processes currently
running. It allocates enough space to fit all the 
data and then fills in this data and sets *ppInfo
to point to the correct location.

***************************************************/ 

LONG FindProcessList (PVOID * ppInfo)
{
    ULONG uRetSize;
    PVOID pProcessInfo;     //points to the process information
    LONG lStatus;

    ULONG lDataSize;        //The size of the proc. info buffer

    //Allocate an initial sized buffer
    lDataSize = SIZE_MEM_INIT;
    pProcessInfo = (PVOID) LocalAlloc (LMEM_FIXED, lDataSize);

    do
    {
       if (!pProcessInfo)
           return ERROR_NOT_ENOUGH_MEMORY;

        //Call the NT service to find out the process information
       lStatus = GetNtProcInfo (pProcessInfo,  lDataSize, &uRetSize);

       if (lStatus == STATUS_INFO_LENGTH_MISMATCH)
       {
           LocalFree (pProcessInfo);
           lDataSize += SIZE_MEM_INCR;
           pProcessInfo = (PVOID) LocalAlloc (LMEM_FIXED, lDataSize);
       }

    } while (lStatus == STATUS_INFO_LENGTH_MISMATCH);


    * ppInfo = pProcessInfo;
    return lStatus;
}


/***************************************************************

GetNtProcInfo

This function attempts to fill the pProcessInfo buffer with
the process information. It returns STATUS_INFO_LENGTH_MISMATCH
(0xc0000004) if the buffer is not large enough.

See ntexapi.h for more information

*****************************************************************/
LONG GetNtProcInfo(PVOID pProcessInfo, ULONG lDataSize, ULONG * pRetSize)
{

    //Call the NT service to find out the process information
    return NtQuerySystemInformation (
                                    SystemProcessInformation,
                                    (PSYSTEM_PROCESS_INFORMATION) pProcessInfo,
                                    lDataSize,
                                    pRetSize
                                    );
}


/**************************************************

GetNextProcString

This function retrieves process information from the
position pointed to currently in the process information 
block and then increments the pointer to the next position.

It returns 0 after processing the last process.

We assume there is at least one process running on the
machine.

***************************************************/ 

LONG GetNextProcString (PVOID * pInfo, LPTSTR szProcStr, HANDLE * phProcId)
{
    PSYSTEM_PROCESS_INFORMATION pPosition;

    if (!pInfo)
        return -1;

    pPosition = (PSYSTEM_PROCESS_INFORMATION)  *pInfo;


    //Create the string with the process name (if any) and the
    //handle ID
    if (pPosition->ImageName.Length == 0)
        _stprintf(szProcStr, _TEXT("Idle (0x%p)"), pPosition->UniqueProcessId);
    else
        _stprintf(szProcStr, _TEXT("%s (0x%p)"), pPosition->ImageName.Buffer,
                                        pPosition->UniqueProcessId);

    //Store the value of the ProcessId
    * phProcId = pPosition->UniqueProcessId;

    
    //Update the pointer in the calling function to point
    //to the next entry
    *pInfo = (PVOID) ((PUCHAR) pPosition + pPosition->NextEntryOffset);      

    return pPosition->NextEntryOffset;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\csxobj.cxx ===
/******************************Module*Header*******************************\
* Module Name: csxobj.cxx                                                  *
*                                                                          *
* CSXform object non-inline methods.                                       *
*                                                                          *
* Created: 12-Nov-1990 16:54:37                                            *
* Author: Wendy Wu [wendywu]                                               *
*                                                                          *
* Copyright (c) 1990-1999 Microsoft Corporation                            *
\**************************************************************************/

#define NO_STRICT

#if !defined(_GDIPLUS_)
    #define INITGUID    // Declare any GUIDs
#endif

extern "C" {

#if defined(_GDIPLUS_)
#include <gpprefix.h>
#endif

#include <string.h>
#include <stdio.h>

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <windows.h>    // GDI function declarations.
#include <winspool.h>
#include "nlsconv.h"    // UNICODE helpers
#include "firewall.h"
#define __CPLUSPLUS
#include <winspool.h>
#include <w32gdip.h>
#include "ntgdistr.h"
#include "winddi.h"
#include "hmgshare.h"
#include "icm.h"
#include "local.h"      // Local object support.
#include "gdiicm.h"
#include "metadef.h"    // Metafile record type constants.
#include "metarec.h"
#include "mf16.h"
#include "ntgdi.h"
#include "glsup.h"
}

#include "xfflags.h"
#include "csxobj.hxx"

#if defined(_AMD64_) || defined(_IA64_) || defined(BUILD_WOW6432)
#define vSetTo1Over16(ef)   (ef.e = EFLOAT_1Over16)
#else
#define vSetTo1Over16(ef)   (ef.i.lMant = 0x040000000, ef.i.lExp = -2)
#endif

#ifndef _BASETSD_H_
typedef size_t SIZE_T;
#endif

extern "C" {
BOOL bCvtPts1(PMATRIX pmx, PPOINTL pptl, SIZE_T cPts);
BOOL bCvtPts(PMATRIX pmx, PPOINTL pSrc, PPOINTL pDest, SIZE_T cPts);
};


#define bIsIdentity(fl) ((fl & (XFORM_UNITY | XFORM_NO_TRANSLATION)) == \
                               (XFORM_UNITY | XFORM_NO_TRANSLATION))


/******************************Public*Routine******************************\
* DPtoLP()
*
* History:
*
*  12-Mar-1996 -by- Mark Enstrom [marke]
*   Use cached dc transform data
*  01-Dec-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY DPtoLP(HDC hdc, LPPOINT pptl, int c)
{
    PDC_ATTR pdcattr;
    PVOID    pvuser;
    BOOL     bRet = TRUE;

    if (c > 0)
    {
        PSHARED_GET_VALIDATE(pvuser,hdc,DC_TYPE);

        pdcattr = (PDC_ATTR)pvuser;

        if (pdcattr)
        {
            if (
                 pdcattr->flXform &
                 (
                   PAGE_XLATE_CHANGED   |
                   PAGE_EXTENTS_CHANGED |
                   WORLD_XFORM_CHANGED  |
                   DEVICE_TO_WORLD_INVALID
                 )
               )
            {
                bRet = NtGdiTransformPoints(hdc,pptl,pptl,c,XFP_DPTOLP);
            }
            else
            {
                //
                // xform is valid, transform in user mode
                //

                PMATRIX pmx = (PMATRIX)&(pdcattr->mxDtoW);

                if (!bIsIdentity(pmx->flAccel))
                {
                    if (!bCvtPts1(pmx, (PPOINTL)pptl, c))
                    {
                        GdiSetLastError(ERROR_ARITHMETIC_OVERFLOW);
                        bRet = FALSE;
                    }
                }
            }
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            bRet = FALSE;
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* LPtoDP()
*
* History:
*  12-Mar-1996 -by- Mark Enstrom [marke]
*   Use cached dc transform data
*  01-Dec-1994 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY LPtoDP(HDC hdc, LPPOINT pptl, int c)
{
    PDC_ATTR pdcattr;
    PVOID    pvuser;
    BOOL     bRet = TRUE;

    if (c > 0)
    {
        PSHARED_GET_VALIDATE(pvuser,hdc,DC_TYPE);

        pdcattr = (PDC_ATTR)pvuser;

        if (pdcattr)
        {
            if (pdcattr->flXform & (PAGE_XLATE_CHANGED | PAGE_EXTENTS_CHANGED |
                            WORLD_XFORM_CHANGED))
            {
                //
                // transform needs to be updated, call kernel
                //

                bRet = NtGdiTransformPoints(hdc,pptl,pptl,c,XFP_LPTODP);
            }
            else
            {
                //
                // transform is valid, transform points locally
                //

                PMATRIX pmx = (PMATRIX)&(pdcattr->mxWtoD);

                if (!bIsIdentity(pmx->flAccel))
                {

                    #if DBG_XFORM
                        DbgPrint("LPtoDP: NOT IDENTITY, hdc = %p, flAccel = %lx\n", hdc, pmx->flAccel);
                    #endif

                    if (!bCvtPts1(pmx, (PPOINTL)pptl, c))
                    {
                        GdiSetLastError(ERROR_ARITHMETIC_OVERFLOW);
                        bRet = FALSE;
                    }
                }
            }
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            bRet = FALSE;
        }
    }

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\d3dstub.h ===
/******************************Module*Header*******************************\
* Module Name: d3dstub.h
*
* Information shared between DirectDraw and Direct3D stubs
*
* Created: 04-June-1996
* Author: Drew Bliss [drewb]
*
* Copyright (c) 1995-1999 Microsoft Corporation
\**************************************************************************/

#ifndef __D3DSTUB_H__
#define __D3DSTUB_H__

DWORD WINAPI D3dContextCreate(LPD3DHAL_CONTEXTCREATEDATA);
DWORD WINAPI D3dRenderState(LPD3DHAL_RENDERSTATEDATA);
DWORD WINAPI D3dRenderPrimitive(LPD3DHAL_RENDERPRIMITIVEDATA);
DWORD WINAPI D3dTextureCreate(LPD3DHAL_TEXTURECREATEDATA);
DWORD WINAPI D3dTextureGetSurf(LPD3DHAL_TEXTUREGETSURFDATA);
DWORD WINAPI D3dSetRenderTarget(LPD3DHAL_SETRENDERTARGETDATA);
DWORD WINAPI D3dDrawPrimitives2(LPD3DHAL_DRAWPRIMITIVES2DATA);

#endif // __D3DSTUB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\d3d.c ===
/******************************Module*Header*******************************\
* Module Name: d3d.c
*
* Client side stubs for the private Direct3D system APIs.
*
* Created: 31-May-1996
* Author: Drew Bliss [drewb]
*
* Copyright (c) 1995-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#undef _NO_COM
#define BUILD_DDDDK
#include <ddrawi.h>
#include "ddstub.h"
#include "d3dstub.h"

// Go from a public DirectDraw surface to a surface handle
#define DDS_HANDLE(lpDDSLcl) \
    ((HANDLE)(lpDDSLcl->hDDSurface))

// Go from a public DirectDraw surface to a surface handle, handling the
// NULL case
#define DDS_HANDLE_OR_NULL(pdds) \
    ((pdds) != NULL ? DDS_HANDLE(pdds) : NULL)

/******************************Public*Routine******************************\
*
* D3dContextCreate
*
* History:
*  Mon Jun 03 14:18:29 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

DWORD WINAPI D3dContextCreate(LPD3DHAL_CONTEXTCREATEDATA pdccd)
{
    ASSERTGDI(FIELD_OFFSET(D3DNTHAL_CONTEXTCREATEI, pvBuffer) ==
              sizeof(D3DHAL_CONTEXTCREATEDATA),
              "D3DNTHAL_CONTEXTCREATEI out of sync\n");

    return NtGdiD3dContextCreate(DD_HANDLE(pdccd->lpDDLcl->hDD),
                                 DDS_HANDLE(pdccd->lpDDSLcl),
                                 DDS_HANDLE_OR_NULL(pdccd->lpDDSZLcl),
                                 (D3DNTHAL_CONTEXTCREATEI *)pdccd);
}


/******************************Public*Routine******************************\
*
* D3dDrawPrimitives2
*
* History:
*  Mon Jun 17 13:27:05 1996	-by-	Anantha Kancherla [anankan]
*   Created
*
\**************************************************************************/

DWORD WINAPI D3dDrawPrimitives2(LPD3DHAL_DRAWPRIMITIVES2DATA pdp2data)
{
    if (pdp2data->dwFlags & D3DHALDP2_USERMEMVERTICES)
    {
        return NtGdiD3dDrawPrimitives2 (
            (HANDLE)pdp2data->lpDDCommands->hDDSurface,
            NULL, // No DDraw surface, pass NULL handle
            (LPD3DNTHAL_DRAWPRIMITIVES2DATA)pdp2data,
            &pdp2data->lpDDCommands->lpGbl->fpVidMem,
            &pdp2data->lpDDCommands->lpGbl->dwLinearSize,
            NULL,
            NULL
            );
    }
    else
    {
        return NtGdiD3dDrawPrimitives2 (
            (HANDLE)pdp2data->lpDDCommands->hDDSurface,
            (HANDLE)pdp2data->lpDDVertex->hDDSurface,
            (LPD3DNTHAL_DRAWPRIMITIVES2DATA)pdp2data,
            &pdp2data->lpDDCommands->lpGbl->fpVidMem,
            &pdp2data->lpDDCommands->lpGbl->dwLinearSize,
            &pdp2data->lpDDVertex->lpGbl->fpVidMem,
            &pdp2data->lpDDVertex->lpGbl->dwLinearSize
            );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\dcmod.c ===
/******************************Module*Header*******************************\
* Module Name: dcmod.c                                                     *
*                                                                          *
* Client side stubs for functions that modify the state of the DC in the   *
* server.                                                                  *
*                                                                          *
* Created: 05-Jun-1991 01:49:42                                            *
* Author: Charles Whitmer [chuckwh]                                        *
*                                                                          *
* Copyright (c) 1991-1999 Microsoft Corporation                            *
\**************************************************************************/
#include "precomp.h"
#pragma hdrstop

#include "winuserk.h"

BOOL InitDeviceInfo(PLDC pldc, HDC hdc);
VOID vComputePageXform(PLDC pldc);
DWORD GetAndSetDCDWord( HDC, UINT, UINT, UINT, WORD, UINT );

#define DBG_XFORM 0

/******************************Public*Routine******************************\
* MoveToEx                                                                 *
*                                                                          *
* Client side stub.  It's important to batch this call whenever we can.    *
*                                                                          *
* History:                                                                 *
*  Thu 06-Jun-1991 23:10:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI MoveToEx(HDC hdc,int x,int y,LPPOINT pptl)
{
    BOOL bRet = FALSE;
    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return (MF16_RecordParms3(hdc,x,y,META_MOVETO));

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_SetDD(hdc,(DWORD)x,(DWORD)y,EMR_MOVETOEX))
                return(bRet);
        }
    }

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        bRet = TRUE;

        if (pptl != NULL)
        {
            // If the logical-space version of the current position is
            // invalid, then the device-space version of the current
            // position is guaranteed to be valid.  So we can reverse
            // the current transform on that to compute the logical-
            // space version:

            if (pDcAttr->ulDirty_ & DIRTY_PTLCURRENT)
            {
                *((POINTL*)pptl) = pDcAttr->ptfxCurrent;
                pptl->x = FXTOL(pptl->x);
                pptl->y = FXTOL(pptl->y);
                bRet = DPtoLP(hdc,pptl,1);
            }
            else
            {
                *((POINTL*)pptl) = pDcAttr->ptlCurrent;
            }
        }

        pDcAttr->ptlCurrent.x = x;
        pDcAttr->ptlCurrent.y = y;

        // We now know the new logical-space version of the current position
        // (but not the device-space version).  Mark it as such.  We also
        // have to reset the style-state for styled pens.

        pDcAttr->ulDirty_ &= ~DIRTY_PTLCURRENT;
        pDcAttr->ulDirty_ |= (DIRTY_PTFXCURRENT | DIRTY_STYLESTATE);
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* OffsetClipRgn                                                            *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  Thu 06-Jun-1991 23:10:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

int META WINAPI OffsetClipRgn(HDC hdc,int x,int y)
{
    int  iRet = RGN_ERROR;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return(MF16_RecordParms3(hdc,x,y,META_OFFSETCLIPRGN));

        DC_PLDC(hdc,pldc,iRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_OffsetClipRgn(hdc,x,y))
                return(iRet);
        }
    }

    return(NtGdiOffsetClipRgn(hdc,x,y));

}

/******************************Public*Routine******************************\
* SetMetaRgn
*
* Client side stub.
*
* History:
*  Tue Apr 07 17:05:37 1992     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

int WINAPI SetMetaRgn(HDC hdc)
{
    int   iRet = RGN_ERROR;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        DC_PLDC(hdc,pldc,iRet);

        if (pldc->iType == LO_METADC && !MF_SetMetaRgn(hdc))
            return(iRet);
    }

    return(NtGdiSetMetaRgn(hdc));
}

/******************************Public*Routine******************************\
* SelectPalette                                                            *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  Thu 06-Jun-1991 23:10:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

HPALETTE META WINAPI SelectPalette(HDC hdc,HPALETTE hpal,BOOL b)
{
    ULONG_PTR hRet = 0;

    FIXUP_HANDLE(hdc);
    FIXUP_HANDLE(hpal);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return ((HPALETTE)(ULONG_PTR)MF16_SelectPalette(hdc,hpal));

        DC_PLDC(hdc,pldc,(HPALETTE)hRet);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_SelectAnyObject(hdc,(HANDLE)hpal,EMR_SELECTPALETTE))
                return((HPALETTE) hRet);
        }
    }

    return(NtUserSelectPalette(hdc,hpal,b));
}

/******************************Public*Routine******************************\
* SetMapperFlags                                                           *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  Thu 06-Jun-1991 23:10:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

DWORD META WINAPI SetMapperFlags(HDC hdc,DWORD fl)
{
    DWORD dwRet;
    PDC_ATTR pdcattr;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {
        CHECK_AND_FLUSH_TEXT (hdc, pdcattr);

        if (fl & (~ASPECT_FILTERING))
        {
            WARNING("gdisrv!GreSetMapperFlags(): unknown flag\n");
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            dwRet = GDI_ERROR;
        }
        else
        {
            dwRet =  pdcattr->flFontMapper;
            pdcattr->flFontMapper = fl;
        }
    }
    else
    {
    WARNING("gdi32!SetMapperFlags(): invalid hdc\n");
    GdiSetLastError(ERROR_INVALID_PARAMETER);
    dwRet = GDI_ERROR;
    }

    return(dwRet);

}

// SetMapperFlagsInternal - no metafile version.

DWORD SetMapperFlagsInternal(HDC hdc,DWORD fl)
{
    return(GetAndSetDCDWord( hdc,
                             GASDDW_MAPPERFLAGS,
                             fl,
                             EMR_MAX+1,
                             EMR_MAX+1,
                             GDI_ERROR ));
}

/******************************Public*Routine******************************\
* SetSystemPaletteUse                                                      *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* This function is not metafile'd.                                         *
*                                                                          *
* History:                                                                 *
*  Thu 06-Jun-1991 23:10:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

UINT META WINAPI SetSystemPaletteUse(HDC hdc,UINT iMode)
{
    FIXUP_HANDLE(hdc);

    return(NtGdiSetSystemPaletteUse(hdc,iMode));
}

/******************************Public*Routine******************************\
* SetTextJustification                                                     *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  Thu 14-Jan-1993 03:30:27 -by- Charles Whitmer [chuckwh]                 *
* Save a copy in the LDC for computing text extent.                        *
*                                                                          *
*  Thu 06-Jun-1991 23:10:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI SetTextJustification(HDC hdc,int dx,int cBreak)
{
    PDC_ATTR pdcattr;
    BOOL bRet = FALSE;
    FIXUP_HANDLE(hdc);

    if (IS_METADC16_TYPE(hdc))
        return (MF16_RecordParms3(hdc,dx,cBreak,META_SETTEXTJUSTIFICATION));

    PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {
        CHECK_AND_FLUSH_TEXT (hdc, pdcattr);

        pdcattr->lBreakExtra = dx;
        pdcattr->cBreak      = cBreak;
        bRet = TRUE;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* SetArcDirection
*
* Client side stub.  Batches the call.
*
* History:
*  20-Mar-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

int META WINAPI SetArcDirection(HDC hdc,int iArcDirection)
{
    FIXUP_HANDLE(hdc);

    return(GetAndSetDCDWord( hdc,
                             GASDDW_ARCDIRECTION,
                             iArcDirection,
                             EMR_MAX+1,
                             EMR_MAX+1,
                             ERROR));
}

/******************************Public*Routine******************************\
* SetMiterLimit
*
* Client side stub.  Batches the call whenever it can.
*
* History:
*  13-Sep-1991 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL META WINAPI SetMiterLimit(HDC hdc,FLOAT e,PFLOAT pe)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;
        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC && !MF_SetD(hdc,(DWORD)e,EMR_SETMITERLIMIT))
            return(bRet);
    }

    return(NtGdiSetMiterLimit(hdc,FLOATARG(e),FLOATPTRARG(pe)));
}

/******************************Public*Routine******************************\
* SetFontXform
*
* Client side stub.  Batches the call whenever it can.
* This is an internal function.
*
* History:
*  Tue Nov 24 09:54:15 1992     -by-    Hock San Lee    [hockl]            *
* Wrote it.
\**************************************************************************/

BOOL SetFontXform(HDC hdc,FLOAT exScale,FLOAT eyScale)
{
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);

// This function is called only by the metafile playback code.
// If hdc is an enhanced metafile DC, we need to remember the scales
// so that we can metafile it in the compatible ExtTextOut or PolyTextOut
// record that follows.

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;
        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC && !MF_SetFontXform(hdc,exScale,eyScale))
            return(bRet);
    }
    // If the dc is mirrored then do not mirror the text at play back time.
    if (GetLayout(hdc) & LAYOUT_RTL) {
        exScale = -exScale;
    }
    return(NtGdiSetFontXform(hdc,FLOATARG(exScale),FLOATARG(eyScale)));
}

/******************************Public*Routine******************************\
* SetBrushOrgEx                                                            *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  Thu 06-Jun-1991 23:10:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL META WINAPI SetBrushOrgEx(HDC hdc,int x,int y,LPPOINT pptl)
{
    BOOL     bRet = FALSE;
    PDC_ATTR pdcattr;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;
        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC && !MF_SetBrushOrgEx(hdc,x,y))
            return(bRet);
    }

    PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

    if (pdcattr != NULL)
    {
        if (pptl != (LPPOINT)NULL)
        {
            *pptl = *((LPPOINT)&pdcattr->ptlBrushOrigin);
        }

        if (
             (pdcattr->ptlBrushOrigin.x != x) ||
             (pdcattr->ptlBrushOrigin.y != y)
           )
        {
            BEGIN_BATCH_HDC(hdc,pdcattr,BatchTypeSetBrushOrg,BATCHSETBRUSHORG);

                pdcattr->ptlBrushOrigin.x = x;
                pdcattr->ptlBrushOrigin.y = y;

                pBatch->x          = x;
                pBatch->y          = y;

            COMPLETE_BATCH_COMMAND();
        }

        bRet = TRUE;

    }
    else
    {
        UNBATCHED_COMMAND:
        bRet = NtGdiSetBrushOrg(hdc,x,y,pptl);
    }
    return(bRet);
}

/******************************Public*Routine******************************\
* RealizePalette                                                           *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
* History:                                                                 *
*  Thu 06-Jun-1991 23:10:01 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

UINT WINAPI RealizePalette(HDC hdc)
{
    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        UINT  uRet = 0xFFFFFFFF;
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
            return((UINT) MF16_RealizePalette(hdc));

        DC_PLDC(hdc,pldc,uRet);

        if (pldc->iType == LO_METADC)
        {
            HPALETTE hpal = (HPALETTE)GetDCObject(hdc,LO_PALETTE_TYPE);
            if ((pmetalink16Get(hpal) != NULL) && !MF_RealizePalette(hpal))
                return(uRet);
        }
    }

    return(UserRealizePalette(hdc));
}

/******************************Public*Routine******************************\
* GetBoundsRect
*
* Client side stub.
*
* History:
*  06-Apr-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

UINT WINAPI GetBoundsRect(HDC hdc, LPRECT lprc, UINT fl)
{
    FIXUP_HANDLE(hdc);

    // Applications can never set DCB_WINDOWMGR

    return(NtGdiGetBoundsRect(hdc, lprc, fl & ~DCB_WINDOWMGR));
}

UINT WINAPI GetBoundsRectAlt(HDC hdc, LPRECT lprc, UINT fl)
{
    FIXUP_HANDLE(hdc);

    return(NtGdiGetBoundsRect(hdc,lprc,fl));
}

/******************************Public*Routine******************************\
* SetBoundsRect
*
* Client side stub.
*
* History:
*  06-Apr-1992 -by- Donald Sidoroff [donalds]
* Wrote it.
\**************************************************************************/

UINT WINAPI SetBoundsRect(HDC hdc, CONST RECT *lprc, UINT fl)
{
    FIXUP_HANDLE(hdc);

    // Applications can never set DCB_WINDOWMGR

    return(NtGdiSetBoundsRect(hdc, (LPRECT)lprc, fl & ~DCB_WINDOWMGR));
}

UINT WINAPI SetBoundsRectAlt(HDC hdc, CONST RECT *lprc, UINT fl)
{
    FIXUP_HANDLE(hdc);

    return(NtGdiSetBoundsRect(hdc,(LPRECT)lprc,fl));
}

/******************************Public*Routine******************************\
* CancelDC1()
*
* History:
*  14-Apr-1992 -by-  - by - Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL WINAPI CancelDC(HDC hdc)
{
    BOOL bRes = FALSE;

    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc) && !IS_METADC16_TYPE(hdc))
    {
        PLDC pldc;

        DC_PLDC(hdc,pldc,bRes);

        if (pldc->fl & LDC_DOC_STARTED)
        {
            pldc->fl |= LDC_DOC_CANCELLED;
        }

        bRes = NtGdiCancelDC(hdc);
    }

    // If we are in the process of playing the metafile, stop the playback.

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        pDcAttr->ulDirty_ &= ~DC_PLAYMETAFILE;
        bRes = TRUE;
    }

    return(bRes);
}

/******************************Public*Function*****************************\
* SetColorAdjustment
*
*  Set the color adjustment data for a given DC.
*
* History:
*  07-Aug-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL META APIENTRY SetColorAdjustment(HDC hdc, CONST COLORADJUSTMENT * pca)
{
    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        BOOL bRet = FALSE;
        PLDC pldc;

        DC_PLDC(hdc,pldc,bRet);

        if (pldc->iType == LO_METADC && !MF_SetColorAdjustment(hdc, pca))
        {
            return(bRet);
        }
    }

    return(NtGdiSetColorAdjustment(hdc,(COLORADJUSTMENT*)pca));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\dcquery.c ===
/******************Module*Header********************************************\
* Module Name: dcquery.c                                                   *
*                                                                          *
* Client side stubs for functions that query the DC in the server.         *
*                                                                          *
* Created: 05-Jun-1991 01:43:56                                            *
* Author: Charles Whitmer [chuckwh]                                        *
*                                                                          *
* Copyright (c) 1991-1999 Microsoft Corporation                            *
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#if DBG
FLONG gflDebug = 0;
#endif

// This macro retrieves the current code page, carefully masking off the
// charset:

#define GET_CODE_PAGE(hdc,pDcAttr)                                           \
    ((!(pDcAttr->ulDirty_ & DIRTY_CHARSET) ? pDcAttr->iCS_CP                 \
                                           : NtGdiGetCharSet(hdc)) & 0xffff)
BOOL bIsDBCSString(LPCSTR psz, int cc);

/******************************Public*Routine******************************\
* vOutlineTextMetricWToOutlineTextMetricA
*
* Convert from OUTLINETEXTMETRICA (ANSI structure) to OUTLINETEXTMETRICW
* (UNICODE structure).
*
* Note:
*   This function is capable of converting in place (in and out buffers
*   can be the same).
*
* Returns:
*   TTRUE if successful, FALSE otherwise.
*
* History:
*  02-Mar-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID vOutlineTextMetricWToOutlineTextMetricA (
    LPOUTLINETEXTMETRICA   potma,
    OUTLINETEXTMETRICW   * potmw,
    TMDIFF *               ptmd
    )
{
// Size.

    potma->otmSize = potmw->otmSize;

// Convert the textmetrics.

    vTextMetricWToTextMetricStrict(
        &potma->otmTextMetrics,
        &potmw->otmTextMetrics);

    potma->otmTextMetrics.tmFirstChar   = ptmd->chFirst;
    potma->otmTextMetrics.tmLastChar    = ptmd->chLast;
    potma->otmTextMetrics.tmDefaultChar = ptmd->chDefault;
    potma->otmTextMetrics.tmBreakChar   = ptmd->chBreak;

// for Win 64 we need to copy these fields one by one due to alignement difference

    potma->otmFiller                    = potmw->otmFiller;
    potma->otmPanoseNumber              = potmw->otmPanoseNumber;
    potma->otmfsSelection               = potmw->otmfsSelection;
    potma->otmfsType                    = potmw->otmfsType;
    potma->otmsCharSlopeRise            = potmw->otmsCharSlopeRise;
    potma->otmsCharSlopeRun             = potmw->otmsCharSlopeRun;
    potma->otmItalicAngle               = potmw->otmItalicAngle;
    potma->otmEMSquare                  = potmw->otmEMSquare;
    potma->otmAscent                    = potmw->otmAscent;
    potma->otmDescent                   = potmw->otmDescent;
    potma->otmLineGap                   = potmw->otmLineGap;
    potma->otmsCapEmHeight              = potmw->otmsCapEmHeight;
    potma->otmsXHeight                  = potmw->otmsXHeight;
    potma->otmrcFontBox                 = potmw->otmrcFontBox;
    potma->otmMacAscent                 = potmw->otmMacAscent;
    potma->otmMacDescent                = potmw->otmMacDescent;
    potma->otmMacLineGap                = potmw->otmMacLineGap;
    potma->otmusMinimumPPEM             = potmw->otmusMinimumPPEM;
    potma->otmptSubscriptSize           = potmw->otmptSubscriptSize;
    potma->otmptSubscriptOffset         = potmw->otmptSubscriptOffset;
    potma->otmptSuperscriptSize         = potmw->otmptSuperscriptSize;
    potma->otmptSuperscriptOffset       = potmw->otmptSuperscriptOffset;
    potma->otmsStrikeoutSize            = potmw->otmsStrikeoutSize;
    potma->otmsStrikeoutPosition        = potmw->otmsStrikeoutPosition;
    potma->otmsUnderscoreSize           = potmw->otmsUnderscoreSize;
    potma->otmsUnderscorePosition       = potmw->otmsUnderscorePosition;

// set the offsets to zero for now, this will be changed later if
// the caller wanted strings as well

    potma->otmpFamilyName = NULL;
    potma->otmpFaceName   = NULL;
    potma->otmpStyleName  = NULL;
    potma->otmpFullName   = NULL;
}

/******************************Public*Routine******************************\
*
* vGenerateANSIString
*
* Effects: Generates Ansi string which consists of consecutive ansi chars
*          [iFirst, iLast] inclusive. The string is stored in the buffer
*          puchBuf that the user must ensure is big enough
*
*
*
* History:
*  24-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vGenerateAnsiString(UINT iFirst, UINT iLast, PUCHAR puchBuf)
{
// Generate string (terminating NULL not needed).

    ASSERTGDI((iFirst <= iLast) && (iLast < 256), "gdi!_vGenerateAnsiString\n");

    for ( ; iFirst <= iLast; iFirst++)
        *puchBuf++ = (UCHAR) iFirst;
}

/******************************Public*Routine******************************\
*
* bSetUpUnicodeString
*
* Effects:
*
* Warnings:
*
* History:
*  25-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL bSetUpUnicodeString(
IN  UINT    iFirst,      // first ansi char
IN  UINT    iLast,       // last char
IN  PUCHAR  puchTmp,     // buffer for an intermediate ansi string
OUT PWCHAR  pwc,         // output fuffer with a unicode string
IN  UINT    dwCP         // ansi codepage
)
{
    UINT c = iLast - iFirst + 1;
    vGenerateAnsiString(iFirst,iLast,puchTmp);
    return MultiByteToWideChar(
               dwCP, 0,
               puchTmp,c,
               pwc, c*sizeof(WCHAR));
}


/******************************Public*Routine******************************\
* GetAspectRatioFilterEx                                                   *
* GetBrushOrgEx                                                            *
*                                                                          *
* Client side stubs which all get mapped to GetPoint.                      *
*                                                                          *
*  Fri 07-Jun-1991 18:01:50 -by- Charles Whitmer [chuckwh]                 *
* Wrote them.                                                              *
\**************************************************************************/

BOOL APIENTRY GetAspectRatioFilterEx(HDC hdc,LPSIZE psizl)
{
    FIXUP_HANDLE(hdc);

    return(NtGdiGetDCPoint(hdc,DCPT_ASPECTRATIOFILTER,(PPOINTL) psizl));
}

BOOL APIENTRY GetBrushOrgEx(HDC hdc,LPPOINT pptl)
{
    BOOL     bRet = FALSE;
    PDC_ATTR pdcattr;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

    if ((pdcattr != NULL) && (pptl != (LPPOINT)NULL))
    {
        *pptl = *((LPPOINT)&pdcattr->ptlBrushOrigin);
        bRet = TRUE;
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }
    return(bRet);

}

BOOL APIENTRY GetDCOrgEx(HDC hdc,LPPOINT pptl)
{
    FIXUP_HANDLE(hdc);

    return(NtGdiGetDCPoint(hdc,DCPT_DCORG,(PPOINTL)pptl));
}

// The old GetDCOrg is here because it was in the Beta and we are afraid
// to remove it now.  It would be nice to remove it.

DWORD APIENTRY GetDCOrg(HDC hdc)
{
    hdc;
    return(0);
}

/******************************Public*Routine******************************\
* Client side stub for GetCurrentPositionEx.
*
*  Wed 02-Sep-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GetCurrentPositionEx(HDC hdc,LPPOINT pptl)
{
    BOOL bRet = FALSE;

    PDC_ATTR pDcAttr;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if ((pDcAttr) && (pptl != (LPPOINT)NULL))
    {
        bRet = TRUE;

        if (pDcAttr->ulDirty_ & DIRTY_PTLCURRENT)
        {
            // If the logical-space version of the current position is invalid,
            // then the device-space version of the current position is
            // guaranteed to be valid.  So we can reverse the current transform
            // on that to compute the logical-space version:

            *((POINTL*)pptl) = pDcAttr->ptfxCurrent;

            pptl->x = FXTOL(pptl->x);
            pptl->y = FXTOL(pptl->y);
            bRet = DPtoLP(hdc,pptl,1);

            if (bRet)
            {
                pDcAttr->ptlCurrent = *((POINTL*)pptl);
                pDcAttr->ulDirty_ &= ~DIRTY_PTLCURRENT;
            }
        }
        else
        {
            *((POINTL*)pptl) = pDcAttr->ptlCurrent;
        }
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* GetPixel                                                                 *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
*  Fri 07-Jun-1991 18:01:50 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

DWORD APIENTRY GetPixel(HDC hdc,int x,int y)
{
    PDC_ATTR pdca;
    COLORREF ColorRet = CLR_INVALID;

    FIXUP_HANDLE(hdc);
    PSHARED_GET_VALIDATE(pdca,hdc,DC_TYPE);

    if (pdca)
    {
        //
        // if the color is not a PaletteIndex and
        // ICM is on then translate
        //

        ColorRet = NtGdiGetPixel(hdc,x,y);

        if ( bNeedTranslateColor(pdca)
               &&
             ( IS_32BITS_COLOR(pdca->lIcmMode)
                        ||
               ((ColorRet != CLR_INVALID) &&
                 !(ColorRet & 0x01000000))
             )
           )
        {
            //
            // translate back color to original.
            //
            COLORREF NewColor;

            BOOL bStatus = IcmTranslateCOLORREF(hdc,
                                                pdca,
                                                ColorRet,
                                                &NewColor,
                                                ICM_BACKWARD);
            if (bStatus)
            {
                ColorRet = NewColor;
            }
        }
    }

    return(ColorRet);
}

/******************************Public*Routine******************************\
* GetDeviceCaps
*
* We store the device caps for primary display dc and its compatible memory dcs
* in the shared handle table.
*
* for printer dcs and meta dcs, we cache the dev info in the LDC structure.
*
*  Fri 07-Jun-1991 18:01:50 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

int APIENTRY GetDeviceCaps(HDC hdc,int iCap)
{
    BOOL bRet = FALSE;
    PDEVCAPS pCachedDevCaps = NULL;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        // For the 16-bit metafile DC, returns only technology.  return 0 for win3.1 compat.

        if (IS_METADC16_TYPE(hdc))
            return(iCap == TECHNOLOGY ? DT_METAFILE : 0);

        DC_PLDC(hdc,pldc,bRet);

        if (!(pldc->fl & LDC_CACHED_DEVCAPS))
        {
            bRet = NtGdiGetDeviceCapsAll (hdc, &pldc->DevCaps);

            if (bRet)
            {
                pCachedDevCaps = &pldc->DevCaps;
                pldc->fl |= LDC_CACHED_DEVCAPS;
            }
        }
        else
        {
           pCachedDevCaps = &pldc->DevCaps;
           bRet = TRUE;
        }
    }
    else
    {
        PDC_ATTR pDcAttr;

        PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

        if (pDcAttr)
        {
                ULONG  fl = pDcAttr->ulDirty_;

                if (!(fl & DC_PRIMARY_DISPLAY))
                {
                    return(NtGdiGetDeviceCaps(hdc,iCap));
                }
            else
            {
                pCachedDevCaps = pGdiDevCaps;
                bRet = TRUE;
            }
        }
    }

    if (!bRet)
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    // actual code - copied from gre\miscgdi.cxx
    switch (iCap)
    {
    case DRIVERVERSION:                     //  Version = 0100h for now
        return(pCachedDevCaps->ulVersion);

    case TECHNOLOGY:                        //  Device classification
        return(pCachedDevCaps->ulTechnology);

    case HORZSIZE:                          //  Horizontal size in millimeters
        return(pCachedDevCaps->ulHorzSizeM);

    case VERTSIZE:                          //  Vertical size in millimeters
        return(pCachedDevCaps->ulVertSizeM);

    case HORZRES:                           //  Horizontal width in pixels
        return(pCachedDevCaps->ulHorzRes);

    case VERTRES:                           //  Vertical height in pixels
        return(pCachedDevCaps->ulVertRes);

    case BITSPIXEL:                         //  Number of bits per pixel
        return(pCachedDevCaps->ulBitsPixel);

    case PLANES:                            //  Number of planes
        return(pCachedDevCaps->ulPlanes);

    case NUMBRUSHES:                        //  Number of brushes the device has
        return(-1);

    case NUMPENS:                           //  Number of pens the device has
        return(pCachedDevCaps->ulNumPens);

    case NUMMARKERS:                        //  Number of markers the device has
        return(0);

    case NUMFONTS:                          //  Number of fonts the device has
        return(pCachedDevCaps->ulNumFonts);

    case NUMCOLORS:                         //  Number of colors in color table
        return(pCachedDevCaps->ulNumColors);

    case PDEVICESIZE:                       //  Size required for the device descriptor
        return(0);

    case CURVECAPS:                         //  Curves capabilities
        return(CC_CIRCLES    |
               CC_PIE        |
               CC_CHORD      |
               CC_ELLIPSES   |
               CC_WIDE       |
               CC_STYLED     |
               CC_WIDESTYLED |
               CC_INTERIORS  |
               CC_ROUNDRECT);

    case LINECAPS:                          //  Line capabilities
        return(LC_POLYLINE   |
               LC_MARKER     |
               LC_POLYMARKER |
               LC_WIDE       |
               LC_STYLED     |
               LC_WIDESTYLED |
               LC_INTERIORS);

    case POLYGONALCAPS:                     //  Polygonal capabilities
        return(PC_POLYGON     |
               PC_RECTANGLE   |
               PC_WINDPOLYGON |
               PC_TRAPEZOID   |
               PC_SCANLINE    |
               PC_WIDE        |
               PC_STYLED      |
               PC_WIDESTYLED  |
               PC_INTERIORS);

    case TEXTCAPS:                          //  Text capabilities
        return(pCachedDevCaps->ulTextCaps);

    case CLIPCAPS:                          //  Clipping capabilities
        return(CP_RECTANGLE);

    case RASTERCAPS:                        //  Bitblt capabilities
        return(pCachedDevCaps->ulRasterCaps);

    case SHADEBLENDCAPS:                    //  shade and blend capabilities
        return(pCachedDevCaps->ulShadeBlendCaps);

    case ASPECTX:                           //  Length of X leg
        return(pCachedDevCaps->ulAspectX);

    case ASPECTY:                           //  Length of Y leg
        return(pCachedDevCaps->ulAspectY);

    case ASPECTXY:                          //  Length of hypotenuse
        return(pCachedDevCaps->ulAspectXY);

    case LOGPIXELSX:                        //  Logical pixels/inch in X
        return(pCachedDevCaps->ulLogPixelsX);

    case LOGPIXELSY:                        //  Logical pixels/inch in Y
        return(pCachedDevCaps->ulLogPixelsY);

    case SIZEPALETTE:                       // # entries in physical palette
        return(pCachedDevCaps->ulSizePalette);

    case NUMRESERVED:                       // # reserved entries in palette
        return(20);

    case COLORRES:
        return(pCachedDevCaps->ulColorRes);

    case PHYSICALWIDTH:                     // Physical Width in device units
        return(pCachedDevCaps->ulPhysicalWidth);

    case PHYSICALHEIGHT:                    // Physical Height in device units
        return(pCachedDevCaps->ulPhysicalHeight);

    case PHYSICALOFFSETX:                   // Physical Printable Area x margin
        return(pCachedDevCaps->ulPhysicalOffsetX);

    case PHYSICALOFFSETY:                   // Physical Printable Area y margin
        return(pCachedDevCaps->ulPhysicalOffsetY);

    case VREFRESH:                          // Vertical refresh rate of the device
        return(pCachedDevCaps->ulVRefresh);

    case DESKTOPHORZRES:                    // Width of entire virtual desktop
        return(pCachedDevCaps->ulDesktopHorzRes);

    case DESKTOPVERTRES:                    // Height of entire virtual desktop
        return(pCachedDevCaps->ulDesktopVertRes);

    case BLTALIGNMENT:                      // Preferred blt alignment
        return(pCachedDevCaps->ulBltAlignment);

    case COLORMGMTCAPS:                     // Color Management capabilities
        return(pCachedDevCaps->ulColorManagementCaps);

    default:
        return(0);
    }

}


/******************************Public*Routine******************************\
* GetDeviceCapsP
*
* Private version to get HORSIZE and VERTSIZE in micrometers
* Copied from GetDeviceCaps
*
* \**************************************************************************/
int GetDeviceCapsP(HDC hdc,int iCap)
{
    BOOL bRet = FALSE;
    PDEVCAPS pCachedDevCaps = NULL;

    FIXUP_HANDLE(hdc);

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        DC_PLDC(hdc,pldc,bRet);

        if (!(pldc->fl & LDC_CACHED_DEVCAPS))
        {
            bRet = NtGdiGetDeviceCapsAll (hdc, &pldc->DevCaps);

            if (bRet)
            {
                pCachedDevCaps = &pldc->DevCaps;
                pldc->fl |= LDC_CACHED_DEVCAPS;
            }
        }
        else
        {
           pCachedDevCaps = &pldc->DevCaps;
           bRet = TRUE;
        }
    }
    else
    {
        PDC_ATTR pDcAttr;

        PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

        if (pDcAttr)
        {
                ULONG  fl = pDcAttr->ulDirty_;

                if (!(fl & DC_PRIMARY_DISPLAY))
                {
                    return(NtGdiGetDeviceCaps(hdc,iCap));
                }
                else
                {
                    pCachedDevCaps = pGdiDevCaps;
                    bRet = TRUE;
                }
        }
    }

    if (!bRet)
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return (0);
    }

    // actual code - copied from gre\miscgdi.cxx
    switch (iCap)
    {
    case HORZSIZEP:                          //  Horizontal size
        return(pCachedDevCaps->ulHorzSize);

    case VERTSIZEP:                          //  Vertical size
        return(pCachedDevCaps->ulVertSize);


    default:
        return(0);
    }

}



/******************************Public*Routine******************************\
* GetNearestColor                                                          *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
*  Fri 07-Jun-1991 18:01:50 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

COLORREF APIENTRY GetNearestColor(HDC hdc,COLORREF color)
{
    FIXUP_HANDLE(hdc);

    return(NtGdiGetNearestColor(hdc,color));
}

/******************************Public*Routine******************************\
* GetArcDirection
*
* Client side stub.
*
*  Fri 09-Apr-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

int APIENTRY GetArcDirection(HDC hdc)
{
    FIXUP_HANDLE(hdc);

    return(GetDCDWord(hdc,DDW_ARCDIRECTION,0));
}

/******************************Public*Routine******************************\
* GetMiterLimit
*
* Client side stub.
*
*  Fri 09-Apr-1992 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

int APIENTRY GetMiterLimit(HDC hdc, PFLOAT peMiterLimit)
{
    FIXUP_HANDLE(hdc);

    return(NtGdiGetMiterLimit(hdc,FLOATPTRARG(peMiterLimit)));
}

/******************************Public*Routine******************************\
* GetSystemPaletteUse                                                      *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
*  Fri 07-Jun-1991 18:01:50 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

UINT APIENTRY GetSystemPaletteUse(HDC hdc)
{
    FIXUP_HANDLE(hdc);

    return(NtGdiGetSystemPaletteUse(hdc));
}

/******************************Public*Routine******************************\
* GetClipBox                                                               *
*                                                                          *
* Client side stub.                                                        *
*                                                                          *
*  Fri 07-Jun-1991 18:01:50 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

int APIENTRY GetClipBox(HDC hdc,LPRECT prcl)
{
    FIXUP_HANDLE(hdc);

    return(NtGdiGetAppClipBox(hdc,prcl));
}

/******************************Public*Routine******************************\
*
* BOOL APIENTRY GetTextMetrics(HDC hdc,LPTEXTMETRIC ptm)
*
*   calls to the unicode version
*
* History:
*  21-Aug-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GetTextMetricsA(HDC hdc,LPTEXTMETRICA ptm)
{
    PDC_ATTR     pDcAttr;
    BOOL         bRet = FALSE;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        CFONT * pcf;
        TMW_INTERNAL tmw;

        ASSERTGDI(pDcAttr->hlfntNew,"GetTextMetricsW - hf is NULL\n");

        ENTERCRITICALSECTION(&semLocal);

        pcf = pcfLocateCFONT(hdc,pDcAttr,0,(PVOID)NULL,0, TRUE);

        bRet = bGetTextMetricsWInternal(hdc,&tmw,sizeof(tmw),pcf);

        // pcfLocateCFONT added a reference so now we need to remove it

        if (pcf)
        {
            DEC_CFONT_REF(pcf);
        }

        LEAVECRITICALSECTION(&semLocal);

        if (bRet)
        {
            vTextMetricWToTextMetric(ptm, &tmw);
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
*
* BOOL APIENTRY GetTextMetricsW(HDC hdc,LPTEXTMETRICW ptmw)
*
* History:
*  21-Aug-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GetTextMetricsW(HDC hdc,LPTEXTMETRICW ptmw)
{
    PDC_ATTR    pDcAttr;
    BOOL bRet = FALSE;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);
    if (pDcAttr)
    {
        CFONT * pcf;

        ASSERTGDI(pDcAttr->hlfntNew,"GetTextMetricsW - hf is NULL\n");

        ENTERCRITICALSECTION(&semLocal);

        pcf = pcfLocateCFONT(hdc,pDcAttr,0,(PVOID) NULL,0, TRUE);

        bRet = bGetTextMetricsWInternal(hdc,(TMW_INTERNAL *)ptmw,sizeof(TEXTMETRICW),pcf);

        // pcfLocateCFONT added a reference so now we need to remove it

        if (pcf)
        {
            DEC_CFONT_REF(pcf);
        }

        LEAVECRITICALSECTION(&semLocal);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
*
* BOOL APIENTRY GetTextMetricsW(HDC hdc,LPTEXTMETRICW ptmw)
*
* History:
*  21-Aug-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL bGetTextMetricsWInternal(
    HDC hdc,
    TMW_INTERNAL *ptmw,
    int cjTM,
    CFONT *pcf
    )
{
    BOOL bRet = FALSE;

    if (ptmw)
    {
        // if no pcf or we havn't cached the metrics

        if ((pcf == NULL) || !(pcf->fl & CFONT_CACHED_METRICS))
        {
            TMW_INTERNAL tmw;
            PDC_ATTR    pDcAttr;

            PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

            bRet = NtGdiGetTextMetricsW(hdc,&tmw,sizeof(tmw));

            if (bRet)
            {
                memcpy(ptmw,&tmw,cjTM);

                if (pcf)
                {
                    // we succeeded and we have a pcf so cache the data

                    pcf->tmw = tmw;

                    pcf->fl |= CFONT_CACHED_METRICS;
                }
            }
        }
        else
        {
            memcpy(ptmw,&pcf->tmw,cjTM);
            bRet  = TRUE;
        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* GetTextExtentPoint32A (hdc,psz,c,psizl)                                  *
* GetTextExtentPointA   (hdc,psz,c,psizl)                                  *
*                                                                          *
* Computes the text extent.  The new 32 bit version returns the "correct"  *
* extent without an extra per for bitmap simulations.  The other is        *
* Windows 3.1 compatible.  Both just set a flag and pass the call to       *
* bGetTextExtentA.                                                         *
*                                                                          *
* History:                                                                 *
*  Thu 14-Jan-1993 04:11:26 -by- Charles Whitmer [chuckwh]                 *
* Added code to compute it on the client side.                             *
*                                                                          *
*  07-Aug-1991 -by- Bodin Dresevic [BodinD]                                *
* Wrote it.                                                                *
\**************************************************************************/

// not in kernel, it is ok to do this much on the stack:
#define CAPTURE_STRING_SIZE 130

BOOL GetTextExtentPointAInternal(HDC hdc,LPCSTR psz,int c,LPSIZE psizl, FLONG fl)
{
    CFONT       *pcf;
    INT         bRet;
    PWSZ        pwszCapt;
    PDC_ATTR    pDcAttr;
    DWORD       dwCP;
    WCHAR awcCaptureBuffer[CAPTURE_STRING_SIZE];

    FIXUP_HANDLE(hdc);

    if (c <= 0)
    {
    // empty string, just return 0 for the extent

        if (c == 0)
        {
            psizl->cx = 0;
            psizl->cy = 0;
            bRet = TRUE;
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            bRet = FALSE;
        }
        return(bRet);
    }

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);
    if (!pDcAttr)
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        bRet = FALSE;
        return(bRet);
    }

    dwCP = GET_CODE_PAGE(hdc, pDcAttr);

    if(guintDBCScp == dwCP)
    {
        QueryFontAssocStatus();

        if(fFontAssocStatus &&
           ((c == 1) || ((c == 2 && *(psz) && *((LPCSTR)(psz + 1)) == '\0'))))
        {
        //
        // If this function is called with only 1 char, and font association
        // is enabled, we should forcely convert the chars to Unicode with
        // codepage 1252.
        // This is for enabling to output Latin-1 chars ( > 0x80 in Ansi codepage )
        // Because, normally font association is enabled, we have no way to output
        // those charactres, then we provide the way, if user call TextOutA() with
        // A character and ansi font, we tempotary disable font association.
        // This might be Windows 3.1 (Korean/Taiwanese) version compatibility..
        //
            dwCP = 1252;
        }
    }


    if((dwCP == CP_ACP)     ||
       (dwCP == guintAcp)   ||
       (dwCP == guintDBCScp)
      )
    {
#ifdef LANGPACK
        if (!gbLpk || (*fpLpkUseGDIWidthCache)(hdc, psz, c, pDcAttr->lTextAlign , FALSE))
        {
#endif
            ENTERCRITICALSECTION(&semLocal);

            pcf = pcfLocateCFONT(hdc,pDcAttr,0,(PVOID)psz,c,TRUE);
            if (pcf != NULL)
            {
                BOOL bExit = TRUE;

                if(dwCP == guintDBCScp)
                {
                    if (pcf->wd.sDBCSInc) // dbcs fixed pitch base font
                    {
                        bRet = bComputeTextExtentDBCS(pDcAttr,pcf,psz,c,fl,psizl);
                    }
                    else if (!bIsDBCSString(psz,c))
                    {
                    // linked case, base font is a latin font, but linked font
                    // perhaps is a FE font. We know that base font is a latin font
                    // because for FE proportional fonts we would never create pcf.
                    // We are looking for this special case when the application asked
                    // for Latin Face Name in the logfont, and a FE charset, but the string
                    // passed in lackily does not contain DBCS glyphs.

                        bRet = bComputeTextExtent(pDcAttr,pcf,(PVOID) psz,c,fl,psizl,TRUE);
                    }
                    else
                    {
                        bExit = FALSE;
                    }
                }
                else
                {
                    bRet = bComputeTextExtent(pDcAttr,pcf,(PVOID) psz,c,fl,psizl,TRUE);
                }

                DEC_CFONT_REF(pcf);

                if(bExit)
                {
                    LEAVECRITICALSECTION(&semLocal);
                    return(bRet);
                }
            }

            LEAVECRITICALSECTION(&semLocal);
#ifdef LANGPACK
        }
#endif
    }

// Allocate the string buffer

    if (c <= CAPTURE_STRING_SIZE)
    {
        pwszCapt = awcCaptureBuffer;
    }
    else
    {
        pwszCapt = LOCALALLOC(c * sizeof(WCHAR));
    }

    if (pwszCapt)
    {

        c = MultiByteToWideChar(dwCP, 0, psz,c, pwszCapt, c*sizeof(WCHAR));

        if (c)
        {
#ifdef LANGPACK
            if(gbLpk)
            {
                bRet = (*fpLpkGetTextExtentExPoint)(hdc, pwszCapt, c, -1, NULL, NULL,
                                                    psizl, fl, 0);
            }
            else
#endif
            bRet = NtGdiGetTextExtent(hdc,
                                     (LPWSTR)pwszCapt,
                                     c,
                                     psizl,
                                     fl);
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            bRet = FALSE;
        }

        if (pwszCapt != awcCaptureBuffer)
            LOCALFREE(pwszCapt);
    }
    else
    {
        GdiSetLastError(ERROR_NOT_ENOUGH_MEMORY);
        bRet = FALSE;
    }

    return(bRet);
}

BOOL APIENTRY GetTextExtentPointA(HDC hdc,LPCSTR psz,int c,LPSIZE psizl)
{
    return GetTextExtentPointAInternal(hdc,psz,c,psizl,GGTE_WIN3_EXTENT);
}


BOOL APIENTRY GetTextExtentPoint32A(HDC hdc,LPCSTR psz,int c,LPSIZE psizl)
{
    return GetTextExtentPointAInternal(hdc,psz,c,psizl,0);
}


/******************************Public*Routine******************************\
*
* DWORD WINAPI GetCharacterPlacementA
*
* Effects:
*
* Warnings:
*
* History:
*  27-Jul-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



DWORD WINAPI GetCharacterPlacementA
(
    HDC     hdc,
    LPCSTR  psz,
    int     nCount,
    int     nMaxExtent,
    LPGCP_RESULTSA   pgcpa,
    DWORD   dwFlags
)
{
#define GCP_GLYPHS 80

    WCHAR       *pwsz = NULL;
    WCHAR        awc[GCP_GLYPHS];
    GCP_RESULTSW gcpw;
    DWORD        dwRet;
    BOOL         bOk = TRUE;
    int          nBuffer;
    SIZE         size;
    DWORD        dwCP;

    FIXUP_HANDLE(hdc);

    size.cx = size.cy = 0;

// nMaxExtent == -1 means that there is no MaxExtent

    if (!psz || (nCount <= 0) || ((nMaxExtent < 0) && (nMaxExtent != -1)))
    {
        WARNING("gdi!_GetCharactherPlacementA, bad parameters \n");
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return 0;
    }

    if (!pgcpa)
    {
    // just call GetTextExtentA, can usually be done on the client side

        if (!GetTextExtentPointA(hdc, psz, nCount, &size))
        {
            WARNING("GetCharacterPlacementW, GetTextExtentPointA failed\n");
            return 0;
        }

    // now backwards compatible win95 hack, chop off 32 bit values to 16 bits

        return (DWORD)((USHORT)size.cx) | (DWORD)(size.cy << 16);
    }

// chop off nCount, win95 does it

    if (nCount > (int)pgcpa->nGlyphs)
        nCount = (int)pgcpa->nGlyphs;

// unicode string buffer will at least be this many WCHAR's long:

    nBuffer = nCount;

// now go on to compute the size of the GCP_RESULTSW that is required
// to receive the results. If lpOutString is not NULL the structures
// will have different pointers else they will be the same.

    gcpw.lpOrder    = pgcpa->lpOrder   ;
    gcpw.lpDx       = pgcpa->lpDx      ;
    gcpw.lpCaretPos = pgcpa->lpCaretPos;
    gcpw.lpClass    = pgcpa->lpClass   ;
    gcpw.lpGlyphs   = pgcpa->lpGlyphs  ;
    gcpw.nGlyphs    = pgcpa->nGlyphs   ;
    gcpw.nMaxFit    = pgcpa->nMaxFit   ;

    if (pgcpa->lpOutString)
    {
        nBuffer += nBuffer; // take into account space for gcpw.lpOutString
    }
    else
    {
        gcpw.lpOutString = NULL;
        gcpw.lStructSize = pgcpa->lStructSize;
    }

// now allocate memory (if needed) for the unicode string and for
// gcpw.lpOutString if needed.

    if (nBuffer <= GCP_GLYPHS)
        pwsz = awc;
    else
        pwsz = LOCALALLOC(nBuffer * sizeof(WCHAR));

    if (pwsz)
    {
        if (pgcpa->lpOutString)
        {
            gcpw.lpOutString = &pwsz[nCount];

        // we have replaced the ansi string by unicode string, this adds
        // nCount bytes to the size of the structure.

            gcpw.lStructSize = pgcpa->lStructSize + nCount;
        }

    // convert Ansi To Unicode based on the code page of the font selected in DC

        if
        (
            gcpw.nGlyphs = MultiByteToWideChar((dwCP = GetCodePage(hdc)), 0,
                                psz, nCount,
                                pwsz, nCount*sizeof(WCHAR))
        )
        {

        // If this is a DBCS font then we need to patch up the DX array since
        // there will be two DX values for each DBCS character.  It is okay
        // to do this in place since GetCharacterPlacement modifies the DX
        // array anyway.

            if((dwFlags & GCP_JUSTIFYIN) &&
               (gcpw.lpDx) &&
               IS_ANY_DBCS_CODEPAGE(dwCP))
            {
                INT *pDxNew, *pDxOld;
                const char *pDBCSString;

                for(pDxNew = pDxOld = gcpw.lpDx, pDBCSString = psz;
                    pDBCSString < psz + nCount;
                    pDBCSString++
                    )
                {
                    if(IsDBCSLeadByteEx(dwCP,*pDBCSString))
                    {
                        pDBCSString++;
                        pDxOld++;
                    }
                    *pDxNew++ = *pDxOld++;
                }
            }

#ifdef LANGPACK
             if (gbLpk)
             {
                 // If the LPK is loaded then pass the caller nGlyphs because it may generate
                 // Glyphs more than nCount.
                 gcpw.nGlyphs = pgcpa->nGlyphs;
                 dwRet = (*fpLpkGetCharacterPlacement)(hdc, pwsz, nCount,nMaxExtent,
                                                        &gcpw, dwFlags, 0);
             }
             else
#endif
             {
                 dwRet = NtGdiGetCharacterPlacementW(hdc,pwsz,nCount,nMaxExtent,
                                                 &gcpw, dwFlags);
             }


            if (dwRet)
            {
            // copy out the data.... we use the original value of nCount
            // when specifying an output buffer size for the lpOutString buffer
            // since nCount on return will be Unicode character count which
            // may not be the same as DBCS character count

                int nOriginalCount = nCount;

                pgcpa->nGlyphs = nCount = gcpw.nGlyphs;
                pgcpa->nMaxFit = gcpw.nMaxFit;
                if (pgcpa->lpOutString)
                {
                    if
                    (
                        !WideCharToMultiByte(
                             (UINT)dwCP,            // UINT CodePage
                             0,                     // DWORD dwFlags
                             gcpw.lpOutString,      // LPWSTR lpWideCharStr
                             gcpw.nMaxFit,          // int cchWideChar
                             pgcpa->lpOutString,    // LPSTR lpMultiByteStr
                             nOriginalCount,        // int cchMultiByte
                             NULL,                  // LPSTR lpDefaultChar
                             NULL)                  // LPBOOL lpUsedDefaultChar
                    )
                    {
                        bOk = FALSE;
                    }
                }
            }
            else
            {
                bOk = FALSE;
            }
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            bOk = FALSE;
        }

        if (pwsz != awc)
            LOCALFREE(pwsz);
    }
    else
    {
        bOk = FALSE;
    }

    return (bOk ? dwRet : 0);
}

/******************************Public*Routine******************************\
*
* DWORD WINAPI GetCharacterPlacementW
* look at gdi32.def, just points to NtGdiGetCharacterPlacementW
*
* History:
*  26-Jul-1995 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


#if LANGPACK

DWORD WINAPI GetCharacterPlacementW
(
    HDC     hdc,
    LPCWSTR pwsz,
    int     nCount,
    int     nMaxExtent,
    LPGCP_RESULTSW   pgcpw,
    DWORD   dwFlags
)
{
    SIZE         size;

    FIXUP_HANDLE(hdc);

    size.cx = size.cy = 0;

    // nMaxExtent == -1 means that there is no MaxExtent

    if (!pwsz || (nCount <= 0) || ((nMaxExtent < 0) && (nMaxExtent != -1)))
    {
       WARNING("gdi!_GetCharactherPlacementW, bad parameters \n");
       GdiSetLastError(ERROR_INVALID_PARAMETER);
       return 0;
    }

    if (!pgcpw)
    {
    // just call GetTextExtentW, can usually be done on the client side

       if (!GetTextExtentPointW(hdc, pwsz, nCount, &size))
       {
           WARNING("GetCharacterPlacementW, GetTextExtentPointW failed\n");
           return 0;
       }

    // now backwards compatible win95 hack, chop off 32 bit values to 16 bits

       return (DWORD)((USHORT)size.cx) | (DWORD)(size.cy << 16);
    }

// chop off nCount, win95 does it

    if (nCount > (int)pgcpw->nGlyphs)
        nCount = (int)pgcpw->nGlyphs;

    if(gbLpk)
    {
        return((*fpLpkGetCharacterPlacement)(hdc,pwsz,nCount,nMaxExtent,pgcpw,
                                             dwFlags,-1));
    }
    else
    {

        return  NtGdiGetCharacterPlacementW(hdc,
                                            (LPWSTR) pwsz,
                                            nCount,
                                            nMaxExtent,
                                            pgcpw,
                                            dwFlags);
    }
}

#endif


/******************************Public*Routine******************************\
* BOOL bGetCharWidthA                                                      *
*                                                                          *
* Client side stub for the various GetCharWidth*A functions.               *
*                                                                          *
* History:                                                                 *
*  Sat 16-Jan-1993 03:08:42 -by- Charles Whitmer [chuckwh]                 *
* Added code to do it on the client side.                                  *
*                                                                          *
*  28-Aug-1991 -by- Bodin Dresevic [BodinD]                                *
* Wrote it.                                                                *
\**************************************************************************/

#define GCW_WIN3_INT   (GCW_WIN3 | GCW_INT)
#define GCW_WIN3_16INT (GCW_WIN3 | GCW_INT | GCW_16BIT)

#define GCW_SIZE(fl)          ((fl >> 16) & 0xffff)
#define GCWFL(fltype,szType)  (fltype | (sizeof(szType) << 16))

BOOL bGetCharWidthA
(
    HDC   hdc,
    UINT  iFirst,
    UINT  iLast,
    ULONG fl,
    PVOID pvBuf
)
{
    PDC_ATTR    pDcAttr;
    LONG        cwc;
    CFONT      *pcf = NULL;
    PUCHAR      pch;
    PWCHAR      pwc;
    BOOL        bRet = FALSE;
    ULONG       cjWidths;
    DWORD       dwCP;
    BOOL        bDBCSCodePage;
    WCHAR       awc[MAX_PATH];
    PVOID       pvResultBuffer;


    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (!pDcAttr)
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(bRet);
    }

    dwCP = GET_CODE_PAGE(hdc, pDcAttr);

    bDBCSCodePage = IS_ANY_DBCS_CODEPAGE(dwCP);

// do parameter validation, check that in chars are indeed ascii


    if ((bDBCSCodePage && !IsValidDBCSRange(iFirst,iLast)) ||
        (!bDBCSCodePage &&
         ((iFirst > iLast) || (iLast & 0xffffff00))) ||
        (pvBuf == NULL))
    {
        WARNING("gdi!_bGetCharWidthA parameters \n");
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(bRet);
    }
    cwc = (LONG)(iLast - iFirst + 1);

    ENTERCRITICALSECTION(&semLocal);

    if ((dwCP == CP_ACP) ||
        (dwCP == guintAcp)
        || (dwCP == guintDBCScp)
    )

    {
        pcf = pcfLocateCFONT(hdc,pDcAttr,iFirst,(PVOID) NULL,(UINT) cwc, TRUE);
    }

    if (pcf != (CFONT *) NULL)
    {
        BOOL bExit = TRUE;

        if(dwCP == guintDBCScp)
        {
            if (pcf->wd.sDBCSInc) // dbcs fixed pitch base font
            {
                bRet = bComputeCharWidthsDBCS (pcf,iFirst,iLast,fl,pvBuf);
            }
            else if (iLast < 0x80)
            {
                // linked case, base font is a latin font, but linked font
                // perhaps is a FE font. We know that base font is a latin font
                // because for FE proportional fonts we would never create pcf.
                // We are looking for this special case when the application asked
                // for Latin Face Name in the logfont, and a FE charset, but the string
                // passed in lackily does not contain DBCS glyphs.

                bRet = bComputeCharWidths(pcf,iFirst,iLast,fl,pvBuf);
            }
            else
            {
                bExit = FALSE;
            }
        }
        else
        {
            bRet = bComputeCharWidths(pcf,iFirst,iLast,fl,pvBuf);
        }

        DEC_CFONT_REF(pcf);

        if(bExit)
        {
            LEAVECRITICALSECTION(&semLocal);
            return(bRet);
        }
    }

    LEAVECRITICALSECTION(&semLocal);

    // Let the server do it.

    cjWidths = cwc * GCW_SIZE(fl);

    //
    // Non kernel mode call
    //

    // What if user's buffer is set up for 16 bit return?? Then we need
    // to allocate buffer for 32 bit date and convert to user's buffer after
    // the call

    pvResultBuffer = pvBuf;


    if (fl & GCW_16BIT)
    {
        // User's buffer is 16 bit, make 32 a bit
        // temp buffer

        pvResultBuffer = LOCALALLOC(cwc * sizeof(LONG));
    
    if (pvResultBuffer == NULL) {
        GdiSetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(bRet);
    }
    }

    // Kernel mode, use users buffer for return data
    // convert to unicode

    if(bDBCSCodePage)
    {
        bRet = bSetUpUnicodeStringDBCS(iFirst,
                                        iLast,
                                        (PUCHAR) pvResultBuffer,
                                        awc,
                                        dwCP,
                                        GetCurrentDefaultChar(hdc));
    }
    else
    {
        bRet = bSetUpUnicodeString(iFirst,iLast,pvResultBuffer,awc,dwCP);
    }

    if(bRet)
    {
        bRet = NtGdiGetCharWidthW(hdc,
                                  0,
                                  cwc,
                                  awc,
                                  (LONG)(fl & (GCW_INT | GCW_WIN3)),
                                  pvResultBuffer);
    }

    if (bRet)
    {
    //
    // May need to convert to 16 bit user buffer
    //

        if (fl & GCW_16BIT)
        {

            PWORD   pw = pvBuf;
            PDWORD  pi = (int *)pvResultBuffer;
            PDWORD  piEnd = pi + cwc;

            ASSERTGDI(pvResultBuffer != pvBuf, "Local buffer not allocated properly");

            while (pi != piEnd)
            {
                *pw++ = (WORD)(*pi++);
            }

            LOCALFREE(pvResultBuffer);

        }
    }

    return(bRet);
}

/******************************Public*Routine******************************\
*
* BOOL APIENTRY GetCharWidthA
*
* History:
*  25-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GetCharWidthA
(
IN  HDC   hdc,
IN  UINT  iFirst,
IN  UINT  iLast,
OUT LPINT lpWidths
)
{
    FIXUP_HANDLE(hdc);
    return bGetCharWidthA(hdc,iFirst,iLast,GCWFL(GCW_WIN3_INT,int),(PVOID)lpWidths);
}

BOOL APIENTRY GetCharWidth32A
(
IN  HDC   hdc,
IN  UINT  iFirst,
IN  UINT  iLast,
OUT LPINT lpWidths
)
{
    FIXUP_HANDLE(hdc);

    return bGetCharWidthA(hdc,iFirst,iLast,GCWFL(GCW_INT,int),(PVOID)lpWidths);
}

/******************************Public*Routine******************************\
*
* GetCharWidthFloatA
*
* History:
*  22-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GetCharWidthFloatA
(
IN  HDC    hdc,
IN  UINT   iFirst,
IN  UINT   iLast,
OUT PFLOAT lpWidths
)
{
    FIXUP_HANDLE(hdc);
    return bGetCharWidthA(hdc,iFirst,iLast,GCWFL(0,FLOAT),(PVOID)lpWidths);
}

/******************************Public*Routine******************************\
*
* BOOL bGetCharWidthW
*
* GetCharWidthW and GetCharWidthFloatW
*
* History:
*  28-Aug-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL bGetCharWidthW
(
HDC   hdc,
UINT  iFirst,     // unicode value
UINT  iLast,      // unicode value
ULONG fl,
PVOID pvBuf
)
{
    LONG        cwc;
    BOOL        bRet = FALSE;

// do parameter validation, check that in chars are indeed unicode

    if ((pvBuf == (PVOID)NULL) || (iFirst > iLast) || (iLast & 0xffff0000))
    {
        WARNING("gdi!_bGetCharWidthW parameters \n");
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(bRet);
    }

    cwc = (LONG)(iLast - iFirst + 1);

    if(iLast < 0x80)
    {
        CFONT       *pcf = NULL;
        PDC_ATTR    pDcAttr;
        DWORD       dwCP;

        PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

        if (!pDcAttr)
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            return(FALSE);
        }

        dwCP = GET_CODE_PAGE(hdc, pDcAttr);

        ENTERCRITICALSECTION(&semLocal);

        if ((dwCP == CP_ACP) ||
            (dwCP == guintAcp)
            || (dwCP == guintDBCScp)
        )

        {
            pcf = pcfLocateCFONT(hdc,pDcAttr,iFirst,(PVOID) NULL,(UINT) cwc, TRUE);
        }

        if (pcf != NULL)
        {
            bRet = bComputeCharWidths(pcf,iFirst,iLast,fl,pvBuf);

            DEC_CFONT_REF(pcf);

            if(bRet)
            {
                LEAVECRITICALSECTION(&semLocal);
                return (bRet);
            }
        }

        LEAVECRITICALSECTION(&semLocal);
    }

    //
    // kernel mode
    //

    bRet = NtGdiGetCharWidthW(
                hdc,
                iFirst,
                cwc,
                NULL,
                (LONG)(fl & (GCW_INT | GCW_WIN3)),
                pvBuf);

    return(bRet);

}

/******************************Public*Routine******************************\
*
* BOOL APIENTRY GetCharWidthFloatW
*
* History:
*  22-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GetCharWidthFloatW
(
HDC    hdc,
UINT   iFirst,
UINT   iLast,
PFLOAT lpWidths
)
{
    FIXUP_HANDLE(hdc);
    return bGetCharWidthW(hdc,iFirst,iLast,0,(PVOID)lpWidths);
}

/******************************Public*Routine******************************\
*
* BOOL APIENTRY GetCharWidthW
*
* History:
*  25-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GetCharWidthW
(
HDC    hdc,
UINT   iFirst,
UINT   iLast,
LPINT  lpWidths
)
{
    FIXUP_HANDLE(hdc);
    return bGetCharWidthW(hdc,iFirst,iLast,GCW_WIN3_INT,(PVOID)lpWidths);
}

BOOL APIENTRY GetCharWidth32W
(
HDC    hdc,
UINT   iFirst,
UINT   iLast,
LPINT  lpWidths
)
{
    FIXUP_HANDLE(hdc);
    return bGetCharWidthW(hdc,iFirst,iLast,GCW_INT,(PVOID)lpWidths);
}


/******************************Public*Routine******************************\
*
* WINGDIAPI BOOL  WINAPI GetCharWidthI(HDC, UINT, UINT, PWCHAR, LPINT);
*
* if pgi == NULL use the consecutive range
*   giFirst, giFirst + 1, ...., giFirst + cgi - 1
*
* if pgi != NULL ignore giFirst and use cgi indices pointed to by pgi
*
* History:
*  28-Aug-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


BOOL  WINAPI GetCharWidthI(
    HDC    hdc,
    UINT   giFirst,
    UINT   cgi,
    LPWORD pgi,
    LPINT  piWidths
)
{
    BOOL   bRet = FALSE;

// do parameter validation

    if (!piWidths || (!pgi && (giFirst & 0xffff0000)))
    {
        WARNING("gdi! GetCharWidthI parameters \n");
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(bRet);
    }

    if (!cgi)
        return TRUE; // quick exit

// kernel mode

    bRet = NtGdiGetCharWidthW(
                hdc,
                giFirst,
                cgi,
                (PWCHAR)pgi,
                (GCW_INT | GCW_GLYPH_INDEX),
                (PVOID)piWidths);

    return bRet;
}




/******************************Public*Routine******************************\
*
* BOOL APIENTRY GetTextExtentPointW(HDC hdc,LPWSTR pwsz,DWORD cwc,LPSIZE psizl)
*
*
* History:
*  07-Aug-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

#define QUICK_BUFSIZE   0xFF

BOOL GetTextExtentPointWInternal(
         HDC hdc,LPCWSTR pwsz,int cwc,LPSIZE psizl, FLONG fl
         )
{
    WCHAR       *pwc;
    CFONT       *pcf;
    INT         bRet;
    PDC_ATTR    pDcAttr;
    BOOL        bCache;
    INT         i;
    WCHAR       wcTest = 0;
    int         ii = cwc;

    FIXUP_HANDLE(hdc);

    if (cwc <= 0)
    {

    // empty string, just return 0 for the extent

        if (cwc == 0)
        {
            psizl->cx = 0;
            psizl->cy = 0;
            return(TRUE);
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            return(FALSE);
        }
    }

    // Let's see if we can take advantage of the ANSI client side GetTextExtent
    // code.  If we can convert everything from Unicode to ANSI by ignoring the
    // high byte and it fits into our quick buffer then we can.  In the future
    // we will probably want to do a quick Unicode to ANSI conversion using
    // something other than sign extension so we don't mess up non 1252 CP locales
    // by making them go through the slow code all the time.

    // We need to use this performance optimization if an LPK is installed
    // and some condiditions are met (LTR text alignment, ..etc)

    pwc = (WCHAR *) pwsz;

    unroll_here:
    switch(ii)
    {
        default:
            wcTest |= pwc[9];
        case 9:
            wcTest |= pwc[8];
        case 8:
            wcTest |= pwc[7];
        case 7:
            wcTest |= pwc[6];
        case 6:
            wcTest |= pwc[5];
        case 5:
            wcTest |= pwc[4];
        case 4:
            wcTest |= pwc[3];
        case 3:
            wcTest |= pwc[2];
        case 2:
            wcTest |= pwc[1];
        case 1:
            wcTest |= pwc[0];
    }

    if ((ii > 10) && !(wcTest & 0xFF80))
    {
        ii -= 10;
        pwc += 10;
        goto unroll_here;
    }

    if (!(wcTest & 0xFF80))
    {
        PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);
        if (!pDcAttr)
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            return(FALSE);
        }
#ifdef LANGPACK
        if (!gbLpk || (*fpLpkUseGDIWidthCache)(hdc, (LPCSTR) pwsz,cwc, pDcAttr->lTextAlign , TRUE)) {
#endif

        ENTERCRITICALSECTION(&semLocal);

        pcf = pcfLocateCFONT(hdc,pDcAttr,0,(PVOID)pwsz,cwc, FALSE);

        if (pcf != NULL)
        {
            bRet = bComputeTextExtent(pDcAttr,pcf,(PVOID) pwsz,cwc,fl,psizl,FALSE);

            DEC_CFONT_REF(pcf);

            if(bRet)
            {
                LEAVECRITICALSECTION(&semLocal);
                return (bRet);
            }
        }


        LEAVECRITICALSECTION(&semLocal);
#ifdef LANGPACK
       }
#endif
    }

#ifdef LANGPACK
    if(gbLpk)
    {
        return(*fpLpkGetTextExtentExPoint)(hdc, pwsz, cwc, -1, NULL, NULL,
                                           psizl, fl, -1);
    }
#endif

    return NtGdiGetTextExtent(hdc,
                              (LPWSTR)pwsz,
                              cwc,
                              psizl,
                              fl);

}


BOOL APIENTRY GetTextExtentPointW(HDC hdc,LPCWSTR pwsz,int cwc,LPSIZE psizl)
{
    return GetTextExtentPointWInternal(hdc, pwsz, cwc, psizl, GGTE_WIN3_EXTENT);
}


BOOL APIENTRY GetTextExtentPoint32W(HDC hdc,LPCWSTR pwsz,int cwc,LPSIZE psizl)
{
    return GetTextExtentPointWInternal(hdc, pwsz, cwc, psizl, 0);
}

/******************************Public*Routine******************************\
*
* GetTextExtentPointI, index version
*
* History:
*  28-Aug-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


BOOL  APIENTRY GetTextExtentPointI(HDC hdc, LPWORD pgiIn, int cgi, LPSIZE psize)
{
    return NtGdiGetTextExtent(hdc, (LPWSTR)pgiIn, cgi , psize, GGTE_GLYPH_INDEX);
}

/******************************Public*Routine******************************\
*
* GetFontUnicodeRanges(HDC, LPGLYPHSET)
*
* return Unicode content of the font.
*
* History:
*  28-Aug-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

#if 0

DWORD WINAPI GetFontUnicodeRanges(HDC hdc, LPGLYPHSET pgs)
{
    return NtGdiGetFontUnicodeRanges(hdc, pgs);
}

#endif

/******************************Public*Routine******************************\
*
* GetGlyphIndicesA(HDC, LPCSTR, int, LPWORD, DWORD mode);
*
* cmap based conversion, if (mode) indicate that glyph is not supported in the
* font by putting FFFF in the output array
*
* If successfull, the function returns the number of indicies in pgi buffer.
*
* History:
*  28-Aug-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

DWORD WINAPI GetGlyphIndicesA(
    HDC    hdc,
    LPCSTR psz,
    int    c,
    LPWORD pgi,
    DWORD  iMode)
{
    DWORD       dwRet = GDI_ERROR;
    PWSZ        pwszCapt;
    PDC_ATTR    pDcAttr;
    DWORD       dwCP;
    WCHAR awcCaptureBuffer[CAPTURE_STRING_SIZE];

    FIXUP_HANDLE(hdc);

    if (c <= 0)
    {
    // empty string, just return 0 for the extent

        if (c == 0)
        {
            dwRet = 0;
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            dwRet = GDI_ERROR;
        }
        return(dwRet);
    }

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);
    if (!pDcAttr)
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        dwRet = GDI_ERROR;
        return dwRet;
    }

    dwCP = GET_CODE_PAGE(hdc, pDcAttr);

    if(guintDBCScp == dwCP)
    {
        QueryFontAssocStatus();

        if(fFontAssocStatus &&
           ((c == 1) || ((c == 2 && *(psz) && *((LPCSTR)(psz + 1)) == '\0'))))
        {
        //
        // If this function is called with only 1 char, and font association
        // is enabled, we should forcely convert the chars to Unicode with
        // codepage 1252.
        // This is for enabling to output Latin-1 chars ( > 0x80 in Ansi codepage )
        // Because, normally font association is enabled, we have no way to output
        // those charactres, then we provide the way, if user call TextOutA() with
        // A character and ansi font, we tempotary disable font association.
        // This might be Windows 3.1 (Korean/Taiwanese) version compatibility..
        //
            dwCP = 1252;
        }
    }

// Allocate the string buffer

    if (c <= CAPTURE_STRING_SIZE)
    {
        pwszCapt = awcCaptureBuffer;
    }
    else
    {
        pwszCapt = LOCALALLOC(c * sizeof(WCHAR));
    }

    if (pwszCapt)
    {

        c = MultiByteToWideChar(dwCP, 0, psz,c, pwszCapt, c*sizeof(WCHAR));

        if (c)
        {
            dwRet =  NtGdiGetGlyphIndicesW(hdc,
                                      (LPWSTR)pwszCapt,
                                      c,
                                      pgi,
                                      iMode);
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            dwRet = GDI_ERROR;
        }

        if (pwszCapt != awcCaptureBuffer)
            LOCALFREE(pwszCapt);
    }
    else
    {
        GdiSetLastError(ERROR_NOT_ENOUGH_MEMORY);
        dwRet = GDI_ERROR;
    }

    return dwRet;
}

/******************************Public*Routine******************************\
*
* GetGlyphIndicesW(HDC, LPCSTR, int, LPWORD, DWORD);
*
* cmap based conversion, if (mode) indicate that glyph is not supported in the
* font by putting FFFF in the output array
*
* History:
*  28-Aug-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

#if 0

DWORD WINAPI GetGlyphIndicesW(
    HDC     hdc,
    LPCWSTR pwc,
    int     cwc,
    LPWORD  pgi,
    DWORD   iMode)
{
    return NtGdiGetGlyphIndicesW(hdc, pwc, cwc, pgi, iMode);
}

#endif

/******************************Public*Routine******************************\
*
* int APIENTRY GetTextFaceA(HDC hdc,int c,LPSTR psz)
*
* History:
*  30-Aug-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

int APIENTRY GetTextFaceA(HDC hdc,int c,LPSTR psz)
{
    ULONG cRet = 0;
    ULONG cbAnsi = 0;

    FIXUP_HANDLE(hdc);

    if ( (psz != (LPSTR) NULL) && (c <= 0) ) 
    {
        WARNING("gdi!GetTextFaceA(): invalid parameter\n");
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return cRet;
    }

    {
        //
        // Kernel mode, allocate a buffer for WCAHR return
        //
        // WINBUG #82833 2-7-2000 bhouse Possible cleanup work in GetTextFaceA
        // Old Comment:
        //    - This allocates a temp buffer, then NtGdi does it again
        //

        PWCHAR pwch = (PWCHAR)NULL;

        if (c > 0)
        {
            pwch = (WCHAR *)LOCALALLOC(c * sizeof(WCHAR));
            if (pwch == (WCHAR *)NULL)
            {
                WARNING("gdi!GetTextFaceA(): Memory allocation error\n");
                cRet = 0;
                return(cRet);
            }
        }

        cRet = NtGdiGetTextFaceW(hdc,c,(LPWSTR)pwch,FALSE);

        if(cRet && (guintDBCScp != 0xFFFFFFFF) && !psz )
        {
            WCHAR *pwcTmp;

        // now we need to actually need to get the string for DBCS code pages
        // so that we can compute the proper multi-byte length

            if(pwcTmp = (WCHAR*)LOCALALLOC(cRet*sizeof(WCHAR)))
            {
                UINT cwTmp;

                cwTmp = NtGdiGetTextFaceW(hdc,cRet,pwcTmp, FALSE);

                RtlUnicodeToMultiByteSize(&cbAnsi,pwcTmp,cwTmp*sizeof(WCHAR));
                LOCALFREE(pwcTmp);
            }
            else
            {
                WARNING("gdi!GetTextFaceA(): UNICODE to ANSI conversion failed\n");
                cRet = 0;
            }
        }
        else
        {
            cbAnsi = cRet;
        }

        //
        // If successful and non-NULL buffer, convert back to ANSI.
        //

        if ( (cRet != 0) && (psz != (LPSTR) NULL) && (pwch != (WCHAR*)NULL))
        {

            if(!(cbAnsi = WideCharToMultiByte(CP_ACP,0,pwch,cRet,psz,c,NULL,NULL)))
            {
                WARNING("gdi!GetTextFaceA(): UNICODE to ANSI conversion failed\n");
                cRet = 0;
            }
        }

        if (pwch != (PWCHAR)NULL)
        {
            LOCALFREE(pwch);
        }

    }


    //
    // return for user and kernel mode
    //

    return( ((cRet == 0 ) || (psz == NULL) || psz[cbAnsi-1] != 0 ) ? cbAnsi : cbAnsi-1 );

}

/******************************Public*Routine******************************\
*
* DWORD APIENTRY GetTextFaceAliasW(HDC hdc,DWORD c,LPWSTR pwsz)
*
* History:
*  24-Feb-1998 -by- Yung-Jen Tony Tsai [YungT]
* Wrote it.
\**************************************************************************/

int APIENTRY GetTextFaceAliasW(HDC hdc,int c,LPWSTR pwsz)
{
    int cRet = 0;

    FIXUP_HANDLE(hdc);

    if ( (pwsz != (LPWSTR) NULL) && (c == 0) )
    {
        WARNING("gdi!GetTextFaceAliasW(): invalid parameter\n");
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return cRet;
    }

    cRet = NtGdiGetTextFaceW(hdc,c,pwsz,TRUE);

    return(cRet);
}


/******************************Public*Routine******************************\
*
* DWORD APIENTRY GetTextFaceW(HDC hdc,DWORD c,LPWSTR pwsz)
*
* History:
*  13-Aug-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

int APIENTRY GetTextFaceW(HDC hdc,int c,LPWSTR pwsz)
{
    int cRet = 0;

    FIXUP_HANDLE(hdc);

    if ( (pwsz != (LPWSTR) NULL) && (c <= 0) )
    {
        WARNING("gdi!GetTextFaceW(): invalid parameter\n");
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return cRet;
    }

    cRet = NtGdiGetTextFaceW(hdc,c,pwsz,FALSE);

    return(cRet);
}

/******************************Public*Routine******************************\
*
* vTextMetricWToTextMetricStrict (no char conversion)
*
* Effects: return FALSE if UNICODE chars have no ASCI equivalents
*
*
* History:
*  20-Aug-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID FASTCALL vTextMetricWToTextMetricStrict
(
LPTEXTMETRICA  ptm,
LPTEXTMETRICW  ptmw
)
{

    ptm->tmHeight           = ptmw->tmHeight             ; // DWORD
    ptm->tmAscent           = ptmw->tmAscent             ; // DWORD
    ptm->tmDescent          = ptmw->tmDescent            ; // DWORD
    ptm->tmInternalLeading  = ptmw->tmInternalLeading    ; // DWORD
    ptm->tmExternalLeading  = ptmw->tmExternalLeading    ; // DWORD
    ptm->tmAveCharWidth     = ptmw->tmAveCharWidth       ; // DWORD
    ptm->tmMaxCharWidth     = ptmw->tmMaxCharWidth       ; // DWORD
    ptm->tmWeight           = ptmw->tmWeight             ; // DWORD
    ptm->tmOverhang         = ptmw->tmOverhang           ; // DWORD
    ptm->tmDigitizedAspectX = ptmw->tmDigitizedAspectX   ; // DWORD
    ptm->tmDigitizedAspectY = ptmw->tmDigitizedAspectY   ; // DWORD
    ptm->tmItalic           = ptmw->tmItalic             ; // BYTE
    ptm->tmUnderlined       = ptmw->tmUnderlined         ; // BYTE
    ptm->tmStruckOut        = ptmw->tmStruckOut          ; // BYTE

    ptm->tmPitchAndFamily   = ptmw->tmPitchAndFamily     ; //        BYTE
    ptm->tmCharSet          = ptmw->tmCharSet            ; //               BYTE

}


VOID FASTCALL vTextMetricWToTextMetric
(
LPTEXTMETRICA  ptma,
TMW_INTERNAL   *ptmi
)
{
    vTextMetricWToTextMetricStrict(ptma,&ptmi->tmw);

    ptma->tmFirstChar    =  ptmi->tmdTmw.chFirst  ;
    ptma->tmLastChar     =  ptmi->tmdTmw.chLast   ;
    ptma->tmDefaultChar  =  ptmi->tmdTmw.chDefault;
    ptma->tmBreakChar    =  ptmi->tmdTmw.chBreak  ;
}


/******************************Public*Routine******************************\
* GetTextExtentExPointA
*
* History:
*  06-Jan-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GetTextExtentExPointA (
    HDC     hdc,
    LPCSTR  lpszString,
    int     cchString,
    int     nMaxExtent,
    LPINT   lpnFit,
    LPINT   lpnDx,
    LPSIZE  lpSize
    )
{
    WCHAR       *pwsz = NULL;
    WCHAR        awc[GCP_GLYPHS];
    INT          aiDx[GCP_GLYPHS];
    INT          *pDx;
    BOOL         bRet = FALSE;
    DWORD        dwCP;
    BOOL		 bZeroSize = FALSE;

    FIXUP_HANDLE(hdc);

// some parameter checking. In a single check we will both make sure that
// cchString is not negative and if positive, that it is not bigger than
// ULONG_MAX / (sizeof(ULONG) + sizeof(WCHAR)). This restriction is necessary
// for one of the memory allocations in ntgdi.c allocates
//           cchString * (sizeof(ULONG) + sizeof(WCHAR)).
// Clearly, the result of this multiplication has to fit in ULONG for the
// alloc to make sense:

// also there is a validity check to be performed on nMaxExtent. -1 is the only
// legal negative value of nMaxExtent, this basically means
// that nMaxExtent can be ignored. All other negative values of nMaxExtent are
// not considered legal input.


    if
    (
        ((ULONG)cchString > (ULONG_MAX / (sizeof(ULONG)+sizeof(WCHAR))))
        ||
        (nMaxExtent < -1)
    )
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return bRet;
    }

    if(cchString == 0)
    	bZeroSize = TRUE;

// now allocate memory (if needed) for the unicode string if needed

    if (cchString <= GCP_GLYPHS)
    {
        pwsz = awc;
        pDx = aiDx;
    }
    else
    {
        pwsz = LOCALALLOC((cchString+1) * (sizeof(WCHAR) + sizeof(INT)));
        pDx = (INT*) &pwsz[(cchString+1)&~1];
    }


    if (pwsz)
    {
        UINT cwcWideChars;

    // convert Ansi To Unicode based on the code page of the font selected in DC

        dwCP = GetCodePage(hdc);
        if( bZeroSize || ( cwcWideChars = MultiByteToWideChar(dwCP,
                                              0,
                                              lpszString, cchString,
                                              pwsz, cchString*sizeof(WCHAR))) )
        {
            BOOL bDBCSFont = IS_ANY_DBCS_CODEPAGE(dwCP) ? TRUE : FALSE;

            if(bZeroSize){
            	cwcWideChars = 0;
            	pwsz[0] = (WCHAR) 0x0;
            }

#ifdef LANGPACK
            if(gbLpk)
            {
                bRet = (*fpLpkGetTextExtentExPoint)(hdc, pwsz, cwcWideChars, nMaxExtent,
                                                    lpnFit, bDBCSFont ? pDx : lpnDx,
                                                    lpSize, 0, 0);
            }
            else
#endif
            bRet = NtGdiGetTextExtentExW(hdc,
                                         pwsz,
                                         cwcWideChars,
                                         nMaxExtent,
                                         lpnFit,
                                         bDBCSFont ? pDx : lpnDx,
                                         lpSize,
                                         0);

            if (bDBCSFont && bRet)
            {
            // if this is a DBCS font then we need to make some adjustments

                int i, j;
                int cchFit, cwc;

            // first compute return the proper fit in multi byte characters

                if (lpnFit)
                {
                    cwc = *lpnFit;
                    cchFit = WideCharToMultiByte(dwCP, 0, pwsz, cwc, NULL, 0, NULL, NULL);
                    *lpnFit = cchFit;
                }
                else
                {
                    cwc = cwcWideChars;
                    cchFit = cchString;
                }

            // next copy the dx array.  we duplicate the dx value for the high
            // and low byte of DBCS characters.

                if(lpnDx)
                {
                    for(i = 0, j = 0; i < cchFit; j++)
                    {
                        if(IsDBCSLeadByteEx(dwCP,lpszString[i]))
                        {
                            lpnDx[i++] = pDx[j];
                            lpnDx[i++] = pDx[j];
                        }
                        else
                        {
                            lpnDx[i++] = pDx[j];
                        }
                    }

                // I claim that we should be at exactly at the end of the Unicode
                // string once we are here if not we need to examine the above loop
                // to make sure it works properly [gerritv]

                    ASSERTGDI(j == cwc,
                          "GetTextExtentExPointA: problem converting DX array\n");
                }
            }
        }
        else
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
        }

        if (pwsz != awc)
            LOCALFREE(pwsz);

    }

    return bRet;
}


/******************************Public*Routine******************************\
* GetTextExtentExPointW
*
* History:
*  06-Jan-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/


BOOL APIENTRY GetTextExtentExPointW (
    HDC     hdc,
    LPCWSTR lpwszString,
    int     cwchString,
    int     nMaxExtent,
    LPINT   lpnFit,
    LPINT   lpnDx,
    LPSIZE  lpSize
    )
{

#ifdef LANGPACK
    if(gbLpk)
    {
        return (*fpLpkGetTextExtentExPoint)(hdc, lpwszString, cwchString, nMaxExtent,
                                            lpnFit, lpnDx, lpSize, 0, -1);
    }
    else
#endif
    return NtGdiGetTextExtentExW(hdc,
                                (LPWSTR)lpwszString,
                                cwchString,
                                nMaxExtent,
                                lpnFit,
                                lpnDx,
                                lpSize,
                                0);

}


/******************************Public*Routine******************************\
*
*  GetTextExtentExPointWPri,
*  The same as  GetTextExtentExPointW, the only difference is that
*  lpk is bypassed, whether installed or not. This routine is actually called
*  by lpk when it is installed.
*
* History:
*  03-Jun-1997 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



BOOL APIENTRY GetTextExtentExPointWPri (
    HDC     hdc,
    LPCWSTR lpwszString,
    int     cwchString,
    int     nMaxExtent,
    LPINT   lpnFit,
    LPINT   lpnDx,
    LPSIZE  lpSize
    )
{

    return NtGdiGetTextExtentExW(hdc,
                                (LPWSTR)lpwszString,
                                cwchString,
                                nMaxExtent,
                                lpnFit,
                                lpnDx,
                                lpSize,
                                0);

}




/******************************Public*Routine******************************\
*
* BOOL APIENTRY GetTextExtentExPointI
*
*
* History:
*  09-Sep-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



BOOL APIENTRY GetTextExtentExPointI (
    HDC     hdc,
    LPWORD  lpwszString,
    int     cwchString,
    int     nMaxExtent,
    LPINT   lpnFit,
    LPINT   lpnDx,
    LPSIZE  lpSize
    )
{
    return NtGdiGetTextExtentExW(hdc,
                                (LPWSTR)lpwszString,
                                cwchString,
                                nMaxExtent,
                                lpnFit,
                                lpnDx,
                                lpSize,
                                GTEEX_GLYPH_INDEX);
}

/******************************Public*Routine******************************\
*
* bGetCharABCWidthsA
*
* works for both floating point and integer version depending on bInt
*
* History:
*  24-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL bGetCharABCWidthsA (
    HDC      hdc,
    UINT     wFirst,
    UINT     wLast,
    FLONG    fl,
    PVOID    pvBuf        // if (fl & GCABCW_INT) pabc else  pabcf,
    )
{
    BOOL    bRet = FALSE;
    ULONG   cjData, cjWCHAR, cjABC;
    ULONG   cChar = wLast - wFirst + 1;
    DWORD   dwCP = GetCodePage(hdc);
    BOOL        bDBCSCodePage;

    bDBCSCodePage = IS_ANY_DBCS_CODEPAGE(dwCP);

// Parameter checking.
    FIXUP_HANDLE(hdc);

    if((pvBuf  == (PVOID) NULL) ||
       (bDBCSCodePage && !IsValidDBCSRange(wFirst,wLast)) ||
       (!bDBCSCodePage && ((wFirst > wLast) || (wLast > 255))))
    {
        WARNING("gdi!_GetCharABCWidthsA(): bad parameter\n");
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

// Compute buffer space needed in memory window.
// Buffer will be input array of WCHAR followed by output arrary of ABC.
// Because ABC need 32-bit alignment, cjWCHAR is rounded up to DWORD boundary.

    cjABC  = cChar * ((fl & GCABCW_INT) ? sizeof(ABC) : sizeof(ABCFLOAT));
    cjWCHAR = ALIGN4(cChar * sizeof(WCHAR));
    cjData = cjWCHAR + cjABC;


    //
    // WINBUG 82840 2-7-2000 bhouse Possible cleanup in bGetCharABCWidthsA
    // Old Comment:
    //    - if vSetUpUnicodeString,x could be moved to ntgdi,
    //      we wouldn't need to allocated temp buffers twice
    //
    // Allocate memory for temp buffer, fill in with proper char values
    //
    // Write the unicode string [wFirst,wLast] at the top of the buffer.
    // vSetUpUnicodeString requires a tmp CHAR buffer; we'll cheat a little
    // and use the ABC return buffer (this assumes that ABC is bigger
    // than a CHAR or USHORT in the case of DBCS).  We can get away with this b
    // because this memory is an output buffer for the server call.
    //

    {
        PUCHAR pjTempBuffer = LOCALALLOC(cjData);
        PUCHAR pwcABC = pjTempBuffer + cjWCHAR;
        PWCHAR pwcCHAR  = (PWCHAR)pjTempBuffer;

        if (pjTempBuffer == (PUCHAR)NULL)
        {
            bRet = FALSE;
        }
        else
        {

            if(bDBCSCodePage)
            {
                bRet = bSetUpUnicodeStringDBCS(wFirst,
                                               wLast,
                                               pwcABC,
                                               pwcCHAR,
                                               dwCP,
                                               GetCurrentDefaultChar(hdc));
            }
            else
            {
                bRet = bSetUpUnicodeString(wFirst,
                                           wLast,
                                           pwcABC,
                                           pwcCHAR, dwCP);
            }

            //
            // call GDI
            //

            if(bRet)
            {
                bRet = NtGdiGetCharABCWidthsW(hdc,
                                              wFirst,
                                              cChar,
                                              (PWCHAR)pwcCHAR,
                                              (fl & GCABCW_INT),
                                              (PVOID)pwcABC);
            }

            //
            // If OK, then copy return data out of window.
            //

            if (bRet)
            {
                RtlCopyMemory((PBYTE) pvBuf,pwcABC, cjABC);
            }

            LOCALFREE(pjTempBuffer);
        }
    }
    return bRet;
}


/******************************Public*Routine******************************\
* BOOL APIENTRY GetCharABCWidthsA (
*
* We want to get ABC spaces
* for a contiguous set of input codepoints (that range from wFirst to wLast).
* The set of corresponding UNICODE codepoints is not guaranteed to be
* contiguous.  Therefore, we will translate the input codepoints here and
* pass the server a buffer of UNICODE codepoints.
*
* History:
*  20-Jan-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GetCharABCWidthsA (
    HDC      hdc,
    UINT     wFirst,
    UINT     wLast,
    LPABC   lpABC
    )
{
    return bGetCharABCWidthsA(hdc,wFirst,wLast,GCABCW_INT,(PVOID)lpABC);
}


/******************************Public*Routine******************************\
*
* GetCharABCWidthsFloatA
*
* History:
*  22-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GetCharABCWidthsFloatA
(
IN HDC           hdc,
IN UINT          iFirst,
IN UINT          iLast,
OUT LPABCFLOAT   lpABCF
)
{
    return bGetCharABCWidthsA(hdc,iFirst,iLast,0,(PVOID)lpABCF);
}


/******************************Public*Routine******************************\
*
* bGetCharABCWidthsW
*
* History:
*  22-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL bGetCharABCWidthsW (
    IN HDC      hdc,
    IN UINT     wchFirst,
    IN UINT     wchLast,
    IN FLONG    fl,
    OUT PVOID   pvBuf
    )
{
    BOOL    bRet = FALSE;
    ULONG   cwch = wchLast - wchFirst + 1;

// Parameter checking.
    FIXUP_HANDLE(hdc);

    if ( (pvBuf == (PVOID)NULL) || (wchFirst > wchLast) )
    {
        WARNING("gdi!GetCharABCWidthsW(): bad parameter\n");
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(FALSE);
    }

    //
    // kernel mode
    //

    bRet = NtGdiGetCharABCWidthsW(
                            hdc,
                            wchFirst,
                            cwch,
                            (PWCHAR)NULL,
                            fl,
                            (PVOID)pvBuf);

    return(bRet);

}


/******************************Public*Routine******************************\
* BOOL APIENTRY GetCharABCWidthsW (
*     IN HDC      hdc,
*     IN WORD     wchFirst,
*     IN WORD     wchLast,
*     OUT LPABC   lpABC
*     )
*
* For this case, we can truly assume that we want to get ABC character
* widths for a contiguous set of UNICODE codepoints from wchFirst to
* wchLast (inclusive).  So we will call the server using wchFirst, but
* with an empty input buffer.
*
* History:
*  20-Jan-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GetCharABCWidthsW (
    HDC     hdc,
    UINT    wchFirst,
    UINT    wchLast,
    LPABC   lpABC
    )
{
    return bGetCharABCWidthsW(hdc,wchFirst,wchLast,GCABCW_INT,(PVOID)lpABC);
}


/******************************Public*Routine******************************\
*
* GetCharABCWidthsFloatW
*
* Effects:
*
* Warnings:
*
* History:
*  22-Feb-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GetCharABCWidthsFloatW
(
HDC         hdc,
UINT        iFirst,
UINT        iLast,
LPABCFLOAT  lpABCF
)
{
    return bGetCharABCWidthsW(hdc,iFirst,iLast,0,(PVOID)lpABCF);
}


/******************************Public*Routine******************************\
*
* GetCharABCWidthsI, index version
*
* if pgi == NULL use the consecutive range
*   giFirst, giFirst + 1, ...., giFirst + cgi - 1
*
* if pgi != NULL ignore giFirst and use cgi indices pointed to by pgi
*
* History:
*  28-Aug-1996 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL  APIENTRY GetCharABCWidthsI(
    HDC    hdc,
    UINT   giFirst,
    UINT   cgi,
    LPWORD pgi,
    LPABC  pabc
)
{
    return NtGdiGetCharABCWidthsW(hdc,
                                  giFirst,
                                  cgi,
                                  pgi,
                                  GCABCW_INT | GCABCW_GLYPH_INDEX,
                                  pabc
                                  );
}




/******************************Public*Routine******************************\
* GetFontData
*
* Client side stub to GreGetFontData.
*
* History:
*  17-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

DWORD APIENTRY GetFontData (
    HDC     hdc,
    DWORD   dwTable,
    DWORD   dwOffset,
    PVOID   pvBuffer,
    DWORD   cjBuffer
    )
{
    DWORD dwRet = (DWORD) -1;

    FIXUP_HANDLE(hdc);

// if there is no buffer to copy data to, ignore possibly different
// from zero cjBuffer parameter. This is what win95 is doing.

    if (cjBuffer && (pvBuffer == NULL))
        cjBuffer = 0;

    dwRet = NtGdiGetFontData(
                        hdc,
                        dwTable,
                        dwOffset,
                        pvBuffer,
                        cjBuffer);

    return(dwRet);
}


/******************************Public*Routine******************************\
* GetGlyphOutline
*
* Client side stub to GreGetGlyphOutline.
*
* History:
*  17-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

DWORD GetGlyphOutlineInternalW (
    HDC             hdc,
    UINT            uChar,
    UINT            fuFormat,
    LPGLYPHMETRICS  lpgm,
    DWORD           cjBuffer,
    LPVOID          pvBuffer,
    CONST MAT2     *lpmat2,
    BOOL            bIgnoreRotation
    )
{
    DWORD dwRet = (DWORD) -1;

// Parameter validation.
    FIXUP_HANDLE(hdc);

    if ( (lpmat2 == (LPMAT2) NULL)
         || (lpgm == (LPGLYPHMETRICS) NULL)
       )
    {
        WARNING("gdi!GetGlyphOutlineW(): bad parameter\n");
        return (dwRet);
    }

    if (pvBuffer == NULL)
        cjBuffer = 0;

// Compute buffer space needed in memory window.

    dwRet = NtGdiGetGlyphOutline(
                            hdc,
                            (WCHAR)uChar,
                            fuFormat,
                            lpgm,
                            cjBuffer,
                            pvBuffer,
                            (LPMAT2)lpmat2,
                            bIgnoreRotation);

    return(dwRet);
}


DWORD APIENTRY GetGlyphOutlineW (
    HDC             hdc,
    UINT            uChar,
    UINT            fuFormat,
    LPGLYPHMETRICS  lpgm,
    DWORD           cjBuffer,
    LPVOID          pvBuffer,
    CONST MAT2     *lpmat2
)
{

    return( GetGlyphOutlineInternalW( hdc,
                                      uChar,
                                      fuFormat,
                                      lpgm,
                                      cjBuffer,
                                      pvBuffer,
                                      lpmat2,
                                      FALSE ) );
}



DWORD APIENTRY GetGlyphOutlineInternalA (
    HDC             hdc,
    UINT            uChar,
    UINT            fuFormat,
    LPGLYPHMETRICS  lpgm,
    DWORD           cjBuffer,
    LPVOID          pvBuffer,
    CONST MAT2     *lpmat2,
    BOOL            bIgnoreRotation
    )
{
    WCHAR wc;
    BOOL  bRet;


    FIXUP_HANDLE(hdc);

    // The ANSI interface is compatible with Win 3.1 and is intended
    // to take a 2 byte uChar.  Since we are 32-bit, this 16-bit UINT
    // is now 32-bit.  So we are only interested in the least significant
    // word of the uChar passed into the 32-bit interface.

    if (!(fuFormat & GGO_GLYPH_INDEX))
    {
    // the conversion needs to be done based on
    // the current code page of the font selected in the dc
        UCHAR Mbcs[2];
        UINT Convert;
        DWORD dwCP = GetCodePage(hdc);


        if(IS_ANY_DBCS_CODEPAGE(dwCP) &&
           IsDBCSLeadByteEx(dwCP, (char) (uChar >> 8)))
        {
            Mbcs[0] = (uChar >> 8) & 0xFF;
            Mbcs[1] = uChar & 0xFF;
            Convert = 2;
        }
        else
        {
            Mbcs[0] = uChar & 0xFF;
            Convert = 1;
        }

        if(!(bRet = MultiByteToWideChar(dwCP, 0,
                                       (LPCSTR)Mbcs,Convert,
                                       &wc, sizeof(WCHAR))))
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
        }

    }
    else
    {
    // The uChar value is to be interpreted as glyph index and
    // no conversion is necessary

        wc = (WCHAR)uChar;
        bRet = TRUE;
    }


    if (bRet)
    {
        bRet = GetGlyphOutlineInternalW(
                   hdc,
                   (UINT) wc,
                   fuFormat,
                   lpgm,
                   cjBuffer,
                   pvBuffer,
                   lpmat2,
                   bIgnoreRotation);
    }

    return bRet;
}


DWORD APIENTRY GetGlyphOutlineA (
    HDC             hdc,
    UINT            uChar,
    UINT            fuFormat,
    LPGLYPHMETRICS  lpgm,
    DWORD           cjBuffer,
    LPVOID          pvBuffer,
    CONST MAT2     *lpmat2
)
{

    return( GetGlyphOutlineInternalA( hdc,
                                      uChar,
                                      fuFormat,
                                      lpgm,
                                      cjBuffer,
                                      pvBuffer,
                                      lpmat2,
                                      FALSE ) );
}


DWORD APIENTRY GetGlyphOutlineWow (
    HDC             hdc,
    UINT            uChar,
    UINT            fuFormat,
    LPGLYPHMETRICS  lpgm,
    DWORD           cjBuffer,
    LPVOID          pvBuffer,
    CONST MAT2     *lpmat2
)
{

    return( GetGlyphOutlineInternalA( hdc,
                                      uChar,
                                      fuFormat,
                                      lpgm,
                                      cjBuffer,
                                      pvBuffer,
                                      lpmat2,
                                      TRUE ) );
}




/******************************Public*Routine******************************\
* GetOutlineTextMetricsW
*
* Client side stub to GreGetOutlineTextMetrics.
*
* History:
*
*  Tue 20-Apr-1993 -by- Gerrit van Wingerden [gerritv]
* update: added bTTOnly stuff for Aldus escape in the WOW layer
*
*  Thu 28-Jan-1993 -by- Bodin Dresevic [BodinD]
* update: added TMDIFF * stuff
*
*  17-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

UINT APIENTRY GetOutlineTextMetricsWInternal (
    HDC  hdc,
    UINT cjCopy,     // refers to OTMW_INTERNAL, not to OUTLINETEXTMETRICSW
    OUTLINETEXTMETRICW * potmw,
    TMDIFF             * ptmd
    )
{
    DWORD cjRet = (DWORD) 0;

    FIXUP_HANDLE(hdc);

    if (potmw == (OUTLINETEXTMETRICW *) NULL)
        cjCopy = 0;

    cjRet = NtGdiGetOutlineTextMetricsInternalW(
                        hdc,
                        cjCopy,
                        potmw,
                        ptmd);

    return(cjRet);

}

/******************************Public*Routine******************************\
*
* UINT APIENTRY GetOutlineTextMetricsW (
*
* wrote the wrapper to go around the corresponding internal routine
*
* History:
*  28-Jan-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


UINT APIENTRY GetOutlineTextMetricsW (
    HDC  hdc,
    UINT cjCopy,
    LPOUTLINETEXTMETRICW potmw
    )
{
    TMDIFF  tmd;

    return GetOutlineTextMetricsWInternal(hdc, cjCopy, potmw, &tmd);
}


#define bAnsiSize(a,b,c) (NT_SUCCESS(RtlUnicodeToMultiByteSize((a),(b),(c))))

// vAnsiSize macro should only be used within GetOTMA, where bAnsiSize
// is not supposed to fail [bodind]

#if DBG

#define vAnsiSize(a,b,c)                                              \
{                                                                     \
    BOOL bTmp = bAnsiSize(&cjString, pwszSrc, sizeof(WCHAR) * cwc);   \
    ASSERTGDI(bTmp, "gdi32!GetOTMA: bAnsiSize failed \n");            \
}

#else

#define vAnsiSize(a,b,c)    bAnsiSize(a,b,c)

#endif  //, non debug version



/******************************Public*Routine******************************\
* GetOutlineTextMetricsInternalA
*
* Client side stub to GreGetOutlineTextMetrics.
*
* History:
*
*  20-Apr-1993 -by- Gerrit van Wingerden [gerritv]
*   Changed to GetOutlineTextMetricsInternalA from GetOutlineTextMetricsA
*   to support all fonts mode for Aldus escape.
*
*  17-Feb-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

UINT APIENTRY GetOutlineTextMetricsInternalA (
    HDC  hdc,
    UINT cjCopy,
    LPOUTLINETEXTMETRICA potma
    )
{
    UINT   cjRet = 0;
    UINT   cjotma, cjotmw;

    TMDIFF               tmd;
    OUTLINETEXTMETRICW  *potmwTmp;
    OUTLINETEXTMETRICA   otmaTmp; // tmp buffer on the stack

    FIXUP_HANDLE(hdc);

// Because we need to be able to copy cjCopy bytes of data from the
// OUTLINETEXTMETRICA structure, we need to allocate a temporary buffer
// big enough for the entire structure.  This is because the UNICODE and
// ANSI versions of OUTLINETEXTMETRIC have mismatched offsets to their
// corresponding fields.

// Determine size of the buffer.

    if ((cjotmw = GetOutlineTextMetricsWInternal(hdc, 0, NULL,&tmd)) == 0 )
    {
        WARNING("gdi!GetOutlineTextMetricsInternalA(): unable to determine size of buffer needed\n");
        return (cjRet);
    }

// get cjotma from tmd.

    cjotma = (UINT)tmd.cjotma;

// if cjotma == 0, this is HONEST to God unicode font, can not convert
// strings to ansi

    if (cjotma == 0)
    {
        WARNING("gdi!GetOutlineTextMetricsInternalA(): unable to determine cjotma\n");
        return (cjRet);
    }

// Early out.  If NULL buffer, then just return the size.

    if (potma == (LPOUTLINETEXTMETRICA) NULL)
        return (cjotma);

// Allocate temporary buffers.

    if ((potmwTmp = (OUTLINETEXTMETRICW*) LOCALALLOC(cjotmw)) == (OUTLINETEXTMETRICW*)NULL)
    {
        WARNING("gdi!GetOutlineTextMetricA(): memory allocation error OUTLINETEXTMETRICW buffer\n");
        GdiSetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return (cjRet);
    }

// Call the UNICODE version of the call.

    if (GetOutlineTextMetricsWInternal(hdc, cjotmw, potmwTmp,&tmd) == 0 )
    {
        WARNING("gdi!GetOutlineTextMetricsInternalA(): call to GetOutlineTextMetricsW() failed\n");
        LOCALFREE(potmwTmp);
        return (cjRet);
    }

// Convert from OUTLINETEXTMETRICW to OUTLINETEXTMETRICA

    vOutlineTextMetricWToOutlineTextMetricA(&otmaTmp, potmwTmp,&tmd);

// Copy data into return buffer.  Do not copy strings.

    cjRet = min(cjCopy, sizeof(OUTLINETEXTMETRICA));
    RtlMoveMemory(potma,&otmaTmp,cjRet);

// Note that if
// offsetof(OUTLINETEXTMETRICA,otmpFamilyName) < cjCopy <= sizeof(OUTLINETEXTMETRICA)
// the offsets to strings have been set to zero [BodinD]

// If strings wanted, convert the strings to ANSI.

    if (cjCopy > sizeof(OUTLINETEXTMETRICA))
    {
        ULONG      cjString,cwc;
        ULONG_PTR   dpString;
        ULONG_PTR   dpStringEnd;
        PWSZ       pwszSrc;

    // first have to make sure that we will not overwrite the end
    // of the caller's buffer, if that is the case

        if (cjCopy < cjotma)
        {
        // Win 31 spec is ambiguous about this case
        // and by looking into the source code, it seems that
        // they just overwrite the end of the buffer without
        // even doing this check.

            GdiSetLastError(ERROR_CAN_NOT_COMPLETE);
            cjRet = 0;
            goto GOTMA_clean_up;
        }

    // now we know that all the strings can fit, moreover we know that
    // all string operations will succeed since we have called
    // cjOTMA to do these same operations on the server side to give us
    // cjotma [bodind]

    // Note: have to do the backwards compatible casting below because Win 3.1 insists
    //       on using a PSTR as PTRDIFF (i.e., an offset).

    // FAMILY NAME ------------------------------------------------------------

        pwszSrc = (PWSZ) (((PBYTE) potmwTmp) + (ULONG_PTR) potmwTmp->otmpFamilyName);
        cwc = wcslen(pwszSrc) + 1;
        vAnsiSize(&cjString, pwszSrc, sizeof(WCHAR) * cwc);

    // Convert from Unicode to ASCII.

        dpString = sizeof(OUTLINETEXTMETRICA);
        dpStringEnd = dpString + cjString;

        ASSERTGDI(dpStringEnd <= cjCopy, "gdi32!GetOTMA: string can not fit1\n");

        if (!bToASCII_N ((PBYTE)potma + dpString,cjString,pwszSrc,cwc))
        {
            WARNING("gdi!GetOutlineTextMetricsInternalA(): UNICODE->ASCII conv error \n");
            cjRet = 0;
            goto GOTMA_clean_up;
        }

    // Store string offset in the return structure.

        potma->otmpFamilyName = (PSTR) dpString;

    // FACE NAME --------------------------------------------------------------

        pwszSrc = (PWSZ) (((PBYTE) potmwTmp) + (ULONG_PTR) potmwTmp->otmpFaceName);
        cwc = wcslen(pwszSrc) + 1;
        vAnsiSize(&cjString, pwszSrc, sizeof(WCHAR) * cwc);

        dpString = dpStringEnd;
        dpStringEnd = dpString + cjString;

        ASSERTGDI(dpStringEnd <= cjCopy, "gdi32!GetOTMA: string can not fit2\n");

    // Convert from Unicode to ASCII.

        if (!bToASCII_N ((PBYTE)potma + dpString,cjString,pwszSrc,cwc))
        {
            WARNING("gdi!GetOutlineTextMetricsInternalA(): UNICODE->ASCII conv error \n");
            cjRet = 0;
            goto GOTMA_clean_up;
        }

    // Store string offset in return structure.  Move pointers to next string.

        potma->otmpFaceName = (PSTR) dpString;

    // STYLE NAME -------------------------------------------------------------

        pwszSrc = (PWSZ) (((PBYTE) potmwTmp) + (ULONG_PTR) potmwTmp->otmpStyleName);
        cwc = wcslen(pwszSrc) + 1;
        vAnsiSize(&cjString, pwszSrc, sizeof(WCHAR) * cwc);

        dpString = dpStringEnd;
        dpStringEnd = dpString + cjString;

        ASSERTGDI(dpStringEnd <= cjCopy, "gdi32!GetOTMA: string can not fit3\n");

    // Convert from Unicode to ASCII.

        if (!bToASCII_N ((PBYTE)potma + dpString,cjString,pwszSrc,cwc))
        {
            WARNING("gdi!GetOutlineTextMetricsInternalA(): UNICODE->ASCII conv error \n");
            cjRet = 0;
            goto GOTMA_clean_up;
        }

    // Store string offset in return structure.  Move pointers to next string.

        potma->otmpStyleName = (PSTR)dpString;

    // FULL NAME --------------------------------------------------------------

        pwszSrc = (PWSZ) (((PBYTE) potmwTmp) + (ULONG_PTR) potmwTmp->otmpFullName);
        cwc = wcslen(pwszSrc) + 1;
        vAnsiSize(&cjString, pwszSrc, sizeof(WCHAR) * cwc);

        dpString = dpStringEnd;
        dpStringEnd = dpString + cjString;

        ASSERTGDI(dpStringEnd <= cjCopy, "gdi32!GetOTMA: string can not fit4\n");

    // Convert from Unicode to ASCII.

        if (!bToASCII_N ((PBYTE)potma + dpString,cjString,pwszSrc,cwc))
        {
            WARNING("gdi!GetOutlineTextMetricsInternalA(): UNICODE->ASCII conv error \n");
            cjRet = 0;
            goto GOTMA_clean_up;
        }

    // Store string offset in return structure.

        potma->otmpFullName = (PSTR) dpString;

        //Sundown: safe to truncate ULONG
        cjRet = (ULONG)dpStringEnd;
        ASSERTGDI(cjRet == cjotma, "gdi32!GetOTMA: cjRet != dpStringEnd\n");

    }

GOTMA_clean_up:

// Free temporary buffer.

    LOCALFREE(potmwTmp);

// Fixup size field.

    if (cjCopy >= sizeof(UINT))  // if it is possible to store otmSize
        potma->otmSize = cjRet;

// Successful, so return size.

    return (cjRet);
}



/******************************Public*Routine******************************\
* GetOutlineTextMetricsA
*
* Client side stub to GreGetOutlineTextMetrics.
*
* History:
*  Tue 02-Nov-1993 -by- Bodin Dresevic [BodinD]
\**************************************************************************/


UINT APIENTRY GetOutlineTextMetricsA (
    HDC  hdc,
    UINT cjCopy,
    LPOUTLINETEXTMETRICA potma
    )
{
    return GetOutlineTextMetricsInternalA(hdc, cjCopy, potma);
}


/******************************Public*Routine******************************\
*                                                                          *
* GetKerningPairs                                                          *
*                                                                          *
* History:                                                                 *
*  Sun 23-Feb-1992 09:48:55 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

DWORD APIENTRY
GetKerningPairsW(
    IN HDC              hdc,        // handle to application's DC
    IN DWORD            nPairs,     // max no. KERNINGPAIR to be returned
    OUT LPKERNINGPAIR   lpKernPair  // pointer to receiving buffer
    )
{
    ULONG     sizeofMsg;
    DWORD     cRet = 0;

    FIXUP_HANDLE(hdc);

    if (nPairs == 0 && lpKernPair != (KERNINGPAIR*) NULL)
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(0);
    }

    cRet = NtGdiGetKerningPairs(
                        hdc,
                        nPairs,
                        lpKernPair);

    return(cRet);
}


/******************************Public*Routine******************************\
* GetKerningPairsA
*
* filters out pairs that are not contained in the code page of the font
* selected in DC
*
* History:
*  14-Mar-1996 -by- Xudong Wu [TessieW]
* Wrote it.
\**************************************************************************/


DWORD APIENTRY GetKerningPairsA
(
    HDC              hdc,        // handle to application's DC
    DWORD            nPairs,     // max no. KERNINGPAIR to be returned
    LPKERNINGPAIR    lpKernPair  // pointer to receiving buffer
)
{
    #define       MAXKERNPAIR     300
    DWORD         i;
    DWORD         dwCP;
    KERNINGPAIR   tmpKernPair[MAXKERNPAIR];
    DWORD         cRet, cRet1;
    KERNINGPAIR   *pkp, *pkrn;
    KERNINGPAIR UNALIGNED *pkrnLast;
    BOOL           bDBCS;

    FIXUP_HANDLE(hdc);

    if ((nPairs == 0) && (lpKernPair != (KERNINGPAIR*) NULL))
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(0);
    }

    cRet = NtGdiGetKerningPairs(hdc, 0, NULL);

    if (cRet == 0)
        return(cRet);

    if (cRet <= MAXKERNPAIR)
        pkrn = tmpKernPair;
    else
        pkrn =  LOCALALLOC(cRet * sizeof(KERNINGPAIR));

    if (!pkrn)
    {
        GdiSetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return 0;
    }

    cRet1 = NtGdiGetKerningPairs(hdc, cRet, pkrn);
    ASSERTGDI(!cRet1 || (cRet1 == cRet), "NtGdiGetKerningPairs returns different values\n");

    if (cRet1 == 0)
        return cRet1;

    pkp = pkrn;
    pkrnLast = lpKernPair;
    cRet = 0;

// GDI has returned iFirst and iSecond of the KERNINGPAIR structure in Unicode
// It is at this point that we translate them to the current code page

    dwCP = GetCodePage(hdc);

    bDBCS = IS_ANY_DBCS_CODEPAGE(dwCP);

    for (i = 0; i < cRet1; i++,pkp++)
    {
        UCHAR ach[2], ach2[2];
        BOOL bUsedDef[2];

        ach[0] = ach[1] = 0;        // insure zero extension

        WideCharToMultiByte(dwCP,
                            0,
                            &(pkp->wFirst),
                            1,
                            ach,
                            sizeof(ach),
                            NULL,
                            &bUsedDef[0]);
        if (!bUsedDef[0])
        {
            ach2[0] = ach2[1] = 0;

            WideCharToMultiByte(dwCP,
                                0,
                                &(pkp->wSecond),
                                1,
                                ach2,
                                sizeof(ach2),
                                NULL,
                                &bUsedDef[1]);

            if (!bUsedDef[1])
            {
                if (lpKernPair)
                {
                // do not overwrite the end of the buffer if it is provided

                    if (cRet >= nPairs)
                        break;

                    if (bDBCS)
                    {
                        if (IsDBCSLeadByteEx(dwCP,ach[0]))
                        {
                            pkrnLast->wFirst = (WORD)(ach[0] << 8 | ach[1]);
                        }
                        else
                        {
                            pkrnLast->wFirst = ach[0];
                        }

                        if (IsDBCSLeadByteEx(dwCP,ach2[0]))
                        {
                            pkrnLast->wSecond = (WORD)(ach2[0] << 8 | ach2[1]);
                        }
                        else
                        {
                            pkrnLast->wSecond = ach2[0];
                        }
                    }
                    else
                    {
                        pkrnLast->wFirst  = ach[0];
                        pkrnLast->wSecond = ach2[0];
                    }

                    pkrnLast->iKernAmount = pkp->iKernAmount;
                    pkrnLast++;

                }
                cRet++;
            }
        }
    }

    if (pkrn != tmpKernPair)
        LOCALFREE(pkrn);

    return cRet;
}




/*****************************Public*Routine******************************\
* FixBrushOrgEx
*
* for win32s
*
* History:
*  04-Jun-1992 -by-  Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

BOOL FixBrushOrgEx(HDC hdc, int x, int y, LPPOINT ptl)
{
    return(FALSE);
}

/******************************Public*Function*****************************\
* GetColorAdjustment
*
*  Get the color adjustment data for a given DC.
*
* History:
*  07-Aug-1992 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GetColorAdjustment(HDC hdc, LPCOLORADJUSTMENT pclradj)
{
    FIXUP_HANDLE(hdc);

    return(NtGdiGetColorAdjustment(hdc,pclradj));
}

/******************************Public*Routine******************************\
* GetETM
*
* Aldus Escape support
*
* History:
*  20-Oct-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GetETM (HDC hdc, EXTTEXTMETRIC * petm)
{
    BOOL  bRet = FALSE;

    FIXUP_HANDLE(hdc);

    bRet = NtGdiGetETM(hdc,petm);

// path up the number of KerningPairs to match GetKerningPairsA

    if (bRet && petm)
    {
        petm->etmNKernPairs = (WORD)GetKerningPairsA(hdc, 0, NULL);
    }

    return(bRet);
}

#if 0
/****************************Public*Routine********************************\
* GetCharWidthInfo
*
* Get the lMaxNegA lMaxNegC and lMinWidthD
*
* History:
* 09-Feb-1996 -by- Xudong Wu [tessiew]
* Wrote it
\***************************************************************************/

BOOL APIENTRY GetCharWidthInfo (HDC hdc, PCHWIDTHINFO pChWidthInfo)
{
   return ( NtGdiGetCharWidthInfo(hdc, pChWidthInfo) );
}
#endif

#ifdef LANGPACK
/******************************Public*Routine******************************\
*
* bGetRealizationInfoInternal
*
* Retreives the realization_info from kernel, if not cached in shared
* memory
*
* History:
*  18-Aug-1997 -by- Samer Arafeh [SamerA]
* Wrote it.
\**************************************************************************/

BOOL bGetRealizationInfoInternal(
    HDC hdc,
    REALIZATION_INFO *pri,
    CFONT *pcf
    )
{
    BOOL bRet = FALSE;

    if (pri)
    {
        // if no pcf or we havn't cached the metrics

        if ((pcf == NULL) || !(pcf->fl & CFONT_CACHED_RI) || pcf->timeStamp != pGdiSharedMemory->timeStamp)
        {
            REALIZATION_INFO ri;
            PDC_ATTR    pDcAttr;

            PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

			if( pcf != NULL && (pcf->fl & CFONT_PUBLIC) )
	            bRet = NtGdiGetRealizationInfo(hdc,&ri, pcf->hf);
	        else
	            bRet = NtGdiGetRealizationInfo(hdc,&ri, 0);

            if (bRet)
            {
                *pri = ri;

                if (pcf && !(pcf->fl & CFONT_PUBLIC))
                {
                    // we succeeded and we have a pcf so cache the data

                    pcf->ri = ri;

                    pcf->fl |= CFONT_CACHED_RI;

                    pcf->timeStamp = pGdiSharedMemory->timeStamp;
                }
                
            }
        }
        else
        {
            *pri = pcf->ri;
            bRet  = TRUE;
        }

    }

    return(bRet);
}

/******************************Public*Routine******************************\
*
* GdiRealizationInfo
*
* Try retreive the RealizationInfo from shared memory
*
* History:
*  18-Aug-1997 -by- Samer Arafeh [SamerA]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY GdiRealizationInfo(HDC hdc,REALIZATION_INFO *pri)
{
    BOOL bRet = FALSE;
    PDC_ATTR    pDcAttr;

    FIXUP_HANDLE(hdc);

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (pDcAttr)
    {
        CFONT * pcf;

        ENTERCRITICALSECTION(&semLocal);

        pcf = pcfLocateCFONT(hdc,pDcAttr,0,(PVOID) NULL,0,TRUE);

        bRet = bGetRealizationInfoInternal(hdc,pri,pcf);

        // pcfLocateCFONT added a reference so now we need to remove it

        if (pcf)
        {
            DEC_CFONT_REF(pcf);
        }

        LEAVECRITICALSECTION(&semLocal);
    }
    else
    {
    // it could a public DC -OBJECT_OWNER_PUBLIC- (in which gpGdiShareMemory[hDC].pUser=NULL)
    // so let's do it the expensive way by doing the kernel-transition...

        bRet = NtGdiGetRealizationInfo(hdc,pri,0);
    }

    return(bRet);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\bitmap.c ===
/******************************Module*Header*******************************\
* Module Name: bitmap.c                                                    *
*                                                                          *
* Client side stubs that move bitmaps over the C/S interface.              *
*                                                                          *
* Created: 14-May-1991 11:04:49                                            *
* Author: Eric Kutter [erick]                                              *
*                                                                          *
* Copyright (c) 1991-1999 Microsoft Corporation                                 *
\**************************************************************************/
#include "precomp.h"
#pragma hdrstop

#define EXTRAPIXEL 4
//
//The default band size is set to 4Mb
//
#define BAND_SIZE (4194304)


/******************************Public*Routine******************************\
* cjBitmapBitsSize - calculate the size of the bitmap bits for the
*   given BITMAPINFO
*
* Arguments:
*
*   pbmi - pointer to BITMAPINFO
*
* Return Value:
*
*   size of bitmap bits in butes
*
* History:
*
*    11-Jul-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/


ULONG cjBitmapBitsSize(CONST BITMAPINFO *pbmi)
{
    //
    // Check for PM-style DIB
    //

    if (pbmi->bmiHeader.biSize == sizeof(BITMAPCOREHEADER))
    {
        LPBITMAPCOREINFO pbmci;
        pbmci = (LPBITMAPCOREINFO)pbmi;
        return(CJSCAN(pbmci->bmciHeader.bcWidth,pbmci->bmciHeader.bcPlanes,
                      pbmci->bmciHeader.bcBitCount) *
                      pbmci->bmciHeader.bcHeight);
    }

    //
    // not a core header
    //

    if ((pbmi->bmiHeader.biCompression == BI_RGB) ||
        (pbmi->bmiHeader.biCompression == BI_BITFIELDS) ||
        (pbmi->bmiHeader.biCompression == BI_CMYK))
    {
        return(CJSCAN(pbmi->bmiHeader.biWidth,pbmi->bmiHeader.biPlanes,
                      pbmi->bmiHeader.biBitCount) *
               ABS(pbmi->bmiHeader.biHeight));
    }
    else
    {
        return(pbmi->bmiHeader.biSizeImage);
    }
}

//
// IS_BMI_RLE
//
// Checks if the header pointed to by pv is a BITMAPINFO for a RLE4 or RLE8.
// Evaluates to TRUE if RLE, FALSE otherwise.
//

#define IS_BMI_RLE(pv) \
    ((pv) && \
     (((BITMAPINFO *)(pv))->bmiHeader.biSize >= sizeof(BITMAPINFOHEADER)) && \
     ((((BITMAPINFO *)(pv))->bmiHeader.biCompression == BI_RLE4) || \
      (((BITMAPINFO *)(pv))->bmiHeader.biCompression == BI_RLE8) ))

//
// IS_BMI_JPEG
//
// Checks if the header pointed to by pv is a BITMAPINFO for a JPEG.
// Evaluates to TRUE if JPEG, FALSE otherwise.
//

#define IS_BMI_JPEG(pv) \
    ((pv) && \
     (((BITMAPINFO *)(pv))->bmiHeader.biSize >= sizeof(BITMAPINFOHEADER)) && \
     (((BITMAPINFO *)(pv))->bmiHeader.biCompression == BI_JPEG))

//
// IS_BMI_PNG
//
// Checks if the header pointed to by pv is a BITMAPINFO for a PNG.
// Evaluates to TRUE if PNG, FALSE otherwise.
//

#define IS_BMI_PNG(pv) \
    ((pv) && \
     (((BITMAPINFO *)(pv))->bmiHeader.biSize >= sizeof(BITMAPINFOHEADER)) && \
     (((BITMAPINFO *)(pv))->bmiHeader.biCompression == BI_PNG))

//
// IS_PASSTHROUGH_IMAGE
//
// Checks if the biCompression value is one of the passthrough formats that
// can be passed to devices (BI_JPEG or BI_PNG).
//

#define IS_PASSTHROUGH_IMAGE(biCompression) \
    (((biCompression) == BI_JPEG) || ((biCompression) == BI_PNG))

//
// IS_BMI_PASSTHROUGH_IMAGE
//
// Checks if the header pointed to by pv is a BITMAPINFO for a JPEG or PNG.
// Evaluates to TRUE if JPEG or PNG, FALSE otherwise.
//

#define IS_BMI_PASSTHROUGH_IMAGE(pv) \
    ((pv) && \
     (((BITMAPINFO *)(pv))->bmiHeader.biSize >= sizeof(BITMAPINFOHEADER)) && \
     IS_PASSTHROUGH_IMAGE(((BITMAPINFO *)(pv))->bmiHeader.biCompression))


/******************************Public*Routine******************************\
* cCalculateColorTableSize(
*
* Arguments:
*
*
*
* Return Value:
*
*
*
* History:
*
*    11-Jul-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/

BOOL
cCalculateColorTableSize(
    UINT  uiBitCount,
    UINT  uiPalUsed,
    UINT  uiCompression,
    UINT  biSize,
    ULONG *piUsage,
    ULONG *pColors
    )
{
    BOOL bStatus = FALSE;
    ULONG cColorsMax = 0;

    if (uiCompression == BI_BITFIELDS)
    {
        //
        // Handle 16 and 32 bit per pel bitmaps.
        //

        if (*piUsage == DIB_PAL_COLORS)
        {
            *piUsage = DIB_RGB_COLORS;
        }

        switch (uiBitCount)
        {
        case 16:
        case 32:
            break;
        default:
            WARNING("ConvertInfo failed for BI_BITFIELDS\n");
            return(FALSE);
        }

        if (biSize <= sizeof(BITMAPINFOHEADER))
        {
            uiPalUsed = cColorsMax = 3;
        }
        else
        {
            //
            // masks are part of BITMAPV4 and greater
            //

            uiPalUsed = cColorsMax = 0;
        }
    }
    else if (uiCompression == BI_RGB)
    {
        switch (uiBitCount)
        {
        case 1:
            cColorsMax = 2;
            break;
        case 4:
            cColorsMax = 16;
            break;
        case 8:
            cColorsMax = 256;
            break;
        default:

            if (*piUsage == DIB_PAL_COLORS)
            {
                *piUsage = DIB_RGB_COLORS;
            }

            cColorsMax = 0;

            switch (uiBitCount)
            {
            case 16:
            case 24:
            case 32:
                break;
            default:
                WARNING("convertinfo failed invalid bitcount in bmi BI_RGB\n");
                return(FALSE);
            }
        }
    }
    else if (uiCompression == BI_CMYK)
    {
        if (*piUsage == DIB_PAL_COLORS)
        {
            *piUsage = DIB_RGB_COLORS;
        }

        switch (uiBitCount)
        {
        case 1:
            cColorsMax = 2;
            break;
        case 4:
            cColorsMax = 16;
            break;
        case 8:
            cColorsMax = 256;
            break;
        case 32:
            cColorsMax = 0;
            break;
        default:
            WARNING("convertinfo failed invalid bitcount in bmi BI_CMYK\n");
            return(FALSE);
        }
    }
    else if ((uiCompression == BI_RLE4) || (uiCompression == BI_CMYKRLE4))
    {
        if (uiBitCount != 4)
        {
            // WARNING("cCalculateColroTableSize invalid bitcount BI_RLE4\n");
            return(FALSE);
        }

        cColorsMax = 16;
    }
    else if ((uiCompression == BI_RLE8) || (uiCompression == BI_CMYKRLE8))
    {
        if (uiBitCount != 8)
        {
            // WARNING("cjBitmapSize invalid bitcount BI_RLE8\n");
            return(FALSE);
        }

        cColorsMax = 256;
    }
    else if ((uiCompression == BI_JPEG) || (uiCompression == BI_PNG))
    {
        cColorsMax = 0;
    }
    else
    {
        WARNING("convertinfo failed invalid Compression in header\n");
        return(FALSE);
    }

    if (uiPalUsed != 0)
    {
        if (uiPalUsed <= cColorsMax)
        {
            cColorsMax = uiPalUsed;
        }
    }

    *pColors = cColorsMax;
    return(TRUE);
}


/**********************************************************************\
* pbmiConvertInfo
*
* Does two things:
*
* 1. takes BITMAPINFO, Converts BITMAPCOREHEADER
*    into BITMAPINFOHEADER and copies the the color table
*
* 2. also return the size of the size of INFO struct if bPackedDIB is
*    FALSE otherwise pass back the size of INFO plus cjBits
*
* Arguments:
*
*  pbmi             - original bitmapinfo
*  iUsage           - iUsage from API
*  *count           - return size
*  bCopyInfoHeader  - force copy if input is BITMAPINFOHEADER
*                     and bPackedDIB is NOT set
*  bPackedDIB       - BITMAPINFO has bitmap data that must be
*                     copied also
*
* Return Value:
*
*   Converted PBITMAPINFO if successful, otherwise NULL
*
* 10-1-95 -by- Lingyun Wang [lingyunw]
\**********************************************************************/

LPBITMAPINFO
pbmiConvertInfo(
    CONST  BITMAPINFO *pbmi,
    ULONG  iUsage,
    ULONG *count,
    BOOL   bPackedDIB
    )
{
    LPBITMAPINFO pbmiNew;
    ULONG cjRGB;
    ULONG cColors;
    UINT  uiBitCount;
    UINT  uiPalUsed;
    UINT  uiCompression;
    BOOL  bCoreHeader = FALSE;
    ULONG ulSize;
    ULONG cjBits = 0;
    PVOID pjBits, pjBitsNew;
    BOOL  bStatus;

    if (pbmi == (LPBITMAPINFO) NULL)
    {
        return(0);
    }

    //
    // Checking for different bitmap headers
    //

    ulSize = pbmi->bmiHeader.biSize;

    if (ulSize == sizeof(BITMAPCOREHEADER))
    {
        cjRGB = sizeof(RGBQUAD);
        uiBitCount = ((LPBITMAPCOREINFO)pbmi)->bmciHeader.bcBitCount;
        uiPalUsed = 0;
        uiCompression =  (UINT) BI_RGB;
        bCoreHeader = TRUE;
    }
    else if ((ulSize >= sizeof(BITMAPINFOHEADER)) &&
             (ulSize <= ( 2 * sizeof(BITMAPV5HEADER))))
    {
        cjRGB    = sizeof(RGBQUAD);
        uiBitCount = pbmi->bmiHeader.biBitCount;
        uiPalUsed = pbmi->bmiHeader.biClrUsed;
        uiCompression = (UINT) pbmi->bmiHeader.biCompression;
    }
    else
    {
        WARNING("ConvertInfo failed - invalid header size\n");
        return(0);
    }

    //
    // figure out the size of the color table
    //

    bStatus = cCalculateColorTableSize(
                    uiBitCount,
                    uiPalUsed,
                    uiCompression,
                    ulSize,
                    &iUsage,
                    &cColors
                    );
    if (!bStatus)
    {
        return(NULL);
    }

    if (iUsage == DIB_PAL_COLORS)
    {
        cjRGB = sizeof(USHORT);
    }
    else if (iUsage == DIB_PAL_INDICES)
    {
        cjRGB = 0;
    }

    if (bPackedDIB)
    {
        cjBits = cjBitmapBitsSize(pbmi);
    }

    //
    // if passed COREHEADER then convert to BITMAPINFOHEADER
    //

    if (bCoreHeader)
    {
        RGBTRIPLE *pTri;
        RGBQUAD *pQuad;

        //
        // allocate new header to hold the info
        //

        ulSize = sizeof(BITMAPINFOHEADER);

        pbmiNew = (PBITMAPINFO)LOCALALLOC(ulSize +
                             cjRGB * cColors+cjBits);

        if (pbmiNew == NULL)
            return (0);

        //
        // copy COREHEADER info over
        //

        CopyCoreToInfoHeader(&pbmiNew->bmiHeader, (BITMAPCOREHEADER *)pbmi);

        //
        // copy the color table
        //

        pTri = (RGBTRIPLE *)((LPBYTE)pbmi + sizeof(BITMAPCOREHEADER));
        pQuad = (RGBQUAD *)((LPBYTE)pbmiNew + sizeof(BITMAPINFOHEADER));

        //
        // copy RGBTRIPLE to RGBQUAD
        //

        if (iUsage != DIB_PAL_COLORS)
        {
            INT cj = cColors;

            while (cj--)
            {
                pQuad->rgbRed = pTri->rgbtRed;
                pQuad->rgbGreen = pTri->rgbtGreen;
                pQuad->rgbBlue = pTri->rgbtBlue;
                pQuad->rgbReserved = 0;

                pQuad++;
                pTri++;
            }

            if (bPackedDIB)
                pjBits = (LPBYTE)pbmi + sizeof(BITMAPCOREHEADER) + cColors*sizeof(RGBTRIPLE);
        }
        else
        {
            //
            // DIB_PAL_COLORS
            //

            RtlCopyMemory((LPBYTE)pQuad,(LPBYTE)pTri,cColors * cjRGB);

            if (bPackedDIB)
                pjBits = (LPBYTE)pbmi + sizeof(BITMAPCOREHEADER) + cColors * cjRGB;
        }

        //
        // copy the packed bits
        //

        if (bPackedDIB)
        {
            pjBitsNew = (LPBYTE)pbmiNew + ulSize + cColors*cjRGB;

            RtlCopyMemory((LPBYTE)pjBitsNew,
                          (LPBYTE)pjBits,
                          cjBits);
        }
    }
    else
    {
        pbmiNew = (LPBITMAPINFO)pbmi;
    }

    *count = ((ulSize + (cjRGB * cColors) + cjBits) + 3) & ~3;

    return((LPBITMAPINFO) pbmiNew);
}


/******************************Public*Routine******************************\
* cjBitmapScanSize
*
* Arguments:
*
*   pbmi
*   nScans
*
* Return Value:
*
*   Image size based on number of scans
*
* History:
*
*    11-Jul-1996 -by- Mark Enstrom [marke]
*
\**************************************************************************/


ULONG cjBitmapScanSize(
    CONST BITMAPINFO *pbmi,
    int nScans
    )
{
    // Check for PM-style DIB

    if (pbmi->bmiHeader.biSize == sizeof(BITMAPCOREHEADER))
    {
        LPBITMAPCOREINFO pbmci;
        pbmci = (LPBITMAPCOREINFO)pbmi;

        return(CJSCAN(pbmci->bmciHeader.bcWidth,pbmci->bmciHeader.bcPlanes,
                      pbmci->bmciHeader.bcBitCount) * nScans);
    }

    // not a core header

    if ((pbmi->bmiHeader.biCompression == BI_RGB) ||
        (pbmi->bmiHeader.biCompression == BI_BITFIELDS) ||
        (pbmi->bmiHeader.biCompression == BI_CMYK))
    {
        return(CJSCAN(pbmi->bmiHeader.biWidth,pbmi->bmiHeader.biPlanes,
                      pbmi->bmiHeader.biBitCount) * nScans);
    }
    else
    {
        return(pbmi->bmiHeader.biSizeImage);
    }
}

/******************************Public*Routine******************************\
* CopyCoreToInfoHeader
*
\**************************************************************************/

VOID CopyCoreToInfoHeader(LPBITMAPINFOHEADER pbmih, LPBITMAPCOREHEADER pbmch)
{
    pbmih->biSize = sizeof(BITMAPINFOHEADER);
    pbmih->biWidth = pbmch->bcWidth;
    pbmih->biHeight = pbmch->bcHeight;
    pbmih->biPlanes = pbmch->bcPlanes;
    pbmih->biBitCount = pbmch->bcBitCount;
    pbmih->biCompression = BI_RGB;
    pbmih->biSizeImage = 0;
    pbmih->biXPelsPerMeter = 0;
    pbmih->biYPelsPerMeter = 0;
    pbmih->biClrUsed = 0;
    pbmih->biClrImportant = 0;
}




/******************************Public*Routine******************************\
* DWORD SetDIBitsToDevice                                                  *
*                                                                          *
*   Can reduce it to 1 scan at a time.  If compressed mode, this could     *
*   gete very difficult.  There must be enough space for the header and    *
*   color table.  This will be needed for every batch.                     *
*                                                                          *
*   BITMAPINFO                                                             *
*       BITMAPINFOHEADER                                                   *
*       RGBQUAD[cEntries] | RGBTRIPLE[cEntries]                            *
*                                                                          *
*                                                                          *
*    1. compute header size (including color table)                        *
*    2. compute size of required bits                                      *
*    3. compute total size (header + bits + args)                          *
*    4. if (memory window is large enough for header + at least 1 scan     *
*                                                                          *
* History:                                                                 *
*  Tue 29-Oct-1991 -by- Patrick Haluptzok [patrickh]                       *
* Add shared memory action for large RLE's.                                *
*                                                                          *
*  Tue 19-Oct-1991 -by- Patrick Haluptzok [patrickh]                       *
* Add support for RLE's                                                    *
*                                                                          *
*  Thu 20-Jun-1991 01:41:45 -by- Charles Whitmer [chuckwh]                 *
* Added handle translation and metafiling.                                 *
*                                                                          *
*  14-May-1991 -by- Eric Kutter [erick]                                    *
* Wrote it.                                                                *
\**************************************************************************/

int SetDIBitsToDevice(
HDC          hdc,
int          xDest,
int          yDest,
DWORD        nWidth,
DWORD        nHeight,
int          xSrc,
int          ySrc,
UINT         nStartScan,
UINT         nNumScans,
CONST VOID * pBits,
CONST BITMAPINFO *pbmi,
UINT         iUsage)            // DIB_PAL_COLORS || DIB_RGB_COLORS
{
    LONG cScansCopied = 0;  // total # of scans copied
    LONG ySrcMax;           // maximum ySrc possible

    // hold info about the header

    UINT uiWidth;
    UINT uiHeight;
    PULONG pulBits = NULL;
    INT cjHeader = 0;
    LPBITMAPINFO pbmiNew = NULL;
    ULONG cjBits;

    // ICM related variables

    PCACHED_COLORSPACE pBitmapColorSpace = NULL;
    PCACHED_COLORTRANSFORM pCXform = NULL;
    HANDLE                 hcmTempXform = NULL;

    FIXUP_HANDLE(hdc);

    // Let's validate the parameters so we don't gp-fault ourselves and
    // to save checks later on.

    if ((nNumScans == 0)                   ||
        (pbmi      == (LPBITMAPINFO) NULL) ||
        (pBits     == (LPVOID) NULL)       ||
        ((iUsage   != DIB_RGB_COLORS) &&
         (iUsage   != DIB_PAL_COLORS) &&
         (iUsage   != DIB_PAL_INDICES)))
    {
        WARNING("You failed a param validation in SetDIBitsToDevice\n");
        return(0);
    }

    pbmiNew = pbmiConvertInfo(pbmi,iUsage,&cjHeader,FALSE);

    if (pbmiNew == NULL)
        return (0);

    uiWidth       = (UINT) pbmiNew->bmiHeader.biWidth;
    uiHeight      = (UINT) pbmiNew->bmiHeader.biHeight;

    // Compute the minimum nNumScans to send across csr interface.
    // It will also prevent faults as a result of overreading the source.

    ySrcMax = max(ySrc, ySrc + (int) nHeight);
    if (ySrcMax <= 0)
        return(0);
    ySrcMax = min(ySrcMax, (int) uiHeight);
    nNumScans = min(nNumScans, (UINT) ySrcMax - nStartScan);

    // NEWFRAME support for backward compatibility.
    // Ship the transform to the server side if needed.

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
        {
            cScansCopied = MF_AnyDIBits(
                   hdc,
                   xDest,yDest,0,0,
                   xSrc,ySrc,(int) nWidth,(int) nHeight,
                   nStartScan,nNumScans,
                   pBits,pbmi,
                   iUsage,
                   SRCCOPY,
                   META_SETDIBTODEV
                   );

            goto Exit;

        }

        DC_PLDC(hdc,pldc,0);

        if (pldc->iType == LO_METADC)
        {
            if (!MF_AnyDIBits(
                    hdc,
                    xDest,yDest,0,0,
                    xSrc,ySrc,(int) nWidth,(int) nHeight,
                    nStartScan,nNumScans,
                    pBits,pbmi,
                    iUsage,
                    SRCCOPY,
                    EMR_SETDIBITSTODEVICE
                    ))
            {
                cScansCopied = 0;
                goto Exit;
            }
        }

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
        {
            cScansCopied = 0;
            goto Exit;
        }
    }

    // reset user's poll count so it counts this as output
    // put it right next to BEGINMSG so that NtCurrentTeb() is optimized

    RESETUSERPOLLCOUNT();

    //
    // Calculate bitmap bits size based on BITMAPINFO and nNumScans
    //

    cjBits = cjBitmapScanSize(pbmi,nNumScans);


    //
    // If the pBits are not dword aligned we need to allocate a buffer and
    // copy them (that's because we always guarantee display and printer
    // drivers that bitmaps are dword aligned):
    //

    cScansCopied = 1;

    if ((ULONG_PTR)pBits & (sizeof(DWORD) - 1))
    {
        pulBits = LOCALALLOC(cjBits);
        if (pulBits)
        {
            //
            // We used to simply access violate here if we had been given
            // a corrupt DIB bitmap.  This was bad because WinLogon is
            // responsible for showing the original background bitmap, and
            // if that bitmap is corrupt, and we access violate, we'll
            // cause the system to blue-screen:
            //

            try
            {
                RtlCopyMemory(pulBits,pBits,cjBits);
                pBits = pulBits;
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                WARNING("SetDIBitsToDevice: Corrupt bitmap\n");
                cScansCopied = 0;
            }
        }
    }

    if (cScansCopied)
    {
        PDC_ATTR pdcattr;

        PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

        if (pdcattr)
        {
            //
            // ICM translation of BITMAP bits or color table
            //
            // At this moment, ensured that pBits and pbmiNew is not NULL.
            // (see above parameter validate check and NULL check !)
            //

            if (
               IS_ICM_INSIDEDC(pdcattr->lIcmMode) &&
               (iUsage != DIB_PAL_COLORS) &&
               !IS_BMI_PASSTHROUGH_IMAGE(pbmiNew))
            {
                LPBITMAPINFO pbmiIcm = NULL;
                PVOID        pvBitsIcm = NULL;
                ULONG        cjHeaderNew = 0;
                BOOL         bIcmStatus;
                VOID *pBitsBand = (VOID *)pBits;
                ULONG CurrentBandSize;
                ULONG SizeOfOneScanline;
                ULONG nBands;
                ULONG nScansInBand;
                ULONG nScansInCurrentBand;
                ULONG nScansInRemainderBand;
                ULONG CumulativeScans=0;
                ULONG i;
                LONG PositiveBandDelta=0;
                LONG NegativeBandDelta=0;
                LONG TotalBandDelta=0;
                LONG IcmSizeOfOneScanline;
                INT iRet;
                LONG HeaderHeightHack;

                SizeOfOneScanline = cjBitmapScanSize(pbmi, 1);

                //
                //pbmiNew must be initialized before getting to this point.
                //

                ASSERTGDI(pbmiNew!=NULL, "SetDIBitsToDevice cannot proceed with pbmiNew==NULL\n");                        

                nScansInBand = BAND_SIZE/SizeOfOneScanline;

                //
                // Set the number of bands provided there are enough scanlines
                // and the hdc is a printer dc.
                //
                // Else set the nubmer of bands to 1 and the scanlines in the 
                // remainder band to all of them, so the entire bitmap is printed
                // in one band (All the code below reduces to doing a single piece)
                //
                // If the bitmap is RLE compressed, we set it up to do one band
                // only. When this is the case, Start and NegativeBandDelta will be
                // computed as 0 and the SizeOfOneScanline parameter will be 
                // multiplied away to zero.
                //




                if ((nScansInBand>0)&&
                    (GetDeviceCaps(hdc, TECHNOLOGY)==DT_RASPRINTER)&&
                    (!IS_BMI_RLE(pbmiNew)))
                {
                    //
                    // Compressed images cannot be converted in this way.
                    // This should never be hit and is included as a guard against
                    // someone inventing a new compression mode and not updating 
                    // this conditional.
                    //

                    ASSERTGDI(SizeOfOneScanline*nNumScans==cjBits, "SetDIBitsToDevice, cannot band compressed image");

                    nBands = (nNumScans)/nScansInBand;
                    nScansInRemainderBand = nNumScans % nScansInBand;
                }
                else
                {
                    nBands = 0;
                    nScansInRemainderBand = (nNumScans);
                }

                if (nScansInRemainderBand>0)
                {
                    nBands++;
                    nScansInCurrentBand = nScansInRemainderBand;
                }
                else
                {
                    nScansInCurrentBand = nScansInBand;
                }


                cScansCopied = 0;

                HeaderHeightHack = pbmiNew->bmiHeader.biHeight;  
                
                for (i=0; i<nBands; i++)
                {

                    CurrentBandSize = nScansInCurrentBand*SizeOfOneScanline;
                    IcmSizeOfOneScanline = SizeOfOneScanline;

                    //
                    // The Delta refers to the number of extra scanlines to pass
                    // to the internal blting routines in order to avoid halftone
                    // seams.
                    //
                    // PositiveBandDelta is the number of scanlines to 
                    // add on to the end of the band. (relative to the start in 
                    // memory)
                    //
                    // NegativeBandDelta is the number of scanlines to 
                    // subtract from the begining of the band (ie move the start
                    // pointer back this many scanlines).
                    //
                    // Total BandDelta is simply the total number of extra scans
                    // added for this band (both at the start and end).
                    //
                    
                    PositiveBandDelta = MIN(EXTRAPIXEL, CumulativeScans);
                    NegativeBandDelta = MIN(EXTRAPIXEL, nNumScans-(CumulativeScans+nScansInCurrentBand));
                    TotalBandDelta = NegativeBandDelta+PositiveBandDelta;


                    if (nBands!=1)
                    {
                        SaveDC(hdc);


                        //
                        // Intersect the clip rectangles.
                        // This clip rectangle is designed to restrict the output to 
                        // just the displayed portion of the band.
                        // We may pass more scanlines on the top and bottom of the band 
                        // to get halftoning to merge seamlessly.
                        //

                        iRet = IntersectClipRect(
                                   hdc,
                                   xDest,
                                   nNumScans - (nStartScan+CumulativeScans+nScansInCurrentBand),
                                   xDest+nWidth,
                                   nNumScans - (nStartScan+CumulativeScans));

                        if (iRet==ERROR)
                        {
                            WARNING("SetDIBitsToDevice: error intersecting clip rect\n");
                            RestoreDC(hdc, -1);
                            goto Exit;
                        }
                        
                        //                        
                        // Empty clip rectangle 
                        // If the clip regions don't intersect, we can quit without
                        // doing anything.
                        //

                        if (iRet==NULLREGION)
                        {
                            RestoreDC(hdc, -1);
                            
                            //
                            // Nothing to do - fall through and do 
                            // initialization for next iteration.
                            //

                            goto Continue_With_Init;
                        }
                    }


                    if (HeaderHeightHack >= 0)
                    {
                        //
                        //Bottom Up
                        //

                        pBitsBand = (char *)pBits + (CumulativeScans-PositiveBandDelta)*SizeOfOneScanline;
                    }
                    else
                    {
                        //
                        //TopDown
                        //
                        
                        pBitsBand = (char *)pBits + (nNumScans-nScansInCurrentBand-CumulativeScans-NegativeBandDelta)*SizeOfOneScanline;
                    }

                    cjHeaderNew=0;
                    pbmiIcm=NULL;
                    pvBitsIcm = NULL;

                    //
                    // Call ICM with an oversized band for later halftoning by 
                    // NtGdiSetDIBitsInternal
                    //

                    bIcmStatus = IcmTranslateDIB(
                                     hdc,
                                     pdcattr,
                                     CurrentBandSize+TotalBandDelta*SizeOfOneScanline,
                                     (PVOID)pBitsBand,
                                     &pvBitsIcm,
                                     pbmiNew,
                                     &pbmiIcm,
                                     &cjHeaderNew,
                                     nScansInCurrentBand+TotalBandDelta,
                                     iUsage,
                                     ICM_FORWARD,
                                     &pBitmapColorSpace,
                                     &pCXform);

                    if (bIcmStatus)
                    {
                        if (pvBitsIcm == NULL)
                        {
                            pvBitsIcm = pBitsBand;
                        }
                        if (pbmiIcm == NULL)
                        {
                            pbmiIcm = pbmiNew;
                            cjHeaderNew = cjHeader;
                        }
                        else
                        {
                            CurrentBandSize = cjBitmapScanSize(pbmiIcm, nScansInCurrentBand);
                            IcmSizeOfOneScanline = cjBitmapScanSize(pbmiIcm, 1);
                            if (!cjHeaderNew)
                            {
                                cjHeaderNew = cjHeader;
                            }
                        }
                        if (pCXform)
                        {
                            hcmTempXform = pCXform->ColorTransform;
                        }
                    }
                    else
                    {
                        pvBitsIcm = pBitsBand;
                        pbmiIcm = pbmiNew;
                        cjHeaderNew = cjHeader;
                    }

                    cScansCopied += NtGdiSetDIBitsToDeviceInternal(
                                        hdc,
                                        xDest,
                                        yDest,
                                        nWidth,
                                        nHeight,
                                        xSrc,
                                        ySrc, 
                                        nStartScan+CumulativeScans-PositiveBandDelta,
                                        nScansInCurrentBand+TotalBandDelta,
                                        (LPBYTE)pvBitsIcm,
                                        pbmiIcm,
                                        iUsage,
                                        (UINT)CurrentBandSize+TotalBandDelta*IcmSizeOfOneScanline,
                                        (UINT)cjHeaderNew,
                                        TRUE,
                                        hcmTempXform);

                    cScansCopied -= TotalBandDelta;

                    if (pBitmapColorSpace)
                    {
                        if (pCXform)
                        {
                            IcmDeleteColorTransform(pCXform,FALSE);
                        }
                        IcmReleaseColorSpace(NULL,pBitmapColorSpace,FALSE);
                    }


                    if ((pvBitsIcm!=NULL)&&(pvBitsIcm!=pBitsBand))
                    {
                        LOCALFREE(pvBitsIcm);
                        pvBitsIcm = NULL;
                    }
                    if ((pbmiIcm!=NULL)&&(pbmiIcm!=pbmiNew))
                    {
                        LOCALFREE(pbmiIcm);
                        pbmiIcm = NULL;
                    }

                    hcmTempXform = NULL;

                    Continue_With_Init:
                    CumulativeScans += nScansInCurrentBand;
                    nScansInCurrentBand = nScansInBand;
                    if (nBands != 1)
                    {
                        RestoreDC(hdc, -1);    
                    }
                }

                //
                // We do our own NtGdiSetDIBitsToDeviceInternal
                // So we need to fall through to cleanup at this point.
                //

                goto Exit;
            }
        }

        //
        // Do the non-ICM version of the SetDIB
        //
        cScansCopied = NtGdiSetDIBitsToDeviceInternal(
                            hdc,
                            xDest,
                            yDest,
                            nWidth, 
                            nHeight,
                            xSrc,
                            ySrc,
                            nStartScan,
                            nNumScans,
                            (LPBYTE)pBits,
                            pbmiNew,
                            iUsage,
                            (UINT)cjBits,
                            (UINT)cjHeader,
                            TRUE,
                            hcmTempXform);
    }

Exit:

    if (pulBits)
    {
        //
        // Free temporary buffer, this would be the buffer which allocated
        // to align, Or to do ICM.
        //
        LOCALFREE (pulBits);
    }

    if (pbmiNew && (pbmiNew != pbmi))
    {
        LOCALFREE (pbmiNew);
    }

    return (cScansCopied);
}



/******************************Public*Routine******************************\
* DWORD GetDIBits
*
*   Can reduce it to 1 scan at a time.  There must be enough space
*   for the header and color table.  This will be needed for every chunk
*
* History:
*  Wed 04-Dec-1991 -by- Patrick Haluptzok [patrickh]
* bug fix, only check for valid DC if DIB_PAL_COLORS.
*
*  Fri 22-Nov-1991 -by- Patrick Haluptzok [patrickh]
* bug fix, copy the header into memory window for NULL bits.
*
*  Tue 20-Aug-1991 -by- Patrick Haluptzok [patrickh]
* bug fix, make iStart and cNum be in valid range.
*
*  Thu 20-Jun-1991 01:44:41 -by- Charles Whitmer [chuckwh]
* Added handle translation.
*
*  14-May-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int GetDIBits(
HDC          hdc,
HBITMAP      hbm,
UINT         nStartScan,
UINT         nNumScans,
LPVOID       pBits,
LPBITMAPINFO pbmi,
UINT         iUsage)     // DIB_PAL_COLORS || DIB_RGB_COLORS
{
    PULONG   pulBits = pBits;
    ULONG    cjBits;
    int      iRet = 0;
    PDC_ATTR pdcattr;

    FIXUP_HANDLE(hdc);
    FIXUP_HANDLE(hbm);

    PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {
        BOOL bNeedICM = TRUE;

        cjBits  = cjBitmapScanSize(pbmi,nNumScans);

        //
        // If pbmi is a input buffer specifying image format
        // (i.e., pBits != NULL), then fail for passthrough
        // images (BI_JPEG and BI_PNG)
        //
        if (pBits && IS_BMI_PASSTHROUGH_IMAGE(pbmi))
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            return 0;
        }

        if (pbmi->bmiHeader.biBitCount == 0)
        {
            //
            // no color table required.
            //
            bNeedICM = FALSE;
        }

        //
        // if the pBits are not dword aligned, we need to allocate
        // a buffer and copy them
        //
        if ((ULONG_PTR)pBits & (sizeof(DWORD) - 1))
        {
            pulBits = LOCALALLOC(cjBits);

            if (pulBits == NULL)
                return(0);
        }

        iRet = NtGdiGetDIBitsInternal(
                hdc,
                hbm,
                nStartScan,
                nNumScans,
                (LPVOID)pulBits,
                pbmi,
                iUsage,
                cjBits,
                0);

        //
        // translate DIB if needed
        //
        if (bNeedICM &&
            (IS_ICM_HOST(pdcattr->lIcmMode)) && (iUsage != DIB_PAL_COLORS))
        {
            //
            // UNDER_CONSTRUCTION: Failed on GetDIBits() from CMYK surface.
            //
            if (IS_CMYK_COLOR(pdcattr->lIcmMode))
            {
                WARNING("GetDIBits(): was called on CMYK bitmap\n");
                iRet = 0;
            }
            else
            {
                //
                // Do backward transform.
                //
                if (!IcmTranslateDIB(hdc,
                                     pdcattr,
                                     cjBits,
                                     pulBits,
                                     NULL,     // Indicates overwrite original...
                                     pbmi,
                                     NULL,     // Indicates overwrite original...
                                     NULL,
                                     nNumScans,
                                     iUsage,
                                     ICM_BACKWARD,
                                     NULL,NULL))
                {
                    //
                    // ICM translation failed.
                    //
                    iRet = 0;
                }
            }
        }

        if (pulBits != pBits)
        {
            if (iRet)
            {
                RtlCopyMemory(pBits,pulBits,cjBits);
            }

            LOCALFREE(pulBits);
        }
    }
    else
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
    }

    return(iRet);
}

/******************************Public*Routine******************************\
* CreateDIBitmap
*
* History:
*  Mon 25-Jan-1993 -by- Patrick Haluptzok [patrickh]
* Add CBM_CREATEDIB support.
*
*  Thu 20-Jun-1991 02:14:59 -by- Charles Whitmer [chuckwh]
* Added local handle support.
*
*  23-May-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HBITMAP
CreateDIBitmap(
    HDC                hdc,
    CONST BITMAPINFOHEADER *pbmih,
    DWORD              flInit,
    CONST VOID        *pjBits,
    CONST BITMAPINFO  *pbmi,
    UINT               iUsage)
{
    LONG  cjBMI = 0;
    LONG  cjBits = 0;
    INT   cx = 0;
    INT   cy = 0;
    PULONG pulBits = NULL;
    HBITMAP hRet = (HBITMAP)-1;
    LPBITMAPINFO pbmiNew = NULL;
    PDC_ATTR pdcattr;

    // ICM related variables.

    PCACHED_COLORSPACE pBitmapColorSpace = NULL;
    PCACHED_COLORTRANSFORM pCXform = NULL;
    HANDLE hcmTempXform = NULL;

    FIXUP_HANDLEZ(hdc);

    PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

    pbmiNew = pbmiConvertInfo(pbmi,iUsage,&cjBMI,FALSE);

    if (flInit & CBM_CREATEDIB)
    {
        // With CBM_CREATEDIB we ignore pbmih

        pbmih = (LPBITMAPINFOHEADER) pbmi;

        if (cjBMI == 0)
        {
            hRet = 0;
        }
        else if (flInit & CBM_INIT)
        {
            if (pjBits == NULL)
            {
                // doesn't make sence if they asked to initialize it but
                // didn't pass the bits.

                hRet = 0;
            }
            else
            {
                cjBits = cjBitmapBitsSize(pbmiNew);
            }
        }
        else
        {
            pjBits = NULL;
        }
    }
    else
    {
        // compute the size of the optional init bits and BITMAPINFO

        if (flInit & CBM_INIT)
        {
            if (pjBits == NULL)
            {
                // doesn't make sence if they asked to initialize it but
                // didn't pass the bits.

                flInit &= ~CBM_INIT;
            }
            else
            {
                if (cjBMI == 0)
                {
                    hRet = 0;
                }
                else
                {
                    // compute the size of the bits

                    cjBits = cjBitmapBitsSize(pbmiNew);
                }
            }
        }
        else
        {
            pjBits = NULL;
        }
    }

    //  CreateDIBitmap cannot handle passthrough image (BI_JPEG or BI_PNG)
    //  init data

    if (IS_BMI_PASSTHROUGH_IMAGE(pbmiNew))
    {
        hRet = 0;
    }

    //  if they passed us a zero height  or  zero  width
    //  bitmap then return a pointer to the stock bitmap

    if (pbmih)
    {
        if (pbmih->biSize >= sizeof(BITMAPINFOHEADER))
        {
            cx = pbmih->biWidth;
            cy = pbmih->biHeight;
        }
        else
        {
            cx = ((LPBITMAPCOREHEADER) pbmih)->bcWidth;
            cy = ((LPBITMAPCOREHEADER) pbmih)->bcHeight;
        }

        if ((cx == 0) || (cy == 0))
        {
            hRet = GetStockObject(PRIV_STOCK_BITMAP);
        }
    }

    // if hRet is still -1, then all is OK and we need to try to the bitmap

    if (hRet == (HBITMAP)-1)
    {
        BOOL bStatus = TRUE;

        // if the pJBits are not dword aligned we need to allocate a buffer and copy them

        if ((ULONG_PTR)pjBits & (sizeof(DWORD) - 1))
        {
            pulBits = LOCALALLOC(cjBits);
            if (pulBits)
            {
                RtlCopyMemory(pulBits,pjBits,cjBits);
                pjBits = pulBits;
            }
        }

        // ICM conversion
        //
        // Convert bitmap data only when ...
        //
        //  - HDC is not NULL.
        //  - ICM is enanled.
        //  - ICM is not lazy mode.
        //  - Initialize data is not Palette Index.
        //  - Initialize data is provided.

        if (pdcattr &&
            IS_ICM_INSIDEDC(pdcattr->lIcmMode) &&
            (IS_ICM_LAZY_CORRECTION(pdcattr->lIcmMode) == FALSE) &&
            (iUsage != DIB_PAL_COLORS) &&
            pjBits && pbmiNew)
        {
            PVOID       pvBitsIcm = NULL;
            PBITMAPINFO pbmiIcm = NULL;
            ULONG       cjBMINew = 0;
            BOOL        bIcmStatus;

            bIcmStatus = IcmTranslateDIB(hdc,
                                         pdcattr,
                                         cjBits,
                                         (PVOID)pjBits,
                                         &pvBitsIcm,
                                         pbmiNew,
                                         &pbmiIcm,
                                         &cjBMINew,
                                         (DWORD)-1,
                                         iUsage,
                                         ICM_FORWARD,
                                         &pBitmapColorSpace,
                                         &pCXform);

            //
            // IcmTranslateDIB will create a duplicate dib
            // pointed to by pulBits if needed.
            //

            if (bIcmStatus)
            {
                if (pvBitsIcm != NULL)
                {
                    ICMMSG(("CreateDIBitmap(): Temp bits are allocated\n"));

                    if (pulBits)
                    {
                        LOCALFREE(pulBits);
                    }

                    pjBits = (PVOID)pulBits = pvBitsIcm;
                }

                if (pbmiIcm != NULL)
                {
                    ICMMSG(("CreateDIBitmap(): Temp bmi are allocated\n"));

                    if (pbmiNew && (pbmiNew != pbmi))
                    {
                        LOCALFREE(pbmiNew);
                    }

                    pbmiNew = pbmiIcm;

                    //
                    // Calculate bitmap bits size based on BITMAPINFO and nNumScans
                    //
                    cjBits = cjBitmapBitsSize(pbmiNew);

                    //
                    // Update sizeof bitmap info (including color table)
                    //
                    if (cjBMINew)
                    {
                        cjBMI = cjBMINew;
                    }
                }

                //
                // Get color transform handle need to pass kernel
                //
                if (pCXform)
                {
                    hcmTempXform = pCXform->ColorTransform;
                }
            }
        }

        if (bStatus)
        {
            hRet = NtGdiCreateDIBitmapInternal(hdc,
                                               cx,
                                               cy,
                                               flInit,
                                               (LPBYTE) pjBits,
                                               (LPBITMAPINFO) pbmiNew,
                                               iUsage,
                                               cjBMI,
                                               cjBits,
                                               0,
                                               hcmTempXform);

#if TRACE_SURFACE_ALLOCS
            {
                PULONGLONG  pUserAlloc;

                PSHARED_GET_VALIDATE(pUserAlloc, hRet, SURF_TYPE);

                if (pUserAlloc != NULL)
                {
                    RtlWalkFrameChain((PVOID *)&pUserAlloc[1], (ULONG)*pUserAlloc, 0);
                }
            }
#endif
        }

        if (pBitmapColorSpace)
        {
            if (pCXform)
            {
                IcmDeleteColorTransform(pCXform,FALSE);
            }

            IcmReleaseColorSpace(NULL,pBitmapColorSpace,FALSE);
        }

        if (pulBits)
        {
            LOCALFREE(pulBits);
        }
    }

    if (pbmiNew && (pbmiNew != pbmi))
    {
        LOCALFREE(pbmiNew);
    }

    return(hRet);
}

/******************************Public*Routine******************************\
* Set/GetBitmapBits                                                        *
*                                                                          *
* History:                                                                 *
*  05-Jun-1991 -by- Eric Kutter [erick]                                    *
* Wrote it.                                                                *
\**************************************************************************/

LONG WINAPI SetBitmapBits(
HBITMAP      hbm,
DWORD        c,
CONST VOID *pv)
{
    LONG   lRet;

    FIXUP_HANDLE(hbm);

    lRet = (LONG)NtGdiSetBitmapBits(hbm,c,(PBYTE)pv);

    return(lRet);
}

LONG WINAPI GetBitmapBits(
HBITMAP hbm,
LONG    c,
LPVOID  pv)
{
    LONG   lRet;

    FIXUP_HANDLE(hbm);

    lRet = (LONG)NtGdiGetBitmapBits(hbm,c,(PBYTE)pv);

    return(lRet);
}

/******************************Public*Routine******************************\
* GdiGetPaletteFromDC
*
* Returns the palette for the DC, 0 for error.
*
* History:
*  04-Oct-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

HANDLE GdiGetPaletteFromDC(HDC h)
{
    return((HANDLE)GetDCObject(h,LO_PALETTE_TYPE));
}

/******************************Public*Routine******************************\
* GdiGetDCforBitmap
*
* Returns the DC a bitmap is selected into, 0 if none or if error occurs.
*
* History:
*  22-Sep-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

HDC GdiGetDCforBitmap(HBITMAP hbm)
{
    FIXUP_HANDLE(hbm);

    return (NtGdiGetDCforBitmap(hbm));
}

/******************************Public*Routine******************************\
* SetDIBits
*
* API to initialize bitmap with DIB
*
* History:
*  Sun 22-Sep-1991 -by- Patrick Haluptzok [patrickh]
* Make it work even if it is selected into a DC, Win3.0 compatibility.
*
*  06-Jun-1991 -by- Patrick Haluptzok patrickh
* Wrote it.
\**************************************************************************/

int WINAPI SetDIBits(
HDC          hdc,
HBITMAP      hbm,
UINT         iStartScans,
UINT         cNumScans,
CONST VOID  *pInitBits,
CONST BITMAPINFO *pInitInfo,
UINT         iUsage)
{
    HDC hdcTemp;
    HBITMAP hbmTemp;
    int iReturn = 0;
    BOOL bMakeDC = FALSE;
    HPALETTE hpalTemp;
    DWORD cWidth;
    DWORD cHeight;

    FIXUP_HANDLE(hdc);
    FIXUP_HANDLE(hbm);

    // if no bits or hbm is not a bitmap, fail

    if ((pInitBits == (PVOID) NULL) ||
        (GRE_TYPE(hbm) != SURF_TYPE))
    {
        return(0);
    }

    // if passthrough image (BI_JPEG or BI_JPEG), fail

    if (IS_BMI_PASSTHROUGH_IMAGE(pInitInfo))
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return(0);
    }

    // First we need a DC to select this bitmap into.  If he is already in a
    // DC we just use that DC temporarily to blt to (we still have to select
    // it in and out because someone might do a SaveDC and select another
    // bitmap in).  If he hasn't been stuck in a DC anywhere we just create
    // one temporarily.

    hdcTemp = GdiGetDCforBitmap(hbm);

    if (hdcTemp == (HDC) 0)
    {
        hdcTemp = CreateCompatibleDC(hdc);
        bMakeDC = TRUE;

        if (hdcTemp == (HDC) NULL)
        {
            WARNING("SetDIBits failed CreateCompatibleDC, is hdc valid?\n");
            return(0);
        }
    }
    else
    {
        if (SaveDC(hdcTemp) == 0)
            return(0);
    }

    hbmTemp = SelectObject(hdcTemp, hbm);

    if (hbmTemp == (HBITMAP) 0)
    {
        //WARNING("ERROR SetDIBits failed to Select, is bitmap valid?\n");
        goto Error_SetDIBits;
    }

    if (hdc != (HDC) 0)
    {
        hpalTemp = SelectPalette(hdcTemp, GdiGetPaletteFromDC(hdc), 0);
    }

    if (pInitInfo->bmiHeader.biSize < sizeof(BITMAPINFOHEADER))
    {
        cWidth  = ((LPBITMAPCOREHEADER)pInitInfo)->bcWidth;
        cHeight = ((LPBITMAPCOREHEADER)pInitInfo)->bcHeight;
    }
    else
    {
        cWidth  = pInitInfo->bmiHeader.biWidth;
        cHeight = ABS(pInitInfo->bmiHeader.biHeight);
    }

    iReturn = SetDIBitsToDevice(hdcTemp,
                                0,
                                0,
                                cWidth,
                                cHeight,
                                0, 0,
                                iStartScans,
                                cNumScans,
                                (VOID *) pInitBits,
                                pInitInfo,
                                iUsage);

    if (hdc != (HDC) 0)
    {
        SelectPalette(hdcTemp, hpalTemp, 0);
    }

    SelectObject(hdcTemp, hbmTemp);

Error_SetDIBits:

    if (bMakeDC)
    {
        DeleteDC(hdcTemp);
    }
    else
    {
        RestoreDC(hdcTemp, -1);
    }

    return(iReturn);
}



/******************************Public*Routine******************************\
* StretchDIBits()
*
*
* Effects:
*
* Warnings:
*
* History:
*  22-Jul-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

int WINAPI StretchDIBits(
                        HDC           hdc,
                        int           xDest,
                        int           yDest,
                        int           nDestWidth,
                        int           nDestHeight,
                        int           xSrc,
                        int           ySrc,
                        int           nSrcWidth,
                        int           nSrcHeight,
                        CONST VOID   *pj,
                        CONST BITMAPINFO  *pbmi,
                        UINT          iUsage,
                        DWORD         lRop)
{


    LONG cPoints = 0;
    LONG cjHeader;
    LONG cjBits;
    ULONG ulResult = 0;
    PULONG pulBits = NULL;
    int   iRet = 0;
    BITMAPINFO * pbmiNew = NULL;
    PDC_ATTR pdcattr;

    BOOL bStatus = TRUE;

    // ICM related variables.

    PCACHED_COLORSPACE pBitmapColorSpace = NULL;
    PCACHED_COLORTRANSFORM pCXform = NULL;
    HANDLE hcmTempXform = NULL;

    FIXUP_HANDLE(hdc);

    // NEWFRAME support for backward compatibility.
    // Ship the transform to the server side if needed.

    if (IS_ALTDC_TYPE(hdc))
    {
        PLDC pldc;

        if (IS_METADC16_TYPE(hdc))
        {

            return (MF_AnyDIBits(
                                hdc,
                                xDest,
                                yDest,
                                nDestWidth,
                                nDestHeight,
                                xSrc,
                                ySrc,
                                nSrcWidth,
                                nSrcHeight,
                                0,
                                0,
                                (BYTE *) pj,
                                pbmi,
                                iUsage,
                                lRop,
                                META_STRETCHDIB
                                ));
        }

        DC_PLDC(hdc,pldc,ulResult);

        if (pldc->iType == LO_METADC)
        {
            //
            // speeds up cases when partial sources bits are sent
            //

            int iStart = 0;
            int iEnd = 0;
            int cScans = 0;

            if (pbmi && (pbmi->bmiHeader.biWidth == nSrcWidth) && (pbmi->bmiHeader.biHeight > nSrcHeight) &&
                (pbmi->bmiHeader.biHeight > 0) &&
                !(IS_BMI_RLE(pbmi) || IS_BMI_PASSTHROUGH_IMAGE(pbmi)))
            {
                iStart = ((ySrc - EXTRAPIXEL) > 0) ? (ySrc - EXTRAPIXEL) : 0;

                iEnd = ((ySrc+nSrcHeight + EXTRAPIXEL) > pbmi->bmiHeader.biHeight)?
                       pbmi->bmiHeader.biHeight : (ySrc+nSrcHeight + EXTRAPIXEL);

                cScans = iEnd - iStart;

            }

            if (!MF_AnyDIBits(hdc,
                              xDest,
                              yDest,
                              nDestWidth,
                              nDestHeight,
                              xSrc,
                              ySrc,
                              nSrcWidth,
                              nSrcHeight,
                              iStart,
                              cScans,
                              (BYTE *) pj,
                              pbmi,
                              iUsage,
                              lRop,
                              EMR_STRETCHDIBITS
                             ))
            {
                return (0);
            }
        }

        if (pldc->fl & LDC_SAP_CALLBACK)
            vSAPCallback(pldc);

        if (pldc->fl & LDC_DOC_CANCELLED)
            return (0);

        if (pldc->fl & LDC_CALL_STARTPAGE)
            StartPage(hdc);
    }

    if (pbmi != NULL)
    {
        pbmiNew = pbmiConvertInfo (pbmi, iUsage, &cjHeader,FALSE);

        if (pbmiNew == NULL)
            return (0);

        cjBits  = cjBitmapBitsSize(pbmiNew);
    }
    else
    {
        cjHeader = 0;
        cjBits   = 0;
    }

    // reset user's poll count so it counts this as output
    // put it right next to BEGINMSG so that NtCurrentTeb() is optimized

    RESETUSERPOLLCOUNT();

    // if the pj are not dword aligned we need to allocate
    // a buffer and copy them

    if ((ULONG_PTR)pj & (sizeof(DWORD) - 1))
    {
        pulBits = LOCALALLOC(cjBits);
        if (pulBits)
        {
            RtlCopyMemory(pulBits,pj,cjBits);
            pj = pulBits;
        }
    }

    PSHARED_GET_VALIDATE(pdcattr,hdc,DC_TYPE);

    if (pdcattr)
    {
        // icm tranlation
        //
        // Convert bitmap data only when ...
        //
        //  - ICM is enabled.
        //  - Bitmap is not Palette Index.
        //  - Bitmap header & data is provided.
        //  - Bitmap is not passthrough image (BI_JPEG or BI_PNG).

        if (IS_ICM_INSIDEDC(pdcattr->lIcmMode) &&
            (iUsage != DIB_PAL_COLORS) &&
            pbmiNew && pj &&
            !IS_BMI_PASSTHROUGH_IMAGE(pbmiNew))
        {

            LPBITMAPINFO pbmiIcm = NULL;
            LPBITMAPINFO pbmiSave = NULL;
            PVOID        pvBitsIcm = NULL;
            ULONG        cjHeaderNew = 0;
            ULONG        cjBitsIcm;
            BOOL         bIcmStatus;
            VOID *pBitsBand = (VOID *)pj;
            LONG CurrentBandSize;
            LONG SizeOfOneScanline;
            LONG IcmSizeOfOneScanline;
            LONG nBands;
            LONG nScansInBand;
            LONG nScansInCurrentBand;
            LONG nScansInRemainderBand;
            LONG CumulativeScans=0;
            LONG i;
            LONG PositiveBandDelta=0;
            LONG NegativeBandDelta=0;
            LONG TotalBandDelta=0;
            HRGN hrgnBandClip = NULL;
            RECT rectCurrentClip;
            LONG HeaderHeightHack;
            INT cScanCount=0;
            float lMulDivStoreY1;
            float lMulDivStoreY2;


            SizeOfOneScanline = cjBitmapScanSize(pbmiNew, 1);

            //
            //pbmiNew must be initialized before getting to this point.
            //

            ASSERTGDI(pbmiNew!=NULL, "StretchDIBits cannot proceed with pbmiNew==NULL\n");                        

            nScansInBand = BAND_SIZE/SizeOfOneScanline;

            //
            // Set the number of bands provided there are enough scanlines
            // and the hdc is a printer dc.
            //
            // Else set the nubmer of bands to 1 and the scanlines in the 
            // remainder band to all of them, so the entire bitmap is printed
            // in one band (All the code below reduces to doing a single piece)
            //
            // If the bitmap is RLE compressed, we set it up to do one band
            // only. When this is the case, Start and NegativeBandDelta will be
            // computed as 0 and the SizeOfOneScanline parameter will be 
            // multiplied away to zero.
            //

            if ((nScansInBand>0)&&
                (GetDeviceCaps(hdc, TECHNOLOGY)==DT_RASPRINTER)&&
                (!IS_BMI_RLE(pbmiNew)))
            {
                //
                // Compressed images cannot be converted in this way.
                // This should never be hit and is included as a guard against
                // someone inventing a new compression mode and not updating 
                // this conditional.
                //

                //This assert needs a rethink - cjBits refers to the whole image
                //which could be larger than the nSrcHeight portion.
                //ASSERTGDI(SizeOfOneScanline*nSrcHeight==cjBits, "StretchDIBits, cannot band compressed image");

                nBands = (nSrcHeight)/nScansInBand;
                nScansInRemainderBand = nSrcHeight % nScansInBand;
            }
            else
            {
                nBands = 0;
                nScansInRemainderBand = (nSrcHeight);
            }

            if (nScansInRemainderBand>0)
            {
                nBands++;
                nScansInCurrentBand = nScansInRemainderBand;
            }
            else
            {
                nScansInCurrentBand = nScansInBand;
            }

            if (nBands != 1)
            {
                //
                // We're going to have to modify the bmi for this image to 
                // coerce NtGdiStretchDIBitsInternal to do the banding.
                // There is a codepath that gets to this point with pbmiNew
                // set to pbmi (pointer copy) rather than local allocated space.
                // if the memory passed in the pointer to pbmi is read only, 
                // we won't be able to hack the header, so we make a local copy
                // for banding.
                //

                pbmiSave = pbmiNew;  //store the old value
                pbmiNew = (LPBITMAPINFO)LOCALALLOC(cjHeader);
                if (pbmiNew)
                {

                    RtlCopyMemory((LPBYTE)pbmiNew, 
                                  (LPBYTE)pbmiSave, 
                                  cjHeader);

                    HeaderHeightHack = pbmiNew->bmiHeader.biHeight;  
                }
                else
                {
                    //
                    // we need to bail out here. Goto the cleanup code.
                    //

                    WARNING("StretchDIBits: couldn't allocate memory for temporary BITMAPINFO\n");

                    pbmiNew = pbmiSave;
                    iRet = 0;
                    goto Exit;
                }
            }

            for (i=0; i<nBands; i++)
            {
                //
                // Initialize band specific size counters.
                //

                CurrentBandSize = nScansInCurrentBand*SizeOfOneScanline;
                IcmSizeOfOneScanline = SizeOfOneScanline;
                cjBitsIcm = cjBits;

                //
                // The Delta refers to the number of extra scanlines to pass
                // to the internal blting routines in order to avoid halftone
                // seams.
                //
                // PositiveBandDelta is usually the number of scanlines to 
                // add on to the end of the band. (relative to the start in 
                // memory)
                //
                // NegativeBandDelta is usually the number of scanlines to 
                // subtract from the begining of the band (ie move the start
                // pointer back this many scanlines).
                //
                // Total BandDelta is simply the total number of extra scans
                // added for this band (both at the start and end).
                //
                // We reverse the sense of positive and negative when rendering
                // bottom up DIBs
                //

                NegativeBandDelta = MIN(EXTRAPIXEL, CumulativeScans);
                PositiveBandDelta = MIN(EXTRAPIXEL, MAX(0, nSrcHeight-(CumulativeScans+nScansInCurrentBand)));
                TotalBandDelta = NegativeBandDelta+PositiveBandDelta;

                if (nBands != 1)
                {
                    //
                    // We're going to be doing fancy banding stuff with the clip
                    // region so we'll want to restore it after the band is done.
                    //

                    SaveDC(hdc);

                    //
                    // Intersect the clip rectangles.
                    // This clip rectangle is designed to restrict the output to 
                    // just the displayed portion of the band.
                    // We may pass more scanlines on the top and bottom of the band 
                    // to get halftoning to merge seamlessly.
                    //

                    
                    lMulDivStoreY1 = (float)nDestHeight*CumulativeScans;
                    lMulDivStoreY2 = (float)nDestHeight*(CumulativeScans+nScansInCurrentBand);


                    iRet = IntersectClipRect(
                                            hdc,
                                            xDest,
                                            yDest+(LONG)(lMulDivStoreY1/nSrcHeight+0.5),
                                            xDest+nDestWidth,
                                            yDest+(LONG)(lMulDivStoreY2/nSrcHeight+0.5));

                    if (iRet==ERROR)
                    {
                        WARNING("StretchDIBits: error intersecting clip rect\n");
                        RestoreDC(hdc, -1);
                        goto Exit;
                    }

                    //
                    // Empty clip rectangle 
                    // If the clip regions don't intersect, we can quit without
                    // doing anything.
                    //

                    if (iRet==NULLREGION)
                    {
                        RestoreDC(hdc, -1);

                        //
                        // Nothing to do - fall through and do 
                        // initialization for next iteration.
                        //

                        goto Continue_With_Init;
                    }

                    //
                    // Hack the BITMAPINFO header so that NtGdiStretchDIBitsInternal
                    // works correctly. Note that hacking it before the ICM call will
                    // carry through to the NtGdiStretchDIBitsInteral call.
                    //
                    // This code also updates the pointer to the bits, in a manner
                    // appropriate to the topdown/bottomup nature of the DIB.
                    //

                    if (HeaderHeightHack >= 0)
                    {
                        //
                        //Bottom Up
                        //

                        pBitsBand = (char *)pj + (ySrc+nSrcHeight-nScansInCurrentBand-CumulativeScans-PositiveBandDelta)*SizeOfOneScanline;
                        pbmiNew->bmiHeader.biHeight = nScansInCurrentBand+TotalBandDelta;
                    }
                    else
                    {
                        //
                        //Top Down
                        //

                        pBitsBand = (char *)pj + (ySrc+CumulativeScans-NegativeBandDelta)*SizeOfOneScanline;
                        pbmiNew->bmiHeader.biHeight = -(nScansInCurrentBand+TotalBandDelta);
                    }
                }
                else
                {
                    pBitsBand = (char *)pj;
                }

                //
                // Initialize per band ICM variables
                //

                cjHeaderNew=0;
                pbmiIcm = NULL;
                pvBitsIcm = NULL;

                //
                // Call ICM with an oversized band for later halftoning by 
                // NtGdiStretchDIBitsInternal
                //

                bIcmStatus = IcmTranslateDIB(
                                            hdc,
                                            pdcattr,
                                            (nBands==1)?cjBits:(CurrentBandSize+TotalBandDelta*SizeOfOneScanline),
                                            (PVOID)pBitsBand,
                                            &pvBitsIcm,
                                            pbmiNew,
                                            &pbmiIcm,
                                            &cjHeaderNew,
                                            (nBands==1)?((DWORD)-1):(nScansInCurrentBand+TotalBandDelta),
                                            iUsage,
                                            ICM_FORWARD,
                                            &pBitmapColorSpace,
                                            &pCXform);

                if (bIcmStatus)
                {
                    if (pvBitsIcm == NULL)
                    {
                        pvBitsIcm = pBitsBand;
                    }
                    if (pbmiIcm == NULL)
                    {
                        pbmiIcm = pbmiNew;
                        cjHeaderNew = cjHeader;
                    }
                    else
                    {
                        //
                        // new bits and header means a possibly different size bitmap
                        // and different size scanline.
                        // 
                        // if nBands==1 then nScansInCurrentBand==nNumScans and
                        // TotalBandDelta==0
                        //
                        // Also note that nNumScans is the number of scans rendered,
                        // not the number of scans in the bitmap or converted in 
                        // IcmTranslateDIB for nBands==1 case
                        //

                        if(nBands == 1) {
                          cjBitsIcm = cjBitmapBitsSize(pbmiIcm);
                        }
                        CurrentBandSize = cjBitmapScanSize(pbmiIcm, nScansInCurrentBand);
                        IcmSizeOfOneScanline = cjBitmapScanSize(pbmiIcm, 1);
                        if (!cjHeaderNew)
                        {
                            cjHeaderNew = cjHeader;
                        }
                    }
                    if (pCXform)
                    {
                        hcmTempXform = pCXform->ColorTransform;
                    }
                }
                else
                {
                    pvBitsIcm = pBitsBand;
                    pbmiIcm = pbmiNew;
                    cjHeaderNew = cjHeader;
                }

                lMulDivStoreY1 = (float)nDestHeight*(CumulativeScans-NegativeBandDelta);
                lMulDivStoreY2 = (float)nDestHeight*(nScansInCurrentBand+TotalBandDelta);
                iRet = NtGdiStretchDIBitsInternal(
                                                 hdc,                                                      
                                                 xDest,
                                                 yDest+(LONG)(lMulDivStoreY1/nSrcHeight+0.5),
                                                 nDestWidth,
                                                 (LONG)(lMulDivStoreY2/nSrcHeight+0.5),
                                                 xSrc,
                                                 (nBands==1)?ySrc:0,
                                                 nSrcWidth,
                                                 nScansInCurrentBand+TotalBandDelta,
                                                 (LPBYTE) pvBitsIcm,
                                                 (LPBITMAPINFO) pbmiIcm,
                                                 iUsage,
                                                 lRop,
                                                 (UINT)cjHeaderNew,
                                                 (nBands==1)?cjBitsIcm:(UINT)CurrentBandSize+TotalBandDelta*IcmSizeOfOneScanline,
                                                 hcmTempXform);


                if (nBands != 1)
                {
                    //
                    // Unhack the header
                    //

                    pbmiNew->bmiHeader.biHeight = HeaderHeightHack;
                }

                if (iRet==GDI_ERROR)
                {
                    WARNING("StretchDIBits: NtGdiStretchDIBitsInternal returned GDI_ERROR\n");
                    if (nBands!=1)
                    {
                        RestoreDC(hdc, -1);
                    }
                    goto Exit;  //Some GDI error and we need to quit.
                }
                cScanCount+=iRet-TotalBandDelta;

                //
                //Throw away temp storage
                //

                if (pBitmapColorSpace)
                {
                    if (pCXform)
                    {
                        IcmDeleteColorTransform(pCXform,FALSE);
                        pCXform = NULL;
                    }
                    IcmReleaseColorSpace(NULL,pBitmapColorSpace,FALSE);
                    pBitmapColorSpace = NULL;
                }
                if ((pvBitsIcm!=NULL)&&(pvBitsIcm!=pBitsBand))
                {
                    LOCALFREE(pvBitsIcm);
                    pvBitsIcm = NULL;
                }
                if ((pbmiIcm!=NULL)&&(pbmiIcm!=pbmiNew))
                {
                    LOCALFREE(pbmiIcm);
                    pbmiIcm = NULL;
                }
                hcmTempXform = NULL;


                Continue_With_Init:                
                //
                //Initialize variables for next loop.
                //

                CumulativeScans += nScansInCurrentBand;
                nScansInCurrentBand = nScansInBand;
                if (nBands != 1)
                {
                    RestoreDC(hdc, -1);
                }
            }

            if (nBands != 1)
            {
                ASSERTGDI(pbmiSave!=NULL, "StretchDIBits: pbmiSave==NULL\n");
                ASSERTGDI(pbmiNew!=NULL, "StretchDIBits: pbmiNew==NULL\n");
                LOCALFREE(pbmiNew);
                pbmiNew = pbmiSave;

                //
                // pbmiNew will be cleaned up in the 
                // regular cleanup code below.
                //
            }
            //
            // We do our own NtGdiSetDIBitsToDeviceInternal
            // So we need to fall through to cleanup at this point.
            //
            iRet=cScanCount;
            goto Exit;
        }
    }

    if (bStatus)
    {
        iRet = NtGdiStretchDIBitsInternal(hdc,
                                          xDest,
                                          yDest,
                                          nDestWidth,
                                          nDestHeight,
                                          xSrc,
                                          ySrc,
                                          nSrcWidth,
                                          nSrcHeight,
                                          (LPBYTE) pj,
                                          (LPBITMAPINFO) pbmiNew,
                                          iUsage,
                                          lRop,
                                          cjHeader,
                                          cjBits,
                                          hcmTempXform);
    }

    Exit:
    if (pulBits)
    {
        LOCALFREE(pulBits);
    }

    if (pbmiNew && (pbmiNew != pbmi))
    {
        LOCALFREE(pbmiNew);
    }

    return (iRet);
}


/******************************Public*Routine******************************\
*
* History:
*  27-Oct-2000 -by- Pravin Santiago [pravins]
* Wrote it.
\**************************************************************************/

HBITMAP SetBitmapAttributes(HBITMAP hbm, DWORD dwFlags)
{
    FIXUP_HANDLE(hbm);

    if ((dwFlags & ~SBA_STOCK) != 0)
        return (HBITMAP)0;

    return (HBITMAP)NtGdiSetBitmapAttributes(hbm,dwFlags);
}

/******************************Public*Routine******************************\
*
* History:
*  27-Oct-2000 -by- Pravin Santiago [pravins]
* Wrote it.
\**************************************************************************/

HBITMAP ClearBitmapAttributes(HBITMAP hbm, DWORD dwFlags)
{
    FIXUP_HANDLE(hbm);

    if ((dwFlags & ~SBA_STOCK) != 0)
        return (HBITMAP)0;

    return (HBITMAP)NtGdiClearBitmapAttributes(hbm,dwFlags);
}

/******************************Public*Routine******************************\
 *
 * History:
 *  27-Oct-2000 -by- Pravin Santiago [pravins]
 * Wrote it.
\**************************************************************************/

DWORD GetBitmapAttributes(HBITMAP hbm)
{
    DWORD dwRet = 0;
    FIXUP_HANDLE(hbm);

    if (IS_STOCKOBJ(hbm))
       dwRet |= SBA_STOCK;

    return dwRet; 
}

/******************************Public*Routine******************************\
*
* History:
*  27-Oct-2000 -by- Pravin Santiago [pravins]
* Wrote it.
\**************************************************************************/

HBRUSH SetBrushAttributes(HBRUSH hbr, DWORD dwFlags)
{
    FIXUP_HANDLE(hbr);

    if ((dwFlags & ~SBA_STOCK) != 0)
        return (HBRUSH)0;

    return (HBRUSH)NtGdiSetBrushAttributes(hbr,dwFlags);
}

/******************************Public*Routine******************************\
*
* History:
*  27-Oct-2000 -by- Pravin Santiago [pravins]
* Wrote it.
\**************************************************************************/

HBRUSH ClearBrushAttributes(HBRUSH hbr, DWORD dwFlags)
{
    FIXUP_HANDLE(hbr);

    if ((dwFlags & ~SBA_STOCK) != 0)
        return (HBRUSH)0;

    return (HBRUSH)NtGdiClearBrushAttributes(hbr,dwFlags);
}

/******************************Public*Routine******************************\
 *
 * History:
 *  27-Oct-2000 -by- Pravin Santiago [pravins]
 * Wrote it.
\**************************************************************************/

DWORD GetBrushAttributes(HBRUSH hbr)
{
    DWORD dwRet = 0;
    FIXUP_HANDLE(hbr);

    if (IS_STOCKOBJ(hbr))
       dwRet |= SBA_STOCK;

    return dwRet; 
}

/******************************Public*Routine******************************\
*
* History:
*  28-May-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HBITMAP CreateBitmap(
int         nWidth,
int         nHeight,
UINT        nPlanes,
UINT        nBitCount,
CONST VOID *lpBits)
{
    LONG    cj;
    HBITMAP hbm = (HBITMAP)0;
    INT     ii;

    // check if it is an empty bitmap

    if ((nWidth == 0) || (nHeight == 0))
    {
        return(GetStockObject(PRIV_STOCK_BITMAP));
    }

    // Pass call to the server

    if (lpBits == (VOID *) NULL)
        cj = 0;
    else
    {
        cj = (((nWidth*nPlanes*nBitCount + 15) >> 4) << 1) * nHeight;

        if (cj < 0)
        {
            GdiSetLastError(ERROR_INVALID_PARAMETER);
            return((HBITMAP)0);
        }
    }

    hbm = NtGdiCreateBitmap(nWidth,
                            nHeight,
                            nPlanes,
                            nBitCount,
                            (LPBYTE) lpBits);

#if TRACE_SURFACE_ALLOCS
    {
        PULONG  pUserAlloc;

        PSHARED_GET_VALIDATE(pUserAlloc, hbm, SURF_TYPE);

        if (pUserAlloc != NULL)
        {
            pUserAlloc[1] = RtlWalkFrameChain((PVOID *)&pUserAlloc[2], pUserAlloc[0], 0);
        }
    }
#endif

    return(hbm);
}

/******************************Public*Routine******************************\
* HBITMAP CreateBitmapIndirect(CONST BITMAP * pbm)
*
* NOTE: if the bmWidthBytes is larger than it needs to be, GetBitmapBits
* will return different info than the set.
*
* History:
*  Tue 18-Jan-1994 -by- Bodin Dresevic [BodinD]
* update: added bmWidthBytes support
*  28-May-1991 -by- Eric Kutter [erick]
* Wrote it.
\**************************************************************************/

HBITMAP CreateBitmapIndirect(CONST BITMAP * pbm)
{
    HBITMAP hbm    = (HBITMAP)0;
    LPBYTE  lpBits = (LPBYTE)NULL; // important to zero init
    BOOL    bAlloc = FALSE;        // indicates that tmp bitmap was allocated

// compute minimal word aligned scan width in bytes given the number of
// pixels in x. The width refers to one plane only. Our multi - planar
// support is broken anyway. I believe that we should take an early
// exit if bmPlanes != 1. [bodind].

    LONG cjWidthWordAligned = ((pbm->bmWidth * pbm->bmBitsPixel + 15) >> 4) << 1;

// Win 31 requires at least WORD alinged scans, have to reject inconsistent
// input, this is what win31 does

    if
    (
     (pbm->bmWidthBytes & 1)           ||
     (pbm->bmWidthBytes == 0)          ||
     (pbm->bmWidthBytes < cjWidthWordAligned)
    )
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return (HBITMAP)0;
    }

// take an early exit if this is not the case we know how to handle:

    if (pbm->bmPlanes != 1)
    {
        WARNING("gdi32: can not handle bmPlanes != 1\n");
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return (HBITMAP)0;
    }

// if bmBits is nonzero and bmWidthBytes is bigger than the minimal required
// word aligned width we will first convert the bitmap to one that
// has the rows that are minimally word aligned:

    if (pbm->bmBits)
    {
        if (pbm->bmWidthBytes > cjWidthWordAligned)
        {
            PBYTE pjSrc, pjDst, pjDstEnd;
            ULONGLONG lrg;

            lrg = UInt32x32To64(
                       (ULONG)cjWidthWordAligned,
                       (ULONG)pbm->bmHeight
                       );

            if (lrg > ULONG_MAX  ||
                !(lpBits = (LPBYTE)LOCALALLOC((size_t) lrg)))
            {
            // the result does not fit in 32 bits, alloc memory will fail
            // this is too big to digest

                GdiSetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return (HBITMAP)0;
            }

        // flag that we have allocated memory so that we can free it later

            bAlloc = TRUE;

        // convert bitmap to minimally word aligned format

            pjSrc = (LPBYTE)pbm->bmBits;
            pjDst = lpBits;
            pjDstEnd = lpBits + (size_t) lrg;

            while (pjDst < pjDstEnd)
            {
                RtlCopyMemory(pjDst,pjSrc, cjWidthWordAligned);
                pjDst += cjWidthWordAligned, pjSrc += pbm->bmWidthBytes;
            }
        }
        else
        {
        // bits already in minimally aligned format, do nothing

            ASSERTGDI(
                pbm->bmWidthBytes == cjWidthWordAligned,
                "pbm->bmWidthBytes != cjWidthWordAligned\n"
                );
            lpBits = (LPBYTE)pbm->bmBits;
        }
    }

    hbm = CreateBitmap(
                pbm->bmWidth,
                pbm->bmHeight,
                (UINT) pbm->bmPlanes,
                (UINT) pbm->bmBitsPixel,
                lpBits);

#if TRACE_SURFACE_ALLOCS
    {
        PULONG  pUserAlloc;

        PSHARED_GET_VALIDATE(pUserAlloc, hbm, SURF_TYPE);

        if (pUserAlloc != NULL)
        {
            pUserAlloc[1] = RtlWalkFrameChain((PVOID *)&pUserAlloc[2], pUserAlloc[0], 0);
        }
    }
#endif

    if (bAlloc)
        LOCALFREE(lpBits);

    return(hbm);
}

/******************************Public*Routine******************************\
* CreateDIBSection
*
* Allocate a file mapping object for a DIB.  Return the pointer to it
* and the handle of the bitmap.
*
* History:
*
*  25-Aug-1993 -by- Wendy Wu [wendywu]
* Wrote it.
\**************************************************************************/

HBITMAP
WINAPI
CreateDIBSection(
    HDC hdc,
    CONST BITMAPINFO *pbmi,
    UINT iUsage,
    VOID **ppvBits,
    HANDLE hSectionApp,
    DWORD dwOffset)
{
    HBITMAP hbm = NULL;
    PVOID   pjBits = NULL;
    BITMAPINFO * pbmiNew = NULL;
    INT     cjHdr;

    FIXUP_HANDLE(hdc);

    pbmiNew = pbmiConvertInfo(pbmi, iUsage, &cjHdr ,FALSE);

    //
    // Does not support passthrough image (BI_JPEG or BI_PNG).
    // Return NULL for error.
    //

    if (IS_BMI_PASSTHROUGH_IMAGE(pbmiNew))
    {
        GdiSetLastError(ERROR_INVALID_PARAMETER);
        return hbm;
    }

    //
    // dwOffset has to be a multiple of 4 (sizeof(DWORD))
    // if there is a section.  If the section is NULL we do
    // not care
    //

    if ( (hSectionApp == NULL) ||
         ((dwOffset & 3) == 0) )
    {
        PCACHED_COLORSPACE pBitmapColorSpace = NULL;
        BOOL               bCreatedColorSpace = FALSE;

        LOGCOLORSPACEW LogColorSpace;
        PROFILE        ColorProfile;
        DWORD          dwFlags = 0;

        //
        // Check they has thier own color space or not.
        //
        if (pbmiNew && IcmGetBitmapColorSpace(pbmiNew,&LogColorSpace,&ColorProfile,&dwFlags))
        {
            //
            // Find ColorSpace from cache.
            //
            pBitmapColorSpace = IcmGetColorSpaceByColorSpace(
                                    (HGDIOBJ)hdc,
                                    &LogColorSpace,
                                    &ColorProfile,
                                    dwFlags);

            if (pBitmapColorSpace == NULL)
            {
                //
                // If we can not find the color space for this DIBSection from existing color space.
                // create new one for this, but we mark it as DIBSECTION_COLORSPACE, then associated
                // to this hdc (later hbm), so that we can make sure this color space get deleted 
                // when hbm is deleted.
                //
                dwFlags |= DIBSECTION_COLORSPACE;

                //
                // Mark we will create new colorspace for this bitmap.
                //
                bCreatedColorSpace = TRUE;

                //
                // Create new cache.
                //
                pBitmapColorSpace = IcmCreateColorSpaceByColorSpace(
                                        (HGDIOBJ)hdc,
                                        &LogColorSpace,
                                        &ColorProfile,
                                        dwFlags);
            }
        }

        hbm = NtGdiCreateDIBSection(
                                hdc,
                                hSectionApp,
                                dwOffset,
                                (LPBITMAPINFO) pbmiNew,
                                iUsage,
                                cjHdr,
                                0,
                                (ULONG_PTR)pBitmapColorSpace,
                                (PVOID *)&pjBits);

        if ((hbm == NULL) || (pjBits == NULL))
        {
            hbm = 0;
            pjBits = NULL;
            if (pBitmapColorSpace)
            {
                IcmReleaseColorSpace(NULL,pBitmapColorSpace,FALSE);
            }
        }
        else
        {
#if TRACE_SURFACE_ALLOCS
            PULONG  pUserAlloc;

            PSHARED_GET_VALIDATE(pUserAlloc, hbm, SURF_TYPE);

            if (pUserAlloc != NULL)
            {
                pUserAlloc[1] = RtlWalkFrameChain((PVOID *)&pUserAlloc[2], pUserAlloc[0], 0);
            }
#endif

            if (pBitmapColorSpace && bCreatedColorSpace)
            {
                //
                // if we created new color space for this bitmap,
                // set owner of this colorspace to the created bitmap.
                //
                pBitmapColorSpace->hObj = hbm;
            }
        }
    }

    //
    // Assign the appropriate value to the caller's pointer
    //

    if (ppvBits != NULL)
    {
        *ppvBits = pjBits;
    }

    if (pbmiNew && (pbmiNew != pbmi))
    {
        LOCALFREE(pbmiNew);
    }

    return(hbm);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\cfont.c ===
/******************************Module*Header*******************************\
* Module Name: cfont.c
*
* Created: 28-May-1991 13:01:27
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1990-1999 Microsoft Corporation
*
*
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

CFONT *pcfCreateCFONT(HDC hdc,PDC_ATTR pDcAttr,UINT iFirst,PVOID pch,UINT c,BOOL bAnsi);
BOOL bFillWidthTableForGTE( HDC, CFONT *, PVOID, UINT, BOOL);
BOOL bFillWidthTableForGCW( HDC, CFONT *, UINT, UINT);
VOID vFreeCFONTCrit(CFONT *pcf);

// If the app deletes a LOCALFONT but one or more of the CFONTs hanging
// of the local font are in use then they will be added to this list.
// anytime we try to allocate a new CFONT we will check the list and
// if there entries on that list we will free them up.

CFONT *pcfDeleteList = (CFONT*) NULL;

/******************************Public*Routine******************************\
* pcfAllocCFONT ()                                                         *
*                                                                          *
* Allocates a CFONT.  Tries to get one off the free list first.  Does not  *
* do any initialization.                                                   *
*                                                                          *
*  Sun 10-Jan-1993 01:16:04 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

#ifdef DBGCFONT
int cCfontAlloc = 0;
int cCfontMax = 0;
#endif

int cCfontFree  = 0;

CFONT *pcfFreeListCFONT = (CFONT *) NULL;

CFONT *pcfAllocCFONT()
{
    CFONT *pcf;
    CFONT **ppcf;

// first lets walk the list of deleted fonts and delete any that

    ppcf = &pcfDeleteList;

    while (*ppcf)
    {
        if ((*ppcf)->cRef == 0)
        {
            pcf = (*ppcf);

            *ppcf = pcf->pcfNext;

            vFreeCFONTCrit(pcf);
        }
        else
        {
            ppcf = &(*ppcf)->pcfNext;
        }
    }

// Try to get one off the free list.

    pcf = pcfFreeListCFONT;
    if (pcf != (CFONT *) NULL)
    {
        pcfFreeListCFONT = *((CFONT **) pcf);
        --cCfontFree;
    }

// Otherwise allocate new memory.

    if (pcf == (CFONT *) NULL)
    {
        pcf = (CFONT *) LOCALALLOC(sizeof(CFONT));

        if (pcf == (CFONT *) NULL)
        {
            GdiSetLastError(ERROR_NOT_ENOUGH_MEMORY);
        }

    #ifdef DBGCFONT
        cCfontAlloc++;
        if (cCfontAlloc > cCfontMax)
        {
            cCfontMax = cCfontAlloc;
            DbgPrint("\n\n******************* cCfontMax = %ld\n\n",cCfontMax);
        }
    #endif
    }
    return(pcf);
}

/******************************Public*Routine******************************\
* vFreeCFONTCrit (pcf)                                                     *
*                                                                          *
* Frees a CFONT.  Actually just puts it on the free list.  We assume that  *
* we are already in a critical section.                                    *
*                                                                          *
*  Sun 10-Jan-1993 01:20:36 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

#define MAX_FREE_CFONT 10

VOID vFreeCFONTCrit(CFONT *pcf)
{
    ASSERTGDI(pcf != (CFONT *) NULL,"Trying to free NULL CFONT.\n");

    if(cCfontFree > MAX_FREE_CFONT)
    {
        LOCALFREE(pcf);
    #ifdef DBGCFONT
        cCfontAlloc--;
    #endif
    }
    else
    {
        *((CFONT **) pcf) = pcfFreeListCFONT;
        pcfFreeListCFONT = pcf;
        ++cCfontFree;
    }
}


/******************************Public*Routine******************************\
* bComputeCharWidths                                                       *
*                                                                          *
* Client side version of GetCharWidth.                                     *
*                                                                          *
*  Sat 16-Jan-1993 04:27:19 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL bComputeCharWidths
(
    CFONT *pcf,
    UINT   iFirst,
    UINT   iLast,
    ULONG  fl,
    PVOID  pv
)
{
    USHORT *ps;
    UINT    ii;

    switch (fl & (GCW_INT | GCW_16BIT))
    {
    case GCW_INT:               // Get LONG widths.
        {
            LONG *pl = (LONG *) pv;
            LONG fxOverhang = 0;

        // Check for Win 3.1 compatibility.

            if (fl & GCW_WIN3)
                fxOverhang = pcf->wd.sOverhang;

        // Do the trivial no-transform case.

            if (bIsOneSixteenthEFLOAT(pcf->efDtoWBaseline))
            {
                fxOverhang += 8;    // To round the final result.

            //  for (ii=iFirst; ii<=iLast; ii++)
            //      *pl++ = (pcf->sWidth[ii] + fxOverhang) >> 4;

                ps = &pcf->sWidth[iFirst];
                ii = iLast - iFirst;
            unroll_1:
                switch(ii)
                {
                default:
                    pl[4] = (ps[4] + fxOverhang) >> 4;
                case 3:
                    pl[3] = (ps[3] + fxOverhang) >> 4;
                case 2:
                    pl[2] = (ps[2] + fxOverhang) >> 4;
                case 1:
                    pl[1] = (ps[1] + fxOverhang) >> 4;
                case 0:
                    pl[0] = (ps[0] + fxOverhang) >> 4;
                }
                if (ii > 4)
                {
                    ii -= 5;
                    pl += 5;
                    ps += 5;
                    goto unroll_1;
                }
                return(TRUE);
            }

        // Otherwise use the back transform.

            else
            {
                for (ii=iFirst; ii<=iLast; ii++)
                    *pl++ = lCvt(pcf->efDtoWBaseline,pcf->sWidth[ii] + fxOverhang);
                return(TRUE);
            }
        }

    case GCW_INT+GCW_16BIT:     // Get SHORT widths.
        {
            USHORT *psDst = (USHORT *) pv;
            USHORT  fsOverhang = 0;

        // Check for Win 3.1 compatibility.

            if (fl & GCW_WIN3)
                fsOverhang = pcf->wd.sOverhang;

        // Do the trivial no-transform case.

            if (bIsOneSixteenthEFLOAT(pcf->efDtoWBaseline))
            {
                fsOverhang += 8;    // To round the final result.

            //  for (ii=iFirst; ii<=iLast; ii++)
            //      *psDst++ = (pcf->sWidth[ii] + fsOverhang) >> 4;

                ps = &pcf->sWidth[iFirst];
                ii = iLast - iFirst;
            unroll_2:
                switch(ii)
                {
                default:
                    psDst[4] = (ps[4] + fsOverhang) >> 4;
                case 3:
                    psDst[3] = (ps[3] + fsOverhang) >> 4;
                case 2:
                    psDst[2] = (ps[2] + fsOverhang) >> 4;
                case 1:
                    psDst[1] = (ps[1] + fsOverhang) >> 4;
                case 0:
                    psDst[0] = (ps[0] + fsOverhang) >> 4;
                }
                if (ii > 4)
                {
                    ii -= 5;
                    psDst += 5;
                    ps += 5;
                    goto unroll_2;
                }
                return(TRUE);
            }

        // Otherwise use the back transform.

            else
            {
                for (ii=iFirst; ii<=iLast; ii++)
                {
                    *psDst++ = (USHORT)
                               lCvt
                               (
                                   pcf->efDtoWBaseline,
                                   (LONG) (pcf->sWidth[ii] + fsOverhang)
                               );
                }
                return(TRUE);
            }
        }

    case 0:                     // Get FLOAT widths.
        {
            LONG *pe = (LONG *) pv; // Cheat to avoid expensive copies.
            EFLOAT_S efWidth,efWidthLogical;

            for (ii=iFirst; ii<=iLast; ii++)
            {
                vFxToEf((LONG) pcf->sWidth[ii],efWidth);
                vMulEFLOAT(efWidthLogical,efWidth,pcf->efDtoWBaseline);
                *pe++ = lEfToF(efWidthLogical);
            }
            return(TRUE);
        }
    }
    RIP("bComputeCharWidths: Don't come here!\n");
    return(FALSE);
}

/******************************Public*Routine******************************\
* bComputeTextExtent (pldc,pcf,psz,cc,fl,psizl,btype)                            *
*                                                                          *
* A quick function to compute text extents on the client side.             *
*                                                                          *
*  Thu 14-Jan-1993 04:00:57 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL bComputeTextExtent
(
    PDC_ATTR    pDcAttr,
    CFONT      *pcf,
    LPVOID      psz,
    int         cc,
    UINT        fl,
    SIZE       *psizl,
    BOOL        bAnsi  // TRUE is for ANSI, FALSE is for Unicode
)
{
    LONG    fxBasicExtent;
    INT     lTextExtra,lBreakExtra,cBreak;
    int     ii;
    BYTE *  pc;
    LONG    fxCharExtra = 0;
    LONG    fxBreakExtra;
    LONG    fxExtra = 0;
    BOOL    bRet = TRUE;
    WCHAR * pwc;

    lTextExtra = pDcAttr->lTextExtra;
    lBreakExtra = pDcAttr->lBreakExtra;
    cBreak = pDcAttr->cBreak;

// Compute the basic extent.

    if (pcf->wd.sCharInc == 0)
    {
        fxBasicExtent = 0;
        if(bAnsi)
            pc = (BYTE *) psz;
        else
            pwc = (WCHAR *) psz;
            
        ii = cc;

    unroll_here:
        if(bAnsi)
        {
            switch (ii)
            {
            default:
                fxBasicExtent += pcf->sWidth[pc[9]];
            case 9:
                fxBasicExtent += pcf->sWidth[pc[8]];
            case 8:
                fxBasicExtent += pcf->sWidth[pc[7]];
            case 7:
                fxBasicExtent += pcf->sWidth[pc[6]];
            case 6:
                fxBasicExtent += pcf->sWidth[pc[5]];
            case 5:
                fxBasicExtent += pcf->sWidth[pc[4]];
            case 4:
                fxBasicExtent += pcf->sWidth[pc[3]];
            case 3:
                fxBasicExtent += pcf->sWidth[pc[2]];
            case 2:
                fxBasicExtent += pcf->sWidth[pc[1]];
            case 1:
                fxBasicExtent += pcf->sWidth[pc[0]];
            }
        }
        else
        {
            switch (ii)
            {
            default:
                fxBasicExtent += pcf->sWidth[pwc[9]];
            case 9:
                fxBasicExtent += pcf->sWidth[pwc[8]];
            case 8:
                fxBasicExtent += pcf->sWidth[pwc[7]];
            case 7:
                fxBasicExtent += pcf->sWidth[pwc[6]];
            case 6:
                fxBasicExtent += pcf->sWidth[pwc[5]];
            case 5:
                fxBasicExtent += pcf->sWidth[pwc[4]];
            case 4:
                fxBasicExtent += pcf->sWidth[pwc[3]];
            case 3:
                fxBasicExtent += pcf->sWidth[pwc[2]];
            case 2:
                fxBasicExtent += pcf->sWidth[pwc[1]];
            case 1:
                fxBasicExtent += pcf->sWidth[pwc[0]];
            }
        }
        ii -= 10;
        if (ii > 0)
        {
            if(bAnsi)
                pc += 10;
            else
                pwc += 10;
            goto unroll_here;
        }
    }
    else
    {
    // Fixed pitch case.

        fxBasicExtent = cc * (LONG) pcf->wd.sCharInc;
    }

// Adjust for CharExtra.

    if (lTextExtra)
    {
        int cNoBackup = 0;

        fxCharExtra = lCvt(pcf->efM11,lTextExtra);

        if (fxCharExtra < 0)
        {
        // the layout code won't backup a characters past it's origin regardless
        // of the value of iTextCharExtra so figure out for how many values
        // we will need to ignore fxCharExtra

            if (pcf->wd.sCharInc == 0)
            {
                if(bAnsi)
                {
                    pc = (BYTE *) psz;
                    for (ii = 0; ii < cc; ii++)
                    {
                        if (pcf->sWidth[pc[ii]] + fxCharExtra <= 0)
                        {
                            cNoBackup += 1;
                        }
                    }
                }
                else
                {
                    pwc = (WCHAR *) psz;
                    for (ii = 0; ii < cc; ii++)
                    {
                        if (pcf->sWidth[pwc[ii]] + fxCharExtra <= 0)
                        {
                            cNoBackup += 1;
                        }
                    }
                }                 
            }
            else if (pcf->wd.sCharInc + fxCharExtra <= 0)
            {
                cNoBackup = cc;
            }
        }

        if ( (fl & GGTE_WIN3_EXTENT) && (pcf->hdc == 0) // hdc of zero is display DC
            && (!(pcf->flInfo & FM_INFO_TECH_STROKE)) )
            fxExtra = fxCharExtra * ((lTextExtra > 0) ? cc : (cc - 1));
        else
            fxExtra = fxCharExtra * (cc - cNoBackup);
    }

// Adjust for lBreakExtra.

    if (lBreakExtra && cBreak)
    {
        fxBreakExtra = lCvt(pcf->efM11,lBreakExtra) / cBreak;

    // Windows won't let us back up over a break.  Set up the BreakExtra
    // to just cancel out what we've already got.

        if (fxBreakExtra + pcf->wd.sBreak + fxCharExtra < 0)
            fxBreakExtra = -(pcf->wd.sBreak + fxCharExtra);

    // Add it up for all breaks.

        if(bAnsi)
        {
            pc = (BYTE *) psz;
            for (ii=0; ii<cc; ii++)
            {
                if (*pc++ == pcf->wd.iBreak)
                    fxExtra += fxBreakExtra;
            }
        }
        else
        {
            pwc = (WCHAR *) psz;
            for (ii=0; ii<cc; ii++)
            {
                if (*pwc++ == pcf->wd.iBreak)
                    fxExtra += fxBreakExtra;
            }
        }
    }

// Add in the extra stuff.

    fxBasicExtent += fxExtra;

// Add in the overhang for font simulations.

    if (fl & GGTE_WIN3_EXTENT)
        fxBasicExtent += pcf->wd.sOverhang;

// Transform the result to logical coordinates.

    if (bIsOneSixteenthEFLOAT(pcf->efDtoWBaseline))
        psizl->cx = (fxBasicExtent + 8) >> 4;
    else
        psizl->cx = lCvt(pcf->efDtoWBaseline,fxBasicExtent);

    psizl->cy = pcf->lHeight;

    return bRet;
}

/******************************Public*Routine******************************\
* pcfLocateCFONT (hdc,pDcAttr,iFirst,pch,c)
*
* Locates a CFONT for the given LDC.  First we try the CFONT last used by
* the LDC.  Then we try to do a mapping ourselves through the LOCALFONT.
* If that fails we create a new one.
*
*  Mon 11-Jan-1993 16:18:43 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

CFONT *pcfLocateCFONT(
    HDC      hdc,
    PDC_ATTR pDcAttr,
    UINT     iFirst,
    PVOID    pch,
    UINT     c,
    BOOL     bAnsi)
{
    CFONT     *pcf = NULL;
    LOCALFONT *plf;
    ULONG      fl;
    HANDLE     hf;
    int        i;
    WCHAR      *pwc;
    BYTE       *pchar;

    if (fFontAssocStatus)
        return(pcf);

    fl = pDcAttr->ulDirty_;
    hf = pDcAttr->hlfntNew;

    // Check to make sure that the XFORM is okay.  If not return FALSE and
    // mark this DC as having slow widths.

    if ((fl & SLOW_WIDTHS) || USER_XFORM_DIRTY(pDcAttr) ||
        !(pDcAttr->mxWtoD.flAccel & XFORM_SCALE))
    {
        if (!(fl & SLOW_WIDTHS))
        {
            if (!NtGdiComputeXformCoefficients(hdc))
                pDcAttr->ulDirty_ |= SLOW_WIDTHS;
        }

        if (pDcAttr->ulDirty_ & SLOW_WIDTHS)
            return(pcf);
    }

    if(guintDBCScp != 0xFFFFFFFF)
    {

        DWORD dwCodePage = GetCodePage(hdc);

    //If this is a DBCS charset but not our native one then we can not
    //compute widths and extent quickly, because gpwcDBCSCharSet[]
    //array is computed based on our NATIVE_CODEPAGE using IsDBCSLeadByte()
    //function.

        if ((guintDBCScp != dwCodePage) && IS_ANY_DBCS_CODEPAGE(dwCodePage))
        {
            pDcAttr->ulDirty_ |= SLOW_WIDTHS;
            return pcf;
        }
    }

    // now find the font

    PSHARED_GET_VALIDATE(plf,hf,LFONT_TYPE);

    if (plf == NULL)
    {
        // If there is no local font then this must be a public font or one
        // that's been deleted while still being selected into a DC.  If it's a
        // stockfont let's try to find it.

        if ((hf != NULL) &&
            !(pGdiSharedHandleTable[HANDLE_TO_INDEX(hf)].Flags & HMGR_ENTRY_LAZY_DEL) &&
            (pDcAttr->iMapMode == MM_TEXT) &&
            (fl & DC_PRIMARY_DISPLAY))
        {
            for (i = 0; i < MAX_PUBLIC_CFONT; ++i)
                if (pGdiSharedMemory->acfPublic[i].hf == hf)
                    break;

            // if we didn't find one, try to set one up

            if (i == MAX_PUBLIC_CFONT)
            {
                // this will fill in both the text metrics and widths

                i = NtGdiSetupPublicCFONT(hdc,NULL,0);
            }

            // have we found one yet

            if ((i >= 0) && (i < MAX_PUBLIC_CFONT))
            {
            // make sure mapping table is initialized before we give out a
            // public CFONT

                if ((gpwcANSICharSet == (WCHAR *) NULL) && !bGetANSISetMap())
                {
                    return((CFONT *) NULL);
                }

                pcf = &pGdiSharedMemory->acfPublic[i];
            }
        }
        else
        {
            pDcAttr->ulDirty_ |= SLOW_WIDTHS;
        }
    }
    else if (plf->fl & LF_HARDWAY)
    {
        // If the logfont has non-zero escapement or orientation then bail out.
        // Stock fonts will never have non-zero escapments or orientation so we can do
        // this now.

        pDcAttr->ulDirty_ |= SLOW_WIDTHS;
    }
    else
    {
        BOOL bRet = FALSE;

        // next loop through all the CFONTs associated with this LOGFONT to see if
        // we can find a match.

        for (pcf = plf->pcf; pcf ; pcf = pcf->pcfNext)
        {
            // if the DC's are both display DC's or the same printer DC and the
            // transform's coefficients match then we've got a winner.

            if ((((pcf->hdc == 0) && (fl & DC_PRIMARY_DISPLAY)) || (pcf->hdc == hdc)) &&
               bEqualEFLOAT(pcf->efM11, pDcAttr->mxWtoD.efM11) &&
               bEqualEFLOAT(pcf->efM22, pDcAttr->mxWtoD.efM22))
            {
                // update the refcount so we don't accidentally delete this CFONT while
                // we are using it.

                INC_CFONT_REF(pcf);
                break;
            }
        }

        if (pcf == NULL)
        {
        // don't do this under semaphore because pcfCreateCFONT will call off to
        // font drivers which in turn could access a file on the net and take a
        // very long time

            pcf = pcfCreateCFONT(hdc,pDcAttr,iFirst,pch,c,bAnsi);

            if (pcf)
            {
                // next update the REFCOUNT of the CFONT

                pcf->hf    = hf;
                pcf->hdc   = (fl & DC_PRIMARY_DISPLAY) ? (HDC) 0 : (HDC) hdc;

                // now that we have a CFONT link it in to the chain off of this
                // LOCALFONT

                pcf->pcfNext = plf->pcf;
                plf->pcf = pcf;
            }
        }
        else
        {
            // At this point we have a non-NULL pcf which is referenced by the LDC.
            // We must check it to see if it contains the widths we need.

            if (pcf->fl & CFONT_COMPLETE)
                return(pcf);

            if (pch != NULL)
            {

            // Make sure we have widths for all the chars in the string.
                if (pcf->fl & CFONT_CACHED_WIDTHS)
                {
                    if(bAnsi)
                    {
                        INT ic = (INT)c;

                        pchar = (BYTE *) pch;

                        if (pcf->fl & CFONT_DBCS)
                        {
                        // we won't have local width cache for DBCS chars in sWidth[] array.

                            for (;ic > 0; ic--,pchar++)
                            {
                                if (gpwcDBCSCharSet[*pchar] == 0xffff)
                                {
                                    // skip DBCS chars
                                    if (ic > 0)
                                    {
                                       ic--;
                                       pchar++;
                                    }
                                }
                                else if (pcf->sWidth[*pchar] == NO_WIDTH)
                                {
                                    break;
                                }
                            }
                            if (ic < 0)
                                c = 0;
                            else
                                c = (UINT)ic;
                        }
                        else
                        {
                            for (; c && (pcf->sWidth[*pchar] != NO_WIDTH); c--,pchar++)
                            {}
                        }
                        pch = (PVOID) pchar;
                    }
                    else
                    {
                        pwc = (WCHAR *) pch;
                        for (; c && (pcf->sWidth[*pwc] != NO_WIDTH); c--,pwc++)
                        {}
                        pch = (PVOID) pwc;
                    }
                }

                if (c)
                {
                    bRet = bFillWidthTableForGTE(hdc, pcf, pch, c, bAnsi);
                }
            }
            else
            {
            // Make sure we have widths for the array requested.

                if (pcf->fl & CFONT_CACHED_WIDTHS)
                {
                    if (!(iFirst & 0xffffff00) && !((iFirst + c) & 0xffffff00))
                    {
                        for (; c && (pcf->sWidth[iFirst] != NO_WIDTH); c--,iFirst++)
                        {}
                    }
                }

                if (c)
                {
                    bRet = bFillWidthTableForGCW(hdc, pcf, iFirst, c);
                }
            }

            if (bRet == GDI_ERROR)
            {
                // Something bad happened while trying to fill.  To avoid hitting this
                // problem again on the next call, we mark the LDC as slow.

                DEC_CFONT_REF(pcf);

                pDcAttr->ulDirty_ |= SLOW_WIDTHS;

                pcf = NULL;
            }
        }
    }

    return(pcf);

}

/******************************Public*Routine******************************\
* pcfCreateCFONT (pldc,iFirst,pch,c)                                       *
*                                                                          *
* Allocate and initialize a new CFONT.                                     *
*                                                                          *
* History:                                                                 *
*  Tue 19-Jan-1993 16:16:03 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

EFLOAT_S ef_1 = EFLOAT_1;

CFONT *pcfCreateCFONT(
    HDC hdc,
    PDC_ATTR pDcAttr,
    UINT iFirst,
    PVOID pch,
    UINT c,
    BOOL bAnsi)
{
    CFONT *pcfNew;
    BOOL   bRet;


// Make sure we have the UNICODE translation of the ANSI character set.
// We'll create this once and keep it around to avoid lots of conversion.

    if ((gpwcANSICharSet == (WCHAR *) NULL) && !bGetANSISetMap())
        return((CFONT *) NULL);

// Allocate a new CFONT to hold the results.

    pcfNew = pcfAllocCFONT();

    if (pcfNew != (CFONT *) NULL)
    {
		pcfNew->timeStamp = pGdiSharedMemory->timeStamp;

        pcfNew->fl    = 0;

    // if the default code page is a DBCS code page then we may need to mark this
    // as a DBCS font

        if(guintDBCScp != 0xFFFFFFFF)
        {

            DWORD dwCodePage = GetCodePage(hdc);

        //If this is a DBCS charset but not our native one then we can not
        //compute widths and extent quickly, because gpwcDBCSCharSet[]
        //array is computed based on our NATIVE_CODEPAGE using IsDBCSLeadByte()
        //function.  We should never get here because we will be doing a check
        //higher up to make sure the codepage of the font in the DC is matches
        //the current DBCS code page

            if(guintDBCScp == dwCodePage)
            {
                pcfNew->fl = CFONT_DBCS;
            }

            ASSERTGDI(guintDBCScp == dwCodePage || !IS_ANY_DBCS_CODEPAGE(dwCodePage),
                      "pcfLocateCFONT called on non-native DBCS font\n");
        }


        pcfNew->cRef  = 1;

    // Compute the back transforms.

        pcfNew->efM11 = pDcAttr->mxWtoD.efM11;
        pcfNew->efM22 = pDcAttr->mxWtoD.efM22;

        efDivEFLOAT(pcfNew->efDtoWBaseline,ef_1,pcfNew->efM11);
        vAbsEFLOAT(pcfNew->efDtoWBaseline);

        efDivEFLOAT(pcfNew->efDtoWAscent,ef_1,pcfNew->efM22);
        vAbsEFLOAT(pcfNew->efDtoWAscent);

    // Send over a request.

        if (pch != NULL)
        {
            bRet = bFillWidthTableForGTE(hdc,pcfNew,pch,c,bAnsi);
        }
        else if (c)
        {
            bRet = bFillWidthTableForGCW(hdc,pcfNew,iFirst,c);
        }
        else
        {
            // probably just creating a cache entry for text metrics.
            // FALSE just means haven't gotten all the widths.  Note
            // that GDI_ERROR is actualy -1

            bRet = FALSE;
        }

    // Clean up failed requests.

        if (bRet == GDI_ERROR)
        {
        // we will not attempt to create cfont if this failed once in the
        // past, because the chances are it will fail again with this logfont.
        // It turns out it is costly to figure out that cfont creation is going to fail
        // so we record this by setting LF_NO_CFONT flag to avoid another attempt at
        // creating cfont.

            pDcAttr->ulDirty_ |= SLOW_WIDTHS;

            vFreeCFONTCrit(pcfNew);
            pcfNew = NULL;
        }
    }

    return(pcfNew);
}

/******************************Public*Routine******************************\
* bFillWidthTableForGCW                                                    *
*                                                                          *
* Requests ANSI character widths from the server for a call to             *
* GetCharWidthA.  iFirst and c specify the characters needed by the API    *
* call, the server must return these.  In addition, it may be prudent to   *
* fill in a whole table of 256 widths at psWidthCFONT.  We will fill in    *
* the whole table and a WIDTHDATA structure if the pointer pwd is non-NULL.*
*                                                                          *
* History:                                                                 *
*  Tue 19-Jan-1993 14:29:31 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.                                                                *
\**************************************************************************/

BOOL bFillWidthTableForGCW
(
    HDC    hdc,
    CFONT *pcf,
    UINT   iFirst,
    UINT   c
)
{
    BOOL   bRet = GDI_ERROR;
    BOOL   bDBCS = pcf->fl & CFONT_DBCS;
    WCHAR *pwcBuf;
    UINT   c1,c2;
    WIDTHDATA *pwd;

    if(iFirst > 256)
    {
    // this is possible for DBCS fonts, just get all the widths
        iFirst = 0;
        c = 256;
    }



    if (pcf->fl & CFONT_CACHED_WIDTHS)
    {
    // Not the first time.  Just get the important widths.

        c1  = c;
        c2  = 0;
        pwd = NULL;
    }
    else
    {
    // Get the whole table, but put the important widths at the start.

        c2  = iFirst;
        c1  = 256 - c2; // only c of those are "important"
        pwd = &pcf->wd;
    }

    pwcBuf = (WCHAR *)LocalAlloc(LMEM_FIXED,
                        (c1+c2) * (sizeof(WCHAR)+sizeof(USHORT)));

    if (pwcBuf)
    {
        USHORT *psWidths = pwcBuf + c1+c2;

        RtlCopyMemory(pwcBuf,
                      (bDBCS) ? (PBYTE)  &gpwcDBCSCharSet[iFirst] :
                                (PBYTE)  &gpwcANSICharSet[iFirst],
                      c1*sizeof(WCHAR));

        if (c2)
        {
            RtlCopyMemory(&pwcBuf[c1],
                          (bDBCS) ? (PBYTE) &gpwcDBCSCharSet[0] :
                                    (PBYTE) &gpwcANSICharSet[0],
                          c2*sizeof(WCHAR));
        }

        LEAVECRITICALSECTION(&semLocal);

        bRet = NtGdiGetWidthTable( hdc,       // The DC
                                   c,         // Number of special characters
                                   pwcBuf,    // Unicode characters requested
                                   c1+c2,     // Number of non-special chars
                                   psWidths,  // Buffer to get widths returned
                                   pwd,       // Width data
                                   &pcf->flInfo); // Font info flags

        ENTERCRITICALSECTION(&semLocal);

        if (bRet != GDI_ERROR)
        {
            if (!(pcf->fl & CFONT_CACHED_WIDTHS))
            {
                // mark this cfont as having some widths

                pcf->fl |= CFONT_CACHED_WIDTHS;

                // Precompute the height.

                pcf->lHeight = lCvt(pcf->efDtoWAscent,(LONG) pcf->wd.sHeight);
            }

            if (bRet && ((c1+c2) >= 256))
                pcf->fl |= CFONT_COMPLETE;

            // Copy the widths into the CFONT table.

            RtlCopyMemory(
                &pcf->sWidth[iFirst], psWidths, c1 * sizeof(USHORT));

            if (c2)
            {
                RtlCopyMemory (
                    pcf->sWidth, &psWidths[c1], c2 * sizeof(USHORT));
            }
        }

        LocalFree(pwcBuf);
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* bFillWidthTableForGTE
*
* Requests ANSI character widths from the server for a call to
* GetTextExtentA.  pch specifies the string from the API call.  The
* server must return widths for these characters.  In addition, it may be
* prudent to fill in a whole table of 256 widths at psWidthCFONT.  We will
* fill in the whole table and a WIDTHDATA structure if the pointer pwd is
* non-NULL.
*
* History:
*  Tue 13-Jun-1995 14:29:31 -by- Gerrit van Wingerden [gerritv]
* Converted for kernel mode.
*  Tue 19-Jan-1993 14:29:31 -by- Charles Whitmer [chuckwh]
* Wrote it.
\**************************************************************************/

BOOL bFillWidthTableForGTE
(
    HDC    hdc,
    CFONT *pcf,
    PVOID  pch,
    UINT   c,
    BOOL   bAnsi
)
{
    BOOL bRet = GDI_ERROR;
    BOOL   bDBCS = pcf->fl & CFONT_DBCS;
    UINT ii;
    UINT c1;
    WCHAR *pwcBuf;
    WCHAR *pwcXlat = (bDBCS) ? gpwcDBCSCharSet : gpwcANSICharSet;

    WIDTHDATA *pwd;

    if (pcf->fl & CFONT_CACHED_WIDTHS)
    {
        c1  = c;
        pwd = NULL;
    }
    else
    {
        c1  = c+256;
        pwd = &pcf->wd;
    }

    pwcBuf = LocalAlloc(LMEM_FIXED,c1*(sizeof(WCHAR)+sizeof(USHORT)));

    if( pwcBuf )
    {
        WCHAR     *pwc = pwcBuf;
        USHORT    *psWidths = pwcBuf + c1;

        if(bAnsi)
        {
            for( ii = 0; ii < c; ii++ )
            {
                *pwc++ = pwcXlat[((BYTE *)pch)[ii]];
            }
        }
        else
        {
            RtlCopyMemory((PBYTE)pwc, (PBYTE) pch, c * sizeof(WCHAR));
            pwc += c;
        }

        if (pwd != (WIDTHDATA *) NULL)
        {
            // Request the whole table, too.

            RtlCopyMemory((PBYTE)pwc,
                          (bDBCS) ? (PBYTE) &gpwcDBCSCharSet[0] :
                                    (PBYTE) &gpwcANSICharSet[0],
                          256*sizeof(WCHAR));
        }

        LEAVECRITICALSECTION(&semLocal);

        bRet = NtGdiGetWidthTable( hdc,          // the DC
                                   c,            // number of special characters
                                   pwcBuf,       // the requested chars in Unicode
                                   c1,           // total number of characters
                                   psWidths,     // the actual width
                                   pwd,          // useful width data
                                   &pcf->flInfo);// font info flags

        ENTERCRITICALSECTION(&semLocal);

        if (bRet != GDI_ERROR)
        {
            if (!(pcf->fl & CFONT_CACHED_WIDTHS))
            {
                // mark this cfont as having some widths

                pcf->fl |= CFONT_CACHED_WIDTHS;

                // Precompute the height.

                pcf->lHeight = lCvt(pcf->efDtoWAscent,(LONG) pcf->wd.sHeight);

				if (bRet) // bFillWidthTableForGTE() tries to get width for all 0x00 to 0xff only at the first time
                	pcf->fl |= CFONT_COMPLETE;
            }

            if( pwd != (WIDTHDATA *) NULL )
                RtlCopyMemory( pcf->sWidth,&psWidths[c],256 * sizeof(USHORT));

            // Write the hard widths into the table too.
            if (bAnsi)
            {
                for (ii=0; ii<c; ii++)
                    pcf->sWidth[((BYTE *)pch)[ii]] = psWidths[ii];
            }
            else
            {
                for (ii=0; ii<c; ii++)
                    pcf->sWidth[((WCHAR *)pch)[ii]] = psWidths[ii];
            }
        }

        LocalFree( pwcBuf );
    }

    return(bRet);
}

/***************************************************************************\
* GetCharDimensions
*
* This function loads the Textmetrics of the font currently selected into
* the hDC and returns the Average char width of the font; Pl Note that the
* AveCharWidth value returned by the Text metrics call is wrong for
* proportional fonts.  So, we compute them On return, lpTextMetrics contains
* the text metrics of the currently selected font.
*
* Legacy code imported from USER.
*
* History:
* 10-Nov-1993 mikeke   Created
\***************************************************************************/

int GdiGetCharDimensions(
    HDC hdc,
    TEXTMETRICW *lptm,
    LPINT lpcy)
{
    TEXTMETRICW tm;
    PLDC        pldc;
    PDC_ATTR    pDcAttr;
    CFONT      *pcf;
    int         iAve;

    PSHARED_GET_VALIDATE(pDcAttr,hdc,DC_TYPE);

    if (!pDcAttr)
    {
        WARNING("GdiGetCharDimensions: invalid DC");
        return(0);
    }

    // find the local font or create one

    if (lptm == NULL)
        lptm = &tm;

    // now find the metrics

    ENTERCRITICALSECTION(&semLocal);

    pcf = pcfLocateCFONT(hdc,pDcAttr,0,(PVOID)NULL,0, TRUE);

    if (!bGetTextMetricsWInternal(hdc, (TMW_INTERNAL *)lptm,sizeof(*lptm), pcf))
    {
        LEAVECRITICALSECTION(&semLocal);
        return(0);
    }

    LEAVECRITICALSECTION(&semLocal);

    if (lpcy != NULL)
        *lpcy = lptm->tmHeight;

    // If fixed width font

    if (lptm->tmPitchAndFamily & TMPF_FIXED_PITCH)
    {
        if (pcf && (pcf->fl & CFONT_CACHED_AVE))
        {
            iAve = (int)pcf->ulAveWidth;
        }
        else
        {
            SIZE size;

            static WCHAR wszAvgChars[] =
                    L"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";

            // Change from tmAveCharWidth.  We will calculate a true average
            // as opposed to the one returned by tmAveCharWidth.  This works
            // better when dealing with proportional spaced fonts.
            // legacy from USER so can't change this.

            if(!GetTextExtentPointW(hdc, wszAvgChars,
                                    (sizeof(wszAvgChars) / sizeof(WCHAR)) - 1,
                                    &size))
            {
                WARNING("GetCharDimension: GetTextExtentPointW failed\n");
                return(0);
            }

            ASSERTGDI(size.cx,
                      "GetCharDimension: GetTextExtentPointW return 0 width string\n");

            iAve = ((size.cx / 26) + 1) / 2; // round up

            // if we have a pcf, let's cache it

            if (pcf)
            {
                // if it is a public font, we need to go to the kernel because
                // the pcf is read only here.

                if (pcf->fl & CFONT_PUBLIC)
                {
                    NtGdiSetupPublicCFONT(NULL,(HFONT)pcf->hf,(ULONG)iAve);
                }
                else
                {
                    pcf->ulAveWidth = (ULONG)iAve;
                    pcf->fl |= CFONT_CACHED_AVE;
                }
            }
        }
    }
    else
    {

        iAve = lptm->tmAveCharWidth;
    }

    // pcfLocateCFONT added a reference so now we need to remove it

    if (pcf)
    {
        DEC_CFONT_REF(pcf);
    }

    return(iAve);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\cliumpd.h ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    cliumpd.h

Abstract:

    User-mode printer driver header file

Environment:

        Windows NT 5.0

Revision History:

        06/30/97 -davidx-
                Created it.

--*/


#ifndef _UMPD_H_
#define _UMPD_H_


//
// Critical section for user-mode printer driver
//

extern RTL_CRITICAL_SECTION semUMPD;


#define UMPDFLAG_DRVENABLEDRIVER_CALLED 0x0001

#define UMPDFLAG_METAFILE_DRIVER        0x0002

#define UMPDFLAG_NON_METAFILE_DRIVER    0x0004

//
// Data structure signature for debugging purposes
//

#define UMPD_SIGNATURE  0xfedcba98
#define VALID_UMPD(p)   ((p) != NULL && (p)->dwSignature == UMPD_SIGNATURE)

//
// User-mode printer driver support functions
//

BOOL
LoadUserModePrinterDriver(
    HANDLE  hPrinter,
    LPWSTR  pwstrPrinterName,
    PUMPD  *ppUMPD,
    PRINTER_DEFAULTSW *pdefaults
    );

BOOL
LoadUserModePrinterDriverEx(
    PDRIVER_INFO_5W     pDriverInfo5,
    LPWSTR              pwstrPrinterName,
    PUMPD               *ppUMPD,
    PRINTER_DEFAULTSW   *pdefaults,
    HANDLE              hPrinter
    );

UnloadUserModePrinterDriver(
    PUMPD   pUMPD,
    BOOL    bNotifySpooler,
    HANDLE  hPrinter
    );


/*++

Routine Description:

    This entrypoint must be exported by a user-mode printer driver DLL.
    GDI calls this function to query various information about the driver.

Arguments:

    dwMode - Specifies what information is being queried
    pBuffer - Points to an output buffer for storing the returned information
    cbBuf - Size of the output buffer in bytes
    pcbNeeded - Returns the expected size of the output buffer

Return Value:

    TRUE if successful, FALSE if there is an error

Note:

    If cbBuf is not large enough to stored the necessary return information,
    the driver should return FALSE from this function and set last error code
    to ERROR_INSUFFICIENT_BUFFER. *pcbNeeded always contains the expected
    size of the output buffer.

--*/

typedef BOOL (APIENTRY *PFN_DrvQueryDriverInfo)(
    DWORD   dwMode,
    PVOID   pBuffer,
    DWORD   cbBuf,
    PDWORD  pcbNeeded
    );

PUMPD
UMPDDrvEnableDriver(
    PWSTR           pDriverDllName,
    ULONG           iEngineVersion
    );

#endif  // !_UMPD_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\ddstub.h ===
/******************************Module*Header*******************************\
* Module Name: ddstub.h
*
* Information shared between DirectDraw and Direct3D stubs
*
* Created: 31-May-1996
* Author: Drew Bliss [drewb]
*
* Copyright (c) 1995-1999 Microsoft Corporation
\**************************************************************************/

#ifndef __DDSTUB_H__
#define __DDSTUB_H__

extern HANDLE ghDirectDraw;
#define DD_HANDLE(h) ((h) != 0 ? (HANDLE) (h) : ghDirectDraw)

#endif // __DDSTUB_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\ddraw.c ===
/******************************Module*Header*******************************\
* Module Name: ddraw.c
*
* Client side stubs for the private DirectDraw system APIs.
*
* Created: 3-Dec-1995
* Author: J. Andrew Goossen [andrewgo]
*
* Copyright (c) 1995-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include <ddrawi.h>
#include <ddrawgdi.h>
#undef _NO_COM
#define BUILD_DDDDK
#include <d3dhal.h>
#include <ddrawi.h>
#include "ddstub.h"
#include "d3dstub.h"


// For the first incarnation of DirectDraw on Windows NT, we are
// implementing a user-mode shared memory section between all instances
// of DirectDraw to keep track of shared state -- mostly for off-screen
// memory allocation and exclusive mode arbitration.  Hopefully future
// versions will move all this logic to kernel mode so that we can get
// rid of the shared section, which is a robustness hole.
//
// One of the ramifications of this is that DirectDraw keeps its
// global DirectDraw object in the shared memory section, where it is
// used by all processes.  Unfortunately, it is preferrable from a kernel
// point of view to keep the DirectDraw objects unique between processes
// so that proper cleanup can be done.  As a compromise, so that
// DirectDraw can keep using this global DirectDraw object, but that the
// kernel still has unique DirectDraw objects per process, we simply stash
// the unique per-process DirectDraw handle in a variable global to this
// process, and use that instead of anything pulled out of DirectDraw's
// own global DirectDraw object structure -- an advantage since the kernel
// code is already written to the future model.
//
// One result of this, however, is that we are limiting ourselves to the
// notion of only one DirectDraw device.  However, since we will not
// support multiple monitors for the NT 4.0 release, I don't consider this
// to be a serious problem, and the non-shared-section model will fix this.

HANDLE ghDirectDraw = 0;    // Process-specific kernel-mode DirectDraw object
                            //   handle that we substitute for the 'global'
                            //   DirectDraw handle whenever we see it
ULONG  gcDirectDraw = 0;    // Count of global DirectDraw instances

/*****************************Private*Routine******************************\
* CanCreateVideoPort
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DWORD
WINAPI
DvpCanCreateVideoPort(
    LPDDHAL_CANCREATEVPORTDATA pCanCreateVideoPort
    )
{
    return(NtGdiDvpCanCreateVideoPort(DD_HANDLE(pCanCreateVideoPort->lpDD->lpGbl->hDD),
                                      (PDD_CANCREATEVPORTDATA)pCanCreateVideoPort));
}

/*****************************Private*Routine******************************\
* CreateVideoPort
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DWORD
WINAPI
DvpCreateVideoPort(
    LPDDHAL_CREATEVPORTDATA pCreateVideoPort
    )
{
    HANDLE  h;

    h = NtGdiDvpCreateVideoPort(DD_HANDLE(pCreateVideoPort->lpDD->lpGbl->hDD),
                                (PDD_CREATEVPORTDATA)pCreateVideoPort);

    pCreateVideoPort->lpVideoPort->hDDVideoPort = h;

    return(DDHAL_DRIVER_HANDLED);
}

/*****************************Private*Routine******************************\
* DestroyVideoPort
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DWORD
WINAPI
DvpDestroyVideoPort(
    LPDDHAL_DESTROYVPORTDATA pDestroyVideoPort
    )
{
    return(NtGdiDvpDestroyVideoPort((HANDLE) pDestroyVideoPort->lpVideoPort->hDDVideoPort,
                                    (PDD_DESTROYVPORTDATA)pDestroyVideoPort));
}

/*****************************Private*Routine******************************\
* ColorControl
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DWORD
WINAPI
DvpColorControl(
    LPDDHAL_VPORTCOLORDATA pColorControl
    )
{
    return(NtGdiDvpColorControl((HANDLE) pColorControl->lpVideoPort->hDDVideoPort,
                                (PDD_VPORTCOLORDATA)pColorControl));
}

/*****************************Private*Routine******************************\
* FlipVideoPort
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/

DWORD
WINAPI
DvpFlipVideoPort(
    LPDDHAL_FLIPVPORTDATA pFlipVideoPort
    )
{
    return(NtGdiDvpFlipVideoPort((HANDLE) pFlipVideoPort->lpVideoPort->hDDVideoPort,
                                 (HANDLE) pFlipVideoPort->lpSurfCurr->hDDSurface,
                                 (HANDLE) pFlipVideoPort->lpSurfTarg->hDDSurface,
                                 (PDD_FLIPVPORTDATA) pFlipVideoPort));
}

/*****************************Private*Routine******************************\
* GetVideoPortBandwidth
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpGetVideoPortBandwidth(
    LPDDHAL_GETVPORTBANDWIDTHDATA pGetVPortBandwidth
    )
{
    return(NtGdiDvpGetVideoPortBandwidth((HANDLE) pGetVPortBandwidth->lpVideoPort->hDDVideoPort,
                                         (PDD_GETVPORTBANDWIDTHDATA) pGetVPortBandwidth));
}


/*****************************Private*Routine******************************\
* GetVideoPortField
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpGetVideoPortField(
    LPDDHAL_GETVPORTFIELDDATA pGetVideoPortField
    )
{
    return(NtGdiDvpGetVideoPortField((HANDLE) pGetVideoPortField->lpVideoPort->hDDVideoPort,
                                     (PDD_GETVPORTFIELDDATA)pGetVideoPortField));
}

/*****************************Private*Routine******************************\
* GetVideoPortFlipStatus
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpGetVideoPortFlipStatus(
    LPDDHAL_GETVPORTFLIPSTATUSDATA pGetVPortFlipStatus
    )
{
    return(NtGdiDvpGetVideoPortFlipStatus(DD_HANDLE(pGetVPortFlipStatus->lpDD->lpGbl->hDD),
                                          (PDD_GETVPORTFLIPSTATUSDATA)pGetVPortFlipStatus));
}

/*****************************Private*Routine******************************\
* GetVideoPortInputFormats
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpGetVideoPortInputFormats(
    LPDDHAL_GETVPORTINPUTFORMATDATA pGetVPortInputFormat
    )
{
    return(NtGdiDvpGetVideoPortInputFormats((HANDLE) pGetVPortInputFormat->lpVideoPort->hDDVideoPort,
                                            (PDD_GETVPORTINPUTFORMATDATA)pGetVPortInputFormat));
}


/*****************************Private*Routine******************************\
* GetVideoPortLine
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpGetVideoPortLine(
    LPDDHAL_GETVPORTLINEDATA pGetVideoPortLine
    )
{
    return(NtGdiDvpGetVideoPortLine((HANDLE) pGetVideoPortLine->lpVideoPort->hDDVideoPort,
                                    (PDD_GETVPORTLINEDATA)pGetVideoPortLine));
}

/*****************************Private*Routine******************************\
* GetVideoPortOutputFormats
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpGetVideoPortOutputFormats(
    LPDDHAL_GETVPORTOUTPUTFORMATDATA pGetVPortOutputFormats
    )
{
    return(NtGdiDvpGetVideoPortOutputFormats((HANDLE) pGetVPortOutputFormats->lpVideoPort->hDDVideoPort,
                                             (PDD_GETVPORTOUTPUTFORMATDATA)pGetVPortOutputFormats));
}

/*****************************Private*Routine******************************\
* GetVideoPortConnectInfo
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpGetVideoPortConnectInfo(
    LPDDHAL_GETVPORTCONNECTDATA pGetVPortConnectInfo
    )
{
    return(NtGdiDvpGetVideoPortConnectInfo(DD_HANDLE(pGetVPortConnectInfo->lpDD->lpGbl->hDD),
                                           (PDD_GETVPORTCONNECTDATA)pGetVPortConnectInfo));
}

/*****************************Private*Routine******************************\
* GetVideoSignalStatus
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpGetVideoSignalStatus(
    LPDDHAL_GETVPORTSIGNALDATA pGetVideoSignalStatus
    )
{
    return(NtGdiDvpGetVideoSignalStatus((HANDLE) pGetVideoSignalStatus->lpVideoPort->hDDVideoPort,
                                        (PDD_GETVPORTSIGNALDATA)pGetVideoSignalStatus));
}

/*****************************Private*Routine******************************\
* UpdateVideoPort
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpUpdateVideoPort(
    LPDDHAL_UPDATEVPORTDATA pUpdateVideoPort
    )
{
    HANDLE  ahSurfaceVideo[MAX_AUTOFLIP_BUFFERS];
    HANDLE  ahSurfaceVbi[MAX_AUTOFLIP_BUFFERS];
    DWORD   dwNumAutoflip;
    DWORD   dwNumVBIAutoflip;
    ULONG   i;

    if (pUpdateVideoPort->dwFlags != DDRAWI_VPORTSTOP)
    {
        dwNumAutoflip = pUpdateVideoPort->dwNumAutoflip;
        if ((dwNumAutoflip == 0) &&
            (pUpdateVideoPort->lplpDDSurface != NULL))
        {
            dwNumAutoflip = 1;
        }
        for (i = 0; i < dwNumAutoflip; i++)
        {
            ahSurfaceVideo[i] = (HANDLE)(pUpdateVideoPort->lplpDDSurface[i]->
                                            lpLcl->hDDSurface);
        }

        dwNumVBIAutoflip = pUpdateVideoPort->dwNumVBIAutoflip;
        if ((dwNumVBIAutoflip == 0) &&
            (pUpdateVideoPort->lplpDDVBISurface != NULL))
        {
            dwNumVBIAutoflip = 1;
        }
        for (i = 0; i < dwNumVBIAutoflip; i++)
        {
            ahSurfaceVbi[i] = (HANDLE)(pUpdateVideoPort->lplpDDVBISurface[i]->
                                            lpLcl->hDDSurface);
        }
    }

    return(NtGdiDvpUpdateVideoPort((HANDLE) pUpdateVideoPort->lpVideoPort->hDDVideoPort,
                                   ahSurfaceVideo,
                                   ahSurfaceVbi,
                                   (PDD_UPDATEVPORTDATA) pUpdateVideoPort));
}

/*****************************Private*Routine******************************\
* WaitForVideoPortSync
*
* History:
*  2-Oct-1996 -by- Lingyun Wang [lingyunw]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpWaitForVideoPortSync(
    LPDDHAL_WAITFORVPORTSYNCDATA pWaitForVideoPortSync
    )
{
    return(NtGdiDvpWaitForVideoPortSync((HANDLE) pWaitForVideoPortSync->lpVideoPort->hDDVideoPort,
                                        (PDD_WAITFORVPORTSYNCDATA)pWaitForVideoPortSync));
}

/*****************************Private*Routine******************************\
* AcquireNotification
*
* History:
*  9-Oct-2000 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpAcquireNotification(
    LPDDRAWI_DDVIDEOPORT_LCL pVideoPort,
    HANDLE * pHandle,
    LPDDVIDEOPORTNOTIFY pNotify)
{
    return(NtGdiDvpAcquireNotification((HANDLE) pVideoPort->hDDVideoPort,
                                        pHandle,
                                        pNotify));
}

/*****************************Private*Routine******************************\
* ReleaseNotification
*
* History:
*  9-Oct-2000 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DvpReleaseNotification(
    LPDDRAWI_DDVIDEOPORT_LCL pVideoPort,
    HANDLE Handle)
{
    return(NtGdiDvpReleaseNotification((HANDLE) pVideoPort->hDDVideoPort,
                                        Handle));
}

/*****************************Private*Routine******************************\
* GetMoCompGuids
*
* History:
*  18-Nov-1997 -by- smac
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DdGetMoCompGuids(
    LPDDHAL_GETMOCOMPGUIDSDATA pGetMoCompGuids
    )
{
    return(NtGdiDdGetMoCompGuids(DD_HANDLE(pGetMoCompGuids->lpDD->lpGbl->hDD),
                                 (PDD_GETMOCOMPGUIDSDATA)pGetMoCompGuids));
}

/*****************************Private*Routine******************************\
* GetMoCompFormats
*
* History:
*  18-Nov-1997 -by- smac
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DdGetMoCompFormats(
    LPDDHAL_GETMOCOMPFORMATSDATA pGetMoCompFormats
    )
{
    return(NtGdiDdGetMoCompFormats(DD_HANDLE(pGetMoCompFormats->lpDD->lpGbl->hDD),
                                   (PDD_GETMOCOMPFORMATSDATA)pGetMoCompFormats));
}

/*****************************Private*Routine******************************\
* GetMoCompBuffInfo
*
* History:
*  18-Nov-1997 -by- smac
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DdGetMoCompBuffInfo(
    LPDDHAL_GETMOCOMPCOMPBUFFDATA pGetBuffData
    )
{
    return(NtGdiDdGetMoCompBuffInfo(DD_HANDLE(pGetBuffData->lpDD->lpGbl->hDD),
                                   (PDD_GETMOCOMPCOMPBUFFDATA)pGetBuffData));
}

/*****************************Private*Routine******************************\
* GetInternalMoCompInfo
*
* History:
*  18-Nov-1997 -by- smac
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DdGetInternalMoCompInfo(
    LPDDHAL_GETINTERNALMOCOMPDATA pGetInternalData
    )
{
    return(NtGdiDdGetInternalMoCompInfo(DD_HANDLE(pGetInternalData->lpDD->lpGbl->hDD),
                                   (PDD_GETINTERNALMOCOMPDATA)pGetInternalData));
}

/*****************************Private*Routine******************************\
* CreateMoComp
*
* History:
*  18-Nov-1997 -by- smac
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DdCreateMoComp(
    LPDDHAL_CREATEMOCOMPDATA pCreateMoComp
    )
{
    HANDLE  h;

    h = NtGdiDdCreateMoComp(DD_HANDLE(pCreateMoComp->lpDD->lpGbl->hDD),
                               (PDD_CREATEMOCOMPDATA)pCreateMoComp);

    pCreateMoComp->lpMoComp->hMoComp = h;

    return(DDHAL_DRIVER_HANDLED);

}

/*****************************Private*Routine******************************\
* DestroyMoComp
*
* History:
*  18-Nov-1997 -by- smac
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DdDestroyMoComp(
    LPDDHAL_DESTROYMOCOMPDATA pDestroyMoComp
    )
{
    return(NtGdiDdDestroyMoComp((HANDLE)pDestroyMoComp->lpMoComp->hMoComp,
                                (PDD_DESTROYMOCOMPDATA)pDestroyMoComp));
}

/*****************************Private*Routine******************************\
* BeginMoCompFrame
*
* History:
*  18-Nov-1997 -by- smac
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DdBeginMoCompFrame(
    LPDDHAL_BEGINMOCOMPFRAMEDATA pBeginFrame
    )
{
    LPDDRAWI_DDRAWSURFACE_LCL *lpOriginal=NULL;
    LPDDRAWI_DDRAWSURFACE_LCL lpOrigDest=NULL;
    DWORD i;
    DWORD dwRet;

    if( pBeginFrame->lpDestSurface != NULL )
    {
        lpOrigDest = pBeginFrame->lpDestSurface;
        pBeginFrame->lpDestSurface = (LPDDRAWI_DDRAWSURFACE_LCL)
            pBeginFrame->lpDestSurface->hDDSurface;
    }

    dwRet = NtGdiDdBeginMoCompFrame((HANDLE)pBeginFrame->lpMoComp->hMoComp,
                                   (PDD_BEGINMOCOMPFRAMEDATA)pBeginFrame);

    if( lpOrigDest )
    {
        pBeginFrame->lpDestSurface = lpOrigDest;
    }

    return dwRet;
}

/*****************************Private*Routine******************************\
* EndMoCompFrame
*
* History:
*  18-Nov-1997 -by- smac
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DdEndMoCompFrame(
    LPDDHAL_ENDMOCOMPFRAMEDATA pEndFrame
    )
{
    return(NtGdiDdEndMoCompFrame((HANDLE)pEndFrame->lpMoComp->hMoComp,
                                 (PDD_ENDMOCOMPFRAMEDATA)pEndFrame));
}

/*****************************Private*Routine******************************\
* RenderMoComp
*
* History:
*  18-Nov-1997 -by- smac
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DdRenderMoComp(
    LPDDHAL_RENDERMOCOMPDATA pRender
    )
{
    DWORD i;
    DWORD dwRet;

    for( i = 0; i < pRender->dwNumBuffers; i++ )
    {
        pRender->lpBufferInfo[i].lpPrivate =
            pRender->lpBufferInfo[i].lpCompSurface;
        pRender->lpBufferInfo[i].lpCompSurface = (LPDDRAWI_DDRAWSURFACE_LCL)
            pRender->lpBufferInfo[i].lpCompSurface->hDDSurface;
    }

    dwRet = NtGdiDdRenderMoComp((HANDLE)pRender->lpMoComp->hMoComp,
                                (PDD_RENDERMOCOMPDATA)pRender);

    for( i = 0; i < pRender->dwNumBuffers; i++ )
    {
        pRender->lpBufferInfo[i].lpCompSurface = (LPDDRAWI_DDRAWSURFACE_LCL)
            pRender->lpBufferInfo[i].lpPrivate;
    }
    return dwRet;
}

/*****************************Private*Routine******************************\
* QueryMoCompStatus
*
* History:
*  18-Nov-1997 -by- smac
* Wrote it.
\**************************************************************************/
DWORD
WINAPI
DdQueryMoCompStatus(
    LPDDHAL_QUERYMOCOMPSTATUSDATA pQueryStatus
    )
{
    DWORD dwRet;
    LPDDRAWI_DDRAWSURFACE_LCL surf_lcl;

    surf_lcl = pQueryStatus->lpSurface;
    pQueryStatus->lpSurface = (LPDDRAWI_DDRAWSURFACE_LCL) surf_lcl->hDDSurface;
    dwRet = NtGdiDdQueryMoCompStatus((HANDLE)pQueryStatus->lpMoComp->hMoComp,
                                (PDD_QUERYMOCOMPSTATUSDATA)pQueryStatus);
    pQueryStatus->lpSurface = surf_lcl;

    return dwRet;
}

/*****************************Private*Routine******************************\
* DdAlphaBlt
*
* History:
*  24-Nov-1997 -by- Scott MacDonald [smac]
* Wrote it.
\**************************************************************************/

DWORD
WINAPI
DdAlphaBlt(
    LPDDHAL_BLTDATA pBlt
    )
{
    HANDLE hSurfaceSrc = (pBlt->lpDDSrcSurface != NULL)
                       ? (HANDLE) pBlt->lpDDSrcSurface->hDDSurface : 0;

    return(NtGdiDdAlphaBlt((HANDLE) pBlt->lpDDDestSurface->hDDSurface,
                      hSurfaceSrc,
                      (PDD_BLTDATA) pBlt));
}

/*****************************Private*Routine******************************\
* DdBlt
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
WINAPI
DdBlt(
    LPDDHAL_BLTDATA pBlt
    )
{
    HANDLE hSurfaceSrc = (pBlt->lpDDSrcSurface != NULL)
                       ? (HANDLE) pBlt->lpDDSrcSurface->hDDSurface : 0;

    return(NtGdiDdBlt((HANDLE) pBlt->lpDDDestSurface->hDDSurface,
                      hSurfaceSrc,
                      (PDD_BLTDATA) pBlt));
}

/*****************************Private*Routine******************************\
* DdFlip
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdFlip(
    LPDDHAL_FLIPDATA pFlip
    )
{
    HANDLE hSurfTargLeft=NULL;
    HANDLE hSurfCurrLeft=NULL;
    if (pFlip->dwFlags & DDFLIP_STEREO)
    { if (pFlip->lpSurfTargLeft!=NULL && pFlip->lpSurfCurrLeft!=NULL)
      { 
         hSurfTargLeft=(HANDLE)pFlip->lpSurfTargLeft->hDDSurface;
         hSurfCurrLeft=(HANDLE)pFlip->lpSurfCurrLeft->hDDSurface;
      }
    } 
    return(NtGdiDdFlip((HANDLE) pFlip->lpSurfCurr->hDDSurface,
                       (HANDLE) pFlip->lpSurfTarg->hDDSurface,
                       hSurfCurrLeft,
                       hSurfTargLeft,
                       (PDD_FLIPDATA) pFlip));
}

/*****************************Private*Routine******************************\
* DdLock
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdLock(
    LPDDHAL_LOCKDATA pLock
    )
{
    return(NtGdiDdLock((HANDLE) pLock->lpDDSurface->hDDSurface,
                       (PDD_LOCKDATA) pLock,
                       NULL));
}

/*****************************Private*Routine******************************\
* DdUnlock
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdUnlock(
    LPDDHAL_UNLOCKDATA pUnlock
    )
{
    return(NtGdiDdUnlock((HANDLE) pUnlock->lpDDSurface->hDDSurface,
                         (PDD_UNLOCKDATA) pUnlock));
}

/*****************************Private*Routine******************************\
* DdLockD3D
*
* History:
*  20-Jan-1998 -by- Anantha Kancherla [anankan]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdLockD3D(
    LPDDHAL_LOCKDATA pLock
    )
{
    return(NtGdiDdLockD3D((HANDLE) pLock->lpDDSurface->hDDSurface,
                       (PDD_LOCKDATA) pLock));
}

/*****************************Private*Routine******************************\
* DdUnlockD3D
*
* History:
*  20-Jan-1998 -by- Anantha Kancherla [anankan]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdUnlockD3D(
    LPDDHAL_UNLOCKDATA pUnlock
    )
{
    return(NtGdiDdUnlockD3D((HANDLE) pUnlock->lpDDSurface->hDDSurface,
                         (PDD_UNLOCKDATA) pUnlock));
}

/*****************************Private*Routine******************************\
* DdGetBltStatus
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdGetBltStatus(
    LPDDHAL_GETBLTSTATUSDATA pGetBltStatus
    )
{
    return(NtGdiDdGetBltStatus((HANDLE) pGetBltStatus->lpDDSurface->hDDSurface,
                               (PDD_GETBLTSTATUSDATA) pGetBltStatus));
}

/*****************************Private*Routine******************************\
* DdGetFlipStatus
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdGetFlipStatus(
    LPDDHAL_GETFLIPSTATUSDATA pGetFlipStatus
    )
{
    return(NtGdiDdGetFlipStatus((HANDLE) pGetFlipStatus->lpDDSurface->hDDSurface,
                               (PDD_GETFLIPSTATUSDATA) pGetFlipStatus));
}

/*****************************Private*Routine******************************\
* DdWaitForVerticalBlank
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdWaitForVerticalBlank(
    LPDDHAL_WAITFORVERTICALBLANKDATA pWaitForVerticalBlank
    )
{
    return(NtGdiDdWaitForVerticalBlank(DD_HANDLE(pWaitForVerticalBlank->lpDD->hDD),
                (PDD_WAITFORVERTICALBLANKDATA) pWaitForVerticalBlank));
}

/*****************************Private*Routine******************************\
* DdCanCreateSurface
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdCanCreateSurface(
    LPDDHAL_CANCREATESURFACEDATA pCanCreateSurface
    )
{
    return(NtGdiDdCanCreateSurface(DD_HANDLE(pCanCreateSurface->lpDD->hDD),
                                (PDD_CANCREATESURFACEDATA) pCanCreateSurface));
}

/*****************************Private*Routine******************************\
* DdCreateSurface
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdCreateSurface(
    LPDDHAL_CREATESURFACEDATA pCreateSurface
    )
{
    ULONG                       i;
    LPDDSURFACEDESC             pSurfaceDesc;
    LPDDRAWI_DDRAWSURFACE_LCL   pSurfaceLocal;
    LPDDRAWI_DDRAWSURFACE_GBL   pSurfaceGlobal;
    DD_SURFACE_GLOBAL           SurfaceGlobal;
    DD_SURFACE_LOCAL            SurfaceLocal;
    DD_SURFACE_MORE             SurfaceMore;
    HANDLE                      hInSurface;
    HANDLE                      hOutSurface;
    DD_SURFACE_LOCAL*           pDDSurfaceLocal = NULL;
    DD_SURFACE_GLOBAL*          pDDSurfaceGlobal = NULL;
    DD_SURFACE_MORE*            pDDSurfaceMore = NULL;
    HANDLE*                     phInSurface = NULL;
    HANDLE*                     phOutSurface = NULL;
    DWORD                       dwRet;
    DWORD                       dwNumToCreate;

    // For every surface, convert to the kernel's surface data structure,
    // call the kernel, then convert back:

    // All video memory heaps are handled in the kernel so if
    // the kernel call cannot create a surface then user-mode can't
    // either.  Always returns DRIVER_HANDLED to enforce this.
    dwRet = DDHAL_DRIVER_HANDLED;

    // If we are only creating one, no need to allocate gobs of memory; otherwise, do it

    dwNumToCreate = pCreateSurface->dwSCnt;
    if (pCreateSurface->dwSCnt == 1)
    {
        pDDSurfaceLocal  = &SurfaceLocal;
        pDDSurfaceGlobal  = &SurfaceGlobal;
        pDDSurfaceMore  = &SurfaceMore;
        phInSurface = &hInSurface;
        phOutSurface = &hOutSurface;

        //
        // Wow64 genthnk will automatically thunk these structures, however,
        // since these structures are pointer dependent, we need to make sure
        // to NULL out these pointers so that Wow64 won't thunk them
        //

        RtlZeroMemory(pDDSurfaceLocal, sizeof(*pDDSurfaceLocal));
        RtlZeroMemory(pDDSurfaceGlobal, sizeof(*pDDSurfaceGlobal));
        RtlZeroMemory(pDDSurfaceMore, sizeof(*pDDSurfaceMore));
    }
    else
    {
        pDDSurfaceLocal = (DD_SURFACE_LOCAL*) LocalAlloc(LMEM_ZEROINIT,
            sizeof(DD_SURFACE_LOCAL) * dwNumToCreate);

        pDDSurfaceGlobal = (DD_SURFACE_GLOBAL*) LocalAlloc(LMEM_ZEROINIT,
            sizeof(DD_SURFACE_GLOBAL) * dwNumToCreate);

        pDDSurfaceMore = (DD_SURFACE_MORE*) LocalAlloc(LMEM_ZEROINIT,
            sizeof(DD_SURFACE_MORE) * dwNumToCreate);

        phInSurface = (HANDLE*) LocalAlloc(LMEM_ZEROINIT,
            sizeof(HANDLE) * dwNumToCreate);

        phOutSurface = (HANDLE*) LocalAlloc(LMEM_ZEROINIT,
            sizeof(HANDLE) * dwNumToCreate);

        if ((pDDSurfaceLocal == NULL) ||
            (pDDSurfaceGlobal == NULL) ||
            (pDDSurfaceMore == NULL) ||
            (phInSurface == NULL) ||
            (phOutSurface == NULL))
        {
            pCreateSurface->ddRVal = DDERR_OUTOFMEMORY;
            goto CleanupCreate;
        }
    }

    for (i = 0; i < dwNumToCreate; i++)
    {
        pSurfaceLocal  = pCreateSurface->lplpSList[i];
        pSurfaceGlobal = pSurfaceLocal->lpGbl;
        pSurfaceDesc   = pCreateSurface->lpDDSurfaceDesc;

        // Make sure there's always a valid pixel format for the surface:

        if (pSurfaceLocal->dwFlags & DDRAWISURF_HASPIXELFORMAT)
        {
            pDDSurfaceGlobal[i].ddpfSurface        = pSurfaceGlobal->ddpfSurface;
            pDDSurfaceGlobal[i].ddpfSurface.dwSize = sizeof(DDPIXELFORMAT);
        }
        else
        {
            pDDSurfaceGlobal[i].ddpfSurface = pSurfaceGlobal->lpDD->vmiData.ddpfDisplay;
        }

        pDDSurfaceGlobal[i].wWidth       = pSurfaceGlobal->wWidth;
        pDDSurfaceGlobal[i].wHeight      = pSurfaceGlobal->wHeight;
        pDDSurfaceGlobal[i].lPitch       = pSurfaceGlobal->lPitch;
        pDDSurfaceGlobal[i].fpVidMem     = pSurfaceGlobal->fpVidMem;
        pDDSurfaceGlobal[i].dwBlockSizeX = pSurfaceGlobal->dwBlockSizeX;
        pDDSurfaceGlobal[i].dwBlockSizeY = pSurfaceGlobal->dwBlockSizeY;

        pDDSurfaceLocal[i].ddsCaps       = pSurfaceLocal->ddsCaps;
        // Copy the driver managed flag
        pDDSurfaceLocal[i].dwFlags      &= ~DDRAWISURF_DRIVERMANAGED;
        pDDSurfaceLocal[i].dwFlags      |= (pSurfaceLocal->dwFlags & DDRAWISURF_DRIVERMANAGED);

        // lpSurfMore will be NULL if called from dciman
        if (pSurfaceLocal->lpSurfMore)
        {
            pDDSurfaceMore[i].ddsCapsEx       = pSurfaceLocal->lpSurfMore->ddsCapsEx;
            pDDSurfaceMore[i].dwSurfaceHandle = pSurfaceLocal->lpSurfMore->dwSurfaceHandle;
        }
        else
        {
            pDDSurfaceMore[i].ddsCapsEx.dwCaps2 = 0;
            pDDSurfaceMore[i].ddsCapsEx.dwCaps3 = 0;
            pDDSurfaceMore[i].ddsCapsEx.dwCaps4 = 0;
            pDDSurfaceMore[i].dwSurfaceHandle   = 0;
        }

        phInSurface[i] = (HANDLE) pSurfaceLocal->hDDSurface;
    }

    // Preset an error in case the kernel can't write status
    // back for some reason.
    pCreateSurface->ddRVal     = DDERR_GENERIC;

    dwRet = NtGdiDdCreateSurface(DD_HANDLE(pCreateSurface->lpDD->hDD),
                                 phInSurface,
                                 pSurfaceDesc,
                                 pDDSurfaceGlobal,
                                 pDDSurfaceLocal,
                                 pDDSurfaceMore,
                                 (PDD_CREATESURFACEDATA) pCreateSurface,
                                 phOutSurface);

    ASSERTGDI(dwRet == DDHAL_DRIVER_HANDLED,
              "NtGdiDdCreateSurface returned NOTHANDLED");

    for (i = 0; i < dwNumToCreate; i++)
    {
        pSurfaceLocal  = pCreateSurface->lplpSList[i];
        pSurfaceGlobal = pSurfaceLocal->lpGbl;
        if (pCreateSurface->ddRVal != DD_OK)
        {
            // Surface creation failed.  Nothing in user-mode can
            // create video memory surfaces so this whole call
            // fails.

            // Ensure the current surface and all following surfaces
            // have a zero fpVidMem to indicate they weren't
            // allocated.
            pCreateSurface->lplpSList[i]->lpGbl->fpVidMem = 0;

            // Handle may have been allocated by DdAttachSurface
        if (pSurfaceLocal->hDDSurface != 0)
                NtGdiDdDeleteSurfaceObject((HANDLE)pSurfaceLocal->hDDSurface);            

            pSurfaceLocal->hDDSurface = 0;
        }
        else
        {
            pSurfaceLocal->hDDSurface = (ULONG_PTR) phOutSurface[i];
        }

        pSurfaceGlobal->lPitch       = pDDSurfaceGlobal[i].lPitch;
        pSurfaceGlobal->fpVidMem     = pDDSurfaceGlobal[i].fpVidMem;
        pSurfaceGlobal->dwBlockSizeX = pDDSurfaceGlobal[i].dwBlockSizeX;
        pSurfaceGlobal->dwBlockSizeY = pDDSurfaceGlobal[i].dwBlockSizeY;
        if (pSurfaceLocal->dwFlags & DDRAWISURF_HASPIXELFORMAT)
        {
            pSurfaceGlobal->ddpfSurface = pDDSurfaceGlobal[i].ddpfSurface;
        }

        pSurfaceLocal->ddsCaps = pDDSurfaceLocal[i].ddsCaps;

        if (pSurfaceLocal->lpSurfMore)
        {
            pSurfaceLocal->lpSurfMore->ddsCapsEx = pDDSurfaceMore[i].ddsCapsEx;
        }

    }

    CleanupCreate:
    if (dwNumToCreate > 1)
    {
        if (pDDSurfaceLocal != NULL)
        {
            LocalFree(pDDSurfaceLocal);
        }
        if (pDDSurfaceGlobal != NULL)
        {
            LocalFree(pDDSurfaceGlobal);
        }
        if (pDDSurfaceMore != NULL)
        {
            LocalFree(pDDSurfaceMore);
        }
        if (phInSurface != NULL)
        {
            LocalFree(phInSurface);
        }
        if (phOutSurface != NULL)
        {
            LocalFree(phOutSurface);
        }
    }

    // fpVidMem is the real per-surface return value, so for the function
    // return value we'll simply return that of the last call:

    return(dwRet);
}

/*****************************Private*Routine******************************\
* DdDestroySurface
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdDestroySurface(
    LPDDHAL_DESTROYSURFACEDATA pDestroySurface
    )
{
    DWORD                       dwRet;
    LPDDRAWI_DDRAWSURFACE_LCL   pSurfaceLocal;

    dwRet = DDHAL_DRIVER_NOTHANDLED;
    pSurfaceLocal = pDestroySurface->lpDDSurface;

    if (pSurfaceLocal->hDDSurface != 0)
    {
        if((pSurfaceLocal->dwFlags & DDRAWISURF_DRIVERMANAGED) &&
            (pSurfaceLocal->dwFlags & DDRAWISURF_INVALID))
            dwRet = NtGdiDdDestroySurface((HANDLE) pSurfaceLocal->hDDSurface, FALSE);
        else
            dwRet = NtGdiDdDestroySurface((HANDLE) pSurfaceLocal->hDDSurface, TRUE);
    }

    return(dwRet);
}

/*****************************Private*Routine******************************\
* DdCanCreateD3DBuffer
*
* History:
*  20-Jan-1998 -by- Anantha Kancherla [anankan]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdCanCreateD3DBuffer(
    LPDDHAL_CANCREATESURFACEDATA pCanCreateSurface
    )
{
    return(NtGdiDdCanCreateD3DBuffer(DD_HANDLE(pCanCreateSurface->lpDD->hDD),
                                (PDD_CANCREATESURFACEDATA) pCanCreateSurface));
}

/*****************************Private*Routine******************************\
* DdCreateD3DBuffer
*
* History:
*  20-Jan-1998 -by- Anantha Kancherla [anankan]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdCreateD3DBuffer(
    LPDDHAL_CREATESURFACEDATA pCreateSurface
    )
{
    ULONG                       i;
    LPDDSURFACEDESC             pSurfaceDesc;
    LPDDRAWI_DDRAWSURFACE_LCL   pSurfaceLocal;
    LPDDRAWI_DDRAWSURFACE_GBL   pSurfaceGlobal;
    DD_SURFACE_GLOBAL           SurfaceGlobal;
    DD_SURFACE_LOCAL            SurfaceLocal;
    DD_SURFACE_MORE             SurfaceMore;
    HANDLE                      hSurface;
    DWORD                       dwRet;

    // For every surface, convert to the kernel's surface data structure,
    // call the kernel, then convert back:

    dwRet = DDHAL_DRIVER_NOTHANDLED;

    //
    // Wow64 genthnk will automatically thunk these structures, however,
    // since these structures are pointer dependent, we need to make sure
    // to NULL out these pointers so that Wow64 won't thunk them
    //
    RtlZeroMemory(&SurfaceLocal, sizeof(SurfaceLocal));
    RtlZeroMemory(&SurfaceGlobal, sizeof(SurfaceGlobal));
    RtlZeroMemory(&SurfaceMore, sizeof(SurfaceMore));

    pSurfaceLocal  = pCreateSurface->lplpSList[0];
    pSurfaceGlobal = pSurfaceLocal->lpGbl;
    pSurfaceDesc   = pCreateSurface->lpDDSurfaceDesc;
    pCreateSurface->dwSCnt = 1;

    SurfaceGlobal.wWidth       = pSurfaceGlobal->wWidth;
    SurfaceGlobal.wHeight      = pSurfaceGlobal->wHeight;
    SurfaceGlobal.lPitch       = pSurfaceGlobal->lPitch;
    SurfaceGlobal.fpVidMem     = pSurfaceGlobal->fpVidMem;
    SurfaceGlobal.dwBlockSizeX = pSurfaceGlobal->dwBlockSizeX;
    SurfaceGlobal.dwBlockSizeY = pSurfaceGlobal->dwBlockSizeY;

    SurfaceLocal.dwFlags       = pSurfaceLocal->dwFlags;
    SurfaceLocal.ddsCaps       = pSurfaceLocal->ddsCaps;

    SurfaceMore.ddsCapsEx       = pSurfaceLocal->lpSurfMore->ddsCapsEx;
    SurfaceMore.dwSurfaceHandle = pSurfaceLocal->lpSurfMore->dwSurfaceHandle;

    dwRet = NtGdiDdCreateD3DBuffer(DD_HANDLE(pCreateSurface->lpDD->hDD),
                                 (HANDLE*) &pSurfaceLocal->hDDSurface,
                                 pSurfaceDesc,
                                 &SurfaceGlobal,
                                 &SurfaceLocal,
                                 &SurfaceMore,
                                 (PDD_CREATESURFACEDATA) pCreateSurface,
                                 &hSurface);

    pSurfaceGlobal->lPitch       = SurfaceGlobal.lPitch;
    pSurfaceGlobal->fpVidMem     = SurfaceGlobal.fpVidMem;
    pSurfaceGlobal->dwBlockSizeX = SurfaceGlobal.dwBlockSizeX;
    pSurfaceGlobal->dwBlockSizeY = SurfaceGlobal.dwBlockSizeY;
    if (hSurface)
    {
        pCreateSurface->lplpSList[0]->hDDSurface = (ULONG_PTR) hSurface;
    }

    // fpVidMem is the real per-surface return value, so for the function
    // return value we'll simply return that of the last call:

    return(dwRet);
}

/*****************************Private*Routine******************************\
* DdDestroyD3DBuffer
*
* History:
*  20-Jan-1998 -by- Anantha Kancherla [anankan]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdDestroyD3DBuffer(
    LPDDHAL_DESTROYSURFACEDATA pDestroySurface
    )
{
    DWORD                       dwRet;
    LPDDRAWI_DDRAWSURFACE_LCL   pSurfaceLocal;

    dwRet = DDHAL_DRIVER_NOTHANDLED;
    pSurfaceLocal = pDestroySurface->lpDDSurface;

    if (pSurfaceLocal->hDDSurface != 0)
    {
        dwRet = NtGdiDdDestroyD3DBuffer((HANDLE) pSurfaceLocal->hDDSurface);
    }

    return(dwRet);
}

/*****************************Private*Routine******************************\
* DdSetColorKey
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdSetColorKey(
    LPDDHAL_SETCOLORKEYDATA pSetColorKey
    )
{
    return(NtGdiDdSetColorKey((HANDLE) pSetColorKey->lpDDSurface->hDDSurface,
                              (PDD_SETCOLORKEYDATA) pSetColorKey));
}

/*****************************Private*Routine******************************\
* DdAddAttachedSurface
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdAddAttachedSurface(
    LPDDHAL_ADDATTACHEDSURFACEDATA pAddAttachedSurface
    )
{
    return(NtGdiDdAddAttachedSurface((HANDLE) pAddAttachedSurface->lpDDSurface->hDDSurface,
                                     (HANDLE) pAddAttachedSurface->lpSurfAttached->hDDSurface,
                                     (PDD_ADDATTACHEDSURFACEDATA) pAddAttachedSurface));
}

/*****************************Private*Routine******************************\
* DdUpdateOverlay
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdUpdateOverlay(
    LPDDHAL_UPDATEOVERLAYDATA pUpdateOverlay
    )
{
    // Kernel doesn't track the color keys in the surface, so we'll always
    // convert any calls that reference them to ones where we explicitly
    // pass the key as a parameter, and pull the key out of the user-mode
    // surface:

    if (pUpdateOverlay->dwFlags & DDOVER_KEYDEST)
    {
        pUpdateOverlay->dwFlags &= ~DDOVER_KEYDEST;
        pUpdateOverlay->dwFlags |=  DDOVER_KEYDESTOVERRIDE;

        pUpdateOverlay->overlayFX.dckDestColorkey
            = pUpdateOverlay->lpDDDestSurface->ddckCKDestOverlay;
    }

    if (pUpdateOverlay->dwFlags & DDOVER_KEYSRC)
    {
        pUpdateOverlay->dwFlags &= ~DDOVER_KEYSRC;
        pUpdateOverlay->dwFlags |=  DDOVER_KEYSRCOVERRIDE;

        pUpdateOverlay->overlayFX.dckSrcColorkey
            = pUpdateOverlay->lpDDSrcSurface->ddckCKSrcOverlay;
    }

    return(NtGdiDdUpdateOverlay((HANDLE) pUpdateOverlay->lpDDDestSurface->hDDSurface,
                                (HANDLE) pUpdateOverlay->lpDDSrcSurface->hDDSurface,
                                (PDD_UPDATEOVERLAYDATA) pUpdateOverlay));
}

/*****************************Private*Routine******************************\
* DdSetOverlayPosition
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdSetOverlayPosition(
    LPDDHAL_SETOVERLAYPOSITIONDATA pSetOverlayPosition
    )
{
    return(NtGdiDdSetOverlayPosition((HANDLE) pSetOverlayPosition->lpDDSrcSurface->hDDSurface,
                            (HANDLE) pSetOverlayPosition->lpDDDestSurface->hDDSurface,
                            (PDD_SETOVERLAYPOSITIONDATA) pSetOverlayPosition));
}

/*****************************Private*Routine******************************\
* DdGetScanLine
*
* History:
*  3-Dec-1995 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdGetScanLine(
    LPDDHAL_GETSCANLINEDATA pGetScanLine
    )
{
    return(NtGdiDdGetScanLine(DD_HANDLE(pGetScanLine->lpDD->hDD),
                              (PDD_GETSCANLINEDATA) pGetScanLine));
}

/*****************************Private*Routine******************************\
* DdSetExclusiveMode
*
* History:
*  22-Apr-1998 -by- John Stephens [johnstep]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdSetExclusiveMode(
    LPDDHAL_SETEXCLUSIVEMODEDATA pSetExclusiveMode
    )
{
    return(NtGdiDdSetExclusiveMode(
                DD_HANDLE(pSetExclusiveMode->lpDD->hDD),
                (PDD_SETEXCLUSIVEMODEDATA) pSetExclusiveMode));
}

/*****************************Private*Routine******************************\
* DdFlipToGDISurface
*
* History:
*  22-Apr-1998 -by- John Stephens [johnstep]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdFlipToGDISurface(
    LPDDHAL_FLIPTOGDISURFACEDATA pFlipToGDISurface
    )
{
    return(NtGdiDdFlipToGDISurface(
                DD_HANDLE(pFlipToGDISurface->lpDD->hDD),
                (PDD_FLIPTOGDISURFACEDATA) pFlipToGDISurface));
}

/*****************************Private*Routine******************************\
* DdGetAvailDriverMemory
*
* History:
*  16-Feb-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdGetAvailDriverMemory(
    LPDDHAL_GETAVAILDRIVERMEMORYDATA pGetAvailDriverMemory
    )
{
    return(NtGdiDdGetAvailDriverMemory(
                DD_HANDLE(pGetAvailDriverMemory->lpDD->hDD),
                (PDD_GETAVAILDRIVERMEMORYDATA) pGetAvailDriverMemory));
}

/*****************************Private*Routine******************************\
* DdColorControl
*
* History:
*  16-Feb-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdColorControl(
    LPDDHAL_COLORCONTROLDATA pColorControl
    )
{
    return(NtGdiDdColorControl((HANDLE) pColorControl->lpDDSurface->hDDSurface,
                               (PDD_COLORCONTROLDATA) pColorControl));
}

/*****************************Private*Routine******************************\
* DdCreateSurfaceEx
*
* History:
*  19-Feb-1999 -by- Kan Qiu [kanqiu]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdCreateSurfaceEx( 
    LPDDHAL_CREATESURFACEEXDATA pCreateSurfaceExData
    )
{
    pCreateSurfaceExData->ddRVal=NtGdiDdCreateSurfaceEx( 
        DD_HANDLE(pCreateSurfaceExData->lpDDLcl->lpGbl->hDD),
        (HANDLE)(pCreateSurfaceExData->lpDDSLcl->hDDSurface),
        pCreateSurfaceExData->lpDDSLcl->lpSurfMore->dwSurfaceHandle);
    return  DDHAL_DRIVER_HANDLED;  
}

/*****************************Private*Routine******************************\
* DdGetDriverInfo
*
* History:
*  16-Feb-1997 -by- J. Andrew Goossen [andrewgo]
* Wrote it.
\**************************************************************************/

DWORD
APIENTRY
DdGetDriverInfo(
    LPDDHAL_GETDRIVERINFODATA lpGetDriverInfoData
    )
{
    DD_GETDRIVERINFODATA    GetDriverInfoData;
    DWORD                   dwRet;
    HANDLE                  hDirectDraw;

    GetDriverInfoData.guidInfo = lpGetDriverInfoData->guidInfo;
    hDirectDraw = DD_HANDLE( (HANDLE) lpGetDriverInfoData->dwContext );

    if (IsEqualIID(&lpGetDriverInfoData->guidInfo, &GUID_VideoPortCallbacks))
    {
        DD_VIDEOPORTCALLBACKS           VideoPortCallBacks;
        LPDDHAL_DDVIDEOPORTCALLBACKS    lpVideoPortCallBacks;

        // Translate VideoPort call-backs to user-mode:

        lpVideoPortCallBacks             = lpGetDriverInfoData->lpvData;
        GetDriverInfoData.lpvData        = &VideoPortCallBacks;
        GetDriverInfoData.dwExpectedSize = sizeof(VideoPortCallBacks);

        dwRet = NtGdiDdGetDriverInfo(hDirectDraw, &GetDriverInfoData);

        RtlZeroMemory(lpVideoPortCallBacks, sizeof(*lpVideoPortCallBacks));
        lpGetDriverInfoData->dwActualSize = sizeof(*lpVideoPortCallBacks);
        lpVideoPortCallBacks->dwSize      = sizeof(*lpVideoPortCallBacks);
        lpVideoPortCallBacks->dwFlags = VideoPortCallBacks.dwFlags
                                       | DDHAL_VPORT32_CREATEVIDEOPORT
                                       | DDHAL_VPORT32_DESTROY
                                       | DDHAL_VPORT32_UPDATE
                                       | DDHAL_VPORT32_FLIP;
        lpVideoPortCallBacks->dwFlags &= ~(DDHAL_VPORT32_GETAUTOFLIPSURF);

        lpVideoPortCallBacks->CreateVideoPort = DvpCreateVideoPort;
        lpVideoPortCallBacks->DestroyVideoPort = DvpDestroyVideoPort;
        lpVideoPortCallBacks->UpdateVideoPort = DvpUpdateVideoPort;
        lpVideoPortCallBacks->FlipVideoPort = DvpFlipVideoPort;

        if (VideoPortCallBacks.CanCreateVideoPort)
        {
            lpVideoPortCallBacks->CanCreateVideoPort = DvpCanCreateVideoPort;
        }
        if (VideoPortCallBacks.GetVideoPortBandwidth)
        {
            lpVideoPortCallBacks->GetVideoPortBandwidth = DvpGetVideoPortBandwidth;
        }
        if (VideoPortCallBacks.GetVideoPortInputFormats)
        {
            lpVideoPortCallBacks->GetVideoPortInputFormats = DvpGetVideoPortInputFormats;
        }
        if (VideoPortCallBacks.GetVideoPortOutputFormats)
        {
            lpVideoPortCallBacks->GetVideoPortOutputFormats = DvpGetVideoPortOutputFormats;
        }
        if (VideoPortCallBacks.GetVideoPortField)
        {
            lpVideoPortCallBacks->GetVideoPortField = DvpGetVideoPortField;
        }
        if (VideoPortCallBacks.GetVideoPortLine)
        {
            lpVideoPortCallBacks->GetVideoPortLine = DvpGetVideoPortLine;
        }
        if (VideoPort