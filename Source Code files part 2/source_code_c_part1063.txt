MMTIMER_DEV

    //
    // Now that we have a warm fuzzy, try to approximate a workload that
    // will keep us busy for the remainder of microsoeconds
    //
    while (TargetTicks > ElapsedTicks) {

#ifdef i386
        _asm { rep nop }
#endif

        i = (TargetTicks - ElapsedTicks) * CyclesStalled / ElapsedTicks;
        CyclesStalled += i;

        while (i--) {
#ifdef i386
            _asm {
                xor eax, eax
                cpuid
            }
#else
            Mirror = 0;
            for (j = 0; j < ULONG_BITS; j++) {
                Mirror <<= 1;
                Mirror |= EndCount & 1;
                EndCount >>= 1;
            }
            EndCount = Mirror;
#endif // i386
        }

        EndCount = ETBContext.EventTimer->MainCounter;
#if DBG || MMTIMER_DEV
        CounterReads++;
#endif
        ElapsedTicks = HalpmmTimerTicks(StartCount, EndCount);
    }

    //
    // Decrement MinimumLoopCount every 0x100 calls so we don't accidentally
    // wind up stalling for longer periods
    //
    StallCount++;
    if ((StallCount == 0) && (MinLoopCount > MIN_LOOP_QUANTUM)) {
        MinLoopCount -= MIN_LOOP_QUANTUM;
    }
}


VOID
HalpmmTimerCalibratePerfCount(
    IN LONG volatile *Number,
    IN ULONGLONG NewCount
    )
/*++

Routine Description:

    This routine resets the performance counter value for the current
    processor to zero, the reset is done such that the resulting value
    is closely synchronized with other processors in the configuration

Arguments:

    Number - Supplies a pointer to count of the number of processors in
             the configuration

    NewCount - Supplies the value to synchronize the counter too

Return Value:

    None

--*/
{
    ULONG MainCount;

    //
    // If this isn't the primary processor, then return
    //
    if (KeGetPcr()->Prcb->Number != HAL_PRIMARY_PROCESSOR) {
        return;
    }

    MainCount = ETBContext.EventTimer->MainCounter;

    PerfCount = NewCount;

    Offset = PerfCount - MainCount;
}


LARGE_INTEGER
HalpmmTimerQueryPerfCount(
   OUT PLARGE_INTEGER PerformanceFrequency OPTIONAL
   )
/*++

Routine Description:

    This routine returns current 64-bit performance counter and,
    optionally, the Performance Frequency

    N.B. The performace counter returned by this routine is
    not necessary the value when this routine is just entered,
    The value returned is actually the counter value at any point
    between the routine is entered and is exited

Arguments:

    PerformanceFrequency - optionally, supplies the address of a
                           variable to receive the performance counter
                           frequency

Return Value:

    Current value of the performance counter will be returned

--*/
{
    ULONG MainCount;
    LARGE_INTEGER li;

    //
    // Clock period is in nanoseconds, help the calculation remain
    // integer by asserting multi media HW clock frequency is between
    // 1MHz and 1GHz, with a period between 1ns and 1Kns, seems
    // reasonable to me?
    //
    if (PerformanceFrequency) {
        
        ASSERT((ETBContext.ClockPeriod > 0) &&
               (ETBContext.ClockPeriod <= 1000));

        PerformanceFrequency->QuadPart =
            (1000 / ETBContext.ClockPeriod) * __1MHz;
    }

    //
    // Read main counter
    //
    MainCount = ETBContext.EventTimer->MainCounter;

    //
    // Check if our 32-bit counter has wrapped since we took our last
    // clock tick
    //
    li.QuadPart = (PerfCount - Offset > MainCount) ?
            Offset + __4GB + MainCount:
            MainCount + Offset;
    return li;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\mmtimer.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    mmTimer.h

Abstract:

    This module contains multimedia event timer definitions

Author:

    Eric Nelson (enelson) July 7, 2000

Revision History:

--*/

#ifndef __MMTIMER_H__
#define __MMTIMER_H__

#define ETDT_SIGNATURE  0x54445445      // "ETDT"

//
// Event Timer Description Table
//
typedef struct _EVENT_TIMER_DESCRIPTION_TABLE {

    DESCRIPTION_HEADER  Header;

    //
    // Hardware ID of Event Timer Block:
    // Contents of General_Cap & ID Reg of Timer Block
    // [31:16] = PCI Vendor ID of 1st Timer Block
    // [5] = Legacy IRQ Routing Capable
    // [14] = Reserved
    // [12:8] = Number of Comparitors in 1st Timer Block
    // [7:0] = Hardware Rev ID
    //
    ULONG EventTimerBlockID;

    //
    // Base address of Event Timer Block
    //
    // Each Event Timer Block consumes 1K of system memory,
    // regardless of how many comparators are actually implemented
    // by hardware
    //
    ULONG BaseAddress;

} EVENT_TIMER_DESCRIPTION_TABLE, *PEVENT_TIMER_DESCRIPTION_TABLE;

#define ANYSIZE_ARRAY 1

#define ON  1
#define OFF 0

//
// Define volatile pointer offsets for easy access of event timer
// registers
//
typedef struct _TIMER_REGISTERS {
    volatile ULONG ConfigCapabilities;  // 0x100, 0x120, 0x140, ...
    ULONG Unknown;
    volatile ULONG Comparator;          // 0x108
    ULONG Mystery;
    volatile ULONG FSBInterruptRoute;   // 0x110
    volatile ULONG FSBInterruptAddress; // 0x114
    ULONGLONG Secret;
} TIMER_REGISTERS, *PTIMER_REGISTERS;

//
// Don't try to allocate one of these puppies, it's just a collecton of
// volatile pointer/offsets to make reading of registers easier
//
typedef struct _EVENT_TIMER_BLOCK {
    volatile ULONG GeneralCapabilities;     // 0x000
    volatile ULONG ClockPeriod;             // 0x004
    ULONGLONG Unknown;
    volatile ULONG GeneralConfig;           // 0x010
    ULONG Mystery[3];
    volatile ULONG GeneralIRQStatus;        // 0x020
    ULONG Secret[51];
    volatile ULONG MainCounter;             // 0x0F0
    ULONG Abyss[3];
    TIMER_REGISTERS mmTimer[ANYSIZE_ARRAY]; // 0x100
} EVENT_TIMER_BLOCK, *PEVENT_TIMER_BLOCK;

//
// Define our multi media event timer block context
//
typedef struct _ETB_CONTEXT {
    ULONG TimerCount;
    PEVENT_TIMER_BLOCK EventTimer;
    PHYSICAL_ADDRESS BaseAddress;
    ULONG ClockPeriod; // In nanoseconds
    ULONG SystemClockFrequency; // Rate of system clock in Hz
    ULONG SystemClockTicks; // Period of system clock in ticks
    BOOLEAN Initialized;
    BOOLEAN NewClockFrequency;
} ETB_CONTEXT, *PETB_CONTEXT;

//
// General Capabilities and ID
//
typedef union {
    struct {
        ULONG RevisionID: 8;
        ULONG TimerCount: 5;
        ULONG MainCounterSize: 1;
        ULONG Reserved: 1;
        ULONG LegacyIRQRoutingCapable: 1;
        ULONG VendorID: 16;
    };
    ULONG AsULONG;
} ETB_GEN_CAP_ID, *PETB_GEN_CAP_ID;

//
// General Configuration
//
typedef union {
    struct {
        ULONG GlobalIRQEnable: 1;
        ULONG LegacyIRQRouteEnable: 1;
        ULONG Reserved: 30;
    };
    ULONG AsULONG;
} ETB_GEN_CONF, *PETB_GEN_CONF;

//
// Timer n Configuration and Capabilities
//
typedef union {
    struct {
        ULONG Reserved0:          1;
        ULONG EdgeLevelSelect:    1;
        ULONG IRQEnable:          1;
        ULONG PeriodicModeEnable: 1;
        ULONG PeriodicCapable:    1;
        ULONG CompareWidth:       1;
        ULONG ValueSetConfig:     1;
        ULONG Reserved1:          1;
        ULONG Mode32BitConfig:    1;
        ULONG IRQRouteConfig:     5;
        ULONG IRQDeliverySelect:  1;
        ULONG FSBIRQCapable:      1;
        ULONG Reserved2:         16;
    };
    ULONG AsULONG;
} ETB_CONF_CAPS, *PETB_CONF_CAPS;

VOID
HalpmmTimerInit(
    IN ULONG EventTimerBlockID,
    IN ULONG BaseAddress
    );

ULONG
HalpmmTimerSetTimeIncrement(
    IN ULONG DesiredIncrement
    );

VOID
HalpmmTimerStallExecProc(
    IN ULONG Microseconds
    );

LARGE_INTEGER
HalpmmTimerQueryPerfCount(
   OUT PLARGE_INTEGER PerformanceFrequency OPTIONAL
   );

VOID
HalpmmTimerCalibratePerfCount(
    IN LONG volatile *Number,
    IN ULONGLONG NewCount
    );

BOOLEAN
HalpmmTimer(
    VOID
    );

VOID
HalpmmTimerClockInit(
    VOID
    );

#endif // __MMTIMER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\mpdebug.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halmps\i386\mpdebug.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\mphal.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halmps\i386\mphal.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\mpinfo.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halmps\i386\mpinfo.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\mpprocst.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\halmps\i386\mpprocst.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\mpsysbus.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halmps\i386\mpsysbus.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\mpsproc.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halmps\i386\mpsproc.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\mpsys.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halmps\i386\mpsys.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\pcip.h ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\pcip.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\mpsyssup.c ===
/*++

Module Name:

    mpsyssup.c

Abstract:

    This file contains APIC-related funtions that are
    specific to halmps.  The functions that can be
    shared with the APIC version of the ACPI HAL are
    still in mpsys.c.

Author:

    Ron Mosgrove (Intel)

Environment:

    Kernel mode only.

Revision History:

    Jake Oshins - 10-20-97 - split off from mpsys.c


*/

#include "halp.h"
#include "apic.inc"
#include "acpi_mp.inc"
#include "acpitabl.h"
#include "ntacpi.h"

extern ULONG HalpPicVectorRedirect[];
extern ULONG HalpPicVectorFlags[];
extern FADT HalpFixedAcpiDescTable;
extern PVOID *HalpLocalNmiSources;
extern UCHAR HalpMaxProcs;

#define ISA_PIC_VECTORS 16

UCHAR   HalpIoApicId[MAX_IOAPICS];

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, HalpInitIntiInfo)
#pragma alloc_text(PAGELK, HalpGetApicInterruptDesc)
#pragma alloc_text(PAGELK, HalpEnableLocalNmiSources)
#pragma alloc_text(PAGE, HaliSetVectorState)
#pragma alloc_text(PAGE, HaliIsVectorValid)
#endif

VOID
HalpInitIntiInfo (
    VOID
    )
/*++

Routine Description:

    This function is called at initialization time before any interrupts
    are connected.  It reads the PC+MP Inti table and builds internal
    information needed to route each Inti.

Return Value:

    The following structures are filled in:
        HalpIntiInfo
        HalpSourceIrqIds
        HalpSourceIrqMapping
        HalpISAIqpToVector

--*/

{
    ULONG           ApicNo, BusNo, InterruptInput, IdIndex, ProcNo;
    ULONG           i, id;
    USHORT          rtcInti, sciInti;
    UCHAR           Level, Polarity;
    BOOLEAN         found;

    //
    // Clear IntiInfo table.  Assume to begin with that
    // all interrupts are active-low, level-triggered.
    //

    for (i=0; i < MAX_INTI; i++) {
        HalpIntiInfo[i].Type = INT_TYPE_INTR;
        HalpIntiInfo[i].Level = CFG_LEVEL;
        HalpIntiInfo[i].Polarity = POLARITY_LOW;
    }

    //
    // Set up the RTC inti with the right flags from
    // the redirection table.
    //

    found = HalpGetApicInterruptDesc( DEFAULT_PC_BUS,
                                      0,
                                      HalpPicVectorRedirect[RTC_IRQ],
                                      &rtcInti
                                      );

    if (!found) {
        KeBugCheckEx(HAL_INITIALIZATION_FAILED,
                     0x3000,
                     1,
                     HalpPicVectorRedirect[RTC_IRQ],
                     0);
    }

    if ((HalpPicVectorFlags[RTC_IRQ] & PO_BITS) == POLARITY_CONFORMS_WITH_BUS) {

        //
        // The flags indicated "conforms to bus,"
        // so this should be active high.
        //

        HalpIntiInfo[rtcInti].Polarity = POLARITY_HIGH;

    } else {

        //
        // The polarity flags are overriden.
        //

        HalpIntiInfo[rtcInti].Polarity =
            (UCHAR)HalpPicVectorFlags[RTC_IRQ] & PO_BITS;
    }

    if ((HalpPicVectorFlags[RTC_IRQ] & EL_BITS) == EL_CONFORMS_WITH_BUS) {

        //
        // The flags indicated "conforms to bus,"
        // so this should be edge triggered.
        //

        HalpIntiInfo[rtcInti].Level = CFG_EDGE;

    } else {

        //
        // The mode flags are overriden.
        //

        HalpIntiInfo[rtcInti].Level =
            ((UCHAR)(HalpPicVectorFlags[RTC_IRQ] & EL_BITS) == EL_EDGE_TRIGGERED ?
              CFG_EDGE : CFG_LEVEL);
    }

    //
    //
    // Set up the SCI inti with the right flags from
    // the redirection table.
    //

    found = HalpGetApicInterruptDesc( DEFAULT_PC_BUS,
                                      0,
                                      HalpPicVectorRedirect[HalpFixedAcpiDescTable.sci_int_vector],
                                      &sciInti
                                      );

    if (!found) {
        KeBugCheckEx(HAL_INITIALIZATION_FAILED,
                     0x3000,
                     2,
                     HalpPicVectorRedirect[HalpFixedAcpiDescTable.sci_int_vector],
                     0);
    }

    if ((HalpPicVectorFlags[HalpFixedAcpiDescTable.sci_int_vector]
         & PO_BITS) == POLARITY_CONFORMS_WITH_BUS) {

        //
        // The flags indicated "conforms to bus,"
        // so this should default to the ACPI spec (active low.)
        //

        HalpIntiInfo[sciInti].Polarity = POLARITY_LOW;

    } else {

        //
        // The polarity flags are overriden.
        //

        HalpIntiInfo[sciInti].Polarity =
            (UCHAR)HalpPicVectorFlags[HalpFixedAcpiDescTable.sci_int_vector] & PO_BITS;
    }

    if (((HalpPicVectorFlags[HalpFixedAcpiDescTable.sci_int_vector] & EL_BITS) ==
          EL_CONFORMS_WITH_BUS) ||
        ((HalpPicVectorFlags[HalpFixedAcpiDescTable.sci_int_vector] & EL_BITS) ==
          EL_LEVEL_TRIGGERED)) {

        //
        // The flags indicated "conforms to bus,"
        // so this should be level-triggered.
        //

        HalpIntiInfo[sciInti].Level = CFG_LEVEL;

    } else {

        //
        // The SCI cannot be edge-triggered.
        //

        KeBugCheckEx(ACPI_BIOS_ERROR,
                        0x10008,
                        HalpFixedAcpiDescTable.sci_int_vector,
                        0,
                        0);
    }

    // Make sure there aren't more Inti lines than we can support
    //

    InterruptInput = 0;
    for (i=0; i < MAX_IOAPICS; i++) {
        InterruptInput += HalpMaxApicInti[i];
    }
    ASSERT (InterruptInput < MAX_INTI);

    //
    // Fill in the boot processors Apic ID.
    //

    ApicNo = *(PVULONG)(LOCALAPIC + LU_ID_REGISTER);

    ApicNo &= APIC_ID_MASK;
    ApicNo >>= APIC_ID_SHIFT;

    ((PHALPRCB)KeGetCurrentPrcb()->HalReserved)->PCMPApicID = (UCHAR)ApicNo;

    //
    // Mark the boot processor as started.
    //

    for (ProcNo = 0; ProcNo < HalpMpInfoTable.ProcessorCount; ProcNo++) {

        if (HalpProcLocalApicTable[ProcNo].ApicID == (UCHAR)ApicNo) {

            HalpProcLocalApicTable[ProcNo].Started = TRUE;
            HalpProcLocalApicTable[ProcNo].Enumerated = TRUE;
            break;
        }
    }

    if (ProcNo == HalpMpInfoTable.ProcessorCount) {
        KeBugCheckEx(HAL_INITIALIZATION_FAILED, 0xdead000a, ApicNo, (ULONG)&HalpProcLocalApicTable, 0);
    }

    //
    // If this is an EISA machine check the ELCR
    //
//
//  if (HalpBusType == MACHINE_TYPE_EISA) {
//      HalpCheckELCR ();
//  }
}

BOOLEAN
HalpGetApicInterruptDesc (
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN ULONG BusInterruptLevel,
    OUT PUSHORT PcMpInti
    )
/*++

Routine Description:

    This procedure gets a "Inti" describing the requested interrupt

Arguments:

    BusType - The Bus type as known to the IO subsystem

    BusNumber - The number of the Bus we care for

    BusInterruptLevel - IRQ on the Bus

Return Value:

    TRUE if PcMpInti found; otherwise FALSE.

    PcMpInti - A number that describes the interrupt to the HAL.

--*/
{
    ULONG   i;
    ULONG   index = 0;

    UNREFERENCED_PARAMETER(BusType);
    UNREFERENCED_PARAMETER(BusNumber);

    for (i = 0; i < HalpMpInfoTable.IOApicCount; i++) {

        if ((BusInterruptLevel >=
                HalpMpInfoTable.IoApicIntiBase[i]) &&
            (BusInterruptLevel <
                HalpMpInfoTable.IoApicIntiBase[i] +
                    HalpMaxApicInti[i])) {

            //
            // Return value is an offset into the INTI_INFO array.  So
            // calculate which one it is.
            //

            *PcMpInti = (USHORT)(index + BusInterruptLevel -
                 HalpMpInfoTable.IoApicIntiBase[i]);

            return TRUE;
        }

        index += HalpMaxApicInti[i];
    }

    //
    // Not found or search out of range
    //

    return FALSE;
}

ULONG
HalpGetIoApicId(
    ULONG   ApicNo
    )
{
    return (ULONG) HalpIoApicId[ApicNo];
}

ULONG
HalpInti2BusInterruptLevel(
    ULONG   Inti
    )
{

    return Inti;
}

VOID
HalpMarkProcessorStarted(
    ULONG   ApicID,
    ULONG   NtNumber
    )
{
    ULONG ProcNo;

    for (ProcNo = 0; ProcNo < HalpMpInfoTable.ProcessorCount; ProcNo++) {
        if (HalpProcLocalApicTable[ProcNo].ApicID == (UCHAR)ApicID) {
            HalpProcLocalApicTable[ProcNo].Started = TRUE;
            HalpProcLocalApicTable[ProcNo].NtNumber = (UCHAR) NtNumber;
            break;
        }
    }

}

NTSTATUS
HalpGetNextProcessorApicId(
    IN ULONG ProcessorNumber,
    IN OUT UCHAR    *ApicId
    )
/*++

Routine Description:

    This function returns an APIC ID of a non-started processor,
    which will be started by HalpStartProcessor.

Arguments:

    ProcessorNumber - The logical processor number that will
        be associated with this APIC ID.

    ApicId - pointer to a value to fill in with the APIC ID.

Return Value:

    status

--*/
{
    UCHAR Proc;

    //
    // Find a processor that hasn't been enumerated.
    //

    for (Proc = 0; Proc < HalpMpInfoTable.ProcessorCount; Proc++) {

        if (!HalpProcLocalApicTable[Proc].Enumerated) {
            break;
        }
    }

    if (Proc == HalpMpInfoTable.ProcessorCount) {

        //
        // Couldn't find a processor to start.
        //
        return STATUS_NOT_FOUND;
    }

    //
    // Keep track of this processor.
    //

    HalpProcLocalApicTable[Proc].Enumerated = TRUE;

    *ApicId = HalpProcLocalApicTable[Proc].ApicID;
    return STATUS_SUCCESS;
}

NTSTATUS
HalpGetApicIdByProcessorNumber(
    IN     UCHAR     Processor,
    IN OUT USHORT   *ApicId
    )
/*++

Routine Description:

    This function returns an APIC ID for a given processor.
    It is intended this routine be able to produce the same
    APIC ID order as HalpGetNextProcessorApicId.

Arguments:

    Processor - The logical processor number that is
        associated with this APIC ID.

    ApicId - pointer to a value to fill in with the APIC ID.

Return Value:

    status

--*/
{
    UCHAR Proc;
    LONG  Skip;

    //
    // Run thru the processors that have already been started
    // to see if this is on of them.
    //

    Skip = Processor;
    for (Proc = 0; Proc < HalpMpInfoTable.ProcessorCount; Proc++) {
        if (HalpProcLocalApicTable[Proc].Started) {
            Skip--;
            if (HalpProcLocalApicTable[Proc].NtNumber == (UCHAR)Processor) {
                *ApicId = (USHORT)HalpProcLocalApicTable[Proc].ApicID;
                return STATUS_SUCCESS;
            }
        }
    }

    //
    // Not amongst the started, rely on the order that processors
    // will be started (see HalpGetNextProcessorApicId) to get the
    // number.
    //

    ASSERT(Skip >= 0);

    for (Proc = 0; Proc < HalpMpInfoTable.ProcessorCount; Proc++) {

        if (HalpProcLocalApicTable[Proc].Started) {
            continue;
        }

        if (Skip == 0) {

            //
            // Return this processor.
            //

            *ApicId = (USHORT)HalpProcLocalApicTable[Proc].ApicID;
            return STATUS_SUCCESS;
        }

        Skip--;
    }

    //
    // Couldn't find a processor to start.
    //

    return STATUS_NOT_FOUND;
}

VOID
HaliSetVectorState(
    IN ULONG Vector,
    IN ULONG Flags
    )
{
    BOOLEAN found;
    USHORT  inti;
    ULONG   picVector;
    UCHAR   i;

    PAGED_CODE();

    found = HalpGetApicInterruptDesc(0, 0, Vector, &inti);

    if (!found) {
        KeBugCheckEx(ACPI_BIOS_ERROR,
                     0x10007,
                     Vector,
                     0,
                     0);
    }

    ASSERT(HalpIntiInfo[inti].Type == INT_TYPE_INTR);

    //
    // Vector is already translated through
    // the PIC vector redirection table.  We need
    // to make sure that we are honoring the flags
    // in the redirection table.  So look in the
    // table here.
    //

    for (i = 0; i < PIC_VECTORS; i++) {

        if (HalpPicVectorRedirect[i] == Vector) {

            picVector = i;
            break;
        }
    }

    if (i != PIC_VECTORS) {

        //
        // Found this vector in the redirection table.
        //

        if (HalpPicVectorFlags[picVector] != 0) {

            //
            // And the flags say something other than "conforms
            // to bus."  So we honor the flags from the table.
            //

            HalpIntiInfo[inti].Level =
                (((HalpPicVectorFlags[picVector] & EL_BITS) == EL_LEVEL_TRIGGERED) ?
                    CFG_LEVEL : CFG_EDGE);

            HalpIntiInfo[inti].Polarity = (UCHAR)(HalpPicVectorFlags[picVector] & PO_BITS);

            return;
        }
    }

    //
    // This vector is not covered in the table, or it "conforms to bus."
    // So we honor the flags passed into this function.
    //

    if (IS_LEVEL_TRIGGERED(Flags)) {

        HalpIntiInfo[inti].Level = CFG_LEVEL;

    } else {

        HalpIntiInfo[inti].Level = CFG_EDGE;
    }

    if (IS_ACTIVE_LOW(Flags)) {

        HalpIntiInfo[inti].Polarity = POLARITY_LOW;

    } else {

        HalpIntiInfo[inti].Polarity = POLARITY_HIGH;
    }
}

VOID
HalpEnableLocalNmiSources(
    VOID
    )
/*++

Routine Description:

    This routine parses the information from the MAPIC table and
    enables any NMI sources in the local APIC of the processor
    that it is running on.

    Callers of this function must be holding HalpAccountingLock.

Arguments:

Return Value:

--*/
{
    PLOCAL_NMISOURCE localSource;
    PKPCR       pPCR;
    UCHAR       ThisCpu;
    ULONG       i;
    ULONG       modeBits = 0;

    pPCR = KeGetPcr();
    ThisCpu = pPCR->Prcb->Number;

    //
    //  Enable local processor NMI source
    //

    if (!HalpLocalNmiSources) {

        //
        // Nobody has cataloged any local NMI sources.
        //

        return;
    }

    for (i = 0; i < (ULONG)HalpMaxProcs * 2; i++) {

        if (!HalpLocalNmiSources[i]) {

            //
            // Out of entries.
            //
            return;
        }

        localSource = (PLOCAL_NMISOURCE)(HalpLocalNmiSources[i]);

        if (((HalpProcLocalApicTable[ThisCpu].NamespaceProcID == localSource->ProcessorID) ||
             (localSource->ProcessorID == 0xff) &&
             HalpProcLocalApicTable[ThisCpu].Started)) {

            //
            // This entry corresponds to this processor.
            //

            modeBits |= ((localSource->Flags & PO_BITS) == POLARITY_LOW) ?
                        ACTIVE_LOW : ACTIVE_HIGH;

            modeBits |= ((localSource->Flags & EL_BITS) == EL_LEVEL_TRIGGERED) ?
                        LEVEL_TRIGGERED : EDGE_TRIGGERED;

            if (localSource->LINTIN == 0) {

                pLocalApic[LU_INT_VECTOR_0/4] =
                    modeBits | DELIVER_NMI | NMI_VECTOR;

            } else {

                pLocalApic[LU_INT_VECTOR_1/4] =
                    modeBits | DELIVER_NMI | NMI_VECTOR;
            }
        }
    }
}

BOOLEAN
HaliIsVectorValid(
    IN ULONG Vector
    )
{
    BOOLEAN found;
    USHORT  inti;

    PAGED_CODE();

    return HalpGetApicInterruptDesc(0, 0, Vector, &inti);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\pmdata.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pmdat.c

Abstract:

    Declares various data which is initialize data, or pagable data.

Author:

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "acpitabl.h"
#include "xxacpi.h"

FADT    HalpFixedAcpiDescTable;
PDEBUG_PORT_TABLE HalpDebugPortTable = NULL;
ULONG   HalpThrottleScale;

UCHAR   HalpBrokenAcpiTimer = 0;

UCHAR   HalpPiix4 = 0;
ULONG   HalpPiix4BusNumber;
ULONG   HalpPiix4SlotNumber;
ULONG   HalpPiix4DevActB;
ULONG   HalpAcpiFlags = HAL_ACPI_PCI_RESOURCES;

BOOLEAN HalpBroken440BX = FALSE;
BOOLEAN HalpProcessedACPIPhase0 = FALSE;
PBOOT_TABLE HalpSimpleBootFlagTable = NULL;

#ifdef APIC_HAL
//
// MP data
//

MP_INFO HalpMpInfoTable;
PMAPIC  HalpApicTable;

PROC_LOCAL_APIC HalpProcLocalApicTable[MAX_PROCESSORS] = {0};

PVOID *HalpLocalNmiSources = NULL;

#endif // APIC_HAL

//
// This array represents the ISA PIC vectors.
// They start out identity-mapped.
//
ULONG   HalpPicVectorRedirect[PIC_VECTORS] =
{
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
    10, 11, 12, 13, 14, 15
};

#ifdef APIC_HAL
ULONG   HalpPicVectorFlags[PIC_VECTORS] = {0};
#endif // APIC_HAL

SLEEP_STATE_CONTEXT HalpSleepContext = {0};
PVOID               HalpWakeVector  = NULL;
PVOID               HalpVirtAddrForFlush = NULL;
PVOID               HalpPteForFlush = NULL;
BOOLEAN             HalpCr4Exists   = FALSE;
UCHAR               HalpRtcRegA;
UCHAR               HalpRtcRegB;

PACPI_BIOS_MULTI_NODE HalpAcpiMultiNode = NULL;
PUCHAR HalpAcpiNvsData = NULL;
PVOID  HalpNvsVirtualAddress = NULL;

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("INIT")
#endif

UCHAR  rgzNoApicTable[]     = "HAL: No ACPI APIC Table Found\n";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\pmapic.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pmapic.c

Abstract:

    Implements various APIC-ACPI functions.

Author:

    Jake Oshins (jakeo) 19-May-1997

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "acpitabl.h"
#include "apic.inc"
#include "xxacpi.h"
#include "ixsleep.h"

#ifdef DEBUGGING
#include "string.h"
#include "stdlib.h"
#include "stdio.h"
#endif

ULONG
DetectAcpiMP (
    OUT PBOOLEAN IsConfiguredMp,
    IN  PLOADER_PARAMETER_BLOCK LoaderBlock
    );

VOID
HalpInitMpInfo (
    IN PMAPIC ApicTable,
    IN ULONG  Phase
    );

BOOLEAN
HalpVerifyIOUnit(
    IN PUCHAR BaseAddress
    );

VOID
HalpMaskAcpiInterrupt(
    VOID
    );

VOID
HalpUnmaskAcpiInterrupt(
    VOID
    );

extern UCHAR  rgzNoApicTable[];
extern UCHAR  rgzNoApic[];
extern UCHAR  rgzBadApicVersion[];
extern UCHAR  rgzApicNotVerified[];

extern ULONG HalpPicVectorRedirect[];
extern ULONG HalpPicVectorFlags[];
extern USHORT HalpMaxApicInti[];
extern UCHAR HalpIoApicId[];
extern ULONG HalpIpiClock;
extern PVOID *HalpLocalNmiSources;

ULONG HalpIOApicVersion[MAX_IOAPICS];

extern BOOLEAN HalpHiberInProgress;

BOOLEAN HalpPicStateIntact = TRUE;
UCHAR   HalpMaxProcs = 0;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DetectAcpiMP)
#pragma alloc_text(PAGELK, HalpInitMpInfo)
#pragma alloc_text(PAGELK, HalpVerifyIOUnit)
#pragma alloc_text(PAGELK, HalpSaveInterruptControllerState)
#pragma alloc_text(PAGELK, HalpRestoreInterruptControllerState)
#pragma alloc_text(PAGELK, HalpSetInterruptControllerWakeupState)
#pragma alloc_text(PAGELK, HalpAcpiPicStateIntact)
#pragma alloc_text(PAGELK, HalpGetApicVersion)
#pragma alloc_text(PAGELK, HalpMaskAcpiInterrupt)
#pragma alloc_text(PAGELK, HalpUnmaskAcpiInterrupt)
#endif


ULONG
DetectAcpiMP(
    OUT PBOOLEAN    IsConfiguredMp,
    IN  PLOADER_PARAMETER_BLOCK LoaderBlock
    )
{
    UCHAR ApicVersion, i;
    PUCHAR  LocalApic;
#ifdef DEBUGGING
    CHAR    string[100];
#endif
    PHYSICAL_ADDRESS physicalAddress;

    //
    // Initialize MpInfo table
    //

    RtlZeroMemory (&HalpMpInfoTable, sizeof(MP_INFO));

    //
    // Set the return Values to the default
    //

    *IsConfiguredMp = FALSE;

    //
    // See if there is an APIC Table
    //

    if ((HalpApicTable = HalpGetAcpiTablePhase0(LoaderBlock, APIC_SIGNATURE)) == NULL) {
        HalDisplayString(rgzNoApicTable);
        return(FALSE);
    }

    // We have an APIC table. Initialize a HAL specific MP information
    // structure that gets information from the MAPIC table.

#ifdef DEBUGGING
    sprintf(string, "Signature: %x      Length: %x\n",
            HalpApicTable->Header.Signature,
            HalpApicTable->Header.Length);
    HalDisplayString(string);
    sprintf(string, "OEMID: %s\n", HalpApicTable->Header.OEMID);
    HalDisplayString(string);
    sprintf(string, "Local Apic Address: %x\n", HalpApicTable->LocalAPICAddress);
    HalDisplayString(string);
    sprintf(string, "Flags: %x\n", HalpApicTable->Flags);
    HalDisplayString(string);
#endif

    HalpInitMpInfo(HalpApicTable, 0);

    // Verify the information in the MAPIC table as best as we can.

    if (HalpMpInfoTable.IOApicCount == 0) {
        //
        //  Someone Has a MP Table and no IO Units -- Weird
        //  We have to assume the BIOS knew what it was doing
        //  when it built the table.  so ..
        //
        HalDisplayString (rgzNoApic);

        return (FALSE);
    }

    //
    //  It's an APIC System.  It could be a UP System though.
    //

    if (HalpMpInfoTable.ProcessorCount > 1) {
        *IsConfiguredMp = TRUE;
    }

    HalpMpInfoTable.LocalApicBase = (ULONG) HalpApicTable->LocalAPICAddress;
    physicalAddress =
        HalpPtrToPhysicalAddress( (PVOID)HalpMpInfoTable.LocalApicBase );

    LocalApic = (PUCHAR) HalpMapPhysicalMemoryWriteThrough( physicalAddress,
                                                            1 );
    HalpRemapVirtualAddress (
        (PVOID) LOCALAPIC,
        physicalAddress,
        TRUE
        );

    ApicVersion = (UCHAR) *(LocalApic + LU_VERS_REGISTER);

    if (ApicVersion > 0x1f) {
        //
        //  Only known Apics are 82489dx with version 0.x and
        //  Embedded Apics with version 1.x (where x is don't care)
        //
        //  Return of 0xFF?   Can't have an MPS system without a Local Unit.
        //

#ifdef DEBUGGING
        sprintf(string, "HALMPS: apic version %x, read from %x\n",
            ApicVersion, LocalApic + LU_VERS_REGISTER);

        HalDisplayString(string);
#endif

        HalDisplayString (rgzBadApicVersion);

        return (FALSE);
    }

    for(i=0; i < HalpMpInfoTable.IOApicCount; i++)
    {
        //
        //  Verify the existance of the IO Unit
        //


        if (!(HalpVerifyIOUnit((PUCHAR)HalpMpInfoTable.IoApicBase[i]))) {
            HalDisplayString (rgzApicNotVerified);

            return (FALSE);
        }
    }

    HalDisplayString("HAL: DetectAPIC: APIC system found - Returning TRUE\n");

    return TRUE;
}

VOID
HalpInitMpInfo (
    IN PMAPIC ApicTable,
    IN ULONG  Phase
    )

/*++
Routine Description:
    This routine initializes a HAL specific data structure that is
    used by the HAL to simplify access to MP information.

Arguments:

    ApicTable - Pointer to the APIC table.

    Phase - indicates which pass we are are doing through the table.

 Return Value:
     Pointer to the HAL MP information table.

*/
{
    PUCHAR  TraversePtr;
    UCHAR   CheckSum;
    UCHAR   apicNo = 0;
    ULONG   nmiSources = 0;
#ifdef DEBUGGING
    CHAR    string[100];
#endif
    PIO_APIC_UNIT   apic;
    PHYSICAL_ADDRESS physicalAddress;
    PIOAPIC ioApic;
    UCHAR totalProcs = 0;

    union {
        ULONG        raw;
        APIC_VERSION version;
    } versionUnion;

    // Walk the MAPIC table.

    TraversePtr = (PUCHAR) ApicTable->APICTables;

    //
    // ACPI machines have embedded APICs.
    //
    HalpMpInfoTable.ApicVersion = 0x10;

#ifdef DUMP_MAPIC_TABLE

    while ((ULONG)TraversePtr <
           ((ULONG)ApicTable + ApicTable->Header.Length)) {

        sprintf(string, "%08x  %08x  %08x  %08x\n",
                *(PULONG)TraversePtr,
                *(PULONG)(TraversePtr + 4),
                *(PULONG)(TraversePtr + 8),
                *(PULONG)(TraversePtr + 12)
                );
        HalDisplayString(string);
        TraversePtr += 16;
    }

    TraversePtr = (PUCHAR) ApicTable->APICTables;
#endif

    if (!(ApicTable->Flags & PCAT_COMPAT)) {

        //
        // This HAL can't actually handle a machine without 8259's,
        // even though it doesn't use them.
        //

        KeBugCheckEx(MISMATCHED_HAL,
                        6, 0, 0, 0);

    }

    while ((ULONG)TraversePtr <
           ((ULONG)ApicTable + ApicTable->Header.Length)) {

        if ((((PPROCLOCALAPIC)(TraversePtr))->Type == PROCESSOR_LOCAL_APIC)
           && (((PPROCLOCALAPIC)(TraversePtr))->Length == PROCESSOR_LOCAL_APIC_LENGTH)) {

#ifdef DEBUGGING
            sprintf(string, "Found a processor-local APIC: %x\n", TraversePtr);
            HalDisplayString(string);
#endif

            if (Phase == 0) {

                if(((PPROCLOCALAPIC)(TraversePtr))->Flags & PLAF_ENABLED) {

                    //
                    // This processor is enabled, so keep track of useful stuff.
                    //

                    HalpProcLocalApicTable[HalpMpInfoTable.ProcessorCount].NamespaceProcID =
                        ((PPROCLOCALAPIC)(TraversePtr))->ACPIProcessorID;

                    HalpProcLocalApicTable[HalpMpInfoTable.ProcessorCount].ApicID =
                        ((PPROCLOCALAPIC)(TraversePtr))->APICID;

                    HalpMpInfoTable.ProcessorCount += 1;
                }
            }

            totalProcs++;

            HalpMaxProcs = (totalProcs > HalpMaxProcs) ? totalProcs : HalpMaxProcs;

            TraversePtr += ((PPROCLOCALAPIC)(TraversePtr))->Length;

        } else if ((((PIOAPIC)(TraversePtr))->Type == IO_APIC) &&
           (((PIOAPIC)(TraversePtr))->Length == IO_APIC_LENGTH)) {


#ifdef DEBUGGING
            sprintf(string, "Found an IO APIC: [%x] %x\n",
                    HalpMpInfoTable.IOApicCount,
                    TraversePtr);
            HalDisplayString(string);
#endif

            ioApic = (PIOAPIC)TraversePtr;

            if (Phase == 0) {
                //
                // Found an IO APIC entry.  Record the info from
                // the table.
                //

                apicNo = (UCHAR)HalpMpInfoTable.IOApicCount;

                HalpIoApicId[apicNo] = ioApic->IOAPICID;

                HalpMpInfoTable.IoApicIntiBase[apicNo] =
                    ioApic->SystemVectorBase;

                HalpMpInfoTable.IoApicPhys[apicNo] =
                    ioApic->IOAPICAddress;

                //
                // Get a virtual address for it.
                //

                physicalAddress = HalpPtrToPhysicalAddress(
                                    (PVOID)ioApic->IOAPICAddress );

                HalpMpInfoTable.IoApicBase[apicNo] =
                    HalpMapPhysicalMemoryWriteThrough( physicalAddress, 1 );

                apic = (PIO_APIC_UNIT)HalpMpInfoTable.IoApicBase[apicNo];

                if (!apic) {
#ifdef DEBUGGING
                    sprintf(string, "Couldn't map the I/O apic\n");
                    HalDisplayString(string);
#endif
                    return;
                }

                //
                // Dig the number of Intis out of the hardware.
                //

                apic->RegisterSelect = IO_VERS_REGISTER;
                apic->RegisterWindow = 0;
                versionUnion.raw = apic->RegisterWindow;

                HalpMaxApicInti[apicNo] = versionUnion.version.MaxRedirEntries + 1;

                //
                // Also store the version so that it can be retrieved by the ACPI driver
                //

                HalpIOApicVersion[apicNo] = versionUnion.raw;

#ifdef DEBUGGING
                    sprintf(string, "GSIV base: %x  PhysAddr: %x  VirtAddr: %x  Intis: %x\n",
                            HalpMpInfoTable.IoApicVectorBase[apicNo],
                            HalpMpInfoTable.IoApicPhys[apicNo],
                            HalpMpInfoTable.IoApicBase[apicNo],
                            HalpMaxApicInti[apicNo]);

                    HalDisplayString(string);
#endif

                HalpMpInfoTable.IOApicCount += 1;
            }

            TraversePtr += ioApic->Length;

        } else if ((((PISA_VECTOR)TraversePtr)->Type == ISA_VECTOR_OVERRIDE) &&
           (((PISA_VECTOR)TraversePtr)->Length == ISA_VECTOR_OVERRIDE_LENGTH)) {

#ifdef DEBUGGING
            sprintf(string, "Found an ISA VECTOR: %x, %x -> %x, flags: %x\n",
                    TraversePtr,
                    ((PISA_VECTOR)TraversePtr)->Source,
                    ((PISA_VECTOR)TraversePtr)->GlobalSystemInterruptVector,
                    ((PISA_VECTOR)TraversePtr)->Flags
                    );
            HalDisplayString(string);
#endif

            if (Phase == 0) {

                //
                // Found an ISA vector redirection entry.
                //

                HalpPicVectorRedirect[((PISA_VECTOR)TraversePtr)->Source] =
                    ((PISA_VECTOR)TraversePtr)->GlobalSystemInterruptVector;

                HalpPicVectorFlags[((PISA_VECTOR)TraversePtr)->Source] =
                    ((PISA_VECTOR)TraversePtr)->Flags;

            }

            TraversePtr += ISA_VECTOR_OVERRIDE_LENGTH;

        } else if ((((PIO_NMISOURCE)TraversePtr)->Type == IO_NMI_SOURCE) &&
           (((PIO_NMISOURCE)TraversePtr)->Length == IO_NMI_SOURCE_LENGTH)) {

            if (Phase == 1) {

                BOOLEAN found;
                USHORT  inti;

                found = HalpGetApicInterruptDesc(0,
                                                 0,
                                                 ((PIO_NMISOURCE)TraversePtr)->GlobalSystemInterruptVector,
                                                 &inti);

                if (found) {

                    HalpIntiInfo[inti].Type = INT_TYPE_NMI;
                    HalpIntiInfo[inti].Level =
                        (((((((PIO_NMISOURCE)TraversePtr)->Flags & EL_BITS) == EL_EDGE_TRIGGERED) ||
                             ((PIO_NMISOURCE)TraversePtr)->Flags & EL_BITS) == EL_CONFORMS_WITH_BUS)
                         ? CFG_EDGE : CFG_LEVEL);
                    HalpIntiInfo[inti].Polarity =
                        ((PIO_NMISOURCE)TraversePtr)->Flags & PO_BITS;
                }
            }

            TraversePtr += IO_NMI_SOURCE_LENGTH;

        } else if ((((PLOCAL_NMISOURCE)TraversePtr)->Type == LOCAL_NMI_SOURCE) &&
           (((PLOCAL_NMISOURCE)TraversePtr)->Length == LOCAL_NMI_SOURCE_LENGTH)) {

            if (Phase == 1) {

                //
                // While running through phase 1, we should catalog local NMI sources.
                //

                if (!HalpLocalNmiSources) {

                    //
                    // Allocate enough pool to point to all the possible local NMI structures.
                    // Since there are two NMI pins on each processor, this is the number of processors
                    // times two times the size of a pointer.
                    //

                    HalpLocalNmiSources = ExAllocatePoolWithTag(NonPagedPool,
                                                                sizeof(PVOID) * HalpMaxProcs * 2,
                                                                HAL_POOL_TAG);

                    RtlZeroMemory(HalpLocalNmiSources,
                                  sizeof(PVOID) * HalpMaxProcs * 2);
                }

                HalpLocalNmiSources[nmiSources++] = (PVOID)TraversePtr;

            }

            TraversePtr += LOCAL_NMI_SOURCE_LENGTH;

        } else {
#ifdef DEBUGGING
            sprintf(string, "%x: %x \n", TraversePtr, *TraversePtr);
            HalDisplayString(string);
#endif
            //
            // Found random bits in the table.  Try the next byte and
            // see if we can make sense of it.
            //

            TraversePtr += 1;
        }
    }

    return;
}

BOOLEAN
HalpVerifyIOUnit(
    IN PUCHAR BaseAddress
    )
/*++

Routine Description:

    Verify that an IO Unit exists at the specified address

 Arguments:

    BaseAddress - Virtual address of the IO Unit to test.

 Return Value:
    BOOLEAN - TRUE if a IO Unit was found at the passed address
            - FALSE otherwise

--*/

{
    union ApicUnion {
        ULONG Raw;
        struct ApicVersion Ver;
    } Temp1, Temp2;

    struct ApicIoUnit *IoUnitPtr = (struct ApicIoUnit *) BaseAddress;

    //
    //  The documented detection mechanism is to write all zeros to
    //  the Version register.  Then read it back.  The IO Unit exists if the
    //  same result is read both times and the Version is valid.
    //

    IoUnitPtr->RegisterSelect = IO_VERS_REGISTER;
    IoUnitPtr->RegisterWindow = 0;

    IoUnitPtr->RegisterSelect = IO_VERS_REGISTER;
    Temp1.Raw = IoUnitPtr->RegisterWindow;

    IoUnitPtr->RegisterSelect = IO_VERS_REGISTER;
    IoUnitPtr->RegisterWindow = 0;

    IoUnitPtr->RegisterSelect = IO_VERS_REGISTER;
    Temp2.Raw = IoUnitPtr->RegisterWindow;

    if ((Temp1.Ver.Version != Temp2.Ver.Version) ||
        (Temp1.Ver.MaxRedirEntries != Temp2.Ver.MaxRedirEntries)) {
        //
        //  No IO Unit There
        //
        return (FALSE);
    }

    return (TRUE);
}

#ifdef DEBUGGING
struct PcMpTable *PcMpTablePtr, *PcMpDefaultTablePtrs[];

void
ComputeCheckSum(UCHAR This, UCHAR That)
{
}
#endif


VOID
HalpSaveInterruptControllerState(
    VOID
    )
{

    HalpHiberInProgress = TRUE;
}

VOID
HalpRestoreInterruptControllerState(
    VOID
    )
{
    //
    // Restore the IO APIC state
    //

    HalpRestoreIoApicRedirTable();

    HalpPicStateIntact = TRUE;
}

VOID
HalpSetInterruptControllerWakeupState(
    ULONG Context
    )
{
    LOADER_PARAMETER_BLOCK LoaderBlock;
    SLEEP_STATE_CONTEXT sleepContext;
    BOOLEAN IsMpSystem;
    ULONG   flags;
    KIRQL   OldIrql;
    KPRCB   Prcb;
    ULONG   ii;
    USHORT  inti;
    ULONG   localApicId;
    ULONG   oldProcNumber, oldProcsStarted;
    ULONG   localApicBase;

    sleepContext.AsULONG = Context;

    _asm {
        pushfd
        pop eax
        mov flags, eax
        cli
    }

    if (sleepContext.bits.Flags & SLEEP_STATE_RESTART_OTHER_PROCESSORS) {

        //
        // If you are remapping local apic, io apic and ACPI MAPIC table
        // resources, you first have to unmap the current resources!!!
        // The BIOS may have created the MAPIC table at a different place or may
        // have changed values like processor local APIC IDs. Reparse it.
        //

        ASSERT(HalpApicTable);
        oldProcNumber = HalpMpInfoTable.ProcessorCount;
        oldProcsStarted = HalpMpInfoTable.NtProcessors;
        localApicBase = HalpMpInfoTable.LocalApicBase;

        HalpUnMapIOApics();

        RtlZeroMemory (&HalpMpInfoTable, sizeof(MP_INFO));
        RtlZeroMemory(HalpProcLocalApicTable,
                      sizeof(PROC_LOCAL_APIC) * MAX_PROCESSORS);

        HalpInitMpInfo(HalpApicTable, 0);

        if (HalpMpInfoTable.ProcessorCount != oldProcNumber) {

            KeBugCheckEx(HAL_INITIALIZATION_FAILED,
                         0x2000,
                         oldProcNumber,
                         HalpMpInfoTable.ProcessorCount,
                         0);
        }

        HalpMpInfoTable.NtProcessors = oldProcsStarted;
        HalpMpInfoTable.LocalApicBase = localApicBase;

        RtlZeroMemory(&LoaderBlock, sizeof(LoaderBlock));
        RtlZeroMemory(&Prcb, sizeof(Prcb));
        LoaderBlock.Prcb = (ULONG) &Prcb;
    }

    //
    // Initialize minimum global hardware state needed.
    //

    HalpIpiClock = 0;
    HalpInitializeIOUnits();
    HalpInitializePICs(FALSE);
    HalpSet8259Mask(HalpGlobal8259Mask);

    //
    // Initialize boot processor's local APIC so it can wake other processors
    //

    HalpInitializeLocalUnit ();
    KeRaiseIrql(HIGH_LEVEL, &OldIrql);

    //
    // Wake up the other processors
    //

    if (sleepContext.bits.Flags & SLEEP_STATE_RESTART_OTHER_PROCESSORS) {

        //
        // Fill in this processor's Apic ID.
        //

        localApicId = *(PVULONG)(LOCALAPIC + LU_ID_REGISTER);

        localApicId &= APIC_ID_MASK;
        localApicId >>= APIC_ID_SHIFT;

        ((PHALPRCB)KeGetPcr()->Prcb->HalReserved)->PCMPApicID = (UCHAR)localApicId;

        //
        // Mark this processor as started.
        //

        for (ii = 0; ii < HalpMpInfoTable.NtProcessors; ii++) {

            if (HalpProcLocalApicTable[ii].ApicID ==
                ((PHALPRCB)KeGetPcr()->Prcb->HalReserved)->PCMPApicID) {

                HalpProcLocalApicTable[ii].Started = TRUE;
                HalpProcLocalApicTable[ii].Enumerated = TRUE;

                break;
            }
        }

        ASSERT(ii != HalpMpInfoTable.ProcessorCount);

        for(ii = 1; ii < HalpMpInfoTable.NtProcessors; ++ii)  {

            // Set processor number in dummy loader parameter block

            Prcb.Number = (UCHAR) ii;
            CurTiledCr3LowPart = HalpTiledCr3Addresses[ii].LowPart;
            if (!HalStartNextProcessor(&LoaderBlock, &HalpHiberProcState[ii]))  {

                //
                // We could not start a processor. This is a fatal error.
                //

                KeBugCheckEx(HAL_INITIALIZATION_FAILED,
                             0x2001,
                             oldProcNumber,
                             HalpMpInfoTable.NtProcessors,
                             0);
            }
        }
    }

    //
    // Enable the clock interrupt.
    //

    HalpGetApicInterruptDesc(
            DEFAULT_PC_BUS,
            0,
            HalpPicVectorRedirect[RTC_IRQ],
            &inti
            );

    HalpSetRedirEntry((UCHAR)inti,
                      HalpIntiInfo[inti].Entry,
                      HalpIntiInfo[inti].Destinations << DESTINATION_SHIFT);

    HalpPicStateIntact = FALSE;

    _asm {
        mov     eax, flags
        push    eax
        popfd
    }
}

BOOLEAN
HalpAcpiPicStateIntact(
    VOID
    )
{
    return HalpPicStateIntact;
}


ULONG HalpGetApicVersion(ULONG ApicNo)
{
/*++
Routine Description:

   Obtains the contents of the version register
   for a particular system IO APIC unit. These contents
   are saved by the HAL in HalpInitMpInfo.

Arguments:

   ApicNo - the number of the IO APIC Unit whose version we want.


Return Value:

   The contents of the version register for the given IO APIC unit.

   A 0 is returned if no version can be obtained because the given
   APIC number is not valid.
*/

   // If this APIC has been found by the HAL ...

   if (ApicNo < HalpMpInfoTable.IOApicCount) {

      // ... return its version

      return HalpIOApicVersion[ApicNo];
   }
   else
   {
      // Otherwise, return 0.

      return 0;
   }
}

VOID
HalpMaskAcpiInterrupt(
    VOID
    )
{
    USHORT inti = 0;
    ULONG  apicEntry;

    HalpGetApicInterruptDesc(
            DEFAULT_PC_BUS,
            0,
            HalpPicVectorRedirect[HalpFixedAcpiDescTable.sci_int_vector],
            &inti
            );

    apicEntry = HalpIntiInfo[inti].Entry;
    apicEntry |= INTERRUPT_MASKED;

    HalpSetRedirEntry((UCHAR)inti,
                      apicEntry,
                      0);


}

VOID
HalpUnmaskAcpiInterrupt(
    VOID
    )
{
    USHORT inti = 0;

    HalpGetApicInterruptDesc(
            DEFAULT_PC_BUS,
            0,
            HalpPicVectorRedirect[HalpFixedAcpiDescTable.sci_int_vector],
            &inti
            );

    HalpSetRedirEntry((UCHAR)inti,
                      HalpIntiInfo[inti].Entry,
                      HalpIntiInfo[inti].Destinations << DESTINATION_SHIFT);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\pmbus.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pmbus.c

Abstract:

    Implements functions that were done in
    previous HALs by bus handlers.  Basically,
    these will be somewhat simplified versions
    since much of the code in the bus handlers
    has effectively been moved into bus 
    drivers in NT5.

Author:

    Jake Oshins (jakeo) 1-Dec-1997

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "pci.h"
#include "pcip.h"

ULONG HalpGetCmosData (
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    );

ULONG HalpSetCmosData (
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    );

HalpGetEisaData (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

NTSTATUS
HalpAssignSlotResources (
    IN PUNICODE_STRING          RegistryPath,
    IN PUNICODE_STRING          DriverClassName       OPTIONAL,
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           DeviceObject          OPTIONAL,
    IN INTERFACE_TYPE           BusType,
    IN ULONG                    BusNumber,
    IN ULONG                    SlotNumber,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    );

BOOLEAN
HalpTranslateBusAddress(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

BOOLEAN
HalpFindBusAddressTranslation(
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress,
    IN OUT PULONG_PTR Context,
    IN BOOLEAN NextBus
    );

extern BUS_HANDLER  HalpFakePciBusHandler;
extern ULONG        HalpMinPciBus;
extern ULONG        HalpMaxPciBus;
extern ULONG HalpPicVectorRedirect[];

VOID
HalpGetNMICrashFlag (
    VOID
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpInitNonBusHandler)
#pragma alloc_text(INIT,HalpInitializePciBus)
#pragma alloc_text(PAGE,HalAssignSlotResources)
#pragma alloc_text(PAGE,HalpAssignSlotResources)
#endif

VOID
HalpInitNonBusHandler (
    VOID
    )
{
    HALPDISPATCH->HalPciTranslateBusAddress = HalpTranslateBusAddress;
    HALPDISPATCH->HalPciAssignSlotResources = HalpAssignSlotResources;
    HALPDISPATCH->HalFindBusAddressTranslation = HalpFindBusAddressTranslation;
}

VOID
HalpInitializePciBus(
    VOID
    )
{
    HalpInitializePciStubs();

    //
    // Check if we should crashdump on NMI.
    //

    HalpGetNMICrashFlag();
}

NTSTATUS
HalAdjustResourceList (
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST   *pResourceList
    )
{
    return STATUS_SUCCESS;
}

ULONG
HalGetBusData(
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    )
{
    return HalGetBusDataByOffset (BusDataType,BusNumber,SlotNumber,Buffer,0,Length);
}


ULONG
HalGetBusDataByOffset (
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    Dispatcher for GetBusData

--*/
{
    PCI_SLOT_NUMBER slot;
    BUS_HANDLER bus;
    ULONG length;
    
    switch (BusDataType) {
    case PCIConfiguration:

        //
        // Hack.  If the bus is outside of the known PCI busses, return
        // a length of zero.
        //

        if ((BusNumber < HalpMinPciBus) || (BusNumber > HalpMaxPciBus)) {
            return 0;
        }

        RtlCopyMemory(&bus, &HalpFakePciBusHandler, sizeof(BUS_HANDLER));
        bus.BusNumber = BusNumber;
        slot.u.AsULONG = SlotNumber;
    
        length = HalpGetPCIData(&bus,
                                &bus,
                                slot,
                                Buffer,
                                Offset,
                                Length
                                );
        
        return length;

    case Cmos:
        return HalpGetCmosData(0, SlotNumber, Buffer, Length);

    case EisaConfiguration:

        //
        // Fake a bus handler.
        //
        
        bus.BusNumber = 0;

        return HalpGetEisaData(&bus,
                               &bus,
                               SlotNumber,
                               Buffer,
                               Offset,
                               Length
                               );

    default:
        return 0;
    }
}

ULONG
HalSetBusData(
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    )
{
    return HalSetBusDataByOffset (BusDataType,BusNumber,SlotNumber,Buffer,0,Length);
}

ULONG
HalSetBusDataByOffset(
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    Dispatcher for SetBusData

--*/
{
    PCI_SLOT_NUMBER slot;
    BUS_HANDLER bus;

    switch (BusDataType) {
    case PCIConfiguration:

        RtlCopyMemory(&bus, &HalpFakePciBusHandler, sizeof(BUS_HANDLER));
        bus.BusNumber = BusNumber;
        slot.u.AsULONG = SlotNumber;

        return HalpSetPCIData(&bus,
                              &bus,
                              slot,
                              Buffer,
                              Offset,
                              Length
                              );
    case Cmos:

        return HalpSetCmosData(0, SlotNumber, Buffer, Length);

    default:
        return 0;
    }
}

NTSTATUS
HalAssignSlotResources (
    IN PUNICODE_STRING          RegistryPath,
    IN PUNICODE_STRING          DriverClassName       OPTIONAL,
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           DeviceObject          OPTIONAL,
    IN INTERFACE_TYPE           BusType,
    IN ULONG                    BusNumber,
    IN ULONG                    SlotNumber,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    )
{
    if (BusType == PCIBus) {
        //
        // Call through the HAL private dispatch table
        // for PCI-related translations.  This is part 
        // of transitioning the HAL out of the bus 
        // management business.
        //
        return HALPDISPATCH->HalPciAssignSlotResources(RegistryPath,
                                                       DriverClassName,
                                                       DriverObject,
                                                       DeviceObject,
                                                       BusType,
                                                       BusNumber,
                                                       SlotNumber,
                                                       AllocatedResources);
    } else {

        return HalpAssignSlotResources(RegistryPath,
                                       DriverClassName,
                                       DriverObject,
                                       DeviceObject,
                                       BusType,
                                       BusNumber,
                                       SlotNumber,
                                       AllocatedResources);
    }
}

NTSTATUS
HalpAssignSlotResources (
    IN PUNICODE_STRING          RegistryPath,
    IN PUNICODE_STRING          DriverClassName       OPTIONAL,
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           DeviceObject          OPTIONAL,
    IN INTERFACE_TYPE           BusType,
    IN ULONG                    BusNumber,
    IN ULONG                    SlotNumber,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    )
/*++

Routine Description:

    Dispatcher for AssignSlotResources

--*/
{
    BUS_HANDLER busHand;
    
    PAGED_CODE();
    
    switch (BusType) {
    case PCIBus:

        //
        // Fake a bus handler.
        //
    
        RtlCopyMemory(&busHand, &HalpFakePciBusHandler, sizeof(BUS_HANDLER));
        busHand.BusNumber = BusNumber;

        return HalpAssignPCISlotResources(&busHand,
                                          &busHand,
                                          RegistryPath,
                                          DriverClassName,
                                          DriverObject,
                                          DeviceObject,
                                          SlotNumber,
                                          AllocatedResources);

    default:
        return STATUS_NOT_IMPLEMENTED;
    }
    
}


ULONG
HalGetInterruptVector(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    )
/*++

Routine Description:

    Dispatcher for GetInterruptVector

--*/
{
    BUS_HANDLER busHand;
    
    //
    // If this is an ISA vector, pass it through the ISA vector
    // redirection table.
    //

    if (InterfaceType == Isa) {
        
        ASSERT(BusInterruptVector < PIC_VECTORS);
        
        BusInterruptVector = HalpPicVectorRedirect[BusInterruptVector];
        BusInterruptLevel = HalpPicVectorRedirect[BusInterruptLevel];
    }
    
    //
    // Fake bus handlers.
    //

    RtlCopyMemory(&busHand, &HalpFakePciBusHandler, sizeof(BUS_HANDLER));
    
    busHand.BusNumber = BusNumber;
    busHand.InterfaceType = InterfaceType;
    busHand.ParentHandler = &busHand;
    
    return HalpGetSystemInterruptVector(&busHand,
                                        &busHand,
                                        BusInterruptLevel,
                                        BusInterruptVector,
                                        Irql,
                                        Affinity);
}

BOOLEAN
HalTranslateBusAddress(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )
{
    if (InterfaceType == PCIBus) {
        //
        // Call through the HAL private dispatch table
        // for PCI-related translations.  This is part 
        // of transitioning the HAL out of the bus 
        // management business.
        //
        return HALPDISPATCH->HalPciTranslateBusAddress(InterfaceType,
                                                       BusNumber,
                                                       BusAddress,
                                                       AddressSpace,
                                                       TranslatedAddress);
    } else {
        return HalpTranslateBusAddress(InterfaceType,
                                       BusNumber,
                                       BusAddress,
                                       AddressSpace,
                                       TranslatedAddress);
    }
};

BOOLEAN
HalpTranslateBusAddress(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )
/*++

Routine Description:

    Dispatcher for TranslateBusAddress

--*/
{
    *TranslatedAddress = BusAddress;
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\pmpcisup.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\pmpcisup.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\pmpic.c ===
/*++

Module Name:

    pmpic.c

Abstract:

    This file contains functions that are specific to
    the PIC version of the ACPI hal.

Author:

    Jake Oshins

Environment:

    Kernel mode only.

Revision History:

*/

#include "halp.h"
#include "acpitabl.h"
#include "xxacpi.h"
#include "eisa.h"
#include "ixsleep.h"

VOID
HalpAcpiSetTempPicState(
    VOID
    );

VOID
HalpMaskAcpiInterrupt(
    VOID
    );

VOID
HalpUnmaskAcpiInterrupt(
    VOID
    );

extern PVOID   HalpEisaControlBase;
#define EISA_CONTROL (PUCHAR)&((PEISA_CONTROL) HalpEisaControlBase)

BOOLEAN HalpPicStateIntact = TRUE;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGELK, HalpAcpiSetTempPicState)
#pragma alloc_text(PAGELK, HalpSetAcpiEdgeLevelRegister)
#pragma alloc_text(PAGELK, HalpAcpiPicStateIntact)
#pragma alloc_text(PAGELK, HalpSaveInterruptControllerState)
#pragma alloc_text(PAGELK, HalpRestoreInterruptControllerState)
#pragma alloc_text(PAGELK, HalpSetInterruptControllerWakeupState)
#pragma alloc_text(PAGELK, HalpPostSleepMP)
#pragma alloc_text(PAGELK, HalpMaskAcpiInterrupt)
#pragma alloc_text(PAGELK, HalpUnmaskAcpiInterrupt)
#pragma alloc_text(PAGE, HaliSetVectorState)
#pragma alloc_text(PAGE, HaliIsVectorValid)
#endif

VOID
HaliSetVectorState(
    IN ULONG Vector,
    IN ULONG Flags
    )
{
    return;
}
BOOLEAN
HaliIsVectorValid(
    IN ULONG Vector
    )
{
    if (Vector < 16) {
        return TRUE;
    }
    
    return FALSE;
}
VOID
HalpAcpiSetTempPicState(
    VOID
    )
{
    ULONG flags;
    USHORT picMask;

    _asm {
        pushfd
        pop     eax
        mov     flags, eax
        cli
    }

    HalpInitializePICs(FALSE);

    //
    // Halacpi lets the PCI interrupt programming be
    // dynamic.  So...
    //
    // Unmask only the clock sources on the PIC and the
    // ACPI vector.  The rest of the vectors will be
    // unmasked later, after we have restored PCI IRQ
    // routing.
    //

    picMask = 0xfefe; // mask everything but clocks

    //
    // Unmask ACPI vector
    //

    picMask &= ~(1 << (UCHAR)HalpFixedAcpiDescTable.sci_int_vector);

    //
    // Write the mask into the hardware.
    //

    WRITE_PORT_UCHAR(EISA_CONTROL->Interrupt1ControlPort1,
                     (UCHAR)(picMask & 0xff));

    WRITE_PORT_UCHAR(EISA_CONTROL->Interrupt2ControlPort1,
                     (UCHAR)((picMask >> 8) & 0xff));

    //
    // For now, set the edge-level control register
    // so that all vectors are edge except the
    // ACPI vector.  This is done because the PIC
    // will trigger if an idle ISA vector is set to
    // edge.  After the ACPI driver resets all the
    // PCI vectors to what we thought they should be,
    //

    HalpSetAcpiEdgeLevelRegister();

    HalpPicStateIntact = FALSE;

    _asm {
        mov      eax, flags
        push     eax
        popfd
    }
}

VOID
HalpSetAcpiEdgeLevelRegister(
    VOID
    )
{
    USHORT  elcr;

    //
    // The idea here is to set the ELCR so that only the ACPI
    // vector is set to 'level.'  That way we can reprogram
    // the PCI interrupt router without worrying that the
    // PIC will start triggering endless interrupts because
    // we have a source programmed to level that is being
    // routed to the ISA bus.
    //

    if (HalpFixedAcpiDescTable.sci_int_vector < PIC_VECTORS) {

        elcr = 1 << HalpFixedAcpiDescTable.sci_int_vector;

        WRITE_PORT_UCHAR(EISA_CONTROL->Interrupt1EdgeLevel,
                         (UCHAR)(elcr & 0xff));

        WRITE_PORT_UCHAR(EISA_CONTROL->Interrupt2EdgeLevel,
                         (UCHAR)(elcr >> 8));
    }
}

VOID
HalpRestoreInterruptControllerState(
    VOID
    )
{
    ULONG flags;
    USHORT picMask;

    _asm {
        pushfd
        pop     eax
        mov     flags, eax
        cli
    }

    //
    // This function is called after PCI interrupt routing has
    // been restored.
    //

    WRITE_PORT_UCHAR(EISA_CONTROL->Interrupt1ControlPort1,
                     HalpMotherboardState.PicState.MasterMask);

    WRITE_PORT_UCHAR(EISA_CONTROL->Interrupt2ControlPort1,
                     HalpMotherboardState.PicState.SlaveMask);

    HalpRestorePicEdgeLevelRegister();

    HalpPicStateIntact = TRUE;

    _asm {
        mov      eax, flags
        push     eax
        popfd
    }

}

BOOLEAN
HalpAcpiPicStateIntact(
    VOID
    )
{
    return HalpPicStateIntact;
}

VOID
HalpSaveInterruptControllerState(
    VOID
    )
{
    HalpSavePicState();
}

VOID
HalpSetInterruptControllerWakeupState(
    ULONG Context
    )
{
    HalpAcpiSetTempPicState();
}

VOID
HalpPostSleepMP(
    IN LONG           NumberProcessors,
    IN volatile PLONG Number
    )
{
}

VOID
HalpMaskAcpiInterrupt(
    VOID
    )
{
}

VOID
HalpUnmaskAcpiInterrupt(
    VOID
    )
{
}


#if DBG

NTSTATUS
HalpGetApicIdByProcessorNumber(
    IN     UCHAR     Processor,
    IN OUT USHORT   *ApicId
    )

/*++

Routine Description:

    This routine only exists on DEBUG builds of the PIC ACPI HAL because
    that HAL is build MP and the SRAT code will be included.   The SRAT
    code will not be exercised but needs this routine in order to link.

Arguments:

    Ignored.

Return Value:

    STATUS_NOT_FOUND

--*/

{
    return STATUS_NOT_FOUND;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\pmsleep.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pmsleep.c

Abstract:

    This file provides the code that changes the system from
    the ACPI S0 (running) state to any one of the sleep states.

Author:

    Jake Oshins (jakeo) Feb. 11, 1997

Revision History:

--*/
#include "halp.h"
#include "acpitabl.h"
#include "xxacpi.h"
#include "kddll.h"
#include "ixsleep.h"

//
// Internal functions
//

NTSTATUS
HalpAcpiSleep(
    IN PVOID                    Context,
    IN LONG                     NumberProcessors,
    IN volatile PLONG           Number
    );

VOID
HalpSetClockBeforeSleep(
    VOID
    );

VOID
HalpSetClockAfterSleep(
    VOID
    );

BOOLEAN
HalpWakeupTimeElapsed(
    VOID
    );

VOID
HalpFreeTiledCR3 (
    VOID
    );

VOID
HalpReenableAcpi(
    VOID
    );

VOID
HalpPiix4Detect(
    BOOLEAN DuringBoot
    );

typedef struct _ERESOURCE {
    LIST_ENTRY SystemResourcesList;
    PVOID OwnerTable;
    SHORT ActiveCount;
    USHORT Flag;
    PKSEMAPHORE SharedWaiters;
    PKEVENT ExclusiveWaiters;
    LIST_ENTRY OwnerThreads[2];
    ULONG ContentionCount;
    USHORT NumberOfSharedWaiters;
    USHORT NumberOfExclusiveWaiters;
    union {
        PVOID Address;
        ULONG CreatorBackTraceIndex;
    };

    KSPIN_LOCK SpinLock;
} ERESOURCE, *PERESOURCE;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGELK, HalpAcpiPreSleep)
#pragma alloc_text(PAGELK, HalpAcpiPostSleep)
#pragma alloc_text(PAGELK, HalpWakeupTimeElapsed)
#pragma alloc_text(PAGELK, HalpReenableAcpi)
#pragma alloc_text(PAGELK, HaliSetWakeEnable)
#pragma alloc_text(PAGELK, HaliSetWakeAlarm)
#pragma alloc_text(PAGELK, HalpMapNvsArea)
#pragma alloc_text(PAGELK, HalpFreeNvsBuffers)
#endif

HAL_WAKEUP_STATE HalpWakeupState;

#if DBG
BOOLEAN          HalpFailSleep = FALSE;
#endif

#define PM1_TMR_EN 0x0001
#define PM1_RTC_EN 0x0400

//
// For re-enabling the debugger's com port.
//
extern PUCHAR KdComPortInUse;

extern PACPI_BIOS_MULTI_NODE HalpAcpiMultiNode;
extern PUCHAR HalpAcpiNvsData;
extern PVOID  *HalpNvsVirtualAddress;


BOOLEAN
HalpAcpiPreSleep(
    SLEEP_STATE_CONTEXT Context
    )
/*++

Routine Description:

Arguments:

    none

Return Value:

    status

--*/
{
    USHORT pmTimer;
    PUSHORT pm1a;
    PUSHORT pm1b;
    PUSHORT pm1astatus;
    PUSHORT pm1bstatus;
    BOOLEAN wakeupElapsed;

    pm1astatus = (PUSHORT) HalpFixedAcpiDescTable.pm1a_evt_blk_io_port;
    pm1bstatus = (PUSHORT) HalpFixedAcpiDescTable.pm1b_evt_blk_io_port;
    pm1a = (PUSHORT)(HalpFixedAcpiDescTable.pm1a_evt_blk_io_port +
                     (HalpFixedAcpiDescTable.pm1_evt_len / 2));

    pm1b = (PUSHORT)(HalpFixedAcpiDescTable.pm1b_evt_blk_io_port +
                     (HalpFixedAcpiDescTable.pm1_evt_len / 2));

    HalpSleepContext.AsULONG = Context.AsULONG;

#if DBG
    if (HalpFailSleep) {
        return FALSE;
    }
#endif

    //
    // If we should have woken up already, don't sleep.
    //
    
    wakeupElapsed = HalpWakeupTimeElapsed();

    //
    // If an RTC alarm is set, then enable it and disable
    // periodic interrupts (for profiling.)
    //
    if (!wakeupElapsed) {
        HalpSetClockBeforeSleep();
    }

    //
    // Save the (A)PIC for any sleep state, as we need to play
    // with it on the way back up again.
    //
    HalpSaveInterruptControllerState();
    if (Context.bits.Flags & SLEEP_STATE_SAVE_MOTHERBOARD) {

        HalpSaveDmaControllerState();
        HalpSaveTimerState();

    }

    //
    // We need to make sure that the PM Timer is disabled from this
    // point onward. We also need to make that the RTC Enable is only
    // enabled if the RTC should wake up the computer
    //
    pmTimer = READ_PORT_USHORT(pm1a);
    if (HalpFixedAcpiDescTable.pm1b_evt_blk_io_port) {

        pmTimer |= READ_PORT_USHORT(pm1b);

    }

    //
    // Clear the timer enable bit.
    //
    pmTimer &= ~PM1_TMR_EN;

    //
    // Check to see if we the machine supports RTC Wake in Fixed Feature
    // space. Some machines implement RTC support via control methods
    //
    if ( !(HalpFixedAcpiDescTable.flags & RTC_WAKE_GENERIC) ) {

        //
        // Check to see if we need to disable/enable the RTC alarm
        //
        if (!HalpWakeupState.RtcWakeupEnable) {

            pmTimer &= ~PM1_RTC_EN;

        } else {

            pmTimer |= PM1_RTC_EN;

        }

    }

    //
    // Write it back into the hardware.
    //
    WRITE_PORT_USHORT(pm1a, pmTimer);
    if (HalpFixedAcpiDescTable.pm1b_evt_blk_io_port) {

        WRITE_PORT_USHORT(pm1b, pmTimer);

    }

    //
    // At this point, we should be running with interrupts disabled and
    // the TMR_EN bit cleared. This is a good place to clear the PM1 Status
    // Register
    //
    pmTimer = READ_PORT_USHORT( pm1astatus );
    if (HalpFixedAcpiDescTable.pm1b_evt_blk_io_port) {

        pmTimer |= READ_PORT_USHORT( pm1bstatus );

    }
    WRITE_PORT_USHORT( pm1astatus, pmTimer );
    if (HalpFixedAcpiDescTable.pm1b_evt_blk_io_port) {

        WRITE_PORT_USHORT( pm1bstatus, pmTimer );

    }

    //
    // Check to see if we need to disable all wakeup events.
    //

    if (!HalpWakeupState.GeneralWakeupEnable) {

        AcpiEnableDisableGPEvents(FALSE);

    } else {

        //
        // Only call this before going to sleep --- waking up should
        // reset the GPEs to the 'proper' value
        //
        AcpiGpeEnableWakeEvents();

    }

    HalpPreserveNvsArea();

    if (wakeupElapsed) {
        return FALSE;
    } else {
        return TRUE;
    }
}

BOOLEAN
HalpAcpiPostSleep(
    ULONG Context
    )
{
    USHORT pmTimer;
    PUSHORT pm1a;
    PUSHORT pm1b;
    BOOLEAN ProfileInterruptEnabled;

#ifdef PICACPI
    extern ULONG HalpProfilingStopped;

    ProfileInterruptEnabled = (HalpProfilingStopped == 0);
#else
    extern ULONG HalpProfileRunning;

    ProfileInterruptEnabled = (HalpProfileRunning == 1);
#endif

    pm1a = (PUSHORT)(HalpFixedAcpiDescTable.pm1a_evt_blk_io_port +
                     (HalpFixedAcpiDescTable.pm1_evt_len / 2));

    pm1b = (PUSHORT)(HalpFixedAcpiDescTable.pm1b_evt_blk_io_port +
                     (HalpFixedAcpiDescTable.pm1_evt_len / 2));


    //
    // Read the currently set PM1 Enable bits
    //
    pmTimer = READ_PORT_USHORT(pm1a);
    if (HalpFixedAcpiDescTable.pm1b_evt_blk_io_port) {

        pmTimer |= READ_PORT_USHORT(pm1b);

    }

    //
    // Set the timer enable bit. Clear the RTC enable bit
    //
    pmTimer |= PM1_TMR_EN;
    pmTimer &= ~PM1_RTC_EN;

    //
    // Write back the new PM1 Enable bits
    //
    WRITE_PORT_USHORT(pm1a, pmTimer);
    if (HalpFixedAcpiDescTable.pm1b_evt_blk_io_port) {

        WRITE_PORT_USHORT(pm1b, pmTimer);

    }

    //
    // Unset the RTC alarm and re-enable periodic interrupts.
    //
    HalpSetClockAfterSleep();

    HalpWakeupState.RtcWakeupEnable = FALSE;

    *((PULONG)HalpWakeVector) = 0;

    HalpSetInterruptControllerWakeupState(Context);

    if (HalpSleepContext.bits.Flags & SLEEP_STATE_SAVE_MOTHERBOARD) {

        //
        // If Kd was in use, then invalidate it.  It will re-sync itself.
        //
        if (KdComPortInUse) {
            KdRestore(TRUE);
        }

        HalpRestoreDmaControllerState();

        HalpRestoreTimerState();

    }

    HalpPiix4Detect(FALSE);

    //
    // Enable all GPEs, not just the wake ones
    //

    AcpiEnableDisableGPEvents(TRUE);

    HalpRestoreNvsArea();

    HalpResetSBF();

    //
    // If we were profiling before, fire up the profile interrupt
    //
    if (ProfileInterruptEnabled) {
        HalStartProfileInterrupt(0);
    }

    return TRUE;
}


BOOLEAN
HalpWakeupTimeElapsed(
    VOID
    )
{
    LARGE_INTEGER wakeupTime, currentTime;
    TIME_FIELDS currentTimeFields;

    //
    // Check to see if a wakeup timer has already expired.
    //
    if (HalpWakeupState.RtcWakeupEnable) {

        HalQueryRealTimeClock(&currentTimeFields);

        RtlTimeFieldsToTime(&currentTimeFields,
                            &currentTime);

        RtlTimeFieldsToTime(&HalpWakeupState.RtcWakeupTime,
                            &wakeupTime);

        if ((ULONGLONG)wakeupTime.QuadPart < 
            (ULONGLONG)currentTime.QuadPart) {
            return TRUE;
        }
    }

    return FALSE;
}

NTSTATUS
HaliSetWakeAlarm (
        IN ULONGLONG    WakeSystemTime,
        IN PTIME_FIELDS WakeTimeFields OPTIONAL
        )
/*++

Routine Description:

    This routine sets the real-time clock's alarm to go
    off at a specified time in the future and programs
    the ACPI chipset so that this wakes the computer.

Arguments:

    WakeSystemTime - amount of time that passes before we wake
    WakeTimeFields - time to wake broken down into TIME_FIELDS

Return Value:

    status

--*/
{
    if (WakeSystemTime == 0) {

        HalpWakeupState.RtcWakeupEnable = FALSE;
        return STATUS_SUCCESS;

    }

    ASSERT( WakeTimeFields );
    HalpWakeupState.RtcWakeupEnable = TRUE;
    HalpWakeupState.RtcWakeupTime = *WakeTimeFields;
    return HalpSetWakeAlarm(WakeSystemTime,
                            WakeTimeFields);
}

VOID
HaliSetWakeEnable(
        IN BOOLEAN      Enable
        )
/*++

Routine Description:

    This routine is called to set the policy for waking up.
    As we go to sleep, the global HalpWakeupState will be
    read and the hardware set accordingly.

Arguments:

    Enable - true or false

Return Value:

--*/
{
    //
    // Always clear the RTC wake --- we expect that someone will
    // set the alarm after they call this function
    //
    HalpWakeupState.RtcWakeupEnable     = FALSE;

    //
    // Toggle the generate wake up bit
    //
    HalpWakeupState.GeneralWakeupEnable = Enable;
}

VOID
HalpReenableAcpi(
    VOID
    )
/*++

Routine Description:

    This calls into the ACPI driver to switch back into ACPI mode,
    presumably after S4 and sets the ACPI registers that the HAL
    controls.

Arguments:

Return Value:

--*/
{
    // TEMPTEMP?
    HalpInitializeClock();

    AcpiInitEnableAcpi(TRUE);
    AcpiEnableDisableGPEvents(TRUE);
}

VOID
HalpMapNvsArea(
    VOID
    )
{
    NTSTATUS status;
    ULONG i, bufferSize, bufferOffset, nodeCount;

    PAGED_CODE();

    status = HalpAcpiFindRsdt(&HalpAcpiMultiNode);

    if (!NT_SUCCESS(status)) {
        return;
    }

    if (HalpAcpiMultiNode->Count == 0) {

        //
        // There's no work to do here.
        //

        goto HalpMapNvsError;
    }

    //
    // Find total size of the buffer we need.
    //

    bufferSize = 0;
    nodeCount = 0;

    for (i = 0; i < HalpAcpiMultiNode->Count; i++) {

        if (HalpAcpiMultiNode->E820Entry[i].Type == AcpiAddressRangeNVS) {

            ASSERT(HalpAcpiMultiNode->E820Entry[i].Length.HighPart == 0);

            bufferSize += HalpAcpiMultiNode->E820Entry[i].Length.LowPart;
            nodeCount++;
        }
    }

    if (bufferSize == 0) {

        //
        // There's no work to do here.
        //

        goto HalpMapNvsError;
    }

#if DBG
    if (bufferSize > (20 * PAGE_SIZE)) {
        DbgPrint("HALACPI:  The BIOS wants the OS to preserve %x bytes\n", bufferSize);
    }
#endif

    HalpAcpiNvsData = ExAllocatePoolWithTag(NonPagedPool,
                                            bufferSize,
                                            'AlaH');

    if (!HalpAcpiNvsData) {

        DbgPrint("HALACPI:  The BIOS's non-volatile data will not be preserved\n");
        goto HalpMapNvsError;
    }

    HalpNvsVirtualAddress = ExAllocatePoolWithTag(NonPagedPool,
                                                  (nodeCount + 1) * sizeof(PVOID),
                                                  'AlaH');

    if (!HalpNvsVirtualAddress) {
        goto HalpMapNvsError;
    }


    //
    // Make a mapping for each run.
    //

    bufferOffset = 0;
    nodeCount = 0;

    for (i = 0; i < HalpAcpiMultiNode->Count; i++) {

        if (HalpAcpiMultiNode->E820Entry[i].Type == AcpiAddressRangeNVS) {

            HalpNvsVirtualAddress[nodeCount] =
                MmMapIoSpace(HalpAcpiMultiNode->E820Entry[i].Base,
                             HalpAcpiMultiNode->E820Entry[i].Length.LowPart,
                             TRUE);

            ASSERT(HalpNvsVirtualAddress[nodeCount]);

            nodeCount++;
        }
    }

    //
    // Mark the end.
    //

    HalpNvsVirtualAddress[nodeCount] = NULL;

    return;

HalpMapNvsError:

    if (HalpAcpiMultiNode)          ExFreePool(HalpAcpiMultiNode);
    if (HalpNvsVirtualAddress)      ExFreePool(HalpNvsVirtualAddress);
    if (HalpAcpiNvsData)            ExFreePool(HalpAcpiNvsData);

    HalpAcpiMultiNode = NULL;

    return;
}

VOID
HalpPreserveNvsArea(
    VOID
    )
{
    ULONG i, dataOffset = 0, nodeCount = 0;

    if (!HalpAcpiMultiNode) {

        //
        // Either there was nothing to save or there
        // was a fatal error.
        //

        return;
    }

    for (i = 0; i < HalpAcpiMultiNode->Count; i++) {

        if (HalpAcpiMultiNode->E820Entry[i].Type == AcpiAddressRangeNVS) {

            //
            // Copy from BIOS memory to temporary buffer.
            //

            RtlCopyMemory(HalpAcpiNvsData + dataOffset,
                          HalpNvsVirtualAddress[nodeCount],
                          HalpAcpiMultiNode->E820Entry[i].Length.LowPart);

            nodeCount++;
            dataOffset += HalpAcpiMultiNode->E820Entry[i].Length.LowPart;
        }
    }
}

VOID
HalpRestoreNvsArea(
    VOID
    )
{
    ULONG i, dataOffset = 0, nodeCount = 0;

    if (!HalpAcpiMultiNode) {

        //
        // Either there was nothing to save or there
        // was a fatal error.
        //

        return;
    }

    for (i = 0; i < HalpAcpiMultiNode->Count; i++) {

        if (HalpAcpiMultiNode->E820Entry[i].Type == AcpiAddressRangeNVS) {

            //
            // Copy from temporary buffer to BIOS area.
            //

            RtlCopyMemory(HalpNvsVirtualAddress[nodeCount],
                          HalpAcpiNvsData + dataOffset,
                          HalpAcpiMultiNode->E820Entry[i].Length.LowPart);

            nodeCount++;
            dataOffset += HalpAcpiMultiNode->E820Entry[i].Length.LowPart;
            
        }
    }
}

VOID
HalpFreeNvsBuffers(
    VOID
    )
{
    ULONG i, nodeCount = 0;

    PAGED_CODE();

    if (!HalpAcpiMultiNode) {

        //
        // Either there was nothing to save or there
        // was a fatal error.
        //

        return;
    }

    for (i = 0; i < HalpAcpiMultiNode->Count; i++) {

        if (HalpAcpiMultiNode->E820Entry[i].Type == AcpiAddressRangeNVS) {

            //
            // Give back all the PTEs that we took earlier
            //

            MmUnmapIoSpace(HalpNvsVirtualAddress[nodeCount],
                           HalpAcpiMultiNode->E820Entry[i].Length.LowPart);

            nodeCount++;
        }
    }

    ASSERT(HalpAcpiMultiNode);
    ASSERT(HalpNvsVirtualAddress);
    ASSERT(HalpAcpiNvsData);

    ExFreePool(HalpAcpiMultiNode);
    ExFreePool(HalpNvsVirtualAddress);
    ExFreePool(HalpAcpiNvsData);

    HalpAcpiMultiNode = NULL;
    HalpNvsVirtualAddress = NULL;
    HalpAcpiNvsData = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\pmisabus.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pmapic.c

Abstract:

    Implements functions specific to ISA busses
    in ACPI-APIC machines.

Author:

    Jake Oshins (jakeo) 11-October-1997

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "acpitabl.h"

NTSTATUS
TranslateGlobalVectorToIsaVector(
    IN  ULONG   GlobalVector,
    OUT PULONG  IsaVector
    );

NTSTATUS
HalacpiIrqTranslateResourceRequirementsIsa(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    );

NTSTATUS
HalacpiIrqTranslateResourcesIsa(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    );

extern ULONG HalpPicVectorRedirect[];
extern FADT HalpFixedAcpiDescTable;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, TranslateGlobalVectorToIsaVector)
#pragma alloc_text(PAGE, HalacpiIrqTranslateResourceRequirementsIsa)
#pragma alloc_text(PAGE, HalacpiIrqTranslateResourcesIsa)
#pragma alloc_text(PAGE, HalacpiGetInterruptTranslator)
#endif

#define TranslateIsaVectorToGlobalVector(vector)  \
            (HalpPicVectorRedirect[vector])

NTSTATUS
TranslateGlobalVectorToIsaVector(
    IN  ULONG   GlobalVector,
    OUT PULONG  IsaVector
    )
{
    UCHAR   i;

    for (i = 0; i < PIC_VECTORS; i++) {

        if (HalpPicVectorRedirect[i] == GlobalVector) {

            *IsaVector = i;

            return STATUS_SUCCESS;
        }
    }

    return STATUS_NOT_FOUND;
}


NTSTATUS
HalacpiIrqTranslateResourceRequirementsIsa(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    )
/*++

Routine Description:

    This function is basically a wrapper for
    HalIrqTranslateResourceRequirementsRoot that understands
    the weirdnesses of the ISA bus.

Arguments:

Return Value:

    status

--*/
{
    PIO_RESOURCE_DESCRIPTOR modSource, target, rootTarget;
    NTSTATUS                status;
    BOOLEAN                 deleteResource;
    ULONG                   sourceCount = 0;
    ULONG                   targetCount = 0;
    ULONG                   resource, resourceLength;
    ULONG                   rootCount;
    ULONG                   irq, startIrq, endIrq;
    ULONG                   maxTargets;

    PAGED_CODE();
    ASSERT(Source->Type == CmResourceTypeInterrupt);

    maxTargets = Source->u.Interrupt.MaximumVector -
                     Source->u.Interrupt.MinimumVector + 3;

    resourceLength = sizeof(IO_RESOURCE_DESCRIPTOR) * maxTargets;

    modSource = ExAllocatePoolWithTag(PagedPool, resourceLength, HAL_POOL_TAG);

    if (!modSource) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modSource, resourceLength);

    //
    // Is the PIC_SLAVE_IRQ in this resource?
    //
    if ((Source->u.Interrupt.MinimumVector <= PIC_SLAVE_IRQ) &&
        (Source->u.Interrupt.MaximumVector >= PIC_SLAVE_IRQ)) {

        //
        // Clip the maximum
        //
        if (Source->u.Interrupt.MinimumVector < PIC_SLAVE_IRQ) {

            modSource[sourceCount] = *Source;

            modSource[sourceCount].u.Interrupt.MinimumVector =
                Source->u.Interrupt.MinimumVector;

            modSource[sourceCount].u.Interrupt.MaximumVector =
                PIC_SLAVE_IRQ - 1;

            sourceCount++;
        }

        //
        // Clip the minimum
        //
        if (Source->u.Interrupt.MaximumVector > PIC_SLAVE_IRQ) {

            modSource[sourceCount] = *Source;

            modSource[sourceCount].u.Interrupt.MaximumVector =
                Source->u.Interrupt.MaximumVector;

            modSource[sourceCount].u.Interrupt.MinimumVector =
                PIC_SLAVE_IRQ + 1;

            sourceCount++;
        }

        //
        // In ISA machines, the PIC_SLAVE_IRQ is rerouted
        // to PIC_SLAVE_REDIRECT.  So find out if PIC_SLAVE_REDIRECT
        // is within this list. If it isn't we need to add it.
        //
        if (!((Source->u.Interrupt.MinimumVector <= PIC_SLAVE_REDIRECT) &&
             (Source->u.Interrupt.MaximumVector >= PIC_SLAVE_REDIRECT))) {

            modSource[sourceCount] = *Source;

            modSource[sourceCount].u.Interrupt.MinimumVector = PIC_SLAVE_REDIRECT;
            modSource[sourceCount].u.Interrupt.MaximumVector = PIC_SLAVE_REDIRECT;

            sourceCount++;
        }

    } else {

        *modSource = *Source;
        sourceCount = 1;
    }

    //
    // Clip out the SCI vector, if it is here.  Also limit the vectors
    // to those that might be on an ISA bus.
    //

    for (resource = 0; resource < sourceCount; resource++) {

        //
        // Make sure that all values are within ISA ranges.
        //

        if ((modSource[resource].u.Interrupt.MaximumVector >= PIC_VECTORS) ||
            (modSource[resource].u.Interrupt.MinimumVector >= PIC_VECTORS)) {

            ExFreePool(modSource);
            return STATUS_UNSUCCESSFUL;
        }

        if ((modSource[resource].u.Interrupt.MinimumVector <=
                HalpFixedAcpiDescTable.sci_int_vector) &&
            (modSource[resource].u.Interrupt.MaximumVector >=
                HalpFixedAcpiDescTable.sci_int_vector)) {

            //
            // The SCI vector is within this range.
            //

            if (modSource[resource].u.Interrupt.MinimumVector <
                    HalpFixedAcpiDescTable.sci_int_vector) {

                //
                // Put a new range on the end of modSource.
                //

                modSource[sourceCount].u.Interrupt.MinimumVector =
                    modSource[resource].u.Interrupt.MinimumVector;

                modSource[sourceCount].u.Interrupt.MaximumVector =
                    HalpFixedAcpiDescTable.sci_int_vector - 1;

                sourceCount++;
            }

            if (modSource[resource].u.Interrupt.MaximumVector >
                    HalpFixedAcpiDescTable.sci_int_vector) {

                //
                // Put a new range on the end of modSource.
                //

                modSource[sourceCount].u.Interrupt.MinimumVector =
                    HalpFixedAcpiDescTable.sci_int_vector + 1;

                modSource[sourceCount].u.Interrupt.MaximumVector =
                    modSource[resource].u.Interrupt.MaximumVector;

                sourceCount++;
            }

            //
            // Now remove the range that we just broke up.
            //

            RtlMoveMemory(modSource + resource,
                          modSource + resource + 1,
                          sizeof(IO_RESOURCE_DESCRIPTOR) *
                            (sourceCount - resource));

            sourceCount--;
        }
    }


    target = ExAllocatePoolWithTag(PagedPool, resourceLength, HAL_POOL_TAG);

    if (!target) {
        ExFreePool(modSource);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(target, resourceLength);

    //
    // Now translate each range from ISA vectors to ACPI
    // "global system interrupt vectors."  Since GSIVs aren't
    // necessarily contiguous with respect to the ISA vectors,
    // this may involve breaking each range up into smaller
    // ranges, each independently translated into the GSIV space.
    //
    for (resource = 0; resource < sourceCount; resource++) {

        //
        // For each existing resource, start with the minimum
        // and maximum, unchanged.
        //

        irq    = modSource[resource].u.Interrupt.MinimumVector;
        endIrq = modSource[resource].u.Interrupt.MaximumVector;

        do {

            //
            // Now cycle through every IRQ in this range, testing
            // to see if its translated value is contiguous
            // with respect to the translated value of the next
            // IRQ in the range.
            //

            startIrq = irq;

            for (; irq < endIrq; irq++) {

                if (TranslateIsaVectorToGlobalVector(irq) + 1 !=
                    TranslateIsaVectorToGlobalVector(irq + 1)) {

                    //
                    // This range is not contiguous.  Stop now
                    // and create a target range.
                    //

                    break;
                }
            }

            //
            // Clone the source descriptor
            //
            target[targetCount] = *Source;

            //
            // Fill in the relevant changes.
            //
            target[targetCount].u.Interrupt.MinimumVector =
                TranslateIsaVectorToGlobalVector(startIrq);

            target[targetCount].u.Interrupt.MaximumVector =
                TranslateIsaVectorToGlobalVector(irq);


            ASSERT(target[targetCount].u.Interrupt.MinimumVector <=
                     target[targetCount].u.Interrupt.MaximumVector);

            targetCount++;

        } while (irq != endIrq);
    }

    *TargetCount = targetCount;

    if (targetCount > 0) {

        *Target = target;

    } else {

        ExFreePool(target);
    }

    ExFreePool(modSource);
    return STATUS_SUCCESS;
}

NTSTATUS
HalacpiIrqTranslateResourcesIsa(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    )
/*++

Routine Description:

    This function is basically a wrapper for
    HalIrqTranslateResourcesRoot that understands
    the weirdnesses of the ISA bus.

Arguments:

Return Value:

    status

--*/
{
    NTSTATUS    status;
    BOOLEAN     usePicSlave = FALSE;
    ULONG       i;
    ULONG       vector;

    PAGED_CODE();

    ASSERT(Source->Type == CmResourceTypeInterrupt);

    //
    // Copy everything
    //
    *Target = *Source;

    switch (Direction) {
    case TranslateChildToParent:

        Target->u.Interrupt.Level  =
            TranslateIsaVectorToGlobalVector(Source->u.Interrupt.Level);

        Target->u.Interrupt.Vector =
            TranslateIsaVectorToGlobalVector(Source->u.Interrupt.Vector);

        break;

    case TranslateParentToChild:

        status = TranslateGlobalVectorToIsaVector(Source->u.Interrupt.Level,
                                                  &vector);

        if (!NT_SUCCESS(status)) {
            return status;
        }

        Target->u.Interrupt.Level = vector;

        status = TranslateGlobalVectorToIsaVector(Source->u.Interrupt.Vector,
                                                  &vector);

        if (!NT_SUCCESS(status)) {
            return status;
        }

        Target->u.Interrupt.Vector = vector;

        //
        // Because the ISA interrupt controller is
        // cascaded, there is one case where there is
        // a two-to-one mapping for interrupt sources.
        // (On a PC, both 2 and 9 trigger vector 9.)
        //
        // We need to account for this and deliver the
        // right value back to the driver.
        //

        if (Target->u.Interrupt.Level == PIC_SLAVE_REDIRECT) {

            //
            // Search the Alternatives list.  If it contains
            // PIC_SLAVE_IRQ but not PIC_SLAVE_REDIRECT,
            // we should return PIC_SLAVE_IRQ.
            //

            for (i = 0; i < AlternativesCount; i++) {

                if ((Alternatives[i].u.Interrupt.MinimumVector >= PIC_SLAVE_REDIRECT) &&
                    (Alternatives[i].u.Interrupt.MaximumVector <= PIC_SLAVE_REDIRECT)) {

                    //
                    // The list contains, PIC_SLAVE_REDIRECT.  Stop
                    // looking.
                    //

                    usePicSlave = FALSE;
                    break;
                }

                if ((Alternatives[i].u.Interrupt.MinimumVector >= PIC_SLAVE_IRQ) &&
                    (Alternatives[i].u.Interrupt.MaximumVector <= PIC_SLAVE_IRQ)) {

                    //
                    // The list contains, PIC_SLAVE_IRQ.  Use it
                    // unless we find PIC_SLAVE_REDIRECT later.
                    //

                    usePicSlave = TRUE;
                }
            }

            if (usePicSlave) {

                Target->u.Interrupt.Level  = PIC_SLAVE_IRQ;
                Target->u.Interrupt.Vector = PIC_SLAVE_IRQ;
            }
        }

        break;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
HalacpiGetInterruptTranslator(
	IN INTERFACE_TYPE ParentInterfaceType,
	IN ULONG ParentBusNumber,
	IN INTERFACE_TYPE BridgeInterfaceType,
	IN USHORT Size,
	IN USHORT Version,
	OUT PTRANSLATOR_INTERFACE Translator,
	OUT PULONG BridgeBusNumber
	)
/*++

Routine Description:


Arguments:

	ParentInterfaceType - The type of the bus the bridge lives on (normally PCI).

	ParentBusNumber - The number of the bus the bridge lives on.

	ParentSlotNumber - The slot number the bridge lives in (where valid).

	BridgeInterfaceType - The bus type the bridge provides (ie ISA for a PCI-ISA bridge).

	ResourceType - The resource type we want to translate.

	Size - The size of the translator buffer.

	Version - The version of the translator interface requested.

	Translator - Pointer to the buffer where the translator should be returned

	BridgeBusNumber - Pointer to where the bus number of the bridge bus should be returned

Return Value:

    Returns the status of this operation.

--*/
{
    PAGED_CODE();

    UNREFERENCED_PARAMETER(ParentInterfaceType);
    UNREFERENCED_PARAMETER(ParentBusNumber);

    ASSERT(Version == HAL_IRQ_TRANSLATOR_VERSION);
    ASSERT(Size >= sizeof (TRANSLATOR_INTERFACE));

    switch (BridgeInterfaceType) {
    case Eisa:
    case Isa:
    case InterfaceTypeUndefined:   // special "IDE" cookie

        //
        // Pass back an interface for an IRQ translator for
        // the (E)ISA interrupts.
        //
        RtlZeroMemory(Translator, sizeof (TRANSLATOR_INTERFACE));

        Translator->Size = sizeof (TRANSLATOR_INTERFACE);
        Translator->Version = HAL_IRQ_TRANSLATOR_VERSION;
        Translator->InterfaceReference = &HalTranslatorReference;
        Translator->InterfaceDereference = &HalTranslatorDereference;
        Translator->TranslateResources = &HalacpiIrqTranslateResourcesIsa;
        Translator->TranslateResourceRequirements = &HalacpiIrqTranslateResourceRequirementsIsa;

        return STATUS_SUCCESS;

    default:
        return STATUS_NOT_IMPLEMENTED;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\pmtimerc.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    pmtimerc.c

Abstract:

    Implements workarounds for PIIX4 bugs.  The
    nature of the ACPI timer in PIIX4 is that it
    occasionally returns completely bogus data.
    Intel claims that this happens about 0.02% of
    the time when it is polled continuously.  As NT
    almost never polls it continuously, we don't
    really know what the real behavior is.

    The workaround is something like this:  On
    every clock tick, we read the timer.  Using this
    value, we compute an upper bound for what the
    timer may read by the next clock tick.  We also
    record the minimum value ever returned.  If, at
    any time, we read the timer and it does not fall
    within the minimum and upper bound, then we read
    it again.  If it either falls within the bounds
    or it is very close to the last read, we use it.
    If not, we read it again.

    This behavior allows us to read the timer only
    once almost all the time that we need a time
    stamp.  Exiting the debugger is almost guaranteed
    to cause the read-twice behavior.

Author:

    Jake Oshins (jakeo) 30-Oct-1998

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#ifdef APIC_HAL
#include "apic.inc"
#include "ntapic.inc"
#endif

BOOLEAN
HalpPmTimerSpecialStall(
    IN ULONG Ticks
    );

BOOLEAN
HalpPmTimerScaleTimers(
    VOID
    );

LARGE_INTEGER
HalpPmTimerQueryPerfCount(
   OUT PLARGE_INTEGER PerformanceFrequency OPTIONAL
   );

VOID
HalpAdjustUpperBoundTable2X(
    VOID
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, HalpPmTimerScaleTimers)
#pragma alloc_text(INIT, HalpPmTimerSpecialStall)
#pragma alloc_text(INIT, HalpAdjustUpperBoundTable2X)
#endif

typedef struct {
    ULONG   CurrentTimePort;
    volatile ULONG TimeLow;
    volatile ULONG TimeHigh2;
    volatile ULONG TimeHigh1;
    ULONG   MsbMask;
    ULONG   BiasLow;
    ULONG   BiasHigh;
    volatile ULONG UpperBoundLow;
    volatile ULONG UpperBoundHigh2;
    volatile ULONG UpperBoundHigh1;
} TIMER_INFO, *PTIMER_INFO;

typedef struct {
    ULONG   RawRead[2];
    ULONG   AdjustedLow[2];
    ULONG   AdjustedHigh[2];
    ULONG   TITL;
    ULONG   TITH;
    ULONG   UBL;
    ULONG   UBH;
    ULONG   ReturnedLow;
    ULONG   ReturnedHigh;
    ULONG   ReadCount;
    ULONG   TickMin;
    ULONG   TickCount;
    ULONG   TickNewUB;
    //UCHAR   padding[4];
} TIMER_PERF_INDEX ,*PTIMER_PERF_INDEX;

extern TIMER_INFO TimerInfo;

#if DBG
ULONG LastKQPCValue[3] = {0};
static ULARGE_INTEGER LastClockSkew = { 0, 0 };
#endif

#ifndef NO_PM_KEQPC

extern ULONG HalpCurrentMSRateTableIndex;
extern UCHAR HalpBrokenAcpiTimer;
extern UCHAR HalpPiix4;
extern PVOID QueryTimer;

#if DBG
extern TIMER_PERF_INDEX TimerPerf[];
extern ULONG TimerPerfIndex;
#endif

//
// The UpperBoundTable contains the values which should be added
// to the current counter value to ensure that the upper bound is
// reasonable.  Values listed here are for all the 15 possible
// timer tick lengths.  The unit is "PM Timer Ticks" and the
// value corresponds to the number of ticks that will pass in
// roughly two timer ticks at this rate.
//
#define UPPER_BOUND_TABLE_SIZE 15
static ULONG HalpPiix4UpperBoundTable[] = {
#if 0
    20000 ,        //  1 ms
    35000 ,        //  2 ms
    50000 ,        //  3 ms
    65000 ,        //  4 ms
    85000 ,        //  5 ms
    100000,        //  6 ms
    115000,        //  7 ms
    130000,        //  8 ms
    150000,        //  9 ms
    165000,        // 10 ms
    180000,        // 11 ms
    195000,        // 12 ms
    211000,        // 13 ms
    230000,        // 14 ms
    250000         // 15 ms
#endif
    14318,
    28636,
    42954,
    57272,
    71590,
    85908,
    100226,
    114544,
    128862,
    143180,
    157498,
    171818,
    186136,
    200454,
    214772
};

VOID
HalpAdjustUpperBoundTable2X(
    VOID
    )
/*++

Routine Description:

    This adjusts the upper bound table for PM timer running at 2X

Arguments:

    None

Return Value:

    None

--*/
{
    ULONG Looper;

    for (Looper = 0; Looper < UPPER_BOUND_TABLE_SIZE; Looper++) {
        HalpPiix4UpperBoundTable[Looper] *= 2;
    }
}


ULONG
HalpQuery8254Counter(
    VOID
    );

static ULARGE_INTEGER ClockSkew = { 0, 0 };
static BOOLEAN PositiveSkew = TRUE;

#ifdef TIMER_DBG
static BOOLEAN DoItOnce = TRUE;
static BOOLEAN PacketLog = TRUE;
static BOOLEAN TimerTick = FALSE;

static ULONG NegativeGlitches = 0;
static ULONG PositiveGlitches = 0;

static ULONG PacketLogCount = 5;

typedef struct _TIMER_PACKET {
    ULONG Hardware;
    ULARGE_INTEGER CurrentRead0;
    ULARGE_INTEGER TimeStamp;
    ULARGE_INTEGER Minimum;
    ULARGE_INTEGER Maximum;
    BOOLEAN PositiveSkew;
    BOOLEAN TimerTick;
    UCHAR Reserved[2];
    ULARGE_INTEGER Skew;
    ULARGE_INTEGER CurrentRead1;
} TIMER_PACKET, *PTIMER_PACKET;

#define MAX_TIMER_PACKETS 10
static ULONG PacketIndex = 0;
static TIMER_PACKET TimerLog[MAX_TIMER_PACKETS];
#endif // TIMER_DBG

#define A_FEW_TICKS 3


ULARGE_INTEGER
FASTCALL
HalpQueryBrokenPiix4(
    VOID
    )
{
    ULARGE_INTEGER  lastRead;
    ULARGE_INTEGER  currentRead;
    ULARGE_INTEGER  currentRead0;
    ULARGE_INTEGER  minTime;
    ULARGE_INTEGER  upperBound;
    ULONG           hardwareVal;
    ULONG           bitsInHardware;
    ULONG           flags;
    ULONG           ClockBits;
    ULARGE_INTEGER  RollOver;
    ULARGE_INTEGER  SkewedTime;
#ifndef NT_UP
    KIRQL Irql;
#endif

#ifdef TIMER_DBG
    ULONG Index;
#endif

#if DBG
    ULONG readCount = 0;
    PTIMER_PERF_INDEX timerPerfRecord =
        &(TimerPerf[TimerPerfIndex]);

    RtlZeroMemory(timerPerfRecord, sizeof(TIMER_PERF_INDEX));
#endif

    //
    // N.B.  This is, of course, not MP safe.  But none
    // of the PIIX4 workaround code is.  MP machines don't
    // use PIIX4 code.
    //
    _asm {
        pushfd
        pop     eax
        mov     flags, eax
        cli
    }

    lastRead.QuadPart = 0;
    bitsInHardware = (TimerInfo.MsbMask << 1) - 1;

    //
    // Get current minimum reported time.
    //
    minTime.HighPart = TimerInfo.TimeHigh2;
    minTime.LowPart = TimerInfo.TimeLow;

#if DBG
    timerPerfRecord->TITL = TimerInfo.TimeLow;
    timerPerfRecord->TITH = TimerInfo.TimeHigh1;
#endif

    //
    // Loop until we get a time that we can believe.
    //
    RollOver.QuadPart = 0;
    while (TRUE) {

        //
        // Read the hardware.
        //

        hardwareVal = READ_PORT_ULONG((PULONG)TimerInfo.CurrentTimePort);

#ifdef TIMER_DBG
        if (DoItOnce) {
            RtlZeroMemory(&TimerLog[0], sizeof(TIMER_PACKET) *
                          MAX_TIMER_PACKETS);
            DoItOnce = FALSE;
        }

        if (FALSE) { //((hardwareVal & 0xFFFF8000) == 0xFFFF8000) {
            PacketLog = TRUE;
            PacketLogCount = 5;
        }

        if (PacketLog) {
            
            if (PacketLogCount == 0) {
                PacketLog = FALSE;
            }

            if (PacketLogCount > 0) {
                Index = PacketIndex++ % MAX_TIMER_PACKETS;
                RtlZeroMemory(&TimerLog[Index], sizeof(TIMER_PACKET));
                TimerLog[Index].Hardware = hardwareVal;
                TimerLog[Index].TimerTick = TimerTick;
                
                {
                    ULONG TSCounterHigh;
                    ULONG TSCounterLow;
                    
                    _asm { rdtsc
                               mov TSCounterLow, eax
                               mov TSCounterHigh, edx };
                    
                    TimerLog[Index].TimeStamp.HighPart = TSCounterHigh;
                    TimerLog[Index].TimeStamp.LowPart = TSCounterLow;  
                }
                                
                TimerLog[Index].Minimum = minTime;
                TimerLog[Index].PositiveSkew = PositiveSkew;
                TimerLog[Index].Skew = ClockSkew;
                
                if ((PacketLogCount < 4) && (PacketLogCount > 0)) {
                    PacketLogCount--;
                }
            }
        }
#endif // TIMER_DBG

        currentRead.HighPart = minTime.HighPart;
        currentRead.LowPart = (minTime.LowPart & (~bitsInHardware)) |
            hardwareVal;

        currentRead0 = currentRead;

        //
        // Check for rollover, since this function is called during each
        // system clock interrupt, if the HW has really rolled over, then it
        // should be within upper bound ticks since that is approximately
        // twice the number of ticks we expect during each system clock
        // interrupt, however, some broken timers occasionally tick backward
        // a few ticks, and if this happens, we may accidentally detect
        // more than one rollover during this period depending upon how
        // frequently applications are calling this API, and how often the
        // HW glitches, and this can cause applications to jerk like mad,
        // but we cannot apply heuristics to try to throw out any of these
        // detected rolls during this interval because we could accidentally
        // throw out the one and only legitimate rollover
        //
        if (RollOver.QuadPart > 0) {
            currentRead.QuadPart += RollOver.QuadPart;
        
        } else {
            SkewedTime = minTime;

            //
            // If time is skewed, we need to remove the skew to accurately
            // assess whether the timer has wrapped
            //
            if (ClockSkew.QuadPart > 0) {
                if (PositiveSkew) {
                    SkewedTime.QuadPart -= ClockSkew.QuadPart;
                } else {
                    SkewedTime.QuadPart += ClockSkew.QuadPart;
                }
            }
            
            if (((ULONG)(SkewedTime.LowPart & bitsInHardware) > hardwareVal) &&
                (hardwareVal < (HalpPiix4UpperBoundTable[HalpCurrentMSRateTableIndex] / 2))) {
                
                RollOver.QuadPart = (UINT64)(TimerInfo.MsbMask) << 1;
                currentRead.QuadPart += RollOver.QuadPart;
            }
        }

#ifdef TIMER_DBG
        if (PacketLog) {
            TimerLog[Index].CurrentRead0 = currentRead;
        }
#endif

#if DBG
        readCount = timerPerfRecord->ReadCount;
        readCount &= 1;
        timerPerfRecord->RawRead[readCount] = hardwareVal;
        timerPerfRecord->AdjustedLow[readCount] = currentRead.LowPart;
        timerPerfRecord->AdjustedHigh[readCount] = currentRead.HighPart;
        timerPerfRecord->ReadCount++;
#endif

        //
        // Get the current upper bound.
        //
        upperBound.HighPart = TimerInfo.UpperBoundHigh2;
        upperBound.LowPart = TimerInfo.UpperBoundLow;

#ifdef TIMER_DBG
        if (PacketLog) {
            TimerLog[Index].Maximum = upperBound;
        }
#endif

        if ((minTime.QuadPart <= currentRead.QuadPart) &&
            (currentRead.QuadPart <= upperBound.QuadPart)) {

            //
            // This value from the counter is within the boundaries
            // that we expect.
            //
            //
            // If there was previously a skew, unskew
            //
            ClockSkew.QuadPart = 0;
            break;
        }
        
        if (ClockSkew.QuadPart > 0) {
            SkewedTime = currentRead;

            if (PositiveSkew) {
                SkewedTime.QuadPart += ClockSkew.QuadPart;
            } else {
                SkewedTime.QuadPart -= ClockSkew.QuadPart;
            }

            if ((minTime.QuadPart <= SkewedTime.QuadPart) &&
                (SkewedTime.QuadPart <= upperBound.QuadPart)) {
                
                //
                // This value from the counter is within the boundaries
                // that we accept
                //
                currentRead = SkewedTime;
                break;
            }
        }

        //
        // We are guaranteed to break out of this as soon as we read
        // two consectutive non-decreasing values from the timer whose
        // difference is less than or equal to 0xfff-- is this
        // too much to ask?
        //
        if ((currentRead.QuadPart - lastRead.QuadPart) > 0xfff) {
            lastRead = currentRead;
            continue;
        }

#ifdef TIMER_DBG
        if (PacketLog) {
            if (PacketLogCount > 0) {
                PacketLogCount--;
            }
        }
#endif

        //
        // Now we are really screwed-- we are consistently reading values
        // from the timer, that are not within the boundaries we expect
        //
        // We are going to record/apply a skew that will get us back on
        // track
        //
        if (currentRead.QuadPart < minTime.QuadPart) {

            //
            // Time jumped backward a small fraction, just add a few ticks
            //
            if ((minTime.QuadPart - currentRead.QuadPart) < 0x40) {
                SkewedTime.QuadPart = minTime.QuadPart + A_FEW_TICKS;
            
            //
            // Time jumped backward quite a bit, add half a system clock
            // interrupt worth of ticks since we know this routine
            // gets called every clock interrupt
            //
            } else {
                SkewedTime.QuadPart = minTime.QuadPart +
                    (HalpPiix4UpperBoundTable[HalpCurrentMSRateTableIndex] /
                     8);
            }

#ifdef TIMER_DBG
            PositiveGlitches++;
            if (PacketLog) {
                TimerLog[Index].PositiveSkew = TRUE;
                TimerLog[Index].Skew.QuadPart =
                    SkewedTime.QuadPart - currentRead.QuadPart;
            }
#endif // TIMER_DBG

            PositiveSkew = TRUE;
            ClockSkew.QuadPart = SkewedTime.QuadPart - currentRead.QuadPart;

        //
        // currentRead > upperBound
        //
        } else {

            //
            // Time jumped forward more than a system clock, interrupts
            // may have been disabled by some unruly driver, or maybe
            // we were hung up in the debugger, at any rate, let's add
            // a full system clock interrupt worth of ticks
            //
            SkewedTime.QuadPart = minTime.QuadPart +
                (HalpPiix4UpperBoundTable[HalpCurrentMSRateTableIndex] /
                 4);

#ifdef TIMER_DBG
            NegativeGlitches++;

            if (PacketLog) {
                TimerLog[Index].PositiveSkew = FALSE;
                TimerLog[Index].Skew.QuadPart =
                    currentRead.QuadPart - SkewedTime.QuadPart;
            }
#endif // TIMER_DBG

            PositiveSkew = FALSE;
            ClockSkew.QuadPart = currentRead.QuadPart - SkewedTime.QuadPart;
        }

        currentRead = SkewedTime;
        break;
    }

#ifdef TIMER_DBG
    if (PacketLog) {
        TimerLog[Index].CurrentRead1 = currentRead;
    }
#endif

    //
    // If we detected a rollover, and there is negative skew, then we
    // should recalculate the skew as positive skew to avoid making
    // an erroneous correction on the next read
    //
    if ((ClockSkew.QuadPart > 0) && (RollOver.QuadPart > 0) &&
        (PositiveSkew == FALSE) && (ClockSkew.QuadPart > hardwareVal)) {

        //
        // I still want to study this case, even though it is handled
        // by the if statement below, it may very well be that when we
        // hit this case, we are double-wrapping the timer by mistake
        //
        ASSERT(currentRead.QuadPart >= currentRead0.QuadPart);

        if (currentRead.QuadPart >= currentRead0.QuadPart) {
            ClockSkew.QuadPart = currentRead.QuadPart - currentRead0.QuadPart;
            PositiveSkew = TRUE;
        }
#if TIMER_DBG
        else {
            if ((PacketLog) && (PacketLogCount > 3)) {
                PacketLogCount = 3;
            }
        }
#endif
    }

    //
    // Similarly, if there is no rollover, but positive skew is causing
    // the timer to rollover, then we need to readjust the skew also to
    // avoid the possibility of making an erroneous correction on the next
    // read
    //
    if ((ClockSkew.QuadPart > 0) && (RollOver.QuadPart == 0) &&
        (PositiveSkew == TRUE) && ((currentRead.QuadPart & ~bitsInHardware) >
                                   (minTime.QuadPart & ~bitsInHardware))) {

        //
        // I'm not sure what this means, or how it can happen, but I will
        // endeavor to decipher the condition if and when it occurs
        //
        ASSERT(currentRead0.QuadPart + bitsInHardware + 1 >
               currentRead.QuadPart);

        if (currentRead0.QuadPart + bitsInHardware + 1 >
            currentRead.QuadPart) {
            ClockSkew.QuadPart = currentRead0.QuadPart + bitsInHardware + 1 -
                currentRead.QuadPart;
            PositiveSkew = FALSE;
        }
#if TIMER_DBG
        else {
            if ((PacketLog) && (PacketLogCount > 3)) {
                PacketLogCount = 3;
            }
        }
#endif
    }

    //
    // Compute new upper bound.
    //
    upperBound.QuadPart = currentRead.QuadPart +
        HalpPiix4UpperBoundTable[HalpCurrentMSRateTableIndex];

    //
    // Update upper and lower bounds.
    //
    TimerInfo.TimeHigh1 = currentRead.HighPart;
    TimerInfo.TimeLow = currentRead.LowPart;
    TimerInfo.TimeHigh2 = currentRead.HighPart;

    TimerInfo.UpperBoundHigh1 = upperBound.HighPart;
    TimerInfo.UpperBoundLow   = upperBound.LowPart;
    TimerInfo.UpperBoundHigh2 = upperBound.HighPart;

#if DBG
    LastClockSkew = ClockSkew;
#endif

   _asm {
        mov  eax, flags
        push eax
        popfd
    }

#if DBG
    timerPerfRecord->ReturnedLow = currentRead.LowPart;
    timerPerfRecord->ReturnedHigh = currentRead.HighPart;
    timerPerfRecord->UBL = upperBound.LowPart;
    timerPerfRecord->UBH = upperBound.HighPart;
    TimerPerfIndex = (TimerPerfIndex + 1) % (4096 / sizeof(TIMER_PERF_INDEX));
#endif

    return currentRead;
}

VOID
HalpBrokenPiix4TimerTick(
    VOID
    )
{
    ULARGE_INTEGER currentCount;
    ULARGE_INTEGER upperBound;

#if DBG
    PTIMER_PERF_INDEX timerPerfRecord;
#endif

#ifdef TIMER_DBG
    TimerTick = TRUE;
#endif

    currentCount =
        HalpQueryBrokenPiix4();

#ifdef TIMER_DBG
    TimerTick = FALSE;
#endif

#if DBG
    timerPerfRecord = &(TimerPerf[TimerPerfIndex]);
    timerPerfRecord->TickMin = currentCount.LowPart;
    timerPerfRecord->TickNewUB = TimerInfo.UpperBoundLow;
    timerPerfRecord->TickCount++;
#endif
}

#endif // NO_PM_KEQPC

VOID
HalaAcpiTimerInit(
   IN ULONG    TimerPort,
   IN BOOLEAN  TimerValExt
   )
{
    TimerInfo.CurrentTimePort = TimerPort;

    if (TimerValExt) {
        TimerInfo.MsbMask = 0x80000000;
    }

#ifndef NO_PM_KEQPC
    if (HalpBrokenAcpiTimer) {
        QueryTimer = HalpQueryBrokenPiix4;

#if DBG
        {
            KIRQL oldIrql;

            KeRaiseIrql(HIGH_LEVEL, &oldIrql);
            LastKQPCValue[0] = 0;
            LastKQPCValue[1] = 0;
            LastKQPCValue[2] = 0;
            KeLowerIrql(oldIrql);
        }
#endif
    }
#endif // NO_PM_KEQPC
}

#define PIT_FREQUENCY 1193182
#define PM_TMR_FREQ   3579545

#define EIGHTH_SECOND_PM_TICKS 447443

ULONG PMTimerFreq = PM_TMR_FREQ;

#ifdef SPEEDY_BOOT

static ULONG HalpFoundPrime = 0; 

VOID
HalpPrimeSearch(
    IN ULONG Primer,
    IN ULONG BitMask
    )
/*++

Routine Description:

    The objective of this routine is to waste as many CPU cycles as possible
    by searching for prime numbers.  To be fairly consistent in the amount
    of time it wastes, it is severly less than optimal-- we force Primer
    to be odd by or-ing in 15, then we and it with the BitMask, and or
    in BitMask+1, and finally we continue testing after we discover the
    Primer's not prime, until out test factor squared is greater than, or
    equal to the Primer.

Arguments:

    Primer - The number to search (seed)

    BitMask - How many bits of primer to use in search, controls amount
              of time wasted

Return Value:

    None

--*/
{
    ULONG Index;
    BOOLEAN FoundPrime;

    Primer |= 0xF;
    BitMask |= 0xF;
    Primer &= BitMask;
    Primer |= (BitMask + 1);

    FoundPrime = TRUE;
    for (Index = 3; (Index * Index) < Primer; Index += 2) {
        if ((Primer % Index) == 0) {
            FoundPrime = FALSE;
            // Do not break-- we're trying to waste time, remember?
        }
    }
    
    //
    // Stuff prime(s) in global so sneaky optimizing compiler
    // doesn't optimize out this B.S.
    //
    if (FoundPrime) {
        HalpFoundPrime = Primer;
    }
}



BOOLEAN
HalpPmTimerSpecialStall(
    IN ULONG Ticks
    )
/*++

Routine Description:

Arguments:

    Ticks - Number of PM timer ticks to stall

Return Value:

    TRUE if we were able to stall for the correct interval,
    otherwise FALSE

--*/
{
    BOOLEAN TimerWrap;
    LARGE_INTEGER TimerWrapBias;
    LARGE_INTEGER LastRead;
    LARGE_INTEGER InitialTicks;
    LARGE_INTEGER TargetTicks;
    LARGE_INTEGER CurrentTicks;
    ULONG ZeroElapsedTickReads;
    
    InitialTicks = HalpPmTimerQueryPerfCount(NULL);

    //
    // Let's test the rollover action...
    //
    CurrentTicks = InitialTicks;
    LastRead.QuadPart = InitialTicks.QuadPart;
    ZeroElapsedTickReads = 0;
    TimerWrapBias.QuadPart = 0;
    TimerWrap = FALSE;

    TargetTicks.QuadPart = InitialTicks.QuadPart + Ticks;

    while (CurrentTicks.QuadPart < TargetTicks.QuadPart) {

        //
        // Now let's really chew up some cycles and see if we can find
        // some prime numbers while we're at it
        //
        HalpPrimeSearch(CurrentTicks.LowPart, 0x7FFF);

        CurrentTicks = HalpPmTimerQueryPerfCount(NULL);
        CurrentTicks.QuadPart += TimerWrapBias.QuadPart;

        //
        // Did the timer wrap, or is it broken?
        //
        if (CurrentTicks.QuadPart < LastRead.QuadPart) {

            //
            // The timer can wrap once, otherwise something's amiss 
            //
            if (!TimerWrap) {

                TimerWrapBias.QuadPart = (UINT64)(TimerInfo.MsbMask) << 1;
                CurrentTicks.QuadPart += TimerWrapBias.QuadPart;
                TimerWrap = TRUE;

                //
                // Something is whack, considering our elaborate stall
                // algorithm, this difference is still too significant,
                // maybe it's time to upgrade that 200MHz CPU if you
                // want fast boot!
                //
                if ((CurrentTicks.QuadPart - LastRead.QuadPart) > 0x1000) {
                    return FALSE;
                }

            //
            // We already had one decreasing read, looser!
            //
            } else {
                return FALSE;
            }
        }

        //
        // Is the timer really ticking?  In practice it is virtually
        // impossible to read the timer so quickly that you get the same
        // answer twice, but in theory it should be possible, so to avoid
        // the possibility of getting stuck in this loop for all eternity
        // we will permit this condition to occur one thousand times
        // before we give up
        //
        if (CurrentTicks.QuadPart == LastRead.QuadPart) ZeroElapsedTickReads++;
        if (ZeroElapsedTickReads > 1000) {
            return FALSE;
        }

        LastRead = CurrentTicks;
    }

    return TRUE;
}

static BOOLEAN SpecialStallSuccess = TRUE;

#define TSC 0x10

LONGLONG ReadCycleCounter(VOID) { _asm { rdtsc } }

#define TIMER_ROUNDING 10000
#define __1MHz 1000000


BOOLEAN
HalpPmTimerScaleTimers(
    VOID
    )
/*++

Routine Description:

    Determines the frequency of the APIC timer, this routine is run
    during initialization

Arguments:

    None

Return Value:

    None

--*/
{
    ULONG Flags;
    ULONG ReadBack;
    PHALPCR HalPCR;
    PKPCR pPCR;
    ULONG ApicHz;
    ULONGLONG TscHz;
    ULONG RoundApicHz;
    ULONGLONG RoundTscHz;
    ULONGLONG RoundTscMhz;

    //
    // If we ever failed before, don't bother wasting any more time
    //
    if (!SpecialStallSuccess) {
        return FALSE;
    }

    //
    // Don't interrupt us!
    //
    _asm {
        pushfd
        pop     eax
        mov     Flags, eax
        cli
    }

    pPCR = KeGetPcr();
    HalPCR = (PHALPCR)(KeGetPcr()->HalReserved);

    //
    // Configure APIC timer
    //
    pLocalApic[LU_TIMER_VECTOR / 4] = INTERRUPT_MASKED |
        PERIODIC_TIMER | APIC_PROFILE_VECTOR;
    pLocalApic[LU_DIVIDER_CONFIG / 4] = LU_DIVIDE_BY_1;
    
    //
    // Make sure the write has happened ???
    //
    ReadBack = pLocalApic[LU_DIVIDER_CONFIG / 4];

    //
    // Zero the perf counter
    //
    HalPCR->PerfCounterLow = 0;
    HalPCR->PerfCounterHigh = 0;

    //
    // Fence ???
    //
    _asm { xor eax, eax
           cpuid }

    //
    // Reset APIC counter and TSC
    //
    pLocalApic[LU_INITIAL_COUNT / 4] = (ULONG)-1;
    WRMSR(TSC, 0);

    //
    // Stall for an eigth second
    //
    SpecialStallSuccess = HalpPmTimerSpecialStall(EIGHTH_SECOND_PM_TICKS);

    if (SpecialStallSuccess) {
 
        //
        // Read/compute APIC clock and TSC Frequencies (ticks * 8)
        //
        TscHz = ReadCycleCounter() * 8;
        ApicHz = ((ULONG)-1 - pLocalApic[LU_CURRENT_COUNT / 4]) * 8;

        //
        // Round APIC frequency
        //
        RoundApicHz = ((ApicHz + (TIMER_ROUNDING / 2)) / TIMER_ROUNDING) *
            TIMER_ROUNDING;

        HalPCR->ApicClockFreqHz = RoundApicHz;

        //
        // Round TSC frequency
        //
        RoundTscHz = ((TscHz + (TIMER_ROUNDING / 2)) / TIMER_ROUNDING) *
            TIMER_ROUNDING;
        HalPCR->TSCHz = (ULONG)RoundTscHz; // ASSERT(RoundTscHz < __4GHz);

        //
        // Convert TSC frequency to MHz
        //
        RoundTscMhz = (RoundTscHz + (__1MHz / 2)) / __1MHz;
        pPCR->StallScaleFactor = (ULONG)RoundTscMhz;

        HalPCR->ProfileCountDown = RoundApicHz;
        pLocalApic[LU_INITIAL_COUNT / 4] = RoundApicHz; 
    }

    //
    // Restore interrupt state-- can this be done without _asm ???
    //
    _asm {
        mov  eax, Flags
        push eax
        popfd
    }

    return SpecialStallSuccess;
}

#endif // SPEEDY_BOOT

#ifndef NO_PM_KEQPC

static ULONG PIT_Ticks = 0xBADCEEDE;

VOID
HalpAcpiTimerPerfCountHack(
    VOID
    )
/*++

Routine Description:

    Some cheezy PIC-based laptops seemed to have wired their ACPI timer to
    the wrong frequecy crystal, and their perf counter freq is twice what
    it should be.  These systems seem to run fine in every other way
    except for midi file playback, or anything else that goes by KeQuery-
    PerformanceCounter's return frequency value, so we perform a simple
    check late during init to see if this clock is twice what we expect,
    and if it is we return twice the ACPI frequency in KeQuery...

Arguments:

    None

Return Value:

    None

--*/
{
    ULONG T0_Count = 0;
    ULONG T1_Count = 1;
    ULONG Retry = 10;

    //
    // If we happen to hit the rollover just do it again
    //
    while ((T0_Count < T1_Count) && (Retry--)) {
        T0_Count = HalpQuery8254Counter();
        KeStallExecutionProcessor(1000);
        T1_Count = HalpQuery8254Counter();
    }

    if (T0_Count < T1_Count) {
        return;
    }

    //
    // We should have read ~1200 ticks during this interval, so if we
    // recorded between 575 and 725 we can reasonably assume the ACPI 
    // Timer is running at 2 * spec
    //
    PIT_Ticks = T0_Count - T1_Count;
    if ((PIT_Ticks < 725) && (PIT_Ticks > 575)) {
        PMTimerFreq = 2 * PM_TMR_FREQ;
        HalpAdjustUpperBoundTable2X();
    }
}

#endif // NO_PM_KEQPC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\sources.inc ===
!IF 0

Copyright (c) 1989-2000  Microsoft Corporation

!ENDIF

!include $(PROJECT_ROOT)\hals\hals.inc

CSOURCES= \
    hal.rc                 \
    ..\acpidtct.c          \
    ..\chiphacks.c         \
    ..\cmosopregion.c      \
    ..\drivesup.c	   \
    ..\dynsysres.c         \
    ..\ixenvirv.c          \
    ..\ixfirm.c            \
    ..\ixhalt.c            \
    ..\ixhwsup.c           \
    ..\ixinfo.c            \
    ..\ixisabus.c          \
    ..\ixisasup.c          \
    ..\ixmca.c             \
    ..\ixnmi.c             \
    ..\ixpcibus.c          \
    ..\ixpciint.c          \
    ..\ixphwsup.c          \
    ..\ixpnpdrv.c          \
    ..\ixreboot.c          \
    ..\ixslpsup.c          \
    ..\ixthunk.c           \
    ..\ixusage.c           \
    ..\mmtimer.c           \
    ..\mpprocst.c          \
    ..\pmbus.c             \
    ..\pmdata.c            \
    ..\pmisabus.c          \
    ..\pmpcisup.c          \
    ..\pmsleep.c           \
    ..\sratnuma.c          \
    ..\xxacpi.c            \
    ..\xxbiosc.c           \
    ..\xxdisp.c            \
    ..\xxmemory.c          \
    ..\xxstubs.c           \
    ..\xxtime.c            \
    ..\xxtimer.c

DLLDEF=$(O)\hal.def

LINKER_FLAGS=$(LINKER_FLAGS) -merge:PAGECONST=PAGE -merge:INITCONST=INIT /LARGEADDRESSAWARE

TARGETLIBS = \
    $(HALKIT_LIB_PATH)\kdcom.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\xxacpi.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    xxacpi.c

Abstract:

    Implements various ACPI utility functions.

Author:

    Jake Oshins (jakeo) 12-Feb-1997

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "acpitabl.h"
#include "xxacpi.h"
#include "pci.h"
#include "string.h"
#include "stdlib.h"
#include "stdio.h"
#include "mmtimer.h"
#include "chiphacks.h"


//#define DUMP_FADT

VOID
HalAcpiTimerCarry(
    VOID
    );

VOID
HalAcpiBrokenPiix4TimerCarry(
    VOID
    );

VOID
HalaAcpiTimerInit(
    ULONG      TimerPort,
    BOOLEAN    TimerValExt
    );

ULONG
HaliAcpiQueryFlags(
    VOID
    );

VOID
HaliAcpiTimerInit(
    IN ULONG TimerPort  OPTIONAL,
    IN BOOLEAN    TimerValExt
    );

VOID
HaliAcpiMachineStateInit(
    IN PPROCESSOR_INIT ProcInit,
    IN PHAL_SLEEP_VAL  SleepValues,
    OUT PULONG         PicVal
    );

BOOLEAN
FASTCALL
HalAcpiC1Idle(
    OUT PPROCESSOR_IDLE_TIMES IdleTimes
    );

BOOLEAN
FASTCALL
HalAcpiC2Idle(
    OUT PPROCESSOR_IDLE_TIMES IdleTimes
    );

BOOLEAN
FASTCALL
HalAcpiC3ArbdisIdle(
    OUT PPROCESSOR_IDLE_TIMES IdleTimes
    );

BOOLEAN
FASTCALL
HalAcpiC3WbinvdIdle(
    OUT PPROCESSOR_IDLE_TIMES IdleTimes
    );

VOID
FASTCALL
HalProcessorThrottle(
    IN UCHAR Throttle
    );

NTSTATUS
HaliSetWakeAlarm (
        IN ULONGLONG    WakeSystemTime,
        IN PTIME_FIELDS WakeTimeFields OPTIONAL
        );

VOID
HaliSetWakeEnable(
        IN BOOLEAN      Enable
        );

ULONG
HaliPciInterfaceReadConfig(
    IN PVOID Context,
    IN UCHAR BusOffset,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG
HaliPciInterfaceWriteConfig(
    IN PVOID Context,
    IN UCHAR BusOffset,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

VOID
HaliSetMaxLegacyPciBusNumber(
    IN ULONG BusNumber
    );

VOID
HalpInitBootTable (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

NTSTATUS
HalReadBootRegister(
    PUCHAR BootRegisterValue
    );

NTSTATUS
HalWriteBootRegister(
    UCHAR BootRegisterValue
    );

VOID
HalpEndOfBoot(
    VOID
    );

VOID
HalpPutAcpiHacksInRegistry(
    VOID
    );

VOID
HalpDynamicSystemResourceConfiguration(
    IN PLOADER_PARAMETER_BLOCK
    );

#if !defined(NT_UP)

VOID
HalpNumaInitializeStaticConfiguration(
    IN PLOADER_PARAMETER_BLOCK
    );

#endif

//
// Externs
//

extern ULONG    HalpAcpiFlags;
extern PHYSICAL_ADDRESS HalpAcpiRsdt;
extern SLEEP_STATE_CONTEXT HalpShutdownContext;
extern ULONG HalpPicVectorRedirect[];
extern ULONG HalpTimerWatchdogEnabled;
extern ULONG HalpOutstandingScatterGatherCount;
extern BOOLEAN HalpDisableHibernate;

//
// Globals
//

ULONG HalpInvalidAcpiTable;
PRSDT HalpAcpiRsdtVA;
PXSDT HalpAcpiXsdtVA;

//
// This is the dispatch table used by the ACPI driver
//
HAL_ACPI_DISPATCH_TABLE HalAcpiDispatchTable = {
        HAL_ACPI_DISPATCH_SIGNATURE, // Signature
    HAL_ACPI_DISPATCH_VERSION, // Version
    &HaliAcpiTimerInit, // HalpAcpiTimerInit
    NULL, // HalpAcpiTimerInterrupt
    &HaliAcpiMachineStateInit, // HalpAcpiMachineStateInit
    &HaliAcpiQueryFlags, // HalpAcpiQueryFlags
    &HalpAcpiPicStateIntact, // HalxPicStateIntact
    &HalpRestoreInterruptControllerState, // HalxRestorePicState
    &HaliPciInterfaceReadConfig, // HalpPciInterfaceReadConfig
    &HaliPciInterfaceWriteConfig, // HalpPciInterfaceWriteConfig
    &HaliSetVectorState, // HalpSetVectorState
    (pHalGetIOApicVersion)&HalpGetApicVersion, // HalpGetIOApicVersion
    &HaliSetMaxLegacyPciBusNumber, // HalpSetMaxLegacyPciBusNumber
    &HaliIsVectorValid // HalpIsVectorValid
};
PPM_DISPATCH_TABLE PmAcpiDispatchTable = NULL;


NTSTATUS
HalpQueryAcpiResourceRequirements(
    IN  PIO_RESOURCE_REQUIREMENTS_LIST *Requirements
    );

NTSTATUS
HalpBuildAcpiResourceList(
    OUT PIO_RESOURCE_REQUIREMENTS_LIST  List
    );

NTSTATUS
HalpAcpiDetectResourceListSize(
    OUT  PULONG   ResourceListSize
    );

VOID
HalpPiix4Detect(
    BOOLEAN DuringBoot
    );

ULONG
HalpGetPCIData (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PCI_SLOT_NUMBER SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG
HalpGetCmosData(
    IN ULONG    SourceLocation,
    IN ULONG    SourceAddress,
    IN PUCHAR   ReturnBuffer,
    IN ULONG    ByteCount
    );

VOID
HalpSetCmosData(
    IN ULONG    SourceLocation,
    IN ULONG    SourceAddress,
    IN PUCHAR   ReturnBuffer,
    IN ULONG    ByteCount
    );

#define LOW_MEMORY          0x000100000

#define MAX(a, b)       \
    ((a) > (b) ? (a) : (b))

#define MIN(a, b)       \
    ((a) < (b) ? (a) : (b))

//
// The following is a Stub version of HalpGetApicVersion
// for non-APIC halacpi's (which don't include
// pmapic.c). This stub just always returns 0.
//

#ifndef APIC_HAL
ULONG HalpGetApicVersion(ULONG ApicNo)
{
   return 0;
}
#endif

//
// ADRIAO 09/16/98 - We are no longer having the HAL declare the IO ports
//                   specified in the FADT. These will be declared in a future
//                   defined PNP0Cxx node (for now, in PNP0C02). This is done
//                   because we cannot know at the hal level what bus the ACPI
//                   FADT resources refer to. We can only use the translated
//                   resource info.
//
//   Hence...
//
#define DECLARE_FADT_RESOURCES_AT_ROOT 0

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, HalpGetAcpiTablePhase0)
#pragma alloc_text(INIT, HalpSetupAcpiPhase0)
#pragma alloc_text(INIT, HalpInitBootTable)
#pragma alloc_text(PAGE, HaliInitPowerManagement)
#pragma alloc_text(PAGE, HalpQueryAcpiResourceRequirements)
#pragma alloc_text(PAGE, HalpBuildAcpiResourceList)
#pragma alloc_text(PAGE, HalpAcpiDetectResourceListSize)
#pragma alloc_text(PAGE, HaliAcpiTimerInit)
#pragma alloc_text(PAGE, HaliAcpiMachineStateInit)
#pragma alloc_text(PAGE, HaliAcpiQueryFlags)
#pragma alloc_text(PAGE, HaliSetWakeEnable)
#pragma alloc_text(PAGE, HalpEndOfBoot)
#pragma alloc_text(PAGE, HalpPutAcpiHacksInRegistry)
#pragma alloc_text(PAGELK, HalpPiix4Detect)
#pragma alloc_text(PAGELK, HalReadBootRegister)
#pragma alloc_text(PAGELK, HalWriteBootRegister)
#pragma alloc_text(PAGELK, HalpResetSBF)
#endif

PVOID
HalpGetAcpiTablePhase0(
    IN  PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN  ULONG   Signature
    )
/*++

Routine Description:

    This function returns a pointer to the ACPI table that is
    identified by Signature.

Arguments:

    Signature - A four byte value that identifies the ACPI table

Return Value:

    Pointer to a copy of the table

--*/
{
    PRSDT rsdt;
    PXSDT xsdt = NULL;
    ULONG entry, rsdtEntries, rsdtLength;
    PVOID table;
    PHYSICAL_ADDRESS physicalAddr;
    PDESCRIPTION_HEADER header;
    NTSTATUS status;
    ULONG lengthInPages;
    ULONG offset;

    physicalAddr.QuadPart = 0;
    header = NULL;

    if ((HalpAcpiRsdtVA == NULL) && (HalpAcpiXsdtVA == NULL)) {

        //
        // Find and map the RSDT once.  This mapping is reused on
        // subsequent calls to this routine.
        //

        status = HalpAcpiFindRsdtPhase0(LoaderBlock);

        if (!NT_SUCCESS(status)) {
            DbgPrint("*** make sure you are using ntdetect.com v5.0 ***\n");
            KeBugCheckEx(MISMATCHED_HAL,
                4, 0xac31, 0, 0);
        }

        rsdt = HalpMapPhysicalMemory( HalpAcpiRsdt, 2);

        if (!rsdt) {
            return NULL;
        }

        //
        // Do a sanity check on the RSDT.
        //
        if ((rsdt->Header.Signature != RSDT_SIGNATURE) &&
            (rsdt->Header.Signature != XSDT_SIGNATURE)) {
            HalDisplayString("Bad RSDT pointer\n");
            KeBugCheckEx(MISMATCHED_HAL,
                4, 0xac31, 0, 0);
        }

        //
        // Calculate the number of entries in the RSDT.
        //

        rsdtLength = rsdt->Header.Length;

        //
        // Remap the RSDT now that we know how long it is.
        //

        offset = HalpAcpiRsdt.LowPart & (PAGE_SIZE - 1);
        lengthInPages = (offset + rsdtLength + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
        if (lengthInPages > 2) {
            HalpUnmapVirtualAddress(rsdt, 2);
            rsdt = HalpMapPhysicalMemory( HalpAcpiRsdt, lengthInPages);
            if (!rsdt) {
                DbgPrint("HAL: Couldn't remap RSDT\n");
                return NULL;
            }
        }

        if (rsdt->Header.Signature == XSDT_SIGNATURE) {

            xsdt = (PXSDT)rsdt;
            rsdt = NULL;
        }

        HalpAcpiRsdtVA = rsdt;
        HalpAcpiXsdtVA = xsdt;
    }
    rsdt = HalpAcpiRsdtVA;
    xsdt = HalpAcpiXsdtVA;

    //
    // Calculate the number of entries in the RSDT.
    //
    rsdtEntries = xsdt ?
        NumTableEntriesFromXSDTPointer(xsdt) :
        NumTableEntriesFromRSDTPointer(rsdt);

    //
    // Look down the pointer in each entry to see if it points to
    // the table we are looking for.
    //
    for (entry = 0; entry < rsdtEntries; entry++) {

        if (xsdt) {

            physicalAddr = xsdt->Tables[entry];

        } else {

            physicalAddr.LowPart = rsdt->Tables[entry];
        }

        if (header != NULL) {
            HalpUnmapVirtualAddress(header, 2);
        }
        header = HalpMapPhysicalMemory( physicalAddr, 2);

        if (!header) {
            return NULL;
        }

        if (header->Signature == Signature) {
            break;
        }
    }

    if (entry == rsdtEntries) {

        //
        // Signature not found, free the PTE for the last entry
        // examined and indicate failure to the caller.
        //

        HalpUnmapVirtualAddress(header, 2);
        return NULL;
    }

    //
    // Make sure we have mapped enough memory to cover the entire
    // table.
    //

    offset = (ULONG)header & (PAGE_SIZE - 1);
    lengthInPages = (header->Length + offset + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
    if (lengthInPages > 2) {
        HalpUnmapVirtualAddress(header, 2);
        header = HalpMapPhysicalMemory( physicalAddr, lengthInPages);
    }

    //
    // Validate the table's checksum.
    // N.B. We expect the checksum to be wrong on some early versions
    // of the FADT.
    //

    if ((header != NULL)  &&
        ((header->Signature != FADT_SIGNATURE) || (header->Revision > 2))) {

        PUCHAR c = (PUCHAR)header + header->Length;
        UCHAR s = 0;

        if (header->Length) {
            do {
                s += *--c;
            } while (c != (PUCHAR)header);
        }


        if ((s != 0) || (header->Length == 0)) {

            //
            // This table is not valid.
            //

            HalpInvalidAcpiTable = header->Signature;

#if 0

            //
            // Don't return this table.
            //

            HalpUnmapVirtualAddress(header, lengthInPages);
            return NULL;

#endif

        }
    }
    return header;
}

NTSTATUS
HalpSetupAcpiPhase0(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

Routine Description:

    Save some information from the ACPI tables before they get
    destroyed.

Arguments:

    none

Return Value:

    none

--*/
{
    NTSTATUS    status;
    ULONG entry, rsdtEntries, rsdtLength;
    PVOID table;
    PHYSICAL_ADDRESS physicalAddr;
    PDESCRIPTION_HEADER header;
    PEVENT_TIMER_DESCRIPTION_TABLE EventTimerDescription = NULL;

    if (HalpProcessedACPIPhase0) {
        return STATUS_SUCCESS;
    }

    //
    // Copy the Fixed Acpi Descriptor Table (FADT) to a permanent
    // home.
    //

    header = HalpGetAcpiTablePhase0(LoaderBlock, FADT_SIGNATURE);
    if (header == NULL) {
        DbgPrint("HAL: Didn't find the FACP\n");
        return STATUS_NOT_FOUND;
    }

    RtlCopyMemory(&HalpFixedAcpiDescTable,
                  header,
                  MIN(header->Length, sizeof(HalpFixedAcpiDescTable)));

    HalpUnMapPhysicalRange(header, header->Length);

#ifdef DUMP_FADT
    DbgPrint("HAL: ACPI Fixed ACPI Description Table\n");
    DbgPrint("\tDSDT:\t\t\t0x%08x\n", HalpFixedAcpiDescTable.dsdt);
    DbgPrint("\tSCI_INT:\t\t%d\n", HalpFixedAcpiDescTable.sci_int_vector);
    DbgPrint("\tPM1a_EVT:\t\t0x%04x\n", HalpFixedAcpiDescTable.pm1a_evt_blk_io_port);
    DbgPrint("\tPM1b_EVT:\t\t0x%04x\n", HalpFixedAcpiDescTable.pm1b_evt_blk_io_port);
    DbgPrint("\tPM1a_CNT:\t\t0x%04x\n", HalpFixedAcpiDescTable.pm1a_ctrl_blk_io_port);
    DbgPrint("\tPM1b_CNT:\t\t0x%04x\n", HalpFixedAcpiDescTable.pm1a_ctrl_blk_io_port);
    DbgPrint("\tPM2_CNT:\t\t0x%04x\n", HalpFixedAcpiDescTable.pm2_ctrl_blk_io_port);
    DbgPrint("\tPM_TMR:\t\t\t0x%04x\n", HalpFixedAcpiDescTable.pm_tmr_blk_io_port);
    DbgPrint("\t\t flags: %08x\n", HalpFixedAcpiDescTable.flags);
#endif

    HalpDebugPortTable = HalpGetAcpiTablePhase0(LoaderBlock, DBGP_SIGNATURE);

#if !defined(NT_UP)

    //
    // See if Static Resource Affinity Table is present.
    //

    HalpNumaInitializeStaticConfiguration(LoaderBlock);

#endif

    HalpDynamicSystemResourceConfiguration(LoaderBlock);


    EventTimerDescription =
        HalpGetAcpiTablePhase0(LoaderBlock, ETDT_SIGNATURE);

    //
    // Initialize timer HW needed for boot
    //
#ifdef MMTIMER_DEV
    if (TRUE) {
        HalpmmTimerInit(0,
#ifdef PICACPI
                        0xd5800000);
#else
                        0xfe000800);
#endif // PICACPI
    }

#else
    if (EventTimerDescription) {
        HalpmmTimerInit(EventTimerDescription->EventTimerBlockID,
                        EventTimerDescription->BaseAddress);
    }
#endif // MMTIMER_DEV

    HaliAcpiTimerInit(0, FALSE);

    //
    // Claim a page of memory below 1MB to be used for transitioning
    // a sleeping processor back from real mode to protected mode
    //

    // check first to see if this has already been done by MP startup code
    if (!HalpLowStubPhysicalAddress) {

        HalpLowStubPhysicalAddress = (PVOID)HalpAllocPhysicalMemory (LoaderBlock,
                                            LOW_MEMORY, 1, FALSE);

        if (HalpLowStubPhysicalAddress) {

            HalpLowStub = HalpMapPhysicalMemory(
                            HalpPtrToPhysicalAddress( HalpLowStubPhysicalAddress ),
                            1);
        }
    }

    //
    // Claim a PTE that will be used for cache flushing in states S2 and S3.
    //

    HalpVirtAddrForFlush = HalpMapPhysicalMemory(
                            HalpPtrToPhysicalAddress((PVOID)LOW_MEMORY),
                            1);

    HalpPteForFlush = MiGetPteAddress(HalpVirtAddrForFlush);

    HalpProcessedACPIPhase0 = TRUE;

    HalpInitBootTable (LoaderBlock);

    return STATUS_SUCCESS;
}

VOID
HaliAcpiTimerInit(
    IN ULONG      TimerPort  OPTIONAL,
    IN BOOLEAN    TimerValExt
    )
/*++
Routine Description:

    This routine initializes the ACPI timer.

Arguments:

    TimerPort - The address in I/O space of the ACPI timer.  If this is
                0, then the values from the cached FADT will be used.

    TimerValExt - signifies whether the timer is 24 or 32 bits.

--*/
{
    ULONG port = TimerPort;
    BOOLEAN ext = TimerValExt;

    PAGED_CODE();

    if (port == 0) {
        port = HalpFixedAcpiDescTable.pm_tmr_blk_io_port;
        if (HalpFixedAcpiDescTable.flags & TMR_VAL_EXT) {
            ext = TRUE;
        } else {
            ext = FALSE;
        }
    }

    HalaAcpiTimerInit(port,
                      ext);
}

VOID
HaliAcpiMachineStateInit(
    IN PPROCESSOR_INIT ProcInit,
    IN PHAL_SLEEP_VAL  SleepValues,
    OUT PULONG         PicVal
    )
/*++
Routine Description:

    This function is a callback used by the ACPI driver
    to notify the HAL with the processor blocks.

Arguments:

--*/
{
    POWER_STATE_HANDLER powerState;
    SLEEP_STATE_CONTEXT sleepContext;
    NTSTATUS    status;
    ULONG       i;
    USHORT      us;
    ULONG       cStates = 1;
    ULONG       ntProc;
    ULONG       procCount = 0;

    PAGED_CODE();
    UNREFERENCED_PARAMETER(ProcInit);

    HalpWakeupState.GeneralWakeupEnable = TRUE;
    HalpWakeupState.RtcWakeupEnable = FALSE;

#ifdef APIC_HAL
    *PicVal = 1;
#else
    *PicVal = 0;
#endif
    //
    // Register sleep handlers with Policy Manager
    //

    if (SleepValues[0].Supported) {
        powerState.Type = PowerStateSleeping1;
        powerState.RtcWake = TRUE;
        powerState.Handler = &HaliAcpiSleep;

        sleepContext.bits.Pm1aVal = SleepValues[0].Pm1aVal;
        sleepContext.bits.Pm1bVal = SleepValues[0].Pm1bVal;
        sleepContext.bits.Flags = SLEEP_STATE_SAVE_MOTHERBOARD;

        powerState.Context = (PVOID)sleepContext.AsULONG;

        status = ZwPowerInformation(SystemPowerStateHandler,
                                    &powerState,
                                    sizeof(POWER_STATE_HANDLER),
                                    NULL,
                                    0);
        ASSERT(NT_SUCCESS(status));

    }

    if (SleepValues[1].Supported && HalpWakeVector) {
        powerState.Type = PowerStateSleeping2;
        powerState.RtcWake = TRUE;
        powerState.Handler = &HaliAcpiSleep;

        sleepContext.bits.Pm1aVal = SleepValues[1].Pm1aVal;
        sleepContext.bits.Pm1bVal = SleepValues[1].Pm1bVal;
        sleepContext.bits.Flags = SLEEP_STATE_FLUSH_CACHE |
                                  SLEEP_STATE_FIRMWARE_RESTART |
                                  SLEEP_STATE_SAVE_MOTHERBOARD |
                                  SLEEP_STATE_RESTART_OTHER_PROCESSORS;

        powerState.Context = (PVOID)sleepContext.AsULONG;

        status = ZwPowerInformation(SystemPowerStateHandler,
                                    &powerState,
                                    sizeof(POWER_STATE_HANDLER),
                                    NULL,
                                    0);
        ASSERT(NT_SUCCESS(status));

    }

    if (SleepValues[2].Supported && HalpWakeVector) {
        powerState.Type = PowerStateSleeping3;
        powerState.RtcWake = TRUE;
        powerState.Handler = &HaliAcpiSleep;

        sleepContext.bits.Pm1aVal = SleepValues[2].Pm1aVal;
        sleepContext.bits.Pm1bVal = SleepValues[2].Pm1bVal;
        sleepContext.bits.Flags = SLEEP_STATE_FLUSH_CACHE |
                                  SLEEP_STATE_FIRMWARE_RESTART |
                                  SLEEP_STATE_SAVE_MOTHERBOARD |
                                  SLEEP_STATE_RESTART_OTHER_PROCESSORS;

        powerState.Context = (PVOID)sleepContext.AsULONG;

        status = ZwPowerInformation(SystemPowerStateHandler,
                                    &powerState,
                                    sizeof(POWER_STATE_HANDLER),
                                    NULL,
                                    0);
        ASSERT(NT_SUCCESS(status));

    }

    i = 0;
    if (SleepValues[3].Supported) {
        i = 3;
    } else if (SleepValues[4].Supported) {
        i = 4;
    }

    if (i && (HalpDisableHibernate == FALSE)) {
        powerState.Type = PowerStateSleeping4;
        powerState.RtcWake = HalpFixedAcpiDescTable.flags & RTC_WAKE_FROM_S4 ? TRUE : FALSE;
        powerState.Handler = &HaliAcpiSleep;

        sleepContext.bits.Pm1aVal = SleepValues[i].Pm1aVal;
        sleepContext.bits.Pm1bVal = SleepValues[i].Pm1bVal;
        sleepContext.bits.Flags = SLEEP_STATE_SAVE_MOTHERBOARD |
                                  SLEEP_STATE_RESTART_OTHER_PROCESSORS;

        powerState.Context = (PVOID)sleepContext.AsULONG;

        status = ZwPowerInformation(SystemPowerStateHandler,
                                    &powerState,
                                    sizeof(POWER_STATE_HANDLER),
                                    NULL,
                                    0);
        ASSERT(NT_SUCCESS(status));
    }

    if (SleepValues[4].Supported) {
        powerState.Type = PowerStateShutdownOff;
        powerState.RtcWake = FALSE;
        powerState.Handler = &HaliAcpiSleep;

        sleepContext.bits.Pm1aVal = SleepValues[4].Pm1aVal;
        sleepContext.bits.Pm1bVal = SleepValues[4].Pm1bVal;
        sleepContext.bits.Flags = SLEEP_STATE_OFF;
        HalpShutdownContext = sleepContext;

        powerState.Context = (PVOID)sleepContext.AsULONG;

        status = ZwPowerInformation(SystemPowerStateHandler,
                                    &powerState,
                                    sizeof(POWER_STATE_HANDLER),
                                    NULL,
                                    0);
        ASSERT(NT_SUCCESS(status));
    }
}

ULONG
HaliAcpiQueryFlags(
    VOID
    )
/*++

Routine Description:

    This routine is temporary is used to report the presence of the
    boot.ini switch

Arguments:

    None

Return Value:

    TRUE, if switch present

--*/
{
    return HalpAcpiFlags;
}



NTSTATUS
HaliInitPowerManagement(
    IN PPM_DISPATCH_TABLE  PmDriverDispatchTable,
    IN OUT PPM_DISPATCH_TABLE *PmHalDispatchTable
    )

/*++

Routine Description:

    This is called by the ACPI driver to start the PM
    code.

Arguments:

    PmDriverDispatchTable - table of functions provided
        by the ACPI driver for the HAL

    PmHalDispatchTable - table of functions provided by
        the HAL for the ACPI driver

Return Value:

    status

--*/
{
    OBJECT_ATTRIBUTES objAttributes;
    PCALLBACK_OBJECT  callback;
    PHYSICAL_ADDRESS  pAddr;
    UNICODE_STRING    callbackName;
    NTSTATUS          status;
    PFACS         facs;

    PAGED_CODE();

    //
    // Figure out if we have to work around PIIX4
    //

    HalpPiix4Detect(TRUE);
    HalpPutAcpiHacksInRegistry();

    //
    // Keep a pointer to the driver's dispatch table.
    //
//  ASSERT(PmDriverDispatchTable);
//  ASSERT(PmDriverDispatchTable->Signature == ACPI_HAL_DISPATCH_SIGNATURE);
    PmAcpiDispatchTable = PmDriverDispatchTable;

    //
    // Fill in the function table
    //
    if (!HalpBrokenAcpiTimer) {

        HalAcpiDispatchTable.HalpAcpiTimerInterrupt =
            (pHalAcpiTimerInterrupt)&HalAcpiTimerCarry;

    } else {

        HalAcpiDispatchTable.HalpAcpiTimerInterrupt =
            (pHalAcpiTimerInterrupt)&HalAcpiBrokenPiix4TimerCarry;

    }

    *PmHalDispatchTable = (PPM_DISPATCH_TABLE)&HalAcpiDispatchTable;

    //
    // Fill in Hal's private dispatch table
    //
    HalSetWakeEnable = HaliSetWakeEnable;
    HalSetWakeAlarm  = HaliSetWakeAlarm;

    //
    // Register callback that tells us to make
    // anything we need for sleeping non-pageable.
    //

    RtlInitUnicodeString(&callbackName, L"\\Callback\\PowerState");

    InitializeObjectAttributes(
        &objAttributes,
        &callbackName,
        OBJ_CASE_INSENSITIVE | OBJ_PERMANENT,
        NULL,
        NULL
        );

    ExCreateCallback(&callback,
                     &objAttributes,
                     FALSE,
                     TRUE);

    ExRegisterCallback(callback,
                       (PCALLBACK_FUNCTION)&HalpPowerStateCallback,
                       NULL);

    //
    // Find the location of the firmware waking vector.
    //  N.B.  If any of this fails, then HalpWakeVector will be NULL
    //        and we won't support S2 or S3.
    //
    if (HalpFixedAcpiDescTable.facs) {

        pAddr.HighPart = 0;
        pAddr.LowPart = HalpFixedAcpiDescTable.facs;

        facs = MmMapIoSpace(pAddr, sizeof(FACS), MmCached);

        if (facs) {

            if (facs->Signature == FACS_SIGNATURE) {

                HalpWakeVector = &facs->pFirmwareWakingVector;
            }
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
HalpQueryAcpiResourceRequirements(
    IN  PIO_RESOURCE_REQUIREMENTS_LIST *Requirements
    )
/*++

Routine Description:

    This routine is a temporary stub that tries to detect the presence
    of an ACPI controller within the system. This code is meant to be
    inserted within NT's root system enumerator.

Arguents:

    Requirements - pointer to list of resources

Return Value:

    STATUS_SUCCESS                  - If we found a device object
    STATUS_NO_SUCH_DEVICE           - If we can't find info about the new PDO

--*/
{
    NTSTATUS                        ntStatus;
    PIO_RESOURCE_REQUIREMENTS_LIST  resourceList;
    ULONG                           resourceListSize;

    PAGED_CODE();

    //
    // Now figure out the number of resource that we need
    //
    ntStatus = HalpAcpiDetectResourceListSize(
        &resourceListSize
        );

    //
    // Convert this resourceListSize into the number of bytes that we
    // must allocate
    //
    resourceListSize = sizeof(IO_RESOURCE_REQUIREMENTS_LIST) +
        ( (resourceListSize - 1) * sizeof(IO_RESOURCE_DESCRIPTOR) );

    //
    // Allocate the correct number of bytes of the Resource List
    //
    resourceList = ExAllocatePoolWithTag(
        PagedPool,
        resourceListSize,
        HAL_POOL_TAG
        );

    //
    // This call must have succeeded or we cannot lay claim to ACPI
    //
    if (resourceList == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Set up the ListSize in the structure
    //
    RtlZeroMemory(resourceList, resourceListSize);
    resourceList->ListSize = resourceListSize;

    //
    // Build the ResourceList here
    //
    ntStatus = HalpBuildAcpiResourceList(resourceList);

    //
    // Did we build the list okay?
    //
    if (!NT_SUCCESS(ntStatus)) {

        //
        // Free memory and exit
        //
        ExFreePool(resourceList);
        return STATUS_NO_SUCH_DEVICE;
    }

    *Requirements = resourceList;
    return ntStatus;
}

NTSTATUS
HalpBuildAcpiResourceList(
    OUT PIO_RESOURCE_REQUIREMENTS_LIST  List
    )
/*++

Routine Description:

    This is the routine that builds the ResourceList given the FADT and
    an arbitrary number of ResourceDescriptors. We assume that the
    ResourceList has been properly allocated and sized

Arguments:

    List    - The list to fill in

Return Value:

    STATUS_SUCCESS if okay
    STATUS_UNSUCCESSUL if not

--*/
{
    PIO_RESOURCE_DESCRIPTOR partialResource;
    ULONG                   count = 0;

    PAGED_CODE();

    ASSERT( List != NULL );

    //
    // Specify default values for Bus Type and
    // the bus number. These values represent root
    //
    List->AlternativeLists = 1;
    List->InterfaceType = PNPBus;
    List->BusNumber = -1;
    List->List[0].Version = 1;
    List->List[0].Revision = 1;

    //
    // Is there an interrupt resource required?
    //
    if (HalpFixedAcpiDescTable.sci_int_vector != 0) {

        List->List[0].Descriptors[count].Type = CmResourceTypeInterrupt;
        List->List[0].Descriptors[count].ShareDisposition = CmResourceShareShared;
        List->List[0].Descriptors[count].Flags = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
        List->List[0].Descriptors[count].u.Interrupt.MinimumVector =
        List->List[0].Descriptors[count].u.Interrupt.MaximumVector =
            HalpPicVectorRedirect[HalpFixedAcpiDescTable.sci_int_vector];
        List->List[0].Count++;
        count++;
    }

#if DECLARE_FADT_RESOURCES_AT_ROOT

    //
    // Is there an SMI CMD IO Port?
    //
    if (HalpFixedAcpiDescTable.smi_cmd_io_port != 0) {

        List->List[0].Descriptors[count].Type = CmResourceTypePort;
        List->List[0].Descriptors[count].ShareDisposition = CmResourceShareDeviceExclusive;
        List->List[0].Descriptors[count].Flags =CM_RESOURCE_PORT_IO;
        List->List[0].Descriptors[count].u.Port.MinimumAddress.LowPart =
            (ULONG) HalpFixedAcpiDescTable.smi_cmd_io_port;
        List->List[0].Descriptors[count].u.Port.MaximumAddress.LowPart =
            (ULONG) HalpFixedAcpiDescTable.smi_cmd_io_port;
        List->List[0].Descriptors[count].u.Port.Length = 1;
        List->List[0].Descriptors[count].u.Port.Alignment = 1;
        List->List[0].Count++;
        count++;
    }

    //
    // Is there an PM1A Event Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm1a_evt_blk_io_port != 0) {

        List->List[0].Descriptors[count].Type = CmResourceTypePort;
        List->List[0].Descriptors[count].ShareDisposition = CmResourceShareDeviceExclusive;
        List->List[0].Descriptors[count].Flags = CM_RESOURCE_PORT_IO;
        List->List[0].Descriptors[count].u.Port.MinimumAddress.LowPart =
            HalpFixedAcpiDescTable.pm1a_evt_blk_io_port;
        List->List[0].Descriptors[count].u.Port.MaximumAddress.LowPart =
            HalpFixedAcpiDescTable.pm1a_evt_blk_io_port + (ULONG) HalpFixedAcpiDescTable.pm1_evt_len - 1;
        List->List[0].Descriptors[count].u.Port.Length = (ULONG) HalpFixedAcpiDescTable.pm1_evt_len;
        List->List[0].Descriptors[count].u.Port.Alignment = 1;
        List->List[0].Count++;
        count++;
    }

    //
    // Is there a PM1B Event Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm1b_evt_blk_io_port != 0) {

        List->List[0].Descriptors[count].Type = CmResourceTypePort;
        List->List[0].Descriptors[count].ShareDisposition = CmResourceShareDeviceExclusive;
        List->List[0].Descriptors[count].Flags = CM_RESOURCE_PORT_IO;
        List->List[0].Descriptors[count].u.Port.MinimumAddress.LowPart =
            HalpFixedAcpiDescTable.pm1b_evt_blk_io_port;
        List->List[0].Descriptors[count].u.Port.MaximumAddress.LowPart =
            HalpFixedAcpiDescTable.pm1b_evt_blk_io_port + (ULONG) HalpFixedAcpiDescTable.pm1_evt_len - 1;
        List->List[0].Descriptors[count].u.Port.Length = (ULONG) HalpFixedAcpiDescTable.pm1_evt_len;
        List->List[0].Descriptors[count].u.Port.Alignment = 1;
        List->List[0].Count++;
        count++;
    }

    //
    // Is there a PM1A Control Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm1a_ctrl_blk_io_port != 0) {

        List->List[0].Descriptors[count].Type = CmResourceTypePort;
        List->List[0].Descriptors[count].ShareDisposition = CmResourceShareDeviceExclusive;
        List->List[0].Descriptors[count].Flags = CM_RESOURCE_PORT_IO;
        List->List[0].Descriptors[count].u.Port.MinimumAddress.LowPart =
            HalpFixedAcpiDescTable.pm1a_ctrl_blk_io_port;
        List->List[0].Descriptors[count].u.Port.MaximumAddress.LowPart =
            HalpFixedAcpiDescTable.pm1a_ctrl_blk_io_port + (ULONG) HalpFixedAcpiDescTable.pm1_ctrl_len - 1;
        List->List[0].Descriptors[count].u.Port.Length = (ULONG) HalpFixedAcpiDescTable.pm1_ctrl_len;
        List->List[0].Descriptors[count].u.Port.Alignment = 1;
        List->List[0].Count++;
        count++;
    }

    //
    // Is there a PM1B Control Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm1b_ctrl_blk_io_port != 0) {

        List->List[0].Descriptors[count].Type = CmResourceTypePort;
        List->List[0].Descriptors[count].ShareDisposition = CmResourceShareDeviceExclusive;
        List->List[0].Descriptors[count].Flags = CM_RESOURCE_PORT_IO;
        List->List[0].Descriptors[count].u.Port.MinimumAddress.LowPart =
            HalpFixedAcpiDescTable.pm1b_ctrl_blk_io_port;
        List->List[0].Descriptors[count].u.Port.MaximumAddress.LowPart =
            HalpFixedAcpiDescTable.pm1b_ctrl_blk_io_port + (ULONG) HalpFixedAcpiDescTable.pm1_ctrl_len - 1;
        List->List[0].Descriptors[count].u.Port.Length = (ULONG) HalpFixedAcpiDescTable.pm1_ctrl_len;
        List->List[0].Descriptors[count].u.Port.Alignment = 1;
        List->List[0].Count++;
        count++;
    }

    //
    // Is there a PM2 Control Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm2_ctrl_blk_io_port != 0) {

        List->List[0].Descriptors[count].Type = CmResourceTypePort;
        List->List[0].Descriptors[count].ShareDisposition = CmResourceShareDeviceExclusive;
        List->List[0].Descriptors[count].Flags = CM_RESOURCE_PORT_IO;
        List->List[0].Descriptors[count].u.Port.MinimumAddress.LowPart =
            HalpFixedAcpiDescTable.pm2_ctrl_blk_io_port;
        List->List[0].Descriptors[count].u.Port.MaximumAddress.LowPart =
            HalpFixedAcpiDescTable.pm2_ctrl_blk_io_port + (ULONG) HalpFixedAcpiDescTable.pm2_ctrl_len - 1;
        List->List[0].Descriptors[count].u.Port.Length = (ULONG) HalpFixedAcpiDescTable.pm2_ctrl_len;
        List->List[0].Descriptors[count].u.Port.Alignment = 1;
        List->List[0].Count++;
        count++;
    }

    //
    // Is there a PM Timer Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm_tmr_blk_io_port != 0) {

        List->List[0].Descriptors[count].Type = CmResourceTypePort;
        List->List[0].Descriptors[count].ShareDisposition = CmResourceShareDeviceExclusive;
        List->List[0].Descriptors[count].Flags = CM_RESOURCE_PORT_IO;
        List->List[0].Descriptors[count].u.Port.MinimumAddress.LowPart =
            HalpFixedAcpiDescTable.pm_tmr_blk_io_port;
        List->List[0].Descriptors[count].u.Port.MaximumAddress.LowPart =
            HalpFixedAcpiDescTable.pm_tmr_blk_io_port + (ULONG) HalpFixedAcpiDescTable.pm_tmr_len - 1;
        List->List[0].Descriptors[count].u.Port.Length = (ULONG) HalpFixedAcpiDescTable.pm_tmr_len;
        List->List[0].Descriptors[count].u.Port.Alignment = 1;
        List->List[0].Count++;
        count++;
    }

    //
    // Is there a GP0 Block IO Port?
    //
    if (HalpFixedAcpiDescTable.gp0_blk_io_port != 0) {

        List->List[0].Descriptors[count].Type = CmResourceTypePort;
        List->List[0].Descriptors[count].ShareDisposition = CmResourceShareDeviceExclusive;
        List->List[0].Descriptors[count].Flags = CM_RESOURCE_PORT_IO;
        List->List[0].Descriptors[count].u.Port.MinimumAddress.LowPart =
            HalpFixedAcpiDescTable.gp0_blk_io_port;
        List->List[0].Descriptors[count].u.Port.MaximumAddress.LowPart =
            HalpFixedAcpiDescTable.gp0_blk_io_port + (ULONG) HalpFixedAcpiDescTable.gp0_blk_len - 1;
        List->List[0].Descriptors[count].u.Port.Length = (ULONG) HalpFixedAcpiDescTable.gp0_blk_len;
        List->List[0].Descriptors[count].u.Port.Alignment = 1;
        List->List[0].Count++;
        count++;
    }

    //
    // Is there a GP1 Block IO port?
    //
    if (HalpFixedAcpiDescTable.gp1_blk_io_port != 0) {

        List->List[0].Descriptors[count].Type = CmResourceTypePort;
        List->List[0].Descriptors[count].ShareDisposition = CmResourceShareDeviceExclusive;
        List->List[0].Descriptors[count].Flags = CM_RESOURCE_PORT_IO;
        List->List[0].Descriptors[count].u.Port.MinimumAddress.LowPart =
            HalpFixedAcpiDescTable.gp1_blk_io_port;
        List->List[0].Descriptors[count].u.Port.MaximumAddress.LowPart =
            HalpFixedAcpiDescTable.gp1_blk_io_port + (ULONG) HalpFixedAcpiDescTable.gp1_blk_len - 1;
        List->List[0].Descriptors[count].u.Port.Length = (ULONG) HalpFixedAcpiDescTable.gp1_blk_len;
        List->List[0].Descriptors[count].u.Port.Alignment = 1;
        List->List[0].Count++;
        count++;
    }
#endif // DECLARE_FADT_RESOURCES_AT_ROOT

    return STATUS_SUCCESS;
}

NTSTATUS
HalpAcpiDetectResourceListSize(
    OUT  PULONG   ResourceListSize
    )
/*++

Routine Description:

    Given a pointer to an FADT, determine the number of
    CM_PARTIAL_RESOURCE_DESCRIPTORS that are required to
    describe all the resource mentioned in the FADT

Arguments:

    ResourceListSize    - Location to store the answer

Return Value:

    STATUS_SUCCESS if everything went okay

--*/
{
    PAGED_CODE();

    //
    // First of all, assume that we need no resources
    //
    *ResourceListSize = 0;

    //
    // Is there an interrupt resource required?
    //
    if (HalpFixedAcpiDescTable.sci_int_vector != 0) {
        *ResourceListSize += 1;
    }

#if DECLARE_FADT_RESOURCES_AT_ROOT
    //
    // Is there an SMI CMD IO Port?
    //
    if (HalpFixedAcpiDescTable.smi_cmd_io_port != 0) {
        *ResourceListSize += 1;
    }

    //
    // Is there an PM1A Event Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm1a_evt_blk_io_port != 0) {
        *ResourceListSize += 1;
    }

    //
    // Is there a PM1B Event Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm1b_evt_blk_io_port != 0) {
        *ResourceListSize += 1;
    }

    //
    // Is there a PM1A Control Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm1a_ctrl_blk_io_port != 0) {
        *ResourceListSize += 1;
    }

    //
    // Is there a PM1B Control Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm1b_ctrl_blk_io_port != 0) {
        *ResourceListSize += 1;
    }

    //
    // Is there a PM2 Control Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm2_ctrl_blk_io_port != 0) {
        *ResourceListSize += 1;
    }

    //
    // Is there a PM Timer Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm_tmr_blk_io_port != 0) {
        *ResourceListSize += 1;
    }

    //
    // Is there a GP0 Block IO Port?
    //
    if (HalpFixedAcpiDescTable.gp0_blk_io_port != 0) {
        *ResourceListSize += 1;
    }

    //
    // Is there a GP1 Block IO Port?
    //
    if (HalpFixedAcpiDescTable.gp1_blk_io_port != 0) {
        *ResourceListSize += 1;
    }
#endif // DECLARE_FADT_RESOURCES_AT_ROOT

    return STATUS_SUCCESS;
}

VOID
HalpPiix4Detect(
    BOOLEAN DuringBoot
    )
/*++

Routine Description:

    This routine detects both the PIIX4 and the 440BX and
    enables various workarounds.  It also disconnects the
    PIIX4 USB controller from the interrupt controller, as
    many BIOSes boot with the USB controller in an
    interrupting state.

Arguments:

    DuringBoot - if TRUE, then do all the things that
                 have to happen at first boot
                 if FALSE, then do only the things that
                 have to happen each time the system
                 transitions to system state S0.

Note:

    This routine calls functions that must be called
    at PASSIVE_LEVEL when DuringBoot is TRUE.

--*/
{
    OBJECT_ATTRIBUTES   ObjectAttributes;
    UNICODE_STRING      UnicodeString;
    STRING              AString;
    NTSTATUS            Status;
    HANDLE              BaseHandle = NULL;
    HANDLE              Handle = NULL;
    BOOLEAN             i440BXpresent = FALSE;
    ULONG               Length;
    ULONG               BytesRead;
    UCHAR               BusNumber;
    ULONG               DeviceNumber;
    ULONG               FuncNumber;
    PCI_SLOT_NUMBER     SlotNumber;
    PCI_COMMON_CONFIG   PciHeader;
    UCHAR               DevActB;
    UCHAR               DramControl;
    ULONG               disposition;
    ULONG               flags;
    CHAR                buffer[20] = {0};

    struct {
        KEY_VALUE_PARTIAL_INFORMATION   Inf;
        UCHAR Data[3];
    } PartialInformation;

    if (DuringBoot) {
        PAGED_CODE();

        //
        // Open current control set
        //

        RtlInitUnicodeString (&UnicodeString,
                              L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET");

        InitializeObjectAttributes(&ObjectAttributes,
                                   &UnicodeString,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   (PSECURITY_DESCRIPTOR) NULL);

        Status = ZwOpenKey (&BaseHandle,
                            KEY_READ,
                            &ObjectAttributes);

        if (!NT_SUCCESS(Status)) {
            return;
        }

        // Get the right key

        RtlInitUnicodeString (&UnicodeString,
                              L"Control\\HAL");

        InitializeObjectAttributes(&ObjectAttributes,
                                   &UnicodeString,
                                   OBJ_CASE_INSENSITIVE,
                                   BaseHandle,
                                   (PSECURITY_DESCRIPTOR) NULL);

        Status = ZwCreateKey (&Handle,
                              KEY_READ,
                              &ObjectAttributes,
                              0,
                              (PUNICODE_STRING) NULL,
                              REG_OPTION_NON_VOLATILE,
                              &disposition);

        if(!NT_SUCCESS(Status)) {
            goto Piix4DetectCleanup;
        }
    }

    //
    // Check each existing PCI bus for a PIIX4 chip.
    //


    for (BusNumber = 0; BusNumber < 0xff; BusNumber++) {

        SlotNumber.u.AsULONG = 0;

        for (DeviceNumber = 0; DeviceNumber < PCI_MAX_DEVICES; DeviceNumber ++ ) {
            for (FuncNumber = 0; FuncNumber < PCI_MAX_FUNCTION; FuncNumber ++) {

            SlotNumber.u.bits.DeviceNumber = DeviceNumber;
            SlotNumber.u.bits.FunctionNumber = FuncNumber;

            BytesRead = HalGetBusData (
                            PCIConfiguration,
                            BusNumber,
                            SlotNumber.u.AsULONG,
                            &PciHeader,
                            PCI_COMMON_HDR_LENGTH
                            );

            if (!BytesRead) {
                // past last bus
                goto Piix4DetectEnd;
            }

            if (PciHeader.VendorID == PCI_INVALID_VENDORID) {
                continue;
            }

            if (DuringBoot) {

                //
                // Look for broken 440BX.
                //

                if (((PciHeader.VendorID == 0x8086) &&
                     (PciHeader.DeviceID == 0x7190 ||
                      PciHeader.DeviceID == 0x7192) &&
                     (PciHeader.RevisionID <= 2))) {

                    i440BXpresent = TRUE;

                    BytesRead = HalGetBusDataByOffset (
                                    PCIConfiguration,
                                    BusNumber,
                                    SlotNumber.u.AsULONG,
                                    &DramControl,
                                    0x57,
                                    1
                                    );

                    ASSERT(BytesRead == 1);

                    if (DramControl & 0x18) {

                        //
                        // This machine is using SDRAM or Registered SDRAM.
                        //

                        if (DramControl & 0x20) {

                            //
                            // SDRAM dynamic power down unavailable.
                            //

                            HalpBroken440BX = TRUE;
                        }
                    }
                }

                Status = HalpGetChipHacks(PciHeader.VendorID,
                                          PciHeader.DeviceID,
                                          0,
                                          &flags);

                if (NT_SUCCESS(Status)) {

                    if (flags & PM_TIMER_HACK_FLAG) {
                        HalpBrokenAcpiTimer = TRUE;
                    }

                    if (flags & DISABLE_HIBERNATE_HACK_FLAG) {
                        HalpDisableHibernate = TRUE;
                    }

#if !defined(APIC_HAL)
                    if (flags & SET_ACPI_IRQSTACK_HACK_FLAG) {
                        HalpSetAcpiIrqHack(2); // AcpiIrqDistributionDispositionStackUp
                    }
#endif
                    if (flags & WHACK_ICH_USB_SMI_HACK_FLAG) {
                        HalpWhackICHUsbSmi(BusNumber, SlotNumber);
                    }
                }
            }

            //
            // Look for PIIX4.
            //

            if (PciHeader.VendorID == 0x8086 && PciHeader.DeviceID == 0x7110) {

                //
                // Get the power management function
                //

                SlotNumber.u.bits.FunctionNumber = 3;
                HalGetBusData (
                    PCIConfiguration,
                    BusNumber,
                    SlotNumber.u.AsULONG,
                    &PciHeader,
                    PCI_COMMON_HDR_LENGTH
                    );

                ASSERT(PciHeader.RevisionID != 0);

                HalpPiix4 = PciHeader.RevisionID;
                        HalpBrokenAcpiTimer = TRUE;

                //
                // If this is an original piix4, then it has thermal joined
                // with C2&C3&Throttle clock stopping.
                //

                if (PciHeader.RevisionID <= 1) {

                    //
                    // This piix4 needs some help - remember where it is and
                    // set the HalpPiix4 flag
                    //

                    HalpPiix4BusNumber = BusNumber;
                    HalpPiix4SlotNumber = SlotNumber.u.AsULONG;

                    //
                    // Does not work MP
                    //

                    // ASSERT (KeNumberProcessors == 1);

                    //
                    // Read the DevActB register and set all IRQs to be break events
                    //

                    HalGetBusDataByOffset (
                        PCIConfiguration,
                        HalpPiix4BusNumber,
                        HalpPiix4SlotNumber,
                        &HalpPiix4DevActB,
                        0x58,
                        sizeof(ULONG)
                        );

                    HalpPiix4DevActB |= 0x23;

                    HalSetBusDataByOffset (
                        PCIConfiguration,
                        HalpPiix4BusNumber,
                        HalpPiix4SlotNumber,
                        &HalpPiix4DevActB,
                        0x58,
                        sizeof(ULONG)
                        );
                }

                //
                // Shut off the interrupt for the USB controller.
                //

                SlotNumber.u.bits.FunctionNumber = 2;

                HalpStopUhciInterrupt(BusNumber,
                                      SlotNumber,
                                      TRUE);

                // piix4 was found, we're done
                goto Piix4DetectEnd;
            }

            //
            // Look for ICH, or any other Intel or VIA UHCI USB controller.
            //

            if ((PciHeader.BaseClass == PCI_CLASS_SERIAL_BUS_CTLR) &&
                (PciHeader.SubClass == PCI_SUBCLASS_SB_USB) &&
                (PciHeader.ProgIf == 0x00)) {
                if (PciHeader.VendorID == 0x8086) {

                    HalpStopUhciInterrupt(BusNumber,
                                          SlotNumber,
                                          TRUE);

                } else if (PciHeader.VendorID == 0x1106) {

                    HalpStopUhciInterrupt(BusNumber,
                                          SlotNumber,
                                          FALSE);

                }
            }

            //
            // Look for an OHCI-compliant USB controller.
            //

            if ((PciHeader.BaseClass == PCI_CLASS_SERIAL_BUS_CTLR) &&
                (PciHeader.SubClass == PCI_SUBCLASS_SB_USB) &&
                (PciHeader.ProgIf == 0x10)) {

                HalpStopOhciInterrupt(BusNumber,
                                      SlotNumber);
            }

            if ((FuncNumber == 0) &&
                !PCI_MULTIFUNCTION_DEVICE((&PciHeader))) {
                break;
            }

            } // func number
        }   // device number
    }   // bus number

Piix4DetectEnd:

    if (!DuringBoot) {
        return;
    }

    if (Handle) {
        ZwClose (Handle);
        Handle = NULL;
    }

    if (i440BXpresent) {

        // Get the right key

        RtlInitUnicodeString (&UnicodeString,
                              L"Services\\ACPI\\Parameters");

        InitializeObjectAttributes(&ObjectAttributes,
                                   &UnicodeString,
                                   OBJ_CASE_INSENSITIVE,
                                   BaseHandle,
                                   (PSECURITY_DESCRIPTOR) NULL);

        Status = ZwCreateKey (&Handle,
                              KEY_READ,
                              &ObjectAttributes,
                              0,
                              (PUNICODE_STRING) NULL,
                              REG_OPTION_NON_VOLATILE,
                              &disposition);

        if(!NT_SUCCESS(Status)) {
            goto Piix4DetectCleanup;
        }

        // Get the value of the hack

        RtlInitUnicodeString (&UnicodeString,
                              L"EnableBXWorkAround");

        Status = ZwQueryValueKey (Handle,
                                  &UnicodeString,
                                  KeyValuePartialInformation,
                                  &PartialInformation,
                                  sizeof (PartialInformation),
                                  &Length);

        if (!NT_SUCCESS(Status)) {
            goto Piix4DetectCleanup;
        }

        // Check to make sure the retrieved data makes sense

        if(PartialInformation.Inf.DataLength < sizeof(UCHAR))
        {
           goto Piix4DetectCleanup;
        }

        HalpBroken440BX = *((PCHAR)(PartialInformation.Inf.Data));
    }

Piix4DetectCleanup:

    if (Handle) ZwClose (Handle);
    if (BaseHandle) ZwClose (BaseHandle);
}

VOID
HalpInitBootTable (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
{
    UCHAR BootRegisterValue;

    HalpSimpleBootFlagTable = (PBOOT_TABLE)HalpGetAcpiTablePhase0(LoaderBlock, BOOT_SIGNATURE);

    //
    // We also verify that the CMOS index of the flag offset is >9 to catch those
    // BIOSes (Toshiba) which mistakenly use the time and date fields to store their
    // simple boot flag.
    //

    if ( HalpSimpleBootFlagTable &&
        (HalpSimpleBootFlagTable->Header.Length >= sizeof(BOOT_TABLE)) &&
        (HalpSimpleBootFlagTable->CMOSIndex > 9)) {

        if ( HalReadBootRegister (&BootRegisterValue) == STATUS_SUCCESS ) {

            if ( !(BootRegisterValue & SBF_PNPOS) ) {
                BootRegisterValue |= SBF_PNPOS;
                HalWriteBootRegister (BootRegisterValue);
            }
        }

    } else {

        HalpSimpleBootFlagTable = NULL;
    }

    HalEndOfBoot = HalpEndOfBoot;
}

NTSTATUS
HalReadBootRegister(
    PUCHAR BootRegisterValue
    )
/*++

Routine Description:

Arguments:

Note:

--*/
{
    if (!HalpSimpleBootFlagTable ||
        (HalpSimpleBootFlagTable->CMOSIndex == 0xFFFFFFFF)) return STATUS_NO_SUCH_DEVICE;

    if (!BootRegisterValue) return STATUS_INVALID_PARAMETER;

    HalpGetCmosData (0, HalpSimpleBootFlagTable->CMOSIndex, (PVOID)BootRegisterValue, 1);

    return STATUS_SUCCESS;
}

NTSTATUS
HalWriteBootRegister(
    UCHAR BootRegisterValue
    )
/*++

Routine Description:

Arguments:

Note:

--*/
{
    UCHAR numbits = 0, mask = 1;

    if (!HalpSimpleBootFlagTable ||
        (HalpSimpleBootFlagTable->CMOSIndex == 0xFFFFFFFF)) return STATUS_NO_SUCH_DEVICE;

    for (mask = 1;mask < 128;mask <<= 1) {

        if (BootRegisterValue & mask) numbits++;

    }

    if ( !(numbits & 1) ) {

        BootRegisterValue |= SBF_PARITY;
    }
    else {

        BootRegisterValue &= (~SBF_PARITY);
    }

    HalpSetCmosData (0, HalpSimpleBootFlagTable->CMOSIndex, (PVOID)&BootRegisterValue, 1);

    return STATUS_SUCCESS;
}

VOID
HalpEndOfBoot(
    VOID
    )
/*++

Routine Description:

Arguments:

Note:

--*/
{
    HalpResetSBF();
}

VOID
HalpResetSBF(
    VOID
    )
{
    UCHAR value;

    if (!HalpSimpleBootFlagTable) {
        //
        // No SBF in this machine.
        //
        return;
    }

    if ( HalReadBootRegister (&value) == STATUS_SUCCESS ) {

        value &=(~(SBF_BOOTING | SBF_DIAG));
        HalWriteBootRegister (value);
    }
}

VOID
HalpPutAcpiHacksInRegistry(
    VOID
    )
{
    OBJECT_ATTRIBUTES   ObjectAttributes;
    UNICODE_STRING      UnicodeString;
    HANDLE              BaseHandle = NULL;
    HANDLE              Handle = NULL;
    ULONG               disposition;
    ULONG               value;
    NTSTATUS            status;

    PAGED_CODE();

    //
    // Open PCI service key.
    //

    RtlInitUnicodeString (&UnicodeString,
                          L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET\\Control\\HAL");

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               (PSECURITY_DESCRIPTOR) NULL);

    status = ZwOpenKey (&BaseHandle,
                        KEY_READ,
                        &ObjectAttributes);

    if (!NT_SUCCESS(status)) {
        return;
    }

    // Get the right key

    RtlInitUnicodeString (&UnicodeString,
                          L"CStateHacks");

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               BaseHandle,
                               (PSECURITY_DESCRIPTOR) NULL);

    status = ZwCreateKey (&Handle,
                          KEY_READ,
                          &ObjectAttributes,
                          0,
                          (PUNICODE_STRING) NULL,
                          REG_OPTION_VOLATILE,
                          &disposition);

    ZwClose(BaseHandle);

    if (!NT_SUCCESS(status)) {
        return;
    }

    //
    // Create keys for each of the hacks.
    //

    value = (ULONG)HalpPiix4;

    RtlInitUnicodeString (&UnicodeString,
                          L"Piix4");

    status = ZwSetValueKey (Handle,
                            &UnicodeString,
                            0,
                            REG_DWORD,
                            &value,
                            sizeof(ULONG));

    //ASSERT(NT_SUCCESS(status));

    value = (ULONG)HalpBroken440BX;

    RtlInitUnicodeString (&UnicodeString,
                          L"440BX");

    status = ZwSetValueKey (Handle,
                            &UnicodeString,
                            0,
                            REG_DWORD,
                            &value,
                            sizeof(ULONG));

    //ASSERT(NT_SUCCESS(status));

    value = (ULONG)&HalpOutstandingScatterGatherCount;

    RtlInitUnicodeString (&UnicodeString,
                          L"SGCount");

    status = ZwSetValueKey (Handle,
                            &UnicodeString,
                            0,
                            REG_DWORD,
                            &value,
                            sizeof(ULONG));

    //ASSERT(NT_SUCCESS(status));

    value = HalpPiix4SlotNumber | (HalpPiix4BusNumber << 16);

    RtlInitUnicodeString (&UnicodeString,
                          L"Piix4Slot");

    status = ZwSetValueKey (Handle,
                            &UnicodeString,
                            0,
                            REG_DWORD,
                            &value,
                            sizeof(ULONG));

    //ASSERT(NT_SUCCESS(status));

    value = HalpPiix4DevActB;

    RtlInitUnicodeString (&UnicodeString,
                          L"Piix4DevActB");

    status = ZwSetValueKey (Handle,
                            &UnicodeString,
                            0,
                            REG_DWORD,
                            &value,
                            sizeof(ULONG));

    //ASSERT(NT_SUCCESS(status));

    ZwClose(Handle);

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\rangesup.c ===
//
// This file simply includes the common sources from the current HAL
// directory. When the structure is finally changed, the real file should
// be in this directory.
//

#include "..\rangesup.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\xxbiosc.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\xxbiosc.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\xxdisp.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\xxdisp.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\xxacpi.h ===
;/*++
;
; Copyright (c) 1997  Microsoft Corporation
;
; Module Name:
;
;   xxacpi.h
;
; Abstract:
;
;
;   This module contains definitions specific to the HAL's
;   ACPI function.
;
; Author:
;
;   Jake Oshins (jakeo) Feb. 18, 1997
;
; Revision History:
;
;-

if 0        ; Begin C only code         */

#if !defined(_XXACPI_H_)
#define __XACPI_H_

#include "eisa.h"
#include "ntacpi.h"
#include "acpi_mp.inc"

//
// General ACPI structures
//
typedef struct {
    BOOLEAN     GeneralWakeupEnable;
    BOOLEAN     RtcWakeupEnable;
    TIME_FIELDS RtcWakeupTime;
} HAL_WAKEUP_STATE, *PHAL_WAKEUP_STATE;


ULONG
HalpBuildTiledCR3 (
    IN PKPROCESSOR_STATE    ProcessorState
    );

VOID
HalpFreeTiledCR3 (
    VOID
    );


//
// internal prototypes
//
PVOID
HalpGetAcpiTablePhase0(
    IN  PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN  ULONG   Signature
    );

BOOLEAN
HalpAcpiPreSleep(
    SLEEP_STATE_CONTEXT Context
    );

NTSTATUS
HaliAcpiSleep(
    IN PVOID                        Context,
    IN PENTER_STATE_SYSTEM_HANDLER  SystemHandler   OPTIONAL,
    IN PVOID                        SystemContext,
    IN LONG                         NumberProcessors,
    IN volatile PLONG               Number
    );

BOOLEAN
HalpAcpiPostSleep(
    ULONG Context
    );

NTSTATUS
HaliSetWakeAlarm (
	IN ULONGLONG	WakeSystemTime,
	IN PTIME_FIELDS	WakeTimeFields OPTIONAL
	);

NTSTATUS
HalpSetWakeAlarm (
	IN ULONGLONG	WakeSystemTime,
	IN PTIME_FIELDS	WakeTimeFields OPTIONAL
	);

VOID
HaliSetWakeEnable(
	IN BOOLEAN	Enable
	);

VOID
HalpSleepGetProcState(
    IN OUT PKPROCESSOR_STATE ProcState
    );

BOOLEAN
HalpAcpiPicStateIntact(
    VOID
    );

ULONG
HalpGetApicVersion(
    ULONG ApicNo
    );

VOID
HalpResetSBF(
    VOID
    );

//
// The kernel leaves some space (64 byte) of the PCR for the HAL to use
// as it needs.
//

typedef struct {
    ULONG   Reserved1;  // this space is used by APIC stuff (see pcmp_nt.inc)
    union {
        ULONG       AddrAndFlags;
        struct {
            USHORT  Addr;
            UCHAR   Flags;
            UCHAR   Spare1;
        } ;
    } PBlk;
} HALPMPRCB, *PHALPMPRCB;

//
// Global HAL-ACPI stuff
//
extern FADT HalpFixedAcpiDescTable;
extern PDEBUG_PORT_TABLE HalpDebugPortTable;
extern BOOLEAN HalpProcessedACPIPhase0;
extern HAL_WAKEUP_STATE HalpWakeupState;
extern ULONG HalpThrottleScale;
extern SLEEP_STATE_CONTEXT HalpSleepContext;
extern KPROCESSOR_STATE    HalpSleepProcState;
extern PHYSICAL_ADDRESS    HalpTiledCR3Address;

extern UCHAR   HalpBrokenAcpiTimer;

extern UCHAR   HalpPiix4;
extern ULONG   HalpPiix4BusNumber;
extern ULONG   HalpPiix4SlotNumber;
extern ULONG   HalpPiix4DevActB;

extern BOOLEAN HalpBroken440BX;

extern PUCHAR  HalpLowStub;
extern PVOID   HalpLowStubPhysicalAddress;
extern PVOID   HalpWakeVector;
extern PVOID   HalpVirtAddrForFlush;
extern PVOID   HalpPteForFlush;
extern BOOLEAN HalpCr4Exists;

extern MP_INFO HalpMpInfoTable;
extern PMAPIC  HalpApicTable;
extern PBOOT_TABLE HalpSimpleBootFlagTable;


#define PIIX4_THROTTLE_FIX  0x10000

#endif // _XXACPI_H_

/*
endif
;
;  Begin assembly part of the definitions
;

include ntacpi.h

;
; The kernel leaves some space (64 byte) of the PCR for the HAL to use
; as it needs.
;

PrcbE struc
    Reserved1           dd      1       ; used in APIC HAL
    PcrPblk             dd      0       ; PBlk and flags
PrcbE ends

PIIX4_THROTTLE_FIX  EQU 10000h

;*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\sratnuma.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    sratnuma.c

Abstract:

    This module contain functions which support static NUMA configurations
    as provided by the ACPI SRAT "Static Resource Affinity Table".

Author:

    Peter L Johnston (peterj) 2-Jul-2000

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "acpitabl.h"
#include "xxacpi.h"

#if !defined(NT_UP)

#define ROUNDUP_TO_NEXT(base, size) \
        ((((ULONG_PTR)(base)) + (size)) & ~((size) - 1))

//
// The following routine is external but only used by NUMA support
// at the moment.
//

NTSTATUS
HalpGetApicIdByProcessorNumber(
    IN     UCHAR     Processor,
    IN OUT USHORT   *ApicId
    );

//
// Prototypes for alloc pragmas.
//

VOID
HalpNumaInitializeStaticConfiguration(
    IN PLOADER_PARAMETER_BLOCK
    );


#if defined(ALLOC_PRAGMA)
#pragma alloc_text(INIT,HalpNumaInitializeStaticConfiguration)
#endif

#define NEXT_ENTRY(base) (((PUCHAR)base) + (base)->Length)

#define HAL_MAX_NODES       8

#if defined(_WIN64)

#define HAL_MAX_PROCESSORS  64

#else

#define HAL_MAX_PROCESSORS  32

#endif

typedef struct _STATIC_NUMA_CONFIG {
    USHORT  ProcessorApicId[HAL_MAX_PROCESSORS];
    UCHAR   ProcessorProximity[HAL_MAX_PROCESSORS];
    UCHAR   ProximityId[HAL_MAX_NODES];
    UCHAR   NodeCount;
    UCHAR   ProcessorCount;
} HALPSRAT_STATIC_NUMA_CONFIG, *PHALPSRAT_STATIC_NUMA_CONFIG;

PHALPSRAT_STATIC_NUMA_CONFIG    HalpNumaConfig;
PACPI_SRAT                      HalpAcpiSrat;
PULONG_PTR                      HalpNumaMemoryRanges;
PUCHAR                          HalpNumaMemoryNode;
ULONG                           HalpNumaLastRangeIndex;

ULONG
HalpNumaQueryPageToNode(
    IN ULONG_PTR PhysicalPageNumber
    )
/*++

Routine Description:

    Search the memory range descriptors to determine the node
    this page exists on.

Arguments:

    PhysicalPageNumber  Provides the page number.

Return Value:

    Returns the node number for the page.

--*/

{
    ULONG Index = HalpNumaLastRangeIndex;

    //
    // Starting in the same range as the last page returned,
    // look for this page.
    //

    if (PhysicalPageNumber >= HalpNumaMemoryRanges[Index]) {

        //
        // Search upwards.
        //

        while (PhysicalPageNumber >= HalpNumaMemoryRanges[Index+1]) {
            Index++;
        }

    } else {

        //
        // Search downwards.
        //

        do {
            Index--;
        } while (PhysicalPageNumber < HalpNumaMemoryRanges[Index]);
    }

    HalpNumaLastRangeIndex = Index;
    return HalpNumaMemoryNode[Index];
}

NTSTATUS
HalpNumaQueryProcessorNode(
    IN  ULONG   ProcessorNumber,
    OUT PUSHORT Identifier,
    OUT PUCHAR  Node
    )
{
    NTSTATUS Status;
    USHORT   ApicId;
    UCHAR    Proximity;
    UCHAR    i, j;

    //
    // Get the APIC Id for this processor.
    //

    Status = HalpGetApicIdByProcessorNumber((UCHAR)ProcessorNumber, &ApicId);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Return the APIC Id as the Identifier.   This should probably
    // be the ACPI Id but we don't have a way to get that yet.
    //

    *Identifier = ApicId;

    //
    // Find the node this processor belongs to.  The node is the
    // index into the array of Proximity Ids for the entry corresponding
    // to the Proximity Id of this processor.
    //

    for (i = 0; i < HalpNumaConfig->ProcessorCount; i++) {
        if (HalpNumaConfig->ProcessorApicId[i] == ApicId) {
            Proximity = HalpNumaConfig->ProcessorProximity[i];
            for (j = 0; j < HalpNumaConfig->NodeCount; j++) {
                if (HalpNumaConfig->ProximityId[j] == Proximity) {
                    *Node = j;
                    return STATUS_SUCCESS;
                }
            }
        }
    }

    //
    // Didn't find this processor in the known set of APIC IDs, this
    // would indicate a mismatch between the BIOS MP tables and the
    // SRAT, or, didn't find the proximity for this processor in the
    // table of proximity IDs.   This would be an internal error as
    // this array is build from the set of proximity IDs in the SRAT.
    //

    return STATUS_NOT_FOUND;
}

VOID
HalpNumaInitializeStaticConfiguration(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This routine reads the ACPI Static Resource Affinity Table to build
    a picture of the system's NUMA configuration.   This information is
    saved in the HalpNumaConfig structure in a form which is optimal for
    the OS's use.

Arguments:

    LoaderBlock supplies a pointer to the system loader parameter block.

Return Value:

    None.

--*/

{
    ULONG NodeCount = 0;
    ULONG MemoryDescriptorCount = 0;
    UCHAR ProcessorCount = 0;
    PACPI_SRAT_ENTRY SratEntry;
    PACPI_SRAT_ENTRY SratEnd;
    ULONG i, j;
    BOOLEAN Swapped;
    PHYSICAL_ADDRESS Base;
    ULONG_PTR p;
    PVOID Phys;

    HalpAcpiSrat = HalpGetAcpiTablePhase0(LoaderBlock, ACPI_SRAT_SIGNATURE);
    if (HalpAcpiSrat == NULL) {
        return;
    }

    //
    // The Static Resource Affinity Table (SRAT) exists.
    //
    // Scan it to determine the number of memory descriptors then
    // allocate memory to contain the tables needed to hold the
    // system's NUMA configuration.
    //

    SratEnd = (PACPI_SRAT_ENTRY)(((PUCHAR)HalpAcpiSrat) +
                                        HalpAcpiSrat->Header.Length);
    for (SratEntry = (PACPI_SRAT_ENTRY)(HalpAcpiSrat + 1);
         SratEntry < SratEnd;
         SratEntry = (PACPI_SRAT_ENTRY)NEXT_ENTRY(SratEntry)) {
        switch (SratEntry->Type) {
        case SratMemory:
            MemoryDescriptorCount++;
            break;
        }
    }

    //
    // HalpNumaConfig format:
    //
    // HalpNumaConfig->
    //      USHORT      ProcessorApicId[HAL_MAX_PROCESSORS];
    //      UCHAR       ProcessorProximity[HAL_MAX_PROCESSORS];
    //      UCHAR       ProximityIds[HAL_MAX_NODES];
    //      UCHAR       NodeCount;
    //      -pad- to 128 byte boundary
    // HalpNumaMemoryNode->
    //      UCHAR       MemoryRangeProximityId[NumberOfMemoryRanges];
    //      -pad to     ULONG_PTR alignment-
    // HalpNumaMemoryRanges->
    //      ULONG_PTR   MemoryRangeBasePage[NumberOfMemoryRanges];
    //
    // This format has been selected to maximize cache hits while
    // searching the ranges.  Specifically, the size of the ranges
    // array is kept to a minumum.
    //

    //
    // Calculate number of pages required to hold the needed structures.
    //

    i = MemoryDescriptorCount * (sizeof(ULONG_PTR) + sizeof(UCHAR)) +
        sizeof(HALPSRAT_STATIC_NUMA_CONFIG) + 2 * sizeof(ULONG) + 128;
    i += PAGE_SIZE - 1;
    i >>= PAGE_SHIFT;

    Phys = (PVOID)HalpAllocPhysicalMemory(LoaderBlock,
                                MAXIMUM_PHYSICAL_ADDRESS,
                                i,
                                FALSE);
    if (Phys == NULL) {

        //
        // Allocation failed, the system will not be able to run
        // as a NUMA system,.... actually the system will probably
        // not run far at all.
        //

        DbgPrint("HAL NUMA Initialization failed, could not allocate %d pages\n",
                 i);

        HalpAcpiSrat = NULL;
        return;
    }
    Base.QuadPart = (ULONG_PTR)Phys;

#if !defined(_IA64_)

    HalpNumaConfig = HalpMapPhysicalMemory(Base, 1);

#else

    HalpNumaConfig = HalpMapPhysicalMemory(Base, 1, MmCached);

#endif

    if (HalpNumaConfig == NULL) {

        //
        // Couldn't map the allocation, give up.
        //

        HalpAcpiSrat = NULL;
        return;
    }
    RtlZeroMemory(HalpNumaConfig, i * PAGE_SIZE);

    //
    // MemoryRangeProximity is an array of UCHARs starting at the next
    // 128 byte boundary.
    //

    p = ROUNDUP_TO_NEXT((HalpNumaConfig + 1), 128);
    HalpNumaMemoryNode = (PUCHAR)p;

    //
    // NumaMemoryRanges is an array of ULONG_PTRs starting at the next
    // ULONG_PTR boundary.
    //

    p += (MemoryDescriptorCount + sizeof(ULONG_PTR)) & ~(sizeof(ULONG_PTR) - 1);
    HalpNumaMemoryRanges = (PULONG_PTR)p;

    //
    // Rescan the SRAT entries filling in the HalpNumaConfig structure.
    //

    ProcessorCount = 0;
    MemoryDescriptorCount = 0;

    for (SratEntry = (PACPI_SRAT_ENTRY)(HalpAcpiSrat + 1);
         SratEntry < SratEnd;
         SratEntry = (PACPI_SRAT_ENTRY)NEXT_ENTRY(SratEntry)) {

        //
        // Does this entry belong to a proximity domain not previously
        // seen?   If so, we have a new node.
        //

        for (i = 0; i < HalpNumaConfig->NodeCount; i++) {
            if (SratEntry->ProximityDomain == HalpNumaConfig->ProximityId[i]) {
                break;
            }
        }

        if (i == HalpNumaConfig->NodeCount) {

            //
            // This is an ID we haven't seen before.  New Node.
            //

            if (HalpNumaConfig->NodeCount >= 8) {

                //
                // We support a maximum of 8 nodes, make this machine
                // not NUMA.  (Yes, we should free the config space
                // we allocated,... but this is an error when it happens
                // so I'm not worrying about it.  peterj).
                //

                HalpAcpiSrat = NULL;
                return;
            }
            HalpNumaConfig->ProximityId[i] = SratEntry->ProximityDomain;
            HalpNumaConfig->NodeCount++;
        }

        switch (SratEntry->Type) {
        case SratProcessorLocalAPIC:

            if (SratEntry->ApicAffinity.Flags.Enabled == 0) {

                //
                // This processor is not enabled, skip it.
                //

                continue;
            }
            if (ProcessorCount == HAL_MAX_PROCESSORS) {

                //
                // Can't handle any more processors.   Turn this
                // into a non-numa machine.
                //

                HalpAcpiSrat = NULL;
                return;
            }
            HalpNumaConfig->ProcessorApicId[ProcessorCount] =

#if defined(_IA64_)

                SratEntry->ApicAffinity.ApicId << 8  |
                (SratEntry->ApicAffinity.SApicEid);

#else

                SratEntry->ApicAffinity.ApicId  |
                (SratEntry->ApicAffinity.SApicEid << 8);

#endif

            HalpNumaConfig->ProcessorProximity[ProcessorCount] =
                SratEntry->ProximityDomain;
            ProcessorCount++;
            break;
        case SratMemory:

            //
            // Save the proximity and the base page for this range.
            //

            HalpNumaMemoryNode[MemoryDescriptorCount] =
                SratEntry->ProximityDomain;
            Base = SratEntry->MemoryAffinity.Base;
            Base.QuadPart >>= PAGE_SHIFT;
            ASSERT(Base.u.HighPart == 0);

            // N.B. This does NOT work for 64 bit systems, those systems
            // should keep both halves of the base address.

            HalpNumaMemoryRanges[MemoryDescriptorCount] = Base.u.LowPart;
            MemoryDescriptorCount++;
            break;
        }
    }

    HalpNumaConfig->ProcessorCount = ProcessorCount;

    //
    // Make sure processor 0 is always in 'logical' node 0.  This
    // is achieved by making sure the proximity Id for the first
    // processor is always the first proximity Id in the table.
    //

    i = 0;
    if (!NT_SUCCESS(HalpGetApicIdByProcessorNumber(0, (PUSHORT)&i))) {

        //
        // Couldn't find the ApicId of processor 0?  Not quite
        // sure what to do, I suspect the MP table's APIC IDs
        // don't match the SRAT's.
        //

        DbgPrint("HAL No APIC ID for boot processor.\n");
    }

    for (j = 0; j < ProcessorCount; j++) {
        if (HalpNumaConfig->ProcessorApicId[j] == (USHORT)i) {
            UCHAR Proximity = HalpNumaConfig->ProcessorProximity[j];
            for (i = 0; i < HalpNumaConfig->NodeCount; i++) {
                if (HalpNumaConfig->ProximityId[i] == Proximity) {
                    HalpNumaConfig->ProximityId[i] =
                        HalpNumaConfig->ProximityId[0];
                    HalpNumaConfig->ProximityId[0] = Proximity;
                    break;
                }
            }
            break;
        }
    }

    //
    // Sort the memory ranges.   There shouldn't be very many
    // so a bubble sort should suffice.
    //

    j = MemoryDescriptorCount - 1;
    do {
        Swapped = FALSE;
        for (i = 0; i < j; i++) {

            ULONG_PTR t;
            UCHAR td;

            t = HalpNumaMemoryRanges[i];
            if (t > HalpNumaMemoryRanges[i+1]) {
                Swapped = TRUE;
                HalpNumaMemoryRanges[i] = HalpNumaMemoryRanges[i+1];
                HalpNumaMemoryRanges[i+1] = t;

                //
                // Keep the proximity domain in sync with the base.
                //

                td = HalpNumaMemoryNode[i];
                HalpNumaMemoryNode[i] = HalpNumaMemoryNode[i+1];
                HalpNumaMemoryNode[i+1] = td;
            }
        }

        //
        // The highest value is now at the top so cut it from the sort.
        //

        j--;
    } while (Swapped == TRUE);

    //
    // When searching the memory descriptors to find out which domain
    // a page is in, we don't care about gaps, we'll never be asked
    // for a page in a gap, so, if two descriptors refer to the same
    // domain, merge them in place.
    //

    j = 0;
    for (i = 1; i < MemoryDescriptorCount; i++) {
        if (HalpNumaMemoryNode[j] !=
            HalpNumaMemoryNode[i]) {
            j++;
            HalpNumaMemoryNode[j] = HalpNumaMemoryNode[i];
            HalpNumaMemoryRanges[j] = HalpNumaMemoryRanges[i];
            continue;
        }
    }
    MemoryDescriptorCount = j + 1;

    //
    // The highest page number on an x86 (32 bit) system with PAE
    // making physical addresses 36 bits, is (1 << (36-12)) - 1, ie
    // 0x00ffffff.   Terminate the table with 0xffffffff which won't
    // actually correspond to any domain but will always be higher
    // than any valid value.
    //

    HalpNumaMemoryRanges[MemoryDescriptorCount] = 0xffffffff;

    //
    // And the base of the lowest range should be 0 even if there
    // are no pages that low.
    //

    HalpNumaMemoryRanges[0] = 0;

    //
    // Convert the proximity IDs in the memory node array to
    // node number.   Node number is the index of the matching
    // entry in proximity ID array.
    //

    for (i= 0; i < MemoryDescriptorCount; i++) {
        for (j = 0;  j < HalpNumaConfig->NodeCount; j++) {
            if (HalpNumaMemoryNode[i] == HalpNumaConfig->ProximityId[j]) {
                HalpNumaMemoryNode[i] = (UCHAR)j;
                break;
            }
        }
    }
}

#endif

NTSTATUS
HalpGetAcpiStaticNumaTopology(
    HAL_NUMA_TOPOLOGY_INTERFACE * NumaInfo
    )
{
#if !defined(NT_UP)

    //
    // This routine is never called unless this ACPI HAL found
    // a Static Resource Affinity Table (SRAT).  But just in case ...
    //

    if (HalpAcpiSrat == NULL) {
        return STATUS_INVALID_LEVEL;
    }

    //
    // Fill in the data structure for the kernel.
    //

    NumaInfo->NumberOfNodes = HalpNumaConfig->NodeCount;
    NumaInfo->QueryProcessorNode = HalpNumaQueryProcessorNode;
    NumaInfo->PageToNode = HalpNumaQueryPageToNode;
    return STATUS_SUCCESS;

#else

    return STATUS_INVALID_LEVEL;

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\xxflshbf.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\xxflshbf.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\xxhal.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\xxhal.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\xxstubs.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\xxstubs.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\xxmemory.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\xxmemory.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\xxtime.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\xxtime.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\amd64\8259.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    8259.h

Abstract:

    This module contains a variety of constants, function prototypes,
    inline functions and external data declarations used by code to
    access the 8259 PIC.

Author:

    Forrest Foltz (forrestf) 24-Oct-2000

--*/

#ifndef _8259_H_
#define _8259_H_

//
// Initialization control words for the PICs
//

#define ICW1_ICW4_NEEDED                    0x01
#define ICW1_CASCADE                        0x00
#define ICW1_INTERVAL8                      0x00
#define ICW1_LEVEL_TRIG                     0x08
#define ICW1_EDGE_TRIG                      0x00
#define ICW1_ICW                            0x10

#define ICW4_8086_MODE                      0x01
#define ICW4_AUTO_EOI                       0x02
#define ICW4_NORM_EOI                       0x00
#define ICW4_NON_BUF_MODE                   0x00
#define ICW4_SPEC_FULLY_NESTED              0x10
#define ICW4_NOT_SPEC_FULLY_NESTED          0x00

#define PIC1_EOI_MASK   0x60
#if defined(NEC_98)
#define PIC2_EOI        0x67
#else
#define PIC2_EOI        0x62
#endif

#define OCW2_NON_SPECIFIC_EOI   0x20
#define OCW2_SPECIFIC_EOI       0x60
#define OCW3_READ_ISR           0x0B
#define OCW3_READ_IRR           0x0A

#define PIC1_BASE               0x30
#define PIC2_BASE               0x38


#if defined(PIC1_PORT0)

C_ASSERT(PIC1_PORT0 == 0x20);
C_ASSERT(PIC1_PORT1 == 0x21);
C_ASSERT(PIC2_PORT0 == 0xA0);
C_ASSERT(PIC2_PORT1 == 0xA1);

#undef PIC1_PORT0
#undef PIC1_PORT1
#undef PIC2_PORT0
#undef PIC2_PORT1

#endif

#define PIC1_PORT0 (PUCHAR)0x20
#define PIC1_PORT1 (PUCHAR)0x21
#define PIC2_PORT0 (PUCHAR)0xA0
#define PIC2_PORT1 (PUCHAR)0xA1

#if defined(EISA_EDGE_LEVEL0)

C_ASSERT(EISA_EDGE_LEVEL0 == 0x4D0);
C_ASSERT(EISA_EDGE_LEVEL1 == 0x4D1);

#undef EISA_EDGE_LEVEL0
#undef EISA_EDGE_LEVEL1

#endif

#define EISA_EDGE_LEVEL0 (PUCHAR)0x4D0
#define EISA_EDGE_LEVEL1 (PUCHAR)0x4D1

__inline
VOID
SET_8259_MASK (
    IN USHORT Mask
    )
{
    WRITE_PORT_USHORT_PAIR (PIC1_PORT1,PIC2_PORT1,Mask);
    IO_DELAY();
}

__inline
USHORT
GET_8259_MASK (
    VOID
    )
{
    USHORT mask;

    mask = READ_PORT_USHORT_PAIR (PIC1_PORT1,PIC2_PORT1);
    IO_DELAY();

    return mask;
}

__inline
VOID
PIC1DELAY(
    VOID
    )
{
    READ_PORT_UCHAR(PIC1_PORT0);
    IO_DELAY();
}   

__inline
VOID
PIC2DELAY(
    VOID
    )
{
    READ_PORT_UCHAR(PIC2_PORT0);
    IO_DELAY();
}

#endif  // _8259_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\xxtimer.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    xxtimer.h

Abstract:

    This module contains definitions used by the HAL's timer-related 
    functions

Author:

    Eric Nelson (enelson) July 7, 2000

Revision History:

--*/

#ifndef __XXTIMER_H__
#define __XXTIMER_H__

typedef
ULONG
(*PSTE_ROUTINE)( // (S)et (T)ime (I)ncrement
    IN ULONG DesiredIncrement
    );

typedef
VOID
(*PSEP_ROUTINE)( // (S)tall (E)xecution (P)rocessor
    IN ULONG Microseconds
    );

typedef
VOID
(*PCPC_ROUTINE)( // (C)alibrate (P)erformance (C)ounter
    IN LONG volatile *Number,
    IN ULONGLONG NewCount
    );

typedef
LARGE_INTEGER
(*PQPC_ROUTINE)( // (Q)uery (P)erformance (C)ounter
   OUT PLARGE_INTEGER PerformanceFrequency OPTIONAL
   );

typedef struct _TIMER_FUNCTIONS {
    PSEP_ROUTINE StallExecProc;
    PCPC_ROUTINE CalibratePerfCount;
    PQPC_ROUTINE QueryPerfCount;
    PSTE_ROUTINE SetTimeIncrement;
} TIMER_FUNCTIONS, *PTIMER_FUNCTIONS;

VOID
HalpSetTimerFunctions(
    IN PTIMER_FUNCTIONS TimerFunctions
    );

#endif // __XXTIMER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\amd64\fakeacpi.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    fakeacpi.c

Abstract:

    Temporary support for Acpi tables in SIMICS simulator environment. This
    file should be removed when SIMICS provides Acpi tables.

Author:

    Forrest Foltz (forrestf) 04-02-2001

Environment:

    Kernel mode only.

Revision History:

--*/

#if defined(_AMD64_SIMULATOR_)

#include "halcmn.h"

typedef struct _FAKE_ACPI_PORT_DESC {
    ACPI_REG_TYPE AcpiReg;
    USHORT PortSize;
    USHORT BlockSize;
    BOOLEAN Mask;
    ULONG  Data;
    PUCHAR IoPortName;
} FAKE_ACPI_PORT_DESC, *PFAKE_ACPI_PORT_DESC;

#define FPE(p,r,s,b,d) { p, r, s, b, d, #p }

FAKE_ACPI_PORT_DESC HalpFakePortDescriptions[] = {
    FPE( PM1a_ENABLE,   2,  2, FALSE,  1 ),
    FPE( PM1b_ENABLE,   2,  2, FALSE,  0 ),
    FPE( PM1a_STATUS,   2,  2, TRUE,   0 ),
    FPE( PM1b_STATUS,   2,  2, TRUE,   0 ),
    FPE( PM1a_CONTROL,  2,  2, FALSE,  0 ),
    FPE( PM1b_CONTROL,  2,  2, FALSE,  0 ),
    FPE( GP_STATUS,     1,  2, TRUE,   0 ),
    FPE( GP_ENABLE,     1,  2, FALSE,  0 ),
    FPE( SMI_CMD,       1,  1, FALSE,  0 )
};

#if DBG
BOOLEAN HalpDebugFakeAcpi = FALSE;
#else
#define HalpDebugFakeAcpi FALSE
#endif


PFAKE_ACPI_PORT_DESC
HalpFindFakeAcpiPortDesc (
    ACPI_REG_TYPE AcpiReg
    )
/*++

Routine Description:

    Locates the FAKE_ACPI_PORT_DESC structure appropriate to the
    supplied AcpiReg.

Arguments:

    AcpiReg - Specifies which ACPI fixed register to find the structure  for.

Return Value:

    Returns a pointer to the appropriate FAKE_ACPI_PORT_DESC structure if
    it was found, or NULL otherwise.

--*/
{
    ULONG i;
    PFAKE_ACPI_PORT_DESC portDesc;

    for (i = 0; i < RTL_NUMBER_OF(HalpFakePortDescriptions); i += 1) {
        portDesc = &HalpFakePortDescriptions[i];
        if (portDesc->AcpiReg == AcpiReg) {
            return portDesc;
        }
    }

    DbgPrint("AMD64: Need to emulate ACPI I/O port 0x%x\n",AcpiReg);

    return NULL;
}


USHORT
HalpReadAcpiRegister (
    IN ACPI_REG_TYPE AcpiReg,
    IN ULONG Register
    )
/*++

Routine Description:

    Read from the specified ACPI fixed register.

Arguments:

    AcpiReg - Specifies which ACPI fixed register to read from.

    Register - Specifies which GP register to read from. Not used for PM1x
               registers.

Return Value:

    Value of the specified ACPI fixed register.

--*/
{
    PFAKE_ACPI_PORT_DESC portDesc;
    PUCHAR source;
    USHORT retVal;

    portDesc = HalpFindFakeAcpiPortDesc(AcpiReg);
    if (portDesc == NULL) {
        return 0xffff;
    }

    ASSERT((Register + portDesc->PortSize) <= portDesc->BlockSize);

    source = (PUCHAR)&portDesc->Data + Register;
    retVal = 0;

    RtlCopyMemory((PUCHAR)&retVal, source, portDesc->PortSize);

    if (HalpDebugFakeAcpi != FALSE) {
        DbgPrint("HalpReadAcpiRegister(%s,0x%x) returns 0x%x\n",
                 portDesc->IoPortName,
                 Register,
                 retVal);
    }
    
    return retVal;
}


VOID
HalpWriteAcpiRegister (
    IN ACPI_REG_TYPE AcpiReg,
    IN ULONG Register,
    IN USHORT Value
    )
/*++

Routine Description:

    Write to the specified ACPI fixed register.

Arguments:

    AcpiReg - Specifies which ACPI fixed register to write to.

    Register - Specifies which GP register to write to. Not used for PM1x
               registers.

    Value - Data to write.

Return Value:

    None.

--*/
{
    PFAKE_ACPI_PORT_DESC portDesc;
    PUCHAR source;
    PUCHAR destination;
    ULONG i;

    portDesc = HalpFindFakeAcpiPortDesc(AcpiReg);
    if (portDesc == NULL) {
        return;
    }

    ASSERT((Register + portDesc->PortSize) <= portDesc->BlockSize);

    source = (PUCHAR)&Value;
    destination = (PUCHAR)&portDesc->Data + Register;

    if (HalpDebugFakeAcpi != FALSE) {
        DbgPrint("HalpWriteAcpiRegister(%s,0x%x) with value 0x%x\n",
                 portDesc->IoPortName,
                 Register,
                 Value);
    }

    for (i = 0; i < portDesc->PortSize; i++) {

        if (portDesc->Mask != FALSE) {
            *destination &= ~(*source);
        } else {
            *destination = *source;
        }

        source += 1;
        destination += 1;
    }

    if (AcpiReg == SMI_CMD && Register == 0) {

        //
        // Assume that we have just turned ACPI on.
        //

        HalpFindFakeAcpiPortDesc(PM1a_CONTROL)->Data |= 1;
    }
}

#endif  // _AMD64_SIMULATOR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\xxtimer.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    xxtimer.c

Abstract:

    This module contains the HAL's timer-related APIs

Author:

    Eric Nelson (enelson) July 6, 2000

Revision History:

--*/

#include "halp.h"
#include "xxtimer.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, HalpSetTimerFunctions)
#endif

//
// External function prototypes
//
ULONG
HalpAcpiTimerSetTimeIncrement(
    IN ULONG DesiredIncrement
    );

VOID
HalpAcpiTimerStallExecProc(
    IN ULONG MicroSeconds
    );

VOID
HalpAcpiTimerCalibratePerfCount(
    IN LONG volatile *Number,
    IN ULONGLONG NewCount
    );
VOID
HalpPmTimerCalibratePerfCount(
    IN LONG volatile *Number,
    IN ULONGLONG NewCount
    );

LARGE_INTEGER
HalpAcpiTimerQueryPerfCount(
   OUT PLARGE_INTEGER PerformanceFrequency OPTIONAL
   );

LARGE_INTEGER
HalpPmTimerQueryPerfCount(
   OUT PLARGE_INTEGER PerformanceFrequency OPTIONAL
   );

//
// Local variables
//
static TIMER_FUNCTIONS HalpTimerFunctions = { HalpAcpiTimerStallExecProc,
#ifdef NO_PM_KEQPC
                                              HalpAcpiTimerCalibratePerfCount,
                                              HalpAcpiTimerQueryPerfCount,
#else
                                              HalpPmTimerCalibratePerfCount,
                                              HalpPmTimerQueryPerfCount,
#endif
                                              HalpAcpiTimerSetTimeIncrement };


VOID
HalpSetTimerFunctions(
    IN PTIMER_FUNCTIONS TimerFunctions
    )
/*++

Routine Description:

    This routine can be used to override the HALs ACPI-timer functions with
    multimedia event timer functions

Arguments:

    TimerFunctions - Pointer to a table of timer functions

Return Value:

    None

--*/
{
    HalpTimerFunctions = *TimerFunctions;

#if 1
    HalpTimerFunctions.SetTimeIncrement = HalpAcpiTimerSetTimeIncrement;
#endif
}


ULONG
HalSetTimeIncrement(
    IN ULONG DesiredIncrement
    )
/*++

Routine Description:

    This routine initialize system time clock to generate an
    interrupt at every DesiredIncrement interval

Arguments:

     DesiredIncrement - Desired interval between every timer tick (in
                        100ns unit)

Return Value:

     The *REAL* time increment set

--*/
{
    return (HalpTimerFunctions.SetTimeIncrement)(DesiredIncrement);
}


VOID
HalCalibratePerformanceCounter(
    IN LONG volatile *Number,
    IN ULONGLONG NewCount
    )
/*++

Routine Description:

    This routine resets the performance counter value for the current
    processor to zero, the reset is done such that the resulting value
    is closely synchronized with other processors in the configuration

Arguments:

    Number - Supplies a pointer to count of the number of processors in
             the configuration

    NewCount - Supplies the value to synchronize the counter too

Return Value:

    None

--*/
{
    (HalpTimerFunctions.CalibratePerfCount)(Number, NewCount);
}


LARGE_INTEGER
KeQueryPerformanceCounter(
   OUT PLARGE_INTEGER PerformanceFrequency OPTIONAL
   )
/*++

Routine Description:

    This routine returns current 64-bit performance counter and,
    optionally, the Performance Frequency

    N.B. The performace counter returned by this routine is
    not necessary the value when this routine is just entered,
    The value returned is actually the counter value at any point
    between the routine is entered and is exited

Arguments:

    PerformanceFrequency - optionally, supplies the address of a
                           variable to receive the performance counter
                           frequency

Return Value:

    Current value of the performance counter will be returned

--*/
{
    return (HalpTimerFunctions.QueryPerfCount)(PerformanceFrequency);
}


VOID
KeStallExecutionProcessor(
   IN ULONG MicroSeconds
   )
/*++

Routine Description:

    This function stalls execution for the specified number of microseconds

Arguments:

    MicroSeconds - Supplies the number of microseconds that execution is to be
                   stalled

 Return Value:

    None

--*/
{
    (HalpTimerFunctions.StallExecProc)(MicroSeconds);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\amd64\halcmn.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    halcmn.h

Abstract:

    This module contains a variety of constants, function prototypes,
    inline functions and external data declarations used by the AMD64
    hal code.

Author:

    Forrest Foltz (forrestf) 24-Oct-2000

--*/

#ifndef _HALCMN_H_
#define _HALCMN_H_

#include <halp.h>
#include <apic.inc>
#include <ntapic.inc>
#include <ntacpi.h>
#include "io_cmos.h"
#include "8259.h"
#include "mp8254.inc"

typedef VOID (*PHALP_SOFTWARE_INTERRUPT)(VOID);

extern PHALP_SOFTWARE_INTERRUPT HalpSoftwareInterruptTable[];
extern KIRQL SWInterruptLookupTable[];
extern USHORT Halp8259MaskTable[];
extern LARGE_INTEGER (*QueryTimer)(VOID);
extern KAFFINITY HalpDefaultInterruptAffinity;
extern KAFFINITY HalpActiveProcessors;
extern ULONG HalpTimerWatchdogEnabled;

//
// Number of 100nS units in one second
//

#define TIME_UNITS_PER_SECOND 10000000


#if defined(DBG)
#define AMD64_IMPLEMENT DbgPrint("AMD64: Not implemented\n"); DbgBreakPoint()
#else
#define AMD64_IMPLEMENT
#endif

#if !defined(RTL_FIELD_SIZE)
#define RTL_FIELD_SIZE(type, field) (sizeof(((type *)0)->field))
#endif

VOID
HalpAcquireSystemHardwareSpinLock(
    VOID
    );

VOID
HalpReleaseSystemHardwareSpinLock(
    VOID
    );

__forceinline
VOID
KPcrReadData (
    IN ULONG Offset,
    IN ULONG Length,
    OUT PVOID Buffer
    )

/*++

Routine Description:

    Used to read data from the current processor's KPCR.  This is a support
    function for KPCR_READ_FIELD

Arguments:

    Offset - Supplies the offset within the KPCR to begin the read

    Length - Supplies the length of the data to read from the KPCR.  Must
             be one of 1, 2, 4 or 8.

    Buffer - Supplies the target buffer that contains the data to read from
             the KPCR.

Return value:

    None

--*/

{
    switch (Length) {
        case 1:
            *(PUCHAR)Buffer = __readgsbyte(Offset);
            break;

        case 2:
            *(PUSHORT)Buffer = __readgsword(Offset);
            break;

        case 4:
            *(PULONG)Buffer = __readgsdword(Offset);
            break;

        case 8:
            *(PULONG64)Buffer = __readgsqword(Offset);
            break;
    }
}

__forceinline
VOID
KPcrWriteData (
    IN ULONG Offset,
    IN ULONG Length,
    IN PVOID Buffer
    )

/*++

Routine Description:

    Used to write data to the current processor's KPCR.  This is a support
    function for KPCR_WRITE_FIELD

Arguments:

    Offset - Supplies the offset within the KPCR to begin the write

    Length - Supplies the length of the data to write within the KPCR.  Must
             be one of 1, 2, 4 or 8

    Buffer - Supplies the source buffer that contains the data to write into
             the KPCR.

Return value:

    None

--*/

{
    switch (Length) {
        case 1:
            __writegsbyte(Offset,*(PUCHAR)Buffer);
            break;

        case 2:
            __writegsword(Offset,*(PUSHORT)Buffer);
            break;

        case 4:
            __writegsdword(Offset,*(PULONG)Buffer);
            break;

        case 8:
            __writegsqword(Offset,*(PULONG64)Buffer);
            break;
    }
}


#define KPCR_READ_FIELD(field,value)                        \
    KPcrReadData(FIELD_OFFSET(KPCR,field),                  \
                 RTL_FIELD_SIZE(KPCR,field),                \
                 value);

#define KPCR_WRITE_FIELD(field,value)                       \
    KPcrWriteData(FIELD_OFFSET(KPCR,field),                 \
                  RTL_FIELD_SIZE(KPCR,field),               \
                  value);

NTSTATUS
HalpConnectInterrupt (
    IN ULONG SystemInterruptVector,
    IN KIRQL SystemIrql,
    IN PHAL_INTERRUPT_SERVICE_ROUTINE HalInterruptServiceRoutine,
    IN KINTERRUPT_MODE InterruptMode
    );

BOOLEAN
PicSpuriousService37 (
    IN struct _KINTERRUPT *Interrupt,
    IN PVOID ServiceContext
);

BOOLEAN
HalpApicSpuriousService (
    IN struct _KINTERRUPT *Interrupt,
    IN PVOID ServiceContext
);

#endif  // _HALCMN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\amd64\asmstub.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    asmstub.c

Abstract:

    This temporary module simply provides stub implementations of routines
    that are found in hal .asm files or for routines that are ultimately
    expected to be imported from the kernel.

    It exists only as a test file, and will no longer be necessary when
    an AMD64 compiler, linker etc. are available.

--*/


#include "halcmn.h"

//
// Things in the hal in .asm files
// 

VOID HalProcessorIdle(VOID) { }

ULONG
HalpGetProcessorFlags(VOID) {
    return 0;
}

VOID
HalpGenerateAPCInterrupt(VOID) {}

VOID
HalpGenerateDPCInterrupt(VOID) {}

VOID
HalpGenerateUnexpectedInterrupt(VOID) {}

VOID
HalpIoDelay(VOID) {}

ULONG
HalpSetCr4Bits(ULONG BitMask){ return 0; }

VOID
HalpSerialize(VOID) {}

VOID
StartPx_PMStub(VOID) {}

VOID
HalpHalt (
    VOID
    )
{
}

//
// Things that will ultimately end up in the kernel
//

BOOLEAN
KiIpiServiceRoutine (
    IN struct _KTRAP_FRAME *TrapFrame,
    IN struct _KEXCEPTION_FRAME *ExceptionFrame
    )
{
    return FALSE;
}

ULONG __imp_KeSetProfileIrql;



//
// Things that will be compiler intrinsics
//

UCHAR
__readgsbyte (
    IN ULONG Offset
    )
{
    return 0;
}

USHORT
__readgsword (
    IN ULONG Offset
    )
{
    return 0;
}

ULONG
__readgsdword (
    IN ULONG Offset
    )
{
    return 0;
}

ULONG64
__readgsqword (
    IN ULONG Offset
    )
{
    return 0;
}

ULONG64
__rdtsc (
    VOID
    )
{
    return 0;
}

VOID
__writegsbyte (
    IN ULONG Offset,
    IN UCHAR Data
    )
{

}

VOID
__writegsword (
    IN ULONG Offset,
    IN USHORT Data
    )
{

}

VOID
__writegsdword (
    IN ULONG Offset,
    IN ULONG Data
    )
{

}

VOID
__writegsqword (
    IN ULONG Offset,
    IN ULONG64 Data
    )
{

}

BOOLEAN
KeTryToAcquireSpinLockAtDpcLevel (
    IN PKSPIN_LOCK SpinLock
    )
{
    return FALSE;
}

BOOLEAN
KeTestSpinLock (
    IN PKSPIN_LOCK SpinLock
    )
{
    return FALSE;
}

ULONG64
__readcr3 (
    VOID
    )
{ return 0; }

VOID
__writecr3 (
    ULONG64 Val
    )
{}

ULONG64
__readcr4 (
    VOID
    )
{ return 0; }

VOID
__writecr4 (
    ULONG64 Val
    )
{}

ULONG64
__readcr8 (
    VOID
    )
{ return 0; }

VOID
__writecr8 (
    IN ULONG64 Data
    )
{}

LONG64
InterlockedOr64 (
    IN OUT LONG64 *Destination,
    IN LONG64 Value
    )
{
    return 0;
}

LONG64
InterlockedAnd64 (
    IN OUT LONG64 volatile *Destination,
    IN LONG64 Value
    )
{
    return 0;
}

LONG
InterlockedAnd (
    IN OUT LONG volatile *Destination,
    IN LONG Value
    )
{
    return 0;
}


LONG
InterlockedOr (
    IN OUT LONG *Destination,
    IN LONG Value
    )
{
    return 0;
}


VOID
__wrmsr (
    IN ULONG Msr,
    IN ULONG64 Value
    )
{
}

ULONG64
__rdmsr (
    IN ULONG Msr
    )
{
    return 0;
}

VOID
__wbinvd (
    VOID
    )
{
}

VOID
KiCpuId (
    IN ULONG Function,
    OUT PCPU_INFO CpuInfo
    )
{
}

UCHAR
__inbyte (
    IN USHORT Port
    )
{ return 0; }

USHORT
__inword (
    IN USHORT Port
    )
{ return 0; }

ULONG
__indword (
    IN USHORT Port
    )
{ return 0; }

VOID
__outbyte (
    IN USHORT Port,
    IN UCHAR Data
    )
{}

VOID
__outword (
    IN USHORT Port,
    IN USHORT Data
    )
{}

VOID
__outdword (
    IN USHORT Port,
    IN ULONG Data
    )
{}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\amd64\interrupt.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    interrupt.c

Abstract:

    HAL routines required to support generic interrupt processing.

Author:

    Forrest Foltz (forrestf) 23-Oct-2000

Revision History:

--*/

#include "halcmn.h"

typedef struct _HAL_INTERRUPT_OBJECT *PHAL_INTERRUPT_OBJECT;
typedef struct _HAL_INTERRUPT_OBJECT {
    PHAL_INTERRUPT_OBJECT Next;
    KSPIN_LOCK SpinLock;
    KINTERRUPT InterruptArray[];
} HAL_INTERRUPT_OBJECT;

//
// Global list of hal interrupt objects
// 

PHAL_INTERRUPT_OBJECT HalpInterruptObjectList = NULL;

//
// Statically allocated heap of KINTERRUPT objects for use during
// initialization of processor 0.
//

#define HALP_INIT_STATIC_INTERRUPTS 16

KINTERRUPT
HalpKInterruptHeap[ HALP_INIT_STATIC_INTERRUPTS ];

ULONG HalpKInterruptHeapUsed = 0;

PKINTERRUPT
HalpAllocateKInterrupt (
    VOID
    )

/*++

Routine Description:

    This allocates a KINTERRUPT structure from HalpKInterruptHeap[].  If
    this array is exhausted then the allocation is satisfied with nonpaged
    pool.

    Several KINTERRUPT structures are required very early in system init
    (before pool is initialized).  HalpKInterruptHeap[] must be
    sufficiently large to accomodate these early structures.

Arguments:

    None.

Return Value:

    Returns a pointer to the KINTERRUPT structure if successful, or NULL
    if not.

--*/

{
    PKINTERRUPT interrupt;

    if (HalpKInterruptHeapUsed < HALP_INIT_STATIC_INTERRUPTS) {

        //
        // Allocate from our private heap of KINTERRUPT objects.  If
        // this is exhausted, then assume we are at an init stage post pool
        // init and allocate from regular heap.
        //

        interrupt = &HalpKInterruptHeap[HalpKInterruptHeapUsed];
        HalpKInterruptHeapUsed += 1;

    } else {

        //
        // The private KINTERRUPT heap has been exhausted.  Assume that
        // the system heap has been initialized.
        //

        interrupt = ExAllocatePoolWithTag(NonPagedPool,
                                          sizeof(KINTERRUPT),
                                          HAL_POOL_TAG);
    }

    return interrupt;
}


NTSTATUS
HalpEnableInterruptHandler (
    IN UCHAR ReportFlags,
    IN ULONG BusInterruptVector,
    IN ULONG SystemInterruptVector,
    IN KIRQL SystemIrql,
    IN PHAL_INTERRUPT_SERVICE_ROUTINE HalInterruptServiceRoutine,
    IN KINTERRUPT_MODE InterruptMode
    )

/*++

Routine Description:

    This function connects & registers an IDT vectors usage by the HAL.

Arguments:

    ReportFlags - Flags passed to HalpRegisterVector indicating how this
                  interrupt should be reported.

    BusInterruptVector - Supplies the interrupt vector from the bus's
                         perspective.

    SystemInterruptVector - Supplies the interrupt vector from the system's
                            perspective.

    SystemIrql - Supplies the IRQL associated with the vector.

    HalInterruptServiceRoutine - Supplies the interrupt handler for the
                                 interrupt.

    InterruptMode - Supplies the interupt mode.

Return Value:

    Returns the final status of the operation.

--*/

{
    ULONG size;
    ULONG processorCount;
    UCHAR processorNumber;
    KAFFINITY processorMask;
    PKINTERRUPT kernelInterrupt;
    PKSPIN_LOCK spinLock;
    NTSTATUS status;

#if !defined(ACPI_HAL)

    //
    // Remember which vector the hal is connecting so it can be reported
    // later on
    //
    // If this is an ACPI HAL, the vectors will be claimed by the BIOS.  This
    // is done for Win98 compatibility.
    //

    HalpRegisterVector (ReportFlags,
                        BusInterruptVector,
                        SystemInterruptVector,
                        SystemIrql);

#endif

    status = HalpConnectInterrupt (SystemInterruptVector,
                                   SystemIrql,
                                   HalInterruptServiceRoutine,
                                   InterruptMode);
    return status;
}

PKINTERRUPT
HalpCreateInterrupt (
    IN PKSERVICE_ROUTINE ServiceRoutine,
    IN ULONG Vector,
    IN KIRQL Irql,
    IN KINTERRUPT_MODE InterruptMode,
    IN UCHAR ProcessorNumber,
    IN UCHAR IstIndex OPTIONAL,
    IN PVOID IstStack OPTIONAL
    )

/*++

Routine Description:

    This function connects an IDT vector to a hal service routine.

Arguments:

    ServiceRoutine - Supplies the interrupt handler for the interrupt.

    Vector - Supplies the interrupt vector from the system's perspective.

    Irql - Supplies the IRQL associated with the interrupt.

    Interrupt Mode - Supplies the interrupt mode, Latched or LevelSensitive.

    ProcessorNumber - Supplies the processor number.  

    IstIndex - The Ist index of the stack that this interrupt must run on
               if other than the default (which is zero).  This is an
               optional parameter.

    IstStack - Supplies a pointer to the top of the stack to be used for this
               interrupt.  This is an optional parameter.

Return Value:

    Returns a pointer to the allocated interrupt object, or NULL in the
    event of failure.

--*/

{
    PKINTERRUPT interrupt;
    PKPCR pcr;
    PKIDTENTRY64 idt;
    PKTSS64 tss;
    BOOLEAN connected;

    //
    // Allocate and initialize the kernel interrupt.
    // 

    interrupt = HalpAllocateKInterrupt();
    if (interrupt == NULL) {

        KeBugCheckEx(HAL_MEMORY_ALLOCATION,
                     sizeof(KINTERRUPT),
                     3,
                     (ULONG_PTR)__FILE__,
                     __LINE__
                     );
    }

    KeInitializeInterrupt(interrupt,
                          ServiceRoutine,
                          NULL,             // ServiceContext
                          NULL,             // SpinLock
                          Vector,
                          Irql,             // Irql
                          Irql,             // SynchronizeIrql
                          InterruptMode,
                          FALSE,            // ShareVector
                          ProcessorNumber,
                          FALSE);           // FloatingSave

    if (IstIndex != 0) {

        pcr = KeGetPcr();
        idt = &pcr->IdtBase[Vector];

        //
        // Check that we're not overwriting an existing IST index and store
        // the index in the IDT.
        //

        ASSERT(idt->IstIndex == 0);
        idt->IstIndex = IstIndex;
        tss = pcr->TssBase;

        //
        // If a stack was supplied for this IstIndex then store it in the
        // TSS.
        // 

        if (ARGUMENT_PRESENT(IstStack)) {

            ASSERT(tss->Ist[IstIndex] == 0);
            tss->Ist[IstIndex] = (ULONG64)IstStack;

        } else {

            ASSERT(tss->Ist[IstIndex] != 0);
        }
    }

    KeSetIdtHandlerAddress(Vector, &interrupt->DispatchCode[0]);

    return interrupt;
}

VOID
HalpSetHandlerAddressToIDTIrql (
    IN ULONG Vector,
    IN PHAL_INTERRUPT_SERVICE_ROUTINE ServiceRoutine,
    IN PVOID Context,
    IN KIRQL Irql
    )
{
    PKINTERRUPT interrupt;
    KIRQL irql;

    if (Irql == 0) {
        irql = (KIRQL)(Vector / 16);
    } else {
        irql = (KIRQL)Irql;
    }

    interrupt = HalpCreateInterrupt(ServiceRoutine,
                                    Vector,
                                    irql,
                                    Latched,
                                    PROCESSOR_CURRENT,
                                    0,
                                    NULL);
}


NTSTATUS
HalpConnectInterrupt (
    IN ULONG SystemInterruptVector,
    IN KIRQL SystemIrql,
    IN PHAL_INTERRUPT_SERVICE_ROUTINE HalInterruptServiceRoutine,
    IN KINTERRUPT_MODE InterruptMode
    )

/*++

Routine Description:

    This function connects & registers an IDT vectors usage by the HAL.

Arguments:

    SystemInterruptVector - Supplies the interrupt vector from the system's
                            perspective.

    SystemIrql - Supplies the IRQL associated with the vector.

    HalInterruptServiceRoutine - Supplies the interrupt handler for the
                                 interrupt.

    InterruptMode - Supplies the interupt mode.

Return Value:

    Returns the final status of the operation.

--*/

{
    ULONG size;
    ULONG processorCount;
    UCHAR processorNumber;
    KAFFINITY processorMask;
    PHAL_INTERRUPT_OBJECT interruptObject;
    PKINTERRUPT kernelInterrupt;
    PKSPIN_LOCK spinLock;
    PHAL_INTERRUPT_OBJECT interruptObjectHead;
    PKSERVICE_ROUTINE interruptServiceRoutine;

    //
    // Count the number of processors in the system
    //

    processorCount = 0;
    processorMask = 1;

    processorMask = HalpActiveProcessors;
    while (processorMask != 0) {
        if ((processorMask & 1) != 0) {
            processorCount += 1;
        }
        processorMask >>= 1;
    }

    //
    // Allocate and initialize the hal interrupt object
    //

    size = FIELD_OFFSET(HAL_INTERRUPT_OBJECT,InterruptArray) +
           sizeof(KINTERRUPT) * processorCount;

    interruptObject = ExAllocatePoolWithTag(NonPagedPool,size,HAL_POOL_TAG);
    if (interruptObject == NULL) {
        return STATUS_NO_MEMORY;
    }

    spinLock = &interruptObject->SpinLock;
    KeInitializeSpinLock(spinLock);

    //
    // Initialize each of the kernel interrupt objects
    //

    kernelInterrupt = interruptObject->InterruptArray;

    for (processorNumber = 0, processorMask = HalpActiveProcessors;
         processorMask != 0;
         processorNumber += 1, processorMask >>= 1) {

        if ((processorMask & 1) == 0) {
            continue;
        }

        interruptServiceRoutine =
            (PKSERVICE_ROUTINE)(HalInterruptServiceRoutine);

        KeInitializeInterrupt(kernelInterrupt,
                              interruptServiceRoutine,
                              NULL,
                              spinLock,
                              SystemInterruptVector,
                              SystemIrql,
                              SystemIrql,
                              InterruptMode,
                              FALSE,
                              processorNumber,
                              FALSE);
        kernelInterrupt += 1;
    }

    //
    // Atomically insert the hal interrupt object in our global list
    // and return success.
    //

    do {

        interruptObject->Next = HalpInterruptObjectList;

    } while (interruptObject->Next !=
             InterlockedCompareExchangePointer(&HalpInterruptObjectList,
                                               interruptObject,
                                               interruptObject->Next)); 

    return STATUS_SUCCESS;
}


BOOLEAN
PicSpuriousService37 (
    IN struct _KINTERRUPT *Interrupt,
    IN PVOID ServiceContext
)
{
    return FALSE;
}

BOOLEAN
HalpApicSpuriousService (
    IN struct _KINTERRUPT *Interrupt,
    IN PVOID ServiceContext
)
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\amd64\irqlstub.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

Abstract:

    This exports irql-related routines to the kernel, to be used in
    a PIC-based AMD64 environment.

    At this time it appears that this environment will never be needed, in
    which case these routines and the associated export table entries.

Author:

    Forrest Foltz (forrestf) 27-Oct-2000

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halcmn.h"

KIRQL
HalGetCurrentIrql (
    VOID
    )
{
    DbgBreakPoint();
    return 0;
}

KIRQL
HalSwapIrql (
    KIRQL NewIrql
    )
{
    DbgBreakPoint();
    return NewIrql;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\amd64\amd64s.asm ===
TITLE  "AMD64 Support Routines"
;++
;
; Copyright (c) 2000 Microsoft Corporation
;
; Module Name:
;
;    miscs.asm
;
; Abstract:
;
;    This module implements various routines for the AMD64 that must be
;    written in assembler.
;
; Author:
;
;    Forrest Foltz (forrestf) 14-Oct-2000
;
; Environment:
;
;    Kernel mode only.
;
;--

include kxamd64.inc
include ksamd64.inc

        extern	HalpMcaExceptionHandler:proc

;++
;
; ULONG
; HalpGetprocessorFlags(
;    VOID
;    )
;
; Routine Description:
;
;   This function retrieves and returns the contents of the processor's
;   flag register.
;
; Arguments:
;
;   None.
;
; Return Value:
;
;   The contents of the processor's flag register.
;
;--

HdiFrame struct
        FlagsLow dd ?			; processor flags, low 
	FlagsHi  dd ?			; processor flags, high
HdiFrame ends

        NESTED_ENTRY HalpGetProcessorFlags, _TEXT$00

        push_eflags                     ; get processor flags

	END_PROLOGUE

        pop	rax
        ret                            

        NESTED_END HalpGetProcessorFlags, _TEXT$00

;++
;
; VOID
; HalProcessorIdle(
;       VOID
;       )
;
; Routine Description:
;
;   This function is called when the current processor is idle.
;
;   This function is called with interrupts disabled, and the processor
;   is idle until it receives an interrupt.  The does not need to return
;   until an interrupt is received by the current processor.
;
;   This is the lowest level of processor idle.  It occurs frequently,
;   and this function (alone) should not put the processor into a
;   power savings mode which requeres large amount of time to enter & exit.
;
; Return Value:
;
;--

	LEAF_ENTRY HalProcessorIdle, _TEXT$00

        ;
        ; the following code sequence "sti-halt" puts the processor
        ; into a Halted state, with interrupts enabled, without processing
        ; an interrupt before halting.   The STI instruction has a delay
        ; slot such that it does not take effect until after the instruction
        ; following it - this has the effect of HALTing without allowing
        ; a possible interrupt and then enabling interrupts while HALTed.
        ;
    
        ;
        ; On an MP hal we don't stop the processor, since that causes
        ; the SNOOP to slow down as well
        ;

        sti

ifdef NT_UP
        hlt
endif

        ;
        ; Now return to the system.  If there's still no work, then it
        ; will call us back to halt again.
        ;

	ret

	LEAF_END HalProcessorIdle, _TEXT$00

;++
;
; VOID
; HalpGenerateAPCInterrupt(
;    VOID
;    )
;
; Routine Description:
;
;   This function generates an APC software interrupt.
;
; Arguments:
;
;   None.
;
; Return Value:
;
;   None.
;
;--

        LEAF_ENTRY HalpGenerateAPCInterrupt, _TEXT$00

	int	1
	ret

        LEAF_END HalpGenerateAPCInterrupt, _TEXT$00

;++
;
; VOID
; HalpGenerateDPCInterrupt(
;    VOID
;    )
;
; Routine Description:
;
;   This function generates an DPC software interrupt.
;
; Arguments:
;
;   None.
;
; Return Value:
;
;   None.
;
;--

        LEAF_ENTRY HalpGenerateDPCInterrupt, _TEXT$00

	int	2
	ret

        LEAF_END HalpGenerateDPCInterrupt, _TEXT$00

;++
;
; VOID
; HalpGenerateUnexpectedInterrupt(
;    VOID
;    )
;
; Routine Description:
;
;   This function generates an unexpected software interrupt.
;
; Arguments:
;
;   None.
;
; Return Value:
;
;   None.
;
;--

        LEAF_ENTRY HalpGenerateUnexpectedInterrupt, _TEXT$00

	int	0
	ret

        LEAF_END HalpGenerateUnexpectedInterrupt, _TEXT$00

;++
;
; VOID
; HalpHalt (
;     VOID
;     );
;
; Routine Description:
;
;     Executes a hlt instruction.  Should the hlt instruction execute,
;     control is returned to the caller.
;
; Arguments:
;
;     None.
;
; Return Value:
;
;     None.
;
;--*/

	LEAF_ENTRY HalpHalt, _TEXT$0

	hlt
	ret

	LEAF_END HalpHalt, _TEXT$0

;++
;
; VOID
; HalpIoDelay (
;     VOID
;     );
;
; Routine Description:
;
;     Generate a delay after port I/O.
;
; Arguments:
;
;     None.
;
; Return Value:
;
;     None.
;
;--

	LEAF_ENTRY HalpIoDelay, _TEXT$00

	jmp	$+2
	jmp	$+2
	ret

	LEAF_END HalpIoDelay, _TEXT$00


;++
;
; VOID
; HalpSerialize (
;     VOID
; )
;
; Routine Description:
;
;     This function implements the fence operation for out-of-order execution
;
; Arguments:
;
;     None
;
; Return Value:
;
;     None
;
;--

HsFrame struct
	SavedRbx    dq ?		; preserve RBX
HsFrame ends

	NESTED_ENTRY HalpSerialize, _TEXT$00

	push_reg rbx

	END_PROLOGUE

	cpuid
	pop 	rbx
	ret

	NESTED_END HalpSerialize, _TEXT$00


;++
;
; StartPx_LMStub
;
; This routine is entered during startup of a secondary processor.  We
; have just left StartPx_PMStub (xmstub.asm) and are running on an
; identity-mapped address space.
;
; Arguments:
;
;   rdi -> idenity-mapped address of PROCESSOR_START_BLOCK
;
; Return Value:
;
;   None
;
;--

	LEAF_ENTRY HalpLMStub, _TEXT$00

	;
	; Get the final CR3 value, set rdi to the self-map address of
	; the processor start block, and set CR3.  We are now executing
	; in image-loaded code, rather than code that has been copied to
	; low memory.
	;

	mov	rax, [rdi] + PsbProcessorState + PsCr3
	mov	rdi, [rdi] + PsbSelfMap
	mov	cr3, rax

	lea	rsi, [rdi] + PsbProcessorState
	ltr	WORD PTR [rsi] + SrTr

	;
	; Load this processor's GDT and IDT.  Because PSB_GDDT32_CODE64 is
	; identical to KGDT64_R0_CODE (asserted in mpsproca.c), no far jump
	; is necessary to load a new CS.
	;

	lgdt	fword ptr [rsi] + PsSpecialRegisters + SrGdtr
	lidt	fword ptr [rsi] + PsSpecialRegisters + SrIdtr

	;
	; Set rdx to point to the context frame and load the segment
	; registers.
	; 

	lea	rdx, [rdi] + PsbProcessorState + PsContextFrame
	mov	es, [rdx] + CxSegES
	mov	fs, [rdx] + CxSegFS
	mov	gs, [rdx] + CxSegGS
	mov	ss, [rdx] + CxSegSS

	;
	; Load the debug registers
	;

	cld
	xor	rax, rax
	mov	dr7, rax

	add	esi, SrKernelDr0

	.errnz  (SrKernelDr1 - SrKernelDr0 - 1 * 8)
	.errnz  (SrKernelDr2 - SrKernelDr0 - 2 * 8)
	.errnz  (SrKernelDr3 - SrKernelDr0 - 3 * 8)
	.errnz  (SrKernelDr6 - SrKernelDr0 - 4 * 8)
	.errnz  (SrKernelDr7 - SrKernelDr0 - 5 * 8)

	lodsq
	mov	dr0, rax

	lodsq
	mov	dr1, rax

	lodsq
	mov	dr2, rax

	lodsq
	mov	dr3, rax

	lodsq
	mov	dr6, rax

	lodsq
	mov	dr7, rax

	;
	; Load the stack pointer, eflags and store the new IP in
	; a return frame.  Also push two registers that will be used
	; to the very end.
	; 

	mov	rsp, [rdx] + CxRsp

	pushq	[rdx] + CxEflags
	popfq

	pushq	[rdx] + CxRip
	push	rdx
	push	rdi

	mov	rax, [rdx] + CxRax
	mov	rbx, [rdx] + CxRbx
	mov	rcx, [rdx] + CxRcx
	mov	rsi, [rdx] + CxRsi
	mov	rbp, [rdx] + CxRbp
	mov	r8,  [rdx] + CxR8
	mov	r9,  [rdx] + CxR9
	mov	r10, [rdx] + CxR10
	mov	r11, [rdx] + CxR11
	mov	r12, [rdx] + CxR12
	mov	r13, [rdx] + CxR13
	mov	r14, [rdx] + CxR14
	mov	r15, [rdx] + CxR15

	;
	; Indicate that we've started, pop the remaining two registers and
	; return.
	;

	inc	DWORD PTR [rdi] + PsbCompletionFlag

	pop 	rdi
	pop	rsi
	ret

	LEAF_END HalpLMStub, _TEXT$00

	END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\amd64\io_cmos.h ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    io_cmos.h

Abstract:

    This module contains a variety of constants, function prototypes,
    inline functions and external data declarations used by code to
    access the CMOS/ECMOS and well-known, standard I/O ports.

Author:

    Forrest Foltz (forrestf) 24-Oct-2000

--*/

#ifndef _IO_CMOS_H_
#define _IO_CMOS_H_

//
// Constants used to initialize timer 0
//

#if defined(NEC_98)

#define TIMER_CONTROL_PORT    (PUCHAR)0x3fdf
#define TIMER_DATA_PORT       (PUCHAR)0x3fdb
#define TIMER_CLOCK_IN             0x2457600
#define TIMER_CONTROL_SELECT            0x76
#define SPEAKER_CONTROL_PORT    (PUCHAR)0x61
#define SPEAKER_OFF                     0x07
#define SPEAKER_ON                      0x06

#else

#define TIMER1_DATA_PORT0    (PUCHAR)0x40 // Timer1, channel 0 data port
#define TIMER1_DATA_PORT1    (PUCHAR)0x41 // Timer1, channel 1 data port
#define TIMER1_DATA_PORT2    (PUCHAR)0x42 // Timer1, channel 2 data port
#define TIMER1_CONTROL_PORT  (PUCHAR)0x43 // Timer1 control port

#define TIMER2_DATA_PORT0    (PUCHAR)0x48 // Timer2, channel 0 data port
#define TIMER2_CONTROL_PORT  (PUCHAR)0x4B // Timer2 control port

#define TIMER_COMMAND_COUNTER0       0x00 // Select channel 0
#define TIMER_COMMAND_COUNTER1       0x40 // Select channel 1
#define TIMER_COMMAND_COUNTER2       0x80 // Select channel 2

#define TIMER_COMMAND_RW_16BIT       0x30 // Read/Write LSB firt then MSB
#define TIMER_COMMAND_MODE2             4 // Use mode 2
#define TIMER_COMMAND_MODE3             6
#define TIMER_COMMAND_BCD               0 // Binary count down
#define TIMER_COMMAND_LATCH_READ        0 // Latch read command

#define TIMER_CLOCK_IN            1193167

#define SPEAKER_CONTROL_PORT  (PCHAR)0x61
#define SPEAKER_OFF_MASK             0xFC  
#define SPEAKER_ON_MASK              0x03

#endif

//
// CMOS ports
//

#define CMOS_ADDRESS_PORT        (PCHAR)0x70
#define CMOS_DATA_PORT           (PCHAR)0x71
#define ECMOS_ADDRESS_PORT_LSB   (PCHAR)0x74
#define ECMOS_ADDRESS_PORT_MSB   (PCHAR)0x75
#define ECMOS_DATA_PORT          (PCHAR)0x76

#define CMOS_STATUS_A                   0x0A
#define CMOS_STATUS_B                   0x0B
#define CMOS_STATUS_C                   0x0C
#define CMOS_STATUS_D                   0x0D
#define CMOS_STATUS_BUSY                0x80
#define CMOS_STATUS_BANK1               0x10
#define CMOS_BANK_1                    0x100
#define RTC_OFFSET_SECOND                  0
#define RTC_OFFSET_SECOND_ALARM            1
#define RTC_OFFSET_MINUTE                  2
#define RTC_OFFSET_MINUTE_ALARM            3
#define RTC_OFFSET_HOUR                    4
#define RTC_OFFSET_HOUR_ALARM              5
#define RTC_OFFSET_DAY_OF_WEEK             6
#define RTC_OFFSET_DATE_OF_MONTH           7    
#define RTC_OFFSET_MONTH                   8     
#define RTC_OFFSET_YEAR                    9      
#define RTC_OFFSET_CENTURY_MCA          0x37       
#define RTC_OFFSET_CENTURY              0x32        
#define RTC_OFFSET_CENTURY_DS          0x148

#define REGISTER_B_DAYLIGHT_SAVINGS_TIME        (1 << 0)
#define REGISTER_B_24HOUR_MODE                  (1 << 1)
#define REGISTER_B_ENABLE_ALARM_INTERRUPT       (1 << 5)
#define REGISTER_B_ENABLE_PERIODIC_INTERRUPT    (1 << 6)

VOID
HalpIoDelay (
    VOID
    );

#define IO_DELAY() HalpIoDelay()

//
// CMOS-related function prototypes
//

VOID
HalpAcquireCmosSpinLockAndWait(
    VOID
    );

//
// Inline functions
//

__inline
UCHAR
BIN_TO_BCD (
    UCHAR Value
    )

/*++

Routine Description:

    This function converts an 8-bit binary value to an packed, 8-bit,
    two-digit BCD value.

Arguments:

    Value - supplies the binary value to convert.

Return Value:

    Returns a two-digit packed BCD representation of Value.

--*/

{
    UCHAR tens;
    UCHAR units;

    tens = Value / 10;
    units = Value % 10;

    return (tens << 4) + units;
}

__inline
UCHAR
BCD_TO_BIN (
    UCHAR Value
    )

/*++

Routine Description:

    This function converts a packed, 8-bit, two-digit BCD value to an
    8-bit binary value.

Arguments:

    Value - supplies the BCD value to convert.

Return Value:

    Returns a binary representation of Value.

--*/

{
    UCHAR tens;
    UCHAR units;

    tens = (Value >> 4) & 0x0F;
    units = Value & 0x0F;

    return tens * 10 + units;
}

__inline
UCHAR
CMOS_READ (
    UCHAR Address
    )

/*++

Routine Description:

    This function reads a CMOS byte.

Arguments:

    Address - supplies the CMOS address of the value to retrieve.

Return Value:

    Returns the value residing in CMOS at Address.

--*/

{
    UCHAR data;
    UCHAR oldAddress;

    //
    // Record the current control port contents, write the address,
    // read the data, and restore the control port contents.
    //

    oldAddress = READ_PORT_UCHAR(CMOS_ADDRESS_PORT);

    WRITE_PORT_UCHAR(CMOS_ADDRESS_PORT,Address);
    IO_DELAY();

    data = READ_PORT_UCHAR(CMOS_DATA_PORT);
    WRITE_PORT_UCHAR(CMOS_ADDRESS_PORT,oldAddress);
    IO_DELAY();

    return data;
}

__inline
VOID
CMOS_WRITE (
    UCHAR Address,
    UCHAR Data
    )

/*++

Routine Description:

    This function writes a CMOS byte.

Arguments:

    Address - supplies the CMOS address of the value to retrieve.

    Data - supplies the value to write at the supplied address.

Return Value:

    None.

--*/

{
    UCHAR oldAddress;

    //
    // Record the current control port contents, write the address,
    // write the data, and restore the control port contents.
    //

    oldAddress = READ_PORT_UCHAR(CMOS_ADDRESS_PORT);

    WRITE_PORT_UCHAR(CMOS_ADDRESS_PORT,Address);
    IO_DELAY();

    WRITE_PORT_UCHAR(CMOS_DATA_PORT,Data);
    WRITE_PORT_UCHAR(CMOS_ADDRESS_PORT,oldAddress);
    IO_DELAY();
}

__inline
UCHAR
CMOS_READ_BCD (
    UCHAR Address
    )

/*++

Routine Description:

    This function reads a CMOS byte as a two-digit packed BCD value and
    returns its binary representation.

Arguments:

    Address - supplies the CMOS address of the BCD value to retrieve.

Return Value:

    Returns the binary representation of the BCD value residing in CMOS
    at Address.

--*/

{
    UCHAR value;

    value = CMOS_READ(Address);
    return BCD_TO_BIN(value);
}

__inline
VOID
CMOS_WRITE_BCD (
    UCHAR Address,
    UCHAR Value
    )

/*++

Routine Description:

    This function writes a CMOS byte as a two-digit packed BCD value.

Arguments:

    Address - supplies the CMOS address of the BCD value to write.

    Value - supplies the binary representation of the value to write in
            CMOS.

Return Value:

    None.

--*/

{
    UCHAR value;

    ASSERT(Value <= 99);

    value = BIN_TO_BCD(Value);
    CMOS_WRITE(Address,value);
}

__inline
VOID
WRITE_PORT_USHORT_PAIR (
    IN PUCHAR LsbPort,
    IN PUCHAR MsbPort,
    IN USHORT Value
    )

/*++

Routine Description:

    This function retrieves a USHORT value by reading two UCHAR values,
    each from one of two supplied 8 bit ports.

    NOTE - the LsbPort is read first, followed by the MsbPort.  

Arguments:

    LsbPort - supplies the port address from which to retrieve the
              least significant UCHAR value.

    MsbPort - supplies the port address from which to retrieve the
              most significant UCHAR value.

Return Value:

    Returns the resultant USHORT value.

--*/

{
    WRITE_PORT_UCHAR(LsbPort,(UCHAR)Value);
    IO_DELAY();
    WRITE_PORT_UCHAR(MsbPort,(UCHAR)(Value >> 8));
}

__inline
USHORT
READ_PORT_USHORT_PAIR (
    IN PUCHAR LsbPort,
    IN PUCHAR MsbPort
    )

/*++

Routine Description:

    This function retrieves a USHORT value by reading two UCHAR values,
    each from one of two supplied 8 bit ports.

    NOTE - the LsbPort is read first, followed by the MsbPort.  

Arguments:

    LsbPort - supplies the port address from which to retrieve the
              least significant UCHAR value.

    MsbPort - supplies the port address from which to retrieve the
              most significant UCHAR value.

Return Value:

    Returns the resultant USHORT value.

--*/

{
    UCHAR lsByte;
    UCHAR msByte;

    lsByte = READ_PORT_UCHAR(LsbPort);
    IO_DELAY();
    msByte = READ_PORT_UCHAR(MsbPort);

    return (USHORT)lsByte | ((USHORT)msByte << 8);
}

extern ULONG HalpCmosCenturyOffset;
extern UCHAR HalpRtcRegA;
extern UCHAR HalpRtcRegB;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\amd64\ixclock.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ixclock.c

Abstract:

    This module implements the code necessary to field and process the
    interval clock interrupts.

Author:

    Shie-Lin Tzong (shielint) 12-Jan-1990

Environment:

    Kernel mode only.

Revision History:

    bryanwi 20-Sep-90

        Add KiSetProfileInterval, KiStartProfileInterrupt,
        KiStopProfileInterrupt procedures.
        KiProfileInterrupt ISR.
        KiProfileList, KiProfileLock are delcared here.

    shielint 10-Dec-90
        Add performance counter support.
        Move system clock to irq8, ie we now use RTC to generate system
          clock.  Performance count and Profile use timer 1 counter 0.
          The interval of the irq0 interrupt can be changed by
          KiSetProfileInterval.  Performance counter does not care about the
          interval of the interrupt as long as it knows the rollover count.
        Note: Currently I implemented 1 performance counter for the whole
        i386 NT.
 
    John Vert (jvert) 11-Jul-1991
        Moved from ke\i386 to hal\i386.  Removed non-HAL stuff
 
    shie-lin tzong (shielint) 13-March-92
        Move System clock back to irq0 and use RTC (irq8) to generate
        profile interrupt.  Performance counter and system clock use time1
        counter 0 of 8254.
 
    Landy Wang (corollary!landy) 04-Dec-92
        Move much code into separate modules for easy inclusion by various
        HAL builds.

    Forrest Foltz (forrestf) 24-Oct-2000
        Ported from ixclock.asm to ixclock.c
 
--*/

#include "halcmn.h"

#define COUNTER_TICKS_AVG_SHIFT       4
#define COUNTER_TICKS_FOR_AVG        16
#define FRAME_COPY_SIZE              64

//
// Convert the interval to rollover count for 8254 Timer1 device.
// Timer1 counts down a 16 bit value at a rate of 1.193181667M counts-per-sec.
// (The main crystal freq is 14.31818, and this is a divide by 12)
//
// The best fit value closest to 10ms is 10.0144012689ms:
//   ROLLOVER_COUNT      11949
//   TIME_INCREMENT      100144
//   Calculated error is -.0109472 s/day
//
//
// The following table contains 8254 values timer values to use at
// any given ms setting from 1ms - 15ms.  All values work out to the
// same error per day (-.0109472 s/day).
//

typedef struct _TIMER_TABLE_ENTRY {
    USHORT RolloverCount;
    ULONG TimeIncrement;
} TIMER_TABLE_ENTRY, *PTIMER_TABLE_ENTRY;

TIMER_TABLE_ENTRY HalpTimerTable[] = {
    {      0,       0 },    // dummy entry to zero-base array
    {   1197,   10032 },    //  1ms
    {   2394,   20064 },    //  2ms
    {   3591,   30096 },    //  3ms
    {   4767,   39952 },    //  4ms
    {   5964,   49984 },    //  5ms
    {   7161,   60016 },    //  6ms
    {   8358,   70048 },    //  7ms
    {   9555,   80080 },    //  8ms
    {  10731,   89936 },    //  9ms
    {  11949,  100144 }     // 10ms
};

#define MIN_TIMER_INCREMENT 1
#define MAX_TIMER_INCREMENT \
    (sizeof(HalpTimerTable) / sizeof(TIMER_TABLE_ENTRY) - 1)

#define HalpMinimumTimerTableEntry (&HalpTimerTable[MIN_TIMER_INCREMENT])
#define HalpMaximumTimerTableEntry (&HalpTimerTable[MAX_TIMER_INCREMENT])

//
// External function prototypes
//

VOID
HalpMcaQueueDpc(
    VOID
    );

//
// External declarations
//

extern ULONG HalpTimerWatchdogEnabled;

//
// Globals
//

ULONG64 HalpWatchdogCount;
ULONG64 HalpWatchdogTsc;
ULONG64 HalpTimeBias;
BOOLEAN HalpClockMcaQueueDpc;

PTIMER_TABLE_ENTRY HalpNextMSRate = NULL;
ULONG HalpCurrentMSRateTableIndex;

#define HalpCurrentMSRate (&HalpTimerTable[HalpCurrentMSRateTableIndex+1])

//
// Forward function declarations
//

VOID
HalpSetMSRate(
    IN PTIMER_TABLE_ENTRY TableEntry
    );

//
// Inline functions
//

__forceinline
VOID
HalpCalibrateWatchdog(
    VOID
    )
{
    if (HalpTimerWatchdogEnabled == 0) {
        return;
    }

    //
    // Initializethe timer latency watchdog
    //

    HalpWatchdogTsc = ReadTimeStampCounter();
    HalpWatchdogCount = 0;
}

__forceinline
VOID
HalpCheckWatchdog(
    VOID
    )
{
    if (HalpTimerWatchdogEnabled == 0) {
        return;
    }

    AMD64_IMPLEMENT;
}

//
// Module functions
//

VOID
HalpInitializeClock (
    VOID
    )

/*++

Routine Description:

    This routine initialize system time clock using 8254 timer1 counter 0
    to generate an interrupt at every 15ms interval at 8259 irq0.

    See the definitions of TIME_INCREMENT and ROLLOVER_COUNT if clock rate
    needs to be changed.

Arguments:

    None

Return Value:

    None

--*/

{
    ULONG maxTimeIncrement;
    ULONG minTimeIncrement;

    //
    // Indicate to the kernel the minimum and maximum tick increments
    //

    minTimeIncrement = HalpMinimumTimerTableEntry->TimeIncrement;
    maxTimeIncrement = HalpMaximumTimerTableEntry->TimeIncrement;
    KeSetTimeIncrement(minTimeIncrement,maxTimeIncrement);

    //
    // Set the initial clock rate to the slowest permissible
    //

    HalpSetMSRate(HalpMaximumTimerTableEntry);
}


VOID
HalpAcpiTimerCalibratePerfCount (
    IN PLONG volatile Number,
    IN ULONG64 NewCount
    )

/*++

Routine Description:

    This routine resets the performance counter value for the current
    processor to zero. The reset is done such that the resulting value
    is closely synchronized with other processors in the configuration.

Arguments:

    Number - Supplies a pointer to count of the number of processors in
    the configuration.

    NewCount - Supplies the value to synchronize the counter too

Return Value:

    None.

--*/

{
    PKPCR pcr;
    ULONG64 perfCount;

    pcr = KeGetPcr();
    if (pcr->Number == 0) {

        //
        // Only execute on the boot processor.
        // 

        perfCount = QueryTimer().QuadPart;

        //
        // Compute how far the current count is from the target count,
        // and adjust TimerInfo.Bias accordingly.
        // 

        HalpTimeBias = NewCount - perfCount;
    }

    //
    // Wait for all processors to reach this point
    //

    InterlockedDecrement(Number); 
    while (*Number != 0) {
        PAUSE_PROCESSOR
    }
}


VOID
HalpSetMSRate(
    IN PTIMER_TABLE_ENTRY TableEntry
    )

/*++

Routine Description

    This routine programs the 8254 with a new rollover count.

Artuments

    TableEntry - Supplies a pointer to an entry within HalpTimerTable.

Return value:

    None.

--*/

{
    USHORT rollover;
    ULONG interruptsEnabled;

    //
    // Program the 8254 to generate the new timer interrupt rate.
    //

    rollover = TableEntry->RolloverCount;
    interruptsEnabled = HalpDisableInterrupts();

    WRITE_PORT_UCHAR(TIMER1_CONTROL_PORT,
                     TIMER_COMMAND_COUNTER0 +
                     TIMER_COMMAND_RW_16BIT +
                     TIMER_COMMAND_MODE2);
    IO_DELAY();

    WRITE_PORT_USHORT_PAIR (TIMER1_DATA_PORT0,
                            TIMER1_DATA_PORT0,
                            rollover);
    IO_DELAY();

    HalpRestoreInterrupts(interruptsEnabled);

    //
    // Recalibrate the timer watchdog
    // 

    HalpCalibrateWatchdog();

    //
    // Update the global representing the timer rate
    // 

    HalpCurrentMSRateTableIndex = (ULONG)(TableEntry - HalpTimerTable) - 1;
}

BOOLEAN
HalpClockInterrupt (
    IN PKINTERRUPT Interrupt,
    IN PVOID ServiceContext
    )

/*++

Routine Description

    This routine is entered as the result of an interrupt generated by CLOCK.
    Its function is to dismiss the interrupt, raise system Irql to
    CLOCK2_LEVEL, update performance counter and transfer control to the
    standard system routine to update the system time and the execution
    time of the current thread
    and process.

Arguments:

    Interrupt - Supplies a pointer to the interrupt object

    ServiceContext - Not used

Return value:

--*/

{
    ULONG timeIncrement;

    //
    // Capture the time increment for the now-occuring tick.  This is
    // done here because HalpCurrentMSRate will change if a rate change
    // is pending.
    //

    timeIncrement = HalpCurrentMSRate->TimeIncrement;

    //
    // Give the watchdog timer a chance to do its work
    //

    HalpCheckWatchdog();

    //
    // Check whether an MCA dpc should be queued
    //

    if (HalpClockMcaQueueDpc != FALSE) {
        HalpClockMcaQueueDpc = FALSE;
        HalpMcaQueueDpc();
    }

    //
    // Check whether the clock interrupt frequency should be changed.
    //

    if (HalpNextMSRate != NULL) {
        HalpNextMSRate = NULL;
        HalpSetMSRate(HalpNextMSRate);
    }

    //
    // Indicate to the kernel that a clock tick has occured.
    //

    KeUpdateSystemTime(Interrupt->TrapFrame,timeIncrement);

    return TRUE;
}

ULONG
HalpAcpiTimerSetTimeIncrement (
    IN ULONG DesiredIncrement
    )

/*++

Routine Description:

   This routine initialize system time clock to generate an
   interrupt at every DesiredIncrement interval.

Arguments:

    DesiredIncrement - desired interval between every timer tick (in
                       100ns unit.)

Return Value:

    The *REAL* time increment set.

--*/

{
    ULONG incMs;
    PTIMER_TABLE_ENTRY tableEntry;

    //
    // Convert the desired time inecrement to milliseconds
    //

    incMs = DesiredIncrement / 10000;

    //
    // Place the value within the range supported by this hal
    //

    if (incMs > MAX_TIMER_INCREMENT) {
        incMs = MAX_TIMER_INCREMENT;
    } else if (incMs < MIN_TIMER_INCREMENT) {
        incMs = MIN_TIMER_INCREMENT;
    }

    //
    // If the new rate is different than the current rate, indicate via
    // a non-null HalpNextMSRate that a new timer rate is expected.  This
    // will be done at the next timer ISR.
    // 

    tableEntry = &HalpTimerTable[incMs];
    if (tableEntry != HalpCurrentMSRate) {
        HalpNextMSRate = tableEntry;
    }

    //
    // Finally, return the timer increment that will actually be used.
    //

    return tableEntry->TimeIncrement;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\amd64\ixipi.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ixipi.c

Abstract:

    Provides the HAL support for Interprocessor Interrupts.
    This is the UP version.

Author:

    John Vert (jvert) 16-Jul-1991

Revision History:

    Forrest Foltz (forrestf) 23-Oct-2000
        Ported from ixipi.asm to ixipi.c

--*/

#include "halcmn.h"

VOID
HalInitializeProcessor(
    ULONG Number,
    PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    Initialize hal pcr values for current processor (if any)
    (called shortly after processor reaches kernel, before
    HalInitSystem if P0)

    IPI's and KeReadir/LowerIrq's must be available once this function
    returns.  (IPI's are only used once two or more processors are
    available)

Arguments:

    Number - Logical processor number of calling processor

Return Value:

    None.

--*/

{
    KAFFINITY mask;

    mask = (KAFFINITY)1 << Number;

    HalpDefaultInterruptAffinity |= mask;
    HalpActiveProcessors |= mask;

    HalpRegisterKdSupportFunctions(LoaderBlock);
}

VOID
HalRequestIpi (
    IN KAFFINITY Mask
    )

/*++

Routine Description:

    Requests an interprocessor interrupt

Arguments:

    Mask - Supplies a mask of the processors to interrupt

Return Value:

    None.

--*/

{
    KdBreakPoint();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\amd64\ixbeep.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ixbeep.c

Abstract:

    HAL routine to make noise.  It needs to synchronize is access to the
    8254, since we also use the 8254 for the profiling interrupt.

Author:

    John Vert (jvert) 31-Jul-1991

Revision History:

    Forrest Foltz (forrestf) 23-Oct-2000
        Ported from ixbeep.asm to ixbeep.c

Revision History:

--*/

#include "halcmn.h"

BOOLEAN
HalMakeBeep (
    IN ULONG Frequency
    )

/*++

Routine Description:

    This function sets the frequency of the speaker, causing it to sound a
    tone.  The tone will sound until the speaker is explicitly turned off,
    so the driver is responsible for controlling the duration of the tone.

Arguments:

    Frequency - Supplies the frequency of the desired tone.  A frequency of
                0 means the speaker should be shut off.

Return Value:

    TRUE  - Operation was successful (frequency within range or zero)
    FALSE - Operation was unsuccessful (frequency was out of range)
            Current tone (if any) is unchanged.

--*/

{
    UCHAR value;
    ULONG count;
    BOOLEAN result;

    HalpAcquireSystemHardwareSpinLock();

    //
    // Stop the speaker
    //

#if defined(NEC_98)
    WRITE_PORT_UCHAR(SPEAKER_CONTROL_PORT,SPEAKER_OFF);
    IO_DELAY();
#else
    value = READ_PORT_UCHAR(SPEAKER_CONTROL_PORT);
    IO_DELAY();
    value &= SPEAKER_OFF_MASK;
    WRITE_PORT_UCHAR(SPEAKER_CONTROL_PORT,value);
    IO_DELAY();
#endif

    //
    // If the frequency is zero, we are finished.
    //

    if (Frequency == 0) {
        result = TRUE;
        goto Exit;
    }

    //
    // Determine the timer register value based on the desired frequency.
    // If it is invalid then FALSE is returned.
    // 

    count = TIMER_CLOCK_IN / Frequency;
    if (count > 65535) {
        result = FALSE;
        goto Exit;
    }

#if defined(NEC_98)

    //
    // Program frequency
    //

    WRITE_PORT_UCHAR(TIMER_CONTROL_PORT,TIMER_CONTROL_SELECT);
    IO_DELAY();

    WRITE_PORT_USHORT_PAIR(TIMER_DATA_PORT,
                           TIMER_DATA_PORT,
                           (USHORT)count);
    IO_DELAY();

    //
    // Turn speaker on
    //

    WRITE_PORT_UCHAR(SPEAKER_CONTROL_PORT,SPEAKER_ON);
    IO_DELAY();

#else

    //
    // Put channel 2 in mode 3 (square-wave generator) and load the
    // proper value in.
    //

    WRITE_PORT_UCHAR(TIMER1_CONTROL_PORT,
                     TIMER_COMMAND_COUNTER2 +
                     TIMER_COMMAND_RW_16BIT +
                     TIMER_COMMAND_MODE3);
    IO_DELAY();
    WRITE_PORT_USHORT_PAIR (TIMER1_DATA_PORT2,
                            TIMER1_DATA_PORT2,
                            (USHORT)count);
    IO_DELAY();

    //
    // Turn the speaker on
    //

    value = READ_PORT_UCHAR(SPEAKER_CONTROL_PORT); IO_DELAY();
    value |= SPEAKER_ON_MASK;
    WRITE_PORT_UCHAR(SPEAKER_CONTROL_PORT,value); IO_DELAY();

#endif  // NEC_98

    //
    // Indicate success, we're done
    //

    result = TRUE;

Exit:
    HalpReleaseSystemHardwareSpinLock();
    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\amd64\ixsstate.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ixstate.c

Abstract:

    This module implements the code for putting the machine to sleep.

Author:

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halcmn.h"

NTSTATUS
HaliAcpiSleep(
    IN PVOID                        Context,
    IN PENTER_STATE_SYSTEM_HANDLER  SystemHandler   OPTIONAL,
    IN PVOID                        SystemContext,
    IN LONG                         NumberProcessors,
    IN volatile PLONG               Number
    )
{
    AMD64_IMPLEMENT;
    return STATUS_NOT_IMPLEMENTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\amd64\ixswint.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    ixswint.c

Abstract:

    This module implements the software interrupt handlers
    for x86 machines

Author:

    John Vert (jvert) 2-Jan-1992

Environment:

    Kernel mode only.

Revision History:

    Forrest Foltz (forrestf) 23-Oct-2000
        Ported from ixswint.asm to ixswint.c

--*/

#include "halcmn.h"

VOID
HalRequestSoftwareInterrupt (
    IN KIRQL RequestIrql
    )

/*++

Routine Description:

    This routine is used to request a software interrupt to the
    system. Also, this routine checks to see if any software
    interrupt should be generated.
    The following condition will cause software interrupt to
    be simulated:
      any software interrupt which has higher priority than
        current IRQL's is pending.

    NOTE: This routine simulates software interrupt as long as
          any pending SW interrupt level is higher than the current
          IRQL, even when interrupts are disabled.

Arguments:

   RequestIrql - Supplies the request IRQL value

Return Value:

   None.

--*/

{
    PHALP_SOFTWARE_INTERRUPT vector;
    ULONG mask;
    ULONG flags;
    PKPCR pcr;
    KIRQL highestPending;

    mask = (1 << RequestIrql);

    //
    // Clear the interrupt flag, set the pending interrupt bit, dispatch any
    // appropriate software interrupts and restore the interrupt flag.
    //

    flags = HalpDisableInterrupts();

    pcr = KeGetPcr();
    pcr->Irr |= mask;
    mask = (pcr->Irr) & ((1 << DISPATCH_LEVEL) - 1);
    highestPending = SWInterruptLookupTable[mask];

    if (highestPending > pcr->Irql) {
        vector = HalpSoftwareInterruptTable[RequestIrql];
        vector();
    }

    HalpRestoreInterrupts(flags);
}            


VOID
HalClearSoftwareInterrupt (
    IN KIRQL RequestIrql
    )

/*++

Routine Description:

    This routine is used to clear a possible pending software interrupt.
    Support for this function is optional, and allows the kernel to
    reduce the number of spurious software interrupts it receives.

Arguments:

    RequestIrql - Supplies the request IRQL value

Return Value:

    None.

--*/

{
    ULONG mask;
    ULONG irr;

    mask = ~(1 << RequestIrql);

    KPCR_READ_FIELD(Irr,&irr);
    irr &= mask;
    KPCR_WRITE_FIELD(Irr,&irr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\amd64\ixcmos.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ixcmos.c

Abstract:

    Procedures necessary to access CMOS/ECMOS information.

Author:

    David Risner (o-ncrdr) 20 Apr 1992

Revision History:

    Landy Wang (corollary!landy) 04 Dec 1992
    - Move much code from ixclock.asm to here so different HALs
      can reuse the common functionality.

    Forrest Foltz (forrestf) 24-Oct-2000
        Ported ixcmos.asm to ixcmos.c

--*/

#include "halcmn.h"

ULONG HalpHardwareLockFlags;

//
// Module-specific types
// 

typedef UCHAR (*READ_CMOS_CHAR)(ULONG Address);
typedef VOID (*WRITE_CMOS_CHAR)(ULONG Address, UCHAR Data);

typedef struct _CMOS_BUS_PARAMETERS {
    ULONG MaximumAddress;
    READ_CMOS_CHAR ReadFunction;
    WRITE_CMOS_CHAR WriteFunction;
} CMOS_BUS_PARAMETERS, *PCMOS_BUS_PARAMETERS;

//
// External data
//

extern KSPIN_LOCK HalpSystemHardwareLock;

//
// Local prototypes
//

UCHAR
HalpCmosReadByte(
    ULONG Address
    );

VOID
HalpCmosWriteByte(
    ULONG Address,
    UCHAR Data
    );

UCHAR
HalpECmosReadByte(
    ULONG Address
    );

VOID
HalpECmosWriteByte(
    ULONG Address,
    UCHAR Data
    );

UCHAR
HalpGetCmosCenturyByte (
    VOID
    );

ULONG
HalpGetSetCmosData (
    IN ULONG SourceLocation,
    IN ULONG SourceAddress,
    IN PVOID ReturnBuffer,
    IN ULONG ByteCount,
    IN BOOLEAN Write
    );

VOID
HalpSetCmosCenturyByte (
    UCHAR Century
    );

//
// Local data
//

//
// Describes each of the CMOS types
// 

CMOS_BUS_PARAMETERS HalpCmosBusParameterTable[] = {
    {   0xFF, HalpCmosReadByte,  HalpCmosWriteByte  },
    { 0xFFFF, HalpECmosReadByte, HalpECmosWriteByte }
};

//
// Contains the offset to the CMOS century information
//

ULONG HalpCmosCenturyOffset;

//
// HalpRebootNow is a reboot vector.  Set in an MP system to cause any
// processors that might be looping in HalpAcquireCmosSpinLock to transfer
// control to the vector in HalpRebootNow.
//

VOID (*HalpRebootNow)(VOID);

ULONG
HalpGetCmosData (
    IN ULONG SourceLocation,
    IN ULONG SourceAddress,
    IN PVOID ReturnBuffer,
    IN ULONG ByteCount
    )

/*++

Routine Description:

   This routine reads the requested number of bytes from CMOS/ECMOS and
   stores the data read into the supplied buffer in system memory.  If
   the requested data amount exceeds the allowable extent of the source
   location, the return data is truncated.

Arguments:

    SourceLocation - where data is to be read from CMOS or ECMOS
                        0 - CMOS, 1 - ECMOS

    SourceAddress - address in CMOS/ECMOS where data is to be transferred

    ReturnBuffer - address in system memory for data to transfer

    ByteCount - number of bytes to be read

Returns:

    Number of byte actually read.

--*/

{
    return HalpGetSetCmosData(SourceLocation,
                              SourceAddress,
                              ReturnBuffer,
                              ByteCount,
                              FALSE);
}

ULONG
HalpSetCmosData (
    IN ULONG SourceLocation,
    IN ULONG SourceAddress,
    IN PVOID ReturnBuffer,
    IN ULONG ByteCount
    )

/*++

Routine Description:

   This routine writes the requested number of bytes to CMOS/ECMOS.

Arguments:

    SourceLocation - where data is to be written from CMOS or ECMOS
                        0 - CMOS, 1 - ECMOS

    SourceAddress - address in CMOS/ECMOS where data is to be transferred

    ReturnBuffer - address in system memory for data to transfer

    ByteCount - number of bytes to be written

Returns:

    Number of byte actually read.

--*/

{
    return HalpGetSetCmosData(SourceLocation,
                              SourceAddress,
                              ReturnBuffer,
                              ByteCount,
                              TRUE);
}

ULONG
HalpGetSetCmosData (
    IN ULONG SourceLocation,
    IN ULONG RangeStart,
    IN PVOID Buffer,
    IN ULONG ByteCount,
    IN BOOLEAN Write
    )

/*++

Routine Description:

   This routine reads the requested number of bytes from CMOS/ECMOS and
   stores the data read into the supplied buffer in system memory.  If
   the requested data amount exceeds the allowable extent of the source
   location, the return data is truncated.

Arguments:

    SourceLocation - where data is to be read from CMOS or ECMOS
                        0 - CMOS, 1 - ECMOS

    RangeStart - address in CMOS/ECMOS where data is to be transferred

    Buffer - address in system memory for data to transfer

    ByteCount - number of bytes to be transferred

    Write - Indicates whether the operation is a read or a write

Returns:

    Number of byte actually transferred

--*/

{
    ULONG address;
    PCHAR buffer;
    ULONG last;
    PCMOS_BUS_PARAMETERS cmosParameters;

    //
    // Validate the "bus type" and get a pointer to the parameters
    // for the corresponding CMOS "bus".
    //

    if (SourceLocation != 0 && SourceLocation != 1) {
        return 0;
    }

    cmosParameters = &HalpCmosBusParameterTable[SourceLocation];

    //
    // Limit the range of bytes to that which the cmos bus can accomodate.
    // 

    address = RangeStart;
    buffer = Buffer;

    last = address + ByteCount - 1;
    if (last > cmosParameters->MaximumAddress) {
        last = cmosParameters->MaximumAddress;
    }

    //
    // Take the cmos spin lock, perform the transfer, and release the lock.
    //

    HalpAcquireCmosSpinLock();

    while (address <= last) {
        if (Write == FALSE) {
            *buffer = cmosParameters->ReadFunction(address);
        } else {
            cmosParameters->WriteFunction(address,*buffer);
        }

        address += 1;
        buffer += 1;
    }
    HalpReleaseCmosSpinLock();

    //
    // Calculate and return the number of bytes trasferred.
    // 

    return last - RangeStart;
}


UCHAR
HalpCmosReadByte(
    ULONG Address
    )

/*++

Routine Description:

   This routine reads a single byte from cmos.

Arguments:

    Address - The CMOS address from which to retrieve the byte.

Returns:

    The byte that was read.

--*/

{
    return CMOS_READ((UCHAR)Address);
}

VOID
HalpCmosWriteByte(
    ULONG Address,
    UCHAR Data
    )

/*++

Routine Description:

   This routine writes a single byte to cmos.

Arguments:

    Address - The CMOS address at which to write the byte

    Data - The byte to write

Returns:

    Nothing

--*/

{
    CMOS_WRITE((UCHAR)Address,Data);
}

UCHAR
HalpECmosReadByte(
    ULONG Address
    )

/*++

Routine Description:

   This routine reads a single byte from extended cmos (ECMOS).

Arguments:

    Address - The CMOS address from which to retrieve the byte.

Returns:

    The byte that was read.

--*/

{
    UCHAR data;

    WRITE_PORT_USHORT_PAIR (ECMOS_ADDRESS_PORT_LSB,
                            ECMOS_ADDRESS_PORT_MSB,
                            (USHORT)Address);
    IO_DELAY();

    data = READ_PORT_UCHAR(ECMOS_DATA_PORT);
    IO_DELAY();

    return data;
}

VOID
HalpECmosWriteByte(
    ULONG Address,
    UCHAR Data
    )

/*++

Routine Description:

   This routine writes a single byte to extended cmos (ECMOS).

Arguments:

    Address - The CMOS address at which to write the byte

    Data - The byte to write

Returns:

    Nothing

--*/

{
    WRITE_PORT_USHORT_PAIR (ECMOS_ADDRESS_PORT_LSB,
                            ECMOS_ADDRESS_PORT_MSB,
                            (USHORT)Address);
    IO_DELAY();

    WRITE_PORT_UCHAR(ECMOS_DATA_PORT,Data);
    IO_DELAY();
}

VOID
HalpReadCmosTime(
    PTIME_FIELDS TimeFields
    )

/*++

Routine Description:

    This routine reads current time from CMOS memory and stores it
    in the TIME_FIELDS structure passed in by caller.

Arguments:

    TimeFields - A pointer to the TIME_FIELDS structure.

Return Value:

    None.

--*/

{
    USHORT year;

    HalpAcquireCmosSpinLockAndWait();

    //
    // The RTC is only accurate to within one second.  So add a
    // half a second so that we are closer, on average, to the right
    // answer.
    //

    TimeFields->Milliseconds = 500;
    TimeFields->Second = CMOS_READ_BCD(RTC_OFFSET_SECOND);
    TimeFields->Minute = CMOS_READ_BCD(RTC_OFFSET_MINUTE);
    TimeFields->Hour = CMOS_READ_BCD(RTC_OFFSET_HOUR);
    TimeFields->Weekday = CMOS_READ_BCD(RTC_OFFSET_DAY_OF_WEEK);
    TimeFields->Day = CMOS_READ_BCD(RTC_OFFSET_DATE_OF_MONTH);

    year = BCD_TO_BIN(HalpGetCmosCenturyByte());
    year = year * 100 + CMOS_READ_BCD(RTC_OFFSET_YEAR);

    if (year >= 1900 && year < 1920) {

        //
        // Compensate for the century field
        //

        year += 100;
    }

    TimeFields->Year = year;

    HalpReleaseCmosSpinLock();
}

VOID
HalpWriteCmosTime (
    PTIME_FIELDS TimeFields
    )

/*++

Routine Description:

   This routine writes current time from TIME_FILEDS structure
   to CMOS memory.

Arguments:

   TimeFields - A pointer to the TIME_FIELDS structure.

Return Value:

   None.

--*/

{
    ULONG year;

    HalpAcquireCmosSpinLockAndWait();

    CMOS_WRITE_BCD(RTC_OFFSET_SECOND,(UCHAR)TimeFields->Second);
    CMOS_WRITE_BCD(RTC_OFFSET_MINUTE,(UCHAR)TimeFields->Minute);
    CMOS_WRITE_BCD(RTC_OFFSET_HOUR,(UCHAR)TimeFields->Hour);
    CMOS_WRITE_BCD(RTC_OFFSET_DAY_OF_WEEK,(UCHAR)TimeFields->Weekday);
    CMOS_WRITE_BCD(RTC_OFFSET_DATE_OF_MONTH,(UCHAR)TimeFields->Month);

    year = TimeFields->Year;
    if (year > 9999) {
        year = 9999;
    }

    HalpSetCmosCenturyByte(BIN_TO_BCD((UCHAR)(year / 100)));
    CMOS_WRITE_BCD(RTC_OFFSET_YEAR,(UCHAR)(year % 100));

    HalpReleaseCmosSpinLock();
}

VOID
HalpAcquireCmosSpinLockAndWait (
    VOID
    )

/*++

Routine Description:

    This routine acquires the CMOS spinlock, then waits for the CMOS
    BUSY flag to be clear.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG count;
    ULONG value;

    //
    // Acquire the cmos spinlock and wait until it is not busy.  While
    // waiting, periodically release and re-acquire the spinlock.
    //

    HalpAcquireCmosSpinLock();
    count = 0;
    while (TRUE) {

        value = CMOS_READ(CMOS_STATUS_A);
        if ((value & CMOS_STATUS_BUSY) == 0) {
            return;
        }

        count += 1;
        if (count == 100) {

            count = 0;
            HalpReleaseCmosSpinLock();
            HalpAcquireCmosSpinLock();
        }
    }
}

VOID
HalpReleaseCmosSpinLock (
    VOID
    )

/*++

Routine Description:

   This routine acquires the spin lock used to protect access to various
   pieces of hardware.

Arguments:

    None

Returns:

    Nothing

--*/

{
    ULONG flags;

    flags = HalpHardwareLockFlags;
    KeReleaseSpinLockFromDpcLevel(&HalpSystemHardwareLock);
    HalpRestoreInterrupts(flags);
}

VOID
HalpAcquireCmosSpinLock (
    VOID
    )

/*++

Routine Description:

   This routine acquires the spin lock used to protect access to various
   pieces of hardware.

Arguments:

    None

Returns:

    Nothing

--*/

{
    BOOLEAN acquired;
    ULONG flags;
    KIRQL oldIrql;

#if defined(NT_UP)
    HalpHardwareLockFlags = HalpDisableInterrupts();
#else
    while (TRUE) {

        flags = HalpDisableInterrupts();
        acquired = KeTryToAcquireSpinLockAtDpcLevel(&HalpSystemHardwareLock);
        if (acquired != FALSE) {
            break;
        }
        HalpRestoreInterrupts(flags);

        while (KeTestSpinLock(&HalpSystemHardwareLock) == FALSE) {
            if (HalpRebootNow != NULL) {
                HalpRebootNow();
            }
            PAUSE_PROCESSOR;
        }
    }

    HalpHardwareLockFlags = flags;
#endif
}

VOID
HalpAcquireSystemHardwareSpinLock (
    VOID
    )

/*++

Routine Description:

   This routine acquires the spin lock used to protect access to various
   pieces of hardware.  It is a synonym of HalpAcquireCmosSpinLock().

Arguments:

    None

Returns:

    Nothing

--*/

{
    HalpAcquireCmosSpinLock();
}

VOID
HalpReleaseSystemHardwareSpinLock (
    VOID
    )

/*++

Routine Description:

   This routine releases the spin lock used to protect access to various
   pieces of hardware.  It is a synonym of HalpReleaseCmosSpinLock().

Arguments:

    None

Returns:

    Nothing

--*/

{
    HalpReleaseCmosSpinLock();
}

UCHAR
HalpGetCmosCenturyByte (
    VOID
    )

/*++

Routine Description:

   This routine retrieves the century byte from the CMOS.

   N.B. The cmos spinlock must be acquired before calling this function.

Arguments:

    None

Returns:

    The century byte.

--*/

{
    UCHAR value;
    UCHAR oldStatus;
    UCHAR centuryByte;

    //
    // Make sure the century offset is initialized
    //

    ASSERT(HalpCmosCenturyOffset != 0);

    if ((HalpCmosCenturyOffset & CMOS_BANK_1) != 0) {

        //
        // Perform a bank 1 read
        //

        oldStatus = CMOS_READ(CMOS_STATUS_A);
        value = oldStatus | CMOS_STATUS_BANK1;
        CMOS_WRITE(CMOS_STATUS_A,value);
        centuryByte = CMOS_READ((UCHAR)HalpCmosCenturyOffset);
        CMOS_WRITE(CMOS_STATUS_A,oldStatus);

    } else {
        centuryByte = CMOS_READ((UCHAR)HalpCmosCenturyOffset);
    }

    return centuryByte;
}

VOID
HalpSetCmosCenturyByte (
    UCHAR Century
    )

/*++

Routine Description:

   This routine sets the century byte in the CMOS.

   N.B. The cmos spinlock must be acquired before calling this function.

Arguments:

    Century - The century byte to set

Returns:

    Nothing

--*/

{
    UCHAR value;
    UCHAR oldStatus;

    //
    // Make sure the century offset is initialized
    //

    ASSERT(HalpCmosCenturyOffset != 0);

    if ((HalpCmosCenturyOffset & CMOS_BANK_1) != 0) {

        //
        // Perform a bank 1 write
        //

        oldStatus = CMOS_READ(CMOS_STATUS_A);
        value = oldStatus | CMOS_STATUS_BANK1;
        CMOS_WRITE(CMOS_STATUS_A,value);
        CMOS_WRITE((UCHAR)HalpCmosCenturyOffset,Century);
        CMOS_WRITE(CMOS_STATUS_A,oldStatus);

    } else {
        CMOS_WRITE((UCHAR)HalpCmosCenturyOffset,Century);
    }
}

VOID
HalpFlushTLB (
    VOID
    )

/*++

Routine Description:

    Flushes the current TLB.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG flags;
    PKPCR pcr;
    PKPRCB prcb;
    ULONG64 cr3;
    ULONG64 cr4;
    ULONG64 oldCr4;

    flags = HalpDisableInterrupts();

    cr3 = ReadCR3();

    pcr = KeGetPcr();
    prcb = pcr->CurrentPrcb;

    //
    // Note: the original code (ixcmos.asm) had differing behavior based
    //       on whether this was CPU 0.  That behavior is mimicked here.
    //       It would be good to find out why this is done.
    //

    if (prcb->Number == 0) {
        WriteCR3(cr3);
    } else {
        cr4 = ReadCR4();
        WriteCR4(cr4 & ~CR4_PGE);
        WriteCR3(cr3);
        WriteCR4(cr4);
    }

    HalpRestoreInterrupts(flags);
}

               
VOID
HalpCpuID (
    IN ULONG  Function,
    OUT PULONG Eax,
    OUT PULONG Ebx,
    OUT PULONG Ecx,
    OUT PULONG Edx
    )

/*++

Routine Description:

    This function executes a cpu id and returns the result as found in
    registers eax, ebx, ecx and edx.

Arguments:

    Function - supplies the CPUID function to execute.

    Eax - supplies a pointer to the storage to contain the contents of eax.

    Eax - supplies a pointer to the storage to contain the contents of ebx.

    Eax - supplies a pointer to the storage to contain the contents of ecx.

    Eax - supplies a pointer to the storage to contain the contents of edx.

Return Value:

    None.

--*/

{
    CPU_INFO cpuInfo;

    KiCpuId (Function,&cpuInfo);

    *Eax = cpuInfo.Eax;
    *Ebx = cpuInfo.Ebx;
    *Ecx = cpuInfo.Ecx;
    *Edx = cpuInfo.Edx;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\amd64\ixprofil.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    ixprofil.c

Abstract:

    This module implements the code necessary to initialize, field and
    process the profile interrupt.

Author:

    Shie-Lin Tzong (shielint) 12-Jan-1990

Environment:

    Kernel mode only.

Revision History:

    bryanwi 20-Sep-90

        Add KiSetProfileInterval, KiStartProfileInterrupt,
        KiStopProfileInterrupt procedures.
        KiProfileInterrupt ISR.
        KiProfileList, KiProfileLock are delcared here.
 
    shielint 10-Dec-90
        Add performance counter support.
        Move system clock to irq8, ie we now use RTC to generate system
          clock.  Performance count and Profile use timer 1 counter 0.
          The interval of the irq0 interrupt can be changed by
          KiSetProfileInterval.  Performance counter does not care about the
          interval of the interrupt as long as it knows the rollover count.
        Note: Currently I implemented 1 performance counter for the whole
        i386 NT.
 
    John Vert (jvert) 11-Jul-1991
        Moved from ke\i386 to hal\i386.  Removed non-HAL stuff
 
    shie-lin tzong (shielint) 13-March-92
        Move System clock back to irq0 and use RTC (irq8) to generate
        profile interrupt.  Performance counter and system clock use time1
        counter 0 of 8254.
 
    Landy Wang (landy@corollary.com) 26-Mar-1992
        Move much code into separate modules for easy inclusion by various
        HAL builds.
 
 	Add HalBeginSystemInterrupt() call at beginning of ProfileInterrupt
 	code - this must be done before any sti.
 	Also add HalpProfileInterrupt2ndEntry for additional processors to
 	join the flow of things.

    Forrest Foltz (forrestf) 28-Oct-2000
        Ported from ixprofil.asm to ixprofil.c

--*/
 

#include "halcmn.h"

VOID
HalStartProfileInterrupt (
    ULONG u
    )
{
    AMD64_IMPLEMENT;
};

VOID
HalStopProfileInterrupt(
    ULONG u
    )
{
    AMD64_IMPLEMENT;
};


ULONG_PTR
HalSetProfileInterval (
    ULONG_PTR u
    )
{
    AMD64_IMPLEMENT;
    return 0;
};

BOOLEAN
HalpProfileInterrupt (
    IN PKINTERRUPT Interrupt,
    IN PVOID ServiceContext
    )
{
    AMD64_IMPLEMENT;
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\amd64\mcirql.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    mcirql.c

Abstract:

    This module implements the code necessary to raise and lower Irql on
    PIC-based AMD64 systems (e.g. SoftHammer).

Author:

    Forrest Foltz (forrestf) 27-Oct-2000

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halcmn.h"

//
// Declare the relationship between PIC irqs and corresponding IRQLs.  This
// table is used during init only, and is the basis for building
// Halp8259MaskTable and Halp8259IrqTable.
// 

#define M(x) (1 << (x))

USHORT HalpPicMapping[16] = {
    0,              //  0 - PASSIVE_LEVEL
    0,              //  1 - APC_LEVEL
    0,              //  2 - DISPATCH_LEVEL
    M(15),          //  3 - hardware
    M(14),          //  4 - hardware
    M(13),          //  5 - hardware
    M(12),          //  6 - hardware
    M(11),          //  7 - hardware
    M(10),          //  8 - hardware
    M(9),           //  9 - hardware
    M(7) | M(6),    // 10 - hardware
    M(5) | M(4),    // 11 - hardware
    M(3) | M(1),    // 12 - hardware
    M(0),           // 13 - CLOCK_LEVEL, SYNCH_LEVEL
    0,              // 14 - IPI_LEVEL
    M(8) };         // 15 - PROFILE_LEVEL, HIGH_LEVEL

//
// Halp8259MaskTable is used to translate an IRQL to a PIC mask.  It is
// initialized in HalpInitialize8259Tables().
//

USHORT Halp8259MaskTable[16];

//
// Halp8259InterruptTable is used to translate a PIC interrupt level
// to its associated IRQL.  It is initialized in HalpInitialize8259Tables().
//

KIRQL Halp8259IrqTable[16];

//
// Vector table to invoke a software interrupt routine.  These can be found
// in amd64s.asm.
//

VOID HalpGenerateUnexpectedInterrupt(VOID);
VOID HalpGenerateAPCInterrupt(VOID);
VOID HalpGenerateDPCInterrupt(VOID);

PHALP_SOFTWARE_INTERRUPT HalpSoftwareInterruptTable[] = {
    HalpGenerateUnexpectedInterrupt,    // Irql = PASSIVE_LEVEL
    HalpGenerateAPCInterrupt,           // Irql = APC_LEVEL
    HalpGenerateDPCInterrupt };         // Irql = DPC_LEVEL

//
// Table to quickly translate a software irr into the highest pending
// software interrupt level.
// 

KIRQL SWInterruptLookupTable[] = {
    0,                  // SWIRR=0, so highest pending SW irql= 0
    0,                  // SWIRR=1, so highest pending SW irql= 0
    1,                  // SWIRR=2, so highest pending SW irql= 1
    1,                  // SWIRR=3, so highest pending SW irql= 1
    2,                  // SWIRR=4, so highest pending SW irql= 2
    2,                  // SWIRR=5, so highest pending SW irql= 2
    2,                  // SWIRR=6, so highest pending SW irql= 2
    2 };                // SWIRR=7, so highest pending SW irql= 2

VOID
HalpRaiseIrql (
    IN KIRQL NewIrql,
    IN KIRQL CurrentIrql
    )

/*++

Routine Description:

    This routine is used to raise IRQL to the specified value.  Also, a
    mask will be used to mask of all of the lower level 8259 interrupts.

Parameters:

    NewIrql - the new irql to be raised to

    CurrentIrql - the current irql level

    None.

Return Value:

    Nothing.

--*/

{
    ULONG flags;
    USHORT mask;
    PKPCR pcr;

    //
    // If the new IRQL is a software IRQL, just set the new level in the
    // PCR.  Otherwise, program the 8259 as well.
    //

    if (NewIrql <= DISPATCH_LEVEL) {
        KPCR_WRITE_FIELD(Irql,&NewIrql);
    } else {
        flags = HalpDisableInterrupts();

        //
        // Interrupts are disabled, it is safe to access KPCR directly.
        //
        // Update the 8259's interrupt mask and set the new
        // Irql in the KPCR.
        //

        pcr = KeGetPcr();
        pcr->Irql = NewIrql;

        mask = (USHORT)pcr->Idr;
        mask |= Halp8259MaskTable[NewIrql];
        SET_8259_MASK(mask);

        HalpRestoreInterrupts(flags);
    }
}

VOID
HalpLowerIrql (
    IN KIRQL NewIrql,
    IN KIRQL CurrentIrql
    )

/*++

Routine Description:

    This routine is used to lower IRQL to the specified value.  Also,
    this routine checks to see if any software interrupt should be
    generated.

Parameters:

    NewIrql - the new irql to be raised to

    CurrentIrql - the current irql level

Return Value:

    Nothing.

--*/

{
    ULONG flags;
    PKPCR pcr;
    USHORT mask;
    KIRQL highestPending;

    flags = HalpDisableInterrupts();

    //
    // Get the current IRQL out of the PCR.  Accessing the pcr directly
    // here is permissible, as interrupts are disabled.
    //

    pcr = KeGetPcr();

    //
    // If the old IRQL was greater than software interrupt level, then
    // reprogram the PIC to the new level.
    //

    if (CurrentIrql > DISPATCH_LEVEL) {
        mask = Halp8259MaskTable[NewIrql];
        mask |= pcr->Idr;
        SET_8259_MASK(mask);
    }

    pcr->Irql = NewIrql;

    //
    // Check for pending software interrupts.
    // 

    highestPending = SWInterruptLookupTable[pcr->Irr];
    if (highestPending > CurrentIrql) {
        HalpSoftwareInterruptTable[highestPending]();
    }

    HalpRestoreInterrupts(flags);
}

KIRQL
HalSwapIrql (
    IN KIRQL NewIrql
    )

/*++

Routine Description:

    This routine is used to change IRQL to a new value.  It is intended
    to be called from the CR8 dispatcher and is used only on AMD64 PIC-based
    systems (e.g. SoftHammer).

Parameters:

    NewIrql - the new irql to be raised to

Return Value:

    The previous IRQL value.

--*/

{
    KIRQL currentIrql;

    KPCR_READ_FIELD(Irql,&currentIrql);

    if (NewIrql > currentIrql) {
        HalpRaiseIrql(NewIrql,currentIrql);
    } else if (NewIrql < currentIrql) {
        HalpLowerIrql(NewIrql,currentIrql);
    } else {
    }

    return currentIrql;
}

VOID
HalEndSystemInterrupt (
    IN KIRQL NewIrql,
    IN ULONG Vector
    )

/*++

Routine Description:

    This routine is used to lower IRQL to the specified value.
    The IRQL and PIRQL will be updated accordingly.  Also, this
    routine checks to see if any software interrupt should be
    generated.  The following condition will cause software
    interrupt to be simulated:
      any software interrupt which has higher priority than
        current IRQL's is pending.

    NOTE: This routine simulates software interrupt as long as
          any pending SW interrupt level is higher than the current
          IRQL, even when interrupts are disabled.

Arguments:

    NewIrql - the new irql to be set.

    Vector - Vector number of the interrupt

Return Value:

    None.

--*/

{
    HalSwapIrql (NewIrql);
}

KIRQL
HalGetCurrentIrql (
    VOID
    )

/*++

Routine Description

    This routine returns the current IRQL.  It is intended to be called from
    the CR8 dispatch routine.

Arguments

    None

Return Value:

    The current IRQL

--*/

{
    KIRQL currentIrql;

    KPCR_READ_FIELD(Irql,&currentIrql);
    return currentIrql;
}


KIRQL
HalpDisableAllInterrupts (
    VOID
    )

/*++

Routine Description:

    This routine is called during a system crash.  The hal needs all
    interrupts disabled.

Arguments:

    None.

Return Value:

    None.  All interrupts are masked off at the PIC.

--*/

{
    KIRQL oldIrql;

    KeRaiseIrql(HIGH_LEVEL, &oldIrql);
    return oldIrql;
}

VOID
HalpInitialize8259Tables (
    VOID
    )

/*++

Routine Description

    This routine initializes Halp8259MaskTable[] and Halp8259IrqTable[]
    based on the contents of HalpPicMapping[].

Arguments

    None

Return Value:

    Nothing

--*/

{
    KIRQL irql;
    USHORT cumulativeMask;
    USHORT mask;
    UCHAR irq;

    //
    // Build Halp8259MaskTable[] and Halp8259IrqTable[]
    //

    cumulativeMask = 0;
    for (irql = 0; irql <= HIGH_LEVEL; irql++) {

        mask = HalpPicMapping[irql];

        //
        // Set the cumulative 8259 mask in the appropriate IRQL slot
        // in Halp8259MaskTable[]
        //

        cumulativeMask |= mask;
        Halp8259MaskTable[irql] = cumulativeMask;

        //
        // For each irq associated with this IRQL, store the IRQL
        // in that irq's slot in Halp8259IrqTable[]
        // 

        irq = 0;
        while (mask != 0) {
            if ((mask & 1) != 0) {
                Halp8259IrqTable[irq] = irql;
            }
            mask >>= 1;
            irq += 1;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\amd64\mcsysint.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    mcsysint.c

Abstract:

    This module implements the HAL routines to enable/disable system
    interrupts.

Author:

    John Vert (jvert) 22-Jul-1991

Revision History:

    Forrest Foltz (forrestf) 27-Oct-2000
        Ported from mcsysint.asm to mcsysint.c

Revision History:

--*/

#include "halcmn.h"

BOOLEAN
HalBeginSystemInterrupt (
    IN KIRQL Irql,
    IN ULONG Vector,
    OUT PKIRQL OldIrql
    )

/*++

Routine Description:

    This routine is used to dismiss the specified vector number.  It is called
    before any interrupt service routine code is executed.

    N.B.  This routine does NOT preserve EAX or EBX

    On a UP machine the interrupt dismissed at BeginSystemInterrupt time.
    This is fine since the irql is being raise to mask it off.
    HalEndSystemInterrupt is simply a LowerIrql request.


Arguments:

    Irql   - Supplies the IRQL to raise to

    Vector - Supplies the vector of the interrupt to be processed

    OldIrql- Location to return OldIrql


Return Value:

    FALSE - Interrupt is spurious and should be ignored

    TRUE -  Interrupt successfully dismissed and Irql raised.

--*/

{
    UCHAR irq;
    UCHAR isr;
    PCHAR picPort;
    ULONG mask;
    PKPCR pcr;

    irq = (UCHAR)(Vector - PRIMARY_VECTOR_BASE);
    if (irq == 0x07) {

        //
        // Check to see if this is a spurious interrupt
        //

        WRITE_PORT_UCHAR(PIC1_PORT0,OCW3_READ_ISR);
        IO_DELAY();
        isr = READ_PORT_UCHAR(PIC1_PORT0);
        IO_DELAY();
        if ((isr & 0x8000) == 0) {

            //
            // This is a spurious interrupt
            //

            HalpEnableInterrupts();
            return FALSE;
        }

        //
        // Non-spurious interrupt, fall through to normal processing
        // 
                         
    } else if (irq == 0x0F) {

        //
        // Check to see if this is a spurious interrupt
        //

        WRITE_PORT_UCHAR(PIC2_PORT0,OCW3_READ_ISR);
        IO_DELAY();
        isr = READ_PORT_UCHAR(PIC2_PORT0);
        IO_DELAY();
        if ((isr & 0x8000) == 0) {

            //
            // This is a spurious interrupt.  Dismiss the master PIC's
            // irq2.
            //

            WRITE_PORT_UCHAR(PIC1_PORT0,PIC2_EOI);
            IO_DELAY();
            HalpEnableInterrupts();
            return FALSE;
        }

        //
        // Non-spurious interrupt, fall through to normal processing
        //
    }

    //
    // Store the old IRQL, raise IRQL to the requested level
    //

    pcr = KeGetPcr();
    *OldIrql = pcr->Irql;
    pcr->Irql = Irql;

    //
    // Mask off interrupts according to the supplied IRQL
    // 

    mask = Halp8259MaskTable[Irql];
    mask |= pcr->Idr;
    SET_8259_MASK((USHORT)mask);

    //
    // Dismiss the interrupt
    //

    if (irq < 8) {

        //
        // Interrupt came from the master, send it a specific eoi.
        //

        WRITE_PORT_UCHAR(PIC1_PORT0,PIC1_EOI_MASK | irq);
        IO_DELAY();

    } else {

        //
        // Interrupt came from the slave, send the slave a non-specific EOI
        // and send the master an irq-2 specific EOI
        //

        WRITE_PORT_UCHAR(PIC2_PORT0,OCW2_NON_SPECIFIC_EOI);
        IO_DELAY();
        WRITE_PORT_UCHAR(PIC1_PORT0,PIC2_EOI);
        IO_DELAY();
    }

    PIC1DELAY();

    HalpEnableInterrupts();
    return TRUE;
}


VOID
HalDisableSystemInterrupt(
    IN ULONG Vector,
    IN KIRQL Irql
    )

/*++

Routine Description:

    Disables a system interrupt.

Arguments:

    Vector - Supplies the vector of the interrupt to be disabled

    Irql   - Supplies the interrupt level of the interrupt to be disabled

Return Value:

    None.

--*/

{
    USHORT mask;
    UCHAR irq;
    ULONG flags;
    PKPCR pcr;
    USHORT imr;
    PUCHAR picPort;

    irq = (UCHAR)(Vector - PRIMARY_VECTOR_BASE);
    mask = 1 << irq;

    flags = HalpDisableInterrupts();
    pcr = KeGetPcr();
    pcr->Idr |= mask;

    //
    // Mask the irq in the 8259.
    //

    mask |= GET_8259_MASK();
    SET_8259_MASK(mask);

    HalpRestoreInterrupts(flags);
}

BOOLEAN
HalEnableSystemInterrupt(
    IN ULONG Vector,
    IN KIRQL Irql,
    IN KINTERRUPT_MODE InterruptMode
    )

/*++

Routine Description:

    Enables a system interrupt

Arguments:

    Vector - Supplies the vector of the interrupt to be enabled

    Irql   - Supplies the interrupt level of the interrupt to be enabled.

Return Value:

    FALSE in the case of an invalid parameter, TRUE otherwise.

--*/

{
    UCHAR irq;
    ULONG mask;
    USHORT edgeLevel;
    ULONG flags;
    PKPCR pcr;

    irq = (UCHAR)(Vector - PRIMARY_VECTOR_BASE);
    if (Vector < PRIMARY_VECTOR_BASE || irq > HIGH_LEVEL) {
        return FALSE;
    }
    mask = 1 << irq;

    //
    // Set the edge/level bit in the interrupt controller
    //

    edgeLevel = READ_PORT_USHORT_PAIR (EISA_EDGE_LEVEL0, EISA_EDGE_LEVEL1);
    edgeLevel |= mask;
    WRITE_PORT_USHORT_PAIR (EISA_EDGE_LEVEL0,
                            EISA_EDGE_LEVEL1,
                            (USHORT)edgeLevel);
    IO_DELAY();

    //
    // Disable interrupts and mask off the corresponding bit in the Idr.
    //

    HalpDisableInterrupts();

    pcr = KeGetPcr();
    mask = ~mask & pcr->Idr;
    pcr->Idr = mask;

    //
    // Get the PIC masks for the current Irql
    //

    mask |= Halp8259MaskTable[Irql];
    SET_8259_MASK((USHORT)mask);

    //
    // Enable interrupts and return success
    // 

    HalpEnableInterrupts();
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\amd64\mpirql.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    mpirql.c

Abstract:

    This module implements support for int<->vector translation.

Author:

    Forrest Foltz (forrestf) 1-Dec-2000

Environment:

    Kernel mode only.

Revision History:

--*/


#include "halcmn.h"

#define ARRAY_SIZE(a) (sizeof(a)/sizeof(a[0]))

#define NUM_VECTORS 0x100

typedef struct _VECTOR_INIT {
    ULONG Vector;
    KIRQL Irql;
} VECTOR_INIT, *PVECTOR_INIT;

VECTOR_INIT HalpVectorInit[] = {
    { ZERO_VECTOR, 0 },
    { APC_VECTOR, APC_LEVEL },
    { DPC_VECTOR, DISPATCH_LEVEL },
    { APIC_GENERIC_VECTOR, PROFILE_LEVEL },
    { APIC_CLOCK_VECTOR, CLOCK_LEVEL },
    { APIC_IPI_VECTOR, IPI_LEVEL },
    { POWERFAIL_VECTOR, POWER_LEVEL }
};

//
// HalpVectorToIRQL maps interrupt vectors to NT IRQLs
//

KIRQL HalpVectorToIRQL[NUM_VECTORS];

//
// HalpVectorToINTI maps interrupt vector to EISA interrupt level
// on a per-node (cluster) basis.  This can be thought of as a
// two-dimensional array.
//

USHORT HalpVectorToINTI[MAX_NODES * NUM_VECTORS];


VOID
HalpInitializeIrqlTables (
    VOID
    )

/*++

Routine Description:

    This routine is responsible for initializing the HalpVectorToINTI[] and
    HalpVectorToIRQL[] tables, based on the contents of the HalpVectorInit[]
    array.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG count;
    PVECTOR_INIT vectorInit;

    //
    // Initialize every element of HalpVectorToINTI to 0xFFFF
    //

    for (count = 0; count < ARRAY_SIZE(HalpVectorToINTI); count++) {
        HalpVectorToINTI[count] = 0xFFFF;
    }

    //
    // Build HalpVectorToIrql based on the contents of HalpVectorInit.
    // Any unused entries are initialized to (KIRQL)0xFF.
    //

    for (count = 0; count < ARRAY_SIZE(HalpVectorToIRQL); count++) {
        HalpVectorToIRQL[count] = (KIRQL)0xFF;
    }

    for (count = 0; count < ARRAY_SIZE(HalpVectorInit); count++) {
        vectorInit = &HalpVectorInit[count];
        HalpVectorToIRQL[vectorInit->Vector] = vectorInit->Irql;
    }




}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\amd64\mpspin.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    mpspin.c

Abstract:

    This module implements the hal high level lock manipulation routines.

Author:

    Forrest Foltz (forrestf) 1-Dec-2000

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halcmn.h"

ULONG
HalpAcquireHighLevelLock (
    IN PKSPIN_LOCK SpinLock
    )

/*++

Routine Description:

    Acquires a spinlock with interrupts disabled.

Arguments:

    SpinLock - Supplies a pointer to a kernel spin lock.

Return Value:

    Returns the state of the EFLAGS register.

--*/

{
    ULONG flags;

    //
    // Remember the state of the processor flags
    // 

    flags = HalpGetProcessorFlags();

    while (TRUE) {

        //
        // Disable interrupts and attempt to take the spinlock, exiting
        // the loop if it was available.
        //

        _disable();
        if (KeTryToAcquireSpinLockAtDpcLevel(SpinLock) != FALSE) {
            break;
        }

        //
        // The spinlock was not available.  Restore the state of the
        // interrupt flag and spin, waiting for it to become available.
        //

        HalpRestoreInterrupts(flags);
        while (KeTestSpinLock(SpinLock) == FALSE) {
            NOTHING;
        }
    }

    return flags;
}

VOID
HalpReleaseHighLevelLock (
    IN PKSPIN_LOCK SpinLock,
    IN ULONG       Flags
    )

/*++

Routine Description:

    This function releases a kernel spin lock that was taken by
    HalpAcquireHighLevelLock() and lowers to the new irql.

Arguments:

    SpinLock - Supplies a pointer to a kernel spin lock.
    Flags    - The contents of the EFLAGS register when the
               lock was taken.

Return Value:

    None.

--*/

{
    //
    // Interrupts at this point are disabled.  Release the spinlock and
    // enable interrupts if they were enabled when the lock was taken.
    //

    KeReleaseSpinLockFromDpcLevel(SpinLock);
    HalpRestoreInterrupts(Flags);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\amd64\mpswint.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    mpswint.c

Abstract:

    This module implements the software interrupt handlers
    for x86 machines

Author:

    John Vert (jvert) 2-Jan-1992

Environment:

    Kernel mode only.

Revision History:

    Forrest Foltz (forrestf) 23-Oct-2000
        Ported from ixswint.asm to ixswint.c

--*/

#include "halcmn.h"

extern UCHAR HalpIRQLtoTPR[];

//
// Array used to look up the correct ICR command based on the requested
// software interrupt
//

const
ULONG
HalpIcrCommandArray[3] = {
    0,
    APC_VECTOR | DELIVER_FIXED | ICR_SELF,  // APC_LEVEL
    DPC_VECTOR | DELIVER_FIXED | ICR_SELF   // DISPATCH_LEVEL
};

C_ASSERT(APC_LEVEL == 1);
C_ASSERT(DISPATCH_LEVEL == 2);


VOID
FASTCALL
HalRequestSoftwareInterrupt (
    IN KIRQL RequestIrql
    )

/*++

Routine Description:

    This routine is used to request a software interrupt of
    the system.

Arguments:

    RequestIrql - Supplies the request IRQL value

 Return Value:

    None.

--*/

{
    ULONG icrCommand;
    ULONG flags;

    ASSERT(RequestIrql == APC_LEVEL || RequestIrql == DISPATCH_LEVEL);

    icrCommand = HalpIcrCommandArray[RequestIrql];

    flags = HalpDisableInterrupts();
    HalpStallWhileApicBusy();

    LOCAL_APIC(LU_INT_CMD_LOW) = icrCommand;

    HalpStallWhileApicBusy();
    HalpRestoreInterrupts(flags);
}


VOID
HalClearSoftwareInterrupt (
    IN KIRQL RequestIrql
    )

/*++

Routine Description:

    This routine is used to clear a possible pending software interrupt.
    Support for this function is optional, and allows the kernel to
    reduce the number of spurious software interrupts it receives/
 
Arguments:
 
     RequestIrql - Supplies the request IRQL value
 
Return Value:
 
     None.

--*/

{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\amd64\mpprofil.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    mpprofil.c

Abstract:

    This module implements the code necessary to initialize, field and
    process the profile interrupt.

Author:

    Shie-Lin Tzong (shielint) 12-Jan-1990

Environment:

    Kernel mode only.

Revision History:

    bryanwi 20-Sep-90

    Forrest Foltz (forrestf) 28-Oct-2000
        Ported from ixprofil.asm to ixprofil.c

--*/

#include "halcmn.h"

#define APIC_TIMER_ENABLED  (PERIODIC_TIMER | APIC_PROFILE_VECTOR)

#define APIC_TIMER_DISABLED (INTERRUPT_MASKED |     \
                             PERIODIC_TIMER   |     \
                             APIC_PROFILE_VECTOR)

#define TIMER_ROUND(x) ((((x) + 10000 / 2) / 10000) * 10000)

ULONG HalpProfileRunning;

VOID (*HalpPerfInterruptHandler)(PKTRAP_FRAME);

VOID
HalStartProfileInterrupt(
    IN ULONG Reserved
    )

/*++

Routine Description:

    What we do here is set the interrupt rate to the value that's been set
    by the KeSetProfileInterval routine. Then enable the APIC Timer interrupt.

    This function gets called on every processor so the hal can enable
    a profile interrupt on each processor.
 
Arguments:

    Reserved - Not used, must be zero.

Return Value:

    None.

--*/

{
    ULONG initialCount;

    ASSERT(Reserved == 0);

    initialCount = HalpGetCurrentHalPcr()->ProfileCountDown;

    LOCAL_APIC(LU_INITIAL_COUNT) = initialCount;
    HalpProfileRunning = TRUE;

    //
    // Set the Local APIC Timer to interrupt periodically at
    // APIC_PROFILE_VECTOR
    //

    LOCAL_APIC(LU_TIMER_VECTOR) = APIC_TIMER_ENABLED;
}

VOID
HalStopProfileInterrupt (
    IN ULONG Reserved
    )

/*++

Routine Description:

    Stop the profile interrupt that was started with
    HalpStartProfileInterrupt;

    This function gets called on every processor so the hal can disable
    a profile interrupt on each processor.
 
Arguments:

    Reserved - Not used, must be zero.

Return Value:

    None.

--*/

{
    ASSERT(Reserved == 0);

    HalpProfileRunning = FALSE;
    LOCAL_APIC(LU_TIMER_VECTOR) = APIC_TIMER_DISABLED;
}


ULONG_PTR
HalSetProfileInterval (
    ULONG_PTR Interval
    )

/*++

Routine Description:

    This procedure sets the interrupt rate (and thus the sampling
    interval) for the profiling interrupt.

Arguments:

    Interval - Supplies the desired profile interrupt interval in 100ns
               units (MINIMUM is 1221 or 122.1 uS) see ke\profobj.c

Return Value:

    Interval actually used

--*/

{
    ULONG64 period;
    ULONG apicFreqency;
    PHAL_PCR halPcr;
    ULONG countDown;

    halPcr = HalpGetCurrentHalPcr();

    //
    // Limit the interrupt period to 1 second
    //

    if (Interval > TIME_UNITS_PER_SECOND) {
        period = TIME_UNITS_PER_SECOND;
    } else {
        period = Interval;
    }

    //
    // Compute the countdown value corresponding to the desired period.
    // The calculation is done with 64-bit intermediate values.
    //

    countDown =
        (ULONG)(period * halPcr->ApicClockFreqHz) / TIME_UNITS_PER_SECOND;

    halPcr->ProfileCountDown = countDown;
    LOCAL_APIC(LU_INITIAL_COUNT) = countDown;

    return period;
}


VOID
#if defined(MMTIMER)
HalpAcpiTimerCalibratePerfCount (
#else                            
HalCalibratePerformanceCounter (
#endif
    IN LONG volatile *Number,
    IN ULONGLONG NewCount
    )

/*++

Routine Description:

    This routine calibrates the performance counter value for a
    multiprocessor system.  The calibration can be done by zeroing
    the current performance counter, or by calculating a per-processor
    skewing between each processors counter.

Arguments:

    Number - Supplies a pointer to count of the number of processors in
    the configuration.

    NewCount - Supplies the value to synchronize the counter too

Return Value:

    None.

--*/

{
    ULONG flags;
    PHAL_PCR halPcr;

    flags = HalpDisableInterrupts();

    //
    // Store the count in the PCR
    //

    halPcr = HalpGetCurrentHalPcr();
    halPcr->PerfCounter = NewCount;

    //
    // Wait here until all processors arrive
    // 

    InterlockedDecrement(Number);
    while (*Number > 0) {
        ;
    }
    PROCESSOR_FENCE;

    //
    // Zero the time stamp counter, restore interrupts and return.
    // 

    WriteMSR(MSR_TSC,0);
    HalpRestoreInterrupts(flags);
}

VOID
HalpWaitForCmosRisingEdge (
    VOID
    )

/*++

Routine Description:

    Waits until the rising edge of the CMOS_STATUS_BUSY bit is detected.

    Note - The CMOS spin lock must be acquired before calling this routine.

Arguments:

    None.

Return Value:

    None.

--*/

{
    UCHAR value;

    //
    // The simulator takes about a day to go through this, so for right
    // 

#if !defined(_AMD64_SIMULATOR_)

    //
    // We're going to be polling the CMOS_STATUS_A register.  Program
    // that register address here, outside of the loop.
    // 

    WRITE_PORT_UCHAR(CMOS_ADDRESS_PORT,CMOS_STATUS_A);

    //
    // Wait for the status bit to be clear
    //

    do {
        value = READ_PORT_UCHAR(CMOS_DATA_PORT);
    } while ((value & CMOS_STATUS_BUSY) != 0);

    //
    // Now wait for the rising edge of the status bit
    //

    do {
        value = READ_PORT_UCHAR(CMOS_DATA_PORT);
    } while ((value & CMOS_STATUS_BUSY) == 0);

#endif

}


ULONG
HalpScaleTimers (
    VOID
    )

/*++

Routine Description:

    Determines the frequency of the APIC timer.  This routine is run
    during initialization

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG flags;
    ULONG passCount;
    ULONG64 cpuFreq;
    ULONG apicFreq;
    UCHAR value;
    PHAL_PCR halPcr;

    HalpAcquireCmosSpinLock();
    flags = HalpDisableInterrupts();

    LOCAL_APIC(LU_TIMER_VECTOR) = APIC_TIMER_DISABLED;
    LOCAL_APIC(LU_DIVIDER_CONFIG) = LU_DIVIDE_BY_1;

    passCount = 2;
    while (passCount > 0) {

        //
        // Make sure the write has occured
        //

        LOCAL_APIC(LU_TIMER_VECTOR);

        //
        // Wait for the rising edge of the UIP bit, this is the start of the
        // cycle.
        //

        HalpWaitForCmosRisingEdge();

        //
        // At this point the UIP bit has just changed to the set state.
        // Clear the time stamp counter and start the APIC counting down
        // from it's maximum value.
        //

        PROCESSOR_FENCE;

        LOCAL_APIC(LU_INITIAL_COUNT) = 0xFFFFFFFF;
        cpuFreq = ReadTimeStampCounter();

        //
        // Wait for the next rising edge, this marks the end of the CMOS
        // clock update cycle.
        //

        HalpWaitForCmosRisingEdge();

        PROCESSOR_FENCE;

        apicFreq = 0xFFFFFFFF - LOCAL_APIC(LU_CURRENT_COUNT);
        cpuFreq = ReadTimeStampCounter() - cpuFreq;

        passCount -= 1;
    }

    halPcr = HalpGetCurrentHalPcr();

    //
    // cpuFreq is elapsed timestamp in one second.  Round to nearest
    // 10Khz and store.
    //

    halPcr->TSCHz = TIMER_ROUND(cpuFreq);

    //
    // Calculate the apic frequency, rounding to the nearest 10Khz
    //

    apicFreq = TIMER_ROUND(apicFreq);
    halPcr->ApicClockFreqHz = apicFreq;

    //
    // Store microsecond representation of TSC frequency.
    //

    halPcr->StallScaleFactor = (ULONG)(halPcr->TSCHz / 1000000);
    if ((halPcr->TSCHz % 1000000) != 0) {
        halPcr->StallScaleFactor += 1;
    }

    HalpReleaseCmosSpinLock();
    halPcr->ProfileCountDown = apicFreq;

    //
    // Set the interrupt rate in the chip and return the apic frequency
    //

    LOCAL_APIC(LU_INITIAL_COUNT) = apicFreq;
    HalpRestoreInterrupts(flags);

    return halPcr->ApicClockFreqHz;
}

BOOLEAN
HalpProfileInterrupt (
    IN PKINTERRUPT Interrupt,
    IN PVOID ServiceContext
    )

/*++

Routine Description:

    This routine is entered as the result of a profile interrupt.  Its
    function is to dismiss the interrupt, raise system Irql to
    HAL_PROFILE_LEVEL and transfer control to the standard system routine
    to process any active profiles.

Arguments:

    Interrupt - Supplies a pointer to the kernel interrupt object

    ServiceContext - Supplies the service context

Return Value:

    TRUE

--*/

{
    UNREFERENCED_PARAMETER(ServiceContext);

    if (HalpProfileRunning != FALSE) {

        //
        // BUGBUG what do we use for source?
        //

        KeProfileInterruptWithSource(Interrupt->TrapFrame,0);
    }

    return TRUE;
}

BOOLEAN
HalpPerfInterrupt (
    IN PKINTERRUPT Interrupt,
    IN PVOID ServiceContext
    )

/*++

Routine Description:

    This routine is entered as the result of a perf interrupt.  Its
    function is to dismiss the interrupt, raise system Irql to
    HAL_PROFILE_LEVEL and transfer control to the standard system routine
    to process any active profiles.

Arguments:

    Interrupt - Supplies a pointer to the kernel interrupt object

    ServiceContext - Supplies the service context

Return Value:

    TRUE

--*/

{
    UNREFERENCED_PARAMETER(Interrupt);

    if (HalpPerfInterruptHandler != NULL) {
        HalpPerfInterruptHandler(Interrupt->TrapFrame);
    } else {
        ASSERT(FALSE);
    }

    //
    // Starting with the Willamette processor, the perf interrupt gets masked
    // on interrupting.  Need to clear the mask before leaving the interrupt
    // handler.
    //

    LOCAL_APIC(LU_PERF_VECTOR), ~INTERRUPT_MASKED;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\amd64\mpsysint.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    mpcsysint.c

Abstract:

    This module implements the HAL routines to enable/disable system
    interrupts on an MPS system.

Author:

    John Vert (jvert) 22-Jul-1991

Revision History:

    Forrest Foltz (forrestf) 27-Oct-2000
        Ported from mcsysint.asm to mcsysint.c

Revision History:

--*/

#include "halcmn.h"

VOID
HalEndSystemInterrupt (
    IN KIRQL NewIrql,
    IN ULONG Vector
    )

/*++

Routine Description:

    This routine is used to send an EOI to the local APIC.

Arguments:

    NewIrql - the new irql to be set.

    Vector - Vector number of the interrupt

Return Value:

    None.

--*/
    
{
    UNREFERENCED_PARAMETER(NewIrql);
    UNREFERENCED_PARAMETER(Vector);

    //
    // Send EOI to APIC local unit
    //

    LOCAL_APIC(LU_EOI) = 0;
}


BOOLEAN
HalBeginSystemInterrupt (
    IN KIRQL Irql,
    IN ULONG Vector,
    OUT PKIRQL OldIrql
    )

/*++

Routine Description:

    This routine raises the IRQL to the level of the specified
    interrupt vector.  It is called by the hardware interrupt
    handler before any other interrupt service routine code is
    executed.  The CPU interrupt flag is set on exit.

    On APIC-based systems we do not need to check for spurious
    interrupts since they now have their own vector.  We also
    no longer need to check whether or not the incoming priority
    is higher than the current priority that is guaranteed by
    the priority mechanism of the APIC.

    SO

    All BeginSystemInterrupt needs to do is set the APIC TPR
    appropriate for the IRQL, and return TRUE.  Note that to
    use the APIC ISR priority we are not going issue EOI until
    EndSystemInterrupt is called.

Arguments:

    Irql   - Supplies the IRQL to raise to

    Vector - Supplies the vector of the interrupt to be
             handled

    OldIrql- Location to return OldIrql

 Return Value:

    TRUE -  Interrupt successfully dismissed and Irql raised.
            This routine can not fail.

--*/

{
    KeRaiseIrql(Irql,OldIrql);
    HalpEnableInterrupts();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\amd64\mpipi.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    mpipi.c

Abstract:

    This module provides the HAL support for interprocessor interrupts and
    processor initialization for MPS systems.

Author:

    Forrest Foltz (forrestf) 27-Oct-2000

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halcmn.h"

#define HAL_FORCEINLINE __forceinline

//
// External functions
//

VOID
HalpResetThisProcessor (
    VOID
    );

ULONG
DetectAcpiMP (
    OUT PBOOLEAN IsConfiguredMp,
    IN  PLOADER_PARAMETER_BLOCK LoaderBlock
    );

//
// External data
//

extern KAFFINITY HalpNodeAffinity[];
extern INTERRUPT_DEST HalpIpiDestinationMap[sizeof(KAFFINITY)][256];
extern BOOLEAN HalpStaticIntAffinity;
extern UCHAR rgzBadHal[];

//
// Local types
//

typedef
VOID
(*HAL_GENERIC_IPI_FUNCTION) (
    ULONG_PTR Context
    );

//
// Local prototypes
//

VOID
HalInitApicInterruptHandlers(
    VOID
    );

//
// External data
//

extern UCHAR HalpPICINTToVector[16];

//
// Local data and defines
//

KSPIN_LOCK HalpBroadcastLock;
KAFFINITY volatile HalpBroadcastTargets;
ULONG_PTR HalpBroadcastContext;
HAL_GENERIC_IPI_FUNCTION HalpBroadcastFunction;
PKPCR HalpProcessorPCR[MAXIMUM_PROCESSORS];

//
// HalpGlobal8259Mask is used to avoid reading the PIC to get the current
// interrupt mask; format is the same as for SET_8259_MASK, i.i.,
// bits 7:0 -> PIC1, 15:8 -> PIC2
//

USHORT HalpGlobal8259Mask = 0;

#define GENERIC_IPI (DELIVER_FIXED | LOGICAL_DESTINATION | ICR_USE_DEST_FIELD | APIC_GENERIC_VECTOR)
#define APIC_IPI    (DELIVER_FIXED | LOGICAL_DESTINATION | ICR_USE_DEST_FIELD | APIC_IPI_VECTOR)

//
// Globals and constants used to log local apic errors
//

#define LogApicErrors TRUE
#if LogApicErrors

//
// Structure defining the layout of an apic error record.
// 

typedef struct _APIC_ERROR {
    union {
        struct {
            UCHAR SendChecksum:1;
            UCHAR ReceiveChecksum:1;
            UCHAR SendAccept:1;
            UCHAR ReceiveAccept:1;
            UCHAR Reserved1:1;
            UCHAR SendVector:1;
            UCHAR ReceiveVector:1;
            UCHAR RegisterAddress:1;
        };
        UCHAR AsByte;
    };
    UCHAR Processor;
} APIC_ERROR, *PAPIC_ERROR;

#define APIC_ERROR_LOG_SIZE 128

//
// Count of local apic errors.
// 

ULONG HalpLocalApicErrorCount = 0;

//
// Apic error log.  This is circular, indexed by
// HalpLocalApicErrorCount % APIC_ERROR_LOG_SIZE.
//

APIC_ERROR HalpApicErrorLog[APIC_ERROR_LOG_SIZE];

//
// Spinlock used to protect access to HalpLocalApicErrorCount.
//

KSPIN_LOCK HalpLocalApicErrorLock;

#endif


HAL_FORCEINLINE
VOID
HalpSendIpiWorker (
    IN UCHAR TargetSet,
    IN ULONG Command
    )

/*++

Routine Description:

    This routine is called to send an IPI command to a set of processors
    on a single node.

Parameters:

    TargetSet - Specifies the processor identifiers within the node.

    Command - Specifies the IPI command to send.

Return Value:

    None.

--*/

{
    ULONG destination;

    //
    // Only high byte of the destination is used.  Wait until the Apic is
    // not busy before sending.  Continue without waiting, there will be
    // another wait after all IPIs have been submitted.
    // 

    destination = (ULONG)TargetSet << DESTINATION_SHIFT;

    HalpStallWhileApicBusy();
    LOCAL_APIC(LU_INT_CMD_HIGH) = destination;
    LOCAL_APIC(LU_INT_CMD_LOW) = Command;
}


HAL_FORCEINLINE
VOID
HalpSendNodeIpi (
    IN KAFFINITY Affinity,
    IN ULONG Command
    )

/*++

Routine Description:

Parameters:

    Affinity - Specifies the set of processors to receive the IPI.

    Command - Specifies the IPI command to send.

Return Value:

    None.

--*/

{
    KAFFINITY remainingProcessors;
    PKAFFINITY nodeAffinity;
    ULONG chunkNo;
    INTERRUPT_DEST intDest;
    INTERRUPT_DEST intDestSum;
    UCHAR affinityChunk;

    //
    // Declare a local union that can be used to access an affinity
    // both chunk-wise and as a whole.
    //

    union {
        UCHAR Chunks[sizeof(KAFFINITY)];
        KAFFINITY Whole;
    } affinity;

    //
    // Affinity has some number of target processors indicated.  Each
    // target processor is a member of a cluster of processors, or "node".
    //
    // For each node, determine whether it contains any of the target
    // processors.  If so, send an IPI command targeting those processors
    // and send it to the node.
    //

    nodeAffinity = HalpNodeAffinity;
    remainingProcessors = Affinity & HalpActiveProcessors;

    while (remainingProcessors != 0) {

        //
        // Iterate through the node affinities here until a node containing
        // at least some of the targeted processors is encountered.
        // 

        do {

            //
            // Determine the set of target CPUs that can be found in this
            // node.  
            // 
    
            affinity.Whole = *nodeAffinity & remainingProcessors;
    
            //
            // Point nodeAffinity at the affinity for the next cluster.
            //
    
            nodeAffinity += 1;
            ASSERT((nodeAffinity - HalpNodeAffinity) < MAX_NODES);

        } while (affinity.Whole == 0);

        //
        // Remove the processors that will be processed on this node from
        // the set of processors remaining to be processed.
        //

        remainingProcessors ^= affinity.Whole;

        //
        // Accumulate the logical target mask 
        //

        intDestSum.LogicalId = 0;
        chunkNo = 0;
        do {

            //
            // Isolate a chunk of the processor affinity mask.
            //

            affinityChunk = affinity.Chunks[chunkNo];

            //
            // Use that chunk as an index into HalpIpiDestinationMap[][],
            // retrieving the logical sum of all node/processor IDs that
            // are associated with each bit that is set in that affinity
            // chunk.
            //

            intDest = HalpIpiDestinationMap[chunkNo][affinityChunk];

            //
            // Now, sum it with the logical ID mask that is being accumulated
            // for each affinity chunk.
            //

            intDestSum.LogicalId |= intDest.LogicalId;

            //
            // Indicate that the processors represented in this chunk
            // have been processed.  When there are no more processors
            // left to process for this node, send the IPI and proceed
            // to the next node.
            //

            affinity.Chunks[chunkNo] = 0;
            chunkNo += 1;

        } while (affinity.Whole != 0);

        //
        // intDest contains an accumulated set of hardware processor
        // identifiers, representing all of the processors on this node that
        // should receive the command.
        // 

        HalpSendIpiWorker(intDestSum.LogicalId,Command);
    }
}


VOID
HalpSendIpi (
    IN KAFFINITY Affinity,
    IN ULONG Command
    )

/*++

Routine Description:

    Affinity - Specifies the set of processors to receive the IPI.

    Command - Specifies the IPI command to send.

Parameters:

    None.

Return Value:

    None.

--*/

{
    ULONG flags;

    //
    // Disable interrupts and call the appropriate routine.
    // 

    flags = HalpDisableInterrupts();
    if (HalpMaxProcsPerCluster == 0) {

        //
        // We know that the maximum number of processors is 8,
        // so send the IPI directly.
        //

        ASSERT((Affinity & 0xFF) == Affinity);
        HalpSendIpiWorker((UCHAR)Affinity,Command);

    } else {

        //
        // Send an IPI to one or mode nodes.
        //

        HalpSendNodeIpi(Affinity,Command);
    }

    //
    // Stall until the last IPI has been sent, restore interrupts and
    // return.
    //

    HalpStallWhileApicBusy();
    HalpRestoreInterrupts(flags);
}

VOID
HalInitializeProcessor(
    ULONG ProcessorNumber,
    PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    Initialize hal pcr values for current processor (if any)
    (called shortly after processor reaches kernel, before
    HalInitSystem if P0)

    IPI's and KeReadir/LowerIrq's must be available once this function
    returns.  (IPI's are only used once two or more processors are
    available)

   . Enable IPI interrupt (makes sense for P1, P2, ...).
   . Save Processor Number in PCR.
   . if (P0)
       . determine if the system is a PC+MP,
       . if not a PC+MP System Halt;
   . Enable IPI's on CPU.

Arguments:

    Number - Logical processor number of calling processor

Return Value:

    None.

--*/

{
    PKPCR pcr;
    KAFFINITY affinity;
    KAFFINITY oldAffinity;
    ULONG detectAcpiResult;
    BOOLEAN isMp;

    affinity = (KAFFINITY)1 << ProcessorNumber;
    pcr = KeGetPcr();

    //
    // Mark all interrupts as disabled, and store the processor number and
    // the default stall scale factor in the pcr.
    //

    pcr->Idr = 0xFFFFFFFF;
    pcr->Number = (UCHAR)ProcessorNumber;
    pcr->StallScaleFactor = INITIAL_STALL_COUNT;

    //
    // Record the pcr pointer in our lookup table and set the affinity
    // bit in our set of active processors.
    // 

    HalpProcessorPCR[ProcessorNumber] = pcr;
    HalpActiveProcessors |= affinity;

    if (HalpStaticIntAffinity == 0) {

        //
        // Interrupts can go to any processor
        //

        HalpDefaultInterruptAffinity |= affinity;

    } else {

        //
        // Interrupts go only to the highest numbered processor
        //

        if (HalpDefaultInterruptAffinity < affinity) {
            HalpDefaultInterruptAffinity = affinity;
        }
    }

    if (ProcessorNumber == 0) {

        KeInitializeSpinLock(&HalpBroadcastLock);

#if LogApicErrors

        KeInitializeSpinLock(&HalpLocalApicErrorLock);

#endif

        //
        // Determine whether the system we are on is an MPS system.
        //
        // DetectMPS has a parameter we don't currently use.  It's a boolean
        // which is set to TRUE if the system we're on is an MP system.
        // We could have a UP MPS system.
        //
        // The DetectMPS routine also allocates virtual addresses for all of
        // the APICs in the system.
        //

#if defined(ACPI_HAL)
        detectAcpiResult = DetectAcpiMP(&isMp,LoaderBlock);
#else
        detectAcpiResult = DetectMPS(&isMp);
#endif
        if (detectAcpiResult == FALSE) {
            HalDisplayString(rgzBadHal);

            HalpDisableInterrupts();
            while (TRUE) {
                HalpHalt();
            }
        }

        HalpRegisterKdSupportFunctions(LoaderBlock);

        //
        // Mask all PIC interrupts
        //

        HalpGlobal8259Mask = 0xFFFF;
        SET_8259_MASK(HalpGlobal8259Mask);
    }

    //
    // All processors execute this code
    //

    HalInitApicInterruptHandlers();
    HalpInitializeLocalUnit();
}

VOID
HalInitApicInterruptHandlers(
    VOID
    )

/*++

Routine Description:

    This routine installs the interrupt vector in the IDT for the APIC
    spurious interrupt.

Arguments:

    None.

Return Value:

    None.

--*/

{
    PKPCR pcr;
    PKIDTENTRY64 idt;

    KiSetHandlerAddressToIDTIrql(PIC1_SPURIOUS_VECTOR,
                                 PicSpuriousService37,
                                 NULL,
                                 0);

    KiSetHandlerAddressToIDTIrql(APIC_SPURIOUS_VECTOR,
                                 HalpApicSpuriousService,
                                 NULL,
                                 0);
}

__forceinline
VOID
HalpPollForBroadcast (
    VOID
    )

/*++

Routine Description:

    Checks whether the current processor has a broadcast function pending
    and, if so, clears it's pending bit and calls the function.

Arguments:

    None.

Return Value:

    None.

--*/

{
    KAFFINITY affinity;
    ULONG_PTR broadcastContext;
    HAL_GENERIC_IPI_FUNCTION broadcastFunction;
    KAFFINITY broadcastTargets;

    affinity = KeGetPcr()->CurrentPrcb->SetMember;
    if ((HalpBroadcastTargets & affinity) != 0) {

        //
        // A pending generic IPI call appears to be pending for this
        // processor.  Pick up the function pointer and context locally.
        //

        broadcastFunction = HalpBroadcastFunction;
        broadcastContext = HalpBroadcastContext;

        //
        // Atomically acknowledge the broadcast.  If the broadcast is still
        // pending for this processor, then call it.
        //

        // BUGBUG
        // broadcastTargets = InterlockedAnd64(&HalpBroadcastTargets,~affinity);
        broadcastTargets &= ~affinity;
        if ((broadcastTargets & affinity) != 0) {
            broadcastFunction(broadcastContext);
        }
    }
}

VOID
HalpGenericCall(
    IN HAL_GENERIC_IPI_FUNCTION BroadcastFunction,
    IN ULONG Context,
    IN KAFFINITY TargetProcessors
    )

/*++

Routine Description:

    Causes the WorkerFunction to be called on the specified target
    processors.  The WorkerFunction is called at CLOCK2_LEVEL-1
    (Must be below IPI_LEVEL in order to prevent system deadlocks).

Enviroment:

    Must be called with interrupts enabled.
    Must be called with IRQL = CLOCK2_LEVEL-1

--*/

{
    //
    // Nothing to do if no target processors have been specified.
    //

    if (TargetProcessors == 0) {
        return;
    }

    //
    // Acquire the broadcast lock, polling for broadcasts while spinning.
    //

    while (KeTryToAcquireSpinLockAtDpcLevel(&HalpBroadcastLock) == FALSE) {
        do {
            HalpPollForBroadcast();
        } while (KeTestSpinLock(&HalpBroadcastLock) == FALSE);
    }

    //
    // We own the broadcast lock.  Store the broadcast parameters
    // into the broadcast prameters and send the generic IPI.
    //

    HalpBroadcastFunction = BroadcastFunction;
    HalpBroadcastContext = Context;
    HalpBroadcastTargets = TargetProcessors;
    HalpSendIpi(TargetProcessors,GENERIC_IPI);

    //
    // Wait for all processors to pick up the IPI and process the generic
    // call, then release the broadcast lock.
    // 

    do {
        HalpPollForBroadcast();
    } while (HalpBroadcastTargets != 0);

    KeReleaseSpinLockFromDpcLevel(&HalpBroadcastLock);
}


ULONG
HalpWaitForPending (
    IN ULONG Count,
    IN ULONG volatile *ICR
    )

/*++

Routine Description:

    Spins waiting for the DELIVERY_PENDING bit in the ICR to clear or
    until spinning Count times.

Arguments:

    Count - Number of times through the loop before giving up.

    ICR - Pointer to the ICR register containing the DELIVERY_PENDING
          status bit.

Return Value:

    Zero if the DELIVERY_PENDING bit has cleared within the number of
    test cycles, non-zero otherwise.

--*/

{
    ULONG countRemaining;

    countRemaining = Count;
    while (countRemaining > 0) {

        if ((*ICR & DELIVERY_PENDING) != 0) {
            break;
        }
        countRemaining -= 1;
    }

    return countRemaining;
}

VOID
HalRequestIpi (
    IN KAFFINITY Affinity
    )

/*++

Routine Description:

    Requests an interprocessor interrupt

Arguments:

    Affinity - Supplies the set of processors to be interrupted

Return Value:

    None.

--*/

{
    HalpSendIpi(Affinity,APIC_IPI);
}

BOOLEAN
HalpApicRebootService (
    IN PKINTERRUPT Interrupt,
    IN PVOID ServiceContext
    )

/*++

Routine Description:

    This is the ISR that handles Reboot interrupts.

Arguments:

    Interrupt - Supplies a pointer to the kernel interrupt object

    ServiceContext - Supplies the service context

Return Value:

    None.  This routine does not return.

--*/

{
    UNREFERENCED_PARAMETER(Interrupt);
    UNREFERENCED_PARAMETER(ServiceContext);

    LOCAL_APIC(LU_TPR) = APIC_REBOOT_VECTOR;

    //
    // EOI the local APIC.  Warm reset does not reset the 82489 APIC
    // so if we don't EOI here we'll never see an interrupt after the
    // reboot.
    //

    LOCAL_APIC(LU_EOI) = 0;

    //
    // Reset this processor.  This function will not return.
    // 

    HalpResetThisProcessor();
    ASSERT(FALSE);

    return TRUE;
}


BOOLEAN
HalpBroadcastCallService (
    IN PKINTERRUPT Interrupt,
    IN PVOID ServiceContext
    )

/*++

Routine Description:

    This is the ISR that handles broadcast call interrupts.

Arguments:

    Interrupt - Supplies a pointer to the kernel interrupt object

    ServiceContext - Supplies the service context

Return Value:

    TRUE

--*/

{
    UNREFERENCED_PARAMETER(Interrupt);
    UNREFERENCED_PARAMETER(ServiceContext);

    HalpPollForBroadcast();
    return TRUE;
}

BOOLEAN
HalpIpiHandler (
    IN PKINTERRUPT Interrupt,
    IN PVOID ServiceContext
    )

/*++

Routine Description:

    This routine is entered as the result of an interrupt generated by
    interprocessor communication.

Arguments:

    Interrupt - Supplies a pointer to the kernel interrupt object

    ServiceContext - Supplies the service context

Return Value:

    TRUE

--*/

{
    UNREFERENCED_PARAMETER(Interrupt);

    KiIpiServiceRoutine(Interrupt->TrapFrame,NULL);

    return TRUE;
}

BOOLEAN
HalpLocalApicErrorService (
    IN PKINTERRUPT Interrupt,
    IN PVOID ServiceContext
    )

/*++

Routine Description:

    This routine is entered as the result of an interrupt generated by
    a local apic error.  It clears the error and, if apic error logging
    is turned on, records information about the error.

Arguments:

    Interrupt - Supplies a pointer to the kernel interrupt object

    ServiceContext - Supplies the service context

Return Value:

    TRUE

--*/

{
    ULONG flags;
    PAPIC_ERROR apicError;
    ULONG index;
    ULONG errorStatus;
    PKPCR pcr;

#if LogApicErrors

    //
    // Take the apic error log lock, get a pointer to the next available
    // error log slot, and increment the error count.
    //

    flags = HalpAcquireHighLevelLock(&HalpLocalApicErrorLock);

    index = HalpLocalApicErrorCount % APIC_ERROR_LOG_SIZE;
    apicError = &HalpApicErrorLog[index];
    HalpLocalApicErrorCount += 1;

#endif

    //
    // The Apic EDS (Rev 4.0) says you have to write before you read.
    // This doesn't work.  The write clears the status bits, but the P6 works
    // according to the EDS.
    //
    // For AMD64, for now assume that things work according to the EDS spec.
    //

    LOCAL_APIC(LU_ERROR_STATUS) = 0;
    errorStatus = LOCAL_APIC(LU_ERROR_STATUS);

#if LogApicErrors

    //
    // Fill in the error log and release the apic error log lock.
    //

    pcr = KeGetPcr();
    apicError->AsByte = (UCHAR)errorStatus;
    apicError->Processor = pcr->Number;

    HalpReleaseHighLevelLock(&HalpLocalApicErrorLock,flags);

#endif

    return TRUE;
}


BOOLEAN
PicNopHandlerInt (
    IN PKINTERRUPT Interrupt,
    IN PVOID Context
    )

/*++

Routine Description:

    This handler is designed to be installed on a system to field any PIC
    interrupts when there are not supposed to be any delivered.

    This routine EOIs the PIC and returns.

Arguments:

    Interrupt - Supplies a pointer to the kernel interrupt object

    ServiceContext - Supplies the service context

Return Value:

    TRUE

--*/

{
    UCHAR irq;

    AMD64_COVERAGE_TRAP();

    //
    // Context is the PIC IRQ
    //

    ASSERT((ULONG_PTR)Context <= 15);

    irq = (UCHAR)(ULONG_PTR)(Context);
    if (irq <= 7) {

        WRITE_PORT_UCHAR(PIC1_PORT0,irq | OCW2_SPECIFIC_EOI);

    } else {

        if (irq == 0x0D) {
            WRITE_PORT_UCHAR(I386_80387_BUSY_PORT, 0);
        }

        WRITE_PORT_UCHAR(PIC2_PORT0,OCW2_NON_SPECIFIC_EOI);
        WRITE_PORT_UCHAR(PIC1_PORT0,OCW2_SPECIFIC_EOI | PIC_SLAVE_IRQ);
    }

    return TRUE;
}


BOOLEAN
PicInterruptHandlerInt (
    IN PKINTERRUPT Interrupt,
    IN PVOID Context
    )

/*++

Routine Description:

    These handlers receive interrupts from the PIC and reissues them via a
    vector at the proper priority level.  This is used to provide a symetric
    interrupt distribution on a non symetric system.
 
    The PIC interrupts will normally only be received (in the PC+MP Hal) via
    an interrupt input from on either the IO Unit or the Local unit which has
    been programed as EXTINT.  EXTINT interrupts are received outside of the
    APIC priority structure (the PIC provides the vector).  We use the APIC
    ICR to generate interrupts to the proper handler at the proper priority.
 
    The EXTINT interrupts are directed to a single processor, currently P0.
    There is no good reason why they can't be directed to another processor.
 
    Since one processor must absorb the overhead of redistributing PIC
    interrupts the interrupt handling on a system using EXTINT interrupts is
    not symetric.
 
Arguments:

    Interrupt - Supplies a pointer to the kernel interrupt object

    ServiceContext - Supplies the service context

Return Value:

    TRUE

--*/

{
    UCHAR irq;
    UCHAR isrRegister;
    UCHAR ipiVector;

    AMD64_COVERAGE_TRAP();

    //
    // Context is the PIC IRQ
    //

    ASSERT((ULONG_PTR)Context <= 15);

    irq = (UCHAR)(ULONG_PTR)(Context);
    if (irq == 7) {

        //
        // Check to see if this is a spurious interrupt
        //

        WRITE_PORT_UCHAR(PIC1_PORT0,OCW3_READ_ISR);
        IO_DELAY();
        isrRegister = READ_PORT_UCHAR(PIC1_PORT0);
        if ((isrRegister & 0x80) == 0) {

            //
            // Spurious.
            //

            return TRUE;
        }
    }

    if (irq == 0x0D) {

        WRITE_PORT_UCHAR(I386_80387_BUSY_PORT,0);

    } else if (irq == 0x1F) {

        WRITE_PORT_UCHAR(PIC2_PORT0,OCW3_READ_ISR);
        IO_DELAY();
        isrRegister = READ_PORT_UCHAR(PIC2_PORT0);
        if ((isrRegister & 0x80) == 0) {

            //
            // Spurious.
            //

            return TRUE;
        }
    }

    if (irq <= 7) {

        //
        // Master PIC
        //

        WRITE_PORT_UCHAR(PIC1_PORT0,irq | OCW2_SPECIFIC_EOI);

    } else {

        //
        // Slave PIC
        //

        WRITE_PORT_UCHAR(PIC2_PORT0,OCW2_NON_SPECIFIC_EOI);
        WRITE_PORT_UCHAR(PIC1_PORT0,OCW2_SPECIFIC_EOI | PIC_SLAVE_IRQ);
    }

    ipiVector = HalpPICINTToVector[irq];

    if (ipiVector != 0) {

        HalpStallWhileApicBusy();
        if (irq == 8) {

            //
            // Clock interrupt
            //

            LOCAL_APIC(LU_INT_CMD_LOW) =
                DELIVER_FIXED | ICR_SELF | APIC_CLOCK_VECTOR;

        } else {

            //
            // Write the IPI command to the Memory Mapped Register
            //

            LOCAL_APIC(LU_INT_CMD_HIGH) = DESTINATION_ALL_CPUS;
            LOCAL_APIC(LU_INT_CMD_LOW) = ipiVector;
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\amd64\mpsproca.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    mpclock.c

Abstract:

    This module implements processor starup code.

Author:

    Forrest Foltz (forrestf) 27-Oct-2000

Environment:

    Kernel mode only.

Revision History:

--*/


#include "halcmn.h"
#include <acpitabl.h>
#include <xxacpi.h>
#include <ixsleep.h>

#if !defined(NT_UP)

//
// Pull in the real- and 32-bit protected-mode object code
//

#include "pmstub.h"
#include "rmstub.h"

extern UCHAR HalpLMStub[];
extern UCHAR HalpLMStubEnd[];
extern UCHAR HalpLMStubTarget[];


#endif

extern BOOLEAN HalpHiberInProgress;
extern PUCHAR Halp1stPhysicalPageVaddr;

#define WARM_RESET_VECTOR   0x467   // warm reset vector in ROM data segment
#define CMOS_SHUTDOWN_REG   0x0f
#define CMOS_SHUTDOWN_JMP   0x0a

#define _20BITS (1 << 20)

ULONG
HalpStartProcessor (
    IN PVOID InitCodePhysAddr,
    IN ULONG ProcessorNumber
    );

VOID
HalpBuildKGDTEntry32 (
    IN PKGDTENTRY64 Gdt,
    IN ULONG Selector,
    IN ULONG Base,
    IN ULONG Limit,
    IN ULONG Type,
    IN BOOLEAN LongMode
    );

BOOLEAN
HalStartNextProcessor (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN PKPROCESSOR_STATE ProcessorState
    )

/*++

Routine Description:

    This routine is called by the kernel during kernel initialization to
    obtain more processors.  It is called until no more processors are
    available.

    If another processor exists this function is to initialize it to the
    passed in processor state structure, and return TRUE.

    If another processor does not exist or if the processor fails to start,
    then FALSE is returned.

    Also note that the loader block has been set up for the next processor.
    The new processor logical thread number can be obtained from it if
    required.

    In order to use the Startup IPI the real mode startup code must be page
    aligned.  The HalpLowStubPhysicalAddress has always been page aligned
    but because the PxParamBlock was placed first in this segment the real
    mode code has been something other than page aligned.  THis has been
    changed by making the first entry in the PxParamBlock a jump instruction
    to the real mode startup code.

Arguments:

    LoaderBlock - A pointer to the loader block which has been initialized
                  for the next processor.

    ProcessorState - A pointer to a structure which containts the initial
                     state of the processor.

Return Value:

    TRUE - ProcessorNumber was dispatched.

    FALSE - A processor was not dispatched, or no other processor exists.

--*/

{

#if defined(NT_UP)

    return FALSE;

#else

    C_ASSERT(PSB_GDT32_CODE64 == KGDT64_R0_CODE);

    ULONG cr3;
    PPROCESSOR_START_BLOCK startupBlock;
    ULONG __unaligned *resetVectorLocation;
    ULONG oldResetVector;
    ULONG newResetVector;
    UCHAR cmosValue;
    PKPRCB prcb;
    ULONG apicId;
    ULONG count;
    PVOID pmStubStart;
    ULONG startupBlockPhysical;
    PVOID pmStub;
    PCHAR dst;

    return FALSE;

    //
    // Initialize the startup block
    //

    startupBlock = (PPROCESSOR_START_BLOCK)HalpLowStub;
    startupBlockPhysical = PtrToUlong(HalpLowStubPhysicalAddress);
    startupBlock->SelfMap = startupBlock;

    //
    // Copy the x86 16-bit real-mode startup code.
    //

    dst = (PCHAR)startupBlock;
    RtlCopyMemory(dst, HalpRMStub, HalpRMStubSize);

    //
    // Copy the x86 32-bit protected-mode startup code and set PmTarget.
    //

    dst += HalpRMStubSize;
    RtlCopyMemory(dst, HalpPMStub, HalpPMStubSize);

    startupBlock->PmTarget.Selector = PSB_GDT32_CODE32;
    startupBlock->PmTarget.Offset =
        (ULONG)(dst - (PUCHAR)startupBlock) + startupBlockPhysical;

    //
    // Copy the AMD64 longmode startup code and set LmTarget.
    //

    startupBlock->LmTarget.Selector = PSB_GDT32_CODE64;
    startupBlock->LmTarget.Offset = (ULONG64)&HalpLMStub;

    //
    // Build the temporary GDT entries to be used while in 32-bit
    // protected mode
    //

    HalpBuildKGDTEntry32(startupBlock->Gdt,
                         PSB_GDT32_CODE32,
                         0,
                         (ULONG)(-1),
                         TYPE_CODE,
                         FALSE);

    HalpBuildKGDTEntry32(startupBlock->Gdt,
                         PSB_GDT32_DATA32,
                         0,
                         (ULONG)(-1),
                         TYPE_DATA,
                         FALSE);

    //
    // Build the temporary code selector GDT entry to be used while in long
    // mode.
    //

    HalpBuildKGDTEntry32(startupBlock->Gdt,
                         PSB_GDT32_CODE64,
                         0,             // base and limit are ignored in 
                         0,             // a long-mode CS selector
                         TYPE_CODE,
                         TRUE);


    //
    // Build the pseudo-descriptor for the GDT
    //

    startupBlock->Gdt32.Limit = sizeof(startupBlock->Gdt) - 1;
    startupBlock->Gdt32.Base =
        startupBlockPhysical + FIELD_OFFSET(PROCESSOR_START_BLOCK,Gdt);

    //
    // Build a CR3 for the starting processor.  If returning from
    // hibernation, then use setup tiled CR3 else create a new map.
    //

    if (HalpHiberInProgress == FALSE) {
        startupBlock->TiledCr3 = HalpBuildTiledCR3(ProcessorState);
    } else {
        startupBlock->TiledCr3 = CurTiledCr3LowPart;
    }

    //
    // Copy in the processor state and the linear address of the startup
    // block, and zero the completionflag.
    //

    startupBlock->ProcessorState = *ProcessorState;
    startupBlock->CompletionFlag = 0;

    //
    // The reset vector lives in the BIOS data area.  Build a pointer to it
    // and store the existing value locally.
    //

    resetVectorLocation = (PULONG)((PUCHAR)Halp1stPhysicalPageVaddr +
                                   WARM_RESET_VECTOR);
    oldResetVector = *resetVectorLocation;

    //
    // Build the new real-mode vector in SEG:OFFS format and store it in the
    // BIOS data area.
    //

    newResetVector = PtrToUlong(HalpLowStubPhysicalAddress);
    newResetVector <<= 12;
    *resetVectorLocation = newResetVector;

    //
    // Tell the BIOS to jump via the vector we gave it by setting the
    // reset code in the cmos
    //

    HalpAcquireCmosSpinLock();
    cmosValue = CMOS_READ(CMOS_SHUTDOWN_REG);
    CMOS_WRITE(CMOS_SHUTDOWN_REG,CMOS_SHUTDOWN_JMP);
    HalpReleaseCmosSpinLock();

    prcb = (PKPRCB)LoaderBlock->Prcb;
    apicId = HalpStartProcessor(HalpLowStubPhysicalAddress, prcb->Number);

#if 0   // later

    if (apicId != 0) {

        apicId -= 1;
        prcb->HalReserved.PCMPApicId = apicId;
    }

    for (count = 0; count < 200; count += 1) {

        if (startupBock->
    }

#endif

    return FALSE;

#endif  // NT_UP

}

VOID
HalpBuildKGDTEntry32 (
    IN PKGDTENTRY64 Gdt,
    IN ULONG Selector,
    IN ULONG Base,
    IN ULONG Limit,
    IN ULONG Type,
    IN BOOLEAN LongMode
    )
{
    KGDT_BASE base;
    KGDT_LIMIT limit;
    PKGDTENTRY64 gdtEntry;

    gdtEntry = &Gdt[Selector >> 4];

    //
    // Note that although gdtEntry points to a 16-byte structure,
    // we're actually building an 8-byte GDT so we are careful to not
    // touch the high 8 bytes.
    // 

    RtlZeroMemory(gdtEntry, 8);

    //
    // Set limit information
    //  

    if (Limit > (_20BITS - 1)) {
        gdtEntry->Bits.Granularity = GRANULARITY_PAGE;
        limit.Limit = Limit / PAGE_SIZE;
    } else {
        limit.Limit = Limit;
    }

    gdtEntry->LimitLow = limit.LimitLow;
    gdtEntry->Bits.LimitHigh = limit.LimitHigh;

    //
    // Set base information
    //

    base.Base = Base;
    gdtEntry->BaseLow = base.BaseLow;
    gdtEntry->Bits.BaseMiddle = base.BaseMiddle;
    gdtEntry->Bits.BaseHigh = base.BaseHigh;

    //
    // Set other bits
    //

    gdtEntry->Bits.Present = 1;
    gdtEntry->Bits.Dpl = DPL_SYSTEM;
    gdtEntry->Bits.DefaultBig = 1;
    gdtEntry->Bits.Type = Type;

    if (LongMode != FALSE) {
        gdtEntry->Bits.LongMode = 1;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\amd64\picinit.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    picinit.c

Abstract:

    This module implements pic initialization code.

Author:

    Forrest Foltz (forrestf) 1-Dec-2000

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halcmn.h"

VOID
HalpInitialize8259Tables (
    VOID
    );

VOID
HalpInitializeIrqlTables (
    VOID
    );

VOID
HalpInitializePICs (
    IN BOOLEAN EnableInterrupts
    )

/*++

Routine Description:

    This routine sends the 8259 PIC initialization commands and masks all
    the interrupts on 8259s.

Parameters:

    EnableInterupts - Indicates whether interrupts should be explicitly
                      enabled just before returning.

Return Value:

    Nothing.

--*/

{
    ULONG flags;

#if defined(PICACPI)

    //
    // Build the irq<->IRQL mapping tables
    //

    HalpInitialize8259Tables();

#else

    //
    // Build the vector <-> INTI tables
    //

    HalpInitializeIrqlTables();

#endif

    flags = HalpDisableInterrupts();

    //
    // First, program the master pic with ICW1 through ICW4
    // 

    WRITE_PORT_UCHAR(PIC1_PORT0,
                     ICW1_ICW +
                     ICW1_EDGE_TRIG +
                     ICW1_INTERVAL8 +
                     ICW1_CASCADE +
                     ICW1_ICW4_NEEDED);

    WRITE_PORT_UCHAR(PIC1_PORT1,
                     PIC1_BASE);

    WRITE_PORT_UCHAR(PIC1_PORT1,
                     1 << PIC_SLAVE_IRQ);

    WRITE_PORT_UCHAR(PIC1_PORT1,
                     ICW4_NOT_SPEC_FULLY_NESTED + 
                     ICW4_NON_BUF_MODE + 
                     ICW4_NORM_EOI + 
                     ICW4_8086_MODE);

    //
    // Mask all irqs on the master
    // 

    WRITE_PORT_UCHAR(PIC1_PORT1,0xFF);

    //
    // Next, program the slave pic with ICW1 through ICW4
    //

    WRITE_PORT_UCHAR(PIC2_PORT0,
                     ICW1_ICW +
                     ICW1_EDGE_TRIG +
                     ICW1_INTERVAL8 +
                     ICW1_CASCADE +
                     ICW1_ICW4_NEEDED);

    WRITE_PORT_UCHAR(PIC2_PORT1,
                     PIC2_BASE);

    WRITE_PORT_UCHAR(PIC2_PORT1,
                     PIC_SLAVE_IRQ);

    WRITE_PORT_UCHAR(PIC2_PORT1,
                     ICW4_NOT_SPEC_FULLY_NESTED + 
                     ICW4_NON_BUF_MODE + 
                     ICW4_NORM_EOI + 
                     ICW4_8086_MODE);

    //
    // Mask all IRQs on the slave
    //

    WRITE_PORT_UCHAR(PIC2_PORT1,0xFF);

    if (EnableInterrupts != FALSE) {
        HalpEnableInterrupts();
    } else {
        HalpRestoreInterrupts(flags);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\amd64\pmrtc.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    pmrtc.c

Abstract:

    This module implements the code for ACPI-related RTC functions.

Author:
 
    Jake Oshins (jakeo) March 28, 1997
 
Environment:
 
    Kernel mode only.
 
Revision History:
 
    Split from pmclock.asm due to PIIX4 bugs.

    Forrest Foltz (forrestf) 24-Oct-2000
        Ported from pmrtc.asm to pmrtc.c
 
--*/

#include <halp.h>
#include <acpitabl.h>
#include <xxacpi.h>
#include "io_cmos.h"

VOID
HalpInitializeCmos (
    VOID
    )

/*++

Routine Description

    This routine reads CMOS and initializes globals required for CMOS access,
    such as the location of the century byte.

Arguments

    None

Return Value

    None

--*/

{
    UCHAR centuryAlarmIndex;

    //
    // If the century byte is filled in, use it... otherwise assume
    // a default value.
    //

    centuryAlarmIndex = HalpFixedAcpiDescTable.century_alarm_index;
    if (centuryAlarmIndex == 0) {
        centuryAlarmIndex = RTC_OFFSET_CENTURY;
    }

    HalpCmosCenturyOffset = centuryAlarmIndex;
}

NTSTATUS
HalpSetWakeAlarm (
    IN ULONG64 WakeSystemTime,
    IN PTIME_FIELDS WakeTimeFields
    )

/*++

Routine Description:

    This routine sets the real-time clock's alarm to go
    off at a specified time in the future and programs
    the ACPI chipset so that this wakes the computer.

Arguments:

    WakeSystemTime - amount of time that passes before we wake
    WakeTimeFields - time to wake broken down into TIME_FIELDS

Return Value:

    status

--*/

{
    UCHAR alarmPort;
    UCHAR value;

    HalpAcquireCmosSpinLockAndWait();

    CMOS_WRITE_BCD(RTC_OFFSET_SECOND_ALARM,(UCHAR)WakeTimeFields->Second);
    CMOS_WRITE_BCD(RTC_OFFSET_MINUTE_ALARM,(UCHAR)WakeTimeFields->Minute);
    CMOS_WRITE_BCD(RTC_OFFSET_HOUR_ALARM,(UCHAR)WakeTimeFields->Hour);

    alarmPort = HalpFixedAcpiDescTable.day_alarm_index;
    if (alarmPort != 0) {

        CMOS_WRITE_BCD(alarmPort,(UCHAR)WakeTimeFields->Day);
        alarmPort = HalpFixedAcpiDescTable.month_alarm_index;
        if (alarmPort != 0) {
            CMOS_WRITE_BCD(alarmPort,(UCHAR)WakeTimeFields->Month);
        }
    }

    //
    // Enable the alarm.  Be sure to preserve the daylight savings time
    // bit.
    //

    value = CMOS_READ(CMOS_STATUS_B);
    value &= REGISTER_B_DAYLIGHT_SAVINGS_TIME;
    value |= REGISTER_B_ENABLE_ALARM_INTERRUPT | REGISTER_B_24HOUR_MODE;

    CMOS_WRITE(CMOS_STATUS_B,value);
    CMOS_READ(CMOS_STATUS_C);
    CMOS_READ(CMOS_STATUS_D);

    HalpReleaseCmosSpinLock();

    return STATUS_SUCCESS;
}

VOID
HalpSetClockBeforeSleep (
   VOID
   )

/*++

Routine Description:

   This routine sets the RTC such that it will not generate
   periodic interrupts while the machine is sleeping, as this
   could be interpretted as an RTC wakeup event.

Arguments:

Return Value:

   None

--*/

{
    UCHAR value;

    HalpAcquireCmosSpinLock();

    HalpRtcRegA = CMOS_READ(CMOS_STATUS_A);
    HalpRtcRegB = CMOS_READ(CMOS_STATUS_B);

    value = HalpRtcRegB & ~REGISTER_B_ENABLE_PERIODIC_INTERRUPT;
    value |= REGISTER_B_24HOUR_MODE;
    CMOS_WRITE(CMOS_STATUS_B,value);

    CMOS_READ(CMOS_STATUS_C);
    CMOS_READ(CMOS_STATUS_D);

    HalpReleaseCmosSpinLock();
}

VOID
HalpSetClockAfterSleep (
   VOID
   )

/*++

Routine Description:

   This routine sets the RTC back to the way it was
   before a call to HalpSetClockBeforeSleep.

Arguments:

Return Value:

   None

--*/

{
    UCHAR value;

    HalpAcquireCmosSpinLock();

    CMOS_WRITE(CMOS_STATUS_A,HalpRtcRegA);

    value = HalpRtcRegB;
    value &= ~REGISTER_B_ENABLE_ALARM_INTERRUPT;
    value |= REGISTER_B_24HOUR_MODE;
    CMOS_WRITE(CMOS_STATUS_B,value);

    CMOS_READ(CMOS_STATUS_C);
    CMOS_READ(CMOS_STATUS_D);

    HalpReleaseCmosSpinLock();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\amd64\pmstall.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    pmstall.c

Abstract:

    This module implements the code necessary to implement the
    Halp...StallExecution() routines for the ACPI HAL.

Author:

    Shie-Lin Tzong (shielint) 12-Jan-1990

Environment:

    Kernel mode only.

Revision History:

    bryanwi 20-Sep-90

        Add KiSetProfileInterval, KiStartProfileInterrupt,
        KiStopProfileInterrupt procedures.
        KiProfileInterrupt ISR.
        KiProfileList, KiProfileLock are delcared here.

    shielint 10-Dec-90
        Add performance counter support.
        Move system clock to irq8, ie we now use RTC to generate system
          clock.  Performance count and Profile use timer 1 counter 0.
          The interval of the irq0 interrupt can be changed by
          KiSetProfileInterval.  Performance counter does not care about the
          interval of the interrupt as long as it knows the rollover count.
        Note: Currently I implemented 1 performance counter for the whole
        i386 NT.
 
    John Vert (jvert) 11-Jul-1991
        Moved from ke\i386 to hal\i386.  Removed non-HAL stuff
 
    shie-lin tzong (shielint) 13-March-92
        Move System clock back to irq0 and use RTC (irq8) to generate
        profile interrupt.  Performance counter and system clock use time1
        counter 0 of 8254.
 
    Landy Wang (corollary!landy) 04-Dec-92
        Created this module by moving routines from ixclock.asm to here.

    Forrest Foltz (forrestf) 24-Oct-2000
        Ported from pmstall.asm to pmstall.c

--*/

#include "halcmn.h"

ULONG64 HalpStallLoopsPerTick = 3;

LARGE_INTEGER
(*QueryTimer)(VOID);


VOID
HalpInitializeStallExecution (
   IN CCHAR ProcessorNumber                                
   )

/*++

 Routine Description:

    This routine is obsolete in this HAL.

 Arguments:

    ProcessorNumber - Processor Number

 Return Value:

    None.

--*/

{
    return;
}


VOID
HalpAcpiTimerStallExecProc(
    IN ULONG MicroSeconds
    )

/*++

Routine Description:

    This function stalls execution for the specified number of microseconds.
    KeStallExecutionProcessor

Arguments:

    MicroSeconds - Supplies the number of microseconds that execution is to be
        stalled.

Return Value:

    None.

--*/

{
    ULONG stallTicks;
    ULONG64 currentTime;
    ULONG64 targetTime;

    PROCESSOR_FENCE;

    if (MicroSeconds == 0) {
        return;
    }

    //
    // Target is in microseconds, or 1MHz.  Convert to PM_TMR_FREQ,
    // which is a colorburst crystal (3,579,545 Hz).
    //

    stallTicks = (ULONG)(((ULONG64)MicroSeconds * PM_TMR_FREQ) / 1000000);

    //
    // Determine the target time and loop until it is reached.
    //
    // ******fixfix
    //
    // The code in pmstall.asm has an inner loop that does not call
    // QueryTimer(), presumably to minimize calls to that routine.
    // Investigate further.
    //
    // ******fixfix
    // 

    currentTime = QueryTimer().QuadPart;
    targetTime = currentTime + stallTicks;

    while (currentTime < targetTime) {
        currentTime = QueryTimer().QuadPart;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\amd64\pmtimer.c ===
/*++

Copyright (c) 2000 Microsoft Corporation

Module Name:

    pmtimer.c

Abstract:

    This module implements the code for ACPI-related timer
    functions.

Author:

    Jake Oshins (jakeo) March 28, 1997

Environment:

    Kernel mode only.

Revision History:

    Split from pmclock.asm due to PIIX4 bugs.

    Forrest Foltz (forrestf) 23-Oct-2000
        Ported from pmtimer.asm to pmtimer.c

--*/

#include <halp.h>
#include <ntacpi.h>

//
// HalpCurrentTime is the value of the hardware timer.  It is updated at
// every timer tick.
//

volatile ULONG64 HalpCurrentTime;

//
// HalpHardwareTimeRollover represents the maximum count + 1 of the
// hardware timer.
//
// The hardware is either 24- or 32-bits.  HalpHardwareTimeRollover will
// therefore have a vale of either 0x1000000 or 0x100000000.
//
// ACPI generates an interrupt whenever the MSb of the hardware timer
// changes.
//

ULONG64 HalpHardwareTimeRollover;

ULONG64 HalpTimeBias;

//
// HalpCurrentTimePort is the port number of the 32-bit hardware timer.
//

ULONG HalpCurrentTimePort;

#if DBG
UCHAR TimerPerf[4096];
ULONG TimerPerfIndex = 0;
#endif

#define MSBMASK24   0x00800000
#define MSBMASK32   0x80000000

ULONG TimerInfo[] = {
    0,
    0,
    0,
    0,
    MSBMASK24,
    0,
    0,
    0,
    2,
    2 };

ULONG64
HalpQueryPerformanceCounter (
    VOID
    )
{
    ULONG64 currentTime;
    ULONG hardwareTime;
    ULONG lastHardwareTime;

    //
    // Get a local copy of HalpCurrentTime and the value of the hardware
    // timer, in that order.
    //

    currentTime = HalpCurrentTime;
    hardwareTime = READ_PORT_ULONG(UlongToPtr(HalpCurrentTimePort));

    //
    // Extract the hardware portion of the currentTime.
    //

    lastHardwareTime = (ULONG)(currentTime & (HalpHardwareTimeRollover - 1));

    //
    // Replace the lastHardwareTime component of currentTime with the
    // current hardware time.
    //

    currentTime ^= lastHardwareTime;
    currentTime |= hardwareTime;

    //
    // Check and compensate for hardware timer rollover
    // 

    if (lastHardwareTime > hardwareTime) {
        currentTime += HalpHardwareTimeRollover;
    }

    return currentTime;
}

LARGE_INTEGER
HalpAcpiTimerQueryPerfCount (
   OUT PLARGE_INTEGER PerformanceFrequency OPTIONAL
   )

/*++

Routine Description:

   This routine returns current 64-bit performance counter and,
   optionally, the Performance Frequency.

   N.B. The performace counter returned by this routine is
   not necessary the value when this routine is just entered.
   The value returned is actually the counter value at any point
   between the routine is entered and is exited.

Arguments:

   PerformanceFrequency - optionally, supplies the address of a variable
       variable to receive the performance counter frequency.

Return Value:

   Current value of the performance counter will be returned.

--*/

{
    LARGE_INTEGER time;

    if (PerformanceFrequency != NULL) {
        PerformanceFrequency->QuadPart = PM_TMR_FREQ;
    }
    time.QuadPart = HalpQueryPerformanceCounter() + HalpTimeBias;

    return time;
}


VOID
HalAcpiTimerCarry (
   VOID
   )

/*++

Routine Description:

   This routine is called to service the PM timer carry interrupt

   N.B. This function is called at interrupt time and assumes the
   caller clears the interrupt

Arguments:

   None

Return Value:

   None

--*/

{
    ULONG hardwareTime;
    ULONG64 currentTime;
    ULONG64 halfRollover;

    currentTime = HalpCurrentTime;
    hardwareTime = READ_PORT_ULONG(UlongToPtr(HalpCurrentTimePort));

    //
    // ACPI generates an interrupt whenever the MSb of the hardware timer
    // changes.  Each interrupt represents, therefore, half a rollover.
    //

    halfRollover = HalpHardwareTimeRollover / 2;
    currentTime += halfRollover;

    //
    // Make sure the MSb of the hardware matches the software MSb.  Breaking
    // into the debugger might have gotten these out of sync.
    //

    currentTime += halfRollover & (currentTime ^ hardwareTime);

    //
    // Finally, store the new current time back into the global
    //

    HalpCurrentTime = currentTime;
}


#if 0

VOID
HalaAcpiTimerInit(
   IN ULONG    TimerPort,
   IN BOOLEAN  TimerValExt
   )
{
    HalpCurrentTimePort = TimerPort;

    if (TimerValExt) {
        HalpHardwareTimeRollover = 0x100000000;
    } else {
        HalpHardwareTimeRollover = 0x1000000;
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\amd64\x86bios.c ===
/*--
Copyright (c) 2001  Microsoft Corporation

Module Name:

    x86bios.c

Abstract:

    This is the AMD64 specific part of the video port driver

Author:

    Forrest C. Foltz (forrestf)

Environment:

    Kernel mode only

Notes:

    This module is a driver which implements OS dependent functions on
    behalf of the video drivers

Revision history:

--*/

#include "halcmn.h"
#include <xm86.h>
#include <x86new.h>

PVOID HalpIoControlBase = NULL;
PVOID HalpIoMemoryBase = (PVOID)KSEG0_BASE;
BOOLEAN HalpX86BiosInitialized = FALSE;

VOID
HalpBiosDisplayReset (
    VOID
    )

/*++

Routine Description:

    This function places the VGA display into 640 x 480 16 color mode
    by calling the BIOS.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG eax;
    ULONG exx;

    //
    // ah = function 0: reset display
    // al = mode 0x12: 640x480 16 color
    //

    eax = 0x0012;
    exx = 0;

    //
    // Simulate:
    //
    // mov ax, 0012h
    // int 10h
    //

    HalCallBios(0x10,&eax,&exx,&exx,&exx,&exx,&exx,&exx);
}


BOOLEAN
HalCallBios (
    IN ULONG BiosCommand,
    IN OUT PULONG Eax,
    IN OUT PULONG Ebx,
    IN OUT PULONG Ecx,
    IN OUT PULONG Edx,
    IN OUT PULONG Esi,
    IN OUT PULONG Edi,
    IN OUT PULONG Ebp
    )

/*++

Routine Description:

    This function provides the platform specific interface between a device
    driver and the execution of the x86 ROM bios code for the specified ROM
    bios command.

Arguments:

    BiosCommand - Supplies the ROM bios command to be emulated.

    Eax to Ebp - Supplies the x86 emulation context.

Return Value:

    A value of TRUE is returned if the specified function is executed.
    Otherwise, a value of FALSE is returned.

--*/

{
    XM86_CONTEXT context;
    XM_STATUS status;

    if (HalpX86BiosInitialized == FALSE) {
        return FALSE;
    }
 
    //                                           s
    // Copy the x86 bios context and emulate the specified command.
    //
 
    context.Eax = *Eax;
    context.Ebx = *Ebx;
    context.Ecx = *Ecx;
    context.Edx = *Edx;
    context.Esi = *Esi;
    context.Edi = *Edi;
    context.Ebp = *Ebp;

    status = x86BiosExecuteInterrupt((UCHAR)BiosCommand,
                                     &context,
                                     (PVOID)HalpIoControlBase,
                                     (PVOID)HalpIoMemoryBase);

    if (status != XM_SUCCESS) {
        return FALSE;
    }
 
    //
    // Copy the x86 bios context and return TRUE.
    //
 
    *Eax = context.Eax;
    *Ebx = context.Ebx;
    *Ecx = context.Ecx;
    *Edx = context.Edx;
    *Esi = context.Esi;
    *Edi = context.Edi;
    *Ebp = context.Ebp;
 
    return TRUE;
}

VOID
HalpInitializeBios (
    VOID
    )

/*++

Routine Description:

    This routine initializes the X86 emulation module and an attached VGA
    adapter.

Arguments:

    None.

Return Value:

    None.

--*/

{
    XM_STATUS status;

    x86BiosInitializeBios(NULL, (PVOID)KSEG0_BASE);

    status = x86BiosInitializeAdapter(0xc0000,NULL,NULL,NULL);
    if (status != XM_SUCCESS) {
        return;
    }

    HalpX86BiosInitialized = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\i386\acpi_mp.inc ===
;/*
;++
;
;   Module Name:
;
;       acpi_mp.inc
;
;   Abstract:
;
;       include file for ACPI MP systems.
;
;       WARNING: This file is included by both ASM and C files.
;
;   Author:
;
;
;--
;

if 0        ; Begin C only code         */

//
// The next structures are defined so that ntapic.h is 
// satisfied.  They are dummied up here so that halacpi
// can share code with halmps more easily.
//

typedef PVOID PPCMPPROCESSOR;
typedef PVOID PPCMPBUS;
typedef PVOID PPCMPIOAPIC;
typedef PVOID PPCMPINTI;
typedef PVOID PPCMPLINTI;
typedef PVOID PMPS_EXTENTRY;

//
// Generic NT APIC HAL stuff
//
#include "ntapic.inc"

/*
endif
;
;  Begin assembly part of the definitions
;

OEMPcr struc
        Reserved        dd      ?
OEMPcr ends

include ..\..\inc\ntapic.inc

;*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\amd64\xmstub.asm ===
title "Amd64 startup"

;++
;
; Copyright (c) 2001 Microsoft Corporation
;
; Module Name:
;
;    xmstub.asm
;
; Abstract:
;
;    This module implements the code that starts secondary processors.  This
;    module is unique in that it is assembled by the i386 32-bit assembler,
;    because the Amd64 assembler does not assemble 16- or 32-bit x86 code.
;
;    The .obj file that is the result of assembling this module is fed
;    through a tool, DMPOBJ.EXE, that stores the contents of the relevant
;    section and generates a c file (startup.c) that can be included in the
;    64-bit compilation process.
;
; Author:
;
;    Forrest Foltz (forrestf) March 6, 2001
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;--

.586p

include ksamd64.inc

RMSTUB SEGMENT DWORD PUBLIC USE16 'CODE'

;++
;
; VOID
; StartPx_RMStub
;
;   When a new processor is started, it starts in real mode and is sent to a
;   copy of this function which resides in low (<1MB) memory.
;
;   When this function is complete, it jumps to StartPx_PMStub.
;
; Arguments:
;   None
;
; Return Value:
;   Does not return, jumps to StartPx_PMStub
;--

StartPx_RMStub:

	jmp	spr10			; skip the processor start block

	db (ProcessorStartBlockLength - ($ - StartPx_RMStub)) dup (0)

spr10:  cli
	mov	ax, cs
	mov	ds, ax

	;
	; Load the 32-bit GDT.
	; 

	db	066h
	lgdt	fword ptr ds:[PsbGdt32]

	;
	; Load edi with the linear address of the processor start block.
	;

        sub	eax, eax
	mov	ax,  ds
	shl	eax, 4
	mov	edi, eax

	;
	; Enter protected mode.  Note paging is still off.
	;

	mov	eax, cr0
	or	eax, CR0_PE OR CR0_ET
	mov	cr0, eax

	;
	; Load CS by performing a far jump to the protected mode target
	; address
	; 

	db	066h
	jmp	DWORD PTR ds:[PsbPmTarget]

RMSTUB ENDS

;++
;
; VOID
; StartPx_PMStub
;
;   When a new processor is started, it starts in real mode and is sent to a
;   copy of this function which resides in low (<1MB) memory.
;
;   When this function is complete, it jumps to StartPx_PMStub.
;
; Arguments:
;   None
;
; Return Value:
;   Does not return, jumps to StartPx_LMStub
;--


PMSTUB SEGMENT PARA PUBLIC 'CODE'

StartPx_PMStub:

	;
	; 32-bit protected-mode boot code goes here.  We are still executing
	; the low-memory, identity-mapped copy of this code.
	;
	; edi -> linear address of PROCESSOR_START_BLOCK
	;

	;
	; Enable PAE mode (requisite for LongMode), load the tiled CR3
	;

	mov	eax, cr4
	or	eax, CR4_PAE
	mov	cr4, eax

	mov	eax, DWORD PTR [edi] + PsbTiledCr3
	mov	cr3, eax

	;
	; Set the long mode enable bit in the EFER msr
	;

	mov	ecx, MSR_EFER
	rdmsr
	or	eax, MSR_LMA
	wrmsr

	;
	; Enable paging and activate long mode
	;

	mov	eax, cr0
	or	eax, CR0_PG
	mov	cr0, eax

	;
	; Still in 32-bit legacy mode until we branch to a long mode
	; code selector
	;

	jmp	FAR PTR [edi] + PsbLmTarget

PMSTUB ENDS

	END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\i386\ix8259.inc ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halx86\i386\ix8259.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\i386\ixmcaa.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halx86\i386\ixmcaa.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\i386\ixipi.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halx86\i386\ixipi.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\i386\ixcmos.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

ACPI_HAL equ 1

include ..\..\halx86\i386\ixcmos.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\i386\ixcmos.inc ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halx86\i386\ixcmos.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\i386\ixbeep.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halx86\i386\ixbeep.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\i386\ixmovnti.asm ===
;
; Include code from halx86
;

include ..\..\halx86\i386\ixmovnti.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\i386\ixidle.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halx86\i386\ixidle.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\i386\ixclock.asm ===
title  "Interval Clock Interrupt"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    ixclock.asm
;
; Abstract:
;
;    This module implements the code necessary to field and process the
;    interval clock interrupt.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 12-Jan-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;   bryanwi 20-Sep-90
;
;       Add KiSetProfileInterval, KiStartProfileInterrupt,
;       KiStopProfileInterrupt procedures.
;       KiProfileInterrupt ISR.
;       KiProfileList, KiProfileLock are delcared here.
;
;   shielint 10-Dec-90
;       Add performance counter support.
;       Move system clock to irq8, ie we now use RTC to generate system
;         clock.  Performance count and Profile use timer 1 counter 0.
;         The interval of the irq0 interrupt can be changed by
;         KiSetProfileInterval.  Performance counter does not care about the
;         interval of the interrupt as long as it knows the rollover count.
;       Note: Currently I implemented 1 performance counter for the whole
;       i386 NT.
;
;   John Vert (jvert) 11-Jul-1991
;       Moved from ke\i386 to hal\i386.  Removed non-HAL stuff
;
;   shie-lin tzong (shielint) 13-March-92
;       Move System clock back to irq0 and use RTC (irq8) to generate
;       profile interrupt.  Performance counter and system clock use time1
;       counter 0 of 8254.
;
;   Landy Wang (corollary!landy) 04-Dec-92
;       Move much code into separate modules for easy inclusion by various
;       HAL builds.
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\ix8259.inc
include i386\kimacro.inc
include mac386.inc
include i386\ixcmos.inc
        .list

        EXTRNP  _KeUpdateSystemTime,0
        EXTRNP  Kei386EoiHelper,0,IMPORT
        EXTRNP  _KeSetTimeIncrement,2,IMPORT
        EXTRNP  _HalEndSystemInterrupt,2
        EXTRNP  _HalBeginSystemInterrupt,3
        EXTRNP  _HalpReleaseCmosSpinLock  ,0
        EXTRNP  _HalpMcaQueueDpc, 0
        EXTRNP  _HalpBrokenPiix4TimerTick, 0
        extrn   _HalpBrokenAcpiTimer:byte
        extrn   _QueryTimer:DWORD
        extrn   _KdEnteredDebugger:DWORD
        extrn   _HalpTimerWatchdogEnabled:DWORD
        extrn   _HalpTimerWatchdogStorage:DWORD
        extrn   _HalpTimerWatchdogCurFrame:DWORD
        extrn   _HalpTimerWatchdogLastFrame:DWORD
        extrn   _HalpTimerWatchdogStorageOverflow:DWORD

;
; Constants used to initialize timer 0
;

TIMER1_DATA_PORT0       EQU     40H     ; Timer1, channel 0 data port
TIMER1_CONTROL_PORT0    EQU     43H     ; Timer1, channel 0 control port
TIMER2_DATA_PORT0       EQU     48H     ; Timer1, channel 0 data port
TIMER2_CONTROL_PORT0    EQU     4BH     ; Timer1, channel 0 control port
TIMER1_IRQ              EQU     0       ; Irq 0 for timer1 interrupt

COMMAND_8254_COUNTER0   EQU     00H     ; Select count 0
COMMAND_8254_RW_16BIT   EQU     30H     ; Read/Write LSB firt then MSB
COMMAND_8254_MODE2      EQU     4       ; Use mode 2
COMMAND_8254_BCD        EQU     0       ; Binary count down
COMMAND_8254_LATCH_READ EQU     0       ; Latch read command

PERFORMANCE_FREQUENCY   EQU     1193182

COUNTER_TICKS_AVG_SHIFT EQU     4
COUNTER_TICKS_FOR_AVG   EQU     16
PAGE_SIZE               EQU     1000H
FRAME_COPY_SIZE         EQU     64

;
; ==== Values used for System Clock ====
;


_DATA   SEGMENT  DWORD PUBLIC 'DATA'

;
; The following array stores the per microsecond loop count for each
; central processor.
;

;
; 8254 performance counter.
;

        public HalpCurrentRollOver, HalpCurrentTimeIncrement, _HalpCurrentMSRateTableIndex
HalpCurrentRollOver           dd      0
HalpCurrentTimeIncrement      dd      0
_HalpCurrentMSRateTableIndex  dd      0
	
        public _HalpClockWork, _HalpClockSetMSRate, _HalpClockMcaQueueDpc
_HalpClockWork label dword
    _HalpClockSetMSRate     db  0
    _HalpClockMcaQueueDpc   db  0
    _bReserved1             db  0
    _bReserved2             db  0

;
; timer latency watchdog variables
;

        public  _HalpWatchdogAvgCounter, _HalpWatchdogCountLow, _HalpWatchdogCountHigh
        public  _HalpWatchdogTscLow, _HalpWatchdogTscHigh

    _HalpWatchdogAvgCounter dd  0
    _HalpWatchdogCountLow   dd  0
    _HalpWatchdogCountHigh  dd  0
    _HalpWatchdogTscLow     dd  0
    _HalpWatchdogTscHigh    dd  0

_DATA   ends

_TEXT   SEGMENT  DWORD PUBLIC 'DATA'

;
; Convert the interval to rollover count for 8254 Timer1 device.
; Timer1 counts down a 16 bit value at a rate of 1.193181667M counts-per-sec.
; (The main crystal freq is 14.31818, and this is a divide by 12)
;
; The best fit value closest to 10ms is 10.0144012689ms:
;   ROLLOVER_COUNT      11949
;   TIME_INCREMENT      100144
;   Calculated error is -.0109472 s/day
;
;
; The following table contains 8254 values timer values to use at
; any given ms setting from 1ms - 15ms.  All values work out to the
; same error per day (-.0109472 s/day).
;

        public HalpRollOverTable

        ;                    RollOver   Time
        ;                    Count      Increment   MS
HalpRollOverTable       dd      1197,   10032       ;  1 ms
                        dd      2394,   20064       ;  2 ms
                        dd      3591,   30096       ;  3 ms
                        dd      4767,   39952       ;  4 ms
                        dd      5964,   49984       ;  5 ms
                        dd      7161,   60016       ;  6 ms
                        dd      8358,   70048       ;  7 ms
                        dd      9555,   80080       ;  8 ms
                        dd     10731,   89936       ;  9 ms
                        dd     11949,  100144       ; 10 ms
                        dd     13125,  110000       ; 11 ms
                        dd     14322,  120032       ; 12 ms
                        dd     15519,  130064       ; 13 ms
                        dd     16695,  139920       ; 14 ms
                        dd     17892,  149952       ; 15 ms

TimeIncr equ    4
RollOver equ    0

_TEXT   ends

_DATA   SEGMENT  DWORD PUBLIC 'DATA'

        public HalpLargestClockMS, _HalpNextMSRate, HalpPendingMSRate
HalpLargestClockMS      dd      15      ; Table goes to 15MS
_HalpNextMSRate         dd      14
HalpPendingMSRate       dd      0

        extrn _TimerInfo:DWORD

BiasLow equ 20
BiasHigh equ 24


_DATA   ends


PAGELK  SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Initialize Clock"
;++
;
; VOID
; HalpInitializeClock (
;    )
;
; Routine Description:
;
;    This routine initialize system time clock using 8254 timer1 counter 0
;    to generate an interrupt at every 15ms interval at 8259 irq0.
;
;    See the definitions of TIME_INCREMENT and ROLLOVER_COUNT if clock rate
;    needs to be changed.
;
; Arguments:
;
;    None
;
; Return Value:
;
;    None.
;
;--
cPublicProc _HalpInitializeClock      ,0

        mov     eax, PCR[PcPrcb]
        cmp     byte ptr [eax].PbCpuType, 4     ; 486 or better?
        jc      short @f                        ; no, skip

        mov     HalpLargestClockMS, 10          ; Limit 486's to 10MS
	mov     _HalpNextMSRate, 9
@@:
        mov     eax, HalpLargestClockMS
	mov     _HalpCurrentMSRateTableIndex, eax
	dec     _HalpCurrentMSRateTableIndex
        mov     ecx, HalpRollOverTable.TimeIncr
        mov     edx, HalpRollOverTable[eax*8-8].TimeIncr
        mov     eax, HalpRollOverTable[eax*8-8].RollOver

        mov     HalpCurrentTimeIncrement, edx

;
; (ecx) = Min time_incr
; (edx) = Max time_incr
; (eax) = max roll over count
;

        push    eax
        stdCall _KeSetTimeIncrement, <edx, ecx>
        pop     ecx

;
; timer latency watchdog initialization
;
        cmp     _HalpTimerWatchdogEnabled, 0
        jz      short @f

        .586p
        rdtsc
        .386p
        mov     _HalpWatchdogAvgCounter, COUNTER_TICKS_FOR_AVG
        mov     _HalpWatchdogTscLow, eax
        mov     _HalpWatchdogTscHigh, edx
        xor     eax, eax
        mov     _HalpWatchdogCountLow, eax
        mov     _HalpWatchdogCountHigh, eax
@@:    

        pushfd                          ; save caller's eflag
        cli                             ; make sure interrupts are disabled

;
; Set clock rate
; (ecx) = RollOverCount
;

        mov     al,COMMAND_8254_COUNTER0+COMMAND_8254_RW_16BIT+COMMAND_8254_MODE2
        out     TIMER1_CONTROL_PORT0, al ;program count mode of timer 0
        IoDelay
        mov     al, cl
        out     TIMER1_DATA_PORT0, al   ; program timer 0 LSB count
        IoDelay
        mov     al,ch
        out     TIMER1_DATA_PORT0, al   ; program timer 0 MSB count

        popfd                             ; restore caller's eflag
        mov     HalpCurrentRollOver, ecx  ; Set RollOverCount & initialized

        stdRET    _HalpInitializeClock

stdENDP _HalpInitializeClock

PAGELK  ends

_TEXT$03   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "System Clock Interrupt"
;++
;
; Routine Description:
;
;    This routine is entered as the result of an interrupt generated by CLOCK.
;    Its function is to dismiss the interrupt, raise system Irql to
;    CLOCK2_LEVEL, update performance counter and transfer control to the
;    standard system routine to update the system time and the execution
;    time of the current thread
;    and process.
;
; Arguments:
;
;    None
;    Interrupt is disabled
;
; Return Value:
;
;    Does not return, jumps directly to KeUpdateSystemTime, which returns
;
;    Sets Irql = CLOCK2_LEVEL and dismisses the interrupt
;
;--
        ENTER_DR_ASSIST Hci_a, Hci_t

cPublicProc _HalpClockInterrupt     ,0

;
; Save machine state in trap frame
;

        ENTER_INTERRUPT Hci_a, Hci_t

;
; (esp) - base of trap frame
;

ifdef MCA

;
; Special hack for MCA machines
;

        in      al, 61h
        jmp     $+2
        or      al, 80h
        out     61h, al
        jmp     $+2

endif   ; MCA


;
; Dismiss interrupt and raise irq level to clock2 level
;

Hci10:
        push    CLOCK_VECTOR
        sub     esp, 4                  ; allocate space to save OldIrql
        stdCall   _HalBeginSystemInterrupt, <CLOCK2_LEVEL, CLOCK_VECTOR, esp>

        or      al,al                           ; check for spurious interrupt
        jz      Hci100

;
; Check to see if we need to fix up a broken PIIX4
;

        .if (_HalpBrokenAcpiTimer)
        stdCall _HalpBrokenPiix4TimerTick
        .endif

;
; Timer latency watchdog
;

        cmp     _HalpTimerWatchdogEnabled, 0
        jz      Hci14

        .586p
        rdtsc
        .386p

;
; Compare difference to watchdog count, while storing a copy of the
; current counter.
;

        xor     ebx, ebx
        push    eax
        push    edx
        sub     eax, _HalpWatchdogTscLow
        sbb     edx, _HalpWatchdogTscHigh
        pop     _HalpWatchdogTscHigh
        pop     _HalpWatchdogTscLow
        js      Hci115                      ; Was this a bogus counter?
                                            ;   (e.g, negative delta)


        push    eax
        mov     ecx, dword ptr _KdEnteredDebugger
        xor     eax, eax
        xchg    eax, [ecx]
        or      al, al                      
        pop     eax
        jnz     Hci14

        cmp     HalpPendingMSRate, ebx      ; Was a new rate set during last
        jnz     Hci14                       ; tick?  Yes, skip this compare

;
; If we need to compute the average of the time-stamp counter for
; the current period, add the delta to the counter.
;

        cmp     _HalpWatchdogAvgCounter, ebx
        jnz     Hci12

        cmp     edx, _HalpWatchdogCountHigh
        ja      short Hci11
        jb      Hci14

        cmp     eax, _HalpWatchdogCountLow
        jbe     Hci14

Hci11:  
        cmp     dword ptr [_HalpTimerWatchdogStorageOverflow], 0
        jne     short Hci115


;
; copy FRAME_COPY_SIZE dwords from the stack, or to next page boundary,
; whichever is less
;       

        push    esi
        push    edi
        lea     esi, [esp + 8]
        lea     ecx, [esi + PAGE_SIZE - 1]
        and     ecx, NOT(PAGE_SIZE - 1)
        sub     ecx, esi
        shr     ecx, 2
        cmp     ecx, FRAME_COPY_SIZE
        jbe     short Hci111
        mov     ecx, FRAME_COPY_SIZE
Hci111:
        mov     edi, dword ptr _HalpTimerWatchdogCurFrame
        rep     movsd
        add     dword ptr _HalpTimerWatchdogCurFrame, (FRAME_COPY_SIZE*4)
;
; If we didn't copy an entire FRAME_COPY_SIZE dwords, zero fill.
;
        mov     ecx, dword ptr _HalpTimerWatchdogCurFrame
        sub     ecx, edi
        shr     ecx, 2
        xor     eax, eax
        rep     stosd
        cmp     edi, dword ptr _HalpTimerWatchdogLastFrame
        jbe     short Hci112
        mov     dword ptr [_HalpTimerWatchdogStorageOverflow], 1
Hci112:

        pop     edi
        pop     esi

Hci115:


;
; reset last time so that we're accurate after the trap
;
        .586p
        rdtsc
        .386p
        mov     _HalpWatchdogTscHigh, edx
        mov     _HalpWatchdogTscLow, eax
        
        jmp     short Hci14

Hci12:
;
; Increment the total counter, perform average when the count is reached
;

        add     _HalpWatchdogCountLow, eax
        adc     _HalpWatchdogCountHigh, edx        
        dec     _HalpWatchdogAvgCounter
        jnz     short Hci14

        mov     edx, _HalpWatchdogCountHigh
        mov     eax, _HalpWatchdogCountLow

;
; compute the average * 2, this measures when we have missed 
; an interrupt at this rate.
;                 
        mov     ecx, COUNTER_TICKS_AVG_SHIFT - 1
Hci13:    
        shr     edx, 1
        rcr     eax, 1
        loop    short Hci13

        mov     _HalpWatchdogCountLow, eax
        mov     _HalpWatchdogCountHigh, edx

Hci14:

;
; Check for any more work
;
        mov     eax, HalpCurrentTimeIncrement

        xor     ebx, ebx
        cmp     _HalpClockWork, ebx         ; Any clock interrupt work desired?
        jz      _KeUpdateSystemTime@0       ; No, process tick

        cmp     _HalpClockMcaQueueDpc, bl
        je      short Hci20

        mov     _HalpClockMcaQueueDpc, bl

;
; Queue MCA Dpc 
;

        push    eax
        stdCall _HalpMcaQueueDpc            ; Queue MCA Dpc
        pop     eax


Hci20:
;
; (esp)   = OldIrql
; (esp+4) = Vector
; (esp+8) = base of trap frame
; ebp = trap frame
; eax = time increment
; ebx = 0
;
        cmp     _HalpClockSetMSRate, bl     ; New clock rate desired?
        jz      _KeUpdateSystemTime@0       ; No, process tick


;
; Time of clock frequency is being changed.  See if the 8254 was
; was reprogrammed for a new rate during last tick
;
        cmp     HalpPendingMSRate, ebx      ; Was a new rate set durning last
        jnz     short Hci50                 ; tick?  Yes, go update globals

Hci40:
; (eax) = time increment for current tick

;
; A new clock rate needs to be set.  Setting the rate here will
; cause the tick after the next tick to be at the new rate.
; (the next tick is already in progress by the 8254 and will occur
; at the same rate as this tick)
;
        mov     ebx, _HalpNextMSRate
        mov     HalpPendingMSRate, ebx  ; pending rate

        mov     ecx, HalpRollOverTable[ebx*8-8].RollOver

;
; Set clock rate
; (ecx) = RollOverCount
;
        push    eax                     ; save current tick's rate

        mov     al,COMMAND_8254_COUNTER0+COMMAND_8254_RW_16BIT+COMMAND_8254_MODE2
        out     TIMER1_CONTROL_PORT0, al ;program count mode of timer 0
        IoDelay
        mov     al, cl
        out     TIMER1_DATA_PORT0, al   ; program timer 0 LSB count
        IoDelay
        mov     al,ch
        out     TIMER1_DATA_PORT0, al   ; program timer 0 MSB count

        pop     eax

;
; (esp)   = OldIrql
; (esp+4) = Vector
; (esp+8) = base of trap frame
; ebp = trap frame
; eax = time increment
;
        jmp     _KeUpdateSystemTime@0   ; dispatch this tick

Hci50:
;
; The next tick will occur at the rate which was programmed during the last
; tick. Update globals for new rate which starts with the next tick.
;
; (eax) = time increment for current tick
;
        mov     ebx, HalpPendingMSRate
	mov     _HalpCurrentMSRateTableIndex, ebx
	dec     _HalpCurrentMSRateTableIndex
        mov     ecx, HalpRollOverTable[ebx*8-8].RollOver
        mov     edx, HalpRollOverTable[ebx*8-8].TimeIncr

        mov     HalpCurrentRollOver, ecx
        mov     HalpCurrentTimeIncrement, edx   ; next tick rate
        mov     HalpPendingMSRate, 0    ; no longer pending, clear it

        cmp     _HalpTimerWatchdogEnabled, 0
        jz      short @f

;
; Schedule to recalibrate watchdog counter
;
        push    eax
        .586p
        rdtsc
        .386p
        mov     _HalpWatchdogAvgCounter, COUNTER_TICKS_FOR_AVG
        mov     _HalpWatchdogTscLow, eax
        mov     _HalpWatchdogTscHigh, edx

        xor     eax,eax
        mov     _HalpWatchdogCountHigh, eax
        mov     _HalpWatchdogCountLow, eax
        pop     eax
@@:

        cmp     ebx, _HalpNextMSRate    ; new rate == NextRate?
        jne     Hci40                   ; no, go set new pending rate

        mov     _HalpClockSetMSRate, 0  ; all done setting new rate
        jmp     _KeUpdateSystemTime@0   ; dispatch this tick

Hci100:
        add     esp, 8                  ; spurious, no EndOfInterrupt
        SPURIOUS_INTERRUPT_EXIT         ; exit interrupt without eoi

stdENDP _HalpClockInterrupt

;++
;
; ULONG
; HalpAcpiTimerSetTimeIncrement (
;     IN ULONG DesiredIncrement
;     )
;
; /*++
;
; Routine Description:
;
;    This routine initialize system time clock to generate an
;    interrupt at every DesiredIncrement interval.
;
; Arguments:
;
;     DesiredIncrement - desired interval between every timer tick (in
;                        100ns unit.)
;
; Return Value:
;
;     The *REAL* time increment set.
;--
cPublicProc _HalpAcpiTimerSetTimeIncrement,1

        mov     eax, [esp+4]                ; desired setting
        xor     edx, edx
        mov     ecx, 9990
        div     ecx                         ; round to MS

        cmp     eax, HalpLargestClockMS     ; MS > max?
        jc      short @f
        mov     eax, HalpLargestClockMS     ; yes, use max
@@:
        or      eax, eax                    ; MS < min?
        jnz     short @f
        inc     eax                         ; yes, use min
@@:
        mov     _HalpNextMSRate, eax
        mov     _HalpClockSetMSRate, 1      ; New clock rate desired.

        mov     eax, HalpRollOverTable[eax*8-8].TimeIncr
        stdRET  _HalpAcpiTimerSetTimeIncrement

stdENDP _HalpAcpiTimerSetTimeIncrement

        page ,132
        subttl  "Query 8254 Counter"
;++
;
; ULONG
; HalpQuery8254Counter(
;    VOID
;    )
;
; Routine Description:
;
;    This routine returns the current value of the 8254 counter
;
; Arguments:
;
;    None
;
; Return Value:
;
;    Current value of the 8254 counter is returned
;
;--

	cPublicProc _HalpQuery8254Counter, 0

	pushfd
        cli

;
; Fetch the current counter value from the hardware
;

        mov     al, COMMAND_8254_LATCH_READ + COMMAND_8254_COUNTER0
                                        ; Latch PIT Ctr 0 command.
        out     TIMER1_CONTROL_PORT0, al
        IODelay
        in      al, TIMER1_DATA_PORT0   ; Read PIT Ctr 0, LSByte.
        IODelay
        movzx   ecx, al                 ; Zero upper bytes of (ECX).
        in      al, TIMER1_DATA_PORT0   ; Read PIT Ctr 0, MSByte.
        mov     ch, al                  ; (CX) = PIT Ctr 0 count.

	mov     eax, ecx
		
        popfd                           ; restore interrupt flag

        stdRET    _HalpQuery8254Counter

stdENDP _HalpQuery8254Counter
	
_TEXT$03   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\i386\ixswint.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halx86\i386\ixswint.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\i386\ixslpctx.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

ACPI_HAL equ 1

include ..\..\halx86\i386\ixslpctx.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\i386\ixprofil.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halx86\i386\ixprofil.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\i386\ixslpctx.inc ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halx86\i386\ixslpctx.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\i386\ixsstate.asm ===
title  "Sleep Handlers"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    ixsstate.asm
;
; Abstract:
;
;    This module implements the code for putting the machine to
;    sleep.
;
; Author:
;
;    Jake Oshins (jakeo) March 13, 1997
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\ix8259.inc
include i386\kimacro.inc
include mac386.inc
include i386\ixcmos.inc
include xxacpi.h
include i386\ixslpctx.inc
        .list

        EXTRNP  _HalpAcpiPreSleep   ,1
        EXTRNP  _HalpAcpiPostSleep  ,1
        EXTRNP  _HalpPostSleepMP, 2
        EXTRNP  _HalpReenableAcpi, 0
        EXTRNP  _StartPx_BuildRealModeStart,1
        EXTRNP  KfLowerIrql, 1,,FASTCALL
        EXTRNP  _KeGetCurrentIrql,0
        EXTRNP  _HalpSaveProcessorStateAndWait,2
        EXTRNP  _KeStallExecutionProcessor, 1
        EXTRNP  _HalpClearSlpSmiStsInICH,0
        extrn   _HalpLowStubPhysicalAddress:DWORD
        extrn   _KeSaveStateForHibernate:proc
        extrn   _HalpFixedAcpiDescTable:DWORD
        extrn   _HalpWakeVector:DWORD
        extrn   _HalpTiledCr3Addresses:DWORD
        extrn   _HalpVirtAddrForFlush:DWORD
        extrn   _HalpPteForFlush:DWORD
        extrn   _HalpHiberProcState:DWORD
        extrn   _HalpBroken440BX:byte

_DATA   SEGMENT  DWORD PUBLIC 'DATA'
    ALIGN   dword

        public  HalpSleepSync
HalpSleepSync   dd      0

        public  HalpBarrier
HalpBarrier     dd      0

_DATA   ends



PAGELK  SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Sleep Handlers"


; VOID
; FASTCALL
; HalpAcpiFlushCache(
;     VOID
;     )
; /*++
;
; Routine Description:
;
;     This is called to flush everything from the caches.
;
; Arguments:
;
;     none
;
; Return Value:
;
;     none
;
; --*/
;
; eax - offset within a page
; ebx - stride size
; ecx - address of PTE we are manipulating
; edi - Physical Address of page
; esi - Virtual Address of page used for flush
; ebp - Flush Limit
;

FlushBase       equ     100000h
PageLength      equ     4096
PteValid        equ     1
PteWrite        equ     2
PteAccessed     equ     20h
PteDirty        equ     40h
PteBits         equ     (PteValid or PteWrite)

cPublicFastCall HalpAcpiFlushCache, 0
cPublicFpo 0, 0
        mov     eax, [FADT_FLAGS]
        test    eax, WBINVD_SUPPORTED or WBINVD_FLUSH
        jz      short hafc10

.586p
        wbinvd
        fstRET    HalpAcpiFlushCache

hafc10:
        push    ebp
        push    ebx
        push    esi
        push    edi

        movzx   eax, word ptr [FLUSH_STRIDE]
        mov     ebx, eax                        ; save the stride size
        movzx   ecx, word ptr [FLUSH_SIZE]
        mul     ecx
        add     eax, FlushBase
        mov     ebp, eax                        ; ebp <- ending physical address

        ;
        ; Iterate across all cache lines
        ;
        mov     edi, FlushBase                  ; start at 1MB, physical

        mov     esi, [_HalpVirtAddrForFlush]
        mov     ecx, [_HalpPteForFlush]

hafc20:
        ; put the right physical page into the PTE
        mov     edx, PteBits                    ; mask off the page
        or      edx, edi
        mov     [ecx], edx
        invlpg  [esi]

        add     edi, PageLength                 ; next physical page
        xor     eax, eax

        ; flush a cache line
hafc30: mov     edx, [esi][eax]
        add     eax, ebx
        cmp     eax, PageLength
        jl      short hafc30

        cmp     edi, ebp
        jl      short hafc20

        pop     edi
        pop     esi
        pop     ebx
        pop     ebp
.386p


        fstRET    HalpAcpiFlushCache
fstENDP HalpAcpiFlushCache

;++
; UCHAR
; FASTCALL
; HalpSetup440BXWorkaround(
;     )
;
; Routine Description:
;
;     This function provides part of the workaround for
;     broken 440BX chips.
;
; Arguments:
;
;     none
;
; Return Value:
;
;     the previous contents of 440BX DRAM Control Register (57h)
;
;--
cPublicFastCall HalpSetup440BXWorkaround, 0
cPublicFpo 0,0

        mov     dx, 0cf8h
        mov     eax, 80000054h
        out     dx, eax
        mov     dx, 0cffh
        in      al, dx
        mov     cl, al
        or      al, 7
        out     dx, al
        push    ecx
        stdCall _KeStallExecutionProcessor <15>
        pop     ecx
        mov     dx, 0cf8h
        mov     eax, 80000054h
        out     dx, eax
        mov     dx, 0cffh
        in      al, dx
        and     al, 0f8h
        out     dx, al
        movzx   eax, cl
        fstRET  HalpSetup440BXWorkaround

fstENDP HalpSetup440BXWorkaround

;++
; VOID
; FASTCALL
; HalpComplete440BXWorkaround(
;     UCHAR DramControl
;     )
;
; Routine Description:
;
;     This function provides the other part of the workaround for
;     broken 440BX chips.
;
; Arguments:
;
;     the previous contents of 440BX DRAM Control Register (57h)
;
; Return Value:
;
;     none
;
;--
cPublicFastCall HalpComplete440BXWorkaround, 1
cPublicFpo 0,0

        mov     dx, 0cf8h
        mov     eax, 80000054h
        out     dx, eax

        mov     dx, 0cffh
        mov     al, cl
        out     dx, al
        fstRET  HalpComplete440BXWorkaround

fstENDP HalpComplete440BXWorkaround

; NTSTATUS
; HaliAcpiSleep(
;     IN PVOID                        Context,
;     IN PENTER_STATE_SYSTEM_HANDLER  SystemHandler   OPTIONAL,
;     IN PVOID                        SystemContext,
;     IN LONG                         NumberProcessors,
;     IN volatile PLONG               Number
;     )
; /*++
;
; Routine Description:
;
;     This is called by the Policy Manager to enter Sx.
;
; Arguments:
;
;     Context - unused
;
;     NumberProcessors - currently unused
;
;     Number - currently unused
;
; Return Value:
;
;     none
;
; --*/

Context     equ     [ebp+8]
SysHandler  equ     [ebp+12]
SysContext  equ     [ebp+16]
NumberProc  equ     [ebp+20]
Barrier     equ     [ebp+24]

Pm1aEvt     equ     [ebp-4]
Pm1bEvt     equ     [ebp-8]
Status      equ     [ebp-12]
SlpTypA     equ     [ebp-14]
SlpTypB     equ     [ebp-16]
ThisProc    equ     [ebp-20]
OldIrql     equ     [ebp-24]
PrevDRAM    equ     [ebp-28]
FrameSize   equ     28

cPublicProc _HaliAcpiSleep, 5
cPublicFpo 5, 4
        push    ebp
        mov     ebp, esp
        sub     esp, FrameSize
        push    ebx
        push    esi
        push    edi
        pushfd
        cli

        mov     edi, HalpSleepSync                  ; Get current sleep sync value
        xor     eax, eax
        mov     Status, eax

        ;
        ; Get current IRQL
        ;

        stdCall _KeGetCurrentIrql
        mov     OldIrql, eax

        ;
        ; Send all
        ;

        mov     al, PCR[PcNumber]
        or      al, al                          ; Is this processor 0?
        jnz     has_wait                        ; if not, set it waiting

        mov     HalpBarrier, 0                  ; init Barrier, processor 0 does it

        ;
        ; Make sure the other processors have saved their
        ; state and begun to spin.
        ;

        lock inc [HalpSleepSync]                ; account for this proc
has1:   YIELD
        mov     eax, [HalpSleepSync]
        cmp     eax, NumberProc
        jnz     short has1

        ;
        ; Take care of chores (RTC, interrupt controller, etc.)
        stdCall _HalpAcpiPreSleep, <Context>
        or      al, al                          ; check for failure
        jz      has_slept                       ; if FALSE, then don't sleep at all

        ;
        ; If we will be losing processor state, save it
        ;
        mov     eax, Context
        test    eax, SLEEP_STATE_FIRMWARE_RESTART shl CONTEXT_FLAG_SHIFT
        jz      short has2
        lea     eax, haswake
        stdCall _HalpSetupRealModeResume, <eax>

        ;
        ; Record the values in the SLP_TYP registers
        ;
has2:
        mov     edx, [PM1a_CNT]
        in      ax, dx
        mov     SlpTypA, ax

        mov     edx, [PM1b_CNT]
        or      edx, edx
        jz      short has5

        in      ax, dx
        mov     SlpTypB, ax

has5:
        ;
        ; The hal has all of it's state saved into ram and is ready
        ; for the power down.  If there's a system state handler give
        ; it a shot
        ;

        mov     eax, SysHandler
        or      eax, eax
        jz      short has10

        mov     ecx, SysContext
        push    ecx
        call    eax                                 ; Call the system state handler
        mov     Status, eax
        test    eax, eax
        jnz     has_s4_wake                         ; If not success, exit

has10:
        mov     esi, Context

        mov     edx, [PM1a_EVT]
        mov     ecx, [PM1b_EVT]
        or      ecx, ecx
        jnz     short has20
        mov     ecx, edx

has20:
        mov     Pm1aEvt, ecx
        mov     Pm1bEvt, edx                        ; save PM1a_EVT & PM1b_EVT address

        ;
        ; Reset WAK_STS
        ;

        mov     eax, WAK_STS
        out     dx, ax                              ; clear PM1a WAK_STS
        mov     edx, ecx
        out     dx, ax                              ; clear PM1b WAK_STS

        ;
        ; Flush the caches if necessary
        ;
        mov     eax, SLEEP_STATE_FLUSH_CACHE shl CONTEXT_FLAG_SHIFT
        test    eax, esi
        jz      short @f
        fstCall HalpAcpiFlushCache
@@:
        ;
        ; Work around 440BX bug.  Criteria is that we have one of
        ; the broken BX parts and we are not hibernating, which 
        ; we know because the SysHandler is 0.
        ;
        
        mov     eax, SysHandler
        .if (_HalpBroken440BX && (eax == 0))
	fstCall HalpSetup440BXWorkaround
        movzx   eax, al
        mov     PrevDRAM, eax
        .endif
        
        ;
        ; Issue SLP commands to PM1a_CNT and PM1b_CNT
        ;

        mov     edx, [PM1a_CNT]
        mov     ecx, esi
        and     ecx, 0fh                            ; nibble 0 is 1a sleep type
        shl     ecx, SLP_TYP_SHIFT                  ; put it in position
        or      ecx, SLP_EN                         ; enable sleep  ********

        in      ax, dx
        and     ax, CTL_PRESERVE                    ; preserve some bits
        or      ax, cx
        out     dx, ax

        mov     edx, [PM1b_CNT]
        or      edx, edx
        jz      short has30

        mov     ecx, esi
        and     ecx, 0f0h                           ; nibble 1 is 1b sleep type
        shl     ecx, (SLP_TYP_SHIFT-4)              ; put it in position
        or      ecx, SLP_EN                         ; enable sleep  *********

        in      ax, dx
        and     ax, CTL_PRESERVE                    ; preserve some bits
        or      ax, cx
        out     dx, ax

has30:
        ;
        ; Wait for sleep to be over
        ;

        mov     ecx, Pm1bEvt
        mov     edx, Pm1aEvt                        ; retrieve PM1_EVT & PM1b_EVT

has40:  in      ax, dx
        test    ax, WAK_STS
        xchg    edx, ecx
        jz      short has40
        
        ;
        ; Finish 440BX workaround
        ;
        
        mov     eax, SysHandler
        .if (_HalpBroken440BX && (eax == 0))
	mov     ecx, PrevDRAM
        fstCall HalpComplete440BXWorkaround
        .endif    

        ;
        ; Invalidate the processor cache so that any stray gamma
        ; rays (I'm serious) that may have flipped cache bits
        ; while in S1 will be ignored.
        ;
        ; Honestly.  Intel asked for this.  I'm serious.
        ;
;.586
;        invd
;.386

haswake:
        ;
        ; Hack around ICH2/ASUS BIOS.
        ;
        
        stdCall _HalpClearSlpSmiStsInICH
        
        ;
        ; Restore the SLP_TYP registers.  (So that embedded controllers
        ; and BIOSes can be sure that we think the machine is awake.)
        ;
        mov     edx, [PM1a_CNT]
        mov     ax, SlpTypA
        out     dx, ax

        mov     edx, [PM1b_CNT]
        or      edx, edx
        jz      short has60

        mov     ax, SlpTypB
        out     dx, ax

has60:
        stdCall _HalpAcpiPostSleep, <Context>

has_slept:
        ;
        ; Notify other processor of completion
        ;

        mov     HalpSleepSync, 0
        jmp     short has_90

has_wait:
        xor     eax, eax
        mov     edx, Context
        test    edx, SLEEP_STATE_OFF shl CONTEXT_FLAG_SHIFT
        jnz     has_wait2                       ; if going to S5, don't save context
        
        mov     al, PCR[PcNumber]               ; get processor number
        mov     edx, ProcessorStateLength       ; get size of proc state
        mul     dx                              ; generate an index into HalpHiberProcState
        add     eax, _HalpHiberProcState        ; add the index to base
has_wait2:
        lea     edx, HalpSleepSync
        stdCall _HalpSaveProcessorStateAndWait <eax, edx>

        ;
        ; Wait for next phase
        ;


hasw10: YIELD
        cmp     HalpSleepSync, 0                ; wait for barrier to move
        jne     short hasw10

        ;
        ; All phases complete, exit
        ;

has_90:
        ;
        ; Restore each processor's APIC state.
        ;

        lea     eax, HalpBarrier
        stdCall _HalpPostSleepMP <NumberProc, eax>

        ;
        ; Restore caller's IRQL
        ;

        mov     ecx, OldIrql
        fstCall KfLowerIrql

        ;
        ; Exit
        ;

        mov     HalpSleepSync, 0
        mov     eax, Status
        popfd
        pop     edi
        pop     esi
        pop     ebx
        mov     esp, ebp
        pop     ebp
        stdRET  _HaliAcpiSleep

has_s4_wake:
	stdCall _HalpReenableAcpi
        jmp     haswake

stdENDP _HaliAcpiSleep

;++
;
; BOOLEAN
; HalpSetupRealModeResume (
; )
;
; Routine Description:
;
;    This routine is called by the kernel durning kernel initialization
;    to obtain more processors.  It is called until no more processors
;    are available.
;
;    If another processor exists this function is to initialize it to
;    the passed in processorstate structure, and return TRUE.
;
;    If another processor does not exists or if the processor fails to
;    start, then a FALSE is returned.
;
;    Also note that the loader block has been setup for the next processor.
;    The new processor logical thread number can be obtained from it, if
;    required.
;
;    In order to use the Startup IPI the real mode startup code must be
;    page aligned.  The MpLowStubPhysicalAddress has always been page
;    aligned but because the PxParamBlock was placed first in this
;    segment the real mode code has been something other than page aligned.
;    This has been changed by making the first entry in the PxParamBlock
;    a jump instruction to the real mode startup code.
;
; Arguments:
;
;    WakeupReturnAddress - address that processor should return to
;                          after it has been asleep
;
; Return Value:
;
;
;--

WakeupReturnAddress equ dword ptr [ebp + 20]

;
; Local variables
;

PxFrame             equ [ebp - size PxParamBlock]
LWarmResetVector    equ [ebp - size PxParamBlock - 4]
LStatusCode         equ [ebp - size PxParamBlock - 8]
LCmosValue          equ [ebp - size PxParamBlock - 12]
CallingEbp          equ [ebp]
CallingEsi          equ [ebp + 12]
CallingEdi          equ [ebp + 8]
CallingEbx          equ [ebp + 4]
CallingEsp          equ 24              ; relative to current ebp

cPublicProc _HalpSetupRealModeResume ,1
cPublicFpo 4, 80

    push    esi                         ; Save required registers
    push    edi
    push    ebx

    push    ebp                         ; save ebp
    mov     ebp, esp                    ; Save Frame
    sub     esp, size PxParamBlock + 12 ; Make room for local vars

    xor     eax, eax
    mov     LStatusCode, eax

    ;
    ; Fill in the firmware wakeup vector
    ;
    mov     eax, _HalpLowStubPhysicalAddress
    mov     ecx, [_HalpWakeVector]
    mov     [ecx], eax

    ;
    ; Save the processor context
    ;

    lea     edi, PxFrame.SPx_PB
    push    edi
    call    _KeSaveStateForHibernate        ; _cdecl function
    add     esp, 4

    ;
    ; Get a CR3 for the starting processor
    ;
    mov     eax, [_HalpTiledCr3Addresses] ; the low 32-bits of processor 0's CR3
    mov     eax, [eax]                    ; physical address will be here
    mov     PxFrame.SPx_TiledCR3, eax     ; Newly contructed CR3

    mov     PxFrame.SPx_P0EBP, ebp        ; Stack pointer

    lea     edi, PxFrame.SPx_PB.PsContextFrame

    mov     eax, WakeupReturnAddress
    mov     dword ptr [edi].CsEip, eax      ; make a copy of remaining
    mov     eax, CallingEbx                 ; registers which need
    mov     dword ptr [edi].CsEbx, eax      ; loaded
    mov     eax, CallingEsi
    mov     dword ptr [edi].CsEsi, eax
    mov     eax, CallingEdi
    mov     dword ptr [edi].CsEdi, eax
    mov     eax, CallingEbp
    mov     dword ptr [edi].CsEbp, eax
    mov     eax, ebp
    add     eax, CallingEsp
    mov     dword ptr [edi].CsEsp, eax

    lea     eax, PxFrame
    stdCall _StartPx_BuildRealModeStart, <eax>

snp_exit:
    mov     esp, ebp
    pop     ebp
    pop     ebx
    pop     edi
    pop     esi
    stdRET  _HalpSetupRealModeResume

stdENDP _HalpSetupRealModeResume


PAGELK   ends

    end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\i386\mcsysint.asm ===
;++
;
;Copyright (c) 1991  Microsoft Corporation
;
;Module Name:
;
;    ixsysint.asm
;
;Abstract:
;
;    This module implements the HAL routines to enable/disable system
;    interrupts.
;
;Author:
;
;    John Vert (jvert) 22-Jul-1991
;
;Environment:
;
;    Kernel Mode
;
;Revision History:
;
;--


.386p
        .xlist
include hal386.inc
include i386\ix8259.inc
include i386\kimacro.inc
include mac386.inc
include callconv.inc
include xxacpi.h
        .list

        extrn   KiI8259MaskTable:DWORD
        EXTRNP  _KeBugCheck,1,IMPORT

;
; Constants used to initialize CMOS/Real Time Clock
;

CMOS_CONTROL_PORT       EQU     70h     ; command port for cmos
CMOS_DATA_PORT          EQU     71h     ; cmos data port

;
; Macros to Read/Write/Reset CMOS to initialize RTC
;

; CMOS_READ
;
; Description: This macro read a byte from the CMOS register specified
;        in (AL).
;
; Parameter: (AL) = address/register to read
; Return: (AL) = data
;

CMOS_READ       MACRO
        OUT     CMOS_CONTROL_PORT,al    ; ADDRESS LOCATION AND DISABLE NMI
        IODelay                         ; I/O DELAY
        IN      AL,CMOS_DATA_PORT       ; READ IN REQUESTED CMOS DATA
        IODelay                         ; I/O DELAY
ENDM

_TEXT   SEGMENT DWORD PUBLIC 'DATA'

align   dword
;
; HalDismissSystemInterrupt does an indirect jump through this table so it
; can quickly execute specific code for different interrupts.
;
        public  HalpSpecialDismissTable
HalpSpecialDismissTable label   dword
        dd      offset FLAT:HalpDismissNormal   ; irq 0
        dd      offset FLAT:HalpDismissNormal   ; irq 1
        dd      offset FLAT:HalpDismissNormal   ; irq 2
        dd      offset FLAT:HalpDismissNormal   ; irq 3
        dd      offset FLAT:HalpDismissNormal   ; irq 4
        dd      offset FLAT:HalpDismissNormal   ; irq 5
        dd      offset FLAT:HalpDismissNormal   ; irq 6
        dd      offset FLAT:HalpDismissIrq07    ; irq 7
        dd      offset FLAT:HalpDismissNormal   ; irq 8
        dd      offset FLAT:HalpDismissNormal   ; irq 9
        dd      offset FLAT:HalpDismissNormal   ; irq A
        dd      offset FLAT:HalpDismissNormal   ; irq B
        dd      offset FLAT:HalpDismissNormal   ; irq C
        dd      offset FLAT:HalpDismissNormal   ; irq D
        dd      offset FLAT:HalpDismissNormal   ; irq E
        dd      offset FLAT:HalpDismissIrq0f    ; irq F
        dd      offset FLAT:HalpDismissNormal   ; irq 10
        dd      offset FLAT:HalpDismissNormal   ; irq 11
        dd      offset FLAT:HalpDismissNormal   ; irq 12
        dd      offset FLAT:HalpDismissNormal   ; irq 13
        dd      offset FLAT:HalpDismissNormal   ; irq 14
        dd      offset FLAT:HalpDismissNormal   ; irq 15
        dd      offset FLAT:HalpDismissNormal   ; irq 16
        dd      offset FLAT:HalpDismissNormal   ; irq 17
        dd      offset FLAT:HalpDismissNormal   ; irq 18
        dd      offset FLAT:HalpDismissNormal   ; irq 19
        dd      offset FLAT:HalpDismissNormal   ; irq 1A
        dd      offset FLAT:HalpDismissNormal   ; irq 1B
        dd      offset FLAT:HalpDismissNormal   ; irq 1C
        dd      offset FLAT:HalpDismissNormal   ; irq 1D
        dd      offset FLAT:HalpDismissNormal   ; irq 1E
        dd      offset FLAT:HalpDismissNormal   ; irq 1F
        dd      offset FLAT:HalpDismissNormal   ; irq 20
        dd      offset FLAT:HalpDismissNormal   ; irq 21
        dd      offset FLAT:HalpDismissNormal   ; irq 22
        dd      offset FLAT:HalpDismissNormal   ; irq 23

_TEXT   ENDS

_TEXT$01   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING


;++
;BOOLEAN
;HalBeginSystemInterrupt(
;    IN KIRQL Irql
;    IN ULONG Vector,
;    OUT PKIRQL OldIrql
;    )
;
;
;
;Routine Description:
;
;    This routine is used to dismiss the specified vector number.  It is called
;    before any interrupt service routine code is executed.
;
;    N.B.  This routine does NOT preserve EAX or EBX
;
;    On a UP machine the interrupt dismissed at BeginSystemInterrupt time.
;    This is fine since the irql is being raise to mask it off.
;    HalEndSystemInterrupt is simply a LowerIrql request.
;
;
;Arguments:
;
;    Irql   - Supplies the IRQL to raise to
;
;    Vector - Supplies the vector of the interrupt to be processed
;
;    OldIrql- Location to return OldIrql
;
;
;Return Value:
;
;    FALSE - Interrupt is spurious and should be ignored
;
;    TRUE -  Interrupt successfully dismissed and Irql raised.
;
;--
align dword
HbsiIrql        equ     byte  ptr [esp+4]
HbsiVector      equ     byte  ptr [esp+8]
HbsiOldIrql     equ     dword ptr [esp+12]

cPublicProc _HalBeginSystemInterrupt ,3
cPublicFpo 3, 0
        movzx   ebx,HbsiVector                  ; (ebx) = IDTEntry
        sub     ebx, PRIMARY_VECTOR_BASE        ; (ebx) = 8259 IRQ #
if DBG
        cmp     ebx, 23h
        jbe     hbsi00
        int     3
hbsi00:

endif
        jmp     HalpSpecialDismissTable[ebx*4]  ; jmp to proper dismiss code

HalpDismissIrq0f:
;
; Check to see if this is a spurious interrupt
;
        mov     al, OCW3_READ_ISR       ; tell 8259 we want to read ISR
        out     PIC2_PORT0, al
        IODelay                         ; delay
        in      al, PIC2_PORT0          ; (al) = content of PIC 1 ISR
        test    al, 10000000B           ; Is In-Service register set?
        jnz     short HalpDismissNormal ; No, this is NOT a spurious int,
                                        ; go do the normal interrupt stuff

;
; This is a spurious interrupt.
; Because the slave PIC is cascaded to irq2 of master PIC, we need to
; dismiss the interupt on master PIC's irq2.
;

        mov     al, PIC2_EOI            ; Specific eoi to master for pic2 eoi
        out     PIC1_PORT0, al          ; send irq2 specific eoi to master
        mov     eax,0                   ; return FALSE
;       sti
        stdRET    _HalBeginSystemInterrupt

HalpDismissIrq07:
;
; Check to see if this is a spurious interrupt
;
        mov     al, OCW3_READ_ISR       ; tell 8259 we want to read ISR
        out     PIC1_PORT0, al
        IODelay                         ; delay
        in      al, PIC1_PORT0          ; (al) = content of PIC 1 ISR
        test    al, 10000000B           ; Is In-Service register set?
        jnz     short HalpDismissNormal ; No, so this is NOT a spurious int
        mov     eax, 0                  ; return FALSE
;       sti
        stdRET    _HalBeginSystemInterrupt

HalpDismissNormal:
;
; Store OldIrql
;
        mov     eax, HbsiOldIrql
        movzx   ecx, word ptr PCR[PcIrql]
        mov     byte ptr [eax], cl

;
; Raise IRQL to requested level
;
        movzx   eax, HbsiIrql           ; (eax) = irql
                                        ; (ebx) = IRQ #

        mov     PCR[PcIrql], al         ; set new Irql


        mov     eax, KiI8259MaskTable[eax*4]    ; get 8259's masks
        or      eax, PCR[PcIDR]         ; mask disabled irqs
        SET_8259_MASK                   ; send mask to 8259s

;
; Dismiss interrupt.  Current interrupt is already masked off.
;
        mov     eax, ebx                ; (eax) = IRQ #
        cmp     eax, 8                  ; EOI to master or slave?

        jae     short Hbsi100           ; EIO to both master and slave
        or      al, PIC1_EOI_MASK       ; create specific eoi mask for master
        out     PIC1_PORT0, al          ; dismiss the interrupt
        jmp     short Hbsi200           ; IO delay - This is not enough for 486

Hbsi100:
        mov     al, OCW2_NON_SPECIFIC_EOI ; send non specific eoi to slave
        out     PIC2_PORT0, al
        mov     al, PIC2_EOI            ; specific eoi to master for pic2 eoi
        out     PIC1_PORT0, al          ; send irq2 specific eoi to master
Hbsi200:
        PIC1DELAY                       ; *MUST* wait for 8259 before sti
        sti
        mov     eax, 1                  ; return TRUE, interrupt dismissed
        stdRET    _HalBeginSystemInterrupt
stdENDP _HalBeginSystemInterrupt


;++
;VOID
;HalDisableSystemInterrupt(
;    IN CCHAR Vector,
;    IN KIRQL Irql
;    )
;
;
;
;Routine Description:
;
;    Disables a system interrupt.
;
;Arguments:
;
;    Vector - Supplies the vector of the interrupt to be disabled
;
;    Irql   - Supplies the interrupt level of the interrupt to be disabled
;
;Return Value:
;
;    None.
;
;--
cPublicProc _HalDisableSystemInterrupt      ,2
cPublicFpo 2, 0

;

        movzx   ecx, byte ptr [esp+4]           ; (ecx) = IDTEntry
        sub     ecx, PRIMARY_VECTOR_BASE        ; (ecx) = 8259 irq #
        mov     edx, 1
        shl     edx, cl                         ; (ebx) = bit in IMR to disable
        cli
        or      PCR[PcIDR], edx
        xor     eax, eax

;
; Get the current interrupt mask register from the 8259
;
        in      al, PIC2_PORT1
        shl     eax, 8
        in      al, PIC1_PORT1
;
; Mask off the interrupt to be disabled
;
        or      eax, edx
;
; Write the new interrupt mask register back to the 8259
;
        out     PIC1_PORT1, al
        shr     eax, 8
        out     PIC2_PORT1, al
        PIC2DELAY

        sti
        stdRET    _HalDisableSystemInterrupt

stdENDP _HalDisableSystemInterrupt

;++
;
;BOOLEAN
;HalEnableSystemInterrupt(
;    IN ULONG Vector,
;    IN KIRQL Irql,
;    IN KINTERRUPT_MODE InterruptMode
;    )
;
;
;Routine Description:
;
;    Enables a system interrupt
;
;Arguments:
;
;    Vector - Supplies the vector of the interrupt to be enabled
;
;    Irql   - Supplies the interrupt level of the interrupt to be enabled.
;
;Return Value:
;
;    None.
;
;--
Vector        EQU     [esp+4]
Irql          EQU     [esp+8]
InterruptMode EQU     [esp+12]

cPublicProc _HalEnableSystemInterrupt       ,3
cPublicFpo 3, 0

        movzx   ecx, byte ptr Vector            ; (ecx) = IDTEntry
        sub     ecx, PRIMARY_VECTOR_BASE
        jc      hes_error
        cmp     ecx, CLOCK2_LEVEL
        jnc     hes_error

        ;
        ; Set Edge/Level bit in the interrupt controller
        ;
        
        ; read the edge/level control bits into ax
        mov     edx, EISA_EDGE_LEVEL1
        in      al, dx
        shl     ax, 8
        mov     edx, EISA_EDGE_LEVEL0
        in      al, dx
 
        mov     dx, 1
        shl     dx, cl          ; set the bit corresponding to this Vector
        .IF     InterruptMode == 0         ; if level,
        or      ax, dx          ; set the bit
        .ELSE                   ; else (edge)
        not     dx              
        and     ax, dx          ; clear the bit
        .ENDIF
        
        ; write it back
        mov     edx, EISA_EDGE_LEVEL0
        out     dx, al
        shr     ax, 8
        mov     edx, EISA_EDGE_LEVEL1
        out     dx, al

        mov     eax, 1
        shl     eax, cl                         ; (ebx) = bit in IMR to enable
        not     eax

        cli
        and     PCR[PcIDR], eax

;
; Get the PIC masks for the current Irql
;
        movzx   eax, byte ptr PCR[PcIrql]
        mov     eax, KiI8259MaskTable[eax*4]
        or      eax, PCR[PcIDR]
;
; Write the new interrupt mask register back to the 8259
;
        SET_8259_MASK

        sti
        mov     eax, 1                          ; return TRUE
        stdRET    _HalEnableSystemInterrupt

hes_error:
if DBG
        int 3
endif
        xor     eax, eax                        ; FALSE
        stdRET    _HalEnableSystemInterrupt

stdENDP _HalEnableSystemInterrupt


_TEXT$01   ENDS

        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\i386\mcirql.asm ===
title  "Irql Processing"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    ixirql.asm
;
; Abstract:
;
;    This module implements the code necessary to raise and lower i386
;    Irql and dispatch software interrupts with the 8259 PIC.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 8-Jan-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;    John Vert (jvert) 27-Nov-1991
;       Moved from kernel into HAL
;
;--

.586p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\ix8259.inc
include i386\kimacro.inc
include mac386.inc
        .list


        EXTRNP  _KeBugCheckEx,5,IMPORT
        EXTRNP _KeSetEventBoostPriority, 2, IMPORT
        EXTRNP _KeWaitForSingleObject,5, IMPORT

        extrn   _HalpApcInterrupt:near
        extrn   _HalpDispatchInterrupt:near
        extrn   _KiUnexpectedInterrupt:near
        extrn   _HalpBusType:DWORD
        extrn   _HalpApcInterrupt2ndEntry:NEAR
        extrn   _HalpDispatchInterrupt2ndEntry:NEAR

ifdef NT_UP
    LOCK_ADD  equ   add
    LOCK_DEC  equ   dec
else
    LOCK_ADD  equ   lock add
    LOCK_DEC  equ   lock dec
endif


;
; Initialization control words equates for the PICs
;

ICW1_ICW4_NEEDED                equ     01H
ICW1_CASCADE                    equ     00H
ICW1_INTERVAL8                  equ     00H
ICW1_LEVEL_TRIG                 equ     08H
ICW1_EDGE_TRIG                  equ     00H
ICW1_ICW                        equ     10H

ICW4_8086_MODE                  equ     001H
ICW4_NORM_EOI                   equ     000H
ICW4_NON_BUF_MODE               equ     000H
ICW4_SPEC_FULLY_NESTED          equ     010H
ICW4_NOT_SPEC_FULLY_NESTED      equ     000H

OCW2_NON_SPECIFIC_EOI           equ     020H
OCW2_SPECIFIC_EOI               equ     060H
OCW2_SET_PRIORITY               equ     0c0H

PIC_SLAVE_IRQ                   equ     2
PIC1_BASE                       equ     30H
PIC2_BASE                       equ     38H

;
; Interrupt flag bit maks for EFLAGS
;

EFLAGS_IF                       equ     200H
EFLAGS_SHIFT                    equ     9


_DATA   SEGMENT DWORD PUBLIC 'DATA'

;
; PICsInitializationString - Master PIC initialization command string
;

PS2PICsInitializationString        dw      PIC1_PORT0

;
; Master PIC initialization command
;

                           db      ICW1_ICW + ICW1_LEVEL_TRIG + ICW1_INTERVAL8 +\
                                   ICW1_CASCADE + ICW1_ICW4_NEEDED
                           db      PIC1_BASE
                           db      1 SHL PIC_SLAVE_IRQ
                           db      ICW4_NOT_SPEC_FULLY_NESTED + \
                                   ICW4_NON_BUF_MODE + \
                                   ICW4_NORM_EOI + \
                                   ICW4_8086_MODE
;
; Slave PIC initialization command strings
;

                           dw      PIC2_PORT0
                           db      ICW1_ICW + ICW1_LEVEL_TRIG + ICW1_INTERVAL8 +\
                                   ICW1_CASCADE + ICW1_ICW4_NEEDED
                           db      PIC2_BASE
                           db      PIC_SLAVE_IRQ
                           db      ICW4_NOT_SPEC_FULLY_NESTED + \
                                   ICW4_NON_BUF_MODE + \
                                   ICW4_NORM_EOI + \
                                   ICW4_8086_MODE
                           dw      0               ; end of string


PICsInitializationString   dw      PIC1_PORT0

;
; Master PIC initialization command
;

                           db      ICW1_ICW + ICW1_EDGE_TRIG + ICW1_INTERVAL8 +\
                                   ICW1_CASCADE + ICW1_ICW4_NEEDED
                           db      PIC1_BASE
                           db      1 SHL PIC_SLAVE_IRQ
                           db      ICW4_NOT_SPEC_FULLY_NESTED + \
                                   ICW4_NON_BUF_MODE + \
                                   ICW4_NORM_EOI + \
                                   ICW4_8086_MODE

; Slave PIC initialization command strings
;

                           dw      PIC2_PORT0
                           db      ICW1_ICW + ICW1_EDGE_TRIG + ICW1_INTERVAL8 +\
                                   ICW1_CASCADE + ICW1_ICW4_NEEDED
                           db      PIC2_BASE
                           db      PIC_SLAVE_IRQ
                           db      ICW4_NOT_SPEC_FULLY_NESTED + \
                                   ICW4_NON_BUF_MODE + \
                                   ICW4_NORM_EOI + \
                                   ICW4_8086_MODE
                           dw      0               ; end of string

            align   4
            public  KiI8259MaskTable
KiI8259MaskTable    label   dword
                dd      00000000000000000000000000000000B ; irql 0
                dd      00000000000000000000000000000000B ; irql 1
                dd      00000000000000000000000000000000B ; irql 2
                dd      00000000000000000000000000000000B ; irql 3
                dd      11111111100000000000000000000000B ; irql 4
                dd      11111111110000000000000000000000B ; irql 5
                dd      11111111111000000000000000000000B ; irql 6
                dd      11111111111100000000000000000000B ; irql 7
                dd      11111111111110000000000000000000B ; irql 8
                dd      11111111111111000000000000000000B ; irql 9
                dd      11111111111111100000000000000000B ; irql 10
                dd      11111111111111110000000000000000B ; irql 11
                dd      11111111111111111000000000000000B ; irql 12
                dd      11111111111111111100000000000000B ; irql 13
                dd      11111111111111111110000000000000B ; irql 14
                dd      11111111111111111111000000000000B ; irql 15
                dd      11111111111111111111100000000000B ; irql 16
                dd      11111111111111111111110000000000B ; irql 17
                dd      11111111111111111111111000000000B ; irql 18
                dd      11111111111111111111111000000000B ; irql 19
                dd      11111111111111111111111010000000B ; irql 20
                dd      11111111111111111111111011000000B ; irql 21
                dd      11111111111111111111111011100000B ; irql 22
                dd      11111111111111111111111011110000B ; irql 23
                dd      11111111111111111111111011111000B ; irql 24
                dd      11111111111111111111111011111000B ; irql 25
                dd      11111111111111111111111011111010B ; irql 26
                dd      11111111111111111111111111111010B ; irql 27
                dd      11111111111111111111111111111011B ; irql 28
                dd      11111111111111111111111111111011B ; irql 29
                dd      11111111111111111111111111111011B ; irql 30
                dd      11111111111111111111111111111011B ; irql 31

        align   4
;
; The following tables define the addresses of software interrupt routers
;

;
; Use this table if there is NO machine state frame on stack already
;

        public  SWInterruptHandlerTable
SWInterruptHandlerTable label dword
        dd      offset FLAT:_KiUnexpectedInterrupt      ; irql 0
        dd      offset FLAT:_HalpApcInterrupt           ; irql 1
        dd      offset FLAT:_HalpDispatchInterrupt      ; irql 2

;
; Use this table if there is a machine state frame on stack already
;

        public  SWInterruptHandlerTable2
SWInterruptHandlerTable2 label dword
        dd      offset FLAT:_KiUnexpectedInterrupt      ; irql 0
        dd      offset FLAT:_HalpApcInterrupt2ndEntry   ; irql 1
        dd      offset FLAT:_HalpDispatchInterrupt2ndEntry ; irql 2

;
; The following table picks up the highest pending software irq level
; from software irr
;

        public  SWInterruptLookUpTable
SWInterruptLookUpTable label byte
        db      0               ; SWIRR=0, so highest pending SW irql= 0
        db      0               ; SWIRR=1, so highest pending SW irql= 0
        db      1               ; SWIRR=2, so highest pending SW irql= 1
        db      1               ; SWIRR=3, so highest pending SW irql= 1
        db      2               ; SWIRR=4, so highest pending SW irql= 2
        db      2               ; SWIRR=5, so highest pending SW irql= 2
        db      2               ; SWIRR=6, so highest pending SW irql= 2
        db      2               ; SWIRR=7, so highest pending SW irql= 2

_DATA   ENDS

_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:FLAT, FS:NOTHING, GS:NOTHING

        PAGE
        subttl  "Raise Irql"

;++
;
; KIRQL
; FASTCALL
; KfRaiseIrql (
;    IN KIRQL NewIrql
;    )
;
; Routine Description:
;
;    This routine is used to raise IRQL to the specified value.
;    Also, a mask will be used to mask off all the lower lever 8259
;    interrupts.
;
; Arguments:
;
;    (cl) = NewIrql - the new irql to be raised to
;
; Return Value:
;
;    OldIrql - the addr of a variable which old irql should be stored
;
;--

cPublicFastCall KfRaiseIrql,1
cPublicFpo 0,0

        xor     eax, eax                ; avoid partial stall
        mov     al, PCR[PcIrql]         ; get current irql
        movzx   ecx, cl                 ; 32bit extend NewIrql

if DBG
        cmp     al,cl                   ; old > new?
        ja      short Kri99             ; raising to a lower IRQL is BAD
endif
        cmp     cl,DISPATCH_LEVEL       ; software level?
        jbe     short kri10             ; Skip setting 8259 masks

        mov     edx, eax                ; Save OldIrql

        pushfd
        cli                             ; disable interrupt
        mov     PCR[PcIrql], cl         ; set the new irql
        mov     eax, KiI8259MaskTable[ecx*4]; get pic masks for the new irql
        or      eax, PCR[PcIDR]         ; mask irqs which are disabled
        SET_8259_MASK                   ; set 8259 masks

        popfd

        mov     eax, edx                ; (al) = OldIrql
        fstRET  KfRaiseIrql

align 4
kri10:
;
; Note it is very important that we set the old irql AFTER we raised to
; the new irql.  Otherwise, if there is an interrupt comes in between and
; the OldIrql is not a local variable, the caller will get wrong OldIrql.
; The bottom line is the raising irql and returning old irql has to be
; atomic to the caller.
;
        mov     PCR[PcIrql], cl
        fstRET  KfRaiseIrql

if DBG
Kri99:  movzx   eax, al
        mov     byte ptr PCR[PcIrql],0   ; avoid recursive error
        stdCall   _KeBugCheckEx,<IRQL_NOT_GREATER_OR_EQUAL,eax,ecx,0,9>
        ; never returns (but need the following for the debugger)
        fstRET  KfRaiseIrql
endif

fstENDP KfRaiseIrql

;++
;
; VOID
; KIRQL
; KeRaiseIrqlToDpcLevel (
;    )
;
; Routine Description:
;
;    This routine is used to raise IRQL to DPC level.
;
; Arguments:
;
; Return Value:
;
;    OldIrql - the addr of a variable which old irql should be stored
;
;--

cPublicProc _KeRaiseIrqlToDpcLevel,0
cPublicFpo 0, 0

        xor     eax, eax                                ; avoid partial stall
        mov     al, PCR[PcIrql]                         ; (al) = Old Irql
        mov     byte ptr PCR[PcIrql], DISPATCH_LEVEL    ; set new irql

ifdef IRQL_METRICS
        inc     HalRaiseIrqlCount
endif
if DBG
        cmp     al, DISPATCH_LEVEL      ; old > new?
        ja      short Krid99            ; yes, go bugcheck
endif

        stdRET  _KeRaiseIrqlToDpcLevel

if DBG
cPublicFpo 0,1
Krid99: movzx   eax, al
        stdCall   _KeBugCheckEx,<IRQL_NOT_GREATER_OR_EQUAL,eax,DISPATCH_LEVEL,0,1>
        ; never returns (but need the following for the debugger)
        stdRET  _KeRaiseIrqlToDpcLevel
endif

stdENDP _KeRaiseIrqlToDpcLevel

;++
;
; VOID
; KIRQL
; KeRaiseIrqlToSynchLevel (
;    )
;
; Routine Description:
;
;    This routine is used to raise IRQL to SYNC level.
;
; Arguments:
;
; Return Value:
;
;    OldIrql - the addr of a variable which old irql should be stored
;
;--

cPublicProc _KeRaiseIrqlToSynchLevel,0
cPublicFpo 0, 0
        pushfd
        cli                             ; disable interrupt
        mov     eax, KiI8259MaskTable[SYNCH_LEVEL*4]; get pic masks for the new irql
        or      eax, PCR[PcIDR]         ; mask irqs which are disabled
        SET_8259_MASK                   ; set 8259 masks

        mov     al, PCR[PcIrql]         ; (al) = Old irql
        mov     byte ptr PCR[PcIrql], SYNCH_LEVEL   ; set new irql

        popfd

if DBG
        cmp     al, SYNCH_LEVEL
        ja      short Kris99
endif

ifdef IRQL_METRICS
        inc     HalRaiseIrqlCount
endif
        stdRET  _KeRaiseIrqlToSynchLevel

if DBG
cPublicFpo 0,1
Kris99: movzx   eax, al
        stdCall   _KeBugCheckEx,<IRQL_NOT_GREATER_OR_EQUAL,eax,SYNCH_LEVEL,0,2>
        stdRET  _KeRaiseIrqlToSynchLevel
endif

stdENDP _KeRaiseIrqlToSynchLevel

        page ,132
        subttl  "Lower irql"

;++
;
; VOID
; FASTCALL
; KfLowerIrql (
;    IN KIRQL NewIrql
;    )
;
; Routine Description:
;
;    This routine is used to lower IRQL to the specified value.
;    The IRQL and PIRQL will be updated accordingly.  Also, this
;    routine checks to see if any software interrupt should be
;    generated.  The following condition will cause software
;    interrupt to be simulated:
;      any software interrupt which has higher priority than
;        current IRQL's is pending.
;
;    NOTE: This routine simulates software interrupt as long as
;          any pending SW interrupt level is higher than the current
;          IRQL, even when interrupts are disabled.
;
;          On a UP system, HalEndSystenInterrupt is treated as a
;          LowerIrql.
;
; Arguments:
;
;    (cl) = NewIrql - the new irql to be set.
;
; Return Value:
;
;    None.
;
;--


cPublicFastCall KfLowerIrql    ,1
cPublicFpo 0,1

        pushfd                          ; save caller's eflags
        movzx   ecx, cl                 ; zero extend irql

if DBG
        cmp     cl,PCR[PcIrql]
        ja      short Kli99
endif
        cmp     byte ptr PCR[PcIrql],DISPATCH_LEVEL ; Software level?
        cli
        jbe     short kli02             ; no, go set 8259 hw

        mov     eax, KiI8259MaskTable[ecx*4]; get pic masks for the new irql
        or      eax, PCR[PcIDR]         ; mask irqs which are disabled
        SET_8259_MASK                   ; set 8259 masks
kli02:
        mov     PCR[PcIrql], cl         ; set the new irql
        mov     eax, PCR[PcIRR]         ; get SW interrupt request register
        mov     al, SWInterruptLookUpTable[eax] ; get the highest pending
                                        ; software interrupt level
        cmp     al, cl                  ; Is highest SW int level > irql?
        ja      Kli10                   ; yes, go simulate interrupt

kil03:  popfd                           ; restore flags, including ints
cPublicFpo 0,0
        fstRET    KfLowerIrql

if DBG
Kli99:
        movzx   eax, byte ptr PCR[PcIrql]; old irql for debugging
        mov     byte ptr PCR[PcIrql],HIGH_LEVEL   ; avoid recursive error
        stdCall   _KeBugCheckEx,<IRQL_NOT_LESS_OR_EQUAL,eax,ecx,0,3>
        ; never returns
endif

;
;   When we come to Kli10, (eax) = soft interrupt index
;
;   Note Do NOT:
;
;   popfd
;   jmp         SWInterruptHandlerTable[eax*4]
;
;   We want to make sure interrupts are off after entering SWInterrupt
;   Handler.
;

align 4
cPublicFpo 1,1
Kli10:  call    SWInterruptHandlerTable[eax*4] ; SIMULATE INTERRUPT
        popfd                           ; restore flags, including ints
cPublicFpo 1,0
        fstRET    KfLowerIrql                             ; cRetURN

fstENDP KfLowerIrql

;++
;
;  KIRQL
;  FASTCALL
;  KfAcquireSpinLock (
;     IN PKSPIN_LOCK SpinLock,
;     )
;
;  Routine Description:
;
;     This function raises to DISPATCH_LEVEL and then acquires a the
;     kernel spin lock.
;
;     In a UP hal spinlock serialization is accomplished by raising the
;     IRQL to DISPATCH_LEVEL.  The SpinLock is not used; however, for
;     debugging purposes if the UP hal is compiled with the NT_UP flag
;     not set (ie, MP) we take the SpinLock.
;
;  Arguments:
;
;     (ecx) = SpinLock - Supplies a pointer to an kernel spin lock.
;
;  Return Value:
;
;     OldIrql
;
;--

cPublicFastCall KfAcquireSpinLock,1
cPublicFpo 0,0

        xor     eax, eax                                ; avoid partial stall
        mov     al, PCR[PcIrql]                         ; (al) = Old Irql
        mov     byte ptr PCR[PcIrql], DISPATCH_LEVEL    ; set new irql

ifndef NT_UP
asl10:  ACQUIRE_SPINLOCK    ecx,<short asl20>
endif

ifdef IRQL_METRICS
        inc     HalRaiseIrqlCount
endif
if DBG
        cmp     al, DISPATCH_LEVEL      ; old > new?
        ja      short asl99             ; yes, go bugcheck
endif
        fstRET  KfAcquireSpinLock

ifndef NT_UP
asl20:  SPIN_ON_SPINLOCK    ecx,<short asl10>
endif

if DBG
cPublicFpo 2, 1
asl99:
        stdCall   _KeBugCheckEx,<IRQL_NOT_GREATER_OR_EQUAL,ecx,DISPATCH_LEVEL,0,4>
endif
        fstRET    KfAcquireSpinLock
fstENDP KfAcquireSpinLock


;++
;
;  KIRQL
;  FASTCALL
;  KeAcquireSpinLockRaiseToSynch (
;     IN PKSPIN_LOCK SpinLock,
;     )
;
;  Routine Description:
;
;     This function acquires the SpinLock at SYNCH_LEVEL.  The function
;     is optmized for hoter locks (the lock is tested before acquired.
;     Any spin should occur at OldIrql; however, since this is a UP hal
;     we don't have the code for it)
;
;     In a UP hal spinlock serialization is accomplished by raising the
;     IRQL to SYNCH_LEVEL.  The SpinLock is not used; however, for
;     debugging purposes if the UP hal is compiled with the NT_UP flag
;     not set (ie, MP) we take the SpinLock.
;
;  Arguments:
;
;     (ecx) = SpinLock - Supplies a pointer to an kernel spin lock.
;
;  Return Value:
;
;     OldIrql
;
;--

cPublicFastCall KeAcquireSpinLockRaiseToSynch,1
cPublicFpo 0,0

        push    ecx
        mov     ecx, SYNCH_LEVEL
        fstCall KfRaiseIrql             ; Raise to SYNCH_LEVEL
        pop     ecx

ifndef NT_UP
asls10: ACQUIRE_SPINLOCK    ecx,<short asls20>
endif

ifdef IRQL_METRICS
        inc     HalRaiseIrqlCount
endif
if DBG
        cmp     al, SYNCH_LEVEL         ; old > new?
        ja      short asls99            ; yes, go bugcheck
endif
        fstRET  KeAcquireSpinLockRaiseToSynch

ifndef NT_UP
asls20: SPIN_ON_SPINLOCK    ecx,<short asls10>
endif

if DBG
cPublicFpo 2, 1
asls99:
        stdCall _KeBugCheckEx,<IRQL_NOT_GREATER_OR_EQUAL,eax,DISPATCH_LEVEL,0,5>
        ; never returns
endif
        fstRET  KeAcquireSpinLockRaiseToSynch
fstENDP KeAcquireSpinLockRaiseToSynch


        PAGE
        SUBTTL "Release Kernel Spin Lock"
;++
;
;  VOID
;  FASTCALL
;  KfReleaseSpinLock (
;     IN PKSPIN_LOCK SpinLock,
;     IN KIRQL       NewIrql
;     )
;
;  Routine Description:
;
;     This function releases a kernel spin lock and lowers to the new irql
;
;     In a UP hal spinlock serialization is accomplished by raising the
;     IRQL to DISPATCH_LEVEL.  The SpinLock is not used; however, for
;     debugging purposes if the UP hal is compiled with the NT_UP flag
;     not set (ie, MP) we use the SpinLock.
;
;
;  Arguments:
;
;     (ecx) = SpinLock  - Supplies a pointer to an executive spin lock.
;     (dl)  = NewIrql   - New irql value to set
;
;  Return Value:
;
;     None.
;
;--

align 16
cPublicFastCall KfReleaseSpinLock  ,2
cPublicFpo 0,1
        pushfd

ifndef NT_UP
        RELEASE_SPINLOCK    ecx         ; release it
endif
        movzx   ecx, dl                 ; (ecx) = NewIrql
        cmp     byte ptr PCR[PcIrql],DISPATCH_LEVEL ; Software level?
        cli
        jbe     short rsl02             ; no, go set 8259 hw

        mov     eax, KiI8259MaskTable[ecx*4]; get pic masks for the new irql
        or      eax, PCR[PcIDR]         ; mask irqs which are disabled
        SET_8259_MASK                   ; set 8259 masks
rsl02:
        mov     PCR[PcIrql], cl
        mov     eax, PCR[PcIRR]         ; get SW interrupt request register
        mov     al, SWInterruptLookUpTable[eax] ; get the highest pending
                                        ; software interrupt level
        cmp     al, cl                  ; Is highest SW int level > irql?
        ja      short rsl20             ; yes, go simulate interrupt

        popfd
        fstRet  KfReleaseSpinLock       ; all done

align 4
rsl20:  call    SWInterruptHandlerTable[eax*4] ; SIMULATE INTERRUPT
        popfd                           ; restore flags, including ints
cPublicFpo 2,0
        fstRET  KfReleaseSpinLock       ; all done

fstENDP KfReleaseSpinLock


;++
;
;  VOID
;  FASTCALL
;  ExAcquireFastMutex (
;     IN PFAST_MUTEX    FastMutex
;     )
;
;  Routine description:
;
;   This function acquire ownership of the FastMutex
;
;  Arguments:
;
;     (ecx) = FastMutex - Supplies a pointer to the fast mutex
;
;  Return Value:
;
;     None.
;
;--

cPublicFastCall ExAcquireFastMutex,1
cPublicFpo 0,1

        push    ecx                             ; Save FastMutex
        mov     ecx, APC_LEVEL
        fstCall KfRaiseIrql                     ; Raise to APC_LEVEL
        pop     ecx                             ; (ecx) = FastMutex
cPublicFpo 0,0

if DBG
        mov     edx, PCR[PcPrcb]
        mov     edx, [edx].PbCurrentThread      ; (edx) = Current Thread
        cmp     [ecx].FmOwner, edx              ; Already owned by this thread?
        je      short afm98                     ; Yes, error
endif

   LOCK_DEC     dword ptr [ecx].FmCount         ; Get count
        jz      short afm_ret                   ; The owner? Yes, Done

        inc     dword ptr [ecx].FmContention

cPublicFpo 0,2
        push    ecx                             ; Save FastMutex
        push    eax                             ; Save OldIrql
        add     ecx, FmEvent                    ; Wait on Event
        stdCall _KeWaitForSingleObject,<ecx,WrExecutive,0,0,0>
        pop     eax
        pop     ecx
cPublicFpo 0,0

if DBG
        mov     edx, PCR[PcPrcb]
        mov     edx, [edx].PbCurrentThread      ; (edx) = Current Thread
endif

afm_ret:

if DBG
        mov     [ecx].FmOwner, edx              ; save owner in fast mutex
endif

        mov     byte ptr [ecx].FmOldIrql, al    ; (al) = OldIrql
        fstRet  ExAcquireFastMutex

if DBG

        ; KeBugCheckEx(MUTEX_ALREADY_OWNED, FastMutex, CurrentThread, 0, 6)
        ; (never returns)

afm98:  stdcall _KeBugCheckEx,<MUTEX_ALREADY_OWNED,ecx,edx,0,6>
        fstRet  ExAcquireFastMutex

endif

fstENDP ExAcquireFastMutex

;++
;
;  BOOLEAN
;  FASTCALL
;  ExTryToAcquireFastMutex (
;     IN PFAST_MUTEX    FastMutex
;     )
;
;  Routine description:
;
;   This function acquire ownership of the FastMutex
;
;  Arguments:
;
;     (ecx) = FastMutex - Supplies a pointer to the fast mutex
;
;  Return Value:
;
;     Returns TRUE if the FAST_MUTEX was acquired; otherwise false
;
;--

cPublicFastCall ExTryToAcquireFastMutex,1
cPublicFpo 0,1

;
; Try to acquire - but needs to support 386s.
; *** Warning: This code is NOT MP safe ***
; But, we know that this hal really only runs on UP machines
;

        push    ecx                             ; Save FAST_MUTEX

        mov     ecx, APC_LEVEL
        fstCall KfRaiseIrql                     ; (al) = OldIrql

        pop     edx                             ; (edx) = FAST_MUTEX

cPublicFpo 0,0

        cli
        cmp     dword ptr [edx].FmCount, 1      ; Busy?
        jne     short tam20                     ; Yes, abort

        mov     dword ptr [edx].FmCount, 0      ; acquire count

if DBG
        mov     ecx, PCR[PcPrcb]
        mov     ecx, [ecx].PbCurrentThread      ; (edx) = Current Thread
        mov     [edx].FmOwner, ecx              ; Save in Fast Mutex
endif

        sti

        mov     byte ptr [edx].FmOldIrql, al
        mov     eax, 1                          ; return TRUE
        fstRet  ExTryToAcquireFastMutex

tam20:  sti
        mov     ecx, eax                        ; (cl) = OldIrql
        fstCall KfLowerIrql                     ; restore OldIrql
        xor     eax, eax                        ; return FALSE
        YIELD
        fstRet  ExTryToAcquireFastMutex         ; all done

fstENDP ExTryToAcquireFastMutex


;++
;
;  VOID
;  FASTCALL
;  ExReleaseFastMutex (
;     IN PFAST_MUTEX    FastMutex
;     )
;
;  Routine description:
;
;   This function releases ownership of the FastMutex
;
;  Arguments:
;
;     (ecx) = FastMutex - Supplies a pointer to the fast mutex
;
;  Return Value:
;
;     None.
;
;--

cPublicFastCall ExReleaseFastMutex,1
cPublicFpo 0,0

if DBG
        mov     edx, PCR[PcPrcb]
        mov     edx, [edx].PbCurrentThread      ; (edx) = CurrentThread
        cmp     [ecx].FmOwner, edx              ; Owner == CurrentThread?
        jne     short rfm_threaderror           ; No, bugcheck

        or      byte ptr [ecx].FmOwner, 1       ; not the owner anymore
endif

        mov     al, byte ptr [ecx].FmOldIrql    ; (cl) = OldIrql

   LOCK_ADD     dword ptr [ecx].FmCount, 1  ; Remove our count
        xchg    ecx, eax                        ; (cl) = OldIrql
        js      short rfm05                     ; if < 0, set event
        jnz     @KfLowerIrql@4                  ; if != 0, don't set event

rfm05:  add     eax, FmEvent
        push    ecx
        stdCall _KeSetEventBoostPriority, <eax, 0>
        pop     ecx
        jmp     @KfLowerIrql@4

if DBG

        ; KeBugCheck(THREAD_NOT_MUTEX_OWNER, FastMutex, Thread, Owner, 7)
        ; (never returns)

rfm_threaderror:
        stdCall _KeBugCheckEx,<THREAD_NOT_MUTEX_OWNER,ecx,edx,[ecx].FmOwner,7>
        int     3

endif

fstENDP ExReleaseFastMutex


        page    ,132
        subttl  "Acquire Queued SpinLock"

;++
;
; KIRQL
; KeAcquireQueuedSpinLock (
;     IN KSPIN_LOCK_QUEUE_NUMBER Number
;     )
;
; KIRQL
; KeAcquireQueuedSpinLockRaiseToSynch (
;     IN KSPIN_LOCK_QUEUE_NUMBER Number
;     )
;
; VOID
; KeAcquireInStackQueuedSpinLock (
;     IN PKSPIN_LOCK SpinLock,
;     IN PKLOCK_QUEUE_HANDLE LockHandle
;     )
;
; VOID
; KeAcquireInStackQueuedSpinLockRaiseToSynch (
;     IN PKSPIN_LOCK SpinLock,
;     IN PKLOCK_QUEUE_HANDLE LockHandle
;     )
;
; Routine Description:
;
;    This function raises the current IRQL to DISPATCH/SYNCH level
;    and acquires the specified queued spinlock.
;
; Arguments:
;
;    Number (ecx) - Supplies the queued spinlock number.
;
; Return Value:
;
;    The previous IRQL is returned as the function value.
;
;
; Routine Description:
;
;    The Kx versions use a LOCK_QUEUE_HANDLE structure rather than
;    LOCK_QUEUE structures in the PRCB.   Old IRQL is stored in the
;    LOCK_QUEUE_HANDLE.
;
; Arguments:
;
;    SpinLock   (ecx) Address of Actual Lock.
;    LockHandle (edx) Address of lock context.
;
; Return Value:
;
;   None.  Actually returns OldIrql because common code is used
;          for all implementations.
;
;--

        ; compile time assert sizeof(KSPIN_LOCK_QUEUE) == 8

        .errnz  (LOCK_QUEUE_HEADER_SIZE - 8)
align 16


; VOID
; KeAcquireInStackQueuedSpinLock (
;     IN PKSPIN_LOCK SpinLock,
;     IN PKLOCK_QUEUE_HANDLE LockHandle
;     )
;

cPublicFastCall KeAcquireInStackQueuedSpinLock,2
cPublicFpo 0,0

ifndef NT_UP

        mov     [edx].LqhLock, ecx              ; save spin lock in lock handle
        mov     dword ptr [edx].LqhNext, 0      ; zero next pointer

endif

        push    DISPATCH_LEVEL                  ; raise to DISPATCH_LEVEL
aqsl0:
        pop     ecx
        push    edx                             ; save LockHandle
        fstCall KfRaiseIrql
        pop     edx                             ; restore lock handle
        mov     [edx].LqhOldIrql, al            ; save old IRQL in lock handle

ifndef NT_UP

        jmp     short aqslrs10                  ; continue in common code

else

ifdef IRQL_METRICS
        inc     HalRaiseIrqlCount
endif

        fstRET  KeAcquireInStackQueuedSpinLock

endif

fstENDP KeAcquireInStackQueuedSpinLock


; VOID
; KeAcquireInStackQueuedSpinLockRaiseToSynch (
;     IN PKSPIN_LOCK SpinLock,
;     IN PKLOCK_QUEUE_HANDLE LockHandle
;     )

cPublicFastCall KeAcquireInStackQueuedSpinLockRaiseToSynch,2
cPublicFpo 0,0

ifndef NT_UP

        mov     [edx].LqhLock, ecx              ; save spin lock in lock handle
        mov     dword ptr [edx].LqhNext, 0      ; zero next pointer

endif

        push    SYNCH_LEVEL                     ; raise to SYNCH_LEVEL
        jmp     short aqsl0

fstENDP KeAcquireInStackQueuedSpinLockRaiseToSynch



; KIRQL
; KeAcquireQueuedSpinLockRaiseToSynch (
;     IN KSPIN_LOCK_QUEUE_NUMBER Number
;     )

cPublicFastCall KeAcquireQueuedSpinLockRaiseToSynch,1
cPublicFpo 0,0

        push    ecx
        mov     ecx, SYNCH_LEVEL                ; Raise to SYNCH_LEVEL
        fstCall KfRaiseIrql
        pop     ecx

ifndef NT_UP

        jmp     short aqslrs                    ; continue in common code

else

ifdef IRQL_METRICS
        inc     HalRaiseIrqlCount
endif

        fstRET  KeAcquireQueuedSpinLockRaiseToSynch

endif

fstENDP KeAcquireQueuedSpinLockRaiseToSynch


; KIRQL
; KeAcquireQueuedSpinLock (
;     IN KSPIN_LOCK_QUEUE_NUMBER Number
;     )

cPublicFastCall KeAcquireQueuedSpinLock,1
cPublicFpo 0,0

        ; Get old IRQL and raise to DISPATCH_LEVEL

        xor     eax, eax
        mov     al, PCR[PcIrql]
        mov     byte ptr PCR[PcIrql], DISPATCH_LEVEL

if DBG
        cmp     al, DISPATCH_LEVEL
        ja      short aqsl
endif

ifndef NT_UP

aqslrs:
        ; Get address of Lock Queue entry

        mov     edx, PCR[PcPrcb]                ; get address of PRCB
        lea     edx, [edx+ecx*8].PbLockQueue    ; get &PRCB->LockQueue[Number]

        ; Get address of the actual lock.

aqslrs10:
        mov     ecx, [edx].LqLock
        push    eax                             ; save return value (old IRQL)
        mov     eax, edx                        ; save Lock Queue entry address

        ; Exchange the value of the lock with the address of this
        ; Lock Queue entry.

        xchg    [ecx], edx

        cmp     edx, 0                          ; check if lock is held
        jnz     short @f                        ; jiff held

        ; note: the actual lock address will be word aligned, we use
        ; the bottom two bits as indicators, bit 0 is LOCK_QUEUE_WAIT,
        ; bit 1 is LOCK_QUEUE_OWNER.

        or      ecx, LOCK_QUEUE_OWNER           ; mark self as lock owner
        mov     [eax].LqLock, ecx

        ; lock has been acquired, return.

aqsl20: pop     eax                             ; restore return value

endif

ifdef IRQL_METRICS
        inc     HalRaiseIrqlCount
endif

        fstRET  KeAcquireQueuedSpinLock

ifndef NT_UP

@@:
        ; The lock is already held by another processor.  Set the wait
        ; bit in this processor's Lock Queue entry, then set the next
        ; field in the Lock Queue entry of the last processor to attempt
        ; to acquire the lock (this is the address returned by the xchg
        ; above) to point to THIS processor's lock queue entry.

        or      ecx, LOCK_QUEUE_WAIT            ; set lock bit
        mov     [eax].LqLock, ecx

        mov     [edx].LqNext, eax               ; set previous acquirer's
                                                ; next field.

        ; Wait.
@@:
        YIELD                                   ; fire avoidance.
        test    [eax].LqLock, LOCK_QUEUE_WAIT   ; check if still waiting
        jz      short aqsl20                    ; jif lock acquired
        jmp     short @b                        ; else, continue waiting

endif

if DBG

aqsl:   mov     edx, DISPATCH_LEVEL
        stdCall _KeBugCheckEx,<IRQL_NOT_GREATER_OR_EQUAL,eax,edx,ecx,8>
        int     3
        ; never returns

endif

fstENDP KeAcquireQueuedSpinLock


        page    ,132
        subttl  "Release Queued SpinLock"

;++
;
; VOID
; KeReleaseInStackQueuedSpinLock (
;     IN PKLOCK_QUEUE_HANDLE LockHandle
;     )
;
; Routine Description:
;
;    This function releases a queued spinlock and lowers the IRQL to
;    its previous value.
;
;    This differs from KeReleaseQueuedSpinLock in that this version
;    uses a caller supplied lock context where that one uses a
;    predefined lock context in the processor's PRCB.
;
;    This version sets up a compatible register context and uses
;    KeReleaseQueuedSpinLock to do the actual work.
;
; Arguments:
;
;    LockHandle (ecx) - Address of Lock Queue Handle structure.
;
; Return Value:
;
;    None.
;
;--

cPublicFastCall KeReleaseInStackQueuedSpinLock,1
cPublicFpo 0,0

ifndef NT_UP

        movzx   edx, byte ptr [ecx].LqhOldIrql  ; get old irql
        lea     eax, [ecx].LqhNext              ; get address of lock struct
        jmp     short rqsl10                    ; continue in common code

else

        movzx   ecx, byte ptr [ecx].LqhOldIrql  ; get old irql
        jmp     @KfLowerIrql@4                  ; returns directly to our caller

endif


fstENDP KeReleaseInStackQueuedSpinLock


;++
;
; VOID
; KeReleaseQueuedSpinLock (
;     IN KSPIN_LOCK_QUEUE_NUMBER Number,
;     IN KIRQL                   OldIrql
;     )
;
; Routine Description:
;
;    This function releases a queued spinlock and lowers the IRQL to
;    its previous value.
;
; Arguments:
;
;    Number  (ecx) - Supplies the queued spinlock number.
;    OldIrql (dl)  - Supplies the IRQL value to lower to.
;
; Return Value:
;
;    None.
;
;--

cPublicFastCall KeReleaseQueuedSpinLock,2
cPublicFpo 0,0

.errnz  (LOCK_QUEUE_OWNER - 2)                  ; error if not bit 1 for btr

ifndef NT_UP

        ; Get address of Lock Queue entry

        mov     eax, PCR[PcPrcb]                ; get address of PRCB
        lea     eax, [eax+ecx*8].PbLockQueue    ; get &PRCB->LockQueue[Number]

rqsl10:
        push    ebx                             ; need another register
cPublicFpo 0,1

        ; Clear the lock field in the Lock Queue entry.

        mov     ebx, [eax].LqNext
        mov     ecx, [eax].LqLock

        ; Quick check: If Lock Queue entry's Next field is not NULL,
        ; there is another waiter.  Don't bother with ANY atomic ops
        ; in this case.
        ;
        ; Note: test clears CF and sets ZF appropriately, the following
        ; btr sets CF appropriately for the owner check.

        test    ebx, ebx

        ; clear the "I am owner" bit in the Lock entry.

        btr     ecx, 1                          ; clear owner bit.

if DBG

        jnc     short   rqsl98                  ; bugcheck if was not set
                                                ; tests CF
endif

        mov     [eax].LqLock, ecx               ; clear lock bit in queue entry
        jnz     short rqsl40                    ; jif another processor waits
                                                ; tests ZF

        ; ebx contains zero here which will be used to set the new owner NULL

        push    eax                             ; save &PRCB->LockQueue[Number]
cPublicFpo 0,2

        ; Use compare exchange to attempt to clear the actual lock.
        ; If there are still no processors waiting for the lock when
        ; the compare exchange happens, the old contents of the lock
        ; should be the address of this lock entry (eax).

        lock cmpxchg [ecx], ebx                 ; store 0 if no waiters
        pop     eax                             ; restore lock queue address
cPublicFpo 0,1
        jnz     short rqsl60                    ; jif store failed

        ; The lock has been released.  Lower IRQL and return to caller.

rqsl20:
        pop     ebx                             ; restore ebx
cPublicFpo 0,0

endif

        movzx   ecx, dl                         ; IRQL is 1st param KfLowerIrql
        jmp     @KfLowerIrql@4                  ; returns directly to our caller

        fstRET  KeReleaseQueuedSpinLock

ifndef NT_UP

        ; Another processor is waiting on this lock.   Hand the lock
        ; to that processor by getting the address of its LockQueue
        ; entry, turning ON its owner bit and OFF its wait bit.

rqsl40: xor     [ebx].LqLock, (LOCK_QUEUE_OWNER+LOCK_QUEUE_WAIT)

        ; Done, the other processor now owns the lock, clear the next
        ; field in my LockQueue entry (to preserve the order for entering
        ; the queue again) and proceed to lower IRQL and return.

        mov     [eax].LqNext, 0
        jmp     short rqsl20


        ; We get here if another processor is attempting to acquire
        ; the lock but had not yet updated the next field in this
        ; processor's Queued Lock Next field.   Wait for the next
        ; field to be updated.

rqsl60: mov     ebx, [eax].LqNext
        test    ebx, ebx                        ; check if still 0
        jnz     short rqsl40                    ; jif Next field now set.
        YIELD                                   ; wait a bit
        jmp     short rqsl60                    ; continue waiting

if DBG

cPublicFpo 0,1

rqsl98: stdCall _KeBugCheckEx,<SPIN_LOCK_NOT_OWNED,ecx,eax,0,1>
        int     3                               ; so stacktrace works

endif

endif

fstENDP KeReleaseQueuedSpinLock

        page    ,132
        subttl  "Try to Acquire Queued SpinLock"

;++
;
; LOGICAL
; KeTryToAcquireQueuedSpinLock (
;     IN  KSPIN_LOCK_QUEUE_NUMBER Number,
;     OUT PKIRQL OldIrql
;     )
;
; LOGICAL
; KeTryToAcquireQueuedSpinLockRaiseToSynch (
;     IN  KSPIN_LOCK_QUEUE_NUMBER Number,
;     OUT PKIRQL OldIrql
;     )
;
; Routine Description:
;
;    This function raises the current IRQL to DISPATCH/SYNCH level
;    and attempts to acquire the specified queued spinlock.  If the
;    spinlock is already owned by another thread, IRQL is restored
;    to its previous value and FALSE is returned.
;
; Arguments:
;
;    Number  (ecx) - Supplies the queued spinlock number.
;    OldIrql (edx) - A pointer to the variable to receive the old
;                    IRQL.
;
; Return Value:
;
;    TRUE if the lock was acquired, FALSE otherwise.
;    N.B. ZF is set if FALSE returned, clear otherwise.
;
;--


align 16
cPublicFastCall KeTryToAcquireQueuedSpinLockRaiseToSynch,2

ifndef NT_UP

cPublicFpo 0,3
        pushfd

else

cPublicFpo 0,2

endif

        push    edx
        push    SYNCH_LEVEL
        jmp     short taqsl10

fstENDP KeTryToAcquireQueuedSpinLockRaiseToSynch

cPublicFastCall KeTryToAcquireQueuedSpinLock,2

ifndef NT_UP

cPublicFpo 0,3
        pushfd

else

cPublicFpo 0,2

endif

        push    edx
        push    DISPATCH_LEVEL
taqsl10:

ifndef NT_UP

        ; Attempt to get the lock with interrupts disabled, raising
        ; the priority in the interrupt controller only if acquisition
        ; is successful.


        ; Get address of Lock Queue entry

        cli                                     ; disable interrupts
        mov     edx, PCR[PcPrcb]                ; get address of PRCB
        lea     edx, [edx+ecx*8].PbLockQueue    ; get &PRCB->LockQueue[Number]

        ; Get address of the actual lock.

        mov     ecx, [edx].LqLock
        cmp     dword ptr [ecx], 0              ; check if already taken
        jnz     short taqsl60                   ; jif already taken
        xor     eax, eax                        ; comparison value (not locked)

        ; Store the Lock Queue entry address in the lock ONLY if the
        ; current lock value is 0.

        lock cmpxchg [ecx], edx
        jnz     short taqsl60

        ; Lock has been acquired.

        ; note: the actual lock address will be word aligned, we use
        ; the bottom two bits as indicators, bit 0 is LOCK_QUEUE_WAIT,
        ; bit 1 is LOCK_QUEUE_OWNER.

        or      ecx, LOCK_QUEUE_OWNER           ; mark self as lock owner
        mov     [edx].LqLock, ecx

endif

        pop     ecx                             ; IRQL to ecx for RaiseIrql

ifndef NT_UP
cPublicFpo 0,2
else
cPublicFpo 0,1
endif

        fstCall KfRaiseIrql                     ; Raise IRQL

        pop     edx
        mov     [edx], al                       ; save OldIrql

ifndef NT_UP

        popfd                                   ; restore interrupt state

endif

        xor     eax, eax
        or      eax, 1                          ; return TRUE

        fstRET  KeTryToAcquireQueuedSpinLock

ifndef NT_UP

taqsl60:
        ; The lock is already held by another processor.  Indicate
        ; failure to the caller.

        pop     eax                             ; pop new IRQL off stack
        pop     edx                             ; pop saved OldIrql address
        popfd                                   ; restore interrupt state
        xor     eax, eax                        ; return FALSE
        fstRET  KeTryToAcquireQueuedSpinLock

endif

fstENDP KeTryToAcquireQueuedSpinLock

    page    ,132
    subttl  "End System Interrupt"

;++
;
; VOID
; HalpEndSystemInterrupt
;    IN KIRQL NewIrql,
;    IN ULONG Vector
;    )
;
; Routine Description:
;
;    This routine is used to lower IRQL to the specified value.
;    The IRQL and PIRQL will be updated accordingly.  Also, this
;    routine checks to see if any software interrupt should be
;    generated.  The following condition will cause software
;    interrupt to be simulated:
;      any software interrupt which has higher priority than
;        current IRQL's is pending.
;
;    NOTE: This routine simulates software interrupt as long as
;          any pending SW interrupt level is higher than the current
;          IRQL, even when interrupts are disabled.
;
; Arguments:
;
;    NewIrql - the new irql to be set.
;
;    Vector - Vector number of the interrupt
;
;    Note that esp+12 is the beginning of interrupt/trap frame and upon
;    entering to this routine the interrupts are off.
;
; Return Value:
;
;    None.
;
;--

HeiNewIrql      equ     [esp + 4]

cPublicProc _HalEndSystemInterrupt  ,2
cPublicFpo 2, 0

        movzx   ecx, byte ptr HeiNewIrql; get new irql value
        cmp     byte ptr PCR[PcIrql],DISPATCH_LEVEL ; Software level?
        jbe     short Hei02             ; no, go set 8259 hw

        mov     eax, KiI8259MaskTable[ecx*4]; get pic masks for the new irql
        or      eax, PCR[PcIDR]         ; mask irqs which are disabled
        SET_8259_MASK                   ; set 8259 masks

Hei02:
        mov     PCR[PcIrql], cl         ; set the new irql
        mov     eax, PCR[PcIRR]         ; get SW interrupt request register
        mov     al, SWInterruptLookUpTable[eax] ; get the highest pending
                                        ; software interrupt level
        cmp     al, cl                  ; Is highest SW int level > irql?
        ja      short Hei10             ; yes, go simulate interrupt

        stdRET    _HalEndSystemInterrupt                             ; cRetURN

;   When we come to Hei10, (eax) = soft interrupt index

Hei10:  add     esp, 12                 ; esp = trap frame
        jmp     SWInterruptHandlerTable2[eax*4] ; SIMULATE INTERRUPT
                                        ; to the appropriate handler

stdENDP _HalEndSystemInterrupt

;++
;
; VOID
; HalpEndSoftwareInterrupt
;    IN KIRQL NewIrql,
;    )
;
; Routine Description:
;
;    This routine is used to lower IRQL from software interrupt
;    level to the specified value.
;    The IRQL and PIRQL will be updated accordingly.  Also, this
;    routine checks to see if any software interrupt should be
;    generated.  The following condition will cause software
;    interrupt to be simulated:
;      any software interrupt which has higher priority than
;        current IRQL's is pending.
;
;    NOTE: This routine simulates software interrupt as long as
;          any pending SW interrupt level is higher than the current
;          IRQL, even when interrupts are disabled.
;
; Arguments:
;
;    NewIrql - the new irql to be set.
;
;    Note that esp+8 is the beginning of interrupt/trap frame and upon
;    entering to this routine the interrupts are off.
;
; Return Value:
;
;    None.
;
;--

HesNewIrql      equ     [esp + 4]

cPublicProc _HalpEndSoftwareInterrupt  ,1
cPublicFpo 1, 0

        movzx   ecx, byte ptr HesNewIrql; get new irql value

        cmp     byte ptr PCR[PcIrql],DISPATCH_LEVEL ; Software level?
        jbe     short Hes02             ; no, go set 8259 hw

        mov     eax, KiI8259MaskTable[ecx*4]; get pic masks for the new irql
        or      eax, PCR[PcIDR]         ; mask irqs which are disabled
        SET_8259_MASK                   ; set 8259 masks

Hes02:
        mov     PCR[PcIrql], cl         ; set the new irql
        mov     eax, PCR[PcIRR]         ; get SW interrupt request register
        mov     al, SWInterruptLookUpTable[eax] ; get the highest pending
                                        ; software interrupt level
        cmp     al, cl                  ; Is highest SW int level > irql?
        ja      short Hes10             ; yes, go simulate interrupt

        stdRET    _HalpEndSoftwareInterrupt                             ; cRetURN

;   When we come to Hes10, (eax) = soft interrupt index

Hes10:  add     esp, 8
        jmp     SWInterruptHandlerTable2[eax*4] ; SIMULATE INTERRUPT

                                        ; to the appropriate handler
stdENDP _HalpEndSoftwareInterrupt


        page ,132
        subttl  "Get current irql"

;++
;
; KIRQL
; KeGetCurrentIrql (VOID)
;
; Routine Description:
;
;    This routine returns to current IRQL.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    The current IRQL.
;
;--

cPublicProc _KeGetCurrentIrql   ,0
cPublicFpo 0, 0
        movzx   eax, word ptr PCR[PcIrql]   ; Current irql is in the PCR
        stdRET    _KeGetCurrentIrql
stdENDP _KeGetCurrentIrql


;++
;
; KIRQL
; HalpDisableAllInterrupts (VOID)
;
; Routine Description:
;
;   This routine is called during a system crash.  The hal needs all
;   interrupts disabled.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    None - all interrupts are masked off
;
;--

cPublicProc _HalpDisableAllInterrupts,0
cPublicFpo 0, 0

    ;
    ; Raising to HIGH_LEVEL disables interrupts for the microchannel HAL
    ;

        mov     ecx, HIGH_LEVEL
        fstCall KfRaiseIrql
        stdRET  _HalpDisableAllInterrupts

stdENDP _HalpDisableAllInterrupts


;++
;
; VOID
; HalpReenableInterrupts (
;     IN KIRQL Irql
;     )
;
; Routine Description:
;
;   Restores irql level.
;
; Arguments:
;
;    Irql - Irql state to restore to.
;
; Return Value:
;
;    None
;
;--

HriNewIrql      equ     [esp + 4]

cPublicProc _HalpReenableInterrupts,1
cPublicFpo 1, 0

        movzx   ecx, byte ptr HriNewIrql
        fstCall KfLowerIrql

        stdRET  _HalpReenableInterrupts

stdENDP _HalpReenableInterrupts

        page ,132
        subttl  "Interrupt Controller Chip Initialization"
;++
;
; VOID
; HalpInitializePICs (
;    BOOLEAN EnableInterrupts
;    )
;
; Routine Description:
;
;    This routine sends the 8259 PIC initialization commands and
;    masks all the interrupts on 8259s.
;
; Arguments:
;
;    EnableInterrupts - If this is true, then this function will
;                       explicitly enable interrupts at the end,
;                       as it always did in the past.  If this
;                       is false, then it will preserve the interrupt
;                       flag.
;
; Return Value:
;
;    None.
;
;--
EnableInterrupts equ [esp + 0ch]

cPublicProc _HalpInitializePICs       ,1

        push    esi                             ; save caller's esi
        pushfd
        cli                                     ; disable interrupt

        lea     esi, PICsInitializationString

        test    _HalpBusType, MACHINE_TYPE_MCA
        jz      short Hip00

; Is this a PS2 or PS700 series machine?

        in      al, 07fh                        ; get PD700 ID byte
        and     al, 0F0h                        ; Mask high nibble
        cmp     al, 0A0h                        ; Is the ID Ax?
        jz      short Hip00
        cmp     al, 090h                        ; Or an 9X?
        jz      short Hip00                     ; Yes, it's a 700

        lea     esi, PS2PICsInitializationString
Hip00:
        lodsw                                   ; (AX) = PIC port 0 address
Hip10:  movzx   edx, ax
        outsb                                   ; output ICW1
        IODelay
        inc     edx                             ; (DX) = PIC port 1 address
        outsb                                   ; output ICW2
        IODelay
        outsb                                   ; output ICW3
        IODelay
        outsb                                   ; output ICW4
        IODelay
        mov     al, 0FFH                        ; mask all 8259 irqs
        out     dx,al                           ; write mask to PIC
        lodsw
        cmp     ax, 0                           ; end of init string?
        jne     short Hip10                     ; go init next PIC

        mov     al, EnableInterrupts
        .if     (al != 0)
        or      [esp], EFLAGS_INTERRUPT_MASK    ; enable interrupts
        .endif
        popfd
        pop     esi                             ; restore caller's esi
        stdRET    _HalpInitializePICs
stdENDP _HalpInitializePICs


_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\i386\mp8254.inc ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halmps\i386\mp8254.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\i386\mpclock.asm ===
;
; Include code from halmps
; This is a cpp style symbolic link

ACPI_HAL equ 1
MMTIMER equ 1
	
include ..\..\halmps\i386\mpclock.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\i386\mpconfig.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halmps\i386\mpconfig.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\i386\mpipi.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

ACPI_HAL equ 1

include ..\..\halmps\i386\mpipi.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\i386\mpclksup.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

MMTIMER equ 1

include ..\..\halmps\i386\mpclksup.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\i386\mpirql.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halmps\i386\mpirql.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\i386\mpprofil.asm ===
;
; Include code from halmps
; This is a cpp style symbolic link

MMTIMER equ 1

include ..\..\halmps\i386\mpprofil.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\i386\mpspin.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halmps\i386\mpspin.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\i386\mpsproca.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halmps\i386\mpsproca.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\acpidtct.c ===
//
// This file simply includes the common sources from the current HAL
// directory. When the structure is finally changed, the real file should
// be in this directory.
//

#include "..\acpidtct.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\i386\mpswint.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halmps\i386\mpswint.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\rangesup.c ===
//
// This file simply includes the common sources from the current HAL
// directory. When the structure is finally changed, the real file should
// be in this directory.
//

#include "..\rangesup.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\i386\mpsysint.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halmps\i386\mpsysint.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\i386\xxbiosa.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halx86\i386\xxbiosa.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\i386\xxioacc.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halx86\i386\xxioacc.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\bushnd.c ===
//
// This file simply includes the common sources from the current HAL
// directory. When the structure is finally changed, the real file should
// be in this directory.
//

#include "..\bushnd.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\i386\pmrtc.asm ===
title  "ACPI Real Time Clock Functions"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    pmclock.asm
;
; Abstract:
;
;    This module implements the code for ACPI-related RTC
;    functions.
;
; Author:
;
;    Jake Oshins (jakeo) March 28, 1997
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;    Split from pmclock.asm due to PIIX4 bugs.
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include mac386.inc
include i386\ix8259.inc
include i386\ixcmos.inc
include xxacpi.h

        .list

        extrn   _HalpFixedAcpiDescTable:DWORD
        EXTRNP  _DbgBreakPoint,0,IMPORT
        EXTRNP  _HalpAcquireCmosSpinLock  ,0
        EXTRNP  _HalpReleaseCmosSpinLock  ,0
        extrn   _HalpRtcRegA:BYTE
        extrn   _HalpRtcRegB:BYTE
        extrn   _HalpCmosCenturyOffset:DWORD

INIT    SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
;   VOID
;   HalpInitializeCmos(
;       VOID
;       )
;
;   This routine reads CMOS and initializes globals required for
;   CMOS access, such as the location of the century byte.
;
;--

cPublicProc _HalpInitializeCmos,0
cPublicFpo 0,0        

        ;
        ; If the century byte is filled in, use it.
        ;
        
        movzx   eax, byte ptr [RTC_CENTURY]
        or      al, al
        jnz     short @f
        
        ;
        ; Assume default
        ;
        mov     eax, RTC_OFFSET_CENTURY

@@:
        mov     _HalpCmosCenturyOffset, eax
        
        stdRET  _HalpInitializeCmos

stdENDP _HalpInitializeCmos

INIT   ends

_TEXT$03   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;   NTSTATUS
;   HalpSetWakeAlarm (
;       IN ULONGLONG    WakeSystemTime,
;       IN PTIME_FIELDS WakeTimeFields OPTIONAL
;       )
;   /*++
;
;   Routine Description:
;
;       This routine sets the real-time clock's alarm to go
;       off at a specified time in the future and programs
;       the ACPI chipset so that this wakes the computer.
;
;   Arguments:
;
;       WakeSystemTime - amount of time that passes before we wake
;       WakeTimeFields - time to wake broken down into TIME_FIELDS
;
;   Return Value:
;
;       status
;
;   --*/
WakeSystemTime  equ [esp + 4]
WakeTimeFields  equ [esp + 12]

cPublicProc _HalpSetWakeAlarm, 3
cPublicFpo 3, 0

if DBG
hswawait0:
        mov     ecx, 100
hswawait:
        push    ecx
else
hswawait:
endif
        stdCall   _HalpAcquireCmosSpinLock
        mov     ecx, 100
        align   4
hswa00: mov     al, 0Ah                 ; Specify register A
        CMOS_READ                       ; (al) = CMOS register A
        test    al, CMOS_STATUS_BUSY    ; Is time update in progress?
        jz      short hswa10            ; if z, no, go write CMOS time
        loop    short hswa00            ; otherwise, try again.

;
; CMOS is still busy. Try again ...
;

        stdCall _HalpReleaseCmosSpinLock
if DBG
        pop     ecx
        loop    short hswawait
        stdCall _DbgBreakPoint
        jmp     short hswawait0
else
        jmp     short hswawait
endif
        align   4
if DBG
hswa10:
        pop     ecx
else
hswa10:
endif
        mov     edx, WakeTimeFields     ; (edx)-> TIME_FIELDS structure

        mov     al, [edx].TfSecond      ; Read second in TIME_FIELDS
        BIN_TO_BCD
        mov     ah, al
        mov     al, RTC_OFFSET_SECOND_ALARM
        CMOS_WRITE

        mov     al, [edx].TfMinute      ; Read minute in TIME_FIELDS
        BIN_TO_BCD
        mov     ah, al
        mov     al, RTC_OFFSET_MINUTE_ALARM
        CMOS_WRITE

        mov     al, [edx].TfHour        ; Read Hour in TIME_FIELDS
        BIN_TO_BCD
        mov     ah, al
        mov     al, RTC_OFFSET_HOUR_ALARM
        CMOS_WRITE

        ; test to see if RTC_DAY_ALRM is supported
        mov     cl, byte ptr [RTC_DAY_ALRM]
        or      cl, cl
        jz      hswa20

        mov     al, [edx].TfDay         ; Read day in TIME_FIELDS
        BIN_TO_BCD
        mov     ah, al
        mov     al, cl
        CMOS_WRITE

        ; test to see if RTC_MON_ALRM is supported
        mov     cl, byte ptr [RTC_MON_ALRM]
        or      cl, cl
        jz      hswa20

        mov     al, [edx].TfMonth       ; Read month in TIME_FIELDS
        BIN_TO_BCD
        mov     ah, al
        mov     al, cl
        CMOS_WRITE

;
; Don't clobber the Daylight Savings Time bit in register B, because we
; stash the LastKnownGood "environment variable" there.
;
hswa20:
        mov     ax, 0bh
        CMOS_READ
        and     al, 1
        mov     ah, al
        or      ah, REGISTER_B_ENABLE_ALARM_INTERRUPT or REGISTER_B_24HOUR_MODE
        mov     al, 0bh
        CMOS_WRITE                      ; Initialize it
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize
        mov     al,0DH                  ; Register D
        CMOS_READ                       ; Read to initialize


        stdCall   _HalpReleaseCmosSpinLock

        xor     eax, eax                ; return STATUS_SUCCESS
        stdRET  _HalpSetWakeAlarm
stdENDP _HalpSetWakeAlarm

_TEXT$03   ends

PAGELK   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; VOID
; HalpSetClockBeforeSleep (
;    VOID
;    )
;
; Routine Description:
;
;    This routine sets the RTC such that it will not generate
;    periodic interrupts while the machine is sleeping, as this
;    could be interpretted as an RTC wakeup event.
;
; Arguments:
;
; Return Value:
;
;    None
;
;--
cPublicProc _HalpSetClockBeforeSleep, 0
cPublicFpo 0, 0

        stdCall   _HalpAcquireCmosSpinLock

        mov     al, 0ah
        CMOS_READ
        mov     _HalpRtcRegA, al        ; save RTC Register A

        or      al, al
        jnz     @f                      ; TEMP - debug stop
    int 3                               ; looking for reg-a corruption
@@:

        mov     al, 0bh
        CMOS_READ
        mov     _HalpRtcRegB, al        ; save RTC Register B
        and     al, not REGISTER_B_ENABLE_PERIODIC_INTERRUPT
        or      al, REGISTER_B_24HOUR_MODE
        mov     ah, al
        mov     al, 0bh
        CMOS_WRITE                      ; Initialize it
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize
        mov     al,0DH                  ; Register D
        CMOS_READ                       ; Read to initialize


        stdCall   _HalpReleaseCmosSpinLock

        stdRET  _HalpSetClockBeforeSleep
stdENDP _HalpSetClockBeforeSleep


;++
;
; VOID
; HalpSetClockAfterSleep (
;    VOID
;    )
;
; Routine Description:
;
;    This routine sets the RTC back to the way it was
;    before a call to HalpSetClockBeforeSleep.
;
; Arguments:
;
; Return Value:
;
;    None
;
;--
cPublicProc _HalpSetClockAfterSleep, 0
cPublicFpo 0, 0

        stdCall   _HalpAcquireCmosSpinLock

        mov     ah, _HalpRtcRegA        ; restore RTC Register A
        mov     al, 0ah
        CMOS_WRITE

        mov     ah, _HalpRtcRegB        ; restore RTC Register B
        and     ah, not REGISTER_B_ENABLE_ALARM_INTERRUPT
        or      ah, REGISTER_B_24HOUR_MODE
        mov     al, 0bh
        CMOS_WRITE                      ; Initialize it
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize
        mov     al,0DH                  ; Register D
        CMOS_READ                       ; Read to initialize

        stdCall   _HalpReleaseCmosSpinLock

        stdRET  _HalpSetClockAfterSleep
stdENDP _HalpSetClockAfterSleep

PAGELK   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\i386\pmstall.asm ===
title  "Stall Execution Support"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    ixstall.asm
;
; Abstract:
;
;    This module implements the code necessary to field and process the
;    interval clock interrupt.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 12-Jan-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;   bryanwi 20-Sep-90
;
;       Add KiSetProfileInterval, KiStartProfileInterrupt,
;       KiStopProfileInterrupt procedures.
;       KiProfileInterrupt ISR.
;       KiProfileList, KiProfileLock are delcared here.
;
;   shielint 10-Dec-90
;       Add performance counter support.
;       Move system clock to irq8, ie we now use RTC to generate system
;         clock.  Performance count and Profile use timer 1 counter 0.
;         The interval of the irq0 interrupt can be changed by
;         KiSetProfileInterval.  Performance counter does not care about the
;         interval of the interrupt as long as it knows the rollover count.
;       Note: Currently I implemented 1 performance counter for the whole
;       i386 NT.
;
;   John Vert (jvert) 11-Jul-1991
;       Moved from ke\i386 to hal\i386.  Removed non-HAL stuff
;
;   shie-lin tzong (shielint) 13-March-92
;       Move System clock back to irq0 and use RTC (irq8) to generate
;       profile interrupt.  Performance counter and system clock use time1
;       counter 0 of 8254.
;
;   Landy Wang (corollary!landy) 04-Dec-92
;       Created this module by moving routines from ixclock.asm to here.
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\ix8259.inc
include i386\kimacro.inc
include mac386.inc
include i386\ixcmos.inc
include xxacpi.h
        .list

        EXTRNP  _KeBugCheckEx,5,IMPORT
        EXTRNP  _DbgBreakPoint,0,IMPORT
        EXTRNP  _HalpAcquireCmosSpinLock  ,0
        EXTRNP  _HalpReleaseCmosSpinLock  ,0
        extrn   _HalpFixedAcpiDescTable:DWORD
        extrn   _QueryTimer:DWORD
	extrn   _PMTimerFreq:DWORD
        
_DATA   SEGMENT  DWORD PUBLIC 'DATA'

MinimumLoopQuantum      equ     42
MinimumLoopCount        dd      MinimumLoopQuantum
KqpcStallCount          db      0
	
; temptemp
if DBG
HalpAcpiStallIns        dd      0
endif

_DATA   ends

INIT    SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Initialize Stall Execution Counter"
;++
;
; VOID
; HalpInitializeStallExecution (
;    IN CCHAR ProcessorNumber
;    )
;
; Routine Description:
;
;    This routine is obsolete in this HAL.
;
; Arguments:
;
;    ProcessorNumber - Processor Number
;
; Return Value:
;
;    None.
;
;--

cPublicProc _HalpInitializeStallExecution     ,1
        stdRET    _HalpInitializeStallExecution
stdENDP _HalpInitializeStallExecution

        page ,132
        subttl  "Stall Execution"

cPublicProc _HalpRemoveFences
        mov     word ptr fence1, 0c98bh
        stdRET    _HalpRemoveFences
stdENDP _HalpRemoveFences

INIT   ends

_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;++
;
; VOID
; HalpAcpiTimerStallExecProc(
;    IN ULONG MicroSeconds
;    )
;
; Routine Description:
;
;    This function stalls execution for the specified number of microseconds.
;    KeStallExecutionProcessor
;
; Arguments:
;
;    MicroSeconds - Supplies the number of microseconds that execution is to be
;        stalled.
;
; Return Value:
;
;    None.
;
; Comments:
;    
;    edi     - total ticks elapsed
;    ebx:esi - starting time, in ticks
;
;--

Target           equ [ebp + 8]
cyclesStalled    equ [ebp - 4]

MASK24           equ 0ff000000h
BIT24            equ 001000000h

cPublicProc _HalpAcpiTimerStallExecProc       ,1
cPublicFpo 1, 5

;
; Issue a CPUID to implement a "fence"
;
        push    ebp
        mov     ebp, esp
        sub     esp, 4                          ; make room for locals        
        push    ebx                             ; cpuid uses eax, ebx, ecx, edx
        push    esi
        push    edi

        xor     eax, eax                        ; Processor zero
        
    .586p
fence1: cpuid
    .386p

        xor     edi, edi                        ; zero total stall count
        
        mov     eax, Target
        
        or      eax, eax
        jz      aese10                          ; return if no loop needed

        ; 'Target' starts out as the argument of the function.
        ; It is in uSeconds.  We convert to timer ticks.
        mov     ebx, _PMTimerFreq
        mul     ebx
        mov     ebx, 1000000
        div     ebx
	sub     eax, 1		                ; fudge factor
	
	mov     Target, eax
        
        mov     eax, _QueryTimer                ; move current counter into edx:eax
        call    eax
        
        mov     esi, eax                        ; record the starting tick count
        mov     ebx, edx

if DBG        
        inc     HalpAcpiStallIns
endif        
        mov     cyclesStalled, 0
        mov     eax, MinimumLoopCount
        
AcpiLoop:
        add     cyclesStalled, eax              ; update total cycles stalled
ALIGN 16
        YIELD
        jmp     short aese05

ALIGN 16
        YIELD
aese05: sub     eax, 1                          ; (eax) = (eax) - 1
        jnz     short aese05

        ;
        ; Now figure out if we have to loop again
        ;
        mov     eax, _QueryTimer                ; move current counter into edx:eax
        call    eax
        
        sub     eax, esi                        ; get actual elapsed ticks
        sbb     edx, ebx                        ; check to see that the upper 32 bits agrees
        
if 0        
        jnl     short @f
        int 3                                   ; time seems to have gone backwards
@@:        
endif        
        
        jz      short aese06
        ;
        ; If the upper 32 bits doesn't agree, then something, perhaps the debugger,
        ; has caused time to slip a whole lot.  Just fix up the bottom 32-bits to
        ; reflect a large time slip to make the math simpler.
        ;
        
        mov     eax, 7fffffffh
aese06:
        
        ; edx:eax now contains the number of timer ticks elapsed
        
        cmp     eax, 3                          ; if 1 less than 1uS elapsed, loop some more
        jge     short aese09
        
        add     MinimumLoopCount, MinimumLoopQuantum
        mov     eax, MinimumLoopCount
        jmp     short AcpiLoop                  ; loop some more
        
aese09: mov     edi, eax                        ; edi <- total number of ticks elapsed
                
if DBG        
        or      edi, edi                        ; if the total elapsed ticks is still 0,
        jz      short aese20                    ; the timer hardware is broken.  Bugcheck.
endif        
        
        ; if we have waited long enough, quit
        cmp     edi, Target
        jge     short aese10
        
        ; calculate remaining wait
        push    ebx
        mov     ebx, Target
        sub     ebx, edi                        ; ebx <- remaining ticks
        
        mov     eax, cyclesStalled
        mul     ebx                             ; multiply by number of ticks remaining to wait
        and     edx, 011b                       ; chop edx so that we don't overflow
        div     edi                             ; divide by the number of ticks we have waited
	inc     eax		                ; Never zero!
        pop     ebx
@@:     jmp     AcpiLoop

aese10:
        ;
        ; Knock down MinimumLoopCount once every 0x100 calls to this
        ; function so that we don't accidentally stall for very
        ; large amounts of time.
        ;
        
        inc     KqpcStallCount
        .if ((KqpcStallCount == 0) && (MinimumLoopCount > MinimumLoopQuantum))
        mov     eax, MinimumLoopCount
        sub     eax, MinimumLoopQuantum
        mov     MinimumLoopCount, eax
        .endif

        pop     edi
        pop     esi
        pop     ebx
        mov     esp, ebp
        pop     ebp
        stdRET    _HalpAcpiTimerStallExecProc
        
if DBG
aese20:
        mov     eax, 0a5h
        mov     ebx, 020000h
        xor     esi, esi
        xor     edi, edi
        stdCall _KeBugCheckEx, <eax, ebx, edx, esi, edi>
        jmp     short aese10
endif        
        
stdENDP _HalpAcpiTimerStallExecProc

_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halacpi\i386\pmtimer.asm ===
title  "ACPI Timer Functions"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    pmtimer.asm
;
; Abstract:
;
;    This module implements the code for ACPI-related timer
;    functions.
;
; Author:
;
;    Jake Oshins (jakeo) March 28, 1997
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;    Split from pmclock.asm due to PIIX4 bugs.
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include mac386.inc
include i386\ix8259.inc
include i386\ixcmos.inc
include xxacpi.h

        .list

        extrn   _HalpFixedAcpiDescTable:DWORD
        extrn   _HalpPiix4:byte
        extrn   _HalpNextMSRate:DWORD
	extrn   _PMTimerFreq:DWORD
if DBG
        extrn   _LastKQPCValue:DWORD
endif        
        
;
; ==== Values used for ACPI Clock ====
;


_DATA   SEGMENT  DWORD PUBLIC 'DATA'

MSBMASK24       equ     00800000h
MSBMASK32       equ     80000000h

CurrentTimePort equ     0
TimeLow         equ     4
TimeHigh2       equ     8
TimeHigh1       equ     12
MsbMask         equ     16
BiasLow         equ     20
BiasHigh        equ     24
UpperBoundLow   equ     28
UpperBoundHigh2 equ     32
UpperBoundHigh1 equ     36

        public _TimerInfo
_TimerInfo       dd      0,0,0,0,MSBMASK24,0,0,0,2,2

        public _QueryTimer
_QueryTimer      dd offset FLAT:@HalpQueryPerformanceCounter

if 0
;
; The UpperBoundTable contains the values which should be added 
; to the current counter value to ensure that the upper bound is
; reasonable.  Values listed here are for all the 15 possible
; timer tick lengths.  The unit is "PM Timer Ticks" and the
; value corresponds to the number of ticks that will pass in
; roughly two timer ticks at this rate.
;
UpperBoundTable dd      14000           ;  1 ms
                dd      28600           ;  2 ms
                dd      43200           ;  3 ms
                dd      57200           ;  4 ms
                dd      71600           ;  5 ms
                dd      86000           ;  6 ms
                dd      100200          ;  7 ms
                dd      114600          ;  8 ms
                dd      128800          ;  9 ms
                dd      143400          ; 10 ms
                dd      157400          ; 11 ms
                dd      171800          ; 12 ms
                dd      186200          ; 13 ms
                dd      200400          ; 14 ms
                dd      214800          ; 15 ms
endif

if DBG
TicksPassed     dd      0,0

        public _TimerPerf, _TimerPerfIndex
_TimerPerf db 4096 dup(0)        

RawRead0        equ     0
RawRead1        equ     4
AdjustedLow0    equ     8
AdjustedHigh0   equ     12
AdjustedLow1    equ     16
AdjustedHigh1   equ     20
TITL            equ     24
TITH            equ     28
UBL             equ     32
UBH             equ     36
ReturnedLow     equ     40
ReturnedHigh    equ     44
ReadCount       equ     48
TickMin         equ     52
TickCount       equ     56
TickNewUB       equ     60
TimerPerfBytes  equ     64

_TimerPerfIndex dd      0

endif

_DATA   ends

_TEXT$03   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Query Performance Counter"
;++
;
; VOID
; HalCalibratePerformanceCounter (
;     IN LONG volatile *Number,
;     IN ULONGLONG NewCount
;     )
;
; /*++
;
; Routine Description:
;
;     This routine resets the performance counter value for the current
;     processor to zero. The reset is done such that the resulting value
;     is closely synchronized with other processors in the configuration.
;
; Arguments:
;
;     Number - Supplies a pointer to count of the number of processors in
;     the configuration.
;
;     NewCount - Supplies the value to synchronize the counter too
;
; Return Value:
;
;     None.
;--
cPublicProc _HalpPmTimerCalibratePerfCount, 3
cPublicFpo 3,1
        push    edi
        mov     edi, [esp+8]                    ; ponter to context

        cmp     byte ptr PCR[PcNumber], 0       ; only execute on one processor
        jnz     short hcp_50                    ; if not boot processor, wait

        mov     eax, _QueryTimer                ; move current counter into edx:eax
        call    eax

        mov     ecx, [esp+12]                   ; compute how far current count
        sub     ecx, eax                        ; is from target count
        mov     eax, [esp+16]
        sbb     eax, edx

        mov     _TimerInfo.BiasLow, ecx         ; replace bias
        mov     _TimerInfo.BiasHigh, eax

hcp_50:
    lock dec    dword ptr [edi]                 ; count down

@@:     YIELD
        cmp     dword ptr [edi], 0              ; wait for all processors to signal
        jnz     short @b

        pop     edi
        stdRET    _HalpPmTimerCalibratePerfCount

stdENDP _HalpPmTimerCalibratePerfCount

        page ,132
        subttl  "Query Performance Counter"
;++
;
; LARGE_INTEGER
; FASTCALL
; HalpQueryPerformanceCounter(
;     VOID
;     )
;
; Routine Description:
;
;     This function is a simplified form of HalpAcpiTimerQueryPerfCount
;     meant to be used internally by the HAL.
;
cPublicFastCall HalpQueryPerformanceCounter,0
cPublicFpo 0, 2

        push    ebx
        push    esi

        ;
        ; Snap current times
        ;

kqpc10: YIELD
        mov     esi, _TimerInfo.TimeHigh2
        mov     ebx, _TimerInfo.TimeLow

        cmp     esi, _TimerInfo.TimeHigh1
        jne     short kqpc10        ; Loop until consistent copy read

        mov     edx, _TimerInfo.CurrentTimePort
        in      eax, dx

        ;
        ; See if h/w MSb matches s/w copy
        ;

        mov     ecx, _TimerInfo.MsbMask
        mov     edx, eax
        xor     edx, ebx
        and     edx, ecx            ; Isolate MSb match or mismatch

        ;
        ; Strip high hardware bit
        ;
        
        not     ecx
        and     eax, ecx
        not     ecx
        
        ;
        ; merge low bits
        ;

        dec     ecx                 
        not     ecx                 
        and     ebx, ecx
        or      eax, ebx
        
        ;
        ; If there was a mismatch, add a tick
        ;

        add     eax, edx
        adc     esi, 0
        
        mov     edx, esi                ; get the top-half of the return value

        pop     esi
        pop     ebx
        fstRET    HalpQueryPerformanceCounter
fstENDP HalpQueryPerformanceCounter


;++
;
; LARGE_INTEGER
; HalpPmTimerQueryPerfCount (
;    OUT PLARGE_INTEGER PerformanceFrequency OPTIONAL
;    )
;
; Routine Description:
;
;    This routine returns current 64-bit performance counter and,
;    optionally, the Performance Frequency.
;
;    N.B. The performace counter returned by this routine is
;    not necessary the value when this routine is just entered.
;    The value returned is actually the counter value at any point
;    between the routine is entered and is exited.
;
; Arguments:
;
;    PerformanceFrequency [TOS+4] - optionally, supplies the address
;        of a variable to receive the performance counter frequency.
;
; Return Value:
;
;    Current value of the performance counter will be returned.
;
;--

KqpcFrequency   EQU     [esp+8]     ; User supplied Performance Frequence

cPublicProc _HalpPmTimerQueryPerfCount, 1
.FPO (0, 1, 0, 1, 0, 0) 

        push    esi
        
        mov     eax, _QueryTimer
        call    eax

if 0
        ;
        ; Check to see if the timer ever reports time moving backwards
        ;
@@:        
        mov     esi, [_LastKQPCValue+8]
        mov     ecx, [_LastKQPCValue]
        cmp     esi, [_LastKQPCValue+4]
        jne     short @b
        
        cmp     edx, esi        ; check for rollover
        jl      short @f        

        sub     ecx, eax
        sbb     esi, edx
        jng     short @f
        int 3
@@:     
        mov     [_LastKQPCValue+4], edx
        mov     [_LastKQPCValue], eax
        mov     [_LastKQPCValue+8], edx
endif        

        ;
        ; Apply bias to time
        ;

        mov     ecx, _TimerInfo.BiasLow
        mov     esi, _TimerInfo.BiasHigh
        add     eax, ecx
        adc     edx, esi

        mov     ecx, KqpcFrequency
        or      ecx, ecx
        jnz     short kqpc20

	pop esi
	
        stdRET  _HalpPmTimerQueryPerfCount

kqpc20: mov     esi, _PMTimerFreq 
	mov     [ecx], esi  ; Hertz of PM timer
        mov     [ecx+4], 0
	pop     esi
        stdRET  _HalpPmTimerQueryPerfCount

stdENDP _HalpPmTimerQueryPerfCount

;++
;
; VOID
; HalAcpiTimerCarry (
;    VOID
;    )
;
; Routine Description:
;
;    This routine is called to service the PM timer carry interrupt
;
;    N.B. This function is called at interrupt time and assumes the
;    caller clears the interrupt
;
; Arguments:
;
;    None
;
; Return Value:
;
;    None
;
;--


cPublicProc _HalAcpiTimerCarry, 0
cPublicFpo 0, 1

        push    ebx

        ;
        ; Get current time from h/w
        ;

        mov     edx, _TimerInfo.CurrentTimePort
        in      eax, dx
        mov     ebx, eax

        mov     ecx, _TimerInfo.MsbMask
        mov     eax, _TimerInfo.TimeLow
        mov     edx, _TimerInfo.TimeHigh2

        ;
        ; Add one tick
        ;

        add     eax, ecx
        adc     edx, 0

        ;
        ; MSb of h/w should now match s/w.  If not, add another tick
        ; to get them back in sync.  (debugger might knock them
        ; out of sync)
        ;

        xor     ebx, eax
        and     ebx, ecx
        add     eax, ebx
        adc     edx, 0

        ;
        ; Store in reverse order of code which reads it
        ;

        mov     _TimerInfo.TimeHigh1, edx
        mov     _TimerInfo.TimeLow, eax
        mov     _TimerInfo.TimeHigh2, edx

        pop     ebx
        stdRET  _HalAcpiTimerCarry
stdENDP _HalAcpiTimerCarry

;++
;
; VOID
; HalAcpiBrokenPiix4TimerCarry (
;    VOID
;    )
;
; Routine Description:
;
;    This routine does nothing.  When we are using the Broken Piix4 
;    Code (TM), we are guaranteed to have examined the timer many times
;    since the last rollover.  So we don't need to do any bookkeeping
;    here.
;
;    N.B. This function is called at interrupt time and assumes the
;    caller clears the interrupt
;
; Arguments:
;
;    None
;
; Return Value:
;
;    None
;
;--
cPublicProc _HalAcpiBrokenPiix4TimerCarry, 0
        stdRET  _HalAcpiBrokenPiix4TimerCarry
stdENDP _HalAcpiBrokenPiix4TimerCarry

_TEXT$03   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\sources.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.


Author:

    Steve Wood (stevewo) 12-Apr-1990

NOTE:   Commented description of this file is in \nt\bak\bin\sources.tpl

!ENDIF

MAJORCOMP=ntos
MINORCOMP=hal

TARGETPATH=obj

!IF $(IA64)

TARGETTYPE=HAL

PASS1_PUBLISH={$(O)\hal.lib=$(DDK_LIB_PATH)\hal.lib}

INCLUDES=$(PROJECT_ROOT)\ntos\inc;               \
         $(PROJECT_ROOT)\ntos\ke;                \
         $(PROJECT_ROOT)\ntos\ke\ia64;           \
         ..\..;                                  \
         ..;                                     \
         $(PROJECT_ROOT)\ntos\io;                \
         ..\ia64;                                \
         ..\..\inc;                              \
         $(PROJECT_ROOT)\hals\x86new;            \
         $(HALKIT_INC_PATH);                     \
         $(HALKIT_INC_PATH)\ia64

LINKLIBS=..\..\x86new\$(O)\x86new.lib $(SDK_LIB_PATH)\libc.lib $(PROJECT_ROOT)\boot\kdcom\$(O)\kdcom.lib

!ELSE

TARGETTYPE=DRIVER

!ENDIF

C_DEFINES=-DAPIC_MACHINE -DACPI64 $(C_DEFINES) -DNO_LEGACY_DRIVERS

SOURCES=

IA64_SOURCES=..\hal.rc            \
             ..\acpidtct.c        \
             ..\ia64\haldebug.c   \
             ..\ia64\i64cache.c   \
             ..\ia64\ixhalt.c     \
             ..\ia64\ixhwsup.c    \
             ..\ia64\ixinfo.c     \
             ..\ia64\ixisasup.c   \
             ..\ia64\ixmca.c      \
             ..\ia64\ixphwsup.c   \
             ..\ia64\ixpnpdrv.c   \
             ..\ia64\ixreboot.c   \
             ..\ia64\ixslpsup.c   \
             ..\ia64\ixthrotl.c   \
             ..\ia64\ixusage.c    \
             ..\ia64\ixisabus.c   \
             ..\ia64\i64pcibus.c  \
             ..\ia64\i64ioacc.c   \
             ..\ia64\i64fwasm.s   \
             ..\ia64\i64itm.s     \
             ..\ia64\i64dma.c     \
             ..\ia64\i64generic.c \
             ..\ia64\i64krnl.c    \
             ..\ia64\i64clock.c   \
             ..\ia64\i64lock.c    \
             ..\ia64\i64bios.c    \
             ..\ia64\i64efi.c     \
             ..\ia64\i64efis.s    \
             ..\ia64\i64fw.c      \
             ..\ia64\i64perfc.c   \
             ..\ia64\i64prfle.c   \
             ..\ia64\i64prfls.s   \
             ..\ia64\i64sxint.c   \
             ..\ia64\i64sapic.c   \
             ..\ia64\i64sysbus.c  \
             ..\ia64\i64dat.c     \
             ..\ia64\i64bus.c     \
             ..\ia64\merced.c     \
             ..\ia64\miscs.s      \
             ..\ia64\gbacpi.c     \
             ..\ia64\osmca.c      \
             ..\ia64\osinit.c     \
             ..\ia64\osmchk.s     \
             ..\ia64\osinitchk.s  \
             ..\ia64\pmsapic.c    \
             ..\ia64\pmbus.c      \
             ..\ia64\pmpcisup.c   \
             ..\ia64\pmsleep.c    \
             ..\ia64\pmisabus.c   \
             ..\ia64\pmdata.c     \
             ..\ia64\xxacpi.c     \
             ..\ia64\xxbiosc.c    \
             ..\ia64\xxhal.c      \
             ..\ia64\xxdisp.c     \
             ..\ia64\xxmemory.c   \
             ..\ia64\xxstubs.c    \
             ..\ia64\xxtime.c     \
             ..\ia64\sratnuma.c

MSC_WARNING_LEVEL=/W3 /WX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\check.h ===
#ifndef CHECK_H_INCLUDED
#define CHECK_H_INCLUDED

//###########################################################################
//**
//**  Copyright  (C) 1996-99 Intel Corporation. All rights reserved.
//**
//** The information and source code contained herein is the exclusive
//** property of Intel Corporation and may not be disclosed, examined
//** or reproduced in whole or in part without explicit written authorization
//** from the company.
//**
//###########################################################################

//-----------------------------------------------------------------------------
// Version control information follows.
//
// $Header: /dev/SAL/INCLUDE/check.h 3     4/21/00 12:52p Mganesan $
// $Log: /dev/SAL/INCLUDE/check.h $
//
// 3     4/21/00 12:52p Mganesan
// Sync Up SAL 5.8
//
//   Rev 1.8   18 Jun 1999 16:29:00   smariset
//
//
//   Rev 1.7   08 Jun 1999 11:29:04   smariset
//Added Fatal Error Define
//
//   Rev 1.6   14 May 1999 09:01:26   smariset
//removal of tabs
//
//   Rev 1.5   07 May 1999 11:27:16   smariset
//Copyright update and Platform Record Hdr. Update
//
//   Rev 1.4   06 May 1999 16:06:42   smariset
//PSI Record Valid Bits Change (No bnk Regs)
//
//   Rev 1.3   05 May 1999 14:13:12   smariset
//Pre Fresh Build 
//
//   Rev 1.2   24 Mar 1999 09:40:06   smariset
// 
//
//   Rev 1.1   09 Mar 1999 13:12:52   smariset
//updated
//
//   Rev 1.0   09 Mar 1999 10:02:28   smariset
//First time check
// 
//*****************************************************************************//

// #define _INTEL_CHECK_H  1

#if defined(_INTEL_CHECK_H)

#define OEM_RECID_CMOS_RAM_ADDR 64              // OEM should define this
#define INIT_IPI_VECTOR         0x500
// SAL_MC_SET_PARAMS
#define RZ_VECTOR               0xf3
#define WKP_VECTOR              0x12            // Rendz. wakeup interrupt vector (IA-32 MCHK Exception Vector)
#define CMC_VECTOR              0xf2            //
#define TIMEOUT                 1000

#endif // _INTEL_CHECK_H

#define IntrVecType             0x01
#define MemSemType              0x02
#define RendzType               0x01
#define WakeUpType              0x02
#define CpevType                0x03

// SAL_SET_VECTORS
#define MchkEvent               0x00
#define InitEvent               0x01
#define BootRzEvent             0x02

#if defined(_INTEL_CHECK_H)

#define ProcCmcEvent            0x02
#define PlatCmcEvent            0x03
#define OsMcaSize               0x20
#define OsInitSize              0x20

// Misc. Flags
#define OS_FLAG                 0x03
#define OEM_FLAG                0x04

// Record Type
#define PROC_RECORD             0x00
#define PLAT_RECORD             0x01
#define NUM_PROC                0x04            // number of processors
#define PSI_REC_VERSION         0x01            // 0.01

// Oem SubTypes
#define MEM_Record              0x00
#define BUS_Record              0x02
#define COMP_Record             0x04
#define SEL_Record              0x08


// Record valid flags
#define MEM_Record_VALID        0x00
#define BUS_Record_VALID        0x02
#define COMP_Record_VALID       0x04
#define SEL_Record_VALID        0x08

#define RdNvmRecord             0x00
#define WrNvmRecord             0x01
#define ClrNvmRecord            0x02
#define ChkIfMoreNvmRecord      0x03

#else // !_INTEL_CHECK_H

// SAL 0800: Reserved           0x03-0x40

// SAL STATE_INFO
//
// Thierry 08/2000 - WARNING:
// These definitions match the ntos\inc\hal.h definitions for KERNEL_MCE_DELIVERY.Reserved.EVENTYPE.
//
#define MCA_EVENT               0x00   // MCA  Event Information
#define INIT_EVENT              0x01   // INIT Event Information 
#define CMC_EVENT               0x02   // Processor CMC Event Information
#define CPE_EVENT               0x03   // Corrected Platform Event Information
// SAL 0800: Reserved           other values...

#endif // !_INTEL_CHECK_H

// // constant defines
// Processor State Parameter error conditions from PAL in GR20
// Processor State Parameters from PAL during machine check bit position
#define PSPrz        2                              // Rendez Request Success
#define PSPra        3                              // Rendez Attempted
#define PSPme        4
#define PSPmn        5
#define PSPsy        6                              // storage inetgrity
#define PSPco        7                              // continuable error
#define PSPci        8                              // contained error, recovery possible
#define PSPus        9                              // uncontained memory failure
#define PSPhd        10                             // damaged hardware
#define PSPtl        11
#define PSPmi        12
#define PSPpi        13
#define PSPpm        14
#define PSPdy        15
#define PSPin        16
#define PSPrs        17
#define PSPcm        18                             // machine check corrected
#define PSPex        19                             // machine check expected
#define PSPcr        20
#define PSPpc        21
#define PSPdr        22
#define PSPtr        23
#define PSPrr        24
#define PSPar        25
#define PSPbr        26
#define PSPpr        27
#define PSPfp        28
#define PSPb1        29
#define PSPb0        30
#define PSPgr        31

#define PSPcc        59                             // cache check, SAL's domain 
#define PSPtc        60                             // tlb check error, SAL's domain
#define PSPbc        61                             // bus check error, SAL's domain
#define PSPrc        62                             // register file check error, SAL's domain
#define PSPuc        63                             // unknown error, SAL's domain

#define BusChktv     21                             // Bus check.tv bit or bus error info
#define CacheChktv     23

#if defined(_INTEL_CHECK_H)

// SAL PSI Validation flag bit mask
#define vPSIpe       0x01<<0                        // start bit pos. for processor error map
#define vPSIps       0x01<<1
#define vPSIid       0x01<<2                        // processor LID register value
#define vPSIStatic   0x01<<3                        // processor static info.
#define vPSIcc       0x01<<4                        // start bit pos. for cache error
#define vPSItc       0x01<<8                        // start bit pos. for tlb errors
#define vPSIbc       0x01<<12                       // bus check valid bit
#define vPSIrf       0x01<<16                       // register file check valid bit
#define vPSIms       0x01<<20                       // ms check valid bit

// Valid bit flags for CR and AR registers for this generation of EM Processor
#define vPSIMinState      0x01<<0
#define vPSIBRs           0x01<<1
#define vPSICRs           0x01<<2
#define vPSIARs           0x01<<3
#define vPSIRRs           0x01<<4
#define vPSIFRs           0x01<<5
#define vPSIRegs          vPSIBRs+vPSICRs+vPSIARs+vPSIRRs+vPSIMinState

///*** All Processor PAL call specific info.
// Processor Error Info Type Index for PAL_MC_ERROR_INFO call
#define PROC_ERROR_MAP      0                       // index for Proc. error map
#define PROC_STATE_PARAM    1                       // index for Proc. state parameter
#define PROC_STRUCT         2                       // index for structure specific error info.

#define PEIsse      0                               // index for Proc. structure specific level index
#define PEIta       1                               // index for target identifer
#define PEIrq       2                               // index for requestor
#define PEIrs       3                               // index for responder
#define PEIip       4                               // index for precise IP

// processor error map starting bit positions for each field (level index)
#define PEMcid            0                     // core ID
#define PEMtid            4                     // thread ID
#define PEMeic            8                     // inst. cache error index
#define PEMedc            12                    // data cache error index
#define PEMeit            16                    // inst. tlb error index
#define PEMedt            20                    // data tlb error index
#define PEMebh            24                    // bus error index
#define PEMerf            28                    // register file error index
#define PEMems            32                    // micro-arch error index

// processor structure specific error bit mappings
#define PEtv                0x01<<60            // valid target identifier
#define PErq                0x01<<61            // valid request identifier
#define PErp                0x01<<62            // valid responder identifier
#define PEpi                0x01<<63            // valid precise IP


// Error Severity: using bits (cm) & (us) only
#define RECOVERABLE     0x00
#define FATAL           0x01
#define CONTINUABLE     0x02
#define BCib            0x05
#define BCeb            0x06

#else  // !_INTEL_CHECK_H

//
// Error Severity: using vits (PSPcm) & (PSPus) only
// The SAL spec'ed values are defined in ntos\inc\hal.h
//
// To remind you:
//  #define ErrorRecoverable  ((USHORT)0)
//  #define ErrorFatal        ((USHORT)1)
//  #define ErrorCorrected    ((USHORT)2)
//
// The following values define some of the reserved ErrorOthers.

#define ErrorBCeb   ((USHORT)6)

#endif // !_INTEL_CHECK_H

#if defined(_INTEL_CHECK_H)

// System Errors bits masks to be handled by SAL, mask bits in d64-d32
#define parError     0x000100000000                 // Memory parity error
#define eccError     0x000200000000                 // Memory ECC error
#define busError     PSPbc                          // System Bus Check/Error
#define iocError     0x000800000000                 // System IO Check Errors
#define temError     0x002000000000                 // System Temperature Error
#define vccError     0x004000000000                 // System Voltage Error
#define intError     0x010000000000                 // Intrusion Error for servers
#define cacError     PSPcc                          // Cache Error
#define tlbError     PSPtc                          // TLB error
#define unkError     PSPuc                          // Unknown/Catastrophic error

// error bits masks
#define PALErrMask     0x0ff                        // bit mask of errors correctable by PAL
#define SALErrMask     busError+cacError+tlbError+unkError // SAL error bit mask
#define OSErrMask      0x0ff                         // OS expected error conditions
#define MCAErrMask     0x0ff                        // Given MCA Error Mask bit map

// New processor error Record structures ACO504
typedef struct tagModInfo
{
    U64		eValid;								// Valid bits for module entries
	U64     eInfo;								// error info cache/tlb/bus
    U64     ReqId;								// requester ID
    U64     ResId;								// responder ID
    U64     TarId;								// target ID
    U64     IP;									// Precise IP
} ModInfo;

typedef struct tagSAL_GUID
{          
    U32  Data1;
    U16  Data2;
    U16  Data3;
    U8   Data4[8]; 
} SAL_GUID;

typedef struct tagProcessorInfo
{
    U64         ValidBits;
    U64         Pem;							// processor map
	U64			Psp;							// processor state parameter
	U64			Pid;							// processor LID register value
    ModInfo		cInfo[8];						// cache check max of 8
    ModInfo     tInfo[8];						// tlb check max of 8
    ModInfo     bInfo[4];						// bus check max or 4
	U64			rInfo[4];						// register file check max of 4
	U64			mInfo[4];						// micro-architectural information max of 
    U64         Psi[584+8];						// 584 bytes
} ProcessorInfo;

typedef struct tagMinProcessorInfo
{
    U64         ValidBits;
    U64         Psp;							// processor state parameter
	U64			Pem;							// processor map
	U64			Pid;							// processor LID register value
} MinProcessorInfo;


// end ACO504 changes.

// platform error Record structures
typedef struct tagCfgSpace
{
	// data - error register dump
	U64     CfgRegAddr;							// register offset/addr
	U64     CfgRegVal; 							// register data/value
} CfgSpace;

typedef struct tagMemSpace
{
	// data - error register dump
	U64     MemRegAddr;							// register offset/addr
	U64     MemRegVal;							// register data/value
} MemSpace;

typedef union tagMemCfgSpace
{
	MemSpace		mSpace;
	CfgSpace		cSpace;
} MemCfgSpace;

typedef struct tagSysCompErr                    // per component
{
    U64     vFlag;                              // bit63=PCI device Flag, LSB:valid bits for each field in the Record

    // header for component Record
    U64     BusNum;                             // bus number on which the component resides
    U64     DevNum;                             // same as device select
    U64     FuncNum;                            // function ID of the device
    U64     DevVenID;                           // PCI device & vendor ID
	U64		SegNum;								// segment number as defined in SAL spec.

	// register dump info.
	U64     MemSpaceNumRegPair;					// number of reg addr/value pairs returned in this Record
	U64     CfgSpaceNumRegPair;					// number of reg addr/value pairs returned in this Record
	MemCfgSpace mcSpace;						// register add/data value pair array

} cErrRecord;

#define BusNum_valid				0x01                         
#define DevNum_valid				0x02                          
#define FuncNum_valid				0x04                           
#define DevVenID_valid				0x08                         
#define SegNum_valid				0x10								
#define MemSpaceNumRegPair_valid	0x20					
#define CfgSpaceNumRegPair_valid	0x40					
#define mcSpace_valid				0x80						

typedef struct tagPlatErrSection
{
    U64         vFlag;							// valid bits for each type of Record
    U64			Addr;							// memory address
    U64			Data;							// memory data
    U64			CmdType;						// command/operation type                            
	U64			BusID;							// bus ID if applicable
	U64			RequesterID;					// Requestor of the transaction if any                   
	U64			ResponderID;    				// Intended target or responder 
	U64			NumOemExt;						// Number of OEM Extension Arrays
	cErrRecord	OemExt;							// Value Array of OEM extensions
} PlatformInfo;

#define Addr_valid				0x01						
#define Data_valid				0x02						
#define CmdType_valid			0x04						
#define BusID_valid				0x08					
#define RequesterID_valid		0x10
#define ResponderID_valid		0x20  				
#define NumOemExt_valid			0x40				
#define OemExt_valid			0x80						

// over all Record structure (processor+platform)
typedef union utagDeviceSpecificSection
{
    ProcessorInfo   procSection;
    PlatformInfo    platSection;
} DeviceSection;

// SAL PSI Record & Section structure
typedef struct tagPsiSectionHeader
{
    SAL_GUID		SectionGuid;
	U16				Revision;
	U16				Reserved;
    U32				SectionLength;
} PsiSectionHeader;

typedef struct tagPsiSection
{
    SAL_GUID		SectionGuid;
	U16				Revision;
	U16				Reserved;
    U32				SectionLength;
    DeviceSection	DevSection;
} PsiSection;

typedef struct tagPsiRecordHeader
{
    U64				RecordID;
	U16				Revision;
	U16				eSeverity;
    U32				RecordLength;
    U64				TimeStamp;
} PsiRecordHeader;

typedef struct tagPsiRecord
{
    U64				RecordID;
	U16				Revision;
	U16				eSeverity;
    U32				RecordLength;
    U64				TimeStamp;
    PsiSection		PsiDevSection;
} PsiRecord;

/*
	LION 460GX: 
			SAC: SAC_FERR, SAC_FERR
			SDC: SDC_FERR, SDC_NERR
			MAC: FERR_MAC
			GXB: FERR_GXB, FERR_PCI, FERR_GART, FERR_F16, FERR_AGP
*/
typedef struct tagPciCfgHdr
{
	U8			RegAddr;
	U8			FuncNum;
	U8			DevNum;
	U8			BusNum;
	U8			SegNum;
	U8			Res[3];
} PciCfgHdr;

#define  PLATFORM_REC_CNT	0x01				// number of consecutive Records in the platform Record linked list
#define  OEM_EXT_REC_CNT	0x06				// number of consecutive OEM extension Array count

// number of registers that will be returned for each device
#define	SAC_REG_CNT				0x02
#define	SDC_REG_CNT				0x02
#define	MAC_REG_CNT				0x01
#define	GXB_REG_CNT				0x04
												
typedef struct tagSacRegs
{
	PciCfgHdr	pHdr;
	U64			RegCnt;
	U64			RegAddr[SAC_REG_CNT];
} SacDevInfo;

typedef struct tagSdcRegs
{
	PciCfgHdr	pHdr;
	U64			RegCnt;
	U64			RegAddr[SDC_REG_CNT];
} SdcDevInfo;

typedef struct tagMacRegs
{
	PciCfgHdr	pHdr;
	U64			RegCnt;
	U64			RegAddr[MAC_REG_CNT];
} MacDevInfo;

typedef struct tagGxbRegs
{
	PciCfgHdr	pHdr;
	U64			RegCnt;
	U64			RegAddr[GXB_REG_CNT];
} GxbDevInfo;

typedef struct tagDevInfo
{
	PciCfgHdr	pHdr;
	U64			RegCnt;
	U64			RegAddr[4];
} DevInfo;


#define DEV_VEN_ID_ADDR		0x0
#define SAC_BN					0x10

#define  DevNumber0             0x0
#define  DevNumber1				0x1
#define  DevNumber2				0x2
#define  DevNumber3             0x3
#define  DevNumber4				0x4
#define  DevNumber5				0x5
#define  DevNumber6             0x6

// function prototypes
rArg _BuildProcErrSection(PsiRecord*, U64, U64, U64);
rArg _BuildPlatErrSection(PsiSection*, U64, U64, U64);
rArg _BuildChipSetSection(PsiSection*, U64);
rArg _GetErrRecord(PsiRecord*, U64, PsiRecord*,PsiSection*, U64*, U64);
rArg _NvmErrRecordMgr(U64, U64, U64, U64);
rArg GetDeviceRecord(cErrRecord*, DevInfo*);
rArg SAL_PCI_CONFIG_READ_(U64, U64, U64, U64, U64, U64, U64, U64);
rArg SAL_PCI_CONFIG_WRITE_(U64, U64, U64, U64, U64, U64, U64, U64);
rArg OemGetInitSource();
rArg _MakeStaticPALCall(U64, U64, U64, U64, U64);
rArg GetProcNum();

#endif // _INTEL_CHECK_H

#endif // CHECK_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\dsdtaml.h ===
UCHAR GambitDSDT[] = {
	(UCHAR)0x44, (UCHAR)0x53, (UCHAR)0x44, (UCHAR)0x54, (UCHAR)0xd6, (UCHAR)0x2, (UCHAR)0, (UCHAR)0, 
	(UCHAR)0x1, (UCHAR)0xee, (UCHAR)0x49, (UCHAR)0x6e, (UCHAR)0x74, (UCHAR)0x65, (UCHAR)0x6c, (UCHAR)0, 
	(UCHAR)0x4c, (UCHAR)0x69, (UCHAR)0x6f, (UCHAR)0x6e, (UCHAR)0x53, (UCHAR)0x44, (UCHAR)0x56, (UCHAR)0, 
	(UCHAR)0, (UCHAR)0, (UCHAR)0, (UCHAR)0, (UCHAR)0x4d, (UCHAR)0x53, (UCHAR)0x46, (UCHAR)0x54, 
	(UCHAR)0x4, (UCHAR)0, (UCHAR)0, (UCHAR)0x1, (UCHAR)0x10, (UCHAR)0x13, (UCHAR)0x5c, (UCHAR)0x5f, 
	(UCHAR)0x50, (UCHAR)0x52, (UCHAR)0x5f, (UCHAR)0x5b, (UCHAR)0x83, (UCHAR)0xb, (UCHAR)0x43, (UCHAR)0x50, 
	(UCHAR)0x55, (UCHAR)0x30, (UCHAR)0, (UCHAR)0xff, (UCHAR)0xff, (UCHAR)0xff, (UCHAR)0xff, (UCHAR)0, 
	(UCHAR)0x5b, (UCHAR)0x80, (UCHAR)0x4c, (UCHAR)0x44, (UCHAR)0x53, (UCHAR)0x5f, (UCHAR)0x1, (UCHAR)0xb, 
	(UCHAR)0x2b, (UCHAR)0x80, (UCHAR)0xa, (UCHAR)0x1, (UCHAR)0x5b, (UCHAR)0x81, (UCHAR)0x10, (UCHAR)0x4c, 
	(UCHAR)0x44, (UCHAR)0x53, (UCHAR)0x5f, (UCHAR)0x1, (UCHAR)0x53, (UCHAR)0x4d, (UCHAR)0x46, (UCHAR)0x5a, 
	(UCHAR)0x1, (UCHAR)0x4c, (UCHAR)0x50, (UCHAR)0x4f, (UCHAR)0x4c, (UCHAR)0x1, (UCHAR)0x10, (UCHAR)0x22, 
	(UCHAR)0x5f, (UCHAR)0x47, (UCHAR)0x50, (UCHAR)0x45, (UCHAR)0x14, (UCHAR)0x1c, (UCHAR)0x5f, (UCHAR)0x4c, 
	(UCHAR)0x30, (UCHAR)0x42, (UCHAR)0, (UCHAR)0x80, (UCHAR)0x4c, (UCHAR)0x50, (UCHAR)0x4f, (UCHAR)0x4c, 
	(UCHAR)0x4c, (UCHAR)0x50, (UCHAR)0x4f, (UCHAR)0x4c, (UCHAR)0x86, (UCHAR)0x5c, (UCHAR)0x2e, (UCHAR)0x5f, 
	(UCHAR)0x53, (UCHAR)0x42, (UCHAR)0x5f, (UCHAR)0x4c, (UCHAR)0x49, (UCHAR)0x44, (UCHAR)0x5f, (UCHAR)0xa, 
	(UCHAR)0x80, (UCHAR)0x10, (UCHAR)0x4e, (UCHAR)0x24, (UCHAR)0x5c, (UCHAR)0x5f, (UCHAR)0x53, (UCHAR)0x42, 
	(UCHAR)0x5f, (UCHAR)0x5b, (UCHAR)0x82, (UCHAR)0x29, (UCHAR)0x4c, (UCHAR)0x49, (UCHAR)0x44, (UCHAR)0x5f, 
	(UCHAR)0x8, (UCHAR)0x5f, (UCHAR)0x48, (UCHAR)0x49, (UCHAR)0x44, (UCHAR)0xc, (UCHAR)0x41, (UCHAR)0xd0, 
	(UCHAR)0xc, (UCHAR)0xd, (UCHAR)0x14, (UCHAR)0x19, (UCHAR)0x5f, (UCHAR)0x4c, (UCHAR)0x49, (UCHAR)0x44, 
	(UCHAR)0, (UCHAR)0x70, (UCHAR)0xd, (UCHAR)0x4c, (UCHAR)0x49, (UCHAR)0x44, (UCHAR)0x20, (UCHAR)0x53, 
	(UCHAR)0x54, (UCHAR)0x41, (UCHAR)0x54, (UCHAR)0x45, (UCHAR)0, (UCHAR)0x5b, (UCHAR)0x31, (UCHAR)0xa4, 
	(UCHAR)0x4c, (UCHAR)0x50, (UCHAR)0x4f, (UCHAR)0x4c, (UCHAR)0x5b, (UCHAR)0x82, (UCHAR)0x4a, (UCHAR)0x21, 
	(UCHAR)0x50, (UCHAR)0x43, (UCHAR)0x49, (UCHAR)0x30, (UCHAR)0x8, (UCHAR)0x5f, (UCHAR)0x48, (UCHAR)0x49, 
	(UCHAR)0x44, (UCHAR)0xc, (UCHAR)0x41, (UCHAR)0xd0, (UCHAR)0xa, (UCHAR)0x3, (UCHAR)0x8, (UCHAR)0x5f, 
	(UCHAR)0x41, (UCHAR)0x44, (UCHAR)0x52, (UCHAR)0xa, (UCHAR)0, (UCHAR)0x8, (UCHAR)0x5f, (UCHAR)0x50, 
	(UCHAR)0x52, (UCHAR)0x54, (UCHAR)0x12, (UCHAR)0x43, (UCHAR)0xe, (UCHAR)0x10, (UCHAR)0x12, (UCHAR)0xd, 
	(UCHAR)0x4, (UCHAR)0xc, (UCHAR)0xff, (UCHAR)0xff, (UCHAR)0x4, (UCHAR)0, (UCHAR)0xa, (UCHAR)0, 
	(UCHAR)0xa, (UCHAR)0, (UCHAR)0xa, (UCHAR)0, (UCHAR)0x12, (UCHAR)0xd, (UCHAR)0x4, (UCHAR)0xc, 
	(UCHAR)0xff, (UCHAR)0xff, (UCHAR)0x4, (UCHAR)0, (UCHAR)0xa, (UCHAR)0x1, (UCHAR)0xa, (UCHAR)0, 
	(UCHAR)0xa, (UCHAR)0xa, (UCHAR)0x12, (UCHAR)0xd, (UCHAR)0x4, (UCHAR)0xc, (UCHAR)0xff, (UCHAR)0xff, 
	(UCHAR)0x4, (UCHAR)0, (UCHAR)0xa, (UCHAR)0x2, (UCHAR)0xa, (UCHAR)0, (UCHAR)0xa, (UCHAR)0x14, 
	(UCHAR)0x12, (UCHAR)0xd, (UCHAR)0x4, (UCHAR)0xc, (UCHAR)0xff, (UCHAR)0xff, (UCHAR)0x4, (UCHAR)0, 
	(UCHAR)0xa, (UCHAR)0x3, (UCHAR)0xa, (UCHAR)0, (UCHAR)0xa, (UCHAR)0x1e, (UCHAR)0x12, (UCHAR)0xd, 
	(UCHAR)0x4, (UCHAR)0xc, (UCHAR)0xff, (UCHAR)0xff, (UCHAR)0x5, (UCHAR)0, (UCHAR)0xa, (UCHAR)0, 
	(UCHAR)0xa, (UCHAR)0, (UCHAR)0xa, (UCHAR)0x1, (UCHAR)0x12, (UCHAR)0xd, (UCHAR)0x4, (UCHAR)0xc, 
	(UCHAR)0xff, (UCHAR)0xff, (UCHAR)0x5, (UCHAR)0, (UCHAR)0xa, (UCHAR)0x1, (UCHAR)0xa, (UCHAR)0, 
	(UCHAR)0xa, (UCHAR)0xb, (UCHAR)0x12, (UCHAR)0xd, (UCHAR)0x4, (UCHAR)0xc, (UCHAR)0xff, (UCHAR)0xff, 
	(UCHAR)0x5, (UCHAR)0, (UCHAR)0xa, (UCHAR)0x2, (UCHAR)0xa, (UCHAR)0, (UCHAR)0xa, (UCHAR)0x15, 
	(UCHAR)0x12, (UCHAR)0xd, (UCHAR)0x4, (UCHAR)0xc, (UCHAR)0xff, (UCHAR)0xff, (UCHAR)0x5, (UCHAR)0, 
	(UCHAR)0xa, (UCHAR)0x3, (UCHAR)0xa, (UCHAR)0, (UCHAR)0xa, (UCHAR)0x1f, (UCHAR)0x12, (UCHAR)0xd, 
	(UCHAR)0x4, (UCHAR)0xc, (UCHAR)0xff, (UCHAR)0xff, (UCHAR)0x6, (UCHAR)0, (UCHAR)0xa, (UCHAR)0, 
	(UCHAR)0xa, (UCHAR)0, (UCHAR)0xa, (UCHAR)0x2, (UCHAR)0x12, (UCHAR)0xd, (UCHAR)0x4, (UCHAR)0xc, 
	(UCHAR)0xff, (UCHAR)0xff, (UCHAR)0x6, (UCHAR)0, (UCHAR)0xa, (UCHAR)0x1, (UCHAR)0xa, (UCHAR)0, 
	(UCHAR)0xa, (UCHAR)0xc, (UCHAR)0x12, (UCHAR)0xd, (UCHAR)0x4, (UCHAR)0xc, (UCHAR)0xff, (UCHAR)0xff, 
	(UCHAR)0x6, (UCHAR)0, (UCHAR)0xa, (UCHAR)0x2, (UCHAR)0xa, (UCHAR)0, (UCHAR)0xa, (UCHAR)0x16, 
	(UCHAR)0x12, (UCHAR)0xd, (UCHAR)0x4, (UCHAR)0xc, (UCHAR)0xff, (UCHAR)0xff, (UCHAR)0x6, (UCHAR)0, 
	(UCHAR)0xa, (UCHAR)0x3, (UCHAR)0xa, (UCHAR)0, (UCHAR)0xa, (UCHAR)0x20, (UCHAR)0x12, (UCHAR)0xd, 
	(UCHAR)0x4, (UCHAR)0xc, (UCHAR)0xff, (UCHAR)0xff, (UCHAR)0x7, (UCHAR)0, (UCHAR)0xa, (UCHAR)0, 
	(UCHAR)0xa, (UCHAR)0, (UCHAR)0xa, (UCHAR)0x3, (UCHAR)0x12, (UCHAR)0xd, (UCHAR)0x4, (UCHAR)0xc, 
	(UCHAR)0xff, (UCHAR)0xff, (UCHAR)0x7, (UCHAR)0, (UCHAR)0xa, (UCHAR)0x1, (UCHAR)0xa, (UCHAR)0, 
	(UCHAR)0xa, (UCHAR)0xd, (UCHAR)0x12, (UCHAR)0xd, (UCHAR)0x4, (UCHAR)0xc, (UCHAR)0xff, (UCHAR)0xff, 
	(UCHAR)0x7, (UCHAR)0, (UCHAR)0xa, (UCHAR)0x2, (UCHAR)0xa, (UCHAR)0, (UCHAR)0xa, (UCHAR)0x17, 
	(UCHAR)0x12, (UCHAR)0xd, (UCHAR)0x4, (UCHAR)0xc, (UCHAR)0xff, (UCHAR)0xff, (UCHAR)0x7, (UCHAR)0, 
	(UCHAR)0xa, (UCHAR)0x3, (UCHAR)0xa, (UCHAR)0, (UCHAR)0xa, (UCHAR)0x21, (UCHAR)0x8, (UCHAR)0x5f, 
	(UCHAR)0x43, (UCHAR)0x52, (UCHAR)0x53, (UCHAR)0x11, (UCHAR)0x42, (UCHAR)0x7, (UCHAR)0xa, (UCHAR)0x6e, 
	(UCHAR)0x88, (UCHAR)0xd, (UCHAR)0, (UCHAR)0x2, (UCHAR)0xf, (UCHAR)0, (UCHAR)0, (UCHAR)0, 
	(UCHAR)0, (UCHAR)0, (UCHAR)0xff, (UCHAR)0, (UCHAR)0, (UCHAR)0, (UCHAR)0, (UCHAR)0x1, 
	(UCHAR)0x47, (UCHAR)0x1, (UCHAR)0xf8, (UCHAR)0xc, (UCHAR)0xf8, (UCHAR)0xc, (UCHAR)0x1, (UCHAR)0x8, 
	(UCHAR)0x88, (UCHAR)0xd, (UCHAR)0, (UCHAR)0x1, (UCHAR)0xc, (UCHAR)0x3, (UCHAR)0, (UCHAR)0, 
	(UCHAR)0, (UCHAR)0, (UCHAR)0xf7, (UCHAR)0xc, (UCHAR)0, (UCHAR)0, (UCHAR)0xf8, (UCHAR)0xc, 
	(UCHAR)0x88, (UCHAR)0xd, (UCHAR)0, (UCHAR)0x1, (UCHAR)0xc, (UCHAR)0x3, (UCHAR)0, (UCHAR)0, 
	(UCHAR)0, (UCHAR)0xd, (UCHAR)0xff, (UCHAR)0xff, (UCHAR)0, (UCHAR)0, (UCHAR)0, (UCHAR)0xf3, 
	(UCHAR)0x87, (UCHAR)0x17, (UCHAR)0, (UCHAR)0, (UCHAR)0xc, (UCHAR)0x2, (UCHAR)0, (UCHAR)0, 
	(UCHAR)0, (UCHAR)0, (UCHAR)0, (UCHAR)0, (UCHAR)0xa, (UCHAR)0, (UCHAR)0xff, (UCHAR)0xff, 
	(UCHAR)0xf, (UCHAR)0, (UCHAR)0, (UCHAR)0, (UCHAR)0, (UCHAR)0, (UCHAR)0, (UCHAR)0, 
	(UCHAR)0x6, (UCHAR)0, (UCHAR)0x87, (UCHAR)0x17, (UCHAR)0, (UCHAR)0, (UCHAR)0xc, (UCHAR)0x1, 
	(UCHAR)0, (UCHAR)0, (UCHAR)0, (UCHAR)0, (UCHAR)0, (UCHAR)0, (UCHAR)0, (UCHAR)0xf0, 
	(UCHAR)0xff, (UCHAR)0xff, (UCHAR)0xff, (UCHAR)0xfd, (UCHAR)0, (UCHAR)0, (UCHAR)0, (UCHAR)0, 
	(UCHAR)0, (UCHAR)0, (UCHAR)0, (UCHAR)0xe, (UCHAR)0x79, (UCHAR)0, (UCHAR)0x5b, (UCHAR)0x82, 
	(UCHAR)0x40, (UCHAR)0xa, (UCHAR)0x49, (UCHAR)0x53, (UCHAR)0x41, (UCHAR)0x5f, (UCHAR)0x8, (UCHAR)0x5f, 
	(UCHAR)0x41, (UCHAR)0x44, (UCHAR)0x52, (UCHAR)0xc, (UCHAR)0, (UCHAR)0, (UCHAR)0x4, (UCHAR)0, 
	(UCHAR)0x5b, (UCHAR)0x82, (UCHAR)0x37, (UCHAR)0x50, (UCHAR)0x53, (UCHAR)0x32, (UCHAR)0x4b, (UCHAR)0x8, 
	(UCHAR)0x5f, (UCHAR)0x48, (UCHAR)0x49, (UCHAR)0x44, (UCHAR)0xc, (UCHAR)0x41, (UCHAR)0xd0, (UCHAR)0x3, 
	(UCHAR)0x3, (UCHAR)0x14, (UCHAR)0x9, (UCHAR)0x5f, (UCHAR)0x53, (UCHAR)0x54, (UCHAR)0x41, (UCHAR)0, 
	(UCHAR)0xa4, (UCHAR)0xa, (UCHAR)0xf, (UCHAR)0x8, (UCHAR)0x5f, (UCHAR)0x43, (UCHAR)0x52, (UCHAR)0x53, 
	(UCHAR)0x11, (UCHAR)0x18, (UCHAR)0xa, (UCHAR)0x15, (UCHAR)0x47, (UCHAR)0x1, (UCHAR)0x60, (UCHAR)0, 
	(UCHAR)0x60, (UCHAR)0, (UCHAR)0x1, (UCHAR)0x1, (UCHAR)0x47, (UCHAR)0x1, (UCHAR)0x64, (UCHAR)0, 
	(UCHAR)0x64, (UCHAR)0, (UCHAR)0x1, (UCHAR)0x1, (UCHAR)0x22, (UCHAR)0x2, (UCHAR)0, (UCHAR)0x79, 
	(UCHAR)0, (UCHAR)0x5b, (UCHAR)0x82, (UCHAR)0x27, (UCHAR)0x50, (UCHAR)0x53, (UCHAR)0x32, (UCHAR)0x4d, 
	(UCHAR)0x8, (UCHAR)0x5f, (UCHAR)0x48, (UCHAR)0x49, (UCHAR)0x44, (UCHAR)0xc, (UCHAR)0x41, (UCHAR)0xd0, 
	(UCHAR)0xf, (UCHAR)0x13, (UCHAR)0x14, (UCHAR)0x9, (UCHAR)0x5f, (UCHAR)0x53, (UCHAR)0x54, (UCHAR)0x41, 
	(UCHAR)0, (UCHAR)0xa4, (UCHAR)0xa, (UCHAR)0xf, (UCHAR)0x8, (UCHAR)0x5f, (UCHAR)0x43, (UCHAR)0x52, 
	(UCHAR)0x53, (UCHAR)0x11, (UCHAR)0x8, (UCHAR)0xa, (UCHAR)0x5, (UCHAR)0x22, (UCHAR)0, (UCHAR)0x10, 
	(UCHAR)0x79, (UCHAR)0, (UCHAR)0x5b, (UCHAR)0x82, (UCHAR)0x2c, (UCHAR)0x55, (UCHAR)0x41, (UCHAR)0x52, 
	(UCHAR)0x31, (UCHAR)0x8, (UCHAR)0x5f, (UCHAR)0x48, (UCHAR)0x49, (UCHAR)0x44, (UCHAR)0xc, (UCHAR)0x41, 
	(UCHAR)0xd0, (UCHAR)0x5, (UCHAR)0x1, (UCHAR)0x8, (UCHAR)0x5f, (UCHAR)0x55, (UCHAR)0x49, (UCHAR)0x44, 
	(UCHAR)0xa, (UCHAR)0x1, (UCHAR)0x8, (UCHAR)0x5f, (UCHAR)0x43, (UCHAR)0x52, (UCHAR)0x53, (UCHAR)0x11, 
	(UCHAR)0x10, (UCHAR)0xa, (UCHAR)0xd, (UCHAR)0x47, (UCHAR)0x1, (UCHAR)0xf8, (UCHAR)0x3, (UCHAR)0xf8, 
	(UCHAR)0x3, (UCHAR)0x1, (UCHAR)0x8, (UCHAR)0x22, (UCHAR)0x10, (UCHAR)0, (UCHAR)0x79, (UCHAR)0, 
	(UCHAR)0x10, (UCHAR)0xd, (UCHAR)0x5c, (UCHAR)0x5f, (UCHAR)0x53, (UCHAR)0x49, (UCHAR)0x5f, (UCHAR)0x14, 
	(UCHAR)0x6, (UCHAR)0x5f, (UCHAR)0x53, (UCHAR)0x53, (UCHAR)0x54, (UCHAR)0x1, 
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\fwglobal.h ===
//###########################################################################
//**
//**  Copyright  (C) 1996-99 Intel Corporation. All rights reserved.
//**
//** The information and source code contained herein is the exclusive
//** property of Intel Corporation and may not be disclosed, examined
//** or reproduced in whole or in part without explicit written authorization
//** from the company.
//**
//###########################################################################

;//-----------------------------------------------------------------------------
;// Version control information follows.
;//
;// $Header:   I:/DEVPVCS/sal/INCLUDE/FWGLOBAL.H   6.6   07 May 1999 10:52:24   smariset  $
;// $Log:   I:/DEVPVCS/sal/INCLUDE/FWGLOBAL.H  $
;//
;//   Rev 6.6   07 May 1999 10:52:24   smariset
;//Copyright year update
;//
;//   Rev 6.5   05 May 1999 14:13:30   smariset
;//Pre Fresh Build 
;//
;//   Rev 6.4   16 Apr 1999 13:45:34   smariset
;//MinState Size Change, Procs Clean Up
;//
;//   Rev 6.2   04 Mar 1999 13:36:06   smariset
;//Pre 0.6 release symbol globalization
;//
;//   Rev 6.1   10 Feb 1999 15:58:38   smariset
;//Boot Mgr Updates
;//
;//   Rev 6.0   Dec 11 1998 10:23:08   khaw
;//Post FW 0.5 release sync-up
;//
;//   Rev 5.0   27 Aug 1998 11:52:28   khaw
;//FW merged for EAS 2.4 SDK tools
;//
;//   Rev 4.1   20 Aug 1998 16:53:30   smariset
;//EAS 2.4 Changes
;//
;//   Rev 4.0   06 May 1998 22:22:50   khaw
;//Major update for MP SAL, tools and build.
;//SAL A/B common source.  .s extension.
;//
;//   Rev 3.3   17 Feb 1998 08:37:24   khaw
;//SAL buid/code update for SDK0.3
;//
;//   Rev 3.2   06 Jan 1998 12:52:48   smariset
;//One more flag: OStoPalRtn
;//
;//   Rev 3.1   06 Jan 1998 09:16:50   smariset
;//Hazard Checked
;//
;//   Rev 3.0   17 Dec 1997 12:42:54   khaw
;// Merced Firmware Development Kit  Rev 0.2
;//
;//   Rev 2.8   Apr 02 1997 14:18:40   smariset
;//Post release clean up
;//
;//   Rev 2.7   Mar 31 1997 12:28:48   smariset
;//Indent tabs replaced by spaces
;//
;//   Rev 2.0   Feb 04 1997 07:29:54   khaw
;//PAL_A/B, SAL_A/B updates
;//
;//*****************************************************************************//
        #define xs0 s0
        #define xs1 s1          
        #define xs2 s2
        #define xs3 s3          

// constants
        #define  Sz64b            64
        #define  Sz128b           128
        #define  Sz256b           0x00100
        #define  Sz512b           0x00200
        #define  Sz1kb            0x00400
        #define  Sz2kb            0x00800
        #define  Sz4kb            0x01000
        #define  Sz6kb            0x01800
        #define  Sz8kb            0x02000
        #define  Sz16kb           0x04000
        #define  Sz20kb           0x05000
        #define  Sz32kb           0x08000
        #define  SzSALGlobal      Sz16kb        // 16K size
        #define  SzSALData        Sz20kb        // size MCA/INIT/CMC areas
        #define  SzPMIData        Sz4kb
        #define  SzBkpStore       Sz512b
        #define  SzStackFrame     Sz256b+Sz128b
        #define  SALGpOff         0x08
        #define  PMIGpOff         0x0f
        #define  SzProcMinState   0x1000        // Architected MinState+ScratchMinState Size
        #define  aSzProcMinState  0x400         // architected MinState Size
        #define  PSI_hLogSz       8*3           // PSI log header size
        #define  PSI_procLogSz    (8*4+16*2+48*2+64*2+128+2*1024+aSzProcMinState)    // size of processor PSI log size
        #define  PSI_platLogSz    Sz4kb         // size of platform log


// primary and secondary debug port numbers
//      #define  pDbgPort         0x080         // used for release code        
        #define  sDbgPort         0x0a0         // used for non-release code only

// increment contstans
        #define  Inc4             4
        #define  Dec4             (-4)
        #define  Inc8             8
        #define  Dec8             (-8)
        #define  Inc16            16
        #define  Dec16            (-16)
        #define  Inc32            32
        #define  Dec32            (-32)
        #define  Inc48            48
        #define  Dec48            (-48)
        #define  Inc64            64
        #define  Dec64            (-64)

// defines
        #define  PMITimeOutValue 0x0f           // PMI Time Out Value
        #define  DestIDMask      0x0ff000000    // LID info.
        #define  DestEIDMask     0x000ff0000
        #define  DestIDMaskPos   24             // LID.id  position
        #define  DestEIDMaskPos  16             // LID.eid position
        #define  IntStoreAddrMsk 0x0fee00000000 // SAPIC store address message mask
        #define  InitDelvModeMsk 0x0500         // SAPIC INIT del. message mask
        #define  PmiDelvModeMsk  0x0200         // SAPIC PMI del. message mask
        #define  FixedDelvModeMsk 0x0000        // SAPIC Fixed Del Mode mask
        #define  MCAFlagMsk      0x01           // bit1 of SalFlags, indicating that a CPU is in MCA
        #define  OSFlagEMMsk     0x01           // bit2 of SalFlags=1/0
        #define  PDSSize         0x02000        // Processor Data Structure memory size 8Kb
        #define  GDataSize       0x01000        // Global Data Area Memory Size 4Kb
        #define  FlushPMI        0x0            // PMI Flush Bit mask
        #define  MsgPMI          0x01           // PMI due to SAPIC Msg
        #define  PSIvLog         0x01           // PSI Structure Log Valid Bit Position
        #define  IntrPMI         0x02           // vector for Rendez. PMI interrupt
        #define  RendzNotRequired 0x00
        #define  RendezOk        0x01
        #define  RendezThruInitCombo 0x02
        #define  MulProcInMca    0x02
        #define  RendezFailed    (-0x01)

// Processor State Register Bit position value for PSR bits.
        #define  PSRor           0
        #define  PSRbe           1
        #define  PSRup           2
        #define  PSRac           3
        
        #define  PSRic           13
        #define  PSRi            14
        #define  PSRpk           15
        #define  PSRrv           16
        
        #define  PSRdt           17
        #define  PSRdfl          18
        #define  PSRdfh          19
        #define  PSRsp           20
        #define  PSRpp           21
        #define  PSRdi           22
        #define  PSRsi           23
        #define  PSRdb           24
        #define  PSRlp           25
        #define  PSRtb           26
        #define  PSRrt           27
// since PSR.um only starts from bit 32 and up and gets loaded that way
        #define  PSRcpl0         32
        #define  PSRcpl1         33
        #define  PSRis           34
        #define  PSRmc           35
        #define  PSRit           36
        #define  PSRid           37
        #define  PSRda           38
        #define  PSRdd           39
        #define  PSRss           40
        #define  PSRri0          41
        #define  PSRri1          42
        #define  PSRed           43
        #define  PSRbn           44
        
        #define  RSCmode         0x0003

        #define  PSRmcMask       0x0800000000
        #define  PSRicMask       0x02000
        #define  PSRiMask        0x04000

// RSE management registers offset
        #define  rRSCOff         0
        #define  rPFSOff         (rRSCOff+0x08)
        #define  rIFSOff         (rPFSOff+0x08)
        #define  rBSPStOff       (rIFSOff+0x08)
        #define  rRNATOff        (rBSPStOff+0x08)
        #define  rBSPDiffOff     (rRNATOff+0x08)
//********************* start of First 4K Shared Data ***************************
// variable offsets used by SAL Set MC Interrupt call
        #define  IPIVectorOff    0x00                  // fix this later to 0, data area bug

// MP synch. semaphores
        #define  InMCAOff        (IPIVectorOff+0x08)    // byte flags per processor to indicate that it is in MC
        #define  InRendzOff      (InMCAOff+0x08)
        #define  RendzCheckInOff (InRendzOff+0x08)     // indicates that processor checkin status
        #define  RendzResultOff  (RendzCheckInOff+0x08)
        #define  PMICheckInOff   (RendzResultOff+0x08)

// Platform Log valid flag bits
        #define  PSI_vPlatLogOff  (PMICheckInOff+0x08)   // platform non-CMC state log flag  
        #define  PSI_cvPlatLogOff (PSI_vPlatLogOff+0x01)   // platform CMC state log flag
        #define  PSI_ivPlatLogOff (PSI_cvPlatLogOff+0x01)  // platform INIT state log flag


//********************* start of Next 4K block of Shared Data Area ******************
// each platform log is 4kb in size (three logs here for MCA, CMC, INIT each 4x3=12Kbytes total
// PSI MCA generic header field offsets from BOM; applies to PSI MemInfo and IOInfo
// PSI MCA Platform Info. data area
        #define  PSI_PlatInfoOff PSI_platLogSz
        #define  PSI_gLogNext    PSI_platLogSz              // platform area starts at 4K from BOM
        #define  PSI_gLength     (PSI_gLogNext+0x08)
        #define  PSI_gType       (PSI_gLength+0x04)
        #define  PSI_gTimeStamp  (PSI_gType+0x04)

// PSI INIT generic header field offsets from BOM; applies to PSI MemInfo and IOInfo
// PSI INIT Platform Info. data area
        #define  PSI_iPlatInfoOff (PSI_PlatInfoOff+PSI_platLogSz)
        #define  PSI_igLogNext   (PSI_cgLogNext+PSI_platLogSz)
        #define  PSI_igLength    (PSI_igLogNext+0x08)
        #define  PSI_igType      (PSI_igLength+0x04)
        #define  PSI_igTimeStamp (PSI_igType+0x04)

// PSI CMC generic header field offsets from BOM; applies to PSI MemInfo and IOInfo)
// PSI CMC Platform Info. data area
        #define  PSI_cPlatInfoOff (PSI_iPlatInfoOff+PSI_platLogSz)
        #define  PSI_cgLogNext   (PSI_gLogNext+PSI_platLogSz)   
        #define  PSI_cgLength    (PSI_cgLogNext+0x08)
        #define  PSI_cgType      (PSI_cgLength+0x04)
        #define  PSI_cgTimeStamp (PSI_cgType+0x04)


//1******************* start of First Proc. Specific 4K block *****************
// Offsets from start of MinState Area *** Start of Min State Area ***
        #define  Min_ProcStateOff 0                      // 512byte aligned always 

//2******************* start of First Proc. 2nd 4K block *****************
// pointer to TOM is registered here by SAL malloc/init. code
        #define  TOMPtrOff       SzProcMinState          // offset from min state ptr.

// Mail box for software SAPIC PMI type message
        #define  PMIMailBoxOff     (TOMPtrOff+0x08)        // software PMI request mailbox            
        #define  OStoPalRtnFlagOff (PMIMailBoxOff+0x01)    // set by OS_MCA Call processing
        
// processor state log valid word MCA, INIT, CMC log areas
        #define  PSI_vProcLogOff  (PMIMailBoxOff+0x10)     // log valid flag for non-CMC log area
        #define  PSI_cvProcLogOff (PSI_vProcLogOff+0x01)   // log valid flag for CMC log area
        #define  PSI_ivProcLogOff (PSI_cvProcLogOff+0x01)  // log valid flag for INIT log area

// processor stack frame
        #define  StackFrameOff   (PSI_vProcLogOff+0x08)    //PSI_vProcLogOff+0x08

// bspstore
        #define  BL_SP_BASEOff   (StackFrameOff+SzStackFrame)    // stack frame size of 256 bytes
        #define  BL_R12_BASEOff  (BL_SP_BASEOff+Sz1kb+Sz512b) // assuming 1.5Kb size for BspMemory

//3**************** start of First Proc. Specific PSI 4K block ****************
// data structure SAL Processor-0 State Info (PSI) Structure
// push header data structure above the second 4k boundary, or below the first 4k 
        #define  PSI_LogNextOff   (TOMPtrOff+Sz4kb)-(PSI_hLogSz+24*8)  // offset from beginning of MinState
        #define  PSI_LengthOff    (PSI_LogNextOff+0x08)
        #define  PSI_LogTypeOff   (PSI_LengthOff+0x04)
        #define  PSI_TimeStampOff (PSI_LogTypeOff+0x04)
        
// PSI Processor Specific Info Header
        #define  PSI_pValidOff    (PSI_TimeStampOff+0x08)  

// PSI Proc. State, Cache, TLB & Bus Check info.
        #define  PSI_StatusCmdOff    (PSI_pValidOff+0x08)
        #define  PSI_CacheCheckOff   (PSI_StatusCmdOff+0x08)    
        #define  PSI_CacheTarAdrOff  (PSI_CacheCheckOff+0x008)  
        #define  PSI_CacheCheck1Off  (PSI_CacheTarAdrOff+0x08)    
        #define  PSI_CacheTarAd1rOff (PSI_CacheCheck1Off+0x008)  
        #define  PSI_CacheCheck2Off  (PSI_CacheTarAd1rOff+0x08)    
        #define  PSI_CacheTarAdr2Off (PSI_CacheCheck2Off+0x008)  
        #define  PSI_CacheCheck3Off  (PSI_CacheTarAdr2Off+0x08)    
        #define  PSI_CacheTarAdr3Off (PSI_CacheCheck3Off+0x008)  
        #define  PSI_CacheCheck4Off  (PSI_CacheTarAdr3Off+0x08)    
        #define  PSI_CacheTarAdr4Off (PSI_CacheCheck4Off+0x008)  
        #define  PSI_CacheCheck5Off  (PSI_CacheTarAdr4Off+0x08)    
        #define  PSI_CacheTarAdr5Off (PSI_CacheCheck5Off+0x008)  
        #define  PSI_TLBCheckOff     (PSI_CacheTarAdr5Off+0x008)  
        #define  PSI_BusCheckOff     (PSI_TLBCheckOff+0x030)  
        #define  PSI_BusReqAdrOff    (PSI_BusCheckOff+0x008)  
        #define  PSI_BusResAdrOff    (PSI_BusReqAdrOff+0x008)  
        #define  PSI_BusTarAdrOff    (PSI_BusResAdrOff+0x008)  

// PSI Static Info - 512 bytes aligned starting at 4K boundary
        #define  PSI_MinStateOff  (PSI_BusTarAdrOff+0x08)   
        #define  PSI_BankGRsOff   (PSI_MinStateOff+aSzProcMinState)  
        #define  PSI_GRNaTOff     (PSI_BankGRsOff+Sz128b)
        #define  PSI_BRsOff       (PSI_GRNaTOff+0x08)
        #define  PSI_CRsOff       (PSI_BRsOff+Sz64b)
        #define  PSI_ARsOff       (PSI_CRsOff+Sz1kb)
        #define  PSI_RRsOff       (PSI_ARsOff+Sz1kb)

//4************ start of First Proc. Specific INIT PSI 4K block ************
// data structure SAL INIT Processor-0 State Info (PSI) Structure 
// offset from beginning of MinState
        #define  PSI_iLogNextOff   (PSI_LogNextOff+Sz4kb)      
        #define  PSI_iLengthOff    (PSI_iLogNextOff+0x08)
        #define  PSI_iLogTypeOff   (PSI_iLengthOff+0x04)
        #define  PSI_iTimeStampOff (PSI_iLogTypeOff+0x04)
        
// PSI Processor Specific Info Header
        #define  PSI_ipValidOff    (PSI_iTimeStampOff+0x08)  

// PSI Proc. State, Cache, TLB & Bus Check info.
        //#define  PSI_iStatusCmdOff  (PSI_ipValidOff+0x04)
        #define  PSI_iStaticSizeOff (PSI_ipValidOff+0x04)

// PSI Proc. State, Cache, TLB & Bus Check info.
        #define  PSI_iStatusCmdOff    (PSI_ipValidOff+0x08)
        #define  PSI_iCacheCheckOff   (PSI_iStatusCmdOff+0x08)    
        #define  PSI_iCacheTarAdrOff  (PSI_iCacheCheckOff+0x008)  
        #define  PSI_iCacheCheck1Off  (PSI_iCacheTarAdrOff+0x08)    
        #define  PSI_iCacheTarAd1rOff (PSI_iCacheCheck1Off+0x008)  
        #define  PSI_iCacheCheck2Off  (PSI_iCacheTarAd1rOff+0x08)    
        #define  PSI_iCacheTarAdr2Off (PSI_iCacheCheck2Off+0x008)  
        #define  PSI_iCacheCheck3Off  (PSI_iCacheTarAdr2Off+0x08)    
        #define  PSI_iCacheTarAdr3Off (PSI_iCacheCheck3Off+0x008)  
        #define  PSI_iCacheCheck4Off  (PSI_iCacheTarAdr3Off+0x08)    
        #define  PSI_iCacheTarAdr4Off (PSI_iCacheCheck4Off+0x008)  
        #define  PSI_iCacheCheck5Off  (PSI_iCacheTarAdr4Off+0x08)    
        #define  PSI_iCacheTarAdr5Off (PSI_iCacheCheck5Off+0x008)  
        #define  PSI_iTLBCheckOff     (PSI_iCacheTarAdr5Off+0x008)  
        #define  PSI_iBusCheckOff     (PSI_iTLBCheckOff+0x030)  
        #define  PSI_iBusReqAdrOff    (PSI_iBusCheckOff+0x008)  
        #define  PSI_iBusResAdrOff    (PSI_iBusReqAdrOff+0x008)  
        #define  PSI_iBusTarAdrOff    (PSI_iBusResAdrOff+0x008)  


// PSI Static Info - 512 bytes aligned starting at 4K boundary
        #define  PSI_iMinStateOff  (PSI_iBusTarAdrOff+0x08)   
        #define  PSI_iBankGRsOff   (PSI_iMinStateOff+aSzProcMinState)  
        #define  PSI_iGRNaTOff     (PSI_iBankGRsOff+Sz128b)
        #define  PSI_iBRsOff       (PSI_iGRNaTOff+0x08)
        #define  PSI_iCRsOff       (PSI_iBRsOff+Sz64b)
        #define  PSI_iARsOff       (PSI_iCRsOff+Sz1kb)
        #define  PSI_iRRsOff       (PSI_iARsOff+Sz1kb)


//5************ start of First Proc. Specific CMC PSI 4K block *************
// data structure SAL CMC Processor State Info (PSI) Structure 
// offset from beginning of MinState
        #define  PSI_cLogNextOff   (PSI_iLogNextOff+Sz4kb)      
        #define  PSI_cLengthOff    (PSI_cLogNextOff+0x08)
        #define  PSI_cLogTypeOff   (PSI_cLengthOff+0x04)
        #define  PSI_cTimeStampOff (PSI_cLogTypeOff+0x04)
        
// PSI Processor Specific Info Header
        #define  PSI_cpValidOff    (PSI_cTimeStampOff+0x08)  

// PSI Proc. State, Cache, TLB & Bus Check info.
        #define  PSI_cStatusCmdOff    (PSI_cpValidOff+0x08)
        #define  PSI_cCacheCheckOff   (PSI_cStatusCmdOff+0x08)    
        #define  PSI_cCacheTarAdrOff  (PSI_cCacheCheckOff+0x008)  
        #define  PSI_cCacheCheck1Off  (PSI_cCacheTarAdrOff+0x08)    
        #define  PSI_cCacheTarAd1rOff (PSI_cCacheCheck1Off+0x008)  
        #define  PSI_cCacheCheck2Off  (PSI_cCacheTarAd1rOff+0x08)    
        #define  PSI_cCacheTarAdr2Off (PSI_cCacheCheck2Off+0x008)  
        #define  PSI_cCacheCheck3Off  (PSI_cCacheTarAdr2Off+0x08)    
        #define  PSI_cCacheTarAdr3Off (PSI_cCacheCheck3Off+0x008)  
        #define  PSI_cCacheCheck4Off  (PSI_cCacheTarAdr3Off+0x08)    
        #define  PSI_cCacheTarAdr4Off (PSI_cCacheCheck4Off+0x008)  
        #define  PSI_cCacheCheck5Off  (PSI_cCacheTarAdr4Off+0x08)    
        #define  PSI_cCacheTarAdr5Off (PSI_cCacheCheck5Off+0x008)  
        #define  PSI_cTLBCheckOff     (PSI_cCacheTarAdr5Off+0x008)  
        #define  PSI_cBusCheckOff     (PSI_cTLBCheckOff+0x030)  
        #define  PSI_cBusReqAdrOff    (PSI_cBusCheckOff+0x008)  
        #define  PSI_cBusResAdrOff    (PSI_cBusReqAdrOff+0x008)  
        #define  PSI_cBusTarAdrOff    (PSI_cBusResAdrOff+0x008)  


// PSI Static Info - 512 bytes aligned starting at 4K boundary
        #define  PSI_cMinStateOff (PSI_cBusTarAdrOff+0x08)   
        #define  PSI_cBankGRsOff  (PSI_cMinStateOff+aSzProcMinState)  
        #define  PSI_cGRNaTOff    (PSI_cBankGRsOff+Sz128b)
        #define  PSI_cBRsOff      (PSI_cGRNaTOff+0x08)
        #define  PSI_cCRsOff      (PSI_cBRsOff+Sz64b)
        #define  PSI_cARsOff      (PSI_cCRsOff+Sz1kb)
        #define  PSI_cRRsOff      (PSI_cARsOff+Sz1kb)

//6************ start of First Proc. Specific PMI 4K block *************
//PMI Data Area 4 Kbytes, offsets from MinState Ptr.
        #define  PMI_BL_SP_BASEOff SzSALData
        #define  PmiStackFrameOff  (PMI_BL_SP_BASEOff+SzBkpStore)  
        #define  PMIGlobalDataOff  (PmiStackFrameOff+SzStackFrame)

        #define TOM TOMPtrOff

// returns Entry Points in regX for whatever SAL/PAL procs, ProcNum value etc.
#define GetEPs(NameOff,regX,regY) \
        add     regX= TOMPtrOff,regX;;\
        ld8     regY = [regX];;\
        movl    regX=NameOff;;\
        add     regY = regX,regY;;\
        ld8     regX = [regY];;                 

#define GetEPsRAM(NameOff,regX,rBOM) \
        movl    regX= SALDataBlockLength;;\
        add     regX = regX,rBOM;\
        movl    rBOM=NameOff;; \
        add     regX = regX,rBOM;;\
        ld8     regX = [regX];;                 

// calculates absolute physical ptr to  variable from offset and base
#define GetAbsPtr(Var,RegX,BASE) \
        movl RegX=Var##Off##;;\
        add RegX=RegX, BASE;;

// input regX=XR0, returns Bottom of Memory (BOM) TOM-256k in regX
#define GetBOM(regX,regY) \
        add     regX= TOM,regX;;\
        ld8     regX=[regX];; \
        movl    regY=SALDataBlockLength;; \
        sub     regX=regX,regY;;

// input regX=XR0, returns Top of Memory (TOM) in regX
#define GetTOM(regX) \
        add     regX= TOM,regX;;\
        ld8     regX=[regX];; 

// returns the pointer to "this" processor MinState Area beginning in regX 
// bom is preserved
#define GetMinStateHead(regX,regY,bom,ProcX) \
        movl    regX=SzPMIData+SzSALData;; \
        shl     regX=regX, ProcX;; \
        movl    ProcX=SzPMIData+SzSALData;; \
        sub     regX=regX,ProcX;; \
        movl    regY=SzSALGlobal;; \
        add     regX=regY,regX;; \
        add     regX=regX,bom;;

// the save and restore macros saves R17-R19 during MCA and INIT before any
// external PAL and SAL calls
#define SaveRs(regX,regY,regZ) \
        mov     xs0=regX;\
        mov     xs1=regY; \
        mov     xs2=regZ

#define ResRs(regX,regY,regZ) \
        mov     regX=xs0;\
        mov     regY=xs1; \
        mov     regZ=xs2;;

//this macro manages the stack frame for the new context, by saving the previous one
#define SwIntCxt(regX,pStkFrm,pBspStore) \
        ;; \
        mov     regX=ar##.##rsc;; \
        st8     [pStkFrm]=regX,Inc8;; \
        mov     regX=ar##.##pfs;; \
        st8     [pStkFrm]=regX,Inc8; \
        cover ;;\
        mov     regX=cr##.##ifs;; \
        st8     [pStkFrm]=regX,Inc8;; \
        mov     regX=ar##.##bspstore;; \
        st8     [pStkFrm]=regX,Inc8;; \
        mov     regX=ar##.##rnat;; \
        st8     [pStkFrm]=regX,Inc8; \
        mov     ar##.##bspstore=pBspStore;; \
        mov     regX=ar##.##bsp;; \
        sub     regX=regX,pBspStore;;\
        st8     [pStkFrm]=regX,Inc8

//this macro restores the stack frame of the previous context 
#define RtnIntCxt(PSRMaskReg,regX,pStkFrm) \
        ;; \
        alloc   regX=ar.pfs,0,0,0,0;\
        add     pStkFrm=rBSPDiffOff,pStkFrm;;\
        ld8     regX=[pStkFrm];; \
        shl     regX=regX,16;;\
        mov     ar##.##rsc=regX;; \
        loadrs;;\
        add     pStkFrm=-rBSPDiffOff+rBSPStOff,pStkFrm;;\
        ld8     regX=[pStkFrm];; \
        mov     ar##.##bspstore=regX;; \
        add     pStkFrm=-rBSPStOff+rRNATOff,pStkFrm;;\
        ld8     regX=[pStkFrm];; \
        mov     ar##.##rnat=regX;;\
        add     pStkFrm=-rRNATOff+rPFSOff,pStkFrm;;\
        ld8     regX=[pStkFrm];; \
        mov     ar##.##pfs=regX;\
        add     pStkFrm=-rPFSOff+rIFSOff,pStkFrm;;\
        ld8     regX=[pStkFrm];; \
        mov     cr##.##ifs=regX;\
        add     pStkFrm=-rIFSOff+rRSCOff,pStkFrm;;\
        ld8     regX=[pStkFrm];; \
        mov     ar##.##rsc=regX ;\
        add     pStkFrm=-rRSCOff,pStkFrm;\
        mov     regX=cr.ipsr;;\
        st8     [pStkFrm]=regX,Inc8;\
        mov     regX=cr.iip;;\
        st8     [pStkFrm]=regX,-Inc8;\
        mov     regX=psr;;\
        or      regX=regX,PSRMaskReg;;\
        mov     cr.ipsr=regX;;\
        mov     regX=ip;;\
        add     regX=0x30,regX;;\
        mov     cr.iip=regX;;\
        rfi;;\
        ld8     regX=[pStkFrm],Inc8;;\
        mov     cr.ipsr=regX;;\
        ld8     regX=[pStkFrm];;\
        mov     cr.iip=regX

//these macros do left and right rotate respectively.
#define lRotate(regX, regCnt,nLabel) \
        mov     ar##.##lc=regCnt;\
nLabel:;\
        shrp        regX=regX,regX,63;\
        br##.##cloop##.##dpnt   nLabel


#define rRotate(regX, regCnt,nLabel) \
        mov     ar##.##lc=regCnt;\
nLabel:;\
        shrp        regX=regX,regX,1;\
        br##.##cloop##.##dpnt   nLabel

// macro increments pointer in regX by (4Kbytes x regCnt)
#define Mul(regX, regCnt,regI) \
        cmp.eq.unc pt0,p0=0x02, regCnt;\
        movl    regI=Sz4kb;;\
        shl     regI=regI,regCnt;;\
        adds    regI=-Sz4kb,regI;;\
(pt0)   adds    regI=-Sz4kb,regI;;\
        add     regX=regX,regI

// this macro loads the return pointer in b0 during static procedure calls
// rLabel=label after macro, pLabel=label prior to this macro
#define SetupBrFrame(regX, regY, regZ, pLabel,rLabel) \
        mov     regX=ip;\
        movl    regY=pLabel;\
        movl    regZ=rLabel;;\
        sub     regZ=regZ,regY;;\
        add     regX=regX,regZ;;\
        mov     b0=regX

//this macro manages the stack frame for the new context, by saving the previous one
#define nSwIntCxt(regX,pStkFrm,pBspStore) \
        mov     regX=ar##.##rsc; \
        st8     [pStkFrm]=regX,Inc8; \
        mov     regX=ar##.##pfs; \
        st8     [pStkFrm]=regX,Inc8; \
        cover;;\
        mov     regX=ar##.##ifs; \
        st8     [pStkFrm]=regX,Inc8; \
        mov     regX=ar##.##bspstore; \
        st8     [pStkFrm]=regX,Inc8; \
        mov     regX=ar##.##rnat; \
        st8     [pStkFrm]=regX,Inc8; \
        mov     ar##.##bspstore=pBspStore; \
        mov     regX=ar##.##bsp; \
        st8     [pStkFrm]=regX,Inc8;\
        mov     regX=b0;\
        st8     [pStkFrm]=regX,Inc8

//this macro restores the stack frame of the previous context 
#define nRtnIntCxt(regX,pStkFrm) \
        alloc   regX=ar.pfs,0,0,0,0;\
        ld8     regX=[pStkFrm],Inc8; \
        mov     ar##.##bspstore=regX; \
        ld8     regX=[pStkFrm],Inc8; \
        mov     ar##.##rnat=regX


#define GLOBAL_FUNCTION(Function) \
         .##type   Function, @function; \
         .##global Function


#define WRITE_MASK  (0x8000000000000000)    // RTC IO port write mask

//
// GetProcessorLidBasedEntry()
//  - macro to setup register regX with arrary entry, indexed with LID.ID field.
//

#define GetProcessorLidBasedEntry(regX,regY,szOffset,VarName,lpName) \
        mov         regY=ar##.##lc;\
        mov         regX=cr##.##lid;;\
        extr##.##u  regX=regX,DestIDMaskPos,8;;\
        mov         ar##.##lc=regX;;\
        movl        regX=VarName;;\
        lpName##:##;\
        addl        regX=szOffset,regX;\
        br##.##cloop##.##dpnt lpName;;\
        mov         ar##.##lc=regY;\
        addl        regX=-szOffset, regX;;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\haldebug.c ===
#if DBG

/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    haldebug.c

Abstract:

    This module contains debugging code for the HAL.

Author:

    Thierry Fevrier 15-Jan-2000

Environment:

    Kernel mode

Revision History:


--*/

#include "halp.h"

#include <stdarg.h>
#include <stdio.h>

UCHAR HalpDebugPrintBuffer[512];

ULONG HalpUseDbgPrint = 0;

VOID
HalpDebugPrint(
    ULONG  Level, 
    PCCHAR Message,
    ...
    )
{
    va_list ap;
    va_start(ap, Message);
    _vsnprintf( HalpDebugPrintBuffer, sizeof(HalpDebugPrintBuffer), Message, ap );
    va_end(ap);
    if ( !HalpUseDbgPrint ) {
        HalDisplayString( HalpDebugPrintBuffer );
    }
    else    {
        DbgPrintEx( DPFLTR_HALIA64_ID, Level, HalpDebugPrintBuffer );
    }
    return;
} // HalpDebugPrint()

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\halnls.h ===
//
// Include code from halx86 and append IA64 specific definitions.
// This is a cpp style symbolic link
//

#include "..\..\halx86\i386\halnls.h"

#define MSG_MCA_HARDWARE_ERROR  "\n*** Machine Check Abort: Hardware Malfunction\n\n"
#define MSG_INIT_HARDWARE_ERROR "\n*** Machine Initialization Event: Hardware Malfunction\n\n"

#define MSG_CMC_PENDING  "Corrected Machine Check pending, HAL CMC handling not enabled\n" 
#define MSG_CPE_PENDING  "Corrected Platform Errors pending, HAL CPE handling is not enabled\n"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\halp.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    halp.h

Abstract:

    This header file defines the private Hardware Architecture Layer (HAL)
    interfaces, defines and structures.

Author:

    John Vert (jvert) 11-Feb-92


Revision History:

--*/
#ifndef _HALP_H_
#define _HALP_H_

#include "nthal.h"
#include "hal.h"
#include "halnls.h"
#include "kxia64.h"
#include "acpitabl.h"

//
// Pickup the pnp guid definitions.
//

#include "wdmguid.h"

#ifndef _HALI_
#include "..\inc\hali.h"
#endif

#include "i64fw.h"

#define SAPIC_SPURIOUS_LEVEL 0
#define DPC_LEVEL            2
#define CMCI_LEVEL           3

#define SAPIC_SPURIOUS_VECTOR 0x0F

#define CMCI_VECTOR (CMCI_LEVEL << VECTOR_IRQL_SHIFT)          // 0x30
#define CPEI_VECTOR (CMCI_VECTOR+1)                            // 0x31
// CPEI_VECTOR is defined relative to CMCI_VECTOR,
// CPEI_LEVEL  is defined from CPEI_VECTOR.
#define CPEI_LEVEL  (CPEI_VECTOR >> VECTOR_IRQL_SHIFT)

#define SYNCH_VECTOR (SYNCH_LEVEL << VECTOR_IRQL_SHIFT)        // 0xD0
#define CLOCK_VECTOR (CLOCK_LEVEL << VECTOR_IRQL_SHIFT)        // 0xD0

#define IPI_VECTOR (IPI_LEVEL << VECTOR_IRQL_SHIFT)            // 0xE0

#define PROFILE_VECTOR (PROFILE_LEVEL << VECTOR_IRQL_SHIFT)    // 0xF0
#define PERF_VECTOR    (PROFILE_VECTOR+1)                      // 0xF1
#define MC_RZ_VECTOR   (0xD+(HIGH_LEVEL << VECTOR_IRQL_SHIFT)) // 0xFD
#define MC_WKUP_VECTOR (MC_RZ_VECTOR+1)                        // 0xFE

#if DBG

//
// _HALIA64_DPFLTR_LEVEL: HALIA64 specific DbgPrintEx() levels.
//

#ifndef DPFLTR_COMPONENT_PRIVATE_MINLEVEL
//
// FIXFIX - 01/2000: The DPFLTR LEVEL definitions do not specify a maximum.
//                   We are defining DPFLTR_INFO_LEVEL as the default max.
//
#define DPFLTR_COMPONENT_PRIVATE_MINLEVEL (DPFLTR_INFO_LEVEL + 1)
#endif // !DPFLTR_COMPONENT_PRIVATE_MINLEVEL

typedef enum _HALIA64_DPFLTR_LEVEL {
    HALIA64_DPFLTR_PNP_LEVEL      = DPFLTR_COMPONENT_PRIVATE_MINLEVEL,
    HALIA64_DPFLTR_PROFILE_LEVEL,
    HALIA64_DPFLTR_MCE_LEVEL,     // Machine Check Events level
    HALIA64_DPFLTR_MAX_LEVEL,
    HALIA64_DPFLTR_MAXMASK        = (((unsigned int)0xffffffff) >> ((unsigned int)(32-HALIA64_DPFLTR_MAX_LEVEL)))
} HALIA64_DPFLTR_LEVEL;

#define HAL_FATAL_ERROR   DPFLTR_ERROR_LEVEL
#define HAL_ERROR         DPFLTR_ERROR_LEVEL
#define HAL_WARNING       DPFLTR_WARNING_LEVEL
#define HAL_INFO          DPFLTR_INFO_LEVEL
#define HAL_VERBOSE       DPFLTR_INFO_LEVEL
#define HAL_PNP           HALIA64_DPFLTR_PNP_LEVEL
#define HAL_PROFILE       HALIA64_DPFLTR_PROFILE_LEVEL
#define HAL_MCE           HALIA64_DPFLTR_MCE_LEVEL

extern ULONG HalpUseDbgPrint;

VOID
__cdecl
HalpDebugPrint(
    ULONG  Level,
    PCCHAR Message,
    ...
    );

#define HalDebugPrint( _x_ )  HalpDebugPrint _x_

#else  // !DBG

#define HalDebugPrint( _x_ )

#endif // !DBG

//
// HALP_VALIDATE_LOW_IRQL()
//
// This macro validates the call at low irql - passive or apc levels - and returns
// STATUS_UNSUCCESSFUL if high irql.
//

#define HALP_VALIDATE_LOW_IRQL() \
 if (KeGetCurrentIrql() > APC_LEVEL) { \
    HalDebugPrint((HAL_ERROR,"HAL: code called at IRQL %d > APC_LEVEL\n", KeGetCurrentIrql() )); \
    ASSERT(FALSE); \
    return( STATUS_UNSUCCESSFUL );  \
 }

#define HAL_MAXIMUM_PROCESSOR 32
#define MAX_NODES             HAL_MAXIMUM_PROCESSOR
#define HAL_MAXIMUM_LID_ID    256

//
// Default clock and profile timer intervals (in 100ns-unit)
//

#define DEFAULT_CLOCK_INTERVAL 100000         // 10  ms
#define MINIMUM_CLOCK_INTERVAL 10000          //  1  ms
#define MAXIMUM_CLOCK_INTERVAL 100000         // 10  ms

extern double HalpITCTicksPer100ns;
extern ULONG HalpCPUMHz;


//
// Define Realtime Clock register numbers.
//

#define RTC_SECOND 0                    // second of minute [0..59]
#define RTC_SECOND_ALARM 1              // seconds to alarm
#define RTC_MINUTE 2                    // minute of hour [0..59]
#define RTC_MINUTE_ALARM 3              // minutes to alarm
#define RTC_HOUR 4                      // hour of day [0..23]
#define RTC_HOUR_ALARM 5                // hours to alarm
#define RTC_DAY_OF_WEEK 6               // day of week [1..7]
#define RTC_DAY_OF_MONTH 7              // day of month [1..31]
#define RTC_MONTH 8                     // month of year [1..12]
#define RTC_YEAR 9                      // year [00..99]
#define RTC_CENTURY 0x32                // Century byte offset
#define RTC_CONTROL_REGISTERA 10        // control register A
#define RTC_CONTROL_REGISTERB 11        // control register B
#define RTC_CONTROL_REGISTERC 12        // control register C
#define RTC_CONTROL_REGISTERD 13        // control register D
#define RTC_REGNUMBER_RTC_CR1 0x6A      // control register 1

#define RTC_ISA_ADDRESS_PORT   0x070

#define RTC_ISA_DATA_PORT      0x071

#include <efi.h>

#define EFI_PHYSICAL_GET_VARIABLE_INDEX  0xFF // GetVariable;
#define EFI_PHYSICAL_SET_VARIABLE_INDEX  0xFE // SetVariable;

//
// Time Services
//

#define EFI_GET_TIME_INDEX              0 // GetTime;
#define EFI_SET_TIME_INDEX              1 // SetTime;
#define EFI_GET_WAKEUP_TIME_INDEX       2 // GetWakeupTime;
#define EFI_SET_WAKEUP_TIME_INDEX       3 // SetWakeupTime;

//
// Virtual memory services
//

#define EFI_SET_VIRTUAL_ADDRESS_MAP_INDEX     4  // SetVirtualAddressMap;
#define EFI_CONVERT_POINTER_INDEX             5  // ConvertPointer;

//
// Variable serviers
//

#define EFI_GET_VARIABLE_INDEX                6 // GetVariable;
#define EFI_GET_NEXT_VARIABLE_NAME_INDEX      7 // GetNextVariableName;
#define EFI_SET_VARIABLE_INDEX                8 // SetVariable;

//
// Misc
//

#define EFI_GET_NEXT_HIGH_MONO_COUNT_INDEX    9  // GetNextHighMonotonicCount;
#define EFI_RESET_SYSTEM_INDEX               0xA // ResetSystem;


//
// Task priority functions
//

#define EFI_RAISE_TPL_INDEX                        0xB // Raise TPL
#define EFI_RESTORE_TPL_INDEX                      0xC // Restore TPL

//
// Memory functions
//

#define EFI_ALLOCATE_PAGES_INDEX                    0xD  // AllocatePages
#define EFI_FREE_PAGES_INDEX                        0xE  // FreePages
#define EFI_GET_MEMORY_MAP_INDEX                    0xF  // GetMemoryMap
#define EFI_ALLOCATE_POOL_INDEX                     0x10 // AllocatePool
#define EFI_FREE_POOL_INDEX                         0x11 // FreePool

//
// Event & timer functions
//

#define EFI_CREATE_EVENT_INDEX                      0x12 // CreateEvent
#define EFI_SET_TIMER_INDEX                         0x13 // SetTimer
#define EFI_WAIT_FOR_EVENT_INDEX                    0x14 // WaitForEvent
#define EFI_SIGNAL_EVENT_INDEX                      0x15 // SignalEvent
#define EFI_CLOSE_EVENT_INDEX                       0x16 // CloseEvent
#define EFI_NOTIFY_IDLE_INDEX                       0x17 // NotifyIdle



//
// Protocol handler functions
//

#define EFI_INSTALL_PROTOCOL_INTERFACE_INDEX        0x18 // InstallProtocolInterface;
#define EFI_REINSTALL_PROTOCOL_INTERFACE_INDEX      0x19 // ReinstallProtocolInterface;
#define EFI_UNINSTALL_PROTOCOL_INTERFACE_INDEX      0x1A // UninstallProtocolInterface;
#define EFI_HANDLE_PROTOCOL_INDEX                   0x1B // HandleProtocol;
#define EFI_REGISTER_PROTOCOL_NOTIFY_INDEX          0x1C // RegisterProtocolNotify;
#define EFI_LOCATE_HANDLE_INDEX_INDEX               0x1D // LocateHandle;
#define EFI_LOCATE_DEVICE_PATH_INDEX                0x1E // LocateDevicePath;
#define EFI_UNREFERENCE_HANDLE_INDEX                0x1F // UnreferenceHandle;
#define EFI_LOCATE_PROTOCOL_INDEX                   0x20 // LocateProtocol;

    //
    // Image functions
    //

#define EFI_IMAGE_LOAD_INDEX                        0x21 // LoadImage;
#define EFI_IMAGE_START_INDEX                       0x22 // StartImage;
#define EFI_EXIT_INDEX                              0x23 // Exit;
#define EFI_IMAGE_UNLOAD_INDEX                      0x24 // UnloadImage;
#define EFI_EXIT_BOOT_SERVICES_INDEX                0x25 // ExitBootServices;

    //
    // Misc functions
    //

#define    EFI_GET_NEXT_MONOTONIC_COUNT_INDEX       0x26 // GetNextMonotonicCount;
#define    EFI_STALL_INDEX                          0x27 // Stall;
#define    EFI_SET_WATCHDOG_TIMER_INDEX             0x28 // SetWatchdogTimer;


#define EFI_VARIABLE_ATTRIBUTE               \
        EFI_VARIABLE_NON_VOLATILE | EFI_VARIABLE_BOOTSERVICE_ACCESS | EFI_VARIABLE_RUNTIME_ACCESS


extern PVOID HalpRtcAddressPort;

extern PVOID HalpRtcDataPort;

extern PLOADER_PARAMETER_BLOCK KeLoaderBlock;

//
// Define Control Register A structure.
//

typedef struct _RTC_CONTROL_REGISTER_A {
    UCHAR RateSelect : 4;
    UCHAR TimebaseDivisor : 3;
    UCHAR UpdateInProgress : 1;
} RTC_CONTROL_REGISTER_A, *PRTC_CONTROL_REGISTER_A;

//
// Define Control Register B structure.
//

typedef struct _RTC_CONTROL_REGISTER_B {
    UCHAR DayLightSavingsEnable : 1;
    UCHAR HoursFormat : 1;
    UCHAR DataMode : 1;
    UCHAR SquareWaveEnable : 1;
    UCHAR UpdateInterruptEnable : 1;
    UCHAR AlarmInterruptEnable : 1;
    UCHAR TimerInterruptEnable : 1;
    UCHAR SetTime : 1;
} RTC_CONTROL_REGISTER_B, *PRTC_CONTROL_REGISTER_B;

//
// Define Control Register C structure.
//

typedef struct _RTC_CONTROL_REGISTER_C {
    UCHAR Fill : 4;
    UCHAR UpdateInterruptFlag : 1;
    UCHAR AlarmInterruptFlag : 1;
    UCHAR TimeInterruptFlag : 1;
    UCHAR InterruptRequest : 1;
} RTC_CONTROL_REGISTER_C, *PRTC_CONTROL_REGISTER_C;

//
// Define Control Register D structure.
//

typedef struct _RTC_CONTROL_REGISTER_D {
    UCHAR Fill : 7;
    UCHAR ValidTime : 1;
} RTC_CONTROL_REGISTER_D, *PRTC_CONTROL_REGISTER_D;




#define EISA_DMA_CHANNELS 8

extern UCHAR HalpDmaChannelMasks[];

//
// HalpOwnedDisplayBeforeSleep is defined in mpdat.c
//

extern BOOLEAN HalpOwnedDisplayBeforeSleep;

#define PIC_VECTORS 16

#define PRIMARY_VECTOR_BASE  0x30

extern ULONG HalpDefaultInterruptAffinity;

//
// Thierry / PeterJ 02/00:
//  Instead of implementing our own IPI generic call, we use KiIpiGenericCall().
//

typedef
ULONG_PTR
(*PKIPI_BROADCAST_WORKER)(
    IN ULONG_PTR Argument
    );

ULONG_PTR
KiIpiGenericCall (
    IN PKIPI_BROADCAST_WORKER BroadcastFunction,
    IN ULONG_PTR Context
    );

//
// ROUND UP SIZE macros:
//
// SIZE_T
// ROUND_UP_SIZE_T(
//      IN SIZE_T _SizeT,
//      IN ULONG  _Pow2,
//      )
//

#define ROUND_UP_SIZE_T(_SizeT, _Pow2) \
        ( (SIZE_T) ( (((SIZE_T)(_SizeT))+(_Pow2)-1) & (~(((LONG)(_Pow2))-1)) ) )

#define ROUND_UP_SIZE(/* SIZE_T */ _SizeT) ROUND_UP_SIZE_T((_SizeT), sizeof(SIZE_T))

//
// PCR address.
// Temporary macros; should already be defined in ntddk.h for IA64
//

#define PCR ((volatile KPCR * const)KIPCR)

//
// PCR has HalReserved area. The following will be the offsets reserved
// by HAL in the HalReserved area.
//

#define CURRENT_ITM_VALUE_INDEX                    0
#define PROCESSOR_ID_INDEX                         1
#define PROCESSOR_INDEX_BEFORE_PROFILING           5  // ToBeIncremented if new index

// PROCESSOR_PROFILING_INDEX:
// HalReserved[] base of indexes used for Performance Profiling based
// on the IA64 Performance Counters. Refer to ia64prof.h:_HALPROFILE_PCR.
//

#define PROCESSOR_PROFILING_INDEX       (PROCESSOR_INDEX_BEFORE_PROFILING + 1)

#define PIC_SLAVE_IRQ      2
#define PIC_SLAVE_REDIRECT 9

extern PVOID HalpSleepPageLock;


NTSTATUS
HalpQueryFrequency(
    PULONGLONG ITCFrequency,
    PULONGLONG ProcessorFrequency
    );

VOID
HalpSynchICache (
    VOID
    );

VOID
KeSetAffinityThread (
    PKTHREAD       Thread,
    KAFFINITY      HalpActiveProcessors
    );

extern BOOLEAN
KdPollBreakIn (
    VOID
    );


NTSTATUS
HalAllocateAdapterChannel (
    IN PADAPTER_OBJECT AdapterObject,
    IN PWAIT_CONTEXT_BLOCK Wcb,
    IN ULONG NumberOfMapRegisters,
    IN PDRIVER_CONTROL ExecutionRoutine
    );

NTSTATUS
HalRealAllocateAdapterChannel(
    IN PADAPTER_OBJECT AdapterObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG NumberOfMapRegisters,
    IN PDRIVER_CONTROL ExecutionRoutine,
    IN PVOID Context
    );

ULONG
HalReadDmaCounter (
   IN PADAPTER_OBJECT AdapterObject
   );

VOID
HalpInitializeInterrupts (
    VOID
    );

VOID
HalpInitIntiInfo(
    VOID
    );

VOID
HalpInitEOITable(
    VOID
    );

VOID
HalpWriteEOITable(
    IN ULONG Vector,
    IN PULONG_PTR EoiAddress,
    IN ULONG Number
    );

VOID
HalInitializeProcessor (
    ULONG Number,
    PLOADER_PARAMETER_BLOCK LoaderBlock
    );

VOID
HalpInitIoMemoryBase (
    VOID
    );

VOID
HalpInitializeX86Int10Call (
    VOID
    );

VOID
HalpGetParameters (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
     );


VOID
HalpClearClock (
      VOID
     );

VOID
HalpIpiInterruptHandler(
   IN PKINTERRUPT_ROUTINE Interrupt,
   IN PKTRAP_FRAME TrapFrame
   );

VOID
HalpSpuriousHandler (
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME TrapFrame
    );


VOID
HalpCMCIHandler (
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME TrapFrame
    );

VOID
HalpCPEIHandler (
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME TrapFrame
    );

VOID
HalpMcRzHandler (
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME TrapFrame
    );


VOID
HalpMcWkupHandler (
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME TrapFrame
    );


NTSTATUS
HalpEfiInitialization (
    PLOADER_PARAMETER_BLOCK LoaderBlock
    );


VOID
HalpPerfInterrupt (
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME TrapFrame
    );

ULONG_PTR
HalpSetProfileInterruptHandler(
    IN ULONG_PTR ProfileInterruptHandler
    );

VOID
HalpSetInternalVector (
    IN ULONG InternalVector,
    IN VOID (*HalInterruptServiceRoutine)(VOID)
    );

VOID
HalpClockInterrupt (
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME TrapFrame
    );

VOID
HalpClockInterruptPn(
   IN PKINTERRUPT_ROUTINE Interrupt,
   IN PKTRAP_FRAME TrapFrame
  );

VOID
HalpInitializeClock  (
    VOID
    );

VOID
HalpInitializeClockPn (
    VOID
    );

VOID
HalpInitializeClockInterrupts(
    VOID
    );

VOID
HalpSetInitialClockRate (
    VOID
    );

VOID
HalpInitializeTimerResolution (
    ULONG Rate
    );

VOID
HalpInitApicDebugMappings(
    VOID
    );

VOID
HalpSendIPI (
    IN USHORT ProcessorID,
    IN ULONGLONG Data
    );


VOID
HalpMcWakeUp (
    VOID
    );



VOID
HalpOSRendez (
    IN USHORT ProcessorID
    );



VOID
HalSweepDcache (
    VOID
    );

VOID
HalSweepIcache (
    VOID
    );

VOID
HalSweepIcacheRange (
    IN PVOID BaseAddress,
    IN SIZE_T Length
    );

VOID
HalSweepDcacheRange (
    IN PVOID BaseAddress,
    IN SIZE_T Length
    );

VOID
HalSweepCacheRange (
   IN PVOID BaseAddress,
   IN SIZE_T Length
   );

VOID
HalpSweepcacheLines (
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfLines
    );

LONGLONG
HalCallPal (
   IN ULONGLONG FunctionIndex,
   IN ULONGLONG Arguement1,
   IN ULONGLONG Arguement2,
   IN ULONGLONG Arguement3,
   OUT PULONGLONG ReturnValue0,
   OUT PULONGLONG ReturnValue1,
   OUT PULONGLONG ReturnValue2,
   OUT PULONGLONG ReturnValue3
   );

ULONG
HalGetDeviceData (
    IN PBUS_HANDLER             BusHandler,
    IN PBUS_HANDLER             RootHandler,
    IN PDEVICE_HANDLER_OBJECT   DeviceHandler,
    IN ULONG                    DataType,
    IN PVOID                    Buffer,
    IN ULONG                    Offset,
    IN ULONG                    Length
    );

ULONG
HalSetDeviceData (
    IN PBUS_HANDLER             BusHandler,
    IN PBUS_HANDLER             RootHandler,
    IN PDEVICE_HANDLER_OBJECT   DeviceHandler,
    IN ULONG                    DataType,
    IN PVOID                    Buffer,
    IN ULONG                    Offset,
    IN ULONG                    Length
    );

NTSTATUS
HalpHibernateHal (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler
    );

NTSTATUS
HalpResumeHal (
    IN PBUS_HANDLER  BusHandler,
    IN PBUS_HANDLER  RootHandler
    );


ULONG
HalpGetFeatureBits (
    VOID
    );

NTSTATUS
HalpGetApicIdByProcessorNumber(
    IN     UCHAR     Processor,
    IN OUT USHORT   *ApicId
    );

ULONG
HalpGetProcessorNumberByApicId(
    USHORT ApicId
    );

VOID
HalpAddNodeNumber(
    ULONG
    );

#define HalpVectorToNode(vector)        ((vector)>>8)
#define HalpVector(node, idtentry)      ((node)<<8|(idtentry))

extern UCHAR  HalpMaxProcsPerCluster;

//
// Always called with the IDT form of the vector
//

#define HalpSetHandlerAddressToVector(Vector, Handler) \
   PCR-> InterruptRoutine[Vector] = (PKINTERRUPT_ROUTINE)Handler;

#define HalpEnableInterrupts()   __ssm(1 << PSR_I)

BOOLEAN
HalpDisableInterrupts (
    VOID
    );

ULONG
HalpAcquireHighLevelLock (
    PKSPIN_LOCK Lock
    );

VOID
HalpReleaseHighLevelLock (
    PKSPIN_LOCK Lock,
    ULONG       OldLevel
    );

#ifdef RtlMoveMemory
#undef RtlMoveMemory
#undef RtlCopyMemory
#undef RtlFillMemory
#undef RtlZeroMemory

#define RtlCopyMemory(Destination,Source,Length) RtlMoveMemory((Destination),(Source),(Length))

VOID
RtlMoveMemory (
   PVOID Destination,
   CONST VOID *Source,
   ULONG Length
   );

VOID
RtlFillMemory (
   PVOID Destination,
   ULONG Length,
   UCHAR Fill
   );

VOID
RtlZeroMemory (
   PVOID Destination,
   ULONG Length
   );

#endif


#include "ixisa.h"

//
// Define map register translation entry structure.
//

typedef struct _TRANSLATION_ENTRY {
    PVOID VirtualAddress;
    ULONG PhysicalAddress;
    ULONG Index;
} TRANSLATION_ENTRY, *PTRANSLATION_ENTRY;

//
//
//

typedef struct _PROCESSOR_INFO {
    UCHAR   NtProcessorNumber;
    UCHAR   AcpiProcessorID;
    USHORT  LocalApicID;

} PROCESSOR_INFO, *PPROCESSOR_INFO;

extern PROCESSOR_INFO HalpProcessorInfo[HAL_MAXIMUM_PROCESSOR];

struct _MPINFO {
    ULONG ProcessorCount;
    ULONG IoSapicCount;
};

extern struct _MPINFO HalpMpInfo;

//
// HAL private Mask of all of the active processors.
//
// The specific processors bits are based on their _KPCR.Number values.

extern KAFFINITY HalpActiveProcessors;

#define VECTOR_SIZE     8
#define IPI_ID_SHIFT    4
#define IpiTOKEN_SHIFT  20
#define IpiTOKEN    0xFFE

#define EID_MASK        0xFF00

//
// Should be read from SST
//

#define DEFAULT_OS_RENDEZ_VECTOR  0xF0

#define RENDEZ_TIME_OUT  0XFFFF

//
// Some devices require a phyicially contiguous data buffers for DMA transfers.
// Map registers are used give the appearance that all data buffers are
// contiguous.  In order to pool all of the map registers a master
// adapter object is used.  This object is allocated and saved internal to this
// file.  It contains a bit map for allocation of the registers and a queue
// for requests which are waiting for more map registers.  This object is
// allocated during the first request to allocate an adapter which requires
// map registers.
//
// In this system, the map registers are translation entries which point to
// map buffers.  Map buffers are physically contiguous and have physical memory
// addresses less than 0x01000000.  All of the map registers are allocated
// initialially; however, the map buffers are allocated base in the number of
// adapters which are allocated.
//
// If the master adapter is NULL in the adapter object then device does not
// require any map registers.
//

extern PADAPTER_OBJECT MasterAdapterObject;

extern POBJECT_TYPE *IoAdapterObjectType;

extern BOOLEAN NoMemoryAbove4Gb;

extern BOOLEAN HalpEisaDma;

//
// Map buffer prameters.  These are initialized in HalInitSystem
//

extern PHYSICAL_ADDRESS HalpMapBufferPhysicalAddress;
extern ULONG HalpMapBufferSize;

extern ULONG HalpBusType;
extern ULONG HalpCpuType;
extern UCHAR HalpSerialLen;
extern UCHAR HalpSerialNumber[];

//
// Resource usage information
//

#pragma pack(1)
typedef struct {
    UCHAR   Flags;
    KIRQL   Irql;
    UCHAR   BusReleativeVector;
} IDTUsage;

typedef struct _HalAddressUsage{
    struct _HalAddressUsage *Next;
    CM_RESOURCE_TYPE        Type;       // Port or Memory
    UCHAR                   Flags;      // same as IDTUsage.Flags
    struct {
        ULONG   Start;
        ULONG   Length;
    }                       Element[];
} ADDRESS_USAGE;
#pragma pack()

//
// Added the following line
//

#define MAXIMUM_IDTVECTOR   0x0FF

#define IDTOwned            0x01        // IDT is not available for others
#define InterruptLatched    0x02        // Level or Latched
#define InternalUsage       0x11        // Report usage on internal bus
#define DeviceUsage         0x21        // Report usage on device bus

extern IDTUsage         HalpIDTUsage[];
extern ADDRESS_USAGE   *HalpAddressUsageList;

#define HalpRegisterAddressUsage(a) \
    (a)->Next = HalpAddressUsageList, HalpAddressUsageList = (a);


//
// Temp definitions to thunk into supporting new bus extension format
//

VOID
HalpRegisterInternalBusHandlers (
    VOID
    );

PBUS_HANDLER
HalpAllocateBusHandler (
    IN INTERFACE_TYPE   InterfaceType,
    IN BUS_DATA_TYPE    BusDataType,
    IN ULONG            BusNumber,
    IN INTERFACE_TYPE   ParentBusDataType,
    IN ULONG            ParentBusNumber,
    IN ULONG            BusSpecificData
    );

#define HalpHandlerForBus   HaliHandlerForBus
#define HalpSetBusHandlerParent(c,p)    (c)->ParentHandler = p;

//
// Define function prototypes.
//

VOID
HalInitSystemPhase2(
    VOID
    );

KIRQL
HaliRaiseIrqlToDpcLevel (
   VOID
   );

BOOLEAN
HalpGrowMapBuffers(
    PADAPTER_OBJECT AdapterObject,
    ULONG Amount
    );

PADAPTER_OBJECT
HalpAllocateAdapter(
    IN ULONG MapRegistersPerChannel,
    IN PVOID AdapterBaseVa,
    IN PVOID MapRegisterBase
    );

KIRQL
HalpDisableAllInterrupts (
    VOID
    );

VOID
HalpReenableInterrupts (
    KIRQL NewIrql
    );

VOID
HalpSetInitialProfileState(
    VOID
    );

VOID
HalpProfileInterrupt (
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME TrapFrame
    );

typedef
VOID
(*PHAL_PROFILE_INTERRUPT_HANDLER)(
    IN PKTRAP_FRAME TrapFrame
    );

VOID
HalpInitializeClock(
    VOID
    );

VOID
HalpInitializeStallExecution(
    IN CCHAR ProcessorNumber
    );

VOID
HalpRemoveFences (
    VOID
    );

VOID
HalpInitializePICs(
    BOOLEAN EnableInterrupts
    );

VOID
HalpIrq13Handler (
    VOID
   );

VOID
HalpFlushTLB (
    VOID
    );

VOID
HalpSerialize (
    VOID
    );


PVOID
HalpMapPhysicalMemory(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG NumberPages,
    IN MEMORY_CACHING_TYPE CacheType
    );

PVOID
HalpMapPhysicalMemory64(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG NumberPages
    );

VOID
HalpUnmapVirtualAddress(
    IN PVOID    VirtualAddress,
    IN ULONG    NumberPages
    );

BOOLEAN
HalpVirtualToPhysical(
    IN  ULONG_PTR           VirtualAddress,
    OUT PPHYSICAL_ADDRESS   PhysicalAddress
    );

PVOID
HalpMapPhysicalMemoryWriteThrough(
    IN PVOID  PhysicalAddress,
    IN ULONG  NumberPages
    );

PVOID
HalpAllocPhysicalMemory(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN ULONG_PTR MaxPhysicalAddress,
    IN ULONG NoPages,
    IN BOOLEAN bAlignOn64k
    );

VOID
HalpBiosDisplayReset(
    IN VOID
    );

HAL_DISPLAY_BIOS_INFORMATION
HalpGetDisplayBiosInformation (
    VOID
    );

VOID
HalpInitializeCmos (
   VOID
   );

VOID
HalpReadCmosTime (
   PTIME_FIELDS TimeFields
   );

VOID
HalpWriteCmosTime (
   PTIME_FIELDS TimeFields
   );

VOID
HalpAcquireCmosSpinLock (
    VOID
    );

VOID
HalpReleaseCmosSpinLock (
    VOID
    );

VOID
HalpResetAllProcessors (
    VOID
    );

VOID
HalpCpuID (
    ULONG   InEax,
    PULONG  OutEax,
    PULONG  OutEbx,
    PULONG  OutEcx,
    PULONG  OutEdx
    );

VOID
HalpYieldProcessor (
    VOID
    );

ULONGLONG
FASTCALL
RDMSR (
    IN ULONG MsrAddress
    );

VOID
WRMSR (
    IN ULONG        MsrAddress,
    IN ULONGLONG    MsrValue
    );

VOID
HalpRegisterVector (
    IN UCHAR    ReportFlags,
    IN ULONG    BusInterruptVector,
    IN ULONG    SystemInterruptVector,
    IN KIRQL    SystemIrql
    );

VOID
HalpReportResourceUsage (
    IN PUNICODE_STRING  HalName,
    IN INTERFACE_TYPE   DeviceInterfaceToUse
    );

VOID
HalpYearIs(
    IN ULONG Year
    );

VOID
HalpRecordEisaInterruptVectors(
    VOID
    );

VOID
HalpMcaCurrentProcessorSetConfig(
    VOID
    );

NTSTATUS
HalpGetNextProcessorApicId(
    IN ULONG ProcessorNumber,
    IN OUT UCHAR    *ApicId
    );

//
// Defines for HalpFeatureBits
//

typedef enum _HALP_FEATURE {
    HAL_PERF_EVENTS             = 0x00000001,
    HAL_NO_SPECULATION          = 0x00000002,
    HAL_MCA_PRESENT             = 0x00000004,
    HAL_CMC_PRESENT             = 0x00000008,
    HAL_CPE_PRESENT             = 0x00000010,
    HAL_MCE_OEMDRIVERS_ENABLED  = 0x00000020,
    HAL_MCE_PROCNUMBER          = 0x01000000,
    HALP_FEATURE_INIT           = (HAL_MCA_PRESENT|HAL_MCE_PROCNUMBER)
} HALP_FEATURE;

extern ULONG HalpFeatureBits;

//
// Added HalpPciIrqMask
//

extern USHORT HalpPciIrqMask;

//
// Defines for Processor Features returned from CPUID instruction
//

#define CPUID_MCA_MASK  0x4000
#define CPUID_MCE_MASK  0x0080
#define CPUID_VME_MASK  0x0002

//
// Added ITIR bit field masks
//

#define ITIR_PPN_MASK       0x7FFF000000000000
#define IoSpaceSize         0x14
#define Attribute_PPN_Mask  0x0000FFFFFFFFF000

#define IoSpaceAttribute    0x0010000000000473

//
// IA64 ERROR Apis
//

#define HALP_KERNEL_TOKEN  0x4259364117

NTSTATUS
HalpGetMceInformation(
    IN  PHAL_ERROR_INFO ErrorInfo,
    OUT PULONG          ErrorInfoLength
    );

NTSTATUS
HalpMceRegisterKernelDriver(
    IN PKERNEL_ERROR_HANDLER_INFO KernelErrorHandler,
    IN ULONG                      InfoSize
    );

typedef struct _HALP_MCELOGS_STATS *PHALP_MCELOGS_STATS; // forward declaration.

NTSTATUS
HalpGetFwMceLog(
    IN ULONG                MceType,
    IN PERROR_RECORD_HEADER Record,
    IN PHALP_MCELOGS_STATS  MceLogsStats,
    IN BOOLEAN              DoClearLog
    );

//
// IA64 Machine Check Error Logs:
//      WMI requires processor LID being stored in the Log.
//      This LID corresponds to the processor on which the SAL_PROC was executed on.
//
// TEMPTEMP: Implementation is temporary, until we implement HAL SW Error Section.
//           It currently used the LID value stored in HalReserved[PROCESSOR_ID_INDEX]
//           at processor initialization.
//           Note that the current FW builds do not update the _ERROR_PROCESSOR.CRLid field,
//           assuming there is a _ERROR_PROCESSOR section in the record.
//
//           This function should be in sync with the mce.h function GetFwMceLogProcessorNumber().
//

__inline
VOID
HalpSetFwMceLogProcessorNumber(
    PERROR_RECORD_HEADER Log
    )
{
    USHORT lid = (USHORT)(PCR->HalReserved[PROCESSOR_ID_INDEX]);
    PERROR_SECTION_HEADER section = (PERROR_SECTION_HEADER)((ULONG64)Log + sizeof(*Log));
    Log->TimeStamp.Reserved = (UCHAR)((lid >> 8) & 0xff);
    section->Reserved = (UCHAR)(lid & 0xff);
} // HalpSetFwMceLogProcessorNumber()

#define HalpGetFwMceLogProcessorNumber( /* PERROR_RECORD_HEADER */ _Log ) \
    GetFwMceLogProcessorNumber( (_Log) )

#define HALP_FWMCE_DO_CLEAR_LOG     (TRUE)
#define HALP_FWMCE_DONOT_CLEAR_LOG  (FALSE)

#define HALP_MCA_STATEDUMP_SIZE  (1024 * sizeof(ULONGLONG))     //  8KB
#define HALP_MCA_BACKSTORE_SIZE  (4 * 1024 * sizeof(ULONGLONG)) // 32KB
#define HALP_MCA_STACK_SIZE      (4 * 1024 * sizeof(ULONGLONG)) // 32KB

#define HALP_INIT_STATEDUMP_SIZE (1024 * sizeof(ULONGLONG))     //  8KB
#define HALP_INIT_BACKSTORE_SIZE (4 * 1024 * sizeof(ULONGLONG)) // 32KB
#define HALP_INIT_STACK_SIZE     (4 * 1024 * sizeof(ULONGLONG)) // 32KB

BOOLEAN
HalpAllocateMceStacks(
    IN ULONG Number
    );

BOOLEAN
HalpPreAllocateMceRecords(
    IN ULONG Number
    );

//
// IA64 MCA Apis
//

VOID
HalpMCAEnable (
    VOID
    );

NTSTATUS
HalpGetMcaLog(
    OUT PMCA_EXCEPTION  Buffer,
    IN  ULONG           BufferSize,
    OUT PULONG          ReturnedLength
    );

NTSTATUS
HalpSetMcaLog(
    IN  PMCA_EXCEPTION Buffer,
    IN  ULONG          BufferSize
    );

NTSTATUS
HalpMcaRegisterDriver(
    IN PMCA_DRIVER_INFO pMcaDriverInfo  // Info about registering driver
    );

VOID
HalpMcaInit(
    VOID
    );

VOID
HalpMCADisable(
    VOID
    );

//
// MCA (but non-OS_MCA related) KeBugCheckEx wrapper:
//

#define HalpMcaKeBugCheckEx( _McaBugCheckType, _McaLog, _McaAllocatedLogSize, _Arg4 )      \
                KeBugCheckEx( MACHINE_CHECK_EXCEPTION, (ULONG_PTR)(_McaBugCheckType),      \
                                                       (ULONG_PTR)(_McaLog),               \
                                                       (ULONG_PTR)(_McaAllocatedLogSize),  \
                                                       (ULONG_PTR)(_Arg4) )

//
// IA64 Default number of MCA Error Records which size is SAL_GET_STATE_INFO_SIZE.MCA
//
// Really the size is rounded up to a multiple of the page size.
//

#define HALP_DEFAULT_PROCESSOR_MCA_RECORDS   1

//
// IA64 Default number of INIT Event Records which size is SAL_GET_STATE_INFO_SIZE.INIT
//
// Really the size is rounded up to a multiple of the page size.
//

#define HALP_DEFAULT_PROCESSOR_INIT_RECORDS  1

//
// IA64 CMC Apis related to:
//
//  - Processor
//  - Platform
//

NTSTATUS
HalpGetCmcLog(
    OUT PCMC_EXCEPTION  Buffer,
    IN  ULONG           BufferSize,
    OUT PULONG          ReturnedLength
    );

NTSTATUS
HalpSetCmcLog(
    IN  PCMC_EXCEPTION Buffer,
    IN  ULONG          BufferSize
    );

NTSTATUS
HalpCmcRegisterDriver(
    IN PCMC_DRIVER_INFO pCmcDriverInfo  // Info about registering driver
    );

NTSTATUS
HalpGetCpeLog(
    OUT PCPE_EXCEPTION  Buffer,
    IN  ULONG           BufferSize,
    OUT PULONG          ReturnedLength
    );

NTSTATUS
HalpSetCpeLog(
    IN  PCPE_EXCEPTION Buffer,
    IN  ULONG          BufferSize
    );

NTSTATUS
HalpCpeRegisterDriver(
    IN PCPE_DRIVER_INFO pCmcDriverInfo  // Info about registering driver
    );

#define HalpWriteCMCVector( Value ) __setReg(CV_IA64_SaCMCV, Value)

ULONG_PTR
HalpSetCMCVector(
    IN ULONG_PTR CmcVector
    );

//
// IA64 generic MCE Definitions.
//

#define HALP_MCELOGS_MAXCOUNT  50L

typedef struct _HALP_MCELOGS_STATS   {  // The following counts are for the entire boot session.
    ULONG      MaxLogSize;          // Maximum size of the information logged by SAL.
    LONG       Count1;              // Event type specific Counter.
    LONG       Count2;              // Event type specific Counter.
    LONG       KernelDeliveryFails; // Number of Kernel callback failures.
    LONG       DriverDpcQueueFails; // Number of OEM CMC Driver Dpc queueing failures.
    ULONG      PollingInterval;     // Polling interval in seconds. Only used for CPE.
    ULONG      GetStateFails;       // Number of failures in getting  the log from FW.
    ULONG      ClearStateFails;     // Number of failures in clearing the log from FW.
    ULONGLONG  LogId;               // Last record identifier.
} HALP_MCELOGS_STATS, *PHALP_MCELOGS_STATS;

//
// MC Event Type specific definition for HALP_MCELOGS_STATS.Count*
//

#define CmcInterruptCount   Count1      // CMC interrupts   count.
#define CpeInterruptCount   Count1      // CMC interrupts   count.
#define McaPreviousCount    Count1      // MCA previous  events counter.
#define McaCorrectedCount   Count2      // MCA corrected events counter.

typedef struct _HALP_MCELOGS_HEADER  {
    ULONG               Count;          // Current number of saved logs.
    ULONG               MaxCount;       // Maximum number of saved logs.
    ULONG               Overflow;       // Number of overflows
    ULONG               Tag;            // Pool allocation tag.
    ULONG               AllocateFails;  // Number of failed allocations.
    ULONG               Padding;
    SINGLE_LIST_ENTRY   Logs;           // List header    of saved logs.
} HALP_MCELOGS_HEADER, *PHALP_MCELOGS_HEADER;

#define HalpMceLogFromListEntry( _ListEntry )  \
    ((PERROR_RECORD_HEADER)((ULONG_PTR)(_ListEntry) + sizeof(SINGLE_LIST_ENTRY)))

//
// IA64 MCA Info Structure
//
//      to keep track of MCA features available on installed hardware
//
//

typedef struct _HALP_MCA_INFO {
    FAST_MUTEX          Mutex;              // non-recursive Mutex for low irql ops.
    HALP_MCELOGS_STATS  Stats;              // Information about log collection and interrupts.
    PVOID               KernelToken;        // Kernel identification.
    LONG                DpcNotification;    // Notify kernel or driver at Dispatch level.
    LONG                NoBugCheck;         // Flag to disable bugcheck calls under OS_MCA.
    KERNEL_MCA_DELIVERY KernelDelivery;     // Kernel-WMI registered notification.
    HALP_MCELOGS_HEADER KernelLogs;         // Saved logs for Kernel queries.
    MCA_DRIVER_INFO     DriverInfo;         // Info about registered OEM MCA driver
    KDPC                DriverDpc;          // DPC object for MCA
    HALP_MCELOGS_HEADER DriverLogs;         // Saved logs for OEM MCA driver.
} HALP_MCA_INFO, *PHALP_MCA_INFO;

extern HALP_MCA_INFO HalpMcaInfo;

#define HalpInitializeMcaMutex()  ExInitializeFastMutex( &HalpMcaInfo.Mutex )
#define HalpInitializeMcaInfo()   \
{ \
    HalpInitializeMcaMutex();                \
    HalpMcaInfo.KernelLogs.Tag = 'KacM';     \
    HalpMcaInfo.KernelLogs.Logs.Next = NULL; \
    HalpMcaInfo.DriverLogs.Tag = 'DacM';     \
    HalpMcaInfo.DriverLogs.Logs.Next = NULL; \
}
#define HalpAcquireMcaMutex()     ExAcquireFastMutex( &HalpMcaInfo.Mutex )
#define HalpReleaseMcaMutex()     ExReleaseFastMutex( &HalpMcaInfo.Mutex )

__inline
ULONG
HalpGetMaxMcaLogSizeProtected(
    VOID
    )
{
    ULONG maxSize;
    HalpAcquireMcaMutex();
    maxSize = HalpMcaInfo.Stats.MaxLogSize;
    HalpReleaseMcaMutex();
    return( maxSize );
} // HalpGetMaxMcaLogSizeProtected()

//
// IA64 HAL private MCE definitions.
//
// Note on current implementation: we use the MCA_INFO.Mutex.
//

#define HalpInitializeMceMutex()
#define HalpAcquireMceMutex()     ExAcquireFastMutex( &HalpMcaInfo.Mutex )
#define HalpReleaseMceMutex()     ExReleaseFastMutex( &HalpMcaInfo.Mutex )

extern KERNEL_MCE_DELIVERY HalpMceKernelDelivery;

//
// HalpMceDeliveryArgument1( )
//
// Note that the low 32 bits are only used for now...
//

#define HalpMceDeliveryArgument1( _MceOperation,  _MceEventType ) \
    ((PVOID)(ULONG_PTR) ((((_MceOperation) & KERNEL_MCE_OPERATION_MASK) << KERNEL_MCE_OPERATION_SHIFT) | ((_MceEventType) & KERNEL_MCE_EVENTTYPE_MASK) ) )

//
// IA64 INIT Info Structure
//
//      to keep track of INIT features available on installed hardware
//

typedef struct _HALP_INIT_INFO {
    FAST_MUTEX  Mutex;
    ULONG       MaxLogSize;     // Maximum size of the information logged by SAL.
} HALP_INIT_INFO, *PHALP_INIT_INFO;

extern HALP_INIT_INFO HalpInitInfo;

#define HalpInitializeInitMutex()  ExInitializeFastMutex( &HalpInitInfo.Mutex )
#define HalpAcquireInitMutex()     ExAcquireFastMutex( &HalpInitInfo.Mutex )
#define HalpReleaseInitMutex()     ExReleaseFastMutex( &HalpInitInfo.Mutex )

__inline
ULONG
HalpGetMaxInitLogSizeProtected(
    VOID
    )
{
    ULONG maxSize;
    HalpAcquireInitMutex();
    maxSize = HalpInitInfo.MaxLogSize;
    HalpReleaseInitMutex();
    return( maxSize );
} // HalpGetMaxInitLogSizeProtected()

//
// IA64 CMC
//

//
// HALP_CMC_DEFAULT_POLLING_INTERVAL
// HALP_CMC_MINIMUM_POLLING_INTERVAL
//
// If these should be exposed to WMI or OEM CMC driver, we will expose them in ntos\inc\hal.h
//

#define HALP_CMC_DEFAULT_POLLING_INTERVAL ((ULONG)60)
#define HALP_CMC_MINIMUM_POLLING_INTERVAL ((ULONG)15)

//
// IA64 CMC Info Structure
//
//      to keep track of CMC features available on installed hardware
//
// Implementation Notes - Thierry 09/15/2000.
//
//  - HAL_CMC_INFO and HAL_CPE_INFO have identical definitions at this time.
//    The merging of the code and data definitions was considered and even implemented.
//    However, because of the lack of testing with these FW/SAL features, I decided to
//    keep them separate. After further testing of the IA64 CMC/CPE features, we might
//    decide to merge them or not...
//
// MP notes 08/2000:
//
//  HALP_CMC_INFO.HalpCmcInfo
//      - only one static instance of this structure.
//      - HAL global variable.
//
//  HAL_CMC_INFO.Mutex
//      - Initialized by HalpInitializeOSMCA() on BSP.
//      - Used to synchronize accesses to structure members accessed at passive level operations.
//
//  HAL_CMC_INFO.Stats.MaxLogSize
//      - is updated by HalpInitializeOSMCA() on BSP. Not modified later.
//      - does not require any MP protection for further read accesses.
//
//  HAL_CMC_INFO.Stats.InterruptsCount
//      - Incremented with interlock at CMCI_LEVEL.
//      - Read at passive level. Approximation is fine.
//
//  HAL_CMC_INFO.Stats.KernelDeliveryFails
//      - Incremented with interlock at CMCI_LEVEL.
//      - Read at passive level. Approximation is fine.
//
//  HAL_CMC_INFO.Stats.KernelDeliveryFails
//      - Increment with interlock at CMCI_LEVEL.
//      - Read at passive level. Approximation is fine.
//
//  HAL_CMC_INFO.Stats.GetStateFails
//      - Incremented at passive level under CMC Mutex protection.
//      - Read at passive level with CMC Mutex protection.
//
//  HAL_CMC_INFO.Stats.ClearStateFails
//      - Incremented at passive level under CMC Mutex protection.
//      - Read at passive level with CMC Mutex protection.
//
//  HAL_CMC_INFO.Stats.LogId
//      - Updated at passive level under CMC Mutex protection.
//      - Read at passive level with CMC Mutex protection.
//
//  HAL_CMC_INFO.KernelToken
//      - is updated by HalpInitializeOSMCA() on BSP. Not modified later.
//      - does not require any MP protection for further read accesses.
//
//  HAL_CMC_INFO.KernelDelivery
//      - is updated by HalpMceRegisterKernelDriver() under CMC Mutex protection.
//        FIXFIX - 09/21/2000 - This initialization has a small window of where a CMC interrupt
//                              could occur and the memory change is not committed. ToBeFixed.
//      - Loaded as CMCI_LEVEL and branched to.
//      - Read at passive level as a flag under CMC Mutex protection.
//
//  HAL_CMC_INFO.KernelLogs
//      - This entire structure is initialized and updated at passive level under CMC Mutex
//        protection with the exception of KernelLogs.Tag initialized by HalpInitializeCmcInfo(),
//        called by HalpMcaInit(). HalpMcaInit() is called at end of phase 1 with Phase1 thread
//        and is executed *before* any HalpGetMceLog() calls could be done.
//
//  HAL_CMC_INFO.DriverInfo
//  HAL_CMC_INFO.Dpc
//      - is updated by HalpCmcRegisterlDriver() under CMC Mutex protection.
//        FIXFIX - 09/21/2000 - This initialization has a small window of where a CMC interrupt
//                              could occur and the memory change is not committed. ToBeFixed.
//      - Loaded as CMCI_LEVEL and branched to.
//      - Read at passive level as a flag under CMC Mutex protection.
//
//  HAL_CMC_INFO.DriverLogs
//      - This entire structure is initialized and updated at passive level under CMC Mutex
//        protection with the exception of KernelLogs.Tag initialized by HalpInitializeCmcInfo(),
//        called by HalpMcaInit(). HalpMcaInit() is called at end of phase 1 with Phase1 thread
//        and is executed *before* any HalpGetMceLog() calls could be done.
//

typedef struct _HALP_CMC_INFO {
    FAST_MUTEX          Mutex;                // non-recursive Mutex for low irql operations.
    HALP_MCELOGS_STATS  Stats;                // Information about log collection and interrupts.
    PVOID               KernelToken;          // Kernel identification.
    KERNEL_CMC_DELIVERY KernelDelivery;       // Kernel callback called at CMCI_LEVEL.
    HALP_MCELOGS_HEADER KernelLogs;           // Saved logs for Kernel queries.
    CMC_DRIVER_INFO     DriverInfo;           // Info about OEM CMC registered driver
    KDPC                DriverDpc;            // DPC object for OEM CMC driver.
    HALP_MCELOGS_HEADER DriverLogs;           // Saved logs for OEM CMC driver.
} HALP_CMC_INFO, *PHALP_CMC_INFO;

extern HALP_CMC_INFO HalpCmcInfo;

#define HalpInitializeCmcMutex()  ExInitializeFastMutex( &HalpCmcInfo.Mutex )
#define HalpInitializeCmcInfo()   \
{ \
    HalpInitializeCmcMutex();                \
    HalpCmcInfo.KernelLogs.Tag = 'KcmC';     \
    HalpCmcInfo.KernelLogs.Logs.Next = NULL; \
    HalpCmcInfo.DriverLogs.Tag = 'DcmC';     \
    HalpCmcInfo.DriverLogs.Logs.Next = NULL; \
}

#define HalpAcquireCmcMutex()     ExAcquireFastMutex( &HalpCmcInfo.Mutex )
#define HalpReleaseCmcMutex()     ExReleaseFastMutex( &HalpCmcInfo.Mutex )

//
// IA64 CPE
//

//
// HALP_CPE_DEFAULT_POLLING_INTERVAL
// HALP_CPE_MINIMUM_POLLING_INTERVAL
//
// If these should be exposed to WMI or OEM CPE driver, we will expose them in ntos\inc\hal.h
//

#define HALP_CPE_DEFAULT_POLLING_INTERVAL ((ULONG)60)
#define HALP_CPE_MINIMUM_POLLING_INTERVAL ((ULONG)15)

//
// HALP_CPE_MAX_INTERRUPT_SOURCES defines the size of SAPIC CPE related data structures.
//
// TEMPORARY - The CPE Interrupt model based data structures should be allocated while
//             passing through the ACPI platform interrupt source entries.
//             This will eliminate this static limitation in the number of CPEs.
//

#define HALP_CPE_MAX_INTERRUPT_SOURCES  16

//
// IA64 CPE Info Structure
//
//      to keep track of CPE features available on installed hardware
//
// Implementation Notes - Thierry 09/15/2000.
//
//  - HAL_CMC_INFO and HAL_CPE_INFO have identical definitions at this time.
//    The merging of the code and data definitions was considered and even implemented.
//    However, because of the lack of testing with these FW/SAL features, I decided to
//    keep them separate. After further testing of the IA64 CMC/CPE features, we might
//    decide to merge them or not...
//
// MP notes 08/2000:
//
//  As specified above, the MP notes are similar to the HALP_CMC_INFO structure MP notes.
//  With the exception of:
//
//  HAL_CPE_INFO.Stats.PollingInterval
//      - is updated by HalpCPEEnable() on BSP. Not modified later.
//      - does not require any MP protection for further read accesses.
//

typedef struct _HALP_CPE_INFO {
    FAST_MUTEX          Mutex;                // non-recursive Mutex for low irql operations.
    HALP_MCELOGS_STATS  Stats;                // Information about log collection and interrupts.
    PVOID               KernelToken;          // Kernel identification.
    KERNEL_CPE_DELIVERY KernelDelivery;       // Kernel callback called at CPEI_LEVEL.
    HALP_MCELOGS_HEADER KernelLogs;           // Saved logs for Kernel queries.
    CPE_DRIVER_INFO     DriverInfo;           // Info about OEM CPE registered driver
    KDPC                DriverDpc;            // DPC object for OEM CPE driver.
    HALP_MCELOGS_HEADER DriverLogs;           // Saved logs for OEM CPE driver.
} HALP_CPE_INFO, *PHALP_CPE_INFO;

extern HALP_CPE_INFO HalpCpeInfo;

#define HalpInitializeCpeMutex()  ExInitializeFastMutex( &HalpCpeInfo.Mutex )
#define HalpInitializeCpeInfo()   \
{ \
    HalpInitializeCpeMutex();                \
    HalpCpeInfo.KernelLogs.Tag = 'KepC';     \
    HalpCpeInfo.KernelLogs.Logs.Next = NULL; \
    HalpCpeInfo.DriverLogs.Tag = 'DepC';     \
    HalpCpeInfo.DriverLogs.Logs.Next = NULL; \
}

#define HalpAcquireCpeMutex()     ExAcquireFastMutex( &HalpCpeInfo.Mutex )
#define HalpReleaseCpeMutex()     ExReleaseFastMutex( &HalpCpeInfo.Mutex )

__inline
ULONG
HalpGetMaxCpeLogSizeProtected(
    VOID
    )
{
    ULONG maxSize;
    HalpAcquireCpeMutex();
    maxSize = HalpCpeInfo.Stats.MaxLogSize;
    HalpReleaseCpeMutex();
    return( maxSize );
} // HalpGetMaxCpeLogSizeProtected()

__inline
ULONG
HalpGetMaxCpeLogSizeAndPollingIntervalProtected(
    PULONG PollingInterval
    )
{
    ULONG maxSize;
    HalpAcquireCpeMutex();
    maxSize = HalpCpeInfo.Stats.MaxLogSize;
    *PollingInterval = HalpCpeInfo.Stats.PollingInterval;
    HalpReleaseCpeMutex();
    return( maxSize );
} // HalpGetMaxCpeLogSizeAndPollingIntervalProtected()

//
// IA64 SAL_MC_SET_PARAMS.time_out default value.
//

#define HALP_DEFAULT_MC_RENDEZ_TIMEOUT 1000

//
// IA64 bugcheck MACHINE_CHECK_EXCEPTION parameters
//
// arg0: MACHINE_EXCEPTION
// arg1: HAL_BUGCHECK_MCE_TYPE
// arg2: mcaLog
// arg3: mcaAllocatedLogSize
// arg4: salStatus
//

typedef enum _HAL_BUGCHECK_MCE_TYPE  {
    HAL_BUGCHECK_MCA_ASSERT           = 1,
    HAL_BUGCHECK_MCA_GET_STATEINFO    = 2,
    HAL_BUGCHECK_MCA_CLEAR_STATEINFO  = 3,
    HAL_BUGCHECK_MCA_FATAL            = 4,
    HAL_BUGCHECK_MCA_MAX              = 10,
    HAL_BUGCHECK_INIT_ASSERT          = 11,
    HAL_BUGCHECK_INIT_GET_STATEINFO   = 12,
    HAL_BUGCHECK_INIT_CLEAR_STATEINFO = 13,
    HAL_BUGCHECK_INIT_FATAL           = 14,
    HAL_BUGCHECK_INIT_MAX             = 20,
} HAL_BUGCHECK_MCE_TYPE;

//
// PnP stuff
//

#define HAL_BUS_INTERFACE_STD_VERSION   1
#define HAL_IRQ_TRANSLATOR_VERSION      0
#define HAL_MEMIO_TRANSLATOR_VERSION    1
#define HAL_PORT_RANGE_INTERFACE_VERSION 0


VOID
HalTranslatorReference(
    PVOID Context
    );

VOID
HalTranslatorDereference(
    PVOID Context
    );

NTSTATUS
HalIrqTranslateResources(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
);

NTSTATUS
HalIrqTranslateResourcesRoot(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    );

NTSTATUS
HalIrqTranslateResourceRequirementsRoot(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    );

NTSTATUS
HalIrqTranslateResourceRequirementsIsa(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    );

NTSTATUS
HalIrqTranslateResourcesIsa(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    );

NTSTATUS
HalpTransMemIoResourceRequirement(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    );

NTSTATUS
HalpTransMemIoResource(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    );


ULONG
HalpGetIsaIrqState(
    ULONG   Vector
    );


//
// HAL port range services.
//

NTSTATUS
HalpQueryAllocatePortRange(
    IN BOOLEAN IsSparse,
    IN BOOLEAN PrimaryIsMmio,
    IN PVOID VirtBaseAddr OPTIONAL,
    IN PHYSICAL_ADDRESS PhysBaseAddr,  // Only valid if PrimaryIsMmio = TRUE
    IN ULONG Length,                   // Only valid if PrimaryIsMmio = TRUE
    OUT PUSHORT NewRangeId
    );

VOID
HalpFreePortRange(
    IN USHORT RangeId
    );


//
// Definition for IA64 HalpVectorToINTI
//

#define VECTOR  0xFF;
#define LEVEL   32;
extern ULONG HalpVectorToINTI[];
extern UCHAR HalpVectorToIRQL[];

VOID
HalpEnableNMI (
    VOID
    );

ULONG
HalpInti2BusInterruptLevel(
    ULONG   Inti
    );

ULONG
HalpINTItoVector(
    ULONG   Inti
    );

VOID
HalpSetINTItoVector(
    ULONG   Inti,
    ULONG   Vector
    );

VOID
HalpSetRedirEntry (
    IN ULONG InterruptInput,
    IN ULONG Entry,
    IN USHORT ThisCpuApicID
    );

VOID
HalpGetRedirEntry (
    IN ULONG InterruptInput,
    IN PULONG Entry,
    IN PULONG Destination
    );

VOID
HalpDisableRedirEntry(
    IN ULONG InterruptInput
    );

//
// Definition for IA64 complete
//

//
// ACPI specific stuff
//

//
// from detect\i386\acpibios.h
//

typedef struct _ACPI_BIOS_INSTALLATION_CHECK {
    UCHAR Signature[8];             // "RSD PTR" (ascii)
    UCHAR Checksum;
    UCHAR OemId[6];                 // An OEM-supplied string
    UCHAR reserved;                 // must be 0
    ULONG RsdtAddress;              // 32-bit physical address of RSDT
} ACPI_BIOS_INSTALLATION_CHECK, *PACPI_BIOS_INSTALLATION_CHECK;

NTSTATUS
HalpAcpiFindRsdtPhase0(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

NTSTATUS
HalpSetupAcpiPhase0(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

ULONG
HalpAcpiNumProcessors(
    VOID
    );

VOID
HaliHaltSystem(
    VOID
    );

VOID
HalpCheckPowerButton(
    VOID
    );

NTSTATUS
HalpRegisterHibernate(
    VOID
    );


VOID
HalpSleepS5(
    VOID
    );

VOID
HalProcessorThrottle (
    IN UCHAR Throttle
    );

VOID
HalpSaveDmaControllerState(
    VOID
    );

VOID
HalpSaveTimerState(
    VOID
    );

VOID
HalpSetAcpiEdgeLevelRegister(
    VOID
    );

VOID
HalpRestoreDmaControllerState(
    VOID
    );

VOID
HalpRestoreTimerState(
    VOID
    );

NTSTATUS
HalacpiGetInterruptTranslator(
    IN INTERFACE_TYPE ParentInterfaceType,
    IN ULONG ParentBusNumber,
    IN INTERFACE_TYPE BridgeInterfaceType,
    IN USHORT Size,
    IN USHORT Version,
    OUT PTRANSLATOR_INTERFACE Translator,
    OUT PULONG BridgeBusNumber
    );

VOID
HalpInitNonBusHandler (
    VOID
    );

VOID
HalpPowerStateCallback(
    IN PVOID CallbackContext,
    IN PVOID Argument1,
    IN PVOID Argument2
    );


VOID
HalpSetMaxLegacyPciBusNumber (
    IN ULONG BusNumber
    );


#ifdef notyet

typedef struct {
    UCHAR           Dma1ExtendedModePort;
    UCHAR           Dma2ExtendedModePort;
    DMA1_CONTROL    Dma1Control;
    DMA2_CONTROL    Dma2Control;
} DMA_CONTEXT, *PDMA_CONTEXT;

typedef struct {
    UCHAR   nothing;
} TIMER_CONTEXT, *PTIMER_CONTEXT;

typedef struct {
    PIC_CONTEXT     PicState;
    DMA_CONTEXT     DmaState;
} MOTHERBOARD_CONTEXT, *PMOTHERBOARD_CONTEXT;

extern MOTHERBOARD_CONTEXT  HalpMotherboardState;
extern UCHAR                HalpDmaChannelModes[];
extern PVOID                HalpSleepPageLock;
extern UCHAR                HalpDmaChannelMasks[];
extern BOOLEAN              HalpOwnedDisplayBeforeSleep;

#endif // notyet

//
// External Interrupt Control Registers macros.
//

#define HalpReadLID()       __getReg(CV_IA64_SaLID)
#define HalpClearLID()      __setReg(CV_IA64_SaLID, (unsigned __int64)0)
#define HalpReadTPR()       __getReg(CV_IA64_SaTPR)

//
// ITM/ITC macros
//

#define HalpReadITC()       __getReg(CV_IA64_ApITC)
#define HalpReadITM()       __getReg(CV_IA64_ApITM)
#define HalpWriteITC(Value) __setReg(CV_IA64_ApITC, Value)
#define HalpWriteITM(Value) __setReg(CV_IA64_ApITM, Value)

//
// set itv control register
//

#define HalpWriteITVector(Vector)   __setReg(CV_IA64_SaITV, Vector)

//
// I/O Port space
//
// IoSpaceSize = 0x16 for 2 power 0x16 is 4Meg space size (ports 0x0000 - 0x1000)
//

#define IO_SPACE_SIZE 0x1A

//
// Present bit       =    1B to wire the space.
// Memory Attributes = 100B for UC Memory type
// Accessed Bit      =    1B to "enable" access without faulting.
// Dirty Bit         =    1B to "enable" write without faulting.
// Privilege Level   =   00B for kernel accesses
// Access Right      =  010B for read/write accesses
// Exception Deferral=    1B for Exception Deferral.
//                               Exceptions are deferred
//                           for speculative loads to pages with
//                               non-spec. mem. attributes anyway.
//
// Protection Key    =    0  for kernel mode
//

#define IO_SPACE_ATTRIBUTE TR_VALUE(1, 0, 3, 0, 1, 1, 4, 1)

#define HAL_READ_REGISTER_UCHAR(x)  \
    (__mf(), *(volatile UCHAR * const)(x))

#define WRITE_REGISTER_UCHAR(x, y) {    \
    *(volatile UCHAR * const)(x) = y;   \
    KeFlushWriteBuffer();               \
}


//
// Firmware interface
//

VOID HalpInitSalPalNonBsp();
VOID InternalTestSal();

ARC_STATUS
HalGetEnvironmentVariable (
    IN PCHAR Variable,
    IN USHORT Length,
    OUT PCHAR Buffer
    );

ARC_STATUS
HalSetEnvironmentVariable (
    IN PCHAR Variable,
    IN PCHAR Buffer
    );

VOID
HalpSetInitProfileRate (
    VOID
    );

VOID
HalpInitializeProfiling (
    ULONG Number
    );

NTSTATUS
HalpProfileSourceInformation (
    OUT PVOID   Buffer,
    IN  ULONG   BufferLength,
    OUT PULONG  ReturnedLength
    );

NTSTATUS
HalSetProfileSourceInterval(
    IN KPROFILE_SOURCE  ProfileSource,
    IN OUT ULONG_PTR   *Interval
    );

//
// Performance Monitor Registers
//
// FIXFIX - Thierry 01/2000.
//
// The following functions are defined until the compiler supports
// the intrinsics __setReg() and __getReg() for the CV_IA64_PFCx,
// CV_IA64_PFDx and CV_IA64_SaPMV registers.
// Anyway, because of the micro-architecture differences,
// and because the implementation of intrinsics cannot handle all the
// micro-architecture differences, it seems useful to keep these
// functions around.
//

#if 0

#define HalpReadPerfMonVectorReg()      __getReg(CV_IA64_SaPMV)

#define HalpReadPerfMonCnfgReg0()       __getReg(CV_IA64_PFC0)
#define HalpReadPerfMonCnfgReg4()       __getReg(CV_IA64_PFC4)

#define HalpReadPerfMonDataReg0()       __getReg(CV_IA64_PFD0)
#define HalpReadPerfMonDataReg4()       __getReg(CV_IA64_PFD4)

#define HalpWritePerfMonDataReg0(Value) __setReg(CV_IA64_PFD0, Value)
#define HalpWritePerfMonDataReg4(Value) __setReg(CV_IA64_PFD4, Value)

#define HalpWritePerfMonCnfgReg0(Value) __setReg(CV_IA64_PFC0, Value)
#define HalpWritePerfMonCnfgReg4(Value) __setReg(CV_IA64_PFC4, Value)

#define HalpWritePerfMonVectorReg(Value) __setReg(CV_IA64_SaPMV,Value)

#else  // !0

VOID
HalpWritePerfMonVectorReg(
   ULONGLONG Value
   );

ULONGLONG
HalpReadPerfMonVectorReg(
   VOID
   );

VOID
HalpWritePerfMonCnfgReg(
   ULONG      Register,
   ULONGLONG  Value
   );

#define HalpWritePerfMonCnfgReg0(_Value) HalpWritePerfMonCnfgReg(0UL, _Value)
#define HalpWritePerfMonCnfgReg4(_Value) HalpWritePerfMonCnfgReg(4UL, _Value)

ULONGLONG
HalpReadPerfMonCnfgReg(
   ULONG      Register
   );

#define HalpReadPerfMonCnfgReg0() HalpReadPerfMonCnfgReg(0UL)
#define HalpReadPerfMonCnfgReg4() HalpReadPerfMonCnfgReg(4UL)

VOID
HalpWritePerfMonDataReg(
   ULONG      Register,
   ULONGLONG  Value
   );

#define HalpWritePerfMonDataReg0(_Value) HalpWritePerfMonDataReg(0UL, _Value)
#define HalpWritePerfMonDataReg4(_Value) HalpWritePerfMonDataReg(4UL, _Value)

ULONGLONG
HalpReadPerfMonDataReg(
   ULONG Register
   );

#define HalpReadPerfMonDataReg0() HalpReadPerfMonDataReg(0UL)
#define HalpReadPerfMonDataReg4() HalpReadPerfMonDataReg(4UL)

#endif // !0

EFI_STATUS
HalpCallEfi(
    IN ULONGLONG FunctionId,
    IN ULONGLONG Arg1,
    IN ULONGLONG Arg2,
    IN ULONGLONG Arg3,
    IN ULONGLONG Arg4,
    IN ULONGLONG Arg5,
    IN ULONGLONG Arg6,
    IN ULONGLONG Arg7,
    IN ULONGLONG Arg8
    );

EFI_STATUS
HalpCallEfiPhysical (
    IN ULONGLONG Arg1,
    IN ULONGLONG Arg2,
    IN ULONGLONG Arg3,
    IN ULONGLONG Arg4,
    IN ULONGLONG Arg5,
    IN ULONGLONG Arg6,
    IN ULONGLONG EP,
    IN ULONGLONG GP
    );

ULONG
HalpReadGenAddr(
    IN  PGEN_ADDR   GenAddr
    );

VOID
HalpWriteGenAddr(
    IN  PGEN_ADDR   GenAddr,
    IN  ULONG       Value
    );

USHORT
HalpReadAcpiRegister(
  IN ACPI_REG_TYPE AcpiReg,
  IN ULONG         Register
  );

VOID
HalpWriteAcpiRegister(
  IN ACPI_REG_TYPE AcpiReg,
  IN ULONG         Register,
  IN USHORT        Value
  );

//
// Debugging support functions
//

VOID
HalpRegisterPciDebuggingDeviceInfo(
    VOID
    );

//
// Functions related to platform properties as exposed by the IPPT
// table.
//

BOOLEAN
HalpIsInternalInterruptVector(
    IN ULONG SystemVector
    );

NTSTATUS
HalpReserveCrossPartitionInterruptVector (
    OUT PULONG Vector,
    OUT PKIRQL Irql,
    IN OUT PKAFFINITY Affinity,
    OUT PUCHAR HardwareVector
    );

NTSTATUS
HalpSendCrossPartitionIpi(
    IN USHORT ProcessorID,
    IN UCHAR  HardwareVector
    );

NTSTATUS
HalpGetCrossPartitionIpiInterface(
    OUT HAL_CROSS_PARTITION_IPI_INTERFACE * IpiInterface
    );

NTSTATUS
HalpGetPlatformProperties(
    OUT PULONG Properties
    );

#endif // _HALP_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\i64bios.c ===
/*++

Copyright (c) 1996  Intel Corporation
Copyright (c) 1994  Microsoft Corporation

Module Name:

  i64bios.c  copied from hali64\x86bios.c

Abstract:


    This module implements the platform specific interface between a device
    driver and the execution of x86 ROM bios code for the device.

Author:

    William K. Cheung (wcheung) 20-Mar-1996

    based on the version by David N. Cutler (davec) 17-Jun-1994

Environment:

    Kernel mode only.

Revision History:
    Bernard Lint, M.Jayakumar November 1998

--*/

#include "halp.h"
#include "emulate.h"


#define LOW_MEM_SEGMET 0

#define LOW_MEM_OFFSET 0

#define SIZE_OF_VECTOR_TABLE 0x400

#define SIZE_OF_BIOS_DATA_AREA 0x400

extern XM_STATUS x86BiosExecuteInterrupt (
    IN UCHAR Number,
    IN OUT PXM86_CONTEXT Context,
    IN PVOID BiosIoSpace OPTIONAL,
    IN PVOID BiosIoMemory OPTIONAL
    );

extern PVOID x86BiosTranslateAddress (
    IN USHORT Segment,
    IN USHORT Offset
    );

//
// Initialize Default X86 bios spaces
//


#define NUMBER_X86_PAGES (0x100000 / PAGE_SIZE)      // map through 0xfffff

PVOID HalpIoControlBase = NULL;
PVOID HalpIoMemoryBase =  NULL;


//
// Define global data.
//



ULONG HalpX86BiosInitialized = FALSE;
ULONG HalpEnableInt10Calls = FALSE;


VOID
HalpInitIoMemoryBase(
    VOID
    )

/*++

Routine Description:

Arguements:

Return Value:

--*/
{

    PHYSICAL_ADDRESS COMPATIBLE_PCI_PHYSICAL_BASE_ADDRESS = { 0x0};
    HalpIoMemoryBase = (PUCHAR)HalpMapPhysicalMemory (
        COMPATIBLE_PCI_PHYSICAL_BASE_ADDRESS,
        (ULONG) NUMBER_X86_PAGES,
        (MEMORY_CACHING_TYPE)MmNonCached
        );
    ASSERT(HalpIoMemoryBase);

}


ULONG
HalpSetCmosData (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )

/*++

Routine Description:

Arguements:

Return Value:

--*/

{
    return 0;
}


ULONG
HalpGetCmosData (
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    )

/*++

Routine Description:

Arguements:

Return Value:

--*/


{
    return 0;
}


VOID
HalpAcquireCmosSpinLock (
    VOID
        )

/*++

Routine Description:

Arguements:

Return Value:

--*/


{
    return;
}


VOID
HalpReleaseCmosSpinLock (
    VOID
    )

/*++

Routine Description:

Arguements:

Return Value:

--*/

{
    return ;
}


HAL_DISPLAY_BIOS_INFORMATION
HalpGetDisplayBiosInformation (
    VOID
    )

/*++

Routine Description:


Arguements:


Return Value:

--*/




{
    return 8;
}


VOID
HalpInitializeCmos (
    VOID
    )

/*++

Routine Description:

Arguements:

Return Value:

--*/


{
    return ;
}


VOID
HalpReadCmosTime (
    PTIME_FIELDS TimeFields
    )

/*++

Routine Description:

Arguements:

Return Value:

--*/

{
    return ;
}

VOID
HalpWriteCmosTime (
    PTIME_FIELDS TimeFields
    )

/*++

Routine Description:

Arguements:

Return Value:

--*/


{
    return;
}



VOID
HalpBiosDisplayReset (
    VOID
    )

/*++

Routine Description:


Arguements:


Return Value:

--*/

{
    //
    // Make an int10 call to set the display into 640x480 16 color mode
    //
    // mov ax, 12h
    // int 10h
    //

    ULONG Eax = 0x12;
    ULONG Exx = 0x00;

    HalCallBios(0x10,
                &Eax,
                &Exx,
                &Exx,
                &Exx,
                &Exx,
                &Exx,
                &Exx);

    return;
}


BOOLEAN
HalCallBios (
    IN ULONG BiosCommand,
    IN OUT PULONG Eax,
    IN OUT PULONG Ebx,
    IN OUT PULONG Ecx,
    IN OUT PULONG Edx,
    IN OUT PULONG Esi,
    IN OUT PULONG Edi,
    IN OUT PULONG Ebp
    )

/*++

Routine Description:

    This function provides the platform specific interface between a device
    driver and the execution of the x86 ROM bios code for the specified ROM
    bios command.

Arguments:

    BiosCommand - Supplies the ROM bios command to be emulated.

    Eax to Ebp - Supplies the x86 emulation context.

Return Value:

    A value of TRUE is returned if the specified function is executed.
    Otherwise, a value of FALSE is returned.

--*/

{

    XM86_CONTEXT Context;

    HalDebugPrint(( HAL_INFO, "HAL: HalCallBios - Cmd = 0x%x, eax = 0x%p\n", BiosCommand, Eax ));
    //
    // If the x86 BIOS Emulator has not been initialized, then return FALSE.
    //

    if (HalpX86BiosInitialized == FALSE) {
        return FALSE;
    }

    //
    // If the Adapter BIOS initialization failed and an Int10 command is
    // specified, then return FALSE.
    //

    if ((BiosCommand == 0x10) && (HalpEnableInt10Calls == FALSE)) {
        return FALSE;
    }

    //
    // Copy the x86 bios context and emulate the specified command.
    //

    Context.Eax = *Eax;
    Context.Ebx = *Ebx;
    Context.Ecx = *Ecx;
    Context.Edx = *Edx;
    Context.Esi = *Esi;
    Context.Edi = *Edi;
    Context.Ebp = *Ebp;


    if (x86BiosExecuteInterrupt((UCHAR)BiosCommand,
        &Context,
        (PVOID)HalpIoControlBase,
        (PVOID)HalpIoMemoryBase) != XM_SUCCESS) {

        HalDebugPrint(( HAL_ERROR, "HAL: HalCallBios - ERROR in Cmd = 0x%x\n", BiosCommand ));
        return FALSE;

    }

    //
    // Copy the x86 bios context and return TRUE.
    //

    *Eax = Context.Eax;
    *Ebx = Context.Ebx;
    *Ecx = Context.Ecx;
    *Edx = Context.Edx;
    *Esi = Context.Esi;
    *Edi = Context.Edi;
    *Ebp = Context.Ebp;
    return TRUE;
}

VOID
HalpInitializeX86Int10Call(
    VOID
    )

/*++

Routine Description:

    This function initializes x86 bios emulator, display data area and
    interrupt vector area.


Arguments:

    None.

Return Value:

    None.

--*/

{
    XM86_CONTEXT State;
    PXM86_CONTEXT Context;
    PULONG x86BiosLowMemoryPtr, PhysicalMemoryPtr;

    //
    // Initialize the x86 bios emulator.
    //

    x86BiosInitializeBios(HalpIoControlBase, HalpIoMemoryBase);


    x86BiosLowMemoryPtr = (PULONG)(x86BiosTranslateAddress(LOW_MEM_SEGMET, LOW_MEM_OFFSET));
    PhysicalMemoryPtr   = (PULONG) HalpIoMemoryBase;

    //
    // Copy the VECTOR TABLE from 0 to 2k. This is because we are not executing
    // the initialization of Adapter since SAL takes care of it. However, the
    // emulation memory needs to be updated from the interrupt vector and BIOS
    // data area.
    //

    RtlCopyMemory(x86BiosLowMemoryPtr,
                  PhysicalMemoryPtr,
                  (SIZE_OF_VECTOR_TABLE+SIZE_OF_BIOS_DATA_AREA)
                  );


    HalpX86BiosInitialized = TRUE;
    HalpEnableInt10Calls = TRUE;
    return;
}


VOID
HalpResetX86DisplayAdapter(
    VOID
    )

/*++

Routine Description:

    This function resets a display adapter using the x86 bios emulator.

Arguments:

    None.

Return Value:

    None.

--*/

{
    ULONG Eax;
    ULONG Ebx;
    ULONG Ecx;
    ULONG Edx;
    ULONG Esi;
    ULONG Edi;
    ULONG Ebp;

    //
    // Initialize the x86 bios context and make the INT 10 call to initialize
    // the display adapter to 80x25 color text mode.
    //

    Eax = 0x0003;  // Function 0, Mode 3
    Ebx = 0;
    Ecx = 0;
    Edx = 0;
    Esi = 0;
    Edi = 0;
    Ebp = 0;

    HalCallBios(0x10,
        &Eax,
        &Ebx,
        &Ecx,
        &Edx,
        &Esi,
        &Edi,
        &Ebp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\gbacpi.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    GbAcpi.c

Abstract:

    Temporary support for Acpi tables in Gambit simulator environment. This
    file should be removed when Gambit/Vpc provides Acpi tables.

    The Acpi tables are created and a pointer to the RSDT is put into the
    Loader block.

Author:

    Todd Kjos (HP) (v-tkjos) 1-Jun-1998

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "acpitabl.h"
#include "xxacpi.h"

NTSTATUS
HalpOpenRegistryKey(
    OUT PHANDLE Handle,
    IN HANDLE BaseHandle OPTIONAL,
    IN PUNICODE_STRING KeyName,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN Create
    );

BOOLEAN
HalpFakeAcpiRegisters(
    VOID
    );

#define PMIO 0x8000
#define PM1a_EVT_BLK (PMIO+0x0)
#define PM1a_STS     PM1a_EVT_BLK
#define PM1a_EN      (PM1a_STS+2)

#define PM1a_CNT_BLK (PMIO+0x4)
#define PM1a_CNTa    PM1a_CNT_BLK

#define PM_TMR       (PMIO+0x8)
#define GP0          (PMIO+0xc)
#define GP0_STS_0    GP0
#define GP0_STS_1    (GP0+1)
#define GP0_EN_0     (GP0+2)
#define GP0_EN_1     (GP0+3)

PCHAR HalpFakeAcpiRegisterFadtIds[][2] =
{
    {"INTEL",       "LIONEMU"},
    {"INTEL",       "SR460AC"},
    {"INTEL",       "AL460GX"},
    {NULL, NULL}
};            

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, HalpFakeAcpiRegisters)
#endif

USHORT AcpiRegPM1a_STS  = 0;
USHORT AcpiRegPM1a_EN   = 0;
USHORT AcpiRegPM1_CNTa  = 1;  // SCI_EN
ULONG  AcpiRegPM_TMR    = 0;
UCHAR  AcpiRegGP0_STS_0 = 0;
UCHAR  AcpiRegGP0_STS_1 = 0;
UCHAR  AcpiRegGP0_EN_0  = 0;
UCHAR  AcpiRegGP0_EN_1  = 0;
UCHAR  AcpiRegNeedToImplement = 0;

BOOLEAN GambitAcpiDebug = FALSE;

//#define TKPRINT(X,Y) if (GambitAcpiDebug) HalDebugPrint(( HAL_INFO, "%s of %s (%#x)\n",X,# Y,Y ))
#define TKPRINT(x, y)

BOOLEAN
GbAcpiReadFakePort(
    UINT_PTR Port,
    PVOID Data,
    ULONG Length
   )
{
    if (Port < PMIO || Port > PMIO+0xfff) return(FALSE);

   switch (Port) {
   case PM1a_STS:
      ASSERT(Length == 2);
      *(USHORT UNALIGNED *)Data = AcpiRegPM1a_STS;
      TKPRINT("Read",AcpiRegPM1a_STS);
      return TRUE;
   case PM1a_EN:
      ASSERT(Length == 2);
      *(USHORT UNALIGNED *)Data = AcpiRegPM1a_EN;
      TKPRINT("Read",AcpiRegPM1a_EN);
      return TRUE;
   case PM1a_CNTa:
      ASSERT(Length == 2);
      *(USHORT UNALIGNED *)Data = AcpiRegPM1_CNTa;
      TKPRINT("Read",AcpiRegPM1_CNTa);
      return TRUE;
   case PM_TMR:
      ASSERT(Length == 4);
      *(ULONG UNALIGNED *)Data = AcpiRegPM_TMR;
      TKPRINT("Read",AcpiRegPM_TMR);
      return TRUE;
   case GP0_STS_0:
      ASSERT(Length == 1);
      *(UCHAR UNALIGNED *)Data = AcpiRegGP0_STS_0;
      TKPRINT("Read",AcpiRegGP0_STS_0);
      return TRUE;
   case GP0_STS_1:
      ASSERT(Length == 1);
      *(UCHAR UNALIGNED *)Data = AcpiRegGP0_STS_1;
      TKPRINT("Read",AcpiRegGP0_STS_1);
      return TRUE;
   case GP0_EN_0:
      ASSERT(Length == 1);
      *(UCHAR UNALIGNED *)Data = AcpiRegGP0_EN_0;
      TKPRINT("Read",AcpiRegGP0_EN_0);
      return TRUE;
   case GP0_EN_1:
      ASSERT(Length == 1);
      *(UCHAR UNALIGNED *)Data = AcpiRegGP0_EN_1;
      TKPRINT("Read",AcpiRegGP0_EN_1);
      return TRUE;
        case 0x802b:
               ASSERT(Length == 1);
               *(UCHAR UNALIGNED *)Data = AcpiRegNeedToImplement;
               TKPRINT("Read",AcpiRegNeedToImplement);
               return TRUE;
   default:
      ;
//      HalDebugPrint(( HAL_ERROR, "HAL: AcpiSimulation - Unknown Acpi register: %#Ix\n", Port ));
//      ASSERT(0);
   }
   return(FALSE);
}

BOOLEAN
GbAcpiWriteFakePort(
    UINT_PTR Port,
    PVOID Value,
    ULONG Length
   )
{
   if (Port < PMIO || Port > PMIO+0xfff) return(FALSE);

   switch (Port) {
   case PM1a_STS:
      ASSERT(Length == 2);
      AcpiRegPM1a_STS &= ~(*(USHORT UNALIGNED *)Value);
      TKPRINT("Write",AcpiRegPM1a_STS);
      return TRUE;
   case PM1a_EN:
      ASSERT(Length == 2);
      AcpiRegPM1a_EN = *((USHORT UNALIGNED *)Value);
      TKPRINT("Write",AcpiRegPM1a_EN);
      return TRUE;
   case PM1a_CNTa:
      ASSERT(Length == 2);
      AcpiRegPM1_CNTa = *((USHORT UNALIGNED *)Value);
      TKPRINT("Write",AcpiRegPM1_CNTa);
      return TRUE;
   case PM_TMR:
      ASSERT(Length == 4);
      AcpiRegPM_TMR = *((ULONG UNALIGNED *)Value);
      TKPRINT("Write",AcpiRegPM_TMR);
      return TRUE;
   case GP0_STS_0:
      ASSERT(Length == 1);
      AcpiRegGP0_STS_0 &= ~(*(UCHAR UNALIGNED *)Value);
      TKPRINT("Write",AcpiRegGP0_STS_0);
      return TRUE;
   case GP0_STS_1:
      ASSERT(Length == 1);
      AcpiRegGP0_STS_1 &= ~(*(UCHAR UNALIGNED *)Value);
      TKPRINT("Write",AcpiRegGP0_STS_1);
      return TRUE;
   case GP0_EN_0:
      ASSERT(Length == 1);
      AcpiRegGP0_EN_0 = *((UCHAR UNALIGNED *)Value);
      TKPRINT("Write",AcpiRegGP0_EN_0);
      return TRUE;
   case GP0_EN_1:
      ASSERT(Length == 1);
      AcpiRegGP0_EN_1 = *((UCHAR UNALIGNED *)Value);
      TKPRINT("Write",AcpiRegGP0_EN_1);
      return TRUE;
   default:
      ;
//      HalDebugPrint(( HAL_ERROR, "HAL: AcpiSimulation - Unknown Acpi register: %#Ix\n",Port ));
//      ASSERT(0);
   }
   return(FALSE);
}

USHORT
HalpReadAcpiRegister(
  IN ACPI_REG_TYPE AcpiReg,
  IN ULONG         Register
  )
{
    USHORT  value;
    BOOLEAN retVal = FALSE;
    
    switch (AcpiReg) {
    case PM1a_ENABLE:

        retVal = GbAcpiReadFakePort(PM1a_EN, &value, 2);
        break;
        
    case PM1a_STATUS:

        retVal = GbAcpiReadFakePort(PM1a_STS, &value, 2);
        break;
        
    case PM1a_CONTROL:

        retVal = GbAcpiReadFakePort(PM1a_CNTa, &value, 2);
        break;
        
    case GP_STATUS:

        retVal = GbAcpiReadFakePort(GP0_STS_0, &value, 1);
        if (!retVal) break;
        retVal = GbAcpiReadFakePort(GP0_STS_1, ((PUCHAR)&value) + 1, 1);
        break;
        
    case GP_ENABLE:

        retVal = GbAcpiReadFakePort(GP0_EN_0, &value, 1);
        if (!retVal) break;
        retVal = GbAcpiReadFakePort(GP0_EN_1, ((PUCHAR)&value) + 1, 1);
        break;
        
    }
    
    if (retVal) {

        return value;

    } else {
        
        return 0xffff;
    }
}

VOID
HalpWriteAcpiRegister(
  IN ACPI_REG_TYPE AcpiReg,
  IN ULONG         Register,
  IN USHORT        Value
  )
{
    BOOLEAN retVal = FALSE;
    
    switch (AcpiReg) {
    case PM1a_ENABLE:

        retVal = GbAcpiWriteFakePort(PM1a_EN, &Value, 2);
        break;
        
    case PM1a_STATUS:

        retVal = GbAcpiWriteFakePort(PM1a_STS, &Value, 2);
        break;
        
    case PM1a_CONTROL:

        retVal = GbAcpiWriteFakePort(PM1a_CNTa, &Value, 2);
        break;
        
    case GP_STATUS:

        retVal = GbAcpiWriteFakePort(GP0_STS_0, &Value, 1);
        if (!retVal) break;
        retVal = GbAcpiWriteFakePort(GP0_STS_1, ((PUCHAR)&Value) + 1, 1);
        break;
        
    case GP_ENABLE:

        switch (Register) {
        case 0:
            retVal = GbAcpiWriteFakePort(GP0_EN_0, &Value, 1);
            break;
        case 1:
            retVal = GbAcpiWriteFakePort(GP0_EN_1, ((PUCHAR)&Value) + 1, 1);
            break;
        }
    }
}

BOOLEAN
HalpFakeAcpiRegisters(
    VOID
    )
{
    ULONG   i = 0;
    
    PAGED_CODE();

    while (HalpFakeAcpiRegisterFadtIds[i][0] != NULL) {

      //DbgPrint("Comparing [%s]-[%s] to [%s]-[%s]\n",
      //         HalpFixedAcpiDescTable.Header.OEMID,
      //         HalpFixedAcpiDescTable.Header.OEMTableID,
      //         HalpFakeAcpiRegisterFadtIds[i][0],
      //         HalpFakeAcpiRegisterFadtIds[i][1]);
        
        if ((!strncmp(HalpFixedAcpiDescTable.Header.OEMID, 
                      HalpFakeAcpiRegisterFadtIds[i][0],
                      6)) &&
            (!strncmp(HalpFixedAcpiDescTable.Header.OEMTableID, 
                      HalpFakeAcpiRegisterFadtIds[i][1],
                      8))) {

            //
            // This machine matches one of the entries
            // in the table that tells us that we should fake
            // our ACPI registers.
            //

            //DbgPrint("Found a match\n");
            //
            // Make sure the oem revision is less than 3.
            // Then we need to fake the acpi registers
            //
            if(HalpFixedAcpiDescTable.Header.OEMRevision < 3)
                return TRUE;
        }

        i++;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\i64cache.c ===
/*++

Module Name:

    i64cache.c

Abstract:

    Merced (IA64 processor) has level0 Instruction and Data cache. Level 1 is unified Cache. All the caches in level0 and level1 are writeback caches. Hardware ensures coherency in both instruction and data cache for DMA transfers.
    Level0 Instruction and Data caches are not coherent with respect to self modifying or cross modifying code. Also for PIO transfers hardware does not ensure coherency. Software has to ensure coherency for self or cross modifying code as well as PIO transfers.

Author:

    Bernard Lint
    M. Jayakumar  (Muthurajan.Jayakumar@intel.com)


Environment:

    Kernel mode

Revision History:

--*/

#include "halp.h"
#include "i64fw.h"

#define CACHE_LINE_SIZE     64


VOID
HalpSweepCacheLines (
    IN PVOID BaseAddress,
    IN SIZE_T NumberOfLines,
    IN SIZE_T CacheLineSize
    )

/*++

Routine Description:

    This function sweeps the number of cache lines from the virtual base address specified.

Arguements:

    Base Address describes the starting virtual address to begin sweeping.

    Number of Lines specify the number of lines to be sweeped.


Return Value:

    None.

--*/

{
    PUCHAR SweepAddress, LastAddress;

    LastAddress = (PUCHAR)(BaseAddress)+(NumberOfLines * CacheLineSize);
    SweepAddress = (PUCHAR)BaseAddress;

    do {
       __fc((__int64)SweepAddress);
       SweepAddress += CacheLineSize;
    } while (SweepAddress < LastAddress);
}


VOID
HalSweepIcache (
    )

/*++

Routine Description:

    This function sweeps the entire I cache on the processor which it runs.

Arguments:

    None.

Return Value:

    None.



NOTE: An OEM modifying this code for HalSweepIcache should note that HalSweepIcache CANNOT USE
    FC instruction (or any routine that uses FC instruction,for example,HalSweepIcacheRange).
    This is because FC can generate page faults and if HalSweepIcache raises its IRQL (for
    avoiding context switch) then page faults will not be tolerated at a raied IRQL.
--*/

{

    //
    // Calls SAL_FLUSH to flush the single processor I cache on which it runs and the platform
    // cache, if any.
    // Calls PAL_FLUSH to flush only the processor I cache on which it runs. PAL_FLUSH does not
    // flush the platform cache.

    // The decision to choose PAL_FLUSH or SAL_FLUSH is made using a interlockedCompareExchange
    // to a semaphore.This allows only one processor to call SAL_FLUSH and other processors to call
    // PAL_FLUSH. This avoids unnecessary overhead of flushing the platform cache multiple times.
    // The assumption in using InterlockedCompareExchange is that by the time the CPU which grabs
    // the semaphore comes out after doing the SAL_FLUSH, all other CPUs at least have entered their
    // PAL_FLUSH. If this assumption is voilated, the platform cache will be flushed multiple times.
    // Functionally nothing fails.

    SAL_PAL_RETURN_VALUES rv = {0};

    HalpSalCall(SAL_CACHE_FLUSH, FLUSH_COHERENT,0,0,0,0,0,0,&rv);
}




VOID
HalSweepDcache (
    )

/*++

Routine Description:

    This function sweeps the entire D cache on ths processor which it runs.

    Arguments:

    None.

    Return Value:

    None.

    NOTE: An OEM modifying this code for HalSweepDcache should note that HalSweepDcache CANNOT USE
    FC instruction (or any routine that uses FC instruction,for example,HalSweepDcacheRange).
    This is because FC can generate page faults and if HalSweepDcache raises its IRQL (for
    avoiding context switch) then page faults will not be tolerated at a raied IRQL.

--*/

{

    //
    // Calls SAL_FLUSH to flush the single processor D cache on which it runs and the platform
    // cache, if any.
    // Calls PAL_FLUSH to flush only the processor D cache on which it runs. PAL_FLUSH does not
    // flush the platform cache.

    // The decision to choose PAL_FLUSH or SAL_FLUSH is made using a interlockedCompareExchange
    // to a semaphore.This allows only one processor to call SAL_FLUSH and other processors to call
    // PAL_FLUSH. This avoids unnecessary overhead of flushing the platform cache multiple times.
    // The assumption in using InterlockedCompareExchange is that by the time the CPU which grabs
    // the semaphore comes out after doing the SAL_FLUSH, all other CPUs at least have entered their
    // PAL_FLUSH. If this assumption is voilated, the platform cache will be flushed multiple times.
    // Functionally nothing fails.
    //
    //

    SAL_PAL_RETURN_VALUES rv = {0};
    HalpSalCall(SAL_CACHE_FLUSH,FLUSH_DATA_CACHE,0,0,0,0,0,0,&rv);
}



VOID
HalSweepCacheRange (
     IN PVOID BaseAddress,
     IN SIZE_T Length
    )

/*++

Routine Description:
    This function sweeps the range of address in the I cache throughout the system.

Arguments:
    BaseAddress - Supplies the starting virtual address of a range of
      virtual addresses that are to be flushed from the data cache.

    Length - Supplies the length of the range of virtual addresses
      that are to be flushed from the data cache.


Return Value:

    None.


PS: HalSweepCacheRange just flushes the cache. It does not synchrnoizes the I-Fetch
    pipeline with the flush operation. To Achieve pipeline flush also, one has to
    call KeSweepCacheRange.

--*/

{
    SIZE_T NumberOfLines;

    if (Length < CACHE_LINE_SIZE) {
        Length = CACHE_LINE_SIZE;
    }

    //
    // Do we need to prevent a context switch? No. We will allow context
    // switching in between fc.
    // Flush the specified range of virtual addresses from the primary
    // instruction cache.
    //

    // We don't need to check for alignment since Merced hardware aligns
    // the address on cache line boundary for flush cache instruction.
    //

    NumberOfLines = Length / CACHE_LINE_SIZE;
    if ((Length % CACHE_LINE_SIZE) != 0) {
        NumberOfLines = NumberOfLines + 1;
    }

    HalpSweepCacheLines(BaseAddress, NumberOfLines, CACHE_LINE_SIZE);
}



VOID
HalSweepIcacheRange (
    IN PVOID BaseAddress,
    IN SIZE_T Length
    )

/*++


Routine Description:
    This function sweeps the range of address in the I cache throughout the system.

Arguments:
    BaseAddress - Supplies the starting virtual address of a range of
      virtual addresses that are to be flushed from the instruction cache.

    Length - Supplies the length of the range of virtual addresses
      that are to be flushed from the instruction cache.


Return Value:

    None.

PS: HalSweepCacheRange just flushes the cache. It does not synchrnoizes the I-Fetch
    pipeline with the flush operation. To Achieve pipeline flush also, one has to
    call KeSweepCacheRange.


--*/

{
    HalSweepCacheRange(BaseAddress,Length);
}


VOID
HalSweepDcacheRange (
    IN PVOID BaseAddress,
    IN SIZE_T Length
    )

/*++

Routine Description:
    This function sweeps the range of address in the D cache throughout the system.

Arguments:
    BaseAddress - Supplies the starting virtual address of a range of
      virtual addresses that are to be flushed from the data cache.

    Length - Supplies the length of the range of virtual addresses
      that are to be flushed from the data cache.


Return Value:

    None.

PS: HalSweepCacheRange just flushes the cache. It does not synchrnoizes the I-Fetch
    pipeline with the flush operation. To Achieve pipeline flush also, one has to
    call KeSweepCacheRange.

--*/

{
    HalSweepCacheRange(BaseAddress,Length);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\i64bus.c ===
/*++

Copyright (c) 1995  Intel Corporation

Module Name:

    i64bus.c

Abstract:

    This module implements the routines to support the management
    of bus resources and translation of bus addresses.

Author:

    14-Apr-1995

Environment:

    Kernel mode

Revision History:

    Based on simbus.c

--*/

#include "halp.h"
#include "hal.h"

UCHAR   HalName[] = "ACPI 1.0 - APIC platform";
extern WCHAR HalHardwareIdString[];

VOID
HalpInitializePciBus (
    VOID
    );

VOID
HalpInheritBusAddressMapInfo (
    VOID
    );

VOID
HalpInitBusAddressMapInfo (
    VOID
    );

BOOLEAN
HalpTranslateSystemBusAddress (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

VOID
KeFlushWriteBuffer(
    VOID
    )

/*++

Routine Description:

KeFlushWriteBuffer
    Flushes all write buffers and/or other data storing or reordering
    hardware on the current processor.  This ensures that all previous
    writes will occur before any new reads or writes are completed.

    In the simulation environment, there is no write buffer and nothing
    needs to be done.

Arguments:

    None

Return Value:

    None.

--*/
{
    __mf();
    return;
}

VOID
HalReportResourceUsage (
    VOID
    )
/*++

Routine Description:
    The registery is now enabled - time to report resources which are
    used by the HAL.

Arguments:

Return Value:

--*/
{
    ANSI_STRING     AHalName;
    UNICODE_STRING  UHalName;
    INTERFACE_TYPE  interfacetype;

    //
    // Set type
    //

    switch (HalpBusType) {
        case MACHINE_TYPE_ISA:  interfacetype = Isa;            break;
        case MACHINE_TYPE_EISA: interfacetype = Eisa;           break;
        case MACHINE_TYPE_MCA:  interfacetype = MicroChannel;   break;
        default:                interfacetype = Internal;       break;
    }

    //
    // Report HALs resource usage
    //

    RtlInitAnsiString (&AHalName, HalName);
    RtlAnsiStringToUnicodeString (&UHalName, &AHalName, TRUE);

    HalpReportResourceUsage (
        &UHalName,          // descriptive name
        interfacetype
    );

    RtlFreeUnicodeString (&UHalName);

    //
    // Turn on MCA support if present
    //

    HalpMcaInit();

    //
    // Registry is now intialized, see if there are any PCI buses
    //

    HalpInitializePciBus ();
#ifdef notyet
    //
    // Update supported address info with MPS bus address map
    //

    HalpInitBusAddressMapInfo ();

    //
    // Inherit any bus address mappings from MPS hierarchy descriptors
    //

    HalpInheritBusAddressMapInfo ();
#endif // notyet

    HalpRegisterPciDebuggingDeviceInfo();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\i64dat.c ===
/*       title  "IA64 Hal static data"
;++
;
; Copyright (c) 1998 Intel Corporation
;
; Module Name:
;
;   i64dat.c (derived from nthals\halx86\ixdat.c)
;
; Abstract:
;
;   Declares various INIT or pagable data
;
; Author:
;
;    Todd Kjos (v-tkjos) 5-Mar-1998
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;--
*/

#include "halp.h"
#include "pci.h"
#include "pcip.h"
#include "iosapic.h"


#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("INIT")
#endif

//
// The following data is only valid during system initialiation
// and the memory will be re-claimed by the system afterwards
//

ADDRESS_USAGE HalpDefaultPcIoSpace = {
    NULL, CmResourceTypePort, InternalUsage,
    {
        0x000,  0x10,   // ISA DMA
        0x0C0,  0x10,   // ISA DMA
        0x080,  0x10,   // DMA

        0x020,  0x2,    // PIC
        0x0A0,  0x2,    // Cascaded PIC

        0x040,  0x4,    // Timer1, Referesh, Speaker, Control Word
        0x048,  0x4,    // Timer2, Failsafe

        0x092,  0x1,    // system control port A

        0x070,  0x2,    // Cmos/NMI enable
        0x0F0,  0x10,   // coprocessor ports
        0xCF8,  0x8,    // PCI Config Space Access Pair
        0,0
    }
};

ADDRESS_USAGE HalpEisaIoSpace = {
    NULL, CmResourceTypePort, InternalUsage,
    {
        0x0D0,  0x10,   // DMA
        0x400,  0x10,   // DMA
        0x480,  0x10,   // DMA
        0x4C2,  0xE,    // DMA
        0x4D4,  0x2C,   // DMA

        0x461,  0x2,    // Extended NMI
        0x464,  0x2,    // Last Eisa Bus Muster granted

        0x4D0,  0x2,    // edge/level control registers

        0xC84,  0x1,    // System board enable
        0, 0
    }
};

ADDRESS_USAGE HalpImcrIoSpace = {
    NULL, CmResourceTypeMemory, InternalUsage,
    {
        0x022,  0x02,   // ICMR ports
        0, 0
    }
};

//
// From usage.c
//

WCHAR HalpSzSystem[] = L"\\Registry\\Machine\\Hardware\\Description\\System";
WCHAR HalpSzSerialNumber[] = L"Serial Number";

ADDRESS_USAGE  *HalpAddressUsageList;
IDTUsage        HalpIDTUsage[MAXIMUM_IDTVECTOR+1];

//
// From ixpcibus.c
//

WCHAR rgzMultiFunctionAdapter[] = L"\\Registry\\Machine\\Hardware\\Description\\System\\MultifunctionAdapter";
WCHAR rgzConfigurationData[] = L"Configuration Data";
WCHAR rgzIdentifier[] = L"Identifier";
WCHAR rgzPCIIndetifier[] = L"PCI";
WCHAR rgzPCICardList[] = L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\PnP\\PCI\\CardList";

//
// From ixpcibrd.c
//

WCHAR rgzReservedResources[] = L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\SystemResources\\ReservedResources";

//
// From ixinfo.c
//

WCHAR rgzSuspendCallbackName[] = L"\\Callback\\SuspendHibernateSystem";

//
// Strings used for boot.ini options
// from mphal.c
//

UCHAR HalpSzBreak[]     = "BREAK";
UCHAR HalpSzOneCpu[]    = "ONECPU";
UCHAR HalpSzPciLock[]   = "PCILOCK";
UCHAR HalpSzTimerRes[]  = "TIMERES";
UCHAR HalpGenuineIntel[]= "GenuineIntel";
UCHAR HalpSzInterruptAffinity[]= "INTAFFINITY";
UCHAR HalpSzForceClusterMode[]= "MAXPROCSPERCLUSTER";

//
// From ixcmos.asm
//

UCHAR HalpSerialLen;
UCHAR HalpSerialNumber[31];

//
// From mpaddr.c
//

USHORT  HalpIoCompatibleRangeList0[] = {
    0x0100, 0x03ff,     0x0500, 0x07FF,     0x0900, 0x0BFF,     0x0D00, 0x0FFF,
    0, 0
    };

USHORT  HalpIoCompatibleRangeList1[] = {
    0x03B0, 0x03BB,     0x03C0, 0x03DF,     0x07B0, 0x07BB,     0x07C0, 0x07DF,
    0x0BB0, 0x0BBB,     0x0BC0, 0x0BDF,     0x0FB0, 0x0FBB,     0x0FC0, 0x0FDF,
    0, 0
    };


//
// Error messages
//

UCHAR  rgzNoMpsTable[]      = "HAL: No MPS Table Found\n";
UCHAR  rgzNoApic[]          = "HAL: No IO SAPIC Found\n";
UCHAR  rgzBadApicVersion[]  = "HAL: Bad SAPIC Version\n";
UCHAR  rgzApicNotVerified[] = "HAL: IO SAPIC not verified\n";
UCHAR  rgzRTCNotFound[]     = "HAL: No RTC device interrupt\n";


//
// From ixmca.c
//
UCHAR   MsgCMCPending[] = MSG_CMC_PENDING;
UCHAR   MsgCPEPending[] = MSG_CPE_PENDING;
WCHAR   rgzSessionManager[] = L"Session Manager";
WCHAR   rgzEnableMCA[] = L"EnableMCA";
WCHAR   rgzEnableCMC[] = L"EnableCMC";
WCHAR   rgzEnableCPE[] = L"EnableCPE";
WCHAR   rgzNoMCABugCheck[] = L"NoMCABugCheck";
WCHAR   rgzEnableMCEOemDrivers[] = L"EnableMCEOemDrivers";

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif

ULONG HalpFeatureBits = HALP_FEATURE_INIT;


volatile BOOLEAN HalpHiberInProgress = FALSE;

//
// Stuff that we only need while we
// sleep or hibernate.
//

#ifdef notyet

MOTHERBOARD_CONTEXT HalpMotherboardState = {0};

#endif //notyet


//
// PAGELK handle
//
PVOID   HalpSleepPageLock = NULL;

USHORT  HalpPciIrqMask = 0;
USHORT  HalpEisaIrqMask = 0;
USHORT  HalpEisaIrqIgnore = 0x1000;

PULONG_PTR *HalEOITable[HAL_MAXIMUM_PROCESSOR];

PROCESSOR_INFO HalpProcessorInfo[HAL_MAXIMUM_PROCESSOR];

//
// HAL private Mask of all of the active processors.
//
// The specific processors bits are based on their _KPCR.Number values.

KAFFINITY HalpActiveProcessors;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\i64efis.s ===
//
///////////////////////////////////////////////////////////////////////////////
//
// Module Name:  EFIASM.S - IA64 EFI Physical Mode Calls //
// Description:
// Target Platform:  Merced
//
// Reuse: None
//
///////////////////////////////////////////////////////////////////////////////

#include "regia64.h"
#include "kxia64.h"

        .global HalpCallEfiPhysical
        .global HalpPhysBSPointer
        .global HalpPhysStackPointer
        .text

//++
// Name: HalpCallEfiPhysical()
// 
// Routine Description:
//
// Arguments:
//
//      Arg 0 to Arg 5
//      EntryPoint
//      GlobalPointer
//
// Return Value: EFI_STATUS
//
//--


        NESTED_ENTRY(HalpCallEfiPhysical)
        NESTED_SETUP(8,2,0,0)

//
//      Aliases
//
        rSaveEP     = t22
        rSaveGP     = t21
        rSaveA5     = t20
        rSaveA4     = t19
        rSaveA3     = t18
        rSaveA2     = t17
        rSaveA1     = t16
        rSaveA0     = t15

        rSaveSp     = t14
        rSaveBSP    = t13
        rSavePfs    = t12
        rSaveBrp    = t11
        rSaveRSC    = t10
        rSaveRNAT   = t9
        rSavePSR    = t8

        rNewSp      = t7
        rNewBSP     = t6

        rT1         = t1
        rT2         = t2
        rT3         = t3
                
// Save Arguements in static Registers
   
        mov         rSaveA0  = a0
        mov         rSaveA1  = a1
        mov         rSaveA2  = a2
        mov         rSaveA3  = a3
        mov         rSaveA4  = a4
        mov         rSaveA5  = a5
        mov         rSaveEP  = a6
        mov         rSaveGP  = a7

        mov         rSaveSp = sp
        mov         rSavePfs = ar.pfs
        mov         rSaveBrp = brp
        
//
// Setup Physical sp, bsp
//

        add          rT1 = @gprel(HalpPhysStackPointer), gp
        add          rT2 = @gprel(HalpPhysBSPointer), gp
        ;;
        ld8          rNewSp = [rT1]
        ld8          rNewBSP = [rT2]

// Allocate 0
        ;;
        alloc       rT1 = 0,0,0,0

// Flush RSE 
        ;;
        flushrs
        ;;
        mov         rSavePSR = psr
        movl        rT2 = (1 << PSR_BN)
        ;;
        or          rSavePSR = rT2, rSavePSR    // psr.bn stays on
        rsm         (1 << PSR_I)        
        
        mov         rSaveRSC = ar.rsc

// Flush RSE to enforced lazy mode by clearing both RSC.mode bits

        mov         rT1 = RSC_KERNEL_DISABLED
        ;;
        mov         ar.rsc = rT1
        ;;
//
// save RSC, RNAT, BSP, PSR, SP in the allocated space during initialization 
//
        mov         rSaveBSP = ar.bsp
        mov         rSaveRNAT = ar.rnat
//
// IC = 0; I = 0; 
//
        ;;
        rsm         (1 << PSR_IC)
        ;;
//        
// IIP = HceContinuePhysical:  IPSR is physical
//        
        movl        rT1 = (1 << PSR_IT) | (1 << PSR_RT) | (1 << PSR_DT) | (1 << PSR_I)
        movl        rT2 = 0xffffffffffffffff
        ;;
        xor         rT1 = rT1, rT2
        ;;
        and         rT1 = rT1, rSavePSR         // rT1 = old PSR & zero it, dt, rt, i
        srlz.i
        ;;
        mov         cr.ipsr = rT1
        mov         cr.ifs = zero
        ;;
        movl        rT2 = HceContinuePhysical
        movl        rT3 = 0xe0000000ffffffff
        ;;
        and         rT2 = rT2, rT3
        ;;
        tpa         rT2 = rT2                   // phys address of new ip
        ;;
        mov         cr.iip = rT2
        ;;
        rfi
        ;;
      
//
// Now in physical mode, ic = 1, i = 0
//

HceContinuePhysical::

//
// Switch to new bsp, sp
//
        mov         sp = rNewSp
        mov         ar.bspstore = rNewBSP
        ;;        
        mov         ar.rnat = zero
        ;;
//
// Enable RSC
//
        mov         ar.rsc = RSC_KERNEL

//
// Allocate frame on new bsp
//
        ;;
        alloc       rT1 = ar.pfs,0,7,6,0

//
// Save caller's state in register stack
//

        mov         loc0 = rSaveRNAT
        mov         loc1 = rSaveSp
        mov         loc2 = rSaveBSP
        mov         loc3 = rSaveRSC
        mov         loc4 = rSaveBrp
        mov         loc5 = rSavePfs
        mov         loc6 = rSavePSR
        ;;
// Setup Arguements

        mov         out0 = rSaveA0
        mov         out1 = rSaveA1
        mov         out2 = rSaveA2
        mov         out3 = rSaveA3
        mov         out4 = rSaveA4
        mov         out5 = rSaveA5

        movl        rT1 = HceEfiReturnAddress
        movl        rT2 = 0xe0000000FFFFFFFF
        ;;
        and         rT2 = rT2, rT1
        ;;
        tpa         rT2 = rT2
        ;;
        mov         brp = rT2
        mov         gp = rSaveGP
        mov         bt0 = rSaveEP        
        ;;
        br.call.sptk brp = bt0
        ;;

HceEfiReturnAddress::
//
// In physical mode: switch to virtual
//

//
// Restore saved state
//
        mov         rSaveRNAT = loc0
        mov         rSaveSp  = loc1
        mov         rSaveBSP = loc2
        mov         rSaveRSC = loc3
        mov         rSaveBrp = loc4
        mov         rSavePfs = loc5
        mov         rSavePSR = loc6
        ;;
//
// Restore BSP, SP
//
        ;;
        mov         ar.rsc = RSC_KERNEL_DISABLED
        ;;
        alloc       rT1 = 0,0,0,0
        ;;
        mov         ar.bspstore = rSaveBSP
        ;;
        mov         ar.rnat = rSaveRNAT
        mov         sp = rSaveSp
        ;;
        rsm         (1 << PSR_IC)
        ;;
        
        movl        rT1 = HceContinueVirtual
        movl        rT2 = 0xe0000000ffffffff
        ;;
        and         rT1 = rT2, rT1
        ;;
        srlz.i
        ;;
        mov         cr.iip = rT1
        mov         cr.ipsr = rSavePSR
        mov         cr.ifs = zero
        ;;
        rfi
        ;;
//
// Now in virtual mode, ic = 1, i = 1
//
HceContinueVirtual::

//
// Restore psf, brp and return
//
        mov         ar.rsc = rSaveRSC
        ;;
        mov         ar.pfs = rSavePfs
        mov         brp = rSaveBrp
        ;;
        br.ret.sptk brp
        NESTED_EXIT(HalpCallEfiPhysical)      





//++
//
//  VOID
//  HalpCallEfiVirtual(
//      ULONGLONG a0,  /* Arg 1 */
//      ULONGLONG a1,  /* Arg 2 */
//      ULONGLONG a2, /*  Arg 3 */
//      ULONGLONG a3, /*  Arg 4 */
//      ULONGLONG a4, /*  Arg 5 */
//      ULONGLONG a5, /*  Arg 6 */
//      ULONGLONG a6, /*  Entry Point */
//      ULONGLONG a7  /*  GP    */
//      );
//
//  Routine Description:
//
//  Return Values:
//      r8->r11 contain the 4 64-bit return values, r8 is the status
//--

        NESTED_ENTRY(HalpCallEfiVirtual)
        
        NESTED_SETUP(8,2,8,0)
        
        // copy args to outs
        mov         out0 = a0
        mov         out1 = a1
        mov         out2 = a2
        mov         out3 = a3
        mov         out4 = a4
        mov         out5 = a5
        mov         out6 = a6
        mov         out7 = a7
        ;;
        
        // Simply load the address and branch to it

        
        mov         gp   = a7
        ;;
        mov         bt0 =  a6
        ;;
        br.call.sptk brp = bt0
        ;;
        NESTED_RETURN
        
        NESTED_EXIT(HalpCallEfiVirtual)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\i64efi.c ===
/*++

Copyright (c) 1995  Intel Corporation

Module Name:

    i64efi.c

Abstract:

    This module implements the routines that transfer control
    from the kernel to the EFI code.

Author:

    Bernard Lint
    M. Jayakumar (Muthurajan.Jayakumar@hotmail.com)

Environment:

    Kernel mode

Revision History:

    Neal Vu (neal.vu@intel.com), 03-Apr-2001:
        Added HalpGetSmBiosVersion.


--*/

#include "halp.h"
#include "arc.h" 
#include "arccodes.h"
#include "i64fw.h"
#include "floatem.h"
#include "fpswa.h"
#include <smbios.h>

extern ULONGLONG PhysicalIOBase;

BOOLEAN
HalpCompareEfiGuid (
    IN EFI_GUID CheckGuid, 
    IN EFI_GUID ReferenceGuid
    );


BOOLEAN
MmSetPageProtection(
    IN PVOID VirtualAddress,
    IN SIZE_T NumberOfBytes,
    IN ULONG NewProtect
    );

EFI_STATUS
HalpCallEfiPhysical(
    IN ULONGLONG Arg1,
    IN ULONGLONG Arg2,
    IN ULONGLONG Arg3,
    IN ULONGLONG Arg4,
    IN ULONGLONG Arg5,
    IN ULONGLONG Arg6,
    IN ULONGLONG EP,
    IN ULONGLONG GP
    );
    

    
EFI_STATUS
HalpCallEfiVirtual(
    IN ULONGLONG Arg1,
    IN ULONGLONG Arg2,
    IN ULONGLONG Arg3,
    IN ULONGLONG Arg4,
    IN ULONGLONG Arg5,
    IN ULONGLONG Arg6,
    IN ULONGLONG EP,
    IN ULONGLONG GP
    );

LONG 
HalFpEmulate( 
    ULONG     trap_type,
    BUNDLE    *pbundle,
    ULONGLONG *pipsr,
    ULONGLONG *pfpsr,
    ULONGLONG *pisr,
    ULONGLONG *ppreds,
    ULONGLONG *pifs,
    FP_STATE  *fp_state
    );

BOOLEAN
HalEFIFpSwa(
    VOID
    );

VOID
HalpFpswaPlabelFixup(
    EFI_MEMORY_DESCRIPTOR *EfiVirtualMemoryMapPtr,
    ULONGLONG MapEntries,
    ULONGLONG EfiDescriptorSize,
    PPLABEL_DESCRIPTOR PlabelPointer
    );

PUCHAR
HalpGetSmBiosVersion (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );


//
// External global data
// 

extern HALP_SAL_PAL_DATA        HalpSalPalData;
extern ULONGLONG                HalpPalProcPointer;
extern ULONGLONG                HalpSalProcPointer;
extern ULONGLONG                HalpSalProcGlobalPointer;
extern KSPIN_LOCK               HalpSalSpinLock;
extern KSPIN_LOCK               HalpSalStateInfoSpinLock;
extern KSPIN_LOCK               HalpMcaSpinLock;
extern KSPIN_LOCK               HalpInitSpinLock;
extern KSPIN_LOCK               HalpCmcSpinLock;
extern KSPIN_LOCK               HalpCpeSpinLock;

#define VENDOR_SPECIFIC_GUID    \
    { 0xa3c72e56, 0x4c35, 0x11d3, 0x8a, 0x03, 0x0, 0xa0, 0xc9, 0x06, 0xad, 0xec }


#define ConfigGuidOffset        0x100
#define ConfigTableOffset       0x200

#define VariableNameOffset      0x100
#define VendorGuidOffset        0x200
#define AttributeOffset         0x300
#define DataSizeOffset          0x400
#define DataBufferOffset        0x500
#define EndOfCommonDataOffset   0x600
                             
//
// Read Variable and Write Variable will not be called till the copying out of 
// Memory Descriptors is done. Because the lock is released before copying and we are using
// the same offset for read/write variable as well as memory layout calls.
// 
                                  
#define MemoryMapSizeOffset     0x100
#define DescriptorSizeOffset    0x200
#define DescriptorVersionOffset 0x300
#define MemoryMapOffset         0x400


#define OptionROMAddress        0xC0000

#define FP_EMUL_ERROR          -1

SST_MEMORY_LIST                 PalCode;
   
NTSTATUS                        EfiInitStatus;

ULONGLONG                       PalTrMask;

PUCHAR                          HalpConfigGuidVirtualPtr, HalpConfigGuidPhysPtr;

PUCHAR                          HalpConfigTableVirtualPtr;
PUCHAR                          HalpConfigTablePhysPtr;

EFI_CONFIGURATION_TABLE         *EfiConfigTableVirtualPtr;
EFI_CONFIGURATION_TABLE         EfiConfigTable;

EFI_GUID                        CheckGuid;
EFI_GUID                        SalGuid = SAL_SYSTEM_TABLE_GUID;

EFI_GUID                        VendorGuid;

PUCHAR                          HalpVendorGuidPhysPtr;
PUCHAR                          HalpVendorGuidVirtualPtr;

EFI_SYSTEM_TABLE                *EfiSysTableVirtualPtr;
EFI_SYSTEM_TABLE                *EfiSysTableVirtualPtrCpy;

EFI_RUNTIME_SERVICES            *EfiRSVirtualPtr;
EFI_BOOT_SERVICES               *EfiBootVirtualPtr;

PLABEL_DESCRIPTOR               *EfiVirtualGetVariablePtr;           // Get Variable
PLABEL_DESCRIPTOR               *EfiVirtualGetNextVariableNamePtr;   // Get NextVariable Name
PLABEL_DESCRIPTOR               *EfiVirtualSetVariablePtr;           // Set Variable
PLABEL_DESCRIPTOR               *EfiVirtualGetTimePtr;               // Get Time
PLABEL_DESCRIPTOR               *EfiVirtualSetTimePtr;               // Set Time

PLABEL_DESCRIPTOR               *EfiSetVirtualAddressMapPtr;         // Set Virtual Address Map

PLABEL_DESCRIPTOR               *EfiResetSystemPtr;                  // Reboot

PULONGLONG                      AttributePtr; 
ULONGLONG                       EfiAttribute;

PULONGLONG                      DataSizePtr;
ULONGLONG                       EfiDataSize;


ULONGLONG                       EfiConfigTableSize, EfiMemoryMapSize,EfiDescriptorSize,EfiMapEntries;

ULONG                           EfiDescriptorVersion;


PULONGLONG                      HalpPhysBSPointer;
PULONGLONG                      HalpPhysStackPointer;


PUCHAR                          HalpVirtualEfiSalPalDataPointer;

PUCHAR                          HalpPhysEfiSalPalDataPointer;

PUCHAR                          HalpVirtualCommonDataPointer; 

PUCHAR                          HalpPhysCommonDataPointer;

PUCHAR                          HalpVariableNamePhysPtr;

PUCHAR                          HalpVariableAttributesPhysPtr;
PUCHAR                          HalpDataSizePhysPtr;
PUCHAR                          HalpDataPhysPtr;

PUCHAR                          HalpMemoryMapSizePhysPtr;
PUCHAR                          HalpMemoryMapPhysPtr;
PUCHAR                          HalpDescriptorSizePhysPtr;
PUCHAR                          HalpDescriptorVersionPhysPtr;


PUCHAR                          HalpVariableNameVirtualPtr;

PUCHAR                          HalpVariableAttributesVirtualPtr;
PUCHAR                          HalpDataSizeVirtualPtr; 
PUCHAR                          HalpDataVirtualPtr;
PUCHAR                          HalpCommonDataEndPtr;

PUCHAR                          HalpMemoryMapSizeVirtualPtr;
PVOID                           HalpMemoryMapVirtualPtr;
PUCHAR                          HalpDescriptorSizeVirtualPtr;
PUCHAR                          HalpDescriptorVersionVirtualPtr;

EFI_FPSWA                       HalpFpEmulate;

KSPIN_LOCK                      EFIMPLock; 

ULONG                           HalpOsBootRendezVector;


BOOLEAN
HalpCompareEfiGuid (
    IN EFI_GUID CheckGuid, 
    IN EFI_GUID ReferenceGuid
    )

/*++

      




--*/

{
    USHORT i;
    USHORT TotalArrayLength = 8; 

    if (CheckGuid.Data1 != ReferenceGuid.Data1) {
        return FALSE;

    } else if (CheckGuid.Data2 != ReferenceGuid.Data2) {
        return FALSE;
    } else if (CheckGuid.Data3 != ReferenceGuid.Data3) {
        return FALSE;
    }

    for (i = 0; i != TotalArrayLength; i++) {
        if (CheckGuid.Data4[i] != ReferenceGuid.Data4[i]) 
            return FALSE;

    }

    return TRUE;

} // HalpCompareEfiGuid()

VOID
HalpInitSalPalWorkArounds(
    VOID
    )
/*++

Routine Description:

    This function determines and initializes the FW workarounds.

Arguments:

    None.

Return Value:

    None.

Globals: 

Notes: This function is being called at the end of HalpInitSalPal.
       It should not access SST members if this SAL table is unmapped.

--*/
{
    NTSTATUS status;
    extern FADT HalpFixedAcpiDescTable;

#define HalpIsIntelOEM() \
    ( !_strnicmp( HalpFixedAcpiDescTable.Header.OEMID, "INTEL", 5 ) )

#define HalpIsBigSur() \
    ( !strncmp( HalpFixedAcpiDescTable.Header.OEMTableID, "W460GXBS", 8 ) )

#define HalpIsIntelBigSur() \
    ( HalpIsIntelOEM() && HalpIsBigSur() )

    if ( HalpIsIntelOEM() ) {

        //
        // If Intel BigSur and FW build < 103 (checked as Pal_A_Revision < 0x20),
        // enable the SAL_GET_STATE_INFO log id increment workaround.
        //

        if ( HalpIsBigSur() )   {

            if (  HalpSalPalData.PalVersion.PAL_A_Revision < 0x20 )    {
                HalpSalPalData.Flags |= HALP_SALPAL_FIX_MCE_LOG_ID;
                HalpSalPalData.Flags |= HALP_SALPAL_FIX_MP_SAFE;
            }

//
// HALP_SALPAL_MCE_MODINFO_CPUINDINFO_OMITTED 04/12/2001:
//  FW omits completely ERROR_PROCESSOR.CpuIdInfo field in the log.
//      Softsur: This is fixed with developer FW SoftMca3 05/09/2001.
//      Lion   : ?
//
// HALP_SALPAL_MCE_PROCESSOR_STATICINFO_PARTIAL 04/12/2001:
//  FW does not pad invalid processor staticinfo fields.
//  We do not know when it is going to be fixed.
//

            if ( HalpSalPalData.PalVersion.PAL_A_Revision < 0x21 ) {
                HalpSalPalData.Flags |= HALP_SALPAL_MCE_PROCESSOR_CPUIDINFO_OMITTED;
            }
            HalpSalPalData.Flags |= HALP_SALPAL_MCE_PROCESSOR_STATICINFO_PARTIAL;
        }
        else  {
        //
        // If Intel Lion and FW build < 78b (checked as SalRevision < 0x300),
        // enable the SAL_GET_STATE_INFO log id increment workaround.
        //
            if (  HalpSalPalData.SalRevision.Revision < 0x300 )    {
                HalpSalPalData.Flags |= HALP_SALPAL_FIX_MCE_LOG_ID;
                HalpSalPalData.Flags |= HALP_SALPAL_FIX_MP_SAFE;
            }

            HalpSalPalData.Flags |= HALP_SALPAL_MCE_PROCESSOR_CPUIDINFO_OMITTED;
            HalpSalPalData.Flags |= HALP_SALPAL_MCE_PROCESSOR_STATICINFO_PARTIAL;
        }

    }

    return;

} // HalpInitSalPalWorkArounds()

NTSTATUS
HalpInitSalPal(
    PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This function extracts data from the SAL system table, virtually maps the
    SAL code, SAL data, and PAL code areas.  PAL requires a TR mapping, and
    is mapped using an architected TR, using the smallest page size to map
    the entire PAL code region.  If SAL data or SAL code areas can be mapped in
    the same page, it uses the same translation.  Otherwise, it uses MmMapIoSpace.

Arguments:

    LoaderBlock - Supplies a pointer to the Loader parameter block, containing the
    physical address of the SAL system table.

Return Value:

    STATUS_SUCCESS is returned if the mappings were successful, and SAL/PAL calls can
    be made.  Otherwise, STATUS_UNSUCCESSFUL is returned if it cannot virtually map
    the areas or if PAL requires a page larger than 16MB.


Assumptions: The EfiSysTableVirtualPtr is initialized prior by EfiInitialization.

--*/

{
    //
    // Local declarations
    //

    PSAL_PAL_ENTRY_POINT FwEntry;
    PSST_MEMORY_DESCRIPTOR SstMemoryDescriptor;
    PAP_WAKEUP_DESCRIPTOR  ApWakeupDescriptor;
    PVOID NextEntry, FwCodeSpace;
    UCHAR Checksum;
    PUCHAR CheckBuf;
    ULONG index,i,SstLength;
    SAL_PAL_RETURN_VALUES RetVals;
    PHYSICAL_ADDRESS physicalAddr;
    SAL_STATUS SALstatus;
    BOOLEAN LargerThan16Mb, MmMappedSalCode, MmMappedSalData;
    ULONGLONG physicalEfiST,physicalSST; 
    ULONGLONG physicalPAL, physicalSAL, physicalSALGP;
    ULONGLONG PhysicalConfigPtr;
    SST_MEMORY_LIST SalCode,SalData, FwCode;
    BOOLEAN FoundSalTable; 
    ULONGLONG palStatus;
    PAL_VERSION_STRUCT minimumPalVersion;
    ULONG PalPageShift;
    ULONGLONG PalPteUlong;

    HalpVirtualEfiSalPalDataPointer  = (PUCHAR)(ExAllocatePool (NonPagedPool, PAGE_SIZE));
    
    HalpConfigTableVirtualPtr        = HalpVirtualEfiSalPalDataPointer + ConfigTableOffset;
        
    HalpConfigGuidVirtualPtr         = HalpVirtualEfiSalPalDataPointer + ConfigGuidOffset;

    HalpPhysEfiSalPalDataPointer     = (PUCHAR)((MmGetPhysicalAddress(HalpVirtualEfiSalPalDataPointer)).QuadPart);
    
    HalpConfigTablePhysPtr           = HalpPhysEfiSalPalDataPointer + ConfigTableOffset;

    HalpConfigGuidPhysPtr            = HalpPhysEfiSalPalDataPointer + ConfigGuidOffset;
    
    EfiConfigTableVirtualPtr         = &EfiConfigTable;

    EfiConfigTableSize               = (ULONGLONG) sizeof(EFI_CONFIGURATION_TABLE);
    
    HalDebugPrint(( HAL_INFO, "SAL_PAL: Entering HalpInitSalPal\n" ));

    FoundSalTable = FALSE;

    //
    // Extract SST physical address out of EFI table 
    //

    PhysicalConfigPtr = (ULONGLONG) EfiSysTableVirtualPtrCpy -> ConfigurationTable;
        
    for (index = 0; (FoundSalTable == FALSE) && (index <= (EfiSysTableVirtualPtr->NumberOfTableEntries)); index = index + 1) {
       
        physicalAddr.QuadPart = PhysicalConfigPtr;
 
        EfiConfigTableVirtualPtr = MmMapIoSpace(physicalAddr, sizeof(EFI_CONFIGURATION_TABLE),MmCached);
          

        if (EfiConfigTableVirtualPtr == NULL) {

            HalDebugPrint(( HAL_ERROR, "SAL_PAL: Efi Config Table Virtual Addr is NULL\n" ));
            
            EfiInitStatus = STATUS_UNSUCCESSFUL;

            return STATUS_UNSUCCESSFUL;
        }

        
        CheckGuid = EfiConfigTableVirtualPtr -> VendorGuid;
        
        PhysicalConfigPtr = PhysicalConfigPtr + EfiConfigTableSize;
        HalDebugPrint(( HAL_INFO, 
			            "SAL_PAL: Found new ConfigPhysPtr 0x%I64x points to tablesize 0x%I64x\n",
						PhysicalConfigPtr, EfiConfigTableSize )); 
       
        // if (CheckGuid.Data1 == 0xeb9d2d32) 

        if (HalpCompareEfiGuid(CheckGuid, SalGuid)) {
            FoundSalTable = TRUE;
        }
  
        
    }
    
    physicalSST = (ULONGLONG) EfiConfigTableVirtualPtr -> VendorTable;

    //
    // Zero out internal structures
    //

    RtlZeroMemory(&HalpSalPalData, sizeof(HalpSalPalData));
    RtlZeroMemory(&SalCode, sizeof(SST_MEMORY_LIST));
    RtlZeroMemory(&PalCode, sizeof(SST_MEMORY_LIST));
    RtlZeroMemory(&SalData, sizeof(SST_MEMORY_LIST));
    RtlZeroMemory(&FwCode,  sizeof(SST_MEMORY_LIST));

    //
    // Initialize flags
    //

    MmMappedSalCode = FALSE;
    MmMappedSalData = FALSE;
    HalpSalPalData.Status = STATUS_SUCCESS;
       
    //
    // Map the SST, get the length of entire SST to remap the rest of it
    //

    physicalAddr.QuadPart = physicalSST;
    HalpSalPalData.SalSystemTable = MmMapIoSpace(physicalAddr,sizeof(SST_HEADER),MmCached);

    if (HalpSalPalData.SalSystemTable) {

        //
        // Save SAL revision in case we decide to unmap it later on.
        //

        HalpSalPalData.SalRevision.Revision = HalpSalPalData.SalSystemTable->SalRev;

        HalDebugPrint(( HAL_INFO, 
						"SAL_PAL: Found SST SAL v%d.%d (XXTF:%d) at PhysAddr 0x%I64x & mapped to VirtAddr 0x%I64x\n", 
                        HalpSalPalData.SalRevision.Major,
                        HalpSalPalData.SalRevision.Minor,
                        HalpSalPalData.SalRevision.Revision,
			            physicalSST,
						HalpSalPalData.SalSystemTable));
        
        SstLength=HalpSalPalData.SalSystemTable->Length;

        MmUnmapIoSpace((PVOID)HalpSalPalData.SalSystemTable,sizeof(SST_HEADER));

        HalpSalPalData.SalSystemTable = MmMapIoSpace(physicalAddr,SstLength,MmCached);

    } else {

        HalDebugPrint(( HAL_INFO, "SAL_PAL: Couldn't virtually map SST (PhysAddr: 0x%I64x)\n", physicalSST ));
        HalpSalPalData.Status = STATUS_UNSUCCESSFUL;
        return STATUS_UNSUCCESSFUL;
    }

    HalDebugPrint(( HAL_INFO, 
                    "SAL_PAL: Mapped all of SST for PhysAddr 0x%I64x at VirtAddr 0x%I64x for %d bytes\n", 
                    physicalSST,
                    HalpSalPalData.SalSystemTable, SstLength ));

    //
    // Because the checksum is maybe not computed and verified by the OS loader before the
    // hand-off to the kernel, let's do a checksum and verify it.
    //

    Checksum=0;
    CheckBuf= (PUCHAR) HalpSalPalData.SalSystemTable;

    for (i=0; i < SstLength; i++) {
        Checksum += CheckBuf[i];
    }
    
    if (Checksum) {

        HalDebugPrint(( HAL_ERROR, "SAL_PAL: Checksum is BAD with value of %d, should be 0\n", Checksum ));
        MmUnmapIoSpace((PVOID)HalpSalPalData.SalSystemTable,SstLength);
        HalpSalPalData.Status = STATUS_UNSUCCESSFUL;
        return STATUS_UNSUCCESSFUL;
    }

    HalDebugPrint(( HAL_INFO, "SAL_PAL: Checksum is GOOD\n" ));

    //
    // Pull out the SAL/PAL entrypoint and memory descriptor information we need by iterating
    // over the entire SST.
    //

    NextEntry = (PUCHAR)(((PUCHAR) HalpSalPalData.SalSystemTable) + sizeof(SST_HEADER));

    for (i = 0; i < HalpSalPalData.SalSystemTable->EntryCount; i++) {

        switch ( *(PUCHAR)NextEntry ) {           

            case SAL_PAL_ENTRY_POINT_TYPE:
                //
                // It is assumed only one Entry Point Type in the SST but we do not currently
                // impose this in this code.
                //

                FwEntry = (PSAL_PAL_ENTRY_POINT)NextEntry;
                physicalSAL   = FwEntry->SalEntryPoint;
                physicalPAL   = FwEntry->PalEntryPoint;
                physicalSALGP = FwEntry->GlobalPointer;

                HalDebugPrint(( HAL_INFO, 
                                "SAL_PAL: SAL_PROC PhysAddr at 0x%I64x\n"
                                "SAL_PAL: PAL_PROC PhysAddr at 0x%I64x\n"
                                "SAL_PAL: SAL_GP   PhysAddr at 0x%I64x\n", 
                                physicalSAL,
                                physicalPAL,
                                physicalSALGP
                             ));

                ((PSAL_PAL_ENTRY_POINT)NextEntry)++;               
                break;

            case SST_MEMORY_DESCRIPTOR_TYPE:
                //
                // It is assumed only one REGULAR_MEMORY entry for PAL_CODE_MEM, SAL_CODE_MEM and
                // SAL_DATA_MEM. However, we do not currently impose this in the code.
                //

                SstMemoryDescriptor = (PSST_MEMORY_DESCRIPTOR)NextEntry;

                HalDebugPrint(( HAL_INFO, 
                                "SAL_PAL: MemDesc for PhysAddr 0x%I64x (%I64d KB) - VaReg:%d,Type:%d,Use:%d\n",
                                SstMemoryDescriptor->MemoryAddress,(ULONGLONG)SstMemoryDescriptor->Length * 4,
                                SstMemoryDescriptor->NeedVaReg,SstMemoryDescriptor->MemoryType,SstMemoryDescriptor->MemoryUsage
                             ));

                if (SstMemoryDescriptor->MemoryType == REGULAR_MEMORY) {

                    switch(SstMemoryDescriptor->MemoryUsage) {

                        case PAL_CODE_MEM:
                            PalCode.PhysicalAddress = SstMemoryDescriptor->MemoryAddress;
                            PalCode.Length = SstMemoryDescriptor->Length << 12;
                            PalCode.NeedVaReg = SstMemoryDescriptor->NeedVaReg;
                            break;

                        case SAL_CODE_MEM:
                            SalCode.PhysicalAddress = SstMemoryDescriptor->MemoryAddress;
                            SalCode.Length = SstMemoryDescriptor->Length << 12;
                            SalCode.NeedVaReg = SstMemoryDescriptor->NeedVaReg;
                            break;

                        case SAL_DATA_MEM:
                            SalData.PhysicalAddress = SstMemoryDescriptor->MemoryAddress;
                            SalData.Length = SstMemoryDescriptor->Length << 12;
                            SalData.NeedVaReg = SstMemoryDescriptor->NeedVaReg;
                            break;

                        case FW_RESERVED:

                            // We need to virtually map and count these areas for NVM access.  
                            // We should keep a list of all such regions and would allocate an 
                            // array of virtual address mappings for each NVM region for later 
                            // use when accessing variables.
                            // No NVM support currently, so ignore for now.

                            break;
                        default:
                            break; 
                    }

                } else if ((SstMemoryDescriptor->MemoryType == FIRMWARE_CODE) && 
                           (SstMemoryDescriptor->MemoryUsage == FW_SAL_PAL)) {

                    FwCode.PhysicalAddress = SstMemoryDescriptor->MemoryAddress;
                    FwCode.Length = SstMemoryDescriptor->Length << 12;
                    FwCode.NeedVaReg = SstMemoryDescriptor->NeedVaReg;
                    
                }
                ((PSST_MEMORY_DESCRIPTOR)NextEntry)++;               
                break;

            case PLATFORM_FEATURES_TYPE:
                // We ignore this entry for now...
                ((PPLATFORM_FEATURES)NextEntry)++;
                 break;

            case TRANSLATION_REGISTER_TYPE:
                // We ignore this entry for now...
                ((PTRANSLATION_REGISTER)NextEntry)++;
                break;

            case PTC_COHERENCE_DOMAIN_TYPE:
                // We ignore this entry for now...
                ((PPTC_COHERENCE_DOMAIN)NextEntry)++;
                break;

            case AP_WAKEUP_DESCRIPTOR_TYPE:
                ApWakeupDescriptor = (PAP_WAKEUP_DESCRIPTOR)NextEntry;
                HalpOsBootRendezVector = (ULONG) ApWakeupDescriptor->WakeupVector;
  
                if ((HalpOsBootRendezVector < 0x100 ) && (HalpOsBootRendezVector > 0xF)) {
                    HalDebugPrint(( HAL_INFO, "SAL_PAL: Found Valid WakeupVector: 0x%x\n",
                                              HalpOsBootRendezVector ));       
                } else {
                    HalDebugPrint(( HAL_INFO, "SAL_PAL: Invalid WakeupVector.Using Default: 0x%x\n",
                                              DEFAULT_OS_RENDEZ_VECTOR ));
                    HalpOsBootRendezVector = DEFAULT_OS_RENDEZ_VECTOR;
                }

                ((PAP_WAKEUP_DESCRIPTOR)NextEntry)++;
                break;

            default:
                HalDebugPrint(( HAL_ERROR, 
                                "SAL_PAL: EntryType %d is bad at VirtAddr 0x%I64x, Aborting\n", 
                                *(PUCHAR)NextEntry,
                                NextEntry ));

                // An unknown SST Type was found, so we can't continue

                MmUnmapIoSpace((PVOID)HalpSalPalData.SalSystemTable,SstLength);
                HalpSalPalData.Status = STATUS_UNSUCCESSFUL;
                return STATUS_UNSUCCESSFUL;               
        }   
    }

    //
    // Initialize the HAL private spinlocks
    //
    //  - HalpSalSpinLock, HalpSalStateInfoSpinLock are used for MP synchronization of the 
    //    SAL calls that are not MP-safe.
    //  - HalpMcaSpinLock is used for defining an MCA monarch and MP synchrnonization of shared
    //    HAL MCA resources during OS_MCA calls.
    //

    KeInitializeSpinLock(&HalpSalSpinLock);
    KeInitializeSpinLock(&HalpSalStateInfoSpinLock);
    KeInitializeSpinLock(&HalpMcaSpinLock);
    KeInitializeSpinLock(&HalpInitSpinLock);
    KeInitializeSpinLock(&HalpCmcSpinLock);
    KeInitializeSpinLock(&HalpCpeSpinLock);

    // 
    // Unmap the SalSystemTable since we will be mapping all PAL and SAL code, and SAL data area 
    // which includes SST.
    //
    // TEMP TEMP TEMP. we are not unmapping
    //

//  MmUnmapIoSpace((PVOID)HalpSalPalData.SalSystemTable,SstLength);

    //
    // Make sure we found all of our entries for mapping
    //

    if (!(SalCode.Length && SalData.Length && PalCode.Length && FwCode.Length)) {
        HalDebugPrint(( HAL_ERROR, "SAL_PAL: One or more of the SalCode, SalData, PalCode, or FwCode spaces not in SST\n" ));
        HalpSalPalData.Status = STATUS_UNSUCCESSFUL;
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Since PAL will need to use only 1 TR, figure out the page size to use for mapping PAL, 
    // starting at 16KB, and trying 64KB, 256KB, 1MB, 4MB, and 16MB.
    //

    HalpSalPalData.PalTrSize = SIZE_IN_BYTES_16KB;
    PalTrMask = MASK_16KB;
    PalPageShift = 14;
    LargerThan16Mb = 1;

    while (PalTrMask >= MASK_16MB) {

        // Check if it entirely fits in the given page

        if ( (PalCode.PhysicalAddress + PalCode.Length) <=
            ( (PalCode.PhysicalAddress & PalTrMask) + HalpSalPalData.PalTrSize) ) {
            LargerThan16Mb = 0;
            break;
         }

        // Try the next page size, incrementing in multiples of 4 from 16KB to 16MB

        PalTrMask <<= 2;
        HalpSalPalData.PalTrSize <<= 2;
        PalPageShift += 2;
     }

    //
    // If PAL requires a page size of larger than 16MB, fail.
    //

    if (LargerThan16Mb) {
        HalDebugPrint(( HAL_ERROR, "SAL_PAL: More than 16MB was required to map PAL" ));
        HalpSalPalData.Status = STATUS_UNSUCCESSFUL;
        return STATUS_UNSUCCESSFUL;
    }
    
    //
    // Set the page size aligned address that fits PAL
    //

    HalpSalPalData.PalTrBase = PalCode.PhysicalAddress & PalTrMask;
    
    HalDebugPrint(( HAL_INFO, 
                    "SAL_PAL: For the PAL code located at 0x%I64x - length 0x%I64x, the TrMask is 0x%I64x and TrSize is %d Kbytes\n", 
                    PalCode.PhysicalAddress,
                    PalCode.Length,
                    PalTrMask,
                    HalpSalPalData.PalTrSize/1024 ));

    //
    // Map the PAL code at a architected address reserved for SAL/PAL
    // 
    // PAL is known to have an alignment of 256KB.
    //

    PalCode.VirtualAddress = HAL_PAL_VIRTUAL_ADDRESS + (PalCode.PhysicalAddress - HalpSalPalData.PalTrBase);

    //
    // Setup the ITR and DTRs to map PAL
    //

    PalPteUlong = HalpSalPalData.PalTrBase | VALID_KERNEL_EXECUTE_PTE;

    KeFillFixedEntryTb((PHARDWARE_PTE)&PalPteUlong, 
                       (PVOID)HAL_PAL_VIRTUAL_ADDRESS,
                       PalPageShift,
                       INST_TB_PAL_INDEX);

    KeFillFixedEntryTb((PHARDWARE_PTE)&PalPteUlong, 
                       (PVOID)HAL_PAL_VIRTUAL_ADDRESS,
                       PalPageShift,
                       DATA_TB_PAL_INDEX);

    //
    // SAL has no specific virtual mapping translation requirement. It can use TCs to map the
    // SAL code regions and the SAL data regions.
    // SAL requires virtual address translations for descriptors like PAL code areas (to be able
    // to call PAL for SAL), SAL code, SAL data and NVM areas. SAL_UPDATE_PAL requires a virtual
    // mapping of the FW ROM area to perform the update. The latter could be done using TCs.
    //
    // First check if the SAL code fits in the same page as PAL. 
    // If it does, then use that mapping, otherwise, create a mapping using MmMapIoSpace and 
    // mark it executable.
    //

    if ((SalCode.PhysicalAddress >= HalpSalPalData.PalTrBase) &&
        ((SalCode.PhysicalAddress + SalCode.Length) <= (HalpSalPalData.PalTrBase + HalpSalPalData.PalTrSize))) {

        SalCode.VirtualAddress = HAL_PAL_VIRTUAL_ADDRESS + (SalCode.PhysicalAddress - HalpSalPalData.PalTrBase);

    } 
        else {

            physicalAddr.QuadPart = SalCode.PhysicalAddress;
            SalCode.VirtualAddress = (ULONGLONG) MmMapIoSpace(physicalAddr, (ULONG)SalCode.Length, MmCached);

            if (!SalCode.VirtualAddress) {
                HalDebugPrint(( HAL_ERROR, "SAL_PAL: Failed to map the SAL code region\n" ));
                goto SalPalCleanup;
        }
        HalDebugPrint(( HAL_INFO, "SAL_PAL: Starting to mark %d bytes of SAL code executable\n", SalCode.Length ));

        //
        // Temporarily commented out for Mm bug of clearing the dirty bit.
        // We will enable this.
        //
        // MmSetPageProtection((PVOID)SalCode.VirtualAddress, 
        //                   SalCode.Length,
        //                   0x40 /* PAGE_EXECUTE_READWRITE */);
        //

        MmMappedSalCode=TRUE;
    }

    // 
    // Same check for SAL data:
    //  Check if the SAL data fits in the same page as PAL. 
    //  If it does, then use that mapping, otherwise, create a mapping using MmMapIoSpace
    //

    if ((SalData.PhysicalAddress >= HalpSalPalData.PalTrBase) &&
        ((SalData.PhysicalAddress + SalData.Length) <= (HalpSalPalData.PalTrBase + HalpSalPalData.PalTrSize))) {

        SalData.VirtualAddress = HAL_PAL_VIRTUAL_ADDRESS + (SalData.PhysicalAddress - HalpSalPalData.PalTrBase);

    } else {

        physicalAddr.QuadPart = SalData.PhysicalAddress;
        SalData.VirtualAddress = (ULONGLONG) MmMapIoSpace(physicalAddr, (ULONG)SalData.Length, MmCached);
        if (!SalData.VirtualAddress) {
            HalDebugPrint(( HAL_ERROR, "SAL_PAL: Failed to map the SAL data region\n" ));
            goto SalPalCleanup;     
        }
        MmMappedSalData=TRUE;
    }

    HalDebugPrint(( HAL_INFO, "SAL_PAL: Mapped SAL code for PhysAddr 0x%I64x at VirtAddr 0x%I64x for %d bytes\n"
                              "SAL_PAL: Mapped PAL code for PhysAddr 0x%I64x at VirtAddr 0x%I64x for %d bytes\n"
                              "SAL_PAL: Mapped SAL data for PhysAddr 0x%I64x at VirtAddr 0x%I64x for %d bytes\n",
                              SalCode.PhysicalAddress, SalCode.VirtualAddress, SalCode.Length,
                              PalCode.PhysicalAddress, PalCode.VirtualAddress, PalCode.Length,
                              SalData.PhysicalAddress, SalData.VirtualAddress, SalData.Length 
                 ));

    // Store virtual address pointers of SST, SAL_PROC, PAL_PROC, and GP for use later
    // (VirtualAddr = VirtualAddrBase + PhysicalOffset) where (PhysicalOffset = physicalAddr - PhysicalBase)

    // We are not ensuring SST is within the SAL code area

    // ASSERT((physicalSST > SalCode.PhysicalAddress) && (physicalSST < (SalCode.PhysicalAddress + SalCode.Length)));

    // HalpSalPalData.SalSystemTable =  (PSST_HEADER) (SalCode.VirtualAddress + (physicalSST - SalCode.PhysicalAddress));

    HalpSalProcPointer       = (ULONGLONG) (SalCode.VirtualAddress + (physicalSAL   - SalCode.PhysicalAddress));
    HalpSalProcGlobalPointer = (ULONGLONG) (SalCode.VirtualAddress + (physicalSALGP - SalCode.PhysicalAddress));

    HalpPalProcPointer       = (ULONGLONG) (PalCode.VirtualAddress + (physicalPAL   - PalCode.PhysicalAddress));

    //
    // Go map the firmware code space
    //
    // SAL_UPDATE_PAL requires a virtual mapping of the ROM area to perform the update.
    //

    HalDebugPrint(( HAL_INFO, "SAL_PAL: Mapping and Registering Virtual Address of FwCode area\n" ));

    physicalAddr.QuadPart = FwCode.PhysicalAddress;

    FwCodeSpace = MmMapIoSpace(physicalAddr, (ULONG) FwCode.Length, MmCached);

    //
    // Get the PAL version.
    //

    palStatus = HalCallPal(PAL_VERSION, 
                           0, 
                           0, 
                           0, 
                           NULL, 
                           &minimumPalVersion.ReturnValue, 
                           &HalpSalPalData.PalVersion.ReturnValue, 
                           NULL);

    if (palStatus != SAL_STATUS_SUCCESS) {
        HalDebugPrint(( HAL_ERROR, "SAL_PAL: Get PAL version number failed. Status = d\n" ));
    }

    //
    // Retrieve SmBiosVersion and save the pointer into HalpSalPalData.  Note:
    // HalpGetSmBiosVersion will allocate a buffer for SmBiosVersion.
    //

    HalpSalPalData.SmBiosVersion = HalpGetSmBiosVersion(LoaderBlock);

    //
    // Determine and Initialize HAL private SAL/PAL WorkArounds if any.
    //

    HalpInitSalPalWorkArounds();

    // We completed initialization

    HalDebugPrint(( HAL_INFO, "SAL_PAL: Exiting HalpSalPalInitialization with SUCCESS\n" ));
    return HalpSalPalData.Status;

    // Cleanup the mappings and get out of here...

SalPalCleanup:

    if (MmMappedSalData) {
        MmUnmapIoSpace((PVOID) SalData.VirtualAddress, (ULONG) SalData.Length);
    }
    if (MmMappedSalCode) {
        MmUnmapIoSpace((PVOID) SalCode.VirtualAddress, (ULONG) SalCode.Length);
    }
    HalDebugPrint(( HAL_ERROR, "SAL_PAL: Exiting HalpSalPalInitialization with ERROR!!!\n" ));

    HalpSalPalData.Status = STATUS_UNSUCCESSFUL;    
    return HalpSalPalData.Status;

} // HalpInitSalPal()


PUCHAR
HalpGetSmBiosVersion (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This function retrieves the SmBiosVersion string from the BIOS structure
    table, allocates memory for the buffer, copies the string to the buffer,
    and returns a pointer to this buffer.  If unsuccessful, this function
    returns a NULL.

Arguments:

    LoaderBlock - Pointer to the loader parameter block.


Return Value:

    Pointer to a buffer that contains SmBiosVersion string.

--*/

{
    PSMBIOS_EPS_HEADER SMBiosEPSHeader;
    PDMIBIOS_EPS_HEADER DMIBiosEPSHeader;
    USHORT SMBiosTableLength;
    USHORT SMBiosTableNumberStructures;
    PUCHAR SmBiosVersion;

    PHYSICAL_ADDRESS SMBiosTablePhysicalAddress;
    PUCHAR SMBiosDataVirtualAddress;

    UCHAR Type;
    UCHAR Length;
    UCHAR BiosVersionStringNumber;
    UCHAR chr;
    USHORT i;
    PUCHAR pBuffer;
    BOOLEAN Found;


    if (LoaderBlock->Extension->Size < sizeof(LOADER_PARAMETER_EXTENSION)) {
        HalDebugPrint((HAL_ERROR, "HalpGetSmBiosVersion: Invalid LoaderBlock extension size\n"));
	return NULL;
    }

    SMBiosEPSHeader = (PSMBIOS_EPS_HEADER)LoaderBlock->Extension->SMBiosEPSHeader;

    //
    // Verify SM Bios Header signature
    //

    if ((SMBiosEPSHeader == NULL) || (strncmp((PUCHAR)SMBiosEPSHeader, "_SM_", 4) != 0)) {
        HalDebugPrint((HAL_ERROR, "HalpGetSmBiosVersion: Invalid SMBiosEPSHeader\n"));
	return NULL;
    }

    DMIBiosEPSHeader = (PDMIBIOS_EPS_HEADER)&SMBiosEPSHeader->Signature2[0];

    //
    // Verify DMI Bios Header signature
    //

    if ((DMIBiosEPSHeader == NULL) || (strncmp((PUCHAR)DMIBiosEPSHeader, "_DMI_", 5) != 0)) {
        HalDebugPrint((HAL_ERROR, "HalpGetSmBiosVersion: Invalid DMIBiosEPSHeader\n"));
	return NULL;
    }

    SMBiosTablePhysicalAddress.HighPart = 0;
    SMBiosTablePhysicalAddress.LowPart = DMIBiosEPSHeader->StructureTableAddress;

    SMBiosTableLength = DMIBiosEPSHeader->StructureTableLength;
    SMBiosTableNumberStructures = DMIBiosEPSHeader->NumberStructures;

    //
    // Map SMBiosTable to virtual address
    //

    SMBiosDataVirtualAddress = MmMapIoSpace(SMBiosTablePhysicalAddress,
                                            SMBiosTableLength,
                                            MmCached
                                            );

    if (!SMBiosDataVirtualAddress) {
        HalDebugPrint((HAL_ERROR, "HalpGetSmBiosVersion: Failed to map SMBiosTablePhysicalAddress\n"));
        return NULL;
    }

    //
    // The Spec doesn't say that SmBios Type 0 structure has to be the first
    // structure at this entry point... so we have to traverse through memory
    // to find the right one.
    //

    i = 0;
    Found = FALSE;
    while (i < SMBiosTableNumberStructures && !Found) {
        i++;
        Type = (UCHAR)SMBiosDataVirtualAddress[SMBIOS_STRUCT_HEADER_TYPE_FIELD];

	if (Type == 0) {
	    Found = TRUE;
	} 
	else {

            //
	    // Advance to the next structure
	    //

            SMBiosDataVirtualAddress += SMBiosDataVirtualAddress[SMBIOS_STRUCT_HEADER_LENGTH_FIELD];

	    // Get pass trailing string-list by looking for a double-null
	    while (*(PUSHORT)SMBiosDataVirtualAddress != 0) { 
	        SMBiosDataVirtualAddress++;
	    }
	    SMBiosDataVirtualAddress += 2;
	}
    }

    if (!Found) {
        HalDebugPrint((HAL_ERROR, "HalpGetSmBiosVersion: Could not find Type 0 structure\n"));
	return NULL;
    }


    //
    // Extract BIOS Version string from the SmBios Type 0 Structure
    //

    Length = SMBiosDataVirtualAddress[SMBIOS_STRUCT_HEADER_LENGTH_FIELD];
    BiosVersionStringNumber = SMBiosDataVirtualAddress[SMBIOS_TYPE0_STRUCT_BIOSVER_FIELD];

    //
    // Text strings begin right after the formatted portion of the structure.
    //

    pBuffer = (PUCHAR)&SMBiosDataVirtualAddress[Length];
    
    //
    // Get to the beginning of SmBiosVersion string
    //

    for (i = 0; i < BiosVersionStringNumber - 1; i++) {
        do {
            chr = *pBuffer;
            pBuffer++;
        } while (chr != '\0');
    }

    //
    // Allocate memory for SmBiosVersion string and copy content of
    // pBuffer to SmBiosVersion.
    //

    SmBiosVersion = ExAllocatePool(NonPagedPool, strlen(pBuffer)+1);

    if (!SmBiosVersion) {
        HalDebugPrint((HAL_ERROR, "HalpGetSmBiosVersion: Failed to allocate memory for SmBiosVersion\n"));
        return NULL;
    }

    strcpy(SmBiosVersion, pBuffer);

    MmUnmapIoSpace(SMBiosDataVirtualAddress,
                   SMBiosTableLength
		   );

    return SmBiosVersion;
}


VOID
HalpInitSalPalNonBsp(
    VOID
    )

/*++

Routine Description:

    This function is called for the non-BSP processors to simply set up the same
    TR registers that HalpInitSalPal does for the BSP processor.

Arguments:

    None

Return Value:

    None

--*/

{
    ULONG PalPageShift;
    ULONGLONG PalPteUlong;
    ULONGLONG PalTrSize;

    // If we successfully initialized in HalpSalPalInitialization, then set-up the TR

    if (!NT_SUCCESS(HalpSalPalData.Status)) {
        return;
    }

    PalTrSize = HalpSalPalData.PalTrSize;
    PalPageShift = 14;

    while (PalTrSize > ((ULONGLONG)1 << PalPageShift)) {
        PalPageShift += 2;
    }

    PalPteUlong = HalpSalPalData.PalTrBase | VALID_KERNEL_EXECUTE_PTE;

    KeFillFixedEntryTb((PHARDWARE_PTE)&PalPteUlong, 
                       (PVOID)HAL_PAL_VIRTUAL_ADDRESS,
                       PalPageShift,
                       INST_TB_PAL_INDEX);

    KeFillFixedEntryTb((PHARDWARE_PTE)&PalPteUlong, 
                       (PVOID)HAL_PAL_VIRTUAL_ADDRESS,
                       PalPageShift,
                       DATA_TB_PAL_INDEX);

} // HalpInitSalPalNonBsp()


NTSTATUS
HalpEfiInitialization(
    PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This function 

Arguments:

    LoaderBlock - Supplies a pointer to the Loader parameter block, containing the
    physical address of the EFI system table.

Return Value:

    STATUS_SUCCESS is returned if the mappings were successful, and EFI calls can
    be made.  Otherwise, STATUS_UNSUCCESSFUL is returned.
    

--*/

{

//
// Local declarations
//

    EFI_MEMORY_DESCRIPTOR *efiMapEntryPtr, *efiVirtualMemoryMapPtr;
    EFI_STATUS             status;
    ULONGLONG              index, mapEntries;
                                                                                             
    ULONGLONG physicalEfiST, physicalEfiMemoryMapPtr, physicalRunTimeServicesPtr;
    ULONGLONG physicalEfiGetVariable, physicalEfiGetNextVariableName, physicalEfiSetVariable;
    ULONGLONG physicalEfiGetTime, physicalEfiSetTime;
    ULONGLONG physicalEfiSetVirtualAddressMap, physicalEfiResetSystem;

    PHYSICAL_ADDRESS  physicalAddr;
    
    ULONGLONG         physicalPlabel_Fpswa;
   
    FPSWA_INTERFACE  *interfacePtr;
    PVOID             tmpPtr;
    
    //
    // First, get the physical address of the fpswa entry point PLABEL.
    //
    if (LoaderBlock->u.Ia64.FpswaInterface != (ULONG_PTR) NULL) {
        physicalAddr.QuadPart = LoaderBlock->u.Ia64.FpswaInterface;
        interfacePtr = MmMapIoSpace(physicalAddr,
                                    sizeof(FPSWA_INTERFACE),
                                    MmCached
                                   );

        if (interfacePtr == NULL) {
            HalDebugPrint(( HAL_FATAL_ERROR, "FpswaInterfacePtr is Null. Efi handle not available\n")); 
            KeBugCheckEx(FP_EMULATION_ERROR, 0, 0, 0, 0);
            return STATUS_UNSUCCESSFUL;
        }
 
        physicalPlabel_Fpswa = (ULONGLONG)(interfacePtr->Fpswa);
    }
    else {
        HalDebugPrint(( HAL_FATAL_ERROR, "HAL: EFI FpswaInterface is not available\n"));
        KeBugCheckEx(FP_EMULATION_ERROR, 0, 0, 0, 0);
        return STATUS_UNSUCCESSFUL;
    }

    physicalEfiST =  LoaderBlock->u.Ia64.EfiSystemTable;
     
    physicalAddr.QuadPart = physicalEfiST;

    EfiSysTableVirtualPtr = MmMapIoSpace( physicalAddr, sizeof(EFI_SYSTEM_TABLE), MmCached); 

    if (EfiSysTableVirtualPtr == NULL) {

            HalDebugPrint(( HAL_ERROR, "HAL: EfiSystem Table Virtual Addr is NULL\n" ));
            
            EfiInitStatus = STATUS_UNSUCCESSFUL;

            return STATUS_UNSUCCESSFUL;

    }

    EfiSysTableVirtualPtrCpy = EfiSysTableVirtualPtr;

    physicalRunTimeServicesPtr = (ULONGLONG) EfiSysTableVirtualPtr->RuntimeServices;
    physicalAddr.QuadPart = physicalRunTimeServicesPtr;

    EfiRSVirtualPtr       = MmMapIoSpace(physicalAddr, sizeof(EFI_RUNTIME_SERVICES),MmCached);
    
    if (EfiRSVirtualPtr == NULL) {

            HalDebugPrint(( HAL_ERROR, "HAL: Run Time Table Virtual Addr is NULL\n" ));
            
            EfiInitStatus = STATUS_UNSUCCESSFUL;

            return STATUS_UNSUCCESSFUL;
    }


    EfiMemoryMapSize         = LoaderBlock->u.Ia64.EfiMemMapParam.MemoryMapSize; 

    EfiDescriptorSize        = LoaderBlock->u.Ia64.EfiMemMapParam.DescriptorSize;

    EfiDescriptorVersion     = LoaderBlock->u.Ia64.EfiMemMapParam.DescriptorVersion;
    

    physicalEfiMemoryMapPtr = (ULONGLONG)LoaderBlock->u.Ia64.EfiMemMapParam.MemoryMap;
    physicalAddr.QuadPart   = physicalEfiMemoryMapPtr;
    efiVirtualMemoryMapPtr  = MmMapIoSpace (physicalAddr, EfiMemoryMapSize, MmCached);

    if (efiVirtualMemoryMapPtr == NULL) {

            HalDebugPrint(( HAL_ERROR, "HAL: Virtual Set Memory Map Virtual Addr is NULL\n" ));
            
            EfiInitStatus = STATUS_UNSUCCESSFUL;

            return STATUS_UNSUCCESSFUL;
    }

    //
    // #define VENDOR_SPECIFIC_GUID    \
    // { 0xa3c72e56, 0x4c35, 0x11d3, 0x8a, 0x03, 0x0, 0xa0, 0xc9, 0x06, 0xad, 0xec }
    //

    VendorGuid.Data1    =  0x8be4df61;
    VendorGuid.Data2    =  0x93ca;
    VendorGuid.Data3    =  0x11d2;
    VendorGuid.Data4[0] =  0xaa;
    VendorGuid.Data4[1] =  0x0d;
    VendorGuid.Data4[2] =  0x00;
    VendorGuid.Data4[3] =  0xe0;
    VendorGuid.Data4[4] =  0x98;
    VendorGuid.Data4[5] =  0x03;
    VendorGuid.Data4[6] =  0x2b;
    VendorGuid.Data4[7] =  0x8c;

    HalDebugPrint(( HAL_INFO, 
                    "HAL: EFI SystemTable     VA = 0x%I64x, PA = 0x%I64x\n"
                    "HAL: EFI RunTimeServices VA = 0x%I64x, PA = 0x%I64x\n"
                    "HAL: EFI MemoryMapPtr    VA = 0x%I64x, PA = 0x%I64x\n"
                    "HAL: EFI MemoryMap     Size = 0x%I64x\n"
                    "HAL: EFI Descriptor    Size = 0x%I64x\n",
                    EfiSysTableVirtualPtr, 
                    physicalEfiST,
                    EfiRSVirtualPtr, 
                    physicalRunTimeServicesPtr,
                    efiVirtualMemoryMapPtr, 
                    physicalEfiMemoryMapPtr,
                    EfiMemoryMapSize,
                    EfiDescriptorSize
                    ));

    // GetVariable

    physicalEfiGetVariable = (ULONGLONG) (EfiRSVirtualPtr -> GetVariable);
    physicalAddr.QuadPart  = physicalEfiGetVariable;

    EfiVirtualGetVariablePtr = MmMapIoSpace (physicalAddr, sizeof(PLABEL_DESCRIPTOR), MmCached);
     
    if (EfiVirtualGetVariablePtr == NULL) {

            HalDebugPrint(( HAL_ERROR, "HAL: EfiGetVariable Virtual Addr is NULL\n" ));
            
            EfiInitStatus = STATUS_UNSUCCESSFUL;

            return STATUS_UNSUCCESSFUL;
    }

    HalDebugPrint(( HAL_INFO, "HAL: EFI GetVariable     VA = 0x%I64x, PA = 0x%I64x\n",
                    EfiVirtualGetVariablePtr, physicalEfiGetVariable ));
    
    // GetNextVariableName

    physicalEfiGetNextVariableName =  (ULONGLONG) (EfiRSVirtualPtr -> GetNextVariableName);
    physicalAddr.QuadPart  = physicalEfiGetNextVariableName;

    EfiVirtualGetNextVariableNamePtr = MmMapIoSpace (physicalAddr,sizeof(PLABEL_DESCRIPTOR),MmCached);

     
    if (EfiVirtualGetNextVariableNamePtr == NULL) {

            HalDebugPrint(( HAL_ERROR, "HAL: EfiVirtual Get Next Variable Name Ptr Addr is NULL\n" ));
            
            EfiInitStatus = STATUS_UNSUCCESSFUL;

            return STATUS_UNSUCCESSFUL;
    }

	
    //SetVariable

    physicalEfiSetVariable = (ULONGLONG) (EfiRSVirtualPtr -> SetVariable);
    physicalAddr.QuadPart  = physicalEfiSetVariable;

    EfiVirtualSetVariablePtr = MmMapIoSpace (physicalAddr, sizeof(PLABEL_DESCRIPTOR), MmCached);
     
    if (EfiVirtualSetVariablePtr == NULL) {

            HalDebugPrint(( HAL_ERROR, "HAL: EfiVariableSetVariable Pointer dr is NULL\n" ));
            
            EfiInitStatus = STATUS_UNSUCCESSFUL;

            return STATUS_UNSUCCESSFUL;
    }


    HalDebugPrint(( HAL_INFO, "HAL: EFI Set Variable    VA = 0x%I64x, PA = 0x%I64x\n",
                    EfiVirtualSetVariablePtr, physicalEfiSetVariable ));
    

    //GetTime

    physicalEfiGetTime = (ULONGLONG) (EfiRSVirtualPtr -> GetTime);
    physicalAddr.QuadPart  = physicalEfiGetTime;

    EfiVirtualGetTimePtr = MmMapIoSpace (physicalAddr, sizeof(PLABEL_DESCRIPTOR), MmCached);
     
    if (EfiVirtualGetTimePtr == NULL) {

            HalDebugPrint(( HAL_ERROR, "HAL: EfiGetTime Virtual Addr is NULL\n" ));
            
            EfiInitStatus = STATUS_UNSUCCESSFUL;

            return STATUS_UNSUCCESSFUL;
    }


    HalDebugPrint(( HAL_INFO, "HAL: EFI GetTime         VA = 0x%I64x, PA = 0x%I64x\n",
                    EfiVirtualGetTimePtr, physicalEfiGetTime ));

	
    //SetTime

	physicalEfiSetTime = (ULONGLONG) (EfiRSVirtualPtr -> SetTime);
    physicalAddr.QuadPart  = physicalEfiSetTime;

    EfiVirtualSetTimePtr = MmMapIoSpace (physicalAddr, sizeof(PLABEL_DESCRIPTOR), MmCached);
     
    if (EfiVirtualSetTimePtr == NULL) {

            HalDebugPrint(( HAL_ERROR, "HAL: EfiSetTime Virtual Addr is NULL\n" ));
            
            EfiInitStatus = STATUS_UNSUCCESSFUL;

            return STATUS_UNSUCCESSFUL;
    }


    HalDebugPrint(( HAL_INFO, "HAL: EFI SetTime         VA = 0x%I64x, PA = 0x%I64x\n",
                    EfiVirtualSetTimePtr, physicalEfiSetTime ));

	
    //SetVirtualAddressMap   

    physicalEfiSetVirtualAddressMap = (ULONGLONG) (EfiRSVirtualPtr -> SetVirtualAddressMap);
    physicalAddr.QuadPart  = physicalEfiSetVirtualAddressMap;

    EfiSetVirtualAddressMapPtr = MmMapIoSpace (physicalAddr, sizeof(PLABEL_DESCRIPTOR), MmCached);
     
    if (EfiSetVirtualAddressMapPtr == NULL) {

            HalDebugPrint(( HAL_ERROR, "HAL: Efi Set VirtualMapPointer Virtual  Addr is NULL\n" ));
            
            EfiInitStatus = STATUS_UNSUCCESSFUL;

            return STATUS_UNSUCCESSFUL;
    }
    
    
    HalDebugPrint(( HAL_INFO, "HAL: EFI SetVirtualAddressMap VA = 0x%I64x, PA = 0x%I64x\n",
                    EfiSetVirtualAddressMapPtr, physicalEfiSetVirtualAddressMap ));


    //ResetSystem

    physicalEfiResetSystem = (ULONGLONG) (EfiRSVirtualPtr -> ResetSystem);
    physicalAddr.QuadPart  = physicalEfiResetSystem;

    EfiResetSystemPtr = MmMapIoSpace (physicalAddr, sizeof(PLABEL_DESCRIPTOR), MmCached);

    if (EfiResetSystemPtr == NULL) {
       HalDebugPrint(( HAL_ERROR,"HAL: Efi Reset System Virtual  Addr is NULL\n" ));
       EfiInitStatus = STATUS_UNSUCCESSFUL;
       return STATUS_UNSUCCESSFUL;
    }

    HalDebugPrint(( HAL_INFO, "HAL: EFI ResetSystem     VA = 0x%I64x, PA = 0x%I64x\n",
                  EfiResetSystemPtr, physicalEfiResetSystem ));

    
    //
    // Allocate one page for Backing store
    // 

    physicalAddr.QuadPart = 0xffffffffffffffffI64;

    tmpPtr            = MmAllocateContiguousMemory( PAGE_SIZE, physicalAddr );
    HalpPhysBSPointer = (PULONGLONG)( ( MmGetPhysicalAddress( tmpPtr ) ).QuadPart );

    //
    // Allocate one page for the Stack, then make sure the base pointer
    // is assigned to the high address of this block since the stack
    // grows down.
    //

    tmpPtr                = MmAllocateContiguousMemory( PAGE_SIZE, physicalAddr );
    HalpPhysStackPointer  = (PULONGLONG)( ( MmGetPhysicalAddress( tmpPtr ) ).QuadPart + PAGE_SIZE - 16);
    
    HalpVirtualCommonDataPointer = (PUCHAR)(ExAllocatePool (NonPagedPool, PAGE_SIZE));
    
        
    HalpVariableNameVirtualPtr       = HalpVirtualCommonDataPointer + VariableNameOffset;
    HalpVendorGuidVirtualPtr         = HalpVirtualCommonDataPointer + VendorGuidOffset;
    HalpVariableAttributesVirtualPtr = HalpVirtualCommonDataPointer + AttributeOffset;
    HalpDataSizeVirtualPtr           = HalpVirtualCommonDataPointer + DataSizeOffset; 
    HalpDataVirtualPtr               = HalpVirtualCommonDataPointer + DataBufferOffset;
    HalpCommonDataEndPtr             = HalpVirtualCommonDataPointer + EndOfCommonDataOffset;
    
    HalpMemoryMapSizeVirtualPtr      = HalpVirtualCommonDataPointer + MemoryMapSizeOffset;
    HalpMemoryMapVirtualPtr          = (PUCHAR)(HalpVirtualCommonDataPointer + MemoryMapOffset);
    HalpDescriptorSizeVirtualPtr     = HalpVirtualCommonDataPointer + DescriptorSizeOffset;
    HalpDescriptorVersionVirtualPtr  = HalpVirtualCommonDataPointer + DescriptorVersionOffset;
    
    
    HalpPhysCommonDataPointer = (PUCHAR)((MmGetPhysicalAddress(HalpVirtualCommonDataPointer)).QuadPart);
    

    HalpVariableNamePhysPtr          = HalpPhysCommonDataPointer + VariableNameOffset;
    HalpVendorGuidPhysPtr            = HalpPhysCommonDataPointer + VendorGuidOffset;
    HalpVariableAttributesPhysPtr    = HalpPhysCommonDataPointer + AttributeOffset;
    HalpDataSizePhysPtr              = HalpPhysCommonDataPointer + DataSizeOffset; 
    HalpDataPhysPtr                  = HalpPhysCommonDataPointer + DataBufferOffset;
    

    HalpMemoryMapSizePhysPtr         = HalpPhysCommonDataPointer + MemoryMapSizeOffset;
    HalpMemoryMapPhysPtr             = HalpPhysCommonDataPointer + MemoryMapOffset;
    HalpDescriptorSizePhysPtr        = HalpPhysCommonDataPointer + DescriptorSizeOffset;
    HalpDescriptorVersionPhysPtr     = HalpPhysCommonDataPointer + DescriptorVersionOffset;


    AttributePtr             = &EfiAttribute;
    
    DataSizePtr              = &EfiDataSize; 
    
    RtlCopyMemory ((PULONGLONG)HalpMemoryMapVirtualPtr,
                   efiVirtualMemoryMapPtr,
                   (ULONG)(EfiMemoryMapSize)
                  );

    //
    // Now, extract SAL, PAL information from the loader parameter block and 
    // initializes HAL SAL, PAL definitions.
    //
    // N.B 10/2000: 
    //  We do not check the return status of HalpInitSalPal(). We should. FIXFIX.
    //  In case of failure, we currently flag HalpSalPalData.Status as unsuccessful.
    //

    HalpInitSalPal(LoaderBlock);
    
    //    
    // Initialize Spin Lock
    //
    
    KeInitializeSpinLock(&EFIMPLock);

    ASSERT (EfiDescriptorVersion == EFI_MEMORY_DESCRIPTOR_VERSION);

    // if (EfiDescriptorVersion != EFI_MEMORY_DESCRIPTION_VERSION) {

    //    HalDebugPrint(HAL_ERROR,("Efi Memory Map Pointer VAddr is NULL\n"));
   
    //    EfiInitStatus = STATUS_UNSUCCESSFUL;

    //    return STATUS_UNSUCCESSFUL;
    // }
    
    HalDebugPrint(( HAL_INFO, "HAL: Creating EFI virtual address mapping\n" ));
    
    efiMapEntryPtr = efiVirtualMemoryMapPtr;
    
    if (efiMapEntryPtr == NULL) {

        HalDebugPrint(( HAL_ERROR, "HAL: Efi Memory Map Pointer VAddr is NULL\n" ));
   
        EfiInitStatus = STATUS_UNSUCCESSFUL;

        return STATUS_UNSUCCESSFUL;
    }

    mapEntries = EfiMemoryMapSize/EfiDescriptorSize;

    HalDebugPrint(( HAL_INFO, "HAL: EfiMemoryMapSize: 0x%I64x & EfiDescriptorSize: 0x%I64x & #of entries: 0x%I64x\n",
                    EfiMemoryMapSize,
                    EfiDescriptorSize,
                    mapEntries ));

    HalDebugPrint(( HAL_INFO, "HAL: Efi RunTime Attribute will be printed as 1\n" ));
    

    for (index = 0; index < mapEntries; index= index + 1) {
        
        BOOLEAN attribute = 0; 

        physicalAddr.QuadPart = efiMapEntryPtr -> PhysicalStart;
        if ((efiMapEntryPtr->Attribute) & EFI_MEMORY_RUNTIME) {
            attribute = 1;
            switch (efiMapEntryPtr->Type) {
                case EfiRuntimeServicesData:
                case EfiReservedMemoryType:
                    efiMapEntryPtr->VirtualStart = (ULONGLONG) (MmMapIoSpace (physicalAddr,
                                                (SIZE_T)((EFI_PAGE_SIZE)*(efiMapEntryPtr->NumberOfPages)),
                                                           (efiMapEntryPtr->Attribute & EFI_MEMORY_WB) ? MmCached : MmNonCached
                                                           ));
                
                
                    if ((efiMapEntryPtr->VirtualStart) == 0) {

                        HalDebugPrint(( HAL_ERROR, "HAL: Efi RunTimeSrvceData/RsrvdMemory area VAddr is NULL\n" ));
                        
                        EfiInitStatus = STATUS_UNSUCCESSFUL;

                        return STATUS_UNSUCCESSFUL;
                    }


                    HalDebugPrint(( HAL_INFO,
                        "HAL: Efi attribute %d & Type 0x%I64x with # of 4k pages 0x%I64x at PA 0x%I64x & mapped to VA 0x%I64x\n",
                        attribute,
                        efiMapEntryPtr->Type,
                        efiMapEntryPtr->NumberOfPages,
                        efiMapEntryPtr->PhysicalStart,
                        efiMapEntryPtr->VirtualStart ));

                    break;

                case EfiPalCode:

                    efiMapEntryPtr->VirtualStart = PalCode.VirtualAddress;

                    HalDebugPrint(( HAL_INFO,
                        "HAL: Efi attribute %d & Type 0x%I64x with # of 4K pages 0x%I64x at PA 0x%I64x & mapped to VA 0x%I64x\n",
                        attribute,
                        efiMapEntryPtr->Type,
                        efiMapEntryPtr->NumberOfPages,
                        efiMapEntryPtr->PhysicalStart,
                        efiMapEntryPtr->VirtualStart ));
    
                    break;

                case EfiRuntimeServicesCode:
                    if(physicalAddr.QuadPart != OptionROMAddress) {
                
                    efiMapEntryPtr->VirtualStart = (ULONGLONG) (MmMapIoSpace (physicalAddr,
                                                     (EFI_PAGE_SIZE) * (efiMapEntryPtr->NumberOfPages),
                                                      MmCached
                                                      ));

                    if ((efiMapEntryPtr->VirtualStart) == 0) {

                        HalDebugPrint(( HAL_ERROR, "HAL: Efi RunTimeSrvceCode area VAddr is NULL\n" ));
                        
                        EfiInitStatus = STATUS_UNSUCCESSFUL;

                        return STATUS_UNSUCCESSFUL;
                     }
                 
                    //
                    // Give Execution previlege
                    //
                    //                
                    // Temporarily commented out. Will be enabled once Mm does not clear dirty bit here.
                    //
                    // MmSetPageProtection ((PVOID)(efiMapEntryPtr->VirtualStart),
                    //                      (EFI_PAGE_SIZE) * (efiMapEntryPtr->NumberOfPages),
                    //                       0x40 /* PAGE_EXECUTE_READWRITE */
                    //                      );
                
                    HalDebugPrint(( HAL_INFO,
                        "HAL: Efi attribute %d & Type 0x%I64x with # of 4K pages 0x%I64x at PA 0x%I64x & mapped to VA 0x%I64x\n",
                        attribute,
                        efiMapEntryPtr->Type,
                        efiMapEntryPtr->NumberOfPages,
                        efiMapEntryPtr->PhysicalStart,
                        efiMapEntryPtr->VirtualStart));
                    break;
                
                    } else {
                        efiMapEntryPtr->VirtualStart = OptionROMAddress;
                        HalDebugPrint(( HAL_INFO,
                            "HAL: Efi attribute %d & Type 0x%I64x with # of 4K pages 0x%I64x at PA 0x%I64x. NOT MAPPED\n",
                            attribute,
                            efiMapEntryPtr->Type,
                            efiMapEntryPtr->NumberOfPages,
                            efiMapEntryPtr->PhysicalStart ));
                        break;
                    }
                case EfiMemoryMappedIO:
                    efiMapEntryPtr->VirtualStart = (ULONGLONG) (MmMapIoSpace (physicalAddr,
                                                      (EFI_PAGE_SIZE) * (efiMapEntryPtr->NumberOfPages),
                                                      MmNonCached
                                                      ));

                    if ((efiMapEntryPtr->VirtualStart) == 0) {

                        HalDebugPrint(( HAL_ERROR, "HAL: Efi MemoryMappedIO VAddr is NULL\n" ));
                        
                        EfiInitStatus = STATUS_UNSUCCESSFUL;

                        return STATUS_UNSUCCESSFUL;
                    }
                
                    HalDebugPrint(( HAL_INFO,
                        "HAL: Efi attribute %d & Type 0x%I64x with # of 4K pages 0x%I64x at PA 0x%I64x & mapped to VA 0x%I64x\n",
                        attribute,
                        efiMapEntryPtr->Type,
                        efiMapEntryPtr->NumberOfPages,
                        efiMapEntryPtr->PhysicalStart,
                        efiMapEntryPtr->VirtualStart ));
                     break;
                
                case EfiMemoryMappedIOPortSpace:

                    efiMapEntryPtr->VirtualStart = VIRTUAL_IO_BASE;
                    HalDebugPrint(( HAL_INFO,
                        "HAL: Efi attribute %d & Type 0x%I64x with # of 4K pages 0x%I64x at PA 0x%I64x ALREADY mapped to VA 0x%I64x\n",
                        attribute,
                        efiMapEntryPtr->Type,
                        efiMapEntryPtr->NumberOfPages,
                        efiMapEntryPtr->PhysicalStart,
                        efiMapEntryPtr->VirtualStart ));
                    break;

                default:
                    
                    HalDebugPrint(( HAL_INFO, "HAL: Efi CONTROL SHOULD NOT COME HERE \n" ));
                    
                    EfiInitStatus = STATUS_UNSUCCESSFUL;

                    return STATUS_UNSUCCESSFUL;

                    break;
            }
            
        } else {

                HalDebugPrint(( HAL_INFO,
                    "HAL: Efi attribute %d & Type 0x%I64x with # of 4K pages 0x%I64x at PA 0x%I64x ALREADY mapped to VA 0x%I64x\n",
                    attribute,
                    efiMapEntryPtr->Type,
                    efiMapEntryPtr->NumberOfPages,
                    efiMapEntryPtr->PhysicalStart,
                    efiMapEntryPtr->VirtualStart ));

        }

        efiMapEntryPtr = NextMemoryDescriptor(efiMapEntryPtr,EfiDescriptorSize);
    }

    
    status = HalpCallEfi(EFI_SET_VIRTUAL_ADDRESS_MAP_INDEX,
                         (ULONGLONG)EfiMemoryMapSize,
                         (ULONGLONG)EfiDescriptorSize,
                         (ULONGLONG)EfiDescriptorVersion,
                         (ULONGLONG)efiVirtualMemoryMapPtr,
                         0,
                         0,
                         0,
                         0
                         );

    
    HalDebugPrint(( HAL_INFO, "HAL: Returned from SetVirtualAddressMap: 0x%Ix\n", status ));

    if (EFI_ERROR( status )) {

        EfiInitStatus = STATUS_UNSUCCESSFUL;

        return STATUS_UNSUCCESSFUL;
    
    } 

    HalDebugPrint(( HAL_INFO, "HAL: EFI Virtual Address mapping done...\n" ));

    EfiInitStatus = STATUS_SUCCESS;

    //
    // Execute some validity checks on the floating point software assist.
    //

    if (LoaderBlock->u.Ia64.FpswaInterface != (ULONG_PTR) NULL) {
        PPLABEL_DESCRIPTOR plabelPointer;

        HalpFpEmulate = interfacePtr->Fpswa;
        if (HalpFpEmulate == NULL ) {
            HalDebugPrint(( HAL_FATAL_ERROR, "HAL: EfiFpswa Virtual Addr is NULL\n" ));
            KeBugCheckEx(FP_EMULATION_ERROR, 0, 0, 0, 0);
            EfiInitStatus = STATUS_UNSUCCESSFUL;
            return STATUS_UNSUCCESSFUL;
        }
    
        plabelPointer = (PPLABEL_DESCRIPTOR) HalpFpEmulate;
        if ((plabelPointer->EntryPoint & 0xe000000000000000) == 0) {

            HalDebugPrint(( HAL_FATAL_ERROR, "HAL: EfiFpswa Instruction Addr is bougus\n" ));
            KeBugCheckEx(FP_EMULATION_ERROR, 0, 0, 0, 0);
        }
        
    }

    return STATUS_SUCCESS;

} // HalpEfiInitialization()



EFI_STATUS
HalpCallEfi(
    IN ULONGLONG FunctionId,
    IN ULONGLONG Arg1,
    IN ULONGLONG Arg2,
    IN ULONGLONG Arg3,
    IN ULONGLONG Arg4,
    IN ULONGLONG Arg5,
    IN ULONGLONG Arg6,
    IN ULONGLONG Arg7,
    IN ULONGLONG Arg8
    )

/*++

Routine Description:
                                                                :9
    This function is a wrapper function for making a EFI call.  Callers within the
    HAL must use this function to call the EFI.

Arguments:

    FunctionId - The EFI function 
    Arg1-Arg7 - EFI defined arguments for each call
    ReturnValues - A pointer to an array of 4 64-bit return values

Return Value:

    SAL's return status, return value 0, is returned in addition to the ReturnValues structure
    being filled

--*/

{
    ULONGLONG EP, GP;
    EFI_STATUS efiStatus;

    //
    // Storage for old level
    //

    KIRQL OldLevel;


    if (((FunctionId != EFI_SET_VIRTUAL_ADDRESS_MAP_INDEX) || (FunctionId != EFI_RESET_SYSTEM_INDEX)) 
         && (!NT_SUCCESS(EfiInitStatus))) {

        return EFI_UNSUPPORTED;

    }
  
    switch (FunctionId) {

    case EFI_GET_VARIABLE_INDEX:
            
        //
        // Dereference the pointer to get the function arguements
        //

        EP = ((PPLABEL_DESCRIPTOR)EfiVirtualGetVariablePtr) -> EntryPoint;
        GP = ((PPLABEL_DESCRIPTOR)EfiVirtualGetVariablePtr) -> GlobalPointer;

        //
        // Acquire MP Lock 
        //

        KeAcquireSpinLock (&EFIMPLock, &OldLevel); 

        efiStatus = (HalpCallEfiVirtual( (ULONGLONG)Arg1,               // VariableNamePtr 
                                         (ULONGLONG)Arg2,               // VendorGuidPtr 
                                         (ULONGLONG)Arg3,               // VariableAttributesPtr, 
                                         (ULONGLONG)Arg4,               // DataSizePtr, 
                                         (ULONGLONG)Arg5,               // DataPtr, 
                                         Arg6,
                                         EP,
                                         GP
                                         ));

        //
        // Release the MP Lock
        // 

        KeReleaseSpinLock (&EFIMPLock, OldLevel); 

        break;
    
    case EFI_SET_VARIABLE_INDEX:
            
        //
        // Dereference the pointer to get the function arguements
        //
    
        EP = ((PPLABEL_DESCRIPTOR)EfiVirtualSetVariablePtr) -> EntryPoint;
        GP = ((PPLABEL_DESCRIPTOR)EfiVirtualSetVariablePtr) -> GlobalPointer;

 
        //
        // Acquire MP Lock 
        //

        KeAcquireSpinLock (&EFIMPLock, &OldLevel); 

        efiStatus = (HalpCallEfiVirtual(  Arg1,
                                          Arg2, 
                                          Arg3, 
                                          Arg4, 
                                          Arg5, 
                                          Arg6,
                                          EP,
                                          GP
                                          ));

        //
        // Release the MP Lock
        // 

        KeReleaseSpinLock (&EFIMPLock, OldLevel); 

        break;

    case EFI_GET_NEXT_VARIABLE_NAME_INDEX:
            
        //
        // Dereference the pointer to get the function arguements
        //
    
        EP = ((PPLABEL_DESCRIPTOR)EfiVirtualGetNextVariableNamePtr) -> EntryPoint;
        GP = ((PPLABEL_DESCRIPTOR)EfiVirtualGetNextVariableNamePtr) -> GlobalPointer;

 
        //
        // Acquire MP Lock 
        //

        KeAcquireSpinLock (&EFIMPLock, &OldLevel); 

        efiStatus = (HalpCallEfiVirtual(  Arg1,
                                          Arg2, 
                                          Arg3, 
                                          Arg4, 
                                          Arg5, 
                                          Arg6,
                                          EP,
                                          GP
                                          ));

        //
        // Release the MP Lock
        // 

        KeReleaseSpinLock (&EFIMPLock, OldLevel); 

        break;


	case EFI_GET_TIME_INDEX:
    
            //
            // Dereference the pointer to get the function arguements
            //

            EP = ((PPLABEL_DESCRIPTOR)EfiVirtualGetTimePtr) -> EntryPoint;
            GP = ((PPLABEL_DESCRIPTOR)EfiVirtualGetTimePtr) -> GlobalPointer;

            //
            // Acquire MP Lock 
            //

            KeAcquireSpinLock (&EFIMPLock, &OldLevel); 
            
            efiStatus = (HalpCallEfiVirtual ((ULONGLONG)Arg1,  //EFI_TIME
                                             (ULONGLONG)Arg2,  //EFI_TIME Capabilities
                                             Arg3,
                                             Arg4,
                                             Arg5,
                                             Arg6,
                                             EP,
                                             GP
                                             ));

            //
            // Release the MP Lock
            // 

            KeReleaseSpinLock (&EFIMPLock, OldLevel); 
            
            break;

            
	case EFI_SET_TIME_INDEX:
    
            //
            // Dereference the pointer to get the function arguements
            //

            EP = ((PPLABEL_DESCRIPTOR)EfiVirtualSetTimePtr) -> EntryPoint;
            GP = ((PPLABEL_DESCRIPTOR)EfiVirtualSetTimePtr) -> GlobalPointer;

            //
            // Acquire MP Lock 
            //

            KeAcquireSpinLock (&EFIMPLock, &OldLevel); 
            
            efiStatus = (HalpCallEfiVirtual ((ULONGLONG)Arg1,  //EFI_TIME
                                             Arg2,
                                             Arg3,
                                             Arg4,
                                             Arg5,
                                             Arg6,
                                             EP,
                                             GP
                                             ));

            //
            // Release the MP Lock
            // 

            KeReleaseSpinLock (&EFIMPLock, OldLevel); 
            
            break;

            
    case EFI_SET_VIRTUAL_ADDRESS_MAP_INDEX:
                
        //
        // Dereference the pointer to get the function arguements
        //
        
        EP = ((PPLABEL_DESCRIPTOR)EfiSetVirtualAddressMapPtr) -> EntryPoint;
        GP = ((PPLABEL_DESCRIPTOR)EfiSetVirtualAddressMapPtr) -> GlobalPointer;

     
        //
        // Arg 1 and 5 are virtual mode pointers. We need to convert to physical 
        //
        
        RtlCopyMemory (HalpMemoryMapVirtualPtr,
                      (PULONGLONG)Arg4,
                      (ULONG)EfiMemoryMapSize
                      );
            
        
        //
        // Acquire MP Lock 
        //
   
        KeAcquireSpinLock (&EFIMPLock, &OldLevel); 
    


        efiStatus = (HalpCallEfiPhysical ((ULONGLONG)EfiMemoryMapSize, 
                                         (ULONGLONG)EfiDescriptorSize, 
                                         (ULONGLONG)EfiDescriptorVersion, 
                                         (ULONGLONG)HalpMemoryMapPhysPtr,
                                         Arg5,
                                         Arg6,
                                         EP,
                                         GP
                                         ));
        
        
        //
        // Release the MP Lock
        // 
    
        KeReleaseSpinLock (&EFIMPLock, OldLevel); 
    
        
        break;

    case EFI_RESET_SYSTEM_INDEX:

        //
        // Dereference the pointer to get the function arguements
        //

        EP = ((PPLABEL_DESCRIPTOR)EfiResetSystemPtr) -> EntryPoint;
        GP = ((PPLABEL_DESCRIPTOR)EfiResetSystemPtr) -> GlobalPointer;

        //
        // Acquire MP Lock
        //

        KeAcquireSpinLock (&EFIMPLock, &OldLevel);

        efiStatus = ((HalpCallEfiVirtual ( Arg1,
                                           Arg2,
                                           Arg3,
                                           Arg4,
                                           Arg5,
                                           Arg6,
                                           EP,
                                           GP
                                           )));

        //
        // Release the MP Lock
        //

        KeReleaseSpinLock (&EFIMPLock, OldLevel);

        break;

    default: 
        
        //    
        // DebugPrint("EFI: Not supported now\n");
        //

        efiStatus = EFI_UNSUPPORTED;
        
        break;
   
    }

    return efiStatus;
        
} // HalpCallEfi()



HalpFpErrorPrint (PAL_RETURN pal_ret)

{

    EM_uint64_t err_nr;
    unsigned int qp;
    EM_uint64_t OpCode;
    unsigned int rc;
    unsigned int significand_size;
    unsigned int ISRlow;
    unsigned int f1;
    unsigned int sign;
    unsigned int exponent;
    EM_uint64_t significand;
    unsigned int new_trap_type;


    err_nr = pal_ret.err1 >> 56;

    switch (err_nr) {
    case 1:
        // err_nr = 1         in err1, bits 63-56
        HalDebugPrint(( HAL_ERROR, "fp_emulate () Internal Error: template FXX is invalid\n"));
        break;
    case 2:
        // err_nr = 2           in err1, bits 63-56
        HalDebugPrint(( HAL_ERROR, "fp_emulate () Internal Error: instruction slot 3 is not valid \n"));
        break;
    case 3:
        // err_nr = 3           in err1, bits 63-56
        // qp                   in err1, bits 31-0
        qp = (unsigned int) pal_ret.err1 & 0xffffffff;
        HalDebugPrint(( HAL_ERROR, "fp_emulate () Internal Error: qualifying predicate PR[%ud] = 0 \n",qp)); 
        break;

    case 4:
        // err_nr = 4           in err1, bits 63-56
        // OpCode               in err2, bits 63-0
        OpCode = pal_ret.err2;
        HalDebugPrint(( HAL_ERROR, "fp_emulate () Internal Error: instruction opcode %8x%8x not recognized \n",
                                  (unsigned int)((OpCode >> 32) & 0xffffffff),(unsigned int)(OpCode & 0xffffffff)));
        break;

    case 5:
        // err_nr = 5           in err1, bits 63-56
        // rc                   in err1, bits 31-0 (1-0)
        rc = (unsigned int) pal_ret.err1 & 0xffffffff;
        HalDebugPrint(( HAL_ERROR, "fp_emulate () Internal Error: invalid rc = %ud\n", rc));
        break;

    case 6:
        // err_nr = 6           in err1, bits 63-56
        HalDebugPrint(( HAL_ERROR, "fp_emulate () Internal Error: cannot determine the computation model \n")); 
        break;

    case 7:
        // err_nr = 7           in err1, bits 63-56
        // significand_size     in err1, bits 55-32
        // ISRlow               in err1, bits 31-0
        // f1                   in err2, bits 63-32
        // tmp_fp.sign          in err2, bit 17
        // tmp_fp.exponent      in err2, bits 16-0
        // tmp_fp.significand   in err3
        significand_size = (unsigned int)((pal_ret.err1 >> 32) & 0xffffff);
        ISRlow = (unsigned int) (pal_ret.err1 & 0xffffffff);
        f1 = (unsigned int) ((pal_ret.err2 >> 32) & 0xffffffff);
        sign = (unsigned int) ((pal_ret.err2 >> 17) & 0x01);
        exponent = (unsigned int) (pal_ret.err2 & 0x1ffff);
        significand = pal_ret.err3;
        HalDebugPrint(( HAL_ERROR, "fp_emulate () Internal Error: incorrect significand \
            size %ud for ISRlow = %4.4x and FR[%ud] = %1.1x %5.5x %8x%8x\n",
            significand_size, ISRlow, f1, sign, exponent, 
            (unsigned int)((significand >> 32) & 0xffffffff),
            (unsigned int)(significand & 0xffffffff)));
        break;

    case 8:
    
        // err_nr = 8           in err1, bits 63-56
        HalDebugPrint(( HAL_ERROR, "fp_emulate () Internal Error: non-tiny result\n"));
        break;

    case 9:
        // err_nr = 9           in err1, bits 63-56
        // significand_size     in err1, bits 31-0
        significand_size = (unsigned int) pal_ret.err1 & 0xffffffff;
        HalDebugPrint(( HAL_ERROR, "fp_emulate () Internal Error: incorrect significand \
            size %ud\n", significand_size));
        break;

    case 10:
        // err_nr = 10          in err1, bits 63-56
        // rc                   in err1, bits 31-0
        rc = (unsigned int) (pal_ret.err1 & 0xffffffff);
        HalDebugPrint(( HAL_ERROR, "fp_emulate () Internal Error: invalid rc = %ud for \
            non-SIMD F1 instruction\n", rc));
        break;
    
    case 11:
        // err_nr = 11          in err1, bits 63-56
        // ISRlow & 0x0ffff     in err1, bits 31-0
        ISRlow = (unsigned int) (pal_ret.err1 & 0xffffffff);
        HalDebugPrint(( HAL_ERROR, "fp_emulate () Internal Error: SWA trap code invoked \
              with F1 instruction, w/o O or U set in ISR.code = %x\n", ISRlow));
        break;

    case 12:
        // err_nr = 12          in err1, bits 63-56
        // ISRlow & 0x0ffff     in err1, bits 31-0
        ISRlow = (unsigned int) (pal_ret.err1 & 0xffffffff);
        HalDebugPrint(( HAL_ERROR, "fp_emulate () Internal Error: SWA trap code invoked \
        with SIMD F1 instruction, w/o O or U set in ISR.code = %x\n", ISRlow));
        break;


    case 13:
        // err_nr = 13          in err1, bits 63-56
        HalDebugPrint(( HAL_ERROR, "fp_emulate () Internal Error: non-tiny result low\n"));
        break;

    case 14:
        // err_nr = 14          in err1, bits 63-56
        // rc                   in err1, bits 31-0
        rc = (unsigned int) (pal_ret.err1 & 0xffffffff);
        HalDebugPrint(( HAL_ERROR, "fp_emulate () Internal Error: invalid rc = %ud for \
            SIMD F1 instruction\n", rc));
        break;

    case 15:
        // err_nr = 15          in err1, bits 63-56
        HalDebugPrint(( HAL_ERROR, "fp_emulate () Internal Error: non-tiny result high\n"));
        break;

    case 16:
        // err_nr = 16          in err1, bits 63-56
        // OpCode               in err2, bits 63-0
        OpCode = pal_ret.err2;
        HalDebugPrint(( HAL_ERROR, "fp_emulate () Internal Error: instruction opcode %8x%8x \
            not valid for SWA trap\n", (unsigned int)((OpCode >> 32) & 0xffffffff),
            (unsigned int)(OpCode & 0xffffffff)));
        break;

    case 17:
        // err_nr = 17          in err1, bits 63-56
        // OpCode               in err2, bits 63-0
        // ISRlow               in err3, bits 31-0
        OpCode = pal_ret.err2;
        ISRlow = (unsigned int) (pal_ret.err3 & 0xffffffff);
        HalDebugPrint(( HAL_ERROR, "fp_emulate () Internal Error: fp_emulate () called w/o \
            trap_type FPFLT or FPTRAP, OpCode = %8x%8x, and ISR code = %x\n",
            (unsigned int)((OpCode >> 32) & 0xffffffff),
            (unsigned int)(OpCode & 0xffffffff), ISRlow));
        break;

    case 18:
        // err_nr = 18          in err1, bits 63-56
        HalDebugPrint(( HAL_ERROR, "fp_emulate () Internal Error: SWA fault repeated\n"));
        break;

    case 19:
        // err_nr = 19          in err1, bits 63-56
        // new_trap_type        in err1, bits 31-0
        new_trap_type = (unsigned int) (pal_ret.err1 & 0xffffffff);
        HalDebugPrint(( HAL_ERROR, "fp_emulate () Internal Error: new_trap_type = %x\n",
            new_trap_type));
        break;

    default:
        // error
        HalDebugPrint(( HAL_ERROR, "Incorrect err_nr = %8x%8x from fp_emulate ()\n",
            (unsigned int)((err_nr >> 32) & 0xffffffff),
            (unsigned int)(err_nr & 0xffffffff)));

    }
}


LONG
HalFpEmulate (
    ULONG     trap_type,
    BUNDLE    *pbundle,
    ULONGLONG *pipsr,
    ULONGLONG *pfpsr,
    ULONGLONG *pisr,
    ULONGLONG *ppreds,
    ULONGLONG *pifs,
    FP_STATE  *fp_state
    )
/*++

Routine Description:
                                  
    This function is a wrapper function to make fp_emulate() call
    to EFI FPSWA driver.

Arguments:

    trap_type - indicating which FP trap it is.
    pbundle   - bundle where this trap occurred
    pipsr     - IPSR value
    pfpsr     - FPSR value
    pisr      - ISR value
    ppreds    - value of predicate registers
    pifs      - IFS value
    fp_state  - floating point registers

Return Value:

    return IEEE result of the floating point operation 

--*/

{
    PAL_RETURN ret;

    ret  =  (*HalpFpEmulate) ( 
                                trap_type,
                                pbundle,
                                pipsr,
                                pfpsr,
                                pisr,
                                ppreds,
                                pifs,
                                fp_state
                                );
    if (ret.retval == FP_EMUL_ERROR) {
       HalpFpErrorPrint (ret);
    }

    return ((LONG) (ret.retval));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\i64dma.c ===
/*++

Copyright (c) 1995  Intel Corporation

Module Name:

    i64dma.c

Abstract:

    This module implements the DMA support routines for the HAL DLL.

Author:

    14-Apr-1995

Environment:

    Kernel mode

Revision History:

--*/

#include "halp.h"



VOID
HalFlushIoBuffers (
    IN PMDL Mdl,
    IN BOOLEAN ReadOperation,
    IN BOOLEAN DmaOperation
    )

/*++

Routine Description:

    This function flushes the I/O buffer specified by the memory descriptor
    list from the data cache on the current processor.

Arguments:

    Mdl - Supplies a pointer to a memory descriptor list that describes the
        I/O buffer location.

    ReadOperation - Supplies a boolean value that determines whether the I/O
        operation is a read into memory.

    DmaOperation - Supplies a boolean value that determines whether the I/O
        operation is a DMA operation.

Return Value:

    None.

--*/

{
    //
    // 
    // In IA64 systems, DMA is coherent with Dcache and Icache.
    // In PIO, Dcache is coherent and Icache is NOT coherent.
    // Only on Page read using PIO Icache coherency is needed to be
    // maintained by software. So, HalFlushIoBuffer will flush the Icache
    // only on Page read using PIO.
    //
    //

    return;

}


ULONG
HalGetDmaAlignmentRequirement (
    VOID
    )

/*++

Routine Description:

    This function returns the alignment requirements for DMA transfers on
    host system.

Arguments:

    None.

Return Value:

    The DMA alignment requirement is returned as the fucntion value.

--*/

{

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\i64clock.c ===
/*++

Module Name:

    i64clock.c

Abstract:

Author:

    Bernard Lint, M. Jayakumar
    Ron Mosgrove - Intel

Environment:

    Kernel mode

Revision History:

    Based on halmps/mpclockc.c


--*/

#include "halp.h"

extern ULONG HalpNextRate;
extern BOOLEAN HalpClockSetMSRate;
int _fltused;

BOOLEAN ReadPerfMonCounter = FALSE;
ULONG HalpCPUMHz;

#if defined(INSTRUMENT_CLOCK_DRIFT)
ULONGLONG HalpITMSkew;
ULONG     HalpCountBadITMValues;
ULONGLONG HalpMinITMMissed;
ULONGLONG HalpMaxITMMissed;

ULONG   HalpBreakMissedTickMin;
ULONG   HalpBreakMissedTickMax = ~0U;
BOOLEAN HalpResetITMDebug;
#endif

#if DBG
// Thierry - until compiler supports the generation of enum types in pdbs...
//          At that time, we will be able the use the enums instead of globals.
unsigned int HalpDpfltrMaxMask = HALIA64_DPFLTR_MAXMASK;
#endif // DBG


ULONGLONG HalpITCFrequency = 500000000; // 500MHz for default real hardware power on.
ULONGLONG HalpProcessorFrequency = 500000000; // 500MHz CPU

ULONG HalpMissedTickCount[HAL_MAXIMUM_PROCESSOR];

//
// Ticks per 100ns used to compute ITM update count
//

double HalpITCTicksPer100ns;
ULONGLONG HalpClockCount;

//
// HalpSetNextClockInterrupt():
//  move to cr.itm latency (= 40 cycles) + 2 cycles from the itc read.
//

ULONGLONG HalpITMUpdateLatency = 42;

//
// All of these are in 100ns units
//

ULONGLONG   HalpCurrentTimeIncrement = DEFAULT_CLOCK_INTERVAL;
ULONGLONG   HalpNextTimeIncrement    = DEFAULT_CLOCK_INTERVAL;
ULONGLONG   HalpNewTimeIncrement     = DEFAULT_CLOCK_INTERVAL;

ULONG HalpProfileInterval = DEFAULT_PROFILE_INTERVAL;
BOOLEAN HalpProfileStopped = TRUE;

ULONGLONG // = (current ITC - previous ITM)
HalpSetNextClockInterrupt(
    VOID
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpSetInitialClockRate)
#pragma alloc_text(INIT,HalpInitializeTimerResolution)
#endif



VOID
HalpClearClock (
    )

/*++

Routine Description:

    Set clock to zero.

    Return Value:

    None.


--*/

{
    HalpWriteITC(0);
    HalpWriteITM(0);
    return;
}


VOID
HalpInitializeClock (
    VOID
    )

/*++

Routine Description:

    Initialize system time clock (ITC and ITM) to generate an interrupt
    at every 10 ms interval at ITC_CLOCK_VECTOR.

    Previously this routine initialize system time clock using 8254 timer1
    counter 0 to generate an interrupt at every 15ms interval at 8259 irq0.

    See the definitions of TIME_INCREMENT and ROLLOVER_COUNT if clock rate
    needs to be changed.

    Arguments:

    None

    Return Value:

    None.


--*/

{
    HalpSetInitialClockRate();
    HalpClearClock();
    HalpWriteITM(PCR->HalReserved[CURRENT_ITM_VALUE_INDEX]);
    return;
}


VOID
HalpInitializeClockPn (
     VOID
     )

/*++

Routine Description:

     Assumes that only non-BSP processors call this routine.
     Initializes system time clock (ITC and ITM) to generate an interrupt
     at every 10 ms interval at ITC_CLOCK_VECTOR.

     Previously this routine initialize system time clock using 8254 timer1
     counter 0 to generate an interrupt at every 15ms interval at 8259 irq0.

     See the definitions of TIME_INCREMENT and ROLLOVER_COUNT if clock rate
     needs to be changed.

     Arguments:

     None

     Return Value:

     None.

--*/

{
    ULONGLONG itmValue;

    itmValue = (ULONGLONG)(HalpITCTicksPer100ns * MAXIMUM_CLOCK_INTERVAL);
    PCR->HalReserved[CURRENT_ITM_VALUE_INDEX] = itmValue;
    HalpClearClock();
    HalpWriteITM( itmValue );
    return;
}


VOID
HalpSetInitialClockRate (
    VOID
    )

/*++

Routine Description:

    This function is called to set the initial clock interrupt rate
    Assumes that only the BSP processor calls this routine.

Arguments:

    None

Return Value:

    None

--*/

{

    //
    // CPU Frequency in MHz = ticks per second / 10 ** 6
    //

    HalpCPUMHz = (ULONG)((HalpProcessorFrequency + 500000) / 1000000);

    //
    // Ticks per 100ns = ticks per second / 10 ** 7
    //

    HalpITCTicksPer100ns = (double) HalpITCFrequency / (10000000.);
    if (HalpITCTicksPer100ns < 1) {
        HalpITCTicksPer100ns = 1;
    }
    HalpClockCount = (ULONGLONG)(HalpITCTicksPer100ns * MAXIMUM_CLOCK_INTERVAL);
    PCR->HalReserved[CURRENT_ITM_VALUE_INDEX] = HalpClockCount;
    KeSetTimeIncrement(MAXIMUM_CLOCK_INTERVAL, MINIMUM_CLOCK_INTERVAL);

}



VOID
HalpClockInterrupt (
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    System Clock Interrupt Handler, for P0 processor only.

    N.B. Assumptions: Comes with IRQL set to CLOCK_LEVEL to disable
         interrupts.

Arguments:

    TrapFrame - Trap frame address.

Return Value:

    None.

--*/

{
    ULONGLONG CurrentITC;
    ULONGLONG currentITCDelta;
    ULONGLONG elapsedTimeIn100ns, numberOfTicksElapsed;
#if defined(INSTRUMENT_CLOCK_DRIFT)
    ULONGLONG originalITM, currentITM, excessITM;
#endif
    LONG      mcaNotification;

    //
    // Check to see if a clock interrupt is generated in a small latency window
    // in HalpSetNextClockInterrupt.
    //

    CurrentITC = HalpReadITC();
#ifndef DISABLE_ITC_WORKAROUND
    while ((CurrentITC & 0xFFFFFFFF) == 0xFFFFFFFF) {
        CurrentITC = HalpReadITC();
    }
#endif

    if ((LONGLONG) (PCR->HalReserved[CURRENT_ITM_VALUE_INDEX] - CurrentITC) > 0)
    {
        return;
    }

    //
    // PerfMon: Per P0 clock interrupt PMD4 collection.
    //

    if (ReadPerfMonCounter) {
       ULONGLONG currentPerfMonValue;

       currentPerfMonValue = HalpReadPerfMonDataReg4();
       HalDebugPrint(( HAL_INFO, "\nHAL: HalpClockInterrupt - PMD4=%I64x\n", currentPerfMonValue ));

    }

#if defined(INSTRUMENT_CLOCK_DRIFT)
    //
    // Time this interrupt was scheduled to occur
    //
    originalITM = (ULONGLONG)PCR->HalReserved[CURRENT_ITM_VALUE_INDEX];
#endif

    //
    // Set next clock interrupt, based on ITC and
    // increment ITM, accounting for interrupt latency.
    //

    currentITCDelta = HalpSetNextClockInterrupt();

#if defined(INSTRUMENT_CLOCK_DRIFT)
    //
    // Time the next interrupt is scheduled to occur
    //
    currentITM = (ULONGLONG)PCR->HalReserved[CURRENT_ITM_VALUE_INDEX];

    excessITM = (currentITM - originalITM) / HalpClockCount - 1;

    if (excessITM != 0) {
        if (HalpMinITMMissed == 0 || excessITM < HalpMinITMMissed)  {
            HalpMinITMMissed = excessITM;
        }
        if (excessITM > HalpMaxITMMissed) {
            HalpMaxITMMissed = excessITM;
        }

        HalpCountBadITMValues++;
        HalpITMSkew += excessITM;

        if (HalpBreakMissedTickMin != 0 &&
            HalpBreakMissedTickMin <= excessITM &&
            HalpBreakMissedTickMax >= excessITM &&
            !HalpResetITMDebug) {
            DbgBreakPoint();
        }
    }

    if (HalpResetITMDebug) {
        HalpResetITMDebug = FALSE;
        HalpCountBadITMValues = 0;
        HalpITMSkew = 0;
        HalpMinITMMissed = 0;
        HalpMaxITMMissed = 0;
    }
#endif

    //
    // Call the kernel to update system time.
    // P0 updates System time and Run Time.
    //

    elapsedTimeIn100ns = (ULONGLONG) (currentITCDelta/HalpITCTicksPer100ns);

    elapsedTimeIn100ns += HalpCurrentTimeIncrement;
    if (elapsedTimeIn100ns >= MAXIMUM_CLOCK_INTERVAL) {

        KeUpdateSystemTime( TrapFrame, MAXIMUM_CLOCK_INTERVAL );

    } else {

        numberOfTicksElapsed = elapsedTimeIn100ns / HalpCurrentTimeIncrement;
        KeUpdateSystemTime( TrapFrame,
                            (ULONG)(numberOfTicksElapsed * HalpCurrentTimeIncrement)
                          );

    }

    HalpCurrentTimeIncrement = HalpNextTimeIncrement;
    HalpNextTimeIncrement    = HalpNewTimeIncrement;

    //
    // If MCA notification was requested by MCA Handler, execute it.
    //

    mcaNotification = InterlockedExchange( &HalpMcaInfo.DpcNotification, 0 );
    if ( mcaNotification )  {
        if ( HalpMcaInfo.KernelDelivery ) {
            if ( !HalpMcaInfo.KernelDelivery( HalpMcaInfo.KernelToken, NULL ) ) {
                InterlockedIncrement( &HalpMcaInfo.Stats.KernelDeliveryFails );
            }
        }
        if ( HalpMcaInfo.DriverInfo.DpcCallback )   {
             if ( !KeInsertQueueDpc( &HalpMcaInfo.DriverDpc, NULL, NULL ) )  {
                 InterlockedIncrement( &HalpMcaInfo.Stats.DriverDpcQueueFails );
             }
        }
    }

    //
    // Poll for debugger breakin if enabled.
    //

    if ( KdDebuggerEnabled && KdPollBreakIn() )  {
       KeBreakinBreakpoint();
    }

} // HalpClockInterrupt()


VOID
HalpClockInterruptPn (
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    System Clock Interrupt Handler, for processors other than P0.

    N.B. Assumptions: Comes with IRQL set to CLOCK_LEVEL to disable
         interrupts.

Arguments:

    TrapFrame - Trap frame address.

Return Value:

    None.

--*/

{
    //
    // Set next clock interrupt, based on ITC and
    // increment ITM, accounting for interrupt latency.
    //

    (void)HalpSetNextClockInterrupt();

    //
    // Call the kernel to update run time.
    // Pn updates only Run time.
    //

    KeUpdateRunTime(TrapFrame);

    // IA64 MCA Notification - 09/18/2000 - WARNING
    // If faster MCA notification was required, the BSP MCA notification checking
    // should be placed here.
    //

} // HalpClockInterruptPn()



VOID
HalpInitializeClockInterrupts (
    VOID
    )

{
    PKPRCB Prcb;
    UCHAR InterruptVector;
    ULONGLONG ITVData;

    Prcb = PCR->Prcb;
    InterruptVector = CLOCK_LEVEL << VECTOR_IRQL_SHIFT;

    if (Prcb -> Number == 0) {

        HalpSetHandlerAddressToVector(InterruptVector,HalpClockInterrupt);

    } else {

        //
        // Non-BSP processor
        //

        HalpSetHandlerAddressToVector(InterruptVector, HalpClockInterruptPn);

    }

    ITVData = (ULONGLONG) InterruptVector;

    HalpWriteITVector(ITVData);

    return;

}


ULONG
HalSetTimeIncrement (
    IN ULONG DesiredIncrement
    )

/*++

Routine Description:

    This function is called to set the clock interrupt rate to the frequency
    required by the specified time increment value.

    N.B. This function is only executed on the processor that keeps the
         system time. Previously this was called HalpSetTimeIncrement. We
         have renamed it HalSetTimeIncrement.


Arguments:

    DesiredIncrement - Supplies desired number of 100ns units between clock
        interrupts.

Return Value:

    The actual time increment in 100ns units.

--*/

{
    ULONGLONG NextIntervalCount;
    KIRQL     OldIrql;

    //
    // DesiredIncrement must map within the acceptable range.
    //

    if (DesiredIncrement < MINIMUM_CLOCK_INTERVAL)
        DesiredIncrement = MINIMUM_CLOCK_INTERVAL;
    else if (DesiredIncrement > MAXIMUM_CLOCK_INTERVAL)
        DesiredIncrement = MAXIMUM_CLOCK_INTERVAL;

    //
    // Raise IRQL to the highest level, set the new clock interrupt
    // parameters, lower IRQl, and return the new time increment value.
    //

    KeRaiseIrql(HIGH_LEVEL, &OldIrql);

    //
    // Calculate the actual 64 bit time value which forms the target interval.
    // The resulting value is added to the ITC to form the new ITM value.
    // HalpITCTicksPer100ns is the calibrated value for the ITC whose value
    // works out to be 100ns (or as close as we can come).
    // Previously HalpITCTicksPer100ns was called as HalpPerformanceFrequency
    //

    NextIntervalCount = (ULONGLONG)(HalpITCTicksPer100ns * DesiredIncrement);

    //
    // Calculate the number of 100ns units to report to the kernel every
    // time the ITM matches the ITC with this new period.  Note, for small
    // values of DesiredIncrement (min being 10000, ie 1ms), truncation
    // in the above may result in a small decrement in the 5th decimal
    // place.  As we are effectively dealing with a 4 digit number, eg
    // 10000 becomes 9999.something, we really can't do any better than
    // the following.
    //

    HalpClockCount = NextIntervalCount;

    HalpNewTimeIncrement = DesiredIncrement;

    //
    // HalpClockSetMSRate   = TRUE;
    //

    KeLowerIrql(OldIrql);
    return DesiredIncrement;
}



NTSTATUS
HalpQueryFrequency(
    PULONGLONG ITCFrequency,
    PULONGLONG ProcessorFrequency
    )

/*++

Routine Description:

    This function is called to provide the ITC update rate.
    This value is computed by first getting the platform base frequency
    from the SAL_FREQ_BASE call. Then applying on the return value, the
    ITC ratios obtained from the PAL_FREQ_RATIOS call.

Arguments:

    None.

Return Value:

    ULONGLONG ITCFrequency - number of ITC updates per seconds

--*/

{

    ULONG     ITCRatioDenominator = 0;
    ULONG     ITCRatioNumerator   = 0;
    ULONG     ProcessorRatioDenominator = 0;
    ULONG     ProcessorRatioNumerator   = 0;

    SAL_PAL_RETURN_VALUES  SalReturn    = {0};
    SAL_PAL_RETURN_VALUES  PalReturn    = {0};

    SAL_STATUS  SalStatus;
    PAL_STATUS  PalStatus;

    SalStatus = HalpSalCall(SAL_FREQ_BASE,
        0 /* Platform base clock frequency is the clock input to the processor */,
        0,
        0,
        0,
        0,
        0,
        0,
        &SalReturn);
    if (SalStatus != 0) {
        HalDebugPrint(( HAL_ERROR,
                        "HAL: HalInitSystem - Phase1 SAL_FREQ_BASE is returning error # %d\n",
                        SalStatus ));
        return STATUS_UNSUCCESSFUL;
    }

    HalDebugPrint(( HAL_INFO, "HAL: HalInitSystem - Platform base clock Frequency is %I64u\n",SalReturn.ReturnValues[1] ));

    PalStatus = HalpPalCall( PAL_FREQ_RATIOS,
                             0,
                             0,
                             0,
                             &PalReturn);
    if (PalStatus != 0) {
        HalDebugPrint(( HAL_ERROR,
                        "HAL: HalInitSystem - Phase1 PAL_FREQ_RATIOS is returning error # %d\n",
                        PalStatus ));
        return STATUS_UNSUCCESSFUL;
    }

    ProcessorRatioNumerator   = (ULONG)((PalReturn.ReturnValues[1]) >> 32);
    ProcessorRatioDenominator = (ULONG)( PalReturn.ReturnValues[1]);

    HalDebugPrint(( HAL_INFO,
                    "HAL: HalInitSystem - PAL returns Processor to Platform clock Frequency as %lu : %lu\n",
                    ProcessorRatioNumerator,
                    ProcessorRatioDenominator));

    *ProcessorFrequency = SalReturn.ReturnValues[1] * ProcessorRatioNumerator / ProcessorRatioDenominator;

    HalDebugPrint(( HAL_INFO,
                    "HAL: HalInitSystem - Processor clock Frequency is %I64u \n",
                    ProcessorFrequency ));

    ITCRatioNumerator   = (ULONG)((PalReturn.ReturnValues[3]) >> 32);
    ITCRatioDenominator = (ULONG)( PalReturn.ReturnValues[3]);

    HalDebugPrint(( HAL_INFO,
                    "HAL: HalInitSystem - PAL returns ITC to Platform clock Frequency as %lu : %lu\n",
                    ITCRatioNumerator,
                    ITCRatioDenominator));

    *ITCFrequency = SalReturn.ReturnValues[1] * ITCRatioNumerator / ITCRatioDenominator;

    HalDebugPrint(( HAL_INFO,
                    "HAL: HalInitSystem - ITC clock Frequency is %I64u \n",
                    ITCFrequency ));

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\i64fw.h ===
//
//
//  Module name
//      i64fw.h
//  Author
//      Arad Rostampour (arad@fc.hp.com)    Mar-22-99
//  Description
//      Defines SAL/PAL data structures and prototypes
//

#ifndef _I64FW_H_
#define _I64FW_H_



#define SET_ITR_AND_DTR                              3 
#define SET_DTR_ONLY                                 2
#define SET_ITR_ONLY                                 1

// TR for PAL is:
//    ed=1, PPN=0 (to be ORed in), RWX privledge only for ring 0, dirty/accessed bit set,
//    cacheable memory, present bit set.

#define HAL_SAL_PAL_TR_ATTRIB TR_VALUE(1,0,3,0,1,1,0,1)
#define HAL_TR_ATTRIBUTE_PPN_MASK    0x0000FFFFFFFFF000I64
#define HAL_RID_MASK 0x00000000FFFFFF00I64
#define HAL_RR_PS_VE 0x69       
#define HAL_ITIR_PPN_MASK 0x7FFF000000000000I64
#define PAL_HIGHEST_STATIC_FUNCTION_ID 255


#define REGULAR_MEMORY     0
#define PAL_CODE_MEM       1
#define SAL_CODE_MEM       4
#define SAL_DATA_MEM       5
#define FW_RESERVED       12

#define FIRMWARE_CODE  4
#define FW_SAL_PAL     0

#define OEM_ID_LENGTH          RTL_NUMBER_OF_FIELD( SST_HEADER, OemId )
#define OEM_PRODUCT_ID_LENGTH  RTL_NUMBER_OF_FIELD( SST_HEADER, ProductId )

#define MASK_16KB           0xffffffffffffc000I64
#define MASK_16MB           0xffffffffff000000I64
#define SIZE_IN_BYTES_16KB                  16384

// SAL_STATUS and PAL_STATUS is a 64-bit copy of the value in ReturnValues[0]

typedef LONGLONG SAL_STATUS;
typedef LONGLONG PAL_STATUS;

// SAL and PAL return up to 4 64-bit return values; HalpSalCall() and
// HalpPalCall() will return a pointer to this structure

typedef struct _SAL_PAL_RETURN_VALUES {
    LONGLONG ReturnValues[4];
} SAL_PAL_RETURN_VALUES, *PSAL_PAL_RETURN_VALUES;


typedef struct _HAL_PLATFORM_ID {
    ANSI_STRING VendorId;
    ANSI_STRING DeviceId;
} HAL_PLATFORM_ID, *PHAL_PLATFORM_ID;

typedef struct _SST_MEMORY_LIST {
    ULONGLONG PhysicalAddress;
    ULONGLONG VirtualAddress;
    ULONGLONG Length;
    UCHAR     NeedVaReg;
    struct _SST_MEMORY_LIST *Next;
} SST_MEMORY_LIST, *PSST_MEMORY_LIST;

// Function Prototypes: SAL takes 8 arguments, PAL takes 4

VOID 
HalpSetupTranslationRegisters(
    ULONGLONG VAddr,
    ULONGLONG PAddr,
    ULONG     PageSize,
    ULONG     TrNumber,
    ULONG     RidValue,
    ULONG     Mode
    );


SAL_STATUS
HalpSalCall(
    IN LONGLONG FunctionId,
    IN LONGLONG Arg1,
    IN LONGLONG Arg2,
    IN LONGLONG Arg3,
    IN LONGLONG Arg4,
    IN LONGLONG Arg5,
    IN LONGLONG Arg6,
    IN LONGLONG Arg7,
    OUT PSAL_PAL_RETURN_VALUES ReturnValues
    );

PAL_STATUS
HalpPalCall(
    IN LONGLONG FunctionId,
    IN LONGLONG Arg1,
    IN LONGLONG Arg2,
    IN LONGLONG Arg3,
    OUT PSAL_PAL_RETURN_VALUES ReturnValues
    );

SAL_PAL_RETURN_VALUES
HalpSalProc(
    LONGLONG FunctionId,
    LONGLONG Arg1,
    LONGLONG Arg2,
    LONGLONG Arg3,
    LONGLONG Arg4,
    LONGLONG Arg5,
    LONGLONG Arg6,
    LONGLONG Arg7
    );

SAL_PAL_RETURN_VALUES 
HalpPalProc(
    LONGLONG FunctionId,
    LONGLONG Arg1,
    LONGLONG Arg2,
    LONGLONG Arg3
    );

SAL_PAL_RETURN_VALUES 
HalpPalProcPhysicalStatic(
    LONGLONG FunctionId,
    LONGLONG Arg1,
    LONGLONG Arg2,
    LONGLONG Arg3
    );

SAL_PAL_RETURN_VALUES 
HalpPalProcPhysicalStacked(
    LONGLONG FunctionId,
    LONGLONG Arg1,
    LONGLONG Arg2,
    LONGLONG Arg3
    );

NTSTATUS
HalpGetPlatformId(
    OUT PHAL_PLATFORM_ID PlatformId
    );

VOID
InternalTestSal(
    IN LONGLONG FunctionId,
    IN LONGLONG Arg1,
    IN LONGLONG Arg2,
    IN LONGLONG Arg3,
    IN LONGLONG Arg4,
    IN LONGLONG Arg5,
    IN LONGLONG Arg6,
    IN LONGLONG Arg7,
    OUT PSAL_PAL_RETURN_VALUES ReturnValues
    );

VOID
InternalTestPal(
    IN LONGLONG FunctionId,
    IN LONGLONG Arg1,
    IN LONGLONG Arg2,
    IN LONGLONG Arg3,
    OUT PSAL_PAL_RETURN_VALUES ReturnValues
    );

// For SAL cache flush

#define FLUSH_INSTRUCTION_CACHE          1
#define FLUSH_DATA_CACHE                 2
#define FLUSH_INSTRUCTION_AND_DATA_CACHE 3
#define FLUSH_COHERENT                   4

// iA-64 defined SAL function IDs in hex format as in the SAL spec

#define SAL_SET_VECTORS                              0x01000000I64
#define SAL_GET_STATE_INFO                           0x01000001I64
#define SAL_GET_STATE_INFO_SIZE                      0x01000002I64
#define SAL_CLEAR_STATE_INFO                         0x01000003I64
#define SAL_MC_RENDEZ                                0x01000004I64
#define SAL_MC_SET_PARAMS                            0x01000005I64
#define SAL_REGISTER_VIRTUAL_ADDR                    0x01000050I64
#define SAL_REGISTER_PHYSICAL_ADDR                   0x01000006I64
#define SAL_CACHE_FLUSH                              0x01000008I64
#define SAL_CACHE_INIT                               0x01000009I64
#define SAL_PCI_CONFIG_READ                          0x01000010I64
#define SAL_PCI_CONFIG_WRITE                         0x01000011I64
#define SAL_FREQ_BASE                                0x01000012I64
#define SAL_UPDATE_PAL                               0x01000020I64

// iA-64 defined SAL return values

#define SAL_STATUS_SUCCESS                                    0I64
#define SAL_STATUS_SUCCESS_WITH_OVERFLOW                      1I64
#define SAL_STATUS_SUCCESS_MORE_RECORDS                       3I64
#define SAL_STATUS_NOT_IMPLEMENTED                           -1I64
#define SAL_STATUS_INVALID_ARGUMENT                          -2I64
#define SAL_STATUS_ERROR                                     -3I64
#define SAL_STATUS_VA_NOT_REGISTERED                         -4I64
#define SAL_STATUS_NO_INFORMATION_AVAILABLE                  -5I64
#define SAL_STATUS_INSUFFICIENT_NVM_MEMORY                   -6I64
#define SAL_STATUS_INSUFFICIENT_SCRATCH_BUFFER               -7I64
#define SAL_STATUS_INVALID_INTERRUPT_VECTOR                  -8I64
#define SAL_STATUS_PARTITION_TYPE_EXISTS                     -9I64
#define SAL_STATUS_REQUESTED_MEMORY_UNAVAILABLE              -9I64
#define SAL_STATUS_UNABLE_TO_WRITE_NVM                      -10I64
#define SAL_STATUS_INVALID_PARTITION_TYPE                   -11I64
#define SAL_STATUS_INVALID_NVM_OBJECT_ID                    -12I64
#define SAL_STATUS_NVM_OBJECT_MAXIMUM_PARITIONS             -13I64
#define SAL_STATUS_INSUFFICIENT_SPACE_FOR_WRITE             -14I64
#define SAL_STATUS_INSUFFICIENT_SPACE_FOR_READ              -15I64
#define SAL_STATUS_SCRATCH_BUFFER_REQUIRED                  -16I64
#define SAL_STATUS_INSUFFICIENT_NVM_SPACE_FOR_SUBFUNCTION   -17I64
#define SAL_STATUS_INVALID_PARTITION_VALUE                  -18I64
#define SAL_STATUS_RECORD_ORIENTED_IO_NOT_SUPPORTED         -19I64
#define SAL_STATUS_BAD_RECORD_FORMAT_OR_KEYWORD_VARIABLE    -20I64

#define SAL_SUCCESSFUL( /* SAL_PAL_RETURN_VALUE */ _rv ) (((_rv).ReturnValues[0]) >= (LONGLONG)0)

//
// SAL descriptor types
//

typedef enum {
    SAL_PAL_ENTRY_POINT_TYPE = 0,
    SST_MEMORY_DESCRIPTOR_TYPE,
    PLATFORM_FEATURES_TYPE,
    TRANSLATION_REGISTER_TYPE,
    PTC_COHERENCE_DOMAIN_TYPE,
    AP_WAKEUP_DESCRIPTOR_TYPE
};

//
// IA64 PAL:  PAL_VERSION
//

typedef union _PAL_VERSION_STRUCT {
    struct {
        UCHAR         PAL_B_Revision;
        UCHAR         PAL_B_Model;
        UCHAR         PAL_Reserved1;
        UCHAR         PAL_Vendor;
        UCHAR         PAL_A_Revision;
        UCHAR         PAL_A_Model;
        UCHAR         PAL_Reserved2[2];
    };

    ULONGLONG ReturnValue;

}PAL_VERSION_STRUCT, *PPAL_VERSION_STRUCT;

//
// IA64 SAL: SAL_REVISION definitions
//

typedef union _SAL_REVISION {
    USHORT      Revision;           // Major and Minor revision:
    struct {
        UCHAR   Minor;              //  Byte0: Minor.
        UCHAR   Major;              //  Byte1: Major.
    };
} SAL_REVISION, *PSAL_REVISION;

#define HALP_SAL_REVISION_2_90  0x0290  /* v2.9 */
#define HALP_SAL_REVISION_MAX   0xffff 

//
//  Format of the SAL System Table (SST) Header. SAL Specs July 2000, Revision: 2.9.  
//  The SST is followed by a variable number of entries with varying length.
//

typedef struct _SST_HEADER {
    ULONG   Signature;
    ULONG   Length;
    USHORT  SalRev;
    USHORT  EntryCount;
    UCHAR   CheckSum;
    UCHAR   Reserved1[7];
    USHORT  Sal_A_Version;
    USHORT  Sal_B_Version;
    UCHAR   OemId[32];
    UCHAR   ProductId[32];
    UCHAR   Reserved2[8];
} SST_HEADER, *PSST_HEADER;

//
// Global Data used by the SAL/PAL support routines
//

// _HALP_SAL_PAL_DATA.Flags:
#define HALP_SALPAL_FIX_MCE_LOG_ID                   0x1
#define HALP_SALPAL_MCE_PROCESSOR_CPUIDINFO_OMITTED  0x2
#define HALP_SALPAL_MCE_PROCESSOR_STATICINFO_PARTIAL 0x4
#define HALP_SALPAL_FIX_MP_SAFE                      0x8

typedef struct _HALP_SAL_PAL_DATA {
    PSST_HEADER         SalSystemTable;
    ULONGLONG           PalTrBase;
    ULONGLONG           PalTrSize;
    NTSTATUS            Status;
    SAL_REVISION        SalRevision;  // Copy of SalSystemTable.SalRev in case we unmap SST.
    USHORT              Flags;     
    PAL_VERSION_STRUCT  PalVersion;
    PUCHAR              SmBiosVersion;
    ULONGLONG           Reserved[4];
} HALP_SAL_PAL_DATA, *PHALP_SAL_PAL_DATA;

#define SMBIOS_STRUCT_HEADER_TYPE_FIELD			0
#define SMBIOS_STRUCT_HEADER_LENGTH_FIELD		1
#define SMBIOS_STRUCT_HEADER_HANDLE_FIELD		2
#define SMBIOS_TYPE0_STRUCT_BIOSVER_FIELD		5

//
// Listing of Descriptors in the SAL System Table and their formats
//

typedef struct _SAL_PAL_ENTRY_POINT {
    UCHAR EntryType;
    UCHAR Reserved0[7];
    ULONGLONG PalEntryPoint;
    ULONGLONG SalEntryPoint;
    ULONGLONG GlobalPointer;
    UCHAR Reserved1[16];
} SAL_PAL_ENTRY_POINT, *PSAL_PAL_ENTRY_POINT;

typedef struct _SST_MEMORY_DESCRIPTOR {
    UCHAR EntryType;    
    UCHAR NeedVaReg;    
    UCHAR CurrentAttribute;
    UCHAR PageAccessRights;
    UCHAR SupportedAttribute;    
    UCHAR Reserved1[1];
    UCHAR MemoryType;    
    UCHAR MemoryUsage;
    ULONGLONG MemoryAddress;    
    ULONG Length;    
    UCHAR Reserved[4];
    UCHAR OemReserved[8];
} SST_MEMORY_DESCRIPTOR, *PSST_MEMORY_DESCRIPTOR;

typedef struct _PLATFORM_FEATURES {
    UCHAR EntryType;
    UCHAR FeatureList;
    UCHAR Reserved[14];
} PLATFORM_FEATURES, *PPLATFORM_FEATURES;

typedef struct _PTC_COHERENCE_DOMAIN {
    UCHAR EntryType;
    UCHAR Reserved[3];
    ULONG NumberOfDomains;
    ULONGLONG CoherenceDomainInfo;
} PTC_COHERENCE_DOMAIN, *PPTC_COHERENCE_DOMAIN;

typedef struct _COHERENCE_DOMAIN_INFO {
    ULONGLONG NumberOfProcessors;
    ULONGLONG LocalIdRegisters;
} COHERENCE_DOMAIN_INFO, *PCOHERENCE_DOMAIN_INFO;

typedef struct _AP_WAKEUP_DESCRIPTOR {
    UCHAR EntryType;
    UCHAR WakeupMechanism;
    UCHAR Reserved[6];
    ULONGLONG WakeupVector;
} AP_WAKEUP_DESCRIPTOR, *PAP_WAKEUP_DESCRIPTOR;

typedef struct _TRANSLATION_REGISTER {    
    UCHAR EntryType;    
    UCHAR TRType;
    UCHAR TRNumber;    
    UCHAR Reserved1[5];    
    ULONGLONG VirtualAddress;
    ULONGLONG PageSize;    
    UCHAR Reserved2[8];
} TRANSLATION_REGISTER, *PTRANSLATION_REGISTER;

#endif // _I64FW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\i64fwasm.s ===
//++
//
//  Module name:
//
//      i64fwasm.s
//
//  Author:
//
//      Arad Rostampour (arad@fc.hp.com)  Mar-21-99
//
//  Description:
//
//      Assembly routines for calling into SAL, PAL, and setting up translation registers
//
//--

#include "ksia64.h"

        .sdata

//
// HalpSalSpinLock:
//
//  HAL private spinlock protecting generic SAL calls.
//

        .align     128
HalpSalSpinLock::
        data8      0

//
// HalpSalStateInfoSpinLock:
//
//  HAL private spinlock protecting specific SAL STATE_INFO calls.
//

        .align     128
HalpSalStateInfoSpinLock::
        data8      0

//
// HalpMcaSpinLock
//
//  HAL private spinlock protecting HAL internal MCA data structures and operations.
//  Including operations at IRQL DISPATCH_LEVEL and higher.
//

        .align     128
HalpMcaSpinLock::
        data8      0

//
// HalpInitSpinLock
//
//  HAL private spinlock protecting HAL internal INIT data structures and operations.
//  Including operations at IRQL DISPATCH_LEVEL and higher.
//

        .align     128
HalpInitSpinLock::
        data8      0

//
// HalpCmcSpinLock
//
//  HAL private spinlock protecting HAL internal CMC data structures and operations.
//  Including operations at IRQL DISPATCH_LEVEL and higher.
//

        .align     128
HalpCmcSpinLock::
        data8      0

//
// HalpCpeSpinLock
//
//  HAL private spinlock protecting HAL internal CPE data structures and operations.
//  Including operations at IRQL DISPATCH_LEVEL and higher.
//

        .align     128
HalpCpeSpinLock::
        data8      0

//
// Definitions used in this file
//
// Bits to set for the Mode argument in the HalpSetupTranslationRegisters call

#define SET_DTR_BIT     1
#define SET_ITR_BIT     0

// TR for PAL is:
//    ed=1, PPN=0 (to be ORed in), RWX privledge only for ring 0, dirty/accessed bit set,
//    cacheable memory, present bit set.

#define HAL_SAL_PAL_TR_ATTRIB TR_VALUE(1,0,3,0,1,1,0,1)
#define HAL_TR_ATTRIBUTE_PPN_MASK    0x0000FFFFFFFFF000

        .file   "i64fwasm.s"

        // These globals are defined in i64fw.c

        .global HalpSalProcPointer
        .global HalpSalProcGlobalPointer
        .global HalpPalProcPointer


//++
//
//  VOID
//  HalpSalProc(
//      LONGLONG a0, /* SAL function ID */
//      LONGLONG a1, /* SAL argument    */
//      LONGLONG a2, /* SAL argument    */
//      LONGLONG a3, /* SAL argument    */
//      LONGLONG a4, /* SAL argument    */
//      LONGLONG a5, /* SAL argument    */
//      LONGLONG a6, /* SAL argument    */
//      LONGLONG a7  /* SAL argument    */
//      );
//
//  Routine Description:
//      This is a simple assembly wrapper that jumps directly to the SAL code.  The ONLY
//      caller should be HalpSalCall.  Other users must use the HalpSalCall API for
//      calling into the SAL.
//
//  Return Values:
//      r8->r11 contain the 4 64-bit return values for SAL, r8 is the status
//--

        NESTED_ENTRY(HalpSalProc)
        NESTED_SETUP(8,3,8,0)
        
        // copy args to outs
        mov         out0 = a0
        mov         out1 = a1
        mov         out2 = a2
        mov         out3 = a3
        mov         out4 = a4
        mov         out5 = a5
        mov         out6 = a6
        mov         out7 = a7
        ;;
        // Simply load the address and branch to it

        addl        t1 = @gprel(HalpSalProcPointer), gp
        addl        t2 = @gprel(HalpSalProcGlobalPointer), gp
        ;;
        mov       loc2 = gp
        ld8         t0 = [t1]
        ;;
        ld8          gp = [t2]
        mov         bt0 = t0
        rsm         1 << PSR_I          // disable interrupts
        ;;                
        
        // br.sptk.many bt0
        br.call.sptk brp = bt0
        ;;

        mov           gp = loc2
        ssm         1 << PSR_I          // enable interrupts
        ;;
 
        NESTED_RETURN
        NESTED_EXIT(HalpSalProc)


//++
//
//  VOID
//  HalpPalProc(
//      LONGLONG a0, /* PAL function ID */
//      LONGLONG a1, /* PAL argument    */
//      LONGLONG a2, /* PAL argument    */
//      LONGLONG a3  /* PAL argument    */
//      );
//
//  Routine Description
//      This routine sets up the correct registers for input into PAL depending on
//      if the call uses static or stacked registers, turns off interrupts, ensures
//      the correct bank registers are being used and calls into the PAL.  The ONLY
//      caller should be HalpPalCall.  Other users must use the HalpPalCall API for
//      calling into the PAL.
//
//  Return Values:
//      r8->r11 contain the 4 64-bit return values for PAL, r8 is the status
//--

        NESTED_ENTRY(HalpPalProc)
        NESTED_SETUP(4,3,4,0)
        PROLOGUE_END

        // For both the static and stacked register conventions, load r28 with FunctionID

        mov     r28 = a0

        // If static register calling convention (1-255, 512-767), copy arguments to r29->r31
        // Otherwise, copy to out0->out3 so they are in r32->r35 in PAL_PROC

        mov     t0 = a0
        ;;
        shr     t0 = t0, 8
        ;;
        tbit.z pt0, pt1 = t0, 0
        ;;

        //
        // Static proc: do br not call
        //
(pt0)   mov         r29 = a1
(pt0)   mov         r30 = a2
(pt0)   mov         r31 = a3

        //
        // Stacked call
        //
(pt1)   mov     out0 = a0
(pt1)   mov     out1 = a1
(pt1)   mov     out2 = a2
(pt1)   mov     out3 = a3

        // Load up the address of PAL_PROC and call it

        addl     t1 = @gprel(HalpPalProcPointer), gp
        ;;
        ld8      t0 = [t1]
        ;;
        mov      bt0 = t0

        // Call into PAL_PROC

(pt0)   addl t1 = @ltoff(PalReturn), gp
        ;;
(pt0)   ld8 t0 = [t1]
        ;;
(pt0)   mov brp = t0
        ;;
        // Disable interrupts

        DISABLE_INTERRUPTS(loc2)
        ;;
        srlz.d
        ;;
(pt0)   br.sptk.many bt0
        ;;
(pt1)   br.call.sptk brp = bt0        
        ;;
PalReturn:
        // Restore the interrupt state

        RESTORE_INTERRUPTS(loc2)
        ;;
        NESTED_RETURN
        NESTED_EXIT(HalpPalProc)


//++
//
//  VOID
//  HalpPalProcPhysicalStatic(
//      LONGLONG a0, /* PAL function ID */
//      LONGLONG a1, /* PAL argument    */
//      LONGLONG a2, /* PAL argument    */
//      LONGLONG a3  /* PAL argument    */
//      );
//
//  Routine Description
//      This routine sets up the correct registers for input into PAL turns off interrupts, 
//      ensures the correct bank registers are being used and calls into the PAL in PHYSICAL
//      mode since some of the calls require it.  The ONLY caller should be HalpPalCall.  
//      Other users must use the HalpPalCall API for calling into the PAL.
//
//  Return Values:
//      r8->r11 contain the 4 64-bit return values for PAL, r8 is the status
//--

        NESTED_ENTRY(HalpPalProcPhysicalStatic)
        NESTED_SETUP(4,3,4,0)
        PROLOGUE_END

        mov     r28 = a0
        mov     r29 = a1
        mov     r30 = a2
        mov     r31 = a3

        // Disable interrupts

        DISABLE_INTERRUPTS(loc2)

        ;;
        srlz.d
        ;;

        // For now, return unimplemented
        //
        // Need to switch into physical mode before calling into PAL, so could:
        //
        // a) Map everything through Region 4, simply turn off translation, and
        // be identity mapped in an uncacheable area (any issues?)
        //
        // b) Setup IIP and IPSR to jump to a physical address in physical mode
        // by doing an RFI.

        movl    r8 = -1
        movl    r9 = 0
        movl    r10 = 0
        movl    r11 = 0

        // Restore the interrupt state

        RESTORE_INTERRUPTS(loc2)
        ;;

        srlz.d
        ;;

        NESTED_RETURN
        NESTED_EXIT(HalpPalProcPhysicalStatic)

//++
//
//  VOID
//  HalpPalProcPhysicalStacked(
//      LONGLONG a0, /* PAL function ID */
//      LONGLONG a1, /* PAL argument    */
//      LONGLONG a2, /* PAL argument    */
//      LONGLONG a3  /* PAL argument    */
//      );
//
//  Routine Description
//      This routine calls PAL in physical mode for the stacked calling
//      convention.  The ONLY caller should be HalpPalCall. Other users must 
//      use the HalpPalCall API for calling into the PAL.
//
//  Return Values:
//      r8->r11 contain the 4 64-bit return values for PAL, r8 is the status
//--

        NESTED_ENTRY(HalpPalProcPhysicalStacked)
        NESTED_SETUP(4,3,4,0)
        PROLOGUE_END

        // Setup the input parameters for PAL (note r28 must specify the function ID as well)

        mov     r28  = a0
        mov     out0 = a0
        mov     out1 = a1
        mov     out2 = a2
        mov     out3 = a3

        // Disable interrupts

        DISABLE_INTERRUPTS(loc2)

        ;;
        srlz.d
        ;;

        // For now, return unimplemented as we can not transition to physical
        // mode using RFI with the stacked convention.  There are RSE issues
        // as well as needing psr.ic bit set to set IIP and other registers, 
        // but memory arguments aren't mapped with a TR, so they could cause
        // a fault.

        movl    r8 = -1
        movl    r9 = 0
        movl    r10 = 0
        movl    r11 = 0

        // Restore the interrupt state

        RESTORE_INTERRUPTS(loc2)
        ;;

        srlz.d
        ;;
        NESTED_RETURN
        NESTED_EXIT(HalpPalProcPhysicalStacked)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\i64fw.c ===
/*++

Copyright (c) 1995  Intel Corporation

Module Name:

    i64fw.c

Abstract:

    This module implements the routines that transfer control
    from the kernel to the PAL and SAL code.

Author:

    Arad Rostampour (arad@fc.hp.com)    Mar-21-99

Environment:

    Kernel mode

Revision History:


--*/

#include "halp.h"
#include "arc.h"
#include "arccodes.h"
#include "i64fw.h"

#include <efi.h>


extern KSPIN_LOCK HalpSalSpinLock;
extern KSPIN_LOCK HalpSalStateInfoSpinLock;

BOOLEAN
MmSetPageProtection(
    IN PVOID VirtualAddress,
    IN SIZE_T NumberOfBytes,
    IN ULONG NewProtect
    );

VOID
HalpReboot (
    VOID
    );


HALP_SAL_PAL_DATA HalpSalPalData;
ULONGLONG HalpSalProcPointer=0;
ULONGLONG HalpSalProcGlobalPointer=0;
ULONGLONG HalpPalProcPointer=0;

// Testing #defines
//
//#define SAL_TEST
//#define PAL_TEST

#if DBG
ULONG HalpDebugTestSalPalCall=0;
#endif


LONGLONG
HalCallPal(
    IN  ULONGLONG FunctionIndex,
    IN  ULONGLONG Arguement1,
    IN  ULONGLONG Arguement2,
    IN  ULONGLONG Arguement3,
    OUT PULONGLONG ReturnValue0,
    OUT PULONGLONG ReturnValue1,
    OUT PULONGLONG ReturnValue2,
    OUT PULONGLONG ReturnValue3
    )

/*++


--*/
{

    //
    // Will interface to PAL Calls.
    //
    LONGLONG Status;

    SAL_PAL_RETURN_VALUES rv = {0};
    PSAL_PAL_RETURN_VALUES p = &rv;

    Status = (LONGLONG) HalpPalCall(FunctionIndex,Arguement1,Arguement2,Arguement3,p);

    if (ReturnValue0 != 0) // Check the pointer is not NULL

        *ReturnValue0 = (ULONGLONG)(p -> ReturnValues[0]);

   if (ReturnValue1 != 0)  // check the pointer is not NULL

        *ReturnValue1 = (ULONGLONG)(p -> ReturnValues[1]);

   if (ReturnValue2 != 0)  // check the pointer is not NULL

        *ReturnValue2 = (ULONGLONG)(p -> ReturnValues[2]);

   if (ReturnValue3 != 0)  // check the pointer is not NULL

        *ReturnValue3 = (ULONGLONG)(p -> ReturnValues[3]);

    return Status;

}

SAL_STATUS
HalpSalCall(
    IN LONGLONG FunctionId,
    IN LONGLONG Arg1,
    IN LONGLONG Arg2,
    IN LONGLONG Arg3,
    IN LONGLONG Arg4,
    IN LONGLONG Arg5,
    IN LONGLONG Arg6,
    IN LONGLONG Arg7,
    OUT PSAL_PAL_RETURN_VALUES ReturnValues
    )
/*++

Routine Description:

    This function is a wrapper function for making a SAL call.  Callers within the
    HAL must use this function to call the SAL.

Arguments:

    FunctionId - The SAL function ID
    Arg1-Arg7 - SAL defined arguments for each call
    ReturnValues - A pointer to an array of 4 64-bit return values

Return Value:

    SAL's return status, return value 0, is returned in addition to the ReturnValues structure
    being filled

--*/

{
    KIRQL OldIrql;
    KIRQL TempIrql;
    BOOLEAN fixLogId;

    // Zero out the return buffer

    RtlZeroMemory(ReturnValues,sizeof(SAL_PAL_RETURN_VALUES));

    if (!NT_SUCCESS(HalpSalPalData.Status)) {
        ReturnValues->ReturnValues[0] = SAL_STATUS_NOT_IMPLEMENTED;
        return (ReturnValues->ReturnValues[0]);
    }
    fixLogId = HalpSalPalData.Flags & HALP_SALPAL_FIX_MCE_LOG_ID;

    KeRaiseIrql(HIGH_LEVEL, &OldIrql);

    switch (FunctionId) {

        // These calls are neither re-entrant, nor MP-safe as defined by the SAL spec

        case SAL_SET_VECTORS:
        case SAL_MC_SET_PARAMS:
        case SAL_FREQ_BASE:

            KiAcquireSpinLock(&HalpSalSpinLock);
            *ReturnValues = HalpSalProc(FunctionId,Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7);
            KiReleaseSpinLock(&HalpSalSpinLock);
            break;

        case SAL_GET_STATE_INFO:
           KiAcquireSpinLock(&HalpSalStateInfoSpinLock);
           *ReturnValues = HalpSalProc(FunctionId,Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7);
           if ( fixLogId && (ReturnValues->ReturnValues[0] >= (LONGLONG)0) )    {
              // ERROR_RECORD_HEADER.Id++
              *(PULONGLONG)((ULONGLONG)Arg3) = ++HalpSalPalData.Reserved[0]; 
           }
           KiReleaseSpinLock(&HalpSalStateInfoSpinLock);
           break;

        case SAL_GET_STATE_INFO_SIZE:
        case SAL_CLEAR_STATE_INFO:

           KiAcquireSpinLock(&HalpSalStateInfoSpinLock);
           *ReturnValues = HalpSalProc(FunctionId,Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7);
           KiReleaseSpinLock(&HalpSalStateInfoSpinLock);
           break;

        case SAL_PCI_CONFIG_READ:
        case SAL_PCI_CONFIG_WRITE:

            KiAcquireSpinLock(&HalpSalSpinLock);
            *ReturnValues = HalpSalProc(FunctionId,Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7);
            KiReleaseSpinLock(&HalpSalSpinLock);
            break;

        //
        // Move these to MP safe after SAL is fixed
        // Kernel ensures only one CACHE_FLUSH at a time
        //

        case SAL_CACHE_INIT:
        case SAL_CACHE_FLUSH:
            if ( HalpSalPalData.Flags & HALP_SALPAL_FIX_MP_SAFE )    {
                KiAcquireSpinLock(&HalpSalSpinLock);
                *ReturnValues = HalpSalProc(FunctionId,Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7);
                KiReleaseSpinLock(&HalpSalSpinLock);
            }
            else
                *ReturnValues = HalpSalProc(FunctionId,Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7);
            break;

        //
        // These SAL calls are MP-safe, but not re-entrant
        //

        case SAL_MC_RENDEZ:
            *ReturnValues = HalpSalProc(FunctionId,Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7);
            break;

        //
        // These calls are not supported at this time
        //

        case SAL_UPDATE_PAL:  // needs end of firmware space to be mapped, and possible authentication code to execute

        default:
            ReturnValues->ReturnValues[0] = SAL_STATUS_NOT_IMPLEMENTED;
    }

    KeLowerIrql(OldIrql);

#ifdef SAL_TEST
    if (ReturnValues->ReturnValues[0] == SAL_STATUS_NOT_IMPLEMENTED) {
        InternalTestSal(FunctionId,Arg1,Arg2,Arg3,Arg4,Arg5,Arg6,Arg7,ReturnValues);
    }
#endif

    HalDebugPrint(( HAL_INFO,
                    "HAL: Got out of SAL call #0x%I64x with status 0x%I64x and RetVals 0x%I64x, 0x%I64x, 0x%I64x\n",
                    FunctionId,
                    ReturnValues->ReturnValues[0],
                    ReturnValues->ReturnValues[1],
                    ReturnValues->ReturnValues[2],
                    ReturnValues->ReturnValues[3] ));

    return (ReturnValues->ReturnValues[0]);

}


PAL_STATUS
HalpPalCall(
    IN LONGLONG FunctionId,
    IN LONGLONG Arg1,
    IN LONGLONG Arg2,
    IN LONGLONG Arg3,
    OUT PSAL_PAL_RETURN_VALUES ReturnValues
    )

/*++

Routine Description:

    This function is a wrapper function for making a PAL call.  Callers within the
    HAL must use this function to call the PAL.

Arguments:

    FunctionId - The PAL function ID
    Arg1-Arg3 - PAL defined arguments for each call
    ReturnValues - A pointer to an array of 4 64-bit return values

Return Value:

    PAL's return status, return value 0, is returned in addition to the ReturnValues structure
    being filled

Assumptions:

    PAL is being called with psr.bn = 1 in all cases (not from an interrupted state)

--*/
{
    KIRQL OldIrql;


    // Zero out the return buffer

    RtlZeroMemory(ReturnValues,sizeof(SAL_PAL_RETURN_VALUES));

    if (!NT_SUCCESS(HalpSalPalData.Status)) {
        ReturnValues->ReturnValues[0] = PAL_STATUS_NOT_IMPLEMENTED;
        return (ReturnValues->ReturnValues[0]);
    }

    // Only allow PAL calls that are supported

    switch (FunctionId) {

        // Virtual mode PAL calls

        case PAL_CACHE_FLUSH:
        case PAL_CACHE_INFO:
        case PAL_CACHE_INIT:
        case PAL_CACHE_PROT_INFO:
        case PAL_CACHE_SUMMARY:
        case PAL_PTCE_INFO:
        case PAL_VM_INFO:
        case PAL_VM_PAGE_SIZE:
        case PAL_VM_SUMMARY:
        case PAL_PERF_MON_INFO:
        case PAL_MC_CLEAR_LOG:
        case PAL_MC_DRAIN:
        case PAL_MC_ERROR_INFO:
        case PAL_HALT:
        case PAL_HALT_INFO:
        case PAL_HALT_LIGHT:
        case PAL_PREFETCH_VISIBILITY:
        case PAL_SHUTDOWN:
        case PAL_FREQ_RATIOS:
        case PAL_VERSION:

            // PAL is MP-safe, but not re-entrant, so just raise IRQL

            KeRaiseIrql(SYNCH_LEVEL, &OldIrql);
            *ReturnValues = HalpPalProc(FunctionId,Arg1,Arg2,Arg3);
            KeLowerIrql(OldIrql);
            break;

        // Physical mode, static PAL calls

        case PAL_MEM_ATTRIB:
        case PAL_BUS_GET_FEATURES:
        case PAL_BUS_SET_FEATURES:
        case PAL_DEBUG_INFO:
        case PAL_FIXED_ADDR:
        case PAL_FREQ_BASE:
        case PAL_PLATFORM_ADDR:
        case PAL_PROC_GET_FEATURES:
        case PAL_PROC_SET_FEATURES:
        case PAL_REGISTER_INFO:
        case PAL_RSE_INFO:
        case PAL_MC_DYNAMIC_STATE:
        case PAL_MC_EXPECTED:
        case PAL_MC_REGISTER_MEM:
        case PAL_MC_RESUME:
        case PAL_CACHE_LINE_INIT:
        case PAL_MEM_FOR_TEST:
        case PAL_COPY_INFO:
        case PAL_ENTER_IA_32_ENV:
        case PAL_PMI_ENTRYPOINT:

            // PAL is MP-safe, but not re-entrant, so just raise IRQL

            KeRaiseIrql(SYNCH_LEVEL, &OldIrql);
            *ReturnValues = HalpPalProcPhysicalStatic(FunctionId,Arg1,Arg2,Arg3);
            KeLowerIrql(OldIrql);
            break;

        // Physical mode, stacked PAL calls

        case PAL_VM_TR_READ:
        case PAL_CACHE_READ:
        case PAL_CACHE_WRITE:
        case PAL_TEST_PROC:
        case PAL_COPY_PAL:

            // PAL is MP-safe, but not re-entrant, so just raise IRQL

            KeRaiseIrql(SYNCH_LEVEL, &OldIrql);
            *ReturnValues = HalpPalProcPhysicalStacked(FunctionId,Arg1,Arg2,Arg3);
            KeLowerIrql(OldIrql);
            break;

        default:
            HalDebugPrint(( HAL_ERROR, "HAL: Unknown PAL Call ProcId #0x%I64x\n", FunctionId ));
            ReturnValues->ReturnValues[0] = PAL_STATUS_NOT_IMPLEMENTED;
    }

#ifdef PAL_TEST
    if (ReturnValues->ReturnValues[0] == PAL_STATUS_NOT_IMPLEMENTED) {
        InternalTestPal(FunctionId,Arg1,Arg2,Arg3,ReturnValues);
    }
#endif

    HalDebugPrint(( HAL_INFO,
                    "HAL: Got out of PAL call #0x%I64x with status 0x%I64x and RetVals 0x%I64x, 0x%I64x, 0x%I64x\n",
                    FunctionId,
                    ReturnValues->ReturnValues[0],
                    ReturnValues->ReturnValues[1],
                    ReturnValues->ReturnValues[2],
                    ReturnValues->ReturnValues[3] ));

    return (ReturnValues->ReturnValues[0]);
}


VOID
HalReturnToFirmware(
    IN FIRMWARE_ENTRY Routine
    )

/*++

Routine Description:

    Returns control to the firmware routine specified.  Since the simulation
    does not provide PAL and SAL support, it just stops the system.

    System reboot can be done here.

Arguments:

    Routine - Supplies a value indicating which firmware routine to invoke.

Return Value:

    Does not return.

--*/

{
    switch (Routine) {
    case HalHaltRoutine:
    case HalPowerDownRoutine:
    case HalRestartRoutine:
    case HalRebootRoutine:
        HalpReboot();
        break;

    default:
        HalDebugPrint(( HAL_INFO, "HAL: HalReturnToFirmware called\n" ));
        DbgBreakPoint();
        break;
    }
}

ARC_STATUS
HalGetEnvironmentVariable (
    IN PCHAR Variable,
    IN USHORT Length,
    OUT PCHAR Buffer
    )

/*++

Routine Description:

    This function locates an environment variable and returns its value.

     The following system environment variables are supported:

    variable                value

    LastKnownGood           FALSE
    SYSTEMPARTITION         multi(0)disk(0)rdisk(0)partition(1)
    OSLOADER                multi(0)disk(0)rdisk(0)partition(1)\osloader.exe
    OSLOADPARTITION         multi(0)disk(0)rdisk(0)partition(1)
    OSLOADFILENAME          \WINNT
    LOADIDENTIFIER          Windows NT
    COUNTDOWN               10
    AUTOLOAD                YES


    The only environment variable this implementation supports is
    "LastKnownGood".  The returned value is always "FALSE".

Arguments:

    Variable - Supplies a pointer to a zero terminated environment variable
        name.

    Length - Supplies the length of the value buffer in bytes.

    Buffer - Supplies a pointer to a buffer that receives the variable value.

Return Value:

    ESUCCESS is returned if the enviroment variable is located. Otherwise,
    ENOENT is returned.

--*/

{
    return ENOENT;
}


ARC_STATUS
HalSetEnvironmentVariable (
   IN PCHAR Variable,
   IN PCHAR Value
   )

/*++

Routine Description:

   This function creates an environment variable with the specified value.

   The environment variable this implementation supports is

   LastKnownGood
   SYSTEMPARTITION
   OSLOADER
   OSLOADPARTITION
   OSLOADFILENAME
   OSLOADOPTIONS
   LOADIDENTIFIER
   COUNTDOWN
   AUTOLOAD

   For all bug LastKnowGood we return ESUCCESS, but don't actually do
   anything.

Arguments:

   Variable - Supplies a pointer to an environment variable name.

   Value - Supplies a pointer to the environment variable value.

Return Value:

   ESUCCESS is returned if the environment variable is created. Otherwise,
   ENOMEM is returned.

--*/

{

   return ENOENT;

}

NTSTATUS
HalGetEnvironmentVariableEx (
    IN PWSTR VariableName,
    IN LPGUID VendorGuid,
    OUT PVOID Value,
    IN OUT PULONG ValueLength,
    OUT PULONG Attributes OPTIONAL
    )

/*++

Routine Description:

    This function locates an environment variable and returns its value.

Arguments:

    VariableName - The name of the variable to query. This is a null-terminated
        Unicode string.

    VendorGuid - The GUID for the vendor associated with the variable.

    Value - The address of the buffer into which the variable value is to be copied.

    ValueLength - On input, the length in bytes of the Value buffer. On output,
        the length in bytes of the variable value. If the input buffer is large
        enough, then ValueLength indicates the amount of data copied into Value.
        If the input buffer is too small, then nothing is copied into the buffer,
        and ValueLength indicates the required buffer length.

    Attributes - Returns the attributes of the variable.

Return Value:

    STATUS_SUCCESS              The function succeeded.
    STATUS_BUFFER_TOO_SMALL     The input buffer was too small.
    STATUS_VARIABLE_NOT_FOUND   The requested variable does not exist.
    STATUS_INVALID_PARAMETER    One of the parameters is invalid.
    STATUS_UNSUPPORTED          The HAL does not support this function.
    STATUS_UNSUCCESSFUL         The firmware returned an unrecognized error.

--*/

{
    NTSTATUS ntStatus;
    EFI_STATUS efiStatus;
    ULONGLONG wideValueLength = *ValueLength;
    ULONGLONG wideAttributes;

    efiStatus = HalpCallEfi (
                    EFI_GET_VARIABLE_INDEX,
                    (ULONGLONG)VariableName,
                    (ULONGLONG)VendorGuid,
                    (ULONGLONG)&wideAttributes,
                    (ULONGLONG)&wideValueLength,
                    (ULONGLONG)Value,
                    0,
                    0,
                    0
                    );

    *ValueLength = (ULONG)wideValueLength;
    if ( ARGUMENT_PRESENT(Attributes) ) {
        *Attributes = (ULONG)wideAttributes;
    }
    switch (efiStatus) {
    case EFI_SUCCESS:
        ntStatus = STATUS_SUCCESS;
        break;
    case EFI_NOT_FOUND:
        ntStatus = STATUS_VARIABLE_NOT_FOUND;
        break;
    case EFI_BUFFER_TOO_SMALL:
        ntStatus = STATUS_BUFFER_TOO_SMALL;
        break;
    case EFI_INVALID_PARAMETER:
        ntStatus = STATUS_INVALID_PARAMETER;
        break;
    default:
        ntStatus = STATUS_UNSUCCESSFUL;
        break;
    }

    return ntStatus;
}

NTSTATUS
HalSetEnvironmentVariableEx (
    IN PWSTR VariableName,
    IN LPGUID VendorGuid,
    IN PVOID Value,
    IN ULONG ValueLength,
    IN ULONG Attributes
    )

/*++

Routine Description:

   This function creates an environment variable with the specified value.

Arguments:

    VariableName - The name of the variable to set. This is a null-terminated
        Unicode string.

    VendorGuid - The GUID for the vendor associated with the variable.

    Value - The address of the buffer containing the new variable value.

    ValueLength - The length in bytes of the Value buffer.

    Attributes - The attributes of the variable. The attribute bit
        VARIABLE_ATTRIBUTE_NON_VOLATILE MUST be set.

Return Value:

    STATUS_SUCCESS                  The function succeeded.
    STATUS_INSUFFICIENT_RESOURCES   Not enough storage is available.
    STATUS_INVALID_PARAMETER        One of the parameters is invalid.
    STATUS_UNSUPPORTED              The HAL does not support this function.
    STATUS_UNSUCCESSFUL             The firmware returned an unrecognized error.

--*/

{
    NTSTATUS ntStatus;
    EFI_STATUS efiStatus;

    if ( (Attributes & VARIABLE_ATTRIBUTE_NON_VOLATILE) == 0 ) {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // First, delete the old value, if it exists. This is necessary to ensure that
    // the attributes specified to this routine are correctly applied.
    //

    efiStatus = HalpCallEfi (
                    EFI_SET_VARIABLE_INDEX,
                    (ULONGLONG)VariableName,
                    (ULONGLONG)VendorGuid,
                    (ULONGLONG)0,           // Attributes
                    (ULONGLONG)0,           // ValueLength
                    (ULONGLONG)NULL,        // Value
                    0,
                    0,
                    0
                    );

    //
    // Now create the new variable, unless the ValueLength is zero. In that
    // case, the caller actually wanted the variable deleted, which we just did.
    //

    if (ValueLength != 0) {
        efiStatus = HalpCallEfi (
                        EFI_SET_VARIABLE_INDEX,
                        (ULONGLONG)VariableName,
                        (ULONGLONG)VendorGuid,
                        (ULONGLONG)EFI_VARIABLE_ATTRIBUTE,
                        (ULONGLONG)ValueLength,
                        (ULONGLONG)Value,
                        0,
                        0,
                        0
                        );
    }

    switch (efiStatus) {
    case EFI_SUCCESS:
        ntStatus = STATUS_SUCCESS;
        break;
    case EFI_NOT_FOUND:
        ntStatus = STATUS_VARIABLE_NOT_FOUND;
        break;
    case EFI_OUT_OF_RESOURCES:
        ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        break;
    case EFI_INVALID_PARAMETER:
        ntStatus = STATUS_INVALID_PARAMETER;
        break;
    default:
        ntStatus = STATUS_UNSUCCESSFUL;
        break;
    }

    return ntStatus;
}

NTSTATUS
HalEnumerateEnvironmentVariablesEx (
    IN ULONG InformationClass,
    OUT PVOID Buffer,
    IN OUT PULONG BufferLength
    )

/*++

Routine Description:

    This function returns information about system environment variables.

Arguments:

    InformationClass - Specifies the type of information to return.

    Buffer - The address of the buffer that is to receive the returned data.
        The format of the returned data depends on InformationClass.

    BufferLength - On input, the length in bytes of the buffer. On output,
        the length in bytes of the returned data. If the input buffer is
        large enough, then BufferLength indicates the amount of data copied
        into Buffer. If the input buffer is too small, then BufferLength
        indicates the required buffer length.

Return Value:

    STATUS_SUCCESS              The function succeeded.
    STATUS_BUFFER_TOO_SMALL     The input buffer was too small.
    STATUS_INVALID_PARAMETER    One of the parameters is invalid.
    STATUS_UNSUPPORTED          The HAL does not support this function.
    STATUS_UNSUCCESSFUL         The firmware returned an unrecognized error.

--*/

{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    EFI_STATUS efiStatus;
    PUCHAR currentPtr;
    PVARIABLE_NAME name;
    PVARIABLE_NAME_AND_VALUE nameAndValue;
    PVARIABLE_NAME previousEntry;
    PWCHAR previousName;
    ULONG variableNameLength;
    GUID guid;
    ULONG baseLength;
    ULONG remainingLength;
    PUCHAR valuePtr;
    ULONG valueLength;
    PULONG attrPtr;
    LOGICAL filling;
    ULONG requiredLength;

#define MAX_VARIABLE_NAME 255

    WCHAR variableName[MAX_VARIABLE_NAME + 1];

    if ( (InformationClass != VARIABLE_INFORMATION_NAMES) &&
         (InformationClass != VARIABLE_INFORMATION_VALUES) ) {
        return STATUS_INVALID_PARAMETER;
    }

    if ( ALIGN_DOWN_POINTER(Buffer, ULONG) != Buffer ) {
        return STATUS_INVALID_PARAMETER;
    }

    if ( InformationClass == VARIABLE_INFORMATION_NAMES ) {
        baseLength = FIELD_OFFSET( VARIABLE_NAME, Name );
    } else {
        baseLength = FIELD_OFFSET( VARIABLE_NAME_AND_VALUE, Name );
    }

    currentPtr = Buffer;
    remainingLength = *BufferLength;

    filling = (LOGICAL)(remainingLength != 0);
    if ( !filling ) {
        ntStatus = STATUS_BUFFER_TOO_SMALL;
    }

    previousEntry = NULL;

    variableName[0] = 0;

    while ( TRUE ) {

        variableNameLength = (MAX_VARIABLE_NAME + 1) * sizeof(WCHAR);

        {
            ULONGLONG wideLength = variableNameLength;

            efiStatus = HalpCallEfi (
                            EFI_GET_NEXT_VARIABLE_NAME_INDEX,
                            (ULONGLONG)&wideLength,
                            (ULONGLONG)variableName,
                            (ULONGLONG)&guid,
                            0,
                            0,
                            0,
                            0,
                            0
                            );

            variableNameLength = (ULONG)wideLength;
        }

        switch (efiStatus) {
        case EFI_SUCCESS:
            break;
        case EFI_NOT_FOUND:
            break;
        default:
            ntStatus = STATUS_UNSUCCESSFUL;
            break;
        }

        if ( efiStatus != EFI_SUCCESS ) {
            break;
        }

        if ( ALIGN_UP_POINTER(currentPtr, ULONG) != currentPtr ) {
            PUCHAR alignedPtr = ALIGN_UP_POINTER( currentPtr, ULONG );
            ULONG fill = (ULONG)(alignedPtr - currentPtr);
            currentPtr = alignedPtr;
            if ( remainingLength < fill ) {
                filling = FALSE;
                remainingLength = 0;
                ntStatus = STATUS_BUFFER_TOO_SMALL;
            } else {
                remainingLength -= fill;
            }
        }

        requiredLength = baseLength + variableNameLength;
        if ( InformationClass != VARIABLE_INFORMATION_NAMES ) {
            requiredLength = ALIGN_UP( requiredLength, ULONG );
        }

        if ( remainingLength < requiredLength ) {

            remainingLength = 0;
            filling = FALSE;
            ntStatus = STATUS_BUFFER_TOO_SMALL;

        } else {

            remainingLength -= requiredLength;
        }

        name = (PVARIABLE_NAME)currentPtr;
        nameAndValue = (PVARIABLE_NAME_AND_VALUE)currentPtr;

        if ( InformationClass == VARIABLE_INFORMATION_NAMES ) {

            if ( filling ) {

                RtlCopyMemory( &name->VendorGuid, &guid, sizeof(GUID) );
                wcscpy( name->Name, variableName );

                if ( previousEntry != NULL ) {
                    previousEntry->NextEntryOffset = (ULONG)(currentPtr - (PUCHAR)previousEntry);
                }
                previousEntry = (PVARIABLE_NAME)currentPtr;
            }

            currentPtr += requiredLength;

        } else {

            ULONGLONG wideLength;
            ULONGLONG wideAttr;

            if ( filling ) {

                RtlCopyMemory( &nameAndValue->VendorGuid, &guid, sizeof(GUID) );
                wcscpy( nameAndValue->Name, variableName );

                valuePtr = (PUCHAR)nameAndValue->Name + variableNameLength;
                valuePtr = ALIGN_UP_POINTER( valuePtr, ULONG );
                valueLength = remainingLength;
                attrPtr = &nameAndValue->Attributes;

                nameAndValue->ValueOffset = (ULONG)(valuePtr - (PUCHAR)nameAndValue);

            } else {

                valuePtr = NULL;
                valueLength = 0;
                attrPtr = NULL;
            }

            wideLength = valueLength;

            efiStatus = HalpCallEfi (
                            EFI_GET_VARIABLE_INDEX,
                            (ULONGLONG)variableName,
                            (ULONGLONG)&guid,
                            (ULONGLONG)&wideAttr,
                            (ULONGLONG)&wideLength,
                            (ULONGLONG)valuePtr,
                            0,
                            0,
                            0
                            );

            valueLength = (ULONG)wideLength;
            if ( attrPtr != NULL ) {
                *attrPtr = (ULONG)wideAttr;
            }

            switch (efiStatus) {
            case EFI_SUCCESS:
                if ( filling ) {
                    nameAndValue->ValueLength = valueLength;
                    remainingLength -= valueLength;
                    if ( previousEntry != NULL ) {
                        previousEntry->NextEntryOffset = (ULONG)(currentPtr - (PUCHAR)previousEntry);
                    }
                    previousEntry = (PVARIABLE_NAME)currentPtr;
                }
                break;
            case EFI_BUFFER_TOO_SMALL:
                efiStatus = EFI_SUCCESS;
                remainingLength = 0;
                filling = FALSE;
                ntStatus = STATUS_BUFFER_TOO_SMALL;
                break;
            default:
                ntStatus = STATUS_UNSUCCESSFUL;
                break;
            }

            if ( efiStatus != EFI_SUCCESS ) {
                break;
            }

            currentPtr += requiredLength + valueLength;
        }
    }

    if ( previousEntry != NULL ) {
        previousEntry->NextEntryOffset = 0;
    }

    *BufferLength = (ULONG)(currentPtr - (PUCHAR)Buffer);

    return ntStatus;
}

NTSTATUS
HalpGetPlatformId(
    OUT PHAL_PLATFORM_ID PlatformId
    )
/*++

Routine Description:

    This function fills in the ANSI_STRING structures for the Vendor and Device IDs out
    of the SalSystemTable.

Arguments:

    PlatformId - Pointer to a structure with two ANSI_STRING structures for Vendor/DeviceIds

Return Value:

    STATUS_SUCCESS if SalSystemTable available, otherwise STATUS_UNSUCCESSFUL

Assumptions:

    The two strings in PlatformId will not be freed or modified, and are therefore pointing
    directly to the SalSystemTable.

--*/

{
    UCHAR i;

    // Initialize the VendorId ANSI_STRING structure to point to SalSystemTable entry
    // Note, both strings are either NULL terminated OR exactly 32-bytes in length and
    // not NULL terminated.

    if (!NT_SUCCESS(HalpSalPalData.Status)) {
        return STATUS_UNSUCCESSFUL;
    }

    i=0;;
    while (HalpSalPalData.SalSystemTable->OemId[i] && i < OEM_ID_LENGTH) {
        i++;
    }
    PlatformId->VendorId.Buffer = HalpSalPalData.SalSystemTable->OemId;
    PlatformId->VendorId.Length = i;
    PlatformId->VendorId.MaximumLength = i;

    // Initialize the DeviceId ANSI_STRING structure to point to SalSystemTable entry

    i=0;
    while (HalpSalPalData.SalSystemTable->ProductId[i] && i < OEM_PRODUCT_ID_LENGTH) {
        i++;
    }
    PlatformId->DeviceId.Buffer = HalpSalPalData.SalSystemTable->ProductId;
    PlatformId->DeviceId.Length = i;
    PlatformId->DeviceId.MaximumLength = i;

    return STATUS_SUCCESS;
}


/*****************************************************************
TEST CODE FOR THE SAL AND PAL:

  These routines provide an infrastructure for supporting SAL and
  PAL calls not supported by firmware, overriding there meaning
  if SAL or PAL returns STATUS_NOT_IMPLEMENTED.  The #define for
  SAL_TEST and/or PAL_TEST must be defined for this behavior.

*****************************************************************/
ULONG
NoSalPCIRead(
    IN ULONG Tok,
    IN ULONG Size
    )
{
    ULONG Data;
    ULONG i = Tok % sizeof(ULONG);

    WRITE_PORT_ULONG((PULONG)0xcf8, 0x80000000 | Tok);
    switch (Size) {
        case 1: Data = READ_PORT_UCHAR((PUCHAR)(ULongToPtr(0xcfc + i) )); break;
        case 2: Data = READ_PORT_USHORT((PUSHORT)(ULongToPtr(0xcfc + i) )); break;
        case 4: Data = READ_PORT_ULONG((PULONG)(0xcfc)); break;
    }
    return(Data);
}

VOID
NoSalPCIWrite(
    IN ULONG Tok,
    IN ULONG Size,
    IN ULONG Data
    )
{
    ULONG i = Tok % sizeof(ULONG);

    WRITE_PORT_ULONG((PULONG)0xcf8, 0x80000000 | Tok);
    switch (Size) {
        case 1: WRITE_PORT_UCHAR((PUCHAR)(ULongToPtr(0xcfc + i) ), (UCHAR)Data); break;
        case 2: WRITE_PORT_USHORT((PUSHORT)(ULongToPtr(0xcfc + i) ), (USHORT)Data); break;
        case 4: WRITE_PORT_ULONG((PULONG)(0xcfc), Data); break;
    }
}


#define PCIBUS(Tok) (((ULONG)(Tok) >> 16) & 0xff)
#define PCIDEV(Tok) (((ULONG)(Tok) >> 11) & 0x1f)
#define PCIFUNC(Tok) (((ULONG)(Tok) >> 8) & 0x7)
#define PCIOFF(Tok)  (((ULONG)(Tok) >> 2) & 0x3f)

VOID
InternalTestSal(
    IN LONGLONG FunctionId,
    IN LONGLONG Arg1,
    IN LONGLONG Arg2,
    IN LONGLONG Arg3,
    IN LONGLONG Arg4,
    IN LONGLONG Arg5,
    IN LONGLONG Arg6,
    IN LONGLONG Arg7,
    OUT PSAL_PAL_RETURN_VALUES ReturnValues
    )
{
    switch (FunctionId) {

        case SAL_PCI_CONFIG_READ: {
            ULONG Data;
            HalDebugPrint(( HAL_INFO, "HAL: << SAL_PCI_CONFIG_READ - Bus: %d Dev: %2d Func: %d  Off: %2d Size = %d ",
                            PCIBUS(Arg1), PCIDEV(Arg1), PCIFUNC(Arg1), PCIOFF(Arg1), Arg2 ));
            ReturnValues->ReturnValues[0] = SAL_STATUS_SUCCESS;
            ReturnValues->ReturnValues[1] = Data = NoSalPCIRead((ULONG)Arg1, (ULONG)Arg2);
            HalDebugPrint(( HAL_INFO, " Data = 0x%08x\n", Data ));
            break;
        }

        case SAL_PCI_CONFIG_WRITE:
            HalDebugPrint(( HAL_INFO, "HAL: >> SAL_PCI_CONFIG_WRITE: Bus: %d Dev: %2d Func: %d Off: %2d  Size = %d Val = 0x%08x\n",
                            PCIBUS(Arg1), PCIDEV(Arg1), PCIFUNC(Arg1), PCIOFF(Arg1), Arg2, Arg3 ));
            NoSalPCIWrite((ULONG)Arg1, (ULONG)Arg2, (ULONG)Arg3);
            ReturnValues->ReturnValues[0] = SAL_STATUS_SUCCESS;
            break;

        default:
            ReturnValues->ReturnValues[0] = SAL_STATUS_NOT_IMPLEMENTED;
    }
}

VOID
InternalTestPal(
    IN LONGLONG FunctionId,
    IN LONGLONG Arg1,
    IN LONGLONG Arg2,
    IN LONGLONG Arg3,
    OUT PSAL_PAL_RETURN_VALUES ReturnValues
    )
{

    switch (FunctionId) {

        default:
            ReturnValues->ReturnValues[0] = SAL_STATUS_NOT_IMPLEMENTED;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\i64generic.c ===
#include "halp.h"

VOID
HalpGenericCall (
	VOID  (*Fnc)(ULONG) ,
  	ULONG		    y, 
	KAFFINITY 	    z
	        )	
	{
	return;

	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\i64ioacc.c ===
/*++

 Copyright (c) 1995  Intel Corporation

 Module Name:

   i64ioacc.c

 Abstract:

   This module implements the I/O Register access routines.

 Author:

    Bernard Lint, M. Jayakumar  Sep 16 '97

 Environment:

    Kernel mode

 Revision History:

--*/


//
// XXX: Possible issues:
//  ISA bit
//  non-ISA bit
//  testing
//  Yosemite config
//  Pluto config
//




#include "halp.h"

#if DBG
ULONG DbgIoPorts = 0;
#endif

typedef struct _PORT_RANGE {
    BOOLEAN InUse;
    BOOLEAN IsSparse;        // _TRS
    BOOLEAN PrimaryIsMmio;   // _TTP
    BOOLEAN HalMapped;
    PVOID VirtBaseAddr;
    PHYSICAL_ADDRESS PhysBaseAddr;     // Only valid if PrimaryIsMmio = TRUE
    ULONG Length;            // Length of VirtBaseAddr and PhysBaseAddr ranges.
} PORT_RANGE, *PPORT_RANGE;


//
// Define a range for the architected IA-64 port space.
//
PORT_RANGE
BasePortRange = {
    TRUE,                   // InUse
    FALSE,                  // IsSparse
    FALSE,                  // PrimaryIsMmio
    FALSE,                  // HalMapped
    (PVOID)VIRTUAL_IO_BASE, // VirtBaseAddr
    {0},                    // PhysBaseAddr (unknown, comes from firmware)
    64*1024*1024            // Length
};


//
// Seed the set of ranges with the architected IA-64 port space.
//
PPORT_RANGE PortRanges = &BasePortRange;
USHORT NumPortRanges = 1;


UINT_PTR
GetVirtualPort(
    IN PPORT_RANGE Range,
    IN USHORT Port
    )
{
    UINT_PTR RangeOffset;

    if (Range->PrimaryIsMmio && !Range->IsSparse) {
        //
        // A densely packed range which converts MMIO transactions to
        // I/O port ones.
        //
        RangeOffset = Port;
        
    } else {
        //
        // Either a sparse MMIO->I/O port range, or primary is not
        // MMIO (IA-64 I/O port space).
        //
        RangeOffset = ((Port & 0xfffc) << 10) | (Port & 0xfff);
    }
    
    ASSERT(RangeOffset < Range->Length);

    return ((UINT_PTR)Range->VirtBaseAddr) + RangeOffset;
}

NTSTATUS
HalpAllocatePortRange(
    OUT PUSHORT RangeId
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    PPORT_RANGE OldPortRanges = PortRanges;
    PPORT_RANGE NewPortRanges = NULL;

    ASSERT(KeGetCurrentIrql() <= DISPATCH_LEVEL);

    
    //
    // First scan the existing ranges, looking for an unused one.
    //

    for (*RangeId = 0; *RangeId < NumPortRanges; *RangeId += 1) {
        if (! PortRanges[*RangeId].InUse) {
            PortRanges[*RangeId].InUse = TRUE;
            return STATUS_SUCCESS;
        }
    }
    

    //
    // Otherwise, grow the set of ranges and copy over the old ones.
    //
    
    NewPortRanges = ExAllocatePool(NonPagedPool,
                                   (NumPortRanges + 1) * sizeof(PORT_RANGE));

    if (NewPortRanges == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }


    if (NT_SUCCESS(Status)) {
        RtlCopyMemory(NewPortRanges,
                      OldPortRanges,
                      NumPortRanges * sizeof(PORT_RANGE));
        
        *RangeId = NumPortRanges;

        PortRanges = NewPortRanges;
        NumPortRanges += 1;

        PortRanges[*RangeId].InUse = TRUE;

        if (OldPortRanges != &BasePortRange) {
            ExFreePool(OldPortRanges);
        }
    }

    
    if (! NT_SUCCESS(Status)) {
        //
        // Error case: cleanup.
        //

        if (NewPortRanges != NULL) {
            ExFreePool(NewPortRanges);
        }
    }


    return Status;
}


VOID
HalpFreePortRange(
    IN USHORT RangeId
    )
{
    PPORT_RANGE Range = &PortRanges[RangeId];
    

    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

    
    ASSERT(Range->InUse);
    Range->InUse = FALSE;

    if (Range->HalMapped) {
        MmUnmapIoSpace(Range->VirtBaseAddr, Range->Length);
    }

    Range->VirtBaseAddr = NULL;
    Range->PhysBaseAddr.QuadPart = 0;
    Range->Length = 0;
}
    

NTSTATUS
HalpAddPortRange(
    IN BOOLEAN IsSparse,
    IN BOOLEAN PrimaryIsMmio,
    IN PVOID VirtBaseAddr OPTIONAL,
    IN PHYSICAL_ADDRESS PhysBaseAddr,  // Only valid if PrimaryIsMmio = TRUE
    IN ULONG Length,                   // Only valid if PrimaryIsMmio = TRUE
    OUT PUSHORT NewRangeId
    )
{
    NTSTATUS Status = STATUS_SUCCESS;
    BOOLEAN HalMapped = FALSE;
    BOOLEAN RangeAllocated = FALSE;


    ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
    

    Status = HalpAllocatePortRange(NewRangeId);

    RangeAllocated = NT_SUCCESS(Status);


    if (NT_SUCCESS(Status) && (VirtBaseAddr == NULL)) {
        VirtBaseAddr = MmMapIoSpace(PhysBaseAddr, Length, MmNonCached);

        if (VirtBaseAddr == NULL) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        } else {
            HalMapped = TRUE;
        }
    }

    
    if (NT_SUCCESS(Status)) {
        PortRanges[*NewRangeId].IsSparse = IsSparse;
        PortRanges[*NewRangeId].PrimaryIsMmio = PrimaryIsMmio;
        PortRanges[*NewRangeId].HalMapped = HalMapped;
        PortRanges[*NewRangeId].VirtBaseAddr = VirtBaseAddr;
        PortRanges[*NewRangeId].PhysBaseAddr.QuadPart = PhysBaseAddr.QuadPart;
        PortRanges[*NewRangeId].Length = Length;
    }

    
    if (! NT_SUCCESS(Status)) {
        //
        // Error case: cleanup.
        //

        if (HalMapped) {
            MmUnmapIoSpace(VirtBaseAddr, Length);
        }
        
        if (RangeAllocated) {
            HalpFreePortRange(*NewRangeId);
        }
    }


    return Status;
}


PPORT_RANGE
HalpGetPortRange(
    IN USHORT RangeId
    )
{
    PPORT_RANGE Range;

    ASSERT(RangeId < NumPortRanges);

    Range = &PortRanges[RangeId];

    ASSERT(Range->InUse);
    
    return Range;
}


//
// Returns TRUE when RangeId has been set.  Overlapping ranges are
// allowed.
//
BOOLEAN
HalpLookupPortRange(
    IN BOOLEAN IsSparse,        // _TRS
    IN BOOLEAN PrimaryIsMmio,   // FALSE for I/O port space, _TTP
    IN PHYSICAL_ADDRESS PhysBaseAddr,
    IN ULONG Length,
    OUT PUSHORT RangeId
    )
{
    BOOLEAN FoundMatch = FALSE;
    PPORT_RANGE Range;
    

    for (*RangeId = 0; *RangeId < NumPortRanges; *RangeId += 1) {

        Range = &PortRanges[*RangeId];


        if (! Range->InUse) {
            continue;
        }

        
        if ((Range->PrimaryIsMmio == PrimaryIsMmio) &&
            (Range->IsSparse == IsSparse)) {

            if (! PrimaryIsMmio) {
                //
                // Port space on the primary side.  Sparseness doesn't
                // make sense for primary side port space.  Because
                // there is only one primary side port space, which is
                // shared by all I/O bridges, don't check the base
                // address.
                //

                ASSERT(! IsSparse);

                FoundMatch = TRUE;
                break;
            }

            
            if ((Range->PhysBaseAddr.QuadPart == PhysBaseAddr.QuadPart) &&
                (Range->Length == Length)) {
                
                FoundMatch = TRUE;
                break;
            }
        }
    }


    //
    // A matching range was not found.
    //
    return FoundMatch;
}


NTSTATUS
HalpQueryAllocatePortRange(
    IN BOOLEAN IsSparse,
    IN BOOLEAN PrimaryIsMmio,
    IN PVOID VirtBaseAddr OPTIONAL,
    IN PHYSICAL_ADDRESS PhysBaseAddr,  // Only valid if PrimaryIsMmio = TRUE
    IN ULONG Length,                   // Only valid if PrimaryIsMmio = TRUE
    OUT PUSHORT NewRangeId
    )
{
    NTSTATUS Status = STATUS_SUCCESS;

    
    if (! HalpLookupPortRange(IsSparse,
                              PrimaryIsMmio,
                              PhysBaseAddr,
                              Length,
                              NewRangeId)) {
        
        Status = HalpAddPortRange(IsSparse,
                                  PrimaryIsMmio,
                                  NULL,
                                  PhysBaseAddr,
                                  Length,
                                  NewRangeId);
    }

    
    return Status;
}

UINT_PTR
HalpGetPortVirtualAddress(
   UINT_PTR Port
   )
{

/*++

Routine Description:

   This routine gives 32 bit virtual address for the I/O Port specified.

Arguements:

   PORT - Supplies PORT address of the I/O PORT.

Returned Value:

   UINT_PTR - Virtual address value.

--*/

    PPORT_RANGE PortRange;
    
    //
    // Upper 16 bits of the port handle are the range id.
    //
    USHORT RangeId = (USHORT)((((ULONG)Port) >> 16) & 0xffff);

    USHORT OffsetInRange = (USHORT)(Port & 0xffff);

    ULONG VirtOffset;

    UINT_PTR VirtualPort = 0;


#if 0
    {
        BOOLEAN isUart = FALSE;
        BOOLEAN isVGA = FALSE;


        if (RangeId == 0) {
            if ((OffsetInRange >= 0x3b0) && (OffsetInRange <= 0x3df)) {
                isVGA = TRUE;
            }
            
            if ((OffsetInRange >= 0x2f8) && (OffsetInRange <= 0x2ff)) {
                isUart = TRUE;
            }
            
            if ((OffsetInRange >= 0x3f8) && (OffsetInRange <= 0x3ff)) {
                isUart = TRUE;
            }

            if (!isVGA && !isUart) {
                static UINT32 numRaw = 0;
                InterlockedIncrement(&numRaw);
            }
        } else {
            static UINT32 numUnTra = 0;
            InterlockedIncrement(&numUnTra);
        }
    }
#endif // #if DBG


    PortRange = HalpGetPortRange(RangeId);

    return GetVirtualPort(PortRange, OffsetInRange);
}



UCHAR
READ_PORT_UCHAR(
    PUCHAR Port
    )
{

/*++

Routine Description:

   Reads a byte location from the PORT

Arguements:

   PORT - Supplies the PORT address to read from

Return Value:

   UCHAR - Returns the byte read from the PORT specified.


--*/

    UINT_PTR VirtualPort;
    UCHAR LoadData;

    KIRQL OldIrql;

    
#if DBG
    if (DbgIoPorts) DbgPrint("READ_PORT_UCHAR(%#x)\n",Port);
#endif

    VirtualPort =  HalpGetPortVirtualAddress((UINT_PTR)Port);

    //
    // Need to ensure load and mfa are not preemptable
    //

    __mf();
    
    OldIrql = KeGetCurrentIrql();
    
    if (OldIrql < DISPATCH_LEVEL) {
        OldIrql = KeRaiseIrqlToDpcLevel();
    }
    

    LoadData = *(volatile UCHAR *)VirtualPort;
    __mfa();
    
    if (OldIrql < DISPATCH_LEVEL) {
        KeLowerIrql (OldIrql);
    }

    return (LoadData);
}



USHORT
READ_PORT_USHORT (
    PUSHORT Port
    )
{

/*++

Routine Description:

   Reads a word location (16 bit unsigned value) from the PORT

Arguements:

   PORT - Supplies the PORT address to read from.

Returned Value:

   USHORT - Returns the 16 bit unsigned value from the PORT specified.

--*/

    UINT_PTR VirtualPort;
    USHORT LoadData;

    KIRQL OldIrql;

#if DBG
    if (DbgIoPorts) DbgPrint("READ_PORT_USHORT(%#x)\n",Port);
#endif

    VirtualPort = HalpGetPortVirtualAddress((UINT_PTR)Port);

    //
    // Need to ensure load and mfa are not preemptable
    //
    __mf();

    OldIrql = KeGetCurrentIrql();

    if (OldIrql < DISPATCH_LEVEL) {
        OldIrql = KeRaiseIrqlToDpcLevel();
    }
    
    LoadData = *(volatile USHORT *)VirtualPort;
    __mfa();
    
    if (OldIrql < DISPATCH_LEVEL) {
         KeLowerIrql (OldIrql);
    }

    return (LoadData);
}


ULONG
READ_PORT_ULONG (
    PULONG Port
    )
{

/*++

   Routine Description:

      Reads a longword location (32bit unsigned value) from the PORT.

   Arguements:

     PORT - Supplies PORT address to read from.

   Returned Value:

     ULONG - Returns the 32 bit unsigned value (ULONG) from the PORT specified.

--*/

    UINT_PTR VirtualPort;
    ULONG LoadData;

    KIRQL OldIrql;

#if DBG
    if (DbgIoPorts) DbgPrint("READ_PORT_ULONG(%#x)\n",Port);
#endif

    VirtualPort = HalpGetPortVirtualAddress((UINT_PTR)Port);

    //
    // Need to ensure load and mfa are not preemptable
    //
    __mf();

    OldIrql = KeGetCurrentIrql();

    if (OldIrql < DISPATCH_LEVEL) {
        OldIrql = KeRaiseIrqlToDpcLevel();
    }
    
    LoadData = *(volatile ULONG *)VirtualPort;
    __mfa();

    if (OldIrql < DISPATCH_LEVEL) {
        KeLowerIrql (OldIrql);
    }
    
    return (LoadData);
}


ULONG
READ_PORT_ULONG_SPECIAL (
    PULONG Port
    )
{

/*++

   Routine Description:

      Reads a longword location (32bit unsigned value) from the PORT.
      For A0 bug 2173. Does not enable/disable interrupts. Called from first level interrupt
      handler.

   Arguements:

     PORT - Supplies PORT address to read from.

   Returned Value:

     ULONG - Returns the 32 bit unsigned value (ULONG) from the PORT specified.

--*/

    UINT_PTR VirtualPort;
    ULONG LoadData;

#if DBG
    if (DbgIoPorts) DbgPrint("READ_PORT_ULONG(%#x)\n",Port);
#endif

    VirtualPort = HalpGetPortVirtualAddress((UINT_PTR)Port);
    __mf();
    LoadData = *(volatile ULONG *)VirtualPort;
    __mfa();

    return (LoadData);
}



VOID
READ_PORT_BUFFER_UCHAR (
    PUCHAR Port,
    PUCHAR Buffer,
    ULONG Count
    )
{

/*++

   Routine Description:

     Reads multiple bytes from the specified PORT address into the
     destination buffer.

   Arguements:

     PORT - The address of the PORT to read from.

     Buffer - A pointer to the buffer to fill with the data read from the PORT.

     Count - Supplies the number of bytes to read.

   Return Value:

     None.

--*/


    UINT_PTR VirtualPort;
    ULONG i;
    KIRQL OldIrql;

#if DBG
    if (DbgIoPorts) DbgPrint("READ_PORT_BUFFER_UCHAR(%#x,%#p,%d)\n",Port,Buffer,Count);
#endif

    VirtualPort =   HalpGetPortVirtualAddress((UINT_PTR)Port);

    //
    // Prevent preemption before mfa
    //
    OldIrql = KeGetCurrentIrql();

    if (OldIrql < DISPATCH_LEVEL) {
        OldIrql = KeRaiseIrqlToDpcLevel();
    }

    __mf();

    for (i=0; i<Count; i++) {
        *Buffer++ = *(volatile UCHAR *)VirtualPort;
        __mfa();
    }


    if (OldIrql < DISPATCH_LEVEL) {
        KeLowerIrql(OldIrql);
    }
}



VOID
READ_PORT_BUFFER_USHORT (
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG Count
    )
{

/*++

    Routine Description:

      Reads multiple words (16bits) from the speicified PORT address into
      the destination buffer.

    Arguements:

      Port - Supplies the address of the PORT to read from.

      Buffer - A pointer to the buffer to fill with the data
               read from the PORT.

      Count  - Supplies the number of words to read.

--*/

    UINT_PTR VirtualPort;
    ULONG i;
    KIRQL OldIrql;

#if DBG
    if (DbgIoPorts) DbgPrint("READ_PORT_BUFFER_USHORT(%#x,%#p,%d)\n",Port,Buffer,Count);
#endif

    VirtualPort = HalpGetPortVirtualAddress((UINT_PTR)Port);

    //
    // Prevent preemption before mfa
    //
    OldIrql = KeGetCurrentIrql();

    if (OldIrql < DISPATCH_LEVEL) {
        OldIrql = KeRaiseIrqlToDpcLevel();
    }

    __mf();

    for (i=0; i<Count; i++) {
        *Buffer++ = *(volatile USHORT *)VirtualPort;
        __mfa();
    }


    if (OldIrql < DISPATCH_LEVEL) {
        KeLowerIrql(OldIrql);
    }
}


VOID
READ_PORT_BUFFER_ULONG (
    PULONG Port,
    PULONG Buffer,
    ULONG Count
    )
{

 /*++

    Routine Description:

      Reads multiple longwords (32bits) from the speicified PORT
      address into the destination buffer.

    Arguements:

      Port - Supplies the address of the PORT to read from.

      Buffer - A pointer to the buffer to fill with the data
               read from the PORT.

      Count  - Supplies the number of long words to read.

--*/

    UINT_PTR VirtualPort;
    PULONG ReadBuffer = Buffer;
    ULONG ReadCount;
    ULONG i;
    KIRQL OldIrql;

#if DBG
    if (DbgIoPorts) DbgPrint("READ_PORT_BUFFER_ULONG(%#x,%#p,%d)\n",Port,Buffer,Count);
#endif

    VirtualPort =  HalpGetPortVirtualAddress((UINT_PTR)Port);

    //
    // Prevent preemption before mfa
    //
    OldIrql = KeGetCurrentIrql();

    if (OldIrql < DISPATCH_LEVEL) {
        OldIrql = KeRaiseIrqlToDpcLevel();
    }

    __mf();

    for (i=0; i<Count; i++) {
        *Buffer++ = *(volatile ULONG *)VirtualPort;
        __mfa();
    }

    if (OldIrql < DISPATCH_LEVEL) {
        KeLowerIrql(OldIrql);
    }
}

VOID
WRITE_PORT_UCHAR (
    PUCHAR Port,
    UCHAR  Value
    )
{

/*++

   Routine Description:

      Writes a byte to the Port specified.

   Arguements:

      Port - The port address of the I/O Port.

      Value - The value to be written to the I/O Port.

   Return Value:

      None.

--*/

    UINT_PTR VirtualPort;
    KIRQL     OldIrql;

#if DBG
    if (DbgIoPorts) DbgPrint("WRITE_PORT_UCHAR(%#x,%#x)\n",Port,Value);
#endif

    VirtualPort =  HalpGetPortVirtualAddress((UINT_PTR)Port);

   //
   // Need to ensure load and mfa are not preemptable
   //

    __mf();
 
    OldIrql = KeGetCurrentIrql();
     
    if (OldIrql < DISPATCH_LEVEL) {
        OldIrql = KeRaiseIrqlToDpcLevel();
    }
           
    *(volatile UCHAR *)VirtualPort = Value;
    __mf();
    __mfa();
    
    if (OldIrql < DISPATCH_LEVEL) {
        KeLowerIrql (OldIrql);
    }
}

VOID
WRITE_PORT_USHORT (
    PUSHORT Port,
    USHORT  Value
    )
{

/*++

   Routine Description:

      Writes a 16 bit SHORT Integer to the Port specified.

   Arguements:

      Port - The port address of the I/O Port.

      Value - The value to be written to the I/O Port.

   Return Value:

      None.

--*/

    UINT_PTR VirtualPort;
    KIRQL     OldIrql;

#if DBG
    if (DbgIoPorts) DbgPrint("WRITE_PORT_USHORT(%#x,%#x)\n",Port,Value);
#endif

    VirtualPort = HalpGetPortVirtualAddress((UINT_PTR)Port);

    //
    // Need to ensure load and mfa are not preemptable
    //

    __mf();

    OldIrql = KeGetCurrentIrql();
    
    if (OldIrql < DISPATCH_LEVEL) {
        OldIrql = KeRaiseIrqlToDpcLevel();
    }
    *(volatile USHORT *)VirtualPort = Value;
    __mf();
    __mfa();
    if (OldIrql < DISPATCH_LEVEL) {
        KeLowerIrql (OldIrql);
    }
}

VOID
WRITE_PORT_ULONG (
    PULONG Port,
    ULONG  Value
    )
{

/*++

   Routine Description:

      Writes a 32 bit Long Word to the Port specified.

   Arguements:

      Port - The port address of the I/O Port.

      Value - The value to be written to the I/O Port.

   Return Value:

      None.

--*/

    UINT_PTR VirtualPort;
    KIRQL     OldIrql;

#if DBG
    if (DbgIoPorts) DbgPrint("WRITE_PORT_ULONG(%#x,%#x)\n",Port,Value);
#endif

    VirtualPort = HalpGetPortVirtualAddress((UINT_PTR)Port);
        
    //
    // Need to ensure load and mfa are not preemptable
    //
    __mf();

    OldIrql = KeGetCurrentIrql();

    if (OldIrql < DISPATCH_LEVEL) {
        OldIrql = KeRaiseIrqlToDpcLevel();
    }
    *(volatile ULONG *)VirtualPort = Value;
    __mf();
    __mfa();
    if (OldIrql < DISPATCH_LEVEL) {
        KeLowerIrql (OldIrql);
    }
}


VOID
WRITE_PORT_ULONG_SPECIAL (
    PULONG Port,
    ULONG  Value
    )
{

/*++

   Routine Description:

      Writes a 32 bit Long Word to the Port specified.
      Assumes context switch is not possible. Used for A0 workaround.
   Arguements:

      Port - The port address of the I/O Port.

      Value - The value to be written to the I/O Port.

   Return Value:

      None.

--*/

    UINT_PTR VirtualPort;

#if DBG
    if (DbgIoPorts) DbgPrint("WRITE_PORT_ULONG(%#x,%#x)\n",Port,Value);
#endif

    VirtualPort = HalpGetPortVirtualAddress((UINT_PTR)Port);
    *(volatile ULONG *)VirtualPort = Value;
    __mf();
    __mfa();

}



VOID
WRITE_PORT_BUFFER_UCHAR (
    PUCHAR Port,
    PUCHAR Buffer,
    ULONG   Count
    )
{

/*++

   Routine Description:

     Writes multiple bytes from the source buffer to the specified Port address.

   Arguements:

     Port  - The address of the Port to write to.

     Buffer - A pointer to the buffer containing the data to write to the Port.

     Count - Supplies the number of bytes to write.

   Return Value:

     None.

--*/


    UINT_PTR VirtualPort;
    ULONG i;
    KIRQL OldIrql;

#if DBG
    if (DbgIoPorts) DbgPrint("WRITE_PORT_BUFFER_UCHAR(%#x,%#p,%d)\n",Port,Buffer,Count);
#endif

    VirtualPort =  HalpGetPortVirtualAddress((UINT_PTR)Port);

    //
    // Prevent preemption before mfa
    //
    OldIrql = KeGetCurrentIrql();

    if (OldIrql < DISPATCH_LEVEL) {
        OldIrql = KeRaiseIrqlToDpcLevel();
    }

    for (i=0; i<Count; i++) {
        *(volatile UCHAR *)VirtualPort = *Buffer++;
        __mfa();
    }

    if (OldIrql < DISPATCH_LEVEL) {
        KeLowerIrql(OldIrql);
    }

    __mf();
}


VOID
WRITE_PORT_BUFFER_USHORT (
    PUSHORT Port,
    PUSHORT Buffer,
    ULONG   Count
    )
{

/*++

   Routine Description:

     Writes multiple 16bit short integers from the source buffer to the specified Port address.

   Arguements:

     Port  - The address of the Port to write to.

     Buffer - A pointer to the buffer containing the data to write to the Port.

     Count - Supplies the number of (16 bit) words to write.

   Return Value:

     None.

--*/


    UINT_PTR VirtualPort;
    ULONG i;
    KIRQL OldIrql;

#if DBG
    if (DbgIoPorts) DbgPrint("WRITE_PORT_BUFFER_USHORT(%#x,%#p,%d)\n",Port,Buffer,Count);
#endif

    VirtualPort =  HalpGetPortVirtualAddress((UINT_PTR)Port);

    //
    // Prevent preemption before mfa
    //
    OldIrql = KeGetCurrentIrql();

    if (OldIrql < DISPATCH_LEVEL) {
        OldIrql = KeRaiseIrqlToDpcLevel();
    }

    for (i=0; i<Count; i++) {
        *(volatile USHORT *)VirtualPort = *Buffer++;
        __mfa();
    }


    if (OldIrql < DISPATCH_LEVEL) {
        KeLowerIrql(OldIrql);
    }

    __mf();
}

VOID
WRITE_PORT_BUFFER_ULONG (
    PULONG Port,
    PULONG Buffer,
    ULONG   Count
    )
{

/*++

   Routine Description:

     Writes multiple 32bit long words from the source buffer to the specified Port address.

   Arguements:

     Port  - The address of the Port to write to.

     Buffer - A pointer to the buffer containing the data to write to the Port.

     Count - Supplies the number of (32 bit) long words to write.

   Return Value:

     None.

--*/


    UINT_PTR VirtualPort;
    ULONG i;
    KIRQL OldIrql;

#if DBG
    if (DbgIoPorts) DbgPrint("WRITE_PORT_BUFFER_ULONG(%#x,%#p,%d)\n",Port,Buffer,Count);
#endif

    VirtualPort = HalpGetPortVirtualAddress((UINT_PTR)Port);


    //
    // Prevent preemption before mfa
    //
    OldIrql = KeGetCurrentIrql();

    if (OldIrql < DISPATCH_LEVEL) {
        OldIrql = KeRaiseIrqlToDpcLevel();
    }

    for (i=0; i<Count; i++) {
        *(volatile ULONG *)VirtualPort = *Buffer++;
        __mfa();
    }


    if (OldIrql < DISPATCH_LEVEL) {
        KeLowerIrql(OldIrql);
    }

    __mf();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\i64kd.c ===
/*++

Copyright (c) 1995  Intel Corporation

Module Name:

    i64kd copied from simkd.c

Abstract:

    Kernel debug com support.

Author:

    14-Apr-1995

    Bernard Lint, M. Jayakumar

Environment:

    Kernel mode

Revision History:

--*/
#include "halp.h"
#include "stdio.h"

//
// Timeout_count 1024 * 200 
//
#define TIMEOUT_COUNT  2     

#define GET_RETRY_COUNT  1024
#define IA64_MSG_DEBUG_ENABLE         "Kernel Debugger Using: COM%x (Port 0x%x, Baud Rate %d)\n"
#define IA64_MSG2_DEBUG_ENABLE        "Kernel Debugger Using named pipe: COM%x (Port 0x%x, Baud Rate %d)\n"

PUCHAR KdComPortInUse=NULL;


BOOLEAN
KdPortInitialize(
    PDEBUG_PARAMETERS DebugParameters,
    PLOADER_PARAMETER_BLOCK LoaderBlock,
    BOOLEAN Initialize
    )

/*++

Routine Description:

    This routine initialize a com port to support kernel debug.

Arguments:

    DebugParameters - Supplies a pointer a structure which optionally
                      sepcified the debugging port information.

    LoaderBlock - supplies a pointer to the loader parameter block.

    Initialize - Specifies a boolean value that determines whether the
                 debug port is initialized or just the debug port parameters
                 are captured.

Returned Value:

    TRUE - If a debug port is found.

--*/

{

    PUCHAR PortAddress = NULL;
    ULONG Com = 0;
    UCHAR DebugMessage[80];
    PHYSICAL_ADDRESS LPDebugParameters;


    if (Initialize) {
        LPDebugParameters = MmGetPhysicalAddress (DebugParameters);
        if ( !SscKdInitialize((PVOID) LPDebugParameters.QuadPart, (SSC_BOOL)Initialize )) { 

        // SscKd initialized sucessfully

        Com = DebugParameters->CommunicationPort;

            //
            // initialize port struct. if not named-pipe
            //
            if ( Com != 0 ) {   
 
                //
                // set port address to default value.
                //

                if (PortAddress == NULL) {
                    switch (Com) {
                    case 1:
                       PortAddress = (PUCHAR)0x3f8;
                       break;
                    case 2:
                       PortAddress = (PUCHAR)0x2f8;
                       break;
                    case 3:
                       PortAddress = (PUCHAR)0x3e8;
                       break;
                    case 4:
                       PortAddress = (PUCHAR)0x2e8;
                    }
                }

                KdComPortInUse= PortAddress;

                sprintf(
                    DebugMessage, 
                    IA64_MSG_DEBUG_ENABLE,
                    Com, 
                    PtrToUlong(PortAddress), 
                    DebugParameters->BaudRate
                    );

                HalDisplayString("\n");
                HalDisplayString(DebugMessage);
            }

            //
            // port = 0, named-pipe
            //
            
            else {   
                sprintf(
                    DebugMessage,
                    IA64_MSG2_DEBUG_ENABLE,
                    Com,
                    PtrToUlong(PortAddress), 
                    DebugParameters->BaudRate
                    );
                HalDisplayString("\n");
                HalDisplayString(DebugMessage);
            }
            return(TRUE);
        }
        //
        // SscKdinitialize() failed.
        //  

        else {
            
            return(FALSE);
        
        }
    }

    //
    // By pass. do not initialize
    //
    else { 
        return(FALSE);
    }
}

ULONG
KdPortGetByte (
    OUT PUCHAR Input
    )

/*++

Routine Description:

    Fetch a byte from the debug port and return it.

    This routine does nothing in the simulation environment.

    N.B. It is assumed that the IRQL has been raised to the highest level, and
    necessary multiprocessor synchronization has been performed before this
    routine is called.

Arguments:

    Input - Returns the data byte.

Return Value:

    CP_GET_SUCCESS is returned if a byte is successfully read from the
    kernel debugger line.
    CP_GET_ERROR is returned if error encountered during reading.
    CP_GET_NODATA is returned if timeout.

--*/

{
    PHYSICAL_ADDRESS LPInput;
    UCHAR DebugMessage[80];
    ULONG   limitcount, status;

    LPInput = MmGetPhysicalAddress (Input);
    limitcount = GET_RETRY_COUNT;

    while (limitcount != 0) {
        limitcount--;

        status = SscKdPortGetByte((PVOID)LPInput.QuadPart);
        if (status == CP_GET_SUCCESS) {
#ifdef KDDBG
            sprintf(DebugMessage,"%02x ", *Input);
            HalDisplayString(DebugMessage);
#endif
            return(CP_GET_SUCCESS);
        }
#ifdef KDDBG
        else {
            HalDisplayString(".");
        }
#endif
    }
    return status;
}

ULONG
KdPortPollByte (
    OUT PUCHAR Input
    )

/*++

Routine Description:

    Fetch a byte from the debug port and return it if one is available.

    This routine does nothing in the simulation environment.

    N.B. It is assumed that the IRQL has been raised to the highest level, and
        necessary multiprocessor synchronization has been performed before this
        routine is called.

Arguments:

    Input - Returns the data byte.

Return Value:

    CP_GET_SUCCESS is returned if a byte is successfully read from the
    kernel debugger line.
    CP_GET_ERROR is returned if error encountered during reading.
    CP_GET_NODATA is returned if timeout.

--*/

{
    PHYSICAL_ADDRESS LPInput;
    UCHAR DebugMessage[80];
    ULONG   limitcount, status;
    
    LPInput = MmGetPhysicalAddress (Input);
    limitcount = TIMEOUT_COUNT;

    while (limitcount != 0) {
        limitcount--;

        status = SscKdPortGetByte((PVOID)LPInput.QuadPart);
        if (status == CP_GET_ERROR)
            return(CP_GET_ERROR);
        if (status == CP_GET_SUCCESS) {
#ifdef KDDBG
            sprintf(DebugMessage, "%02x ", *Input);
            HalDisplayString(DebugMessage);
#endif
            return(CP_GET_SUCCESS);
        }
#ifdef KDDBG
        HalDisplayString(".");
#endif
    }
    return (CP_GET_NODATA);
}

VOID
KdPortPutByte (
    IN UCHAR Output
    )

/*++

Routine Description:

    Write a byte to the debug port.  
    
    This routine does nothing in the simulation environment.

    N.B. It is assumed that the IRQL has been raised to the highest level, and
        necessary multiprocessor synchronization has been performed before this
        routine is called.

Arguments:

    Output - Supplies the output data byte.

Return Value:

    None.

--*/

{
#ifdef KDDBG
    UCHAR DebugMessage[80];

    sprintf(DebugMessage, "%02x-", Output);
    HalDisplayString(DebugMessage);
#endif
    SscKdPortPutByte(Output);
}

VOID
KdPortRestore (
    VOID
    )

/*++

Routine Description:

    This routine does nothing in the simulation environment.

    N.B. It is assumed that the IRQL has been raised to the highest level, and
        necessary multiprocessor synchronization has been performed before this
        routine is called.

Arguments:

    None.

Return Value:

    None.

--*/

{

}

VOID
KdPortSave (
    VOID
    )

/*++

Routine Description:

    This routine does nothing in the simulation environment.

    N.B. It is assumed that the IRQL has been raised to the highest level, and
        necessary multiprocessor synchronization has been performed before this
        routine is called.

Arguments:

    None.

Return Value:

    None.

--*/

{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\i64itm.s ===
//      TITLE ("Memory Fences, Load Acquires and Store Acquires")

/*++

    Copyright (c) 1995  Intel Corporation

    Module Name:

     i64itm.s assembly routines for updating ITM.

    Abstract:

      This module implements the I/O port access routines.

    Author:

      Bernard Lint, M. Jayakumar 17 Sep '97

    Environment:

      Kernel mode

    Revision History:

--*/

#include "ksia64.h"

        .file "i64itm.s"

        .global HalpClockCount
        .global HalpITMUpdateLatency
        .global HalpITCTicksPer100ns


// Temp until compiler fixed


        LEAF_ENTRY(HalpInitLINT)
        LEAF_SETUP(1,0,0,0)
        mov         t0 = 0x10000
        ;;
        mov         cr.lrr0 = t0
        mov         cr.lrr1 = t0
        ;;
        // Clear pending interrupts from irr's
        // read ivr until spurious (0xf)
        // set tpr level to zero to unmask all ints

        mov         t2 = cr.tpr
        ;;
        mov         cr.tpr = zero
        ;;
        srlz.d
        mov         t0 = 0xf
        ;;
Hil_loop:
        mov         t1 = cr.ivr
        ;;
        cmp.ne      pt0 = t0, t1
        ;;
(pt0)   mov         cr.eoi = zero
(pt0)   br.spnt     Hil_loop

        // Restore tpr

        mov         cr.tpr = t2
        ;;
        srlz.d
        LEAF_RETURN
        LEAF_EXIT(HalpInitLINT)

/*++

BOOLEAN
HalpDisableInterrupts (
    )

Routine Description:

     This function disables interrupts.

Arguements:

     None.

Return Value:

     TRUE if interrupts were previously enabled else FALSE

--*/

        LEAF_ENTRY(HalpDisableInterrupts)

        mov       t0 = psr
        mov       v0 = TRUE         // set return value -- TRUE if enabled
        ;;
        tbit.z    pt1 = t0, PSR_I   // pt1 = 1 if disabled
        ;;

        FAST_DISABLE_INTERRUPTS
(pt1)   mov       v0 = FALSE        // FALSE if disabled
        br.ret.sptk brp

        LEAF_EXIT(HalpDisableInterrupts)

/*++

VOID
HalpTurnOffInterrupts (
    VOID
    )

Routine Description:

     This function turns off interrupts and interruption resources collection.

Arguements:

     None.

Return Value:

     None.

--*/

        LEAF_ENTRY(HalpTurnOffInterrupts)
        rsm     1 << PSR_I
        ;;
        rsm     1 << PSR_IC
        ;;
        srlz.d
        LEAF_RETURN
        LEAF_EXIT(HalpTurnOffInterrupts)

/*++

VOID
HalpTurnOnInterrupts (
    VOID
    )

Routine Description:

     This function turns on interruption resources collection and interrupts.

Arguements:

     None.

Return Value:

     None.

--*/

        LEAF_ENTRY(HalpTurnOnInterrupts)
        ssm     1 << PSR_IC             // set PSR.ic bit again
        ;;
        srlz.i                          // serialize
        ;;
        ssm     1 << PSR_I              // set PSR.i bit again

        LEAF_RETURN
        LEAF_EXIT(HalpTurnOnInterrupts)

/*++

VOID
HalpSetNextClockInterrupts (
    VOID
    )

Routine Description:

     This function reads the current ITC and updates accordingly the ITM
     register with interruption resources collection and interrupts off.
     The interruption resources collection and interrupts are turned on
     returning to the caller.

Arguements:

     None.

Return Value:

     currentITCValue - previousITMValue.

--*/

        LEAF_ENTRY(HalpSetNextClockInterrupt)
        .regstk 0, 2, 0, 0

        alloc   r2 = 0, 2, 0, 0
        addl    r31 = @gprel(HalpClockCount),gp
        movl    r9 = KiPcr+PcHalReserved   // CURRENT_ITM_VALUE_INDEX = 0
        addl    r30 = @gprel(HalpITMUpdateLatency),gp
        ;;

        ld8.acq r11 = [r9]   // r11 = currentITMValue
        ld8     r10 = [r31]  // r10 = HalpClockCount
        ;;

// 08/16/2000 TF
// We should check if r11 == cr.itm here...
//

        add     r32 = r11, r10 // r32 = compareITCValue = currentITMValue + HalpClockCount
        ;;

        rsm     1 << PSR_I
        ;;

        rsm     1 << PSR_IC
        ;;
        srlz.d

retry_itm_read:

        mov     cr.itm = r32  // set itm with the most common scenario
        ;;
        mov     r30 = cr.itm

retry_itc_read:
        mov     r33 = ar.itc  // r33 = currentITCValue
        ;;

        cmp.ne  pt2 = r30, r32
(pt2)   br.cond.spnt retry_itm_read // this should not be taken,
                               // this just makes sure itm is actually written
#ifndef DISABLE_ITC_WORKAROUND
        cmp4.eq pt1 = -1, r33 // if lower 32 bits equal 0xffffffff
(pt1)   br.cond.spnt retry_itc_read
        ;;
#endif // DISABLE_ITC_WORKAROUND

        sub     r30 = r32, r33  // calculate a ITM/ITC delta
        ;;
        cmp.lt  pt0 = r30, r0  // if a delta is negative set pt0
        ;;
(pt0)   add     r32 = r32, r10  // r32 = updated currentITMValue + HalpClockCount
(pt0)   br.cond.spnt retry_itm_read
        ;;

        ssm     1 << PSR_IC     // set PSR.ic bit again
        ;;
        srlz.d                  // serialize
        ssm     1 << PSR_I      // set PSR.i bit again
        st8     [r9] = r32
        sub     r8 = r33, r11   // r8 = currentITCValue - previousITMValue

        LEAF_RETURN
        LEAF_EXIT(HalpSetNextClockInterrupt)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\i64krnl.c ===
/*++

Copyright (c) 1995  Intel Corporation

Module Name:

    i64krnl.c

Abstract:

    This module implements the kernel support routines for the HAL DLL.

Author:

   Bernard Lint
   M. Jayakumar (Muthurajan.Jayakumar@intel.com)
   14-Apr-1995

Environment:

    Kernel mode

Revision History:

--*/

#include "halp.h"
#include "i64fw.h"
#include "check.h"
#include "osmca.h"
#include "iosapic.h"
#include "string.h"
#include "stdlib.h"
#include "stdio.h"

#define GreaterThan4GB 0x100000000

VOID
HalpInitReservedPages(
    VOID
    );

VOID
HalpRegisterKdSupportFunctions(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

extern ADDRESS_USAGE HalpDefaultPcIoSpace;
extern ULONGLONG HalpITCFrequency;
extern ULONGLONG HalpProcessorFrequency;
extern ULONG HalpOsBootRendezVector;

WCHAR   HalHardwareIdString[]  = L"acpi";
ULONG HalpBusType;

ULONGLONG PhysicalIOBase;

static short HalpOwnDisplay = TRUE;

PKPROCESSOR_STATE HalpProcessorState;

PULONGLONG InterruptBlock;

extern KEVENT HalpNewAdapter;

ULONG HalPxbTcap;

//
// When Accessing IO SAPIC, HalpIoSapicLock is acquired and released
//

KSPIN_LOCK HalpIoSapicLock;

PHYSICAL_ADDRESS INTERRUPT_BLOCK_ADDRESS = { 0x0FEE00000 };

//
// Thierry - 10/01/2000 - Do NOT check the HALP_FIX_KD_HALIA64_MASK related
//                        code and data in the tree.
//
// This is to allow us to enable HAL_INFO level or other desired mask.
// The current debugger does not allow this and it should.
//

// #define HALP_FIX_KD_HALIA64_MASK  1

ULONG HalpFixKdHalia64Mask = 0;


VOID
HalpInitializeInterruptBlock (
    VOID
    )

/*++

Routine Description:

    Map Interrupt Block used for IPI. The size of the IPI area is 1MB.

Arguements:

    None

Return Value:

    None

--*/

{
    InterruptBlock = (PULONGLONG) HalpMapPhysicalMemory (
                                      INTERRUPT_BLOCK_ADDRESS,
                                      256,
                                      MmNonCached);
    return;
}

VOID
HalpCalibrateTB (
    )

/*++

Routine Description:

    This function calibrates the time base by determining the frequency
    that the ITC is running at to determine the interval value for a
    100 ns time increment (used by clock and profile).

 Arguments:

    None.

 Return Value:

    None.

*/

{
    return;
}



VOID
HalpFlushTLB (
    VOID
    )
{
    return;
}



BOOLEAN
HalAllProcessorsStarted (
    VOID
    )

/**++

Routine Description:

    This function returns TRUE if all the processors in the system started
    successfully.

Arguments:

    None.

Return Value:

    Returns TRUE.
--**/

{
    return TRUE;
}


VOID
HalpIpiInterruptHandler(
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:

    This routine is entered as the result of an interrupt generated by inter
    processor communication.

Arguments:

    Interrupt - Interrupt object address

    TrapFrame - Trap frame address

Return Value:

    None.

--*/
{

    KeIpiInterrupt(TrapFrame);

    return;

}


VOID
HalpSendIPI(
    IN USHORT ProcessorID,
    IN ULONGLONG Data
    )

/*++

Routine Description:

    This function sends IPI to the processor specified.

Arguements:

    ProcessorID   - Supplies the ID of processor to IPI.

    Data          - The formatted Data ready to ship it as IPI.

Return Value:

    None.

--*/
{

    PULONGLONG Address;
    ULONG  tmp1;
    KIRQL OldIrql;

    tmp1 = ProcessorID << IPI_ID_SHIFT;

    Address = (PULONGLONG)((UINT_PTR)(InterruptBlock) + tmp1);

    *(volatile ULONGLONG *)Address = Data;

    return;

}

NTSTATUS
HalpSendCrossPartitionIpi(
    IN USHORT ProcessorID,
    IN UCHAR  HardwareVector
    )

/*++

Routine Description:

    This function sends a cross partition IPI to the processor
    specified.  The caller must know that this processor is in another
    partition and the hardware vector previously reserved for
    receiving cross partition IPIs.

Arguements:

    ProcessorID   - Supplies the ID of processor to IPI.

    HardwareVector - Hardware Vector on remote processor that will
                     receive the interrupt.

Return Value:

    NTSTATUS

--*/
{
    ULONGLONG Data;

    if (HardwareVector < 16) {
        return STATUS_INVALID_PARAMETER;
    }

    Data = HardwareVector | DELIVER_FIXED;
    HalpSendIPI(ProcessorID, Data);

    return STATUS_SUCCESS;
}

VOID
HalpOSRendez (
    IN USHORT ProcessorID
    )

/*++

Routine Description:

   This function does IPI to start the next processor.

Arguements:

   PhysicalNumber  - Supplies the physical number of processor to IPI.

Return Value:

   None.

--*/

{
    HalpSendIPI ( ProcessorID, HalpOsBootRendezVector);
    return;
}

BOOLEAN
HalStartNextProcessor (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN PKPROCESSOR_STATE ProcessorState
    )

/*++

Routine Description:

    This function is called to start the next processor.

Arguments:

    LoaderBlock - Supplies a pointer to the loader parameter block.

    ProcessorState - Supplies a pointer to the processor state to be
        used to start the processor.

Return Value:

    If a processor is successfully started, then a value of TRUE is
    returned. Otherwise a value of FALSE is returned. If a value of
    TRUE is returned, then the logical processor number is stored
    in the processor control block specified by the loader block.

--*/

{
    ULONG  count;
    ULONGLONG   EntryPoint;
    ULONG ProcNumber = ((PKPRCB)LoaderBlock->Prcb)->Number;
    SAL_PAL_RETURN_VALUES SalReturn;
    SAL_STATUS salStatus;
    NTSTATUS ntStatus;
    USHORT TargetProcessorID;

    if (HalpAcpiNumProcessors() <= ProcNumber) {
       return (FALSE);
    }

    //
    // Boot OS rendezvous entry point
    //

    EntryPoint = ProcessorState->ContextFrame.StIIP;
    salStatus = HalpSalCall(SAL_SET_VECTORS,
                2 /* Boot rendz */,
                (ULONGLONG)(MmGetPhysicalAddress((PUCHAR)EntryPoint).QuadPart),
                0,
                0,
                0,
                0,
                0,
                &SalReturn);

    if (salStatus != 0) {
        HalDebugPrint(( HAL_ERROR, "HAL: HalStartNextProcessor - Cannot register OS rendezvous with SAL for processor %d\n",
                        ProcNumber ));
        return (FALSE);
    }

    //
    // For ia64, we will assume that the processor is ready  and not started
    //

    //
    // Start the next processor, if Processor ID not self
    //


    ntStatus = HalpGetApicIdByProcessorNumber((UCHAR)ProcNumber, &TargetProcessorID);

    if (!NT_SUCCESS(ntStatus)) {

        return FALSE;
    }

    HalpOSRendez(TargetProcessorID);

    count = 0;

    while (*((volatile ULONG_PTR *)&LoaderBlock->Prcb) != 0 && (count < RENDEZ_TIME_OUT)) {
        KeStallExecutionProcessor (1000);    // 1000000
        count++;
    } // end while (count < RENDEZ_TIMEOUT)

    if (LoaderBlock->Prcb != 0) {
        return (FALSE);
    } else {
        return (TRUE);
    }
}



VOID
HalRequestIpi (
    IN KAFFINITY Mask
    )

/*++

Routine Description:

    This function does nothing on a uni-processor platform.

Arguments:

    Mask - A mask that specifies the target processor(s) to which an
           IPI is to be sent.

Return Value:

    None.

--*/

{
    USHORT  LogicalCpu;
    USHORT  ProcessorID;

    //
    // Make sure we don't try and IPI processors that we don't believe are
    // started
    //

    Mask &= HalpActiveProcessors;

    //
    // Scan the processor set and request an interprocessor interrupt on
    // each of the specified targets.
    //

    for (LogicalCpu = 0; LogicalCpu < HalpMpInfo.ProcessorCount; LogicalCpu++) {

        if ((Mask & (1 << HalpProcessorInfo[LogicalCpu].NtProcessorNumber)) != 0)  {

            ProcessorID = HalpProcessorInfo[LogicalCpu].LocalApicID;

            //
            // Request interprocessor interrupt on target physicalCpu.
            //

            HalpSendIPI(ProcessorID, IPI_VECTOR);
        }
    }
}





VOID
HalProcessorIdle (
    VOID
    )

/*++

Routine Description:

    This function calls the TAL function to halt the processor.

Arguments:

    None.

Return Value:

    None.

--*/


{
    _enable();
}

#if !defined(NO_LEGACY_DRIVERS)


BOOLEAN
HalMakeBeep (
    IN ULONG Frequency
    )

/*++

Routine Description:

    This function calls SSC function SscMakeBeep() to make a beep sound
    when the specified frequency has a non-zero value.

Arguments:

    Frequency - the frequency of the sound to be made.

Return Value:

    None.

--*/

{
    if (Frequency > 0) {

        SscMakeBeep(Frequency);
    }
    return TRUE;
}

#endif // NO_LEGACY_DRIVERS


VOID
KeStallExecutionProcessor (
    IN ULONG MicroSeconds
    )

/**
Routine Description:

    This function stalls the processor.

Arguments:

    MicroSeconds - Number of microseconds to stall the processor.

Return Value:

    None.

**/

{
    ULONGLONG CurrentITC;
    ULONGLONG LimitITC;

    CurrentITC = __getReg(CV_IA64_ApITC);

#ifndef DISABLE_ITC_WORKAROUND
    while ((CurrentITC & 0xFFFFFFFF) == 0xFFFFFFFF) {
        CurrentITC = __getReg(CV_IA64_ApITC);
    }
#endif

    LimitITC = CurrentITC + (ULONGLONG) (HalpITCTicksPer100ns * 10 * MicroSeconds);

    while (LimitITC > CurrentITC) {
        CurrentITC = __getReg(CV_IA64_ApITC);

#ifndef DISABLE_ITC_WORKAROUND
        while ((CurrentITC & 0xFFFFFFFF) == 0xFFFFFFFF) {
            CurrentITC = __getReg(CV_IA64_ApITC);
        }
#endif
    }

    return;
}


VOID HalpInitLINT(VOID);


VOID
HalInitializeProcessor (
     ULONG Number,
     PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This function is called early in the initialization of the kernel
    to perform platform dependent initialization for each processor
    before the HAL Is fully functional.

    N.B. When this routine is called, the PCR is present but is not
         fully initialized.

Arguments:

    Number - Supplies the number of the processor to initialize.

Return Value:

    None.

--*/


{
    extern ULONG HalpDefaultInterruptAffinity;

    //
    // Add this processor to the interrupt affinity mask
    //

    HalpDefaultInterruptAffinity |= 1<<Number;

    //
    // Turn off LINT0 LINT1 (disable 8259)
    //

    // __setReg(CV_IA64_SaLRR0, 0x10000);
    // __setReg(CV_IA64_SaLRR1, 0x10000);
    //

    HalpInitLINT();
    __dsrlz();


    //
    // No need to Initialize the virtual address mapping for IO port space
    // since loader/MM do that
    //

    PhysicalIOBase = LoaderBlock->u.Ia64.DtrInfo[DTR_IO_PORT_INDEX].PhysicalAddress;

    PCR->StallScaleFactor = 0;

    //
    // Save my processor ID in PCR
    //

    PCR->HalReserved[PROCESSOR_ID_INDEX] = HalpReadLID() >> 16;

    //
    // This next call has nothing to do with processor init.
    // But this is the only function in the HAL that gets
    // called before KdInit.
    //

    HalpRegisterKdSupportFunctions(LoaderBlock);

    //
    // Update node tables
    //

    HalpAddNodeNumber(Number);

    return;
}

VOID
HalpRegisterInternalInterrupts(
    VOID
    )
/*++

Routine Description:

    This function reserves the known HAL IA64 resources usage and
    registers the IDT vectors usage.

Arguements:

    None.

Return Value:

    None.

--*/
{
    ULONG i;

    //
    // Make sure all vectors 00-2f, c0-ff are reserved
    // 00-0E Passive    Reserved by Intel
    // 0F    SAPIC Spurious Interrupt Vector Reserved
    // 10-1F APC priority level   Reserved
    // 20-2F DPC priority level   Reserved
    // c0-ff clock, ipi, synch, high
    // these are reserved in HalpGetSystemInterruptVector()
    // Do not report to IoReportHalResourceUsage()
    //

    for(i=0; i < PRIMARY_VECTOR_BASE; i++) {
        if (!(HalpIDTUsage[i].Flags & IDTOwned)) {
             HalpIDTUsage[i].Flags = 0;
             HalpIDTUsage[i].BusReleativeVector = (UCHAR) i;
        }
    }


    //
    // Make sure all the interrupts in the SYNCH IRQL range are
    // also reserved.
    //

    for(i= SYNCH_VECTOR; i < (SYNCH_VECTOR+16); i++) {
        if (!(HalpIDTUsage[i].Flags & IDTOwned)) {
             HalpIDTUsage[i].Flags = 0;
             HalpIDTUsage[i].BusReleativeVector = (UCHAR) i;
        }
    }

   //
   // Make sure all the interrupts in the IPI IRQL range are also
   // reserved.
   //

    for(i= IPI_VECTOR; i < (IPI_VECTOR+16); i++) {
        if (!(HalpIDTUsage[i].Flags & IDTOwned)) {
             HalpIDTUsage[i].Flags = 0;
             HalpIDTUsage[i].BusReleativeVector = (UCHAR) i;
        }
    }


   //
   // Make sure all the interrupts in the CLOCK IRQL range are also
   // reserved.
   //

    for(i= CLOCK_VECTOR; i < (CLOCK_VECTOR+16); i++) {
        if (!(HalpIDTUsage[i].Flags & IDTOwned)) {
             HalpIDTUsage[i].Flags = 0;
             HalpIDTUsage[i].BusReleativeVector = (UCHAR) i;
        }
    }

   //
   // Make sure all interrupts in the PROFILE IRQL range also are
   // reserved.
   //

    for(i= PROFILE_VECTOR; i < (PROFILE_VECTOR+16); i++) {
        if (!(HalpIDTUsage[i].Flags & IDTOwned)) {
             HalpIDTUsage[i].Flags = 0;
             HalpIDTUsage[i].BusReleativeVector = (UCHAR) i;
        }
    }

    HalpRegisterVector (
         0,
         SAPIC_SPURIOUS_VECTOR,
         SAPIC_SPURIOUS_VECTOR,
         SAPIC_SPURIOUS_LEVEL
         );

    HalpRegisterVector (
         0,
         (APC_LEVEL << VECTOR_IRQL_SHIFT),
         (APC_LEVEL << VECTOR_IRQL_SHIFT),
         APC_LEVEL
         );

    HalpRegisterVector (
         0,
         (DPC_LEVEL << VECTOR_IRQL_SHIFT),
         (DPC_LEVEL << VECTOR_IRQL_SHIFT),
         DPC_LEVEL
         );

    HalpRegisterVector (
         0,
         MC_RZ_VECTOR,
         MC_RZ_VECTOR,
         HIGH_LEVEL
         );

    HalpRegisterVector (
         0,
         MC_WKUP_VECTOR,
         MC_WKUP_VECTOR,
         HIGH_LEVEL
         );

    //
    // Note that it is possible that HAL_CMC_PRESENT is not set.
    // With the current implementation, we always register the CMC vector.
    //

    HalpRegisterVector (
         0,
         CMCI_VECTOR,
         CMCI_VECTOR,
         CMCI_LEVEL
         );

    //
    // Note that it is possible that HAL_CPE_PRESENT is not set.
    // With the current implementation, we always register the CPE vector.
    //

    HalpRegisterVector (
         0,
         CPEI_VECTOR,
         CPEI_VECTOR,
         CPEI_LEVEL
         );

    HalpRegisterVector (
         0,
         SYNCH_VECTOR,
         SYNCH_VECTOR,
         SYNCH_LEVEL
         );

    HalpRegisterVector (
         0,
         IPI_VECTOR,
         IPI_VECTOR,
         IPI_LEVEL
         );


    HalpRegisterVector (
         0,
         CLOCK_VECTOR,
         CLOCK_VECTOR,
         CLOCK_LEVEL
         );

    HalpRegisterVector (
         0,
         PROFILE_VECTOR,
         PROFILE_VECTOR,
         PROFILE_LEVEL
         );

    HalpRegisterVector (
         0,
         PERF_VECTOR,
         PERF_VECTOR,
         PROFILE_LEVEL
         );

    return;

} // HalpRegisterInternalInterrupts()


VOID
HalpPerfInterrupt (
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

Routine Description:


Arguements:


Return Parameters:


--*/

{

// Thierry: This interrupt handler could be used to implement instructions
//          tracing based on the overflow interrupts generated by PMU events
//          like "retired instructions" or "taken branches".
//          This would provide very valuable inputs for hardware performance simulators.
//
// XXTF - not implemented yet...
    return;

} // HalpPerfInterrupt()



#if defined(HALP_FIX_KD_HALIA64_MASK)
#if DBG

VOID
HalpSetKdHalia64Mask(
   ULONG Mask
   )
//
// Mask == 0 should return without modifying Kd_HALIA64_Mask.
//
{
   NTSTATUS status;
   ULONG    level, levelMasked;
   int      shift;

   if ( Mask == (ULONG)-1 )   {
      status = DbgSetDebugFilterState( DPFLTR_HALIA64_ID, -1, TRUE );
      if ( !NT_SUCCESS(status) ) {
         HalDebugPrint(( HAL_ERROR,
               "HAL!HalInitSystem: failed to set Kd_HALIA64_Mask to maximum debug spew... 0x%lx\n",
               status ));
      }
      return;
   }

   level = levelMasked = Mask & HALIA64_DPFLTR_MAXMASK;
   shift = 0;
   while( level )  {
      level &= 0x1;
      if ( level )    {
        status = DbgSetDebugFilterState( DPFLTR_HALIA64_ID, shift, TRUE );
        if ( !NT_SUCCESS(status) ) {
            HalDebugPrint(( HAL_ERROR,
                         "HAL!HalInitSystem: failed to set Kd_HALIA64_Mask to 0x%lx... 0x%lx\n",
                         shift,
                         status ));
            break;
        }
      }
      shift = shift + 1;
      level = levelMasked >> shift;
    }

    return;

} // HalpSetKdHalia64Mask()

#else  // !DBG

#define HalpSetKdHalia64Mask()

#endif // !DBG
#endif // HALP_FIX_KD_HALIA64_MASK



BOOLEAN
HalInitSystem (
    IN ULONG Phase,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This function initializes the Hardware Architecture Layer (HAL) for an
    ia64 system.

Arguments:

    None.

Return Value:

    A value of TRUE is returned is the initialization was successfully
    complete. Otherwise a value of FALSE is returned.

--*/

{

    PMEMORY_ALLOCATION_DESCRIPTOR Descriptor;
    PLIST_ENTRY NextMd;
    PKPRCB      pPRCB;
    volatile KPCR * const pPCR = KeGetPcr();
    BOOLEAN     Found;

    ULONGLONG   ITCFrequencyQueried;
    ULONGLONG   ProcessorFrequencyQueried;

    ULONG       RTCInti;

    KIRQL       OldIrql;
    NTSTATUS    status;

    //
    // This is for testing RTC clock
    //

    TIME_FIELDS CurrentTimeFields;

    pPRCB = KeGetCurrentPrcb();

    if (Phase == 0) {

        extern VOID DetectAcpiMP();
        BOOLEAN IsMP;
        BOOLEAN EnableInterrupts;

        //
        // Phase 0 initialization only called by P0
        //

        HalpBusType = LoaderBlock->u.Ia64.MachineType & 0x00ff;
        HalpGetParameters (LoaderBlock);

        //
        // Disable Interrupts before messing around with the APIC etc.
        //

        EnableInterrupts = HalpDisableInterrupts();

        DetectAcpiMP(&IsMP, LoaderBlock);

        HalpSetupAcpiPhase0(LoaderBlock);

        //
        // Verify Prcb version and build flags conform to
        // this image
        //

        if (pPRCB->MajorVersion != PRCB_MAJOR_VERSION) {
            KeBugCheckEx (
                MISMATCHED_HAL,
                1,
                pPRCB->MajorVersion,
                PRCB_MAJOR_VERSION,
                0
                );
        }

        KeInitializeSpinLock(&HalpIoSapicLock);

        //
        // Fill in handlers for APIs which this hal supports
        //

        HalQuerySystemInformation = HaliQuerySystemInformation;
        HalSetSystemInformation = HaliSetSystemInformation;
        HalInitPnpDriver = HaliInitPnpDriver;

        //
        // HalGetDmaAdapter was commented in previous version
        // also. HalInitPowerManagement, HalLocateHiberRanges and
        // HalGetInterruptTranslator are added in the latest version
        // of Microsoft source code.
        //

        HalGetDmaAdapter = HaliGetDmaAdapter;
        HalHaltSystem = HaliHaltSystem;
        HalResetDisplay = HalpBiosDisplayReset;

#if !defined( HAL_SP )
        HalGetInterruptTranslator = HalacpiGetInterruptTranslator;
#endif // HAL_SP

#if DBG
        //
        // Switch from HalDisplayString to DbgPrint.
        //

        HalpUseDbgPrint++;
#endif // DBG

#if !defined( HAL_SP ) && !(MCA)
        HalInitPowerManagement = HaliInitPowerManagement;
        HalLocateHiberRanges = HaliLocateHiberRanges;
#endif// HAL_SP and MCA

        //
        // Register PC style IO space used by hal
        //

        HalpRegisterAddressUsage (&HalpDefaultPcIoSpace);
        HalpInitIntiInfo ();

        //
        // Initialize CMOS
        //

        HalpInitializeCmos();

        //
        // Initialize per processor EOI table
        //

        HalpInitEOITable();

        //
        // Initialize the clock for the processor that keeps
        // the system time. This uses a stub ISR until Phase 1
        //

        // Initialize Clock interrupts, profile , APC and DPC interrupts,

        HalpInitializeClock();
        HalpRegisterInternalInterrupts();
        HalpInitializeInterrupts();

        //
        // Initialize initial processor and NT profiling state
        // that should be initialized at Phase 0 and
        // do not require to wait for Phase 1.
        //

        HalpSetInitialProfileState();

        //
        // Interrupts should be safe now.
        //

        if (EnableInterrupts) {
            HalpEnableInterrupts();
        }

        //
        // Initialize event for serialization of new dma adapter events
        //

        KeInitializeEvent(&HalpNewAdapter, SynchronizationEvent, TRUE);

        //
        // Determine if there is physical memory above 4 GB.
        //

        HalDebugPrint(( HAL_INFO, "HAL: Determine if there is memory above 4 Gb\n" ));
        NoMemoryAbove4Gb = TRUE;

        NextMd = LoaderBlock->MemoryDescriptorListHead.Flink;

        while (NextMd != &LoaderBlock->MemoryDescriptorListHead) {
             Descriptor = CONTAINING_RECORD(
                           NextMd,
                           MEMORY_ALLOCATION_DESCRIPTOR,
                           ListEntry
                           );

            if (Descriptor->MemoryType != LoaderFirmwarePermanent &&
                Descriptor->MemoryType != LoaderSpecialMemory) {
                //
                // Test for 4 GB:
                //
                if ((Descriptor->BasePage + Descriptor->PageCount) > (GreaterThan4GB >> PAGE_SHIFT)) {
                      NoMemoryAbove4Gb = FALSE;
                      HalDebugPrint(( HAL_INFO, "HAL: Memory is present above 4Gb\n" ));
                      break;
                }
            }

            NextMd = Descriptor->ListEntry.Flink;
        }

        //
        // Determine the size needed for map buffers.  If this system has
        // memory that requires more than 32 bits to access, then allocate
        // a large chunk; otherwise, allocate a small chunk.
        //

        if (NoMemoryAbove4Gb) {

            //
            // Allocate a small set of map buffers.  They are only need for
            // devices which do not function.
            //

            HalpMapBufferSize = INITIAL_MAP_BUFFER_SMALL_SIZE;
            HalDebugPrint(( HAL_INFO, "HAL: No memory beyond 4Gb\n" ));

        } else {

            //
            // Allocate a larger set of map buffers.  These are used for
            // 32 bit devices to reach memory above 4gb.
            //

            HalpMapBufferSize = INITIAL_MAP_BUFFER_LARGE_SIZE;
            HalDebugPrint(( HAL_INFO, "HAL: Map Buffers for 32 bit devices to reach memory above 4Gb\n" ));

        }

        //
        // Allocate map buffers for the adapter objects
        //

        HalpMapBufferPhysicalAddress.QuadPart = (ULONGLONG)
            HalpAllocPhysicalMemory(LoaderBlock,
                                    MAXIMUM_PHYSICAL_ADDRESS,
                                    HalpMapBufferSize >> PAGE_SHIFT,
                                    TRUE);

        HalpMapBufferPhysicalAddress.HighPart = 0;


        if (!HalpMapBufferPhysicalAddress.LowPart) {

            //
            // There was not a satisfactory block.  Clear the allocation.
            //

            HalpMapBufferSize = 0;
        }

        //
        // Set the processor active in the HAL private active processor mask.
        //
        // For the BSP processor, the specific bit is set at the end of HalInitSystem(Phase0).

        HalpActiveProcessors = 1 << pPRCB->Number;

    } else {

        //
        // Phase 1 initialization
        //

        if ( pPCR->Number == 0) {

            //
            // Back-pocket some PTEs for DMA during low mem
            //
            HalpInitReservedPages();

#if defined(HALP_FIX_KD_HALIA64_MASK)
#if DBG

            HalpSetKdHalia64Mask( HalpFixKdHalia64Mask );

#endif // DBG
#endif // HALP_FIX_KD_HALIA64_MASK

            HalpEfiInitialization(LoaderBlock);

            HalpInitIoMemoryBase();
            HalpInitializeX86Int10Call();
            HalpInitializeInterruptBlock();

            //
            // Map the APICs so that MM will allow us to access them in the
            // debugger.
            //

            HalpInitApicDebugMappings();

            //
            // Initialize MCA,INIT parameters and pre-allocate Event records for BSP processor.
            //

            if ( !HalpInitializeOSMCA( pPCR->Number ) )   {
                return FALSE;
            }

            HalpInitNonBusHandler();

            //
            // Raise IRQL to the highest level, set the new clock interrupt
            // parameters, lower IRQl, and return the new time increment value.
            //

            status = HalpQueryFrequency( &ITCFrequencyQueried,
                                         &ProcessorFrequencyQueried);

            KeRaiseIrql(HIGH_LEVEL, &OldIrql);

            if (NT_SUCCESS(status)) {
                HalpITCFrequency = ITCFrequencyQueried;
                HalpProcessorFrequency = ProcessorFrequencyQueried;
            }

            HalpSetInitialClockRate();

            KeLowerIrql(OldIrql);

            //
            // Set initial feature bits
            //

            HalpFeatureBits = HalpGetFeatureBits();

            //
            // Initialize per-processor profiling
            //
            // Requires HalpITCTicksPer100ns initialized.

            HalpInitializeProfiling( pPCR->Number );

            HalpMCAEnable();
            HalpCMCEnable();
            HalpCPEEnable();

        } else {

            //
            // Initialize per processor EOI table
            //

            HalpInitEOITable();

            //
            //  Initialization needed only on non BSP processors
            //

            HalpInitSalPalNonBsp();
            HalpInitializeClockPn();

            //
            // Allocate MCA, INIT stacks on non BSP processors
            //

            if ( !HalpAllocateMceStacks( pPCR->Number) )  {
                return FALSE;
            }

            //
            // Pre-allocate MCA,INIT records on non BSP processors
            //

            if ( !HalpPreAllocateMceRecords( pPCR->Number) )  {
                return FALSE;
            }

            //
            // Reduce feature bits to be a subset
            //

            HalpFeatureBits &= HalpGetFeatureBits();

            HalpInitializeInterrupts();

            //
            // Initialize per-processor profiling
            //

            HalpInitializeProfiling( pPCR->Number );

            HalpMCAEnable();
            HalpCMCEnable();

            //
            // Set the processor active in the HAL private active processor mask.
            //
            // For non-BSP processors, the specific bit is set at the end of HalInitSystem(Phase1).

            HalpActiveProcessors |= 1 << pPRCB->Number;

        }

    }

    return TRUE;
}


VOID
HalChangeColorPage (
    IN PVOID NewColor,
    IN PVOID OldColor,
    IN ULONG PageFrame
    )
/*++

Routine Description:

   This function changes the color of a page if the old and new colors
   do not match.

Arguments:

   NewColor - Supplies the page aligned virtual address of the
      new color of the page to change.

   OldColor - Supplies the page aligned virtual address of the
      old color of the page to change.

   pageFrame - Supplies the page frame number of the page that
      is changed.

Return Value:

   None.

--*/
{
    return;
}

//****************************************************************
// T. Kjos Added stuff after this line as part of initial
// APIC, PCMP removal.

// From mpsproc.c
ULONG           HalpDontStartProcessors = 0;

//
// Since IA-64 does not support lowest priority interrupts set
// processors per cluster to 1 so that we staically assign interrupts
// in round robin to the processors.
//

UCHAR           HalpMaxProcsPerCluster = 1;

// From pmmphal.c:
BOOLEAN         HalpStaticIntAffinity = FALSE;

extern UCHAR    HalpSzInterruptAffinity[];
extern UCHAR    HalpSzOneCpu[];
extern ULONG    HalpDontStartProcessors;
extern UCHAR    HalpSzPciLock[];
extern UCHAR    HalpSzBreak[];
extern UCHAR    HalpSzForceClusterMode[];

VOID
HalpGetParameters (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

Routine Description:

    This gets any parameters from the boot.ini invocation line.

Arguments:

    None.

Return Value:

    None

--*/
{
    PCHAR       Options;
    PCHAR       p;

    if (LoaderBlock != NULL  &&  LoaderBlock->LoadOptions != NULL) {

        Options = LoaderBlock->LoadOptions;

        //
        //  Has the user set the debug flag?
        //
        //
        //  Has the user requested a particular number of CPU's?
        //

        if (strstr(Options, HalpSzOneCpu)) {
            HalpDontStartProcessors++;
        }

        //
        // Check if user wants device ints to go to highest numbered processor
        //

        if (strstr(Options, HalpSzInterruptAffinity)) {
            HalpStaticIntAffinity = TRUE;
        }

        //
        //  Has the user asked for an initial BreakPoint?
        //

        if (strstr(Options, HalpSzBreak)) {
            DbgBreakPoint();
        }

        //
        // Used to define the size of a node = MaxProcsPerCluster
        // 0 implies one node for the whole machine
        //
        p = strstr(Options, HalpSzForceClusterMode);
        if (p) {
            // skip to value
            while (*p  &&  *p != ' ' &&  (*p < '0'  || *p > '9')) {
                p++;
            }
            HalpMaxProcsPerCluster = (UCHAR)atoi(p);
        }
    }

    return ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\i64prfle.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    i64prfle.c

Abstract:


    This module implements the IA64 Hal Profiling using the performance
    counters within the core of the first IA64 Processor Merced, aka Itanium.  
    This module is appropriate for all machines based on microprocessors using
    the Merced core.
    
    With the information known at this development time, this module tries to 
    consider the future IA64 processor cores by encapsulating the differences 
    in specific micro-architecture data structures. 
    
    Furthermore, with the implementation of the new NT ACPI Processor driver, this
    implementation will certainly change in the coming months.
    
    N.B. - This module assumes that all processors in a multiprocessor
           system are running the microprocessor at the same clock speed.
           
Author:

    Thierry Fevrier 08-Feb-2000

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"

//
// Assumptions for the current implementation - 02/08/2000 :
// These assumptions will be re-evaluated and worked out if required.
//
//  - Respect and satisfy as much possible the Profiling Sources interface
//    already defined by NT and HAL.
//
//  - All processors in a multiprocessor system are running the microprocessor 
//    at the same invariant clock speed.
//     
//  - All processors are configured with the same set of profiling counters. 
//    XXTF - 04/01/2000 - This assumption is being re-worked and will disappear.
//
//  - Profiling is based on the processor monitored events and if possible 
//    on derived events.
//
//  - A monitored event can only be enabled on one performance counter at a time. 
//

//
// IA64 performance counters defintions:
//      - event counters
//      - EARS
//      - BTBs
//      - ...
//

#include "ia64prof.h"
#if defined(_MCKINLEY_)
#include "mckinley.h"
#else  // Default IA64 - Merced
#include "merced.h"
#endif //

extern ULONGLONG            HalpITCFrequency;
extern HALP_PROFILE_MAPPING HalpProfileMapping[];

#define HalpDisactivateProfileSource( _ProfileSource ) ((_ProfileSource)  = ProfileIA64Maximum)
#define HalpIsProfileSourceActive( _ProfileSource )    ((_ProfileSource) != ProfileIA64Maximum)           
#define HalpIsProfileMappingInvalid( _ProfileMapping ) (!(_ProfileMapping) || ((_ProfileMapping)->Supported == FALSE))
                             
VOID
HalpEnableProfileCounting (
   VOID
   )
/*++

Routine Description:

   This function enables the profile counters to increment.
   This function is the counterpart of HalpDisableProfileCounting().

Arguments:

   None.

Return Value:

   None.

--*/
{
    ULONGLONG Data, ClearStatusMask;

    //
    // Clear PMC0.fr - bit 0.
    // Clear PMCO,1,2,3 OverFlow Bits.
    //

    ClearStatusMask = 0xFFFFFFFFFFFFFF0E; // XXTF - FIXFIX - Merced specific.
    Data = HalpReadPerfMonCnfgReg0();
    Data &= ClearStatusMask;
    HalpWritePerfMonCnfgReg0(Data);

    return;

} // HalpEnableProfileCounting()

VOID
HalpDisableProfileCounting (
   VOID
   )
/*++

Routine Description:

   This function disables the profile counters to increment.
   This function is the counterpart of HalpEnableProfileCounting().

Arguments:

   None.

Return Value:

   None.

--*/
{
   ULONGLONG Data, SetFreezeMask;

   SetFreezeMask = 0x1;
   Data = HalpReadPerfMonCnfgReg0();
   Data |= SetFreezeMask;
   HalpWritePerfMonCnfgReg0(Data);

   return;

} // HalpDisableProfileCounting()

VOID
HalpSetInitialProfileState(
   VOID
  )
/*++

Routine Description:

   This function is called at HalInitSystem - phase 0 time to set
   the initial state of processor and profiling os subsystem with 
   regards to the profiling functionality.

Arguments:

   None.

Return Value:

   None.

--*/
{

//   HalpProfilingRunning = 0;

   HalpDisableProfileCounting();

   return;

} // HalpSetInitialProfileState()

VOID
HalpSetProfileCounterInterval (
     IN ULONG    Counter,
     IN LONGLONG NextCount
     )
/*++

Routine Description:

    This function preloads the specified counter with a count value
    of 2^IMPL_BITS - NextCount. 

Arguments:

    Counter   - Supplies the performance counter register number.

    NextCount - Supplies the value to preload in the monitor. 
                An external interruption will be generated after NextCount.

Return Value:

    None.
    
Note:

    IMPL_BITS is defined by PAL_PERF_MON_INFO.PAL_WIDTH.
    
ToDo:

    IMPL_BITS is hardcoded to 32.                                                            

--*/
{
   
    ULONGLONG Count;

#define MAXIMUM_COUNT 4294967296 // 2 ** 32 for Merced. XXTF - FIXFIX - Merced specific.

// if ( (Counter < 4) || (Counter > 7) ) return;

    if (NextCount > MAXIMUM_COUNT) {
       Count = 0;
    } else   {
       Count = MAXIMUM_COUNT - NextCount;
    }

    HalpWritePerfMonDataReg( Counter, Count ); 

#undef MAXIMUM_COUNT

    return;

} // HalpSetProfileCounterInterval()

VOID
HalpSetProfileCounterPrivilegeLevelMask(
     IN ULONG    Counter,
     IN ULONG    Mask
     )
/*++

Routine Description:

    This function set the profile counter privilege level mask.

Arguments:

    Counter   - Supplies the performance counter register number.

    Mask      - Supplies the privilege level mask to program the PMC with.

Return Value:

    None.
    
--*/
{
   ULONGLONG data, plmMask;

// if ( (Counter < 4) || (Counter > 7) ) return;

   plmMask = Mask & 0xF;
   data = HalpReadPerfMonCnfgReg( Counter );
   data &= ~0xF;
   data |= plmMask;
   HalpWritePerfMonCnfgReg( Counter, data );

   return;
   
} // HalpSetProfileCounterPrivilegeLevelMask()

VOID
HalpEnableProfileCounterOverflowInterrupt (
     IN ULONG    Counter
     )
/*++

Routine Description:

    This function enables the delivery of an overflow interrupt for 
    the specified profile counter.

Arguments:

    Counter   - Supplies the performance counter register number.

Return Value:

    None.
    
--*/
{
   ULONGLONG data, mask;

// if ( (Counter < 4) || (Counter > 7) ) return;

   mask = 1<<5;
   data = HalpReadPerfMonCnfgReg( Counter );
   data |= mask;
   HalpWritePerfMonCnfgReg( Counter, data );

   return;
   
} // HalpEnableProfileCounterOverflowInterrupt()

VOID
HalpDisableProfileCounterOverflowInterrupt (
     IN ULONG    Counter
     )
/*++

Routine Description:

    This function disables the delivery of an overflow interrupt for 
    the specified profile counter.

Arguments:

    Counter   - Supplies the performance counter register number.

Return Value:

    None.
    
--*/
{
   ULONGLONG data, mask;

// if ( (Counter < 4) || (Counter > 7) ) return;

   mask = 1<<5;
   data = HalpReadPerfMonCnfgReg( Counter );
   data &= ~mask;
   HalpWritePerfMonCnfgReg( Counter, data );

   return;
   
} // HalpDisableProfileCounterOverflowInterrupt()

VOID
HalpEnableProfileCounterPrivilegeMonitor(
     IN ULONG    Counter
     )
/*++

Routine Description:

    This function enables the profile counter as privileged monitor.

Arguments:

    Counter   - Supplies the performance counter register number.

Return Value:

    None.
    
--*/
{
   ULONGLONG data, pm;

// if ( (Counter < 4) || (Counter > 7) ) return;

   pm = 1<<6;
   data = HalpReadPerfMonCnfgReg( Counter );
   data |= pm;
   HalpWritePerfMonCnfgReg( Counter, data );

   return;
   
} // HalpEnableProfileCounterPrivilegeMonitor()

VOID
HalpDisableProfileCounterPrivilegeMonitor(
     IN ULONG    Counter
     )
/*++

Routine Description:

    This function disables the profile counter as privileged monitor.

Arguments:

    Counter   - Supplies the performance counter register number.

Return Value:

    None.
    
--*/
{
   ULONGLONG data, pm;

// if ( (Counter < 4) || (Counter > 7) ) return;

   pm = 1<<6;
   data = HalpReadPerfMonCnfgReg( Counter );
   data &= ~pm;
   HalpWritePerfMonCnfgReg( Counter, data );

   return;
   
} // HalpDisableProfileCounterPrivilegeMonitor()

VOID
HalpSetProfileCounterEvent(
     IN ULONG    Counter,
     IN ULONG    Event
     )
/*++

Routine Description:

    The function specifies the monitor event for the profile counter.

Arguments:

    Counter   - Supplies the performance counter register number.

    Event     - Supplies the monitor event code.

Return Value:

    None.
    
--*/
{
   ULONGLONG data, es;

// if ( (Counter < 4) || (Counter > 7) ) return;

   es = (Event & 0x7F) << 8;
   data = HalpReadPerfMonCnfgReg( Counter );
   data &= ~(0x7F << 8);
   data |= es;
   HalpWritePerfMonCnfgReg( Counter, data );

   return;
   
} // HalpSetProfileCounterEvent()

VOID
HalpSetProfileCounterUmask(
     IN ULONG    Counter,
     IN ULONG    Umask
     )
/*++

Routine Description:

    This function sets the event specific umask value for the profile 
    counter.

Arguments:

    Counter   - Supplies the performance counter register number.

    Umask     - Supplies the event specific umask value.

Return Value:

    None.
    
--*/
{
   ULONGLONG data, um;

// if ( (Counter < 4) || (Counter > 7) ) return;

   um = (Umask & 0xF) << 16;
   data = HalpReadPerfMonCnfgReg( Counter );
   data &= ~(0xF << 16);
   data |= um;
   HalpWritePerfMonCnfgReg( Counter, data );

   return;
   
} // HalpSetProfileCounterUmask()

VOID
HalpSetProfileCounterThreshold(
     IN ULONG    Counter,
     IN ULONG    Threshold
     )
/*++

Routine Description:

    This function sets the profile counter threshold.

Arguments:

    Counter   - Supplies the performance counter register number.

    Threshold - Supplies the desired threshold. 
                This is related to multi-occurences events.

Return Value:

    None.
    
--*/
{
   ULONGLONG data, reset, th;

   switch( Counter )    {
    case 4:
    case 5:
        Threshold &= 0x7;
        reset = ~(0x7 << 20);
        break;

    case 6:
    case 7:
        Threshold &= 0x3;
        reset = ~(0x3 << 20);
        break;

    default:
        return;
   }
   
   th = Threshold << 20;
   data = HalpReadPerfMonCnfgReg( Counter );
   data &= reset;
   data |= th;
   HalpWritePerfMonCnfgReg( Counter, data );

   return;
   
} // HalpSetProfileCounterThreshold()

VOID
HalpSetProfileCounterInstructionSetMask(
     IN ULONG    Counter,
     IN ULONG    Mask
     )
/*++

Routine Description:

    This function sets the instruction set mask for the profile counter.

Arguments:

    Counter   - Supplies the performance counter register number.

    Mask      - Supplies the instruction set mask.

Return Value:

    None.
    
--*/
{
   ULONGLONG data, ismMask;

// if ( (Counter < 4) || (Counter > 7) ) return;

   ismMask = (Mask & 0x3) << 24;
   data = HalpReadPerfMonCnfgReg( Counter );
   data &= ~(0x3 << 24);
   data |= ismMask;
   HalpWritePerfMonCnfgReg( Counter, data );

   return;
   
} // HalpSetProfileCounterInstructionSetMask()

VOID
HalpSetProfileCounterConfiguration(
     IN ULONG    Counter,
     IN ULONG    PrivilegeMask,
     IN ULONG    EnableOverflowInterrupt,
     IN ULONG    EnablePrivilegeMonitor,
     IN ULONG    Event,
     IN ULONG    Umask,
     IN ULONG    Threshold,
     IN ULONG    InstructionSetMask
     )
/*++  

Function Description: 

    This function sets the profile counter with the specified parameters.

Arguments:

    IN ULONG Counter - 

    IN ULONG PrivilegeMask - 

    IN ULONG EnableOverflowInterrupt - 

    IN ULONG EnablePrivilegeMonitor - 

    IN ULONG Event - 

    IN ULONG Umask - 

    IN ULONG Threshold - 

    IN ULONG InstructionSetMask - 

Return Value:

    VOID 

Algorithm:

    ToBeSpecified

In/Out Conditions:

    ToBeSpecified

Globals Referenced:

    ToBeSpecified

Exception Conditions:

    ToBeSpecified

MP Conditions:

    ToBeSpecified

Notes:

    This function is a kind of combo of the different profile counter APIs.
    It was created to provide speed.

ToDo List:

    - Setting the threshold is not yet supported.

Modification History:

    3/16/2000  TF  Initial version

--*/
{
   ULONGLONG data, plmMask, ismMask, es, um, th;

// if ( (Counter < 4) || (Counter > 7) ) return;

   plmMask = (PrivilegeMask & 0xF);
   es      = (Event & 0x7F) << 8;
   um = (Umask & 0xF) << 16;
// XXTF - ToBeDone - Threshold not supported yet.
   ismMask = (InstructionSetMask & 0x3) << 24;

   data = HalpReadPerfMonCnfgReg( Counter );

HalDebugPrint(( HAL_PROFILE, "HalpSetProfileCounterConfiguration: Counter = %ld Read    = 0x%I64x\n", Counter, data ));

   data &= ~( (0x3 << 24) | (0xF << 16) | (0x7F << 8) | 0xF );
   data |= ( plmMask | es | um | ismMask );
   data = EnableOverflowInterrupt ? (data | (1<<5)) : (data & ~(1<<5));
   data = EnablePrivilegeMonitor  ? (data | (1<<6)) : (data & ~(1<<6));
   
   HalpWritePerfMonCnfgReg( Counter, data );

HalDebugPrint(( HAL_PROFILE, "HalpSetProfileCounterConfiguration: Counter = %ld Written = 0x%I64x\n", Counter, data ));

   return;
   
} // HalpSetProfileCounterConfiguration()

NTSTATUS
HalpProgramProfileMapping(
    PHALP_PROFILE_MAPPING ProfileMapping,
    KPROFILE_SOURCE       ProfileSource
    )
/*++

Routine Description:

    This function enables the profiling configuration for the event defined by the 
    specified Profile Mapping entry.

Arguments:

    ProfileMapping - Supplies the Profile Mapping entry.

    ProfileSource  - Supplies the Profile Source corresponding to the Profile Mapping entry.

Return Value:
    
    STATUS_SUCCESS -

    STATUS_INVALID_PARAMETER -

    STATUS_UNSUCESSFUL -

--*/
{
    NTSTATUS status;
    ULONG    sourceMask;

    if ( ! ProfileMapping ) {
        return STATUS_INVALID_PARAMETER;
    }

// XXTF - ToBeDone - Derived Event

    sourceMask = ProfileMapping->ProfileSourceMask;
    if ( (sourceMask & PMCD_MASK_4) && !HalpIsProfileSourceActive( HalpProfileSource4 ) )   {

        HalpSetProfileCounterConfiguration( 4, 
                                            PMC_PLM_ALL, 
                                            PMC_ENABLE_OVERFLOW_INTERRUPT, 
                                            PMC_ENABLE_PRIVILEGE_MONITOR,
                                            ProfileMapping->Event,
                                            0, // Umask
                                            0, // Threshold
                                            PMC_ISM_ALL
                                          );

        HalpSetProfileCounterInterval( 4, ProfileMapping->Interval );   

        HalpProfileSource4 = ProfileSource;

        return STATUS_SUCCESS;
    }
    if ( (sourceMask & PMCD_MASK_5) && !HalpIsProfileSourceActive( HalpProfileSource5 ) )   {

        HalpSetProfileCounterConfiguration( 5, 
                                            PMC_PLM_ALL, 
                                            PMC_ENABLE_OVERFLOW_INTERRUPT, 
                                            PMC_ENABLE_PRIVILEGE_MONITOR,
                                            ProfileMapping->Event,
                                            0, // Umask
                                            0, // Threshold
                                            PMC_ISM_ALL
                                          );

        HalpSetProfileCounterInterval( 5, ProfileMapping->Interval );   

        HalpProfileSource5 = ProfileSource;

        return STATUS_SUCCESS;
    }
    if ( (sourceMask & PMCD_MASK_6) && !HalpIsProfileSourceActive( HalpProfileSource6 ) )   {

        HalpSetProfileCounterConfiguration( 6, 
                                            PMC_PLM_ALL, 
                                            PMC_ENABLE_OVERFLOW_INTERRUPT, 
                                            PMC_ENABLE_PRIVILEGE_MONITOR,
                                            ProfileMapping->Event,
                                            0, // Umask
                                            0, // Threshold
                                            PMC_ISM_ALL
                                          );

        HalpSetProfileCounterInterval( 6, ProfileMapping->Interval );   

        HalpProfileSource6 = ProfileSource;

        return STATUS_SUCCESS;
    }
    if ( (sourceMask & PMCD_MASK_7) && !HalpIsProfileSourceActive( HalpProfileSource7 ) )   {

        HalpSetProfileCounterConfiguration( 7, 
                                            PMC_PLM_ALL, 
                                            PMC_ENABLE_OVERFLOW_INTERRUPT, 
                                            PMC_ENABLE_PRIVILEGE_MONITOR,
                                            ProfileMapping->Event,
                                            0, // Umask
                                            0, // Threshold
                                            PMC_ISM_ALL
                                          );

        HalpSetProfileCounterInterval( 7, ProfileMapping->Interval );   

        HalpProfileSource7 = ProfileSource;

        return STATUS_SUCCESS;
    }

    return STATUS_UNSUCCESSFUL;

} // HalpProgramProfileMapping()

ULONG_PTR
HalpSetProfileInterruptHandler(
    IN ULONG_PTR ProfileInterruptHandler
    )
/*++

Routine Description:

    This function registers a per-processor Profiling Interrupt Handler.
    
Arguments:

    ProfileInterruptHandler - Interrupt Handler.

Return Value:

    (ULONG_PTR)STATUS_SUCCESS           - Successful registration.

    (ULONG_PTR)STATUS_ALREADY_COMMITTED - Cannot register an handler if profiling events are running.

    (ULONG_PTR)STATUS_PORT_ALREADY_SET  - An Profiling Interrupt Handler was already registred - not imposed currently.

Note:

    IT IS THE RESPONSIBILITY OF THE CALLER OF THIS ROUTINE TO ENSURE
    THAT NO PAGE FAULTS WILL OCCUR DURING EXECUTION OF THE PROVIDED
    FUNCTION OR ACCESS TO THE PROVIDED CONTEXT.
    A MINIMUM OF FUNCTION POINTER CHECKING WAS DONE IN HalSetSystemInformation PROCESSING.

--*/
{

    //
    // If profiling is already running, we do not allow the handler registration.
    //
    // This imposes that:
    //
    //  - if the default HAL profiling is running or a profiling with a registered interrupt
    //    handler is running, we cannot register an interrupt handler.
    //    In the last case, all the profiling events have to be stopped before a possible
    //    registration.
    //  
    // It should be also noticed that there is no ownership of profiling monitors implemented.
    // Meaning that if profiling is started, the registred handler will get the interrupts
    // generated by ALL the running monitor events if they are programmed to generate interrupts.
    // 

    if ( HalpProfilingRunning ) {

HalDebugPrint(( HAL_PROFILE, "HalpSetProfileInterruptHandler: Profiling already running\n" ));
        return((ULONG_PTR)(ULONG)(STATUS_ALREADY_COMMITTED));

    }

#if 0
//
// Thierry - 03/2000. ToBeVerified.
//
// In case, no profiling was started, there is currently no restriction in registering 
// another handler if one was already registered. 
//

    if ( HalpProfillingInterruptHandler )   {
        return((ULONG_PTR)(ULONG)(STATUS_PORT_ALREADY_SET));
    }

#endif // 0

    HalpProfilingInterruptHandler = (ULONGLONG)ProfileInterruptHandler;
    return((ULONG_PTR)(ULONG)(STATUS_SUCCESS));

} // HalpSetProfileInterruptHandler()

VOID 
HalpProfileInterrupt(
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME TrapFrame
    )
/*++

Routine Description:

    Default PROFILE_VECTOR Interrupt Handler.
    This function is executed as the result of an interrupt from the
    internal microprocessor performance counters.  The interrupt
    may be used to signal the completion of a profile event.
    If profiling is current active, the function determines if the
    profile interval has expired and if so dispatches to the standard
    system routine to update the system profile time.  If profiling
    is not active then returns.

Arguments:

    TrapFrame - Trap frame address.

Return Value:

    None.

--*/
{

    // 
    // Call registered per-processor Profiling Interrupt handler if it exists.
    // We will return immediately before doing any default profiling interrupt handling.
    // 
    // XXTF - ToBeVerified - This functionality has to be verified before 
    //                       final check-in.
    //

    if ( HalpProfilingInterruptHandler )  {
        (*((PHAL_PROFILE_INTERRUPT_HANDLER)HalpProfilingInterruptHandler))( TrapFrame ); 
        return;
    }

    //
    // Handle interrupt if profiling is enabled.
    // 

    if ( HalpProfilingRunning )   {

        //
        // Process every PMC/PMD pair overflow.
        //

// XXTF - FIXFIX - Merced specific.
        UCHAR pmc0, overflow;
        ULONG source;

        HalpProfilingInterrupts++;

        pmc0 = (UCHAR)HalpReadPerfMonCnfgReg0();
ASSERTMSG( "HAL!HalpProfileInterrupt PMC0 freeze bit is not set!\n", pmc0 & 0x1 );
        overflow = pmc0 & 0xF0;
ASSERTMSG( "HAL!HalpProfileInterrupt no overflow bit set!\n", overflow );
        if ( overflow & (1<<4) )  {
            source =  HalpProfileSource4;  // XXTF - IfFaster - Coud used pmc.es
ASSERTMSG( "HAL!HalpProfileInterrupt no overflow bit set!\n", source < ProfileIA64Maximum );
            KeProfileInterruptWithSource( TrapFrame, source );
            HalpSetProfileCounterInterval( 4, HalpProfileMapping[source].Interval );
//          XXTF - IfFaster - HalpWritePerfMonDataReg( 4, HalpProfileMapping[source].Interval );
//          XXTF - CodeWithReload - HalpWritePerfMonCnfgReg( 4, *PCRProfileCnfg4Reload );
        }
        if ( overflow & (1<<5) )  {
            source =  HalpProfileSource5;  // XXTF - IfFaster - Coud used pmc.es
ASSERTMSG( "HAL!HalpProfileInterrupt no overflow bit set!\n", source < ProfileIA64Maximum );
            KeProfileInterruptWithSource( TrapFrame, source );
            HalpSetProfileCounterInterval( 5, HalpProfileMapping[source].Interval );
//          XXTF - IfFaster - HalpWritePerfMonDataReg( 5, HalpProfileMapping[source].Interval );
//          XXTF - CodeWithReload - HalpWritePerfMonCnfgReg( 5, *PCRProfileCnfg5Reload );
        }
        if ( overflow & (1<<6) )  {
            source =  HalpProfileSource6;  // XXTF - IfFaster - Coud used pmc.es
ASSERTMSG( "HAL!HalpProfileInterrupt no overflow bit set!\n", source < ProfileIA64Maximum );
            KeProfileInterruptWithSource( TrapFrame, source );
            HalpSetProfileCounterInterval( 6, HalpProfileMapping[source].Interval );
//          XXTF - IfFaster - HalpWritePerfMonDataReg( 6, HalpProfileMapping[source].Interval );
//          XXTF - CodeWithReload - HalpWritePerfMonCnfgReg( 6, *PCRProfileCnfg6Reload );
        }
        if ( overflow & (1<<7) )  {
            source =  HalpProfileSource7;  // XXTF - IfFaster - Coud used pmc.es
ASSERTMSG( "HAL!HalpProfileInterrupt no overflow bit set!\n", source < ProfileIA64Maximum );
            KeProfileInterruptWithSource( TrapFrame, source );
            HalpSetProfileCounterInterval( 7, HalpProfileMapping[source].Interval );
//          XXTF - IfFaster - HalpWritePerfMonDataReg( 6, HalpProfileMapping[source].Interval );
//          XXTF - CodeWithReload - HalpWritePerfMonCnfgReg( 7, *PCRProfileCnfg7Reload );
        }

        //
        // Clear pmc0.fr and overflow bits.
        // 

        HalpEnableProfileCounting();

    }
    else   {

        HalpProfilingInterruptsWithoutProfiling++;

    }

    return;

} // HalpProfileInterrupt()

PHALP_PROFILE_MAPPING
HalpGetProfileMapping(
    IN KPROFILE_SOURCE Source
    )
/*++

Routine Description:

    Given a profile source, returns whether or not that source is
    supported.

Arguments:

    Source - Supplies the profile source

Return Value:

    TRUE - Profile source is supported

    FALSE - Profile source is not supported

--*/
{
    if ( Source > ProfileIA64Maximum /* = (sizeof(HalpProfileMapping)/sizeof(HalpProfileMapping[0])) */ )
    {
        return NULL;
    }

    return(&HalpProfileMapping[Source]);

} // HalpGetProfileMapping()

BOOLEAN
HalQueryProfileInterval(
    IN KPROFILE_SOURCE Source
    )
/*++

Routine Description:

    Given a profile source, returns whether or not that source is
    supported.

Arguments:

    Source - Supplies the profile source

Return Value:

    TRUE - Profile source is supported

    FALSE - Profile source is not supported

--*/
{
    PHALP_PROFILE_MAPPING profileMapping;

    profileMapping = HalpGetProfileMapping( Source );
    if ( !profileMapping ) {
        return(FALSE);
    }

    return( profileMapping->Supported );

} // HalQueryProfileInterval()

NTSTATUS
HalSetProfileSourceInterval(
    IN KPROFILE_SOURCE  ProfileSource,
    IN OUT ULONG_PTR   *Interval
    )
/*++

Routine Description:

    Sets the profile interval for a specified profile source

Arguments:

    ProfileSource - Supplies the profile source

    Interval - Supplies the specified profile interval
               Returns the actual profile interval

             - if ProfileSource is ProfileTime, Interval is in 100ns units.

Return Value:

    NTSTATUS

--*/
{
    ULONGLONG countEvents;
    PHALP_PROFILE_MAPPING profileMapping;

    profileMapping = HalpGetProfileMapping(ProfileSource);
    if ( HalpIsProfileMappingInvalid( profileMapping ) )  {
        return(STATUS_NOT_IMPLEMENTED);
    }

HalDebugPrint(( HAL_PROFILE, "HalSetProfileSourceInterval: ProfileSource = %ld IN  *Interval = 0x%Ix\n", ProfileSource, *Interval ));

    if ( ProfileSource == ProfileTime ) {
        //
        // Convert the clock tick period (in 100ns units) into a cycle count period
        //
        countEvents = (ULONGLONG)(*Interval * HalpITCTicksPer100ns); 
    } 
    else {
        countEvents = (ULONGLONG)*Interval;
    }

HalDebugPrint(( HAL_PROFILE, "HalSetProfileSourceInterval: countEvent = 0x%I64x\n", countEvents ));

    //
    // Check to see if the desired Interval is reasonable, if not adjust it.
    //

    if ( countEvents > profileMapping->MaxInterval )  {
        countEvents = profileMapping->MaxInterval;
    }
    else if ( countEvents < profileMapping->MinInterval )   {
        countEvents = profileMapping->MinInterval;
    }
    profileMapping->Interval = countEvents;

HalDebugPrint(( HAL_PROFILE, "HalSetProfileSourceInterval: CurrentInterval = 0x%I64x\n", profileMapping->Interval ));

    if ( ProfileSource == ProfileTime ) {
        ULONGLONG tempInterval;

        //
        // Convert cycle count back into 100ns clock ticks
        //

        tempInterval = (ULONGLONG)(countEvents / HalpITCTicksPer100ns);
#if 0
        if ( tempInterval < 1 ) {
            tempInterval = 1;
        }
#endif 
        *Interval = (ULONG_PTR)tempInterval;

    }
    else {
        *Interval = (ULONG_PTR)countEvents;
    }

HalDebugPrint(( HAL_PROFILE, "HalSetProfileSourceInterval: ProfileSource = %ld OUT *Interval = 0x%Ix\n", ProfileSource, *Interval ));   

    return STATUS_SUCCESS;

} // HalSetProfileSourceInterval()

ULONG_PTR
HalSetProfileInterval (
    IN ULONG_PTR Interval
    )

/*++

Routine Description:

    This routine sets the ProfileTime source interrupt interval.

Arguments:

    Interval - Supplies the desired profile interval in 100ns units.

Return Value:

    The actual profile interval.

--*/

{
    ULONG_PTR NewInterval;

    NewInterval = Interval;
    HalSetProfileSourceInterval(ProfileTime, &NewInterval);
    return(NewInterval);

} // HalSetProfileInterval()

VOID
HalStartProfileInterrupt (
    KPROFILE_SOURCE ProfileSource
    )

/*++

Routine Description:

    This routine turns on the profile interrupt.

    N.B. This routine must be called at PROFILE_LEVEL while holding the profile lock if MP.

Arguments:

    None.

Return Value:

    None.

--*/

{
    BOOLEAN               disabledProfileCounting;
    NTSTATUS              status;
    PHALP_PROFILE_MAPPING profileMapping;

    //
    // Get the Hal profile mapping entry associated with the specified source.
    //

    profileMapping = HalpGetProfileMapping( ProfileSource );
    if ( HalpIsProfileMappingInvalid( profileMapping ) )  {
HalDebugPrint(( HAL_PROFILE, "HalStartProfileInterrupt: invalid source = %ld\n", ProfileSource ));
        return;
    }

    //
    // Disable the profile counting if enabled.
    //
    
    disabledProfileCounting = FALSE;
    if ( HalpProfilingRunning && !(HalpReadPerfMonCnfgReg0() & 0x1) )   {
        HalpDisableProfileCounting();
        disabledProfileCounting = TRUE;
    }

    //
    // Obtain and initialize an available PMC register that supports this event.
    // We may enable more than one event.
    // If the initialization failed, we return immediately. 
    //
    // XXTF - FIXFIX - is there a way to 
    //     * notify the caller for the failure and the reason of the failure. or
    //     * modify the API. or
    //     * define a new API.
    //

    status = HalpProgramProfileMapping( profileMapping, ProfileSource );   
    if ( !NT_SUCCESS(status) )  {
HalDebugPrint(( HAL_PROFILE, "HalStartProfileInterrupt: HalpProgramProfileMapping failed.\n" ));
        if ( disabledProfileCounting )  {
            HalpEnableProfileCounting();        
        }
        return;
    }

    //
    // Notify the profiling as active. 
    // before enabling the selected pmc overflow interrupt and unfreezing the counters.
    //

    HalpProfilingRunning++;
    HalpEnableProfileCounting();

    return;

} // HalStartProfileInterrupt()

VOID
HalStopProfileInterrupt (
    KPROFILE_SOURCE ProfileSource
    )

/*++

Routine Description:

    This routine turns off the profile interrupt.

    N.B. This routine must be called at PROFILE_LEVEL while holding the
        profile lock.

Arguments:

    ProfileSource - Supplies the Profile Source to stop.

Return Value:

    None.

--*/
{
    PHALP_PROFILE_MAPPING profileMapping;

    //
    // Get the Hal profile mapping entry associated with the specified profile source.
    //

    profileMapping = HalpGetProfileMapping( ProfileSource );
    if ( HalpIsProfileMappingInvalid( profileMapping ) )  {
HalDebugPrint(( HAL_PROFILE, "HalStopProfileInterrupt: invalid source = %ld\n", ProfileSource ));
        return;
    }

    //
    // Validate the Profile Source as active.
    //

    if ( HalpProfileSource4 == ProfileSource )   {

// XXTF - FIXFIX - Derived Event - ToBeDone 

        HalpSetProfileCounterConfiguration( 4,
                                            PMC_PLM_NONE,
                                            PMC_DISABLE_OVERFLOW_INTERRUPT,
                                            PMC_DISABLE_PRIVILEGE_MONITOR,
                                            0, // Event
                                            0, // Umask
                                            0, // Threshold
                                            PMC_ISM_NONE
                                          );

        HalpSetProfileCounterInterval( 4, 0 );
        HalpDisactivateProfileSource( HalpProfileSource4 ); 
        HalpProfilingRunning--;
        
    }
    else if ( HalpProfileSource5 == ProfileSource )   {

// XXTF - FIXFIX - Derived Event - ToBeDone 

        HalpSetProfileCounterConfiguration( 5,
                                            PMC_PLM_NONE,
                                            PMC_DISABLE_OVERFLOW_INTERRUPT,
                                            PMC_DISABLE_PRIVILEGE_MONITOR,
                                            0, // Event
                                            0, // Umask
                                            0, // Threshold
                                            PMC_ISM_NONE
                                          );

        HalpSetProfileCounterInterval( 5, 0 );
        HalpDisactivateProfileSource( HalpProfileSource5 ); 
        HalpProfilingRunning--;
        
    }
    else if ( HalpProfileSource6 == ProfileSource )   {

// XXTF - FIXFIX - Derived Event - ToBeDone 

        HalpSetProfileCounterConfiguration( 6,
                                            PMC_PLM_NONE,
                                            PMC_DISABLE_OVERFLOW_INTERRUPT,
                                            PMC_DISABLE_PRIVILEGE_MONITOR,
                                            0, // Event
                                            0, // Umask
                                            0, // Threshold
                                            PMC_ISM_NONE
                                          );

        HalpSetProfileCounterInterval( 6, 0 );
        HalpDisactivateProfileSource( HalpProfileSource6); 
        HalpProfilingRunning--;
        
    }
    else if ( HalpProfileSource7 == ProfileSource )   {

// XXTF - FIXFIX - Derived Event - ToBeDone 

        HalpSetProfileCounterConfiguration( 7,
                                            PMC_PLM_NONE,
                                            PMC_DISABLE_OVERFLOW_INTERRUPT,
                                            PMC_DISABLE_PRIVILEGE_MONITOR,
                                            0, // Event
                                            0, // Umask
                                            0, // Threshold
                                            PMC_ISM_NONE
                                          );

        HalpSetProfileCounterInterval( 7, 0 );
        HalpDisactivateProfileSource( HalpProfileSource7 ); 
        HalpProfilingRunning--;
    }

    return;

} // HalStopProfileInterrupt()

VOID
HalpResetProcessorDependentPerfMonCnfgRegs(
    ULONGLONG DefaultValue
    )
/*++

Routine Description:

    This routine initializes the processor dependent performance configuration
    registers.

Arguments:

    DefaultValue - default value used to initialize IA64 generic PMCs.

Return Value:

    None.

--*/
{

    // XXTF - 02/08/2000
    // For now, there is no initialization for processor dependent performance
    // configuration registers.
    return;

} // HalpResetProcessorDependentPerfMonCnfgRegs()

VOID
HalpResetPerfMonCnfgRegs(
    VOID
    )
/*++

Routine Description:

    This routine initializes the IA64 architected performance configuration
    registers and calls the micro-architecture specific initialization.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG pmc;
    ULONGLONG value;

    //
    // PMC Reset value:
    // Reg.   Field         Bits
    // PMC*   .plm       -  3: 0 - Privilege Mask       - 0 (Disable Counter)
    // PMC*   .ev        -     4 - External Visibility  - 0 (Disabled)
    // PMC*   .oi        -     5 - Overflow Interrupt   - 0 (Disabled)
    // PMC*   .pm        -     6 - Privilege Monitor    - 0 (user monitor)
    // PMC*   .ig        -     7 - Ignored           
    // PMC*   .es        - 14: 8 - Event Select         - 0 (XXTF - Warning - 0x0 = Real Event)
    // PMC*   .ig        -    15 - Ignored           
    // PMC*   .umask     - 19:16 - Unit Mask            - 0 (event specific. ok for .es=0)
    // PMC4,5 .threshold - 22:20 - Threshold            - 0 (multi-occurence events threshold)
    // PMC4,5 .ig        -    23 - Ignored           
    // PMC6,7 .threshold - 21:20 - Threshold            - 0 (multi-occurence events threshold)
    // PMC6,7 .ig        - 23:22 - Ignored           
    // PMC*   .ism       - 25:24 - Instruction Set Mask - 0 (IA64 & IA32 sets - 11:disables monitoring)
    // PMC*   .ig        - 63:26 - Ignored
    //                                                  -----
    //                                                 PMC_RESET

#define PMC_RESET 0ui64
   
    value = PMC_RESET;
    for ( pmc = 4; pmc < 8; pmc++ ) {
       HalpWritePerfMonCnfgReg( pmc, value );
    }

    HalpResetProcessorDependentPerfMonCnfgRegs( value );

#undef PMC_RESET

    return;

} // HalpResetPerfMonCnfgRegs()

VOID
HalpInitializeProfiling (
    ULONG Number
    )
/*++

Routine Description:

    This routine is called during initialization to initialize profiling
    for each processor in the system.

    Called from HalInitSystem at phase 1 on every processor.

Arguments:

    Number - Supplies the processor number.

Return Value:

    None.

--*/
{

    //
    // If BSP processor, initialize the ProfileTime Interval entries.
    //
    // Assumes HalpITCTicksPer100ns has been initialized.

    if ( Number == 0 )  {
        ULONGLONG interval;
        ULONGLONG count;
        PHALP_PROFILE_MAPPING profile;

        profile = &HalpProfileMapping[ProfileTime]; 

        interval = DEFAULT_PROFILE_INTERVAL;
        count = (ULONGLONG)(interval * HalpITCTicksPer100ns);
        profile->DefInterval = count;

        interval = MAXIMUM_PROFILE_INTERVAL;
        count = (ULONGLONG)(interval * HalpITCTicksPer100ns);
        profile->MaxInterval = count;

        interval = MINIMUM_PROFILE_INTERVAL;
        count = (ULONGLONG)(interval * HalpITCTicksPer100ns);
        profile->MinInterval = count;
    }

    //
    // ToBeDone - checkpoint for default processor.PSR fields for
    //            performance monitoring.
    //

    //
    // Resets the processor performance configuration registers.
    //

    HalpResetPerfMonCnfgRegs();

    //
    // Initialization of the Per processor profiling data.
    //

    HalpProfilingRunning = 0;
    HalpDisactivateProfileSource( HalpProfileSource4 );
    HalpDisactivateProfileSource( HalpProfileSource5 );
    HalpDisactivateProfileSource( HalpProfileSource6 );
    HalpDisactivateProfileSource( HalpProfileSource7 );

    //
    // XXTF 02/08/2000:
    // Different performance vectors are considered:
    //  - Profiling (default) -> PROFILE_VECTOR
    //  - Tracing             -> PERF_VECTOR    [PMUTRACE_VECTOR]
    //
    // Set default Performance vector to Profiling.
    //

    ASSERTMSG( "HAL!HalpInitializeProfiler PROFILE_VECTOR handler != HalpProfileInterrupt\n",
               PCR->InterruptRoutine[PROFILE_VECTOR] == (PKINTERRUPT_ROUTINE)HalpProfileInterrupt );

    HalpWritePerfMonVectorReg( PROFILE_VECTOR );
    
    return;

} // HalpInitializeProfiler()

NTSTATUS
HalpProfileSourceInformation (
    OUT PVOID   Buffer,
    IN  ULONG   BufferLength,
    OUT PULONG  ReturnedLength
    )
/*++

Routine Description:

    Returns the HAL_PROFILE_SOURCE_INFORMATION or 
    HAL_PROFILE_SOURCE_INFORMATION_EX for this processor.

Arguments:

    Buffer - output buffer
    BufferLength - length of buffer on input
    ReturnedLength - The length of data returned

Return Value:

    STATUS_SUCCESS
    STATUS_BUFFER_TOO_SMALL - The ReturnedLength contains the buffersize
        currently needed.

--*/
{
   PHALP_PROFILE_MAPPING    profileMapping;
   NTSTATUS                 status;

   if ( (BufferLength != sizeof(HAL_PROFILE_SOURCE_INFORMATION)) && 
        (BufferLength <  sizeof(HAL_PROFILE_SOURCE_INFORMATION_EX)) )
   {
       status = STATUS_INFO_LENGTH_MISMATCH;
       return status;
   }
         
   profileMapping = HalpGetProfileMapping(((PHAL_PROFILE_SOURCE_INFORMATION)Buffer)->Source);
   //
   // return a different status error if the source is not supported or
   // the source is not a valid 
   //

   if ( profileMapping == NULL )    {
       status = STATUS_INVALID_PARAMETER;
       return status;
   }

   if ( BufferLength == sizeof(HAL_PROFILE_SOURCE_INFORMATION) )    {

        PHAL_PROFILE_SOURCE_INFORMATION    sourceInfo;

        // 
        // HAL_PROFILE_SOURCE_INFORMATION buffer.
        //

        sourceInfo   = (PHAL_PROFILE_SOURCE_INFORMATION)Buffer;
        sourceInfo->Supported = profileMapping->Supported;
        if ( sourceInfo->Supported )    {

            //
            //  For ProfileTime, we convert cycle count back into 100ns clock ticks.
            //

            if ( profileMapping->ProfileSource == ProfileTime  )   {
                sourceInfo->Interval = (ULONG) (profileMapping->Interval / HalpITCTicksPer100ns);
            }
            else  {
                sourceInfo->Interval = (ULONG) profileMapping->Interval;
            }

        }

        if ( ReturnedLength )   {
            *ReturnedLength = sizeof(HAL_PROFILE_SOURCE_INFORMATION);
        }

   }
   else   {

        PHAL_PROFILE_SOURCE_INFORMATION_EX sourceInfoEx;

        // 
        // HAL_PROFILE_SOURCE_INFORMATION_EX buffer.
        //

        sourceInfoEx = (PHAL_PROFILE_SOURCE_INFORMATION_EX)Buffer;
        sourceInfoEx->Supported = profileMapping->Supported;
        if ( sourceInfoEx->Supported )    {

            //
            //  For ProfileTime, we convert cycle count back into 100ns clock ticks.
            //

            if ( profileMapping->ProfileSource == ProfileTime  )   {
                sourceInfoEx->Interval = (ULONG_PTR) (profileMapping->Interval / HalpITCTicksPer100ns);
            }
            else  {
                sourceInfoEx->Interval = (ULONG_PTR) profileMapping->Interval;
            }

            sourceInfoEx->DefInterval = (ULONG_PTR) profileMapping->DefInterval;
            sourceInfoEx->MaxInterval = (ULONG_PTR) profileMapping->MaxInterval;
            sourceInfoEx->MinInterval = (ULONG_PTR) profileMapping->MinInterval;
        }

        if ( ReturnedLength )   {
            *ReturnedLength = sizeof(HAL_PROFILE_SOURCE_INFORMATION_EX);
        }
   }

   return STATUS_SUCCESS;

} // HalpProfileSourceInformation()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\i64perfc.c ===
/*++

Copyright (c) 1995  Intel Corporation

Module Name:

    i64perfc.c copied from  simperfc.c

Abstract:

    This module implements the routines to support performance counters.

Author:

    14-Apr-1995

Environment:

    Kernel mode

Revision History:


--*/

#include "halp.h"
#include "eisa.h"

//
// Define and initialize the 64-bit count of total system cycles used
// as the performance counter.
//

ULONGLONG HalpCycleCount = 0;

BOOLEAN HalpITCCalibrate = TRUE; // XXTF

extern ULONGLONG HalpITCFrequency;

extern ULONGLONG HalpClockCount;

#if 0

VOID
HalpCheckPerformanceCounter(
    VOID
    )

Routine Description:

    This function is called every system clock interrupt in order to
    check for wrap of the performance counter.  The function must handle
    a wrap if it is detected.

    N.B. - This function was from the Alpha HAL.
           This function must be called at CLOCK_LEVEL.

Arguments:

    None.

Return Value:

    None.

{

    return;

} // HalpCheckPerformanceCounter()

#endif // 0


LARGE_INTEGER
KeQueryPerformanceCounter (
    OUT PLARGE_INTEGER PerformanceFrequency OPTIONAL
    )

/*++

Routine Description:

    This routine returns current 64-bit performance counter and,
    optionally, the Performance Frequency.

Arguments:

    PerformanceFrequency - optionally, supplies the address
    of a variable to receive the performance counter frequency.

Return Value:

    Current value of the performance counter will be returned.

--*/

{
    LARGE_INTEGER result;

#ifndef DISABLE_ITC_WORKAROUND
    result.QuadPart = __getReg(CV_IA64_ApITC);
    while ((result.QuadPart & 0xFFFFFFFF) == 0xFFFFFFFF) {
        result.QuadPart = __getReg(CV_IA64_ApITC);
    }
#else
    result.QuadPart = __getReg(CV_IA64_ApITC);
#endif

    if (ARGUMENT_PRESENT(PerformanceFrequency)) {
       PerformanceFrequency->QuadPart = HalpITCFrequency;
    }

    return result;

} // KeQueryPerformanceCounter()



VOID
HalCalibratePerformanceCounter (
    IN LONG volatile *Number,
    IN ULONGLONG NewCount
    )

/*++

Routine Description:

    This routine sets the performance counter value for the current
    processor to the specified valueo.
    The reset is done such that the resulting value is closely
    synchronized with other processors in the configuration.

Arguments:

    Number - Supplies a pointer to count of the number of processors in
    the configuration.

Return Value:

    None.

--*/
{
    KSPIN_LOCK Lock;
    KIRQL      OldIrql;

if ( HalpITCCalibrate )   {

    //
    // Raise IRQL to HIGH_LEVEL, decrement the number of processors, and
    // wait until the number is zero.
    //

    KeInitializeSpinLock(&Lock);
    KeRaiseIrql(HIGH_LEVEL, &OldIrql);

    PCR->HalReserved[CURRENT_ITM_VALUE_INDEX] = NewCount + HalpClockCount;
    HalpWriteITM( PCR->HalReserved[CURRENT_ITM_VALUE_INDEX] );

    if (ExInterlockedDecrementLong((PLONG)Number, &Lock) != RESULT_ZERO) {
        do {
        } while (*((LONG volatile *)Number) !=0);
    }

    //
    // Write the compare register with defined current ITM value,
    // and set the performance counter for the current processor
    // with the passed count.
    //

    HalpWriteITC( NewCount );

    //
    // Restore IRQL to its previous value and return.
    //

    KeLowerIrql(OldIrql);

}
else  {

    *Number = 0;

}

    return;

} // HalCalibratePerformanceCounter()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\i64lock.c ===
/*++

Module Name:

    i64lock.c copied from ixlock.asm

Abstract:

    This module contains the lock routines.

Author:

    Bernard Lint,   M. Jayakumar

Revision History:

    Bernard Lint 6-Jun-1995: IA64 version based on MIPS version.
	Todd Kjos    1-Jun-1998: Added versions of HighLevelLock services.

--*/



#include "halp.h"

ULONG
HalpAcquireHighLevelLock (
    PKSPIN_LOCK Lock
)

/*++ 

Routine Description:

	Turns off interrupts and acquires a spinlock.  Note: Interrupts MUST
	be enabled on entry.

Arguments:

	Lock to acquire

Return Value:

	Previous IRQL

--*/

{
    BOOLEAN Enabled;
    KIRQL   OldLevel;

    ASSERT(sizeof(ULONG) >= sizeof(KIRQL));
    Enabled = HalpDisableInterrupts();
    ASSERT(Enabled);
    KeAcquireSpinLock(Lock,&OldLevel);
    return((ULONG)OldLevel);
}


VOID
HalpReleaseHighLevelLock ( 
    PKSPIN_LOCK Lock,
    ULONG       OldLevel
)
/*++ 

Routine Description:

	Releases a spinlock and turns interrupts back on

Arguments:

	Lock - Lock to release
	OldLevel - Context returned by HalpAcquireHighLevelLock

Return Value:

	None

--*/


/*++

Routine Description:

Arguments:  

Return Value:

--*/

{
    KeReleaseSpinLock(Lock,(KIRQL)OldLevel);
    HalpEnableInterrupts();
}


VOID
HalpSerialize ( )

/*++

Routine Description:

Arguements: 

Return Value:

--*/
{
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\i64pcibus.c ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    i64pcibus.c

Abstract:

    Get/Set bus data routines for the PCI bus

Author:

    Ken Reneris (kenr) 14-June-1994
    Chris Hyser (chrish@fc.hp.com) 1-Feb-98

Environment:

    Kernel mode

Revision History:


--*/

#include "halp.h"
#include "pci.h"
#include "pcip.h"
#include "i64fw.h"

extern WCHAR rgzMultiFunctionAdapter[];
extern WCHAR rgzConfigurationData[];
extern WCHAR rgzIdentifier[];
extern WCHAR rgzPCIIdentifier[];
extern WCHAR rgzPCICardList[];

//
// Prototypes
//
ULONG
HalpGetPCIData(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PCI_SLOT_NUMBER SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG
HalpSetPCIData(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PCI_SLOT_NUMBER SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

NTSTATUS
HalpAssignPCISlotResources(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PUNICODE_STRING          RegistryPath,
    IN PUNICODE_STRING          DriverClassName       OPTIONAL,
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           DeviceObject          OPTIONAL,
    IN ULONG                    SlotNumber,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    );

VOID
HalpInitializePciBus(
    VOID
    );

BOOLEAN
HalpIsValidPCIDevice(
    IN PBUS_HANDLER BusHandler,
    IN PCI_SLOT_NUMBER Slot
    );

BOOLEAN
HalpValidPCISlot(
    IN PBUS_HANDLER BusHandler,
    IN PCI_SLOT_NUMBER Slot
    );


//
// Globals
//
KSPIN_LOCK HalpPCIConfigLock;
BOOLEAN HalpDoingCrashDump = FALSE;

//
// Used to prevent attempts at synchronizing on locks which might have been held
// before the crash.
//
extern BOOLEAN HalpDoingCrashDump;


//
// PCI Configuration Space Accessor types
//
typedef enum {
    PCI_READ,
    PCI_WRITE
} PCI_ACCESS_TYPE;

VOID
HalpPCIConfig(
    IN PBUS_HANDLER BusHandler,
    IN PCI_SLOT_NUMBER Slot,
    IN PUCHAR Buffer,
    IN ULONG Offset,
    IN ULONG Length,
    IN PCI_ACCESS_TYPE Acctype
    );


#if DBG
#if !defined(NO_LEGACY_DRIVERS)
VOID
HalpTestPci(
    ULONG
    );
#endif
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpInitializePciBus)
#pragma alloc_text(INIT,HalpAllocateAndInitPciBusHandler)
#pragma alloc_text(INIT,HalpIsValidPCIDevice)
#pragma alloc_text(PAGE,HalpAssignPCISlotResources)
#endif


ULONG
HalpGetPCIData(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PCI_SLOT_NUMBER Slot,
    IN PUCHAR Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    The function returns the PCI bus data for a specified PCI "slot". This
    function is called on behalf of

Arguments:

    BusHandler - An encapsulation of data and manipulation functions specific to
                 this bus.

    RootHandler - ???

    Slot - A PCI "slot" description (ie bus number, device number and function
           number.)

    Buffer - A pointer to the space to store the data.

    Offset - The byte offset into the configuration space for this PCI "slot".

    Length - Supplies a count in bytes of the maximum amount to return. (ie
             equal or less than the size of the Buffer.)

Return Value:

    Returns the amount of data stored into the buffer.

    If this PCI slot has never been set, then the configuration information
    returned is zeroed.

--*/
{
    PPCI_COMMON_CONFIG  PciData;
    UCHAR               iBuffer[PCI_COMMON_HDR_LENGTH];
    PPCIPBUSDATA        BusData;
    ULONG               Len;
    ULONG               i, bit;

    if (Length > sizeof(PCI_COMMON_CONFIG))
        Length = sizeof(PCI_COMMON_CONFIG);

    Len = 0;
    PciData = (PPCI_COMMON_CONFIG)iBuffer;

    //
    // If the requested offset does not lie in the PCI onfiguration space common
    // header, we will read the vendor ID from the common header to ensure this
    // is a valid device. Note: The common header is from 0 to
    // PCI_COMMON_HEADER_LENGTH inclusive. We know Offset is > 0 because it is
    // unsigned.
    //
    if (Offset >= PCI_COMMON_HDR_LENGTH) {
        //
        // No data was requested from the common header. Verify the PCI device
        // exists, then continue in the device specific area.
        //
        HalpReadPCIConfig(BusHandler, Slot, PciData, 0, sizeof(ULONG));

        if (PciData->VendorID == PCI_INVALID_VENDORID)
            return(0);

    } else {

        //
        // Caller requested at least some data within the common header. Read
        // the whole header, effect the fields we need to and then copy the
        // user's requested bytes from the header
        //
        BusData = (PPCIPBUSDATA)BusHandler->BusData;

        //
        // Read this PCI devices slot data
        //
        Len = PCI_COMMON_HDR_LENGTH;
        HalpReadPCIConfig(BusHandler, Slot, PciData, 0, Len);

        if (PciData->VendorID == PCI_INVALID_VENDORID) {
            PciData->VendorID = PCI_INVALID_VENDORID;
            Len = 2;       // only return invalid id

        } else {
            BusData->CommonData.Pin2Line(BusHandler, RootHandler, Slot, PciData);
        }

        //
        // Copy whatever data overlaps into the callers buffer
        //
        if (Len < Offset)
            return(0);

        Len -= Offset;
        if (Len > Length)
            Len = Length;

        RtlMoveMemory(Buffer, iBuffer + Offset, Len);

        Offset += Len;
        Buffer += Len;
        Length -= Len;
    }

    if (Length) {
        if (Offset >= PCI_COMMON_HDR_LENGTH) {
            //
            // The remaining Buffer comes from the Device Specific
            // area - put on the kitten gloves and read from it.
            //
            // Specific read/writes to the PCI device specific area
            // are guarenteed:
            //
            //    Not to read/write any byte outside the area specified
            //    by the caller.  (this may cause WORD or BYTE references
            //    to the area in order to read the non-dword aligned
            //    ends of the request)
            //
            //    To use a WORD access if the requested length is exactly
            //    a WORD long.
            //
            //    To use a BYTE access if the requested length is exactly
            //    a BYTE long.
            //
            HalpReadPCIConfig(BusHandler, Slot, Buffer, Offset, Length);
            Len += Length;
        }
    }

    return(Len);
}

ULONG
HalpSetPCIData(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PCI_SLOT_NUMBER Slot,
    IN PUCHAR Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    The function sets the PCI bus data for a specified PCI "slot".

Arguments:

    BusHandler - An encapsulation of data and manipulation functions specific to
                 this bus.

    RootHandler - ???

    Slot - A PCI "slot" description (ie bus number, device number and function
           number.)

    Buffer - Supplies the space to store the data.

    Length - Supplies a count in bytes of the maximum amount to return.

Return Value:

    Returns the amount of data stored into the buffer. ???

--*/
{
    PPCI_COMMON_CONFIG  PciData, PciData2;
    UCHAR               iBuffer[PCI_COMMON_HDR_LENGTH];
    UCHAR               iBuffer2[PCI_COMMON_HDR_LENGTH];
    PPCIPBUSDATA        BusData;
    ULONG               Len, cnt;

    if (Length > sizeof(PCI_COMMON_CONFIG))
        Length = sizeof(PCI_COMMON_CONFIG);

    Len = 0;
    PciData = (PPCI_COMMON_CONFIG)iBuffer;
    PciData2 = (PPCI_COMMON_CONFIG)iBuffer2;

    if (Offset >= PCI_COMMON_HDR_LENGTH) {
        //
        // The user did not request any data from the common
        // header.  Verify the PCI device exists, then continue in
        // the device specific area.
        //
        HalpReadPCIConfig(BusHandler, Slot, PciData, 0, sizeof(ULONG));

        if (PciData->VendorID == PCI_INVALID_VENDORID)
            return(0);

    } else {

        //
        // Caller requested to set at least some data within the
        // common header.
        //
        Len = PCI_COMMON_HDR_LENGTH;
        HalpReadPCIConfig(BusHandler, Slot, PciData, 0, Len);

        //
        // return error if no device or header type unknown
        //
        if (PciData->VendorID == PCI_INVALID_VENDORID ||
            PCI_CONFIG_TYPE(PciData) != PCI_DEVICE_TYPE)
            return(0);


        //
        // Set this device as configured
        //
        BusData = (PPCIPBUSDATA)BusHandler->BusData;
#if DBG1
        cnt = PciBitIndex(Slot.u.bits.DeviceNumber, Slot.u.bits.FunctionNumber);
        RtlSetBits(&BusData->DeviceConfigured, cnt, 1);
#endif
        //
        // Copy COMMON_HDR values to buffer2, then overlay callers changes.
        //
        RtlMoveMemory(iBuffer2, iBuffer, Len);
        BusData->CommonData.Pin2Line(BusHandler, RootHandler, Slot, PciData2);

        Len -= Offset;
        if (Len > Length)
            Len = Length;

        RtlMoveMemory(iBuffer2+Offset, Buffer, Len);

        //
        // in case interrupt line or pin was edited
        //
        BusData->CommonData.Line2Pin(BusHandler, RootHandler, Slot, PciData2, PciData);

#if DBG1
        //
        // Verify R/O fields haven't changed
        //
        if (PciData2->VendorID   != PciData->VendorID       ||
            PciData2->DeviceID   != PciData->DeviceID       ||
            PciData2->RevisionID != PciData->RevisionID     ||
            PciData2->ProgIf     != PciData->ProgIf         ||
            PciData2->SubClass   != PciData->SubClass       ||
            PciData2->BaseClass  != PciData->BaseClass      ||
            PciData2->HeaderType != PciData->HeaderType     ||
            PciData2->BaseClass  != PciData->BaseClass      ||
            PciData2->u.type0.MinimumGrant   != PciData->u.type0.MinimumGrant   ||
            PciData2->u.type0.MaximumLatency != PciData->u.type0.MaximumLatency) {
                HalDebugPrint(( HAL_INFO, "HAL: PCI SetBusData - Read-Only configuration value changed\n" ));
        }
#endif
        //
        // Set new PCI configuration
        //
        HalpWritePCIConfig(BusHandler, Slot, iBuffer2+Offset, Offset, Len);

        Offset += Len;
        Buffer += Len;
        Length -= Len;
    }

    if (Length) {
        if (Offset >= PCI_COMMON_HDR_LENGTH) {
            //
            // The remaining Buffer comes from the Device Specific
            // area - put on the kitten gloves and write it
            //
            // Specific read/writes to the PCI device specific area
            // are guarenteed:
            //
            //    Not to read/write any byte outside the area specified
            //    by the caller.  (this may cause WORD or BYTE references
            //    to the area in order to read the non-dword aligned
            //    ends of the request)
            //
            //    To use a WORD access if the requested length is exactly
            //    a WORD long.
            //
            //    To use a BYTE access if the requested length is exactly
            //    a BYTE long.
            //
            HalpWritePCIConfig(BusHandler, Slot, Buffer, Offset, Length);
            Len += Length;
        }
    }

    return(Len);
}


NTSTATUS
HalpAssignPCISlotResources(
    IN PBUS_HANDLER             BusHandler,
    IN PBUS_HANDLER             RootHandler,
    IN PUNICODE_STRING          RegistryPath,
    IN PUNICODE_STRING          DriverClassName       OPTIONAL,
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           DeviceObject          OPTIONAL,
    IN ULONG                    Slot,
    IN OUT PCM_RESOURCE_LIST   *pAllocatedResources
    )
/*++

Routine Description:

    Reads the targeted device to determine it's required resources.
    Calls IoAssignResources to allocate them.
    Sets the targeted device with it's assigned resoruces
    and returns the assignments to the caller.

    Note: This function assumes all of a PCI "slots" resources as indicated by
    it's configuration space are REQUIRED.

Arguments:

Return Value:

    STATUS_SUCCESS or error

--*/
{
    NTSTATUS                        status;
    PUCHAR                          WorkingPool;
    PPCI_COMMON_CONFIG              PciData, PciOrigData, PciData2;
    PCI_SLOT_NUMBER                 PciSlot;
    PPCIPBUSDATA                    BusData;
    PIO_RESOURCE_REQUIREMENTS_LIST  CompleteList;
    PIO_RESOURCE_DESCRIPTOR         Descriptor;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR CmDescriptor;
    ULONG                           BusNumber;
    ULONG                           i, j, m, length, memtype;
    ULONG                           NoBaseAddress, RomIndex, Option;
    PULONG                          BaseAddress[PCI_TYPE0_ADDRESSES + 1];
    PULONG                          OrigAddress[PCI_TYPE0_ADDRESSES + 1];
    BOOLEAN                         Match, EnableRomBase, RequestedInterrupt;


    *pAllocatedResources = NULL;
    PciSlot = *((PPCI_SLOT_NUMBER) &Slot);
    BusNumber = BusHandler->BusNumber;
    BusData = (PPCIPBUSDATA) BusHandler->BusData;

    //
    // Allocate some pool for working space
    //
    i = sizeof(IO_RESOURCE_REQUIREMENTS_LIST) +
        sizeof(IO_RESOURCE_DESCRIPTOR) * (PCI_TYPE0_ADDRESSES + 2) * 2 +
        PCI_COMMON_HDR_LENGTH * 3;

    WorkingPool = (PUCHAR)ExAllocatePool(PagedPool, i);
    if (!WorkingPool)
        return(STATUS_INSUFFICIENT_RESOURCES);

    //
    // Zero initialize pool, and get pointers into memory
    //

    RtlZeroMemory(WorkingPool, i);
    CompleteList = (PIO_RESOURCE_REQUIREMENTS_LIST)WorkingPool;
    PciData     = (PPCI_COMMON_CONFIG) (WorkingPool + i - PCI_COMMON_HDR_LENGTH * 3);
    PciData2    = (PPCI_COMMON_CONFIG) (WorkingPool + i - PCI_COMMON_HDR_LENGTH * 2);
    PciOrigData = (PPCI_COMMON_CONFIG) (WorkingPool + i - PCI_COMMON_HDR_LENGTH * 1);

    //
    // Read the PCI device's configuration
    //
    HalpReadPCIConfig(BusHandler, PciSlot, PciData, 0, PCI_COMMON_HDR_LENGTH);
    if (PciData->VendorID == PCI_INVALID_VENDORID) {
        ExFreePool(WorkingPool);
        return(STATUS_NO_SUCH_DEVICE);
    }

    //
    // For now since there's not PnP support in the OS, if the BIOS hasn't
    // enable a VGA device don't allow it to get enabled via this interface.
    //
    if ((PciData->BaseClass == 0 && PciData->SubClass == 1) ||
        (PciData->BaseClass == 3 && PciData->SubClass == 0)) {

        if ((PciData->Command & (PCI_ENABLE_IO_SPACE | PCI_ENABLE_MEMORY_SPACE)) == 0) {
            ExFreePool (WorkingPool);
            return(STATUS_DEVICE_NOT_CONNECTED);
        }
    }

    //
    // Make a copy of the device's current settings
    //
    RtlMoveMemory(PciOrigData, PciData, PCI_COMMON_HDR_LENGTH);

    //
    // Initialize base addresses base on configuration data type
    //
    switch (PCI_CONFIG_TYPE(PciData)) {
        case 0 :
            NoBaseAddress = PCI_TYPE0_ADDRESSES+1;
            for (j=0; j < PCI_TYPE0_ADDRESSES; j++) {
                BaseAddress[j] = &PciData->u.type0.BaseAddresses[j];
                OrigAddress[j] = &PciOrigData->u.type0.BaseAddresses[j];
            }
            BaseAddress[j] = &PciData->u.type0.ROMBaseAddress;
            OrigAddress[j] = &PciOrigData->u.type0.ROMBaseAddress;
            RomIndex = j;
            break;

        case 1:
            NoBaseAddress = PCI_TYPE1_ADDRESSES+1;
            for (j=0; j < PCI_TYPE1_ADDRESSES; j++) {
                BaseAddress[j] = &PciData->u.type1.BaseAddresses[j];
                OrigAddress[j] = &PciOrigData->u.type1.BaseAddresses[j];
            }
            BaseAddress[j] = &PciData->u.type1.ROMBaseAddress;
            OrigAddress[j] = &PciOrigData->u.type1.ROMBaseAddress;
            RomIndex = j;
            break;

        default:
            ExFreePool (WorkingPool);
            return(STATUS_NO_SUCH_DEVICE);
    }

    //
    // If the BIOS doesn't have the device's ROM enabled, then we won't enable
    // it either.  Remove it from the list.
    //
    EnableRomBase = TRUE;
    if (!(*BaseAddress[RomIndex] & PCI_ROMADDRESS_ENABLED)) {
        ASSERT (RomIndex+1 == NoBaseAddress);
        EnableRomBase = FALSE;
        NoBaseAddress -= 1;
    }

    //
    // Set resources to all bits on to see what type of resources are required.
    //
    for (j=0; j < NoBaseAddress; j++)
        *BaseAddress[j] = 0xFFFFFFFF;

    PciData->Command &= ~(PCI_ENABLE_IO_SPACE | PCI_ENABLE_MEMORY_SPACE);
    *BaseAddress[RomIndex] &= ~PCI_ROMADDRESS_ENABLED;
    HalpWritePCIConfig (BusHandler, PciSlot, PciData, 0, PCI_COMMON_HDR_LENGTH);
    HalpReadPCIConfig  (BusHandler, PciSlot, PciData, 0, PCI_COMMON_HDR_LENGTH);

    //
    // note type0 & type1 overlay ROMBaseAddress, InterruptPin, and InterruptLine
    //
    BusData->CommonData.Pin2Line (BusHandler, RootHandler, PciSlot, PciData);

    //
    // Build an IO_RESOURCE_REQUIREMENTS_LIST for the PCI device
    //
    CompleteList->InterfaceType = PCIBus;
    CompleteList->BusNumber = BusNumber;
    CompleteList->SlotNumber = Slot;
    CompleteList->AlternativeLists = 1;

    CompleteList->List[0].Version = 1;
    CompleteList->List[0].Revision = 1;

    Descriptor = CompleteList->List[0].Descriptors;

    //
    // If PCI device has an interrupt resource, add it
    //
    RequestedInterrupt = FALSE;
    if (PciData->u.type0.InterruptPin  &&
        PciData->u.type0.InterruptLine != (0 ^ IRQXOR)  &&
        PciData->u.type0.InterruptLine != (0xFF ^ IRQXOR)) {

        RequestedInterrupt = TRUE;
        CompleteList->List[0].Count++;

        Descriptor->Option = 0;
        Descriptor->Type   = CmResourceTypeInterrupt;
        Descriptor->ShareDisposition = CmResourceShareShared;
        Descriptor->Flags  = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;

        // Fill in any vector here - we'll pick it back up in
        // HalAdjustResourceList and adjust it to it's allowed settings
        Descriptor->u.Interrupt.MinimumVector = 0;
        Descriptor->u.Interrupt.MaximumVector = 0xff;
        Descriptor++;
    }

    //
    // Add a memory/port resoruce for each PCI resource
    //

    // Clear ROM reserved bits

    *BaseAddress[RomIndex] &= ~0x7FF;

    for (j=0; j < NoBaseAddress; j++) {
        if (*BaseAddress[j]) {
            i = *BaseAddress[j];

            //
            // scan for first set bit, that's the length & alignment
            //
            length = 1 << (i & PCI_ADDRESS_IO_SPACE ? 2 : 4);
            while (!(i & length) && length)
                length <<= 1;

            //
            // scan for last set bit, that's the maxaddress + 1
            //
            for (m = length; i & m; m <<= 1) ;
            m--;

            //
            // check for hosed PCI configuration requirements
            //
            if (length & ~m) {
#if DBG
                HalDebugPrint(( HAL_INFO, "HAL: PCI - defective device! Bus %d, Slot %d, Function %d\n",
                    BusNumber,
                    PciSlot.u.bits.DeviceNumber,
                    PciSlot.u.bits.FunctionNumber
                    ));

                HalDebugPrint(( HAL_INFO, "HAL: PCI - BaseAddress[%d] = %08lx\n", j, i ));
#endif
                //
                // The device is in error - punt.  don't allow this
                // resource any option - it either gets set to whatever
                // bits it was able to return, or it doesn't get set.
                //

                if (i & PCI_ADDRESS_IO_SPACE) {
                    m = i & ~0x3;
                    Descriptor->u.Port.MinimumAddress.LowPart = m;
                } else {
                    m = i & ~0xf;
                    Descriptor->u.Memory.MinimumAddress.LowPart = m;
                }

                m += length;    // max address is min address + length
            }

            //
            // Add requested resource
            //
            Descriptor->Option = 0;
            if (i & PCI_ADDRESS_IO_SPACE) {
                memtype = 0;

                if (!Is64BitBaseAddress(i)  &&
                    PciOrigData->Command & PCI_ENABLE_IO_SPACE) {

                    //
                    // The IO range is/was already enabled at some location, add that
                    // as it's preferred setting.
                    //
                    Descriptor->Type = CmResourceTypePort;
                    Descriptor->ShareDisposition = CmResourceShareDeviceExclusive;
                    Descriptor->Flags = CM_RESOURCE_PORT_IO;
                    Descriptor->Option = IO_RESOURCE_PREFERRED;

                    Descriptor->u.Port.Length = length;
                    Descriptor->u.Port.Alignment = length;
                    Descriptor->u.Port.MinimumAddress.LowPart = *OrigAddress[j] & ~0x3;
                    Descriptor->u.Port.MaximumAddress.LowPart =
                        Descriptor->u.Port.MinimumAddress.LowPart + length - 1;

                    CompleteList->List[0].Count++;
                    Descriptor++;

                    Descriptor->Option = IO_RESOURCE_ALTERNATIVE;
                }

                //
                // Add this IO range
                //
                Descriptor->Type = CmResourceTypePort;
                Descriptor->ShareDisposition = CmResourceShareDeviceExclusive;
                Descriptor->Flags = CM_RESOURCE_PORT_IO;

                Descriptor->u.Port.Length = length;
                Descriptor->u.Port.Alignment = length;
                Descriptor->u.Port.MaximumAddress.LowPart = m;

            } else {

                memtype = i & PCI_ADDRESS_MEMORY_TYPE_MASK;

                Descriptor->Flags  = CM_RESOURCE_MEMORY_READ_WRITE;
                if (j == RomIndex) {
                    // this is a ROM address
                    Descriptor->Flags = CM_RESOURCE_MEMORY_READ_ONLY;
                }

                if (i & PCI_ADDRESS_MEMORY_PREFETCHABLE) {
                    Descriptor->Flags |= CM_RESOURCE_MEMORY_PREFETCHABLE;
                }

                if (!Is64BitBaseAddress(i)  &&
                    (j == RomIndex  ||
                     PciOrigData->Command & PCI_ENABLE_MEMORY_SPACE)) {

                    //
                    // The memory range is/was already enabled at some location, add that
                    // as it's preferred setting.
                    //
                    Descriptor->Type = CmResourceTypeMemory;
                    Descriptor->ShareDisposition = CmResourceShareDeviceExclusive;
                    Descriptor->Option = IO_RESOURCE_PREFERRED;

                    Descriptor->u.Port.Length = length;
                    Descriptor->u.Port.Alignment = length;
                    Descriptor->u.Port.MinimumAddress.LowPart = *OrigAddress[j] & ~0xF;
                    Descriptor->u.Port.MaximumAddress.LowPart =
                        Descriptor->u.Port.MinimumAddress.LowPart + length - 1;

                    CompleteList->List[0].Count++;
                    Descriptor++;

                    Descriptor->Flags = Descriptor[-1].Flags;
                    Descriptor->Option = IO_RESOURCE_ALTERNATIVE;
                }

                //
                // Add this memory range
                //
                Descriptor->Type = CmResourceTypeMemory;
                Descriptor->ShareDisposition = CmResourceShareDeviceExclusive;

                Descriptor->u.Memory.Length = length;
                Descriptor->u.Memory.Alignment = length;
                Descriptor->u.Memory.MaximumAddress.LowPart = m;

                if (memtype == PCI_TYPE_20BIT && m > 0xFFFFF) {
                    // limit to 20 bit address
                    Descriptor->u.Memory.MaximumAddress.LowPart = 0xFFFFF;
                }
            }

            CompleteList->List[0].Count++;
            Descriptor++;


            if (Is64BitBaseAddress(i)) {
                //
                // Eventually we may want to do some work here for 64-bit
                // configs...
                //
                // skip upper half of 64 bit address since this processor
                // only supports 32 bits of address space
                //
                j++;
            }
        }
    }

    CompleteList->ListSize = (ULONG)
            ((PUCHAR) Descriptor - (PUCHAR) CompleteList);

    //
    // Restore the device settings as we found them, enable memory
    // and io decode after setting base addresses.  This is done in
    // case HalAdjustResourceList wants to read the current settings
    // in the device.
    //
    HalpWritePCIConfig (
        BusHandler,
        PciSlot,
        &PciOrigData->Status,
        FIELD_OFFSET (PCI_COMMON_CONFIG, Status),
        PCI_COMMON_HDR_LENGTH - FIELD_OFFSET (PCI_COMMON_CONFIG, Status)
        );

    HalpWritePCIConfig (
        BusHandler,
        PciSlot,
        PciOrigData,
        0,
        FIELD_OFFSET (PCI_COMMON_CONFIG, Status)
        );

    //
    // Have the IO system allocate resource assignments
    //
    status = IoAssignResources (
                RegistryPath,
                DriverClassName,
                DriverObject,
                DeviceObject,
                CompleteList,
                pAllocatedResources
            );

    if (!NT_SUCCESS(status)) {
        goto CleanUp;
    }

    //
    // Slurp the assigments back into the PciData structure and perform them
    //
    CmDescriptor = (*pAllocatedResources)->List[0].PartialResourceList.PartialDescriptors;

    //
    // If PCI device has an interrupt resource then that was passed in as the
    // first requested resource
    //
    if (RequestedInterrupt) {
        PciData->u.type0.InterruptLine = (UCHAR) CmDescriptor->u.Interrupt.Vector;
        BusData->CommonData.Line2Pin (BusHandler, RootHandler, PciSlot, PciData, PciOrigData);
        CmDescriptor++;
    }

    //
    // Pull out resources in the order they were passed to IoAssignResources
    //
    for (j=0; j < NoBaseAddress; j++) {
        i = *BaseAddress[j];
        if (i) {
            if (i & PCI_ADDRESS_IO_SPACE) {
                *BaseAddress[j] = CmDescriptor->u.Port.Start.LowPart;
            } else {
                *BaseAddress[j] = CmDescriptor->u.Memory.Start.LowPart;
            }
            CmDescriptor++;
        }

        if (Is64BitBaseAddress(i)) {
            // skip upper 32 bits
            j++;
        }
    }

    //
    // Turn off decodes, then set new addresses
    //
    HalpWritePCIConfig (BusHandler, PciSlot, PciData, 0, PCI_COMMON_HDR_LENGTH);

    //
    // Read configuration back and verify address settings took
    //
    HalpReadPCIConfig(BusHandler, PciSlot, PciData2, 0, PCI_COMMON_HDR_LENGTH);

    Match = TRUE;
    if (PciData->u.type0.InterruptLine  != PciData2->u.type0.InterruptLine ||
        PciData->u.type0.InterruptPin   != PciData2->u.type0.InterruptPin  ||
        PciData->u.type0.ROMBaseAddress != PciData2->u.type0.ROMBaseAddress) {
            Match = FALSE;
    }

    for (j=0; j < NoBaseAddress; j++) {
        if (*BaseAddress[j]) {
            if (*BaseAddress[j] & PCI_ADDRESS_IO_SPACE) {
                i = (ULONG) ~0x3;
            } else {
                i = (ULONG) ~0xF;
            }

            if (( (*BaseAddress[j]) & i) !=
                 (*((PULONG) ((PUCHAR) BaseAddress[j] -
                             (PUCHAR) PciData +
                             (PUCHAR) PciData2)) & i)) {

                    Match = FALSE;
            }

            if (Is64BitBaseAddress(*BaseAddress[j])) {
                //
                // Eventually we may want to do something with the upper
                // 32 bits
                //
                j++;
            }
        }
    }

    if (!Match) {
        HalDebugPrint(( HAL_INFO, "HAL: PCI - defective device! Bus %d, Slot %d, Function %d\n",
            BusNumber,
            PciSlot.u.bits.DeviceNumber,
            PciSlot.u.bits.FunctionNumber
            ));
        status = STATUS_DEVICE_PROTOCOL_ERROR;
        goto CleanUp;
    }

    //
    // Settings took - turn on the appropiate decodes
    //
    if (EnableRomBase  &&  *BaseAddress[RomIndex]) {

        //
        // A rom address was allocated and should be enabled
        //
        *BaseAddress[RomIndex] |= PCI_ROMADDRESS_ENABLED;
        HalpWritePCIConfig(
            BusHandler,
            PciSlot,
            BaseAddress[RomIndex],
            (ULONG) ((PUCHAR) BaseAddress[RomIndex] - (PUCHAR) PciData),
            sizeof (ULONG)
            );
    }

    //
    // Enable IO, Memory, and BUS_MASTER decodes
    // (use HalSetBusData since valid settings now set)
    //
    PciData->Command |= PCI_ENABLE_IO_SPACE |
                        PCI_ENABLE_MEMORY_SPACE |
                        PCI_ENABLE_BUS_MASTER;

    HalSetBusDataByOffset(
        PCIConfiguration,
        BusHandler->BusNumber,
        PciSlot.u.AsULONG,
        &PciData->Command,
        FIELD_OFFSET (PCI_COMMON_CONFIG, Command),
        sizeof (PciData->Command)
        );

CleanUp:
    if (!NT_SUCCESS(status)) {

        //
        // Failure, if there are any allocated resources free them
        //
        if (*pAllocatedResources) {
            IoAssignResources(
                RegistryPath,
                DriverClassName,
                DriverObject,
                DeviceObject,
                NULL,
                NULL
                );

            ExFreePool(*pAllocatedResources);
            *pAllocatedResources = NULL;
        }

        //
        // Restore the device settings as we found them, enable memory
        // and io decode after setting base addresses
        //
        HalpWritePCIConfig(
            BusHandler,
            PciSlot,
            &PciOrigData->Status,
            FIELD_OFFSET(PCI_COMMON_CONFIG, Status),
            PCI_COMMON_HDR_LENGTH - FIELD_OFFSET (PCI_COMMON_CONFIG, Status)
            );

        HalpWritePCIConfig(
            BusHandler,
            PciSlot,
            PciOrigData,
            0,
            FIELD_OFFSET(PCI_COMMON_CONFIG, Status)
            );
    }

    ExFreePool(WorkingPool);
    return(status);
}

BOOLEAN
HalpValidPCISlot(
    IN PBUS_HANDLER BusHandler,
    IN PCI_SLOT_NUMBER Slot
    )
/*++

Routine Description:

    The function validates the information specifying a PCI "slot".

Arguments:

    BusHandler - An encapsulation of data and manipulation functions specific to
                 this bus.

    Slot - A PCI "slot" description (ie bus number, device number and function
           number.)

Return Value:

    Returns TRUE if "slot" valid, otherwise FALSE.

--*/

{
    PCI_SLOT_NUMBER                 Slot2;
    PPCIPBUSDATA                    BusData;
    UCHAR                           HeaderType;
    ULONG                           i;

    BusData = (PPCIPBUSDATA)BusHandler->BusData;

    if (Slot.u.bits.Reserved != 0)
        return(FALSE);

    if (Slot.u.bits.DeviceNumber >= BusData->MaxDevice)
        return(FALSE);

    if (Slot.u.bits.FunctionNumber == 0)
        return(TRUE);

    //
    // Read DeviceNumber, Function zero, to determine if the
    // PCI supports multifunction devices
    //
    Slot.u.bits.FunctionNumber = 0;

    HalpPCIConfig(
        BusHandler,
        Slot,
        &HeaderType,
        FIELD_OFFSET(PCI_COMMON_CONFIG, HeaderType),
        sizeof(UCHAR),
        PCI_READ
        );

    //
    // FALSE if this device doesn't exist or doesn't support MULTIFUNCTION types
    //
    if (!(HeaderType & PCI_MULTIFUNCTION) || HeaderType == 0xFF)
        return(FALSE);

    return(TRUE);
}

//
// This table is used to determine correct access size to PCI configuration
// space given (offset % 4) and (length % 4).
//
// usage: PCIDeref[offset%4][length%4];
//
// Key:
//     4 - implies a ULONG access and is the number of bytes returned
//     1 - implies a UCHAR access and is the number of bytes returned
//     2 - implies a USHORT access and is the number of bytes returned
//
UCHAR PCIDeref[4][4] = {{4,1,2,2}, {1,1,1,1}, {2,1,2,2}, {1,1,1,1}};
#define SIZEOF_PARTIAL_INFO_HEADER FIELD_OFFSET(KEY_VALUE_PARTIAL_INFORMATION, Data)

VOID
HalpPCIConfig(
    IN PBUS_HANDLER     BusHandler,
    IN PCI_SLOT_NUMBER  Slot,
    IN OUT PUCHAR       Buffer,
    IN ULONG            Offset,
    IN ULONG            Length,
    IN PCI_ACCESS_TYPE  AccType
    )
{
    KIRQL Irql;
    ULONG Size;
    ULONG SALFunc;
    ULONG CfgAddr;
    ULONG WriteVal;
    SAL_PAL_RETURN_VALUES RetVals;
    SAL_STATUS Stat;

    //
    // Generate a PCI configuration address
    //
    CfgAddr = (BusHandler->BusNumber      << 16) |
              (Slot.u.bits.DeviceNumber   << 11) |
              (Slot.u.bits.FunctionNumber << 8);

    //
    // As an optimization we could have a separate spinlock for each
    // host adapter
    
    // SAL should do whatever locking required.
    
    //
    if (!HalpDoingCrashDump) {
        Irql = KeAcquireSpinLockRaiseToSynch(&HalpPCIConfigLock);
    }

    while (Length) {
        Size = PCIDeref[Offset % sizeof(ULONG)][Length % sizeof(ULONG)];

        //
        // Set up input parameters
        //
        if (AccType == PCI_READ) {
            SALFunc = SAL_PCI_CONFIG_READ;
            WriteVal = 0;
        } else {
            switch (Size) {
                case 4: WriteVal = *((PULONG)Buffer); break;
                case 2: WriteVal = *((PUSHORT)Buffer); break;
                case 1: WriteVal = *Buffer; break;
            }
            SALFunc = SAL_PCI_CONFIG_WRITE;
        }

        //
        // Make SAL call
        //
        Stat = HalpSalCall(SALFunc, CfgAddr | Offset, Size, WriteVal, 0, 0, 0, 0, &RetVals);

        //
        // Retrieve SAL return data
        //
        if (AccType == PCI_READ) {
            switch (Size) {
                case 4: *((PULONG)Buffer) = (ULONG)RetVals.ReturnValues[1]; break;
                case 2: *((PUSHORT)Buffer) = (USHORT)RetVals.ReturnValues[1]; break;
                case 1: *Buffer = (UCHAR)RetVals.ReturnValues[1]; break;
            }
        }

        Offset += Size;
        Buffer += Size;
        Length -= Size;
    }

    //
    // Release spinlock
    //
    if (!HalpDoingCrashDump) {
        KeReleaseSpinLock(&HalpPCIConfigLock, Irql);
    }
}


VOID
HalpReadPCIConfig(
    IN PBUS_HANDLER BusHandler,
    IN PCI_SLOT_NUMBER Slot,
    OUT PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
{
    //
    // If request for an invalid slot, fill return buffer with -1
    //
    if (!HalpValidPCISlot(BusHandler, Slot)) {
        RtlFillMemory(Buffer, Length, (UCHAR)-1);
        return;
    }

    HalpPCIConfig(BusHandler, Slot, Buffer, Offset, Length, PCI_READ);
}

VOID
HalpWritePCIConfig(
    IN PBUS_HANDLER BusHandler,
    IN PCI_SLOT_NUMBER Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
{
    //
    // If request for an invalid slot, do nothing
    //
    if (!HalpValidPCISlot(BusHandler, Slot))
        return;

    HalpPCIConfig(BusHandler, Slot, Buffer, Offset, Length, PCI_WRITE);
}


BOOLEAN
HalpIsValidPCIDevice(
    IN PBUS_HANDLER BusHandler,
    IN PCI_SLOT_NUMBER Slot
    )
/*++

Routine Description:

    Reads the device configuration data for the given slot and
    returns TRUE if the configuration data appears to be valid for
    a PCI device; otherwise returns FALSE.

Arguments:

    BusHandler  - Bus to check
    Slot        - Slot to check

--*/

{
    PPCI_COMMON_CONFIG  PciData;
    UCHAR               iBuffer[PCI_COMMON_HDR_LENGTH];
    ULONG               i, j;

    PciData = (PPCI_COMMON_CONFIG)iBuffer;

    //
    // Read device common header.
    //
    HalpReadPCIConfig(BusHandler, Slot, PciData, 0, PCI_COMMON_HDR_LENGTH);

    //
    // Valid device header?
    //
    if (PciData->VendorID == PCI_INVALID_VENDORID  ||
        PCI_CONFIG_TYPE(PciData) != PCI_DEVICE_TYPE) {
        return(FALSE);
    }

    //
    // Check fields for reasonable values.
    //

    //
    // Do these values make sense for IA64
    //
    if ((PciData->u.type0.InterruptPin && PciData->u.type0.InterruptPin > 4) ||
        (PciData->u.type0.InterruptLine & 0x70)) {
        return(FALSE);
    }

    for (i=0; i < PCI_TYPE0_ADDRESSES; i++) {
        j = PciData->u.type0.BaseAddresses[i];

        if (j & PCI_ADDRESS_IO_SPACE) {
            if (j > 0xffff) {
                // IO port > 64k?
                return(FALSE);
            }
        } else {
            if (j > 0xf  &&  j < 0x80000) {
                // Mem address < 0x8000h?
                return(FALSE);
            }
        }

        if (Is64BitBaseAddress(j))
            i++;
    }

    //
    // Guess it's a valid device..
    //
    return(TRUE);
}

#if !defined(NO_LEGACY_DRIVERS)

#if DBG
VOID
HalpTestPci (ULONG flag2)
{
    PCI_SLOT_NUMBER     SlotNumber;
    PCI_COMMON_CONFIG   PciData, OrigData;
    ULONG               i, f, j, k, bus;
    BOOLEAN             flag;


    if (!flag2) {
        return ;
    }

    DbgBreakPoint ();
    SlotNumber.u.bits.Reserved = 0;

    //
    // Read every possible PCI Device/Function and display it's
    // default info.
    //
    // (note this destories it's current settings)
    //

    flag = TRUE;
    for (bus = 0; flag; bus++) {

        for (i = 0; i < PCI_MAX_DEVICES; i++) {
            SlotNumber.u.bits.DeviceNumber = i;

            for (f = 0; f < PCI_MAX_FUNCTION; f++) {
                SlotNumber.u.bits.FunctionNumber = f;

                //
                // Note: This is reading the DeviceSpecific area of
                // the device's configuration - normally this should
                // only be done on device for which the caller understands.
                // I'm doing it here only for debugging.
                //

                j = HalGetBusData (
                    PCIConfiguration,
                    bus,
                    SlotNumber.u.AsULONG,
                    &PciData,
                    sizeof (PciData)
                    );

                if (j == 0) {
                    // out of buses
                    flag = FALSE;
                    break;
                }

                if (j < PCI_COMMON_HDR_LENGTH) {
                    continue;
                }

                HalSetBusData (
                    PCIConfiguration,
                    bus,
                    SlotNumber.u.AsULONG,
                    &PciData,
                    1
                    );

                HalGetBusData (
                    PCIConfiguration,
                    bus,
                    SlotNumber.u.AsULONG,
                    &PciData,
                    sizeof (PciData)
                    );

                HalDebugPrint(( HAL_INFO, "HAL: PCI Bus %d Slot %2d %2d  ID:%04lx-%04lx  Rev:%04lx",
                    bus, i, f, PciData.VendorID, PciData.DeviceID,
                    PciData.RevisionID ));


                if (PciData.u.type0.InterruptPin) {
                    HalDebugPrint(( HAL_INFO, "  IntPin:%x", PciData.u.type0.InterruptPin ));
                }

                if (PciData.u.type0.InterruptLine) {
                    HalDebugPrint(( HAL_INFO, "  IntLine:%x", PciData.u.type0.InterruptLine ));
                }

                if (PciData.u.type0.ROMBaseAddress) {
                        HalDebugPrint(( HAL_INFO, "  ROM:%08lx", PciData.u.type0.ROMBaseAddress ));
                }

                HalDebugPrint(( HAL_INFO, "\nHAL:    Cmd:%04x  Status:%04x  ProgIf:%04x  SubClass:%04x  BaseClass:%04lx\n",
                    PciData.Command, PciData.Status, PciData.ProgIf,
                     PciData.SubClass, PciData.BaseClass ));

                k = 0;
                for (j=0; j < PCI_TYPE0_ADDRESSES; j++) {
                    if (PciData.u.type0.BaseAddresses[j]) {
                        HalDebugPrint(( HAL_INFO, "  Ad%d:%08lx", j, PciData.u.type0.BaseAddresses[j] ));
                        k = 1;
                    }
                }

                if (k) {
                    HalDebugPrint(( HAL_INFO, "\n" ));
                }

                if (PciData.VendorID == 0x8086) {
                    // dump complete buffer
                    HalDebugPrint(( HAL_INFO, "HAL: Command %x, Status %x, BIST %x\n",
                        PciData.Command, PciData.Status,
                        PciData.BIST
                        ));

                    HalDebugPrint(( HAL_INFO, "HAL: CacheLineSz %x, LatencyTimer %x",
                        PciData.CacheLineSize, PciData.LatencyTimer
                        ));

                    for (j=0; j < 192; j++) {
                        if ((j & 0xf) == 0) {
                            HalDebugPrint(( HAL_INFO, "\n%02x: ", j + 0x40 ));
                        }
                        HalDebugPrint(( HAL_INFO, "%02x ", PciData.DeviceSpecific[j] ));
                    }
                    HalDebugPrint(( HAL_INFO, "\n" ));
                }

                //
                // Next
                //

                if (k) {
                    HalDebugPrint(( HAL_INFO, "\n\n" ));
                }
            }
        }
    }
    DbgBreakPoint ();
}

#endif

#endif // NO_LEGACY_DRIVERS

//------------------------------------------------------------------------------

PPCI_REGISTRY_INFO_INTERNAL
HalpQueryPciRegistryInfo (
    VOID
    )
/*++

Routine Description:

    Reads information from the registry concerning PCI, including the number
    of buses and the hardware access mechanism.

Arguments:

    None.

Returns:

    Buffer that must be freed by the caller, NULL if insufficient memory exists
    to complete the request, or the information cannot be located.

--*/
{
    PPCI_REGISTRY_INFO_INTERNAL     PCIRegInfo = NULL;
    PPCI_REGISTRY_INFO              PCIRegInfoHeader = NULL;
    UNICODE_STRING                  unicodeString, ConfigName, IdentName;
    HANDLE                          hMFunc, hBus, hCardList;
    OBJECT_ATTRIBUTES               objectAttributes;
    NTSTATUS                        status;
    static UCHAR                    buffer [sizeof(PPCI_REGISTRY_INFO) + 99];
    PWSTR                           p;
    WCHAR                           wstr[8];
    ULONG                           i, junk;
    ULONG                           cardListIndex, cardCount, cardMax;
    PKEY_VALUE_FULL_INFORMATION     ValueInfo;
    PCM_FULL_RESOURCE_DESCRIPTOR    Desc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR PDesc;
    UCHAR                           partialInfo[SIZEOF_PARTIAL_INFO_HEADER +
                                                sizeof(PCI_CARD_DESCRIPTOR)];
    PKEY_VALUE_PARTIAL_INFORMATION  partialInfoHeader;
    KEY_FULL_INFORMATION            keyFullInfo;

    //
    // Search the hardware description looking for any reported
    // PCI bus.  The first ARC entry for a PCI bus will contain
    // the PCI_REGISTRY_INFO.

    RtlInitUnicodeString (&unicodeString, rgzMultiFunctionAdapter);
    InitializeObjectAttributes (
        &objectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,       // handle
        NULL);


    status = ZwOpenKey (&hMFunc, KEY_READ, &objectAttributes);
    if (!NT_SUCCESS(status)) {
        return NULL;
    }

    unicodeString.Buffer = wstr;
    unicodeString.MaximumLength = sizeof (wstr);

    RtlInitUnicodeString (&ConfigName, rgzConfigurationData);
    RtlInitUnicodeString (&IdentName,  rgzIdentifier);

    ValueInfo = (PKEY_VALUE_FULL_INFORMATION) buffer;

    for (i=0; TRUE; i++) {
        RtlIntegerToUnicodeString (i, 10, &unicodeString);
        InitializeObjectAttributes (
            &objectAttributes,
            &unicodeString,
            OBJ_CASE_INSENSITIVE,
            hMFunc,
            NULL);

        status = ZwOpenKey (&hBus, KEY_READ, &objectAttributes);
        if (!NT_SUCCESS(status)) {
            //
            // Out of Multifunction adapter entries...
            //

            ZwClose (hMFunc);
            return NULL;
        }

        //
        // Check the Identifier to see if this is a PCI entry
        //

        status = ZwQueryValueKey (
                    hBus,
                    &IdentName,
                    KeyValueFullInformation,
                    ValueInfo,
                    sizeof (buffer),
                    &junk
                    );

        if (!NT_SUCCESS (status)) {
            ZwClose (hBus);
            continue;
        }

        p = (PWSTR) ((PUCHAR) ValueInfo + ValueInfo->DataOffset);
        if (p[0] != L'P' || p[1] != L'C' || p[2] != L'I' || p[3] != 0) {
            ZwClose (hBus);
            continue;
        }

        //
        // The first PCI entry has the PCI_REGISTRY_INFO structure
        // attached to it.
        //

        status = ZwQueryValueKey (
                    hBus,
                    &ConfigName,
                    KeyValueFullInformation,
                    ValueInfo,
                    sizeof (buffer),
                    &junk
                    );

        ZwClose (hBus);
        if (!NT_SUCCESS(status)) {
            continue ;
        }

        Desc  = (PCM_FULL_RESOURCE_DESCRIPTOR) ((PUCHAR)
                      ValueInfo + ValueInfo->DataOffset);
        PDesc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) ((PUCHAR)
                      Desc->PartialResourceList.PartialDescriptors);

        if (PDesc->Type == CmResourceTypeDeviceSpecific) {

            // got it..
            PCIRegInfoHeader = (PPCI_REGISTRY_INFO) (PDesc+1);
            break;
        }
    }

    if (!PCIRegInfoHeader) {

        return NULL;
    }

    //
    // Retrieve the list of interesting cards.
    //

    RtlInitUnicodeString (&unicodeString, rgzPCICardList);
    InitializeObjectAttributes (
        &objectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,       // handle
        NULL
        );

    status = ZwOpenKey (&hCardList, KEY_READ, &objectAttributes);
    if (NT_SUCCESS(status)) {

        status = ZwQueryKey( hCardList,
                             KeyFullInformation,
                             &keyFullInfo,
                             sizeof(keyFullInfo),
                             &junk );

        if ( NT_SUCCESS(status) ) {

            cardMax = keyFullInfo.Values;

            PCIRegInfo = (PPCI_REGISTRY_INFO_INTERNAL) ExAllocatePoolWithTag(
                NonPagedPool,
                sizeof(PCI_REGISTRY_INFO_INTERNAL) +
                cardMax * sizeof(PCI_CARD_DESCRIPTOR),
                HAL_POOL_TAG
                );

            if (PCIRegInfo) {

                //
                // Now that we've allocated enough room, enumerate again.
                //
                partialInfoHeader = (PKEY_VALUE_PARTIAL_INFORMATION) partialInfo;

                for(cardListIndex = cardCount = 0;
                    cardListIndex < cardMax;
                    cardListIndex++) {

                    status = ZwEnumerateValueKey(
                        hCardList,
                        cardListIndex,
                        KeyValuePartialInformation,
                        partialInfo,
                        sizeof(partialInfo),
                        &junk
                        );

                    //
                    // Note that STATUS_NO_MORE_ENTRIES is a failure code
                    //
                    if (!NT_SUCCESS( status )) {
                        break;
                    }

                    if (partialInfoHeader->DataLength != sizeof(PCI_CARD_DESCRIPTOR)) {

                        continue;
                    }

                    RtlCopyMemory(
                        PCIRegInfo->CardList + cardCount,
                        partialInfoHeader->Data,
                        sizeof(PCI_CARD_DESCRIPTOR)
                        );

                    cardCount++;
                } // next cardListIndex
            }

        }
        ZwClose (hCardList);
    }

    if (!PCIRegInfo) {

        PCIRegInfo = (PPCI_REGISTRY_INFO_INTERNAL) ExAllocatePoolWithTag(
            NonPagedPool,
            sizeof(PCI_REGISTRY_INFO_INTERNAL),
            HAL_POOL_TAG
            );

        if (!PCIRegInfo) {

            return NULL;
        }

        cardCount = 0;
    }

    RtlCopyMemory(
        PCIRegInfo,
        PCIRegInfoHeader,
        sizeof(PCI_REGISTRY_INFO)
        );

    PCIRegInfo->ElementCount = cardCount;

    return PCIRegInfo;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\i64prfls.s ===
//++
// TITLE ("Performance Monitor Control & Data Register Accesses")
//
//
//
// Copyright (c) 1995  Intel Corporation
//
// Module Name:
//
//    i64prfls.s 
//
// Abstract:
//
//    This module implements Profiling.
//
// Author:
//
//    Bernard Lint, M. Jayakumar 1 Sep '99
//
// Environment:
//
//    Kernel mode
//
// Revision History:
//
//--

#include "ksia64.h"

        .file "i64prfls.s"


//
// The following functions are defined until the compiler supports 
// the intrinsics __setReg() and __getReg() for the CV_IA64_PFCx, 
// CV_IA64_PFDx and CV_IA64_SaPMV registers.
// Anyway, these functions might stay for a while, the compiler
// having no consideration for micro-architecture specific 
// number of PMCs/PMDs.
//

        LEAF_ENTRY(HalpReadPerfMonVectorReg)
        LEAF_SETUP(0,0,0,0)
        mov         v0 = cr.pmv
        ;;
        LEAF_RETURN
        LEAF_EXIT(HalpReadPerfMonVectorReg)

        LEAF_ENTRY(HalpWritePerfMonVectorReg)
        LEAF_SETUP(1,0,0,0)
        mov         cr.pmv = a0
        ;;
        LEAF_RETURN
        LEAF_EXIT(HalpWritePerfMonVectorReg)

        LEAF_ENTRY(HalpWritePerfMonCnfgReg)
        LEAF_SETUP(2,0,0,0)
        rPMC        = t15
        mov         rPMC = a0
        ;;
        mov         pmc[rPMC] = a1 
        ;;
        LEAF_RETURN
        LEAF_EXIT(HalpWritePerfMonCnfgReg)

        LEAF_ENTRY(HalpReadPerfMonCnfgReg)
        LEAF_SETUP(1,0,0,0)
        rPMC        = t15
        mov         rPMC = a0
        ;;
        mov         v0 = pmc[rPMC]  
        ;;
        LEAF_RETURN
        LEAF_EXIT(HalpReadPerfMonCnfgReg)

        LEAF_ENTRY(HalpWritePerfMonDataReg)
        LEAF_SETUP(2,0,0,0)
        rPMD    = t15
        mov     rPMD = a0
        ;;
        mov     pmd[rPMD] = a1
        ;;
        LEAF_RETURN
        LEAF_EXIT(HalpWritePerfMonDataReg)

        LEAF_ENTRY(HalpReadPerfMonDataReg)
        LEAF_SETUP(1,0,0,0)
        rPMD        = t15
        mov         rPMD = a0
        ;;
        mov         v0 = pmd[rPMD] 
        ;;
        LEAF_RETURN
        LEAF_EXIT(HalpReadPerfMonDataReg)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\i64sapic.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    i64sapic.c

Abstract:

    Implements I/O Sapic functionality

Author:

    Todd Kjos (HP) (v-tkjos) 1-Jun-1998

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "iosapic.h"

#include <ntacpi.h>

VOID
IoSapicMaskEntry(
    PIO_INTR_CONTROL IoUnit,
    ULONG RteNumber
    );

VOID
IoSapicSetEntry(
    PIO_INTR_CONTROL IoUnit,
    ULONG RteNumber
    );

VOID
IoSapicEnableEntry(
    PIO_INTR_CONTROL IoUnit,
    ULONG RteNumber
    );

VOID
IoSapicAssignCpu(
    PIO_INTR_CONTROL IoUnit,
    ULONG RteNumber
    );

VOID
IoSapicGetAffinityMask(
    PIO_INTR_CONTROL IoUnit,
    ULONG RteNumber
    );

//
// Method structure for control of IO Sapic Hardware
//
INTR_METHODS HalpIoSapicMethods = {
    IoSapicMaskEntry,
    IoSapicSetEntry,
    IoSapicEnableEntry
};

VOID
HalpInti2InterruptController (
    IN  ULONG   InterruptInput,
    OUT PIO_INTR_CONTROL *InterruptController,
    OUT PULONG  ControllerInti
    )
/*++

Routine Description:

    Convert InterruptInput to an interrupt controller
    structure and input number

Arguments:

   InterruptInput -  System Global Interrupt Input

   InterruptController - Pointer to Interupt controller structure

   ControllerInti - Redirection Table Entry on this interrupt controller

Return Value:

--*/
{
    PIO_INTR_CONTROL IoUnit;

    for (IoUnit=HalpIoSapicList; IoUnit; IoUnit=IoUnit->flink) {
        if (InterruptInput <= IoUnit->IntiMax) {
            break;
        }
    }

    *InterruptController   = IoUnit;
    if (IoUnit)
        *ControllerInti = InterruptInput-IoUnit->IntiBase;
}


BOOLEAN
HalpGetSapicInterruptDesc (
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN ULONG BusInterruptLevel,
    OUT PULONG Inti,
    OUT PKAFFINITY InterruptAffinity
    )
/*++

Routine Description:

    This procedure gets a "Inti" describing the requested interrupt

Arguments:

    BusType - The Bus type as known to the IO subsystem

    BusNumber - The number of the Bus we care for

    BusInterruptLevel - IRQ on the Bus


Return Value:

    TRUE if AcpiInti found; otherwise FALSE.

    Inti - Global system interrupt input

--*/
{
    PIO_INTR_CONTROL  IoUnit;
    ULONG  RteNumber;

    HalpInti2InterruptController (
        BusInterruptLevel,&IoUnit,&RteNumber
        );

    // Make sure Inti is not out of range
    if (IoUnit == NULL)
        return FALSE;

    // It's in range, just give back the same value as was passed in
    *Inti = BusInterruptLevel;

    //
    // The Interrupt affinity is the intersection of the global affinity mask
    // (HalpDefaultInterruptAffinity) and any additional restrictions due to the
    // location of the Io Sapic (IoUnit->InterruptAffinity).
    //
    *InterruptAffinity = IoUnit->InterruptAffinity & HalpDefaultInterruptAffinity;
    return(TRUE);
}

ULONG
HalpINTItoVector(
    ULONG   Inti
)
    // Returns the Vector associated with this global interrupt input
    // Vector is node and IDT entry
{
    PIO_INTR_CONTROL  IoUnit;
    ULONG  RteNumber;

    HalpInti2InterruptController (
        Inti,&IoUnit,&RteNumber
        );

    ASSERT(IoUnit);

    return (IoUnit->Inti[RteNumber].GlobalVector);
}

VOID
HalpSetINTItoVector(
    ULONG   Inti,
    ULONG   Vector
)
    // Sets the vector for this global interrupt input
    // Vector is node and IDT entry
{
    PIO_INTR_CONTROL  IoUnit;
    ULONG  RteNumber;

    HalpInti2InterruptController (
        Inti,&IoUnit,&RteNumber
        );

    ASSERT(IoUnit);

    // .Vector (IDTEntry) is set in SetRedirEntry
    IoUnit->Inti[RteNumber].GlobalVector =  Vector;
}

VOID
HalpSetRedirEntry (
    IN ULONG InterruptInput,
    IN ULONG Entry,
    IN USHORT ThisCpuApicID
    )
/*++

Routine Description:

    This procedure sets a IO Unit Redirection Table Entry

    Must be called with the HalpAccountingLock held

Arguments:

Return Value:

    None.

--*/
{
    PIO_INTR_CONTROL  IoUnit;
    ULONG  RteNumber;

    HalpInti2InterruptController (
        InterruptInput,&IoUnit,&RteNumber
        );

    ASSERT(IoUnit);
    ASSERT(IoUnit->Inti[RteNumber].GlobalVector);
    ASSERT((UCHAR)(IoUnit->Inti[RteNumber].GlobalVector) == (UCHAR)Entry);

    IoUnit->Inti[RteNumber].Vector = Entry;
    IoUnit->Inti[RteNumber].Destination = ThisCpuApicID << 16;

    IoUnit->IntrMethods->SetEntry(IoUnit, RteNumber);
}

VOID
HalpWriteRedirEntry (
    IN ULONG  GlobalInterrupt,
    IN UCHAR  SapicVector,
    IN USHORT DestinationCPU,
    IN ULONG  Flags,
    IN ULONG  InterruptType
    )
{
    ULONG rteNumber;
    PIO_INTR_CONTROL ioUnit;

    HalpInti2InterruptController( GlobalInterrupt, &ioUnit, &rteNumber );

    ASSERT(ioUnit);

    ioUnit->Inti[rteNumber].Vector = SapicVector;

    //
    // Set the delivery mode
    //

    switch (InterruptType) {
        case PLATFORM_INT_PMI:
                ioUnit->Inti[rteNumber].Vector &= ~INT_TYPE_MASK;   // first clear the field
                ioUnit->Inti[rteNumber].Vector |= DELIVER_SMI;
                break;
        case PLATFORM_INT_CPE:
                ioUnit->Inti[rteNumber].Vector &= ~INT_TYPE_MASK;   // first clear the field
                ioUnit->Inti[rteNumber].Vector |= DELIVER_LOW_PRIORITY;
                break;
        case PLATFORM_INT_INIT:
                ioUnit->Inti[rteNumber].Vector &= ~INT_TYPE_MASK;   // first clear the field
                ioUnit->Inti[rteNumber].Vector |= DELIVER_INIT;
                break;
    }

    //
    // So we honor the flags passed into this function.
    //

    if (IS_LEVEL_TRIGGERED_MPS(Flags)) {
        ioUnit->Inti[rteNumber].Vector |= LEVEL_TRIGGERED;
    } else {
        ioUnit->Inti[rteNumber].Vector &= ~LEVEL_TRIGGERED;
    }

    if (IS_ACTIVE_LOW_MPS(Flags)) {
        ioUnit->Inti[rteNumber].Vector |= ACTIVE_LOW;
    } else {
        ioUnit->Inti[rteNumber].Vector &= ~ACTIVE_LOW;
    }

    ioUnit->Inti[rteNumber].Destination = DestinationCPU<<16;

    ioUnit->IntrMethods->SetEntry(ioUnit, rteNumber);

    return;

} // HalpWriteRedirEntry()

VOID
HalpGetRedirEntry (
    IN ULONG  InterruptInput,
    IN PULONG Entry,
    IN PULONG Destination
    )
/*++

Routine Description:


Arguments:


Return Value:

    None.

--*/
{
    PIO_INTR_CONTROL  IoUnit;
    ULONG  RteNumber;

    HalpInti2InterruptController (
        InterruptInput,&IoUnit,&RteNumber
        );

    ASSERT(IoUnit);

    *Entry = IoUnit->Inti[RteNumber].Vector;
    *Destination = IoUnit->Inti[RteNumber].Destination;
}

VOID
HalpEnableRedirEntry(
    IN ULONG InterruptInput
    )
/*++

Routine Description:

    This procedure enables a IO Unit Redirection Table Entry
    by setting the mask bit in the Redir Entry.

Arguments:

    InterruptInput - The input line we're interested in

Return Value:

    None.

--*/
{
    PIO_INTR_CONTROL  IoUnit;
    ULONG  RteNumber;

    HalpInti2InterruptController (
        InterruptInput,&IoUnit,&RteNumber
        );

    ASSERT(IoUnit);

    IoUnit->IntrMethods->EnableEntry(IoUnit, RteNumber);
}

VOID
HalpDisableRedirEntry(
    IN ULONG InterruptInput
    )
/*++

Routine Description:

    This procedure disables a IO Unit Redirection Table Entry
    by setting the mask bit in the Redir Entry.

Arguments:

    InterruptInput - The input line we're interested in

Return Value:

    None.

--*/
{
    PIO_INTR_CONTROL  IoUnit;
    ULONG  RteNumber;

    HalpInti2InterruptController (
        InterruptInput,&IoUnit,&RteNumber
        );

    ASSERT(IoUnit);

    IoUnit->IntrMethods->MaskEntry(IoUnit, RteNumber);
}


VOID
IoSapicMaskEntry(
    PIO_INTR_CONTROL IoUnit,
    ULONG RteNumber
    )
{
    PIO_SAPIC_REGS IoSapicPtr = IoUnit->RegBaseVirtual;
    ULONG RedirRegister;

    RedirRegister = RteNumber*2 + IO_REDIR_00_LOW;

    IoSapicPtr->RegisterSelect = RedirRegister;
    IoSapicPtr->RegisterWindow |= INTERRUPT_MASKED;

    HalDebugPrint(( HAL_VERBOSE, "HAL: IoSapicMaskEntry - %d [%#p]: Dest=%#x  Vec=%#x\n",
                    RteNumber,IoSapicPtr,
                    IoUnit->Inti[RteNumber].Destination,
                    IoUnit->Inti[RteNumber].Vector
                 ));
}


VOID
IoSapicEnableEntry(
    PIO_INTR_CONTROL IoUnit,
    ULONG RteNumber
    )
{
    PIO_SAPIC_REGS IoSapicPtr = IoUnit->RegBaseVirtual;
    ULONG  RedirRegister;
    PULONG_PTR EoiValue;

    RedirRegister = RteNumber*2 + IO_REDIR_00_LOW;

    IoSapicPtr->RegisterSelect = RedirRegister;
    IoSapicPtr->RegisterWindow &= (~INTERRUPT_MASKED);

    HalDebugPrint(( HAL_VERBOSE, "HAL: IoSapicEnableEntry: %d [%#p]: Dest=%#x  Vec=%#x\n",
             RteNumber,IoSapicPtr,
             IoUnit->Inti[RteNumber].Destination,
             IoUnit->Inti[RteNumber].Vector
             ));
}

VOID
IoSapicSetEntry(
    PIO_INTR_CONTROL IoUnit,
    ULONG RteNumber
    )
{
    PIO_SAPIC_REGS IoSapicPtr = IoUnit->RegBaseVirtual;
    ULONG  RedirRegister;
    PULONG_PTR EoiValue;
    USHORT ApicId;

    RedirRegister = RteNumber*2 + IO_REDIR_00_LOW;

    IoSapicPtr->RegisterSelect = RedirRegister+1;
    IoSapicPtr->RegisterWindow = IoUnit->Inti[RteNumber].Destination;
    IoSapicPtr->RegisterSelect = RedirRegister;
    IoSapicPtr->RegisterWindow = IoUnit->Inti[RteNumber].Vector; // Enable
    EoiValue = (PULONG_PTR)(IoUnit->Inti[RteNumber].Vector & LEVEL_TRIGGERED ?
            &((PIO_SAPIC_REGS)(IoUnit->RegBaseVirtual))->Eoi : 0 );

    HalDebugPrint(( HAL_VERBOSE, "HAL: IoSapicSetEntry: %d [%#p]: Dest=%#x  Vec=%#x  Eoi=%#p\n",
             RteNumber,IoSapicPtr,
             IoUnit->Inti[RteNumber].Destination,
             IoUnit->Inti[RteNumber].Vector,
             EoiValue
             ));

    // Only SetEntry sets the eoi table because set entry is the only
    // one that sets the destination CPU.

    ApicId = (USHORT)((IoUnit->Inti[RteNumber].Destination & SAPIC_XID_MASK) >> SAPIC_XID_SHIFT);

    HalpWriteEOITable(
        IoUnit->Inti[RteNumber].Vector & INT_VECTOR_MASK,
        EoiValue,
        HalpGetProcessorNumberByApicId(ApicId));
}

BOOLEAN
HalpIsActiveLow(
    ULONG Inti
    )
{
    PIO_INTR_CONTROL  IoUnit;
    ULONG  RteNumber;

    HalpInti2InterruptController (
        Inti,&IoUnit,&RteNumber
        );

    return( (IoUnit->Inti[RteNumber].Vector & ACTIVE_LOW) == ACTIVE_LOW);
}

BOOLEAN
HalpIsLevelTriggered(
    ULONG Inti
    )
{
    PIO_INTR_CONTROL  IoUnit;
    ULONG  RteNumber;

    HalpInti2InterruptController (
        Inti,&IoUnit,&RteNumber
        );

    ASSERT(IoUnit);
    return( (IoUnit->Inti[RteNumber].Vector & LEVEL_TRIGGERED) == LEVEL_TRIGGERED);
}

VOID
HalpSetPolarity(
    ULONG Inti,
    BOOLEAN ActiveLow
    )
{
    PIO_INTR_CONTROL  IoUnit;
    ULONG  RteNumber;

    HalpInti2InterruptController (
        Inti,&IoUnit,&RteNumber
        );

    ASSERT(IoUnit);
    if (ActiveLow) {
        IoUnit->Inti[RteNumber].Vector |= ACTIVE_LOW;
    } else {
        IoUnit->Inti[RteNumber].Vector &= ~ACTIVE_LOW;
    }
}

VOID
HalpSetLevel(
    ULONG Inti,
    BOOLEAN LevelTriggered
    )
{
    PIO_INTR_CONTROL  IoUnit;
    ULONG  RteNumber;

    HalpInti2InterruptController (
        Inti,&IoUnit,&RteNumber
        );

    ASSERT(IoUnit);
    if (LevelTriggered) {
        IoUnit->Inti[RteNumber].Vector |= LEVEL_TRIGGERED;
    } else {
        IoUnit->Inti[RteNumber].Vector &= ~LEVEL_TRIGGERED;
    }
}

#if 0

VOID
HalpSetDestination(
    ULONG Inti,
    USHORT ProcessorID
    )
{
    PIO_INTR_CONTROL  ioUnit;
    ULONG  rteNumber;
    ULONG  oldLevel;

    HalpInti2InterruptController (
        Inti,&ioUnit,&rteNumber
        );

    ASSERT(ioUnit);


    oldLevel = HalpAcquireHighLevelLock (&HalpIoSapicLock);

    ioUnit->Inti[rteNumber].Destination = ProcessorID<<16;
    ioUnit->IntrMethods->SetEntry(ioUnit, rteNumber);

    HalpReleaseHighLevelLock (&HalpIoSapicLock, oldLevel);

} // HalpSetDestination()

#endif // 0

VOID
HalpSpuriousHandler (
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME        TrapFrame
    )

/*++
    Routine Description:

        Spurious Interrupt handler. Dummy return or we can count number of
        occurance of spurious interrupts. Right now, we will do a dummy return.

    Arguements:


    Return Parameters:

--*/


{



}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\i64sysbus.c ===
/*++


Copyright (c) 1998  Microsoft Corporation

Module Name:

    i64sysbus.c

Abstract:

Author:

   Todd Kjos (HP) (v-tkjos) 1-Jun-1998
   Based on halacpi\i386\pmbus.c and halmps\i386\mpsysbus.c

Environment:

   Kernel Mode Only

Revision History:


--*/

#include "halp.h"
#include "iosapic.h"
#include <ntacpi.h>

#define HalpInti2BusInterruptLevel(Inti) Inti

ULONG HalpDefaultInterruptAffinity = 0;

extern ULONG HalpMaxNode;
extern ULONG HalpNodeAffinity[MAX_NODES];

UCHAR HalpNodeBucket[MAX_NODES];

extern ULONG HalpPicVectorRedirect[];
extern ULONG HalpPicVectorFlags[];

BOOLEAN
HalpTranslateSystemBusAddress(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

ULONG
HalpGetSystemInterruptVector(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG InterruptLevel,
    IN ULONG InterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    );

VOID
HalpSetInternalVector (
    IN ULONG    InternalVector,
    IN VOID   (*HalInterruptServiceRoutine)(VOID)
    );

VOID
HalpSetCPEVectorState(
    IN ULONG  GlobalInterrupt,
    IN UCHAR  SapicVector,
    IN USHORT DestinationCPU,
    IN ULONG  Flags
    );

UCHAR HalpVectorToIRQL[256];
ULONG HalpVectorToINTI[(1+MAX_NODES)*256];
ULONG HalpInternalSystemVectors[MAX_NODES];
ULONG HalpInternalSystemVectorCount;

extern KSPIN_LOCK HalpIoSapicLock;
extern BUS_HANDLER HalpFakePciBusHandler;

#ifdef PIC_SUPPORTED
UCHAR HalpPICINTToVector[16];
#endif

#define HAL_IRQ_TRANSLATOR_VERSION 0

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpSetInternalVector)
#pragma alloc_text(PAGELK,HalpGetSystemInterruptVector)
#pragma alloc_text(PAGE, HaliSetVectorState)
#pragma alloc_text(PAGE, HalpSetCPEVectorState)
#pragma alloc_text(PAGE, HalIrqTranslateResourceRequirementsRoot)
#pragma alloc_text(PAGE, HalTranslatorReference)
#pragma alloc_text(PAGE, HalTranslatorDereference)
#pragma alloc_text(PAGE, HaliIsVectorValid)
#endif

BOOLEAN
HalpFindBusAddressTranslation(
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress,
    IN OUT PUINT_PTR Context,
    IN BOOLEAN NextBus
    )

/*++

Routine Description:

    This routine performs a very similar function to HalTranslateBusAddress
    except that InterfaceType and BusNumber are not known by the caller.
    This function will walk all busses known by the HAL looking for a
    valid translation for the input BusAddress of type AddressSpace.

    This function is recallable using the input/output Context parameter.
    On the first call to this routine for a given translation the UINT_PTR
    Context should be NULL.  Note:  Not the address of it but the contents.

    If the caller decides the returned translation is not the desired
    translation, it calls this routine again passing Context in as it
    was returned on the previous call.  This allows this routine to
    traverse the bus structures until the correct translation is found
    and is provided because on multiple bus systems, it is possible for
    the same resource to exist in the independent address spaces of
    multiple busses.

Arguments:

    BusAddress          Address to be translated.
    AddressSpace        0 = Memory
                        1 = IO (There are other possibilities).
                        N.B. This argument is a pointer, the value
                        will be modified if the translated address
                        is of a different address space type from
                        the untranslated bus address.
    TranslatedAddress   Pointer to where the translated address
                        should be stored.
    Context             Pointer to a UINT_PTR. On the initial call,
                        for a given BusAddress, it should contain
                        0.  It will be modified by this routine,
                        on subsequent calls for the same BusAddress
                        the value should be handed in again,
                        unmodified by the caller.
    NextBus             FALSE if we should attempt this translation
                        on the same bus as indicated by Context,
                        TRUE if we should be looking for another
                        bus.

Return Value:

    TRUE    if translation was successful,
    FALSE   otherwise.

--*/

{
    //
    // First, make sure the context parameter was supplied and is
    // being used correctly.  This also ensures that the caller
    // doesn't get stuck in a loop looking for subsequent translations
    // for the same thing.  We won't succeed the same translation twice
    // unless the caller reinits the context.
    //

    if ((!Context) || (*Context && (NextBus == TRUE))) {
        return FALSE;
    }
    *Context = 1;

    //
    // PC/AT (halx86) case is simplest, there is no translation.
    //

    *TranslatedAddress = BusAddress;
    return TRUE;
}


BOOLEAN
HalpTranslateSystemBusAddress(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )

/*++

Routine Description:

    This function translates a bus-relative address space and address into
    a system physical address.

Arguments:

    BusAddress        - Supplies the bus-relative address

    AddressSpace      -  Supplies the address space number.
                         Returns the host address space number.

                         AddressSpace == 0 => memory space
                         AddressSpace == 1 => I/O space

    TranslatedAddress - Supplies a pointer to return the translated address

Return Value:

    A return value of TRUE indicates that a system physical address
    corresponding to the supplied bus relative address and bus address
    number has been returned in TranslatedAddress.

    A return value of FALSE occurs if the translation for the address was
    not possible

--*/

{
    BOOLEAN             status;
    PSUPPORTED_RANGE    pRange;

    status  = FALSE;
    switch (*AddressSpace) {
        case 0:
            // verify memory address is within buses memory limits
            pRange = &BusHandler->BusAddresses->Memory;
            while (!status  &&  pRange) {
                status = BusAddress.QuadPart >= pRange->Base &&
                         BusAddress.QuadPart <= pRange->Limit;
                pRange = pRange->Next;
            }

            pRange = &BusHandler->BusAddresses->PrefetchMemory;
            while (!status  &&  pRange) {
                status = BusAddress.QuadPart >= pRange->Base &&
                         BusAddress.QuadPart <= pRange->Limit;

                pRange = pRange->Next;
            }
            break;

        case 1:
            // verify IO address is within buses IO limits
            pRange = &BusHandler->BusAddresses->IO;
            while (!status  &&  pRange) {
                status = BusAddress.QuadPart >= pRange->Base &&
                         BusAddress.QuadPart <= pRange->Limit;

                pRange = pRange->Next;
            }
            break;

        default:
            status = FALSE;
            break;
    }

    if (status) {
        TranslatedAddress->LowPart = BusAddress.LowPart;
        TranslatedAddress->HighPart = BusAddress.HighPart;
    }

    return status;
}


#define MAX_SYSTEM_IRQL     15
#define MAX_FREE_IRQL       11
#define MIN_FREE_IRQL       4
#define MAX_FREE_IDTENTRY   0xbf
#define MIN_FREE_IDTENTRY   0x41
#define IDTENTRY_BASE       0x40
#define MAX_VBUCKET         8

#define AllocateVectorIn(index)     \
    vBucket[index]++;               \
    ASSERT (vBucket[index] < 16);

#define GetIDTEntryFrom(index)  \
    (UCHAR) ( index*16 + IDTENTRY_BASE + vBucket[index] )
    // note: device levels 40,50,60,70,80,90,A0,B0 are not allocatable

#define GetIrqlFrom(index)  (KIRQL) ( (GetIDTEntryFrom(index)) >> 4 )

UCHAR   nPriority[MAX_NODES][MAX_VBUCKET];

ULONG
HalpAllocateSystemInterruptVector (
    IN OUT PKIRQL Irql,
    IN OUT PKAFFINITY Affinity
    )
/*++

Routine Description:

    This function allocates a system interrupt vector that reflects
    the maximum specified affinity and priority allocation policy.  A
    system interrupt vector is returned along with the IRQL and a
    modified affinity.

    NOTE: HalpIoSapicLock must already have been taken at HIGH_LEVEL.

Arguments:

    Irql - Returns the system request priority.

    Affinity - What is passed in represents the maximum affinity that
    can be returned.  Returned value represents that affinity
    constrained by the node chosen.

Return Value:

    Returns the system interrupt vector

--*/
{
    ULONG           SystemVector;
    ULONG           Node;
    ULONG           Bucket, i;
    PUCHAR          vBucket;
    UCHAR           IDTEntry;

    //
    // Pick a node.  In the future, Affinity will be INOUT and
    // we will have to screen the node against the input affinity.
    if (HalpMaxNode == 1)  {
        Node = 1;
    } else {
        //
        // Find a node that meets the affinity requirements.
        // Nodes are numbered 1..n, so 0 means we are done.
        for (i = HalpMaxNode; i; i--) {
            if ((*Affinity & HalpNodeAffinity[i-1]) == 0)
                continue;
            Node = i;
            break;
        }
        ASSERT(Node != 0);

        //
        // Look for a "less busy" alternative.
        for (i = Node-1; i; i--) {
            //
            // Check input Affinity to see if this node is permitted.
            if ((*Affinity & HalpNodeAffinity[i-1]) == 0)
                continue;
            //
            // Take the least busy of the permitted nodes.
            if (HalpNodeBucket[i-1] < HalpNodeBucket[Node-1]) {
                Node = i;
            }
        }
    }
    HalpNodeBucket[Node-1]++;
    *Affinity = HalpNodeAffinity[Node-1];
    vBucket = nPriority[Node-1];

    //
    // Choose the least busy priority on the node.
    //
    Bucket = MAX_VBUCKET-1;
    for (i = Bucket; i; i--) {
        if (vBucket[i - 1] < vBucket[Bucket]) {
            Bucket = i - 1;
        }
    }

    AllocateVectorIn (Bucket);

    //
    // Now form the vector for the kernel.
    IDTEntry = GetIDTEntryFrom (Bucket);
    SystemVector = HalpVector(Node, IDTEntry);
    ASSERT(IDTEntry <= MAX_FREE_IDTENTRY);
    ASSERT(IDTEntry >= MIN_FREE_IDTENTRY);

    *Irql = GetIrqlFrom (Bucket);
    ASSERT(*Irql <= MAX_FREE_IRQL);

    HalpVectorToIRQL[IDTEntry] = (UCHAR) *Irql;

    HalDebugPrint(( HAL_VERBOSE, "HAL: IDTEntry %x  SystemVector %x  Irql %x\n", IDTEntry, SystemVector, *Irql));

    return SystemVector;
}

ULONG
HalpGetSystemInterruptVector (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG InterruptLevel,
    IN ULONG InterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    )

/*++

Routine Description:

    This function returns the system interrupt vector and IRQL
    corresponding to the specified bus interrupt level and/or
    vector.  The system interrupt vector and IRQL are suitable
    for use in a subsequent call to KeInitializeInterrupt.

Arguments:

    InterruptLevel - Supplies the bus specific interrupt level.

    InterruptVector - Supplies the bus specific interrupt vector.

    Irql - Returns the system request priority.

    Affinity - Returns the system wide irq affinity.

Return Value:

    Returns the system interrupt vector corresponding to the specified device.

--*/
{
    ULONG           SystemVector, SapicInti;
    ULONG           OldLevel;
    BOOLEAN         Found;
    PVOID           LockHandle;
    ULONG           Node;
    KAFFINITY       SapicAffinity;


    UNREFERENCED_PARAMETER( InterruptVector );
    //
    // TODO: Remove when Affinity becomes IN OUT.
    *Affinity = ~0;
    //
    // Restrict Affinity if required.
    if (HalpMaxProcsPerCluster == 0)  {
        *Affinity &= HalpDefaultInterruptAffinity;
    }

    //
    // Find closest child bus to this handler
    //

    if (RootHandler != BusHandler) {
        while (RootHandler->ParentHandler != BusHandler) {
            RootHandler = RootHandler->ParentHandler;
        }
    }

    //
    // Find Interrupt's Sapic Inti connection
    //

    Found = HalpGetSapicInterruptDesc (
                RootHandler->InterfaceType,
                RootHandler->BusNumber,
                InterruptLevel,
                &SapicInti,
                &SapicAffinity
                );

    if (!Found) {
        return 0;
    }

    HalDebugPrint(( HAL_VERBOSE, "HAL: type %x  Level: %x  gets inti: %x Sapicaffinity: %p\n",
                    RootHandler->InterfaceType,
                    InterruptLevel,
                    SapicInti,
                    SapicAffinity));
    //
    // If device interrupt vector mapping is not already allocated,
    // then do it now
    //

    if (!HalpINTItoVector(SapicInti)) {

        //
        // Vector is not allocated - synchronize and check again
        //

        LockHandle = MmLockPagableCodeSection (&HalpGetSystemInterruptVector);
        OldLevel = HalpAcquireHighLevelLock (&HalpIoSapicLock);
        if (!HalpINTItoVector(SapicInti)) {

            //
            // Still not allocated
            //

            HalDebugPrint(( HAL_VERBOSE, "HAL: vector is not allocated\n"));

            SystemVector = HalpAllocateSystemInterruptVector(Irql, Affinity);

            HalpVectorToINTI[SystemVector] = SapicInti;
            HalpSetINTItoVector(SapicInti, SystemVector);

#ifdef PIC_SUPPORTED
            //
            // If this assigned interrupt is connected to the machines PIC,
            // then remember the PIC->SystemVector mapping.
            //

            if (RootHandler->BusNumber == 0  &&  InterruptLevel < 16  &&
                 RootHandler->InterfaceType == DEFAULT_PC_BUS) {
                HalpPICINTToVector[InterruptLevel] = (UCHAR) SystemVector;
            }
#endif
        }

        HalpReleaseHighLevelLock (&HalpIoSapicLock, OldLevel);
        MmUnlockPagableImageSection (LockHandle);
    } else {
        //
        // Return this SapicInti's system vector & irql
        //

        SystemVector = HalpINTItoVector(SapicInti);
        *Irql = HalpVectorToIRQL[HalVectorToIDTEntry(SystemVector)];
    }

    HalDebugPrint(( HAL_VERBOSE, "HAL: SystemVector: %x\n",
                    SystemVector));

    ASSERT(HalpVectorToINTI[SystemVector] == (USHORT) SapicInti);

    HalDebugPrint(( HAL_VERBOSE, "HAL: HalpGetSystemInterruptVector - In  Level 0x%x, In  Vector 0x%x\n",
                    InterruptLevel, InterruptVector ));
    HalDebugPrint(( HAL_VERBOSE, "HAL:                                Out Irql  0x%x, Out System Vector 0x%x\n",
                    *Irql, SystemVector ));

    //
    // Find an appropriate affinity.
    //
    Node = HalpVectorToNode(SystemVector);
    *Affinity &= HalpNodeAffinity[Node-1];
    if (!*Affinity) {
        return 0;
    }

    return SystemVector;
}

BOOLEAN
HalpIsInternalInterruptVector(
    ULONG SystemVector
    )
/*++

Routine Description:

    This function returns whether or not the vector specified is an
    internal vector i.e. one not connected to the IOAPIC

Arguments:

    System Vector - specifies an interrupt vector

Return Value:

    BOOLEAN - TRUE indicates that the vector is internal.

--*/
{
    ULONG i;
    BOOLEAN Result = FALSE;

    for (i = 0; i < HalpInternalSystemVectorCount; i++) {
        if (HalpInternalSystemVectors[i] == SystemVector) {
            Result = TRUE;
            break;
        }
    }

    return Result;
}

NTSTATUS
HalpReserveCrossPartitionInterruptVector (
    OUT PULONG Vector,
    OUT PKIRQL Irql,
    IN OUT PKAFFINITY Affinity,
    OUT PUCHAR HardwareVector
    )
/*++

Routine Description:

    This function returns the system interrupt vector, IRQL, and
    corresponding to the specified bus interrupt level and/or
    vector.  The system interrupt vector and IRQL are suitable
    for use in a subsequent call to KeInitializeInterrupt.

Arguments:

    Vector - specifies an interrupt vector that can be passed to
    IoConnectInterrupt.

    Irql - specifies the irql that should be passed to IoConnectInterrupt

    Affinity - should be set to the requested maximum affinity.  On
    return, it will reflect the actual affinity that should be
    specified in IoConnectInterrupt.

    HardwareVector - this is the hardware vector to be used by a
    remote partition to target this interrupt vector.

Return Value:

    NTSTATUS

--*/
{
    ULONG OldLevel;
    NTSTATUS Status;

    OldLevel = HalpAcquireHighLevelLock (&HalpIoSapicLock);

    if (HalpInternalSystemVectorCount != MAX_NODES) {

        *Vector = HalpAllocateSystemInterruptVector(Irql, Affinity);

        HalpInternalSystemVectors[HalpInternalSystemVectorCount++] = *Vector;

        *HardwareVector = HalVectorToIDTEntry(*Vector);

        Status = STATUS_SUCCESS;
    }
    else {

        Status = STATUS_UNSUCCESSFUL;
    }

    HalpReleaseHighLevelLock (&HalpIoSapicLock, OldLevel);

    return Status;
}


//
// This section implements a "translator," which is the PnP-WDM way
// of doing the same thing that the first part of this file does.
//
VOID
HalTranslatorReference(
    PVOID Context
    )
{
    return;
}

VOID
HalTranslatorDereference(
    PVOID Context
    )
{
    return;
}

NTSTATUS
HalIrqTranslateResourcesRoot(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    )
/*++

Routine Description:

    This function takes a CM_PARTIAL_RESOURCE_DESCRIPTOR and translates
    it to an IO-bus-relative from a Processor-bus-relative form, or the other
    way around.  In this x86-specific example, an IO-bus-relative form is the
    ISA IRQ and the Processor-bus-relative form is the IDT entry and the
    associated IRQL.

    N.B.  This funtion has an associated "Direction."  These are not exactly
          reciprocals.  This has to be the case because the output from
          HalIrqTranslateResourceRequirementsRoot will be used as the input
          for the ParentToChild case.

          ChildToParent:

            Level  (ISA IRQ)        -> IRQL
            Vector (ISA IRQ)        -> x86 IDT entry
            Affinity (not refereced)-> KAFFINITY

          ParentToChild:

            Level (not referenced)  -> (ISA IRQ)
            Vector (IDT entry)      -> (ISA IRQ)
            Affinity                -> 0xffffffff

Arguments:

    Context     - unused

    Source      - descriptor that we are translating

    Direction   - direction of translation (parent to child or child to parent)

    AlternativesCount   - unused

    Alternatives        - unused

    PhysicalDeviceObject- unused

    Target      - translated descriptor

Return Value:

    status

--*/
{
    NTSTATUS        status = STATUS_SUCCESS;
    PBUS_HANDLER    bus;
    KAFFINITY       affinity;
    KIRQL           irql;
    ULONG           vector, inti;
    BUS_HANDLER     fakeIsaBus;

    PAGED_CODE();

    ASSERT(Source->Type == CmResourceTypeInterrupt);

    switch (Direction) {
    case TranslateChildToParent:


        RtlCopyMemory(&fakeIsaBus, &HalpFakePciBusHandler, sizeof(BUS_HANDLER));
        fakeIsaBus.InterfaceType = Isa;
        fakeIsaBus.ParentHandler = &fakeIsaBus;
        bus = &fakeIsaBus;

        //
        // Copy everything
        //
        *Target = *Source;

        //
        // Translate the IRQ
        //

        vector = HalpGetSystemInterruptVector(bus,
                                              bus,
                                              Source->u.Interrupt.Level,
                                              Source->u.Interrupt.Vector,
                                              &irql,
                                              &affinity);

        Target->u.Interrupt.Level  = irql;
        Target->u.Interrupt.Vector = vector;
        Target->u.Interrupt.Affinity = affinity;

        if (NT_SUCCESS(status)) {
            status = STATUS_TRANSLATION_COMPLETE;
        }

        break;

    case TranslateParentToChild:

        //
        // Copy everything
        //
        *Target = *Source;

        //
        // There is no inverse to HalpGetSystemInterruptVector, so we
        // just do what that function would do.
        //

        ASSERT(HalpVectorToINTI[Source->u.Interrupt.Vector]);

        inti = HalpVectorToINTI[Source->u.Interrupt.Vector];

        Target->u.Interrupt.Level = Target->u.Interrupt.Vector =
            HalpInti2BusInterruptLevel(inti);

        Target->u.Interrupt.Affinity = 0xFFFFFFFF;

        status = STATUS_SUCCESS;

        break;

    default:
        status = STATUS_INVALID_PARAMETER;
    }

    return status;
}

NTSTATUS
HalIrqTranslateResourceRequirementsRoot(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    )
/*++

Routine Description:

    This function takes an IO_RESOURCE_DESCRIPTOR and translates
    it from an IO-bus-relative to a Processor-bus-relative form.  In this
    x86-specific example, an IO-bus-relative form is the ISA IRQ and the
    Processor-bus-relative form is the IDT entry and the associated IRQL.
    This is essentially a PnP form of HalGetInterruptVector.

Arguments:

    Context     - unused

    Source      - descriptor that we are translating

    PhysicalDeviceObject- unused

    TargetCount - 1

    Target      - translated descriptor

Return Value:

    status

--*/
{
    PBUS_HANDLER    bus;
    KAFFINITY       affinity;
    KIRQL           irql;
    ULONG           vector;
    BOOLEAN         success = TRUE;
    BUS_HANDLER     fakeIsaBus;

    PAGED_CODE();

    ASSERT(Source->Type == CmResourceTypeInterrupt);

    RtlCopyMemory(&fakeIsaBus, &HalpFakePciBusHandler, sizeof(BUS_HANDLER));
    fakeIsaBus.InterfaceType = Isa;
    fakeIsaBus.ParentHandler = &fakeIsaBus;
    bus = &fakeIsaBus;

    //
    // The interrupt requirements were obtained by calling HalAdjustResourceList
    // so we don't need to call it again.
    //

    *Target = ExAllocatePoolWithTag(PagedPool,
                                    sizeof(IO_RESOURCE_DESCRIPTOR),
                                    HAL_POOL_TAG
                                    );

    if (!*Target) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    *TargetCount = 1;

    //
    // Copy the requirement unchanged
    //

    **Target = *Source;

    //
    // Perform the translation of the minimum & maximum
    //

    vector = HalpGetSystemInterruptVector(bus,
                                          bus,
                                          Source->u.Interrupt.MinimumVector,
                                          Source->u.Interrupt.MinimumVector,
                                          &irql,
                                          &affinity);

    if (!vector) {
        success = FALSE;
    }

    (*Target)->u.Interrupt.MinimumVector = vector;

    vector = HalpGetSystemInterruptVector(bus,
                                          bus,
                                          Source->u.Interrupt.MaximumVector,
                                          Source->u.Interrupt.MaximumVector,
                                          &irql,
                                          &affinity);

    if (!vector) {
        success = FALSE;
    }

    (*Target)->u.Interrupt.MaximumVector = vector;

    if (!success) {

        ExFreePool(*Target);
        *TargetCount = 0;
    }

    return STATUS_TRANSLATION_COMPLETE;
}

#if 0

// HALMPS doesn't provide this function.   It is left here as documentation
// for HALs which must provide translation.

NTSTATUS
HalpTransMemIoResourceRequirement(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    )

/*++

Routine Description:

    This routine translates memory and IO resource requirements.

Parameters:

    Context - The context from the TRANSLATOR_INTERFACE

    Source - The interrupt requirement to translate

    PhysicalDeviceObject - The device requesting the resource

    TargetCount - Pointer to where to return the number of descriptors this
        requirement translates into

    Target - Pointer to where a pointer to a callee allocated buffer containing
        the translated descriptors should be placed.

Return Value:

    STATUS_SUCCESS or an error status

Note:

    We do not perform any translation.

--*/

{
    ASSERT(Source);
    ASSERT(Target);
    ASSERT(TargetCount);
    ASSERT(Source->Type == CmResourceTypeMemory ||
           Source->Type == CmResourceTypePort);


    //
    // Allocate space for the target
    //

    *Target = ExAllocatePoolWithTag(PagedPool,
                                    sizeof(IO_RESOURCE_DESCRIPTOR),
                                    HAL_POOL_TAG
                                    );

    if (!*Target) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Copy the source to target and update the fields that have changed
    //

    **Target = *Source;
    *TargetCount = 1;

    return STATUS_SUCCESS;
}

NTSTATUS
HalpTransMemIoResource(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    )

/*++

Routine Description:

    This routine translates memory and IO resources.   On generic x86
    machines, such as those that use this HAL, there isn't actually
    any translation.

Parameters:

    Context - The context from the TRANSLATOR_INTERFACE

    Source - The interrupt resource to translate

    Direction - The direction in relation to the Pnp device tree translation
        should occur in.

    AlternativesCount - The number of alternatives this resource was selected
        from.

    Alternatives - Array of alternatives this resource was selected from.

    PhysicalDeviceObject - The device requesting the resource

    Target - Pointer to a caller allocated buffer to hold the translted resource
        descriptor.

Return Value:

    STATUS_SUCCESS or an error status

--*/

{
    NTSTATUS status;

    //
    // Copy the target to the source
    //

    *Target = *Source;

    switch (Direction) {
    case TranslateChildToParent:

        //
        // Make sure PnP knows it doesn't have to walk up the tree
        // translating at each point.
        //

        status = STATUS_TRANSLATION_COMPLETE;
        break;

    case TranslateParentToChild:

        //
        // We do not translate requirements so do nothing...
        //

        status = STATUS_SUCCESS;
        break;

    default:
        status = STATUS_INVALID_PARAMETER;
    }
    return status;
}
#endif

NTSTATUS
HaliGetInterruptTranslator(
   IN INTERFACE_TYPE ParentInterfaceType,
   IN ULONG ParentBusNumber,
   IN INTERFACE_TYPE BridgeInterfaceType,
   IN USHORT Size,
   IN USHORT Version,
   OUT PTRANSLATOR_INTERFACE Translator,
   OUT PULONG BridgeBusNumber
   )
/*++

Routine Description:


Arguments:

   ParentInterfaceType - The type of the bus the bridge lives on (normally PCI).

   ParentBusNumber - The number of the bus the bridge lives on.

   ParentSlotNumber - The slot number the bridge lives in (where valid).

   BridgeInterfaceType - The bus type the bridge provides (ie ISA for a PCI-ISA bridge).

   ResourceType - The resource type we want to translate.

   Size - The size of the translator buffer.

   Version - The version of the translator interface requested.

   Translator - Pointer to the buffer where the translator should be returned

   BridgeBusNumber - Pointer to where the bus number of the bridge bus should be returned

Return Value:

    Returns the status of this operation.

--*/
{
    PAGED_CODE();

    UNREFERENCED_PARAMETER(ParentInterfaceType);
    UNREFERENCED_PARAMETER(ParentBusNumber);

    ASSERT(Version == HAL_IRQ_TRANSLATOR_VERSION);
    ASSERT(Size >= sizeof(TRANSLATOR_INTERFACE));

    //
    // Fill in the common bits.
    //

    RtlZeroMemory(Translator, sizeof(TRANSLATOR_INTERFACE));

    Translator->Size = sizeof(TRANSLATOR_INTERFACE);
    Translator->Version = HAL_IRQ_TRANSLATOR_VERSION;
    Translator->Context = (PVOID)BridgeInterfaceType;
    Translator->InterfaceReference = HalTranslatorReference;
    Translator->InterfaceDereference = HalTranslatorDereference;

    switch (BridgeInterfaceType) {
    case Eisa:
    case Isa:
    case InterfaceTypeUndefined:  // special "IDE" cookie

        //
        // Set IRQ translator for (E)ISA interrupts.
        //

        Translator->TranslateResources = HalIrqTranslateResourcesIsa;
        Translator->TranslateResourceRequirements =
            HalIrqTranslateResourceRequirementsIsa;

        return STATUS_SUCCESS;

    case MicroChannel:

        //
        // Set IRQ translator for MCA interrupts.
        //

        Translator->TranslateResources = HalIrqTranslateResourcesRoot;
        Translator->TranslateResourceRequirements =
            HalIrqTranslateResourceRequirementsRoot;

        return STATUS_SUCCESS;
    }

    //
    // If we got here, we don't have an interface.
    //

    return STATUS_NOT_IMPLEMENTED;
}

// These defines come from the MPS 1.4 spec, section 4.3.4
#define PO_BITS                     3
#define POLARITY_HIGH               1
#define POLARITY_LOW                3
#define POLARITY_CONFORMS_WITH_BUS  0
#define EL_BITS                     0xc
#define EL_BIT_SHIFT                2
#define EL_EDGE_TRIGGERED           4
#define EL_LEVEL_TRIGGERED          0xc
#define EL_CONFORMS_WITH_BUS        0

VOID
HaliSetVectorState(
    IN ULONG Vector,
    IN ULONG Flags
    )
{
    BOOLEAN found;
    ULONG inti;
    ULONG picVector;
    UCHAR i;
    KAFFINITY affinity;

    PAGED_CODE();

   found = HalpGetSapicInterruptDesc( 0, 0, Vector, &inti, &affinity);

    if (!found) {
        KeBugCheckEx(ACPI_BIOS_ERROR,
                     0x10007,
                     Vector,
                     0,
                     0);
    }

    // ASSERT(HalpIntiInfo[inti].Type == INT_TYPE_INTR);

    //
    // Vector is already translated through
    // the PIC vector redirection table.  We need
    // to make sure that we are honoring the flags
    // in the redirection table.  So look in the
    // table here.
    //

    for (i = 0; i < PIC_VECTORS; i++) {

        if (HalpPicVectorRedirect[i] == Vector) {

            picVector = i;
            break;
        }
    }

    if (i != PIC_VECTORS) {

        //
        // Found this vector in the redirection table.
        //

        if (HalpPicVectorFlags[picVector] != 0) {

            //
            // And the flags say something other than "conforms
            // to bus."  So we honor the flags from the table.
            //
         switch ((UCHAR)(HalpPicVectorFlags[picVector] & EL_BITS) ) {

         case EL_EDGE_TRIGGERED:   HalpSetLevel(inti, FALSE);  break;
         case EL_LEVEL_TRIGGERED:  HalpSetLevel(inti, TRUE); break;
         default: // do nothing
            break;
         }

            switch ((UCHAR)(HalpPicVectorFlags[picVector] & PO_BITS)) {
         case POLARITY_HIGH: HalpSetPolarity(inti, FALSE); break;
         case POLARITY_LOW:  HalpSetPolarity(inti, TRUE);  break;
         default: // do nothing
            break;
         }

            return;
        }
    }

    //
    // This vector is not covered in the table, or it "conforms to bus."
    // So we honor the flags passed into this function.
    //

    if (IS_LEVEL_TRIGGERED(Flags)) {

      HalpSetLevel(inti,TRUE);

    } else {

      HalpSetLevel(inti,FALSE);
    }

    if (IS_ACTIVE_LOW(Flags)) {

      HalpSetPolarity(inti,TRUE);

    } else {

      HalpSetPolarity(inti,FALSE);
    }
}


VOID
HalpSetInternalVector (
    IN ULONG    InternalVector,
    IN VOID   (*HalInterruptServiceRoutine)(VOID)
    )
/*++

Routine Description:

    Used at init time to set IDT vectors for internal use.

--*/
{
    //
    // Remember this vector so it's reported as Hal internal usage
    //

    HalpRegisterVector (
        InternalUsage,
        InternalVector,
        InternalVector,

        //
        //  HalpVectorToIRQL[InternalVector >> 4]
        //

        (KIRQL)(InternalVector >> 4)

    );

    //
    // Connect the IDT
    //

    HalpSetHandlerAddressToVector(InternalVector, HalInterruptServiceRoutine);
}

VOID
HalpSetCPEVectorState(
    IN ULONG  GlobalInterrupt,
    IN UCHAR  SapicVector,
    IN USHORT DestinationCPU,
    IN ULONG  Flags
    )
{
    BOOLEAN found;
    ULONG SapicInti;
    KAFFINITY affinity;

    PAGED_CODE();

    found = HalpGetSapicInterruptDesc( 0, 0, GlobalInterrupt, &SapicInti, &affinity);

    if ( found ) {

        HalpWriteRedirEntry( GlobalInterrupt, SapicVector, DestinationCPU, Flags, PLATFORM_INT_CPE );

    }
    else    {

        HalDebugPrint(( HAL_ERROR,
                        "HAL: HalpSetCPEVectorState - Could not find interrupt input for SAPIC interrupt %ld\n",
                        GlobalInterrupt ));

    }

    return;

} // HalpSetCPEVectorState()

BOOLEAN
HaliIsVectorValid(
    IN ULONG Vector
    )
{
    BOOLEAN found;
    ULONG   inti;
    KAFFINITY affinity;

    PAGED_CODE();

    return HalpGetSapicInterruptDesc( 0, 0, Vector, &inti, &affinity);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\i64sxint.c ===
//

/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/*++

Copyright (c) 1995  Intel Corporation

Module Name:

    i64sxint.c copied from simsxint.c

Abstract:

    This module implements the routines to manage the
    system interrupt and IRQL.

Author:

    William K. Cheung (wcheung) 14-Apr-1995
    Bernard Lint
    M. Jayakumar (Muthurajan.Jayakumar@intel.com)
Environment:

    Kernel mode

Revision History:

   Todd Kjos (HP) (v-tkjos) 1-Jun-1998 : Added I/O Sapic support

   Thierry Fevrier (HP) (v-thief) 8-Feb-2000 : Profiling support

--*/

#include "halp.h"
#include "iosapic.h"

VOID HalpInitLINT(VOID);

extern KSPIN_LOCK HalpIoSapicLock;
extern PULONG_PTR *HalEOITable[];
PULONG_PTR HalpEOITableP0[MAX_INTR_VECTOR];

ULONG HalpNodeAffinity[MAX_NODES];
ULONG HalpMaxNode = 1;


VOID
HalpInitializeInterrupts (
    VOID
    )
/*++

Routine Description:

    This function initializes interrupts for an IA64 system.

Arguments:

    None.

Return Value:

    None.

Note:

    In KiInitializeKernel(), PCR.InterruptRoutine[] entries have been first initialized
    with the Unexpected Interrupt code then entries index-0, APC_VECTOR, DISPATCH_VECTOR
    have been initialized with their respective interrupt handlers.

--*/
{

    //
    // Turn off LINT0 LINT1 (disable 8259)
    //

    // __setReg(CV_IA64_SaLRR0, 0x10000);
    // __setReg(CV_IA64_SaLRR1, 0x10000);
    HalpInitLINT();
    __dsrlz();

    //
    // interval timer interrupt; 10ms by default
    //

    HalpInitializeClockInterrupts();

    //
    // Initialize SpuriousInterrupt
    //

    HalpSetHandlerAddressToVector
             (SAPIC_SPURIOUS_VECTOR, HalpSpuriousHandler);


    //
    // Initialize CMCI Interrupt
    //
    // Note that it is possible that HAL_CMC_PRESENT is not set.
    // With the current implementation, we always connect the vector to the ISR.
    //

    HalpSetHandlerAddressToVector
             (CMCI_VECTOR, HalpCMCIHandler);

    //
    // Initialize CPEI Interrupt
    //
    // Note that it is possible that HAL_CPE_PRESENT is not set.
    // With the current implementation, we always connect the vector to the ISR.
    //

    HalpSetHandlerAddressToVector
             (CPEI_VECTOR, HalpCPEIHandler);

    //
    // Initialiaze MC Rendezvous Interrupt
    //

    HalpSetHandlerAddressToVector
             (MC_RZ_VECTOR, HalpMcRzHandler);

    //
    // Initialize MC Wakeup Interrupt
    //

    HalpSetHandlerAddressToVector
             (MC_WKUP_VECTOR, HalpMcWkupHandler);

    //
    // IPI Interrupt
    //

    HalpSetHandlerAddressToVector(IPI_VECTOR, HalpIpiInterruptHandler);

    //
    // profile timer interrupt; turned off initially
    //

    HalpSetHandlerAddressToVector(PROFILE_VECTOR, HalpProfileInterrupt);

    //
    // Performance monitor interrupt
    //

    HalpSetHandlerAddressToVector(PERF_VECTOR, HalpPerfInterrupt);

    return;

} // HalpInitializeInterrupts()

VOID
HalpInitIntiInfo(
    VOID
    )
{
    USHORT Index;

    // Initialize the vector to INTi table

    for (Index=0; Index < ((1 + MAX_NODES)*256); Index++) {
       HalpVectorToINTI[Index] = (ULONG)-1;
    }
}

VOID
HalpInitEOITable(
    VOID
    )
{
    USHORT Index;
    ULONG ProcessorNumber;

    // Allocate and Initialize EOI table on current processor

    ProcessorNumber = PCR->Prcb->Number;

    if (ProcessorNumber == 0) {
       HalEOITable[ProcessorNumber] = HalpEOITableP0;
    } else {
       HalEOITable[ProcessorNumber] = ExAllocatePool(NonPagedPool,
                                                     MAX_INTR_VECTOR*sizeof(HalEOITable[0]));
    }

    // For kernel access to eoi table

    PCR->EOITable = HalEOITable[ProcessorNumber];

    for (Index=0; Index < MAX_INTR_VECTOR; Index++) {
       HalEOITable[ProcessorNumber][Index] = 0;
    }
}


VOID
HalpWriteEOITable(
    IN ULONG     Vector,
    IN PULONG_PTR EoiAddress,
    IN ULONG Number
    )
/*++

Routine Description:

    This routine updates the EOI table for a processor

Arguments:

    Vector - Entry to update (IDT entry)

    EoiAddress - Address to write (SAPIC address)

    Number - Logical (NT) processor number

Return Value:

    None

--*/

{

    if (HalEOITable != NULL && HalEOITable[Number] != NULL) {
        HalEOITable[Number][Vector] = EoiAddress;
    }

}


BOOLEAN
HalEnableSystemInterrupt (
    IN ULONG Vector,
    IN KIRQL Irql,
    IN KINTERRUPT_MODE InterruptMode
    )

/*++

Routine Description:

    This routine enables the specified system interrupt.

    N.B. This routine assumes that the caller has provided any required
         synchronization to enable a system interrupt.

Arguments:

    Vector - Supplies the vector of the system interrupt that is enabled.

    Irql - Supplies the IRQL of the interrupting source.

    InterruptMode - Supplies the mode of the interrupt; LevelSensitive or
                    Latched.

Return Value:

    TRUE if the system interrupt was enabled

--*/

{
    ULONG Entry, Destination;
    ULONG OldLevel;
    ULONG Inti;
    ULONG LevelAndPolarity;
    USHORT ThisCpuApicID;
    ULONG InterruptType;
    BOOLEAN RetVal = TRUE;
    UCHAR IDTEntry;

    ASSERT(Vector < (1+MAX_NODES)*0x100-1);
    ASSERT(Irql <= HIGH_LEVEL);

    HalDebugPrint(( HAL_VERBOSE, "HAL: HalpEnableSystemInterrupt - INTI=0x%x  Vector=0x%x  IRQL=0x%x\n",
             HalpVectorToINTI[Vector],
             Vector,
             Irql ));

    if ( (Inti = HalpVectorToINTI[Vector]) == (ULONG)-1 ) {
        //
        // There is no external device associated with this interrupt,
        // but it might be an internal interrupt i.e. one that never
        // involves the IOSAPIC.
        //
        return HalpIsInternalInterruptVector(Vector);
    }

    // Make sure the passed-in level matches our settings...
    if ((InterruptMode == LevelSensitive && !HalpIsLevelTriggered(Inti)) ||
       (InterruptMode != LevelSensitive && HalpIsLevelTriggered(Inti)) ) {

      // It doesn't match!
      HalDebugPrint(( HAL_INFO, "HAL: HalpEnableSystemInterrupt - Warning device interrupt mode overridden\n"));
    }

    LevelAndPolarity =
        (HalpIsLevelTriggered(Inti) ? LEVEL_TRIGGERED : EDGE_TRIGGERED) |
        (HalpIsActiveLow(Inti)      ? ACTIVE_LOW      : ACTIVE_HIGH);

    //
    // Block interrupts and synchronize until we're done
    //
    OldLevel = HalpAcquireHighLevelLock (&HalpIoSapicLock);

    ThisCpuApicID = (USHORT)KeGetPcr()->HalReserved[PROCESSOR_ID_INDEX];

    // Get Interrupt type
    HalpGetRedirEntry(Inti,&Entry,&Destination);

    InterruptType = Entry & INT_TYPE_MASK;
    IDTEntry = HalVectorToIDTEntry(Vector);

    switch (InterruptType) {
    case DELIVER_FIXED:
    case DELIVER_LOW_PRIORITY:
        //
        // Normal external interrupt...
        // Enable the interrupt in the I/O SAPIC redirection table
        //
        if (IDTEntry < 16) {
            // Reserved vectors: Extint, NMI, IntelReserved
            // No vectors in this range can be assigned
            ASSERT(0);
            RetVal = FALSE;
            break;
        }

        //
        // All external interrupts are delivered as Fixed interrupts
        // without the "redirectable" bit set (aka Lowest Priority).  This
        // disallows hardware to redirect the interrupts using the XTP mechanism.
        //

        Entry = (ULONG)IDTEntry | LevelAndPolarity;

        HalpSetRedirEntry ( Inti, Entry, ThisCpuApicID );
        break;

    case DELIVER_EXTINT:
        //
        // This is an interrupt that uses the IO Sapic to route PIC
        // events.  This configuration is not supported in IA64.
        //
        ASSERT(0);
        RetVal = FALSE;
        break;

    default:
        HalDebugPrint(( HAL_ERROR, "HAL: HalEnableSystemInterrupt - Unknown Interrupt Type: %d\n",
                 InterruptType));
        RetVal = FALSE;
        break;
    } // switch (InterruptType)

   HalpReleaseHighLevelLock (&HalpIoSapicLock, OldLevel);
   return(RetVal);
}

VOID
HalDisableSystemInterrupt (
    IN ULONG Vector,
    IN KIRQL Irql
    )

/*++

Routine Description:

    This routine disables the specified system interrupt.

    In the simulation environment, this function does nothing and returns.

    N.B. This routine assumes that the caller has provided any required
        synchronization to disable a system interrupt.

Arguments:

    Vector - Supplies the vector of the system interrupt that is disabled.

    Irql - Supplies the IRQL of the interrupting source.

Return Value:

    None.

--*/

{
    ULONG Entry, Destination;
    ULONG OldLevel;
    ULONG Inti;
    ULONG LevelAndPolarity;
    ULONG ThisCpuApicID;
    ULONG InterruptType;

    ASSERT(Vector < (1+MAX_NODES)*0x100-1);
    ASSERT(Irql <= HIGH_LEVEL);

    HalDebugPrint(( HAL_INFO, "HAL: HalpDisableSystemInterrupt: INTI=%x  Vector=%x  IRQL=%x\n",
             HalpVectorToINTI[Vector],
             Vector,
             Irql));

    if ( (Inti = HalpVectorToINTI[Vector]) == (ULONG)-1 ) {
        //
        // There is no external device associated with this interrupt
        //
        return;
    }

    //
    // Block interrupts and synchronize until we're done
    //
    OldLevel = HalpAcquireHighLevelLock(&HalpIoSapicLock);

    ThisCpuApicID = (USHORT)KeGetPcr()->HalReserved[PROCESSOR_ID_INDEX];

    // Get Interrupt Type and Destination
    HalpGetRedirEntry(Inti, &Entry, &Destination);

    if (ThisCpuApicID != Destination) {
        // The interrupt is not enabled on this Cpu
        HalpReleaseHighLevelLock (&HalpIoSapicLock, OldLevel);
        return;
    }

    InterruptType = Entry & INT_TYPE_MASK;

    switch (InterruptType) {
    case DELIVER_FIXED:
        //
        // Normal external interrupt...
        // Disable the interrupt in the I/O SAPIC redirection table
        //
        if (Vector < 16) {
            // Reserved vectors: Extint, NMI, IntelReserved
            // No vectors in this range can be assigned
            ASSERT(0);
            break;
        }

      HalpDisableRedirEntry (Inti);
      break;

    case DELIVER_EXTINT:
        //
        // This is an interrupt that uses the IO Sapic to route PIC
        // events.  This configuration is not supported in IA64.
        //
        ASSERT(0);
        break;

    default:
        HalDebugPrint(( HAL_INFO, "HAL: HalDisableSystemInterrupt - Unknown Interrupt Type: %d\n",
                      InterruptType ));
        break;
    } // switch (InterruptType)

    HalpReleaseHighLevelLock (&HalpIoSapicLock, OldLevel);
}


UCHAR
HalpNodeNumber(
    ULONG Number
    )
/*++

Routine Description:

    This routine divines the Node number for the CPU Number.
    Node numbers start at 1, and represent the granularity of interrupt
    routing decisions.

Arguments:

    Number - Processor number

Return Value:

    None.

--*/
{
    if (HalpMaxProcsPerCluster != 0)  {
        // One Node per Cluster.
        return (UCHAR)(Number/HalpMaxProcsPerCluster + 1);
    } else {
        // One Node per machine.
        return(1);
    }
}

VOID
HalpAddNodeNumber(
    ULONG Number
    )
/*++

Routine Description:

    This routine adds the current processor to the Node tables.

Arguments:

    None

Return Value:

    None.

--*/
{
    ULONG Node;
    //
    // Add the current processor to the Node tables.
    //
    Node = HalpNodeNumber(Number);

    if (HalpMaxNode < Node) {
        HalpMaxNode = Node;
    }

    HalpNodeAffinity[Node-1] |= 1 << Number;
}

ULONG
HalpGetProcessorNumberByApicId(
    USHORT ApicId
    )
/*++

Routine Description:

    This routine returns the logical processor number for a given
    physical processor id (extended local sapic id)

Arguments:

    ApicId -- Extended ID of processor (16 bit id)

Return Value:

    Logical (NT) processor number

--*/

{
    ULONG index;

    for (index = 0; index < HalpMpInfo.ProcessorCount; index++) {

        if (ApicId == HalpProcessorInfo[index].LocalApicID) {

            return HalpProcessorInfo[index].NtProcessorNumber;
        }
    }

    ASSERT (index < HalpMpInfo.ProcessorCount);

    //
    // Note: The previous code returned an invalid index (HalpMpInfo.ProcessorCount
    // which is 1 greater than the number of processors) we should probably
    // just bugcheck here.
    //

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\ixhalt.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ixhalt.c

Abstract:

    Implements various ACPI utility functions.

Author:

	Todd Kjos (HP) (v-tkjos) 15-Jun-1998

	Based on i386 version by Jake Oshins (jakeo) 12-Feb-1997

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "acpitabl.h"
#include "xxacpi.h"
#include <inbv.h>

extern ULONG_PTR     KiBugCheckData[];
SLEEP_STATE_CONTEXT  HalpShutdownContext;


VOID
HaliHaltSystem (
    VOID
    )
/*++

Routine Description:

    This procedure is called when the machine has crashed and is to be
        halted

    N.B.

        Will NOT return.

--*/
{
#ifndef IA64
    for (; ;) {
        HalpCheckPowerButton();
        HalpYieldProcessor();
    }
#else
	HalDebugPrint(( HAL_ERROR, "HAL: HaliHaltSystem called -- in tight loop\n" ));
	for (;;) {}
#endif
}


VOID
HalpCheckPowerButton (
    VOID
    )
/*++

Routine Description:

    This procedure is called when the machine is spinning in the debugger,
    or has crashed and halted.

--*/
{
    USHORT                  Pm1Status, Pm1Control;
    SLEEP_STATE_CONTEXT     ShutdownContext;

    //
    // If there's been a bugcheck, or if the hal owns the display check
    // the fixed power button for an unconditional power off
    //

    if ((KiBugCheckData[0] || InbvCheckDisplayOwnership()) &&  HalpShutdownContext.AsULONG) {

        Pm1Status = (USHORT)HalpReadGenAddr(&HalpFixedAcpiDescTable.x_pm1a_evt_blk);
        if (HalpFixedAcpiDescTable.x_pm1b_evt_blk.Address.QuadPart) {
            Pm1Status |= (USHORT)HalpReadGenAddr(&HalpFixedAcpiDescTable.x_pm1b_evt_blk);
        }

        //
        // If the fixed button has been pushed, power off the system
        //

        if (Pm1Status & PM1_PWRBTN_STS) {
            //
            // Only do this once
            //

            ShutdownContext = HalpShutdownContext;
            HalpShutdownContext.AsULONG = 0;

            //
            // Disable & eoi all wake events
            //

            AcpiEnableDisableGPEvents(FALSE);
            HalpWriteGenAddr(&HalpFixedAcpiDescTable.x_pm1a_evt_blk, Pm1Status);
            if (HalpFixedAcpiDescTable.x_pm1b_evt_blk.Address.QuadPart) {
                HalpWriteGenAddr(&HalpFixedAcpiDescTable.x_pm1b_evt_blk, Pm1Status);
            }

            //
            // Power off
            //

            Pm1Control = (USHORT)HalpReadGenAddr(&HalpFixedAcpiDescTable.x_pm1a_ctrl_blk);
            Pm1Control = (USHORT) ((Pm1Control & CTL_PRESERVE) | (ShutdownContext.bits.Pm1aVal << SLP_TYP_SHIFT) | SLP_EN);
            HalpWriteGenAddr (&HalpFixedAcpiDescTable.x_pm1a_ctrl_blk, Pm1Control);

            if (HalpFixedAcpiDescTable.x_pm1b_ctrl_blk.Address.QuadPart) {
                Pm1Control = (USHORT)HalpReadGenAddr(&HalpFixedAcpiDescTable.x_pm1b_ctrl_blk);
                Pm1Control = (USHORT) ((Pm1Control & CTL_PRESERVE) | (ShutdownContext.bits.Pm1bVal << SLP_TYP_SHIFT) | SLP_EN);
                HalpWriteGenAddr(&HalpFixedAcpiDescTable.x_pm1b_ctrl_blk, Pm1Control);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\iosapic.h ===
/*++

Module Name:

   iosapic.h

Abstract:

   This module contains the definitions used by HAL to manipulate
   the IO SAPIC interrupt controller and SAPIC-specific constants.

Author:

   Todd Kjos (v-tkjos) 1-30-98

Environment:

   Kernel mode only.

Revision History:

--*/

#define STATIC

#include "halp.h"
#include "acpitabl.h"

//
// MPS INTi Flags related macros:
//
// Warning: these definitions do not consider the POLARITY or EL comformity with bus.
//

#define IS_LEVEL_TRIGGERED_MPS(vectorFlags) \
    ((vectorFlags & EL_LEVEL_TRIGGERED) == EL_LEVEL_TRIGGERED)

#define IS_EDGE_TRIGGERED_MPS(vectorFlags) \
    ((vectorFlags & EL_EDGE_TRIGGERED) == EL_EDGE_TRIGGERED)

#define IS_ACTIVE_LOW_MPS(vectorFlags) \
    ((vectorFlags & POLARITY_LOW) == POLARITY_LOW)

#define IS_ACTIVE_HIGH_MPS(vectorFlags) \
    ((vectorFlags & POLARITY_HIGH) == POLARITY_HIGH)

typedef struct {
    ULONG GlobalVector;     // This is Node+IDT vector value seen by kernel
    ULONG Vector;           // Bits 31:0 of the Rte entry (IDT vector+polarity...)
    ULONG Destination;      // Bits 63:32 of Rte entry
} IOSAPICINTI, *PIOSAPICINTI;

typedef struct _INTR_METHODS INTR_METHODS, *PINTR_METHODS;

typedef struct _IO_INTR_CONTROL IO_INTR_CONTROL, *PIO_INTR_CONTROL;

typedef VOID (*PINTRMETHOD) (PIO_INTR_CONTROL,ULONG);
typedef volatile ULONG * (*PGETEOI) (PIO_INTR_CONTROL);

struct _INTR_METHODS {
    PINTRMETHOD MaskEntry;
    PINTRMETHOD SetEntry;
    PINTRMETHOD EnableEntry;
};

//
// External interrupt controller structure.
//
struct _IO_INTR_CONTROL {
    ULONG IntiBase;
    ULONG IntiMax;
    ULONG InterruptAffinity;
    ULONG NextCpu;
    PVOID RegBaseVirtual;
    PHYSICAL_ADDRESS RegBasePhysical;
    PINTR_METHODS IntrMethods;
    PIO_INTR_CONTROL flink;
    IOSAPICINTI Inti[ANYSIZE_ARRAY];
};

extern struct _MPINFO HalpMpInfo;
extern PIO_INTR_CONTROL HalpIoSapicList;
extern INTR_METHODS HalpIoSapicMethods;

//
//  IO Unit definition
//
typedef struct {
    volatile ULONG RegisterSelect;  // Write register number to access register
    volatile ULONG Reserved1[3];
    volatile ULONG RegisterWindow;  // Data read/written here
    volatile ULONG Reserved2[3];
    volatile ULONG Reserved3[8];
    volatile ULONG Eoi;             // EOI register for level triggered interrupts
} IO_SAPIC_REGS, *PIO_SAPIC_REGS;

//
//  IO SAPIC Version Register
//

struct SapicVersion {
    UCHAR Version;              // either 0.x or 1.x
    UCHAR Reserved1;
    UCHAR MaxRedirEntries;      // Number of INTIs on unit
    UCHAR Reserved2;
};

typedef struct SapicVersion SAPIC_VERSION, *PSAPIC_VERSION;

BOOLEAN
HalpGetSapicInterruptDesc (
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN ULONG BusInterruptLevel,
    OUT PULONG SapicInti,
    OUT PKAFFINITY InterruptAffinity
    );

VOID
HalpSetInternalVector (
    IN ULONG    InternalVector,
    IN VOID   (*HalInterruptSerivceRoutine)(VOID)
    );

VOID
HalpEnableRedirEntry(
    ULONG Inti
    );

VOID
HalpDisableRedirEntry(
    ULONG Inti
    );

VOID
HalpWriteRedirEntry (
    IN ULONG  GlobalInterrupt,
    IN UCHAR  SapicVector,
    IN USHORT DestinationCPU,
    IN ULONG  Flags,
    IN ULONG  InterruptType
    );

BOOLEAN
HalpIsActiveLow(
    ULONG Inti
    );

BOOLEAN
HalpIsLevelTriggered(
    ULONG Inti
    );

VOID
HalpSetPolarity(
    ULONG Inti,
    BOOLEAN ActiveLow
    );

VOID
HalpSetLevel(
    ULONG Inti,
    BOOLEAN LevelTriggered
    );

//
// I/O SAPIC defines
//

#define IO_REGISTER_SELECT      0x00000000
#define IO_REGISTER_WINDOW      0x00000010
#define IO_EOI_REGISTER         0x00000040

#define IO_ID_REGISTER          0x00000000  // Exists, but ignored by SAPIC
#define IO_VERS_REGISTER        0x00000001
#define IO_REDIR_00_LOW         0x00000010
#define IO_REDIR_00_HIGH        0x00000011

#define IO_MAX_REDIR_MASK       0x00FF0000
#define IO_VERSION_MASK         0x000000FF

#define SAPIC_ID_MASK           0xFF000000
#define SAPIC_ID_SHIFT          24
#define SAPIC_EID_MASK          0x00FF0000
#define SAPIC_EID_SHIFT         16
#define SAPIC_XID_MASK          0xFFFF0000
#define SAPIC_XID_SHIFT         16

#define INT_VECTOR_MASK         0x000000FF
#define DELIVER_FIXED           0x00000000
#define DELIVER_LOW_PRIORITY    0x00000100
#define DELIVER_SMI             0x00000200
#define DELIVER_NMI             0x00000400
#define DELIVER_INIT            0x00000500
#define DELIVER_EXTINT          0x00000700
#define INT_TYPE_MASK           0x00000700
#define ACTIVE_LOW              0x00002000
#define ACTIVE_HIGH             0x00000000
#define LEVEL_TRIGGERED         0x00008000
#define EDGE_TRIGGERED          0x00000000
#define INTERRUPT_MASKED        0x00010000
#define INTERRUPT_MOT_MASKED    0x00000000

#define MAX_INTR_VECTOR 256
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\ixhwsup.c ===
/*++


Copyright (c) 1989  Microsoft Corporation

Module Name:

    ixhwsup.c

Abstract:

    This module contains the IoXxx routines for the NT I/O system that
    are hardware dependent.  Were these routines not hardware dependent,
    they would reside in the iosubs.c module.

Author:

    Darryl E. Havens (darrylh) 11-Apr-1990

Environment:

    Kernel mode

Revision History:


--*/

#include "halp.h"
#include "halpnpp.h"
#include "mca.h"


#define HAL_WCB_DRIVER_BUFFER    1

typedef struct _HAL_WAIT_CONTEXT_BLOCK {
    ULONG Flags;
    PMDL Mdl;
    PMDL DmaMdl;
    PVOID MapRegisterBase;
    PVOID CurrentVa;
    ULONG Length;
    ULONG NumberOfMapRegisters;
    union {
        struct {
            WAIT_CONTEXT_BLOCK Wcb;
            PDRIVER_LIST_CONTROL DriverExecutionRoutine;
            PVOID DriverContext;
            PIRP CurrentIrp;
            PADAPTER_OBJECT AdapterObject;
            BOOLEAN WriteToDevice;
        };

        SCATTER_GATHER_LIST ScatterGather;
    };
} HAL_WAIT_CONTEXT_BLOCK, *PHAL_WAIT_CONTEXT_BLOCK;


IO_ALLOCATION_ACTION
HalpAllocateAdapterCallback (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    );

VOID
HalpCopyBufferMap(
    IN PMDL Mdl,
    IN PTRANSLATION_ENTRY TranslationEntry,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice
    );

static KSPIN_LOCK HalpReservedPageLock;
static PVOID      HalpReservedPages = NULL;
static PFN_NUMBER HalpReservedPageMdl[(sizeof(MDL)/sizeof(PFN_NUMBER)) + 2];


VOID
HalpInitReservedPages(
    VOID
    )
/*++

Routine Description:

    Back pocket some PTEs so we can make forward progress during low
    memory conditions

Aruments:

    None

Reurn Value:

    None

--*/
{
    PMDL Mdl;

    HalpReservedPages = MmAllocateMappingAddress(PAGE_SIZE, HAL_POOL_TAG);

    ASSERT(HalpReservedPages);

    Mdl = (PMDL)&HalpReservedPageMdl;
    MmInitializeMdl(Mdl, NULL, PAGE_SIZE);
    Mdl->MdlFlags |= MDL_PAGES_LOCKED;

    KeInitializeSpinLock(&HalpReservedPageLock);
}


VOID
HalpCopyBufferMapSafe(
    IN PMDL Mdl,
    IN PTRANSLATION_ENTRY TranslationEntry,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice
    )
/*++

Routine Description:

    This routine copies the specific data between an unmapped user buffer
    and the map register buffer.  We will map and unmap each page of the
    transfer using our emergency reserved mapping

Arguments:

    Mdl - Pointer to the MDL that describes the pages of memory that are
          being read or written.

    TranslationEntry - The address of the base map register that has been
                       allocated to the device driver for use in mapping
                       the transfer.

    CurrentVa - Current virtual address in the buffer described by the MDL
                that the transfer is being done to or from.

    Length - The length of the transfer.  This determines the number of map
             registers that need to be written to map the transfer.

    WriteToDevice - Boolean value that indicates whether this is a write
                    to the device from memory (TRUE), or vice versa.

Return Value:

    STATUS_SUCCESS, or error

--*/
{
    PCCHAR bufferAddress;
    PCCHAR mapAddress;
    ULONG bytesLeft;
    ULONG bytesThisCopy;
    ULONG bufferPageOffset;
    PTRANSLATION_ENTRY translationEntry;
    KIRQL Irql;
    PMDL ReserveMdl;
    MEMORY_CACHING_TYPE MCFlavor;
    PPFN_NUMBER SrcPFrame;
    PPFN_NUMBER ReservePFrame;

    //
    // Synchronize access to our reserve page data structures
    //
    KeAcquireSpinLock(&HalpReservedPageLock, &Irql);

    //
    // Get local copies of Length and TranslationEntry as they will be
    // decremented/incremented respectively
    //
    bytesLeft = Length;
    translationEntry = TranslationEntry;

    //
    // Find the PFN in our caller's MDL that describes the first page in
    // physical memory that we need to access
    //
    SrcPFrame = (PPFN_NUMBER)(Mdl + 1);
    SrcPFrame += (((UINT_PTR)CurrentVa - (UINT_PTR)MmGetMdlBaseVa(Mdl)) >> PAGE_SHIFT);

    //
    // Initialize our reserve MDL's StartVa and ByteOffset
    //
    ReserveMdl = (PMDL)&HalpReservedPageMdl;
    ReservePFrame = (PPFN_NUMBER)(ReserveMdl + 1);
    ReserveMdl->StartVa = (PVOID)PAGE_ALIGN(CurrentVa);
    ReserveMdl->ByteOffset = BYTE_OFFSET(CurrentVa);
    ReserveMdl->ByteCount = PAGE_SIZE - ReserveMdl->ByteOffset;

    //
    // Copy the data one translation entry at a time.
    //
    while (bytesLeft > 0) {

        //
        // Copy current source PFN into our reserve MDL
        //      
        *ReservePFrame = *SrcPFrame;

        //
        // Enumerate thru cache flavors until we get our reserve mapping
        //
        bufferAddress = NULL;
        for (MCFlavor = MmNonCached;
             MCFlavor < MmMaximumCacheType;
             MCFlavor++) {
            
            bufferAddress =
                MmMapLockedPagesWithReservedMapping(HalpReservedPages,
                                                    HAL_POOL_TAG,
                                                    ReserveMdl,
                                                    MCFlavor);
            if (bufferAddress != NULL) {
                break;
            }
        }
        
        //
        // Could not establish a reserve mapping, we're totally screwed!
        //
        if (bufferAddress == NULL) {
            KeBugCheckEx(HAL_MEMORY_ALLOCATION,
                         PAGE_SIZE,
                         0xEF02,
                         (ULONG_PTR)__FILE__,
                         __LINE__
                         );
        }

        //
        // Find the buffer offset within the page
        //
        // N.B. bufferPageOffset can only be non-zero on the first iteration
        //
        bufferPageOffset = BYTE_OFFSET(bufferAddress);

        //
        // Copy from bufferAddress up to the next page boundary...
        //
        bytesThisCopy = PAGE_SIZE - bufferPageOffset;

        //
        // ...but no more than bytesLeft.
        //
        if (bytesThisCopy > bytesLeft) {
            bytesThisCopy = bytesLeft;
        }

        //
        // Calculate the base address of this translation entry and the
        // offset into it
        //
        mapAddress = (PCCHAR) translationEntry->VirtualAddress +
            bufferPageOffset;

        //
        // Copy up to one page
        //
        if (WriteToDevice) {
            RtlMoveMemory( mapAddress, bufferAddress, bytesThisCopy );

        } else {
            RtlMoveMemory( bufferAddress, mapAddress, bytesThisCopy );
        }

        //
        // Update locals and process the next translation entry
        //
        bytesLeft -= bytesThisCopy;
        translationEntry += 1;
        MmUnmapReservedMapping(HalpReservedPages, HAL_POOL_TAG, ReserveMdl);
        SrcPFrame++;
        ReserveMdl->ByteOffset = 0;
        (PCCHAR)ReserveMdl->StartVa += PAGE_SIZE;
        ReserveMdl->ByteCount = (PAGE_SIZE > bytesLeft) ? bytesLeft: PAGE_SIZE;
    }

    KeReleaseSpinLock(&HalpReservedPageLock, Irql);
}


VOID
HalpCopyBufferMap(
    IN PMDL Mdl,
    IN PTRANSLATION_ENTRY TranslationEntry,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN BOOLEAN WriteToDevice
    )

/*++

Routine Description:

    This routine copies the specific data between the user's buffer and the
    map register buffer.  First a the user buffer is mapped if necessary, then
    the data is copied.  Finally the user buffer will be unmapped if
    necessary.

Arguments:

    Mdl - Pointer to the MDL that describes the pages of memory that are
        being read or written.

    TranslationEntry - The address of the base map register that has been
        allocated to the device driver for use in mapping the transfer.

    CurrentVa - Current virtual address in the buffer described by the MDL
        that the transfer is being done to or from.

    Length - The length of the transfer.  This determines the number of map
        registers that need to be written to map the transfer.

    WriteToDevice - Boolean value that indicates whether this is a write
        to the device from memory (TRUE), or vice versa.

Return Value:

    None.

--*/
{
    PCCHAR bufferAddress;
    PCCHAR mapAddress;
    ULONG bytesLeft;
    ULONG bytesThisCopy;
    ULONG bufferPageOffset;
    PTRANSLATION_ENTRY translationEntry;
    
    //
    // Get the system address of the MDL, if we run out of PTEs try safe
    // method
    //
    bufferAddress = MmGetSystemAddressForMdlSafe(Mdl, HighPagePriority);
    
    if (bufferAddress == NULL) {
                                                                 
        //
        // Our caller's buffer is unmapped, and the memory manager is out
        // of PTEs, try to use reserve page method
        //
        if (HalpReservedPages != NULL) {
            HalpCopyBufferMapSafe(Mdl,
                                  TranslationEntry,
                                  CurrentVa,
                                  Length,
                                  WriteToDevice);
            return;
        }

        //
        // The DMA transfer cannot be completed, the system is now unstable
        //
        KeBugCheckEx(HAL_MEMORY_ALLOCATION,
                     PAGE_SIZE,
                     0xEF01,
                     (ULONG_PTR)__FILE__,
                     __LINE__
                     );
    }

    //
    // Calculate the actual start of the buffer based on the system VA and
    // the current VA.
    //

    bufferAddress += (PCCHAR) CurrentVa - (PCCHAR) MmGetMdlVirtualAddress(Mdl);

    //
    // Get local copies of Length and TranslationEntry as they will be
    // decremented/incremented respectively.
    //

    bytesLeft = Length;
    translationEntry = TranslationEntry;

    //
    // Copy the data one translation entry at a time.
    //

    while (bytesLeft > 0) {

        //
        // Find the buffer offset within the page.
        //
        // N.B. bufferPageOffset can only be non-zero on the first iteration.
        // 

        bufferPageOffset = BYTE_OFFSET(bufferAddress);

        //
        // Copy from bufferAddress up to the next page boundary...
        //

        bytesThisCopy = PAGE_SIZE - bufferPageOffset;

        //
        // ...but no more than bytesLeft.
        //

        if (bytesThisCopy > bytesLeft) {
            bytesThisCopy = bytesLeft;
        }

        //
        // Calculate the base address of this translation entry and the
        // offset into it.
        //

        mapAddress = (PCCHAR) translationEntry->VirtualAddress +
            bufferPageOffset;

        //
        // Copy up to one page.
        // 

        if (WriteToDevice) {

            RtlMoveMemory( mapAddress, bufferAddress, bytesThisCopy );

        } else {

            RtlMoveMemory( bufferAddress, mapAddress, bytesThisCopy );

        }

        //
        // Update locals and process the next translation entry.
        //

        bytesLeft -= bytesThisCopy;
        bufferAddress += bytesThisCopy;
        translationEntry += 1;
    }
}

PVOID
HalAllocateCommonBuffer(
    IN PADAPTER_OBJECT AdapterObject,
    IN ULONG Length,
    OUT PPHYSICAL_ADDRESS LogicalAddress,
    IN BOOLEAN CacheEnabled
    )
/*++

Routine Description:

    This function allocates the memory for a common buffer and maps it so that
    it can be accessed by a master device and the CPU.

Arguments:

    AdapterObject - Supplies a pointer to the adapter object used by this
                    device.

    Length - Supplies the length of the common buffer to be allocated.

    LogicalAddress - Returns the logical address of the common buffer.

    CacheEnable - Indicates whether the memeory is cached or not.

Return Value:

    Returns the virtual address of the common buffer.  If the buffer cannot be
    allocated then NULL is returned.

--*/

{
    PSINGLE_LIST_ENTRY virtualAddress;
    PHYSICAL_ADDRESS minPhysicalAddress;
    PHYSICAL_ADDRESS maxPhysicalAddress;
    PHYSICAL_ADDRESS logicalAddress;
    PHYSICAL_ADDRESS boundaryPhysicalAddress;
    ULONGLONG boundaryMask;

    UNREFERENCED_PARAMETER( CacheEnabled );

    //
    // Determine the maximum physical address that this adapter can handle.
    //

    minPhysicalAddress.QuadPart = 0;
    maxPhysicalAddress = HalpGetAdapterMaximumPhysicalAddress( AdapterObject );

    //
    // Determine the boundary mask for this adapter.
    //

    if (AdapterObject->MasterDevice) {

        //
        // This is not an ISA system.  The buffer must not cross a 4GB boundary.
        // It is predicted that most adapters are incapable of reliably
        // transferring across a 4GB boundary.
        //

        boundaryPhysicalAddress.QuadPart = 0x0000000100000000;
        boundaryMask = 0xFFFFFFFF00000000;

    } else {

        //
        // Common buffer cannot cross a 64K boundary.
        //

        boundaryPhysicalAddress.QuadPart = 0x10000;
        boundaryMask = 0xFFFFFFFFFFFF0000;
    }

    HalDebugPrint((HAL_INFO, "Allocate common buffer below %p\n", maxPhysicalAddress));

    //
    // Allocate a contiguous buffer.
    //

    virtualAddress = MmAllocateContiguousMemorySpecifyCache(
                        Length,
                        minPhysicalAddress,
                        maxPhysicalAddress,
                        boundaryPhysicalAddress,
                        MmCached );

    if (virtualAddress != NULL) {

        //
        // Got a buffer, get the physical/logical address and see if it
        // meets our conditions.
        //
    
        logicalAddress = MmGetPhysicalAddress( virtualAddress );

#if DBG
        ASSERT (((logicalAddress.QuadPart ^
             (logicalAddress.QuadPart + Length - 1)) & boundaryMask) == 0);
#endif
    
        *LogicalAddress = logicalAddress;
    }

    return virtualAddress;
}

BOOLEAN
HalFlushCommonBuffer(
    IN PADAPTER_OBJECT AdapterObject,
    IN ULONG Length,
    IN PHYSICAL_ADDRESS LogicalAddress,
    IN PVOID VirtualAddress
    )
/*++

Routine Description:

    This function is called to flush any hardware adapter buffers when the
    driver needs to read data written by an I/O master device to a common
    buffer.

Arguments:

    AdapterObject - Supplies a pointer to the adapter object used by this
        device.

    Length - Supplies the length of the common buffer. This should be the same
        value used for the allocation of the buffer.

    LogicalAddress - Supplies the logical address of the common buffer.  This
        must be the same value return by HalAllocateCommonBuffer.

    VirtualAddress - Supplies the virtual address of the common buffer.  This
        must be the same value return by HalAllocateCommonBuffer.

Return Value:

    Returns TRUE if no errors were detected.  Otherwise, FALSE is returned.

--*/

{
    UNREFERENCED_PARAMETER( AdapterObject );
    UNREFERENCED_PARAMETER( Length );
    UNREFERENCED_PARAMETER( LogicalAddress );
    UNREFERENCED_PARAMETER( VirtualAddress );

    return(TRUE);

}

VOID
HalFreeCommonBuffer(
    IN PADAPTER_OBJECT AdapterObject,
    IN ULONG Length,
    IN PHYSICAL_ADDRESS LogicalAddress,
    IN PVOID VirtualAddress,
    IN BOOLEAN CacheEnabled
    )
/*++

Routine Description:

    This function frees a common buffer and all of the resources it uses.

Arguments:

    AdapterObject - Supplies a pointer to the adapter object used by this
        device.

    Length - Supplies the length of the common buffer. This should be the same
        value used for the allocation of the buffer.

    LogicalAddress - Supplies the logical address of the common buffer.  This
        must be the same value returned by HalAllocateCommonBuffer.

    VirtualAddress - Supplies the virtual address of the common buffer.  This
        must be the same value returned by HalAllocateCommonBuffer.

    CacheEnable - Indicates whether the memory is cached or not.

Return Value:

    None

--*/

{
    UNREFERENCED_PARAMETER( AdapterObject );
    UNREFERENCED_PARAMETER( LogicalAddress );

    MmFreeContiguousMemorySpecifyCache(VirtualAddress,
                                       Length,
                                       MmCached);

}


NTSTATUS
HalCalculateScatterGatherListSize(
    IN PADAPTER_OBJECT AdapterObject,
    IN OPTIONAL PMDL Mdl,
    IN PVOID CurrentVa,
    IN ULONG Length,
    OUT PULONG  ScatterGatherListSize,
    OUT OPTIONAL PULONG pNumberOfMapRegisters
    )
/*++

Routine Description:

    This routine calculates the size of the scatter/gather list that
    needs to be allocated for a given virtual address range or MDL.

Arguments:

    AdapterObject - Pointer to the adapter control object to allocate to the
        driver.

    Mdl - Pointer to the MDL that describes the pages of memory that are being
        read or written.

    CurrentVa - Current virtual address in the buffer described by the MDL
        that the transfer is being done to or from.

    Length - Supplies the length of the transfer.

Return Value:

    Returns STATUS_SUCCESS unless too many map registers are requested or
    memory for the scatter/gather list could not be allocated.

Notes:

--*/
{
    PHAL_WAIT_CONTEXT_BLOCK WaitBlock;
    PMDL TempMdl;
    PSCATTER_GATHER_LIST ScatterGather;
    PSCATTER_GATHER_ELEMENT Element;
    ULONG NumberOfMapRegisters;
    ULONG ContextSize;
    ULONG TransferLength;
    ULONG MdlLength;
    PUCHAR MdlVa;
    NTSTATUS Status;
    ULONG PageOffset;

    if (ARGUMENT_PRESENT(Mdl)) {
        MdlVa = MmGetMdlVirtualAddress(Mdl);

        //
        // Calculate the number of required map registers.
        //

        TempMdl = Mdl;
        TransferLength = TempMdl->ByteCount - (ULONG)((PUCHAR) CurrentVa - MdlVa);
        MdlLength = TransferLength;

        PageOffset = BYTE_OFFSET(CurrentVa);
        NumberOfMapRegisters = 0;

        //
        // The virtual address should fit in the first MDL.
        //

        ASSERT((ULONG)((PUCHAR)CurrentVa - MdlVa) <= TempMdl->ByteCount);

        //
        // Loop through the any chained MDLs accumulating the the required
        // number of map registers.
        //

        while (TransferLength < Length && TempMdl->Next != NULL) {

            NumberOfMapRegisters += (PageOffset + MdlLength + PAGE_SIZE - 1) >>
                                        PAGE_SHIFT;

            TempMdl = TempMdl->Next;
            PageOffset = TempMdl->ByteOffset;
            MdlLength = TempMdl->ByteCount;
            TransferLength += MdlLength;
        }

        if ((TransferLength + PAGE_SIZE) < (Length + PageOffset )) {
            ASSERT(TransferLength >= Length);
            return(STATUS_BUFFER_TOO_SMALL);
        }

        //
        // Calculate the last number of map registers based on the requested
        // length not the length of the last MDL.
        //

        ASSERT( TransferLength <= MdlLength + Length );

        NumberOfMapRegisters += (PageOffset + Length + MdlLength - TransferLength +
                                 PAGE_SIZE - 1) >> PAGE_SHIFT;


        if (NumberOfMapRegisters > AdapterObject->MapRegistersPerChannel) {
            return(STATUS_INSUFFICIENT_RESOURCES);
        }

    } else {

        //
        // Determine the number of pages required to map the buffer described
        // by CurrentVa and Length.
        //

        NumberOfMapRegisters = ADDRESS_AND_SIZE_TO_SPAN_PAGES(CurrentVa, Length);
    }

    //
    // Calculate how much memory is required for the context structure.
    //

    ContextSize = NumberOfMapRegisters * sizeof( SCATTER_GATHER_ELEMENT ) +
                  sizeof( SCATTER_GATHER_LIST );

    //
    // If the adapter does not need map registers then most of this code
    // can be bypassed.  Just build the scatter/gather list and give it
    // to the caller.
    //

    if (AdapterObject->NeedsMapRegisters) {

        ContextSize += FIELD_OFFSET( HAL_WAIT_CONTEXT_BLOCK, ScatterGather );
        if (ContextSize < sizeof( HAL_WAIT_CONTEXT_BLOCK )) {
            ContextSize = sizeof( HAL_WAIT_CONTEXT_BLOCK );
        }
    }

    //
    // Return the list size.
    //

    *ScatterGatherListSize = ContextSize;
    if (pNumberOfMapRegisters) {
        *pNumberOfMapRegisters = NumberOfMapRegisters;
    }

    return( STATUS_SUCCESS );
}

NTSTATUS
HalGetScatterGatherList (
    IN PADAPTER_OBJECT AdapterObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN PMDL Mdl,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN PDRIVER_LIST_CONTROL ExecutionRoutine,
    IN PVOID Context,
    IN BOOLEAN WriteToDevice
    )
{
    return (HalBuildScatterGatherList(AdapterObject,
                              DeviceObject,
                              Mdl,
                              CurrentVa,
                              Length,
                              ExecutionRoutine,
                              Context,
                              WriteToDevice,
                              NULL,
                              0
                              ));
}

NTSTATUS
HalBuildScatterGatherList (
    IN PADAPTER_OBJECT AdapterObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN PMDL Mdl,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN PDRIVER_LIST_CONTROL ExecutionRoutine,
    IN PVOID Context,
    IN BOOLEAN WriteToDevice,
    IN PVOID ScatterGatherBuffer,
    IN ULONG ScatterGatherBufferLength
    )
/*++

Routine Description:

    This routine allocates the adapter channel specified by the adapter
    object.  Next a scatter/gather list is built based on the MDL, the
    CurrentVa and the requested Length.  Finally the driver's execution
    function is called with the scatter/gather list.  The adapter is
    released when after the execution function returns.

    The scatter/gather list is allocated if a buffer is not passed and is 
    freed by calling PutScatterGatherList. If a buffer is passed its used instead
    and this buffer is not freed in PutScatterGatherList.

Arguments:

    AdapterObject - Pointer to the adapter control object to allocate to the
        driver.

    DeviceObject - Pointer to the device object that is allocating the
        adapter.

    Mdl - Pointer to the MDL that describes the pages of memory that are being
        read or written.

    CurrentVa - Current virtual address in the buffer described by the MDL
        that the transfer is being done to or from.

    Length - Supplies the length of the transfer.

    ExecutionRoutine - The address of the driver's execution routine that is
        invoked once the adapter channel (and possibly map registers) have been
        allocated.

    Context - An untyped longword context parameter passed to the driver's
        execution routine.

    WriteToDevice - Supplies the value that indicates whether this is a
        write to the device from memory (TRUE), or vice versa.

Return Value:

    Returns STATUS_SUCCESS unless too many map registers are requested or
    memory for the scatter/gather list could not be allocated.

Notes:

    Note that this routine MUST be invoked at DISPATCH_LEVEL or above.

    The data in the buffer cannot be accessed until the put scatter/gather function has been called.

--*/

{
    PHAL_WAIT_CONTEXT_BLOCK WaitBlock;
    PMDL TempMdl;
    PSCATTER_GATHER_LIST ScatterGather;
    PSCATTER_GATHER_ELEMENT Element;
    ULONG NumberOfMapRegisters;
    ULONG ContextSize;
    ULONG TransferLength;
    ULONG MdlLength;
    PUCHAR MdlVa;
    NTSTATUS Status;
    PPFN_NUMBER PageFrame;
    ULONG PageOffset;

    if (!Mdl) {
        return (STATUS_INVALID_PARAMETER);
    }

    Status = HalCalculateScatterGatherListSize(AdapterObject,
                                                  Mdl,
                                                  CurrentVa,
                                                  Length,
                                                  &ContextSize,
                                                  &NumberOfMapRegisters 
                                                  );
    if (!NT_SUCCESS(Status)) {
        return (Status);
    }

    //
    // If the adapter does not need map registers then most of this code
    // can be bypassed.  Just build the scatter/gather list and give it
    // to the caller.
    //

    if (!AdapterObject->NeedsMapRegisters) {

        if (ScatterGatherBuffer) {

            if (ScatterGatherBufferLength < ContextSize) {
                return (STATUS_BUFFER_TOO_SMALL);
            }

            ScatterGather = ScatterGatherBuffer;

        } else {

            ScatterGather = ExAllocatePoolWithTag( NonPagedPool,
                                                   ContextSize,
                                                   HAL_POOL_TAG );
            if (ScatterGather == NULL) {
                return( STATUS_INSUFFICIENT_RESOURCES );
            }
        }

        MdlVa = MmGetMdlVirtualAddress(Mdl);

        ScatterGather->Reserved = 0;

        Element = ScatterGather->Elements;
        TempMdl = Mdl;
        TransferLength = Length;
        MdlLength = TempMdl->ByteCount - (ULONG)((PUCHAR) CurrentVa - MdlVa);
        PageOffset = BYTE_OFFSET(CurrentVa);

        //
        // Calculate where to start in the MDL.
        //

        PageFrame = (PPFN_NUMBER)(TempMdl+1);
        PageFrame += ((UINT_PTR) CurrentVa - ((UINT_PTR) MdlVa & ~(PAGE_SIZE - 1)))
                        >> PAGE_SHIFT;

        //
        // Loop build the list for each MDL.
        //

        while (TransferLength >  0) {

            if (MdlLength > TransferLength) {

                MdlLength = TransferLength;
            }

            TransferLength -= MdlLength;

            //
            // Loop building the list for the elements within the MDL.
            //

            while (MdlLength > 0) {

                //
                // Compute the starting address of the transfer.
                //

                Element->Address.QuadPart =
                    (ULONGLONG)((*PageFrame << PAGE_SHIFT) + PageOffset);

                Element->Length = PAGE_SIZE - PageOffset;

                if (Element->Length  > MdlLength ) {

                    Element->Length  = MdlLength;
                }

                ASSERT( (ULONG) MdlLength >= Element->Length );
                MdlLength -= Element->Length;

                //
                // Combine contiguous pages.
                //

                if (Element != ScatterGather->Elements ) {

                    if (Element->Address.QuadPart ==
                        (Element - 1)->Address.QuadPart + (Element - 1)->Length) {

                        //
                        // Add the new length to the old length.
                        //

                        (Element - 1)->Length += Element->Length;

                        //
                        // Reuse the current element.
                        //

                        Element--;
                    }
                }

                PageOffset = 0;
                Element++;
                PageFrame++;
            }


            if (TempMdl->Next == NULL) {

                //
                // There are a few cases where the buffer described by the MDL
                // is less than the transfer length.  This occurs when the
                // file system is transfering the last page of the file and
                // MM defines the MDL to be the file size and the file system
                // rounds the write up to a sector.  This extra should never
                // cross a page boundary.  Add this extra to the length of
                // the last element.
                //

                ASSERT(((Element - 1)->Length & (PAGE_SIZE - 1)) + TransferLength <= PAGE_SIZE );
                (Element - 1)->Length += TransferLength;

                break;
            }

            //
            // Advance to the next MDL.  Update the current VA and the MdlLength.
            //

            TempMdl = TempMdl->Next;
            PageOffset = MmGetMdlByteOffset(TempMdl);
            MdlLength = TempMdl->ByteCount;
            PageFrame = (PPFN_NUMBER)(TempMdl+1);

        }

        //
        // Set the number of elements actually used.
        //

        ScatterGather->NumberOfElements = (ULONG)(Element - ScatterGather->Elements);

        if (ScatterGatherBuffer) {
            ScatterGather->Reserved = HAL_WCB_DRIVER_BUFFER;
        }

        //
        // Call the driver with the scatter/gather list.
        //

        ExecutionRoutine( DeviceObject,
                          DeviceObject->CurrentIrp,
                          ScatterGather,
                          Context );

        return STATUS_SUCCESS;

    }

    if (ScatterGatherBuffer) {

        if (ScatterGatherBufferLength < ContextSize) {
            return (STATUS_BUFFER_TOO_SMALL);
        }

        WaitBlock = ScatterGatherBuffer;

    } else {
        WaitBlock = ExAllocatePoolWithTag(NonPagedPool, ContextSize, HAL_POOL_TAG);

        if (WaitBlock == NULL) {
            return( STATUS_INSUFFICIENT_RESOURCES );
        }
    }


    if (ScatterGatherBuffer) {
        WaitBlock->Flags |= HAL_WCB_DRIVER_BUFFER;
    } else {
        WaitBlock->Flags = 0;
    }

    //
    // Save the interesting data in the wait block.
    //

    WaitBlock->Mdl = Mdl;
    WaitBlock->DmaMdl = NULL;
    WaitBlock->CurrentVa = CurrentVa;
    WaitBlock->Length = Length;
    WaitBlock->DriverExecutionRoutine = ExecutionRoutine;
    WaitBlock->DriverContext = Context;
    WaitBlock->AdapterObject = AdapterObject;
    WaitBlock->WriteToDevice = WriteToDevice;
    WaitBlock->NumberOfMapRegisters = NumberOfMapRegisters;

    WaitBlock->Wcb.DeviceContext = WaitBlock;
    WaitBlock->Wcb.DeviceObject = DeviceObject;
    WaitBlock->Wcb.CurrentIrp = DeviceObject->CurrentIrp;


    //
    // Call the HAL to allocate the adapter channel.
    // HalpAllocateAdapterCallback will fill in the scatter/gather list.
    //

    Status = HalAllocateAdapterChannel( AdapterObject,
                                        &WaitBlock->Wcb,
                                        NumberOfMapRegisters,
                                        HalpAllocateAdapterCallback );

    //
    // If HalAllocateAdapterChannel failed then free the wait block.
    //

    if (!NT_SUCCESS( Status)) {
        ExFreePool( WaitBlock );
    }

    return( Status );
}



VOID
HalPutScatterGatherList (
    IN PADAPTER_OBJECT AdapterObject,
    IN PSCATTER_GATHER_LIST ScatterGather,
    IN BOOLEAN WriteToDevice
    )
/*++

Routine Description:

    This function frees the map registers allocated for the scatter gather list. It can also free the 
    scatter gather buffer and any associated MDLs.

Arguments:

    ScatterGather - The scatter gather buffer

    WriteToDevice - Supplies the value that indicates whether this is a
        write to the device from memory (TRUE), or vice versa.
    

Return Value:

    Returns a success or error status.

--*/
{
    PHAL_WAIT_CONTEXT_BLOCK WaitBlock = (PVOID) ScatterGather->Reserved;
    PTRANSLATION_ENTRY TranslationEntry;
    ULONG TransferLength;
    ULONG MdlLength;
    PMDL Mdl;
    PMDL tempMdl;
    PMDL nextMdl;
    PUCHAR CurrentVa;

    //
    // If the reserved field was empty then just free the list and return.
    //

    if (WaitBlock == NULL) {

        ASSERT(!AdapterObject->NeedsMapRegisters);
        ExFreePool( ScatterGather );
        return;

    }

    if (WaitBlock == (PVOID)HAL_WCB_DRIVER_BUFFER) {
        ASSERT(!AdapterObject->NeedsMapRegisters);
        return;
    }

    ASSERT( WaitBlock == CONTAINING_RECORD( ScatterGather, HAL_WAIT_CONTEXT_BLOCK, ScatterGather ));

    //
    // Setup for the first MDL.  We expect the MDL pointer to be pointing
    // at the first used mdl.
    //

    Mdl = WaitBlock->Mdl;
    CurrentVa = WaitBlock->CurrentVa;

#if DBG
    ASSERT( CurrentVa >= (PUCHAR) MmGetMdlVirtualAddress(Mdl));

    if (MmGetMdlVirtualAddress(Mdl) < (PVOID)((PUCHAR) MmGetMdlVirtualAddress(Mdl) + Mdl->ByteCount )) {

        ASSERT( CurrentVa < (PUCHAR) MmGetMdlVirtualAddress(Mdl) + Mdl->ByteCount );
    }
#endif

    MdlLength = Mdl->ByteCount - (ULONG)(CurrentVa - (PUCHAR) MmGetMdlVirtualAddress(Mdl));
    TransferLength = WaitBlock->Length;

    TranslationEntry = WaitBlock->MapRegisterBase;

    //
    // Loop through the used MDLs, calling IoFlushAdapterBuffers.
    //

    while (TransferLength >  0) {

        //
        // Do not perform a flush for buffers of zero length.
        //

        if (MdlLength > 0) {

            if (MdlLength > TransferLength) {
    
                MdlLength = TransferLength;
            }
    
            TransferLength -= MdlLength;
    
            IoFlushAdapterBuffers(  AdapterObject,
                                    Mdl,
                                    TranslationEntry,
                                    CurrentVa,
                                    MdlLength,
                                    WriteToDevice );
    
    
    
    
            TranslationEntry += ADDRESS_AND_SIZE_TO_SPAN_PAGES( CurrentVa,
                                                                MdlLength );
        }

        if (Mdl->Next == NULL) {
            break;
        }

        //
        // Advance to the next MDL.  Update the current VA and the MdlLength.
        //

        Mdl = Mdl->Next;
        CurrentVa = MmGetMdlVirtualAddress(Mdl);
        MdlLength = Mdl->ByteCount;
    }

    IoFreeMapRegisters( AdapterObject,
                        WaitBlock->MapRegisterBase,
                        WaitBlock->NumberOfMapRegisters
                        );

    if (WaitBlock->DmaMdl) {
        tempMdl = WaitBlock->DmaMdl;
        while (tempMdl) {
            nextMdl = tempMdl->Next;

            //
            // If the MDL was mapped by the driver unmap it here.
            //

            if (tempMdl->MdlFlags & MDL_MAPPED_TO_SYSTEM_VA) {
                MmUnmapLockedPages(tempMdl->MappedSystemVa, tempMdl);
            }
            IoFreeMdl(tempMdl);
            tempMdl = nextMdl;
        }
    }

    if (!(WaitBlock->Flags & HAL_WCB_DRIVER_BUFFER)) {
        ExFreePool( WaitBlock );
    }
}

IO_ALLOCATION_ACTION
HalpAllocateAdapterCallback (
    IN struct _DEVICE_OBJECT *DeviceObject,
    IN struct _IRP *Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the adapter object and map registers are
    available for the data transfer. This routines saves the map register
    base away.  If all of the required bases have not been saved then it
    returns. Otherwise it routine builds the entire scatter/gather
    list by calling IoMapTransfer.  After the list is build it is passed to
    the driver.

Arguments:

    DeviceObject - Pointer to the device object that is allocating the
        adapter.

    Irp - Supplies the map register offset assigned for this callback.

    MapRegisterBase - Supplies the map register base for use by the adapter
        routines.

    Context - Supplies a pointer to the xhal wait contorl block.

Return Value:

    Returns DeallocateObjectKeepRegisters.


--*/
{
    PHAL_WAIT_CONTEXT_BLOCK WaitBlock = Context;
    ULONG TransferLength;
    LONG MdlLength;
    PMDL Mdl;
    PUCHAR CurrentVa;
    PSCATTER_GATHER_LIST ScatterGather;
    PSCATTER_GATHER_ELEMENT Element;
    PTRANSLATION_ENTRY TranslationEntry = MapRegisterBase;
    PTRANSLATION_ENTRY NextEntry;
    PDRIVER_LIST_CONTROL DriverExecutionRoutine;
    PVOID DriverContext;
    PIRP CurrentIrp;
    PADAPTER_OBJECT AdapterObject;
    BOOLEAN WriteToDevice;

    //
    // Save the map register base.
    //

    WaitBlock->MapRegisterBase = MapRegisterBase;

    //
    // Save the data that will be over written by the scatter gather list.
    //

    DriverExecutionRoutine = WaitBlock->DriverExecutionRoutine;
    DriverContext = WaitBlock->DriverContext;
    CurrentIrp = WaitBlock->Wcb.CurrentIrp;
    AdapterObject = WaitBlock->AdapterObject;
    WriteToDevice = WaitBlock->WriteToDevice;

    //
    // Put the scatter gatther list after wait block. Add a back pointer to
    // the beginning of the wait block.
    //

    ScatterGather = &WaitBlock->ScatterGather;
    ScatterGather->Reserved = (UINT_PTR) WaitBlock;
    Element = ScatterGather->Elements;

    //
    // Setup for the first MDL.  We expect the MDL pointer to be pointing
    // at the first used MDL.
    //

    Mdl = WaitBlock->Mdl;
    CurrentVa = WaitBlock->CurrentVa;

#if DBG
    ASSERT( CurrentVa >= (PUCHAR) MmGetMdlVirtualAddress(Mdl));

    if (MmGetMdlVirtualAddress(Mdl) < (PVOID)((PUCHAR) MmGetMdlVirtualAddress(Mdl) + Mdl->ByteCount )) {

        ASSERT( CurrentVa < (PUCHAR) MmGetMdlVirtualAddress(Mdl) + Mdl->ByteCount );
    }
#endif

    MdlLength = Mdl->ByteCount - (ULONG)(CurrentVa - (PUCHAR) MmGetMdlVirtualAddress(Mdl));

    TransferLength = WaitBlock->Length;

    //
    // Loop building the list for each MDL.
    //

    while (TransferLength >  0) {

        if ((ULONG) MdlLength > TransferLength) {

            MdlLength = TransferLength;
        }

        TransferLength -= MdlLength;

        NextEntry = TranslationEntry;
        if (MdlLength > 0) {

            NextEntry +=  ADDRESS_AND_SIZE_TO_SPAN_PAGES( CurrentVa,
                                                          MdlLength );

        }

        //
        // Loop building the list for the elments within an MDL.
        //

        while (MdlLength > 0) {

            Element->Length = MdlLength;
            Element->Address = IoMapTransfer( AdapterObject,
                                              Mdl,
                                              MapRegisterBase,
                                              CurrentVa,
                                              &Element->Length,
                                              WriteToDevice );

            ASSERT( (ULONG) MdlLength >= Element->Length );
            MdlLength -= Element->Length;
            CurrentVa += Element->Length;
            Element++;
        }

        if (Mdl->Next == NULL) {

            //
            // There are a few cases where the buffer described by the MDL
            // is less than the transfer length.  This occurs when the
            // file system transfering the last page of file and MM defines
            // the MDL to be the file size and the file system rounds the write
            // up to a sector.  This extra should never cross a page
            // boundary.  Add this extra to the length of the last element.
            //

            ASSERT(((Element - 1)->Length & (PAGE_SIZE - 1)) + TransferLength <= PAGE_SIZE );
            (Element - 1)->Length += TransferLength;

            break;
        }

        //
        // Advance to the next MDL.  Update the current VA and the MdlLength.
        //

        Mdl = Mdl->Next;
        CurrentVa = MmGetMdlVirtualAddress(Mdl);
        MdlLength = Mdl->ByteCount;
        TranslationEntry = NextEntry;

    }

    //
    // Set the number of elements actually used.
    //

    ScatterGather->NumberOfElements = (ULONG)(Element - ScatterGather->Elements);

    //
    // Call the driver with the scatter/gather list.
    //

    DriverExecutionRoutine( DeviceObject,
                            CurrentIrp,
                            ScatterGather,
                            DriverContext );

    return( DeallocateObjectKeepRegisters );
}

VOID
IoFreeAdapterChannel(
    IN PADAPTER_OBJECT AdapterObject
    )

/*++

Routine Description:

    This routine is invoked to deallocate the specified adapter object.
    Any map registers that were allocated are also automatically deallocated.
    No checks are made to ensure that the adapter is really allocated to
    a device object.  However, if it is not, the kernel will bugcheck.

    If another device is waiting in the queue to allocate the adapter object
    it will be pulled from the queue and its execution routine will be
    invoked.

Arguments:

    AdapterObject - Pointer to the adapter object to be deallocated.

Return Value:

    None.

--*/

{
    PKDEVICE_QUEUE_ENTRY Packet;
    PWAIT_CONTEXT_BLOCK Wcb;
    PADAPTER_OBJECT MasterAdapter;
    BOOLEAN Busy = FALSE;
    IO_ALLOCATION_ACTION Action;
    KIRQL Irql;
    LONG MapRegisterNumber;

    //
    // Begin by getting the address of the master adapter.
    //

    MasterAdapter = AdapterObject->MasterAdapter;

    //
    // Pull requests of the adapter's device wait queue as long as the
    // adapter is free and there are sufficient map registers available.
    //

    while( TRUE ) {

       //
       // Begin by checking to see whether there are any map registers that
       // need to be deallocated.  If so, then deallocate them now.
       //

       if (AdapterObject->NumberOfMapRegisters != 0) {
           IoFreeMapRegisters( AdapterObject,
                               AdapterObject->MapRegisterBase,
                               AdapterObject->NumberOfMapRegisters
                               );
       }

       //
       // Simply remove the next entry from the adapter's device wait queue.
       // If one was successfully removed, allocate any map registers that it
       // requires and invoke its execution routine.
       //

       Packet = KeRemoveDeviceQueue( &AdapterObject->ChannelWaitQueue );
       if (Packet == NULL) {

           //
           // There are no more requests - break out of the loop.
           //

           break;
       }

       Wcb = CONTAINING_RECORD( Packet,
            WAIT_CONTEXT_BLOCK,
            WaitQueueEntry );

       AdapterObject->CurrentWcb = Wcb;
       AdapterObject->NumberOfMapRegisters = Wcb->NumberOfMapRegisters;

        //
        // Check to see whether this driver wishes to allocate any map
        // registers.  If so, then queue the device object to the master
        // adapter queue to wait for them to become available.  If the driver
        // wants map registers, ensure that this adapter has enough total
        // map registers to satisfy the request.
        //

        if (Wcb->NumberOfMapRegisters != 0 &&
            AdapterObject->MasterAdapter != NULL) {

            //
            // Lock the map register bit map and the adapter queue in the
            // master adapter object. The channel structure offset is used as
            // a hint for the register search.
            //

            KeAcquireSpinLock( &MasterAdapter->SpinLock, &Irql );

            MapRegisterNumber = -1;

            if (IsListEmpty( &MasterAdapter->AdapterQueue)) {
               MapRegisterNumber = RtlFindClearBitsAndSet( MasterAdapter->MapRegisters,
                                                        Wcb->NumberOfMapRegisters,
                                                        0
                                                        );
            }
            if (MapRegisterNumber == -1) {

               //
               // There were not enough free map registers.  Queue this request
               // on the master adapter where it will wait until some registers
               // are deallocated.
               //

               InsertTailList( &MasterAdapter->AdapterQueue,
                               &AdapterObject->AdapterQueue
                               );
               Busy = 1;

            } else {

                AdapterObject->MapRegisterBase = ((PTRANSLATION_ENTRY)
                    MasterAdapter->MapRegisterBase + MapRegisterNumber);

                //
                // Set the no scatter/gather flag if scatter/gather is not
                // supported.
                //

                if (!AdapterObject->ScatterGather) {

                    AdapterObject->MapRegisterBase = (PVOID)
                        ((UINT_PTR) AdapterObject->MapRegisterBase | NO_SCATTER_GATHER);

                }
            }

            KeReleaseSpinLock( &MasterAdapter->SpinLock, Irql );

        } else {

            AdapterObject->MapRegisterBase = NULL;
            AdapterObject->NumberOfMapRegisters = 0;

        }

        //
        // If there were either enough map registers available or no map
        // registers needed to be allocated, invoke the driver's execution
        // routine now.
        //

        if (!Busy) {
            AdapterObject->CurrentWcb = Wcb;
            Action = Wcb->DeviceRoutine( Wcb->DeviceObject,
                Wcb->CurrentIrp,
                AdapterObject->MapRegisterBase,
                Wcb->DeviceContext );

            //
            // If the execution routine would like to have the adapter
            // deallocated, then release the adapter object.
            //

            if (Action == KeepObject) {

               //
               // This request wants to keep the channel a while so break
               // out of the loop.
               //

               break;

            }

            //
            // If the driver wants to keep the map registers then set the
            // number allocated to 0.  This keeps the deallocation routine
            // from deallocating them.
            //

            if (Action == DeallocateObjectKeepRegisters) {
                AdapterObject->NumberOfMapRegisters = 0;
            }

        } else {

           //
           // This request did not get the requested number of map registers so
           // break out of the loop.
           //

           break;
        }
    }
}

VOID
IoFreeMapRegisters(
   PADAPTER_OBJECT AdapterObject,
   PVOID MapRegisterBase,
   ULONG NumberOfMapRegisters
   )
/*++

Routine Description:

    If NumberOfMapRegisters != 0, this routine deallocates the map registers
    for the adapter.

    If there are any queued adapters waiting then an attempt is made to allocate
    the next entry.

Arguments:

    AdapterObject - The adapter object where the map registers should be
        returned to.

    MapRegisterBase - The map register base of the registers to be deallocated.

    NumberOfMapRegisters - The number of registers to be deallocated.

Return Value:

    None

--+*/
{
    PADAPTER_OBJECT MasterAdapter;
    LONG MapRegisterNumber;
    PWAIT_CONTEXT_BLOCK Wcb;
    PLIST_ENTRY Packet;
    IO_ALLOCATION_ACTION Action;
    KIRQL Irql;

    //
    // Begin by getting the address of the master adapter.
    //

    if (AdapterObject->MasterAdapter != NULL && MapRegisterBase != NULL) {

        MasterAdapter = AdapterObject->MasterAdapter;

    } else {

        //
        // There are no map registers to return.
        //

        return;
    }

    if (NumberOfMapRegisters != 0) {

        //
        // Strip the no scatter/gather flag.
        //
        
        MapRegisterBase = (PVOID) ((UINT_PTR) MapRegisterBase & ~NO_SCATTER_GATHER);
        
        MapRegisterNumber = (LONG)((PTRANSLATION_ENTRY) MapRegisterBase -
             (PTRANSLATION_ENTRY) MasterAdapter->MapRegisterBase);
        
        //
        // Acquire the master adapter spinlock which locks the adapter queue and the
        // bit map for the map registers.
        //
        
        KeAcquireSpinLock(&MasterAdapter->SpinLock, &Irql);
        
        //
        // Return the registers to the bit map.
        //
        
        RtlClearBits( MasterAdapter->MapRegisters,
                      MapRegisterNumber,
                      NumberOfMapRegisters
                      );

    } else {

        KeAcquireSpinLock(&MasterAdapter->SpinLock, &Irql);
    }
   

    //
    // Process any requests waiting for map registers in the adapter queue.
    // Requests are processed until a request cannot be satisfied or until
    // there are no more requests in the queue.
    //

    while(TRUE) {

        if ( IsListEmpty(&MasterAdapter->AdapterQueue) ){
            break;
        }

        Packet = RemoveHeadList( &MasterAdapter->AdapterQueue );
        AdapterObject = CONTAINING_RECORD( Packet,
                                         ADAPTER_OBJECT,
                                         AdapterQueue
                                         );
        Wcb = AdapterObject->CurrentWcb;

        //
        // Attempt to allocate map registers for this request. Use the previous
        // register base as a hint.
        //

        MapRegisterNumber = RtlFindClearBitsAndSet( MasterAdapter->MapRegisters,
                                               AdapterObject->NumberOfMapRegisters,
                                               MasterAdapter->NumberOfMapRegisters
                                               );

        if (MapRegisterNumber == -1) {

            //
            // There were not enough free map registers.  Put this request back on
            // the adapter queue where is came from.
            //

            InsertHeadList( &MasterAdapter->AdapterQueue,
                         &AdapterObject->AdapterQueue
                         );

            break;

        }

        KeReleaseSpinLock( &MasterAdapter->SpinLock, Irql );

        AdapterObject->MapRegisterBase = (PVOID) ((PTRANSLATION_ENTRY)
                         MasterAdapter->MapRegisterBase + MapRegisterNumber);

        //
        // Set the no scatter/gather flag if scatter/gather not
        // supported.
        //

        if (!AdapterObject->ScatterGather) {

            AdapterObject->MapRegisterBase = (PVOID)
                   ((UINT_PTR) AdapterObject->MapRegisterBase | NO_SCATTER_GATHER);

        }

        //
        // Invoke the driver's execution routine now.
        //

        Action = Wcb->DeviceRoutine( Wcb->DeviceObject,
                                     Wcb->CurrentIrp,
                                     AdapterObject->MapRegisterBase,
                                     Wcb->DeviceContext );

        //
        // If the driver wishes to keep the map registers then set the number
        // allocated to zero and set the action to deallocate object.
        //

        if (Action == DeallocateObjectKeepRegisters) {
            AdapterObject->NumberOfMapRegisters = 0;
            Action = DeallocateObject;
        }

        //
        // If the driver would like to have the adapter deallocated,
        // then deallocate any map registers allocated and then release
        // the adapter object.
        //

        if (Action == DeallocateObject) {

            //
            // The map registers registers are deallocated here rather than in
            // IoFreeAdapterChannel.  This limits the number of times
            // this routine can be called recursively possibly overflowing
            // the stack.  The worst case occurs if there is a pending
            // request for the adapter that uses map registers and whos
            // excution routine decallocates the adapter.  In that case if there
            // are no requests in the master adapter queue, then IoFreeMapRegisters
            // will get called again.
            //

            if (AdapterObject->NumberOfMapRegisters != 0) {

                //
                // Deallocate the map registers and clear the count so that
                // IoFreeAdapterChannel will not deallocate them again.
                //

                KeAcquireSpinLock( &MasterAdapter->SpinLock, &Irql);

                RtlClearBits( MasterAdapter->MapRegisters,
                           MapRegisterNumber,
                           AdapterObject->NumberOfMapRegisters
                           );

                AdapterObject->NumberOfMapRegisters = 0;

                KeReleaseSpinLock( &MasterAdapter->SpinLock, Irql );
            }

            IoFreeAdapterChannel( AdapterObject );
        }

        KeAcquireSpinLock( &MasterAdapter->SpinLock, &Irql);

    }

    KeReleaseSpinLock( &MasterAdapter->SpinLock, Irql );
}

VOID
HalPutDmaAdapter(
    IN PADAPTER_OBJECT AdapterObject
    )
/*++

Routine Description:

    This routine frees the DMA adapter.

Arguments:

    AdapterObject - Supplies a pointer to the DMA adapter to be freed.

Return Value:

    None.


--*/
{

    ASSERT( AdapterObject->ChannelNumber == 0xFF );

    //
    // This adapter can be freed if the channel number is zero and
    // it is not the channel zero adapter.
    //

    if ( AdapterObject->ChannelNumber == 0xFF ) {

        ObDereferenceObject( AdapterObject );
    }
}

struct _DMA_ADAPTER *
HaliGetDmaAdapter(
    IN PVOID Context,
    IN struct _DEVICE_DESCRIPTION *DeviceDescriptor,
    OUT PULONG NumberOfMapRegisters
    )
/*++

Routine Description:

    This function is a wrapper for HalGetAdapter.  Is is called through
    the HAL dispatch table.

Arguments:

    Context - Unused.

    DeviceDescriptor - Supplies the device descriptor used to allocate the dma
        adapter object.

    NubmerOfMapRegisters - Returns the maximum number of map registers a device
        can allocate at one time.

Return Value:

    Returns a DMA adapter or NULL.

--*/
{
    return (PDMA_ADAPTER) HalGetAdapter( DeviceDescriptor, NumberOfMapRegisters );

}

NTSTATUS
HalBuildMdlFromScatterGatherList(
    IN PADAPTER_OBJECT AdapterObject,
    IN PSCATTER_GATHER_LIST ScatterGather,
    IN PMDL OriginalMdl,
    OUT PMDL *TargetMdl
    )
/*++

Routine Description:

    This function builds an MDL from the scatter gather list. This is so if a driver wants to 
    construct a virtual address for the DMA buffer and write to it. The target MDL is freed when the 
    caller calls HalPutScatterGatherList.

Arguments:

    ScatterGather - The scatter gather buffer from which to build the MDL.

    OriginalMdl  - The MDL used to build the scatter gather list (using HalGet or HalBuild API)
    
    TargetMdl - Returns the new MDL in this.
    

Return Value:

    Returns a success or error status.

--*/
{
    PMDL    tempMdl;
    PMDL    newMdl;
    PMDL    targetMdl;
    PMDL    prevMdl;
    PMDL    nextMdl;
    CSHORT  mdlFlags;
    PHAL_WAIT_CONTEXT_BLOCK WaitBlock = (PVOID) ScatterGather->Reserved;
    ULONG    i,j;
    PSCATTER_GATHER_ELEMENT element;
    PPFN_NUMBER  pfnArray;
    PFN_NUMBER  pageFrame;
    ULONG   nPages;

    if (!OriginalMdl) {
        return  STATUS_INVALID_PARAMETER;
    }

    if (!AdapterObject->NeedsMapRegisters) {
        *TargetMdl = OriginalMdl;
        return STATUS_SUCCESS;
    }

    //
    // If this API is called more than once 
    if (WaitBlock && WaitBlock->DmaMdl) {
        return (STATUS_NONE_MAPPED);
    }

    //
    // Allocate a chain of target MDLs
    //

    prevMdl = NULL;
    targetMdl = NULL;

    for (tempMdl = OriginalMdl; tempMdl; tempMdl = tempMdl->Next) {

        PVOID va;
        ULONG byteCount;

        if(tempMdl == OriginalMdl) {
            va = WaitBlock->CurrentVa;
            byteCount = MmGetMdlByteCount(tempMdl);
        } else {
            va = MmGetMdlVirtualAddress(tempMdl);
            byteCount = MmGetMdlByteCount(tempMdl);
        }

        newMdl = IoAllocateMdl(va, byteCount, FALSE, FALSE, NULL);

        
        if (!newMdl) {

            //
            // Clean up previous allocated MDLs
            //

            tempMdl = targetMdl;
            while (tempMdl) {
                nextMdl = tempMdl->Next;
                IoFreeMdl(tempMdl);
                tempMdl = nextMdl;
            }

            return (STATUS_INSUFFICIENT_RESOURCES);
        }
        if (!prevMdl) {
            prevMdl = newMdl;
            targetMdl = newMdl;
        } else {
            prevMdl->Next = newMdl;
            prevMdl = newMdl;
        }
    }


    tempMdl = OriginalMdl;

    element = ScatterGather->Elements;
    for (tempMdl = targetMdl; tempMdl; tempMdl = tempMdl->Next) {

        targetMdl->MdlFlags |= MDL_PAGES_LOCKED;
        pfnArray = MmGetMdlPfnArray(tempMdl);

        for (i = 0; i < ScatterGather->NumberOfElements; i++, element++) {
            nPages = BYTES_TO_PAGES(BYTE_OFFSET(element->Address.QuadPart) + element->Length);

            pageFrame = (ULONG)(element->Address.QuadPart >> PAGE_SHIFT);
            for (j = 0; j < nPages; j++) {
                *pfnArray = pageFrame + j;
                pfnArray++;
                ASSERT((PVOID)pfnArray <= (PVOID)((PCHAR)tempMdl + tempMdl->Size));
            }
        }
    }

    *TargetMdl = targetMdl;
    if (WaitBlock) {
        WaitBlock->DmaMdl = targetMdl;
    }
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\ia64prof.h ===
#ifndef IA64PROF_H_INCLUDED
#define IA64PROF_H_INCLUDED

/*++

Copyright (c) 1989-2000  Microsoft Corporation

Component Name:

    IA64 Profiling

Module Name:

    ia64prof.h

Abstract:

    This header file presents the IA64 specific profiling definitions 

Author:

    David N. Cutler (davec) 5-Mar-1989

Environment:

    ToBeSpecified

Revision History:

    3/15/2000 Thierry Fevrier (v-thief@microsoft.com):

         Initial version

--*/

//
// Warning: The definition of HALPROFILE_PCR should match the HalReserved[] type definition
//          and the PROCESSOR_PROFILING_INDEX based indexes.
//

//
// IA64 Generic - Number of PMCs / PMDs pairs.
//

#define PROCESSOR_IA64_PERFCOUNTERS_PAIRS  4

typedef struct _HALPROFILE_PCR {
    ULONGLONG ProfilingRunning;
    ULONGLONG ProfilingInterruptHandler;    
    ULONGLONG ProfilingInterrupts;                  // XXTF - DEBUG
    ULONGLONG ProfilingInterruptsWithoutProfiling;  // XXTF - DEBUG
    ULONGLONG ProfileSource [ PROCESSOR_IA64_PERFCOUNTERS_PAIRS ];
    ULONGLONG PerfCnfg      [ PROCESSOR_IA64_PERFCOUNTERS_PAIRS ];
    ULONGLONG PerfData      [ PROCESSOR_IA64_PERFCOUNTERS_PAIRS ];
    ULONGLONG PerfCnfgReload[ PROCESSOR_IA64_PERFCOUNTERS_PAIRS ];
    ULONGLONG PerfDataReload[ PROCESSOR_IA64_PERFCOUNTERS_PAIRS ];
} HALPROFILE_PCR, *PHALPROFILE_PCR;

#define HALPROFILE_PCR  ( (PHALPROFILE_PCR)(&(PCR->HalReserved[PROCESSOR_PROFILING_INDEX])) )

//
// Define space in the HAL-reserved part of the PCR structure for each
// performance counter's interval count
//
// Note that i64prfs.s depends on these positions in the PCR.
//

//
// Per-Processor Profiling Status
//

#define HalpProfilingRunning          HALPROFILE_PCR->ProfilingRunning

//
// Per-Processor registered Profiling Interrupt Handler
//

#define HalpProfilingInterruptHandler HALPROFILE_PCR->ProfilingInterruptHandler

//
// Per-Processor Profiling Interrupts Status
//

#define HalpProfilingInterrupts                  HALPROFILE_PCR->ProfilingInterrupts
#define HalpProfilingInterruptsWithoutProfiling  HALPROFILE_PCR->ProfilingInterruptsWithoutProfiling

//
// Define the currently selected profile source for each counter
//
// FIXFIX - Merced Specific.

#define HalpProfileSource4     (KPROFILE_SOURCE)HALPROFILE_PCR->ProfileSource[0]  // PMC4
#define HalpProfileSource5     (KPROFILE_SOURCE)HALPROFILE_PCR->ProfileSource[1]  // PMC5
#define HalpProfileSource6     (KPROFILE_SOURCE)HALPROFILE_PCR->ProfileSource[2]  // PMC6
#define HalpProfileSource7     (KPROFILE_SOURCE)HALPROFILE_PCR->ProfileSource[3]  // PMC7

#define PCRProfileCnfg4        ( (PULONGLONG) (&(HALPROFILE_PCR->PerfCnfg[0])) )
#define PCRProfileCnfg5        ( (PULONGLONG) (&(HALPROFILE_PCR->PerfCnfg[1])) )
#define PCRProfileCnfg6        ( (PULONGLONG) (&(HALPROFILE_PCR->PerfCnfg[2])) )
#define PCRProfileCnfg7        ( (PULONGLONG) (&(HALPROFILE_PCR->PerfCnfg[3])) )

#define PCRProfileData4        ( (PULONGLONG) (&(HALPROFILE_PCR->PerfData[0])) )
#define PCRProfileData5        ( (PULONGLONG) (&(HALPROFILE_PCR->PerfData[1])) )
#define PCRProfileData6        ( (PULONGLONG) (&(HALPROFILE_PCR->PerfData[2])) )
#define PCRProfileData7        ( (PULONGLONG) (&(HALPROFILE_PCR->PerfData[3])) )

#define PCRProfileCnfg4Reload  ( (PULONGLONG) (&(HALPROFILE_PCR->PerfCnfgReload[0])) )
#define PCRProfileCnfg5Reload  ( (PULONGLONG) (&(HALPROFILE_PCR->PerfCnfgReload[1])) )
#define PCRProfileCnfg6Reload  ( (PULONGLONG) (&(HALPROFILE_PCR->PerfCnfgReload[2])) )
#define PCRProfileCnfg7Reload  ( (PULONGLONG) (&(HALPROFILE_PCR->PerfCnfgReload[3])) )

#define PCRProfileData4Reload  ( (PULONGLONG) (&(HALPROFILE_PCR->PerfCnfgReload[0])) )
#define PCRProfileData5Reload  ( (PULONGLONG) (&(HALPROFILE_PCR->PerfDataReload[1])) )
#define PCRProfileData6Reload  ( (PULONGLONG) (&(HALPROFILE_PCR->PerfDataReload[2])) )
#define PCRProfileData7Reload  ( (PULONGLONG) (&(HALPROFILE_PCR->PerfDataReload[3])) )

//
// IA64 Monitored Events have 
//
// FIXFIX - Merced Specific.

typedef enum _PMCD_SOURCE_MASK {
    PMCD_MASK_4    = 0x1,
    PMCD_MASK_5    = 0x2,
    PMCD_MASK_6    = 0x4,
    PMCD_MASK_7    = 0x8,
    PMCD_MASK_45   = (PMCD_MASK_4 | PMCD_MASK_5),
    PMCD_MASK_4567 = (PMCD_MASK_4 | PMCD_MASK_5 | PMCD_MASK_6 | PMCD_MASK_7)
} PMCD_SOURCE_MASK;

//
// Define the mapping between possible profile sources and the
// CPU-specific settings for the IA64 specific Event Counters.
//

typedef struct _HALP_PROFILE_MAPPING {
    BOOLEAN   Supported;
    ULONG     Event;
    ULONG     ProfileSource;
    ULONG     ProfileSourceMask;
    ULONGLONG Interval;
    ULONGLONG DefInterval;           // Default or Desired Interval
    ULONGLONG MaxInterval;           // Maximum Interval
    ULONGLONG MinInterval;           // Maximum Interval
} HALP_PROFILE_MAPPING, *PHALP_PROFILE_MAPPING;

/////////////
//
// XXTF - ToBeDone - 02/08/2000.
// The following section should provide the IA64 PMC APIs.
// These should be considered as inline versions of the Halp*ProfileCounter*() 
// functions. This will allow user application to use standardized APIs to 
// program the performance monitor counters.
//

// HalpSetProfileCounterConfiguration()
// HalpSetProfileCounterPrivilegeLevelMask()

typedef enum _PMC_PLM_MASK {
    PMC_PLM_NONE = 0x0,
    PMC_PLM_0    = 0x1,
    PMC_PLM_1    = 0x2,
    PMC_PLM_2    = 0x4,
    PMC_PLM_3    = 0x8,
    PMC_PLM_ALL  = (PMC_PLM_3|PMC_PLM_2|PMC_PLM_1|PMC_PLM_0)
} PMC_PLM_MASK;

// HalpSetProfileCounterConfiguration()

typedef enum _PMC_NAMESPACE {
    PMC_DISABLE_OVERFLOW_INTERRUPT = 0x0,
    PMC_ENABLE_OVERFLOW_INTERRUPT  = 0x1,
    PMC_DISABLE_PRIVILEGE_MONITOR  = 0x0,
    PMC_ENABLE_PRIVILEGE_MONITOR   = 0x1    
} PMC_NAMESPACE;

// HalpSetProfileCounterConfiguration()
// HalpSetProfileCounterInstructionSetMask()

typedef enum _PMC_INSTRUCTION_SET_MASK {
    PMC_ISM_ALL  = 0x0,
    PMC_ISM_IA64 = 0x1,
    PMC_ISM_IA32 = 0x2,
    PMC_ISM_NONE = 0x3
} PMC_INSTRUCTION_SET_MASK;

//
////////////

#endif /* IA64PROF_H_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\ixisa.h ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ixisa.h

Abstract:

    This header file defines the private Hardware Architecture Layer (HAL)
    EISA/ISA specific interfaces, defines and structures.

Author:

    Jeff Havens (jhavens) 20-Jun-91

Revision History:

--*/

#ifndef _IXISA_
#define _IXISA_


//
// The MAXIMUM_MAP_BUFFER_SIZE defines the maximum map buffers which the system
// will allocate for devices which require phyically contigous buffers.
//

#define MAXIMUM_ISA_MAP_BUFFER_SIZE      0x40000
#define MAXIMUM_MAP_BUFFER_SIZE          MAXIMUM_ISA_MAP_BUFFER_SIZE

//
// MAXIMUM_PCI_MAP_BUFFER_SIZE defines the maximum map buffers which the system
// will allocate for 32-bit PCI devices on a 64-bit system.
//

#define MAXIMUM_PCI_MAP_BUFFER_SIZE  (64 * 1024 * 1024)

//
// Define the initial buffer allocation size for a map buffers for systems with
// no memory which has a physical address greater than MAXIMUM_PHYSICAL_ADDRESS.
//

#define INITIAL_MAP_BUFFER_SMALL_SIZE 0x10000

//
// Define the initial buffer allocation size for a map buffers for systems with
// no memory which has a physical address greater than MAXIMUM_PHYSICAL_ADDRESS.
//

#define INITIAL_MAP_BUFFER_LARGE_SIZE 0x30000

//
// Define the incremental buffer allocation for a map buffers.
//

#define INCREMENT_MAP_BUFFER_SIZE 0x10000

//
// Define the maximum number of map registers that can be requested at one time
// if actual map registers are required for the transfer.
//

#define MAXIMUM_ISA_MAP_REGISTER  16

#define MAXIMUM_PCI_MAP_REGISTER  16

//
// Define the maximum physical address which can be handled by an Isa card
//

#define MAXIMUM_PHYSICAL_ADDRESS 0xffffffff

//
// Define the scatter/gather flag for the Map Register Base.
//

#define NO_SCATTER_GATHER 0x00000001

//
// Define the copy buffer flag for the index.
//

#define COPY_BUFFER 0XFFFFFFFF

//
// Define adapter object structure.
//

typedef struct _ADAPTER_OBJECT {
    DMA_ADAPTER DmaHeader;
    struct _ADAPTER_OBJECT *MasterAdapter;
    ULONG MapRegistersPerChannel;
    PVOID AdapterBaseVa;
    PVOID MapRegisterBase;
    ULONG NumberOfMapRegisters;
    ULONG CommittedMapRegisters;
    struct _WAIT_CONTEXT_BLOCK *CurrentWcb;
    KDEVICE_QUEUE ChannelWaitQueue;
    PKDEVICE_QUEUE RegisterWaitQueue;
    LIST_ENTRY AdapterQueue;
    KSPIN_LOCK SpinLock;
    PRTL_BITMAP MapRegisters;
    PUCHAR PagePort;
    UCHAR ChannelNumber;
    UCHAR AdapterNumber;
    USHORT DmaPortAddress;
    UCHAR AdapterMode;
    BOOLEAN NeedsMapRegisters;
    BOOLEAN MasterDevice;
    BOOLEAN Width16Bits;
    BOOLEAN ScatterGather;
    BOOLEAN IgnoreCount;
    BOOLEAN Dma32BitAddresses;
    BOOLEAN Dma64BitAddresses;
} ADAPTER_OBJECT;

ULONG 
HalGetDmaAlignment (
    PVOID Conext
    );

NTSTATUS
HalCalculateScatterGatherListSize(
    IN PADAPTER_OBJECT AdapterObject,
    IN OPTIONAL PMDL Mdl,
    IN PVOID CurrentVa,
    IN ULONG Length,
    OUT PULONG  ScatterGatherListSize,
    OUT OPTIONAL PULONG pNumberOfMapRegisters
    );

NTSTATUS
HalBuildScatterGatherList (
    IN PADAPTER_OBJECT AdapterObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN PMDL Mdl,
    IN PVOID CurrentVa,
    IN ULONG Length,
    IN PDRIVER_LIST_CONTROL ExecutionRoutine,
    IN PVOID Context,
    IN BOOLEAN WriteToDevice,
    IN PVOID ScatterGatherBuffer,
    IN ULONG ScatterGatherBufferLength
    );


NTSTATUS
HalBuildMdlFromScatterGatherList(
    IN PADAPTER_OBJECT AdapaterObject,
    IN PSCATTER_GATHER_LIST ScatterGather,
    IN PMDL OriginalMdl,
    OUT PMDL *TargetMdl
    );

PHYSICAL_ADDRESS
__inline
HalpGetAdapterMaximumPhysicalAddress(
    IN PADAPTER_OBJECT AdapterObject
    )

/*++

Routine Description:

    This routine determines and returns the maximum physical address that
    can be accessed by the given adapter.

Arguments:

    AdapterObject - Supplies a pointer to the adapter object used by this
        device.

Return Value:

    Returns the maximum physical address that can be accessed by this
        device.

--*/

{
    PHYSICAL_ADDRESS maximumAddress;

    //
    // Assume the device requires physical addresses 2GB.
    //

    maximumAddress.HighPart = 0;
    maximumAddress.LowPart = MAXIMUM_PHYSICAL_ADDRESS - 1;

    //
    // IoMapTransfer() is sometimes called with a NULL adapter object.  In
    // this case, assume the adapter is 32 bit.
    //

    if (AdapterObject == NULL) {
        return maximumAddress;
    }

    if (AdapterObject->MasterDevice) {

        if (AdapterObject->Dma64BitAddresses) {

            //
            // This device is a master and can handle 64 bit addresses.
            //

            maximumAddress.QuadPart = (ULONGLONG)-1;

        } else if(AdapterObject->Dma32BitAddresses) {

            //
            // This device is a master and can handle 32 bit addresses.
            //

            maximumAddress.LowPart = (ULONG)-1;
        }
    }

    return maximumAddress;
}


#endif // _IXISA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\ixinfo.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ixinfo.c

Abstract:

Author:

    Ken Reneris (kenr)  08-Aug-1994

Environment:

    Kernel mode only.

Revision History:

--*/


#include "halp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,HaliQuerySystemInformation)
#pragma alloc_text(PAGE,HaliSetSystemInformation)
#pragma alloc_text(INIT,HalInitSystemPhase2)

#endif

//
// NUMA Information.
//

extern PVOID HalpAcpiSrat;

NTSTATUS
HalpGetAcpiStaticNumaTopology(
    HAL_NUMA_TOPOLOGY_INTERFACE * NumaInfo
    );

NTSTATUS
HaliQuerySystemInformation(
    IN HAL_QUERY_INFORMATION_CLASS  InformationClass,
    IN ULONG     BufferSize,
    OUT PVOID    Buffer,
    OUT PULONG   ReturnedLength
    )
{
    NTSTATUS    Status;
    PVOID       InternalBuffer;
    ULONG       Length, PlatformProperties;
    union {
        HAL_POWER_INFORMATION               PowerInf;
        HAL_PROCESSOR_SPEED_INFORMATION     ProcessorInf;
        HAL_ERROR_INFO                      ErrorInfo;
        HAL_DISPLAY_BIOS_INFORMATION        DisplayBiosInf;
        HAL_PLATFORM_INFORMATION            PlatformInfo;
    } U;

    BOOLEAN     bUseFrameBufferCaching;

    PAGED_CODE();

    Status = STATUS_SUCCESS;
    *ReturnedLength = 0;
    Length = 0;

    switch (InformationClass) {

        case HalFrameBufferCachingInformation:

            Status = HalpGetPlatformProperties(&PlatformProperties);
            if (NT_SUCCESS(Status) &&
                (PlatformProperties & IPPT_DISABLE_WRITE_COMBINING)) {
                bUseFrameBufferCaching = FALSE;
            } else {

                //
                // Note - we want to return TRUE here to enable USWC in all
                // cases except in a "Shared Memory Cluster" machine.
                //

                Status = STATUS_SUCCESS;
                bUseFrameBufferCaching = TRUE;
            }
            InternalBuffer = &bUseFrameBufferCaching;
            Length = sizeof (BOOLEAN);
            break;

        case HalMcaLogInformation:
            Status = HalpGetMcaLog( Buffer, BufferSize, ReturnedLength );
            break;

        case HalCmcLogInformation:
            Status = HalpGetCmcLog( Buffer, BufferSize, ReturnedLength );
            break;

        case HalCpeLogInformation:
            Status = HalpGetCpeLog( Buffer, BufferSize, ReturnedLength );
            break;

        case HalErrorInformation:
            InternalBuffer = &U.ErrorInfo;
            if ( Buffer && (BufferSize > sizeof(U.ErrorInfo.Version)) )   {
                U.ErrorInfo.Version = ((PHAL_ERROR_INFO)Buffer)->Version;
                Status = HalpGetMceInformation(&U.ErrorInfo, &Length);
            }
            else    {
                Status = STATUS_INVALID_PARAMETER;
            }
            break;

        case HalDisplayBiosInformation:
            InternalBuffer = &U.DisplayBiosInf;
            Length = sizeof(U.DisplayBiosInf);
            U.DisplayBiosInf = HalpGetDisplayBiosInformation ();
            break;

        case HalProcessorSpeedInformation:
            RtlZeroMemory (&U.ProcessorInf, sizeof(HAL_PROCESSOR_SPEED_INFORMATION));

            // U.ProcessorInf.MaximumProcessorSpeed = HalpCPUMHz;
            // U.ProcessorInf.CurrentAvailableSpeed = HalpCPUMHz;
            // U.ProcessorInf.ConfiguredSpeedLimit  = HalpCPUMHz;

            U.ProcessorInf.ProcessorSpeed = HalpCPUMHz;

            InternalBuffer = &U.ProcessorInf;
            Length = sizeof (HAL_PROCESSOR_SPEED_INFORMATION);
            break;

        case HalProfileSourceInformation:
            Status = HalpProfileSourceInformation (
                        Buffer,
                        BufferSize,
                        ReturnedLength);
            return Status;
            break;

        case HalNumaTopologyInterface:
            if (BufferSize == sizeof(HAL_NUMA_TOPOLOGY_INTERFACE)) {

                Status = STATUS_INVALID_LEVEL;

                if (HalpAcpiSrat) {
                    Status = HalpGetAcpiStaticNumaTopology(Buffer);
                    if (NT_SUCCESS(Status)) {
                        *ReturnedLength = sizeof(HAL_NUMA_TOPOLOGY_INTERFACE);
                    }
                    break;
                }

            } else {

                //
                // Buffer size is wrong, we could return valid data
                // if the buffer is too big,.... but instead we will
                // use this as an indication that we're not compatible
                // with the kernel.
                //

                Status = STATUS_INFO_LENGTH_MISMATCH;
            }
            break;
        case HalPartitionIpiInterface:

            //
            // Some platforms generate interrupts in remote partitions
            // as part of their shared memory implementation.  This is
            // accomplished by targetting an IPI at a processor/vector
            // in that remote partition.  Provide interfaces to enable
            // this but make them conditional on presence of IPPT
            // table and appropriate bit explicitly enabling this
            // functionality.  OEM is responsible for ensuring that an
            // interrupt isn't sent to a logical processor that isn't
            // present.
            //

            if (BufferSize >= sizeof(HAL_CROSS_PARTITION_IPI_INTERFACE)) {
                Status = HalpGetPlatformProperties(&PlatformProperties);
                if (NT_SUCCESS(Status) &&
                    (PlatformProperties & IPPT_ENABLE_CROSS_PARTITION_IPI)) {
                    Status = HalpGetCrossPartitionIpiInterface(Buffer);
                    if (NT_SUCCESS(Status)) {
                        *ReturnedLength = sizeof(HAL_CROSS_PARTITION_IPI_INTERFACE);
                    }
                } else {
                    Status = STATUS_UNSUCCESSFUL;
                }
            } else {
                Status = STATUS_INFO_LENGTH_MISMATCH;
            }
            break;
        case HalPlatformInformation:
            //
            // Any platform information that must be exposed to the kernel.
            //

            if (BufferSize >= sizeof(HAL_PLATFORM_INFORMATION)) {
                Status = HalpGetPlatformProperties(&PlatformProperties);
                if (NT_SUCCESS(Status)) {
                    InternalBuffer = &U.PlatformInfo;
                    Length = sizeof(U.PlatformInfo);
                    U.PlatformInfo.PlatformFlags = PlatformProperties;
                }
            } else {
                Status = STATUS_INFO_LENGTH_MISMATCH;
            }
            break;
        default:
            Status = STATUS_INVALID_LEVEL;
            break;
    }

    //
    // If non-zero Length copy data to callers buffer
    //

    if (Length) {
        if (BufferSize < Length) {
            Length = BufferSize;
        }

        *ReturnedLength = Length;
        RtlCopyMemory (Buffer, InternalBuffer, Length);
    }

    return Status;

} // HaliQuerySystemInformation()

#if !defined(MmIsFunctionPointerValid)
#define MmIsFunctionPointerValid( _Va ) ( MmIsAddressValid((PVOID)(_Va)) && MmIsAddressValid((PVOID)(*((PULONG_PTR)(_Va)))) )
#endif // !MmIsFunctionPointerValid

NTSTATUS
HaliSetSystemInformation (
    IN HAL_SET_INFORMATION_CLASS    InformationClass,
    IN ULONG     BufferSize,
    IN PVOID     Buffer
    )
/*++

Routine Description:

    The function allows setting of various fields return by
    HalQuerySystemInformation.

Arguments:

    InformationClass - Information class of the request.

    BufferSize - Size of buffer supplied by the caller.

    Buffer - Supplies the data to be set.

Return Value:

    STATUS_SUCCESS or error.

--*/
{
    NTSTATUS    Status;

    PAGED_CODE();

    Status = STATUS_SUCCESS;

    switch (InformationClass) {

        case HalProfileSourceInterval:
            if (BufferSize == sizeof(HAL_PROFILE_SOURCE_INTERVAL)) {

                PHAL_PROFILE_SOURCE_INTERVAL sourceInterval =
                            (PHAL_PROFILE_SOURCE_INTERVAL)Buffer;

                Status = HalSetProfileSourceInterval(  sourceInterval->Source,
                                                      &sourceInterval->Interval
                                                    );
            }
            else  {
                Status = STATUS_INFO_LENGTH_MISMATCH;
            }
            break;

        case HalProfileSourceInterruptHandler:
            //
            // Register an Profiling Interrupt Handler.
            //

            Status = STATUS_INFO_LENGTH_MISMATCH;
            if (BufferSize == sizeof(ULONG_PTR)) {
                if ( !(HalpFeatureBits & HAL_PERF_EVENTS) ) {
                    Status = STATUS_NO_SUCH_DEVICE;
                }
                else if ( !MmIsFunctionPointerValid(Buffer) ) {
                    Status = STATUS_INVALID_ADDRESS;
                }
                else  {
                    Status = (NTSTATUS)KiIpiGenericCall( HalpSetProfileInterruptHandler, *(PULONG_PTR)Buffer );
                }
            }
            break;

        case HalKernelErrorHandler:
            Status = HalpMceRegisterKernelDriver( (PKERNEL_ERROR_HANDLER_INFO) Buffer, BufferSize );
            break;

        case HalMcaRegisterDriver:
            Status = HalpMcaRegisterDriver(
                (PMCA_DRIVER_INFO) Buffer  // Info about registering driver
            );
            break;

        case HalCmcRegisterDriver:
            Status = HalpCmcRegisterDriver(
                (PCMC_DRIVER_INFO) Buffer  // Info about registering driver
            );
            break;

        case HalCpeRegisterDriver:
            Status = HalpCpeRegisterDriver(
                (PCPE_DRIVER_INFO) Buffer  // Info about registering driver
            );
            break;

        case HalMcaLog:  // Class requested by MS Machine Check Event Test Team.
            Status = HalpSetMcaLog( (PMCA_EXCEPTION) Buffer, BufferSize );
            break;

        case HalCmcLog:  // Class requested by MS Machine Check Event Test Team.
            Status = HalpSetCmcLog( (PCMC_EXCEPTION) Buffer, BufferSize );
            break;

        case HalCpeLog:  // Class requested by MS Machine Check Event Test Team.
            Status = HalpSetCpeLog( (PCPE_EXCEPTION) Buffer, BufferSize );
            break;

        default:
            Status = STATUS_INVALID_LEVEL;
            break;
    }

    return Status;

} // HaliSetSystemInformation()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\ixisabus.c ===
/*++


Copyright (c) 1989  Microsoft Corporation

Module Name:

    ixisabus.c

Abstract:

Author:

Environment:

Revision History:


--*/

#include "halp.h"

BOOLEAN
HalpTranslateIsaBusAddress (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

BOOLEAN
HalpTranslateEisaBusAddress (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

BOOLEAN
HalpTranslateSystemBusAddress (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

#ifdef EISA_SUPPORTED
ULONG
HalpGetEisaInterruptVector(
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    );

NTSTATUS
HalpAdjustEisaResourceList (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST   *pResourceList
    );

HalpGetEisaData (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

extern USHORT HalpEisaIrqMask;
extern USHORT HalpEisaIrqIgnore;
#endif // EISA_SUPPORTED

#ifdef ALLOC_PRAGMA
#ifdef EISA_SUPPORTED
#pragma alloc_text(PAGE,HalpAdjustEisaResourceList)
#pragma alloc_text(PAGE,HalpRecordEisaInterruptVectors)
#pragma alloc_text(PAGE,HalpGetEisaInterruptVector)
#pragma alloc_text(PAGE,HalpGetEisaData)
#endif
#pragma alloc_text(PAGE,HalIrqTranslateResourceRequirementsIsa)
#pragma alloc_text(PAGE,HalIrqTranslateResourcesIsa)
#endif



#ifdef EISA_SUPPORTED
HalpGetEisaData (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    The function returns the Eisa bus data for a slot or address.

Arguments:

    Buffer - Supplies the space to store the data.

    Length - Supplies a count in bytes of the maximum amount to return.

Return Value:

    Returns the amount of data stored into the buffer.

--*/

{
    OBJECT_ATTRIBUTES ObjectAttributes;
    OBJECT_ATTRIBUTES BusObjectAttributes;
    PWSTR EisaPath = L"\\Registry\\Machine\\Hardware\\Description\\System\\EisaAdapter";
    PWSTR ConfigData = L"Configuration Data";
    ANSI_STRING TmpString;
    ULONG BusNumber;
    UCHAR BusString[] = "00";
    UNICODE_STRING RootName, BusName;
    UNICODE_STRING ConfigDataName;
    NTSTATUS NtStatus;
    PKEY_VALUE_FULL_INFORMATION ValueInformation;
    PCM_FULL_RESOURCE_DESCRIPTOR Descriptor;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialResource;
    PCM_EISA_SLOT_INFORMATION SlotInformation;
    ULONG PartialCount;
    ULONG TotalDataSize, SlotDataSize;
    HANDLE EisaHandle, BusHandle;
    ULONG BytesWritten, BytesNeeded;
    PUCHAR KeyValueBuffer;
    ULONG i;
    ULONG DataLength = 0;
    PUCHAR DataBuffer = Buffer;
    BOOLEAN Found = FALSE;

    PAGED_CODE ();


    RtlInitUnicodeString(
                    &RootName,
                    EisaPath
                    );

    InitializeObjectAttributes(
                    &ObjectAttributes,
                    &RootName,
                    OBJ_CASE_INSENSITIVE,
                    (HANDLE)NULL,
                    NULL
                    );

    //
    // Open the EISA root
    //

    NtStatus = ZwOpenKey(
                    &EisaHandle,
                    KEY_READ,
                    &ObjectAttributes
                    );

    if (!NT_SUCCESS(NtStatus)) {
        DataLength = 0;
        goto HalpGetEisaDataExit;

    }

    //
    // Init bus number path
    //

    BusNumber = BusHandler->BusNumber;
    if (BusNumber > 99) {
        DataLength = 0;
        goto HalpGetEisaDataExit;

    }

    if (BusNumber > 9) {
        BusString[0] += (UCHAR) (BusNumber/10);
        BusString[1] += (UCHAR) (BusNumber % 10);
    } else {
        BusString[0] += (UCHAR) BusNumber;
        BusString[1] = '\0';
    }

    RtlInitAnsiString(
                &TmpString,
                BusString
                );

    RtlAnsiStringToUnicodeString(
                            &BusName,
                            &TmpString,
                            TRUE
                            );


    InitializeObjectAttributes(
                    &BusObjectAttributes,
                    &BusName,
                    OBJ_CASE_INSENSITIVE,
                    (HANDLE)EisaHandle,
                    NULL
                    );

    //
    // Open the EISA root + Bus Number
    //

    NtStatus = ZwOpenKey(
                    &BusHandle,
                    KEY_READ,
                    &BusObjectAttributes
                    );

    if (!NT_SUCCESS(NtStatus)) {
        HalDebugPrint(( HAL_INFO, "HAL: Opening Bus Number: Status = %x\n",NtStatus ));
        DataLength = 0;
        goto HalpGetEisaDataExit; 
    }

    //
    // opening the configuration data. This first call tells us how
    // much memory we need to allocate
    //

    RtlInitUnicodeString(
                &ConfigDataName,
                ConfigData
                );

    //
    // This should fail.  We need to make this call so we can
    // get the actual size of the buffer to allocate.
    //

    ValueInformation = (PKEY_VALUE_FULL_INFORMATION) &i;
    NtStatus = ZwQueryValueKey(
                        BusHandle,
                        &ConfigDataName,
                        KeyValueFullInformation,
                        ValueInformation,
                        0,
                        &BytesNeeded
                        );

    KeyValueBuffer = ExAllocatePoolWithTag(
                            NonPagedPool,
                            BytesNeeded,
                            HAL_POOL_TAG
                            );

    if (KeyValueBuffer == NULL) {
        HalDebugPrint(( HAL_INFO, "HAL: Cannot allocate Key Value Buffer\n" ));
        ZwClose(BusHandle);
        DataLength = 0;
        goto HalpGetEisaDataExit; 
    }

    ValueInformation = (PKEY_VALUE_FULL_INFORMATION)KeyValueBuffer;

    NtStatus = ZwQueryValueKey(
                        BusHandle,
                        &ConfigDataName,
                        KeyValueFullInformation,
                        ValueInformation,
                        BytesNeeded,
                        &BytesWritten
                        );


    ZwClose(BusHandle);

    if (!NT_SUCCESS(NtStatus)) {
        HalDebugPrint(( HAL_INFO, "HAL: Query Config Data: Status = %x\n",NtStatus ));
        DataLength = 0;
        goto HalpGetEisaDataExit;

    }


    //
    // We get back a Full Resource Descriptor List
    //

    Descriptor = (PCM_FULL_RESOURCE_DESCRIPTOR)((PUCHAR)ValueInformation +
                                         ValueInformation->DataOffset);

    PartialResource = (PCM_PARTIAL_RESOURCE_DESCRIPTOR)
                          &(Descriptor->PartialResourceList.PartialDescriptors);
    PartialCount = Descriptor->PartialResourceList.Count;

    for (i = 0; i < PartialCount; i++) {

        //
        // Do each partial Resource
        //

        switch (PartialResource->Type) {
            case CmResourceTypeNull:
            case CmResourceTypePort:
            case CmResourceTypeInterrupt:
            case CmResourceTypeMemory:
            case CmResourceTypeDma:

                //
                // We dont care about these.
                //

                PartialResource++;

                break;

            case CmResourceTypeDeviceSpecific:

                //
                // Bingo!
                //

                TotalDataSize = PartialResource->u.DeviceSpecificData.DataSize;

                SlotInformation = (PCM_EISA_SLOT_INFORMATION)
                                    ((PUCHAR)PartialResource +
                                     sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR));

                while (((LONG)TotalDataSize) > 0) {

                    if (SlotInformation->ReturnCode == EISA_EMPTY_SLOT) {

                        SlotDataSize = sizeof(CM_EISA_SLOT_INFORMATION);

                    } else {

                        SlotDataSize = sizeof(CM_EISA_SLOT_INFORMATION) +
                                  SlotInformation->NumberFunctions *
                                  sizeof(CM_EISA_FUNCTION_INFORMATION);
                    }

                    if (SlotDataSize > TotalDataSize) {

                        //
                        // Something is wrong again
                        //

                        DataLength = 0;
                        goto HalpGetEisaDataExit;

                    }

                    if (SlotNumber != 0) {

                        SlotNumber--;

                        SlotInformation = (PCM_EISA_SLOT_INFORMATION)
                            ((PUCHAR)SlotInformation + SlotDataSize);

                        TotalDataSize -= SlotDataSize;

                        continue;

                    }

                    //
                    // This is our slot
                    //

                    Found = TRUE;
                    break;

                }

                //
                // End loop
                //

                i = PartialCount;

                break;

            default:
                HalDebugPrint(( HAL_INFO, "HAL: Bad Data in registry!\n" ));
                DataLength = 0;
                goto HalpGetEisaDataExit;

        }

    }

    if (Found) {
        i = Length + Offset;
        if (i > SlotDataSize) {
            i = SlotDataSize;
        }

        DataLength = i - Offset;
        RtlMoveMemory (Buffer, ((PUCHAR)SlotInformation + Offset), DataLength);
    }
HalpGetEisaDataExit:

    if (KeyValueBuffer) ExFreePool(KeyValueBuffer);
    RtlFreeUnicodeString(&BusName); 
    return DataLength;
}
#endif // EISA_SUPPORTED


NTSTATUS
HalIrqTranslateResourceRequirementsIsa(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
)
/*++

Routine Description:

    This function is basically a wrapper for
    HalIrqTranslateResourceRequirementsRoot that understands
    the weirdnesses of the ISA bus.

Arguments:

Return Value:

    status

--*/
{
    PIO_RESOURCE_DESCRIPTOR modSource, target, rootTarget;
    NTSTATUS                status;
    BOOLEAN                 picSlaveDeleted = FALSE;
    BOOLEAN                 deleteResource;
    ULONG                   sourceCount = 0;
    ULONG                   targetCount = 0;
    ULONG                   resource;
    ULONG                   rootCount;
    ULONG                   invalidIrq;

    PAGED_CODE();
    ASSERT(Source->Type == CmResourceTypeInterrupt);

    modSource = ExAllocatePoolWithTag(
                    NonPagedPool,

    //
    // we will have at most nine ranges when we are done
    //   
                    sizeof(IO_RESOURCE_DESCRIPTOR) * 9,
                    HAL_POOL_TAG
                    );

    if (!modSource) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modSource, sizeof(IO_RESOURCE_DESCRIPTOR) * 9);

    //
    // Is the PIC_SLAVE_IRQ in this resource?
    //
    if ((Source->u.Interrupt.MinimumVector <= PIC_SLAVE_IRQ) &&
        (Source->u.Interrupt.MaximumVector >= PIC_SLAVE_IRQ)) {

        //
        // Clip the maximum
        //
        
        if (Source->u.Interrupt.MinimumVector < PIC_SLAVE_IRQ) {

            modSource[sourceCount] = *Source;

            modSource[sourceCount].u.Interrupt.MinimumVector =
                Source->u.Interrupt.MinimumVector;

            modSource[sourceCount].u.Interrupt.MaximumVector =
                PIC_SLAVE_IRQ - 1;

            sourceCount++;
        }

        //
        // Clip the minimum
        //
       
        if (Source->u.Interrupt.MaximumVector > PIC_SLAVE_IRQ) {

            modSource[sourceCount] = *Source;

            modSource[sourceCount].u.Interrupt.MaximumVector =
                Source->u.Interrupt.MaximumVector;

            modSource[sourceCount].u.Interrupt.MinimumVector =
                PIC_SLAVE_IRQ + 1;

            sourceCount++;
        }

        //
        // In ISA machines, the PIC_SLAVE_IRQ is rerouted
        // to PIC_SLAVE_REDIRECT.  So find out if PIC_SLAVE_REDIRECT
        // is within this list. If it isn't we need to add it.
        //
       
        if (!((Source->u.Interrupt.MinimumVector <= PIC_SLAVE_REDIRECT) &&
             (Source->u.Interrupt.MaximumVector >= PIC_SLAVE_REDIRECT))) {

            modSource[sourceCount] = *Source;

            modSource[sourceCount].u.Interrupt.MinimumVector=PIC_SLAVE_REDIRECT;
            modSource[sourceCount].u.Interrupt.MaximumVector=PIC_SLAVE_REDIRECT;

            sourceCount++;
        }

    } else {

        *modSource = *Source;
        sourceCount = 1;
    }

    //
    // Now that the PIC_SLAVE_IRQ has been handled, we have
    // to take into account IRQs that may have been steered
    // away to the PCI bus.
    //
    // N.B.  The algorithm used below may produce resources
    // with minimums greater than maximums.  Those will
    // be stripped out later.
    //

    for (invalidIrq = 0; invalidIrq < PIC_VECTORS; invalidIrq++) {

        //
        // Look through all the resources, possibly removing
        // this IRQ from them.
        //
        for (resource = 0; resource < sourceCount; resource++) {

            deleteResource = FALSE;

            if (HalpPciIrqMask & (1 << invalidIrq)) {

                //
                // This IRQ belongs to the PCI bus.
                //

                if (!((HalpBusType == MACHINE_TYPE_EISA) &&
                      ((modSource[resource].Flags == CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE)))) {

                    //
                    // And this resource is not an EISA-style,
                    // level-triggered interrupt.
                    //
                    // N.B.  Only the system BIOS truely knows
                    //       whether an IRQ on a PCI bus can be
                    //       shared with an IRQ on an ISA bus.
                    //       This code assumes that, in the case
                    //       that the BIOS set an EISA device to
                    //       the same interrupt as a PCI device,
                    //       the machine can actually function.
                    //
                    deleteResource = TRUE;
                }
            }

#if !defined(MCA) && defined(EISA_SUPPORTED)
            if ((HalpBusType == MACHINE_TYPE_EISA) &&
                !(HalpEisaIrqIgnore & (1 << invalidIrq))) {

                if (modSource[resource].Flags != HalpGetIsaIrqState(invalidIrq)) {

                    //
                    // This driver has requested a level-triggered interrupt
                    // and this particular interrupt is set to be edge, or
                    // vice-versa.
                    //
                    deleteResource = TRUE;
                }
            }
#endif

            if (deleteResource) {

                if (modSource[resource].u.Interrupt.MinimumVector == invalidIrq) {

                    modSource[resource].u.Interrupt.MinimumVector++;

                } else if (modSource[resource].u.Interrupt.MaximumVector == invalidIrq) {

                    modSource[resource].u.Interrupt.MaximumVector--;

                } else if ((modSource[resource].u.Interrupt.MinimumVector < invalidIrq) &&
                    (modSource[resource].u.Interrupt.MaximumVector > invalidIrq)) {

                    //
                    // Copy the current resource into a new resource.
                    //
                    modSource[sourceCount] = modSource[resource];

                    //
                    // Clip the current resource to a range below invalidIrq.
                    //
                    modSource[resource].u.Interrupt.MaximumVector = invalidIrq - 1;

                    //
                    // Clip the new resource to a range above invalidIrq.
                    //
                    modSource[sourceCount].u.Interrupt.MinimumVector = invalidIrq + 1;

                    sourceCount++;
                }
            }
        }
    }


    target = ExAllocatePoolWithTag(PagedPool,
                                   sizeof(IO_RESOURCE_DESCRIPTOR) * sourceCount,
                                   HAL_POOL_TAG
                                   );

    if (!target) {
        ExFreePool(modSource);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Now send each of these ranges through
    // HalIrqTranslateResourceRequirementsRoot.
    //

    for (resource = 0; resource < sourceCount; resource++) {

        //
        // Skip over resources that we have previously
        // clobbered (while deleting PCI IRQs.)
        //

        if (modSource[resource].u.Interrupt.MinimumVector >
            modSource[resource].u.Interrupt.MaximumVector) {

            continue;
        }

        status = HalIrqTranslateResourceRequirementsRoot(
                    Context,
                    &modSource[resource],
                    PhysicalDeviceObject,
                    &rootCount,
                    &rootTarget
                    );

        if (!NT_SUCCESS(status)) {
            ExFreePool(target);
            goto HalIrqTranslateResourceRequirementsIsaExit;
        }

        //
        // HalIrqTranslateResourceRequirementsRoot should return
        // either one resource or, occasionally, zero.
        //

        ASSERT(rootCount <= 1);

        if (rootCount == 1) {

            target[targetCount] = *rootTarget;
            targetCount++;
            ExFreePool(rootTarget);
        }
    }

    *TargetCount = targetCount;

    if (targetCount > 0) {

        *Target = target;

    } else {

        ExFreePool(target);
    }

    status = STATUS_TRANSLATION_COMPLETE;

HalIrqTranslateResourceRequirementsIsaExit:

    ExFreePool(modSource);
    return status;
}

NTSTATUS
HalIrqTranslateResourcesIsa(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    )
/*++

Routine Description:

    This function is basically a wrapper for
    HalIrqTranslateResourcesRoot that understands
    the weirdnesses of the ISA bus.

Arguments:

Return Value:

    status

--*/
{
    CM_PARTIAL_RESOURCE_DESCRIPTOR modSource;
    NTSTATUS    status;
    BOOLEAN     usePicSlave = FALSE;
    ULONG       i;
   
   
    modSource = *Source;
    
    if (Direction == TranslateChildToParent) {

        if (Source->u.Interrupt.Vector == PIC_SLAVE_IRQ) {
            modSource.u.Interrupt.Vector = PIC_SLAVE_REDIRECT;
            modSource.u.Interrupt.Level = PIC_SLAVE_REDIRECT;
        }
    }

    status = HalIrqTranslateResourcesRoot(
                Context,
                &modSource,
                Direction,
                AlternativesCount,
                Alternatives,
                PhysicalDeviceObject,
                Target);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    if (Direction == TranslateParentToChild) {

        //
        // Because the ISA interrupt controller is
        // cascaded, there is one case where there is
        // a two-to-one mapping for interrupt sources.
        // (On a PC, both 2 and 9 trigger vector 9.)
        //
        // We need to account for this and deliver the
        // right value back to the driver.
        //

        if (Target->u.Interrupt.Level == PIC_SLAVE_REDIRECT) {

            //
            // Search the Alternatives list.  If it contains
            // PIC_SLAVE_IRQ but not PIC_SLAVE_REDIRECT,
            // we should return PIC_SLAVE_IRQ.
            //

            for (i = 0; i < AlternativesCount; i++) {

                if ((Alternatives[i].u.Interrupt.MinimumVector >= PIC_SLAVE_REDIRECT) &&
                    (Alternatives[i].u.Interrupt.MaximumVector <= PIC_SLAVE_REDIRECT)) {

                    //
                    // The list contains, PIC_SLAVE_REDIRECT.  Stop
                    // looking.
                    //

                    usePicSlave = FALSE;
                    break;
                }

                if ((Alternatives[i].u.Interrupt.MinimumVector >= PIC_SLAVE_IRQ) &&
                    (Alternatives[i].u.Interrupt.MaximumVector <= PIC_SLAVE_IRQ)) {

                    //
                    // The list contains, PIC_SLAVE_IRQ.  Use it
                    // unless we find PIC_SLAVE_REDIRECT later.
                    //

                    usePicSlave = TRUE;
                }
            }

            if (usePicSlave) {

                Target->u.Interrupt.Level  = PIC_SLAVE_IRQ;
                Target->u.Interrupt.Vector = PIC_SLAVE_IRQ;
            }
        }
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\ixisasup.c ===
/*++


Copyright (c) 1989  Microsoft Corporation

Module Name:

    ixisasup.c

Abstract:

    This module contains the IoXxx routines for the NT I/O system that
    are hardware dependent.  Were these routines not hardware dependent,
    they would reside in the iosubs.c module.

Author:

    Darryl E. Havens (darrylh) 11-Apr-1990

Environment:

    Kernel mode

Revision History:


--*/

#include "halp.h"
#include "eisa.h"
#include "pci.h"

#include "pcip.h"


//
//Only take the prototype, don't instantiate
//
#include <wdmguid.h>

#include "halpnpp.h"

VOID
HalpGrowMapBufferWorker(
    IN PVOID Context
    );

#ifdef ALLOC_PRAGMA
        #pragma alloc_text(PAGE,HalGetAdapter)
        #pragma alloc_text(PAGE,HalpGetIsaIrqState)
#endif

//
// The HalpNewAdapter event is used to serialize allocations
// of new adapter objects, additions to the HalpEisaAdapter
// array, and some global values (MasterAdapterObject) and some
// adapter fields modified by HalpGrowMapBuffers.
// (AdapterObject->NumberOfMapRegisters is assumed not to be
// growable while this even is held)
//
// Note: We don't really need our own an event object for this.
//

KEVENT   HalpNewAdapter;


#define ACQUIRE_NEW_ADAPTER_LOCK()  \
{                                   \
    KeWaitForSingleObject (         \
        &HalpNewAdapter,            \
        WrExecutive,                \
        KernelMode,                 \
        FALSE,                      \
        NULL                        \
        );                          \
}

typedef struct _BUFFER_GROW_WORK_ITEM {
    WORK_QUEUE_ITEM WorkItem;
    PADAPTER_OBJECT AdapterObject;
    ULONG MapRegisterCount;
} BUFFER_GROW_WORK_ITEM, *PBUFFER_GROW_WORK_ITEM;


#define RELEASE_NEW_ADAPTER_LOCK()  \
    KeSetEvent (&HalpNewAdapter, 0, FALSE)

BOOLEAN NoMemoryAbove4Gb = FALSE;

VOID
HalpCopyBufferMap(
                 IN PMDL Mdl,
                 IN PTRANSLATION_ENTRY TranslationEntry,
                 IN PVOID CurrentVa,
                 IN ULONG Length,
                 IN BOOLEAN WriteToDevice
                 );

PHYSICAL_ADDRESS
HalpMapTransfer(
               IN PADAPTER_OBJECT AdapterObject,
               IN PMDL Mdl,
               IN PVOID MapRegisterBase,
               IN PVOID CurrentVa,
               IN OUT PULONG Length,
               IN BOOLEAN WriteToDevice
               );

VOID
HalpMapTransferHelper(
                     IN PMDL Mdl,
                     IN PVOID CurrentVa,
                     IN ULONG TransferLength,
                     IN PPFN_NUMBER PageFrame,
                     IN OUT PULONG Length
                     );


NTSTATUS
HalAllocateAdapterChannel(
                         IN PADAPTER_OBJECT AdapterObject,
                         IN PWAIT_CONTEXT_BLOCK Wcb,
                         IN ULONG NumberOfMapRegisters,
                         IN PDRIVER_CONTROL ExecutionRoutine
                         )
/*++

Routine Description:

    This routine allocates the adapter channel specified by the adapter object.
    This is accomplished by placing the device object of the driver that wants
    to allocate the adapter on the adapter's queue.  If the queue is already
    "busy", then the adapter has already been allocated, so the device object
    is simply placed onto the queue and waits until the adapter becomes free.

    Once the adapter becomes free (or if it already is), then the driver's
    execution routine is invoked.

    Also, a number of map registers may be allocated to the driver by specifying
    a non-zero value for NumberOfMapRegisters.  Then the map register must be
    allocated from the master adapter.  Once there are a sufficient number of
    map registers available, then the execution routine is called and the
    base address of the allocated map registers in the adapter is also passed
    to the driver's execution routine.

Arguments:

    AdapterObject - Pointer to the adapter control object to allocate to the
        driver.

    Wcb - Supplies a wait context block for saving the allocation parameters.
        The DeviceObject, CurrentIrp and DeviceContext should be initalized.

    NumberOfMapRegisters - The number of map registers that are to be allocated
        from the channel, if any.

    ExecutionRoutine - The address of the driver's execution routine that is
        invoked once the adapter channel (and possibly map registers) have been
        allocated.

Return Value:

    Returns STATUS_SUCESS unless too many map registers are requested.

Notes:

    Note that this routine MUST be invoked at DISPATCH_LEVEL or above.

--*/
{

    PADAPTER_OBJECT MasterAdapter;
    BOOLEAN Busy = FALSE;
    IO_ALLOCATION_ACTION Action;
    KIRQL Irql;
    ULONG MapRegisterNumber;

    //
    // Begin by obtaining a pointer to the master adapter associated with this
    // request.
    //

    MasterAdapter = AdapterObject->MasterAdapter;

    //
    // Initialize the device object's wait context block in case this device
    // must wait before being able to allocate the adapter.
    //

    Wcb->DeviceRoutine = ExecutionRoutine;
    Wcb->NumberOfMapRegisters = NumberOfMapRegisters;

    //
    // Allocate the adapter object for this particular device.  If the
    // adapter cannot be allocated because it has already been allocated
    // to another device, then return to the caller now;  otherwise,
    // continue.
    //

    if (!KeInsertDeviceQueue( &AdapterObject->ChannelWaitQueue,
                              &Wcb->WaitQueueEntry )) {

        //
        // Save the parameters in case there are not enough map registers.
        //

        AdapterObject->NumberOfMapRegisters = NumberOfMapRegisters;
        AdapterObject->CurrentWcb = Wcb;

        //
        // The adapter was not busy so it has been allocated.  Now check
        // to see whether this driver wishes to allocate any map registers.
        // Ensure that this adapter has enough total map registers
        // to satisfy the request.
        //

        if (NumberOfMapRegisters != 0 && AdapterObject->NeedsMapRegisters) {

            //
            // Lock the map register bit map and the adapter queue in the
            // master adapter object. The channel structure offset is used as
            // a hint for the register search.
            //

            if (NumberOfMapRegisters > AdapterObject->MapRegistersPerChannel) {
                AdapterObject->NumberOfMapRegisters = 0;
                IoFreeAdapterChannel(AdapterObject);
                return (STATUS_INSUFFICIENT_RESOURCES);
            }

            KeAcquireSpinLock (&MasterAdapter->SpinLock, &Irql);

            MapRegisterNumber = (ULONG)-1;

            if (IsListEmpty( &MasterAdapter->AdapterQueue)) {

                HalDebugPrint((HAL_VERBOSE, "HAAC: FindClearBitsAndSet(%p,%d,0)\n",
                                           MasterAdapter->MapRegisters,
                                           NumberOfMapRegisters));

                MapRegisterNumber = RtlFindClearBitsAndSet(
                                                  MasterAdapter->MapRegisters,
                                                  NumberOfMapRegisters,
                                                  0
                                                  );

                HalDebugPrint((HAL_VERBOSE, "HAAC: MapRegisterNumber = 0x%x\n",
                                           MapRegisterNumber));
            }

            if (MapRegisterNumber == -1) {

                PBUFFER_GROW_WORK_ITEM bufferWorkItem;

                //
                // There were not enough free map registers.  Queue this request
                // on the master adapter where is will wait until some registers
                // are deallocated.
                //

                InsertTailList( &MasterAdapter->AdapterQueue,
                                &AdapterObject->AdapterQueue
                              );
                Busy = 1;

                //
                // Queue a work item to grow the map registers
                //

                bufferWorkItem = ExAllocatePool( NonPagedPool,
                                                 sizeof(BUFFER_GROW_WORK_ITEM) );
                if (bufferWorkItem != NULL) {

                    ExInitializeWorkItem( &bufferWorkItem->WorkItem,
                                          HalpGrowMapBufferWorker,
                                          bufferWorkItem );

                    bufferWorkItem->AdapterObject = AdapterObject;
                    bufferWorkItem->MapRegisterCount = NumberOfMapRegisters;

                    ExQueueWorkItem( &bufferWorkItem->WorkItem,
                                     DelayedWorkQueue );
                }

            } else {

                //
                // Calculate the map register base from the allocated map
                // register and base of the master adapter object.
                //

                AdapterObject->MapRegisterBase = ((PTRANSLATION_ENTRY)
                          MasterAdapter->MapRegisterBase + MapRegisterNumber);

                //
                // Set the no scatter/gather flag if scatter/gather not
                // supported.
                //

                if (!AdapterObject->ScatterGather) {

                    AdapterObject->MapRegisterBase = (PVOID)
                     ((UINT_PTR) AdapterObject->MapRegisterBase | NO_SCATTER_GATHER);

                }
            }

            KeReleaseSpinLock( &MasterAdapter->SpinLock, Irql );

        } else {

            AdapterObject->MapRegisterBase = NULL;
            AdapterObject->NumberOfMapRegisters = 0;
        }

        //
        // If there were either enough map registers available or no map
        // registers needed to be allocated, invoke the driver's execution
        // routine now.
        //

        if (!Busy) {

            AdapterObject->CurrentWcb = Wcb;
            Action = ExecutionRoutine( Wcb->DeviceObject,
                                       Wcb->CurrentIrp,
                                       AdapterObject->MapRegisterBase,
                                       Wcb->DeviceContext );

            //
            // If the driver would like to have the adapter deallocated,
            // then release the adapter object.
            //

            if (Action == DeallocateObject) {

                IoFreeAdapterChannel( AdapterObject );

            } else if (Action == DeallocateObjectKeepRegisters) {

                //
                // Set the NumberOfMapRegisters  = 0 in the adapter object.
                // This will keep IoFreeAdapterChannel from freeing the
                // registers. After this it is the driver's responsiblity to
                // keep track of the number of map registers.
                //

                AdapterObject->NumberOfMapRegisters = 0;
                IoFreeAdapterChannel(AdapterObject);

            }
        }
    }

    return (STATUS_SUCCESS);

}

NTSTATUS
HalRealAllocateAdapterChannel(
    IN PADAPTER_OBJECT AdapterObject,
    IN PDEVICE_OBJECT DeviceObject,
    IN ULONG NumberOfMapRegisters,
    IN PDRIVER_CONTROL ExecutionRoutine,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine allocates the adapter channel specified by the adapter object.
    This is accomplished by calling HalAllocateAdapterChannel which does all of
    the work.

Arguments:

    AdapterObject - Pointer to the adapter control object to allocate to the
        driver.

    DeviceObject - Pointer to the driver's device object that represents the
        device allocating the adapter.

    NumberOfMapRegisters - The number of map registers that are to be allocated
        from the channel, if any.

    ExecutionRoutine - The address of the driver's execution routine that is
        invoked once the adapter channel (and possibly map registers) have been
        allocated.

    Context - An untyped longword context parameter passed to the driver's
        execution routine.

Return Value:

    Returns STATUS_SUCESS unless too many map registers are requested.

Notes:

    Note that this routine MUST be invoked at DISPATCH_LEVEL or above.

--*/

{
    PWAIT_CONTEXT_BLOCK wcb;

    wcb = &DeviceObject->Queue.Wcb;

    wcb->DeviceObject = DeviceObject;
    wcb->CurrentIrp = DeviceObject->CurrentIrp;
    wcb->DeviceContext = Context;

    return( HalAllocateAdapterChannel( AdapterObject,
                                       wcb,
                                       NumberOfMapRegisters,
                                       ExecutionRoutine ) );
}

VOID
HalpGrowMapBufferWorker(
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is called in the context of a work item from
    HalAllocateAdapterChannel() when it queues a map register allocation
    because map regiers are not available.

    Its purpose is to attempt to grow the map buffers for the adapter and,
    if successful, process queued adapter allocations.

Arguments:

    Context - Actually a pointer to a BUFFER_GROW_WORK_ITEM structure.

Return Value:

    None.

--*/

{
    PBUFFER_GROW_WORK_ITEM growWorkItem;
    PADAPTER_OBJECT masterAdapter;
    BOOLEAN allocated;
    ULONG bytesToGrow;
    KIRQL oldIrql;

    growWorkItem = (PBUFFER_GROW_WORK_ITEM)Context;
    masterAdapter = growWorkItem->AdapterObject->MasterAdapter;

    //
    // HalpGrowMapBuffers() takes a byte count
    //

    bytesToGrow = growWorkItem->MapRegisterCount * PAGE_SIZE +
                  INCREMENT_MAP_BUFFER_SIZE;

    ACQUIRE_NEW_ADAPTER_LOCK();

    allocated = HalpGrowMapBuffers( masterAdapter,
                                    bytesToGrow );

    RELEASE_NEW_ADAPTER_LOCK();

    if (allocated != FALSE) {

        KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );

        //
        // The map buffers were grown.  It is likely that someone is waiting
        // in the adapter queue, so try to get things started.
        //
        // The code in IoFreeMapRegisters() does this, and it turns out
        // we can safely get it to do this work for us by freeing 0
        // map registers at a bogus (but non-NULL) register base.
        //

        IoFreeMapRegisters( growWorkItem->AdapterObject,
                            (PVOID)2,
                            0 );

        KeLowerIrql( oldIrql );

    }

    ExFreePool( growWorkItem );
}



PVOID
HalAllocateCrashDumpRegisters(
                             IN PADAPTER_OBJECT AdapterObject,
                             IN PULONG NumberOfMapRegisters
                             )
/*++

Routine Description:

    This routine is called during the crash dump disk driver's initialization
    to allocate a number map registers permanently.

Arguments:

    AdapterObject - Pointer to the adapter control object to allocate to the
        driver.
    NumberOfMapRegisters - Number of map registers requested. This field
        will be updated to reflect the actual number of registers allocated
        when the number is less than what was requested.

Return Value:

    Returns STATUS_SUCESS if map registers allocated.

--*/
{
    PADAPTER_OBJECT MasterAdapter;
    ULONG MapRegisterNumber;

    //
    // Begin by obtaining a pointer to the master adapter associated with this
    // request.
    //

    MasterAdapter = AdapterObject->MasterAdapter;

    //
    // Check to see whether this driver needs to allocate any map registers.
    //

    if (AdapterObject->NeedsMapRegisters) {

        //
        // Ensure that this adapter has enough total map registers to satisfy
        // the request.
        //

        if (*NumberOfMapRegisters > AdapterObject->MapRegistersPerChannel) {
            AdapterObject->NumberOfMapRegisters = 0;
            return NULL;
        }

        //
        // Attempt to allocate the required number of map registers w/o
        // affecting those registers that were allocated when the system
        // crashed.
        //

        MapRegisterNumber = (ULONG)-1;

        MapRegisterNumber = RtlFindClearBitsAndSet(
                                                  MasterAdapter->MapRegisters,
                                                  *NumberOfMapRegisters,
                                                  0
                                                  );

        if (MapRegisterNumber == (ULONG)-1) {

            //
            // Not enough free map registers were found, so they were busy
            // being used by the system when it crashed.  Force the appropriate
            // number to be "allocated" at the base by simply overjamming the
            // bits and return the base map register as the start.
            //

            RtlSetBits(
                      MasterAdapter->MapRegisters,
                      0,
                      *NumberOfMapRegisters
                      );
            MapRegisterNumber = 0;

        }

        //
        // Calculate the map register base from the allocated map
        // register and base of the master adapter object.
        //

        AdapterObject->MapRegisterBase = ((PTRANSLATION_ENTRY)
                      MasterAdapter->MapRegisterBase + MapRegisterNumber);

        //
        // Set the no scatter/gather flag if scatter/gather not
        // supported.
        //

        if (!AdapterObject->ScatterGather) {

            AdapterObject->MapRegisterBase = (PVOID)
                 ((UINT_PTR) AdapterObject->MapRegisterBase | NO_SCATTER_GATHER);

        }

    } else {

        AdapterObject->MapRegisterBase = NULL;
        AdapterObject->NumberOfMapRegisters = 0;
    }

    return AdapterObject->MapRegisterBase;
}

PADAPTER_OBJECT
HalGetAdapter(
             IN PDEVICE_DESCRIPTION DeviceDescriptor,
             OUT PULONG NumberOfMapRegisters
             )

/*++

Routine Description:

    This function returns the appropriate adapter object for the device defined
    in the device description structure.

Arguments:

    DeviceDescriptor - Supplies a description of the deivce.

    NumberOfMapRegisters - Returns the maximum number of map registers which
        may be allocated by the device driver.

Return Value:

    A pointer to the requested adapter object or NULL if an adapter could not
    be created.

--*/

{
    PADAPTER_OBJECT adapterObject;
    PVOID adapterBaseVa;
    UCHAR adapterMode;
    ULONG numberOfMapRegisters;
    ULONG maximumLength;

    PAGED_CODE();

    HalDebugPrint((HAL_VERBOSE, "HGA: IN DeviceDescriptor %p\n",
                                DeviceDescriptor));

    HalDebugPrint((HAL_VERBOSE, "HGA: IN NumberOfMapregisters %p\n",
                                NumberOfMapRegisters));

    //
    // Make sure this is the correct version.
    //

    if (DeviceDescriptor->Version > DEVICE_DESCRIPTION_VERSION2) {
        return ( NULL );
    }

#if DBG
    if (DeviceDescriptor->Version >= DEVICE_DESCRIPTION_VERSION1) {
            ASSERT (DeviceDescriptor->Reserved1 == FALSE);
    }
#endif

    //
    // Limit the maximum length to 2 GB this is done so that the BYTES_TO_PAGES
    // macro works correctly.
    //

    maximumLength = DeviceDescriptor->MaximumLength & 0x7fffffff;

    if (DeviceDescriptor->InterfaceType == PCIBus &&
        DeviceDescriptor->Master != FALSE &&
        DeviceDescriptor->ScatterGather != FALSE) {

        //
        // This device can handle 32 bits, even if the caller forgot to
        // set Dma32BitAddresses.
        //

        DeviceDescriptor->Dma32BitAddresses = TRUE;
    }

    //
    // Determine the number of map registers for this device.
    //

    if (DeviceDescriptor->ScatterGather &&

       (NoMemoryAbove4Gb ||
        DeviceDescriptor->Dma64BitAddresses)) {

        //
        // Since the device support scatter/Gather then map registers are not
        // required.
        //

        numberOfMapRegisters = 0;

    } else {

        //
        // Determine the number of map registers required based on the maximum
        // transfer length, up to a maximum number.
        //

        numberOfMapRegisters = BYTES_TO_PAGES(maximumLength) + 1;

        if (numberOfMapRegisters > MAXIMUM_PCI_MAP_REGISTER) {
            numberOfMapRegisters = MAXIMUM_PCI_MAP_REGISTER;
        }
    }

    HalDebugPrint((HAL_VERBOSE, "HGA: Number of map registers needed = %x\n",
                                numberOfMapRegisters));

    adapterBaseVa = NULL;

    //
    // Serialize before allocating a new adapter
    //

    ACQUIRE_NEW_ADAPTER_LOCK();

    //
    // Allocate an adapter object.
    //

    adapterObject =
        (PADAPTER_OBJECT) HalpAllocateAdapter( numberOfMapRegisters,
                                                     adapterBaseVa,
                                                     NULL);
    if (adapterObject == NULL) {
        RELEASE_NEW_ADAPTER_LOCK();
        return (NULL);
    }

    //
    // Set the maximum number of map registers for this channel bus on
    // the number requested and the type of device.
    //

    if (numberOfMapRegisters) {

        //
        // The speicified number of registers are actually allowed to be
        // allocated.
        //

        adapterObject->MapRegistersPerChannel = numberOfMapRegisters;

        //
        // Increase the commitment for the map registers.
        //
        // Master I/O devices use several sets of map registers double
        // their commitment.
        //

        MasterAdapterObject->CommittedMapRegisters += numberOfMapRegisters * 2;

        //
        // If the committed map registers is signicantly greater than the
        // number allocated then grow the map buffer.
        //

        if (MasterAdapterObject->CommittedMapRegisters >
            MasterAdapterObject->NumberOfMapRegisters  ) {

            HalpGrowMapBuffers(
                MasterAdapterObject,
                INCREMENT_MAP_BUFFER_SIZE
                );
        }

        adapterObject->NeedsMapRegisters = TRUE;

    } else {

        //
        // No real map registers were allocated.  If this is a master
        // device, then the device can have as may registers as it wants.
        //

        adapterObject->NeedsMapRegisters = FALSE;

        adapterObject->MapRegistersPerChannel =
                        BYTES_TO_PAGES( maximumLength ) + 1;

    }
    RELEASE_NEW_ADAPTER_LOCK();

    adapterObject->IgnoreCount = FALSE;
    if (DeviceDescriptor->Version >= DEVICE_DESCRIPTION_VERSION1) {

        //
        // Move version 1 structure flags.
        // IgnoreCount is used on machines where the DMA Counter
        // is broken.  (Namely PS/1 model 1000s).  Setting this
        // bit informs the hal not to rely on the DmaCount to determine
        // how much data was DMAed.
        //

        adapterObject->IgnoreCount = DeviceDescriptor->IgnoreCount;
    }

    adapterObject->Dma32BitAddresses = DeviceDescriptor->Dma32BitAddresses;
    adapterObject->Dma64BitAddresses = DeviceDescriptor->Dma64BitAddresses;
    adapterObject->ScatterGather = DeviceDescriptor->ScatterGather;
    *NumberOfMapRegisters = adapterObject->MapRegistersPerChannel;
    adapterObject->MasterDevice = TRUE;

    HalDebugPrint((HAL_VERBOSE, "HGA: OUT adapterObject = %p\n",
                                adapterObject));
    HalDebugPrint((HAL_VERBOSE, "HGA: OUT NumberOfMapRegisters = %d\n",
                                *NumberOfMapRegisters));

    return (adapterObject);
}


PHYSICAL_ADDRESS
IoMapTransfer(
             IN PADAPTER_OBJECT AdapterObject,
             IN PMDL Mdl,
             IN PVOID MapRegisterBase,
             IN PVOID CurrentVa,
             IN OUT PULONG Length,
             IN BOOLEAN WriteToDevice
             )

/*++

Routine Description:

    This routine is invoked to set up the map registers in the DMA controller
    to allow a transfer to or from a device.

Arguments:

    AdapterObject - Pointer to the adapter object representing the DMA
        controller channel that has been allocated.

    Mdl - Pointer to the MDL that describes the pages of memory that are
        being read or written.

    MapRegisterBase - The address of the base map register that has been
        allocated to the device driver for use in mapping the transfer.

    CurrentVa - Current virtual address in the buffer described by the MDL
        that the transfer is being done to or from.

    Length - Supplies the length of the transfer.  This determines the
        number of map registers that need to be written to map the transfer.
        Returns the length of the transfer which was actually mapped.

    WriteToDevice - Boolean value that indicates whether this is a write
        to the device from memory (TRUE), or vice versa.

Return Value:

    Returns the logical address that should be used bus master controllers.

--*/

{
    ULONG transferLength;
    PHYSICAL_ADDRESS returnAddress;
    PPFN_NUMBER pageFrame;
    ULONG pageOffset;

    //
    // If the adapter is a 32-bit bus master, take the fast path,
    // otherwise call HalpMapTransfer for the slow path
    //

    if (MapRegisterBase == NULL) {

        pageOffset = BYTE_OFFSET(CurrentVa);

        //
        // Calculate how much of the transfer is contiguous
        //
        transferLength = PAGE_SIZE - pageOffset;
        pageFrame = (PPFN_NUMBER)(Mdl+1);
        pageFrame += (((UINT_PTR) CurrentVa - (UINT_PTR) MmGetMdlBaseVa(Mdl)) >> PAGE_SHIFT);

        //
        // Compute the starting address of the transfer
        //

        returnAddress.QuadPart = (*pageFrame << PAGE_SHIFT) + pageOffset;

        //
        // If the transfer is not completely contained within
        // a page, call the helper to compute the appropriate
        // length.
        //
        if (transferLength < *Length) {
                HalpMapTransferHelper(Mdl, CurrentVa, transferLength, pageFrame, Length);
        }
        return (returnAddress);
    }

    return (HalpMapTransfer(AdapterObject,
                            Mdl,
                            MapRegisterBase,
                            CurrentVa,
                            Length,
                            WriteToDevice));

}


VOID
HalpMapTransferHelper(
                     IN PMDL Mdl,
                     IN PVOID CurrentVa,
                     IN ULONG TransferLength,
                     IN PPFN_NUMBER PageFrame,
                     IN OUT PULONG Length
                     )

/*++

Routine Description:

    Helper routine for bus master transfers that cross a page
    boundary.  This routine is separated out from the IoMapTransfer
    fast path in order to minimize the total instruction path
    length taken for the common network case where the entire
    buffer being mapped is contained within one page.

Arguments:

    Mdl - Pointer to the MDL that describes the pages of memory that are
        being read or written.

    CurrentVa - Current virtual address in the buffer described by the MDL
        that the transfer is being done to or from.

    TransferLength = Supplies the current transferLength

    PageFrame - Supplies a pointer to the starting page frame of the transfer

    Length - Supplies the length of the transfer.  This determines the
        number of map registers that need to be written to map the transfer.
        Returns the length of the transfer which was actually mapped.

Return Value:

    None.  *Length will be updated

--*/

{
    PFN_NUMBER thisPageFrame;
    PFN_NUMBER nextPageFrame;

    do {

        thisPageFrame = *PageFrame;
        PageFrame += 1;
        nextPageFrame = *PageFrame;

        if ((thisPageFrame + 1) != nextPageFrame) {

            //
            // The next page frame is not contiguous with this one,
            // so break the transfer here.
            //

            break;
        }

        if (((thisPageFrame ^ nextPageFrame) & 0xFFFFFFFFFFF80000i64) != 0) {

            //
            // The next page frame is contiguous with this one,
            // but it crosses a 4GB boundary, another reason to
            // break the transfer.
            //

            break;
        }

        TransferLength += PAGE_SIZE;

    } while ( TransferLength < *Length );


    //
    // Limit the Length to the maximum TransferLength.
    //

    if (TransferLength < *Length) {
        *Length = TransferLength;
    }
}


PHYSICAL_ADDRESS
HalpMapTransfer(
               IN PADAPTER_OBJECT AdapterObject,
               IN PMDL Mdl,
               IN PVOID MapRegisterBase,
               IN PVOID CurrentVa,
               IN OUT PULONG Length,
               IN BOOLEAN WriteToDevice
               )

/*++

Routine Description:

    This routine is invoked to set up the map registers in the DMA controller
    to allow a transfer to or from a device.

Arguments:

    AdapterObject - Pointer to the adapter object representing the DMA
        controller channel that has been allocated.

    Mdl - Pointer to the MDL that describes the pages of memory that are
        being read or written.

    MapRegisterBase - The address of the base map register that has been
        allocated to the device driver for use in mapping the transfer.

    CurrentVa - Current virtual address in the buffer described by the MDL
        that the transfer is being done to or from.

    Length - Supplies the length of the transfer.  This determines the
        number of map registers that need to be written to map the transfer.
        Returns the length of the transfer which was actually mapped.

    WriteToDevice - Boolean value that indicates whether this is a write
        to the device from memory (TRUE), or vice versa.

Return Value:

    Returns the logical address that should be used bus master controllers.

--*/

{
    BOOLEAN useBuffer;
    ULONG transferLength;
    PHYSICAL_ADDRESS logicalAddress;
    PHYSICAL_ADDRESS returnAddress;
    ULONG index;
    PPFN_NUMBER pageFrame;
    PTRANSLATION_ENTRY translationEntry;
    ULONG pageOffset;
    PHYSICAL_ADDRESS maximumPhysicalAddress;

    pageOffset = BYTE_OFFSET(CurrentVa);

    //
    // Calculate how much of the transfer is contiguous.
    //

    transferLength = PAGE_SIZE - pageOffset;
    pageFrame = (PPFN_NUMBER)(Mdl+1);
    pageFrame += (((UINT_PTR)CurrentVa - (UINT_PTR) MmGetMdlBaseVa(Mdl)) >> PAGE_SHIFT);

    logicalAddress.QuadPart = (*pageFrame << PAGE_SHIFT) + pageOffset;

    // Find a run of contiguous pages in the buffer

    while ( transferLength < *Length ) {

        if (*pageFrame + 1 != *(pageFrame + 1)) {
            break;
        }

        transferLength += PAGE_SIZE;
        pageFrame++;

    }

    //
    // Limit the transferLength to the requested Length.
    //

    transferLength = transferLength > *Length ? *Length : transferLength;

    ASSERT(MapRegisterBase != NULL);

    //
    // Strip no scatter/gather flag.
    //

    translationEntry = (PTRANSLATION_ENTRY) ((UINT_PTR) MapRegisterBase & ~NO_SCATTER_GATHER);

    if ((UINT_PTR) MapRegisterBase & NO_SCATTER_GATHER
        && transferLength < *Length) {

        logicalAddress.QuadPart = translationEntry->PhysicalAddress + pageOffset;
        translationEntry->Index = COPY_BUFFER;
        index = 0;
        transferLength = *Length;
        useBuffer = TRUE;

    } else {

        //
        // If there are map registers, then update the index to indicate
        // how many have been used.
        //

        useBuffer = FALSE;
        index = translationEntry->Index;
        translationEntry->Index += ADDRESS_AND_SIZE_TO_SPAN_PAGES(
                                                                 CurrentVa,
                                                                 transferLength
                                                                 );
        //
        // PeterJ added the following to catch drivers which don't call
        // IoFlushAdapterBuffers.   Calling IoMapTransfer repeatedly
        // without calling IoFlushAdapterBuffers will run you out of
        // map registers,....  Some PCI device drivers think they can
        // get away with this because they do 32 bit direct transfers.
        // Try plugging one of these into a system with > 4GB and see
        // what happens to you.
        //

        //ASSERT(translationEntry->Index < AdapterObject->NumberOfMapRegisters);
    }

    //
    // It must require memory to be within the adapter's address range.  If the
    // logical address is greater than that which the adapter can directly
    // access then map registers must be used
    //

    maximumPhysicalAddress =
        HalpGetAdapterMaximumPhysicalAddress( AdapterObject );

    if ((ULONGLONG)(logicalAddress.QuadPart + transferLength - 1) >
        (ULONGLONG)maximumPhysicalAddress.QuadPart) {

        logicalAddress.QuadPart = (translationEntry + index)->PhysicalAddress +
                                  pageOffset;
        useBuffer = TRUE;

        if ((UINT_PTR) MapRegisterBase & NO_SCATTER_GATHER) {

            translationEntry->Index = COPY_BUFFER;
            index = 0;

        }

    }

    //
    // Copy the data if necessary.
    //

    if (useBuffer  &&  WriteToDevice) {
        HalpCopyBufferMap(
                         Mdl,
                         translationEntry + index,
                         CurrentVa,
                         transferLength,
                         WriteToDevice
                         );
    }

    //
    // Return the length.
    //

    *Length = transferLength;

    //
    // Return the logical address to transfer to.
    //

    returnAddress = logicalAddress;

    //
    // If no adapter was specificed then there is no more work to do so
    // return.
    //

    ASSERT(AdapterObject == NULL || AdapterObject->MasterDevice);

    return (returnAddress);
}

BOOLEAN
IoFlushAdapterBuffers(
                     IN PADAPTER_OBJECT AdapterObject,
                     IN PMDL Mdl,
                     IN PVOID MapRegisterBase,
                     IN PVOID CurrentVa,
                     IN ULONG Length,
                     IN BOOLEAN WriteToDevice
                     )

/*++

Routine Description:

    This routine flushes the DMA adapter object buffers.  For the Jazz system
    its clears the enable flag which aborts the dma.

Arguments:

    AdapterObject - Pointer to the adapter object representing the DMA
        controller channel.

    Mdl - A pointer to a Memory Descriptor List (MDL) that maps the locked-down
        buffer to/from which the I/O occured.

    MapRegisterBase - A pointer to the base of the map registers in the adapter
        or DMA controller.

    CurrentVa - The current virtual address in the buffer described the the Mdl
        where the I/O operation occurred.

    Length - Supplies the length of the transfer.

    WriteToDevice - Supplies a BOOLEAN value that indicates the direction of
        the data transfer was to the device.

Return Value:

    TRUE - No errors are detected so the transfer must succeed.

--*/

{
    PTRANSLATION_ENTRY translationEntry;
    PPFN_NUMBER pageFrame;
    ULONG transferLength;
    ULONG partialLength;
    PHYSICAL_ADDRESS maximumPhysicalAddress;
    ULONGLONG maximumPhysicalPage;

    ASSERT(AdapterObject == NULL || AdapterObject->MasterDevice);

    if (MapRegisterBase == NULL) {
        return (TRUE);
    }

    //
    // Determine if the data needs to be copied to the orginal buffer.
    // This only occurs if the data tranfer is from the device, the
    // MapReisterBase is not NULL and the transfer spans a page.
    //

    if (!WriteToDevice) {

        //
        // Strip no scatter/gather flag.
        //

        translationEntry = (PTRANSLATION_ENTRY) ((UINT_PTR) MapRegisterBase & ~NO_SCATTER_GATHER);

        //
        // If this is not a master device, then just transfer the buffer.
        //

        if ((UINT_PTR) MapRegisterBase & NO_SCATTER_GATHER) {

            if (translationEntry->Index == COPY_BUFFER) {

                //
                // The adapter does not support scatter/gather copy the buffer.
                //

                HalpCopyBufferMap(
                                 Mdl,
                                 translationEntry,
                                 CurrentVa,
                                 Length,
                                 WriteToDevice
                                 );

            }

        } else {

            //
            // Cycle through the pages of the transfer to determine if there
            // are any which need to be copied back.
            //

            maximumPhysicalAddress =
                HalpGetAdapterMaximumPhysicalAddress( AdapterObject );

            maximumPhysicalPage = (maximumPhysicalAddress.QuadPart >> PAGE_SHIFT);

            transferLength = PAGE_SIZE - BYTE_OFFSET(CurrentVa);
            partialLength = transferLength;
            pageFrame = (PPFN_NUMBER)(Mdl+1);
            pageFrame += (((UINT_PTR) CurrentVa - (UINT_PTR) MmGetMdlBaseVa(Mdl)) >> PAGE_SHIFT);

            while ( transferLength <= Length ) {

                if (*pageFrame > maximumPhysicalPage) {

                    HalpCopyBufferMap(
                                     Mdl,
                                     translationEntry,
                                     CurrentVa,
                                     partialLength,
                                     WriteToDevice
                                     );

                }

                (PCCHAR) CurrentVa += partialLength;
                partialLength = PAGE_SIZE;

                //
                // Note that transferLength indicates the amount which will be
                // transfered after the next loop; thus, it is updated with the
                // new partial length.
                //

                transferLength += partialLength;
                pageFrame++;
                translationEntry++;
            }

            //
            // Process the any remaining residue.
            //

            partialLength = Length - transferLength + partialLength;
            if (partialLength && *pageFrame > maximumPhysicalPage) {

                HalpCopyBufferMap(
                                 Mdl,
                                 translationEntry,
                                 CurrentVa,
                                 partialLength,
                                 WriteToDevice
                                 );

            }
        }
    }

    //
    // Strip no scatter/gather flag.
    //

    translationEntry = (PTRANSLATION_ENTRY) ((UINT_PTR) MapRegisterBase & ~NO_SCATTER_GATHER);

    //
    // Clear index in map register.
    //

    translationEntry->Index = 0;

    return TRUE;
}

ULONG
HalReadDmaCounter(
    IN PADAPTER_OBJECT AdapterObject
    )
/*++

Routine Description:

    This function reads the DMA counter and returns the number of bytes left
    to be transfered.

Arguments:

    AdapterObject - Supplies a pointer to the adapter object to be read.

Return Value:

    Returns the number of bytes still be be transfered.

--*/

{
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\ixpnpdrv.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ixpnpdrv.c

Abstract:

    Implements functionality necessary for the
    HAL to become a PnP-style device driver
    after system initialization.  This is done
    so that the HAL can enumerate the ACPI driver
    in the way that the PnP stuff expects.

Author:

    Jake Oshins (jakeo) 27-Jan-1997

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "exboosts.h"
#include "wchar.h"

//
// Cause the GUID to be defined.
//

#include "initguid.h"
#include "wdmguid.h"
#include "halpnpp.h"

#if DBG
ULONG HalDebug = 0;
#endif

extern WCHAR HalHardwareIdString[];

typedef enum {
    Hal = 0x80,
    AcpiDriver
} PDO_TYPE;

typedef enum {
    PdoExtensionType = 0xc0,
    FdoExtensionType
} EXTENSION_TYPE;

typedef struct _PDO_EXTENSION *PPDO_EXTENSION;
typedef struct _FDO_EXTENSION *PFDO_EXTENSION;

typedef struct _PDO_EXTENSION{
    EXTENSION_TYPE                  ExtensionType;
    PPDO_EXTENSION                  Next;
    PDEVICE_OBJECT                  PhysicalDeviceObject;
    PFDO_EXTENSION                  ParentFdoExtension;
    PDO_TYPE                        PdoType;
    LONG                            InterfaceReferenceCount;
} PDO_EXTENSION, *PPDO_EXTENSION;

#define ASSERT_PDO_EXTENSION(x) ASSERT((x)->ExtensionType == PdoExtensionType );

typedef struct _FDO_EXTENSION{
    EXTENSION_TYPE        ExtensionType;
    PPDO_EXTENSION        ChildPdoList;
    PDEVICE_OBJECT        PhysicalDeviceObject;  // PDO passed into AddDevice()
    PDEVICE_OBJECT        FunctionalDeviceObject;
    PDEVICE_OBJECT        AttachedDeviceObject;
} FDO_EXTENSION, *PFDO_EXTENSION;

#define ASSERT_FDO_EXTENSION(x) ASSERT((x)->ExtensionType == FdoExtensionType );

INT_ROUTE_INTERFACE_STANDARD PciIrqRoutingInterface = {0};

NTSTATUS
HalpDriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
HalpAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

NTSTATUS
HalpDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
HalpDispatchWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
HalpDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
HalpQueryDeviceRelations(
    IN PDEVICE_OBJECT       DeviceObject,
    IN DEVICE_RELATION_TYPE RelationType,
    OUT PDEVICE_RELATIONS *DeviceRelations
    );

NTSTATUS
HalpQueryIdPdo(
    IN PDEVICE_OBJECT PdoExtension,
    IN BUS_QUERY_ID_TYPE IdType,
    IN OUT PWSTR *BusQueryId
    );

NTSTATUS
HalpQueryIdFdo(
    IN PDEVICE_OBJECT PdoExtension,
    IN BUS_QUERY_ID_TYPE IdType,
    IN OUT PWSTR *BusQueryId
    );

NTSTATUS
HalpQueryCapabilities(
    IN PDEVICE_OBJECT PdoExtension,
    IN PDEVICE_CAPABILITIES Capabilities
    );

NTSTATUS
HalpQueryResources(
    PDEVICE_OBJECT DeviceObject,
    PCM_RESOURCE_LIST *Resources
    );

NTSTATUS
HalpQueryResourceRequirements(
    PDEVICE_OBJECT DeviceObject,
    PIO_RESOURCE_REQUIREMENTS_LIST *Requirements
    );

NTSTATUS
HalpQueryInterface(
    IN     PDEVICE_OBJECT   DeviceObject,
    IN     LPCGUID          InterfaceType,
    IN     USHORT           Version,
    IN     PVOID            InterfaceSpecificData,
    IN     ULONG            InterfaceBufferSize,
    IN OUT PINTERFACE       Interface,
    IN OUT PULONG           Length
    );

#ifdef WANT_IRQ_ROUTING

NTSTATUS
HalpQueryInterfaceFdo(
    IN     PDEVICE_OBJECT   DeviceObject,
    IN     LPCGUID          InterfaceType,
    IN     USHORT           Version,
    IN     PVOID            InterfaceSpecificData,
    IN     ULONG            InterfaceBufferSize,
    IN OUT PINTERFACE       Interface,
    IN OUT PULONG           Length
    );

#endif

NTSTATUS
HalIrqTranslateResourcesRoot(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
);

NTSTATUS
HalIrqTranslateResourceRequirementsRoot(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
);

VOID
HalpMaskAcpiInterrupt(
    VOID
    );

VOID
HalpUnmaskAcpiInterrupt(
    VOID
    );

// from xxacpi.c
NTSTATUS
HalpQueryAcpiResourceRequirements(
    IN  PIO_RESOURCE_REQUIREMENTS_LIST *Requirements
    );

VOID
HalpMarkAcpiHal(
    VOID
    );

NTSTATUS
HalpOpenRegistryKey(
    OUT PHANDLE Handle,
    IN HANDLE BaseHandle OPTIONAL,
    IN PUNICODE_STRING KeyName,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN Create
    );

//
//  Define the PNP interface functions.
//

VOID
HalPnpInterfaceReference(
    PVOID Context
    );

VOID
HalPnpInterfaceDereference(
    PVOID Context
    );

BOOLEAN
HalPnpTranslateBusAddress(
    IN PVOID Context,
    IN PHYSICAL_ADDRESS BusAddress,
    IN ULONG Length,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

struct _DMA_ADAPTER *
HalPnpGetDmaAdapter(
    IN PVOID Context,
    IN struct _DEVICE_DESCRIPTION *DeviceDescriptor,
    OUT PULONG NumberOfMapRegisters
    );

BOOLEAN
HalpFakeAcpiRegisters(
    VOID
    );

#define HAL_DRIVER_NAME  L"\\Driver\\ACPI_HAL"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, HaliInitPnpDriver)
#pragma alloc_text(PAGE, HalpMarkAcpiHal)
#pragma alloc_text(PAGE, HalpOpenRegistryKey)
#pragma alloc_text(PAGE, HalpDispatchPnp)
#pragma alloc_text(PAGE, HalpAddDevice)
#pragma alloc_text(PAGE, HalpDriverEntry)
#pragma alloc_text(PAGE, HalpQueryDeviceRelations)
#pragma alloc_text(PAGE, HalpQueryIdPdo)
#pragma alloc_text(PAGE, HalpQueryIdFdo)
#pragma alloc_text(PAGE, HalpQueryCapabilities)
#pragma alloc_text(PAGE, HalpQueryResources)
#pragma alloc_text(PAGE, HalpQueryResourceRequirements)
#pragma alloc_text(PAGE, HalpQueryInterface)
#ifdef WANT_IRQ_ROUTING
#pragma alloc_text(PAGE, HalpQueryInterfaceFdo)
#endif
#pragma alloc_text(PAGELK, HalpDispatchPower)
#pragma alloc_text(PAGE, HalpDispatchWmi)
#endif

PDRIVER_OBJECT HalpDriverObject;


NTSTATUS
HaliInitPnpDriver(
    VOID
    )
/*++

Routine Description:

    This routine starts the process of making the HAL into
    a "driver," which is necessary because we need to
    enumerate a Plug and Play PDO for the ACPI driver.

Arguments:

    DriverName - Unicode string that will be used for the
                 driver object.

Return Value:

    status

--*/
{

    UNICODE_STRING  DriverName;
    NTSTATUS Status;

    PAGED_CODE();

    RtlInitUnicodeString( &DriverName, HAL_DRIVER_NAME );

    Status = IoCreateDriver( &DriverName, HalpDriverEntry );

    HalpMarkAcpiHal();

    ASSERT( NT_SUCCESS( Status ));

    return Status;

}

VOID
HalpMarkAcpiHal(
    VOID
    )

/*++

Routine Description:


Arguments:

    None.

Return Value:

    None.

--*/
{
    ULONG tmpValue;
    UNICODE_STRING unicodeString;
    HANDLE hCurrentControlSet, handle;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Open/create System\CurrentControlSet key.
    //

    RtlInitUnicodeString(&unicodeString, L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET");
    status = HalpOpenRegistryKey (
                 &hCurrentControlSet,
                 NULL,
                 &unicodeString,
                 KEY_ALL_ACCESS,
                 FALSE
                 );
    if (!NT_SUCCESS(status)) {
        return;
    }

    //
    // Open HKLM\System\CurrentControlSet\Control\Pnp
    //

    RtlInitUnicodeString(&unicodeString, L"Control\\Pnp");
    status = HalpOpenRegistryKey (
                 &handle,
                 hCurrentControlSet,
                 &unicodeString,
                 KEY_ALL_ACCESS,
                 TRUE
                 );
    ZwClose(hCurrentControlSet);
    if (!NT_SUCCESS(status)) {
        return;
    }

    RtlInitUnicodeString(&unicodeString, L"DisableFirmwareMapper");
    tmpValue = 1;
    ZwSetValueKey(handle,
                  &unicodeString,
                  0,
                  REG_DWORD,
                  &tmpValue,
                  sizeof(tmpValue)
                  );
    ZwClose(handle);
}

NTSTATUS
HalpOpenRegistryKey(
    OUT PHANDLE Handle,
    IN HANDLE BaseHandle OPTIONAL,
    IN PUNICODE_STRING KeyName,
    IN ACCESS_MASK DesiredAccess,
    IN BOOLEAN Create
    )

/*++

Routine Description:

    Opens or creates a VOLATILE registry key using the name passed in based
    at the BaseHandle node.

Arguments:

    Handle - Pointer to the handle which will contain the registry key that
        was opened.

    BaseHandle - Handle to the base path from which the key must be opened.

    KeyName - Name of the Key that must be opened/created.

    DesiredAccess - Specifies the desired access that the caller needs to
        the key.

    Create - Determines if the key is to be created if it does not exist.

Return Value:

   The function value is the final status of the operation.

--*/

{
    OBJECT_ATTRIBUTES objectAttributes;
    ULONG disposition;

    PAGED_CODE();

    //
    // Initialize the object for the key.
    //

    InitializeObjectAttributes( &objectAttributes,
                                KeyName,
                                OBJ_CASE_INSENSITIVE,
                                BaseHandle,
                                (PSECURITY_DESCRIPTOR) NULL );

    //
    // Create the key or open it, as appropriate based on the caller's
    // wishes.
    //

    if (Create) {
        return ZwCreateKey( Handle,
                            DesiredAccess,
                            &objectAttributes,
                            0,
                            (PUNICODE_STRING) NULL,
                            REG_OPTION_VOLATILE,
                            &disposition );
    } else {
        return ZwOpenKey( Handle,
                          DesiredAccess,
                          &objectAttributes );
    }
}

NTSTATUS
HalpDriverEntry (
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This is the callback function when we call IoCreateDriver to create a
    PnP Driver Object.  In this function, we need to remember the DriverObject.

Arguments:

    DriverObject - Pointer to the driver object created by the system.

    RegistryPath - is NULL.

Return Value:

   STATUS_SUCCESS

--*/
{
    NTSTATUS status;
    PDEVICE_OBJECT detectedDeviceObject = NULL;
    ANSI_STRING    AKeyName;

    PAGED_CODE();

    //
    // File the pointer to our driver object away
    //
    HalpDriverObject = DriverObject;

    //
    // Fill in the driver object
    //
    DriverObject->DriverExtension->AddDevice = (PDRIVER_ADD_DEVICE)HalpAddDevice;
    DriverObject->MajorFunction[ IRP_MJ_PNP ] = HalpDispatchPnp;
    DriverObject->MajorFunction[ IRP_MJ_POWER ] = HalpDispatchPower;
    DriverObject->MajorFunction[ IRP_MJ_SYSTEM_CONTROL ] = HalpDispatchWmi;

    status = IoReportDetectedDevice(DriverObject,
                                    InterfaceTypeUndefined,
                                    -1,
                                    -1,
                                    NULL,
                                    NULL,
                                    FALSE,
                                    &detectedDeviceObject);

    ASSERT(detectedDeviceObject);
    if (!(NT_SUCCESS(status))) {
        return status;
    }

    HalpAddDevice(DriverObject,
                  detectedDeviceObject);

    return STATUS_SUCCESS;

}

NTSTATUS
HalpAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )

/*++

Routine Description:

    This routine handles AddDevice for an madeup PDO device.

Arguments:

    DriverObject - Pointer to our pseudo driver object.

    DeviceObject - Pointer to the device object for which this requestapplies.

Return Value:

    NT status.

--*/
{
    PDEVICE_OBJECT functionalDeviceObject;
    PDEVICE_OBJECT childDeviceObject;
    PDEVICE_OBJECT AttachedDevice;
    NTSTATUS       status;
    PFDO_EXTENSION FdoExtension;
    PPDO_EXTENSION PdoExtension;

    PAGED_CODE();

    //
    // We've been given the PhysicalDeviceObject.  Create the
    // FunctionalDeviceObject.  Our FDO will be nameless.
    //

    status = IoCreateDevice(
                DriverObject,               // our driver object
                sizeof(FDO_EXTENSION),      // size of our extension
                NULL,                       // our name
                FILE_DEVICE_BUS_EXTENDER,   // device type
                0,                          // device characteristics
                FALSE,                      // not exclusive
                &functionalDeviceObject     // store new device object here
                );

    if( !NT_SUCCESS( status )){

        DbgBreakPoint();
        return status;
    }

    //
    // Fill in the FDO extension
    //
    FdoExtension = (PFDO_EXTENSION)functionalDeviceObject->DeviceExtension;
    FdoExtension->ExtensionType = FdoExtensionType;
    FdoExtension->PhysicalDeviceObject = PhysicalDeviceObject;
    FdoExtension->FunctionalDeviceObject = functionalDeviceObject;

    functionalDeviceObject->Flags &= ~(DO_DEVICE_INITIALIZING);

    //
    // Now attach to the PDO we were given.
    //

    AttachedDevice = IoAttachDeviceToDeviceStack(functionalDeviceObject,
                                                 PhysicalDeviceObject );
    if(AttachedDevice == NULL){

        //
        // Couldn't attach.  Delete the FDO.
        //

        IoDeleteDevice( functionalDeviceObject );

        return STATUS_NO_SUCH_DEVICE;

    }

    FdoExtension->AttachedDeviceObject = AttachedDevice;

    //
    // Next, create a PDO for the ACPI driver.
    //
    status = IoCreateDevice(
                DriverObject,               // our driver object
                sizeof(PDO_EXTENSION),      // size of our extension
                NULL,                       // our name
                FILE_DEVICE_BUS_EXTENDER,   // device type
                FILE_AUTOGENERATED_DEVICE_NAME, // device characteristics
                FALSE,                      // not exclusive
                &childDeviceObject          // store new device object here
                );

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Fill in the PDO extension
    //
    PdoExtension = (PPDO_EXTENSION)childDeviceObject->DeviceExtension;
    PdoExtension->ExtensionType = PdoExtensionType;
    PdoExtension->Next = NULL;
    PdoExtension->PhysicalDeviceObject = childDeviceObject;
    PdoExtension->ParentFdoExtension = FdoExtension;
    PdoExtension->PdoType = AcpiDriver;

    childDeviceObject->Flags &= ~(DO_DEVICE_INITIALIZING);
    //
    // Record this as a child of the HAL
    //
    FdoExtension->ChildPdoList = PdoExtension;

    return STATUS_SUCCESS;
}

NTSTATUS
HalpPassIrpFromFdoToPdo(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Description:

    Given an FDO, pass the IRP to the next device object in the
    device stack.  This is the PDO if there are no lower level
    filters.

Arguments:

    DeviceObject - the Fdo
    Irp - the request

Return Value:

    Returns the result from calling the next level.

--*/

{

    PIO_STACK_LOCATION irpSp;       // our stack location
    PIO_STACK_LOCATION nextIrpSp;   // next guy's
    PFDO_EXTENSION     fdoExtension;

    //
    // Get the pointer to the device extension.
    //

    fdoExtension = (PFDO_EXTENSION)DeviceObject->DeviceExtension;

    IoSkipCurrentIrpStackLocation(Irp);

    //
    // Call the PDO driver with the request.
    //

    return IoCallDriver(fdoExtension->AttachedDeviceObject ,Irp);
}

NTSTATUS
HalpDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine handles all IRP_MJ_PNP IRPs for madeup PDO device.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP IRP to dispatch.

Return Value:

    NT status.

--*/
{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;
    ULONG length;
    DEVICE_RELATION_TYPE relationType;
    EXTENSION_TYPE  extensionType;
    BOOLEAN passDown;
    PUCHAR objectTypeString;

    PAGED_CODE();

    extensionType = ((PFDO_EXTENSION)(DeviceObject->DeviceExtension))->ExtensionType;

    //
    // Get a pointer to our stack location and take appropriate action based
    // on the minor function.
    //

    irpSp = IoGetCurrentIrpStackLocation(Irp);
    status = Irp->IoStatus.Status;
    switch (extensionType) {

    case PdoExtensionType:

        objectTypeString = "PDO";

        switch (irpSp->MinorFunction) {

        case IRP_MN_START_DEVICE:

            HalDebugPrint(( HAL_PNP, "HAL: (%s) Start_Device Irp received\n",
                            objectTypeString ));

            //
            // If we get a start device request for a PDO, we simply
            // return success.
            //

            status = STATUS_SUCCESS;
            break;

        case IRP_MN_QUERY_STOP_DEVICE:

            HalDebugPrint(( HAL_PNP, "HAL: (%s) Query_Stop_Device Irp received",
                            objectTypeString));

            status = STATUS_SUCCESS;
            break;

        case IRP_MN_CANCEL_STOP_DEVICE:

            HalDebugPrint(( HAL_PNP, "HAL: (%s) Cancel_Stop_Device Irp received",
                            objectTypeString ));

            status = STATUS_SUCCESS;
            break;


        case IRP_MN_STOP_DEVICE:

            HalDebugPrint(( HAL_PNP, "HAL: (%s) Stop_Device Irp received\n",
                            objectTypeString ));

            //
            // If we get a stop device request for a PDO, we simply
            // return success.
            //

            status = STATUS_SUCCESS;
            break;

        case IRP_MN_QUERY_RESOURCES:

            HalDebugPrint(( HAL_PNP, "HAL: (%s) Query_Resources Irp received\n",
                            objectTypeString ));

            status = HalpQueryResources(DeviceObject,
                         (PCM_RESOURCE_LIST*)&Irp->IoStatus.Information);

            break;

        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:

            HalDebugPrint(( HAL_PNP, "HAL: (%s) Query_Resource_Requirements Irp received\n",
                           objectTypeString ));

            status = HalpQueryResourceRequirements(DeviceObject,
                         (PIO_RESOURCE_REQUIREMENTS_LIST*)&Irp->IoStatus.Information);
            break;

        case IRP_MN_QUERY_REMOVE_DEVICE:

            HalDebugPrint(( HAL_PNP, "HAL: (%s) Query_Remove_device Irp for %p",
                            objectTypeString,
                            DeviceObject ));

            status = STATUS_UNSUCCESSFUL;
            break;

        case IRP_MN_CANCEL_REMOVE_DEVICE:

            HalDebugPrint(( HAL_PNP, "HAL: (%s) Cancel_Remove_device Irp for %p",
                            objectTypeString,
                            DeviceObject));

            status = STATUS_SUCCESS;
            break;

        case IRP_MN_REMOVE_DEVICE:

            HalDebugPrint(( HAL_PNP, "HAL: (%s) Remove_device Irp for PDO %p\n",
                            objectTypeString,
                            DeviceObject ));

            status = STATUS_SUCCESS;
            break;

        case IRP_MN_QUERY_DEVICE_RELATIONS:

            HalDebugPrint(( HAL_PNP, "HAL: (%s) Query_Device_Relations Irp received\n",
                            objectTypeString ));

            relationType = irpSp->Parameters.QueryDeviceRelations.Type;
            status = HalpQueryDeviceRelations(DeviceObject,
                                              relationType,
                                              (PDEVICE_RELATIONS*)&Irp->IoStatus.Information);
            break;


        case IRP_MN_QUERY_ID:

            HalDebugPrint(( HAL_PNP, "HAL: (%s) Query_Id Irp received\n",
                            objectTypeString ));

            status = HalpQueryIdPdo(DeviceObject,
                                 irpSp->Parameters.QueryId.IdType,
                                 (PWSTR*)&Irp->IoStatus.Information);

            break;

        case IRP_MN_QUERY_INTERFACE:

            HalDebugPrint(( HAL_PNP, "HAL: (%s) Query_Interface Irp received\n",
                            objectTypeString));

            status = HalpQueryInterface(
                         DeviceObject,
                         irpSp->Parameters.QueryInterface.InterfaceType,
                         irpSp->Parameters.QueryInterface.Version,
                         irpSp->Parameters.QueryInterface.InterfaceSpecificData,
                         irpSp->Parameters.QueryInterface.Size,
                         irpSp->Parameters.QueryInterface.Interface,
                         (PULONG)&Irp->IoStatus.Information
                         );
            break;

        case IRP_MN_QUERY_CAPABILITIES:

            HalDebugPrint(( HAL_PNP, "HAL: (%s) Query_Capabilities Irp received\n",
                            objectTypeString));

            status = HalpQueryCapabilities(DeviceObject,
                                           irpSp->Parameters.DeviceCapabilities.Capabilities);

            break;

        case IRP_MN_DEVICE_USAGE_NOTIFICATION:
            HalDebugPrint(( HAL_PNP, "HAL: DEVICE_USAGE Irp received\n" ));
            status = STATUS_SUCCESS;
            break;

        default:

            HalDebugPrint(( HAL_PNP, "HAL: (%s) Unsupported Irp (%d) received\n",
                            objectTypeString,
                            irpSp->MinorFunction));
            status = STATUS_NOT_SUPPORTED ;
            break;
        }

        break;  // end PDO cases

    case FdoExtensionType:

        objectTypeString = "FDO";
        passDown = TRUE;

        //
        // In case we don't touch this IRP, save the current status.
        //

        switch (irpSp->MinorFunction) {

        case IRP_MN_QUERY_DEVICE_RELATIONS:

            HalDebugPrint(( HAL_PNP, "HAL: (%s) Query_Device_Relations Irp received\n",
                            objectTypeString));

            relationType = irpSp->Parameters.QueryDeviceRelations.Type;
            status = HalpQueryDeviceRelations(DeviceObject,
                                              relationType,
                                              (PDEVICE_RELATIONS*)&Irp->IoStatus.Information);
            break;

        case IRP_MN_QUERY_INTERFACE:

#ifdef WANT_IRQ_ROUTING
        case IRP_MN_QUERY_INTERFACE:

            HalDebugPrint(( HAL_PNP, "(%s) Query_Interface Irp received",
                       objectTypeString));
            HalDebugPrint(( HAL_PNP, "HAL: (%s) Query_Interface Irp received",
                            objectTypeString ));
            Status = HalpQueryInterfaceFdo(
                         DeviceObject,
                         irpSp->Parameters.QueryInterface.InterfaceType,
                         irpSp->Parameters.QueryInterface.Version,
                         irpSp->Parameters.QueryInterface.InterfaceSpecificData,
                         irpSp->Parameters.QueryInterface.Size,
                         irpSp->Parameters.QueryInterface.Interface,
                         &Irp->IoStatus.Information
                         );
            break;

#endif

        case IRP_MN_QUERY_ID:

            HalDebugPrint(( HAL_PNP, "HAL: (%s) Query_Id Irp received\n",
                            objectTypeString ));

            status = HalpQueryIdFdo(DeviceObject,
                                 irpSp->Parameters.QueryId.IdType,
                                 (PWSTR*)&Irp->IoStatus.Information);

            break;

        default:

            //
            // Ignore any PNP Irps unknown by the FDO but allow them
            // down to the PDO.
            //

            status = STATUS_NOT_SUPPORTED ;
            break;
        }

        if (passDown && (NT_SUCCESS(status) || (status == STATUS_NOT_SUPPORTED))) {

            //
            // Pass FDO IRPs down to the PDO.
            //
            // Set Irp status first.
            //
            if (status != STATUS_NOT_SUPPORTED) {

                Irp->IoStatus.Status = status;
            }

            HalDebugPrint(( HAL_PNP, "HAL: (%s) Passing down Irp (%x)\n",
                            objectTypeString, irpSp->MinorFunction ));
            return HalpPassIrpFromFdoToPdo(DeviceObject, Irp);
        }

        break;  // end FDO cases

    default:

        HalDebugPrint(( HAL_PNP, "HAL: Received IRP for unknown Device Object\n" ));
        status = STATUS_INVALID_DEVICE_REQUEST ;
        break;

    }

    //
    // Complete the Irp and return.
    //

    if (status != STATUS_NOT_SUPPORTED) {

        Irp->IoStatus.Status = status;

    } else {

        status = Irp->IoStatus.Status ;
    }

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return status;
}

NTSTATUS
HalpDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )

/*++

Routine Description:

    This routine handles all IRP_MJ_POWER IRPs for madeup PDO device.
    Note: We don't actually handle any Power IRPs at this level so
    all we do is return the status from the incoming IRP.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_POWER IRP to dispatch.

Return Value:

    NT status.

--*/
{
    NTSTATUS Status;
    EXTENSION_TYPE  extensionType;
    PIO_STACK_LOCATION irpSp;

    HalDebugPrint(( HAL_PNP, "HAL:  Power IRP for DevObj: %p\n", DeviceObject ));

    extensionType = ((PFDO_EXTENSION)(DeviceObject->DeviceExtension))->ExtensionType;

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Simply store the appropriate status and complete the request.
    //

    Status = Irp->IoStatus.Status;

    PoStartNextPowerIrp(Irp);

    if (extensionType == FdoExtensionType) {

        switch (irpSp->MinorFunction) {
        case IRP_MN_SET_POWER:

            if (irpSp->Parameters.Power.Type == SystemPowerState) {

                if (irpSp->Parameters.Power.State.SystemState ==
                    PowerSystemWorking) {

                    HalpUnmaskAcpiInterrupt();

                } else {

                    HalpMaskAcpiInterrupt();
                }
            }

            //
            // Fall through.
            //

        case IRP_MN_QUERY_POWER:

            Irp->IoStatus.Status = Status = STATUS_SUCCESS;

            //
            // Fall through.
            //

        default:

            Status = HalpPassIrpFromFdoToPdo(DeviceObject, Irp);
            break;
        }

    } else {

        switch (irpSp->MinorFunction) {
        case IRP_MN_SET_POWER:
        case IRP_MN_QUERY_POWER:

            Irp->IoStatus.Status = Status = STATUS_SUCCESS;

            //
            // Fall through.
            //

        default:
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            break;
        }
    }

    return Status;
}

NTSTATUS
HalpDispatchWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS Status;
    EXTENSION_TYPE  extensionType;

    extensionType = ((PFDO_EXTENSION)(DeviceObject->DeviceExtension))->ExtensionType;

    if (extensionType == FdoExtensionType) {
        Status = HalpPassIrpFromFdoToPdo(DeviceObject, Irp);
    } else {
        Status = Irp->IoStatus.Status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return Status;
}

NTSTATUS
HalpQueryDeviceRelations(
    IN PDEVICE_OBJECT       DeviceObject,
    IN DEVICE_RELATION_TYPE RelationType,
    OUT PDEVICE_RELATIONS   *DeviceRelations
    )
/*++

Routine Description:

    This routine builds a DEVICE_RELATIONS structure that
    tells the PnP manager how many children we have.

Arguments:

    DeviceObject - FDO of ACPI_HAL

    RelationType - we only respond to BusRelations

    DeviceRelations - pointer to the structure

Return Value:

    status

--*/
{
    PFDO_EXTENSION  FdoExtension;
    PDEVICE_RELATIONS   relations = NULL;
    PDEVICE_OBJECT deviceObjectToReturn ;
    EXTENSION_TYPE  extensionType;
    NTSTATUS status ;

    PAGED_CODE();

    FdoExtension = (PFDO_EXTENSION)DeviceObject->DeviceExtension;
    extensionType = FdoExtension->ExtensionType;
    status = STATUS_NOT_SUPPORTED ;

    switch(RelationType) {

        case BusRelations:

            if (extensionType == FdoExtensionType) {
                deviceObjectToReturn = FdoExtension->ChildPdoList->PhysicalDeviceObject ;
                status = STATUS_SUCCESS ;
            }
            break;

        case TargetDeviceRelation:

            if (extensionType == PdoExtensionType) {

                deviceObjectToReturn = DeviceObject ;
                status = STATUS_SUCCESS ;
            }
            break;
    }

    if (status == STATUS_NOT_SUPPORTED) {

        HalDebugPrint(( HAL_PNP, "HAL:  We don't support this kind of device relation\n" ));

    } else if (NT_SUCCESS(status)) {

        ASSERT(*DeviceRelations == 0);

        relations = ExAllocatePoolWithTag(
            PagedPool,
            sizeof(DEVICE_RELATIONS),
            HAL_POOL_TAG
            );

        if (!relations) {

            status = STATUS_INSUFFICIENT_RESOURCES;

        } else {

            relations->Count = 1;
            relations->Objects[0] = deviceObjectToReturn ;

            ObReferenceObject(relations->Objects[0]);
            *DeviceRelations = relations;
        }
    }

    return status ;
}

NTSTATUS
HalpQueryIdPdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN BUS_QUERY_ID_TYPE IdType,
    IN OUT PWSTR *BusQueryId
    )
/*++

Routine Description:

    This routine identifies each of the children that were
    enumerated in HalpQueryDeviceRelations.

Arguments:

    DeviceObject - PDO of the child

    IdType - the type of ID to be returned, currently ignored

    BusQueryId - pointer to the wide string being returned

Return Value:

    status

--*/
{
    PPDO_EXTENSION  PdoExtension = DeviceObject->DeviceExtension;
    PWSTR idString;
    PWCHAR sourceString;
    ULONG stringLen;
    static WCHAR AcpiHardwareIdString[] = L"ACPI_HAL\\PNP0C08\0*PNP0C08";
    static WCHAR AcpiCompatibleString[] = L"*PNP0C08";
    static WCHAR AcpiInstanceIdString[] = L"0";

    PAGED_CODE();

    switch (IdType) {
    case BusQueryDeviceID:
    case BusQueryHardwareIDs:

        switch (PdoExtension->PdoType) {
        case AcpiDriver:
            sourceString = AcpiHardwareIdString;
            stringLen = sizeof(AcpiHardwareIdString);
            break;

        default:
            return STATUS_NOT_SUPPORTED;

        }
        break;

    case BusQueryCompatibleIDs:
        return STATUS_NOT_SUPPORTED;
        break;

    case BusQueryInstanceID:
        sourceString = AcpiInstanceIdString;
        stringLen = sizeof(AcpiInstanceIdString);
        break;

    default:
        return STATUS_NOT_SUPPORTED;
    }

    idString = ExAllocatePoolWithTag(PagedPool,
                                     stringLen + sizeof(UNICODE_NULL),
                                     HAL_POOL_TAG);

    if (!idString) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlCopyMemory(idString,
                  sourceString, stringLen);

    *(idString + stringLen / sizeof(WCHAR)) = UNICODE_NULL;

    *BusQueryId = idString;

    return STATUS_SUCCESS;
}
NTSTATUS
HalpQueryIdFdo(
    IN PDEVICE_OBJECT DeviceObject,
    IN BUS_QUERY_ID_TYPE IdType,
    IN OUT PWSTR *BusQueryId
    )
/*++

Routine Description:

    This routine identifies each of the children that were
    enumerated in HalpQueryDeviceRelations.

Arguments:

    DeviceObject - PDO of the child

    IdType - the type of ID to be returned.

    BusQueryId - pointer to the wide string being returned

Return Value:

    status

--*/
{
    PPDO_EXTENSION  PdoExtension = DeviceObject->DeviceExtension;
    PWSTR idString;
    PWCHAR sourceString = NULL;
    ULONG stringLen;
    UNICODE_STRING String;
    WCHAR Buffer[16];
    NTSTATUS Status;
    PWCHAR widechar;
    static WCHAR HalInstanceIdString[] = L"0";

    PAGED_CODE();

    switch (IdType) {
    case BusQueryDeviceID:
    case BusQueryHardwareIDs:

        sourceString = HalHardwareIdString;
        widechar = (PWCHAR)&HalHardwareIdString;
        while (*widechar != 0) widechar++;
        stringLen =  (ULONG)((PUCHAR)widechar - ((PUCHAR)&HalHardwareIdString) + 2);

        break;

    case BusQueryInstanceID:

        sourceString = HalInstanceIdString;
        stringLen = sizeof(HalInstanceIdString);
        break;

    default:
        break;
    }
    if (sourceString) {

        //
        // Note that hardware IDs and compatible IDs must be terminated by
        // 2 NULLs.
        //

        idString = ExAllocatePoolWithTag(PagedPool,
                                         stringLen + sizeof(UNICODE_NULL),
                                         HAL_POOL_TAG);

        if (!idString) {
            HalDebugPrint(( HAL_PNP, "HalpQueryIdFdo: couldn't allocate pool\n" ));
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlCopyMemory(idString,
                      sourceString, stringLen);

        *(idString + stringLen / sizeof(WCHAR)) = UNICODE_NULL;

        *BusQueryId = idString;

        return STATUS_SUCCESS;
    } else {
        return STATUS_NOT_SUPPORTED;
    }
}

NTSTATUS
HalpQueryCapabilities(
    IN PDEVICE_OBJECT PdoExtension,
    IN PDEVICE_CAPABILITIES Capabilities
    )
/*++

Routine Description:

    This routine fills in the DEVICE_CAPABILITIES structure for
    a device.

Arguments:

    DeviceObject - PDO of the child

    Capabilities - pointer to the structure to be filled in.

Return Value:

    status

--*/
{
    PAGED_CODE();

    ASSERT(Capabilities->Version == 1);
    if (Capabilities->Version != 1) {

        return STATUS_NOT_SUPPORTED;

    }

    Capabilities->LockSupported = FALSE;
    Capabilities->EjectSupported = FALSE;
    Capabilities->Removable = FALSE;
    Capabilities->DockDevice = FALSE;
    Capabilities->UniqueID = TRUE;
    Capabilities->SilentInstall = TRUE;
    Capabilities->RawDeviceOK = FALSE;
    Capabilities->Address = 0xffffffff;
    Capabilities->UINumber = 0xffffffff;
    Capabilities->D1Latency = 0;
    Capabilities->D2Latency = 0;
    Capabilities->D3Latency = 0;

    //
    // Default S->D mapping
    //
    Capabilities->DeviceState[PowerSystemWorking] = PowerDeviceD0;
    Capabilities->DeviceState[PowerSystemHibernate] = PowerDeviceD3;
    Capabilities->DeviceState[PowerSystemShutdown] = PowerDeviceD3;

    return STATUS_SUCCESS;
}

NTSTATUS
HalpQueryResources(
    PDEVICE_OBJECT DeviceObject,
    PCM_RESOURCE_LIST *Resources
    )
{
    PIO_RESOURCE_REQUIREMENTS_LIST requirements;
    PPDO_EXTENSION  PdoExtension = DeviceObject->DeviceExtension;
    PIO_RESOURCE_DESCRIPTOR descriptor;
    PCM_RESOURCE_LIST cmResList;
    NTSTATUS status;
    ULONG i;

    PAGED_CODE();

    if (PdoExtension->PdoType == AcpiDriver) {

        //
        // The whole point behind creating a boot config for the
        // ACPI PDO is that the PnP Manager will not terminate
        // its algorithm that tries to reserve boot configs for
        // all of ACPI's children.  So it is not necessary that
        // ACPI have a complicated list of resources in its boot
        // config.  We'll be happy with just the IRQ.
        //
        // N.B.  At the time of this writing, it should also be
        // true that the IRQ is the only resource that the ACPI
        // claims anyhow.
        //

        status = HalpQueryAcpiResourceRequirements(&requirements);

        if (!NT_SUCCESS(status)) {
            return status;
        }

        cmResList = ExAllocatePoolWithTag(PagedPool,
                                          sizeof(CM_RESOURCE_LIST),
                                          HAL_POOL_TAG);

        if (!cmResList) {
            ExFreePool(requirements);
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        RtlZeroMemory(cmResList, sizeof(CM_RESOURCE_LIST));

        cmResList->Count = 1;
        cmResList->List[0].InterfaceType = PNPBus;
        cmResList->List[0].BusNumber     = -1;
        cmResList->List[0].PartialResourceList.Version = 1;
        cmResList->List[0].PartialResourceList.Revision = 1;
        cmResList->List[0].PartialResourceList.Count = 1;
        cmResList->List[0].PartialResourceList.PartialDescriptors[0].Type =
            CmResourceTypeInterrupt;

        ASSERT(requirements->AlternativeLists == 1);

        for (i = 0; i < requirements->List[0].Count; i++) {

            descriptor = &requirements->List[0].Descriptors[i];

            if (descriptor->Type == CmResourceTypeInterrupt) {

                cmResList->List[0].PartialResourceList.PartialDescriptors[0].ShareDisposition =
                    descriptor->ShareDisposition;
                cmResList->List[0].PartialResourceList.PartialDescriptors[0].Flags =
                    descriptor->Flags;

                ASSERT(descriptor->u.Interrupt.MinimumVector ==
                       descriptor->u.Interrupt.MaximumVector);

                cmResList->List[0].PartialResourceList.PartialDescriptors[0].u.Interrupt.Level =
                    descriptor->u.Interrupt.MinimumVector;

                cmResList->List[0].PartialResourceList.PartialDescriptors[0].u.Interrupt.Vector =
                    descriptor->u.Interrupt.MinimumVector;

                cmResList->List[0].PartialResourceList.PartialDescriptors[0].u.Interrupt.Affinity = -1;

                *Resources = cmResList;

                ExFreePool(requirements);
                return STATUS_SUCCESS;
            }
        }

        ExFreePool(requirements);
        ExFreePool(cmResList);
        return STATUS_NOT_FOUND;

    } else {
        return STATUS_NOT_SUPPORTED;
    }
}


NTSTATUS
HalpQueryResourceRequirements(
    IN  PDEVICE_OBJECT DeviceObject,
    IN  PIO_RESOURCE_REQUIREMENTS_LIST *Requirements
    )
/*++

Routine Description:

    This routine handles IRP_MN_QUERY_RESOURCE_REQUIREMENTS.

Arguments:

    DeviceObject - PDO of the child

    Requirements - pointer to be filled in with the devices
        resource requirements.

Return Value:

    status

--*/
{
    PPDO_EXTENSION  PdoExtension = DeviceObject->DeviceExtension;

    PAGED_CODE();

    if (PdoExtension->PdoType == AcpiDriver) {

        return HalpQueryAcpiResourceRequirements(Requirements);

    } else {
        return STATUS_NOT_SUPPORTED;
    }
}

NTSTATUS
HalpQueryInterface(
    IN     PDEVICE_OBJECT   DeviceObject,
    IN     LPCGUID          InterfaceType,
    IN     USHORT           Version,
    IN     PVOID            InterfaceSpecificData,
    IN     ULONG            InterfaceBufferSize,
    IN OUT PINTERFACE       Interface,
    IN OUT PULONG           Length
    )

/*++

Routine Description:

    This routine fills in the interface structure for a device.

Arguments:

    DeviceObject            - PDO of the child
    InterfaceType           - Pointer to the interface type GUID.
    Version                 - Supplies the requested interface version.
    InterfaceSpecificData   - This is context that means something based on the interface.
    Interface Buffer Size   - Supplies the length of a buffer for the interface structure.
    Interface               - Supplies a pointer where interference information should be returned.ointer to the supplied interface buffer.
    Length                  - The value is updated on return to actual number of bytes modified.

Return Value:

    status

--*/
{
    PPDO_EXTENSION PdoExtension = (PPDO_EXTENSION)DeviceObject->DeviceExtension;
    CM_RESOURCE_TYPE resource = (CM_RESOURCE_TYPE)(INT_PTR)InterfaceSpecificData;

    PAGED_CODE();

    ASSERT_PDO_EXTENSION(PdoExtension);

    if (IsEqualGUID(&GUID_BUS_INTERFACE_STANDARD, InterfaceType)) {

        PBUS_INTERFACE_STANDARD standard = (PBUS_INTERFACE_STANDARD)Interface;

        //
        // ASSERT we know about all of the fields in the structure.
        //

        ASSERT(sizeof(BUS_INTERFACE_STANDARD) == FIELD_OFFSET(BUS_INTERFACE_STANDARD, GetBusData) + sizeof(PGET_SET_DEVICE_DATA));

        *Length = sizeof(BUS_INTERFACE_STANDARD);

        if (InterfaceBufferSize < sizeof(BUS_INTERFACE_STANDARD)) {
            return STATUS_BUFFER_TOO_SMALL;
        }

        //
        //  The only version this code knows about is 1.
        //

        standard->Size = sizeof(BUS_INTERFACE_STANDARD);
        standard->Version = HAL_BUS_INTERFACE_STD_VERSION;
        standard->Context = DeviceObject;

        standard->InterfaceReference = HalPnpInterfaceReference;
        standard->InterfaceDereference = HalPnpInterfaceDereference;
        standard->TranslateBusAddress = HalPnpTranslateBusAddress;
        standard->GetDmaAdapter = HalPnpGetDmaAdapter;
        standard->SetBusData = NULL;
        standard->GetBusData = NULL;

    } else if (IsEqualGUID(&GUID_TRANSLATOR_INTERFACE_STANDARD, InterfaceType)) {

        PTRANSLATOR_INTERFACE translator = (PTRANSLATOR_INTERFACE)Interface;

        //
        // Common initialization.
        //

        if (InterfaceBufferSize < sizeof(TRANSLATOR_INTERFACE)) {
            *Length = sizeof(TRANSLATOR_INTERFACE);
            return STATUS_BUFFER_TOO_SMALL;
        }

        switch ((CM_RESOURCE_TYPE)(INT_PTR)InterfaceSpecificData) {

        case CmResourceTypeInterrupt:

            translator->Size = sizeof(TRANSLATOR_INTERFACE);
            translator->Version = HAL_IRQ_TRANSLATOR_VERSION;
            translator->Context = DeviceObject;
            translator->InterfaceReference = HalTranslatorReference;
            translator->InterfaceDereference = HalTranslatorDereference;
            translator->TranslateResources = HalIrqTranslateResourcesRoot;
            translator->TranslateResourceRequirements =
                HalIrqTranslateResourceRequirementsRoot;
            *Length = sizeof(TRANSLATOR_INTERFACE);

            break;

        default:
            return STATUS_NOT_SUPPORTED;
        }

    } else if (IsEqualGUID(&GUID_ACPI_REGS_INTERFACE_STANDARD, InterfaceType)) {

        //
        // ACPI register function interface.
        //

        PACPI_REGS_INTERFACE_STANDARD AcpiRegInterface =
          (PACPI_REGS_INTERFACE_STANDARD)Interface;

        if (!HalpFakeAcpiRegisters()) {
            return STATUS_NOT_FOUND;
        }

        DbgPrint("Faking ACPI registers\n");

        //
        // Common initialization.
        //
        *Length = sizeof(ACPI_REGS_INTERFACE_STANDARD);

        if (InterfaceBufferSize < sizeof(ACPI_REGS_INTERFACE_STANDARD)) {
            return STATUS_BUFFER_TOO_SMALL;
        }

        AcpiRegInterface->Size = sizeof(ACPI_REGS_INTERFACE_STANDARD);
        AcpiRegInterface->Context = NULL;
        AcpiRegInterface->InterfaceReference = HalTranslatorReference;
        AcpiRegInterface->InterfaceDereference = HalTranslatorDereference;

        //
        // Set the two ACPI register access routines.
        //

        AcpiRegInterface->ReadAcpiRegister = HalpReadAcpiRegister;
        AcpiRegInterface->WriteAcpiRegister = HalpWriteAcpiRegister;

    } else if (IsEqualGUID(&GUID_ACPI_PORT_RANGES_INTERFACE_STANDARD,
                           InterfaceType)) {

        PHAL_PORT_RANGE_INTERFACE PortRanges = (PHAL_PORT_RANGE_INTERFACE)Interface;

        *Length = sizeof(HAL_PORT_RANGE_INTERFACE);

        if (InterfaceBufferSize < sizeof(HAL_PORT_RANGE_INTERFACE)) {
            return STATUS_BUFFER_TOO_SMALL;
        }

        PortRanges->Size = sizeof(HAL_PORT_RANGE_INTERFACE);
        PortRanges->Version = HAL_PORT_RANGE_INTERFACE_VERSION;
        PortRanges->Context = DeviceObject;
        PortRanges->InterfaceReference = HalPnpInterfaceReference;
        PortRanges->InterfaceDereference = HalPnpInterfaceDereference;

        PortRanges->QueryAllocateRange = HalpQueryAllocatePortRange;
        PortRanges->FreeRange = HalpFreePortRange;

    } else {

        //
        //  Unsupport bus interface type.
        //

        return STATUS_NOT_SUPPORTED ;
    }

    //
    // Bump the reference count.
    //

    InterlockedIncrement(&PdoExtension->InterfaceReferenceCount);

    return STATUS_SUCCESS;
}

#ifdef WANT_IRQ_ROUTING

NTSTATUS
HalpQueryInterfaceFdo(
    IN     PDEVICE_OBJECT   DeviceObject,
    IN     LPCGUID          InterfaceType,
    IN     USHORT           Version,
    IN     PVOID            InterfaceSpecificData,
    IN     ULONG            InterfaceBufferSize,
    IN OUT PINTERFACE       Interface,
    IN OUT PULONG           Length
    )

/*++

Routine Description:

    This routine fills in the interface structure for
    a device.

Arguments:

    DeviceObject - FDO of the child

    InterfaceType - Pointer to the interface type GUID.

    Version - Supplies the requested interface version.

    InterfaceSpecificData - This is context that means something based on the
                            interface.

    InterfaceBufferSize - Supplies the length of the buffer for the interface
                          structure.

    Interface - Supplies a pointer where the interface informaiton should
        be returned.

    Length - Supplies the length of the buffer for the interface structure.
        This value is updated on return to actual number of bytes modified.

Return Value:

    status

--*/
{
    NTSTATUS                status = STATUS_NOT_SUPPORTED;
    CM_RESOURCE_TYPE        resource = (CM_RESOURCE_TYPE)InterfaceSpecificData;

    PAGED_CODE();

    if (    resource == CmResourceTypeInterrupt &&
            IsPciIrqRoutingEnabled()) {

        if (IsEqualGUID(&GUID_ARBITER_INTERFACE_STANDARD, InterfaceType)) {

            status = HalpInitIrqArbiter(DeviceObject);

            if (NT_SUCCESS(status))
            {
                status = HalpFillInIrqArbiter(
                    DeviceObject,
                    InterfaceType,
                    Version,
                    InterfaceSpecificData,
                    InterfaceBufferSize,
                    Interface,
                    Length
                    );
            }
        }
        else if (IsEqualGUID(&GUID_TRANSLATOR_INTERFACE_STANDARD, InterfaceType)) {

            PTRANSLATOR_INTERFACE   translator;

            *Length = sizeof(TRANSLATOR_INTERFACE);
            if (InterfaceBufferSize < sizeof(TRANSLATOR_INTERFACE)) {
                return STATUS_BUFFER_TOO_SMALL;
            }

            translator = (PTRANSLATOR_INTERFACE)Interface;

            //
            // Fill in the common bits.
            //

            RtlZeroMemory(translator, sizeof (TRANSLATOR_INTERFACE));
            translator->Size = sizeof(TRANSLATOR_INTERFACE);
            translator->Version = HAL_IRQ_TRANSLATOR_VERSION;
            translator->Context = DeviceObject;
            translator->InterfaceReference = HalTranslatorReference;
            translator->InterfaceDereference = HalTranslatorDereference;

            //
            // Set IRQ translator for PCI interrupts.
            //

            translator->TranslateResources = HalIrqTranslateResourcesRoot;
            translator->TranslateResourceRequirements =
                                            HalIrqTranslateResourceRequirementsRoot;

            status = STATUS_SUCCESS;

            HalDebugPrint(( HAL_PNP, "Providing Irq translator for FDO %p since Pci Irq Routing is enabled!", DeviceObject));
        }
    }

    return (status);
}

#endif

VOID
HalPnpInterfaceReference(
    PVOID Context
    )
/*++

Routine Description:

    This function increments the reference count on the interface context.

Arguments:

    Context - Supplies a pointer to the interface context.  This is actually
        the PDO for the root bus.

Return Value:

    None

--*/
{
    PPDO_EXTENSION  PdoExtension = ((PDEVICE_OBJECT) Context)->DeviceExtension;
    PAGED_CODE();

    ASSERT_PDO_EXTENSION( PdoExtension );

    InterlockedIncrement( &PdoExtension->InterfaceReferenceCount );
}

VOID
HalPnpInterfaceDereference(
    PVOID Context
    )
/*++

Routine Description:

    This function decrements the reference count on the interface context.

Arguments:

    Context - Supplies a pointer to the interface context.  This is actually
        the PDO for the root bus.

Return Value:

    None

--*/
{
    PPDO_EXTENSION  PdoExtension = ((PDEVICE_OBJECT) Context)->DeviceExtension;
    LONG Result;

    PAGED_CODE();

    ASSERT_PDO_EXTENSION( PdoExtension );

    Result = InterlockedDecrement( &PdoExtension->InterfaceReferenceCount );

    ASSERT( Result >= 0 );
}

BOOLEAN
HalPnpTranslateBusAddress(
    IN PVOID Context,
    IN PHYSICAL_ADDRESS BusAddress,
    IN ULONG Length,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )
/*++

Routine Description:

    This function is used to translate bus addresses from legacy drivers.  It really
    should never get called on an ACPI system as the PCI or ACPI driver should field
    these requests before it gets here.

Arguments:

    Context - Supplies a pointer to the interface context.  This is actually
        the PDO for the root bus.

    BusAddress - Supplies the orginal address to be translated.

    Length - Supplies the length of the range to be translated.

    AddressSpace - Points to the location of of the address space type such as
        memory or I/O port.  This value is updated by the translation.

    TranslatedAddress - Returns the translated address.

Return Value:

    Returns a boolean indicating if the operations was a success.

--*/
{
    HalDebugPrint(( HAL_PNP, "HAL: HalPnpTranslateBusAddress Called, BusAddress = %p\n", BusAddress ));

    *TranslatedAddress = BusAddress;

    return TRUE;
}

PDMA_ADAPTER
HalPnpGetDmaAdapter(
    IN PVOID Context,
    IN struct _DEVICE_DESCRIPTION *DeviceDescriptor,
    OUT PULONG NumberOfMapRegisters
    )
/*++

Routine Description:

    This function writes the PCI configuration space.

Arguments:

    Context - Supplies a pointer  to the interface context.  This is actually
        the PDO for the root bus.

    DeviceDescriptor - Supplies the device descriptor used to allocate the dma
        adapter object.

    NubmerOfMapRegisters - Returns the maximum number of map registers a device
        can allocate at one time.

Return Value:

    Returns a DMA adapter or NULL.

--*/
{
    PPDO_EXTENSION  PdoExtension = ((PDEVICE_OBJECT) Context)->DeviceExtension;
    PAGED_CODE();

    ASSERT_PDO_EXTENSION( PdoExtension );


    //
    //  Fill in the bus number.
    //

    return (PDMA_ADAPTER) HalGetAdapter( DeviceDescriptor, NumberOfMapRegisters );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\ixphwsup.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    ixphwsup.c

Abstract:

    This module contains the HalpXxx routines for the NT I/O system that
    are hardware dependent.  Were these routines not hardware dependent,
    they would normally reside in the internal.c module.

Author:

    Darryl E. Havens (darrylh) 11-Apr-1990

Environment:

    Kernel mode, local to I/O system

Revision History:


--*/

#include "halp.h"
#include "mca.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,HalpAllocateAdapter)
#pragma alloc_text(PAGELK,HalpGrowMapBuffers)
#endif


//
// Some devices require a physically contiguous data buffer for DMA transfers.
// Map registers are used to give the appearance that all data buffers are
// contiguous.  In order to pool all of the map registers a master
// adapter object is used.  This object is allocated and saved internal to this
// file.  It contains a bit map for allocation of the registers and a queue
// for requests which are waiting for more map registers.  This object is
// allocated during the first request to allocate an adapter which requires
// map registers.
//

PADAPTER_OBJECT MasterAdapterObject;

#define ADAPTER_BASE_MASTER    ((PVOID)-1)

//
// Map buffer prameters.  These are initialized in HalInitSystem.
//

PHYSICAL_ADDRESS HalpMapBufferPhysicalAddress;
ULONG HalpMapBufferSize;

//
// Define DMA operations structure.
//

DMA_OPERATIONS HalpDmaOperations = {
    sizeof(DMA_OPERATIONS),
    (PPUT_DMA_ADAPTER) HalPutDmaAdapter,
    (PALLOCATE_COMMON_BUFFER) HalAllocateCommonBuffer,
    (PFREE_COMMON_BUFFER) HalFreeCommonBuffer,
    (PALLOCATE_ADAPTER_CHANNEL) HalRealAllocateAdapterChannel,
    (PFLUSH_ADAPTER_BUFFERS) IoFlushAdapterBuffers,
    (PFREE_ADAPTER_CHANNEL) IoFreeAdapterChannel,
    (PFREE_MAP_REGISTERS) IoFreeMapRegisters,
    (PMAP_TRANSFER) IoMapTransfer,
    (PGET_DMA_ALIGNMENT) HalGetDmaAlignment,
    (PREAD_DMA_COUNTER) HalReadDmaCounter,
    (PGET_SCATTER_GATHER_LIST) HalGetScatterGatherList,
    (PPUT_SCATTER_GATHER_LIST) HalPutScatterGatherList,
    (PCALCULATE_SCATTER_GATHER_LIST_SIZE)HalCalculateScatterGatherListSize,
    (PBUILD_SCATTER_GATHER_LIST) HalBuildScatterGatherList,
    (PBUILD_MDL_FROM_SCATTER_GATHER_LIST) HalBuildMdlFromScatterGatherList
    };



BOOLEAN
HalpGrowMapBuffers(
    PADAPTER_OBJECT AdapterObject,
    ULONG Amount
    )
/*++

Routine Description:

    This function attempts to allocate additional map buffers for use by I/O
    devices.  The map register table is updated to indicate the additional
    buffers.

    Caller owns the HalpNewAdapter event

Arguments:

    AdapterObject - Supplies the adapter object for which the buffers are to be
        allocated.

    Amount - Indicates the size of the map buffers which should be allocated.

Return Value:

    TRUE is returned if the memory could be allocated.

    FALSE is returned if the memory could not be allocated.

--*/
{
    ULONG MapBufferPhysicalAddress;
    PVOID MapBufferVirtualAddress;
    PTRANSLATION_ENTRY TranslationEntry;
    LONG NumberOfPages;
    LONG i;
    PHYSICAL_ADDRESS physicalAddressMinimum;
    PHYSICAL_ADDRESS physicalAddressMaximum;
    PHYSICAL_ADDRESS boundaryAddress;
    KIRQL Irql;
    PVOID CodeLockHandle;
    ULONG maximumBufferPages;
    ULONG bytesToAllocate;

    PAGED_CODE();

    boundaryAddress.QuadPart = 0;

    NumberOfPages = BYTES_TO_PAGES(Amount);

    //
    // Make sure there is room for the additional pages.  The maximum number of
    // slots needed is equal to NumberOfPages + Amount / 64K + 1.
    //

    maximumBufferPages = BYTES_TO_PAGES(MAXIMUM_PCI_MAP_BUFFER_SIZE);

    i = maximumBufferPages - (NumberOfPages +
        (NumberOfPages * PAGE_SIZE) / 0x10000 + 1 +
        AdapterObject->NumberOfMapRegisters);

    if (i < 0) {

        //
        // Reduce the allocation amount so it will fit.
        //

        NumberOfPages += i;
    }

    if (NumberOfPages <= 0) {

        //
        // No more memory can be allocated.
        //

        return(FALSE);
    }

    HalDebugPrint((HAL_VERBOSE, "HGMB: NumberOfPages = %d\n",
                                NumberOfPages));

    if (AdapterObject->NumberOfMapRegisters == 0  && HalpMapBufferSize) {

        NumberOfPages = BYTES_TO_PAGES( HalpMapBufferSize );

        //
        // Since this is the initial allocation, use the buffer allocated by
        // HalInitSystem rather than allocating a new one.
        //

        MapBufferPhysicalAddress = HalpMapBufferPhysicalAddress.LowPart;

        //
        // Map the buffer for access.
        //
        HalDebugPrint((HAL_VERBOSE, "HGMB: MapBufferPhys = %p\n",
                                    HalpMapBufferPhysicalAddress));
        HalDebugPrint((HAL_VERBOSE, "HGMB: MapBufferSize = 0x%x\n",
                                    HalpMapBufferSize));


        MapBufferVirtualAddress = MmMapIoSpace(
            HalpMapBufferPhysicalAddress,
            HalpMapBufferSize,
            TRUE                                // Cache enable.
            );

        if (MapBufferVirtualAddress == NULL) {

            //
            // The buffer could not be mapped.
            //

            HalpMapBufferSize = 0;
            return(FALSE);
        }


    } else {

        //
        // Allocate the map buffers. Restrict to 32-bit range
        // (TRANSLATION_ENTRY is 32-bit)
        //

        physicalAddressMinimum.QuadPart = 0;

        physicalAddressMaximum.LowPart = 0xFFFFFFFF;
        physicalAddressMaximum.HighPart = 0;

        bytesToAllocate = NumberOfPages * PAGE_SIZE;

        MapBufferVirtualAddress =
                MmAllocateContiguousMemorySpecifyCache( bytesToAllocate,
                                                        physicalAddressMinimum,
                                                        physicalAddressMaximum,
                                                        boundaryAddress,
                                                        MmCached );

        if (MapBufferVirtualAddress == NULL) {
            //
            // The allocation attempt failed.
            //

            return FALSE;
        }

        //
        // Get the physical address of the map base.
        //

        MapBufferPhysicalAddress = 
            MmGetPhysicalAddress(MapBufferVirtualAddress).LowPart;

        HalDebugPrint((HAL_VERBOSE, "HGMB: MapBufferVa = %p\n",
                                    MapBufferVirtualAddress));

        HalDebugPrint((HAL_VERBOSE, "HGMB: MapBufferPhysAddr = %p\n",
                                    MapBufferPhysicalAddress));
    }

    //
    // Initialize the map registers where memory has been allocated.
    // Serialize with master adapter object.
    //

    CodeLockHandle = MmLockPagableCodeSection (&HalpGrowMapBuffers);
    KeAcquireSpinLock( &AdapterObject->SpinLock, &Irql );

    TranslationEntry = ((PTRANSLATION_ENTRY) AdapterObject->MapRegisterBase) +
        AdapterObject->NumberOfMapRegisters;

    for (i = 0; (LONG) i < NumberOfPages; i++) {

        //
        // Make sure the perivous entry is physically contiguous with the next
        // entry 
        //

        if (TranslationEntry != AdapterObject->MapRegisterBase &&
            (((TranslationEntry - 1)->PhysicalAddress + PAGE_SIZE) !=
            MapBufferPhysicalAddress)) {

            //
            // An entry needs to be skipped in the table.  This entry will
            // remain marked as allocated so that no allocation of map
            // registers will cross this bountry.
            //

            TranslationEntry++;
            AdapterObject->NumberOfMapRegisters++;
        }

        //
        // Clear the bits where the memory has been allocated.
        //

        HalDebugPrint((HAL_VERBOSE, "HGMB: ClearBits (%p, 0x%x, 0x%x\n",
                      AdapterObject->MapRegisters,
                      (ULONG)(TranslationEntry - (PTRANSLATION_ENTRY)AdapterObject->MapRegisterBase),
                      1));

        RtlClearBits(
            AdapterObject->MapRegisters,
            (ULONG)(TranslationEntry - (PTRANSLATION_ENTRY)
                                         AdapterObject->MapRegisterBase),
            1
            );

        TranslationEntry->VirtualAddress = MapBufferVirtualAddress;
        TranslationEntry->PhysicalAddress = MapBufferPhysicalAddress;
        TranslationEntry++;
        (PCCHAR) MapBufferVirtualAddress += PAGE_SIZE;
        MapBufferPhysicalAddress += PAGE_SIZE;

    }

    //
    // Remember the number of pages that were allocated.
    //

    AdapterObject->NumberOfMapRegisters += NumberOfPages;

    //
    // Release master adapter object.
    //

    KeReleaseSpinLock( &AdapterObject->SpinLock, Irql );
    MmUnlockPagableImageSection (CodeLockHandle);
    return(TRUE);
}

PADAPTER_OBJECT
HalpAllocateAdapter(
    IN ULONG MapRegistersPerChannel,
    IN PVOID AdapterBaseVa,
    IN PVOID ChannelNumber
    )

/*++

Routine Description:

    This routine allocates and initializes an adapter object to represent an
    adapter or a DMA controller on the system.  If no map registers are required
    then a standalone adapter object is allocated with no master adapter.

    If map registers are required, then a master adapter object is used to
    allocate the map registers.  For Isa systems these registers are really
    phyically contiguous memory pages.

    Caller owns the HalpNewAdapter event


Arguments:

    MapRegistersPerChannel - Specifies the number of map registers that each
        channel provides for I/O memory mapping.

    AdapterBaseVa - Address of the the DMA controller.

    ChannelNumber - Unused.

Return Value:

    The function value is a pointer to the allocate adapter object.

--*/

{

    PADAPTER_OBJECT AdapterObject;
    OBJECT_ATTRIBUTES ObjectAttributes;
    ULONG Size;
    ULONG BitmapSize;
    HANDLE Handle;
    NTSTATUS Status;

    UNREFERENCED_PARAMETER(ChannelNumber);

    PAGED_CODE();

    HalDebugPrint((HAL_VERBOSE, "HAA: MapRegistersPerChannel = %d\n",
                      MapRegistersPerChannel));

    HalDebugPrint((HAL_VERBOSE, "HAA: BaseVa = %p\n",
                      AdapterBaseVa));

    //
    // Initalize the master adapter if necessary.
    //

    if (MasterAdapterObject == NULL && AdapterBaseVa != (PVOID) -1 &&
        MapRegistersPerChannel) {

       MasterAdapterObject = HalpAllocateAdapter(
                                          MapRegistersPerChannel,
                                          (PVOID) -1,
                                          NULL
                                          );

       HalDebugPrint((HAL_VERBOSE, "HAA: MasterAdapterObject = %p\n",
                      MasterAdapterObject));

       //
       // If we could not allocate the master adapter then give up.
       //

       if (MasterAdapterObject == NULL) {
          return(NULL);
       }
    }

    //
    // Begin by initializing the object attributes structure to be used when
    // creating the adapter object.
    //

    InitializeObjectAttributes( &ObjectAttributes,
                                NULL,
                                OBJ_PERMANENT,
                                (HANDLE) NULL,
                                (PSECURITY_DESCRIPTOR) NULL
                              );

    //
    // Determine the size of the adapter object. If this is the master object
    // then allocate space for the register bit map; otherwise, just allocate
    // an adapter object.
    //

    if (AdapterBaseVa == (PVOID) -1) {

       //
       // Allocate a bit map large enough MAXIMUM_PCI_MAP_BUFFER_SIZE / PAGE_SIZE
       // of map register buffers.
       //

       BitmapSize = (((sizeof( RTL_BITMAP ) +
            ((( MAXIMUM_PCI_MAP_BUFFER_SIZE / PAGE_SIZE ) + 7) >> 3)) + 3) & ~3);

       Size = sizeof( ADAPTER_OBJECT ) + BitmapSize;

    } else {

       Size = sizeof( ADAPTER_OBJECT );

    }

    //
    // Now create the adapter object.
    //

    Status = ObCreateObject( KernelMode,
                             *IoAdapterObjectType,
                             &ObjectAttributes,
                             KernelMode,
                             (PVOID) NULL,
                             Size,
                             0,
                             0,
                             (PVOID *)&AdapterObject );

    //
    // Reference the object.
    //

    if (NT_SUCCESS(Status)) {

        Status = ObReferenceObjectByPointer(
            AdapterObject,
            FILE_READ_DATA | FILE_WRITE_DATA,
            *IoAdapterObjectType,
            KernelMode
            );

    }

    //
    // If the adapter object was successfully created, then attempt to insert
    // it into the the object table.
    //

    if (NT_SUCCESS( Status )) {

        RtlZeroMemory (AdapterObject, sizeof (ADAPTER_OBJECT));

        Status = ObInsertObject( AdapterObject,
                                 NULL,
                                 FILE_READ_DATA | FILE_WRITE_DATA,
                                 0,
                                 (PVOID *) NULL,
                                 &Handle );

        if (NT_SUCCESS( Status )) {

            ZwClose( Handle );

            //
            // Initialize the adapter object itself.
            //

            AdapterObject->DmaHeader.Version = IO_TYPE_ADAPTER;
            AdapterObject->DmaHeader.Size = (USHORT) Size;
            AdapterObject->MapRegistersPerChannel = 1;
            AdapterObject->AdapterBaseVa = AdapterBaseVa;
            AdapterObject->ChannelNumber = 0xff;
            AdapterObject->DmaHeader.DmaOperations = &HalpDmaOperations;


            if (MapRegistersPerChannel) {

                AdapterObject->MasterAdapter = MasterAdapterObject;

            } else {

                AdapterObject->MasterAdapter = NULL;

            }

            //
            // Initialize the channel wait queue for this
            // adapter.
            //

            KeInitializeDeviceQueue( &AdapterObject->ChannelWaitQueue );

            //
            // If this is the MasterAdatper then initialize register bit map,
            // AdapterQueue and the spin lock.
            //

            if ( AdapterBaseVa == (PVOID) -1 ) {

               KeInitializeSpinLock( &AdapterObject->SpinLock );

               InitializeListHead( &AdapterObject->AdapterQueue );

               AdapterObject->MapRegisters = (PVOID) ( AdapterObject + 1);

               HalDebugPrint((HAL_VERBOSE, "HAA: InitBitMap(%p, %p, 0x%x\n",
                   AdapterObject->MapRegisters,
                   (PULONG)(((PCHAR)(AdapterObject->MapRegisters)) + 
                       sizeof( RTL_BITMAP )),
                   ( MAXIMUM_PCI_MAP_BUFFER_SIZE / PAGE_SIZE )));

               RtlInitializeBitMap ( 
                   AdapterObject->MapRegisters,
                   (PULONG)(((PCHAR)(AdapterObject->MapRegisters)) + 
                       sizeof( RTL_BITMAP )),
                   ( MAXIMUM_PCI_MAP_BUFFER_SIZE / PAGE_SIZE )
                                    );
               //
               // Set all the bits in the memory to indicate that memory
               // has not been allocated for the map buffers
               //

               RtlSetAllBits( AdapterObject->MapRegisters );
               AdapterObject->NumberOfMapRegisters = 0;
               AdapterObject->CommittedMapRegisters = 0;

               //
               // ALlocate the memory map registers.
               //

               AdapterObject->MapRegisterBase = ExAllocatePoolWithTag(
                    NonPagedPool,
                    (MAXIMUM_PCI_MAP_BUFFER_SIZE / PAGE_SIZE) *
                        sizeof(TRANSLATION_ENTRY),
                    HAL_POOL_TAG
                    );

               if (AdapterObject->MapRegisterBase == NULL) {

                   ObDereferenceObject( AdapterObject );
                   AdapterObject = NULL;
                   return(NULL);

               }

               //
               // Zero the map registers.
               //

               RtlZeroMemory(
                    AdapterObject->MapRegisterBase,
                    (MAXIMUM_PCI_MAP_BUFFER_SIZE / PAGE_SIZE) *
                        sizeof(TRANSLATION_ENTRY)
                    );

               if (!HalpGrowMapBuffers(
                        AdapterObject, 
                        INITIAL_MAP_BUFFER_LARGE_SIZE
                                       )
                  )
               {

                   //
                   // If no map registers could be allocated then free the
                   // object.
                   //

                   ObDereferenceObject( AdapterObject );
                   AdapterObject = NULL;
                   return(NULL);

               }
           }

        } else {

            //
            // An error was incurred for some reason.  Set the return value
            // to NULL.
            //

            AdapterObject = (PADAPTER_OBJECT) NULL;
        }
    } else {

        AdapterObject = (PADAPTER_OBJECT) NULL;

    }


    return AdapterObject;

}

ULONG
HalGetDmaAlignment (
    PVOID Conext
    )
{
    return HalGetDmaAlignmentRequirement();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\ixmca.c ===
/*++

Module Name:

    ixmca.c

Abstract:

    HAL component of the Machine Check Architecture.
    All exported MCA functionality is present in this file.

Author:

    Srikanth Kambhatla (Intel)

Revision History:

    Anil Aggarwal (Intel)
        Changes incorporated as per design review with Microsoft

--*/

#include <bugcodes.h>
#include <halp.h>

#include "check.h"
#include "osmca.h"

//
// Default MCA Bank configuration
//

#define MCA_DEFAULT_BANK_CONF       0xFFFFFFFFFFFFFFFF

//
// Bogus define for -1 sal status return
// to get around the bugcheck on bad status
// 
#define SAL_STATUS_BOGUS_RETURN   -1I64 

//
// MCA architecture related defines
//

#define MCA_NUM_REGS        4
#define MCA_CNT_MASK        0xFF
#define MCG_CTL_PRESENT     0x100

#define MCE_VALID           0x01

//
// MSR register addresses for MCA
//

#define MCG_CAP             0x179
#define MCG_STATUS          0x17a
#define MCG_CTL             0x17b
#define MC0_CTL             0x400
#define MC0_STATUS          0x401
#define MC0_ADDR            0x402
#define MC0_MISC            0x403

#define PENTIUM_MC_ADDR     0x0
#define PENTIUM_MC_TYPE     0x1

//
// Writing all 1's to MCG_CTL register enables logging.
//
#define MCA_MCGCTL_ENABLE_LOGGING      0xffffffff

//
// Bit interpretation of MCG_STATUS register
//
#define MCG_MC_INPROGRESS       0x4
#define MCG_EIP_VALID           0x2
#define MCG_RESTART_EIP_VALID   0x1

//
// For the function that reads the error reporting bank log, the type of error we
// are interested in
//
#define MCA_GET_ANY_ERROR               0x1
#define MCA_GET_NONRESTARTABLE_ERROR    0x2


//
// Defines for the size of TSS and the initial stack to operate on
//

#define MINIMUM_TSS_SIZE 0x68
#if DBG

//
// If we use DbgPrint, we need bigger stack
//

#define MCA_EXCEPTION_STACK_SIZE 0x1000
#else
#define MCA_EXCEPTION_STACK_SIZE 0x100
#endif // DBG

//
// Global Variables
//

extern KAFFINITY      HalpActiveProcessors;

// pmdata.c: CPE definitions.
extern ULONG          HalpMaxCPEImplemented;

// Thierry 03/02/2001 FIXFIX
// Current BigSur FWs require that MCA,CMC,CPE logs passed to SAL_GET_STATE_INFO
// interfaces are physically contiguous. This should be fixed for Whistler RC1.
// 
// Thierry 03/03/2001 FIXFIX
// If Lion FWs do not have this issue, we will test the product type to disable
// this variable.
//

BOOLEAN HalpFwMceLogsMustBePhysicallyContiguous = TRUE;

extern UCHAR        MsgCMCPending[];
extern UCHAR        MsgCPEPending[];
extern WCHAR        rgzSessionManager[];
extern WCHAR        rgzEnableMCA[];
extern WCHAR        rgzEnableCMC[];
extern WCHAR        rgzEnableCPE[];
extern WCHAR        rgzNoMCABugCheck[];
extern WCHAR        rgzEnableMCEOemDrivers[];

#if DBG
// from osmchk.s
extern VOID HalpGenerateMce( ULONG MceType );
#endif // DBG

//
// Internal prototypes
//

NTSTATUS
HalpMcaReadProcessorException (
    OUT PMCA_EXCEPTION  Exception,
    IN BOOLEAN  NonRestartableOnly
    );


VOID
HalpMcaGetConfiguration (
    OUT PULONG  MCAEnabled,
    OUT PULONG  CMCEnabled,
    OUT PULONG  CPEEnabled,
    OUT PULONG  NoMCABugCheck,
    OUT PULONG  MCEOemDriversEnabled
    );

#define IsMceKernelQuery( _buffer ) \
    ( (((ULONG_PTR)(*((PULONG_PTR)Buffer))) == (ULONG_PTR)HALP_KERNEL_TOKEN) ? TRUE : FALSE )

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, HalpMcaInit)
#pragma alloc_text(INIT, HalpMcaGetConfiguration)
#endif


VOID
HalpMcaInit (
    VOID
    )

/*++
    Routine Description:
        This routine is called to do the initialization of the HAL private 
        IA64 ERROR management. Called at end of phase 1 from HalReportResourceUsage().

    Arguments:
        None

    Return Value:
        None
--*/
{
    ULONG MCAEnabled, CMCEnabled, CPEEnabled, NoMCABugCheck, MCEOemDriversEnabled;

    C_ASSERT( HALP_CMC_MINIMUM_POLLING_INTERVAL > 1 );
    C_ASSERT( HALP_CPE_MINIMUM_POLLING_INTERVAL > 1 );

    //
    // If the default HAL features do not support IA64 Errors handling - 
    // defined as the inclusion of MCA, CMC, CPE handling - we return immediately.
    //

    if ( (!(HalpFeatureBits & HAL_MCA_PRESENT)) &&
         (!(HalpFeatureBits & HAL_CMC_PRESENT)) &&
         (!(HalpFeatureBits & HAL_CPE_PRESENT)) )   {
        return;
    }

    //
    // Gather regisry settings for IA64 Errors handling.
    //

    HalpMcaGetConfiguration( &MCAEnabled, &CMCEnabled, &CPEEnabled, 
                             &NoMCABugCheck, &MCEOemDriversEnabled );

    //
    //
    //

    if ( HalpFeatureBits & HAL_MCA_PRESENT )    {

        if ( !MCAEnabled )  {

            //
            // Registry setting has disabled MCA handling.
            // 
            // Thierry 08/00: We ignore this registry setting.
            //

            HalDebugPrint(( HAL_INFO, "HAL: MCA handling is disabled via registry.\n" ));
            HalDebugPrint(( HAL_INFO, "HAL: Disabling MCA handling is ignored currently...\n" ));

        }

        if ( NoMCABugCheck )    {

             //
             // Flag HalpMcaInfo, so HalpMcaBugCheck will not call KeBugCheckEx().
             //

             HalpMcaInfo.NoBugCheck++;
        }

        //
        // Execute other required MCA initialization here...
        //

    }
    else {
        HalDebugPrint(( HAL_INFO, "HAL: MCA handling is disabled.\n" ));
    }

    //
    // At this time of the HAL initialization, the default HAL CMC model is initialized as:
    //    - non-present               if SAL reported invalid CMC max log sizes.
    //    - present & interrupt-based if SAL reported valid   CMC max log sizes.
    //
    
    if ( HalpFeatureBits & HAL_CMC_PRESENT )    {

        if ( CMCEnabled )  {

            if ( (CMCEnabled == HAL_CMC_INTERRUPTS_BASED) || (CMCEnabled == (ULONG)1) )   {

                //
                // In this case, we do not change the default HAL CMC handling.
                //

            }
            else  {

                //
                // Registry setting enables CMC Polling mode.
                // Polling interval is registry specified value with mininum value
                // checked with HAL_CMC_MINIMUM_POLLING_INTERVAL.
                //

                if ( CMCEnabled < HALP_CMC_MINIMUM_POLLING_INTERVAL )   {
                    CMCEnabled = HALP_CMC_MINIMUM_POLLING_INTERVAL;
                }

                HalDebugPrint(( HAL_INFO, "HAL: CMC Polling mode enabled via registry.\n" ));
                HalpCMCDisableForAllProcessors();
                HalpCmcInfo.Stats.PollingInterval = CMCEnabled;

            } 

        }
        else   {

            //
            // Registry setting has disabled CMC handling.
            //

            HalDebugPrint(( HAL_INFO, "HAL: CMC handling is disabled via registry.\n" ));
            HalpCMCDisableForAllProcessors();
            HalpFeatureBits &= ~HAL_CMC_PRESENT;

        }

        //
        // Execute other required CMC initialization here...
        //

    }
    else  {
        HalDebugPrint(( HAL_INFO, "HAL: CMC handling is disabled.\n" ));
    }

    //
    // At this time of the HAL initialization, the default HAL CPE model is initialized as:
    //    - non-present               if SAL reported invalid CPE max log sizes.
    //    - present & interrupt-based if SAPIC Platform Interrupt Sources exist.
    //    - present & polled-based    if there is no SAPIC Platform Interrupt Source. 
    //                                Polling interval is: HALP_CPE_DEFAULT_POLLING_INTERVAL.
    //

    if ( HalpFeatureBits & HAL_CPE_PRESENT )    {

        if ( CPEEnabled )   {

            if ( (CPEEnabled == HAL_CPE_INTERRUPTS_BASED) || (CPEEnabled == (ULONG)1) )   {

                //
                // In this case, we do not change the default HAL CPE handling.
                //

                if ( HalpMaxCPEImplemented == 0 )   {

                    HalDebugPrint(( HAL_INFO, "HAL: registry setting enabling CPE interrupt mode but no platform interrupt sources.\n" ));

                }

            }
            else  {

                //
                // Registry setting enables CPE Polling mode.
                // Polling interval is registry specified value with mininum value
                // checked with HAL_CPE_MINIMUM_POLLING_INTERVAL.
                //

                if ( CPEEnabled < HALP_CPE_MINIMUM_POLLING_INTERVAL )   {
                    CPEEnabled = HALP_CPE_MINIMUM_POLLING_INTERVAL;
                }

                HalDebugPrint(( HAL_INFO, "HAL: CPE Polling mode enabled via registry.\n" ));
                HalpCPEDisable();
                HalpCpeInfo.Stats.PollingInterval = CPEEnabled;

            } 

        }
        else  {

            //
            // Registry setting has disabled CPE handling.
            //

            HalDebugPrint(( HAL_INFO, "HAL: CPE handling is disabled via registry.\n" ));
            HalpCPEDisable();
            HalpFeatureBits &= ~HAL_CPE_PRESENT;
            HalpCpeInfo.Stats.PollingInterval = HAL_CPE_DISABLED;

        }

        //
        // Execute other required CPE initialization here...
        //

    }
    else  {
        HalDebugPrint(( HAL_INFO, "HAL: CPE handling is disabled.\n" ));
    }

    //
    // 06/09/01: OEM MCE Drivers registration is disabled by default in the HAL and
    //           should be enabled using the registry. See HalpMcaGetConfiguration().
    //           This was decided by the MS IA64 MCA Product Manager for Windows XP, 
    //           after consideration of the IA64 platforms FWs and little testing done
    //           on this path.
    //

    if ( MCEOemDriversEnabled ) {
        HalpFeatureBits |= HAL_MCE_OEMDRIVERS_ENABLED;
        HalDebugPrint(( HAL_INFO, "HAL: OEM MCE Drivers registration enabled via registry.\n" ));
    }

    //
    // Initialize HALP_INFO required members.
    // This is done regardless of the enabled set of features.
    //

    HalpInitializeMceMutex();
    HalpInitializeMcaInfo();
    HalpInitializeInitMutex();
    HalpInitializeCmcInfo();
    HalpInitializeCpeInfo();

    return;

} // HalpMcaInit()

NTSTATUS
HalpMceRegisterKernelDriver(
    IN PKERNEL_ERROR_HANDLER_INFO DriverInfo,
    IN ULONG                      InfoSize
    )
/*++
    Routine Description:
        This routine is called by the kernel (via HalSetSystemInformation)
        to register its presence. This is mostly for WMI callbacks registration.

    Arguments:
        DriverInfo: Contains kernel info about the callbacks and associated objects.

    Return Value:
        Unless a MCA driver is already registered OR one of the two callback
        routines are NULL, this routine returns Success.

    Implementation Notes:
        - the current implementation assumes the kernel registers its callbacks
          earlier than a driver will. The current kernel registration is done by
          WMI and should be done at WMI-Phase 0.
        - the registrations do not consider if the HAL supports or not the MCA,CMC,CPE
          functionalities. It simply registers the callbacks if no other callback was
          registered before. This allows us to allow some flexibility if a machine event
          functionality is enabled AFTER the hal initialization (e.g. HalpGetFeatureBits())
          through the mean of a registry key or driver event, for example.
    
--*/

{
    NTSTATUS status;
    NTSTATUS statusMcaRegistration;
    NTSTATUS statusCmcRegistration;
    NTSTATUS statusCpeRegistration;

    PAGED_CODE();

    if ( !DriverInfo )  {
        status = STATUS_INVALID_PARAMETER;
        return status;
    }

    //
    // Backward compatibility only.
    //

    if ( DriverInfo->Version && (DriverInfo->Version > KERNEL_ERROR_HANDLER_VERSION) )  {
        status = STATUS_REVISION_MISMATCH;
        return status;
    }

#if DBG
    //
    // Special case: we needed a way of generating Machine Check events.
    // We used this system information interface to let a WMI-based tool generates them.
    //
    {
#define HALP_MCE_GENERATOR_GUID \
            { 0x3001bce4, 0xd9b6, 0x4167, { 0xb5, 0xe1, 0x39, 0xa7, 0x28, 0x59, 0xe2, 0x67 } }
        GUID mceGeneratorGuid = HALP_MCE_GENERATOR_GUID;
        if ( !DriverInfo->KernelMcaDelivery && 
             !DriverInfo->KernelCmcDelivery && 
             !DriverInfo->KernelCpeDelivery && 
             !DriverInfo->KernelMceDelivery && 
             (InfoSize >= (sizeof(*DriverInfo)+sizeof(GUID))) ) {
            GUID *recordGuid = (GUID *)((ULONG_PTR)DriverInfo + sizeof(*DriverInfo));
            if ( IsEqualGUID( recordGuid, &mceGeneratorGuid ) ) {
                HalpGenerateMce( DriverInfo->Padding );
                return( STATUS_SUCCESS );
            }
        }
    }
#endif // DBG

    statusMcaRegistration = statusCmcRegistration = statusCpeRegistration = STATUS_UNSUCCESSFUL;

    //
    // Acquire HAL-wide mutex for MCA/CMC/CPE operations.
    //


    //
    // Register Kernel MCA notification.
    //

    HalpAcquireMcaMutex(); 
    if ( !HalpMcaInfo.KernelDelivery ) {
        HalpMcaInfo.KernelDelivery = DriverInfo->KernelMcaDelivery;
        statusMcaRegistration = STATUS_SUCCESS;
    }
    HalpReleaseMcaMutex();

    //
    // Register Kernel CMC notification.
    //

    HalpAcquireCmcMutex();
    if ( !HalpCmcInfo.KernelDelivery ) {
        HalpCmcInfo.KernelDelivery = DriverInfo->KernelCmcDelivery;
        statusCmcRegistration = STATUS_SUCCESS;
    }
    HalpReleaseCmcMutex();

    //
    // Register Kernel CPE notification.
    //

    HalpAcquireCpeMutex();
    if ( !HalpCpeInfo.KernelDelivery ) {
        HalpCpeInfo.KernelDelivery = DriverInfo->KernelCpeDelivery;
        statusCpeRegistration = STATUS_SUCCESS;
    }
    HalpReleaseCpeMutex();

    //
    // Register Kernel MCE notification.
    //

    HalpAcquireMceMutex(); 
    if ( !HalpMceKernelDelivery )    {
        HalpMceKernelDelivery = DriverInfo->KernelMceDelivery;
    }
    HalpReleaseMceMutex();

    //
    // If Kernel-WMI MCA registration was sucessful and we have Previous logs, notify the
    // Kernel-WMI component before returning.
    //

    if ( (statusMcaRegistration == STATUS_SUCCESS) && HalpMcaInfo.Stats.McaPreviousCount )  {
        InterlockedExchange( &HalpMcaInfo.DpcNotification, 1 );
    }

    //
    // return status determined by the success of the different registrations.
    //
    // Note: the 'OR'ing is valid because STATUS_SUCCESS and STATUS_UNSUCCESSFUL are only used.
    //

    status = (NTSTATUS)(statusMcaRegistration | statusCmcRegistration | statusCpeRegistration);
    return status;

} // HalpMceRegisterKernelDriver()

NTSTATUS
HalpMcaRegisterDriver(
    IN PMCA_DRIVER_INFO DriverInfo
    )
/*++
    Routine Description:
        This routine is called by the driver (via HalSetSystemInformation)
        to register its presence. Only one driver can be registered at a time.

    Arguments:
        DriverInfo: Contains info about the callback routine and the DeviceObject

    Return Value:
        Unless a MCA driver is already registered OR one of the two callback
        routines are NULL, this routine returns Success.
--*/

{
    NTSTATUS    status;

    PAGED_CODE();

    status = STATUS_UNSUCCESSFUL;

    if ( (HalpFeatureBits & (HAL_MCE_OEMDRIVERS_ENABLED | HAL_MCA_PRESENT)) && 
          DriverInfo->DpcCallback) {

        HalpAcquireMcaMutex(); 

        //
        // Register driver
        //

        if ( !HalpMcaInfo.DriverInfo.DpcCallback ) {
 
            //
            // Initialize the DPC object
            //

            KeInitializeDpc(
                &HalpMcaInfo.DriverDpc,
                DriverInfo->DpcCallback,
                DriverInfo->DeviceContext
                );

            // 
            // register driver
            //

            HalpMcaInfo.DriverInfo.ExceptionCallback = DriverInfo->ExceptionCallback;
            HalpMcaInfo.DriverInfo.DpcCallback       = DriverInfo->DpcCallback;
            HalpMcaInfo.DriverInfo.DeviceContext     = DriverInfo->DeviceContext;
            status = STATUS_SUCCESS;
        }

        HalpReleaseMcaMutex();
    }
    else if ( !DriverInfo->DpcCallback )    {

        //
        // Deregistring the callbacks is the only allowed operation.
        //

        HalpAcquireMcaMutex(); 

        if (HalpMcaInfo.DriverInfo.DeviceContext == DriverInfo->DeviceContext) {
            HalpMcaInfo.DriverInfo.ExceptionCallback = NULL;
            HalpMcaInfo.DriverInfo.DpcCallback = NULL;
            HalpMcaInfo.DriverInfo.DeviceContext = NULL;
            status = STATUS_SUCCESS;
        }

        HalpReleaseMcaMutex();

    }

    return status;

} // HalpMcaRegisterDriver()

NTSTATUS
HalpCmcRegisterDriver(
    IN PCMC_DRIVER_INFO DriverInfo
    )
/*++
    Routine Description:
        This routine is called by the driver (via HalSetSystemInformation)
        to register its presence. Only one driver can be registered at a time.

    Arguments:
        DriverInfo: Contains info about the callback routine and the DeviceObject

    Return Value:
        Unless a MCA driver is already registered OR one of the two callback
        routines are NULL, this routine returns Success.
--*/

{
    NTSTATUS    status;

    PAGED_CODE();

    status = STATUS_UNSUCCESSFUL;

    if ( (HalpFeatureBits & (HAL_MCE_OEMDRIVERS_ENABLED | HAL_CMC_PRESENT)) && 
          DriverInfo->DpcCallback ) {

        HalpAcquireCmcMutex();

        //
        // Register driver
        //

        if ( !HalpCmcInfo.DriverInfo.DpcCallback ) {

            //
            // Initialize the DPC object
            //

            KeInitializeDpc(
                &HalpCmcInfo.DriverDpc,
                DriverInfo->DpcCallback,
                DriverInfo->DeviceContext
                );

            //
            // register driver
            //

            HalpCmcInfo.DriverInfo.ExceptionCallback = DriverInfo->ExceptionCallback;
            HalpCmcInfo.DriverInfo.DpcCallback = DriverInfo->DpcCallback;
            HalpCmcInfo.DriverInfo.DeviceContext = DriverInfo->DeviceContext;
            status = STATUS_SUCCESS;
        }

        HalpReleaseCmcMutex();
    }
    else if ( !DriverInfo->DpcCallback )    {

        //
        // Deregistring the callbacks is the only allowed operation.
        //

        HalpAcquireCmcMutex();

        if (HalpCmcInfo.DriverInfo.DeviceContext == DriverInfo->DeviceContext) {
            HalpCmcInfo.DriverInfo.ExceptionCallback = NULL;
            HalpCmcInfo.DriverInfo.DpcCallback = NULL;
            HalpCmcInfo.DriverInfo.DeviceContext = NULL;
            status = STATUS_SUCCESS;
        }

        HalpReleaseCmcMutex();

    }

    return status;

} // HalpCmcRegisterDriver()

NTSTATUS
HalpCpeRegisterDriver(
    IN PCPE_DRIVER_INFO DriverInfo
    )
/*++
    Routine Description:
        This routine is called by the driver (via HalSetSystemInformation)
        to register its presence. Only one driver can be registered at a time.

    Arguments:
        DriverInfo: Contains info about the callback routine and the DeviceObject

    Return Value:
        Unless a MCA driver is already registered OR one of the two callback
        routines are NULL, this routine returns Success.
--*/

{
    NTSTATUS    status;

    PAGED_CODE();

    status = STATUS_UNSUCCESSFUL;

    if ( (HalpFeatureBits & (HAL_MCE_OEMDRIVERS_ENABLED | HAL_CPE_PRESENT)) && 
          DriverInfo->DpcCallback ) {

        HalpAcquireCpeMutex();

        //
        // Register driver
        //

        if ( !HalpCpeInfo.DriverInfo.DpcCallback ) {

            //
            // Initialize the DPC object
            //

            KeInitializeDpc(
                &HalpCpeInfo.DriverDpc,
                DriverInfo->DpcCallback,
                DriverInfo->DeviceContext
                );

            //
            // register driver
            //

            HalpCpeInfo.DriverInfo.ExceptionCallback = DriverInfo->ExceptionCallback;
            HalpCpeInfo.DriverInfo.DpcCallback = DriverInfo->DpcCallback;
            HalpCpeInfo.DriverInfo.DeviceContext = DriverInfo->DeviceContext;
            status = STATUS_SUCCESS;
        }

        HalpReleaseCpeMutex();
    }
    else if ( !DriverInfo->DpcCallback )    {

        //
        // Deregistring the callbacks is the only allowed operation.
        //

        HalpAcquireCpeMutex();

        if (HalpCpeInfo.DriverInfo.DeviceContext == DriverInfo->DeviceContext) {
            HalpCpeInfo.DriverInfo.ExceptionCallback = NULL;
            HalpCpeInfo.DriverInfo.DpcCallback = NULL;
            HalpCpeInfo.DriverInfo.DeviceContext = NULL;
            status = STATUS_SUCCESS;
        }

        HalpReleaseCpeMutex();

    } 

    return status;

} // HalpCpeRegisterDriver()

VOID
HalpSaveMceLog(
    IN PHALP_MCELOGS_HEADER LogsHeader,
    IN PERROR_RECORD_HEADER Record,
    IN ULONG                RecordLength
    )
{
    PSINGLE_LIST_ENTRY entry, previousEntry;
    PERROR_RECORD_HEADER  savedLog;

    if ( LogsHeader->Count >= LogsHeader->MaxCount )    {
        LogsHeader->Overflow++;
        return;
    }

    entry = ExAllocatePoolWithTag( PagedPool, RecordLength + sizeof(*entry), LogsHeader->Tag );
    if ( !entry )   {
        LogsHeader->AllocateFails++;
        return;
    }
    entry->Next = NULL;

    previousEntry = &LogsHeader->Logs;
    while( previousEntry->Next != NULL )    {
        previousEntry = previousEntry->Next;
    }
    previousEntry->Next = entry;

    savedLog = HalpMceLogFromListEntry( entry );
    RtlCopyMemory( savedLog, Record, RecordLength );

    LogsHeader->Count++;

    return;

} // HalpSaveMceLog()

PSINGLE_LIST_ENTRY
HalpGetSavedMceLog(
    PHALP_MCELOGS_HEADER  LogsHeader,
    PSINGLE_LIST_ENTRY   *LastEntry
    )
{
    PSINGLE_LIST_ENTRY entry, previousEntry;

    ASSERTMSG( "HAL!HalpGetSavedMceLog: LogsHeader->Count = 0!\n", LogsHeader->Count );

    entry      = NULL;
    *LastEntry = previousEntry = &LogsHeader->Logs;
    while( previousEntry->Next )  {
        entry = previousEntry;
        previousEntry = previousEntry->Next;
    }
    if ( entry )    {
        *LastEntry = entry;
        return( previousEntry );
    }
    return( NULL );

} // HalpGetSavedMceLog()

NTSTATUS 
HalpGetFwMceLog(
    ULONG                MceType,
    PERROR_RECORD_HEADER Record,
    PHALP_MCELOGS_STATS  MceLogsStats,
    BOOLEAN              DoClearLog
    )
{
    NTSTATUS              status;
    SAL_PAL_RETURN_VALUES rv;
    LONGLONG              salStatus;
    BOOLEAN               logPhysicallyContiguous = FALSE;
    PERROR_RECORD_HEADER  log;

    log = Record;
    if ( HalpFwMceLogsMustBePhysicallyContiguous )  {
        PHYSICAL_ADDRESS physicalAddr;
        ULONG            logSize;

        switch( MceType )   {
            case CMC_EVENT:
                logSize = HalpCmcInfo.Stats.MaxLogSize;
                break;

            case CPE_EVENT:
                logSize = HalpCpeInfo.Stats.MaxLogSize;
                break;
            
            case MCA_EVENT:
            default:
                logSize = HalpMcaInfo.Stats.MaxLogSize;
                break;
        }

        physicalAddr.QuadPart = 0xffffffffffffffffI64;
        log = MmAllocateContiguousMemory( logSize, physicalAddr );
        if ( log == NULL ) {
            return( STATUS_NO_MEMORY );
        }

        logPhysicallyContiguous = TRUE;
    }

    //
    // Get the currently pending Machine Check Event log.
    //

    rv = HalpGetStateInfo( MceType, log );
    salStatus = rv.ReturnValues[0];
    if ( salStatus < 0 )    {

        //
        // SAL_GET_STATE_INFO failed.
        //
        if ( salStatus == SAL_STATUS_NO_INFORMATION_AVAILABLE || salStatus == SAL_STATUS_BOGUS_RETURN) {
            return ( STATUS_NOT_FOUND );
        }

        if ( MceType == MCA_EVENT ) {
            HalpMcaKeBugCheckEx( HAL_BUGCHECK_MCA_GET_STATEINFO, (PMCA_EXCEPTION)log,
                                                                 HalpMcaInfo.Stats.MaxLogSize,
                                                                 salStatus );
            // no-return
        }
        else   {
            MceLogsStats->GetStateFails++;
            if ( HalpMceKernelDelivery )    {
                HalpMceKernelDelivery(
                       HalpMceDeliveryArgument1( KERNEL_MCE_OPERATION_GET_STATE_INFO, MceType ),
                       (PVOID)(ULONG_PTR)salStatus );
            }
        }

        return( STATUS_UNSUCCESSFUL ); 
    }

    status = STATUS_SUCCESS;

    if ( DoClearLog )   {
        static ULONGLONG currentClearedLogCount = 0UI64;

        rv = HalpClearStateInfo( MceType );
        salStatus = rv.ReturnValues[0];
        if ( salStatus < 0 )  {

            //
            // SAL_CLEAR_STATE_INFO failed.
            //
            // We do not modify the status of the log collection. It is still sucessful.
            //
    
            if ( MceType == MCA_EVENT ) {
    
                //
                // Current consideration for this implementation - 08/2000:
                // if clearing the MCA log event fails, we assume that FW has a real
                // problem; Continuing will be dangerous. We bugcheck.
                //
    
                HalpMcaKeBugCheckEx( HAL_BUGCHECK_MCA_CLEAR_STATEINFO, (PMCA_EXCEPTION)log,
                                                                       HalpMcaInfo.Stats.MaxLogSize,
                                                                       salStatus );
                // no-return
            }
            else  {
    
                //
                // The SAL CLEAR_STATE_INFO interface failed.
                // However, we consider that for this event type, it is not worth bugchecking 
                // the system. We clearly flag it and notify the kernel-WMI if the callback was
                // registered.
                //
    
                MceLogsStats->ClearStateFails++;
                if ( HalpMceKernelDelivery )    {
                    HalpMceKernelDelivery(
                        HalpMceDeliveryArgument1( KERNEL_MCE_OPERATION_CLEAR_STATE_INFO, MceType ),
                        (PVOID)(ULONG_PTR)salStatus );
                }
            }
        }
        else if ( salStatus == SAL_STATUS_SUCCESS_MORE_RECORDS )    {
            status = STATUS_MORE_ENTRIES;
        }

        //
        // We are saving the record id. This is a unique monotically increasing ID.
        // This is mostly to check that we are not getting the same log because of 
        // SAL_CLEAR_STATE_INFO failure. Note that we have tried to clear it again.
        //

        if ( currentClearedLogCount && (log->Id == MceLogsStats->LogId) ) {
            status = STATUS_ALREADY_COMMITTED;
        }
        MceLogsStats->LogId = log->Id;
        currentClearedLogCount++;

    }

    //
    // Last sanity check on the record. This is to help the log saving processing and the
    // detection of invalid records.
    //

    if ( log->Length < sizeof(*log) ) { // includes Length == 0.
        status = STATUS_BAD_DESCRIPTOR_FORMAT;
    }

    //
    // If local physically contiguous memory allocation was done,
    // update the passed buffer and free this memory block.
    //
    
    if ( logPhysicallyContiguous ) {
        if ( log->Length )  {
            RtlMoveMemory( Record, log, log->Length );
        }
        MmFreeContiguousMemory( log );
    }

    return( status );

} // HalpGetFwMceLog()

NTSTATUS
HalpGetMcaLog (
    OUT PMCA_EXCEPTION  Buffer,
    IN  ULONG           BufferSize,
    OUT PULONG          ReturnedLength
    )
/*++

Routine Description:

    This function is called by HaliQuerySysteminformation for the HalMcaLogInformation class.
    It provides a MCA log to the caller.

Arguments:

    Buffer        : Buffer into which the error is reported
    BufferSize    : Size of the passed buffer
    ReturnedLength: Length of the log.

Return Value:

    Success or failure

--*/
{
    ULONG                 maxLogSize;
    BOOLEAN               kernelQuery;
    KAFFINITY             activeProcessors, currentAffinity;
    NTSTATUS              status;
    PERROR_RECORD_HEADER  log;
    PHALP_MCELOGS_HEADER  logsHeader;

    PAGED_CODE();

    //
    // If MCA is not enabled, return immediately.
    //

    if ( !(HalpFeatureBits & HAL_MCA_PRESENT) ) {
        return( STATUS_NO_SUCH_DEVICE );
    }

    //
    // Assertions for the HAL MCA implementation.
    //

    ASSERTMSG( "HAL!HalpGetMcaLog: ReturnedLength NULL!\n", ReturnedLength );
    ASSERTMSG( "HAL!HalpGetMcaLog: HalpMcaInfo.MaxLogSize 0!\n", HalpMcaInfo.Stats.MaxLogSize );
    ASSERTMSG( "HAL!HalpGetMcaLog: HalpMcaInfo.MaxLogSize < sizeof(ERROR_RECORD_HEADER)!\n",
                                    HalpMcaInfo.Stats.MaxLogSize >= sizeof(ERROR_RECORD_HEADER) );

    //
    // Let's the caller know about its passed buffer size or the minimum required size.
    //

    maxLogSize = HalpMcaInfo.Stats.MaxLogSize;
    if ( BufferSize < maxLogSize )  {
        *ReturnedLength = maxLogSize;
        return( STATUS_INVALID_BUFFER_SIZE );
    }

    //
    // Determine if the caller is the kernel-WMI.
    //

    kernelQuery = IsMceKernelQuery( Buffer );
    logsHeader = ( kernelQuery ) ? &HalpMcaInfo.KernelLogs : &HalpMcaInfo.DriverLogs;

    //
    // Enable MP protection for MCA logs accesses
    //

    status = STATUS_NOT_FOUND;
    HalpAcquireMcaMutex();

    //
    // If saved logs exist, pop an entry.
    //

    if ( logsHeader->Count ) {
        PSINGLE_LIST_ENTRY entry, lastEntry;

        entry = HalpGetSavedMceLog( logsHeader, &lastEntry );
        if ( entry )  {
            PERROR_RECORD_HEADER savedLog;
            ULONG length;

            savedLog = HalpMceLogFromListEntry( entry );
            length   = savedLog->Length;
            if ( length <= BufferSize )  {
                ULONG logsCount;

                RtlCopyMemory( Buffer, savedLog, length );
                ExFreePoolWithTag( entry, logsHeader->Tag );
                lastEntry->Next = NULL;
                logsCount = (--logsHeader->Count);
                HalpReleaseMcaMutex();
                *ReturnedLength = length;
                if ( logsCount )   {
                   return( STATUS_MORE_ENTRIES );
                }
                else   {
                   return( STATUS_SUCCESS );
                }
            }
            else   {
                HalpReleaseMcaMutex();
                *ReturnedLength = length;
                return( STATUS_INVALID_BUFFER_SIZE );
            }
        }
    }

    //
    // Initalize local log pointer after memory allocation if required.
    //

    if ( kernelQuery ) {
        log = (PERROR_RECORD_HEADER)Buffer;
    }
    else  {

        //
        // The OEM CMC driver HAL interface does not require the CMC driver memory
        // for the log buffer to be allocated from NonPagedPool.
        // Also, MM does not export memory pool type checking APIs.
        // It is safer to allocate in NonPagedPool and pass this buffer to the SAL.
        // If the SAL interface is sucessful, we will copy the buffer to the caller's buffer.
        //

        log = ExAllocatePoolWithTag( NonPagedPool, maxLogSize, 'TacM' );
        if ( log == NULL ) {
            HalpReleaseMcaMutex();
            return( STATUS_NO_MEMORY );
        }
    }

    //
    // We did not have any saved log, check if we have notified that FW has logs from 
    // previous MCAs or corrected MCAs.
    //

    activeProcessors = HalpActiveProcessors;
    for (currentAffinity = 1; activeProcessors; currentAffinity <<= 1) {

        if (activeProcessors & currentAffinity) {

            activeProcessors &= ~currentAffinity;
            KeSetSystemAffinityThread(currentAffinity);

            status = HalpGetFwMceLog( MCA_EVENT, log, &HalpMcaInfo.Stats, HALP_FWMCE_DO_CLEAR_LOG );
            if ( NT_SUCCESS( status ) ||
                 ( (status != STATUS_NOT_FOUND) && (status != STATUS_ALREADY_COMMITTED) ) ) {
                break;
            }
        }
    }

    if ( NT_SUCCESS( status ) ) {
        ULONG length = log->Length; // Note: Length was checked in HalpGetMceLog().

        if ( kernelQuery ) {
            if ( HalpMcaInfo.DriverInfo.DpcCallback )   {
                HalpSaveMceLog( &HalpMcaInfo.DriverLogs, log, length );
            }
        }
        else  {
            RtlCopyMemory( Buffer, log, length );
            if ( HalpMcaInfo.KernelDelivery )   {
                HalpSaveMceLog( &HalpMcaInfo.KernelLogs, log, length );
            }
        }
        *ReturnedLength = length;
    }

    //
    // Restore threads affinity, release mutex.
    //

    KeRevertToUserAffinityThread();
    HalpReleaseMcaMutex();

    //
    // If the caller is not the Kernel-WMI, free the allocated NonPagedPool log.
    //

    if ( !kernelQuery ) {
        ExFreePoolWithTag( log, 'TacM' );
    }

    return status;

} // HalpGetMcaLog()

NTSTATUS
HalpGetCmcLog (
    OUT PCMC_EXCEPTION  Buffer,
    IN  ULONG           BufferSize,
    OUT PULONG          ReturnedLength
    )
/*++

Routine Description:

   This function is called by HaliQuerySysteminformation for the HalCmcLogInformation class.
   It provides a CMC log to the caller.

Arguments:

   Buffer        : Buffer into which the error is reported
   BufferSize    : Size of the passed buffer
   ReturnedLength: Length of the log. This pointer was validated by caller.

Return Value:

   Success or failure

--*/
{
    ULONG                 maxLogSize;
    BOOLEAN               kernelQuery;
    KAFFINITY             activeProcessors, currentAffinity;
    NTSTATUS              status;
    PERROR_RECORD_HEADER  log;
    PHALP_MCELOGS_HEADER  logsHeader;

    PAGED_CODE();

    //
    // If CMC is not enabled, return immediately.
    //

    if ( !(HalpFeatureBits & HAL_CMC_PRESENT) ) {
        return( STATUS_NO_SUCH_DEVICE );
    }

    //
    // Assertions for the HAL CMC implementation.
    //

    ASSERTMSG( "HAL!HalpGetCmcLog: ReturnedLength NULL!\n", ReturnedLength );
    ASSERTMSG( "HAL!HalpGetCmcLog: HalpCmcInfo.MaxLogSize 0!\n", HalpCmcInfo.Stats.MaxLogSize );
    ASSERTMSG( "HAL!HalpGetCmcLog: HalpCmcInfo.MaxLogSize < sizeof(ERROR_RECORD_HEADER)!\n", 
                                    HalpCmcInfo.Stats.MaxLogSize >= sizeof(ERROR_RECORD_HEADER) );

    //
    // Let's the caller know about its passed buffer size or the minimum required size.
    //

    maxLogSize = HalpCmcInfo.Stats.MaxLogSize;
    if ( BufferSize < maxLogSize )  {
        *ReturnedLength = maxLogSize;
        return( STATUS_INVALID_BUFFER_SIZE );
    }

    //
    // Determine if the caller is the kernel-WMI.
    //

    kernelQuery = IsMceKernelQuery( Buffer );
    logsHeader = ( kernelQuery ) ? &HalpCmcInfo.KernelLogs : &HalpCmcInfo.DriverLogs; 

    //
    // Enable MP protection for CMC logs accesses
    //

    status = STATUS_NOT_FOUND;
    HalpAcquireCmcMutex();

    //
    // If saved logs exist, pop an entry.
    //

    if ( logsHeader->Count ) {
        PSINGLE_LIST_ENTRY entry, lastEntry;

        entry = HalpGetSavedMceLog( logsHeader, &lastEntry );
        if ( entry )  {
            PERROR_RECORD_HEADER savedLog;
            ULONG length;

            savedLog = HalpMceLogFromListEntry( entry );
            length   = savedLog->Length;
            if ( length <= BufferSize )  {
                ULONG logsCount;

                RtlCopyMemory( Buffer, savedLog, length );
                ExFreePoolWithTag( entry, logsHeader->Tag );
                lastEntry->Next = NULL;
                logsCount = (--logsHeader->Count);
                HalpReleaseCmcMutex();
                *ReturnedLength = length;
                if ( logsCount )   {
                   return( STATUS_MORE_ENTRIES );
                }
                else   {
                   return( STATUS_SUCCESS );
                }
            } 
            else   {
                HalpReleaseCmcMutex();
                *ReturnedLength = length; 
                return( STATUS_INVALID_BUFFER_SIZE );
            }
        }
    }

    //
    // Initalize local log pointer after memory allocation if required.
    //

    if ( kernelQuery ) {
        log = (PERROR_RECORD_HEADER)Buffer;
    }
    else  {

        //
        // The OEM CMC driver HAL interface does not require the CMC driver memory
        // for the log buffer to be allocated from NonPagedPool.
        // Also, MM does not export memory pool type checking APIs.
        // It is safer to allocate in NonPagedPool and pass this buffer to the SAL.
        // If the SAL interface is sucessful, we will copy the buffer to the caller's buffer.
        //

        log = ExAllocatePoolWithTag( NonPagedPool, maxLogSize, 'TcmC' );
        if ( log == NULL ) {
            HalpReleaseCmcMutex();
            return( STATUS_NO_MEMORY );
        }
    }

    //
    // We did not have any saved log, migrate from 1 processor to another to collect 
    // the FW logs.
    //

    activeProcessors = HalpActiveProcessors;
    for (currentAffinity = 1; activeProcessors; currentAffinity <<= 1) {

        if (activeProcessors & currentAffinity) {
            
            activeProcessors &= ~currentAffinity;
            KeSetSystemAffinityThread(currentAffinity);

            status = HalpGetFwMceLog( CMC_EVENT, log, &HalpCmcInfo.Stats, HALP_FWMCE_DO_CLEAR_LOG );
            if ( NT_SUCCESS( status ) || 
                 ( (status != STATUS_NOT_FOUND) && (status != STATUS_ALREADY_COMMITTED) ) ) {
                break;
            }
        }
    }

    if ( NT_SUCCESS( status ) ) {
        ULONG length = log->Length; // Note: Length was checked in HalpGetMceLog().

        if ( kernelQuery ) {
            if ( HalpCmcInfo.DriverInfo.DpcCallback )   {
                HalpSaveMceLog( &HalpCmcInfo.DriverLogs, log, length );
            }
        }
        else  {
            RtlCopyMemory( Buffer, log, length );
            if ( HalpCmcInfo.KernelDelivery )   {
                HalpSaveMceLog( &HalpCmcInfo.KernelLogs, log, length );
            }
        }
        *ReturnedLength = length;
    }

    //
    // Restore threads affinity, release mutex.
    //

    KeRevertToUserAffinityThread();
    HalpReleaseCmcMutex();

    //
    // If the caller is not the Kernel-WMI, free the allocated NonPagedPool log.
    //

    if ( !kernelQuery ) {
        ExFreePoolWithTag( log, 'TcmC' );
    }

    return status;

} // HalpGetCmcLog()

NTSTATUS
HalpGetCpeLog (
    OUT PCPE_EXCEPTION  Buffer,
    IN  ULONG           BufferSize,
    OUT PULONG          ReturnedLength
    )
/*++

Routine Description:

    This function is called by HaliQuerySysteminformation for the HalCpeLogInformation class.
    It provides a CPE log to the caller.

Arguments:

    Buffer        : Buffer into which the error is reported
    BufferSize    : Size of the passed buffer
    ReturnedLength: Length of the log. This pointer was validated by caller.

Return Value:

    Success or failure

--*/
{
    ULONG                 maxLogSize;
    BOOLEAN               kernelQuery;
    KAFFINITY             activeProcessors, currentAffinity;
    NTSTATUS              status;
    PERROR_RECORD_HEADER  log;
    PHALP_MCELOGS_HEADER  logsHeader;

    PAGED_CODE();

    //
    // If CPE is not enabled, return immediately.
    //

    if ( !(HalpFeatureBits & HAL_CPE_PRESENT) ) {
        return( STATUS_NO_SUCH_DEVICE );
    }

    //
    // Assertions for the HAL CPE implementation.
    //

    ASSERTMSG( "HAL!HalpGetCpeLog: ReturnedLength NULL!\n", ReturnedLength );
    ASSERTMSG( "HAL!HalpGetCpeLog: HalpCpeInfo.MaxLogSize 0!\n", HalpCpeInfo.Stats.MaxLogSize );
    ASSERTMSG( "HAL!HalpGetCpeLog: HalpCpeInfo.MaxLogSize < sizeof(ERROR_RECORD_HEADER)!\n", 
                                 HalpCpeInfo.Stats.MaxLogSize >= sizeof(ERROR_RECORD_HEADER) );

    //
    // Let's the caller know about its passed buffer size or the minimum required size.
    //

    maxLogSize = HalpCpeInfo.Stats.MaxLogSize;
    if ( BufferSize < maxLogSize )  {
        *ReturnedLength = maxLogSize;
        return( STATUS_INVALID_BUFFER_SIZE );
    }

    //
    // Determine if the caller is the kernel-WMI.
    //

    kernelQuery = IsMceKernelQuery( Buffer );
    logsHeader = ( kernelQuery ) ? &HalpCpeInfo.KernelLogs : &HalpCpeInfo.DriverLogs;

    //
    // Enable MP protection for CPE logs accesses
    //

    status = STATUS_NOT_FOUND;
    HalpAcquireCpeMutex();

    //
    // If saved logs exist, pop an entry.
    //

    if ( logsHeader->Count ) {
        PSINGLE_LIST_ENTRY entry, lastEntry;

        entry = HalpGetSavedMceLog( logsHeader, &lastEntry );
        if ( entry )  {
            PERROR_RECORD_HEADER savedLog;
            ULONG length;

            savedLog = HalpMceLogFromListEntry( entry );
            length   = savedLog->Length;
            if ( length <= BufferSize )  {
                ULONG logsCount;

                RtlCopyMemory( Buffer, savedLog, length );
                ExFreePoolWithTag( entry, logsHeader->Tag );
                lastEntry->Next = NULL;
                logsCount = (--logsHeader->Count);
                HalpReleaseCpeMutex();
                *ReturnedLength = length;
                if ( logsCount )   {
                   return( STATUS_MORE_ENTRIES );
                }
                else   {
                   return( STATUS_SUCCESS );
                }
            } 
            else   {
                HalpReleaseCpeMutex();
                *ReturnedLength = length; 
                return( STATUS_INVALID_BUFFER_SIZE );
            }
        }
    }

    //
    // Initalize local log pointer after memory allocation if required.
    //

    if ( kernelQuery ) {
        log = (PERROR_RECORD_HEADER)Buffer;
    }
    else  {

        //
        // The OEM CPE driver HAL interface does not require the CPE driver memory
        // for the log buffer to be allocated from NonPagedPool.
        // Also, MM does not export memory pool type checking APIs.
        // It is safer to allocate in NonPagedPool and pass this buffer to the SAL.
        // If the SAL interface is sucessful, we will copy the buffer to the caller's buffer.
        //

        log = ExAllocatePoolWithTag( NonPagedPool, maxLogSize, 'TpeC' );
        if ( log == NULL ) {
            HalpReleaseCpeMutex();
            return( STATUS_NO_MEMORY );
        }
    }

    //
    // We did not have any saved log, migrate from 1 processor to another to collect 
    // the FW logs.
    //

    activeProcessors = HalpActiveProcessors;
    for (currentAffinity = 1; activeProcessors; currentAffinity <<= 1) {

        if (activeProcessors & currentAffinity) {
            
            activeProcessors &= ~currentAffinity;
            KeSetSystemAffinityThread(currentAffinity);

            status = HalpGetFwMceLog( CPE_EVENT, log, &HalpCpeInfo.Stats, HALP_FWMCE_DO_CLEAR_LOG );
            if ( NT_SUCCESS( status ) || 
                 ( (status != STATUS_NOT_FOUND) && (status != STATUS_ALREADY_COMMITTED) ) ) {
                break;
            }
        }
    }

    if ( NT_SUCCESS( status ) ) {
        ULONG length = log->Length; // Note: Length was checked in HalpGetMceLog().

        if ( kernelQuery ) {
            if ( HalpCpeInfo.DriverInfo.DpcCallback )   {
                HalpSaveMceLog( &HalpCpeInfo.DriverLogs, log, length );
            }
        }
        else  {
            RtlCopyMemory( Buffer, log, length );
            if ( HalpCpeInfo.KernelDelivery )   {
                HalpSaveMceLog( &HalpCpeInfo.KernelLogs, log, length );
            }
        }
        *ReturnedLength = length;
    }

    //
    // Restore threads affinity, release mutex.
    //

    KeRevertToUserAffinityThread();
    HalpReleaseCpeMutex();

    //
    // If the caller is not the Kernel-WMI, free the allocated NonPagedPool log.
    //

    if ( !kernelQuery ) {
        ExFreePoolWithTag( log, 'TpeC' );
    }

    return status;

} // HalpGetCpeLog()

VOID
HalpMcaGetConfiguration (
    OUT PULONG  MCAEnabled,
    OUT PULONG  CMCEnabled,
    OUT PULONG  CPEEnabled,
    OUT PULONG  NoMCABugCheck,
    OUT PULONG  MCEOemDriversEnabled
)

/*++

Routine Description:

    This routine returns the registry settings for the 
    the IA64 Error - MCA, CMC, CPE - configuration information.

Arguments:

    MCAEnabled - Pointer to the MCAEnabled indicator.
                 0 = False, 1 = True (1 if value not present in Registry).

    CMCEnabled - Pointer to the CMCEnabled indicator.
                 0     = HAL CMC Handling should be disabled. 
                         Registry value was (present and set to 0) or was not present.
                 -1|1  = HAL CMC Interrupt-based mode. See Note 1/ below.
                 Other = HAL CMC Polling mode and value is user-specified polling interval.

    CPEEnabled - Pointer to the CPEEnabled indicator.
                 0     = HAL CPE Handling should be disabled. 
                         Registry value was (present and set to 0) or was not present.
                 -1|1  = HAL CPE Interrupt-based mode. See Note 1/ below.
                 Other = HAL CPE Polling mode and value is user-specified polling interval.

    NoMCABugCheck - Pointer to the MCA BugCheck indicator.
                 0 = Fatal MCA HAL processing calls the KeBugCheckEx path.
                 1 = Fatal MCA HAL processing does not call the KeBugCheckEx path.
                     The system stalls. This is useful for extreme error containment.
                 if not present = value is 0, e.g. HAL calls KeBugCheckEx for fatal MCA.

    MCEOemDriversEnabled - Pointer to the MCEOemDriversEnabled indicator.
                           0 = HAL OEM MCE Drivers registration is disabled.
                           1 = HAL OEM MCE Drivers registration is enabled.  
                           If not present = value is 0, e.g. registration is disabled.

Return Value:

    None.

Notes:

  1/  HAL defines minimum values for polling intervals. These minima are defined > 1, as imposed
      by the C_ASSERTs in HalpMcaInit().

--*/

{

    RTL_QUERY_REGISTRY_TABLE    parameters[6];
    ULONG                       defaultDataCMC;
    ULONG                       defaultDataMCA;
    ULONG                       defaultDataCPE;
    ULONG                       defaultNoMCABugCheck;
    ULONG                       defaultMCEOemDriversEnabled;

    RtlZeroMemory(parameters, sizeof(parameters));
    defaultDataCMC = *CMCEnabled = 0;
    defaultDataMCA = *MCAEnabled = TRUE;
    defaultDataCPE = *CPEEnabled = 0;
    defaultNoMCABugCheck = *NoMCABugCheck = FALSE;
    defaultMCEOemDriversEnabled = FALSE;  // 06/09/01: default chosen by MS IA64 MCA PM.

    //
    // Gather all of the "user specified" information from
    // the registry.
    //

    parameters[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    parameters[0].Name = rgzEnableCMC;
    parameters[0].EntryContext = CMCEnabled;
    parameters[0].DefaultType = REG_DWORD;
    parameters[0].DefaultData = &defaultDataCMC;
    parameters[0].DefaultLength = sizeof(ULONG);

    parameters[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
    parameters[1].Name = rgzEnableMCA;
    parameters[1].EntryContext =  MCAEnabled;
    parameters[1].DefaultType = REG_DWORD;
    parameters[1].DefaultData = &defaultDataMCA;
    parameters[1].DefaultLength = sizeof(ULONG);

    parameters[2].Flags = RTL_QUERY_REGISTRY_DIRECT;
    parameters[2].Name = rgzEnableCPE;
    parameters[2].EntryContext =  CPEEnabled;
    parameters[2].DefaultType = REG_DWORD;
    parameters[2].DefaultData = &defaultDataCPE;
    parameters[2].DefaultLength = sizeof(ULONG);

    parameters[3].Flags = RTL_QUERY_REGISTRY_DIRECT;
    parameters[3].Name = rgzNoMCABugCheck;
    parameters[3].EntryContext =  NoMCABugCheck;
    parameters[3].DefaultType = REG_DWORD;
    parameters[3].DefaultData = &defaultNoMCABugCheck;
    parameters[3].DefaultLength = sizeof(ULONG);

    parameters[4].Flags = RTL_QUERY_REGISTRY_DIRECT;
    parameters[4].Name = rgzEnableMCEOemDrivers;
    parameters[4].EntryContext =  MCEOemDriversEnabled;
    parameters[4].DefaultType = REG_DWORD;
    parameters[4].DefaultData = &defaultMCEOemDriversEnabled;
    parameters[4].DefaultLength = sizeof(ULONG);

    RtlQueryRegistryValues(
        RTL_REGISTRY_CONTROL | RTL_REGISTRY_OPTIONAL,
        rgzSessionManager,
        parameters,
        NULL,
        NULL
        );

    return;

} // HalpMcaGetConfiguration()

NTSTATUS
HalpSetMcaLog (
    IN  PMCA_EXCEPTION  Buffer,
    IN  ULONG           BufferSize
    )
/*++

Routine Description:

   This function is called by HaliSetSysteminformation for the HalMcaLog class.
   It stores the passed MCA record in the HAL. 
   This functionality was requested by the MS Test Team to validate the HAL/WMI/WMI consumer
   path with "well-known" logs.

Arguments:

   Buffer        : supplies the MCA log.
   BufferSize    : supplies the MCA log size.

Return Value:

   Success or failure

Implementation Notes:

    As requested by the WMI and Test Teams, there is mininum HAL processing for the record
    and no validation of the record contents.

--*/
{
    ULONG                 maxLogSize;
    BOOLEAN               kernelQuery;
    KAFFINITY             activeProcessors, currentAffinity;
    NTSTATUS              status;
    PERROR_RECORD_HEADER  log;
    PHALP_MCELOGS_HEADER  logsHeader;
    KIRQL                 oldIrql;

    HALP_VALIDATE_LOW_IRQL()

    //
    // Check calling arguments.
    //

    if ( (Buffer == (PMCA_EXCEPTION)0) || (BufferSize == 0) )    {
        return( STATUS_INVALID_PARAMETER );
    }

    //
    // If MCA is not enabled, return immediately.
    //

    if ( !(HalpFeatureBits & HAL_MCA_PRESENT) ) {
        return( STATUS_NO_SUCH_DEVICE );
    }

    //
    // Enable MP protection for MCA logs accesses
    //

    HalpAcquireMcaMutex();

    //
    // Save log on Kernel and Drivers Logs if enabled.
    //

    if ( HalpMcaInfo.KernelDelivery )   {
       HalpSaveMceLog( &HalpMcaInfo.KernelLogs, Buffer, BufferSize );
    }

    if ( HalpMcaInfo.DriverInfo.DpcCallback )   {
       HalpSaveMceLog( &HalpMcaInfo.DriverLogs, Buffer, BufferSize );
    }

    //
    // Let Kernel or OEM MCA driver know about it.
    //
    // There is no model other than INTERRUPTS_BASED for MCA at this date - 05/04/01.
    //

    if ( HalpMcaInfo.KernelDelivery || HalpMcaInfo.DriverInfo.DpcCallback ) {
        InterlockedExchange( &HalpMcaInfo.DpcNotification, 1 );
    }

    //
    // release mutex.
    //

    HalpReleaseMcaMutex();

    return( STATUS_SUCCESS );

} // HalpSetMcaLog()

NTSTATUS
HalpSetCmcLog (
    IN  PCMC_EXCEPTION  Buffer,
    IN  ULONG           BufferSize
    )
/*++

Routine Description:

   This function is called by HaliSetSysteminformation for the HalCmcLog class.
   It stores the passed CMC record in the HAL. 
   This functionality was requested by the MS Test Team to validate the HAL/WMI/WMI consumer
   path with "well-known" logs.

Arguments:

   Buffer        : supplies the CMC log.
   BufferSize    : supplies the CMC log size.

Return Value:

   Success or failure

Implementation Notes:

    As requested by the WMI and Test Teams, there is mininum HAL processing for the record
    and no validation of the record contents.

--*/
{
    ULONG                 maxLogSize;
    BOOLEAN               kernelQuery;
    KAFFINITY             activeProcessors, currentAffinity;
    NTSTATUS              status;
    PERROR_RECORD_HEADER  log;
    PHALP_MCELOGS_HEADER  logsHeader;
    KIRQL                 oldIrql;

    HALP_VALIDATE_LOW_IRQL()

    //
    // Check calling arguments.
    //

    if ( (Buffer == (PCMC_EXCEPTION)0) || (BufferSize == 0) )    {
        return( STATUS_INVALID_PARAMETER );
    }

    //
    // If CMC is not enabled, return immediately.
    //

    if ( !(HalpFeatureBits & HAL_CMC_PRESENT) ) {
        return( STATUS_NO_SUCH_DEVICE );
    }

    //
    // Enable MP protection for CMC logs accesses
    //

    HalpAcquireCmcMutex();

    //
    // Save log on Kernel and Driver Logs if enabled.
    //

    if ( HalpCmcInfo.KernelDelivery )   {
       HalpSaveMceLog( &HalpCmcInfo.KernelLogs, Buffer, BufferSize );
    }

    if ( HalpCmcInfo.DriverInfo.DpcCallback )   {
       HalpSaveMceLog( &HalpCmcInfo.DriverLogs, Buffer, BufferSize );
    }

    //
    // If Interrupt based mode, call directly second-level handler at CMCI level.
    //

    if ( HalpCmcInfo.Stats.PollingInterval == HAL_CMC_INTERRUPTS_BASED )    {
        KeRaiseIrql(CMCI_LEVEL, &oldIrql);
        HalpCmcHandler();
        KeLowerIrql( oldIrql );
    }

    //
    // release mutex.
    //

    HalpReleaseCmcMutex();

    return( STATUS_SUCCESS );

} // HalpSetCmcLog()

NTSTATUS
HalpSetCpeLog (
    IN  PCPE_EXCEPTION  Buffer,
    IN  ULONG           BufferSize
    )
/*++

Routine Description:

   This function is called by HaliSetSysteminformation for the HalCpeLog class.
   It stores the passed CPE record in the HAL. 
   This functionality was requested by the MS Test Team to validate the HAL/WMI/WMI consumer
   path with "well-known" logs.

Arguments:

   Buffer        : supplies the CPE log.
   BufferSize    : supplies the CPE log size.

Return Value:

   Success or failure

Implementation Notes:

    As requested by the WMI and Test Teams, there is mininum HAL processing for the record
    and no validation of the record contents.

--*/
{
    ULONG                 maxLogSize;
    BOOLEAN               kernelQuery;
    KAFFINITY             activeProcessors, currentAffinity;
    NTSTATUS              status;
    PERROR_RECORD_HEADER  log;
    PHALP_MCELOGS_HEADER  logsHeader;
    KIRQL                 oldIrql;

    HALP_VALIDATE_LOW_IRQL()

    //
    // Check calling arguments.
    //

    if ( (Buffer == (PCPE_EXCEPTION)0) || (BufferSize == 0) )    {
        return( STATUS_INVALID_PARAMETER );
    }

    //
    // If CPE is not enabled, return immediately.
    //

    if ( !(HalpFeatureBits & HAL_CPE_PRESENT) ) {
        return( STATUS_NO_SUCH_DEVICE );
    }

    //
    // Enable MP protection for CPE logs accesses
    //

    HalpAcquireCpeMutex();

    //
    // Save log on Kernel and Drivers Logs if enabled.
    //

    if ( HalpCpeInfo.KernelDelivery )   {
       HalpSaveMceLog( &HalpCpeInfo.KernelLogs, Buffer, BufferSize );
    }

    if ( HalpCpeInfo.DriverInfo.DpcCallback )   {
       HalpSaveMceLog( &HalpCpeInfo.DriverLogs, Buffer, BufferSize );
    }

    //
    // If Interrupt based mode, call directly second-level handler at CPEI level.
    //

    if ( HalpCpeInfo.Stats.PollingInterval == HAL_CPE_INTERRUPTS_BASED )    {
        KeRaiseIrql(CPEI_LEVEL, &oldIrql);
        HalpCpeHandler();
        KeLowerIrql( oldIrql );
    }

    //
    // release mutex.
    //

    HalpReleaseCpeMutex();

    return( STATUS_SUCCESS );

} // HalpSetCpeLog()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\ixsleep.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ixsleep.h

Abstract:

    This file has all the common headers used
    for saving and restoring context for multiple
    processors.

Author:

    Jake Oshins (jakeo) March 25, 1998

Revision History:

--*/

VOID
HalpSavePicState(
    VOID
    );

VOID
HalpRestorePicState(
    VOID
    );

VOID
HalpRestoreTempPicState(
    VOID
    );

VOID
HalpSaveProcessorStateAndWait(
    IN PKPROCESSOR_STATE ProcessorState,
    IN volatile PULONG   Count
    );

extern PVOID HalpResumeContext;
extern PKPROCESSOR_STATE HalpHiberProcState;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\ixreboot.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ixreboot.c

Abstract:

    Provides the interface to the firmware for x86.  Since there is no
    firmware to speak of on x86, this is just reboot support.

Author:

    John Vert (jvert) 12-Aug-1991

Revision History:

--*/
#include "halp.h"

//
// Defines to let us diddle the CMOS clock and the keyboard
//

#define CMOS_CTRL   (PUCHAR )0x70
#define CMOS_DATA   (PUCHAR )0x71

#define RESET       0xfe
#define KEYBPORT    (PUCHAR )0x64

//
// Private function prototypes
//

VOID
HalpReboot (
    VOID
    );

VOID
HalpReboot (
    VOID
    )

/*++

Routine Description:

    This procedure resets the CMOS clock to the standard timer settings
    so the bios will work, and then issues a reset command to the keyboard
    to cause a warm boot.

    It is very machine dependent, this implementation is intended for
    PC-AT like machines.

    This code copied from the "old debugger" sources.

    N.B.

        Will NOT return.

--*/

{
    UCHAR   Scratch;
    PUSHORT   Magic;
    EFI_STATUS  status;


    //
    // Disable IA64 Errror Handling 
    //

    HalpMCADisable();

    //
    // Instead of the previous code we will use Efi's reset proc (RESET_TYPE = cold boot). 
    //

    status =  HalpCallEfi (
                  EFI_RESET_SYSTEM_INDEX,
                  (ULONGLONG)EfiResetCold,
                  EFI_SUCCESS, 
                  0,           
                  0,
                  0,
                  0,
                  0,
                  0
                  );
     

    HalDebugPrint(( HAL_INFO, "HAL: HalpReboot - returned from HalpCallEfi: %I64X\n", status ));
    
   
    //
    // If we return, send the reset command to the keyboard controller
    //

    WRITE_PORT_UCHAR(KEYBPORT, RESET);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\ixthrotl.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ixthrotl.c

Abstract:

    This module implements the code for throttling the processors

Author:

    Jake Oshins (jakeo) 17-July-1997

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "acpitabl.h"
#include "xxacpi.h"
#include "pci.h"


VOID
FASTCALL
HalProcessorThrottle (
    IN UCHAR Throttle
    )
/*++

Routine Description:

    This function limits the speed of the processor.

Arguments:

    (ecx) = Throttle setting

Return Value:

    none

--*/
{
	HalDebugPrint(( HAL_ERROR, "HAL: HalProcessorThrottle - Throttle not yet supported for IA64" ));
    KeBugCheck(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\ixslpsup.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    ixhibrnt.c

Abstract:

    This file provides the code that saves and restores
    state for traditional motherboard devices when the
    system goes into a sleep state that removes power.

Author:

    Jake Oshins (jakeo) May 6, 1997

Revision History:

--*/

#include "halp.h"

extern PVOID   HalpEisaControlBase;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, HaliLocateHiberRanges)
#pragma alloc_text(PAGELK, HalpSaveDmaControllerState)
#pragma alloc_text(PAGELK, HalpSaveTimerState)
#ifdef PIC_SUPPORTED
#pragma alloc_text(PAGELK, HalpSavePicState)
#pragma alloc_text(PAGELK, HalpRestorePicState)
#endif
#pragma alloc_text(PAGELK, HalpRestoreDmaControllerState)
#pragma alloc_text(PAGELK, HalpRestoreTimerState)
#endif

#ifdef notyet



#define EISA_CONTROL (PUCHAR)&((PEISA_CONTROL) HalpEisaControlBase)


#endif // notyet


#ifdef PIC_SUPPORTED
VOID
HalpSavePicState(
    VOID
    )
{
#ifdef notyet
 //
 // Commented HalpMotherboardState and EISA_CONTROL********
 //

#ifdef notyet

    HalpMotherboardState.PicState.MasterMask =
    READ_PORT_UCHAR(EISA_CONTROL->Interrupt1ControlPort1);

#endif // notyet

#if defined(NEC_98)
#else
    HalpMotherboardState.PicState.MasterEdgeLevelControl =
        READ_PORT_UCHAR(EISA_CONTROL->Interrupt1EdgeLevel);

    HalpMotherboardState.PicState.SlaveEdgeLevelControl =
        READ_PORT_UCHAR(EISA_CONTROL->Interrupt2EdgeLevel);
#endif

#endif // notyet

}

VOID
HalpRestorePicState(
    VOID
    )
{

#ifdef notyet

    ULONG flags;
   
   
    // _asm {
    //       pushfd
    //        pop     flags
    //        cli
    //  }

    _disable();

#ifdef notyet
 
   HalpInitializePICs(FALSE);

//
// HalpMotherboardState,EISA_CONTROL and assembly instruction commented
//

    WRITE_PORT_UCHAR(
        EISA_CONTROL->Interrupt1ControlPort1,
        HalpMotherboardState.PicState.MasterMask
        );

   WRITE_PORT_UCHAR(
       EISA_CONTROL->Interrupt2ControlPort1,
       HalpMotherboardState.PicState.SlaveMask
       );

#endif // notyet

#if defined(NEC_98)
#else
     //
     // For halx86, the PCI interrupt vector programming 
     // is static, so this code can just restore everything.
     //
     HalpRestorePicEdgeLevelRegister();

#endif


   // _asm {
   //     push    flags
   //      popfd
   //   }
  
      

   }

   #ifndef NEC_98
   VOID
   HalpRestorePicEdgeLevelRegister(
       VOID
       )
   { 

    WRITE_PORT_UCHAR(EISA_CONTROL->Interrupt1EdgeLevel,
                     HalpMotherboardState.PicState.MasterEdgeLevelControl);

    WRITE_PORT_UCHAR(EISA_CONTROL->Interrupt2EdgeLevel,
                     HalpMotherboardState.PicState.SlaveEdgeLevelControl);
   }

#endif


#endif // notyet

}
#endif


VOID
HalpSaveDmaControllerState(
    VOID
    )
{
#ifdef notyet
 
#if defined(NEC_98)

#else
    HalpMotherboardState.DmaState.Dma1ExtendedModePort =
        READ_PORT_UCHAR(
            EISA_CONTROL->Dma1ExtendedModePort
            );

    HalpMotherboardState.DmaState.Dma2ExtendedModePort =
        READ_PORT_UCHAR(
            EISA_CONTROL->Dma2ExtendedModePort
            );

#endif // NEC_98


#ifdef notyet

    HalpMotherboardState.DmaState.Dma2ExtendedModePort =
        READ_PORT_UCHAR(
            EISA_CONTROL->Dma2ExtendedModePort
            );

    HalpMotherboardState.DmaState.Dma1Control.Mode =
        READ_PORT_UCHAR(
            EISA_CONTROL->Dma1BasePort.Mode
            );

    HalpMotherboardState.DmaState.Dma2Control.Mode =
        READ_PORT_UCHAR(
            EISA_CONTROL->Dma2BasePort.Mode
            );

   HalpMotherboardState.DmaState.Dma1Control.SingleMask =
        READ_PORT_UCHAR(
            EISA_CONTROL->Dma1BasePort.SingleMask
            );

   HalpMotherboardState.DmaState.Dma2Control.SingleMask =
        READ_PORT_UCHAR(
            EISA_CONTROL->Dma2BasePort.SingleMask
            );

#endif // notyet

#endif // notyet
}



VOID
HalpRestoreDmaControllerState(
    VOID
    )

{
#ifdef notyet
#if defined(NEC_98)
#else
    UCHAR   i;

    WRITE_PORT_UCHAR(
        EISA_CONTROL->Dma1ExtendedModePort,
        HalpMotherboardState.DmaState.Dma1ExtendedModePort
        );

    WRITE_PORT_UCHAR(
        EISA_CONTROL->Dma2ExtendedModePort,
        HalpMotherboardState.DmaState.Dma2ExtendedModePort
        );

    for (i = 0; i < (EISA_DMA_CHANNELS / 2); i++) {

        //
        // Check to see if the array has contains a value for this channel.
        //

        if ((HalpDmaChannelModes[i] & 0x3) == i) {

            WRITE_PORT_UCHAR(
                EISA_CONTROL->Dma1BasePort.Mode,
                HalpDmaChannelModes[i]
                );

            WRITE_PORT_UCHAR(
                EISA_CONTROL->Dma1BasePort.SingleMask,
                HalpDmaChannelMasks[i]
                );

        }

        if ((HalpDmaChannelModes[i + (EISA_DMA_CHANNELS / 2)] & 0x3) == i) {

            WRITE_PORT_UCHAR(
                EISA_CONTROL->Dma2BasePort.Mode,
                HalpDmaChannelModes[i + (EISA_DMA_CHANNELS / 2)]
                );

            WRITE_PORT_UCHAR(
                EISA_CONTROL->Dma2BasePort.SingleMask,
                HalpDmaChannelMasks[i]
                );

        }
    }
#endif

#endif // notyet 

}

VOID
HalpSaveTimerState(
    VOID
    )
{

}

VOID
HalpRestoreTimerState(
    VOID
    )
{
    HalpInitializeClock();
}

VOID
HaliLocateHiberRanges (
    IN PVOID MemoryMap
    )
{
  ;
    //
    // Mark the hal's data section as needed to be cloned
    //
    //
    // Commented PO_MEM_CLONE, PO_MEM_PAGE_ADDRESS and PO_MEM_DISCARD
    //

#ifdef notyet

    // PoSetHiberRange (
    //     MemoryMap,
    //     PO_MEM_CLONE,
    //     (PVOID) &HalpFeatureBits,
    //     0,
    //     'dlah'
    //     );

    //
    // Mark DMA buffer has not needing saved
    //

    // if (HalpMapBufferSize) {
    //     PoSetHiberRange (
    //         MemoryMap,
    //         PO_MEM_DISCARD | PO_MEM_PAGE_ADDRESS,
    //         (PVOID) (HalpMapBufferPhysicalAddress.LowPart >> PAGE_SHIFT),
    //         HalpMapBufferSize >> PAGE_SHIFT,
    //         'mlah'
    //         );
    //    }

#endif // notyet

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\ixusage.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ixusage.c

Abstract:

Author:

    Ken Reneris (kenr)

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "kdcom.h"

//
// Array to remember hal's IDT usage
//

extern ADDRESS_USAGE  *HalpAddressUsageList;
extern IDTUsage        HalpIDTUsage[MAXIMUM_IDTVECTOR];
extern WCHAR HalpSzSystem[];
extern WCHAR HalpSzSerialNumber[];
extern KAFFINITY HalpActiveProcessors;

PUCHAR KdComPortInUse = NULL;

ADDRESS_USAGE HalpComIoSpace = {
    NULL, CmResourceTypePort, DeviceUsage,
    {
        0x2F8,  0x8,    // Default is 2F8 for COM2.  This will be changed.
        0, 0
    }
};

VOID
HalpGetResourceSortValue (
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR  pRCurLoc,
    OUT PULONG                          sortscale,
    OUT PLARGE_INTEGER                  sortvalue
    );

USHORT HalpComPortIrqMapping[5][2] = {
    {COM1_PORT, 4},
    {COM2_PORT, 3},
    {COM3_PORT, 4},
    {COM4_PORT, 3},
    {0,0}
};

VOID
HalpReportSerialNumber (
    VOID
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpRegisterVector)
#pragma alloc_text(INIT,HalpGetResourceSortValue)
#pragma alloc_text(INIT,HalpReportResourceUsage)
#pragma alloc_text(INIT,HalpReportSerialNumber)
#endif




VOID
HalpRegisterVector (
    IN UCHAR    ReportFlags,
    IN ULONG    BusInterruptVector,
    IN ULONG    SystemInterruptVector,
    IN KIRQL    SystemIrql
    )
/*++

Routine Description:

    This registers an IDT vectors usage by the HAL.

Arguments:

Return Value:

--*/
{
#if DBG
    // There are only 0ff IDT entries...
    ASSERT (SystemInterruptVector <= MAXIMUM_IDTVECTOR  &&
            BusInterruptVector <= MAXIMUM_IDTVECTOR);
#endif

    //
    // Remember which vector the hal is connecting so it can be reported
    // later on
    //

    HalpIDTUsage[SystemInterruptVector].Flags = ReportFlags;
    HalpIDTUsage[SystemInterruptVector].Irql  = SystemIrql;
    HalpIDTUsage[SystemInterruptVector].BusReleativeVector = (UCHAR) BusInterruptVector;
}


VOID
HalpGetResourceSortValue (
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR  pRCurLoc,
    OUT PULONG                          sortscale,
    OUT PLARGE_INTEGER                  sortvalue
    )
/*++

Routine Description:

    Used by HalpReportResourceUsage in order to properly sort
    partial_resource_descriptors.

Arguments:

    pRCurLoc    - resource descriptor

Return Value:

    sortscale   - scaling of resource descriptor for sorting
    sortvalue   - value to sort on


--*/
{
    switch (pRCurLoc->Type) {
        case CmResourceTypeInterrupt:
            *sortscale = 0;
            *sortvalue = RtlConvertUlongToLargeInteger(
                        pRCurLoc->u.Interrupt.Level );
            break;

        case CmResourceTypePort:
            *sortscale = 1;
            *sortvalue = pRCurLoc->u.Port.Start;
            break;

        case CmResourceTypeMemory:
            *sortscale = 2;
            *sortvalue = pRCurLoc->u.Memory.Start;
            break;

        default:
            *sortscale = 4;
            *sortvalue = RtlConvertUlongToLargeInteger (0);
            break;
    }
}


VOID
HalpReportResourceUsage (
    IN PUNICODE_STRING  HalName,
    IN INTERFACE_TYPE   DeviceInterfaceToUse
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PCM_RESOURCE_LIST               RawResourceList, TranslatedResourceList;
    PCM_FULL_RESOURCE_DESCRIPTOR    pRFullDesc,      pTFullDesc;
    PCM_PARTIAL_RESOURCE_LIST       pRPartList,      pTPartList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pRCurLoc,        pTCurLoc;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pRSortLoc,       pTSortLoc;
    CM_PARTIAL_RESOURCE_DESCRIPTOR  RPartialDesc,    TPartialDesc;
    ULONG   i, j, k, ListSize, Count;
    ULONG   curscale, sortscale;
    UCHAR   pass, reporton;
    INTERFACE_TYPE  interfacetype;
    ULONG           CurrentIDT, CurrentElement;
    ADDRESS_USAGE   *CurrentAddress;
    LARGE_INTEGER   curvalue, sortvalue;

    //
    // Claim the debugger com port resource if it is in use
    //
    if (KdComPortInUse != NULL) {
        HalpComIoSpace.Element[0].Start = (ULONG)(ULONG_PTR)KdComPortInUse;
        HalpRegisterAddressUsage(&HalpComIoSpace);

        //
        // The debugger does not use any interrupts. However for consistent
        // behaviour between a machine with and without a debugger, we claim
        // an interrupt for the debugger if the debugger port address is one
        // for COM1-4.
        //
        
        for (i = 0; HalpComPortIrqMapping[i][0]; i++) {
            
            if ((PUCHAR)HalpComPortIrqMapping[i][0] == KdComPortInUse) {
                
                HalpRegisterVector( DeviceUsage | InterruptLatched,
                                    HalpComPortIrqMapping[i][1],
                                    HalpComPortIrqMapping[i][1] +
                                    PRIMARY_VECTOR_BASE,
                                    HIGH_LEVEL);
                break;
            }
        }
    }

    //
    // Allocate some space to build the resource structure
    //

    RawResourceList = (PCM_RESOURCE_LIST)ExAllocatePoolWithTag(
                                             NonPagedPool,
                                             PAGE_SIZE*2,
                                             HAL_POOL_TAG);
    TranslatedResourceList = (PCM_RESOURCE_LIST)ExAllocatePoolWithTag(
                                                    NonPagedPool,
                                                    PAGE_SIZE*2,
                                                    HAL_POOL_TAG);
    if (!RawResourceList || !TranslatedResourceList) {

        //
        // These allocations were critical.
        //

        KeBugCheckEx(HAL_MEMORY_ALLOCATION,
                     PAGE_SIZE*4,
                     1,
                     (UINT_PTR)__FILE__,
                     __LINE__
                     );
    }

    //
    // This functions assumes unset fields are zero
    //

    RtlZeroMemory(RawResourceList, PAGE_SIZE*2);
    RtlZeroMemory(TranslatedResourceList, PAGE_SIZE*2);

    //
    // Initialize the lists
    //

    RawResourceList->List[0].InterfaceType = (INTERFACE_TYPE) -1;

    pRFullDesc = RawResourceList->List;
    pRCurLoc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) RawResourceList->List;
    pTCurLoc = (PCM_PARTIAL_RESOURCE_DESCRIPTOR) TranslatedResourceList->List;



    for(pass=0; pass < 2; pass++) {
        if (pass == 0) {
            //
            // First pass - build resource lists for resources reported
            // reported against device usage.
            //

            reporton = DeviceUsage & ~IDTOwned;
            interfacetype = DeviceInterfaceToUse;
        } else {

            //
            // Second pass = build reousce lists for resources reported
            // as internal usage.
            //

            reporton = InternalUsage & ~IDTOwned;
            interfacetype = Internal;
        }

        CurrentIDT = 0;
        CurrentElement = 0;
        CurrentAddress = HalpAddressUsageList;

        for (; ;) {
            if (CurrentIDT <= MAXIMUM_IDTVECTOR) {
                //
                // Check to see if CurrentIDT needs to be reported
                //

                if (!(HalpIDTUsage[CurrentIDT].Flags & reporton)) {
                    // Don't report on this one
                    CurrentIDT++;
                    continue;
                }

                //
                // Report CurrentIDT resource
                //

                RPartialDesc.Type = CmResourceTypeInterrupt;
                RPartialDesc.ShareDisposition = CmResourceShareDriverExclusive;
                RPartialDesc.Flags =
                    HalpIDTUsage[CurrentIDT].Flags & InterruptLatched ?
                    CM_RESOURCE_INTERRUPT_LATCHED :
                    CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
                RPartialDesc.u.Interrupt.Vector = HalpIDTUsage[CurrentIDT].BusReleativeVector;
                RPartialDesc.u.Interrupt.Level = HalpIDTUsage[CurrentIDT].BusReleativeVector;
                RPartialDesc.u.Interrupt.Affinity = HalpActiveProcessors;

                RtlCopyMemory (&TPartialDesc, &RPartialDesc, sizeof TPartialDesc);
                TPartialDesc.u.Interrupt.Vector = CurrentIDT;
                TPartialDesc.u.Interrupt.Level = HalpIDTUsage[CurrentIDT].Irql;

                CurrentIDT++;

            } else {
                //
                // Check to see if CurrentAddress needs to be reported
                //

                if (!CurrentAddress) {
                    break;                  // No addresses left
                }

                if (!(CurrentAddress->Flags & reporton)) {
                    // Don't report on this list
                    CurrentElement = 0;
                    CurrentAddress = CurrentAddress->Next;
                    continue;
                }

                if (!CurrentAddress->Element[CurrentElement].Length) {
                    // End of current list, go to next list
                    CurrentElement = 0;
                    CurrentAddress = CurrentAddress->Next;
                    continue;
                }

                //
                // Report CurrentAddress
                //

                RPartialDesc.Type = (UCHAR) CurrentAddress->Type;
                RPartialDesc.ShareDisposition = CmResourceShareDriverExclusive;

                if (RPartialDesc.Type == CmResourceTypePort) {
                    i = 1;              // address space port
                    RPartialDesc.Flags = CM_RESOURCE_PORT_IO;
                } else {
                    i = 0;              // address space memory
                    RPartialDesc.Flags = CM_RESOURCE_MEMORY_READ_WRITE;
                }

                // Notice: assuming u.Memory and u.Port have the same layout
                RPartialDesc.u.Memory.Start.HighPart = 0;
                RPartialDesc.u.Memory.Start.LowPart =
                    CurrentAddress->Element[CurrentElement].Start;

                RPartialDesc.u.Memory.Length =
                    CurrentAddress->Element[CurrentElement].Length;

                // translated address = Raw address
                RtlCopyMemory (&TPartialDesc, &RPartialDesc, sizeof TPartialDesc);
                HalTranslateBusAddress (
                    interfacetype,                  // device bus or internal
                    0,                              // bus number
                    RPartialDesc.u.Memory.Start,    // source address
                    &i,                             // address space
                    &TPartialDesc.u.Memory.Start ); // translated address

                if (RPartialDesc.Type == CmResourceTypePort  &&  i == 0) {
                    TPartialDesc.Flags = CM_RESOURCE_PORT_MEMORY;
                }

                CurrentElement++;
            }

            //
            // Include the current resource in the HALs list
            //

            if (pRFullDesc->InterfaceType != interfacetype) {
                //
                // Interface type changed, add another full section
                //

                RawResourceList->Count++;
                TranslatedResourceList->Count++;

                pRFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR) pRCurLoc;
                pTFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR) pTCurLoc;

                pRFullDesc->InterfaceType = interfacetype;
                pTFullDesc->InterfaceType = interfacetype;

                pRPartList = &pRFullDesc->PartialResourceList;
                pTPartList = &pTFullDesc->PartialResourceList;

                //
                // Bump current location pointers up
                //
                pRCurLoc = pRFullDesc->PartialResourceList.PartialDescriptors;
                pTCurLoc = pTFullDesc->PartialResourceList.PartialDescriptors;
            }


            pRPartList->Count++;
            pTPartList->Count++;
            RtlCopyMemory (pRCurLoc, &RPartialDesc, sizeof RPartialDesc);
            RtlCopyMemory (pTCurLoc, &TPartialDesc, sizeof TPartialDesc);

            pRCurLoc++;
            pTCurLoc++;
        }
    }

    ListSize = (ULONG) ( ((PUCHAR) pRCurLoc) - ((PUCHAR) RawResourceList) );

    //
    // The HAL's resource usage structures have been built
    // Sort the partial lists based on the Raw resource values
    //

    pRFullDesc = RawResourceList->List;
    pTFullDesc = TranslatedResourceList->List;

    for (i=0; i < RawResourceList->Count; i++) {

        pRCurLoc = pRFullDesc->PartialResourceList.PartialDescriptors;
        pTCurLoc = pTFullDesc->PartialResourceList.PartialDescriptors;
        Count = pRFullDesc->PartialResourceList.Count;

        for (j=0; j < Count; j++) {
            HalpGetResourceSortValue (pRCurLoc, &curscale, &curvalue);

            pRSortLoc = pRCurLoc;
            pTSortLoc = pTCurLoc;

            for (k=j; k < Count; k++) {
                HalpGetResourceSortValue (pRSortLoc, &sortscale, &sortvalue);

                if (sortscale < curscale ||
                    (sortscale == curscale &&
                     RtlLargeIntegerLessThan (sortvalue, curvalue)) ) {

                    //
                    // Swap the elements..
                    //

                    RtlCopyMemory (&RPartialDesc, pRCurLoc, sizeof RPartialDesc);
                    RtlCopyMemory (pRCurLoc, pRSortLoc, sizeof RPartialDesc);
                    RtlCopyMemory (pRSortLoc, &RPartialDesc, sizeof RPartialDesc);

                    // swap translated descriptor as well
                    RtlCopyMemory (&TPartialDesc, pTCurLoc, sizeof TPartialDesc);
                    RtlCopyMemory (pTCurLoc, pTSortLoc, sizeof TPartialDesc);
                    RtlCopyMemory (pTSortLoc, &TPartialDesc, sizeof TPartialDesc);

                    // get new curscale & curvalue
                    HalpGetResourceSortValue (pRCurLoc, &curscale, &curvalue);
                }

                pRSortLoc++;
                pTSortLoc++;
            }

            pRCurLoc++;
            pTCurLoc++;
        }

        pRFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR) pRCurLoc;
        pTFullDesc = (PCM_FULL_RESOURCE_DESCRIPTOR) pTCurLoc;
    }


    //
    // Inform the IO system of our resources..
    //

    IoReportHalResourceUsage (
        HalName,
        RawResourceList,
        TranslatedResourceList,
        ListSize
    );

    ExFreePool (RawResourceList);
    ExFreePool (TranslatedResourceList);

    //
    // Add system's serial number
    //

    HalpReportSerialNumber ();
}

VOID
HalpReportSerialNumber (
    VOID
    )
{
    OBJECT_ATTRIBUTES   objectAttributes;
    UNICODE_STRING      unicodeString;
    HANDLE              hSystem;
    NTSTATUS            status;

    if (!HalpSerialLen) {
        return ;
    }

    //
    // Open HKEY_LOCAL_MACHINE\Hardware\Description\System
    //

    RtlInitUnicodeString (&unicodeString, HalpSzSystem);
    InitializeObjectAttributes (
        &objectAttributes,
        &unicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,       // handle
        NULL
        );


    status = ZwOpenKey (&hSystem, KEY_READ | KEY_WRITE, &objectAttributes);
    if (NT_SUCCESS(status)) {

        //
        // Add "Serial Number" as REG_BINARY
        //

        RtlInitUnicodeString (&unicodeString, HalpSzSerialNumber);

        ZwSetValueKey (
                hSystem,
                &unicodeString,
                0L,
                REG_BINARY,
                HalpSerialNumber,
                HalpSerialLen
                );

        ZwClose (hSystem);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\merced.c ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Component Name:

    HALIA64

Module Name:

    merced.c

Abstract:

    This file declares the data structures related to 
    the Merced [aka Itanium] Processor.

Author:

    David N. Cutler (davec) 5-Mar-1989

Environment:

    ToBeSpecified

Revision History:

    3/15/2000 Thierry Fevrier (v-thief@microsoft.com):

         Initial version

--*/

#include "halp.h"
#include "ia64prof.h"
#include "merced.h"

//
// Hal Profiling Mapping for the Merced Processor.
//

HALP_PROFILE_MAPPING 
HalpProfileMapping[ ProfileIA64Maximum + 1 ] = {
    //
    // XXTF - ToBeValidated: - PMCD_MASKs 
    //                       - NumberOfTicks
    //                       - EventsCount
    //                       - Event Names
//
// HALP_PROFILE_MAPPING:           Sup.,   Event,                  Source, SourceMask, Interval, DefInt, MaxInt, MinInt
//
// NT KE architected Profile Sources:
/* ProfileTime                 */  {TRUE, MercedCpuCycles,              0, PMCD_MASK_4567, 0, 0x3bd08, 0x1d34ce80, 0x4c90},
/* ProfileAlignmentFixup       */  {FALSE, 0,0,0,0,0,0},
/* ProfileTotalIssues          */  {TRUE, MercedInstRetired,            0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfilePipelineDry          */  {TRUE, MercedPipelineFlushes,        0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileLoadInstructions     */  {TRUE, MercedRetiredLoads,           0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfilePipelineFrozen       */  {FALSE, 0,0,0,0,0,0}, // XXTF - ToBeDone - Existing or derived events ?
/* ProfileBranchInstructions   */  {TRUE, MercedBranchInstructions,     0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileTotalNonissues       */  {FALSE, 0,0,0,0,0,0}, // XXTF - ToBeDone - Existing or derived events ? MercedNonIssue
/* ProfileDcacheMisses         */  {TRUE, MercedL1DataMisses,           0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileIcacheMisses         */  {TRUE, MercedL1InstMisses,           0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileCacheMisses          */  {FALSE, 0,0,0,0,0,0}, // XXTF - ToBeDone - Existing or derived events ?
/* ProfileBranchMispredictions */  {TRUE, MercedBranchMispredictDetail, 0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileStoreInstructions    */  {TRUE, MercedRetiredStores,          0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileFpInstructions       */  {TRUE, MercedFPOperationsRetired,    0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileIntegerInstructions  */  {TRUE, MercedIntegerInstructions,    0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* Profile2Issue               */  {FALSE, 0,0,0,0,0,0}, // XXTF - ToBeDone - Existing or derived events ?
/* Profile3Issue               */  {FALSE, 0,0,0,0,0,0}, // XXTF - ToBeDone - Existing or derived events ?
/* Profile4Issue               */  {FALSE, 0,0,0,0,0,0}, // XXTF - ToBeDone - Existing or derived events ?
/* ProfileSpecialInstructions  */  {FALSE, 0,0,0,0,0,0},
/* ProfileTotalCycles          */  {TRUE, MercedCpuCycles,              0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileIcacheIssues         */  {TRUE, MercedInstReferences,         0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileDcacheAccesses       */  {TRUE, MercedDataReferences,         0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMemoryBarrierCycles  */  {TRUE, MercedMemoryStallCycles,      0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileLoadLinkedIssues     */  {FALSE, 0,0,0,0,0,0}, // XXTF - ToBeDone - Existing or derived events ?
/* ProfileMaximum              */  {FALSE, 0,0,0,0,0,0}, // End of NT KE architected Profile Sources.
// NT IA64 Processor specific Profile Sources:
//      Merced Monitored Events:
/* ProfileMercedBranchMispredictStallCycles  */ {TRUE, MercedBranchMispredictStallCycles   ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedInstAccessStallCycles        */ {TRUE, MercedInstAccessStallCycles         ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedExecLatencyStallCycles       */	{TRUE, MercedExecLatencyStallCycles        ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedDataAccessStallCycles        */ {TRUE, MercedDataAccessStallCycles         ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedBranchStallCycles            */ {TRUE, MercedBranchStallCycles             ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedInstFetchStallCycles         */ {TRUE, MercedInstFetchStallCycles          ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedExecStallCycles              */ {TRUE, MercedExecStallCycles               ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedMemoryStallCycles            */ {TRUE, MercedMemoryStallCycles             ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedTaggedInstRetired            */ {TRUE, MercedTaggedInstRetired             ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedInstRetired                  */ {TRUE, MercedInstRetired                   ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedFPOperationsRetired          */ {TRUE, MercedFPOperationsRetired           ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedFPFlushesToZero              */ {TRUE, MercedFPFlushesToZero               ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedSIRFlushes                   */ {TRUE, MercedSIRFlushes                    ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedBranchTakenDetail            */ {TRUE, MercedBranchTakenDetail             ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedBranchMultiWayDetail         */ {TRUE, MercedBranchMultiWayDetail          ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedBranchPathPrediction         */ {TRUE, MercedBranchPathPrediction          ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedBranchMispredictDetail       */ {TRUE, MercedBranchMispredictDetail        ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedBranchEvents                 */ {TRUE, MercedBranchEvents                  ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedCpuCycles                    */ {TRUE, MercedCpuCycles                     ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedISATransitions               */ {TRUE, MercedISATransitions                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedIA32InstRetired              */ {TRUE, MercedIA32InstRetired               ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL1InstReads                  */ {TRUE, MercedL1InstReads                   ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL1InstFills                  */ {TRUE, MercedL1InstFills                   ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL1InstMisses                 */ {TRUE, MercedL1InstMisses                  ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedInstEAREvents                */ {TRUE, MercedInstEAREvents                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL1InstPrefetches             */ {TRUE, MercedL1InstPrefetches              ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL2InstPrefetches             */ {TRUE, MercedL2InstPrefetches              ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedInstStreamingBufferLinesIn   */ {TRUE, MercedInstStreamingBufferLinesIn    ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedInstTLBDemandFetchMisses     */ {TRUE, MercedInstTLBDemandFetchMisses      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedInstTLBHPWInserts            */ {TRUE, MercedInstTLBHPWInserts             ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedInstDispersed                */ {TRUE, MercedInstDispersed                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedExplicitStops                */ {TRUE, MercedExplicitStops                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedImplicitStops                */ {TRUE, MercedImplicitStops                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedInstNOPRetired               */ {TRUE, MercedInstNOPRetired                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedInstPredicateSquashedRetired */ {TRUE, MercedInstPredicateSquashedRetired  ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedRSELoadRetired               */ {TRUE, MercedRSELoadRetired                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedPipelineFlushes              */ {TRUE, MercedPipelineFlushes               ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedCpuCPLChanges                */ {TRUE, MercedCpuCPLChanges                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedFailedSpeculativeCheckLoads  */ {TRUE, MercedFailedSpeculativeCheckLoads   ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedAdvancedCheckLoads           */ {TRUE, MercedAdvancedCheckLoads            ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedFailedAdvancedCheckLoads     */ {TRUE, MercedFailedAdvancedCheckLoads      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedALATOverflows                */ {TRUE, MercedALATOverflows                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedExternBPMPins03Asserted      */ {TRUE, MercedExternBPMPins03Asserted       ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedExternBPMPins45Asserted      */ {TRUE, MercedExternBPMPins45Asserted       ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedDataTCMisses                 */ {TRUE, MercedDataTCMisses                  ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedDataTLBMisses                */ {TRUE, MercedDataTLBMisses                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedDataTLBHPWInserts            */ {TRUE, MercedDataTLBHPWInserts             ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedDataReferences               */ {TRUE, MercedDataReferences                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL1DataReads                  */ {TRUE, MercedL1DataReads                   ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedRSEAccesses                  */ {TRUE, MercedRSEAccesses                   ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL1DataReadMisses             */ {TRUE, MercedL1DataReadMisses              ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL1DataEAREvents              */ {TRUE, MercedL1DataEAREvents               ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL2References                 */ {TRUE, MercedL2References                  ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL2DataReferences             */ {TRUE, MercedL2DataReferences              ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL2Misses                     */ {TRUE, MercedL2Misses                      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL1DataForcedLoadMisses       */ {TRUE, MercedL1DataForcedLoadMisses        ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedRetiredLoads                 */ {TRUE, MercedRetiredLoads                  ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedRetiredStores                */ {TRUE, MercedRetiredStores                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedRetiredUncacheableLoads      */ {TRUE, MercedRetiredUncacheableLoads       ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedRetiredUncacheableStores     */ {TRUE, MercedRetiredUncacheableStores      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedRetiredMisalignedLoads       */ {TRUE, MercedRetiredMisalignedLoads        ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedRetiredMisalignedStores      */ {TRUE, MercedRetiredMisalignedStores       ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL2Flushes                    */ {TRUE, MercedL2Flushes                     ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL2FlushesDetail              */ {TRUE, MercedL2FlushesDetail               ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL3References                 */ {TRUE, MercedL3References                  ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL3Misses                     */ {TRUE, MercedL3Misses                      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL3Reads                      */ {TRUE, MercedL3Reads                       ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL3Writes                     */ {TRUE, MercedL3Writes                      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL3LinesReplaced              */ {TRUE, MercedL3LinesReplaced               ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
	//
	// 02/08/00 - Are missing: [at least]
	//      - Front-Side bus events,
	//      - IVE events,
	//      - Debug monitor events,
	//      - ...
	//
	//
//      Merced Derived Events:
//      ProfileMercedDerivedEventMinimum,
/* ProfileMercedRSEStallCycles              */ {TRUE, MercedRSEStallCycles                  ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedIssueLimitStallCycles       */ {TRUE, MercedIssueLimitStallCycles           ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedTakenBranchStallCycles      */ {TRUE, MercedTakenBranchStallCycles          ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedFetchWindowStallCycles      */ {TRUE, MercedFetchWindowStallCycles          ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedIA64InstPerCycle            */ {TRUE, MercedIA64InstPerCycle                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedIA32InstPerCycle            */ {TRUE, MercedIA32InstPerCycle                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedAvgIA64InstPerTransition    */ {TRUE, MercedAvgIA64InstPerTransition        ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedAvgIA32InstPerTransition    */ {TRUE, MercedAvgIA32InstPerTransition        ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedAvgIA64CyclesPerTransition  */ {TRUE, MercedAvgIA64CyclesPerTransition      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedAvgIA32CyclesPerTransition  */ {TRUE, MercedAvgIA32CyclesPerTransition      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL1InstReferences            */ {TRUE, MercedL1InstReferences                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL1InstMissRatio             */ {TRUE, MercedL1InstMissRatio                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL1DataReadMissRatio         */ {TRUE, MercedL1DataReadMissRatio             ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL2MissRatio                 */ {TRUE, MercedL2MissRatio                     ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL2DataMissRatio             */ {TRUE, MercedL2DataMissRatio                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL2InstMissRatio             */ {TRUE, MercedL2InstMissRatio                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL2DataReadMissRatio         */ {TRUE, MercedL2DataReadMissRatio             ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL2DataWriteMissRatio        */ {TRUE, MercedL2DataWriteMissRatio            ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL2InstFetchRatio            */ {TRUE, MercedL2InstFetchRatio                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL2DataRatio                 */ {TRUE, MercedL2DataRatio                     ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL3MissRatio                 */ {TRUE, MercedL3MissRatio                     ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL3DataMissRatio             */ {TRUE, MercedL3DataMissRatio                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL3InstMissRatio             */ {TRUE, MercedL3InstMissRatio                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL3DataReadMissRatio         */ {TRUE, MercedL3DataReadMissRatio             ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL3DataRatio                 */ {TRUE, MercedL3DataRatio                     ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedInstReferences              */ {TRUE, MercedInstReferences                  ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedInstTLBMissRatio            */ {TRUE, MercedInstTLBMissRatio                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedDataTLBMissRatio            */ {TRUE, MercedDataTLBMissRatio                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedDataTCMissRatio             */ {TRUE, MercedDataTCMissRatio                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedInstTLBEAREvents            */ {TRUE, MercedInstTLBEAREvents                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedDataTLBEAREvents            */ {TRUE, MercedDataTLBEAREvents                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedCodeDebugRegisterMatches    */ {TRUE, MercedCodeDebugRegisterMatches        ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedDataDebugRegisterMatches    */ {TRUE, MercedDataDebugRegisterMatches        ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedControlSpeculationMissRatio */ {TRUE, MercedControlSpeculationMissRatio     ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedDataSpeculationMissRatio    */ {TRUE, MercedDataSpeculationMissRatio        ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedALATCapacityMissRatio       */ {TRUE, MercedALATCapacityMissRatio           ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL1DataWayMispredicts        */ {TRUE, MercedL1DataWayMispredicts            ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL2InstReferences            */ {TRUE, MercedL2InstReferences                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedInstFetches                 */ {TRUE, MercedInstFetches                     ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL2DataReads                 */ {TRUE, MercedL2DataReads                     ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL2DataWrites                */ {TRUE, MercedL2DataWrites                    ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL3InstReferences            */ {TRUE, MercedL3InstReferences                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL3InstMisses                */ {TRUE, MercedL3InstMisses                    ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL3InstHits                  */ {TRUE, MercedL3InstHits                      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL3DataReferences            */ {TRUE, MercedL3DataReferences                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL3LoadReferences            */ {TRUE, MercedL3LoadReferences                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL3LoadMisses                */ {TRUE, MercedL3LoadMisses                    ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL3LoadHits                  */ {TRUE, MercedL3LoadHits                      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL3ReadReferences            */ {TRUE, MercedL3ReadReferences                ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL3ReadMisses                */ {TRUE, MercedL3ReadMisses                    ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL3ReadHits                  */ {TRUE, MercedL3ReadHits                      ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL3StoreReferences           */ {TRUE, MercedL3StoreReferences               ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL3StoreMisses               */ {TRUE, MercedL3StoreMisses                   ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL3StoreHits                 */ {TRUE, MercedL3StoreHits                     ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL2WriteBackReferences       */ {TRUE, MercedL2WriteBackReferences           ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL2WriteBackMisses           */ {TRUE, MercedL2WriteBackMisses               ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL2WriteBackHits             */ {TRUE, MercedL2WriteBackHits                 ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL2WriteReferences           */ {TRUE, MercedL2WriteReferences               ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL2WriteMisses               */ {TRUE, MercedL2WriteMisses                   ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL2WriteHits                 */ {TRUE, MercedL2WriteHits                     ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedBranchInstructions          */ {TRUE, MercedBranchInstructions              ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedIntegerInstructions         */ {TRUE, MercedIntegerInstructions             ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedL1DataMisses                */ {TRUE, MercedL1DataMisses                    ,0, PMCD_MASK_4567, 0, 0x10000, 0x10000, 10},
/* ProfileMercedMaximum                     */ {FALSE, 0,0,0,0,0,0}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\merced.h ===
#ifndef MERCED_H_INCLUDED
#define MERCED_H_INCLUDED

/*++

Copyright (c) 1989-2000  Microsoft Corporation

Component Name:

    HALIA64

Module Name:

    merced.h

Abstract:

    This header file presents IA64 Itanium [aka Merced] definitions.
    Like profiling definitions.

Author:

    David N. Cutler (davec) 5-Mar-1989

Environment:

    ToBeSpecified

Revision History:

    3/15/2000 Thierry Fevrier (v-thief@microsoft.com):

         Initial version

--*/

//
// MercedBranchPathPrediction - Branch Path Mask [XXTF: not really a mask, more a specification value].
//

typedef enum _MERCED_BRANCH_PATH_RESULT_MASK {
    MISPRED_NT       = 0x0,
    MISPRED_TAKEN    = 0x1,
    OKPRED_NT        = 0x2,
    OKPRED_TAKEN     = 0x3,
} MERCED_BRANCH_PATH_RESULT_MASK;

//
// MercedBranchTakenDetail - Slot Unit Mask.
//

typedef enum _MERCED_BRANCH_TAKEN_DETAIL_SLOT_MASK {
    INSTRUCTION_SLOT0  = 0x1,
    INSTRUCTION_SLOT1  = 0x2,
    INSTRUCTION_SLOT2  = 0x4,
    NOT_TAKEN_BRANCH   = 0x8
} MERCED_BRANCH_TAKEN_DETAIL_SLOT_MASK;

//
// MercedBranchMultiWayDetail   - Prediction OutCome Mask [XXTF: not really a mask, more a specification value].
// MercedBranchMispredictDetail
//

typedef enum _MERCED_BRANCH_DETAIL_PREDICTION_OUTCOME_MASK {
    ALL_PREDICTIONS    = 0x0,
    CORRECT_PREDICTION = 0x1,
    WRONG_PATH         = 0x2,
    WRONG_TARGET       = 0x3
} MERCED_BRANCH_MWAY_DETAIL_PREDICTION_OUTCOME_MASK;

//
// MercedBranchMultiWayDetail - Branch Path Mask [XXTF: not really a mask, more a specification value].
//

typedef enum _MERCED_BRANCH_MWAY_DETAIL_BRANCH_PATH_MASK {
    NOT_TAKEN       = 0x0,
    TAKEN           = 0x1,
    ALL_PATH        = 0x2
} MERCED_BRANCH_MWAY_DETAIL_BRANCH_PATH_MASK;

//
// INST_TYPE for:
//
// MercedFailedSpeculativeCheckLoads
// MercedAdvancedCheckLoads
// MercedFailedAdvancedCheckLoads
// MercedALATOverflows
//

typedef enum _MERCED_SPECULATION_EVENT_MASK {
    NONE    = 0x0,
    INTEGER = 0x1,
    FP      = 0x2,
    ALL     = 0x3
} MERCED_SPECULATION_EVENT_MASK;
  
typedef enum _MERCED_MONITOR_EVENT_ALIAS {
   IA64_INSTS_RETIRED_EVENT_CODE = 0x09,
   FPOPS_RETIRED_EVENT_CODE      = 0x0a,
} MERCED_MONITOR_EVENT_ALIAS;

//
// MercedCpuCycles - Executing Instruction Set
//

typedef enum _MERCED_CPU_CYCLES_MODE_MASK {
    ALL_MODES = 0x0,
    IA64_MODE = 0x1,
    IA32_MODE = 0x2
} MERCED_CPU_CYCLES_MODE_MASK;

//
//  Merced Monitored Events:
//

typedef enum _MERCED_MONITOR_EVENT {
    MercedMonitoredEventMinimum         = 0x00,
    MercedBranchMispredictStallCycles   = 0x00,  //  "BRANCH_MISPRED_CYCLE"  
    MercedInstAccessStallCycles         = 0x01,  //  "INST_ACCESS_CYCLE"     
    MercedExecLatencyStallCycles        = 0x02,  //  "EXEC_LATENCY_CYCLE"
    MercedDataAccessStallCycles         = 0x03,  //  "DATA_ACCESS_CYCLE"
    MercedBranchStallCycles             = 0x04,  //  "BRANCH_CYCLE",       
    MercedInstFetchStallCycles          = 0x05,  //  "INST_FETCH_CYCLE",   
    MercedExecStallCycles               = 0x06,  //  "EXECUTION_CYCLE",    
    MercedMemoryStallCycles             = 0x07,  //  "MEMORY_CYCLE",       
    MercedTaggedInstRetired             = 0x08,  //  "IA64_TAGGED_INSTRS_RETIRED",   XXTF - ToBeDone: Set Event Qualification
    MercedInstRetired                   = IA64_INSTS_RETIRED_EVENT_CODE,  //  "IA64_INSTS_RETIRED.u", XXTF - ToBeDone: Set Umask - 0x0.
    MercedFPOperationsRetired           = FPOPS_RETIRED_EVENT_CODE,       //  "FPOPS_RETIRED",        XXTF - ToBeDone: Set IA64_TAGGED_INSTRS_RETIRED opcode
    MercedFPFlushesToZero               = 0x0b,  //  "FP_FLUSH_TO_ZERO",     
    MercedSIRFlushes                    = 0x0c,  //  "FP_SIR_FLUSH",     
    MercedBranchTakenDetail             = 0x0d,  //  "BR_TAKEN_DETAIL",       // XXTF - ToBeDone - Slot specification[0,1,2,NO] + addresses range
    MercedBranchMultiWayDetail          = 0x0e,  //  "BR_MWAY_DETAIL",        // XXTF - ToBeDone - Not taken/Taken/all path + Prediction outcome + address range
    MercedBranchPathPrediction          = 0x0f,  //  "BR_PATH_PREDICTION",    // XXTF - ToBeDone - BRANCH_PATH_RESULT specification + address range
    MercedBranchMispredictDetail        = 0x10,  //  "BR_MISPREDICT_DETAIL",  // XXTF - ToBeDone - Prediction outcome specification + address range
    MercedBranchEvents                  = 0x11,  //  "BRANCH_EVENT",    
    MercedCpuCycles                     = 0x12,  //  "CPU_CYCLES",            // XXTF - ToBeDone - All/IA64/IA32
    MercedISATransitions                = 0x14,  //  "ISA_TRANSITIONS", 
    MercedIA32InstRetired               = 0x15,  //  "IA32_INSTR_RETIRED", 
    MercedL1InstReads                   = 0x20,  //  "L0I_READS",             // XXTF - ToBeDone - + address range
    MercedL1InstFills                   = 0x21,  //  "L0I_FILLS",             // XXTF - ToBeDone - + address range
    MercedL1InstMisses                  = 0x22,  //  "L0I_MISSES",            // XXTF - ToBeDone - + address range
    MercedInstEAREvents                 = 0x23,  //  "INSTRUCTION_EAR_EVENTS",  
    MercedL1InstPrefetches              = 0x24,  //  "L0I_IPREFETCHES",       // XXTF - ToBeDone - + address range
    MercedL2InstPrefetches              = 0x25,  //  "L1_INST_PREFETCHES",    // XXTF - ToBeDone - + address range  
    MercedInstStreamingBufferLinesIn    = 0x26,  //  "ISB_LINES_IN",          // XXTF - ToBeDone - + address range
    MercedInstTLBDemandFetchMisses      = 0x27,  //  "ITLB_MISSES_FETCH",     // XXTF - ToBeDone - + ??? address range + PMC.umask on L1ITLB/L2ITLB/ALL/NOTHING.
    MercedInstTLBHPWInserts             = 0x28,  //  "ITLB_INSERTS_HPW",      // XXTF - ToBeDone - + ??? address range  
    MercedInstDispersed                 = 0x2d,  //  "INST_DISPERSED",        
    MercedExplicitStops                 = 0x2e,  //  "EXPL_STOPBITS",    
    MercedImplicitStops                 = 0x2f,  //  "IMPL_STOPS_DISPERSED",    
    MercedInstNOPRetired                = 0x30,  //  "NOPS_RETIRED",     
    MercedInstPredicateSquashedRetired  = 0x31,  //  "PREDICATE_SQUASHED_RETIRED", 
    MercedRSELoadRetired                = 0x32,  //  "RSE_LOADS_RETIRED", 
    MercedPipelineFlushes               = 0x33,  //  "PIPELINE_FLUSH",    
    MercedCpuCPLChanges                 = 0x34,  //  "CPU_CPL_CHANGES",   
    MercedFailedSpeculativeCheckLoads   = 0x35,  //  "INST_FAILED_CHKS_RETIRED",   // XXTF - ToBeDone - INST_TYPE
    MercedAdvancedCheckLoads            = 0x36,  //  "ALAT_INST_CHKA_LDC",         // XXTF - ToBeDone - INST_TYPE
    MercedFailedAdvancedCheckLoads      = 0x37,  //  "ALAT_INST_FAILED_CHKA_LDC",  // XXTF - ToBeDone - INST_TYPE
    MercedALATOverflows                 = 0x38,  //  "ALAT_CAPACITY_MISS",         // XXTF - ToBeDone - INST_TYPE
    MercedExternBPMPins03Asserted       = 0x5e,  //  "EXTERN_BPM_PINS_0_TO_3",     
    MercedExternBPMPins45Asserted       = 0x5f,  //  "EXTERN_BPM_PINS_4_TO_5",     
    MercedDataTCMisses                  = 0x60,  //  "DTC_MISSES",            // XXTF - ToBeDone - + ??? address range
    MercedDataTLBMisses                 = 0x61,  //  "DTLB_MISSES",           // XXTF - ToBeDone - + ??? address range
    MercedDataTLBHPWInserts             = 0x62,  //  "DTLB_INSERTS_HPW",      // XXTF - ToBeDone - + ??? address range
    MercedDataReferences                = 0x63,  //  "DATA_REFERENCES_RETIRED", // XXTF - ToBeDone - + ibr, opcode, dbr
    MercedL1DataReads                   = 0x64,  //  "L1D_READS_RETIRED",       // XXTF - ToBeDone - + ibr, opcode, dbr                                       
    MercedRSEAccesses                   = 0x65,  //  "RSE_REFERENCES_RETIRED",     
    MercedL1DataReadMisses              = 0x66,  //  "L1D_READ_MISSES_RETIRED", // XXTF - ToBeDone - + ibr, opcode, dbr   
    MercedL1DataEAREvents               = 0x67,  //  "DATA_EAR_EVENTS",   
    MercedL2References                  = 0x68,  //  "L2_REFERENCES",           // XXTF - ToBeDone - + ibr, opcode, dbr
    MercedL2DataReferences              = 0x69,  //  "L2_DATA_REFERENCES",      // XXTF - ToBeDone - + ibr, opcode, dbr
    MercedL2Misses                      = 0x6a,  //  "L2_MISSES",               // XXTF - ToBeDone - + ibr, opcode, dbr
    MercedL1DataForcedLoadMisses        = 0x6b,  //  "L1D_READ_FORCED_MISSES_RETIRED", // XXTF - ToBeDone - + ibr, opcode, dbr
    MercedRetiredLoads                  = 0x6c,  //  "LOADS_RETIRED",      
    MercedRetiredStores                 = 0x6d,  //  "STORES_RETIRED",     
    MercedRetiredUncacheableLoads       = 0x6e,  //  "UC_LOADS_RETIRED",   
    MercedRetiredUncacheableStores      = 0x6f,  //  "UC_STORES_RETIRED",  
    MercedRetiredMisalignedLoads        = 0x70,  //  "MISALIGNED_LOADS_RETIRED",       
    MercedRetiredMisalignedStores       = 0x71,  //  "MISALIGNED_STORES_RETIRED",      
    MercedL2Flushes                     = 0x76,  //  "L2_FLUSHES",              // XXTF - ToBeDone - + ibr, opcode, dbr
    MercedL2FlushesDetail               = 0x77,  //  "L2_FLUSH_DETAILS",        // XXTF - ToBeDone - + ibr, opcode, dbr
    MercedL3References                  = 0x7b,  //  "L3_REFERENCES",     
    MercedL3Misses                      = 0x7c,  //  "L3_MISSES",       
    MercedL3Reads                       = 0x7d,  //  "L3_READS",        
    MercedL3Writes                      = 0x7e,  //  "L3_WRITES",       
    MercedL3LinesReplaced               = 0x7f,  //  "L3_LINES_REPLACED",
//
// 02/08/00 - Are missing: [at least]
//      - Front-Side bus events,
//      - IVE events,
//      - Debug monitor events,
//      - ...
//
} MERCED_MONITOR_EVENT;

//
// Merced Derived Events:
//
// Assumption: MercedDerivedEventMinimum > MercedMonitoredEventMaximum.
//

typedef enum _MERCED_DERIVED_EVENT {
    MercedDerivedEventMinimum           = 0x100, /* > Maximum of Merced Monitored Event */
    MercedRSEStallCycles                = MercedDerivedEventMinimum, // XXTF - ToBeDone - (MercedMemoryStallCycles    - MercedDataStallAccessCycles)
    MercedIssueLimitStallCycles,        // XXTF - ToBeDone - (MercedExecStallCycles      - MercedExecLatencyStallCycles)
    MercedTakenBranchStallCycles,       // XXTF - ToBeDone - (MercedBranchStallCycles    - MercedBranchMispredictStallCycles)
    MercedFetchWindowStallCycles,       // XXTF - ToBeDone - (MercedInstFetchStallCycles - MercedInstAccessStallCycles)
    MercedIA64InstPerCycle,             // XXTF - ToBeDone - (IA64_INST_RETIRED.u        / CPU_CYCLES[IA64])
    MercedIA32InstPerCycle,             // XXTF - ToBeDone - (IA32_INSTR_RETIRED         / CPU_CYCLES[IA32])
    MercedAvgIA64InstPerTransition,     // XXTF - ToBeDone - (IA64_INST_RETIRED.u        / (ISA_TRANSITIONS * 2))
    MercedAvgIA32InstPerTransition,     // XXTF - ToBeDone - (IA32_INSTR_RETIRED         / (ISA_TRANSITIONS * 2))
    MercedAvgIA64CyclesPerTransition,   // XXTF - ToBeDone - (CPU_CYCLES[IA64]           / (ISA_TRANSITIONS * 2))
    MercedAvgIA32CyclesPerTransition,   // XXTF - ToBeDone - (CPU_CYCLES[IA32]           / (ISA_TRANSITIONS * 2))
    MercedL1InstReferences,             // XXTF - ToBeDone - (L1I_READS                  / L1I_IPREFETCHES) 
    MercedL1InstMissRatio,              // XXTF - ToBeDone - (L1I_MISSES                 / MercedL1InstReferences)
    MercedL1DataReadMissRatio,          // XXTF - ToBeDone - (L1D_READS_MISSES_RETIRED   / L1D_READS_RETIRED)
    MercedL2MissRatio,                  // XXTF - ToBeDone - (L2_MISSES                  / L2_REFERENCES)     
    MercedL2DataMissRatio,              // XXTF - ToBeDone - (L3_DATA_REFERENCES         / L2_DATA_REFERENCES)
    MercedL2InstMissRatio,              // XXTF - ToBeDone - (L3_DATA_REFERENCES         / L2_DATA_REFERENCES)
    MercedL2DataReadMissRatio,          // XXTF - ToBeDone - (L3_LOAD_REFERENCES.u       / L2_DATA_READS.u)     
    MercedL2DataWriteMissRatio,         // XXTF - ToBeDone - (L3_STORE_REFERENCES.u      / L2_DATA_WRITES.u)    
    MercedL2InstFetchRatio,             // XXTF - ToBeDone - (L1I_MISSES                 / L2_REFERENCES) 
    MercedL2DataRatio,                  // XXTF - ToBeDone - (L2_DATA_REFERENCES         / L2_REFERENCES) 
    MercedL3MissRatio,                  // XXTF - ToBeDone - (L3_MISSES                  / L2_MISSES)     
    MercedL3DataMissRatio,              // XXTF - ToBeDone - ((L3_LOAD_MISSES.u + L3_STORE_MISSES.u) / L3_REFERENCES.d)     
    MercedL3InstMissRatio,              // XXTF - ToBeDone - (L3_INST_MISSES.u           / L3_INST_REFERENCES.u)     
    MercedL3DataReadMissRatio,          // XXTF - ToBeDone - (L3_LOAD_REFERENCES.u       / L3_DATA_REFERENCES.d)     
    MercedL3DataRatio,                  // XXTF - ToBeDone - (L3_DATA_REFERENCES.d       / L3_REFERENCES)     
    MercedInstReferences,               // XXTF - ToBeDone - (L1I_READS)                                  
    MercedInstTLBMissRatio,             // XXTF - ToBeDone - (ITLB_MISSES_FETCH          / L1I_READS)     
    MercedDataTLBMissRatio,             // XXTF - ToBeDone - (DTLB_MISSES                / DATA_REFERENCES_RETIRED)
    MercedDataTCMissRatio,              // XXTF - ToBeDone - (DTC_MISSES                 / DATA_REFERENCES_RETIRED)
    MercedInstTLBEAREvents,             // XXTF - ToBeDone - (INSTRUCTION_EAR_EVENTS)
    MercedDataTLBEAREvents,             // XXTF - ToBeDone - (DATA_EAR_EVENTS)
    MercedCodeDebugRegisterMatches,     // XXTF - ToBeDone - (IA64_TAGGED_INSTRS_RETIRED)
    MercedDataDebugRegisterMatches,     // XXTF - ToBeDone - (LOADS_RETIRED              + STORES_RETIRED)
    MercedControlSpeculationMissRatio,  // XXTF - ToBeDone - (INST_FAILED_CHKS_RETIRED   / IA64_TAGGED_INSTRS_RETIRED[chk.s])
    MercedDataSpeculationMissRatio,     // XXTF - ToBeDone - (ALAT_INST_FAILED_CHKA_LDC  / ALAT_INST_CHKA_LDC)
    MercedALATCapacityMissRatio,        // XXTF - ToBeDone - (ALAT_CAPACITY_MISS         / IA64_TAGGED_INSTRS_RETIRED[ld.sa,ld.a,ldfp.a,ldfp.sa])
    MercedL1DataWayMispredicts,         // XXTF - ToBeDone - (EventCode: 0x33 / Umask: 0x2)
    MercedL2InstReferences,             // XXTF - ToBeDone - (L1I_MISSES                 + L2_INST_PREFETCHES)
    MercedInstFetches,                  // XXTF - ToBeDone - (L1I_MISSES)
    MercedL2DataReads,                  // XXTF - ToBeDone - (L2_DATA_REFERENCES/0x1)
    MercedL2DataWrites,                 // XXTF - ToBeDone - (L2_DATA_REFERENCES/0x2)
    MercedL3InstReferences,             // XXTF - ToBeDone - (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    MercedL3InstMisses,                 // XXTF - ToBeDone - (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    MercedL3InstHits,                   // XXTF - ToBeDone - (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    MercedL3DataReferences,             // XXTF - ToBeDone - (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    MercedL3LoadReferences,             // XXTF - ToBeDone - (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    MercedL3LoadMisses,                 // XXTF - ToBeDone - (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    MercedL3LoadHits,                   // XXTF - ToBeDone - (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    MercedL3ReadReferences,             // XXTF - ToBeDone - (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    MercedL3ReadMisses,                 // XXTF - ToBeDone - (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    MercedL3ReadHits,                   // XXTF - ToBeDone - (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    MercedL3StoreReferences,            // XXTF - ToBeDone - (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    MercedL3StoreMisses,                // XXTF - ToBeDone - (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    MercedL3StoreHits,                  // XXTF - ToBeDone - (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    MercedL2WriteBackReferences,        // XXTF - ToBeDone - (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    MercedL2WriteBackMisses,            // XXTF - ToBeDone - (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    MercedL2WriteBackHits,              // XXTF - ToBeDone - (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    MercedL2WriteReferences,            // XXTF - ToBeDone - (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    MercedL2WriteMisses,                // XXTF - ToBeDone - (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    MercedL2WriteHits,                  // XXTF - ToBeDone - (PMC.umask{17:16}HIT/MISS/ALL + PMC.umask{19:18}) 
    MercedBranchInstructions,           // XXTF - ToBeDone - (TAGGED_INSTR + opcode)
    MercedIntegerInstructions,          // XXTF - ToBeDone - (TAGGED_INSTR + opcode)
    MercedL1DataMisses,                 // XXTF - ToBeDone - 
} MERCED_DERIVED_EVENT;

typedef enum _KPROFILE_MERCED_SOURCE {
//
// Profile Merced Monitored Events:
//
    ProfileMercedMonitoredEventMinimum       = ProfileMaximum + 0x1,
	ProfileMercedBranchMispredictStallCycles = ProfileMercedMonitoredEventMinimum,
	ProfileMercedInstAccessStallCycles,
	ProfileMercedExecLatencyStallCycles,
	ProfileMercedDataAccessStallCycles,
	ProfileMercedBranchStallCycles,
	ProfileMercedInstFetchStallCycles,
	ProfileMercedExecStallCycles,
	ProfileMercedMemoryStallCycles,
	ProfileMercedTaggedInstRetired,
	ProfileMercedInstRetired,
	ProfileMercedFPOperationsRetired,
	ProfileMercedFPFlushesToZero,
	ProfileMercedSIRFlushes,
	ProfileMercedBranchTakenDetail,
	ProfileMercedBranchMultiWayDetail,
	ProfileMercedBranchPathPrediction,
	ProfileMercedBranchMispredictDetail,
	ProfileMercedBranchEvents,
	ProfileMercedCpuCycles,
	ProfileMercedISATransitions,
	ProfileMercedIA32InstRetired,
	ProfileMercedL1InstReads,
	ProfileMercedL1InstFills,
	ProfileMercedL1InstMisses,
	ProfileMercedInstEAREvents,
	ProfileMercedL1InstPrefetches,
	ProfileMercedL2InstPrefetches,
	ProfileMercedInstStreamingBufferLinesIn,
	ProfileMercedInstTLBDemandFetchMisses,
	ProfileMercedInstTLBHPWInserts,
	ProfileMercedInstDispersed,
	ProfileMercedExplicitStops,
	ProfileMercedImplicitStops,
	ProfileMercedInstNOPRetired,
	ProfileMercedInstPredicateSquashedRetired,
	ProfileMercedRSELoadRetired,
	ProfileMercedPipelineFlushes,
	ProfileMercedCpuCPLChanges,
	ProfileMercedFailedSpeculativeCheckLoads,
	ProfileMercedAdvancedCheckLoads,
	ProfileMercedFailedAdvancedCheckLoads,
	ProfileMercedALATOverflows,
	ProfileMercedExternBPMPins03Asserted,
	ProfileMercedExternBPMPins45Asserted,
	ProfileMercedDataTCMisses,
	ProfileMercedDataTLBMisses,
	ProfileMercedDataTLBHPWInserts,
	ProfileMercedDataReferences,
	ProfileMercedL1DataReads,
	ProfileMercedRSEAccesses,
	ProfileMercedL1DataReadMisses,
	ProfileMercedL1DataEAREvents,
	ProfileMercedL2References,
	ProfileMercedL2DataReferences,
	ProfileMercedL2Misses,
	ProfileMercedL1DataForcedLoadMisses,
	ProfileMercedRetiredLoads,
	ProfileMercedRetiredStores,
	ProfileMercedRetiredUncacheableLoads,
	ProfileMercedRetiredUncacheableStores,
	ProfileMercedRetiredMisalignedLoads,
	ProfileMercedRetiredMisalignedStores,
	ProfileMercedL2Flushes,
	ProfileMercedL2FlushesDetail,
	ProfileMercedL3References,
	ProfileMercedL3Misses,
	ProfileMercedL3Reads,
	ProfileMercedL3Writes,
	ProfileMercedL3LinesReplaced,
	//
	// 02/08/00 - Are missing: [at least]
	//      - Front-Side bus events,
	//      - IVE events,
	//      - Debug monitor events,
	//      - ...
	//
//
// Profile Merced Derived Events:
//
    ProfileMercedDerivedEventMinimum,
    ProfileMercedRSEStallCycles               = ProfileMercedDerivedEventMinimum,
    ProfileMercedIssueLimitStallCycles,
    ProfileMercedTakenBranchStallCycles,
    ProfileMercedFetchWindowStallCycles,
    ProfileMercedIA64InstPerCycle,
    ProfileMercedIA32InstPerCycle,
    ProfileMercedAvgIA64InstPerTransition,
    ProfileMercedAvgIA32InstPerTransition,
    ProfileMercedAvgIA64CyclesPerTransition,
    ProfileMercedAvgIA32CyclesPerTransition,
    ProfileMercedL1InstReferences,
    ProfileMercedL1InstMissRatio,
    ProfileMercedL1DataReadMissRatio,
    ProfileMercedL2MissRatio,
    ProfileMercedL2DataMissRatio,
    ProfileMercedL2InstMissRatio,
    ProfileMercedL2DataReadMissRatio,
    ProfileMercedL2DataWriteMissRatio,
    ProfileMercedL2InstFetchRatio,
    ProfileMercedL2DataRatio,
    ProfileMercedL3MissRatio,
    ProfileMercedL3DataMissRatio,
    ProfileMercedL3InstMissRatio,
    ProfileMercedL3DataReadMissRatio,
    ProfileMercedL3DataRatio,
    ProfileMercedInstReferences,
    ProfileMercedInstTLBMissRatio,
    ProfileMercedDataTLBMissRatio,
    ProfileMercedDataTCMissRatio,
    ProfileMercedInstTLBEAREvents,
    ProfileMercedDataTLBEAREvents,
    ProfileMercedCodeDebugRegisterMatches,
    ProfileMercedDataDebugRegisterMatches,
    ProfileMercedControlSpeculationMissRatio,
    ProfileMercedDataSpeculationMissRatio,
    ProfileMercedALATCapacityMissRatio,
    ProfileMercedL1DataWayMispredicts,
    ProfileMercedL2InstReferences,
    ProfileMercedInstFetches,
    ProfileMercedL2DataReads,
    ProfileMercedL2DataWrites,
    ProfileMercedL3InstReferences,
    ProfileMercedL3InstMisses,
    ProfileMercedL3InstHits,
    ProfileMercedL3DataReferences,
    ProfileMercedL3LoadReferences,
    ProfileMercedL3LoadMisses,
    ProfileMercedL3LoadHits,
    ProfileMercedL3ReadReferences,
    ProfileMercedL3ReadMisses,
    ProfileMercedL3ReadHits,
    ProfileMercedL3StoreReferences,
    ProfileMercedL3StoreMisses,
    ProfileMercedL3StoreHits,
    ProfileMercedL2WriteBackReferences,
    ProfileMercedL2WriteBackMisses,
    ProfileMercedL2WriteBackHits,
    ProfileMercedL2WriteReferences,
    ProfileMercedL2WriteMisses,
    ProfileMercedL2WriteHits,
    ProfileMercedBranchInstructions,
    ProfileMercedIntegerInstructions,
    ProfileMercedL1DataMisses,
    ProfileMercedMaximum
} KPROFILE_MERCED_SOURCE, *PKPROFILE_MERCED_SOURCE;

#define ProfileIA64Maximum   ProfileMercedMaximum

#endif /* MERCED_H_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\miscs.s ===
//
//
// Module Name:  miscs.s
//
// Description:
//
//    miscellaneous assembly functions used by hal.
//
// Target Platform:
//
//    IA-64
//
// Reuse: None
//
//

#include "regia64.h"
#include "kxia64.h"

//++
// Name: HalpLockedIncrementUlong(Sync)
// 
// Routine Description:
//
//    Atomically increment a variable. 
//
// Arguments:
//
//    Sync:  Synchronization variable
//
// Return Value: NONE
//
//--


        LEAF_ENTRY(HalpLockedIncrementUlong)
        LEAF_SETUP(1,2,0,0)

        ARGPTR(a0)

        ;;
        fetchadd4.acq.nt1    t1 = [a0], 1
        ;;

        LEAF_RETURN
        LEAF_EXIT(HalpLockedIncrementUlong)

//++
// Name: HalpGetReturnAddress()
// 
// Routine Description:
//
//    Returns b0
//
// Arguments:
//
//    NONE
//
// Return Value: b0
//
//--


        LEAF_ENTRY(HalpGetReturnAddress)
        LEAF_SETUP(0,2,0,0)

        mov    v0 = b0
        ;;

        LEAF_RETURN
        LEAF_EXIT(HalpGetReturnAddress)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\oemmca.c ===
//###########################################################################
//**
//**  Copyright  (C) 1996-98 Intel Corporation. All rights reserved.
//**
//** The information and source code contained herein is the exclusive
//** property of Intel Corporation and may not be disclosed, examined
//** or reproduced in whole or in part without explicit written authorization
//** from the company.
//**
//###########################################################################

//-----------------------------------------------------------------------------
// Version control information follows.
//
// $Header:   I:/DEVPVCS/OSMCA/oemmca.c_v   2.1   09 Mar 1999 10:30:24   smariset  $
// $Log:   I:/DEVPVCS/OSMCA/oemmca.c_v  $
// 
//    Rev 2.1   09 Mar 1999 10:30:24   smariset
// *.h consolidation
// 
//    Rev 2.0   Dec 11 1998 11:42:18   khaw
// Post FW 0.5 release sync-up
// 
//   Rev 1.5   29 Oct 1998 14:25:00   smariset
//Consolidated Sources
//
//   Rev 1.4   07 Aug 1998 13:47:50   smariset
// 
//
//   Rev 1.3   10 Jul 1998 11:04:22   smariset
//just checking in
//
//   Rev 1.2   08 Jul 1998 14:23:14   smariset
// 
//
//   Rev 1.1   02 Jul 1998 15:36:32   smariset
// 
//
//   Rev 1.0   02 Jul 1998 09:20:56   smariset
// 
//
///////////////////////////////////////////////////////////////////////////////
//
// Module Name:  OEMMCA.C - Merced OS Machine Check Handler
//
// Description:
//    This module has OEM machine check handler
//
//      Contents:   OemMcaHndlr()          
//                  PlatMcaHndlr()      
//
//
// Target Platform:  Merced
//
// Reuse: None
//
////////////////////////////////////////////////////////////////////////////M//
#include "halp.h"
#include "arc.h"
#include "i64fw.h"
#include "check.h"
#include "osmca.h"
#include "oemmca.h"

fptr  pOsGetErrLog=0;                          // global pointer for OEM MCA entry point

//++
// Name: OemMcaInit()
// 
// Routine Description:
//
//      This routine registers OEM MCA handler initialization
//
// Arguments On Entry:
//              arg0 = Function ID
//
//      Success/Failure (0/!0)
//--
SAL_PAL_RETURN_VALUES 
OemMcaInit(void)
{   
    SAL_PAL_RETURN_VALUES rv={0};

    // register the OS_MCA call back handler 
    rv=HalpOemToOsMcaRegisterProc((fptr)OemMcaDispatch);

    return(rv);
}

//EndProc//////////////////////////////////////////////////////////////////////

//++
// Name: OemMcaDispatch()
// 
// Routine Description:
//
//      This is the OEM call back handler, which is only exported
//      to the OS_MCA for call back during MCA/CMC errors.  This
//      handler will dispatch to the appripriate CMC/MCA proc.
//
// Arguments On Entry:
//              arg0 = Error Event (MchkEvent/CmcEvent)
//
//      Success/Failure (0/!0)
//--
SAL_PAL_RETURN_VALUES 
OemMcaDispatch(ULONGLONG eFlag)
{   
    SAL_PAL_RETURN_VALUES rv={0};

    if(eFlag==MchkEvent)
        rv=OemMcaHndlr();
    else
        rv=OemCmcHndlr();

    return(rv);
}

//EndProc//////////////////////////////////////////////////////////////////////

//++
// Name: OemCmcHndlr()
// 
// Routine Description:
//
//      This is the OsMca CMC Handler, which is called by
//      the CMC interrupt handler in virtual mode
//
// Arguments On Entry:
//              arg0 = Function ID
//
//      Success/Failure (0/!0)
//--
SAL_PAL_RETURN_VALUES 
OemCmcHndlr(void)
{   
    SAL_PAL_RETURN_VALUES rv={0};
    PsiLog myPsiLog;

    if(pOsGetErrLog >0)
    {
        rv=HalpOsGetErrLog(0, CmcEvent, PROC_LOG, (ULONGLONG*)&myPsiLog, sizeof(PsiLog));
        rv=HalpOsGetErrLog(0, CmcEvent, PLAT_LOG, (ULONGLONG*)&myPsiLog, sizeof(PsiLog));
    }

    return(rv);
}

//EndProc//////////////////////////////////////////////////////////////////////

//++
// Name: OemMcaHndlr()
// 
// Routine Description:
//
//      This is the OsMca handler for firmware uncorrected errors
//
// Arguments On Entry:
//              arg0 = Function ID
//
//      Success/Failure: 
//          Error Corrected/Not Corrected (0/!0)
//--
SAL_PAL_RETURN_VALUES 
OemMcaHndlr(void)
{   
    SAL_PAL_RETURN_VALUES rv={0};

    rv=OemProcErrHndlr();
    rv=OemPlatErrHndlr();
    
    return(rv);
}

//EndProc//////////////////////////////////////////////////////////////////////


//++
// Name: OemProcErrHndlr()
// 
// Routine Description:
//
//      This routine reads or writes data to NVM space
//
// Arguments On Entry:
//              arg0 = Function ID
//
//      Success/Failure (0/!0)
//--
SAL_PAL_RETURN_VALUES 
OemProcErrHndlr(void)
{   
    SAL_PAL_RETURN_VALUES rv={0};
    PsiLog myPsiLog;

    // first let us get the error log
    if(pOsGetErrLog >0)
    {
        rv=HalpOsGetErrLog(0, MchkEvent, PROC_LOG, (ULONGLONG*)&myPsiLog, sizeof(PsiLog));
    }

    return(rv);
}

//EndProc//////////////////////////////////////////////////////////////////////

//++
// Name: OemPlatErrHndlr()
// 
// Routine Description:
//
//      This routine reads or writes data to NVM space
//
// Arguments On Entry:
//              arg0 = Function ID
//
//      Success/Failure (0/!0)
//--
SAL_PAL_RETURN_VALUES 
OemPlatErrHndlr(void)
{   
    SAL_PAL_RETURN_VALUES rv={0};
    PsiLog myPsiLog;

    // first let us get the error log
    if(pOsGetErrLog >0)
    {
        rv=HalpOsGetErrLog(0, MchkEvent, PLAT_LOG, (ULONGLONG*)&myPsiLog, sizeof(PsiLog));
    }

    return(rv);
}

//EndProc//////////////////////////////////////////////////////////////////////

//++
// Name: OemMcaCb()
// 
// Routine Description:
//
//      The entry point to this procedure is registered with OsMca 
//      fw interface for call back to return the call back address of OS proc.
//
// Arguments On Entry:
//              arg0 = OS MCA call back handler entry point
//
//      Success/Failure (0/!0)
//--
SAL_PAL_RETURN_VALUES 
OemMcaCb(fptr pOsHndlr)
{   
    SAL_PAL_RETURN_VALUES rv={0};
    
    pOsGetErrLog=pOsHndlr;

    return(rv);
}

//EndProc//////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\osinitchk.s ===
//###########################################################################
//**
//**  Copyright  (C) 1996-2000 Intel Corporation. All rights reserved.
//**
//** The information and source code contained herein is the exclusive
//** property of Intel Corporation and may not be disclosed, examined
//** or reproduced in whole or in part without explicit written authorization
//** from the company.
//**
//###########################################################################

//-----------------------------------------------------------------------------
// Version control information follows.
//
// $Header:   I:/DEVPVCS/OSMCA/osmchk.s_v   2.1   05 Mar 1999 12:59:42   smariset  $
// $Log:   I:/DEVPVCS/OSMCA/osmchk.s_v  $
//
//   Rev 2.0   Dec 11 1998 11:42:18   khaw
//Post FW 0.5 release sync-up
//
//   Rev 1.4   12 Oct 1998 14:05:20   smariset
//gp fix up work around
//
///////////////////////////////////////////////////////////////////////////////
//
// Module Name:  OSINITCHK.S - Merced OS INIT Handler Dispatcher
//
// Description:
//    TEMPTEMP CHANGE THE DOC.
//    Merced OS INIT event handler Stub to OSINIT "C" frame work.  If
//    we find a TLB related error, we cannot switch to virtual mode in
//    the OS.  All TLB related errors will need system reboot after 
//    storing the errors to a persistence storage media (HD or Flash).
//
//      HalpOsInitDispatch               - Main
//
// Target Platform:  Merced
//
// Reuse: None
//
////////////////////////////////////////////////////////////////////////////M//

#include "ksia64.h"
#include "fwglobal.h"

        GLOBAL_FUNCTION(HalpOsInitDispatch)
        GLOBAL_FUNCTION(HalpInitHandler)
        GLOBAL_FUNCTION(HalpMcaHandler)

        .text
//++
// Name: HalpOsInitDispatch()
// 
// Routine Description:
//
//      This is the OS Init call back handler, which is only exported
//      to the SAL for call back during MCA errors.  This
//      handler will dispatch to the appripriate Init. proc. This
//      proc will be called in physical mode.
//
//      Sets up virtual->physical address translation
//      0x00100000->0x00100000 in dtr1/itr1 for OS_INIT. 
//      
// Arguments:
//
//      None
//
// On entry:
//      This function is called:
//          - in physical mode for uncorrected or correctable MCA events,
//          - RSE enforced in lazy mode,
//          - Processor resources:
//      PSR.dt = 0, PSR.it = 0, PSR.rt = 0 - Physical mode.
//      PSR.ic = 0, PSR.i  = 0             - Interrupt resources collection and interrupt disabled.
//      PSR.mc = 1                         - Machine Checks masked
//      PSR.mfl = 0                        - low fp disabled.
//      GR1  : OS_MCA Global Pointer (GP) registered by OS: OS's GP.
//      GR2-7: Unspecified.
//      GR8  : Physical address of the PAL_PROC entrypoint.
//      GR9  : Physical address of the SAL_PROC entrypoint.
//      GR10 : Physical address value of the SAL Global Pointer: SAL's GP.
//      GR11 : Rendezvous state information, defined as:
//                0 - Rendezvous of other processors was not required by 
//                    PAL_CHECK and as such was not done.
//                1 - All other processors in the system were successfully 
//                    rendezvous using MC_RENDEZVOUS interrupt.
//                2 - All other processors in the system were successfully
//                    rendezvous using a combination of MC_RENDEZVOUS 
//                    interrupt and INIT.
//               -1 - Rendezvous of other processors was required by PAL 
//                    but was unsuccessful.
//      GR12 : Return address to a location within SAL_CHECK.
//      GR17 : Pointer to processor minimum state saved memory location.
//      GR18 : Processor state as defined below:
//          D0-D5:          Reserved
//          D6-D31:         As defined in PAL EAS
//          D60-D63:        As defined in PAL EAS
//          D32-D47:        Size in bytes of processor dynamic state
//          D48-D59:        Reserved.
//      GR19 : Return address to a location within PAL_CHECK. 
//      BR0  : Unspecified.
//
// Return State:
//
//      Note  : The OS_MCA procedure may or may not return to SAL_CHECK
//              in the case of uncorrected machine checks.
//              If it returns to SAL, the runtime convention requires that
//              it sets appropriate values in the Min-State area pointed
//              to by GR12 for continuing execution at the interrupted
//              context or at a new context.
//              Furthermore, the OS_MCA procedure must restore the 
//              processor state to the same state as on entry except as:
//      GR1-7  : Unspecified.
//      GR8    : Return status
//                0 [= SAL_STATUS_SUCCESS] - Error has been corrected 
//                    by OS_MCA.
//               -1 - Error has not been corrected by OS_MCA and
//                    SAL must warm boot the system.
//               -2 - Error has not been corrected by OS_MCA and 
//                    SAL must cold boot the system.
//               -3 - Error has not been corrected by OS_MCA and 
//                    SAL must halt the system.
//      GR9    : Physical address value for SAL's GP.
//      GR10   : Context flag
//                0 - Return will be to the same context.
//                1 - Return will be to a   new  context.
//      GR11-21: Unspecified.
//      GR22   : Pointer to a structure containing new values of registers 
//               in the Min-State Save area. 
//               OS_MCA must supply this parameter even if it does not 
//               change the register values in the Min-State Save areas.
//      GR23-31: Unspecified.
//      BR0    : Unspecified.
//      PSR.mc : May be either 0 or 1.
//--

       .proc   HalpOsInitDispatch;
HalpOsInitDispatch::
   
       .prologue
       .unwabi     @nt,  EXCEPTION_FRAME

      // aliases for known registers:
      
      rPalProcEntryPoint     = r8
      rSalProcEntryPoint     = r9
      rSalGlobalPointer      = r10
      rRendezVousResult      = r11
      rSalReturnAddress      = r12
      rProcMinStateSavePtr   = r17
      rProcStateParameter    = r18
      rPalCheckReturnAddress = r19
      rEventResources        = t22
      rPcrPhysicalAddress    = t6 
      
    //
    // Use pt1, pt2 to inidcate if this is a INIT or MCA event.
    //
    
    cmp.ne pt1, pt2 = r0, r0
    br.sptk HalpOsCommonDispatch
    ;;

ALTERNATE_ENTRY(HalpOsMcaDispatch1)
          
     cmp.eq pt1, pt2 = r0, r0

HalpOsCommonDispatch::

    //
    // - Flag the processor as "InOsInit":
    //   KiPcr.InOsInit = 1
    //
    // - Update KiPcr.InitPTOM to point to TopOfMemory, 
    //   Memory after Processor Minimum State Save area. 
    //
    // - Update processor InitSalToOsHandOff
    // 
    // - Update local rPcrInitStateDump before calling osInitProcStateDump.  
    //
    
      mov    rEventResources = PcOsMcaResourcePtr      
      movl   t21 = KiPcr
      ;;
      tpa    rPcrPhysicalAddress = t21           //  Calculate physical address of PCR
      mov    t19  = SerSalToOsHandOff
      mov    t1  = 0x1
      ;;
      add    t0 = rPcrPhysicalAddress, rEventResources      
      sub    t21 = rPcrPhysicalAddress, t21               
      add    t16  = TOM, rProcMinStateSavePtr
      ;;
(pt1) ld8    rEventResources = [t0], PcInOsInit-PcOsMcaResourcePtr
      ;;
(pt2) ld8    rEventResources = [t0], PcInOsMca-PcOsMcaResourcePtr
      mov    t18  = SerPTOM
      add    t20  = 0x8,  t19
      ;;        
      xchg1  t1  = [t0], t1
      add    rEventResources = rEventResources, t21          // Calculate the physical address of the OsMcaResources
      add    t21  = 0x10, t19
      ;;                    
      add    t18  = rEventResources, t18
      add    t19  = rEventResources, t19
      add    t20  = rEventResources, t20
      add    t21  = rEventResources, t21
      ;;
      ld8    t17  = [t16]
      st8    [t19] = rPalProcEntryPoint,  0x18
      add    t0 = SerStateDumpPhysical, rEventResources
      ;;
      st8    [t18] = t17
      st8    [t20] = rSalProcEntryPoint,  0x18
      st8    [t21] = rSalGlobalPointer,   0x18
      ;;
      st8    [t19] = rRendezVousResult
      st8    [t20] = rSalReturnAddress
      st8    [t21] = rProcMinStateSavePtr
      ld8    t0 = [t0]                                  // InitStateDump
      ;;

    
    //
    // Save in preserved registers:
    //     - pointer to processor minimum state save area, 
    //     - processor state parameter
    //     - PAL_CHECK return address.
    //   s0 [=r4] <- r17, 
    //   s1 [=r5] <- r18,
    //   s2 [=r6] <- r19
    //

        SaveRs(rProcMinStateSavePtr, rProcStateParameter, rPalCheckReturnAddress)
   
        br.dpnt     osInitProcStateDump
        ;;

osInitDoneDump:
        //
        // If we have a TLB error, we cannot enable translation
        //
        tbit.nz.unc pt0,p0=s1, 60  // PSP.tc=60
(pt0)   br.dpnt     iResetNow
        ;;                

    //
    // Initialize current sp and ar.bsp and ar.bspstore
    //
    //    KiPcr.InitStackFrame[0] = ar.rsc
    //    KiPcr.InitStackFrame[1] = ar.pfs
    //    KiPcr.InitStackFrame[2] = ar.ifs
    //    KiPcr.InitStackFrame[3] = ar.bspstore
    //    KiPcr.InitStackFrame[4] = ar.rnat
    //    ar.bspstore = t0 [=KiPcr.InitBspStore]
    //    KiPcr.InitStackFrame[5] = ar.bsp - KiPcr.InitBspStore 
    //      [BUGBUG ?? : should be ar.bsptore=KiPcr.InitStackFrame[3]] 
    //    sp = KiPcr.InitStack
    // 
    
      movl   t21 = KiPcr + PcOsMcaResourcePtr
      ;;
      tpa    t0 = t21           //  Calculate physical address of PCR OsInitResourcePtr
      mov    t1 = SerStateDumpPhysical
      ;;
      sub    t16 = SerBackStore, t21      
      sub    t1 = t1, t21
      ;;
      add    t16 = t0, t16   
      add    t1 = t0, t1   
      ld8    rEventResources = [t0], PcInitialBStore - PcOsMcaResourcePtr
      ;;        
      add    t16 = rEventResources, t16   // Calculate physical address of the new BSP
      mov    t21 = t0                    // t21 now points to InitialBStore in the PCR
      ;;
      add    t1 = rEventResources, t1   // Calculate the physical address of State Dump physical pointer
      ld8    t3 = [t16], SerStack - SerBackStore // t3 contains the initial BSP.
      ;;
      ld8    t7 = [t1]                  // t7 now contain the physical address of the state dump area
      ;;                                // and the physical top of stack
      st8    [t21] = t3, PcInitialStack - PcInitialBStore  // Save the InitialBStore in the PCR
      ld8    t1 = [t16], SerBackStoreLimit - SerStack      // Get inital Init stack
      ;;
      st8    [t21] = t1, PcBStoreLimit - PcInitialStack
      ld8    t0 = [t16], SerStackLimit - SerBackStoreLimit
      ;;
      add    t1 = -STACK_SCRATCH_AREA-ThreadStateSaveAreaLength-TrapFrameLength-PalMiniSaveLength, t1
      add    t7 = -STACK_SCRATCH_AREA-ThreadStateSaveAreaLength-TrapFrameLength-PalMiniSaveLength, t7     
      st8    [t21] = t0, PcStackLimit - PcBStoreLimit     // Save BStore limit
      ld8    t18 = [t16]
      ;;
      mov    sp = t1
      st8    [t21] = t18, PcCurrentIrql - PcStackLimit
      ;;
      ld1    t1 = [t21]

//
// Copy the PAL Mini-save area to the stack. It must be accessed non-cached.
// t7 contains the physical address for the trap frame.
// r4 contains the minium save area physical address.
//

      mov    t16 = ar.lc                                // Save lc
      mov    t0 = PalMiniSaveLength/8
      ;;
      add    t21 = ThreadStateSaveAreaLength+TrapFrameLength, t7        // Calculate stack physical address 
                                                                        // of PAL mini save area is saved.
      dep    t17 = 1, r4, 63, 1                 // Non-cached address of PAL mini save area
      mov    ar.lc = t0
      ;;

iCopyMini:
      ld8    t0 = [t17],8
      ;;
      st8    [t21] = t0,8
      br.ctop.sptk.few  iCopyMini
      ;;
      mov    ar.lc = t16                        // Restore lc
      mov    ar.rsc = r0                        // put RSE in lazy mode and use kernel mode stores.
      ;;  
    
//
// Generate a excpetion trap frame.
// t7 contains the physical address for the trap frame.
// t3 contains the initial BSP
//
     add     t17=TrOldIrql, t7
     add     t21 = ThreadStateSaveAreaLength+TrapFrameLength+PmsRsRSC, t7    // Calculate stack physical address 
     cover                                                                   // of PAL mini save area of RSE.
     ;;
     st1     [t17] = t1, TrEOFMarker - TrOldIrql
     movl    t0 = KTRAP_FRAME_EOF | EXCEPTION_FRAME
     ;;
     st8     [t17] = t0
     mov     t1 = ar.bspstore   
     ;;
     mov     t0 = ar.bsp
     ld8     t18 = [t21],PmsStIIP - PmsRsRSC    
     add     t17 = TrRsBSP - TrEOFMarker, t17
     ;;
     dep     t3 = t1, t3, 0, 9                          // Adjust new BSPSTORE for NATs
     st8     [t17] = t0,TrRsBSPSTORE - TrRsBSP      
     ;;
     sub     t0 = t0, t1
     st8     [t17] = t1, TrRsRSC - TrRsBSPSTORE         // Save old BspStore
     ;;
     dep     t18 = t0, t18, RSC_MBZ1, RSC_LOADRS_LEN
     mov     ar.bspstore = t3
     ld8     t1 = [t21], PmsStIPSR - PmsStIIP               // Copy IIP to trap frame as IIP
     ;;
     st8     [t17] = t18, TrStIIP - TrRsRSC
     ld8     t0 = [t21], PmsStIFS - PmsStIPSR               // Copy IPSR to trap frame as IPSR
     ;;
     st8     [t17] = t1, TrStIPSR - TrStIIP
     ;;
     st8     [t17] = t0, TrStIFS - TrStIPSR
     ld8     t1 = [t21], PmsBrRp - PmsStIFS               // Copy IFS to trap frame as IFS
     ;;
     st8     [t17] = t1, TrBrRp - TrStIFS
     ld8     t0 = [t21], PmsPreds - PmsBrRp
     ;;
     st8     [t17] = t0, TrStISR - TrBrRp
     mov     t1 = cr.isr
     ;;
     st8     [t17] = t1, TrRsPFS - TrStISR                      
     mov     t0 = ar.pfs
     ;;
     st8     [t17] = t0, TrStIIPA - TrRsPFS
     mov     t1 = cr.iipa
     ;;
     st8     [t17] = t1, TrStIIM - TrStIIPA
     mov     t0 = cr.iim
     ;;
     st8     [t17] = t0, TrStIHA - TrStIIM
     mov     t1 = cr.iha
     ;;
     st8     [t17] = t0, TrStFPSR - TrStIHA
     mov     t0 = ar.fpsr
     ;;
     st8     [t17] = t0 
     ld8     t1 = [t21]
     ;;            
     add     t17 = TrPreds - TrStFPSR, t17
     add     t21 = PmsIntGp - PmsPreds, t21
     ;;
     st8     [t17] = t1, TrApUNAT - TrPreds
     mov     t0 = ar.unat
     ;;
     st8     [t17] = t0, TrIntGp - TrApUNAT
     ld8     t1 = [t21], PmsIntSp - PmsIntGp
     ;;
     st8     [t17] = t1, TrIntSp - TrIntGp
     ld8     t0 = [t21], PmsIntTeb - PmsIntSp
     ;;
     st8     [t17] = t0, TrIntTeb - TrIntSp
     ld8     t1 = [t21], PmsIntT0 - PmsIntTeb
     ;;
     st8     [t17] = t1, TrRsRNAT - TrIntTeb
     mov     t0 = ar.rnat
     ;;
     st8     [t17] = t0, TrBrT0 - TrRsRNAT
     mov     t1 = bt0
     ;;
     st8     [t17] = t1, TrBrT1 - TrBrT0
     mov     t0 = bt1
     ;;
     st8     [t17] = t0, TrApCCV-TrBrT1
     mov     t1 = ar.ccv
     ;;
     st8     [t17] = t1, TrApDCR - TrApCCV
     mov     t0 = cr.dcr
     ;;
     st8     [t17] = t0, TrIntT0 - TrApDCR 
     ld8     t1 = [t21], PmsIntT1 - PmsIntT0
     ;;
     st8     [t17] = t1, TrIntT1 - TrIntT0
     ld8     t0 = [t21], PmsIntV0 - PmsIntT1
     ;;
     st8     [t17] = t0, TrIntV0 - TrIntT1
     mov     t16 = ar.lc
     mov     t1 = 7
     ;;
     mov     ar.lc = t1
     ;;
iRegCopy1:
     ld8     t0 = [t21], 8
     ;;
     st8     [t17] = t0, 8
     br.ctop.sptk.few iRegCopy1     
     ;;
     mov     t1 = 15
     add     t21 = PmsIntT7 - PmsB0R16, t21       // Skip over the bank 0 registers.
     ;;
     mov     ar.lc = t1
     ;;
iRegCopy2:
     ld8     t0 = [t21], 8
     ;;
     st8     [t17] = t0, 8
     br.ctop.sptk.few iRegCopy2     
     ;;
     mov     ar.lc = t16
     
iEnableTranslation:

// let us switch to virtual mode
//
//      Need to do a "rfi" in order set "it" and "ed" bits in the PSR.
//
//      Make sure interrupts are disabled and that we are running on bank 1.
//
        rsm       1 << PSR_I
        bsw.1
        ;;

//
// psr mask prepration, warning we will have a problem with PMI here
//

        movl    t0 = MASK_IA64(PSR_BN,1) | MASK_IA64(PSR_IC,1) |MASK_IA64(PSR_DA,1) | MASK_IA64(PSR_IT,1) | MASK_IA64(PSR_RT,1) | MASK_IA64(PSR_DT,1) | MASK_IA64(PSR_MC,1);;
        mov     t1=psr;;
        or      t0=t0,t1
        movl    t1=iVirtualSwitchDone;;
        mov     cr.iip=t1;;
        movl    t1 = FPSR_FOR_KERNEL      /* initial fpsr value     */;\
        mov     cr.ipsr = t0;;
        mov     ar.fpsr = t1;;
        rfi
        ;;

iVirtualSwitchDone:
// done with enabling address translation

//
//      Set up arguments to the handler.
//

        alloc   t1 = 0, 0, 2, 0
        mov     r32 =  r11
        add     r33 = ThreadStateSaveAreaLength+TrapFrameLength, sp
     
// call our handler
(pt1)   movl        t0=HalpMcaHandler;;
(pt2)   movl        t0=HalpInitHandler;;
        mov         b6=t0;;
        br.call.dpnt b0=b6
        ;;

// psr mask prepration
        rsm     MASK_IA64(PSR_IC,1);;
        movl    t0 = MASK_IA64(PSR_DA,1) | MASK_IA64(PSR_IT,1) | MASK_IA64(PSR_RT,1) | MASK_IA64(PSR_DT,1);;
        movl    t1=0xffffffffffffffff;;
        xor     t0=t0,t1;;
        mov     t1=psr;;
        and     t0=t0,t1
        movl    t1=BeginOsInitRestore;;
        tpa     t1=t1;;
        mov     cr.iip=t1;;
        mov     cr.ipsr = t0;;
        rfi
        ;;

BeginOsInitRestore:
// restore the original stack frame here
        mov    t16 = SerStackFrame
        movl   t21 = KiPcr + PcOsMcaResourcePtr
        ;;
        tpa    t1 = t21           //  Calculate physical address of PCR OsInitResourcePtr
        sub    t16 = t16, t21
        sub    t0 = SerStateDumpPhysical, t21
        ;;
        ld8    rEventResources = [t1]
        add    t16 = t1, t16
        add    t0 = t1, t0
        ;;        
        add    t16 = rEventResources, t16   // Calculate the physical address of the Stack Frame   
        add    t0 = rEventResources, t0   // Calculate the physical address of the State Dump pointer.
        ;;
        ld8    t0 = [t0];
        movl   t7 = PSRmcMask
        ;;
        RtnIntCxt( t7, t1, t16 )  // switch from interrupt context -> RSC mgmt.
        ;;

        //
        // let us restore all the registers from our PSI structure
        //
        
        mov     t6 = gp
        br.dpnt osInitProcStateRestore
        ;;

osInitDoneRestore:

        // Pal requires DFH of 0
        rsm         1 << PSR_DFH
        ;;
        rsm         1 << PSR_MFL  // just restoring to original state only
        ;;
        srlz.d
        ;;

     //
     // - Restore processor state from OsToSalHandOff. 
     //   
     // - Branch back to SALE_CHECK. 
     
      mov    t1 = PcOsMcaResourcePtr      
      movl   t21 = KiPcr
      ;;
      tpa    rPcrPhysicalAddress = t21           //  Calculate physical address of PCR
      ;;
      add    t0 = rPcrPhysicalAddress, t1      
      sub    t21 = SerOsToSalHandOff, t21               
      ;;
      ld8    t1 = [t0], PcInOsInit-PcOsMcaResourcePtr
      add    t21 = t21, rPcrPhysicalAddress
      ;;        
      add    t1 = t1, t21          // Calculate the physical address of the OsInitResources->SalToOSHandOff
      ;;
      add    t16  = 0x8,  t1
      add    t17  = 0x10, t1
      ;;
      ld8    r8  = [t1], 0x18      // result of error handling
      ld8    r9  = [t16], 0x18      // physical SAL's GP value
      ld8    t22 = [t17]            // new Processor Min-State Save Ptr
      ;;
      ld8    t1 = [t1]         // SAL return address
      ld8    r10    = [t16]         // New Context Switch Flag
      xchg1  t0 = [t0], r0     // KiPcr.InOsInit = 0
      ;;
      mov     b0 = t1
      br.dpnt b0                       // Return to SALE_CHECK
      ;;

      .endp HalpOsInitDispatch
        
iStayInPhysicalMode::
// we have to reboot the machine, assume the log is already there in NVM
// OS can read the log next time when it comes around.  Or OS can try to
// run in physical mode as well.

iResetNow:
//      do EFI system reset here...
//      Go to BugCheck (in physical mode). 
//      Out to Port 80: Fatal TLB error
//

iThyself:        
        br          iThyself                     // loop for safety      
        ;;


//EndMain//////////////////////////////////////////////////////////////////////


//++
// Name:
//      osInitProcStateDump()
// 
// Stub Description:
//
//       This stub dumps the processor state during MCHK to a data area
//
// On Entry:
//
//       t0 = rPcrInitStateDump.
//
// Return Value:
//
//       None.
//
//--

osInitProcStateDump:
// TF: ASSERT( t0 == rPcrInitStateDump )

//save BRs
        add         t2=Inc8,t0                  // duplicate t0 in t2
        add         t7=2*Inc8,t0                // duplicate t0 in t2

        mov         t1=b0
        mov         t3=b1
        mov         t5=b2;;
        st8         [t0]=t1,3*Inc8
        st8         [t2]=t3,3*Inc8
        st8         [t7]=t5,3*Inc8;;  

        mov         t1=b3
        mov         t3=b4
        mov         t5=b5;;
        st8         [t0]=t1,3*Inc8
        st8         [t2]=t3,3*Inc8
        st8         [t7]=t5,3*Inc8;;  

        mov         t1=b6
        mov         t3=b7;;
        st8         [t0]=t1,2*Inc8
        st8         [t2]=t3,2*Inc8;;

icSaveCRs:
// save CRs
        add         t2=Inc8,t0                  // duplicate t0 in t2
        add         t7=2*Inc8,t0                // duplicate t0 in t2

        mov         t1=cr0                      // cr.dcr
        mov         t3=cr1                      // cr.itm
        mov         t5=cr2;;                    // cr.iva

        st8         [t0]=t1,8*Inc8
        st8         [t2]=t3,3*Inc8
        st8         [t7]=t5,3*Inc8;;            // 48 byte increments

        mov         t1=cr8;;                    // cr.pta
        st8         [t0]=t1,Inc8*8;;            // 64 byte increments

// Reading interruption registers when PSR.ic=1 causes an illegal operation fault
        mov         t1=psr;;
        tbit.nz.unc pt0,p0=t1,PSRic;;           // PSI Valid Log bit pos. test
(pt0)   st8         [t0]=r0,9*8+160             // increment by 168 byte inc.
(pt0)   br.dpnt     iSkipIntrRegs
        ;;

        add         t2=Inc8,t0                  // duplicate t0 in t2
        add         t7=2*Inc8,t0                // duplicate t0 in t7
        
        mov         t1=cr16                     // cr.ipsr
        mov         t3=cr17                     // cr.isr
        mov         t5=r0;;                     // cr.ida => cr18
        st8         [t0]=t1,3*Inc8
        st8         [t2]=t3,3*Inc8
        st8         [t7]=t5,3*Inc8;;                                      

        mov         t1=cr19                     // cr.iip
        mov         t3=cr20                     // cr.ifa  
        mov         t5=cr21;;                   // cr.iitr
        st8         [t0]=t1,3*Inc8
        st8         [t2]=t3,3*Inc8
        st8         [t7]=t5,3*Inc8;;                                      

        mov         t1=cr22                     // cr.iipa
        mov         t3=cr23                     // cr.ifs
        mov         t5=cr24;;                   // cr.iim
        st8         [t0]=t1,3*Inc8
        st8         [t2]=t3,3*Inc8
        st8         [t7]=t5,3*Inc8;;    
                                          
        mov         t1=cr25;;                   // cr.iha
        st8         [t0]=t1,160;;               // 160 byte increment

iSkipIntrRegs:
        st8         [t0]=r0,168                 // another 168 byte inc.

        mov         t1=cr66;;                   // cr.lid
        st8         [t0]=t1,40                  // 40 byte increment

        mov         t1=cr71;;                   // cr.ivr
        st8         [t0]=t1,Inc8

        mov         t1=cr72;;                   // cr.tpr
        st8         [t0]=t1,24                  // 24 byte increment
    
        mov         t1=r0;;                     // cr.eoi => cr75
        st8         [t0]=t1,168                 // 168 byte inc.
    
        mov         t1=r0;;                     // cr.irr0 => cr96
        st8         [t0]=t1,Inc16               // 16 byte inc.

        mov         t1=r0;;                     // cr.irr1 => cr98
        st8         [t0]=t1,Inc16               // 16 byte inc.

        mov         t1=r0;;                     // cr.irr2 => cr100
        st8         [t0]=t1,Inc16               // 16 byte inc

        mov         t1=r0;;                     // cr.irt1 => cr100
        st8         [t0]=t1,Inc16               // 16b inc.

        mov         t1=r0;;                     // cr.itv => cr114
        st8         [t0]=t1,Inc16               // 16 byte inc.

        mov         t1=r0;;                     // cr.pmv => cr116
        st8         [t0]=t1,Inc8

        mov         t1=r0;;                     // cr.lrr0 => cr117
        st8         [t0]=t1,Inc8

        mov         t1=r0;;                     // cr.lrr1 => cr118
        st8         [t0]=t1,Inc8

        mov         t1=r0;;                     // cr.cmcv => cr119
        st8         [t0]=t1,Inc8*10;;

icSaveARs:
// save ARs
        add         t2=Inc8,t0                  // duplicate t0 in t2
        add         t7=2*Inc8,t0                // duplicate t0 in t7

        mov         t1=ar0                      // ar.kr0
        mov         t3=ar1                      // ar.kr1
        mov         t5=ar2;;                    // ar.kr2
        st8         [t0]=t1,3*Inc8
        st8         [t2]=t3,3*Inc8
        st8         [t7]=t5,3*Inc8;;

        mov         t1=ar3                      // ar.kr3                               
        mov         t3=ar4                      // ar.kr4
        mov         t5=ar5;;                    // ar.kr5
        st8         [t0]=t1,3*Inc8
        st8         [t2]=t3,3*Inc8
        st8         [t7]=t5,3*Inc8;;

        mov         t1=ar6                      // ar.kr6
        mov         t3=ar7                      // ar.kr7
        mov         t5=r0;;                     // ar.kr8
        st8         [t0]=t1,10*Inc8
        st8         [t2]=t3,10*Inc8
        st8         [t7]=t5,10*Inc8;;           // increment by 72 bytes

        mov         t1=ar16                     // ar.rsc
        mov         t3=ar17                     // ar.bsp
        mov         t5=ar18;;                   // ar.bspstore
        st8         [t0]=t1,3*Inc8
        st8         [t2]=t3,3*Inc8
        st8         [t7]=t5,3*Inc8;;

        mov         t1=ar19;;                   // ar.rnat
        st8         [t0]=t1,Inc8*13             // increment by 13x8 bytes

        mov         t1=ar32;;                   // ar.ccv
        st8         [t0]=t1,Inc8*4

        mov         t1=ar36;;                   // ar.unat
        st8         [t0]=t1,Inc8*4

        mov         t1=ar40;;                   // ar.fpsr
        st8         [t0]=t1,Inc8*4

        mov         t1=ar44;;                   // ar.itc
        st8         [t0]=t1,160                 // 160

        mov         t1=ar64;;                   // ar.pfs
        st8         [t0]=t1,Inc8

        mov         t1=ar65;;                   // ar.lc
        st8         [t0]=t1,Inc8

        mov         t1=ar66;;                   // ar.ec
        st8         [t0]=t1
        adds        t0=Inc8*62,t0               //padding
    
// save RRs
        mov         ar.lc=0x08-1
        movl        t2=0x00;;

icStRR:
        mov         t1=rr[t2];;
        st8         [t0]=t1,Inc8
        add         t2=1,t2
        br.cloop.dpnt icStRR
        ;;

// align memory addresses to 16 bytes
        and         t1=0x0f,t0;;
        cmp.ne.unc  pt0,p0=t1,r0;;
(pt0)   add         t0=Inc8,t0

icSaveFRs:
// just save FP for INIT restore only, "C" code will trash f6-f15
// save ar.NaT 
        mov         t3=ar.unat;;                 // ar.unat

        stf.spill   [t0]=f6,Inc16;;
        stf.spill   [t0]=f7,Inc16;;
        stf.spill   [t0]=f8,Inc16;;
        stf.spill   [t0]=f9,Inc16;;
        stf.spill   [t0]=f10,Inc16;;
        stf.spill   [t0]=f11,Inc16;;
        stf.spill   [t0]=f12,Inc16;;
        stf.spill   [t0]=f13,Inc16;;
        stf.spill   [t0]=f14,Inc16;;
        stf.spill   [t0]=f15,Inc16;;

        mov         t2=ar.unat;;
        st8         [t0]=t2,Inc8                // save User NaT bits for r16-t11
        mov         ar.unat=t3                  // restore original unat

        br.dpnt     osInitDoneDump
        ;;

//EndStub//////////////////////////////////////////////////////////////////////


//++
// Name:
//       osInitProcStateRestore()
// 
// Stub Description:
//
//       This is a stub to restore the saved processor state during MCHK
//
// On Entry:
//
//       t0 = rPcrInitStateDump.
//
// Return Value:
//
//       None.
//--

osInitProcStateRestore:

// TF: ASSERT( t0 == rPcrInitStateDump )

// Restore bank1 GR16-31 

irestore_BRs:
        add         t2=Inc8,t0                  // duplicate t0 in t2
        add         t7=2*Inc8,t0;;              // duplicate t0 in t2

        ld8         t1=[t0],3*Inc8
        ld8         t3=[t2],3*Inc8
        ld8         t5=[t7],3*Inc8;;  
        mov         b0=t1
        mov         b1=t3
        mov         b2=t5;;

        ld8         t1=[t0],3*Inc8
        ld8         t3=[t2],3*Inc8
        ld8         t5=[t7],3*Inc8;;  
        mov         b3=t1
        mov         b4=t3
        mov         b5=t5;;

        ld8         t1=[t0],2*Inc8
        ld8         t3=[t2],2*Inc8;;  
        mov         b6=t1
        mov         b7=t3;;

irestore_CRs:
        add         t2=Inc8,t0                  // duplicate t0 in t2
        add         t7=2*Inc8,t0;;              // duplicate t0 in t2

        ld8         t1=[t0],8*Inc8
        ld8         t3=[t2],3*Inc8
        ld8         t5=[t7],3*Inc8;;            // 48 byte increments
        mov         cr0=t1                      // cr.dcr
        mov         cr1=t3                      // cr.itm
        mov         cr2=t5;;                    // cr.iva

        ld8         t1=[t0],8*Inc8;;            // 64 byte increments
//      mov         cr8=t1                      // cr.pta


// if PSR.ic=1, reading interruption registers causes an illegal operation fault
        mov         t1=psr;;
        tbit.nz.unc pt0,p0=t1,PSRic;;           // PSI Valid Log bit pos. test
(pt0)   st8         [t0]=r0,9*8+160             // increment by 160 byte inc.
(pt0)   br.dpnt     irSkipIntrRegs
        ;;

        add         t2=Inc8,t0                  // duplicate t0 in t2
        add         t7=2*Inc8,t0;;              // duplicate t0 in t2

        ld8         t1=[t0],3*Inc8
        ld8         t3=[t2],3*Inc8
        ld8         t5=[t7],3*Inc8;;
        mov         cr16=t1                     // cr.ipsr
        mov         cr17=t3                     // cr.isr is read only
//      mov         cr18=t5;;                   // cr.ida

        ld8         t1=[t0],3*Inc8
        ld8         t3=[t2],3*Inc8
        ld8         t5=[t7],3*Inc8;;
        mov         cr19=t1                     // cr.iip
        mov         cr20=t3                     // cr.idtr
        mov         cr21=t5;;                   // cr.iitr

        ld8         t1=[t0],3*Inc8
        ld8         t3=[t2],3*Inc8
        ld8         t5=[t7],3*Inc8;;
        mov         cr22=t1                     // cr.iipa
        mov         cr23=t3                     // cr.ifs
        mov         cr24=t5                     // cr.iim

        ld8         t1=[t0],160;;               // 160 byte increment
        mov         cr25=t1                     // cr.iha 

irSkipIntrRegs:
        ld8         t1=[t0],168;;               // another 168 byte inc.

        ld8         t1=[t0],40;;                // 40 byte increment
        mov         cr66=t1                     // cr.lid

        ld8         t1=[t0],Inc8;;
//      mov         cr71=t1                     // cr.ivr is read only
        ld8         t1=[t0],24;;                // 24 byte increment
        mov         cr72=t1                     // cr.tpr
   
        ld8         t1=[t0],168;;               // 168 byte inc.
//      mov         cr75=t1                     // cr.eoi
   
        ld8         t1=[t0],Inc16;;             // 16 byte inc.
//      mov         cr96=t1                     // cr.irr0 is read only

        ld8         t1=[t0],Inc16;;             // 16 byte inc.
//      mov         cr98=t1                     // cr.irr1 is read only

        ld8         t1=[t0],Inc16;;             // 16 byte inc
//      mov         cr100=t1                    // cr.irr2 is read only

        ld8         t1=[t0],Inc16;;             // 16b inc.
//      mov         cr102=t1                    // cr.irt1 is read only

        ld8         t1=[t0],Inc16;;             // 16 byte inc.
//      mov         cr114=t1                    // cr.itv

        ld8         t1=[t0],Inc8;;
//      mov         cr116=t1                    // cr.pmv
        ld8         t1=[t0],Inc8;;
//      mov         cr117=t1                    // cr.lrr0
        ld8         t1=[t0],Inc8;;
//      mov         cr118=t1                    // cr.lrr1
        ld8         t1=[t0],Inc8*10;;
//      mov         cr119=t1                    // cr.cmcv

irestore_ARs:
        add         t2=Inc8,t0                  // duplicate t0 in t2
        add         t7=2*Inc8,t0;;              // duplicate t0 in t2

        ld8         t1=[t0],3*Inc8
        ld8         t3=[t2],3*Inc8
        ld8         t5=[t7],3*Inc8;;
        mov         ar0=t1                      // ar.kro
        mov         ar1=t3                      // ar.kr1
        mov         ar2=t5;;                    // ar.kr2

        ld8         t1=[t0],3*Inc8
        ld8         t3=[t2],3*Inc8
        ld8         t5=[t7],3*Inc8;;
        mov         ar3=t1                      // ar.kr3                               
        mov         ar4=t3                      // ar.kr4
        mov         ar5=t5;;                    // ar.kr5

        ld8         t1=[t0],10*Inc8
        ld8         t3=[t2],10*Inc8
        ld8         t5=[t7],10*Inc8;;
        mov         ar6=t1                      // ar.kr6
        mov         ar7=t3                      // ar.kr7
//      mov         ar8=t7                      // ar.kr8
        ;;

        ld8         t1=[t0],3*Inc8
        ld8         t3=[t2],3*Inc8
        ld8         t5=[t7],3*Inc8;;
//      mov         ar16=t1                     // ar.rsc
//      mov         ar17=t3                     // ar.bsp is read only
        mov         ar18=t5;;                   // ar.bspstore

        ld8         t1=[t0],Inc8*13;;
        mov         ar19=t1                     // ar.rnat

        ld8         t1=[t0],Inc8*4;;
        mov         ar32=t1                     // ar.ccv

        ld8         t1=[t0],Inc8*4;;
        mov         ar36=t1                     // ar.unat

        ld8         t1=[t0],Inc8*4;;
        mov         ar40=t1                     // ar.fpsr

        ld8         t1=[t0],160;;               // 160
//      mov         ar44=t1                     // ar.itc

        ld8         t1=[t0],Inc8;;
        mov         ar64=t1                     // ar.pfs

        ld8         t1=[t0],Inc8;;
        mov         ar65=t1                     // ar.lc

        ld8         t1=[t0];;
        mov         ar66=t1                     // ar.ec
        adds        t0=Inc8*62,t0;;             // padding 
    
irestore_RRs:
        mov         t3=ar.lc
        mov         ar.lc=0x08-1
        movl        t2=0x00
icStRRr:
        ld8         t1=[t0],Inc8;;
//      mov         rr[t2]=t1                   // what are its access previledges?
        add         t2=1,t2
        br.cloop.dpnt icStRRr
        ;;
        mov         ar.lc=t3

// align memory addresses to 16 bytes
        and         t1=0x0f,t0;;
        cmp.ne.unc  pt0,p0=t1,r0;;
(pt0)   add         t0=Inc8,t0;;

// restore FP's which might be trashed by the "C" code
        mov         t3=ar.unat
        add         t1=16*10,t0;;                // to get to NaT of GR 16-31
        ld8         t1=[t1];;
        mov         ar.unat=t1;;                // first restore NaT

irestore_FRs:
        ldf.fill    f6=[t0],Inc16;;
        ldf.fill    f7=[t0],Inc16;;
        ldf.fill    f8=[t0],Inc16;;
        ldf.fill    f9=[t0],Inc16;;
        ldf.fill    f10=[t0],Inc16;;
        ldf.fill    f11=[t0],Inc16;;
        ldf.fill    f12=[t0],Inc16;;
        ldf.fill    f13=[t0],Inc16;;
        ldf.fill    f14=[t0],Inc16;;
        ldf.fill    f15=[t0],Inc16;;

        mov         ar.unat=t3                  // restore original NaT

        br.dpnt     osInitDoneRestore
        ;;

//EndStub//////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\pcip.h ===
//
// Include code from halx86
// This is a cpp style symbolic link

// #define SUBCLASSPCI 1

#include "..\..\halx86\i386\pcip.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\oemmca.h ===
//###########################################################################
//**
//**  Copyright  (C) 1996-98 Intel Corporation. All rights reserved.
//**
//** The information and source code contained herein is the exclusive
//** property of Intel Corporation and may not be disclosed, examined
//** or reproduced in whole or in part without explicit written authorization
//** from the company.
//**
//###########################################################################

//-----------------------------------------------------------------------------
// Version control information follows.
//
// $Header:   I:/DEVPVCS/OSMCA/oemmca.h_v   2.0   Dec 11 1998 11:42:18   khaw  $
// $Log:   I:/DEVPVCS/OSMCA/oemmca.h_v  $
// 
//    Rev 2.0   Dec 11 1998 11:42:18   khaw
// Post FW 0.5 release sync-up
// 
//   Rev 1.3   07 Aug 1998 13:47:50   smariset
// 
//
//   Rev 1.2   10 Jul 1998 11:04:22   smariset
//just checking in
//
//   Rev 1.1   08 Jul 1998 14:23:14   smariset
// 
//
//   Rev 1.0   02 Jul 1998 09:20:56   smariset
// 
//
//
//*****************************************************************************//

// function prototypes
typedef (*fptr)(void);
SAL_PAL_RETURN_VALUES OemMcaInit(void);
SAL_PAL_RETURN_VALUES OemMcaDispatch(ULONGLONG);
SAL_PAL_RETURN_VALUES OemCmcHndlr(void);     
SAL_PAL_RETURN_VALUES OemMcaHndlr(void);
SAL_PAL_RETURN_VALUES OemProcErrHndlr(void);
SAL_PAL_RETURN_VALUES OemPlatErrHndlr(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\osmca.c ===
//**  Copyright  (C) 1996-2000 Intel Corporation. All rights reserved.
//**
//** The information and source code contained herein is the exclusive
//** property of Intel Corporation and may not be disclosed, examined
//** or reproduced in whole or in part without explicit written authorization
//** from the company.
//**
//###########################################################################

//-----------------------------------------------------------------------------
// Version control information follows.
//
//
//             10 Jun 1999  Bugcheck  Bernard Lint
//                                    M. Jayakumar (Muthurajan.Jayakumar@intel.com)
//                                    Thierry Fevrier
///////////////////////////////////////////////////////////////////////////////
//
// Module Name:  OSMCA.C - Merced OS Machine Check Handler
//
// Description:
//    This module has OS Machine Check Handler Reference Code.
//
//      Contents:   HalpOsMcaInit()
//                  HalpCmcHandler()
//                  HalpMcaHandler()
//                  HalpMcRzHandlr()
//                  HalpMcWkupHandlr()
//                  HalpProcMcaHndlr()
//                  HalpPlatMcaHndlr()
//
//
// Target Platform:  Merced
//
// Reuse: None
//
////////////////////////////////////////////////////////////////////////////M//
#include "halp.h"
#include "nthal.h"
#include "arc.h"
#include "i64fw.h"
#include "check.h"
#include "iosapic.h"
#include "inbv.h"
#include "osmca.h"

// pmdata.c: CPE definitions.
extern ULONG             HalpMaxCPEImplemented;
extern ULONG             HalpCPEIntIn[];

// i64fw.c: HAL Private Data structure for SAL/PAL
extern HALP_SAL_PAL_DATA HalpSalPalData;

// i64fwasm.s: low-level protection data structures
extern KSPIN_LOCK        HalpMcaSpinLock;
extern KSPIN_LOCK        HalpCmcSpinLock;
extern KSPIN_LOCK        HalpCpeSpinLock;

//
// IA64 MCE Info structures to keep track of MCE features
// available on installed hardware.
//

HALP_MCA_INFO       HalpMcaInfo;
HALP_CMC_INFO       HalpCmcInfo;
HALP_CPE_INFO       HalpCpeInfo;
KERNEL_MCE_DELIVERY HalpMceKernelDelivery;
volatile ULONG      HalpOsMcaInProgress = 0;

//
// SAL_MC_SET_PARAMS.time_out
//

ULONGLONG HalpMcRendezTimeOut = HALP_DEFAULT_MC_RENDEZ_TIMEOUT;

//
// HalpProcessorMcaRecords:
//
// Number of MCA records pre-allocated per processor.
//

ULONGLONG HalpProcessorMcaRecords = HALP_DEFAULT_PROCESSOR_MCA_RECORDS;

//
// HalpProcessorInitRecords:
//
// Number of INIT records pre-allocated per processor.
//

ULONGLONG HalpProcessorInitRecords = HALP_DEFAULT_PROCESSOR_INIT_RECORDS;

//
// HalpMceLogsMaxCount:
//
// Maximum number of saved logs.
//

ULONG HalpMceLogsMaxCount = HALP_MCELOGS_MAXCOUNT;

//
// HAL Private Error Device GUIDs:
// [useful for kdexts]
//

ERROR_DEVICE_GUID HalpErrorProcessorGuid              = ERROR_PROCESSOR_GUID;
ERROR_DEVICE_GUID HalpErrorMemoryGuid                 = ERROR_MEMORY_GUID;
ERROR_DEVICE_GUID HalpErrorPciBusGuid                 = ERROR_PCI_BUS_GUID;
ERROR_DEVICE_GUID HalpErrorPciComponentGuid           = ERROR_PCI_COMPONENT_GUID;
ERROR_DEVICE_GUID HalpErrorSystemEventLogGuid         = ERROR_SYSTEM_EVENT_LOG_GUID;
ERROR_DEVICE_GUID HalpErrorSmbiosGuid                 = ERROR_SMBIOS_GUID;
ERROR_DEVICE_GUID HalpErrorPlatformSpecificGuid       = ERROR_PLATFORM_SPECIFIC_GUID;
ERROR_DEVICE_GUID HalpErrorPlatformBusGuid            = ERROR_PLATFORM_BUS_GUID;
ERROR_DEVICE_GUID HalpErrorPlatformHostControllerGuid = ERROR_PLATFORM_HOST_CONTROLLER_GUID;

//
// HAL Private Error Definitions:
// [useful for kdexts]
// Actually in this case, the typed pointers allow also the inclusion of the symbols definitions
// without the data structures sizes.
//

PERROR_MODINFO                  HalpPErrorModInfo;
PERROR_PROCESSOR_CPUID_INFO     HalpPErrorProcessorCpuIdInfo;
PERROR_PROCESSOR                HalpPErrorProcessor;
PERROR_PROCESSOR_STATIC_INFO    HalpPErrorProcessorStaticInfo;
PERROR_MEMORY                   HalpPErrorMemory;
PERROR_PCI_BUS                  HalpPErrorPciBus;
PERROR_PCI_COMPONENT            HalpPErrorPciComponent;
PERROR_SYSTEM_EVENT_LOG         HalpPErrorSystemEventLog;
PERROR_SMBIOS                   HalpPErrorSmbios;
PERROR_PLATFORM_SPECIFIC        HalpPErrorPlatformSpecific;
PERROR_PLATFORM_BUS             HalpPErrorPlatformBus;
PERROR_PLATFORM_HOST_CONTROLLER HalpPErrorPlatformHostController;

//
// MCA/CMC/CPE state catchers
//

ERROR_SEVERITY
HalpMcaProcessLog(
    PMCA_EXCEPTION  McaLog
    );

BOOLEAN
HalpPreAllocateMceTypeRecords(
    ULONG EventType,
    ULONG Number
    );

VOID
HalpMcaBugCheck(
    ULONG          McaBugCheckType,
    PMCA_EXCEPTION McaLog,
    ULONGLONG      McaAllocatedLogSize,
    ULONGLONG      Arg4
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,   HalpInitializeOSMCA)
#pragma alloc_text(INIT,   HalpAllocateMceStacks)
#pragma alloc_text(INIT,   HalpPreAllocateMceRecords)
#pragma alloc_text(INIT,   HalpPreAllocateMceTypeRecords)
#pragma alloc_text(PAGELK, HalpMcaHandler)
#pragma alloc_text(PAGELK, HalpMcaProcessLog)
#pragma alloc_text(PAGELK, HalpMcaBugCheck)
#pragma alloc_text(PAGELK, HalpGetErrLog)
#pragma alloc_text(PAGELK, HalpClrErrLog)
#pragma alloc_text(PAGE,   HalpGetMceInformation)
#endif // ALLOC_PRAGMA


BOOLEAN
HalpSaveEventLog(
    PSINGLE_LIST_ENTRY   HeadList,
    PERROR_RECORD_HEADER RecordHeader,
    ULONG                Tag,
    POOL_TYPE            PoolType,
    PKSPIN_LOCK          SpinLock
    )
{
    PSINGLE_LIST_ENTRY   entry, previousEntry;
    SIZE_T               logSize;
    PERROR_RECORD_HEADER savedLog;
    KIRQL                oldIrql;

    //
    // Allocate and Initialize the new entry
    //

    logSize = RecordHeader->Length;
    if ( !logSize ) {
        HalDebugPrint(( HAL_ERROR, "HAL!HalpSaveEventLog: record length is zeroed.\n" ));
        return FALSE;
    }
    entry = (PSINGLE_LIST_ENTRY)ExAllocatePoolWithTag( PoolType, sizeof(*entry) + logSize, Tag );
    if ( entry == NULL )   {
        HalDebugPrint(( HAL_ERROR, "HAL!HalpSaveEventLog: Event log allocation failed.\n" ));
        return FALSE;
    }
    entry->Next = NULL;
    savedLog = (PERROR_RECORD_HEADER)((ULONG_PTR)entry + sizeof(*entry));
    RtlCopyMemory( savedLog, RecordHeader, logSize );

    //
    // Insert the new entry with protection.
    //

    KeRaiseIrql( HIGH_LEVEL, &oldIrql );
    KiAcquireSpinLock( SpinLock );

    previousEntry = HeadList;
    while( previousEntry->Next != NULL )   {
        previousEntry = previousEntry->Next;
    }
    previousEntry->Next = entry;

    KiReleaseSpinLock( SpinLock );
    KeLowerIrql( oldIrql );

    return TRUE;

} // HalpSaveEventLog()

#define HalpSaveCorrectedMcaLog( _McaLog ) \
   HalpSaveEventLog( &HalpMcaInfo.CorrectedLogs, (PERROR_RECORD_HEADER)(_McaLog), 'CacM', NonPagedPool, &HalpMcaSpinLock )

NTSTATUS
HalpCheckForMcaLogs(
    VOID
    )
/*++
    Routine Description:
        This routine checks the FW early during boot if a MCA event log is present.
        The log is considered as "previous".

        This routine is called at phase 1 on BSP and APs, from HalpPreAllocateMceRecords().
        it is executed on the standard kernel stacks.

    Arguments:
        None

    Return Value:
        STATUS_NO_MEMORY if mca log allocation failed.
        STATUS_SUCCESS   otherwise, regardless of FW interfaces failures.
--*/

{
    NTSTATUS             status;
    PERROR_RECORD_HEADER log;

    log = ExAllocatePoolWithTag( NonPagedPool, HalpMcaInfo.Stats.MaxLogSize, 'PacM' );
    if ( !log ) {
        return( STATUS_NO_MEMORY );
    }

    status = HalpGetFwMceLog( MCA_EVENT, log, &HalpMcaInfo.Stats, HALP_FWMCE_DONOT_CLEAR_LOG );
    if ( status != STATUS_NOT_FOUND )   {
        //
        // Successful log collection or invalid record or unsuccessful FW Interface calls
        // are considered as a trigger for the MCA log consumers to collect them from the FW.
        //

        InterlockedIncrement( &HalpMcaInfo.Stats.McaPreviousCount );
    }

    ExFreePoolWithTag( log, 'PacM' );
    return( STATUS_SUCCESS );

} // HalpCheckForMcaLogs()

BOOLEAN
HalpPreAllocateMceTypeRecords(
    ULONG EventType,
    ULONG Number
    )
{
    SAL_PAL_RETURN_VALUES rv = {0};
    ULONGLONG             defaultEventRecords;
    PVOID                 log;
    SIZE_T                logSize;
    PHYSICAL_ADDRESS      physicalAddr;

    if ( (EventType != MCA_EVENT) && (EventType != INIT_EVENT) )    {
        ASSERTMSG( "HAL!HalpPreAllocateMceTypeRecords: unknown event type!\n", FALSE );
        return FALSE;
    }

    //
    // On BSP only, call SAL to get maximum size of EventType record
    //

    if ( Number == 0 )  {
        rv = HalpGetStateInfoSize( EventType );
        if ( !SAL_SUCCESSFUL(rv) )  {
            HalDebugPrint(( HAL_ERROR, "HAL!HalpPreAllocateMceTypeRecords: SAL_GET_STATE_INFO_SIZE failed...\n" ));
            return FALSE;
        }
        logSize = rv.ReturnValues[1];
    }

    if ( EventType == MCA_EVENT )   {

        if ( Number == 0 )  {
            // Update HalpMcaInfo, without protection. This is not required.
            HalpMcaInfo.Stats.MaxLogSize = (ULONG)logSize;
        }
        else  {
            logSize = (SIZE_T)HalpMcaInfo.Stats.MaxLogSize;
        }

       defaultEventRecords = HalpProcessorMcaRecords;

    }
    else {
        ASSERTMSG( "HAL!HalpPreAllocateMceTypeRecords: invalid event type!\n", EventType == INIT_EVENT );

        if ( Number == 0 )  {
            // Update HalpInitInfo, without protection. This is not required.
            HalpInitInfo.MaxLogSize = (ULONG)logSize;
        }
        else  {
            logSize = (SIZE_T)HalpInitInfo.MaxLogSize;
        }

       defaultEventRecords = HalpProcessorInitRecords;

    }

    // Determine size of allocation
    logSize = ROUND_TO_PAGES( (logSize * defaultEventRecords) );

    //
    // Allocate Event Records buffer
    //

    physicalAddr.QuadPart = 0xffffffffffffffffI64;
    log = MmAllocateContiguousMemory( logSize, physicalAddr );
    if ( log == NULL )  {
        HalDebugPrint(( HAL_ERROR, "HAL!HalpPreAllocateMceTypeRecords: SAL %s Event Records allocation failed (0x%Ix)...\n",
                                   ( EventType == MCA_EVENT ) ? "MCA" : "INIT",
                                   logSize ));
        return FALSE;
    }

    //
    // Update KPCR entry.
    //
    {
       volatile KPCR * const pcr = KeGetPcr();
       PSAL_EVENT_RESOURCES eventResources;

       if ( EventType == MCA_EVENT )	{
           eventResources = pcr->OsMcaResourcePtr;
       }

       eventResources->EventPool     = log;
       eventResources->EventPoolSize = (ULONG) logSize;

    }

    return TRUE;

} // HalpPreAllocateMceTypeRecords()

BOOLEAN
HalpPreAllocateMceRecords(
    IN ULONG Number
    )
{
    NTSTATUS status;

    //
    // Pre-Allocate MCA records
    //

    if ( !HalpPreAllocateMceTypeRecords( MCA_EVENT , Number ) )   {
        return FALSE;
    }

    //
    // Check for MCA logs.
    // These might be logs related to previous boot sessions.
    //

    status = HalpCheckForMcaLogs();
    if ( !NT_SUCCESS( status ) )  {
        return FALSE;
    }

    return TRUE;

} // HalpPreAllocateMceRecords()

BOOLEAN
HalpAllocateMceStacks(
    IN ULONG Number
    )
{
    PHYSICAL_ADDRESS physicalAddr;
    PVOID            mem;
    PVOID            mcaStateDump, mcaBackStore, mcaStack;
    ULONGLONG        mcaStateDumpPhysical;
    ULONGLONG        mcaBackStoreLimit, mcaStackLimit;
    ULONG            length;

    //
    // Allocate MCA/INIT stacks
    //

    length = HALP_MCA_STATEDUMP_SIZE + HALP_MCA_BACKSTORE_SIZE + HALP_MCA_STACK_SIZE;
    physicalAddr.QuadPart = 0xffffffffffffffffI64;
    mem = MmAllocateContiguousMemory( length, physicalAddr );
    if ( mem == NULL )  {
        HalDebugPrint(( HAL_ERROR, "HAL!HalpAllocateMceStacks: MCA State Dump allocation failed (0x%Ix)...\n",
                                   length ));
        return FALSE;
    }

    //
    // The layout in memory by increasing addresses is:
    //
    //   Bottom of stack
    //          .
    //          .
    //          .
    //   Initial Stack
    //   State Dump Area
    //          .
    //          .
    //   Initial BSP
    //          .
    //          .
    //          .
    //   BSP Limit
    //

    mcaStack = mem;
    mcaStackLimit = (ULONGLONG)mem + HALP_MCA_STACK_SIZE;

    mem = (PCHAR) mem + HALP_MCA_STACK_SIZE;
    mcaStateDump = mem;
    mcaStateDumpPhysical = MmGetPhysicalAddress(mem).QuadPart;


    mem = (PCHAR) mem + HALP_MCA_STATEDUMP_SIZE;
    mcaBackStore = mem;
    mcaBackStoreLimit = (ULONGLONG)mem + (ULONGLONG)(ULONG)HALP_MCA_BACKSTORE_SIZE;


    //
    // Update PCR MCA, INIT stacks
    //

    {
        volatile KPCR * const pcr = KeGetPcr();
        PSAL_EVENT_RESOURCES eventResources;

        eventResources = pcr->OsMcaResourcePtr;

        eventResources->StateDump = mcaStateDump;
        eventResources->StateDumpPhysical = mcaStateDumpPhysical;
        eventResources->BackStore = mcaBackStore;
        eventResources->BackStoreLimit = mcaBackStoreLimit;
        eventResources->Stack = (PCHAR) mcaStackLimit;
        eventResources->StackLimit = (ULONGLONG) mcaStack;

    }

    return TRUE;

} // HalpPreAllocateMceRecords()

//++
// Name: HalpInitializeOSMCA()
//
// Routine Description:
//
//      This routine registers MCA init's
//
// Arguments On Entry:
//              arg0 = Function ID
//
//      Success/Failure (0/!0)
//--

BOOLEAN
HalpInitializeOSMCA(
    IN ULONG Number
    )
{
    SAL_PAL_RETURN_VALUES rv = {0};
    ULONGLONG             gp_reg;

    //
    // Register SAL_MC_RendezVous parameters with SAL
    //

    rv = HalpSalSetParams(0, RendzType, IntrVecType, MC_RZ_VECTOR, HalpMcRendezTimeOut);
    if ( !SAL_SUCCESSFUL(rv) )  {
        HalDebugPrint(( HAL_ERROR, "HAL!HalpInitializeOSMCA: SAL_MC_SET_PARAMS.rendezvous vector failed...\n" ));
        return FALSE;
    }

    //
    // Register WakeUp parameters with SAL
    //

    rv = HalpSalSetParams(0, WakeUpType, IntrVecType, MC_WKUP_VECTOR,0);
    if ( !SAL_SUCCESSFUL(rv) )  {
        HalDebugPrint(( HAL_ERROR, "HAL!HalpInitializeOSMCA: SAL_MC_SET_PARAMS.wakeup vector failed...\n" ));
        return FALSE;
    }

    //
    // Allocate MCA, INIT stacks
    //

    if ( !HalpAllocateMceStacks( Number ) )   {
        return FALSE;
    }

    //
    // Pre-Allocate desired number of MCA,INIT records
    //

    HalpMcaInfo.KernelToken = (PVOID)(ULONG_PTR)HALP_KERNEL_TOKEN;
    if ( !HalpPreAllocateMceRecords( Number ) )   {
        return FALSE;
    }

    //
    // Initialize HAL private CMC, CPE structures.
    //

    rv = HalpGetStateInfoSize( CMC_EVENT );
    if ( !SAL_SUCCESSFUL( rv ) )   {
        HalDebugPrint(( HAL_ERROR, "HAL!HalpInitializeOSMCA: SAL_GET_STATE_INFO_SIZE.CMC failed...\n" ));
        return FALSE;
    }
    HalpCmcInfo.Stats.MaxLogSize  = (ULONG)rv.ReturnValues[1];
    HalpCmcInfo.KernelToken = (PVOID)(ULONG_PTR)HALP_KERNEL_TOKEN;
    HalpCmcInfo.KernelLogs.MaxCount = HalpMceLogsMaxCount;
    HalpCmcInfo.DriverLogs.MaxCount = HalpMceLogsMaxCount;
    HalpCmcInfo.Stats.PollingInterval = HAL_CMC_INTERRUPTS_BASED;

    rv = HalpGetStateInfoSize( CPE_EVENT );
    if ( !SAL_SUCCESSFUL( rv ) )   {
        HalDebugPrint(( HAL_ERROR, "HAL!HalpInitializeOSMCA: SAL_GET_STATE_INFO_SIZE.CPE failed...\n" ));
        return FALSE;
    }
    HalpCpeInfo.Stats.MaxLogSize = (ULONG)rv.ReturnValues[1];
    HalpCpeInfo.KernelToken = (PVOID)(ULONG_PTR)HALP_KERNEL_TOKEN;
    HalpCpeInfo.KernelLogs.MaxCount = HalpMceLogsMaxCount;
    HalpCpeInfo.DriverLogs.MaxCount = HalpMceLogsMaxCount;

    //
    // Register OsMcaDispatch (OS_MCA) physical address with SAL
    //

    gp_reg = GetGp();
    rv = HalpSalSetVectors(0, MchkEvent, MmGetPhysicalAddress((fptr)(((PLabel*)HalpOsMcaDispatch1)->fPtr)), gp_reg,0);
    if ( !SAL_SUCCESSFUL(rv) )  {
        HalDebugPrint(( HAL_ERROR, "HAL!HalpInitializeOSMCA: SAL_SET_VECTOR.MCA vector failed...\n" ));
        return FALSE;
    }

    //
    // Register OsInitDispatch physical address with SAL
    //

    rv = HalpSalSetVectors(0, InitEvent, MmGetPhysicalAddress((fptr)(((PLabel*)HalpOsInitDispatch)->fPtr)), gp_reg,0);
    if ( !SAL_SUCCESSFUL(rv) )  {
        HalDebugPrint(( HAL_ERROR, "HAL!HalpInitializeOSMCA: SAL_SET_VECTOR.INIT vector failed...\n" ));
        return FALSE;
    }

    return TRUE;

} // HalpInitializeOSMCA()

//EndProc//////////////////////////////////////////////////////////////////////

VOID
HalpMcaBugCheck(
    ULONG          McaBugCheckType,
    PMCA_EXCEPTION McaLog,
    ULONGLONG      McaAllocatedLogSize,
    ULONGLONG      SalStatus
    )
//++
// Name: HalpMcaBugCheck()
//
// Routine Description:
//
//      This function is called to bugcheck the system in a case of a fatal MCA
//      or fatal FW interface errors. The OS must guarantee as much as possible
//      error containment in this path.
//      With the current implementation, this function should be only called from
//      the OS_MCA path. For other MCA specific wrappers of KeBugCheckEx, one should
//      HalpMcaKeBugCheckEx().
//
// Arguments On Entry:
//      ULONG          McaBugCheckType
//      PMCA_EXCEPTION McaLog
//      ULONGLONG      McaAllocatedLogSize
//      ULONGLONG      SalStatus
//
// Return:
//      None.
//
// Implementation notes:
//      This code CANNOT [as default rules - at least entry and through fatal MCAs handling]
//          - make any system call
//          - attempt to acquire any spinlock used by any code outside the MCA handler
//          - change the interrupt state.
//      Passing data to non-MCA code must be done using manual semaphore instructions.
//      This code should minimize the path and the global or memory allocated data accesses.
//      This code should only access MCA-namespace structures.
//      This code is called under the MP protection of HalpMcaSpinLock and with the flag
//      HalpOsMcaInProgress set.
//
//--
{

    if ( HalpOsMcaInProgress )   {

        //
        // Enable InbvDisplayString calls to make it through to bootvid driver.
        //

        if ( InbvIsBootDriverInstalled() ) {

            InbvAcquireDisplayOwnership();

            InbvResetDisplay();
            InbvSolidColorFill(0,0,639,479,4); // make the screen blue
            InbvSetTextColor(15);
            InbvInstallDisplayStringFilter((INBV_DISPLAY_STRING_FILTER)NULL);
            InbvEnableDisplayString(TRUE);     // enable display string
            InbvSetScrollRegion(0,0,639,479);  // set to use entire screen
        }

        HalDisplayString (MSG_MCA_HARDWARE_ERROR);
        HalDisplayString (MSG_HARDWARE_ERROR2);

//
// Thierry 09/2000:
//
//   - if desired, process the MCA log HERE...
//
//     and use HalDisplayString() to dump info for the field or hardware vendor.
//     The processing could be based on processor or platform independent record definitions.
//

        HalDisplayString( MSG_HALT );

        if ( HalpMcaInfo.NoBugCheck == 0 )  {

           KeBugCheckEx( MACHINE_CHECK_EXCEPTION, (ULONG_PTR)McaBugCheckType,
                                                  (ULONG_PTR)McaLog,
                                                  (ULONG_PTR)McaAllocatedLogSize,
                                                  (ULONG_PTR)SalStatus );
        }

    }

    if ( ((*KdDebuggerNotPresent) == FALSE) && ((*KdDebuggerEnabled) != FALSE) )    {
        KeEnterKernelDebugger();
    }

    while( TRUE ) {
          //
        ; // Simply sit here so the MCA HARDWARE ERROR screen does not get corrupted...
          //
    }

    // noreturn

} // HalpMcaBugCheck()

ERROR_SEVERITY
HalpMcaProcessLog(
    PMCA_EXCEPTION  McaLog
    )
//++
// Name: HalpMcaProcessLog()
//
// Routine Description:
//
//      This function is called to process the MCA event log in the OS_MCA path.
//
// Arguments On Entry:
//      PMCA_EXCEPTION McaLog - Pointer to the MCA event log.
//
// Return:
//      ERROR_SEVERITY
//
// Implementation notes:
//      This code CANNOT [as default rules]
//          - make any system call
//          - attempt to acquire any spinlock used by any code outside the MCA handler
//          - change the interrupt state.
//      Passing data to non-MCA code must be done using manual semaphore instructions.
//      This code should minimize the path and the global or memory allocated data accesses.
//      This code should only access MCA-namespace structures.
//      This code is called under the MP protection of HalpMcaSpinLock and with the flag
//      HalpOsMcaInProgress set.
//
//--
{
    ERROR_SEVERITY mcaSeverity;

    mcaSeverity = McaLog->ErrorSeverity;
    switch( mcaSeverity )    {

        case ErrorFatal:
            break;

        case ErrorRecoverable:
            //
            // Thierry - FIXFIX 08/2000:
            //
            ///////////////////////////////////////////////////////////////
            //
            //  Call to kernel supported recovery will be here....
            //
            ///////////////////////////////////////////////////////////////
            //
            // However, for now we do not recover so flag it as ErrorFatal.
            mcaSeverity = ErrorFatal;
            break;

        case ErrorCorrected:
        default:
            //
            // These ERRROR_SEVERITY values have no HAL MCA specific handling.
            // As specified by the SAL Specs July 2000, we should not get these values in this path.
            //
            break;
    }

    //
    // If OEM driver has registered an exception callback for MCA event,
    // call it here and save returned error severity value.
    //

    if ( HalpMcaInfo.DriverInfo.ExceptionCallback ) {
        mcaSeverity = HalpMcaInfo.DriverInfo.ExceptionCallback(
                                     HalpMcaInfo.DriverInfo.DeviceContext,
                                     McaLog );
    }

    //
    // Save corrected log for future kernel notification.
    //

    if ( (HalpMcaInfo.KernelDelivery) && (mcaSeverity == ErrorCorrected) ) {
        InterlockedIncrement( &HalpMcaInfo.Stats.McaCorrectedCount );
#if 0
//
// Thierry - 09/16/2000: ToBeDone.
//  Saving the corrected MCA log records requires careful rendez-vous configuration
//  handling, possible OS_MCA monarch selection, MCA logs (pre-)allocations and
//  special locking in case a consumer accesses the logs queue on another processor.
//
//  The kernel-WMI and/or OEM MCA driver notification is done in HalpMcaHandler().
//
        if ( !HalpSaveCorrectedMcaLog( McaLog ) )   {
            InterlockedIncrement( &HalpMcaInfo.CorrectedLogsLost );
        }
#endif // 0

        //
        //  The kernel-WMI and/or OEM MCA driver notification for corrected MCA event
        //  is done in HalpMcaHandler().
        //

    }

    //
    // Thierry 10/17/2000 BUGBUG
    //
    // The FW does not save the MCA log in NVRAM and we have no official date from Intel
    // when the SAL will be doing it.
    // So for now, return as ErrorFatal and let dump the log through the debugger.
    //
    // Before Sal Rev <ToBeDetermined>, the error logs were completely erroneous...
    //

    if ( HalpSalPalData.SalRevision.Revision < HALP_SAL_REVISION_MAX )  {
        return( ErrorFatal );
    }
    else    {
        return( mcaSeverity );
    }

} // HalpMcaProcessLog()

SAL_PAL_RETURN_VALUES
HalpMcaHandler(
    ULONG64 RendezvousState,
    PPAL_MINI_SAVE_AREA  Pmsa
    )
//++
// Name: HalpMcaHandler()
//
// Routine Description:
//
//      This is the OsMca handler for firmware uncorrected errors
//      It is our option to run this in physical or virtual mode.
//
// Arguments On Entry:
//      None.
//
// Conditions On Entry: 09/2000 implementation.
//      - PSR state: at least,
//          PSR.dt = 1, PSR.it = 1, PSR.rt = 1 - virtual mode.
//          PSR.ic = 1, PSR.i = 0              - Interruption resources collection enabled,
//                                               Interrupts off.
//          PSR.mc = 1                         - MCA masked for this processor.
//      - SalToOsHndOff initialized.
//      - s0 = MinStatePtr.
//      - s1 = IA64 PAL Processor State Parameter.
//      - s2 = PALE_CHECK return address.
//      - Processor registers state saved in myStateDump[] by osmcaProcStateDump().
//      - myStackFrame[0] = ar.rsc
//      - myStackFrame[1] = ar.pfs
//      - myStackFrame[2] = ar.ifs
//      - myStackFrame[3] = ar.bspstore
//      - myStackFrame[4] = ar.rnat
//      - myStackFrame[5] = ar.bsp - ar.bspstore
//      - ar.bspstore = myBspStore
//      - sp = &mySp[sizeof(mySp[])]
//
// Return:
//      rtn0=Success/Failure (0/!0)
//      rtn1=Alternate MinState Pointer if any else NULL
//
// Implementation notes:
//      This code CANNOT [as default rules - at least entry and through fatal MCAs handling]
//          - make any system call
//          - attempt to acquire any spinlock used by any code outside the MCA handler
//          - change the interrupt state.
//      Passing data to non-MCA code must be done using manual semaphore instructions.
//      This code should minimize the path and the global or memory allocated data accesses.
//      This code should only access MCA-namespace structures and should not access globals
//      until it is safe.
//
//--
{
    SAL_PAL_RETURN_VALUES rv;
    LONGLONG              salStatus;
    BOOLEAN               mcWakeUp;
    PMCA_EXCEPTION        mcaLog;
    ULONGLONG             mcaAllocatedLogSize;
    PSAL_EVENT_RESOURCES  mcaResources;
    KIRQL                 oldIrql;

    volatile KPCR * const pcr = KeGetPcr();

    //
    // Acquire MCA spinlock protecting OS_MCA resources.
    //
    // Thierry 10/06/2000: FIXFIX.
    //   we will move this MP synchronization in HalpOsMcaDispatch after current discussions
    //   with Intel about MP MCA handling are completed.
    //   Expecting responses from Intel about these.
    //

    KeRaiseIrql(HIGH_LEVEL, &oldIrql);

    HalpAcquireMcaSpinLock( &HalpMcaSpinLock );
    HalpOsMcaInProgress++;

    //
    // Save OsToSal minimum state
    //

    mcaResources = pcr->OsMcaResourcePtr;
    mcaResources->OsToSalHandOff.SalReturnAddress = mcaResources->SalToOsHandOff.SalReturnAddress;
    mcaResources->OsToSalHandOff.SalGlobalPointer = mcaResources->SalToOsHandOff.SalGlobalPointer;

    //
    // update local variables with pre-initialized MCA log data.
    //

    mcaLog = (PMCA_EXCEPTION)(mcaResources->EventPool);
    mcaAllocatedLogSize = mcaResources->EventPoolSize;
    if ( !mcaLog || !mcaAllocatedLogSize )  {
        //
        // The following code should never happen or the implementation of the HAL MCA logs
        // pre-allocation failed miserably. This would be a development error.
        //
        HalpMcaBugCheck( (ULONG_PTR)HAL_BUGCHECK_MCA_ASSERT, mcaLog,
                                                             mcaAllocatedLogSize,
                                                             (ULONGLONG)0 );
    }

    //
    // Get the MCA logs
    //

    salStatus = (LONGLONG)0;
    while( salStatus >= 0 )  {
        ERROR_SEVERITY errorSeverity;

        rv = HalpGetStateInfo( MCA_EVENT, mcaLog );
        salStatus = rv.ReturnValues[0];
        switch( salStatus )    {

            case SAL_STATUS_SUCCESS:
                errorSeverity = HalpMcaProcessLog( mcaLog );
                if ( errorSeverity == ErrorFatal )  {
                    //
                    // We are now going down with a MACHINE_CHECK_EXCEPTION.
                    // No return...
                    //
                    HalpMcaBugCheck( HAL_BUGCHECK_MCA_FATAL, mcaLog,
                                                             mcaAllocatedLogSize,
                                                             0 );
                }
                rv = HalpClearStateInfo( MCA_EVENT );
                if ( !SAL_SUCCESSFUL(rv) )  {
                    //
                    // Current consideration for this implementation - 08/2000:
                    // if clearing the event fails, we assume that FW has a real problem;
                    // continuing will be dangerous. We bugcheck.
                    //
                    HalpMcaBugCheck( HAL_BUGCHECK_MCA_CLEAR_STATEINFO, mcaLog,
                                                                       mcaAllocatedLogSize,
                                                                       rv.ReturnValues[0] );
                }
                // SAL_STATUS_SUCCESS, SAL_STATUS_SUCCESS_MORE_RECORDS ... and
                // ErrorSeverity != ErrorFatal.

                //
                // Call the registered kernel handler.
                //
                // Thierry 08/2000 - FIXFIX:
                // The errorSeverity check is under comments. It should not be commented for the
                // final version. However, we wanted to have kernel notification if we are getting
                // log error severity != ErrorFatal or != ErrorRecoverable.

                if ( /* (errorSeverity == ErrorCorrected) && */
                     ( HalpMcaInfo.KernelDelivery || HalpMcaInfo.DriverInfo.DpcCallback ) ) {
                    InterlockedExchange( &HalpMcaInfo.DpcNotification, 1 );
                }
                break;

            case SAL_STATUS_NO_INFORMATION_AVAILABLE:
                //
                // The salStatus value will break the salStatus loop.
                //
                rv.ReturnValues[0] = SAL_STATUS_SUCCESS;
                break;

            case SAL_STATUS_SUCCESS_WITH_OVERFLOW:
            case SAL_STATUS_INVALID_ARGUMENT:
            case SAL_STATUS_ERROR:
            case SAL_STATUS_VA_NOT_REGISTERED:
            default: // Thierry 08/00: WARNING - SAL July 2000 - v2.90.
                     // default includes possible unknown positive salStatus values.
                HalpMcaBugCheck( HAL_BUGCHECK_MCA_GET_STATEINFO, mcaLog,
                                                                 mcaAllocatedLogSize,
                                                                 salStatus );
                break;
        }

    }

    //
    // Currently 08/2000, we do not support the modification of the minstate.
    //

    mcaResources->OsToSalHandOff.MinStateSavePtr = mcaResources->SalToOsHandOff.MinStateSavePtr;
    mcaResources->OsToSalHandOff.Result          = rv.ReturnValues[0];

    //
    // If error was corrected and MCA non-monarch processors are in rendez vous,
    // we will have to wake them up.
    //

    mcWakeUp = ( (rv.ReturnValues[0] == SAL_STATUS_SUCCESS) &&
                 HalpSalRendezVousSucceeded( mcaResources->SalToOsHandOff ) );

    //
    // Release MCA spinlock protecting OS_MCA resources.
    //

    HalpOsMcaInProgress = 0;
    HalpReleaseMcaSpinLock( &HalpMcaSpinLock );

    //
    // If required, let's wake MCA non-monarch processors up.
    //

    if ( mcWakeUp )  {
        HalpMcWakeUp();
    }

    return( rv );

} // HalpMcaHandler()

//++
// Name: HalpGetErrLogSize()
//
// Routine Description:
//
//      This is a wrapper that will call SAL_GET_STATE_INFO_SIZE
//
// Arguments On Entry:
//              arg0 = Reserved
//              arg1 = Event Type (MCA,INIT,CMC,CPE)
//
// Returns
//              rtn0=Success/Failure (0/!0)
//              rtn1=Size
//--
SAL_PAL_RETURN_VALUES
HalpGetErrLogSize(  ULONGLONG Res,
                    ULONGLONG eType
                 )
{
    SAL_PAL_RETURN_VALUES rv = {0};
    HalpSalCall(SAL_GET_STATE_INFO_SIZE, eType, 0,0,0,0,0,0, &rv);

    return(rv);
}

//EndProc//////////////////////////////////////////////////////////////////////

//++
// Name: HalpGetErrLog()
//
// Routine Description:
//
//      This is a wrapper that will call SAL_GET_STATE_INFO
//
// Arguments On Entry:
//              arg0 = Reserved
//              arg1 = Event Type (MCA,INIT,CMC)
//              arg3 = pBuffer
//
//      Success/Failure (0/!0)
//--
SAL_PAL_RETURN_VALUES
HalpGetErrLog(  ULONGLONG  Res,
                ULONGLONG  eType,
                ULONGLONG* pBuff
             )
{
    SAL_PAL_RETURN_VALUES rv={0};

    HalpSalCall(SAL_GET_STATE_INFO, eType, 0, (ULONGLONG)pBuff, 0,0,0,0, &rv);

    //
    // Regardless of the call success or failure, fix the record to store
    // the processor number the SAL_PROC was executed on.
    // This feature is requested by WMI.
    //

    HalpSetFwMceLogProcessorNumber( (PERROR_RECORD_HEADER)pBuff );

    return(rv);
}

//EndProc//////////////////////////////////////////////////////////////////////

//++
// Name: HalpClrErrLog()
//
// Routine Description:
//
//      This is a wrapper that will call SAL_CLEAR_STATE_INFO
//
// Arguments On Entry:
//              arg0 = Reserved
//              arg1 = Event Type (MCA,INIT,CMC,CPE)
//
//      Success/Failure (0/!0)
//--

SAL_PAL_RETURN_VALUES
HalpClrErrLog(  ULONGLONG Res,
                ULONGLONG eType
             )
{
    SAL_PAL_RETURN_VALUES rv={0};

    HalpSalCall( SAL_CLEAR_STATE_INFO, eType, 0,0,0,0,0,0, &rv );

    return(rv);
}

//EndProc//////////////////////////////////////////////////////////////////////

//++
// Name: HalpSalSetParams()
//
// Routine Description:
//
//      This is a wrapper that will call SAL_MC_SET_PARAMS
//
// Arguments On Entry:
//              arg0 = Reserved
//              arg1 = Parameter Type (rendz. or wakeup)
//              arg2 = Event Type (interrupt/semaphore)
//              arg3 = Interrupt Vector or Memory Address
//              arg4 = Timeout value for rendezvous
//
//      Success/Failure (0/!0)
//--
SAL_PAL_RETURN_VALUES
HalpSalSetParams(ULONGLONG Res,
                ULONGLONG pType,
                ULONGLONG eType,
                ULONGLONG VecAdd,
                ULONGLONG tValue)
{
    SAL_PAL_RETURN_VALUES rv={0};

    HalpSalCall(SAL_MC_SET_PARAMS, pType, eType, VecAdd,tValue,0,0,0,&rv);

    return(rv);
}

//EndProc//////////////////////////////////////////////////////////////////////

//++
// Name: HalpSalSetVectors()
//
// Routine Description:
//
//      This is a wrapper that will call SAL_SET_VECTORS
//
// Arguments On Entry:
//              arg0 = Reserved
//              arg1 = Event Type (MCA, INIT..)
//              arg2 = Physical Address of handler
//              arg3 = gp
//              arg4 = length of event handler in bytes
//
//      Success/Failure (0/!0)
//--
SAL_PAL_RETURN_VALUES
HalpSalSetVectors(  ULONGLONG Res,
                    ULONGLONG eType,
                    PHYSICAL_ADDRESS Addr,
                    ULONGLONG gpValue,
                    ULONGLONG szHndlr)
{
    SAL_PAL_RETURN_VALUES rv={0};

    if ( eType == InitEvent )   {
        //
        // Thierry 08/2000:
        //    Current implementation assumes that OS decides the monarch inside OS_INIT.
        //    This implies handler_2, gp_2, length_2 are identical to handler_1, gp_1, length_1.
        //

        HalpSalCall(SAL_SET_VECTORS, eType, (ULONGLONG)Addr.QuadPart, gpValue, szHndlr,
                                            (ULONGLONG)Addr.QuadPart, gpValue, szHndlr, &rv);
    }
    else  {
        HalpSalCall(SAL_SET_VECTORS, eType, (ULONGLONG)Addr.QuadPart, gpValue,szHndlr,0,0,0,&rv);
    }

    return(rv);
}

//EndProc//////////////////////////////////////////////////////////////////////


//++
// Name: HalpSalRendz()
//
// Routine Description:
//
//      This is a wrapper that will call SAL_MC_RENDEZ
//
// Arguments On Entry:
//              arg0 = Reserved
//
//      Success/Failure (0/!0)
//--
SAL_PAL_RETURN_VALUES
HalpSalRendz(void)
{
    SAL_PAL_RETURN_VALUES rv={0};

    HalpSalCall(SAL_MC_RENDEZ, 0, 0, 0,0,0,0,0,&rv);

    return(rv);
}

VOID
HalpMcWakeUp(
    VOID
    )

/*++

Routine Description:

   This function does IPI to wakeup the MC non-monarch processors.

Arguments:

   None.

Return Value:

   None.

Remarks:

   This function is assumed to be executed on the MC monarch processor.

--*/

{
    USHORT  LogicalCpu;
    USHORT  ProcessorID;
    USHORT  monarchID;

    //
    // Scan the processor set and request an interprocessor interrupt on
    // each of the specified targets.
    //

    monarchID = (USHORT)PCR->HalReserved[PROCESSOR_ID_INDEX];

    for (LogicalCpu = 0; LogicalCpu < HalpMpInfo.ProcessorCount; LogicalCpu++) {

        //
        // Only IPI processors that are started.
        //

        if (HalpActiveProcessors & (1 << HalpProcessorInfo[LogicalCpu].NtProcessorNumber)) {

            ProcessorID = HalpProcessorInfo[LogicalCpu].LocalApicID;

            //
            // Request interprocessor interrupt on target physicalCpu.
            //

            if ( ProcessorID != monarchID ) {
                HalpSendIPI(ProcessorID, MC_WKUP_VECTOR);
            }
        }
    }

} // HalpMcWakeUp()

VOID
HalpCMCEnable(
    VOID
    )
/*++

Routine Description:

    This routine sets the processor CMCV register with CMCI_VECTOR.

Arguments:

    None.

Return Value:

    None.

--*/
{

    if ( HalpFeatureBits & HAL_CMC_PRESENT )    {
        HalpWriteCMCVector( CMCI_VECTOR );
    }
    return;

} // HalpCMCEnable()

VOID
HalpCMCDisable(
    VOID
    )
/*++
    Routine Description:
        This routine resets the processor CMCV register.

    Arguments:
        None

    Return Value:
        None
--*/
{

    HalpWriteCMCVector( 0x10000ui64 );
    return;

} // HalpCMCDisable()

ULONG_PTR
HalpSetCMCVector(
    IN ULONG_PTR CmcVector
    )
/*++

Routine Description:

    This routine sets the processor CMCV register with specified vector.
    This function is the broadcast function for HalpCMCDisableForAllProcessors().

Arguments:

    CmcVector: CMC Vector value.

Value:

    STATUS_SUCCESS

--*/
{

    HalpWriteCMCVector( (ULONG64)CmcVector );

    return((ULONG_PTR)(ULONG)(STATUS_SUCCESS));

} // HalpSetCmcVector()

VOID
HalpCMCDisableForAllProcessors(
    VOID
    )
/*++

Routine Description:

    This routine disables processor CMC on every processor in the host configuration
    by executing HalpSetCmcVector( 0ui64 ) on every processor in a synchronous manner.

Arguments:

    None.

Value:

    None.

--*/
{
    //
    // Can not do an IPI if the processors are above IPI level such
    // as we are in the kernel debugger.
    //

    if (KeGetCurrentIrql() < IPI_LEVEL) {
        (VOID)KiIpiGenericCall( HalpSetCMCVector, (ULONG_PTR)0x10000ui64 );
    } else {
        HalpSetCMCVector(0x10000ui64);
    }

    return;

} // HalpCMCDisableForAllProcessors()

VOID
HalpCMCIHandler (
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

    Routine Description:
        Processor Interrupt routine for CMC interrupts.

    Arguments:
        TrapFrame - Captured trap frame address.

    Return Parameters:
        None.

    Notes:
        Thierry 08/2000:
            This function does not do much, it flags the PCR InOsCmc field
            and calls the second-level handler: HalpCmcHandler().
            However, this was implmented this way so this function abstracts the
            standard interrupts resources from the purely CMC processing in HalpCmcHandler().

--*/

{
     volatile KPCR * const pcr = KeGetPcr();

     pcr->InOsCmc = TRUE;

     HalpCmcHandler();

     pcr->InOsCmc = FALSE;
     return;

} // HalpCMCIHandler()

VOID
HalpCmcProcessLog(
    PCMC_EXCEPTION CmcLog
    )
/*++

    Routine Description:
        This function does a simple processing check a IA64 CMC log.

    Arguments:
        CmcLog - Provides CMC log address

    Return Parameters:
        None.

    Notes:
        Currently simply checking and outputing log contents for checked hal only.

--*/

{

#if DBG
    //
    // Simple log processing for first debugging...
    //

    GUID                  processorDeviceGuid = ERROR_PROCESSOR_GUID;
    BOOLEAN               processorDeviceFound;
    PERROR_RECORD_HEADER  header = (PERROR_RECORD_HEADER)CmcLog;
    PERROR_SECTION_HEADER section, sectionMax;

    if ( header->ErrorSeverity != ErrorCorrected )  {
        HalDebugPrint(( HAL_ERROR,
                        "HAL!HalpCmcProcessLog: CMC record with severity [%d] != corrected!!!\n",
                        header->ErrorSeverity ));
    }
    //
    // SAL spec BUGBUG 08/2000: we should have put the length of the header in the definition.
    //                          Same for section header.
    //

    processorDeviceFound = FALSE;
    section    = (PERROR_SECTION_HEADER)((ULONG_PTR)header + sizeof(*header));
    sectionMax = (PERROR_SECTION_HEADER)((ULONG_PTR)header + header->Length);
    while( section < sectionMax )   {
        if ( IsEqualGUID( &section->Guid, &processorDeviceGuid ) )  {
            PERROR_PROCESSOR processorRecord = (PERROR_PROCESSOR)section;
            processorDeviceFound = TRUE;
            //
            // Minimum processing here. This will enhance with testing and most common
            // occurences.
            //

            if ( processorRecord->Valid.StateParameter )    {
                ULONGLONG stateParameter = processorRecord->StateParameter.StateParameter;

                //
                // At any time more than one error could be valid
                //

                if((stateParameter >> ERROR_PROCESSOR_STATE_PARAMETER_CACHE_CHECK_SHIFT) &
                                      ERROR_PROCESSOR_STATE_PARAMETER_CACHE_CHECK_MASK) {
                    //
                    // cache error
                    //
                    HalDebugPrint(( HAL_INFO,
                                    "HAL!HalpCmcProcessLog: Corrected Processor CACHE Machine Check error\n" ));

                }
                if((stateParameter >> ERROR_PROCESSOR_STATE_PARAMETER_TLB_CHECK_SHIFT) &
                                      ERROR_PROCESSOR_STATE_PARAMETER_TLB_CHECK_MASK) {
                    //
                    // tlb error
                    //
                    HalDebugPrint(( HAL_INFO,
                                    "HAL!HalpCmcProcessLog: Corrected Processor TLB Machine Check error\n" ));
                }
                if((stateParameter >> ERROR_PROCESSOR_STATE_PARAMETER_BUS_CHECK_SHIFT) &
                                      ERROR_PROCESSOR_STATE_PARAMETER_BUS_CHECK_MASK) {
                    //
                    // bus error
                    //
                    HalDebugPrint(( HAL_INFO,
                                    "HAL!HalpCmcProcessLog: Corrected Processor BUS Machine Check error\n" ));
                }
                if((stateParameter >> ERROR_PROCESSOR_STATE_PARAMETER_UNKNOWN_CHECK_SHIFT) &
                                      ERROR_PROCESSOR_STATE_PARAMETER_UNKNOWN_CHECK_MASK) {
                    //
                    // unknown error
                    //
                    HalDebugPrint(( HAL_INFO,
                                    "HAL!HalpCmcProcessLog: Corrected Processor UNKNOWN Machine Check error\n" ));
                }
            }
        }
    }
    if ( !processorDeviceFound )    {
        HalDebugPrint(( HAL_ERROR,
                        "HAL!HalpCmcProcessLog: CMC log without processor device record!!!\n"));
    }

#endif // DBG

    return;

} // HalpCmcProcessLog()

//++
// Name: HalpCmcHandler()
//
// Routine Description:
//
//      This is the second level CMC Interrupt Handler for FW corrected errors.
//
// Arguments On Entry:
//      None.
//
// Return.
//      None.
//
// Notes:
//      This function calls the kernel notification and inserts the OEM CMC driver dpc if
//      registered.
//      Accessing the CMC logs at this level could be inacceptable because of the possible
//      large size of the logs and the time required to collect them.
//      The collection of the logs is delayed until the work item calls
//      HalQuerySystemInformation.HalCmcLogInformation.
//--

VOID
HalpCmcHandler(
   VOID
   )
{

    //
    // Internal housekeeping.
    //

    InterlockedIncrement( &HalpCmcInfo.Stats.CmcInterruptCount );

    //
    // Notify the kernel if registered.
    //

    if ( HalpCmcInfo.KernelDelivery ) {
        if ( !HalpCmcInfo.KernelDelivery( HalpCmcInfo.KernelToken, NULL ) ) {
            InterlockedIncrement( &HalpCmcInfo.Stats.KernelDeliveryFails );
        }
    }

    //
    // Notify the OEM CMC driver if registered.
    //

    if ( HalpCmcInfo.DriverInfo.DpcCallback )   {
        if ( !KeInsertQueueDpc( &HalpCmcInfo.DriverDpc, NULL, NULL ) )  {
            InterlockedIncrement( &HalpCmcInfo.Stats.DriverDpcQueueFails );
        }
    }

    return;

} // HalpCmcHandler()

//EndProc//////////////////////////////////////////////////////////////////////

//++
// Name: HalpCpeHandler()
//
// Routine Description:
//
//      This is the second level CPE Interrupt Handler for Platform corrected errors.
//
// Arguments On Entry:
//      None.
//
// Return.
//      None.
//
// Notes:
//      This function calls the kernel notification and inserts the OEM CPE driver dpc if
//      registered.
//      Accessing the CPE logs at this level could be inacceptable because of the possible
//      large size of the logs and the time required to collect them.
//      The collection of the logs is delayed until the work item calls
//      HalQuerySystemInformation.HalCpeLogInformation.
//--

VOID
HalpCpeHandler(
   VOID
   )
{

    //
    // Internal housekeeping.
    //

    InterlockedIncrement( &HalpCpeInfo.Stats.CpeInterruptCount );

    //
    // Notify the kernel if registered.
    //

    if ( HalpCpeInfo.KernelDelivery ) {
        if ( !HalpCpeInfo.KernelDelivery( HalpCpeInfo.KernelToken, NULL ) ) {
            InterlockedIncrement( &HalpCpeInfo.Stats.KernelDeliveryFails );
        }
    }

    //
    // Notify the OEM CPE driver if registered.
    //

    if ( HalpCpeInfo.DriverInfo.DpcCallback )   {
        if ( !KeInsertQueueDpc( &HalpCpeInfo.DriverDpc, NULL, NULL ) )  {
            InterlockedIncrement( &HalpCpeInfo.Stats.DriverDpcQueueFails );
        }
    }

    return;

} // HalpCpeHandler()

//EndProc//////////////////////////////////////////////////////////////////////

VOID
HalpMcRzHandler (
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

    Routine Description:


    Arguements:


    Return Parameters:


--*/

{
    SAL_PAL_RETURN_VALUES rv={0};
    HalpDisableInterrupts();
    rv=HalpSalRendz();
    HalpEnableInterrupts();
    // do any Isr clean up and re-enable the interrupts & MC's

   return;

}

//EndProc//////////////////////////////////////////////////////////////////////


VOID
HalpMcWkupHandler (
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

    Routine Description:


    Arguements:


    Return Parameters:


--*/

{

    return;
}

//EndProc//////////////////////////////////////////////////////////////////////

VOID
HalpCPEIHandler (
    IN PKINTERRUPT_ROUTINE Interrupt,
    IN PKTRAP_FRAME TrapFrame
    )

/*++

    Routine Description:
        Processor Interrupt routine for CPE interrupts.

    Arguments:
        TrapFrame - Captured trap frame address.

    Return Parameters:
        None.

    Notes:
        Thierry 08/2000:
            This function does not do much, it flags the PCR InOsCpe field
            and calls the second-level handler: HalpCpeHandler().
            However, this was implmented this way so this function abstracts the
            standard interrupts resources from the purely CPE processing in HalpCpeHandler().

--*/

{
     volatile KPCR * const pcr = KeGetPcr();

     pcr->InOsCpe = TRUE;

     HalpCpeHandler();

     pcr->InOsCpe = FALSE;
     return;

} // HalpCPEIHandler()

VOID
HalpCPEEnable (
    VOID
    )

/*++

Routine Description:

    This routine sets the default HAL CPE handling regardless of the user specified
    registry setting. It enables the supported Platform Interrupt sources and
    exposes the initial interrupt/polling based mode used for CPE.

    The user specified registry setting is handled via HalpMcaInit() at the end of
    phase 1.

Arguments:

    None.

Return Parameters:

    None.

Implementation Notes:

    The following implementation assumes that this code is executed on BSP.

--*/

{
    ULONG i;

    if ( HalpFeatureBits & HAL_CPE_PRESENT )    {

        ULONG maxCPE = HalpMaxCPEImplemented;

        if ( maxCPE )   {
            //
            // Pick up the information from HalpCPEIntIn, HalpCPEDestination, HalpCPEVectorFlags,
            // HalpCPEIoSapicVector.
            //

            for (i=0 ; i != maxCPE; i++ ) {
                HalpEnableRedirEntry( HalpCPEIntIn[i] );
            }

            //
            // Initialize the remaining fields of HAL private CPE info structure.
            //

            HalpCpeInfo.Stats.PollingInterval = HAL_CPE_INTERRUPTS_BASED;

        }
        else  {

            //
            // We will implement Polling model.
            //

//
// Thierry 03/11/2001: WARNING WARNING
// Do not enable xxhal.c HAL_CPE_PRESENT if HalpMaxCPEImplemented == 0.
// We bugcheck with the current BigSur SAL/FW (<= build 99) at SAL_GET_STATE_INFO calls,
// the FW assuming that we are calling the SAL MC related functions in physical mode.
// With the Lion SAL/FW (<= build 75), we bugcheck after getting MCA logs at boot time,
// the FW having some virtualization issues.
// Intel is committed to provide working FWs soon (< 2 weeks...).
//
            HalpCpeInfo.Stats.PollingInterval = HALP_CPE_DEFAULT_POLLING_INTERVAL;

        }

    }
    else  {

        HalpCpeInfo.Stats.PollingInterval = HAL_CPE_DISABLED;

    }

    return;

} // HalpCPEEnable()

VOID
HalpCPEDisable (
    VOID
    )

/*++

Routine Description:

    This routine disables the SAPIC Platform Interrupt Sources.
    Note that if HalpMaxCPEImplemented is 0, the function does nothing.

Arguments:

    None.

Return Parameters:

    None.

--*/

{
    //
    // Pick up the information from HalpCPEIntIn, HalpCPEDestination, HalpCPEVectorFlags,
    // HalpCPEIoSapicVector

    int i;

    for (i=0;i != HalpMaxCPEImplemented;i++) {
        HalpDisableRedirEntry(HalpCPEIntIn[i]);
    }

    return;

} // HalpCPEDisable()

VOID
HalpMCADisable(
    VOID
    )
{
   PHYSICAL_ADDRESS NULL_PHYSICAL_ADDRESS = {0};
   SAL_PAL_RETURN_VALUES rv = {0};
   char Lid;
   ULONGLONG gp_reg = GetGp();

   // Disable CMCs
   HalpCMCDisableForAllProcessors();

   // Disable CPE Interrupts
   HalpCPEDisable();

   //DeRegister Rendez. Paramters with SAL

#define NULL_VECTOR 0xF

   rv = HalpSalSetParams(0,RendzType, IntrVecType, NULL_VECTOR, HalpMcRendezTimeOut );

   // Deregister WakeUp parameters with SAL

   rv=HalpSalSetParams(0, WakeUpType, IntrVecType, NULL_VECTOR,0);

   // Deregister OsMcaDispatch (OS_MCA) physical address with SAL
   rv=HalpSalSetVectors(0, MchkEvent, NULL_PHYSICAL_ADDRESS, gp_reg,0);

   // Deregister OsInitDispatch physical address with SAL
   rv=HalpSalSetVectors(0, InitEvent, NULL_PHYSICAL_ADDRESS, gp_reg,0);

   return;

} // HalpMCADisable()

NTSTATUS
HalpGetMceInformation(
    PHAL_ERROR_INFO ErrorInfo,
    PULONG          ErrorInfoLength
    )
/*++
    Routine Description:
        This routine is called by HaliQuerySystemInformation for the HalErrorInformation class.

    Arguments:
        ErrorInfo : pointer to HAL_ERROR_INFO structure.

        ErrorInfoLength : size of the valid memory structure pointed by ErrorInfo.

    Return Value:
        STATUS_SUCCESS if successful
        error status otherwise
--*/
{
    NTSTATUS status;
    ULONG    cpePollingInterval;

    PAGED_CODE();

    ASSERT( ErrorInfo );
    ASSERT( ErrorInfoLength );

    //
    // Backward compatibility only.
    //

    if ( !ErrorInfo->Version || ( ErrorInfo->Version > HAL_ERROR_INFO_VERSION ) ) {
        return( STATUS_REVISION_MISMATCH );
    }

    //
    // Zero Reserved field.
    //

    ErrorInfo->Reserved                = 0;

    //
    // Collect MCA info under protection if required.
    //

    ErrorInfo->McaMaxSize              = HalpMcaInfo.Stats.MaxLogSize;
    ErrorInfo->McaPreviousEventsCount  = HalpMcaInfo.Stats.McaPreviousCount;
    ErrorInfo->McaCorrectedEventsCount = HalpMcaInfo.Stats.McaCorrectedCount;    // approximation.
    ErrorInfo->McaKernelDeliveryFails  = HalpMcaInfo.Stats.KernelDeliveryFails;  // approximation.
    ErrorInfo->McaDriverDpcQueueFails  = HalpMcaInfo.Stats.DriverDpcQueueFails;  // approximation.
    ErrorInfo->McaReserved             = 0;

    //
    // Collect CMC info under protection if required.
    //

    ErrorInfo->CmcMaxSize              = HalpCmcInfo.Stats.MaxLogSize;
    ErrorInfo->CmcPollingInterval      = HalpCmcInfo.Stats.PollingInterval;
    ErrorInfo->CmcInterruptsCount      = HalpCmcInfo.Stats.CmcInterruptCount;    // approximation.
    ErrorInfo->CmcKernelDeliveryFails  = HalpCmcInfo.Stats.KernelDeliveryFails;  // approximation.
    ErrorInfo->CmcDriverDpcQueueFails  = HalpCmcInfo.Stats.DriverDpcQueueFails;  // approximation.

    HalpAcquireCmcMutex();
    ErrorInfo->CmcGetStateFails        = HalpCmcInfo.Stats.GetStateFails;
    ErrorInfo->CmcClearStateFails      = HalpCmcInfo.Stats.ClearStateFails;
    ErrorInfo->CmcLogId                = HalpCmcInfo.Stats.LogId;
    HalpReleaseCmcMutex();

    ErrorInfo->CmcReserved             = 0;

    //
    // Collect CPE info under protection if required.
    //

    ErrorInfo->CpeMaxSize              = HalpCpeInfo.Stats.MaxLogSize;
    ErrorInfo->CpePollingInterval      = HalpCpeInfo.Stats.PollingInterval;

    ErrorInfo->CpeInterruptsCount      = HalpCpeInfo.Stats.CpeInterruptCount;    // approximation.
    ErrorInfo->CpeKernelDeliveryFails  = HalpCpeInfo.Stats.KernelDeliveryFails;  // approximation.
    ErrorInfo->CpeDriverDpcQueueFails  = HalpCpeInfo.Stats.DriverDpcQueueFails;  // approximation.

    HalpAcquireCpeMutex();
    ErrorInfo->CpeGetStateFails        = HalpCpeInfo.Stats.GetStateFails;
    ErrorInfo->CpeClearStateFails      = HalpCpeInfo.Stats.ClearStateFails;
    ErrorInfo->CpeLogId                = HalpCpeInfo.Stats.LogId;
    HalpReleaseCpeMutex();

    // CpeInterruptSources: Number of SAPIC Platform Interrup Sources supported by HAL.
    ErrorInfo->CpeInterruptSources     = HalpMaxCPEImplemented;

    //
    // Update KernelTokens
    //

    ErrorInfo->McaKernelToken          = (ULONGLONG) HalpMcaInfo.KernelToken;
    ErrorInfo->CmcKernelToken          = (ULONGLONG) HalpCmcInfo.KernelToken;
    ErrorInfo->CpeKernelToken          = (ULONGLONG) HalpCpeInfo.KernelToken;

    ErrorInfo->KernelReserved[3]       = (ULONGLONG) 0;

    *ErrorInfoLength = sizeof(*ErrorInfo);

    return( STATUS_SUCCESS );

} // HalpGetMceInformation()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\osinit.c ===
//**  Copyright  (C) 1996-98 Intel Corporation. All rights reserved.
//**
//** The information and source code contained herein is the exclusive
//** property of Intel Corporation and may not be disclosed, examined
//** or reproduced in whole or in part without explicit written authorization
//** from the company.
//**
//###########################################################################

//-----------------------------------------------------------------------------
// Version control information follows.
//
// 
//             10 Jun 1999  Bugcheck  Bernard Lint
//                                    M. Jayakumar (Muthurajan.Jayakumar@intel.com)

///////////////////////////////////////////////////////////////////////////////
//
// Module Name:  OSINIT.C - Merced OS INIT Handler
//
// Description:
//    This module has OS INIT Event Handler Reference Code.
//
//      Contents:   HalpOsInitInit()          
//                  HalpInitHandler() 
//
//
// Target Platform:  Merced
//
// Reuse: None
//
////////////////////////////////////////////////////////////////////////////M//  

#include "halp.h"
#include "nthal.h"
#include "arc.h"
#include "i64fw.h"
#include "check.h"
#include "inbv.h"
#include "osmca.h"


// i64fwasm.s: low-level protection data structures
extern KSPIN_LOCK HalpInitSpinLock;

//
// Temporary location for INIT_EXCEPTION definition.
//

typedef ERROR_RECORD_HEADER INIT_EXCEPTION, *PINIT_EXCEPTION;    // Init Event Record

HALP_INIT_INFO  HalpInitInfo;

volatile ULONG HalpOsInitInProgress = 0;

VOID
HalpInitBugCheck(
    ULONG           InitBugCheckType,
    PINIT_EXCEPTION InitLog,
    ULONGLONG       InitAllocatedLogSize,
    ULONGLONG       SalStatus
    )
//++
// Name: HalpInitBugCheck()
// 
// Routine Description:
//
//      This function is called to bugcheck the system in a case of a fatal INIT 
//      or fatal FW interface errors. The OS must guarantee as much as possible
//      error containment in this path.
//      With the current implementation, this function should be only called from
//      the OS_INIT path. 
//
// Arguments On Entry:
//      ULONG           InitBugCheckType
//      PINIT_EXCEPTION InitLog
//      ULONGLONG       InitAllocatedLogSize
//      ULONGLONG       SalStatus
//      
// Return:
//      None.
//
// Implementation notes: 
//      This code CANNOT [as default rules - at least entry and through fatal INITs handling]
//          - make any system call
//          - attempt to acquire any spinlock used by any code outside the INIT handler
//          - change the interrupt state. 
//      Passing data to non-INIT code must be done using manual semaphore instructions.
//      This code should minimize the path and the global or memory allocated data accesses.
//      This code should only access INIT-namespace structures.
//      This code is called under the MP protection of HalpInitSpinLock and with the flag
//      HalpOsInitInProgress set.
//
//--
{

    if ( HalpOsInitInProgress )   {

        //
        // Enable InbvDisplayString calls to make it through to bootvid driver.
        //

        if ( InbvIsBootDriverInstalled() ) {

            InbvAcquireDisplayOwnership();

            InbvResetDisplay();
            InbvSolidColorFill(0,0,639,479,4); // make the screen blue
            InbvSetTextColor(15);
            InbvInstallDisplayStringFilter((INBV_DISPLAY_STRING_FILTER)NULL);
            InbvEnableDisplayString(TRUE);     // enable display string
            InbvSetScrollRegion(0,0,639,479);  // set to use entire screen
        }

        HalDisplayString (MSG_INIT_HARDWARE_ERROR);
        HalDisplayString (MSG_HARDWARE_ERROR2);

//
// Thierry 09/2000:
//
//   - if desired, process the INIT log HERE...
//
//     and use HalDisplayString() to dump info for the field or hardware vendor.
//     The processing could be based on processor or platform independent record definitions.
//

        HalDisplayString( MSG_HALT );

        KeBugCheckEx( MACHINE_CHECK_EXCEPTION, (ULONG_PTR)InitBugCheckType,
                                               (ULONG_PTR)InitLog, 
                                               (ULONG_PTR)InitAllocatedLogSize,
                                               (ULONG_PTR)SalStatus );

    }

    if ( ((*KdDebuggerNotPresent) == FALSE) && ((*KdDebuggerEnabled) != FALSE) )    {
        KeEnterKernelDebugger();
    }

    while( TRUE ) {
          //
        ; // Simply sit here so the INIT HARDWARE ERROR screen does not get corrupted...
          //
    }

    // noreturn

} // HalpInitBugCheck()

ERROR_SEVERITY
HalpInitProcessLog(
    PINIT_EXCEPTION  InitLog
    )
//++
// Name: HalpInitProcessLog()
//
// Routine Description:
//
//      This function is called to process the INIT event log in the OS_INIT path.
//
// Arguments On Entry:
//      PINIT_EXCEPTION InitLog - Pointer to the INIT event log.
//
// Return:
//      ERROR_SEVERITY
//
// Implementation notes:
//      This code does not do anything right now.
//      Testing will allow to determine the right filtering depending on FW functionalities
//      and user requested operations like warm reset.
//
//--
{
    ERROR_SEVERITY initSeverity;

    initSeverity = InitLog->ErrorSeverity;
    switch( initSeverity )    {

        case ErrorFatal:
            break;

        case ErrorRecoverable:
            break;

        case ErrorCorrected:
            break;

        default:
            //
            // These ERRROR_SEVERITY values have no HAL INIT specific handling.
            // As specified by the SAL Specs July 2000, we should not get these values in this path.
            //
            break;
    }

    return( initSeverity );

} // HalpInitProcessLog()

//++
// Name: HalpInitHandler()
// 
// Routine Description:
//
//      This is the OsInit handler for firmware uncorrected errors
//      It is our option to run this in physical or virtual mode
//
// Arguments On Entry:
//              arg0 = Function ID
//
// Return:
//              rtn0=Success/Failure (0/!0)
//              rtn1=Alternate MinState Pointer if any else NULL
//--
SAL_PAL_RETURN_VALUES 
HalpInitHandler(
      ULONG64 RendezvousState, 
      PPAL_MINI_SAVE_AREA  Pmsa
      )
{   
    SAL_PAL_RETURN_VALUES rv;
    LONGLONG              salStatus;
    KIRQL                 oldIrql;
    PINIT_EXCEPTION       initLog;
    ULONGLONG             initAllocatedLogSize;
    PSAL_EVENT_RESOURCES  initResources;

    volatile KPCR * const pcr = KeGetPcr();
 
    //
    // Block various I/O interrupts.
    //

    KeRaiseIrql(SYNCH_LEVEL, &oldIrql);

    //
    // Enable interrupts so the debugger will work.
    //

    HalpEnableInterrupts();

    HalpAcquireMcaSpinLock(&HalpInitSpinLock);
    HalpOsInitInProgress++;

    //
    // Save OsToSal minimum state
    //

    initResources = pcr->OsMcaResourcePtr;
    initResources->OsToSalHandOff.SalReturnAddress = initResources->SalToOsHandOff.SalReturnAddress;
    initResources->OsToSalHandOff.SalGlobalPointer = initResources->SalToOsHandOff.SalGlobalPointer;

    //
    // update local variables with pre-initialized INIT log data.
    //

    initLog = (PINIT_EXCEPTION)(initResources->EventPool);
    initAllocatedLogSize = initResources->EventPoolSize;
    if ( !initLog || !initAllocatedLogSize )  {
        //
        // The following code should never happen or the implementation of the HAL INIT logs
        // pre-allocation failed miserably. This would be a development error.
        //
        HalpInitBugCheck( (ULONG_PTR)HAL_BUGCHECK_INIT_ASSERT, initLog,
                                                               initAllocatedLogSize,
                                                               (ULONGLONG)Pmsa );
    }

    //
    // Get the INIT logs
    //

    salStatus = (LONGLONG)0;
    while( salStatus >= 0 )  {
        ERROR_SEVERITY errorSeverity;

        rv = HalpGetStateInfo( INIT_EVENT, initLog );
        salStatus = rv.ReturnValues[0];
        switch( salStatus )    {

            case SAL_STATUS_SUCCESS:
                errorSeverity = HalpInitProcessLog( initLog );
                if ( errorSeverity == ErrorFatal )  {
                    //
                    // We are now going down with a MACHINE_CHECK_EXCEPTION.
                    // No return...
                    //

                    KeBugCheckEx( MANUALLY_INITIATED_CRASH, (ULONG_PTR) initLog, initAllocatedLogSize, salStatus, (ULONG_PTR) Pmsa );
                } 
                rv = HalpClearStateInfo( INIT_EVENT );
                if ( !SAL_SUCCESSFUL(rv) )  { 
                    //
                    // Current consideration for this implementation - 08/2000:
                    // if clearing the event fails, we assume that FW has a real problem;
                    // continuing will be dangerous. We bugcheck.
                    // 
                    HalpInitBugCheck( HAL_BUGCHECK_INIT_CLEAR_STATEINFO, initLog, 
                                                                         initAllocatedLogSize, 
                                                                         rv.ReturnValues[0] );
                }
                // SAL_STATUS_SUCCESS, SAL_STATUS_SUCCESS_MORE_RECORDS ... and
                // ErrorSeverity != ErrorFatal.
                break;

            case SAL_STATUS_NO_INFORMATION_AVAILABLE:
                //
                // The salStatus value will break the salStatus loop.
                //
                rv.ReturnValues[0] = SAL_STATUS_SUCCESS;
                break;

            case SAL_STATUS_SUCCESS_WITH_OVERFLOW:  
            case SAL_STATUS_INVALID_ARGUMENT:
            case SAL_STATUS_ERROR:
            case SAL_STATUS_VA_NOT_REGISTERED:
            default: // Thierry 08/00: WARNING - SAL July 2000 - v2.90.
                     // default includes possible unknown positive salStatus values.
                HalpInitBugCheck( HAL_BUGCHECK_INIT_GET_STATEINFO, initLog, 
                                                                   initAllocatedLogSize,
                                                                   salStatus );
                break;
        }

    }

    if (RendezvousState == 2) {

        KeBugCheckEx( MANUALLY_INITIATED_CRASH, 
                      (ULONG_PTR) initLog, 
                      initAllocatedLogSize, 
                      salStatus, 
                      (ULONG_PTR) Pmsa 
                      );

    } else {

        KeBugCheckEx( NMI_HARDWARE_FAILURE, 
                      (ULONG_PTR) initLog, 
                      initAllocatedLogSize, 
                      salStatus, 
                      (ULONG_PTR) Pmsa 
                      );

    }


    //
    // Currently 08/2000, we do not support the modification of the minstate.
    //

    initResources->OsToSalHandOff.MinStateSavePtr = initResources->SalToOsHandOff.MinStateSavePtr;
    initResources->OsToSalHandOff.Result          = rv.ReturnValues[0];
    initResources->OsToSalHandOff.NewContextFlag = 0; // continue the same context and NOT new

    //
    // Release INIT spinlock protecting OS_INIT resources.
    //

    HalpOsInitInProgress = 0;
    HalpReleaseMcaSpinLock(&HalpInitSpinLock);

    return(rv);

} // HalpInitHandler()

//EndProc//////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\osmca.h ===
#ifndef OSMCA_H_INCLUDED
#define OSMCA_H_INCLUDED

//###########################################################################
//**
//**  Copyright  (C) 1996-98 Intel Corporation. All rights reserved.
//**
//** The information and source code contained herein is the exclusive
//** property of Intel Corporation and may not be disclosed, examined
//** or reproduced in whole or in part without explicit written authorization
//** from the company.
//**
//###########################################################################

//-----------------------------------------------------------------------------
// Version control information follows.
//
// $Header:   I:/DEVPVCS/OSMCA/osmca.h_v   2.2   09 Mar 1999 10:30:26   smariset  $
// $Log:   I:/DEVPVCS/OSMCA/osmca.h_v  $
// 
//    Rev 2.2   09 Mar 1999 10:30:26   smariset
// *.h consolidation
// 
//    Rev 2.0   Dec 11 1998 11:42:18   khaw
// Post FW 0.5 release sync-up
// 
//   Rev 1.4   29 Oct 1998 14:25:02   smariset
//Consolidated Sources
//
//   Rev 1.3   07 Aug 1998 13:47:50   smariset
// 
//
//   Rev 1.2   10 Jul 1998 11:04:24   smariset
//just checking in
//
//   Rev 1.1   08 Jul 1998 14:23:16   smariset
// 
//
//   Rev 1.0   02 Jul 1998 09:20:56   smariset
// 
//
//
//*****************************************************************************//

// SAL_MC_SET_PARAMS
// typedef's

typedef (*fptr)(void);
typedef SAL_PAL_RETURN_VALUES (*fpSalProc)(ULONGLONG,ULONGLONG,ULONGLONG,ULONGLONG,ULONGLONG,ULONGLONG,ULONGLONG,ULONGLONG);

typedef struct tagPLabel
{
    ULONGLONG    fPtr;
    ULONGLONG    gp;
} PLabel;

typedef struct tagSalHandOffState
{
    ULONGLONG     OsGp;
    ULONGLONG     pPalProc;
    fptr    pSalProc;
    ULONGLONG     SalGp;
     LONGLONG     RendzResult;
    ULONGLONG     SalRtnAddr;
    ULONGLONG     MinStatePtr;
} SalHandOffState;

#define SAL_RZ_NOT_REQUIRED                 0
#define SAL_RZ_WITH_MC_RENDEZVOUS           1
#define SAL_RZ_WITH_MC_RENDEZVOUS_AND_INIT  2
#define SAL_RZ_FAILED                      -1
#define SalRendezVousSucceeded( _SalHandOffState ) \
                    ((_SalHandOffState).RendzResult > SAL_RZ_NOT_REQUIRED)

//
// HAL Private SalRendezVousSucceeded definition, 
// using ntos\inc\ia64.h: _SAL_HANDOFF_STATE.
//

#define HalpSalRendezVousSucceeded( _SalHandOffState ) \
                    ((_SalHandOffState).RendezVousResult > SAL_RZ_NOT_REQUIRED)

typedef struct tagOsHandOffState
{
    ULONGLONG     Result;
    ULONGLONG     SalGp;
    ULONGLONG     nMinStatePtr;
    ULONGLONG     SalRtnAddr;
    ULONGLONG     NewCxFlag;
} OsHandOffState;

typedef SAL_PAL_RETURN_VALUES (*fpOemMcaDispatch)(ULONGLONG);

// function prototypes
void     HalpOsMcaDispatch(void);
void     HalpOsInitDispatch(void);
VOID     HalpCMCEnable ( VOID );
VOID     HalpCMCDisable( VOID );
VOID     HalpCMCDisableForAllProcessors( VOID );
VOID     HalpCPEEnable ( VOID );
VOID     HalpCPEDisable( VOID );
BOOLEAN  HalpInitializeOSMCA( ULONG Number );
VOID     HalpCmcHandler( VOID );
VOID     HalpCpeHandler( VOID );
SAL_PAL_RETURN_VALUES HalpMcaHandler(ULONG64 RendezvousState, PPAL_MINI_SAVE_AREA  Pmsa);

extern VOID HalpAcquireMcaSpinLock( PKSPIN_LOCK );
extern VOID HalpReleaseMcaSpinLock( PKSPIN_LOCK );
void     HalpOsMcaDispatch1(void);

//
// wrappers to SAL procedure calls
//

SAL_PAL_RETURN_VALUES 
HalpGetErrLogSize( ULONGLONG Reserved, 
                   ULONGLONG EventType
                 );   

#define HalpGetStateInfoSize( /* ULONGLONG */ _EventType ) HalpGetErrLogSize( 0, (_EventType) )

SAL_PAL_RETURN_VALUES 
HalpGetErrLog( ULONGLONG  Reserved, 
               ULONGLONG  EventType, 
               ULONGLONG *MemAddr
             );

#define HalpGetStateInfo( /* ULONGLONG */ _EventType, /* ULONGLONG * */ _Buffer ) \
                             HalpGetErrLog( 0, (ULONGLONG)(_EventType), (PULONGLONG)(_Buffer) )

SAL_PAL_RETURN_VALUES 
HalpClrErrLog( ULONGLONG Reserved, 
               ULONGLONG EventType  // MCA_EVENT,INIT_EVENT,CMC_EVENT,CPE_EVENT
             );

#define HalpClearStateInfo( /* ULONGLONG */ _EventType ) HalpClrErrLog( 0, (_EventType) )

SAL_PAL_RETURN_VALUES HalpSalSetParams(ULONGLONG, ULONGLONG, ULONGLONG, ULONGLONG, ULONGLONG);
SAL_PAL_RETURN_VALUES HalpSalSetVectors(ULONGLONG, ULONGLONG, PHYSICAL_ADDRESS, ULONGLONG, ULONGLONG);
SAL_PAL_RETURN_VALUES HalpSalRendz(void);

#define  GetGp()      __getReg(CV_IA64_IntGp)

#endif // OSMCA_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\pmdata.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pmdata.c

Abstract:

    Declares various data which is initialize data, or pagable data.

Author:

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "acpitabl.h"
#include "xxacpi.h"

FADT    HalpFixedAcpiDescTable;
ULONG   HalpThrottleScale;

ULONG   HalpAcpiFlags = HAL_ACPI_PCI_RESOURCES;

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGE")
#endif

//
// This array represents the ISA PIC vectors.
// They start out identity-mapped.
//
ULONG   HalpPicVectorRedirect[PIC_VECTORS] =
{
    0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
    10, 11, 12, 13, 14, 15
};

ULONG HalpPicVectorFlags[PIC_VECTORS] = {0};

//
// HalpCPEIntIn[] represents the Platform Interrupt Source's
// connection to SAPIC input pin. They start out "identity-mapped".
//


ULONG HalpCPEIntIn[HALP_CPE_MAX_INTERRUPT_SOURCES] =
{
   0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
   10, 11, 12, 13, 14, 15
};

//
// HalpCMCDestination[] represents the target CPU number of CMC interrupt source.
// They start out with all pointing to processor 0.
//

USHORT HalpCPEDestination[HALP_CPE_MAX_INTERRUPT_SOURCES] =
{
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0
};

//
// HalpCPEVectorFlags[] represents the flags for CPE interrupt source.
//

ULONG HalpCPEVectorFlags[HALP_CPE_MAX_INTERRUPT_SOURCES] = {0};

//
// HalpCPEIoSapicVector[] represents the interrupt vector of CPE interrupt source.
// They start out with all vectors at CPEI_VECTOR.
//


UCHAR HalpCPEIoSapicVector[HALP_CPE_MAX_INTERRUPT_SOURCES] = {CPEI_VECTOR};

//
// HalpMaxCPEImplemented indicates as how many INITIN pins are
// connected to different sources of platform CMC Error. The default value is 0.
// Since this will be used to index the arrays, a value of 0 means one source of CPE is
// implemented in this platform.

ULONG HalpMaxCPEImplemented = 0;

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("PAGELKSX")
#endif

SLEEP_STATE_CONTEXT HalpSleepContext = {0};
PVOID               HalpWakeVector  = NULL;
PVOID               HalpVirtAddrForFlush = NULL;
PVOID               HalpPteForFlush = NULL;
UCHAR               HalpRtcRegA;
UCHAR               HalpRtcRegB;

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("INIT")
#endif

UCHAR  rgzNoApicTable[]     = "HAL: No ACPI SAPIC Table Found\n";
UCHAR  HalpSzHackPci[]      = "VALID_PCI_RESOURCE";
UCHAR  HalpSzHackPrt[]      = "HACK_PRT_SUPPORT";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\osmchk.s ===
//###########################################################################
//**
//**  Copyright  (C) 1996-98 Intel Corporation. All rights reserved.
//**
//** The information and source code contained herein is the exclusive
//** property of Intel Corporation and may not be disclosed, examined
//** or reproduced in whole or in part without explicit written authorization
//** from the company.
//**
//###########################################################################

//-----------------------------------------------------------------------------
// Version control information follows.
//
// $Header:   I:/DEVPVCS/OSMCA/osmchk.s_v   2.1   05 Mar 1999 12:59:42   smariset  $
// $Log:   I:/DEVPVCS/OSMCA/osmchk.s_v  $
//
//   Rev 2.0   Dec 11 1998 11:42:18   khaw
//Post FW 0.5 release sync-up
//
//   Rev 1.4   12 Oct 1998 14:05:20   smariset
//gp fix up work around
//
///////////////////////////////////////////////////////////////////////////////
//
// Module Name:  OSMCHK.ASM - Merced OS Machine Check Abort Dispatcher
//
// Description:
//    Merced OS Machine Check Abort Stub to OSMCA "C" frame work.  If
//    we find a TLB related error, we cannot switch to virtual mode in
//    the OS.  All TLB related errors will need system reboot after 
//    storing the errors to a persistence storage media (HD or Flash).
//
//      HalpOsMcaDispatch               - Main
//
// Target Platform:  Merced
//
// Reuse: None
//
////////////////////////////////////////////////////////////////////////////M//
#include "ksia64.h"
#include "fwglobal.h"

        GLOBAL_FUNCTION(HalpOsMcaDispatch)
        GLOBAL_FUNCTION(HalpMCAEnable)
        GLOBAL_FUNCTION(HalpMcaHandler)
        GLOBAL_FUNCTION(HalpAcquireMcaSpinLock)
        GLOBAL_FUNCTION(HalpReleaseMcaSpinLock)

        .text
//++
// Name: HalpOsMcaDispatch()
// 
// Routine Description:
//
//      This is the OS call back handler, which is only exported to the SAL for call back 
//      during MCA errors. This handler will dispatch to the appropriate MCA procedure. 
//
//      Sets up virtual->physical address translation
//      0x00100000->0x00100000 in dtr1/itr1 for OS_MCA. 
//      
// Arguments:
//
//      None
//
// On entry:
//
//      This function is called:
//          - in physical mode for uncorrected or correctable MCA events,
//          - RSE enforced in lazy mode,
//          - Processor resources:
//      PSR.dt = 0, PSR.it = 0, PSR.rt = 0 - Physical mode.
//      PSR.ic = 0, PSR.i  = 0             - Interrupt resources collection and interrupt disabled.
//      PSR.mc = 1                         - Machine Checks masked
//      PSR.mfl = 0                        - low fp disabled.
//      GR1  : OS_MCA Global Pointer (GP) registered by OS: OS's GP.
//      GR2-7: Unspecified.
//      GR8  : Physical address of the PAL_PROC entrypoint.
//      GR9  : Physical address of the SAL_PROC entrypoint.
//      GR10 : Physical address value of the SAL Global Pointer: SAL's GP.
//      GR11 : Rendezvous state information, defined as:
//                0 - Rendezvous of other processors was not required by 
//                    PAL_CHECK and as such was not done.
//                1 - All other processors in the system were successfully 
//                    rendezvous using MC_RENDEZVOUS interrupt.
//                2 - All other processors in the system were successfully
//                    rendezvous using a combination of MC_RENDEZVOUS 
//                    interrupt and INIT.
//               -1 - Rendezvous of other processors was required by PAL 
//                    but was unsuccessful.
//      GR12 : Return address to a location within SAL_CHECK.
//      GR17 : Pointer to processor minimum state saved memory location.
//      GR18 : Processor state as defined below:
//          D0-D5:          Reserved
//          D6-D31:         As defined in PAL EAS
//          D60-D63:        As defined in PAL EAS
//          D32-D47:        Size in bytes of processor dynamic state
//          D48-D59:        Reserved.
//      GR19 : Return address to a location within PAL_CHECK. 
//      BR0  : Unspecified.
//
// Return State:
//
//      Note  : The OS_MCA procedure may or may not return to SAL_CHECK
//              in the case of uncorrected machine checks.
//              If it returns to SAL, the runtime convention requires that
//              it sets appropriate values in the Min-State area pointed
//              to by GR12 for continuing execution at the interrupted
//              context or at a new context.
//              Furthermore, the OS_MCA procedure must restore the 
//              processor state to the same state as on entry except as:
//      GR1-7  : Unspecified.
//      GR8    : Return status
//                0 [= SAL_STATUS_SUCCESS] - Error has been corrected 
//                    by OS_MCA.
//               -1 - Error has not been corrected by OS_MCA and
//                    SAL must warm boot the system.
//               -2 - Error has not been corrected by OS_MCA and 
//                    SAL must cold boot the system.
//               -3 - Error has not been corrected by OS_MCA and 
//                    SAL must halt the system.
//      GR9    : Physical address value for SAL's GP.
//      GR10   : Context flag
//                0 - Return will be to the same context.
//                1 - Return will be to a   new  context.
//      GR11-21: Unspecified.
//      GR22   : Pointer to a structure containing new values of registers 
//               in the Min-State Save area. 
//               OS_MCA must supply this parameter even if it does not 
//               change the register values in the Min-State Save areas.
//      GR23-31: Unspecified.
//      BR0    : Unspecified.
//      PSR.mc : May be either 0 or 1.
//--

HalpOsMcaDispatch::
   
      // aliases for known registers:
      
      rPalProcEntryPoint     = r8
      rSalProcEntryPoint     = r9
      rSalGlobalPointer      = r10
      rRendezVousResult      = r11
      rSalReturnAddress      = r12
      rProcMinStateSavePtr   = r17
      rProcStateParameter    = r18
      rPalCheckReturnAddress = r19
      rEventResources        = t22
      rPcrPhysicalAddress    = t6 
      
    //
    // - Flag the processor as "InOsMca":
    //   KiPcr.InOsMca = 1
    //
    // - Update KiPcr.McaPTOM to point to TopOfMemory, 
    //   Memory after Processor Minimum State Save area. 
    //
    // - Update processor McaResource.SalToOsHandOff
    //
    // - Update local rPcrMcaStateDump before calling osMcaProcStateDump.  
    //
    
      mov    rEventResources = PcOsMcaResourcePtr      
      movl   t21 = KiPcr
      ;;
      tpa    rPcrPhysicalAddress = t21           //  Calculate physical address of PCR
      mov    t19  = SerSalToOsHandOff
      mov    t1  = 0x1
      ;;
      add    t0 = rPcrPhysicalAddress, rEventResources      
      sub    t21 = rPcrPhysicalAddress, t21               
      add    t16  = TOM, rProcMinStateSavePtr
      ;;
      ld8    rEventResources = [t0], PcInOsMca-PcOsMcaResourcePtr
      mov    t18  = SerPTOM
      add    t20  = 0x8,  t19
      ;;        
      xchg1  t1  = [t0], t1
      add    rEventResources = rEventResources, t21          // Calculate the physical address of the OsMcaResources
      add    t21  = 0x10, t19
      ;;                    
      add    t18  = rEventResources, t18
      add    t19  = rEventResources, t19
      add    t20  = rEventResources, t20
      add    t21  = rEventResources, t21
      ;;
      ld8    t17  = [t16]
      st8    [t19] = rPalProcEntryPoint,  0x18
      add    t0 = SerStateDumpPhysical, rEventResources
      ;;
      st8    [t18] = t17
      st8    [t20] = rSalProcEntryPoint,  0x18
      st8    [t21] = rSalGlobalPointer,   0x18
      ;;
      st8    [t19] = rRendezVousResult
      st8    [t20] = rSalReturnAddress
      st8    [t21] = rProcMinStateSavePtr
      ld8    t0 = [t0]                                  // McaStateDump
      ;;

    
    //
    // Save in preserved registers:
    //     - pointer to processor minimum state save area, 
    //     - processor state parameter
    //     - PAL_CHECK return address.
    //   s0 [=r4] <- r17, 
    //   s1 [=r5] <- r18,
    //   s2 [=r6] <- r19
    //

        SaveRs(rProcMinStateSavePtr, rProcStateParameter, rPalCheckReturnAddress)

    //
    // Save register resources in myStateDump[].
    //

        br.dpnt     osMcaProcStateDump
        ;;

osMcaDoneDump::
        //
        // If we have a TLB error, we cannot enable translation
        //
        tbit.nz.unc pt0,p0=s1, 60  // PSP.tc=60
(pt0)   br.dpnt     ResetNow
        ;;                

    //
    // Initialize current sp and ar.bsp and ar.bspstore
    //
    //    KiPcr.McaStackFrame[0] = ar.rsc
    //    KiPcr.McaStackFrame[1] = ar.pfs
    //    KiPcr.McaStackFrame[2] = ar.ifs
    //    KiPcr.McaStackFrame[3] = ar.bspstore
    //    KiPcr.McaStackFrame[4] = ar.rnat
    //    ar.bspstore = t0 [=KiPcr.McaBspStore]
    //    KiPcr.McaStackFrame[5] = ar.bsp - KiPcr.McaBspStore 
    //      [BUGBUG ?? : should be ar.bsptore=KiPcr.McaStackFrame[3]] 
    //    sp = KiPcr.McaStack
    // 

      movl   t21 = KiPcr + PcOsMcaResourcePtr
      ;;
      tpa    t0 = t21           //  Calculate physical address of PCR OsMcaResourcePtr
      mov    t1 = SerStackFrame
      ;;
      sub    t16 = SerBackStore, t21      
      sub    t1 = t1, t21
      ;;
      add    t16 = t0, t16   
      add    t1 = t0, t1   
      ld8    rEventResources = [t0], PcInitialBStore - PcOsMcaResourcePtr
      ;;        
      add    t16 = rEventResources, t16   // Calculate physical address of the new BSP
      mov    t21 = t0                    // t21 now points to InitialBStore in the PCR
      ;;
      add    t1 = rEventResources, t1   // Calculate the physical address of the Stack Frame   
      ld8    t0 = [t16], SerStack - SerBackStore
      ;;
      SwIntCxt( t4, t1, t0 )
      ;;
      st8    [t21] = t0, PcInitialStack - PcInitialBStore  // Save the InitialBStore in the PCR
      ld8    t1 = [t16], SerBackStoreLimit - SerStack      // Get inital MCA stack
      ;;
      st8    [t21] = t1, PcBStoreLimit - PcInitialStack
      ld8    t0 = [t16], SerStackLimit - SerBackStoreLimit
      ;;
      add    t1 = -STACK_SCRATCH_AREA, t1
      st8    [t21] = t0, PcStackLimit - PcBStoreLimit     // Save BStore limit
      ld8    t18 = [t16]  
      ;;
      mov    sp = t1
      st8    [t21] = t18
      ;;
      
EnableTranslation::
// let us switch to virtual mode
//
//      Need to do a "rfi" in order set "it" and "ed" bits in the PSR.
//
//      Make sure interrupts are disabled and that we are running on bank 1.
//
        rsm       1 << PSR_I
        bsw.1
        ;;

        mov       ar.rsc = r0                  // put RSE in lazy mode and use kernel mode stores.
        
//
// psr mask prepration, warning we will have a problem with PMI here
//
        movl    t0  = MASK_IA64(PSR_BN,1) | MASK_IA64(PSR_IC,1) |MASK_IA64(PSR_DA,1) | MASK_IA64(PSR_IT,1) | MASK_IA64(PSR_RT,1) | MASK_IA64(PSR_DT,1) | MASK_IA64(PSR_MC,1);;
        mov     t1  = psr;;
        or      t0  = t0, t1
        movl    t1  = VirtualSwitchDone;;
        mov     cr.iip  = t1
        mov     cr.ipsr = t0;;
        rfi
        ;;

VirtualSwitchDone::
// done with enabling address translation
     
// call our handler
        movl        t0  = HalpMcaHandler;;
        mov         b6  = t0;;
        br.call.dpnt b0=b6
        ;;

DisableTranslation::
// psr mask prepration
        rsm     MASK_IA64(PSR_IC,1);;
        movl    t0 = MASK_IA64(PSR_DA,1) | MASK_IA64(PSR_IT,1) | MASK_IA64(PSR_RT,1) | MASK_IA64(PSR_DT,1);;
        movl    t1=0xffffffffffffffff;;
        xor     t0=t0,t1;;
        mov     t1=psr;;
        and     t0=t0,t1
        movl    t1=BeginOsMcaRestore;;
        tpa     t1=t1;;
        mov     cr.iip=t1;;
        mov     cr.ipsr = t0;;
        rfi
        ;;

BeginOsMcaRestore::
// restore the original stack frame here
        mov    t16 = SerStackFrame
        movl   t21 = KiPcr + PcOsMcaResourcePtr
        ;;
        tpa    t1 = t21           //  Calculate physical address of PCR OsMcaResourcePtr
        sub    t16 = t16, t21
        sub    t0 = SerStateDumpPhysical, t21
        ;;
        ld8    rEventResources = [t1]
        add    t16 = t1, t16
        add    t0 = t1, t0
        ;;        
        add    t16 = rEventResources, t16   // Calculate the physical address of the Stack Frame   
        add    t0 = rEventResources, t0   // Calculate the physical address of the State Dump pointer.
        ;;
        ld8    t0 = [t0];
        movl   t4 = PSRmcMask
        ;;
        RtnIntCxt( t4, t1, t16 )  // switch from interrupt context -> RSC mgmt.
        ;;

        //
        // let us restore all the registers from our PSI structure
        //
        
        mov     t6 = gp
        br.dpnt osMcaProcStateRestore
        ;;

osMcaDoneRestore::

        // Pal requires DFH of 0
        rsm         1 << PSR_DFH
        ;;
        rsm         1 << PSR_MFL  // just restoring to original state only
        ;;
        srlz.d
        ;;

     //
     // - Restore processor state from OsToSalHandOff. 
     //   
     // - Branch back to SALE_CHECK. 
     
      mov    t1 = PcOsMcaResourcePtr      
      movl   t21 = KiPcr
      ;;
      tpa    rPcrPhysicalAddress = t21           //  Calculate physical address of PCR
      ;;
      add    t0 = rPcrPhysicalAddress, t1      
      sub    t21 = SerOsToSalHandOff, t21               
      ;;
      ld8    t1 = [t0], PcInOsMca-PcOsMcaResourcePtr
      add    t21 = t21, rPcrPhysicalAddress
      ;;        
      add    t1 = t1, t21          // Calculate the physical address of the OsMcaResources->SalToOSHandOff
      ;;
      add    t16  = 0x8,  t1
      add    t17  = 0x10, t1
      ;;
      ld8    r8  = [t1], 0x18      // result of error handling
      ld8    r9  = [t16], 0x18      // physical SAL's GP value
      ld8    r22 = [t17]            // new Processor Min-State Save Ptr
      ;;
      ld8    t1 = [t1]         // SAL return address
      ld8    r10    = [t16]         // New Context Switch Flag
      xchg1  t0 = [t0], r0     // KiPcr.InOsMca = 0
      ;;
      mov     b0 = t1
      br.dpnt b0                       // Return to SALE_CHECK
      ;;
        
StayInPhysicalMode::
// we have to reboot the machine, assume the log is already there in NVM
// OS can read the log next time when it comes around.  Or OS can try to
// run in physical mode as well.

ResetNow::
//      do EFI system reset here...
//      Go to BugCheck (in physical mode). 
//      Out to Port 80: Fatal TLB error
//

Thyself::        
        br          Thyself                     // loop for safety      
        ;;


//EndMain//////////////////////////////////////////////////////////////////////


//++
// Name:
//      osMcaProcStateDump()
// 
// Stub Description:
//
//       This stub dumps the processor state during MCHK to a data area
//
// On Entry:
//
//       t0 = rPcrMcaStateDump.
//
// Return Value:
//
//       None.
//
//--

osMcaProcStateDump::
// Get and save GR0-31 from Proc. Min. State Save Area to SAL PSI
        
// TF: ASSERT( t0 == rPcrMcaStateDump )

//save BRs
        add         t2=Inc8,t0                  // duplicate t0 in t2
        add         t4=2*Inc8,t0                // duplicate t0 in t2

        mov         t1=b0
        mov         t3=b1
        mov         t5=b2;;
        st8         [t0]=t1,3*Inc8
        st8         [t2]=t3,3*Inc8
        st8         [t4]=t5,3*Inc8;;  

        mov         t1=b3
        mov         t3=b4
        mov         t5=b5;;
        st8         [t0]=t1,3*Inc8
        st8         [t2]=t3,3*Inc8
        st8         [t4]=t5,3*Inc8;;  

        mov         t1=b6
        mov         t3=b7;;
        st8         [t0]=t1,2*Inc8
        st8         [t2]=t3,2*Inc8;;

cSaveCRs::
// save CRs
        add         t2=Inc8,t0                  // duplicate t0 in t2
        add         t4=2*Inc8,t0                // duplicate t0 in t2

        mov         t1=cr0                      // cr.dcr
        mov         t3=cr1                      // cr.itm
        mov         t5=cr2;;                    // cr.iva

        st8         [t0]=t1,8*Inc8
        st8         [t2]=t3,3*Inc8
        st8         [t4]=t5,3*Inc8;;            // 48 byte increments

        mov         t1=cr8;;                    // cr.pta
        st8         [t0]=t1,Inc8*8;;            // 64 byte increments

// Reading interruption registers when PSR.ic=1 causes an illegal operation fault
        mov         t1=psr;;
        tbit.nz.unc pt0,p0=t1,PSRic;;           // PSI Valid Log bit pos. test
(pt0)   st8         [t0]=r0;;                   
(pt0)   adds        t0 = 0x30*Inc8, t0          // cr16->cr64 increment
(pt0)   br.dpnt     SkipIntrRegs
        ;;

        add         t2=Inc8,t0                  // duplicate t0 in t2
        add         t4=2*Inc8,t0                // duplicate t0 in t4
        
        mov         t1=cr16                     // cr.ipsr
        mov         t3=cr17                     // cr.isr
        mov         t5=r0;;                     // cr.ida => cr18
        st8         [t0]=t1,3*Inc8
        st8         [t2]=t3,3*Inc8
        st8         [t4]=t5,3*Inc8;;                                      

        mov         t1=cr19                     // cr.iip
        mov         t3=cr20                     // cr.ifa  
        mov         t5=cr21;;                   // cr.iitr
        st8         [t0]=t1,3*Inc8
        st8         [t2]=t3,3*Inc8
        st8         [t4]=t5,3*Inc8;;                                      

        mov         t1=cr22                     // cr.iipa
        mov         t3=cr23                     // cr.ifs
        mov         t5=cr24;;                   // cr.iim
        st8         [t0]=t1,3*Inc8
        st8         [t2]=t3,3*Inc8
        st8         [t4]=t5,3*Inc8;;    
                                          
        mov         t1=cr25;;                   // cr.iha
        st8         [t0]=t1;;
        adds        t0 = 0x27*Inc8, t0;;        // cr25->cr64 byte increment

SkipIntrRegs::
        mov         t1=cr64;;                   // cr.lid
        st8         [t0]=t1,Inc8                // 

        mov         t1=cr65;;                   // cr.ivr
        st8         [t0]=t1,Inc8

        mov         t1=cr66;;                   // cr.tpr
        st8         [t0]=t1,Inc8                
    
        mov         t1=r0;;                     // cr.eoi
        st8         [t0]=t1,Inc8                // 
    
        mov         t1=r0;;                     // cr.irr0 
        st8         [t0]=t1,Inc8             

        mov         t1=r0;;                     // cr.irr1 
        st8         [t0]=t1,Inc8              

        mov         t1=r0;;                     // cr.irr2 
        st8         [t0]=t1,Inc8               

        mov         t1=r0;;                     // cr.irr3 
        st8         [t0]=t1,Inc8                

        mov         t1=r0;;                     // cr.itv 
        st8         [t0]=t1,Inc8              

        mov         t1=r0;;                     // cr.pmv 
        st8         [t0]=t1,Inc8

        mov         t1=r0;;                     // cr.cmcv 
        st8         [t0]=t1,6*Inc8

        mov         t1=r0;;                     // cr.lrr0 
        st8         [t0]=t1,Inc8

        mov         t1=r0;;                     // cr.lrr1 
        st8         [t0]=t1;;                  
        adds        t0 = 0x2f*Inc8, t0;;        // cr81->ar [128]

cSaveARs::
// save ARs
        add         t2=Inc8,t0                  // duplicate t0 in t2
        add         t4=2*Inc8,t0                // duplicate t0 in t4

        mov         t1=ar0                      // ar.kr0
        mov         t3=ar1                      // ar.kr1
        mov         t5=ar2;;                    // ar.kr2
        st8         [t0]=t1,3*Inc8
        st8         [t2]=t3,3*Inc8
        st8         [t4]=t5,3*Inc8;;

        mov         t1=ar3                      // ar.kr3                               
        mov         t3=ar4                      // ar.kr4
        mov         t5=ar5;;                    // ar.kr5
        st8         [t0]=t1,3*Inc8
        st8         [t2]=t3,3*Inc8
        st8         [t4]=t5,13*Inc8;;           // ar5->ar18

        mov         t1=ar6                      // ar.kr6
        mov         t3=ar7;;                    // ar.kr7
        st8         [t0]=t1,10*Inc8
        st8         [t2]=t3,10*Inc8;;

        mov         t1=ar16                     // ar.rsc
        mov         t3=ar17                     // ar.bsp
        mov         t5=ar18;;                   // ar.bspstore
        st8         [t0]=t1,3*Inc8
        st8         [t2]=t3,3*Inc8
        st8         [t4]=t5,3*Inc8;;

        mov         t1=ar19;;                   // ar.rnat
        st8         [t0]=t1,Inc8*13             // increment by 13x8 bytes

        mov         t1=ar32;;                   // ar.ccv
        st8         [t0]=t1,Inc8*4

        mov         t1=ar36;;                   // ar.unat
        st8         [t0]=t1,Inc8*4

        mov         t1=ar40;;                   // ar.fpsr
        st8         [t0]=t1,Inc8*4

        mov         t1=ar44;;                   // ar.itc
        st8         [t0]=t1,160                 // 160

        mov         t1=ar64;;                   // ar.pfs
        st8         [t0]=t1,Inc8

        mov         t1=ar65;;                   // ar.lc
        st8         [t0]=t1,Inc8

        mov         t1=ar66;;                   // ar.ec
        st8         [t0]=t1
        adds        t0=Inc8*62,t0               //padding
    
// save RRs
        mov         ar.lc=0x08-1
        movl        t2=0x00;;

cStRR::
        mov         t1=rr[t2];;
        st8         [t0]=t1,Inc8
        add         t2=1,t2
        br.cloop.dpnt cStRR
        ;;

// align memory addresses to 16 bytes
        and         t1=0x0f,t0;;
        cmp.ne.unc  pt0,p0=t1,r0;;
(pt0)   add         t0=Inc8,t0

cSaveFRs::
// just save FP for MCA restore only, "C" code will trash f6-f15
// save ar.NaT 
        mov         t3=ar.unat;;                 // ar.unat

        stf.spill   [t0]=f6,Inc16;;
        stf.spill   [t0]=f7,Inc16;;
        stf.spill   [t0]=f8,Inc16;;
        stf.spill   [t0]=f9,Inc16;;
        stf.spill   [t0]=f10,Inc16;;
        stf.spill   [t0]=f11,Inc16;;
        stf.spill   [t0]=f12,Inc16;;
        stf.spill   [t0]=f13,Inc16;;
        stf.spill   [t0]=f14,Inc16;;
        stf.spill   [t0]=f15,Inc16;;

        mov         t2=ar.unat;;
        st8         [t0]=t2,Inc8                // save User NaT bits for r16-r31
        mov         ar.unat=t3                  // restore original unat

        br.dpnt     osMcaDoneDump
        ;;

//EndStub//////////////////////////////////////////////////////////////////////


//++
// Name:
//       osMcaProcStateRestore()
// 
// Stub Description:
//
//       This is a stub to restore the saved processor state during MCHK
//
// On Entry:
//
//       t0 = rPcrMcaStateDump.
//
// Return Value:
//
//       None.
//--

osMcaProcStateRestore::

// TF: ASSERT( t0 == rPcrMcaStateDump )

restore_BRs::
        add         t2=Inc8,t0                  // duplicate t0 in t2
        add         t4=2*Inc8,t0;;              // duplicate t0 in t2

        ld8         t1=[t0],3*Inc8
        ld8         t3=[t2],3*Inc8
        ld8         t5=[t4],3*Inc8;;  
        mov         b0=t1
        mov         b1=t3
        mov         b2=t5;;

        ld8         t1=[t0],3*Inc8
        ld8         t3=[t2],3*Inc8
        ld8         t5=[t4],3*Inc8;;  
        mov         b3=t1
        mov         b4=t3
        mov         b5=t5;;

        ld8         t1=[t0],2*Inc8
        ld8         t3=[t2],2*Inc8;;  
        mov         b6=t1
        mov         b7=t3;;

restore_CRs::
        add         t2=Inc8,t0                  // duplicate t0 in t2
        add         t4=2*Inc8,t0;;              // duplicate t0 in t2

        ld8         t1=[t0],8*Inc8
        ld8         t3=[t2],3*Inc8
        ld8         t5=[t4],3*Inc8;;            // 48 byte increments
        mov         cr0=t1                      // cr.dcr
        mov         cr1=t3                      // cr.itm
        mov         cr2=t5;;                    // cr.iva

        ld8         t1=[t0],8*Inc8;;            // 64 byte increments
//      mov         cr8=t1                      // cr.pta


// if PSR.ic=1, reading interruption registers causes an illegal operation fault
        mov         t1=psr;;
        tbit.nz.unc pt0,p0=t1,PSRic;;           // PSI Valid Log bit pos. test
(pt0)   st8         [t0]=r0,9*8+160             // increment by 160 byte inc.
(pt0)   br.dpnt     rSkipIntrRegs
        ;;

        add         t2=Inc8,t0                  // duplicate t0 in t2
        add         t4=2*Inc8,t0;;              // duplicate t0 in t2

        ld8         t1=[t0],3*Inc8
        ld8         t3=[t2],3*Inc8
        ld8         t5=[t4],3*Inc8;;
        mov         cr16=t1                     // cr.ipsr
        mov         cr17=t3                     // cr.isr is read only
//      mov         cr18=t5;;                   // cr.ida

        ld8         t1=[t0],3*Inc8
        ld8         t3=[t2],3*Inc8
        ld8         t5=[t4],3*Inc8;;
        mov         cr19=t1                     // cr.iip
        mov         cr20=t3                     // cr.idtr
        mov         cr21=t5;;                   // cr.iitr

        ld8         t1=[t0],3*Inc8
        ld8         t3=[t2],3*Inc8
        ld8         t5=[t4],3*Inc8;;
        mov         cr22=t1                     // cr.iipa
        mov         cr23=t3                     // cr.ifs
        mov         cr24=t5                     // cr.iim

        ld8         t1=[t0],160;;               // 160 byte increment
        mov         cr25=t1                     // cr.iha 

rSkipIntrRegs::
        ld8         t1=[t0],168;;               // another 168 byte inc.

        ld8         t1=[t0],40;;                // 40 byte increment
        mov         cr66=t1                     // cr.lid

        ld8         t1=[t0],Inc8;;
//      mov         cr71=t1                     // cr.ivr is read only
        ld8         t1=[t0],24;;                // 24 byte increment
        mov         cr72=t1                     // cr.tpr
   
        ld8         t1=[t0],168;;               // 168 byte inc.
//      mov         cr75=t1                     // cr.eoi
   
        ld8         t1=[t0],Inc16;;             // 16 byte inc.
//      mov         cr96=t1                     // cr.irr0 is read only

        ld8         t1=[t0],Inc16;;             // 16 byte inc.
//      mov         cr98=t1                     // cr.irr1 is read only

        ld8         t1=[t0],Inc16;;             // 16 byte inc
//      mov         cr100=t1                    // cr.irr2 is read only

        ld8         t1=[t0],Inc16;;             // 16b inc.
//      mov         cr102=t1                    // cr.irr3 is read only

        ld8         t1=[t0],Inc16;;             // 16 byte inc.
//      mov         cr114=t1                    // cr.itv

        ld8         t1=[t0],Inc8;;
//      mov         cr116=t1                    // cr.pmv
        ld8         t1=[t0],Inc8;;
//      mov         cr117=t1                    // cr.lrr0
        ld8         t1=[t0],Inc8;;
//      mov         cr118=t1                    // cr.lrr1
        ld8         t1=[t0],Inc8*10;;
//      mov         cr119=t1                    // cr.cmcv

restore_ARs::
        add         t2=Inc8,t0                  // duplicate t0 in t2
        add         t4=2*Inc8,t0;;              // duplicate t0 in t2

        ld8         t1=[t0],3*Inc8
        ld8         t3=[t2],3*Inc8
        ld8         t5=[t4],3*Inc8;;
        mov         ar0=t1                      // ar.kro
        mov         ar1=t3                      // ar.kr1
        mov         ar2=t5;;                    // ar.kr2

        ld8         t1=[t0],3*Inc8
        ld8         t3=[t2],3*Inc8
        ld8         t5=[t4],3*Inc8;;
        mov         ar3=t1                      // ar.kr3                               
        mov         ar4=t3                      // ar.kr4
        mov         ar5=t5;;                    // ar.kr5

        ld8         t1=[t0],10*Inc8
        ld8         t3=[t2],10*Inc8
        ld8         t5=[t4],10*Inc8;;
        mov         ar6=t1                      // ar.kr6
        mov         ar7=t3                      // ar.kr7
//      mov         ar8=t4                      // ar.kr8
        ;;

        ld8         t1=[t0],3*Inc8
        ld8         t3=[t2],3*Inc8
        ld8         t5=[t4],3*Inc8;;
//      mov         ar16=t1                     // ar.rsc
//      mov         ar17=t3                     // ar.bsp is read only
        mov         ar18=t5;;                   // ar.bspstore

        ld8         t1=[t0],Inc8*13;;
        mov         ar19=t1                     // ar.rnat

        ld8         t1=[t0],Inc8*4;;
        mov         ar32=t1                     // ar.ccv

        ld8         t1=[t0],Inc8*4;;
        mov         ar36=t1                     // ar.unat

        ld8         t1=[t0],Inc8*4;;
        mov         ar40=t1                     // ar.fpsr

        ld8         t1=[t0],160;;               // 160
//      mov         ar44=t1                     // ar.itc

        ld8         t1=[t0],Inc8;;
        mov         ar64=t1                     // ar.pfs

        ld8         t1=[t0],Inc8;;
        mov         ar65=t1                     // ar.lc

        ld8         t1=[t0];;
        mov         ar66=t1                     // ar.ec
        adds        t0=Inc8*62,t0;;             // padding 
    
restore_RRs::
        mov         t3=ar.lc
        mov         ar.lc=0x08-1
        movl        t2=0x00
cStRRr::
        ld8         t1=[t0],Inc8;;
//      mov         rr[t2]=t1                   // what are its access previledges?
        add         t2=1,t2
        br.cloop.dpnt cStRRr
        ;;
        mov         ar.lc=t3

// align memory addresses to 16 bytes
        and         t1=0x0f,t0;;
        cmp.ne.unc  pt0,p0=t1,r0;;
(pt0)   add         t0=Inc8,t0;;

// restore FP's which might be trashed by the "C" code
        mov         t3=ar.unat
        add         t1=16*10,t0;;                // to get to NaT of GR 16-31
        ld8         t1=[t1];;
        mov         ar.unat=t1;;                // first restore NaT

restore_FRs::
        ldf.fill    f6=[t0],Inc16;;
        ldf.fill    f7=[t0],Inc16;;
        ldf.fill    f8=[t0],Inc16;;
        ldf.fill    f9=[t0],Inc16;;
        ldf.fill    f10=[t0],Inc16;;
        ldf.fill    f11=[t0],Inc16;;
        ldf.fill    f12=[t0],Inc16;;
        ldf.fill    f13=[t0],Inc16;;
        ldf.fill    f14=[t0],Inc16;;
        ldf.fill    f15=[t0],Inc16;;

        mov         ar.unat=t3                  // restore original NaT

        br.dpnt     osMcaDoneRestore
        ;;

//EndStub//////////////////////////////////////////////////////////////////////

//++
// VOID
// HalpAcquireMcaSpinLock (
//    IN PKSPIN_LOCK SpinLock
//    )
//
// Routine Description:
//
//    This function acquires a MCA spin lock.
//    This function does not modify the interrupt state or the IRQL.
//
//    N.B: This function does *NOT* replace KiAcquireSpinLock but 
//         allows us to place it in a locked MCA specific section.
//
// Arguments:
//
//    SpinLock (a0) - Supplies a pointer to a MCA spin lock.
//
// Return Value:
//
//    None.
//
//--

        .align      16

        LEAF_ENTRY(HalpAcquireMcaSpinLock)

#if !defined(NT_UP)

        ACQUIRE_SPINLOCK(a0,a0,Halpasl10)

        br.ret.dptk brp
        ;;

#else

        LEAF_RETURN

#endif // !defined(NT_UP)

        LEAF_EXIT(HalpAcquireMcaSpinLock)

//EndProc//////////////////////////////////////////////////////////////////////

//++
// VOID
// HalpReleaseMcaSpinLock (
//    IN PKSPIN_LOCK SpinLock
//    )
//
// Routine Description:
//
//    This function release a MCA spin lock.
//    This function does not modify the interrupt state or the IRQL.
//
//    N.B: This function does *NOT* replace KiReleaseSpinLock but
//         allows us to place it in a locked MCA specific section.
//
// Arguments:
//
//    SpinLock (a0) - Supplies a pointer to a MCA spin lock.
//
// Return Value:
//
//    None.
//
//--

        .align      16

        LEAF_ENTRY(HalpReleaseMcaSpinLock)

#if !defined(NT_UP)
        st8.rel     [a0] = zero             // set spin lock not owned
#endif

        LEAF_RETURN
        LEAF_EXIT(HalpReleaseMcaSpinLock)

//EndProc//////////////////////////////////////////////////////////////////////


//++
// Name:
//      HalpMCAEnable()
// 
// Routine Description:
//
//      This procedure enables MCA resources that are not already enabled. 
//
// Arguments:
//
//      None  
//
// Return value:
//    
//      None
//      
//--
        .align      16
        .proc       HalpMCAEnable
HalpMCAEnable::
        NESTED_SETUP(0,2,0,0);;

// nothing right now...

        NESTED_RETURN
        .endp       HalpMCAEnable 

//EndProc//////////////////////////////////////////////////////////////////////

#if DBG

//++
// Name:
//      HalpGenerateMce()
//
// Routine Description:
//
//      This proc. generates Machine Check Events for testing.
//
// Arguments:
//
//      None
//
// Return value:
//
//      None
//
//--
        .align      16
#define HALP_DBG_GENERATE_MCA_L0D   456
#define HALP_DBG_GENERATE_CMC_L1ECC 490

        LEAF_ENTRY(HalpGenerateMce)

HalpGenerateMcaL0d:
//
// Thierry - 05/20/00. This code generates an Itanium processor L0D MCA.
// It is particularly useful when debugging the OS_MCA path.
//
        mov t1 = HALP_DBG_GENERATE_MCA_L0D
        ;;
        cmp.ne pt0, pt1 = a0, t1
(pt0)   br.sptk HalpGenerateCmcL1Ecc1
        ;;
        mov  t0 = msr[t1]
        movl t2 = 0x1d1
        ;;
        mf.a // drain bus transactions
        or  t0 = t2, t0
        ;;
        mov msr[t1] = t0

HalpGenerateCmcL1Ecc1:
//
// Thierry - 04/08/01. This code generates an Itanium processor L1 1 bit ECC.
// It is particularly useful when debugging the OS/Kernel WMI/OEM CMC driver paths.
//
        mov t1 = HALP_DBG_GENERATE_CMC_L1ECC
        ;;
        cmp.ne pt0, pt1 = a0, t1
(pt0)   br.sptk HalpGenerateOtherMce
        ;;
// Setting the valid bit (bit 7), cmci pend bit(4) and L1 1xEcc bit (14)
        mov t0 = msr[t1]
        mov t2 = 0x4090 
        ;;
        dep t0 = t2, t0, 0, 0xf
        ;;
        mov msr[t1] = t0

HalpGenerateOtherMce:
        // none for now...

        LEAF_RETURN
        LEAF_EXIT(HalpGenerateMce)

//EndProc//////////////////////////////////////////////////////////////////////

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\pmbus.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pmbus.c

Abstract:

    Implements functions that were done in
    previous HALs by bus handlers.  Basically,
    these will be somewhat simplified versions
    since much of the code in the bus handlers
    has effectively been moved into bus 
    drivers in NT5.

Author:

    Jake Oshins (jakeo) 1-Dec-1997

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "pci.h"
#include "pcip.h"

ULONG HalpGetCmosData (
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    );

ULONG HalpSetCmosData (
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    );

HalpGetEisaData (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG
HalpGetSystemInterruptVector (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG InterruptLevel,
    IN ULONG InterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    );

NTSTATUS
HalpAssignSlotResources (
    IN PUNICODE_STRING          RegistryPath,
    IN PUNICODE_STRING          DriverClassName       OPTIONAL,
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           DeviceObject          OPTIONAL,
    IN INTERFACE_TYPE           BusType,
    IN ULONG                    BusNumber,
    IN ULONG                    SlotNumber,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    );

BOOLEAN
HalpTranslateBusAddress(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

BOOLEAN
HalpFindBusAddressTranslation(
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress,
    IN OUT PULONG_PTR Context,
    IN BOOLEAN NextBus
    );

extern BUS_HANDLER  HalpFakePciBusHandler;
extern ULONG        HalpMinPciBus;
extern ULONG        HalpMaxPciBus;
extern ULONG HalpPicVectorRedirect[];


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpInitNonBusHandler)
#pragma alloc_text(PAGE,HalpAssignSlotResources)

#if !defined(NO_LEGACY_DRIVERS)
#pragma alloc_text(PAGE,HalAssignSlotResources)
#endif

#endif

VOID
HalpInitNonBusHandler (
    VOID
    )
{
    HALPDISPATCH->HalPciTranslateBusAddress = HalpTranslateBusAddress;
    HALPDISPATCH->HalPciAssignSlotResources = HalpAssignSlotResources;
    HALPDISPATCH->HalFindBusAddressTranslation = HalpFindBusAddressTranslation;
}


#if !defined(NO_LEGACY_DRIVERS)

NTSTATUS
HalAdjustResourceList (
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST   *pResourceList
    )
{
    return STATUS_SUCCESS;
}

ULONG
HalGetBusData(
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    )
{
    return HalGetBusDataByOffset (BusDataType,BusNumber,SlotNumber,Buffer,0,Length);
}

#endif // NO_LEGACY_DRIVERS

ULONG
HalGetBusDataByOffset (
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    Dispatcher for GetBusData

--*/
{
    PCI_SLOT_NUMBER slot;
    BUS_HANDLER bus;
    ULONG length;
    
    switch (BusDataType) {
    case PCIConfiguration:

        //
        // Hack.  If the bus is outside of the known PCI busses, return
        // a length of zero.
        //

        if ((BusNumber < HalpMinPciBus) || (BusNumber > HalpMaxPciBus)) {
            return 0;
        }

        RtlCopyMemory(&bus, &HalpFakePciBusHandler, sizeof(BUS_HANDLER));
        bus.BusNumber = BusNumber;
        slot.u.AsULONG = SlotNumber;
    
        length = HalpGetPCIData(&bus,
                                &bus,
                                slot,
                                Buffer,
                                Offset,
                                Length
                                );
        
        return length;

    case Cmos:
        return HalpGetCmosData(0, SlotNumber, Buffer, Length);

#ifdef EISA_SUPPORTED
    case EisaConfiguration:

        //
        // Fake a bus handler.
        //
        
        bus.BusNumber = 0;

        return HalpGetEisaData(&bus,
                               &bus,
                               SlotNumber,
                               Buffer,
                               Offset,
                               Length
                               );
#endif

    default:
        return 0;
    }
}

#if !defined(NO_LEGACY_DRIVERS)

ULONG
HalSetBusData(
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Length
    )
{
    return HalSetBusDataByOffset (BusDataType,BusNumber,SlotNumber,Buffer,0,Length);
}

#endif // NO_LEGACY_DRIVERS

ULONG
HalSetBusDataByOffset(
    IN BUS_DATA_TYPE  BusDataType,
    IN ULONG BusNumber,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
/*++

Routine Description:

    Dispatcher for SetBusData

--*/
{
    PCI_SLOT_NUMBER slot;
    BUS_HANDLER bus;

    switch (BusDataType) {
    case PCIConfiguration:

        RtlCopyMemory(&bus, &HalpFakePciBusHandler, sizeof(BUS_HANDLER));
        bus.BusNumber = BusNumber;
        slot.u.AsULONG = SlotNumber;

        return HalpSetPCIData(&bus,
                              &bus,
                              slot,
                              Buffer,
                              Offset,
                              Length
                              );
    case Cmos:

        return HalpSetCmosData(0, SlotNumber, Buffer, Length);

    default:
        return 0;
    }
}

#if !defined(NO_LEGACY_DRIVERS)

NTSTATUS
HalAssignSlotResources (
    IN PUNICODE_STRING          RegistryPath,
    IN PUNICODE_STRING          DriverClassName       OPTIONAL,
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           DeviceObject          OPTIONAL,
    IN INTERFACE_TYPE           BusType,
    IN ULONG                    BusNumber,
    IN ULONG                    SlotNumber,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    )
{
    if (BusType == PCIBus) {
        //
        // Call through the HAL private dispatch table
        // for PCI-related translations.  This is part 
        // of transitioning the HAL out of the bus 
        // management business.
        //
        return HALPDISPATCH->HalPciAssignSlotResources(RegistryPath,
                                                       DriverClassName,
                                                       DriverObject,
                                                       DeviceObject,
                                                       BusType,
                                                       BusNumber,
                                                       SlotNumber,
                                                       AllocatedResources);
    } else {

        return HalpAssignSlotResources(RegistryPath,
                                       DriverClassName,
                                       DriverObject,
                                       DeviceObject,
                                       BusType,
                                       BusNumber,
                                       SlotNumber,
                                       AllocatedResources);
    }
}

#endif // NO_LEGACY_DRIVERS

NTSTATUS
HalpAssignSlotResources (
    IN PUNICODE_STRING          RegistryPath,
    IN PUNICODE_STRING          DriverClassName       OPTIONAL,
    IN PDRIVER_OBJECT           DriverObject,
    IN PDEVICE_OBJECT           DeviceObject          OPTIONAL,
    IN INTERFACE_TYPE           BusType,
    IN ULONG                    BusNumber,
    IN ULONG                    SlotNumber,
    IN OUT PCM_RESOURCE_LIST   *AllocatedResources
    )
/*++

Routine Description:

    Dispatcher for AssignSlotResources

--*/
{
    BUS_HANDLER busHand;
    
    PAGED_CODE();
    
    switch (BusType) {
    case PCIBus:

        //
        // Fake a bus handler.
        //
    
        RtlCopyMemory(&busHand, &HalpFakePciBusHandler, sizeof(BUS_HANDLER));
        busHand.BusNumber = BusNumber;

        return HalpAssignPCISlotResources(&busHand,
                                          &busHand,
                                          RegistryPath,
                                          DriverClassName,
                                          DriverObject,
                                          DeviceObject,
                                          SlotNumber,
                                          AllocatedResources);

    default:
        return STATUS_NOT_IMPLEMENTED;
    }
    
}

#if !defined(NO_LEGACY_DRIVERS)


ULONG
HalGetInterruptVector(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    )
/*++

Routine Description:

    Dispatcher for GetInterruptVector

--*/
{
    BUS_HANDLER busHand;

    //
    // If this is an ISA vector, pass it through the ISA vector
    // redirection table.
    //

    if (InterfaceType == Isa) {

        ASSERT(BusInterruptVector < PIC_VECTORS);

        BusInterruptVector = HalpPicVectorRedirect[BusInterruptVector];
        BusInterruptLevel = HalpPicVectorRedirect[BusInterruptLevel];
    }
    
    //
    // Fake bus handlers.
    //

    RtlCopyMemory(&busHand, &HalpFakePciBusHandler, sizeof(BUS_HANDLER));
    
    busHand.BusNumber = BusNumber;
    busHand.InterfaceType = InterfaceType;
    busHand.ParentHandler = &busHand;
    
    return HalpGetSystemInterruptVector(&busHand,
                                        &busHand,
                                        BusInterruptLevel,
                                        BusInterruptVector,
                                        Irql,
                                        Affinity);
}

#endif // NO_LEGACY_DRIVERS


BOOLEAN
HalTranslateBusAddress(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )
{
    if (InterfaceType == PCIBus) {
        //
        // Call through the HAL private dispatch table
        // for PCI-related translations.  This is part 
        // of transitioning the HAL out of the bus 
        // management business.
        //
        return HALPDISPATCH->HalPciTranslateBusAddress(InterfaceType,
                                                       BusNumber,
                                                       BusAddress,
                                                       AddressSpace,
                                                       TranslatedAddress);
    } else {
        return HalpTranslateBusAddress(InterfaceType,
                                       BusNumber,
                                       BusAddress,
                                       AddressSpace,
                                       TranslatedAddress);
    }
};

BOOLEAN
HalpTranslateBusAddress(
    IN INTERFACE_TYPE  InterfaceType,
    IN ULONG BusNumber,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    )
/*++

Routine Description:

    Dispatcher for TranslateBusAddress

--*/
{
   
    //*(&TranslatedAddress->QuadPart) = BusAddress.QuadPart;
    *(&TranslatedAddress->LowPart) = BusAddress.LowPart;
    *(&TranslatedAddress->HighPart) = BusAddress.HighPart;
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\pmisabus.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pmapic.c

Abstract:

    Implements functions specific to ISA busses
    in ACPI-APIC machines.

Author:

    Jake Oshins (jakeo) 11-October-1997

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "acpitabl.h"

NTSTATUS
TranslateGlobalVectorToIsaVector(
    IN  ULONG   GlobalVector,
    OUT PULONG  IsaVector
    );

NTSTATUS
HalacpiIrqTranslateResourceRequirementsIsa(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    );

NTSTATUS
HalacpiIrqTranslateResourcesIsa(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    );

extern ULONG HalpPicVectorRedirect[];
extern FADT HalpFixedAcpiDescTable;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, TranslateGlobalVectorToIsaVector)
#pragma alloc_text(PAGE, HalacpiIrqTranslateResourceRequirementsIsa)
#pragma alloc_text(PAGE, HalacpiIrqTranslateResourcesIsa)
#pragma alloc_text(PAGE, HalacpiGetInterruptTranslator)
#endif

#define TranslateIsaVectorToGlobalVector(vector)  \
            (HalpPicVectorRedirect[vector])

NTSTATUS
TranslateGlobalVectorToIsaVector(
    IN  ULONG   GlobalVector,
    OUT PULONG  IsaVector
    )
{
    UCHAR   i;

    for (i = 0; i < PIC_VECTORS; i++) {

        if (HalpPicVectorRedirect[i] == GlobalVector) {

            *IsaVector = i;

            return STATUS_SUCCESS;
        }
    }

    return STATUS_NOT_FOUND;
}


NTSTATUS
HalacpiIrqTranslateResourceRequirementsIsa(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    )
/*++

Routine Description:

    This function is basically a wrapper for
    HalIrqTranslateResourceRequirementsRoot that understands
    the weirdnesses of the ISA bus.

Arguments:

Return Value:

    status

--*/
{
    PIO_RESOURCE_DESCRIPTOR modSource, target, rootTarget;
    NTSTATUS                status;
    BOOLEAN                 deleteResource;
    ULONG                   sourceCount = 0;
    ULONG                   targetCount = 0;
    ULONG                   resource, resourceLength;
    ULONG                   rootCount;
    ULONG                   irq, startIrq, endIrq;
    ULONG                   maxTargets;

    PAGED_CODE();
    ASSERT(Source->Type == CmResourceTypeInterrupt);

    maxTargets = Source->u.Interrupt.MaximumVector -
                     Source->u.Interrupt.MinimumVector + 3;

    resourceLength = sizeof(IO_RESOURCE_DESCRIPTOR) * maxTargets;

    modSource = ExAllocatePoolWithTag(PagedPool, resourceLength, HAL_POOL_TAG);

    if (!modSource) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(modSource, resourceLength);

    //
    // Is the PIC_SLAVE_IRQ in this resource?
    //
    if ((Source->u.Interrupt.MinimumVector <= PIC_SLAVE_IRQ) &&
        (Source->u.Interrupt.MaximumVector >= PIC_SLAVE_IRQ)) {

        //
        // Clip the maximum
        //
        if (Source->u.Interrupt.MinimumVector < PIC_SLAVE_IRQ) {

            modSource[sourceCount] = *Source;

            modSource[sourceCount].u.Interrupt.MinimumVector =
                Source->u.Interrupt.MinimumVector;

            modSource[sourceCount].u.Interrupt.MaximumVector =
                PIC_SLAVE_IRQ - 1;

            sourceCount++;
        }

        //
        // Clip the minimum
        //
        if (Source->u.Interrupt.MaximumVector > PIC_SLAVE_IRQ) {

            modSource[sourceCount] = *Source;

            modSource[sourceCount].u.Interrupt.MaximumVector =
                Source->u.Interrupt.MaximumVector;

            modSource[sourceCount].u.Interrupt.MinimumVector =
                PIC_SLAVE_IRQ + 1;

            sourceCount++;
        }

        //
        // In ISA machines, the PIC_SLAVE_IRQ is rerouted
        // to PIC_SLAVE_REDIRECT.  So find out if PIC_SLAVE_REDIRECT
        // is within this list. If it isn't we need to add it.
        //
        if (!((Source->u.Interrupt.MinimumVector <= PIC_SLAVE_REDIRECT) &&
             (Source->u.Interrupt.MaximumVector >= PIC_SLAVE_REDIRECT))) {

            modSource[sourceCount] = *Source;

            modSource[sourceCount].u.Interrupt.MinimumVector = PIC_SLAVE_REDIRECT;
            modSource[sourceCount].u.Interrupt.MaximumVector = PIC_SLAVE_REDIRECT;

            sourceCount++;
        }

    } else {

        *modSource = *Source;
        sourceCount = 1;
    }

    //
    // Clip out the SCI vector, if it is here.
    //

    for (resource = 0; resource < sourceCount; resource++) {

        if ((modSource[resource].u.Interrupt.MinimumVector <=
                HalpFixedAcpiDescTable.sci_int_vector) &&
            (modSource[resource].u.Interrupt.MaximumVector >=
                HalpFixedAcpiDescTable.sci_int_vector)) {

            //
            // The SCI vector is within this range.
            //

            if (modSource[resource].u.Interrupt.MinimumVector <
                    HalpFixedAcpiDescTable.sci_int_vector) {

                //
                // Put a new range on the end of modSource.
                //

                modSource[sourceCount].u.Interrupt.MinimumVector =
                    modSource[resource].u.Interrupt.MinimumVector;

                modSource[sourceCount].u.Interrupt.MaximumVector =
                    HalpFixedAcpiDescTable.sci_int_vector - 1;

                sourceCount++;
            }

            if (modSource[resource].u.Interrupt.MaximumVector >
                    HalpFixedAcpiDescTable.sci_int_vector) {

                //
                // Put a new range on the end of modSource.
                //

                modSource[sourceCount].u.Interrupt.MinimumVector =
                    HalpFixedAcpiDescTable.sci_int_vector + 1;

                modSource[sourceCount].u.Interrupt.MaximumVector =
                    modSource[resource].u.Interrupt.MaximumVector;

                sourceCount++;
            }

            //
            // Now remove the range that we just broke up.
            //

            RtlMoveMemory(modSource + resource,
                          modSource + resource + 1,
                          sizeof(IO_RESOURCE_DESCRIPTOR) *
                            (sourceCount - resource));

            sourceCount--;
        }
    }


    target = ExAllocatePoolWithTag(PagedPool, resourceLength, HAL_POOL_TAG);

    if (!target) {
        ExFreePool(modSource);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory(target, resourceLength);

    //
    // Now translate each range from ISA vectors to ACPI
    // "global system interrupt vectors."  Since GSIVs aren't
    // necessarily contiguous with respect to the ISA vectors,
    // this may involve breaking each range up into smaller
    // ranges, each independently translated into the GSIV space.
    //
    for (resource = 0; resource < sourceCount; resource++) {

        //
        // For each existing resource, start with the minimum
        // and maximum, unchanged.
        //

        irq    = modSource[resource].u.Interrupt.MinimumVector;
        endIrq = modSource[resource].u.Interrupt.MaximumVector;

        do {

            //
            // Now cycle through every IRQ in this range, testing
            // to see if its translated value is contiguous
            // with respect to the translated value of the next
            // IRQ in the range.
            //

            startIrq = irq;

            for (; irq < endIrq; irq++) {

                if (TranslateIsaVectorToGlobalVector(irq) + 1 !=
                    TranslateIsaVectorToGlobalVector(irq + 1)) {

                    //
                    // This range is not contiguous.  Stop now
                    // and create a target range.
                    //

                    break;
                }
            }

            //
            // Clone the source descriptor
            //
            target[targetCount] = *Source;

            //
            // Fill in the relevant changes.
            //
            target[targetCount].u.Interrupt.MinimumVector =
                TranslateIsaVectorToGlobalVector(startIrq);

            target[targetCount].u.Interrupt.MaximumVector =
                TranslateIsaVectorToGlobalVector(irq);

			ASSERT(target[targetCount].u.Interrupt.MinimumVector <=
			         target[targetCount].u.Interrupt.MaximumVector);

            targetCount++;

        } while (irq != endIrq);
    }

    *TargetCount = targetCount;

    if (targetCount > 0) {

        *Target = target;

    } else {

        ExFreePool(target);
    }

    ExFreePool(modSource);
    return STATUS_SUCCESS;
}

NTSTATUS
HalacpiIrqTranslateResourcesIsa(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    )
/*++

Routine Description:

    This function is basically a wrapper for
    HalIrqTranslateResourcesRoot that understands
    the weirdnesses of the ISA bus.

Arguments:

Return Value:

    status

--*/
{
    NTSTATUS    status;
    BOOLEAN     usePicSlave = FALSE;
    ULONG       i;
    ULONG       vector;

    PAGED_CODE();

    ASSERT(Source->Type == CmResourceTypeInterrupt);

    //
    // Copy everything
    //
    *Target = *Source;

    switch (Direction) {
    case TranslateChildToParent:

        Target->u.Interrupt.Level  =
            TranslateIsaVectorToGlobalVector(Source->u.Interrupt.Level);

        Target->u.Interrupt.Vector =
            TranslateIsaVectorToGlobalVector(Source->u.Interrupt.Vector);

        break;

    case TranslateParentToChild:

        status = TranslateGlobalVectorToIsaVector(Source->u.Interrupt.Level,
                                                  &vector);

        if (!NT_SUCCESS(status)) {
            return status;
        }

        Target->u.Interrupt.Level = vector;

        status = TranslateGlobalVectorToIsaVector(Source->u.Interrupt.Vector,
                                                  &vector);

        if (!NT_SUCCESS(status)) {
            return status;
        }

        Target->u.Interrupt.Vector = vector;

        //
        // Because the ISA interrupt controller is
        // cascaded, there is one case where there is
        // a two-to-one mapping for interrupt sources.
        // (On a PC, both 2 and 9 trigger vector 9.)
        //
        // We need to account for this and deliver the
        // right value back to the driver.
        //

        if (Target->u.Interrupt.Level == PIC_SLAVE_REDIRECT) {

            //
            // Search the Alternatives list.  If it contains
            // PIC_SLAVE_IRQ but not PIC_SLAVE_REDIRECT,
            // we should return PIC_SLAVE_IRQ.
            //

            for (i = 0; i < AlternativesCount; i++) {

                if ((Alternatives[i].u.Interrupt.MinimumVector >= PIC_SLAVE_REDIRECT) &&
                    (Alternatives[i].u.Interrupt.MaximumVector <= PIC_SLAVE_REDIRECT)) {

                    //
                    // The list contains, PIC_SLAVE_REDIRECT.  Stop
                    // looking.
                    //

                    usePicSlave = FALSE;
                    break;
                }

                if ((Alternatives[i].u.Interrupt.MinimumVector >= PIC_SLAVE_IRQ) &&
                    (Alternatives[i].u.Interrupt.MaximumVector <= PIC_SLAVE_IRQ)) {

                    //
                    // The list contains, PIC_SLAVE_IRQ.  Use it
                    // unless we find PIC_SLAVE_REDIRECT later.
                    //

                    usePicSlave = TRUE;
                }
            }

            if (usePicSlave) {

                Target->u.Interrupt.Level  = PIC_SLAVE_IRQ;
                Target->u.Interrupt.Vector = PIC_SLAVE_IRQ;
            }
        }

        break;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
HalacpiGetInterruptTranslator(
	IN INTERFACE_TYPE ParentInterfaceType,
	IN ULONG ParentBusNumber,
	IN INTERFACE_TYPE BridgeInterfaceType,
	IN USHORT Size,
	IN USHORT Version,
	OUT PTRANSLATOR_INTERFACE Translator,
	OUT PULONG BridgeBusNumber
	)
/*++

Routine Description:


Arguments:

	ParentInterfaceType - The type of the bus the bridge lives on (normally PCI).

	ParentBusNumber - The number of the bus the bridge lives on.

	ParentSlotNumber - The slot number the bridge lives in (where valid).

	BridgeInterfaceType - The bus type the bridge provides (ie ISA for a PCI-ISA bridge).

	ResourceType - The resource type we want to translate.

	Size - The size of the translator buffer.

	Version - The version of the translator interface requested.

	Translator - Pointer to the buffer where the translator should be returned

	BridgeBusNumber - Pointer to where the bus number of the bridge bus should be returned

Return Value:

    Returns the status of this operation.

--*/
{
    PAGED_CODE();

    UNREFERENCED_PARAMETER(ParentInterfaceType);
    UNREFERENCED_PARAMETER(ParentBusNumber);

    ASSERT(Version == HAL_IRQ_TRANSLATOR_VERSION);
    ASSERT(Size >= sizeof (TRANSLATOR_INTERFACE));

    switch (BridgeInterfaceType) {
    case Eisa:
    case Isa:
	case InterfaceTypeUndefined:   // special "IDE" cookie

        //
        // Pass back an interface for an IRQ translator for
        // the (E)ISA interrupts.
        //
        RtlZeroMemory(Translator, sizeof (TRANSLATOR_INTERFACE));

        Translator->Size = sizeof (TRANSLATOR_INTERFACE);
        Translator->Version = HAL_IRQ_TRANSLATOR_VERSION;
        Translator->InterfaceReference = &HalTranslatorReference;
        Translator->InterfaceDereference = &HalTranslatorDereference;
        Translator->TranslateResources = &HalacpiIrqTranslateResourcesIsa;
        Translator->TranslateResourceRequirements = &HalacpiIrqTranslateResourceRequirementsIsa;

        return STATUS_SUCCESS;

    default:
        return STATUS_NOT_IMPLEMENTED;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\pmpcisup.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pmpcibus.c

Abstract:

    Implements simplified PCI configuration
    read and write functions for use in
    an ACPI HAL.

Author:

    Jake Oshins (jakeo) 1-Dec-1997
    Chris Hyser (chrish@fc.hp.com) 23-Jun-1997
    Neal Vu (neal.vu@intel.com) 11-Jul-2000

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "pci.h"
#include "pcip.h"

#define MAX(a, b)       \
    ((a) > (b) ? (a) : (b))

#define MIN(a, b)       \
    ((a) < (b) ? (a) : (b))

NTSTATUS
HalpSearchForPciDebuggingDevice(
    IN OUT PDEBUG_DEVICE_DESCRIPTOR PciDevice,
    IN ULONG                        StartBusNumber,
    IN ULONG                        EndBusNumber,
    IN ULONG                        MinMem,
    IN ULONG                        MaxMem,
    IN USHORT                       MinIo,
    IN USHORT                       MaxIo,
    IN BOOLEAN                      ConfigureBridges
    );

PCIPBUSDATA HalpFakePciBusData = {
    {
        PCI_DATA_TAG,//Tag
        PCI_DATA_VERSION,//Version
        (PciReadWriteConfig)HalpReadPCIConfig,//ReadConfig
        (PciReadWriteConfig) HalpWritePCIConfig,//WriteConfig
        (PciPin2Line)HalpPCIPin2ISALine,//Pin2Line
        (PciLine2Pin)HalpPCIISALine2Pin,//Line2Pin
        {0},//ParentSlot
        NULL,NULL,NULL,NULL//Reserved[4]
    },
    {0},//Config
    PCI_MAX_DEVICES,//MaxDevice
};

BUS_HANDLER HalpFakePciBusHandler = {
    BUS_HANDLER_VERSION,//Version
    PCIBus,//InterfaceType
    PCIConfiguration,//ConfigurationType
    0,//BusNumber
    NULL,//DeviceObject
    NULL,//ParentHandler
    (PPCIBUSDATA)&HalpFakePciBusData,//BusData
    0,//DeviceControlExtensionSize
    NULL,//BusAddresses
    {0},//Reserved[4]
    (PGETSETBUSDATA)HalpGetPCIData,//GetBusData
    (PGETSETBUSDATA)HalpSetPCIData,//SetBusData
    NULL,//AdjustResourceList
    (PASSIGNSLOTRESOURCES)HalpAssignPCISlotResources,//AssignSlotResources
    NULL,//GetInterruptVector
    NULL,//TranslateBusAddress
};

ULONG       HalpMinPciBus = 0;
ULONG       HalpMaxPciBus = 0;

#define MAX_DEBUGGING_DEVICES_SUPPORTED 2
PCI_TYPE1_CFG_CYCLE_BITS HalpPciDebuggingDevice[MAX_DEBUGGING_DEVICES_SUPPORTED] = {0};

extern BOOLEAN HalpDoingCrashDump;
extern KSPIN_LOCK HalpPCIConfigLock;

PVOID
HalpGetAcpiTablePhase0(
    IN  PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN  ULONG   Signature
    );

VOID
HalpFindFreeResourceLimits(
    IN      ULONG   Bus,
    IN OUT  ULONG   *MinIo,
    IN OUT  ULONG   *MaxIo,
    IN OUT  ULONG   *MinMem,
    IN OUT  ULONG   *MaxMem,
    IN OUT  ULONG   *MinBus,
    IN OUT  ULONG   *MaxBus
    );

NTSTATUS
HalpSetupUnconfiguredDebuggingDevice(
    IN ULONG   Bus,
    IN ULONG   Slot,
    IN ULONG   IoMin,
    IN ULONG   IoMax,
    IN ULONG   MemMin,
    IN ULONG   MemMax,
    IN OUT PDEBUG_DEVICE_DESCRIPTOR PciDevice
    );

NTSTATUS
HalpConfigurePciBridge(
    IN      PDEBUG_DEVICE_DESCRIPTOR  PciDevice,
    IN      ULONG   Bus,
    IN      ULONG   Slot,
    IN      ULONG   IoMin,
    IN      ULONG   IoMax,
    IN      ULONG   MemMin,
    IN      ULONG   MemMax,
    IN      ULONG   BusMin,
    IN      ULONG   BusMax,
    IN OUT  PPCI_COMMON_CONFIG PciData
    );

VOID
HalpUnconfigurePciBridge(
    IN  ULONG   Bus,
    IN  ULONG   Slot
    );

VOID
HalpRegisterKdSupportFunctions(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

VOID
HalpRegisterPciDebuggingDeviceInfo(
    VOID
    );

ULONG
HalpPhase0GetPciDataByOffset (
    ULONG BusNumber,
    ULONG SlotNumber,
    PVOID Buffer,
    ULONG Offset,
    ULONG Length
    );

ULONG
HalpPhase0SetPciDataByOffset (
    ULONG BusNumber,
    ULONG SlotNumber,
    PVOID Buffer,
    ULONG Offset,
    ULONG Length
    );

NTSTATUS
HalpReleasePciDeviceForDebugging(
    IN OUT PDEBUG_DEVICE_DESCRIPTOR  PciDevice
    );

NTSTATUS
HalpSetupPciDeviceForDebugging(
    IN     PLOADER_PARAMETER_BLOCK   LoaderBlock,   OPTIONAL
    IN OUT PDEBUG_DEVICE_DESCRIPTOR  PciDevice
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpInitializePciBus)
#pragma alloc_text(INIT,HalpRegisterKdSupportFunctions)
#pragma alloc_text(INIT,HalpRegisterPciDebuggingDeviceInfo)
#pragma alloc_text(PAGELK,HalpConfigurePciBridge)
#pragma alloc_text(PAGELK,HalpFindFreeResourceLimits)
#pragma alloc_text(PAGELK,HalpPhase0GetPciDataByOffset)
#pragma alloc_text(PAGELK,HalpPhase0SetPciDataByOffset)
#pragma alloc_text(PAGELK,HalpReleasePciDeviceForDebugging)
#pragma alloc_text(PAGELK,HalpSearchForPciDebuggingDevice)
#pragma alloc_text(PAGELK,HalpSetupPciDeviceForDebugging)
#pragma alloc_text(PAGELK,HalpSetupUnconfiguredDebuggingDevice)
#pragma alloc_text(PAGELK,HalpUnconfigurePciBridge)
#endif

VOID
HalpInitializePciBus (
    VOID
    )
{
    PPCIPBUSDATA        BusData;
    UCHAR               iBuffer[PCI_COMMON_HDR_LENGTH];

    //
    // Initialize spinlock for synchronizing access to PCI space
    //

    KeInitializeSpinLock (&HalpPCIConfigLock);

    RtlZeroMemory(&HalpFakePciBusHandler, sizeof(BUS_HANDLER));

    HalpFakePciBusHandler.Version = BUS_HANDLER_VERSION;
    HalpFakePciBusHandler.InterfaceType = PCIBus;
    HalpFakePciBusHandler.ConfigurationType = PCIConfiguration;

    //
    // Fill in PCI handlers
    //

    HalpFakePciBusHandler.GetBusData = (PGETSETBUSDATA) HalpGetPCIData;
    HalpFakePciBusHandler.SetBusData = (PGETSETBUSDATA) HalpSetPCIData;
    HalpFakePciBusHandler.AssignSlotResources = (PASSIGNSLOTRESOURCES) HalpAssignPCISlotResources;
    HalpFakePciBusHandler.BusData = &HalpFakePciBusData;

    BusData = (PPCIPBUSDATA) HalpFakePciBusHandler.BusData;

    //
    // Fill in common PCI data
    //

    BusData->CommonData.Tag         = PCI_DATA_TAG;
    BusData->CommonData.Version     = PCI_DATA_VERSION;
    BusData->CommonData.ReadConfig  = (PciReadWriteConfig) HalpReadPCIConfig;
    BusData->CommonData.WriteConfig = (PciReadWriteConfig) HalpWritePCIConfig;
    BusData->CommonData.Pin2Line    = (PciPin2Line) HalpPCIPin2ISALine;
    BusData->CommonData.Line2Pin    = (PciLine2Pin) HalpPCIISALine2Pin;

    //
    // Set defaults
    //

    BusData->MaxDevice   = PCI_MAX_DEVICES;

    //
    // There used to be a switch statment on HwType which installed
    // different handlers based on PCI Configuration Type.  This
    // has been removed since SAL is always used for IA64.
    //
}


ULONG
HaliPciInterfaceReadConfig(
    IN PVOID Context,
    IN UCHAR BusOffset,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
{
    PCI_SLOT_NUMBER slotNum;
    BUS_HANDLER     busHand;

    UNREFERENCED_PARAMETER(Context);

    slotNum.u.AsULONG = Slot;

    //
    // Fake a bus handler.
    //

    RtlCopyMemory(&busHand, &HalpFakePciBusHandler, sizeof(BUS_HANDLER));

    //
    // Calculate the right bus number.
    //

    busHand.BusNumber = BusOffset;

    HalpReadPCIConfig(&busHand,
                      slotNum,
                      Buffer,
                      Offset,
                      Length
                      );

    //
    // This is a hack.  The legacy HAL interfaces need to be able
    // to distinguish between busses that exist and busses that
    // don't.  And many users of the legacy interfaces implicitly
    // assume that PCI busses are tightly packed.  (i.e. All busses
    // between the lowest numbered one and the highest numbered one
    // exist.)  So here we are keeping track of the highest numbered
    // bus that we have seen so far.
    //

    if ((Length >= 2) &&
        (((PPCI_COMMON_CONFIG)Buffer)->VendorID != PCI_INVALID_VENDORID)) {

        //
        // This is a valid device.
        //

        if (busHand.BusNumber > HalpMaxPciBus) {

            //
            // This is the highest numbered bus we have
            // yet seen.
            //

            HalpMaxPciBus = busHand.BusNumber;
        }
    }

    return Length;
}

ULONG
HaliPciInterfaceWriteConfig(
    IN PVOID Context,
    IN UCHAR BusOffset,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    )
{
    PCI_SLOT_NUMBER slotNum;
    BUS_HANDLER     busHand;

    UNREFERENCED_PARAMETER(Context);

    slotNum.u.AsULONG = Slot;

    //
    // Fake a bus handler.
    //

    RtlCopyMemory(&busHand, &HalpFakePciBusHandler, sizeof(BUS_HANDLER));

    //
    // Calculate the right bus number.
    //

    busHand.BusNumber = BusOffset;

    HalpWritePCIConfig(&busHand,
                       slotNum,
                       Buffer,
                       Offset,
                       Length
                       );

    return Length;
}

VOID
HalpPCIPin2ISALine (
    IN PBUS_HANDLER          BusHandler,
    IN PBUS_HANDLER          RootHandler,
    IN PCI_SLOT_NUMBER      SlotNumber,
    IN PPCI_COMMON_CONFIG   PciData
    )
/*++

    This function maps the device's InterruptPin to an InterruptLine
    value.

    On the current PC implementations, the bios has already filled in
    InterruptLine as it's ISA value and there's no portable way to
    change it.

    On a DBG build we adjust InterruptLine just to ensure driver's
    don't connect to it without translating it on the PCI bus.

--*/
{
    if (!PciData->u.type0.InterruptPin) {
        return ;
    }
    HalDebugPrint(( HAL_INFO, "HAL: HalpPCIPin2ISALine - non-zero InterruptPin value\n" ));
}



VOID
HalpPCIISALine2Pin (
    IN PBUS_HANDLER          BusHandler,
    IN PBUS_HANDLER          RootHandler,
    IN PCI_SLOT_NUMBER      SlotNumber,
    IN PPCI_COMMON_CONFIG   PciNewData,
    IN PPCI_COMMON_CONFIG   PciOldData
    )
/*++

    This functions maps the device's InterruptLine to it's
    device specific InterruptPin value.

    On the current PC implementations, this information is
    fixed by the BIOS.  Just make sure the value isn't being
    editted since PCI doesn't tell us how to dynically
    connect the interrupt.

--*/
{
    if (!PciNewData->u.type0.InterruptPin) {
        return ;
    }
}

VOID
HalpSetMaxLegacyPciBusNumber(
    IN ULONG BusNumber
    )

/*++

Routine Description:

    This routine bumps the Legacy PCI bus maximum up to whatever
    is passed in.  This may be necessary because the ACPI driver
    needs to run a configuration cycle to a PCI device before the
    PCI driver loads.  This happens mostly in the context of a
    _REG method.

Arguments:

    BusNumber - max PCI bus number

Return Value:

    none

--*/
{
    if (BusNumber > HalpMaxPciBus) {
        HalpMaxPciBus = BusNumber;
    }
}

ULONG
HalpPhase0SetPciDataByOffset (
    ULONG BusNumber,
    ULONG SlotNumber,
    PVOID Buffer,
    ULONG Offset,
    ULONG Length
    )

/*++

Routine Description:

    This routine writes to PCI configuration space prior to bus handler
    installation.

Arguments:

    BusNumber   PCI Bus Number.  This is the 8 bit BUS Number which is
                bits 23-16 of the Configuration Address.  In support of
                multiple top level busses, the upper 24 bits of this
                argument will supply the index into the table of
                configuration address registers.
    SlotNumber  PCI Slot Number, 8 bits composed of the 5 bit device
                number (bits 15-11 of the configuration address) and
                the 3 bit function number (10-8).
    Buffer      Address of source data.
    Offset      Number of bytes to skip from base of PCI config area.
    Length      Number of bytes to write

Return Value:

    Returns length of data written.

Notes:

    Caller is responsible for acquiring any necessary PCI config
    spinlocks.

--*/

{
    PCI_TYPE1_CFG_BITS ConfigAddress;
    ULONG ReturnLength;
    PCI_SLOT_NUMBER slot;
    PUCHAR Bfr = (PUCHAR)Buffer;

    ASSERT(!(Offset & ~0xff));
    ASSERT(Length);
    ASSERT((Offset + Length) <= 256);

    if ( Length + Offset > 256 ) {
        if ( Offset > 256 ) {
            return 0;
        }
        Length = 256 - Offset;
    }

    ReturnLength = Length;
    slot.u.AsULONG = SlotNumber;

    ConfigAddress.u.bits.BusNumber = BusNumber;
    ConfigAddress.u.bits.DeviceNumber = slot.u.bits.DeviceNumber;
    ConfigAddress.u.bits.FunctionNumber = slot.u.bits.FunctionNumber;
    ConfigAddress.u.bits.RegisterNumber = (Offset & 0xfc) >> 2;
    ConfigAddress.u.bits.Enable = TRUE;

    if ( Offset & 0x3 ) {
        //
        // Access begins at a non-register boundary in the config
        // space.  We need to read the register containing the data
        // and rewrite only the changed data.   (I wonder if this
        // ever really happens?)
        //
        ULONG SubOffset = Offset & 0x3;
        ULONG SubLength = 4 - SubOffset;
        union {
            ULONG All;
            UCHAR Bytes[4];
        } Tmp;

        if ( SubLength > Length ) {
            SubLength = Length;
        }

        //
        // Adjust Length (remaining) and (new) Offset by amount covered
        // in this first word.
        //
        Length -= SubLength;
        Offset += SubLength;

        //
        // Get the first word (register), replace only those bytes that
        // need to be changed, then write the whole thing back out again.
        //
        WRITE_PORT_ULONG((PULONG)PCI_TYPE1_ADDR_PORT, ConfigAddress.u.AsULONG);
        Tmp.All = READ_PORT_ULONG((PULONG)PCI_TYPE1_DATA_PORT);

        while ( SubLength-- ) {
            Tmp.Bytes[SubOffset++] = *Bfr++;
        }

        WRITE_PORT_ULONG((PULONG)PCI_TYPE1_DATA_PORT, Tmp.All);

        //
        // Aim ConfigAddressRegister at the next word (register).
        //
        ConfigAddress.u.bits.RegisterNumber++;
    }

    //
    // Do the majority of the transfer 4 bytes at a time.
    //
    while ( Length > sizeof(ULONG) ) {
        ULONG Tmp = *(PULONG)Bfr;
        WRITE_PORT_ULONG((PULONG)PCI_TYPE1_ADDR_PORT, ConfigAddress.u.AsULONG);
        WRITE_PORT_ULONG((PULONG)PCI_TYPE1_DATA_PORT, Tmp);
        ConfigAddress.u.bits.RegisterNumber++;
        Bfr += sizeof(ULONG);
        Length -= sizeof(ULONG);

    }

    //
    // Do bytes in last register.
    //
    if ( Length ) {
        union {
            ULONG All;
            UCHAR Bytes[4];
        } Tmp;
        ULONG i = 0;
        WRITE_PORT_ULONG((PULONG)PCI_TYPE1_ADDR_PORT, ConfigAddress.u.AsULONG);
        Tmp.All = READ_PORT_ULONG((PULONG)PCI_TYPE1_DATA_PORT);

        while ( Length-- ) {
            Tmp.Bytes[i++] = *(PUCHAR)Bfr++;
        }
        WRITE_PORT_ULONG((PULONG)PCI_TYPE1_DATA_PORT, Tmp.All);
    }

    return ReturnLength;
}

ULONG
HalpPhase0GetPciDataByOffset (
    ULONG BusNumber,
    ULONG SlotNumber,
    PVOID Buffer,
    ULONG Offset,
    ULONG Length
    )

/*++

Routine Description:

    This routine reads PCI config space prior to bus handlder installation.

Arguments:

    BusNumber   PCI Bus Number.  This is the 8 bit BUS Number which is
                bits 23-16 of the Configuration Address.  In support of
                multiple top level busses, the upper 24 bits of this
                argument will supply the index into the table of
                configuration address registers.
    SlotNumber  PCI Slot Number, 8 bits composed of the 5 bit device
                number (bits 15-11 of the configuration address) and
                the 3 bit function number (10-8).
    Buffer      Address of source data.
    Offset      Number of bytes to skip from base of PCI config area.
    Length      Number of bytes to write

Return Value:

    Amount of data read.

--*/

{
    PCI_TYPE1_CFG_BITS ConfigAddress;
    PCI_TYPE1_CFG_BITS ConfigAddressTemp;
    ULONG ReturnLength;
    ULONG i;
    PCI_SLOT_NUMBER slot;
    union {
        ULONG All;
        UCHAR Bytes[4];
    } Tmp;

    ASSERT(!(Offset & ~0xff));
    ASSERT(Length);
    ASSERT((Offset + Length) <= 256);

    if ( Length + Offset > 256 ) {
        if ( Offset > 256 ) {
            return 0;
        }
        Length = 256 - Offset;
    }

    ReturnLength = Length;
    slot.u.AsULONG = SlotNumber;

    ConfigAddress.u.bits.BusNumber = BusNumber;
    ConfigAddress.u.bits.DeviceNumber = slot.u.bits.DeviceNumber;
    ConfigAddress.u.bits.FunctionNumber = slot.u.bits.FunctionNumber;
    ConfigAddress.u.bits.RegisterNumber = (Offset & 0xfc) >> 2;
    ConfigAddress.u.bits.Enable = TRUE;

    //
    // If we are being asked to read data when function != 0, check
    // first to see if this device decares itself as a multi-function
    // device.  If it doesn't, don't do this read.
    //
    if (ConfigAddress.u.bits.FunctionNumber != 0) {

        ConfigAddressTemp.u.bits.RegisterNumber = 3; // contains header type
        ConfigAddressTemp.u.bits.FunctionNumber = 0; // look at base package
        ConfigAddressTemp.u.bits.DeviceNumber = ConfigAddress.u.bits.DeviceNumber;
        ConfigAddressTemp.u.bits.BusNumber    = ConfigAddress.u.bits.BusNumber;
        ConfigAddressTemp.u.bits.Enable       = TRUE;

        WRITE_PORT_ULONG((PULONG)PCI_TYPE1_ADDR_PORT, ConfigAddressTemp.u.AsULONG);
        Tmp.All = READ_PORT_ULONG((PULONG)PCI_TYPE1_DATA_PORT);

        if (!(Tmp.Bytes[2] & 0x80)) { // if the Header type field's multi-function bit is not set

            for (i = 0; i < Length; i++) {
                *((PUCHAR)Buffer)++ = 0xff; // Make this read as if the device isn't populated
            }

            return Length;
        }
    }

    i = Offset & 0x3;

    while ( Length ) {
        WRITE_PORT_ULONG((PULONG)PCI_TYPE1_ADDR_PORT, ConfigAddress.u.AsULONG);
        Tmp.All = READ_PORT_ULONG((PULONG)PCI_TYPE1_DATA_PORT);
        while ( (i < 4) && Length) {
            *((PUCHAR)Buffer)++ = Tmp.Bytes[i];
            i++;
            Length--;
        }
        i = 0;
        ConfigAddress.u.bits.RegisterNumber++;
    }
    return ReturnLength;
}

NTSTATUS
HalpSetupPciDeviceForDebugging(
    IN     PLOADER_PARAMETER_BLOCK   LoaderBlock,   OPTIONAL
    IN OUT PDEBUG_DEVICE_DESCRIPTOR  PciDevice
    )
/*++

Routine Description:

    This routine finds and initializes a PCI device to be
    used for communicating with a debugger.

    The caller fills in as much of DEBUG_DEVICE_DESCRIPTOR
    as it cares to, filling unused fields with (-1).

    This routine attempts to find a matching PCI device.  It
    matches first based on Bus and Slot, if the caller has
    provided them.  Then it matches on VendorID/DeviceID, if
    the caller has provided them.  Last, it matches on
    BaseClass/SubClass.

    This routine will fill in any unused fields in the structure
    so that the caller can know specifically which PCI
    device matched the criteria.

    If the matching PCI device is not enabled, or it is
    behind a PCI to PCI bridge that is not enabled, this
    routine makes a best-effort attempt to find a safe
    configuration that allows the device (and possibly bridges)
    to function, and enables them.

    If the PCI device implements memory mapped Base Address
    registers, this function will create a virtual to physical
    mapping for the memory ranges implied by the Base Address
    Registers and fill in the TranslatedAddress field with
    virtual pointers to the bases of the ranges.  It will then
    fill in the Type field with CmResourceTypeMemory.  And
    the Valid field with be TRUE.

    If the PCI device implements I/O port Base Address registers,
    this function will put the translated port address in
    TranslatedAddress, setting the Type field to CmResourceTypePort
    and the Valid field to TRUE.

    If the PCI device does not implement a specific Base Address
    Register, the Valid field will be FALSE.

Arguments:

    PciDevice - Structure indicating the device

Return Value:

    STATUS_SUCCESS if the device is configured and usable.

    STATUS_NO_MORE_MATCHES if no device matched the criteria.

    STATUS_INSUFFICIENT_RESOURCES if the memory requirements
    couldn't be met.

    STATUS_UNSUCCESSFUL if the routine failed for other reasons.

--*/
{
    NTSTATUS            status;
    PCI_SLOT_NUMBER     slot;
    ULONG               i, j;
    ULONG               maxPhys;

    status = HalpSearchForPciDebuggingDevice(
                PciDevice,
                0,
                0xff,
                0x10000000,
                0xfc000000,
                0x1000,
                0xffff,
                FALSE);

    if (!NT_SUCCESS(status)) {

        //
        // We didn't find the device using a conservative
        // search.  Try a more invasive one.
        //

        status = HalpSearchForPciDebuggingDevice(
                    PciDevice,
                    0,
                    0xff,
                    0x10000000,
                    0xfc000000,
                    0x1000,
                    0xffff,
                    TRUE);
    }

    //
    // Record the Bus/Dev/Func so that we can stuff it in the
    // registry later.
    //

    if (NT_SUCCESS(status)) {

        slot.u.AsULONG = PciDevice->Slot;

        for (i = 0;
             i < MAX_DEBUGGING_DEVICES_SUPPORTED;
             i++) {

            if ((HalpPciDebuggingDevice[i].u.bits.Reserved1 == TRUE) &&
                (HalpPciDebuggingDevice[i].u.bits.FunctionNumber ==
                 slot.u.bits.FunctionNumber)                         &&
                (HalpPciDebuggingDevice[i].u.bits.DeviceNumber ==
                 slot.u.bits.DeviceNumber)                           &&
                (HalpPciDebuggingDevice[i].u.bits.BusNumber ==
                 PciDevice->Bus)) {

                //
                // This device has already been set up for
                // debugging.  Thus we should refuse to set
                // it up again.
                //

                return STATUS_UNSUCCESSFUL;
            }
        }

        for (i = 0;
             i < MAX_DEBUGGING_DEVICES_SUPPORTED;
             i++) {

            if (HalpPciDebuggingDevice[i].u.bits.Reserved1 == FALSE) {

                //
                // This slot is available.
                //

                HalpPciDebuggingDevice[i].u.bits.FunctionNumber =
                    slot.u.bits.FunctionNumber;
                HalpPciDebuggingDevice[i].u.bits.DeviceNumber =
                    slot.u.bits.DeviceNumber;
                HalpPciDebuggingDevice[i].u.bits.BusNumber = PciDevice->Bus;
                HalpPciDebuggingDevice[i].u.bits.Reserved1 = TRUE;

                break;
            }
        }
    }

    //
    // Check to see if the caller wants any memory.
    //

    if (PciDevice->Memory.Length != 0) {

        if (!LoaderBlock) {
            return STATUS_INVALID_PARAMETER_1;
        }

        if (PciDevice->Memory.MaxEnd.QuadPart == 0) {
            PciDevice->Memory.MaxEnd.QuadPart = -1;
        }

        maxPhys = PciDevice->Memory.MaxEnd.HighPart ? 0xffffffff : PciDevice->Memory.MaxEnd.LowPart;
        maxPhys -= PciDevice->Memory.Length;

        //
        // The HAL APIs will always return page-aligned
        // memory.  So ignore Aligned for now.
        //

        maxPhys = (ULONG)(ULONG_PTR)PAGE_ALIGN(maxPhys);
        maxPhys += ADDRESS_AND_SIZE_TO_SPAN_PAGES(maxPhys, PciDevice->Memory.Length);

        PciDevice->Memory.Start.HighPart = 0;
        PciDevice->Memory.Start.LowPart = (ULONG)(ULONG_PTR)
            HalpAllocPhysicalMemory(LoaderBlock,
                                    maxPhys,
                                    ADDRESS_AND_SIZE_TO_SPAN_PAGES(maxPhys, PciDevice->Memory.Length),
                                    FALSE);

        if (!PciDevice->Memory.Start.LowPart) {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        PciDevice->Memory.VirtualAddress =
            HalpMapPhysicalMemory(PciDevice->Memory.Start,
                                  ADDRESS_AND_SIZE_TO_SPAN_PAGES(maxPhys, PciDevice->Memory.Length),
                                  MmNonCached);
    }

    return status;
}

VOID
HalpFindFreeResourceLimits(
    IN      ULONG   Bus,
    IN OUT  ULONG   *MinIo,
    IN OUT  ULONG   *MaxIo,
    IN OUT  ULONG   *MinMem,
    IN OUT  ULONG   *MaxMem,
    IN OUT  ULONG   *MinBus,
    IN OUT  ULONG   *MaxBus
    )
{
    UCHAR               buffer[PCI_COMMON_HDR_LENGTH];
    PPCI_COMMON_CONFIG  pciData;
    UCHAR               bus, dev, func, bytesRead;
    PCI_SLOT_NUMBER     pciSlot, targetSlot;
    ULONG               newMinMem, newMaxMem;
    ULONG               newMinIo, newMaxIo;
    ULONG               newMinBus, newMaxBus;
    UCHAR               barNo;

    pciData = (PPCI_COMMON_CONFIG)buffer;
    pciSlot.u.AsULONG = 0;
    newMinMem   = *MinMem;
    newMaxMem   = *MaxMem;
    newMinIo    = *MinIo;
    newMaxIo    = *MaxIo;
    newMinBus   = *MinBus;
    newMaxBus   = *MaxBus;

    for (dev = 0; dev < PCI_MAX_DEVICES; dev++) {
        for (func = 0; func < PCI_MAX_FUNCTION; func++) {

            pciSlot.u.bits.DeviceNumber = dev;
            pciSlot.u.bits.FunctionNumber = func;


            bytesRead = (UCHAR)HalpPhase0GetPciDataByOffset(Bus,
                                 pciSlot.u.AsULONG,
                                 pciData,
                                 0,
                                 PCI_COMMON_HDR_LENGTH);

            if (bytesRead == 0) continue;

            if (pciData->VendorID != PCI_INVALID_VENDORID) {

                switch (PCI_CONFIGURATION_TYPE(pciData)) {
                case PCI_DEVICE_TYPE:

                    //
                    // While we scan across the bus, keep track
                    // of the minimum decoder values that we've seen.
                    // This will be used if we have to configure the
                    // device.  This relies on the fact that most BIOSes
                    // assign addresses from the top down.
                    //

                    for (barNo = 0; barNo < PCI_TYPE0_ADDRESSES; barNo++) {

                        if (pciData->u.type0.BaseAddresses[barNo] &
                            PCI_ADDRESS_IO_SPACE) {

                            if (pciData->u.type0.BaseAddresses[barNo] &
                                PCI_ADDRESS_IO_ADDRESS_MASK) {

                                //
                                // This BAR is implemented
                                //

                                if ((pciData->u.type0.BaseAddresses[barNo] &
                                     PCI_ADDRESS_IO_ADDRESS_MASK) <
                                    ((newMaxIo + newMinIo) / 2)) {

                                    //
                                    // This BAR is at the bottom of the range.
                                    // Bump up the min.
                                    //

                                    newMinIo = (USHORT)MAX (newMinIo,
                                                            (pciData->u.type0.BaseAddresses[barNo] &
                                                             PCI_ADDRESS_IO_ADDRESS_MASK) + 0x100);

                                } else {

                                    //
                                    // This BAR is not at the bottom of the range.
                                    // Bump down the max.
                                    //

                                    newMaxIo = (USHORT)MIN (newMaxIo,
                                                            pciData->u.type0.BaseAddresses[barNo] &
                                                            PCI_ADDRESS_IO_ADDRESS_MASK);
                                }
                            }

                        } else {

                            if (pciData->u.type0.BaseAddresses[barNo] &
                                PCI_ADDRESS_MEMORY_ADDRESS_MASK) {

                                //
                                // The BAR is populated.
                                //

                                if ((pciData->u.type0.BaseAddresses[barNo] &
                                     PCI_ADDRESS_MEMORY_ADDRESS_MASK) <
                                    ((newMaxMem / 2) + (newMinMem / 2))) {

                                    //
                                    // This BAR is at the bottom of the range.
                                    // Bump up the min.
                                    //

                                    newMinMem = MAX (newMinMem,
                                                     (pciData->u.type0.BaseAddresses[barNo] &
                                                        PCI_ADDRESS_MEMORY_ADDRESS_MASK) + 0x10000);

                                } else {

                                    //
                                    // This BAR is not at the bottom of the range.
                                    // Bump down the max.
                                    //

                                    newMaxMem = MIN (newMaxMem,
                                                     (pciData->u.type0.BaseAddresses[barNo] &
                                                        PCI_ADDRESS_MEMORY_ADDRESS_MASK));

                                }
                            }
                        }
                    }

                    break;

                case PCI_CARDBUS_BRIDGE_TYPE:
                case PCI_BRIDGE_TYPE:

                    {
                      ULONG  bridgeMemMin = 0, bridgeMemMax = 0;
                      USHORT bridgeIoMin, bridgeIoMax;

                      if ((pciData->u.type1.SecondaryBus != 0) &&
                          (pciData->u.type1.SubordinateBus !=0) &&
                          (pciData->Command & PCI_ENABLE_MEMORY_SPACE) &&
                          (pciData->Command & PCI_ENABLE_IO_SPACE)) {

                        bridgeMemMin = PciBridgeMemory2Base(pciData->u.type1.MemoryBase);
                        bridgeMemMax = PciBridgeMemory2Limit(pciData->u.type1.MemoryLimit);
                        bridgeIoMin = (USHORT)PciBridgeIO2Base(pciData->u.type1.IOBase, 0);
                        bridgeIoMax = (USHORT)PciBridgeIO2Limit(pciData->u.type1.IOLimit, 0);

                        //
                        // Keep track of address space allocation.
                        //

                        if (bridgeIoMin > ((newMaxIo + newMinIo) / 2)) {
                            newMaxIo = MIN(newMaxIo, bridgeIoMin);
                        }

                        if (bridgeIoMax < ((newMaxIo + newMinIo) / 2)) {
                            newMinIo = MAX(newMinIo, bridgeIoMax) + 1;
                        }

                        if (bridgeMemMin > ((newMaxMem + newMinMem) / 2)) {
                            newMaxMem = MIN(newMaxMem, bridgeMemMin);
                        }

                        if (bridgeMemMax < ((newMaxMem + newMinMem) / 2)) {
                            newMinMem = MAX(newMinMem, bridgeMemMax) + 1;
                        }

                        //
                        // Keep track of bus numbers.
                        //

                        if (pciData->u.type1.PrimaryBus > ((newMaxBus + newMinBus) / 2)) {
                            newMaxBus = MIN(newMaxBus, pciData->u.type1.PrimaryBus);
                        }

                        if (pciData->u.type1.SubordinateBus < ((newMaxBus + newMinBus) / 2)) {
                            newMinBus = MAX(newMinBus, pciData->u.type1.SubordinateBus) + 1;
                        }
                      }

                      break;

                      default:
                        break;

                    }

                }

                if (!PCI_MULTIFUNCTION_DEVICE(pciData) &&
                    (func == 0)) {
                    break;
                }
            }
        }
    }

    *MinMem = newMinMem;
    *MaxMem = newMaxMem;
    *MinIo  = newMinIo;
    *MaxIo  = newMaxIo;
    *MinBus = newMinBus;
    *MaxBus = newMaxBus;
}

NTSTATUS
HalpSetupUnconfiguredDebuggingDevice(
    IN ULONG   Bus,
    IN ULONG   Slot,
    IN ULONG   IoMin,
    IN ULONG   IoMax,
    IN ULONG   MemMin,
    IN ULONG   MemMax,
    IN OUT PDEBUG_DEVICE_DESCRIPTOR PciDevice
    )
{

    UCHAR               buffer[PCI_COMMON_HDR_LENGTH];
    PPCI_COMMON_CONFIG  pciData;
    ULONG               barLength, bytesRead;
    ULONG               barContents = 0;
    PHYSICAL_ADDRESS    physicalAddress;
    PCI_SLOT_NUMBER     pciSlot;
    UCHAR               barNo;

    pciSlot.u.AsULONG = Slot;
    pciData = (PPCI_COMMON_CONFIG)buffer;

    bytesRead = (UCHAR)HalpPhase0GetPciDataByOffset(Bus,
                         pciSlot.u.AsULONG,
                         pciData,
                         0,
                         PCI_COMMON_HDR_LENGTH);

    ASSERT(bytesRead != 0);

    PciDevice->Bus = Bus;
    PciDevice->Slot = pciSlot.u.AsULONG;
    PciDevice->VendorID = pciData->VendorID;
    PciDevice->DeviceID = pciData->DeviceID;
    PciDevice->BaseClass = pciData->BaseClass;
    PciDevice->SubClass = pciData->SubClass;

  //DbgPrint("Configuring device between %x - %x\n",
  //         MemMin, MemMax);

    //
    // Cycle through the BARs, turning them on if necessary,
    // and mapping them.
    //

    for (barNo = 0; barNo < PCI_TYPE0_ADDRESSES; barNo++) {

        barContents = 0xffffffff;

        PciDevice->BaseAddress[barNo].Valid = FALSE;

        HalpPhase0SetPciDataByOffset(Bus,
                                     pciSlot.u.AsULONG,
                                     &barContents,
                                     0x10 + (4 * barNo),
                                     4);

        HalpPhase0GetPciDataByOffset(Bus,
                                     pciSlot.u.AsULONG,
                                     &barContents,
                                     0x10 + (4 * barNo),
                                     4);

        if (pciData->u.type0.BaseAddresses[barNo] &
            PCI_ADDRESS_IO_SPACE) {

            //
            // This is an I/O BAR.
            //

            if (!(pciData->u.type0.BaseAddresses[barNo] &
                  PCI_ADDRESS_IO_ADDRESS_MASK)) {

                //
                // And it's empty.
                //

                barLength = (((USHORT)barContents & PCI_ADDRESS_IO_ADDRESS_MASK) - 1) ^
                    0xffff;

                //
                // Try to fit this I/O window half-way between the min and the max.
                //

                if ((ULONG)(IoMax - IoMin) >= (barLength * 3)) {

                    //
                    // There is plenty of room, make a safe guess.  Try
                    // to put it half-way between the upper and lower
                    // bounds, rounding up to the next natural alignment.
                    //

                    pciData->u.type0.BaseAddresses[barNo] =
                        (((IoMax + IoMin) / 2) + barLength) & (barLength -1);

                } else if (barLength >= (IoMax -
                                         ((IoMin & (barLength -1)) ?
                                            ((IoMin + barLength) & (barLength -1)) :
                                            IoMin))) {
                    //
                    // Space is tight, make a not-so-safe guess.  Try
                    // to put it at the bottom of the range, rounded
                    // up the the next natural alignment.
                    //

                    pciData->u.type0.BaseAddresses[barNo] =
                        ((IoMin & (barLength -1)) ?
                                            ((IoMin + barLength) & (barLength -1)) :
                                            IoMin);
                }

                IoMin = (USHORT)pciData->u.type0.BaseAddresses[barNo];
            }

            pciData->Command |= PCI_ENABLE_IO_SPACE;

            PciDevice->BaseAddress[barNo].Type = CmResourceTypePort;
            PciDevice->BaseAddress[barNo].Valid = TRUE;
            PciDevice->BaseAddress[barNo].TranslatedAddress =
                (PUCHAR)(ULONG_PTR)(pciData->u.type0.BaseAddresses[barNo] &
                PCI_ADDRESS_IO_ADDRESS_MASK);
            PciDevice->BaseAddress[barNo].Length = barLength;

        } else {

            //
            // This is a memory BAR.
            //

            barLength = ((barContents & PCI_ADDRESS_MEMORY_ADDRESS_MASK) - 1) ^
                0xffffffff;

            if (!(pciData->u.type0.BaseAddresses[barNo] &
                  PCI_ADDRESS_MEMORY_ADDRESS_MASK)) {

                //
                // And it's empty.
                //

                if (barLength == 0) continue;

                //
                // Try to fit this memory window half-way between the min and the max.
                //

                if ((ULONG)(MemMax - MemMin) >= (barLength * 3)) {

                    //
                    // There is plenty of room, make a safe guess.  Try
                    // to put it half-way between the upper and lower
                    // bounds, rounding up to the next natural alignment.
                    //

                    pciData->u.type0.BaseAddresses[barNo] =
                        (ULONG)(((MemMax + MemMin) / 2)
                                 + barLength) & ~(barLength -1);

                } else if (barLength >= (ULONG)(MemMax -
                                         ((MemMin & ~(barLength -1)) ?
                                            ((MemMin + barLength) & ~(barLength-1)) :
                                            MemMin))) {
                    //
                    // Space is tight, make a not-so-safe guess.  Try
                    // to put it at the bottom of the range, rounded
                    // up the the next natural alignment.
                    //

                    pciData->u.type0.BaseAddresses[barNo] =
                        (ULONG)((MemMin & ~(barLength -1)) ?
                                    ((MemMin + barLength) & ~(barLength -1)) :
                                      MemMin);
                }

                MemMin = pciData->u.type0.BaseAddresses[barNo] &
                    PCI_ADDRESS_MEMORY_ADDRESS_MASK;
            }

            pciData->Command |= PCI_ENABLE_MEMORY_SPACE;

            physicalAddress.HighPart = 0;
            physicalAddress.LowPart = pciData->u.type0.BaseAddresses[barNo]
                & PCI_ADDRESS_MEMORY_ADDRESS_MASK;
            PciDevice->BaseAddress[barNo].Type = CmResourceTypeMemory;
            PciDevice->BaseAddress[barNo].Valid = TRUE;
            PciDevice->BaseAddress[barNo].TranslatedAddress =
                HalpMapPhysicalMemory(physicalAddress,
                    ADDRESS_AND_SIZE_TO_SPAN_PAGES(physicalAddress.LowPart, barLength),
                    MmNonCached);
            PciDevice->BaseAddress[barNo].Length = barLength;
        }
    }

    pciData->Command |= PCI_ENABLE_BUS_MASTER;

    //
    // Write back any changes we made.
    //

    HalpPhase0SetPciDataByOffset(Bus,
                                 pciSlot.u.AsULONG,
                                 pciData,
                                 0,
                                 0x40);

    return STATUS_SUCCESS;
}

NTSTATUS
HalpSearchForPciDebuggingDevice(
    IN OUT PDEBUG_DEVICE_DESCRIPTOR PciDevice,
    IN ULONG                        StartBusNumber,
    IN ULONG                        EndBusNumber,
    IN ULONG                        MinMem,
    IN ULONG                        MaxMem,
    IN USHORT                       MinIo,
    IN USHORT                       MaxIo,
    IN BOOLEAN                      ConfigureBridges
    )
/*++

Routine Description:

    This routine is a helper function for
    HalpSetupPciDeviceForDebugging.

Arguments:

    PciDevice - Structure indicating the device

Return Value:

    STATUS_SUCCESS if the device is configured and usable.

    STATUS_NO_MORE_MATCHES if no device matched the criteria.

    STATUS_UNSUCCESSFUL if the routine fails for other reasons.
--*/
#define TARGET_DEVICE_NOT_FOUND 0x10000
{
    NTSTATUS            status;
    UCHAR               buffer[PCI_COMMON_HDR_LENGTH];
    PPCI_COMMON_CONFIG  pciData;
    UCHAR               bus, dev, func, bytesRead;
    PCI_SLOT_NUMBER     pciSlot, targetSlot;
    ULONG               newMinMem, newMaxMem;
    ULONG               newMinIo, newMaxIo;
    ULONG               newMinBus, newMaxBus;
    UCHAR               barNo;
    BOOLEAN             unconfigureBridge = FALSE;

    pciData = (PPCI_COMMON_CONFIG)buffer;
    pciSlot.u.AsULONG = 0;
    newMinMem = MinMem;
    newMaxMem = MaxMem;
    newMinIo = MinIo;
    newMaxIo = MaxIo;
    newMinBus = StartBusNumber;
    newMaxBus = EndBusNumber;
    bus = (UCHAR)StartBusNumber;

  //DbgPrint("HalpSearchForPciDebuggingDevice:\n"
  //         "\tMem: %x-%x\n"
  //         "\tI/O: %x-%x\n"
  //         "\tBus: %x-%x\n"
  //         "\t%s Configuring Bridges\n",
  //         MinMem, MaxMem,
  //         MinIo, MaxIo,
  //         StartBusNumber, EndBusNumber,
  //         ConfigureBridges ? "" : "Not");

    //
    // This bit stays set to 1 until we find the device.
    //
    targetSlot.u.bits.Reserved = TARGET_DEVICE_NOT_FOUND;

    while (TRUE) {

        UCHAR nextBus;

        nextBus = bus + 1;

        HalpFindFreeResourceLimits(bus,
                                   &newMinIo,
                                   &newMaxIo,
                                   &newMinMem,
                                   &newMaxMem,
                                   &newMinBus,
                                   &newMaxBus
                                   );

        for (dev = 0; dev < PCI_MAX_DEVICES; dev++) {
            for (func = 0; func < PCI_MAX_FUNCTION; func++) {

                pciSlot.u.bits.DeviceNumber = dev;
                pciSlot.u.bits.FunctionNumber = func;


                bytesRead = (UCHAR)HalpPhase0GetPciDataByOffset(bus,
                                     pciSlot.u.AsULONG,
                                     pciData,
                                     0,
                                     PCI_COMMON_HDR_LENGTH);

                if (bytesRead == 0) continue;

                if (pciData->VendorID != PCI_INVALID_VENDORID) {

                  //DbgPrint("%04x:%04x - %x/%x/%x - \tSlot: %x\n",
                  //         pciData->VendorID,
                  //         pciData->DeviceID,
                  //         pciData->BaseClass,
                  //         pciData->SubClass,
                  //         pciData->ProgIf,
                  //         pciSlot.u.AsULONG);

                    switch (PCI_CONFIGURATION_TYPE(pciData)) {
                    case PCI_DEVICE_TYPE:

                        //
                        // Match first on Bus/Dev/Func
                        //

                        if ((PciDevice->Bus == bus) &&
                            (PciDevice->Slot == pciSlot.u.AsULONG)) {

                          //DbgPrint("\n\nMatched on Bus/Slot\n\n");

                            return HalpSetupUnconfiguredDebuggingDevice(
                                        bus,
                                        pciSlot.u.AsULONG,
                                        newMinIo,
                                        newMaxIo,
                                        newMinMem,
                                        newMaxMem,
                                        PciDevice
                                        );
                        }

                        if ((PciDevice->Bus == MAXULONG) &&
                            (PciDevice->Slot == MAXULONG)) {

                            //
                            // Bus and Slot weren't specified.  Match
                            // on VID/DID.
                            //

                            if ((pciData->VendorID == PciDevice->VendorID) &&
                                (pciData->DeviceID == PciDevice->DeviceID)) {

                              //DbgPrint("\n\nMatched on Vend/Dev\n\n");

                                return HalpSetupUnconfiguredDebuggingDevice(
                                            bus,
                                            pciSlot.u.AsULONG,
                                            newMinIo,
                                            newMaxIo,
                                            newMinMem,
                                            newMaxMem,
                                            PciDevice
                                            );
                            }

                            if ((PciDevice->VendorID == MAXUSHORT) &&
                                (PciDevice->DeviceID == MAXUSHORT)) {

                                //
                                // VID/DID weren't specified.  Match
                                // on class codes.
                                //

                                if ((pciData->BaseClass == PciDevice->BaseClass) &&
                                    (pciData->SubClass == PciDevice->SubClass)) {

                                  //DbgPrint("\n\nMatched on Base/Sub\n\n");
                                    //
                                    // Further match on Programming Interface,
                                    // if specified.
                                    //

                                    if ((PciDevice->ProgIf != MAXUCHAR) &&
                                        (PciDevice->ProgIf != pciData->ProgIf)) {

                                        break;
                                    }

                                  //DbgPrint("\n\nMatched on programming interface\n\n");

                                    return HalpSetupUnconfiguredDebuggingDevice(
                                                bus,
                                                pciSlot.u.AsULONG,
                                                newMinIo,
                                                newMaxIo,
                                                newMinMem,
                                                newMaxMem,
                                                PciDevice
                                                );
                                }
                            }

                        }

                        break;

                    case PCI_CARDBUS_BRIDGE_TYPE:
                        //
                        // Cardbus bridge stuff here
                        //
                    case PCI_BRIDGE_TYPE:

                        {
                          ULONG  bridgeMemMin = 0, bridgeMemMax = 0;
                          USHORT bridgeIoMin, bridgeIoMax;

                        //DbgPrint("Found a PCI to PCI bridge\n");

                          if (!((pciData->u.type1.SecondaryBus != 0) &&
                                (pciData->u.type1.SubordinateBus !=0) &&
                                (pciData->Command & PCI_ENABLE_MEMORY_SPACE) &&
                                (pciData->Command & PCI_ENABLE_IO_SPACE))) {

                              //
                              // The bridge is unconfigured.
                              //

                              if (ConfigureBridges){

                                  //
                                  // We should configure it now.
                                  //

                                  status = HalpConfigurePciBridge(
                                                PciDevice,
                                                bus,
                                                pciSlot.u.AsULONG,
                                                newMinIo,
                                                newMaxIo,
                                                newMinMem,
                                                newMaxMem,
                                                MAX((UCHAR)newMinBus, (bus + 1)),
                                                newMaxBus,
                                                pciData
                                                );

                                  if (!NT_SUCCESS(status)) {
                                      break;
                                  }

                                  unconfigureBridge = TRUE;

                              } else {

                                  //
                                  // We aren't configuring bridges
                                  // on this pass.
                                  //

                                  break;
                              }

                          }

                          bridgeMemMin = PciBridgeMemory2Base(pciData->u.type1.MemoryBase);
                          bridgeMemMax = PciBridgeMemory2Limit(pciData->u.type1.MemoryLimit);
                          bridgeIoMin = (USHORT)PciBridgeIO2Base(pciData->u.type1.IOBase, 0);
                          bridgeIoMax = (USHORT)PciBridgeIO2Limit(pciData->u.type1.IOLimit, 0);

                        //DbgPrint("Configured:  I/O %x-%x  Mem %x-%x\n",
                        //         bridgeIoMin, bridgeIoMax,
                        //         bridgeMemMin, bridgeMemMax);

                          //
                          // Recurse.
                          //

                          status = HalpSearchForPciDebuggingDevice(
                              PciDevice,
                              (ULONG)pciData->u.type1.SecondaryBus,
                              (ULONG)pciData->u.type1.SubordinateBus,
                              bridgeMemMin,
                              bridgeMemMax,
                              bridgeIoMin,
                              bridgeIoMax,
                              ConfigureBridges);

                          if (NT_SUCCESS(status)) {
                              return status;
                          }

                          if (!unconfigureBridge) {

                              //
                              // Bump up the bus number so that we don't
                              // scan down the busses we just recursed into.
                              //

                              nextBus = pciData->u.type1.SubordinateBus + 1;

                          } else {

                              HalpUnconfigurePciBridge(bus,
                                                       pciSlot.u.AsULONG);
                          }
                        }

                        break;
                    default:
                        break;

                    }

                }

                if (!PCI_MULTIFUNCTION_DEVICE(pciData) &&
                    (func == 0)) {
                    break;
                }
            }
        }

        if (nextBus >= EndBusNumber) {
            break;
        }

        bus = nextBus;
    }

    return STATUS_NOT_FOUND;
}

NTSTATUS
HalpReleasePciDeviceForDebugging(
    IN OUT PDEBUG_DEVICE_DESCRIPTOR  PciDevice
    )
/*++

Routine Description:

    This routine de-allocates any resources acquired in
    HalpSetupPciDeviceForDebugging.

Arguments:

    PciDevice - Structure indicating the device

Return Value:

--*/
{
    ULONG i;

    for (i = 0; i < PCI_TYPE0_ADDRESSES; i++) {

        if (PciDevice->BaseAddress[i].Valid &&
            PciDevice->BaseAddress[i].Type == CmResourceTypeMemory) {

            PciDevice->BaseAddress[i].Valid = FALSE;

            HalpUnmapVirtualAddress(PciDevice->BaseAddress[i].TranslatedAddress,
                                    ADDRESS_AND_SIZE_TO_SPAN_PAGES(
                                        PciDevice->BaseAddress[i].TranslatedAddress,
                                        PciDevice->BaseAddress[i].Length));
        }
    }

    return STATUS_SUCCESS;
}

VOID
HalpRegisterKdSupportFunctions(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

Routine Description:

    This routine fills in the HalPrivateDispatchTable
    with the functions needed for debugging through
    PCI devices.

Arguments:

    LoaderBlock - The Loader Block

Return Value:

--*/
{

    KdSetupPciDeviceForDebugging = HalpSetupPciDeviceForDebugging;
    KdReleasePciDeviceForDebugging = HalpReleasePciDeviceForDebugging;

    KdGetAcpiTablePhase0 = HalpGetAcpiTablePhase0;
    KdMapPhysicalMemory64 = HalpMapPhysicalMemory64;

    KdCheckPowerButton = HalpCheckPowerButton;
}

VOID
HalpRegisterPciDebuggingDeviceInfo(
    VOID
    )
{
    OBJECT_ATTRIBUTES   ObjectAttributes;
    UNICODE_STRING      UnicodeString;
    HANDLE              BaseHandle = NULL;
    HANDLE              Handle = NULL;
    ULONG               disposition;
    ULONG               bus;
    UCHAR               i;
    PCI_SLOT_NUMBER     slot;
    NTSTATUS            status;
    BOOLEAN             debuggerFound = FALSE;

    PAGED_CODE();

    for (i = 0;
         i < MAX_DEBUGGING_DEVICES_SUPPORTED;
         i++) {

        if (HalpPciDebuggingDevice[i].u.bits.Reserved1 == TRUE) {
            //
            // Must be using a PCI device for a debugger.
            //
            debuggerFound = TRUE;
        }
    }

    if (!debuggerFound) {
        return;
    }

    //
    // Open PCI service key.
    //

    RtlInitUnicodeString (&UnicodeString,
                          L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET\\SERVICES\\PCI");

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               (PSECURITY_DESCRIPTOR) NULL);

    status = ZwOpenKey (&BaseHandle,
                        KEY_READ,
                        &ObjectAttributes);

    if (!NT_SUCCESS(status)) {
        return;
    }

    // Get the right key

    RtlInitUnicodeString (&UnicodeString,
                          L"Debug");

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               BaseHandle,
                               (PSECURITY_DESCRIPTOR) NULL);

    status = ZwCreateKey (&Handle,
                          KEY_READ,
                          &ObjectAttributes,
                          0,
                          (PUNICODE_STRING) NULL,
                          REG_OPTION_VOLATILE,
                          &disposition);

    ZwClose(BaseHandle);
    BaseHandle = Handle;

    ASSERT(disposition == REG_CREATED_NEW_KEY);

    if (!NT_SUCCESS(status)) {
        return;
    }

    for (i = 0;
         i < MAX_DEBUGGING_DEVICES_SUPPORTED;
         i++) {

        if (HalpPciDebuggingDevice[i].u.bits.Reserved1 == TRUE) {

            //
            // This entry is populated.  Create a key for it.
            //

            RtlInitUnicodeString (&UnicodeString,
                                  L"0");

            (*(PCHAR)&(UnicodeString.Buffer[0])) += i;

            InitializeObjectAttributes(&ObjectAttributes,
                                       &UnicodeString,
                                       OBJ_CASE_INSENSITIVE,
                                       BaseHandle,
                                       (PSECURITY_DESCRIPTOR) NULL);

            status = ZwCreateKey (&Handle,
                                  KEY_READ,
                                  &ObjectAttributes,
                                  0,
                                  (PUNICODE_STRING) NULL,
                                  REG_OPTION_VOLATILE,
                                  &disposition);

            ASSERT(disposition == REG_CREATED_NEW_KEY);

            //
            // Fill in the values below this key.
            //

            bus = HalpPciDebuggingDevice[i].u.bits.BusNumber;

            RtlInitUnicodeString (&UnicodeString,
                                  L"Bus");

            status = ZwSetValueKey (Handle,
                                    &UnicodeString,
                                    0,
                                    REG_DWORD,
                                    &bus,
                                    sizeof(ULONG));

            //ASSERT(NT_SUCCESS(status));

            slot.u.AsULONG = 0;
            slot.u.bits.FunctionNumber = HalpPciDebuggingDevice[i].u.bits.FunctionNumber;
            slot.u.bits.DeviceNumber = HalpPciDebuggingDevice[i].u.bits.DeviceNumber;

            RtlInitUnicodeString (&UnicodeString,
                                  L"Slot");

            status = ZwSetValueKey (Handle,
                                    &UnicodeString,
                                    0,
                                    REG_DWORD,
                                    &slot.u.AsULONG,
                                    sizeof(ULONG));

            //ASSERT(NT_SUCCESS(status));

            ZwClose(Handle);
        }
    }

    ZwClose(BaseHandle);
    return;
}

NTSTATUS
HalpConfigurePciBridge(
    IN      PDEBUG_DEVICE_DESCRIPTOR  PciDevice,
    IN      ULONG   Bus,
    IN      ULONG   Slot,
    IN      ULONG   IoMin,
    IN      ULONG   IoMax,
    IN      ULONG   MemMin,
    IN      ULONG   MemMax,
    IN      ULONG   BusMin,
    IN      ULONG   BusMax,
    IN OUT  PPCI_COMMON_CONFIG PciData
    )
{
    USHORT  memUnits = 0;
    ULONG   memSize;

    PciData->u.type1.PrimaryBus = (UCHAR)Bus;
    PciData->u.type1.SecondaryBus = (UCHAR)BusMin;
    PciData->u.type1.SubordinateBus = (UCHAR)(MIN(BusMax, (BusMin + 2)));

    PciData->Command &= ~PCI_ENABLE_BUS_MASTER;

  //DbgPrint("HalpConfigurePciBridge: P: %x  S: %x  S: %x\n"
  //         "\tI/O  %x-%x  Mem %x-%x  Bus %x-%x\n",
  //         PciData->u.type1.PrimaryBus,
  //         PciData->u.type1.SecondaryBus,
  //         PciData->u.type1.SubordinateBus,
  //         IoMin, IoMax,
  //         MemMin, MemMax,
  //         BusMin, BusMax);

    //
    // Only enable I/O on the bridge if we are looking for
    // something besides a 1394 controller.
    //

    if (!((PciDevice->BaseClass == PCI_CLASS_SERIAL_BUS_CTLR) &&
          (PciDevice->SubClass == PCI_SUBCLASS_SB_IEEE1394))) {

        if (((IoMax & 0xf000) - (IoMin & 0xf000)) >= 0X1000) {

            //
            // There is enough I/O space here to enable
            // an I/O window.
            //

            PciData->u.type1.IOBase =
                (UCHAR)((IoMax & 0xf000) >> 12) - 1;
            PciData->u.type1.IOLimit = PciData->u.type1.IOBase;

            PciData->Command |= PCI_ENABLE_IO_SPACE;
            PciData->Command |= PCI_ENABLE_BUS_MASTER;
        }
    }

    //
    // Enable a memory window if possible.
    //

    memSize = ((MemMax + 1) & 0xfff00000) - (MemMin & 0xfff00000);

    if (memSize >= 0x100000) {

        memUnits = 1;
    }

    if (memSize >= 0x400000) {

        memUnits = 4;
    }

    if (memUnits > 0) {

        //
        // There is enough space.
        //

        PciData->u.type1.MemoryBase =
            (USHORT)((MemMax & 0xfff00000) >> 16) - (memUnits << 4);

        PciData->u.type1.MemoryLimit = PciData->u.type1.MemoryBase + ((memUnits- 1) << 4);

        PciData->Command |= PCI_ENABLE_MEMORY_SPACE;
        PciData->Command |= PCI_ENABLE_BUS_MASTER;

    }

    if (PciData->Command & PCI_ENABLE_BUS_MASTER) {

        HalpPhase0SetPciDataByOffset(Bus,
                                     Slot,
                                     PciData,
                                     0,
                                     0x24);

        return STATUS_SUCCESS;

    } else {
        return STATUS_UNSUCCESSFUL;
    }
}

VOID
HalpUnconfigurePciBridge(
    IN  ULONG   Bus,
    IN  ULONG   Slot
    )
{
    UCHAR   buffer[0x20] = {0};

    //
    // Zero the command register.
    //

    HalpPhase0SetPciDataByOffset(Bus,
                                 Slot,
                                 buffer,
                                 FIELD_OFFSET (PCI_COMMON_CONFIG, Command),
                                 2);

    //
    // Zero the address space and bus number registers.
    //

    HalpPhase0SetPciDataByOffset(Bus,
                                 Slot,
                                 buffer,
                                 FIELD_OFFSET (PCI_COMMON_CONFIG, u),
                                 0x20);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\pmsleep.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pmsleep.c

Abstract:

    This file provides the code that changes the system from
    the ACPI S0 (running) state to any one of the sleep states.

Author:

    Jake Oshins (jakeo) Feb. 11, 1997

Revision History:

   Todd Kjos (HP) (v-tkjos) 1-Jun-1998: Initial port to IA64

--*/
#include "halp.h"
#include "acpitabl.h"
#include "xxacpi.h"
#include "ixsleep.h"
#include "kddll.h"

//
// Internal functions
//

VOID
HalpLockedIncrementUlong(
    PULONG SyncVariable
);

VOID
HalpReboot (
    VOID
    );

NTSTATUS
HaliAcpiFakeSleep(
    IN PVOID                        Context,
    IN PENTER_STATE_SYSTEM_HANDLER  SystemHandler   OPTIONAL,
    IN PVOID                        SystemContext,
    IN LONG                         NumberProcessors,
    IN volatile PLONG               Number
    );

NTSTATUS
HaliAcpiSleep(
    IN PVOID                        Context,
    IN PENTER_STATE_SYSTEM_HANDLER  SystemHandler   OPTIONAL,
    IN PVOID                        SystemContext,
    IN LONG                         NumberProcessors,
    IN volatile PLONG               Number
    );

VOID
HalpSetClockBeforeSleep(
    VOID
    );

VOID
HalpSetClockAfterSleep(
    VOID
    );

BOOLEAN
HalpWakeupTimeElapsed(
    VOID
    );

VOID
HalpReenableAcpi(
    VOID
    );

VOID
HalpSetInterruptControllerWakeupState(
    ULONG Context
    );

typedef struct _ERESOURCE {
    LIST_ENTRY SystemResourcesList;
    PVOID OwnerTable;
    SHORT ActiveCount;
    USHORT Flag;
    PKSEMAPHORE SharedWaiters;
    PKEVENT ExclusiveWaiters;
    LIST_ENTRY OwnerThreads[2];
    ULONG ContentionCount;
    USHORT NumberOfSharedWaiters;
    USHORT NumberOfExclusiveWaiters;
    union {
        PVOID Address;
        ULONG CreatorBackTraceIndex;
    };

    KSPIN_LOCK SpinLock;
} ERESOURCE, *PERESOURCE;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGELK, HaliAcpiSleep)
#pragma alloc_text(PAGELK, HaliAcpiFakeSleep)
#pragma alloc_text(PAGELK, HalpAcpiPreSleep)
#pragma alloc_text(PAGELK, HalpAcpiPostSleep)
#pragma alloc_text(PAGELK, HalpWakeupTimeElapsed)
#pragma alloc_text(PAGELK, HalpReenableAcpi)
#pragma alloc_text(PAGELK, HaliSetWakeEnable)
#pragma alloc_text(PAGELK, HaliSetWakeAlarm)
#endif

HAL_WAKEUP_STATE HalpWakeupState;
ULONG Barrier;
volatile ULONG HalpSleepSync;
PKPROCESSOR_STATE HalpHiberProcState;

#if DBG
BOOLEAN             HalpFailSleep  = FALSE;
#endif

#define PM1_TMR_EN 0x0001
#define PM1_RTC_EN 0x0400
#define WAK_STS    0x8000

#define HAL_PRIMARY_PROCESSOR 0

//
// For re-enabling the debugger's com port.
//
extern PUCHAR KdComPortInUse;


VOID
HalpAcpiFlushCache(
    )
{
    HalSweepDcache();
    HalSweepIcache();
}



VOID
HalpSaveProcessorStateAndWait(
    IN PKPROCESSOR_STATE ProcessorState,
    IN volatile PULONG   Count
    )
/*++
Rountine description:

    This function saves the volatile, non-volatile and special register
    state of the current processor.

    N.B. floating point state is NOT captured.

Arguments:

    ProcessorState  -  Address of processor state record to fill in.

    pBarrier - Address of a value to use as a lock.

Return Value:

    None.  This function does not return.

--*/
{

#if 0
    //
    // Fill in ProcessorState
    //

    KeSaveStateForHibernate(ProcessorState);

    //
    // Save return address, not caller's return address.
    //

    ProcessorState->ContextFrame.StIIP = HalpGetReturnAddress();
#endif

    //
    // Flush the cache, as the processor may be about to power off.
    //
    //
    HalpAcpiFlushCache();

    //
    // Singal that this processor has saved its state.
    //

    HalpLockedIncrementUlong(Count);

    //
    // Wait for the hibernation file to be written.
    // Processor 0 will zero Barrier when it is
    // finished.
    //
    // N.B.  We can't return from this function
    // before the hibernation file is finished
    // because we would be tearing down the very same
    // stack that we will be jumping onto when the
    // processor resumes.  But after the hibernation
    // file is written, it doesn't matter, because
    // the stack will be restored from disk.
    //

    while (*Count != 0);

}

BOOLEAN
HalpAcpiPreSleep(
    SLEEP_STATE_CONTEXT Context
    )
/*++

Routine Description:

Arguments:

    none

Return Value:

    status

--*/
{
    USHORT pmTimer;
    GEN_ADDR pm1a;
    GEN_ADDR pm1b;

    pm1a = HalpFixedAcpiDescTable.x_pm1a_evt_blk;
    pm1a.Address.QuadPart += (HalpFixedAcpiDescTable.x_pm1a_evt_blk.BitWidth / 2 / 8); // 2 because we want to cut it in half, 8 because we want to convert bits to bytes
    pm1a.BitWidth = HalpFixedAcpiDescTable.x_pm1a_evt_blk.BitWidth / 2;

    pm1b = HalpFixedAcpiDescTable.x_pm1b_evt_blk;
    pm1b.Address.QuadPart += (HalpFixedAcpiDescTable.x_pm1b_evt_blk.BitWidth / 2 / 8);
    pm1b.BitWidth = HalpFixedAcpiDescTable.x_pm1b_evt_blk.BitWidth / 2;

    HalpSleepContext.AsULONG = Context.AsULONG;

    #if DBG
        if (HalpFailSleep) {

            return FALSE;
        }
    #endif

    //
    // If we should have woken up already, don't sleep.
    //
    if (HalpWakeupTimeElapsed()) {
        return FALSE;
    }

    //
    // If an RTC alarm is set, then enable it and disable
    // periodic interrupts (for profiling.)
    //
    HalpSetClockBeforeSleep();

    //
    // Check to see if we need to disable all wakeup events.
    //

    if (!HalpWakeupState.GeneralWakeupEnable) {

        AcpiEnableDisableGPEvents(FALSE);

    } else {

        //
        // Only call this before going to sleep --- waking up should
        // reset the GPEs to the 'proper' value
        //

        AcpiGpeEnableWakeEvents();

    }

    if (Context.bits.Flags & SLEEP_STATE_SAVE_MOTHERBOARD) {

        HalpSaveDmaControllerState();

        HalpSaveTimerState();

    }

    //
    // We need to make sure that the PM timer is disabled from
    // this point onward. We also need to make that the
    // RTC Enable is only enabled if the RTC shold wake up the compiler
    //

    pmTimer = (USHORT)HalpReadGenAddr(&pm1a);

    if (HalpFixedAcpiDescTable.x_pm1b_evt_blk.Address.QuadPart) {

        pmTimer |= (USHORT)HalpReadGenAddr(&pm1b);
    }

    //
    // Clear the timer enable bit.
    //

    pmTimer &= ~PM1_TMR_EN;

    //
    // Check to see if we the machine supports RTC wake in Fixed Feature
    // space. Some machines implement RTC support via control methods.
    //
    if (!(HalpFixedAcpiDescTable.flags & RTC_WAKE_GENERIC) ) {

        //
        // Check to see f we need to disable/enable the RTC alarm
        //
        if (!HalpWakeupState.RtcWakeupEnable) {
           pmTimer &= ~PM1_RTC_EN;
        } else {
           pmTimer |= PM1_RTC_EN;

        }

    }


    //
    // Write it back into the hardware.
    //

    HalpWriteGenAddr(&pm1a, pmTimer);

    if (HalpFixedAcpiDescTable.x_pm1b_evt_blk.Address.QuadPart) {

        HalpWriteGenAddr(&pm1b, pmTimer);
    }

    return TRUE;
}

BOOLEAN
HalpAcpiPostSleep(
    ULONG Context
    )
{
    USHORT pmTimer;
    GEN_ADDR pm1a;
    GEN_ADDR pm1b;

    pm1a = HalpFixedAcpiDescTable.x_pm1a_evt_blk;
    pm1a.Address.QuadPart += (HalpFixedAcpiDescTable.pm1_evt_len / 2);

    pm1b = HalpFixedAcpiDescTable.x_pm1b_evt_blk;
    pm1b.Address.QuadPart += (HalpFixedAcpiDescTable.pm1_evt_len / 2);

    //
    // Read te currently set PM1 Enable bits.
    //

    pmTimer = (USHORT)HalpReadGenAddr(&pm1a);

    if (HalpFixedAcpiDescTable.x_pm1b_evt_blk.Address.QuadPart) {

        pmTimer |= (USHORT)HalpReadGenAddr(&pm1b);
    }

    //
    // Set the timer enable bit. Clear the RTC enable bit.
    //

    pmTimer &= ~PM1_RTC_EN;

    //
    // Write it back the new PM1 Enable bits
    //

    HalpWriteGenAddr(&pm1a, pmTimer);

    if (HalpFixedAcpiDescTable.x_pm1b_evt_blk.Address.QuadPart) {

        HalpWriteGenAddr(&pm1b, pmTimer);
    }

    //
    // Unset the RTC alarm and re-enable periodic interrupts.
    //
    HalpSetClockAfterSleep();

    HalpWakeupState.RtcWakeupEnable = FALSE;

    *((PULONG)HalpWakeVector) = 0;

   HalpSetInterruptControllerWakeupState(Context);

    if (HalpSleepContext.bits.Flags & SLEEP_STATE_SAVE_MOTHERBOARD) {

        //
        // If Kd was in use, then invalidate it.  It will re-sync itself.
        //
        if (KdComPortInUse) {
            KdRestore(TRUE);
        }

        HalpRestoreDmaControllerState();

        HalpRestoreTimerState();

    }

    //
    // Enable all GPEs, not just the wake ones
    //

    AcpiEnableDisableGPEvents(TRUE);

    return TRUE;
}


BOOLEAN
HalpWakeupTimeElapsed(
    VOID
    )
{
    LARGE_INTEGER wakeupTime, currentTime;
    TIME_FIELDS currentTimeFields;

    //
    // Check to see if a wakeup timer has already expired.
    //
    if (HalpWakeupState.RtcWakeupEnable) {

        HalQueryRealTimeClock(&currentTimeFields);

        RtlTimeFieldsToTime(&currentTimeFields,
                            &currentTime);

        RtlTimeFieldsToTime(&HalpWakeupState.RtcWakeupTime,
                            &wakeupTime);

        if (wakeupTime.QuadPart < currentTime.QuadPart) {
            return TRUE;
        }
    }

    return FALSE;
}

NTSTATUS
HaliSetWakeAlarm (
        IN ULONGLONG    WakeSystemTime,
        IN PTIME_FIELDS WakeTimeFields OPTIONAL
        )
/*++

Routine Description:

    This routine sets the real-time clock's alarm to go
    off at a specified time in the future and programs
    the ACPI chipset so that this wakes the computer.

Arguments:

    WakeSystemTime - amount of time that passes before we wake
    WakeTimeFields - time to wake broken down into TIME_FIELDS

Return Value:

    status

--*/
{
    if (WakeSystemTime == 0) {

        HalpWakeupState.RtcWakeupEnable = FALSE;
        return STATUS_SUCCESS;

    }

    ASSERT( WakeTimeFields );
    HalpWakeupState.RtcWakeupEnable = TRUE;
    HalpWakeupState.RtcWakeupTime = *WakeTimeFields;
    return HalpSetWakeAlarm(WakeSystemTime,
                            WakeTimeFields);
}

VOID
HaliSetWakeEnable(
        IN BOOLEAN      Enable
        )
/*++

Routine Description:

    This routine is called to set the policy for waking up.
    As we go to sleep, the global HalpWakeupState will be
    read and the hardware set accordingly.

Arguments:

    Enable - true or false

Return Value:

--*/
{
    if (Enable) {
        HalpWakeupState.GeneralWakeupEnable = TRUE;
    } else {
        HalpWakeupState.GeneralWakeupEnable = FALSE;
        HalpWakeupState.RtcWakeupEnable     = FALSE;
    }
}

VOID
HalpReenableAcpi(
    VOID
    )
/*++

Routine Description:

    This calls into the ACPI driver to switch back into ACPI mode,
    presumably after S4 and sets the ACPI registers that the HAL
    controls.

Arguments:

Return Value:

--*/
{
    // TEMPTEMP?
    HalpInitializeClock();

    AcpiInitEnableAcpi(TRUE);
    AcpiEnableDisableGPEvents(TRUE);
}

/*++

Routine Description:

    This is a stub to allow us to perform device powerdown
    testing on IA64 machines before they actually support
    real sleep states.

Arguments:

    <standard sleep handler args>

Return Value:

    STATUS_NOT_SUPPORTED
    
--*/

NTSTATUS
HaliAcpiFakeSleep(
    IN PVOID                        Context,
    IN PENTER_STATE_SYSTEM_HANDLER  SystemHandler   OPTIONAL,
    IN PVOID                        SystemContext,
    IN LONG                         NumberProcessors,
    IN volatile PLONG               Number
    )
{
    return STATUS_NOT_SUPPORTED;
}


NTSTATUS
HaliAcpiSleep(
    IN PVOID                        Context,
    IN PENTER_STATE_SYSTEM_HANDLER  SystemHandler   OPTIONAL,
    IN PVOID                        SystemContext,
    IN LONG                         NumberProcessors,
    IN volatile PLONG               Number
    )
/*++
Routine Description:

    At some point in time this function will be  called to put PCs into a sleep 
    state.  It saves motherboard state and then bails out.  For now this function
    is only called to implement S5 on Itanium.

Arguments:

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    KIRQL OldIrql;
    SLEEP_STATE_CONTEXT SleepContext;
    USHORT SlpTypA, SlpTypB, Pm1Control;
    PKPROCESSOR_STATE CurrentProcessorState;
    GEN_ADDR Pm1bEvt;
    PKPRCB Prcb;

    //
    // initial setup.
    //
    HalpDisableInterrupts();
    KeRaiseIrql(HIGH_LEVEL, &OldIrql);
    SleepContext.AsULONG = (ULONG) (((ULONGLONG) Context) & 0xffffffff);

    SlpTypA = (USHORT)HalpReadGenAddr(&HalpFixedAcpiDescTable.x_pm1a_ctrl_blk);
    if (HalpFixedAcpiDescTable.x_pm1b_ctrl_blk.Address.QuadPart) {
        SlpTypB = (USHORT)HalpReadGenAddr(&HalpFixedAcpiDescTable.x_pm1b_ctrl_blk);
    }


    //
    // If it is not processor 0, then goto wait loop.
    //
    Prcb = PCR->Prcb;
    if (Prcb->Number != 0) {
        //
        // Get processor number, get size of proc state and generate an index
        // into HalpHiberProcState.
        //

        CurrentProcessorState = HalpHiberProcState + Prcb->Number;
        HalpSaveProcessorStateAndWait(CurrentProcessorState,
                                      (PULONG) &HalpSleepSync);
    
        //
        // Wait for next phase
        //

        while (HalpSleepSync != 0);    // wait for barrier to move

    } else {                           // processor 0
        Barrier = 0;

        //
        // Make sure the other processors have saved their
        // state and begun to spin.
        //

        HalpLockedIncrementUlong((PULONG) &HalpSleepSync);
        while (NumberProcessors != (LONG) HalpSleepSync);

        //
        // Take care of chores (RTC, interrupt controller, etc.)
        //

        //
        // The hal has all of it's state saved into ram and is ready
        // for the power down.  If there's a system state handler give
        // it a shot
        //
    
        if (SystemHandler) {
            Status = (*SystemHandler)(SystemContext);
            if (!NT_SUCCESS(Status)) {
                HalpReenableAcpi();

                //
                // Restore the SLP_TYP registers.  (So that embedded controllers
                // and BIOSes can be sure that we think the machine is awake.)
                //
                HalpWriteGenAddr (&HalpFixedAcpiDescTable.x_pm1a_ctrl_blk, SlpTypA);
                if (HalpFixedAcpiDescTable.x_pm1b_ctrl_blk.Address.QuadPart) {
                    HalpWriteGenAddr(&HalpFixedAcpiDescTable.x_pm1b_ctrl_blk, SlpTypB);
                }

                HalpAcpiPostSleep(SleepContext.AsULONG);
            }

        } else {

            if (HalpAcpiPreSleep(SleepContext)) {

                //
                // If we will not be losing processor state, go to sleep.
                //

                if ((SleepContext.bits.Flags & SLEEP_STATE_FIRMWARE_RESTART) == 0) {

                    //
                    // Reset WAK_STS
                    //

                    HalpWriteGenAddr(&HalpFixedAcpiDescTable.x_pm1a_evt_blk, (USHORT) WAK_STS);
                    if (HalpFixedAcpiDescTable.x_pm1b_evt_blk.Address.QuadPart) {
                        HalpWriteGenAddr(&HalpFixedAcpiDescTable.x_pm1b_evt_blk, (USHORT) WAK_STS);
                    }

                    //
                    // Flush the caches if necessary
                    //

                    if (SleepContext.bits.Flags & SLEEP_STATE_FLUSH_CACHE) {
                        HalpAcpiFlushCache();
                    }

                    //
                    // Issue SLP commands to PM1a_CNT and PM1b_CNT
                    //

                    //
                    // nibble 0 is 1a sleep type, put it in position and enable sleep.
                    // preserve some bits in Pm1aCnt.
                    //
                    Pm1Control = (USHORT)HalpReadGenAddr(&HalpFixedAcpiDescTable.x_pm1a_ctrl_blk);
                    Pm1Control = (USHORT) ((Pm1Control & CTL_PRESERVE) | 
                                           (SleepContext.bits.Pm1aVal << SLP_TYP_SHIFT) | SLP_EN);
                    HalpWriteGenAddr (&HalpFixedAcpiDescTable.x_pm1a_ctrl_blk, Pm1Control);

                    //
                    // nibble 1 is 1b sleep type, put it in position and enable sleep
                    // preserve some bits in Pm1bCnt.
                    //
                    if (HalpFixedAcpiDescTable.x_pm1b_ctrl_blk.Address.QuadPart) {
                        Pm1Control = (USHORT)HalpReadGenAddr(&HalpFixedAcpiDescTable.x_pm1b_ctrl_blk);
                        Pm1Control = (USHORT) ((Pm1Control & CTL_PRESERVE) | 
                                               (SleepContext.bits.Pm1bVal << SLP_TYP_SHIFT) | SLP_EN);
                        HalpWriteGenAddr(&HalpFixedAcpiDescTable.x_pm1b_ctrl_blk, Pm1Control);
                    }

                    //
                    // Wait for sleep to be over
                    //

                    if (HalpFixedAcpiDescTable.x_pm1b_evt_blk.Address.QuadPart) {
                        Pm1bEvt = HalpFixedAcpiDescTable.x_pm1b_evt_blk;
                    } else {
                        Pm1bEvt = HalpFixedAcpiDescTable.x_pm1a_evt_blk;
                    }

                    while ( ((HalpReadGenAddr(&HalpFixedAcpiDescTable.x_pm1a_evt_blk) & WAK_STS) == 0) &&
                            ((HalpReadGenAddr(&Pm1bEvt) & WAK_STS) == 0) );

                } else {
                    CurrentProcessorState = HalpHiberProcState + Prcb->Number;
                    // HalpSetupStateForResume(CurrentProcessorState);
                }

            }       // HalpAcpiPreSleep() == 0
        }       // SystemHandler == 0

        //
        // Notify other processor of completion
        //

        HalpSleepSync = 0;

    }       // processor 0

    //
    // Restore each processor's APIC state.
    //
    // HalpPostSleepMP<NumberProc, Barrier>;

    //
    // Restore caller's IRQL.
    //
    KeLowerIrql(OldIrql);

    //
    // Exit.
    //
    // HalpSleepSync = 0;
    
    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\setupnvr.c ===
/*++

Module Name:

    setupnvr.c

Abstract:

    Access function to r/w environment variables from pseudo-NVRAM file

Author:

    Mudit Vats (v-muditv) 5-18-99

Revision History:

    6/4/99 added OSLOADOPTIONS

--*/
#include <stdio.h>
#include <string.h>
#include "halp.h"
#include "setupnvr.h"

#define SYSTEMPARTITION     0
#define OSLOADER            1
#define OSLOADPARTITION     2
#define OSLOADFILENAME      3
#define LOADIDENTIFIER      4
#define OSLOADOPTIONS       5
#define COUNTDOWN           6
#define AUTOLOAD            7
#define LASTKNOWNGOOD       8

#define BOOTNVRAMFILE         L"\\device\\harddisk0\\partition1\\boot.nvr"

PUCHAR HalpNvrKeys[] = {
    "SYSTEMPARTITION",
    "OSLOADER",
    "OSLOADPARTITION",
    "OSLOADFILENAME",
    "LOADIDENTIFIER",
    "OSLOADOPTIONS",
    "COUNTDOWN",
    "AUTOLOAD",
    "LASTKNOWNGOOD",
    ""
    };


//
//  All Pseudo-NVRAM vars stored here
//
char g_szBootVars[MAXBOOTVARS][MAXBOOTVARSIZE];


//
//  ReadNVRAM - read pseudo-nvram; read boot vars from "boot.nvr" file
//
int ReadNVRAM()
{
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    FILE_STANDARD_INFORMATION StandardInfo;
    char szBuffer[MAXBOOTVARSIZE+20];
    int i;
    ULONG LengthRemaining;
    ULONG CurrentLength;
    ULONG CurrentLine = 1;
    PCHAR KeyStart;
    PCHAR ValueStart;
    PCHAR pc;
    PCHAR ReadPos;
    PCHAR BufferEnd;
    CHAR c;
    BOOLEAN SkipSpace;

    //
    // Clear all variables.
    //

    for (i=SYSTEMPARTITION; i<=LASTKNOWNGOOD; i++) {
        g_szBootVars[i][0] = '\0';
    }

    RtlInitUnicodeString( &UnicodeString, BOOTNVRAMFILE );
    InitializeObjectAttributes(&Obja,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    Status = ZwCreateFile(
                &Handle,
                FILE_GENERIC_READ,
                &Obja,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                FILE_SHARE_READ,
                FILE_OPEN,
                FILE_SYNCHRONOUS_IO_NONALERT,
                NULL,
                0
                );

    if (!NT_SUCCESS(Status)) {
        //KdPrint(("HALIA64: Unable to open %ws for reading!\n", BOOTNVRAMFILE));
        //return NT_SUCCESS(Status);

        //
        // We didn't find the boot.nvr, so we will assume we are
        // doing a setup from cd
        //
        strcpy( g_szBootVars[0], "multi(0)disk(0)rdisk(0)partition(1)\0" );
        strcpy( g_szBootVars[1], "multi(0)disk(0)cdrom(1)\\setupldr.efi\0" );
        strcpy( g_szBootVars[2], "multi(0)disk(0)cdrom(1)\0" );
        strcpy( g_szBootVars[3], "\\IA64\0" );
        strcpy( g_szBootVars[4], "Microsoft Windows 2000 Setup\0" );
        strcpy( g_szBootVars[5], "\0" );
        strcpy( g_szBootVars[6], "30\0" );
        strcpy( g_szBootVars[7], "YES\0" );
        strcpy( g_szBootVars[8], "False\0" );

        return ERROR_OK;
    }

    Status = ZwQueryInformationFile( Handle,
                                     &IoStatusBlock,
                                     &StandardInfo,
                                     sizeof(FILE_STANDARD_INFORMATION),
                                     FileStandardInformation );

    if (!NT_SUCCESS(Status)) {
      KdPrint(("HALIA64: Error querying info on file %ws\n", BOOTNVRAMFILE));
      goto cleanup;
    }

    LengthRemaining = StandardInfo.EndOfFile.LowPart;
    
    KeyStart = ValueStart = szBuffer;
    ReadPos = szBuffer;
    SkipSpace = TRUE;

    while (LengthRemaining) {

        //
        // Read a buffer's worth of data from the 'nvram' file and
        // attempt to parse it one variable at a time.
        //

        CurrentLength = (ULONG)((szBuffer + sizeof(szBuffer)) - ReadPos);
        if (CurrentLength > LengthRemaining) {
            CurrentLength = LengthRemaining;
        }
        BufferEnd = ReadPos + CurrentLength;
        LengthRemaining -= CurrentLength;

        Status = ZwReadFile(Handle,
                            NULL,
                            NULL,
                            NULL,
                            &IoStatusBlock,
                            ReadPos,
                            CurrentLength,
                            NULL,
                            NULL
                            );

        if (!NT_SUCCESS(Status)) {
            KdPrint(("HALIA64: Error reading from %ws!\n", BOOTNVRAMFILE));
            goto cleanup;
        }

        //
        // Lines in the file are of the form KEY=VALUE\r, find the
        // start of the key, the start of the value and the start of
        // the next key.   Note the buffer is large enough to contain
        // at least one of the largest key and largest value.
        //

        for (pc = ReadPos; TRUE; pc++) {
            if (pc == BufferEnd) {

                //
                // Hit end of buffer.   If the data we are processing
                // begins at the start of the buffer then the data is
                // too big to process, abort.
                //

                if ((KeyStart == szBuffer) && (SkipSpace == FALSE)) {
                    KdPrint(("HALIA64: %ws line %d too long to process, aborting\n",
                             BOOTNVRAMFILE, CurrentLine));
                    Status = STATUS_UNSUCCESSFUL;
                    goto cleanup;
                }

                //
                // Move current line to start of buffer then read more
                // data into the buffer.
                //

                i = (int)((szBuffer + sizeof(szBuffer)) - KeyStart);
                RtlMoveMemory(szBuffer,
                              KeyStart,
                              i);

                ValueStart -= KeyStart - szBuffer;
                KeyStart = szBuffer;
                ReadPos = szBuffer + i;

                //
                // Break out of this loop and reexecute the read loop.
                //

                break;
            }
            c = *pc;

            if (c == '\0') {

                // 
                // Unexpected end of string, abort.
                //

                KdPrint(("HALIA64: Unexpected end of string in %ws!\n",
                         BOOTNVRAMFILE));
                Status = STATUS_UNSUCCESSFUL;
                goto cleanup;
            }

            if (SkipSpace == TRUE) {

                //
                // Skipping White Space.
                //

                if ((c == ' ') ||
                    (c == '\t') ||
                    (c == '\r') ||
                    (c == '\n')) {
                    continue;
                }

                //
                // Current character is NOT white space, set as
                // beginning of things we will look at.
                //

                KeyStart = ValueStart = pc;
                SkipSpace = FALSE;
            }

            if (c == '=') {
                if (ValueStart == KeyStart) {

                    //
                    // This is the first '=' on the line, the value
                    // starts in the next character position.
                    //

                    ValueStart = pc;
                }
            }
            if (c == '\r') {

                //
                // At end of line.   Treat from KeyStart to current
                // position as a single line containing a variable.
                //

                *ValueStart = '\0';
                for (i = 0; i < MAXBOOTVARS; i++) {
                    if (strcmp(KeyStart, HalpNvrKeys[i]) == 0) {

                        //
                        // Have a key match, copy from ValueStart+1
                        // thru end of line as the variable's value.
                        //

                        ULONGLONG ValueLength = pc - ValueStart - 1;

                        if (ValueLength >= MAXBOOTVARSIZE) {
                            ValueLength = MAXBOOTVARSIZE - 1;
                        }

                        RtlCopyMemory(g_szBootVars[i],
                                      ValueStart + 1,
                                      ValueLength);
                        g_szBootVars[i][ValueLength] = '\0';
                        CurrentLine++;
                        SkipSpace = TRUE;
                        break;
                    }
                }

                //
                // Start looking for the next key at the current
                // character position.
                //

                KeyStart = pc;
                ValueStart = pc;
            }
        }
    }

cleanup:

    ZwClose( Handle );
    return NT_SUCCESS( Status );
}



//
// WriteNVRAM - write pseudo-nvram; read boot vars from "boot.nvr" file
//
int WriteNVRAM()
{
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    HANDLE Handle;
    IO_STATUS_BLOCK IoStatusBlock;
    NTSTATUS Status;
    UCHAR szBuffer[MAXBOOTVARSIZE+20];
    ULONG BootVar;
    ULONG VarLen;

    RtlInitUnicodeString( &UnicodeString, BOOTNVRAMFILE );
    InitializeObjectAttributes( &Obja, &UnicodeString, OBJ_CASE_INSENSITIVE, NULL, NULL );

    Status = ZwCreateFile(
                &Handle,
                FILE_GENERIC_WRITE | DELETE,
                &Obja,
                &IoStatusBlock,
                NULL,
                FILE_ATTRIBUTE_NORMAL,
                0,                     // no sharing
                FILE_OVERWRITE_IF,
                FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT |  FILE_WRITE_THROUGH,
                NULL,
                0
                );

    if(!NT_SUCCESS(Status)) {
        KdPrint(("HALIA64: Unable to open %ws for writing!\n", BOOTNVRAMFILE));
        return ERROR_NOTOK;
    }

    //
    // Generate an entry of the form NAME=VALUE for each variable
    // and write it to the 'nvram' file.
    //

    for ( BootVar = 0; BootVar < MAXBOOTVARS; BootVar++ ) {
        VarLen = _snprintf(szBuffer, 
                           sizeof(szBuffer),
                           "%s=%s\r\n",
                           HalpNvrKeys[BootVar],
                           g_szBootVars[BootVar]);
    
        Status = ZwWriteFile(
                Handle,
                NULL,
                NULL,
                NULL,
                &IoStatusBlock,
                szBuffer,
                VarLen,
                NULL,
                NULL
                );

        if (!NT_SUCCESS(Status)) {
            KdPrint(("HALIA64: Error writing %s to %ws!\n",
                     HalpNvrKeys[BootVar],
                     BOOTNVRAMFILE));
            goto cleanup;
        }
    }

cleanup:

    ZwClose( Handle );
    return NT_SUCCESS( Status );
}


//
//  GetBootVar - gets the requested boot environment variable
//
//    szBootVar  - this is the requested boot var:
//
//                 SYSTEMPARTITION
//                 OSLOADER
//                 OSLOADPARTITION
//                 OSLOADFILENAME
//                 LOADIDENTIFIER
//                 OSLOADOPTIONS
//                 COUNTDOWN
//                 AUTOLOAD
//                 LASTKNOWNGOOD 
//    nLength   - length of szBootVal (input buffer)
//    szBootVal - boot environment variable returned here
//
int
GetBootVar(
    PCHAR  szBootVar,
    USHORT nLength,
    PCHAR  szBootVal
    )
{
    ULONG BootVar;

    //
    // Search the boot variable keys for a match.
    //

    for ( BootVar = 0; BootVar < MAXBOOTVARS; BootVar++ ) {
        if (_stricmp(szBootVar, HalpNvrKeys[BootVar]) == 0) {

            //
            // Found a key match, copy the variable's value to the 
            // caller's buffer.
            //

            strncpy(szBootVal, g_szBootVars[BootVar], nLength);
            return ERROR_OK;
        }
    }

    //
    // No such variable, return error.
    //

    return ERROR_NOTOK;
}


//
//  SetBootVar - sets the requested boot environment variable
//
//    szBootVar  - this is the requested boot var:
//
//                 SYSTEMPARTITION
//                 OSLOADER
//                 OSLOADPARTITION
//                 OSLOADFILENAME
//                 LOADIDENTIFIER
//                 OSLOADOPTIONS
//                 COUNTDOWN
//                 AUTOLOAD
//                 LASTKNOWNGOOD 
//    szBootVal - new boot environment variable value
//
int
SetBootVar(
    PCHAR szBootVar,
    PCHAR szBootVal
    )
{
    ULONG BootVar;

    //
    // Search the boot variable keys for a match.
    //

    for ( BootVar = 0; BootVar < MAXBOOTVARS; BootVar++ ) {
        if (_stricmp(szBootVar, HalpNvrKeys[BootVar]) == 0) {

            //
            // Found it, copy the new value to this value.
            //

            strncpy(g_szBootVars[BootVar], szBootVal, MAXBOOTVARSIZE);
            return ERROR_OK;
        }
    }

    //
    // No such variable, return error.
    //

    return ERROR_NOTOK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\sratnuma.c ===
//
// Get the IA64 versions of the following files.
//

#include "halp.h"
#include "acpitabl.h"
#include "xxacpi.h"

//
// Use common code.
//

#include "..\..\halacpi\sratnuma.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\pmsapic.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    pmsapic.c

Abstract:

    Implements various SAPIC-ACPI functions.

Author:

    Todd Kjos (Hewlett-Packard) 20-Apr-1998

    Based on I386 version of pmapic.c:
      Jake Oshins (jakeo) 19-May-1997

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "acpitabl.h"
#include "iosapic.h"
#include "xxacpi.h"
#include "ixsleep.h"

PMAPIC HalpApicTable;

struct  _IOAPIC_DEBUG_TABLE
{
    PIO_INTR_CONTROL    IoIntrControl;
    PIO_SAPIC_REGS      IoSapicRegs;

}   *HalpApicDebugAddresses;

ULONG
DetectAcpiMP(
    OUT PBOOLEAN IsConfiguredMp,
    IN  PLOADER_PARAMETER_BLOCK LoaderBlock
    );

VOID
HalpInitMPInfo(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN PMAPIC ApicTable
    );

BOOLEAN
HalpVerifyIoSapic(
    IN PUCHAR BaseAddress
    );
VOID
HalpSaveInterruptControllerState(
    VOID
    );

VOID
HalpRestoreInterruptControllerState(
    VOID
    );

VOID
HalpSetInterruptControllerWakeupState(
    ULONG Context
    );

VOID
HalpSetCPEVectorState(
    IN ULONG  GlobalInterrupt,
    IN UCHAR  SapicVector,
    IN USHORT DestinationCPU,
    IN ULONG  Flags
    );

VOID
HalpProcessLocalSapic(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN PPROCLOCALSAPIC ProcLocalSapic
    );

VOID
HalpProcessIoSapic(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN PIOSAPIC IoSapic
    );

VOID
HalpProcessIsaVector(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN PISA_VECTOR IsaVector
    );

VOID
HalpProcessPlatformInt(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN PPLATFORM_INTERRUPT PlatformInt
    );

extern UCHAR  rgzNoApicTable[];
extern UCHAR  rgzNoApic[];
extern UCHAR  rgzApicNotVerified[];
extern ULONG HalpPicVectorRedirect[];

struct _MPINFO HalpMpInfo;
extern ULONG HalpPicVectorFlags[];
extern ULONG HalpIpiClock;
extern BOOLEAN HalpHiberInProgress;

// from pmdata.c: CPE related.
extern ULONG  HalpCPEIntIn[];
extern USHORT HalpCPEDestination[];
extern ULONG  HalpCPEVectorFlags[];
extern UCHAR  HalpCPEIoSapicVector[];
extern ULONG  HalpMaxCPEImplemented;

BOOLEAN HalpPicStateIntact = TRUE;

PIO_INTR_CONTROL HalpIoSapicList = NULL;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DetectAcpiMP)
#pragma alloc_text(INIT, HalpInitMPInfo)
#pragma alloc_text(INIT, HalpProcessLocalSapic)
#pragma alloc_text(INIT, HalpProcessIoSapic)
#pragma alloc_text(INIT, HalpProcessIsaVector)
#pragma alloc_text(INIT, HalpProcessPlatformInt)
#pragma alloc_text(PAGELK, HalpVerifyIoSapic)
#pragma alloc_text(PAGELK, HalpSaveInterruptControllerState)
#pragma alloc_text(PAGELK, HalpRestoreInterruptControllerState)
#pragma alloc_text(PAGELK, HalpSetInterruptControllerWakeupState)
#pragma alloc_text(PAGELK, HalpAcpiPicStateIntact)
#endif


ULONG
DetectAcpiMP(
    OUT PBOOLEAN IsConfiguredMp,
    IN  PLOADER_PARAMETER_BLOCK LoaderBlock
    )
{
    UCHAR ApicVersion, index, processorNumber;
    PUCHAR  LocalApic;
    NTSTATUS status;

    //
    // Make sure there is an SAPIC Table
    //

    HalpApicTable = HalpGetAcpiTablePhase0(LoaderBlock, APIC_SIGNATURE);

    if (HalpApicTable == NULL) {
        HalDisplayString(rgzNoApicTable);
        KeBugCheckEx(ACPI_BIOS_ERROR, 0x11, 10, 0, 0);
        return(FALSE);
    }

    HalDebugPrint(( HAL_INFO, "HAL: Found a MADT table at %p\n", HalpApicTable ));

    HalDebugPrint(( HAL_INFO, "HAL: Signature: %x      Length: %x\n",
                    HalpApicTable->Header.Signature,
                    HalpApicTable->Header.Length ));

    HalDebugPrint(( HAL_INFO, "HAL: OEMID: %s\n", HalpApicTable->Header.OEMID ));

    // We have a SAPIC table. Initialize the interrupt info structure

    HalpInitMPInfo(LoaderBlock, HalpApicTable);

    if (HalpMpInfo.IoSapicCount == 0) {
        //
        //  There are no IO Sapics.
        //
        //  Should we allow this case on the theory that
        //  that all the interrupts are connected to LINTx pins on the CPU?
        //
        HalDebugPrint(( HAL_ERROR, rgzNoApic ));
        return (FALSE);
    }

    if (HalpMpInfo.ProcessorCount == 0) {

        KeBugCheckEx(ACPI_BIOS_ERROR, 0x11, 11, 0, 0);
    }

    //
    // Initialize NtProcessorNumber in the order that we are going to process
    // them in HalStartNextProcessor.  The BSP is 0 and the rest are numbered
    // in the order the Local SAPICs appear in the MADT starting at 1.
    //

    processorNumber = 1;
    for (index = 0; index < HalpMpInfo.ProcessorCount; index++) {

        if (HalpProcessorInfo[index].LocalApicID == (USHORT)PCR->HalReserved[PROCESSOR_ID_INDEX]) {

            HalpProcessorInfo[index].NtProcessorNumber = 0;

        } else {

            HalpProcessorInfo[index].NtProcessorNumber = processorNumber++;
        }
    }

    *IsConfiguredMp = (HalpMpInfo.ProcessorCount > 1 ? TRUE : FALSE);
    return TRUE;
}

#define IO_SAPIC_REGS_SIZE 4096


VOID
HalpInitMPInfo(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN PMAPIC ApicTable
    )
/*++
Routine Description:
    This routine initializes a HAL specific data structure that is
    used by the HAL to simplify access to MP information.

Arguments:
    SapicTable Pointer to the SAPIC table.

 Return Value:
     None

*/
{
    PAPICTABLE  TablePtr;
    ULONG i;

    HalpMpInfo.ProcessorCount = 0;
    HalpMpInfo.IoSapicCount = 0;

    // Walk the Multiple Apic table...

    TablePtr = (PAPICTABLE) ApicTable->APICTables;

    // Loop ends when TraversePtr is off the end of the table...
    while ((UINT_PTR)TablePtr <
           ((UINT_PTR)ApicTable + ApicTable->Header.Length)) {

        if (TablePtr->Type == LOCAL_SAPIC) {

            HalpProcessLocalSapic(LoaderBlock, (PPROCLOCALSAPIC)TablePtr);

        } else if (TablePtr->Type == IO_SAPIC) {

            HalpProcessIoSapic(LoaderBlock, (PIOSAPIC)TablePtr);

        } else if (TablePtr->Type == ISA_VECTOR_OVERRIDE) {

            HalpProcessIsaVector(LoaderBlock, (PISA_VECTOR)TablePtr);

        } else if (TablePtr->Type == PLATFORM_INTERRUPT_SOURCE)  {

            HalpProcessPlatformInt(LoaderBlock, (PPLATFORM_INTERRUPT)TablePtr);

        } else {

           HalDebugPrint(( HAL_ERROR, "HAL: Processing MADT - Skip Table %p: Type = %d, Length = %d\n", TablePtr, TablePtr->Type, TablePtr->Length ));
        }

        (UINT_PTR)TablePtr += TablePtr->Length;
    }
    //
    // Check if there is Interrupt Source Override entry. If there is, force the
    // new flags into the SAPIC state. This is done now because of the possibility
    // the firmware can place the ISO Vector Override entry ahead of IOSAPIC entry.
    //
    for (i = 0; i < PIC_VECTORS; i++) {
        if (HalpPicVectorFlags[i]) {
            HaliSetVectorState( HalpPicVectorRedirect[i],
                                HalpPicVectorFlags[i]
                              );
        }
    }

}

VOID
HalpProcessLocalSapic(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN PPROCLOCALSAPIC ProcLocalSapic
    )
{
    USHORT  LID;
    ULONG ProcessorNum;

    if (ProcLocalSapic->Length != PROCESSOR_LOCAL_SAPIC_LENGTH) {
        HalDebugPrint(( HAL_ERROR,
                        "HAL: HalpProcessLocalSapic - Invalid Length %p: Expected %d, Found %d\n",
                        ProcLocalSapic,
                        PROCESSOR_LOCAL_SAPIC_LENGTH,
                        ProcLocalSapic->Length ));
        return;
    }

    // Make sure processor is enabled...
    if (!(ProcLocalSapic->Flags & PLAF_ENABLED)) {

        return;
    }

    // It is.  Bump the count and store the LID value for IPIs

    LID = (ProcLocalSapic->APICID << 8) | ProcLocalSapic->APICEID;

    HalpProcessorInfo[HalpMpInfo.ProcessorCount].AcpiProcessorID = ProcLocalSapic->ACPIProcessorID;
    HalpProcessorInfo[HalpMpInfo.ProcessorCount].LocalApicID = LID;

    HalpMpInfo.ProcessorCount++;

    HalDebugPrint(( HAL_INFO,
                    "HAL: Found a processor-local SAPIC: %p LID=%x\n",
                    ProcLocalSapic,
                    LID ));
}

VOID
HalpProcessIoSapic(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN PIOSAPIC IoSapic
    )
{
    ULONG IntiBase,RedirEntries;
    PHYSICAL_ADDRESS IoSapicPhys;
    PVOID IoSapicBase;
    UINT_PTR IoSapicPhysBase;
    PIO_SAPIC_REGS SapicRegs;
    PIO_INTR_CONTROL IoIntrControl;
    ULONG   i;

    union {
        ULONG        raw;
        SAPIC_VERSION version;
    } versionUnion;

    if (IoSapic->Length != IO_SAPIC_LENGTH) {

        HalDebugPrint(( HAL_ERROR,
                        "HAL: HalpProcessIoSapic - Invalid Length %p: Expected %d, Found %d\n",
                        IoSapic,
                        IO_SAPIC_LENGTH,
                        IoSapic->Length ));

        return;
    }

    HalDebugPrint(( HAL_INFO, "HAL: Found an IO SAPIC: %p\n", IoSapic ));

    // Map IO Sapic Registers...
    IntiBase = IoSapic->SystemVectorBase;
    IoSapicPhysBase = IoSapic->IOSAPICAddress;
    IoSapicPhys.QuadPart = (UINT_PTR)IoSapicPhysBase;
    IoSapicBase = HalpMapPhysicalMemory( IoSapicPhys,
                                ADDRESS_AND_SIZE_TO_SPAN_PAGES(IoSapicPhys.LowPart, IO_SAPIC_REGS_SIZE),
                                MmNonCached);
    ASSERT(IoSapicBase);

    SapicRegs = (PIO_SAPIC_REGS)IoSapicBase;

    if (!SapicRegs) {
        HalDebugPrint(( HAL_ERROR, "HAL: Couldn't map the I/O Sapic\n" ));
        return;
    }

    // Read the IO Sapic version and extract the number of redirection table entries
    SapicRegs->RegisterSelect = IO_VERS_REGISTER;
    SapicRegs->RegisterWindow = 0;
    versionUnion.raw = SapicRegs->RegisterWindow;

    //
    // CPQMOD_JL001 - Incorrect count - hw provide max rte index not
    // count.
    //
    //RedirEntries = versionUnion.version.MaxRedirEntries;
    RedirEntries = versionUnion.version.MaxRedirEntries + 1;

    if (HalpVerifyIoSapic((PUCHAR)SapicRegs)) {

        // Allocate and fill out a IO Sapic structure
        PHYSICAL_ADDRESS    physicalAddress;

        physicalAddress.QuadPart = (LONGLONG)HalpAllocPhysicalMemory(
            LoaderBlock,
            ~0,
            BYTES_TO_PAGES(sizeof(IO_INTR_CONTROL) + (RedirEntries*sizeof(IOSAPICINTI))),
            FALSE );

        if (physicalAddress.QuadPart == 0)  {
            HalDebugPrint(( HAL_ERROR, "HAL: Couldn't allocate memory for the IO Sapic structures\n" ));
            return;
        }

        IoIntrControl = (PIO_INTR_CONTROL)HalpMapPhysicalMemory(
            physicalAddress,
            ADDRESS_AND_SIZE_TO_SPAN_PAGES(physicalAddress.LowPart, sizeof(IO_INTR_CONTROL) + (RedirEntries*sizeof(IOSAPICINTI))),
            MmCached );

        ASSERT(IoIntrControl);

        IoIntrControl->IntiBase = IntiBase;
        IoIntrControl->IntiMax  = IntiBase + RedirEntries - 1;
        IoIntrControl->RegBaseVirtual = IoSapicBase;
        IoIntrControl->RegBasePhysical = IoSapicPhys;
        IoIntrControl->IntrMethods = &HalpIoSapicMethods;
        IoIntrControl->InterruptAffinity = 0xffffffff;
        IoIntrControl->NextCpu = 0;
        IoIntrControl->flink = NULL;

        for (i = 0; i < RedirEntries; i++) {
            IoIntrControl->Inti[i].Vector =
                DELIVER_FIXED | ACTIVE_LOW | LEVEL_TRIGGERED;
            IoIntrControl->Inti[i].Destination = 0;
            IoIntrControl->Inti[i].GlobalVector = 0;

            //
            // CPQMOD_JL002 - Fix for using the rte and not the
            // SystemVector.
            //
            //IoIntrControl->IntrMethods->MaskEntry(IoIntrControl,IntiBase+i);
            IoIntrControl->IntrMethods->MaskEntry(IoIntrControl,i);
        }

        // Insert structure into list.  Since we are running on P0 at
        // Phase0 initialization, we can assume that no one else is
        // modifying this list therefore no synchronization is needed.
        if (HalpIoSapicList == NULL) {
            HalpIoSapicList = IoIntrControl;
        } else {
            PIO_INTR_CONTROL *LastLink;
            PIO_INTR_CONTROL IoSapicListEntry;
            LastLink = &HalpIoSapicList;
            IoSapicListEntry = HalpIoSapicList;
            while (IoSapicListEntry != NULL) {

                if (IoSapicListEntry->IntiBase > IoIntrControl->IntiMax) {
                    // Insert new entry before current entry
                    IoIntrControl->flink = *LastLink;
                    *LastLink = IoIntrControl;
                    break;
                } else {
                    LastLink = &IoSapicListEntry->flink;
                    IoSapicListEntry = IoSapicListEntry->flink;
                }
            }
            if (IoSapicListEntry == NULL) {
                // We got to the end of the list.  The new entry goes
                // after the last entry...
                *LastLink = IoIntrControl;
            }
        }

        HalpMpInfo.IoSapicCount++;

    } else {
        // The Io Sapic is not there, ignore this entry in the table
        HalDebugPrint(( HAL_ERROR, rgzApicNotVerified ));
        HalpUnmapVirtualAddress(IoSapicBase, ADDRESS_AND_SIZE_TO_SPAN_PAGES(IoSapicBase, IO_SAPIC_REGS_SIZE));
    }
}

VOID
HalpProcessIsaVector(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN PISA_VECTOR IsaVector
    )
{
    if (IsaVector->Length != ISA_VECTOR_OVERRIDE_LENGTH) {

        HalDebugPrint(( HAL_ERROR,
                        "HAL: HalpProcessIsaVector - Invalid Length %p: Expected %d, Found %d\n",
                        IsaVector,
                        ISA_VECTOR_OVERRIDE_LENGTH,
                        IsaVector->Length ));

        return;
    }

    //
    // Found an ISA vector redirection entry.
    //

    HalpPicVectorRedirect[IsaVector->Source] =
        IsaVector->GlobalSystemInterruptVector;

    HalpPicVectorFlags[IsaVector->Source] = IsaVector->Flags;

    HalDebugPrint(( HAL_INFO, "HAL: Found an ISA VECTOR: %p, %x -> %x, flags: %x\n",
                    IsaVector,
                    IsaVector->Source,
                    IsaVector->GlobalSystemInterruptVector,
                    IsaVector->Flags ));
}

VOID
HalpProcessPlatformInt(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN PPLATFORM_INTERRUPT PlatformInt
    )
{
    static  ULONG   currentCPECount = 0;

    if (PlatformInt->Length != PLATFORM_INTERRUPT_SOURCE_LENGTH) {

        HalDebugPrint(( HAL_ERROR,
                        "HAL: HalpProcessPlatformInt - Invalid Length %p: Expected %d, Found %d\n",
                        PlatformInt,
                        PLATFORM_INTERRUPT_SOURCE_LENGTH,
                        PlatformInt->Length ));

        return;
    }

    //
    // Process a Corrected Platform Error Interrupt Source structure.
    //

    if (PlatformInt->InterruptType == PLATFORM_INT_CPE) {


        //
        // Does this platform has more (than what we expected) number of CPE sources?
        //

        if ( currentCPECount >= HALP_CPE_MAX_INTERRUPT_SOURCES ) {

            HalDebugPrint(( HAL_ERROR,
                        "HAL: Platform Interrupt Source %p skipped due to overflow: %ld >= HALP_CPE_MAX_INTERRUPT_SOURCES\n", PlatformInt, currentCPECount ));

            return;
        }

        //
        // Save the input pin number of SAPIC for this CPE source
        //

        HalpCPEIntIn[currentCPECount] = (ULONG)PlatformInt->GlobalVector;

        //
        // Save the Flags for this CPE source
        //

        HalpCPEVectorFlags[currentCPECount] = (ULONG)PlatformInt->Flags;

        //
        // Save the IO Sapic Vector (that BIOS expects OS to use) for this platform CMC source
        //

        HalpCPEIoSapicVector[currentCPECount] = (UCHAR)PlatformInt->IOSAPICVector;

// Thierry - WARNING - 09/19/2000
//    NT HAL ignores the IO SAPIC vector field for the platform interrupt sources.
//    NT imposes the CPEI_VECTOR value for Corrected Machine Errors interrupt vector, for all
//    the destination processors. Actually, the current default is to attach all the processors
//    IDT[CPEI_VECTOR] with the HAL default ISR - HalpCPEIHandler for the CPE interrupt model.
//    We will connect the ISR only for the destination processors after testing if judged valid.
//    The rationales are:
//       - IOSAPICVector was mostly added in the specs by Intel for IA64 PMI interrupt sources.
//         These PMI interrupts are not visible by NT.
//       - NT has no infrastructure at this time to support vector registration for FW/chipset
//         generated external interrupts visible to NT.
//       - Having the FW specifying the vector requires the HAL to control the specified
//         value with its current IDT[] related resources usage and defines actions in case
//         of conficts.
//

        HalDebugPrint(( HAL_INFO, "HAL: CPE source VECTOR: %x. HAL imposes VECTOR: %x\n",
                                  HalpCPEIoSapicVector[currentCPECount],
                                  CPEI_VECTOR ));
        HalpCPEIoSapicVector[currentCPECount] = (UCHAR)(CPEI_VECTOR);

        //
        // Save the Destination Processor (that BIOS expects OS to use) for this CPE source)
        //

        HalpCPEDestination[currentCPECount] = (USHORT)(
            (PlatformInt->APICID << 8) | PlatformInt->ACPIEID);

        //
        // Force the flags into the SAPIC state
        //

        HalpSetCPEVectorState( HalpCPEIntIn[currentCPECount],
                               HalpCPEIoSapicVector[currentCPECount],
                               HalpCPEDestination[currentCPECount],
                               HalpCPEVectorFlags[currentCPECount]
                             );


        HalDebugPrint(( HAL_INFO, "HAL: Found an Platform Interrupt VECTOR: %p, %x -> %x, flags: %x\n",
                                  PlatformInt,
                                  PlatformInt->IOSAPICVector,
                                  PlatformInt->GlobalVector,
                                  PlatformInt->Flags ));

        //
        // Keep track of how many CPE sources are implemented in the platform.
        //

        HalpMaxCPEImplemented = ++currentCPECount;

    }
    else if (  ( PlatformInt->InterruptType == PLATFORM_INT_PMI  ) ||
               ( PlatformInt->InterruptType == PLATFORM_INT_INIT ) )   {

        HalpWriteRedirEntry( PlatformInt->GlobalVector,
                             PlatformInt->IOSAPICVector,
                             (USHORT)((PlatformInt->APICID <<8) | PlatformInt->ACPIEID),
                             PlatformInt->Flags,
                             PlatformInt->InterruptType
                           );

    }

    return;
}

BOOLEAN
HalpVerifyIoSapic(
    IN PUCHAR BaseAddress
    )
/*++

Routine Description:

    Verify that an IO Sapic Unit exists at the specified address

 Arguments:

    BaseAddress - Virtual address of the IO Unit to test.

 Return Value:
    BOOLEAN - TRUE if a IO Unit was found at the passed address
            - FALSE otherwise

--*/

{
    union SapicUnion {
        ULONG Raw;
        struct SapicVersion Ver;
    } Temp1, Temp2;

    PIO_SAPIC_REGS IoUnitPtr = (PIO_SAPIC_REGS) BaseAddress;

    //
    //  The documented detection mechanism is to write all zeros to
    //  the Version register.  Then read it back.  The IO Unit exists if the
    //  same result is read both times and the Version is valid.
    //

    IoUnitPtr->RegisterSelect = IO_VERS_REGISTER;
    IoUnitPtr->RegisterWindow = 0;

    IoUnitPtr->RegisterSelect = IO_VERS_REGISTER;
    Temp1.Raw = IoUnitPtr->RegisterWindow;

    IoUnitPtr->RegisterSelect = IO_VERS_REGISTER;
    IoUnitPtr->RegisterWindow = 0;

    IoUnitPtr->RegisterSelect = IO_VERS_REGISTER;
    Temp2.Raw = IoUnitPtr->RegisterWindow;

    if ( Temp1.Raw == 0 ||
        (Temp1.Ver.Version != Temp2.Ver.Version) ||
        (Temp1.Ver.MaxRedirEntries != Temp2.Ver.MaxRedirEntries)) {
        //
        //  No IO Unit There
        //
        HalDebugPrint(( HAL_ERROR, "HAL: No IoSapic at %I64x\n", BaseAddress ));
        return (FALSE);
    }

    HalDebugPrint(( HAL_INFO, "HAL: IoSapic found at %I64x, Max Entries = %d\n", BaseAddress, Temp1.Ver.MaxRedirEntries ));

    return (TRUE);
}

VOID
HalpInitApicDebugMappings(
    VOID
    )
/*++

Routine Description:

    This routine is called at the very beginning of phase 1 initialization.
    It creates mappings for the APICs using MmMapIoSpace.  This will allow
    us to access their registers from the debugger.

    A much better solution would be to allow us to describe our memory usage to
    MM but ....

 Arguments:


 Return Value:

--*/
{
    PHYSICAL_ADDRESS physicalAddress;
    PIO_INTR_CONTROL IoIntrControl;
    ULONG   index;

    if (HalpMpInfo.IoSapicCount == 0) {

        //
        // I doubt this machine is going to get very far without IOAPICs
        // but there is certainly nothing for this routine to do.

        return;
    }

    ASSERT(HalpApicDebugAddresses == NULL);

    HalpApicDebugAddresses = ExAllocatePool(NonPagedPool,
                                            HalpMpInfo.IoSapicCount * sizeof(*HalpApicDebugAddresses));

    if (HalpApicDebugAddresses == NULL) {

        return;
    }

    IoIntrControl = HalpIoSapicList;

    for (index = 0; index < HalpMpInfo.IoSapicCount; index++) {

        if (IoIntrControl != NULL) {

            if (HalpVirtualToPhysical((ULONG_PTR)IoIntrControl, &physicalAddress)) {

                HalpApicDebugAddresses[index].IoIntrControl =
                    MmMapIoSpace(physicalAddress,
                                 sizeof(IO_INTR_CONTROL) +
                                    (IoIntrControl->IntiMax - IoIntrControl->IntiBase + 1) * sizeof(IOSAPICINTI),
                                 MmCached
                                 );
            }

            HalpApicDebugAddresses[index].IoSapicRegs =
                MmMapIoSpace(IoIntrControl->RegBasePhysical,
                             IO_SAPIC_REGS_SIZE,
                             MmNonCached
                             );

            IoIntrControl = IoIntrControl->flink;

        } else {

            HalpApicDebugAddresses[index].IoIntrControl = NULL;
            HalpApicDebugAddresses[index].IoSapicRegs = NULL;
        }
    }
}

VOID
HalpSaveInterruptControllerState(
    VOID
    )
{
    HalDebugPrint(( HAL_ERROR, "HAL: HalpSaveInterruptControllerState - not yet implemented\n"));

    HalpHiberInProgress = TRUE;
}

VOID
HalpRestoreInterruptControllerState(
    VOID
    )
{
    //
    // Restore the IO APIC state
    //
    HalDebugPrint(( HAL_ERROR, "HAL: HalpRestoreInterruptControllerState - not yet implemented\n"));

    HalpPicStateIntact = TRUE;
}

VOID
HalpSetInterruptControllerWakeupState(
    ULONG Context
    )
{
    HalDebugPrint(( HAL_FATAL_ERROR, "HAL: HalpSetInterruptControllerWakeupState - not yet implemented\n"));

    KeBugCheckEx(HAL_INITIALIZATION_FAILED, 0, 0, 0 , 0);
}

BOOLEAN
HalpAcpiPicStateIntact(
    VOID
    )
{
    return HalpPicStateIntact;
}


ULONG
HalpAcpiNumProcessors(
    VOID
    )
{
    return HalpMpInfo.ProcessorCount;
}


VOID
HalpMaskAcpiInterrupt(
    VOID
    )
{
    ULONG inti;
    KAFFINITY affinity;
    ULONG sciVector = HalpFixedAcpiDescTable.sci_int_vector;

    if (sciVector < PIC_VECTORS) {
        sciVector = HalpPicVectorRedirect[sciVector];
    }

    HalpGetSapicInterruptDesc(
            Internal,
            0,
            sciVector,
            &inti,
            &affinity
            );

    HalpDisableRedirEntry(inti);

}

VOID
HalpUnmaskAcpiInterrupt(
    VOID
    )
{
    ULONG inti;
    KAFFINITY affinity;

    ULONG sciVector = HalpFixedAcpiDescTable.sci_int_vector;

    if (sciVector < PIC_VECTORS) {
        sciVector = HalpPicVectorRedirect[sciVector];
    }

    HalpGetSapicInterruptDesc(
            Internal,
            0,
            sciVector,
            &inti,
            &affinity
            );

    HalpEnableRedirEntry(inti);
}

NTSTATUS
HalpGetApicIdByProcessorNumber(
    IN     UCHAR     Processor,
    IN OUT USHORT   *ApicId
    )
/*++

Routine Description:

    This function returns an APIC ID for a given processor.

Arguments:

    Processor - The logical processor number that is
        associated with this APIC ID.

    ApicId - pointer to a value to fill in with the APIC ID.

Return Value:

    Status.

--*/
{
    ULONG   index;

    for (index = 0; index < HalpMpInfo.ProcessorCount; index++) {

        if (HalpProcessorInfo[index].NtProcessorNumber == Processor) {

            //
            // Return the APIC ID, Extended APIC ID for this
            // processor.
            //

            *ApicId = HalpProcessorInfo[index].LocalApicID;

            return STATUS_SUCCESS;
        }
    }

    return STATUS_NOT_FOUND;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\setupnvr.h ===
/*++

Module Name:

    setupnvr.h

Abstract:

    Access function to r/w environment variables from pseudo-NVRAM file

Author:

    Mudit Vats (v-muditv) 5-18-99

Revision History:

--*/
#define MAXBOOTVARS         9
#define MAXBOOTVARSIZE      1024

#define ERROR_OK            1
#define ERROR_NOTOK         0

int ReadNVRAM();
int WriteNVRAM();
int GetBootVar( char *szBootVar, unsigned short nLength, char *szBootVal );
int SetBootVar( char *szBootVar, char *szBootVal );


NTSYSAPI
NTSTATUS
NTAPI
ZwCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwQueryInformationFile(
    IN HANDLE FileHandle,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID FileInformation,
    IN ULONG Length,
    IN FILE_INFORMATION_CLASS FileInformationClass
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwReadFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );

NTSYSAPI
NTSTATUS
NTAPI
ZwWriteFile(
    IN HANDLE FileHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PVOID Buffer,
    IN ULONG Length,
    IN PLARGE_INTEGER ByteOffset OPTIONAL,
    IN PULONG Key OPTIONAL
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\xxdisp.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    xxdisp.c

Abstract:

    This module implements the HAL display initialization and output routines
    for a x86 system.

Author:

    David N. Cutler (davec) 27-Apr-1991

Environment:

    Kernel mode

Revision History:

--*/

#include "halp.h"
#include <inbv.h>


VOID
HalAcquireDisplayOwnership (
    IN PHAL_RESET_DISPLAY_PARAMETERS  ResetDisplayParameters
    )
{
    return;
}

VOID
HalDisplayString (
    PUCHAR String
    )

{
    //
    // forward the call to the graphical boot driver...
    //

    InbvDisplayString(String); 

} // HalDisplayString()

VOID
HalQueryDisplayParameters (
    OUT PULONG WidthInCharacters,
    OUT PULONG HeightInLines,
    OUT PULONG CursorColumn,
    OUT PULONG CursorRow
    )
{
    return;
}

VOID
HalSetDisplayParameters (
    IN ULONG CursorColumn,
    IN ULONG CursorRow
    )
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\xxacpi.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    xxacpi.c

Abstract:

    Implements various ACPI utility functions.

Author:

    Jake Oshins (jakeo) 12-Feb-1997

Environment:

    Kernel mode only.

Revision History:

   Todd Kjos (HP) (v-tkjos) 1-Jun-1998 : Added IA64 support

--*/

#include "halp.h"
#include "acpitabl.h"
#include "xxacpi.h"
#include "pci.h"

//#define DUMP_FADT

VOID
HalAcpiTimerCarry(
    VOID
    );

VOID
HalaAcpiTimerInit(
#if defined(ACPI64)
    ULONG_PTR  TimerPort,
#else
    ULONG      TimerPort,
#endif
    BOOLEAN    TimerValExt
    );

ULONG
HaliAcpiQueryFlags(
    VOID
    );

VOID
HaliAcpiTimerInit(
// *** TBD should be ULONG_PTR
    ULONG      TimerPort OPTIONAL,
    IN BOOLEAN    TimerValExt
    );

VOID
HaliAcpiMachineStateInit(
    IN PPROCESSOR_INIT ProcInit,
    IN PHAL_SLEEP_VAL  SleepValues,
    OUT PULONG         PicVal
    );

BOOLEAN
FASTCALL
HalAcpiC1Idle(
    OUT PPROCESSOR_IDLE_TIMES IdleTimes
    );

BOOLEAN
FASTCALL
HalAcpiC2Idle(
    OUT PPROCESSOR_IDLE_TIMES IdleTimes
    );

BOOLEAN
FASTCALL
HalAcpiC3ArbdisIdle(
    OUT PPROCESSOR_IDLE_TIMES IdleTimes
    );

BOOLEAN
FASTCALL
HalAcpiC3WbinvdIdle(
    OUT PPROCESSOR_IDLE_TIMES IdleTimes
    );

VOID
FASTCALL
HalProcessorThrottle(
    IN UCHAR Throttle
    );

NTSTATUS
HaliSetWakeAlarm (
        IN ULONGLONG    WakeSystemTime,
        IN PTIME_FIELDS WakeTimeFields OPTIONAL
        );

VOID
HaliSetWakeEnable(
        IN BOOLEAN      Enable
        );

VOID
HalpSetInterruptControllerWakeupState(
    ULONG Context
   );

PVOID
HalpRemapVirtualAddress(
    IN PVOID VirtualAddress,
    IN PVOID PhysicalAddress,
    IN BOOLEAN WriteThrough
    );

ULONG
HaliPciInterfaceReadConfig(
    IN PVOID Context,
    IN UCHAR BusOffset,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

ULONG
HaliPciInterfaceWriteConfig(
    IN PVOID Context,
    IN UCHAR BusOffset,
    IN ULONG Slot,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

VOID
HalpNumaInitializeStaticConfiguration(
    IN PLOADER_PARAMETER_BLOCK
    );

//
// HAL Hack flags
//

typedef enum {
    HalHackAddFakeSleepHandlersS1 = 1,
    HalHackAddFakeSleepHandlersS2 = 2,
    HalHackAddFakeSleepHandlersS3 = 4
} HALHACKFLAGS;

extern HALHACKFLAGS HalpHackFlags = 0;

//
// Externs
//

extern ULONG    HalpAcpiFlags;
extern PHYSICAL_ADDRESS HalpAcpiRsdt;
extern SLEEP_STATE_CONTEXT HalpShutdownContext;

//
// Globals
//

ULONG HalpInvalidAcpiTable;
PRSDT HalpAcpiRsdtVA;
PXSDT HalpAcpiXsdtVA;
PIPPT_TABLE HalpPlatformPropertiesTable;

//
// This is the dispatch table used by the ACPI driver
//
HAL_ACPI_DISPATCH_TABLE HalAcpiDispatchTable;
PPM_DISPATCH_TABLE PmAcpiDispatchTable = NULL;


NTSTATUS
HalpQueryAcpiResourceRequirements(
    IN  PIO_RESOURCE_REQUIREMENTS_LIST *Requirements
    );

NTSTATUS
HalpBuildAcpiResourceList(
    OUT PIO_RESOURCE_REQUIREMENTS_LIST  List
    );

NTSTATUS
HalpAcpiDetectResourceListSize(
    OUT  PULONG   ResourceListSize
    );

VOID
HalpRestoreInterruptControllerState(
    VOID
   );

ULONG
HalpGetPCIData (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN PCI_SLOT_NUMBER SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

VOID
HalpReadRegistryAndApplyHacks (
    VOID
    );

#define LOW_MEMORY          0x000100000

#define MAX(a, b)       \
    ((a) > (b) ? (a) : (b))

#define MIN(a, b)       \
    ((a) < (b) ? (a) : (b))

// ADRIAO 01/12/98 - We no longer having the HAL declare the IO ports
//                     specified in the FADT. These will be declared in a future
//                     defined PNP0Cxx node (for new, in PNP0C02). This is done
//                     because we cannot know at the hal level what bus the ACPI
//                     FADT resources refer to. We can only the translated resource info.
//    Hence....

#define DECLARE_FADT_RESOURCES_AT_ROOT 0

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, HalpGetAcpiTablePhase0)
#pragma alloc_text(INIT, HalpSetupAcpiPhase0)
#pragma alloc_text(PAGE, HaliInitPowerManagement)
#pragma alloc_text(PAGE, HalpQueryAcpiResourceRequirements)
#pragma alloc_text(PAGE, HalpBuildAcpiResourceList)
#pragma alloc_text(PAGE, HalpGetCrossPartitionIpiInterface)
#pragma alloc_text(PAGE, HalpAcpiDetectResourceListSize)
#pragma alloc_text(PAGE, HalpReadRegistryAndApplyHacks)
#pragma alloc_text(PAGE, HaliAcpiTimerInit)
#pragma alloc_text(PAGE, HaliAcpiMachineStateInit)
#pragma alloc_text(PAGE, HaliAcpiQueryFlags)
#pragma alloc_text(PAGE, HaliSetWakeEnable)
#endif


PVOID
HalpGetAcpiTablePhase0(
    IN  PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN  ULONG   Signature
    )
/*++

Routine Description:

    This function returns a pointer to the ACPI table that is
    identified by Signature.

Arguments:

    Signature - A four byte value that identifies the ACPI table

Return Value:

    Pointer to a copy of the table

--*/
{
    PRSDT rsdt;
    PXSDT xsdt;
    ULONG entry, rsdtEntries;
    PVOID table;
    PHYSICAL_ADDRESS physicalAddr;
    PDESCRIPTION_HEADER header;
    NTSTATUS status;
    ULONG lengthInPages;
    ULONG offset;

    physicalAddr.QuadPart = 0;
    header = NULL;

    if ((HalpAcpiRsdtVA == NULL) && (HalpAcpiXsdtVA == NULL)) {

        //
        // Find and map the RSDT once.  This mapping is reused on
        // subsequent calls to this routine.
        //

        status = HalpAcpiFindRsdtPhase0(LoaderBlock);

        if (!(NT_SUCCESS(status))) {
            HalDebugPrint(( HAL_INFO, "HAL: *** make sure you are using ntdetect.com v5.0 ***\n" ));
            KeBugCheckEx(MISMATCHED_HAL,
                4, 0xac31, 0, 0);
        }

        xsdt = HalpMapPhysicalMemory(HalpAcpiRsdt, 2, MmCached);

        if (!xsdt) {
            return NULL;
        }

        //
        // Do a sanity check on the RSDT.
        //

        if ((xsdt->Header.Signature != RSDT_SIGNATURE) &&
            (xsdt->Header.Signature != XSDT_SIGNATURE)) {
            HalDisplayString("HAL: Bad RSDT pointer\n");
            KeBugCheckEx(MISMATCHED_HAL,
                4, 0xac31, 1, 0);
        }

        //
        // Remap the (X)RSDT now that we know how long it is.
        //

        offset = HalpAcpiRsdt.LowPart & (PAGE_SIZE - 1);
        lengthInPages = (offset + xsdt->Header.Length + (PAGE_SIZE - 1))
                        >> PAGE_SHIFT;
        if (lengthInPages > 2) {
            HalpUnmapVirtualAddress(xsdt, 2);
            xsdt = HalpMapPhysicalMemory(HalpAcpiRsdt, lengthInPages, MmCached);
            if (!xsdt) {
                DbgPrint("HAL: Couldn't remap RSDT\n");
                return NULL;
            }
        }

        if (xsdt->Header.Signature == XSDT_SIGNATURE) {
            HalpAcpiXsdtVA = xsdt;
        } else {
            HalpAcpiRsdtVA = (PRSDT)xsdt;
            HalpAcpiXsdtVA = NULL;
        }
    }

    xsdt = HalpAcpiXsdtVA;
    rsdt = HalpAcpiRsdtVA;

    rsdtEntries = xsdt ?
        NumTableEntriesFromXSDTPointer(xsdt) :
        NumTableEntriesFromRSDTPointer(rsdt);

    //
    // Look down the pointer in each entry to see if it points to
    // the table we are looking for.
    //
    for (entry = 0; entry < rsdtEntries; entry++) {

        physicalAddr.QuadPart = xsdt ?
            xsdt->Tables[entry].QuadPart :
            rsdt->Tables[entry];

        if (header != NULL) {
            HalpUnmapVirtualAddress(header, 2);
        }
        header = HalpMapPhysicalMemory(physicalAddr, 2, MmCached);

        if (!header) {
            return NULL;
        }

        if (header->Signature == Signature) {
            break;
        }
    }

    if (entry == rsdtEntries) {

        //
        // Signature not found, free the PTR for the last entry
        // examined and indicate failure to the caller.
        //

        HalpUnmapVirtualAddress(header, 2);
        return NULL;
    }

    //
    // Make sure we have mapped enough memory to cover the entire
    // table.
    //

    offset = (ULONG)((ULONG_PTR)header & (PAGE_SIZE - 1));
    lengthInPages = (header->Length + offset + (PAGE_SIZE - 1)) >> PAGE_SHIFT;
    if (lengthInPages > 2) {
        HalpUnmapVirtualAddress(header, 2);
        header = HalpMapPhysicalMemory( physicalAddr, lengthInPages, MmCached);
    }

    //
    // Validate the table's checksum.
    // N.B. We expect the checksum to be wrong on some early versions
    // of the FADT.
    //

    if ((header != NULL)  &&
        ((header->Signature != FADT_SIGNATURE) || (header->Revision > 2))) {

        PUCHAR c = (PUCHAR)header + header->Length;
        UCHAR s = 0;

        if (header->Length) {
            do {
                s += *--c;
            } while (c != (PUCHAR)header);
        }


        if ((s != 0) || (header->Length == 0)) {

            //
            // This table is not valid.
            //

            HalpInvalidAcpiTable = header->Signature;

#if 0

            //
            // Don't return this table.
            //

            HalpUnmapVirtualAddress(header, lengthInPages);
            return NULL;

#endif

        }
    }
    return header;
}

NTSTATUS
HalpSetupAcpiPhase0(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

Routine Description:

    Save some information from the ACPI tables before they get
    destroyed.

Arguments:

    none

Return Value:

    none

--*/
{
    NTSTATUS    status;
    ULONG entry;
    PVOID table;
    PVOID physicalAddr;
    PDESCRIPTION_HEADER header;
    ULONG blkSize;
    PHYSICAL_ADDRESS rawAddr;

    //
    // Copy the Fixed Acpi Descriptor Table (FADT) to a permanent
    // home.
    //

    header = HalpGetAcpiTablePhase0(LoaderBlock, FADT_SIGNATURE);
    if (header == NULL) {
        HalDebugPrint(( HAL_INFO, "HAL: Didn't find the FACP\n" ));
        return STATUS_NOT_FOUND;
    }

    RtlCopyMemory(&HalpFixedAcpiDescTable,
                  header,
                  MIN(header->Length, sizeof(HalpFixedAcpiDescTable)));

    if (header->Revision < 3) {

        KeBugCheckEx(ACPI_BIOS_ERROR, 0x11, 9, header->Revision, 0);
    }

    // Check for MMIO addresses that need to be mapped.

    blkSize = HalpFixedAcpiDescTable.pm1_evt_len;
    ASSERT(blkSize);
    if ((HalpFixedAcpiDescTable.x_pm1a_evt_blk.AddressSpaceID == AcpiGenericSpaceMemory) &&
        (blkSize > 0)) {
        rawAddr = HalpFixedAcpiDescTable.x_pm1a_evt_blk.Address;
        HalpFixedAcpiDescTable.x_pm1a_evt_blk.Address.QuadPart =
            (LONGLONG)HalpMapPhysicalMemory(rawAddr,ADDRESS_AND_SIZE_TO_SPAN_PAGES(rawAddr.LowPart, blkSize),MmCached);
    }

    blkSize = HalpFixedAcpiDescTable.pm1_ctrl_len;
    ASSERT(blkSize);
    if ((HalpFixedAcpiDescTable.x_pm1a_ctrl_blk.AddressSpaceID == AcpiGenericSpaceMemory) &&
        (blkSize > 0)) {
        rawAddr = HalpFixedAcpiDescTable.x_pm1a_ctrl_blk.Address;
        HalpFixedAcpiDescTable.x_pm1a_ctrl_blk.Address.QuadPart =
            (LONGLONG) HalpMapPhysicalMemory(rawAddr,ADDRESS_AND_SIZE_TO_SPAN_PAGES(rawAddr.LowPart, blkSize),MmCached);
    }

    blkSize = HalpFixedAcpiDescTable.pm_tmr_len;
    ASSERT(blkSize);
    if ((HalpFixedAcpiDescTable.x_pm_tmr_blk.AddressSpaceID == AcpiGenericSpaceMemory) &&
        (blkSize > 0)) {
    	rawAddr = HalpFixedAcpiDescTable.x_pm_tmr_blk.Address;
        HalpFixedAcpiDescTable.x_pm_tmr_blk.Address.QuadPart =
            (LONGLONG) HalpMapPhysicalMemory(rawAddr,ADDRESS_AND_SIZE_TO_SPAN_PAGES(rawAddr.LowPart, blkSize),MmCached);
    }

    // The rest of these ACPI blocks are optional so test if they exist before mapping them

    if (HalpFixedAcpiDescTable.x_pm1b_evt_blk.Address.QuadPart) {
        if (HalpFixedAcpiDescTable.x_pm1b_evt_blk.AddressSpaceID == AcpiGenericSpaceMemory) {
            blkSize = HalpFixedAcpiDescTable.pm1_evt_len;
            rawAddr = HalpFixedAcpiDescTable.x_pm1b_evt_blk.Address;
            HalpFixedAcpiDescTable.x_pm1b_evt_blk.Address.QuadPart =
                (LONGLONG) HalpMapPhysicalMemory(rawAddr,ADDRESS_AND_SIZE_TO_SPAN_PAGES(rawAddr.LowPart, blkSize),MmCached);
        }
    }

    if (HalpFixedAcpiDescTable.x_pm1b_ctrl_blk.Address.QuadPart) {
        if (HalpFixedAcpiDescTable.x_pm1b_ctrl_blk.AddressSpaceID == AcpiGenericSpaceMemory) {
            blkSize = HalpFixedAcpiDescTable.pm1_ctrl_len;
            rawAddr = HalpFixedAcpiDescTable.x_pm1b_ctrl_blk.Address;
            HalpFixedAcpiDescTable.x_pm1b_ctrl_blk.Address.QuadPart =
                (LONGLONG) HalpMapPhysicalMemory(rawAddr,ADDRESS_AND_SIZE_TO_SPAN_PAGES(rawAddr.LowPart, blkSize),MmCached);
        }
    }

    if (HalpFixedAcpiDescTable.x_pm2_ctrl_blk.Address.QuadPart) {
        if (HalpFixedAcpiDescTable.x_pm2_ctrl_blk.AddressSpaceID == AcpiGenericSpaceMemory) {
            blkSize = HalpFixedAcpiDescTable.pm2_ctrl_len;
            rawAddr = HalpFixedAcpiDescTable.x_pm2_ctrl_blk.Address;
            HalpFixedAcpiDescTable.x_pm2_ctrl_blk.Address.QuadPart =
                (LONGLONG) HalpMapPhysicalMemory(rawAddr,ADDRESS_AND_SIZE_TO_SPAN_PAGES(rawAddr.LowPart, blkSize),MmCached);
        }
    }

    if (HalpFixedAcpiDescTable.x_gp0_blk.Address.QuadPart) {
        if (HalpFixedAcpiDescTable.x_gp0_blk.AddressSpaceID == AcpiGenericSpaceMemory) {
            blkSize = HalpFixedAcpiDescTable.gp0_blk_len;
            rawAddr = HalpFixedAcpiDescTable.x_gp0_blk.Address;
            HalpFixedAcpiDescTable.x_gp0_blk.Address.QuadPart =
                (LONGLONG) HalpMapPhysicalMemory(rawAddr,ADDRESS_AND_SIZE_TO_SPAN_PAGES(rawAddr.LowPart, blkSize),MmCached);
        }
    }

    if (HalpFixedAcpiDescTable.x_gp1_blk.Address.QuadPart) {
        if (HalpFixedAcpiDescTable.x_gp1_blk.AddressSpaceID == AcpiGenericSpaceMemory) {
            blkSize = HalpFixedAcpiDescTable.gp1_blk_len;
            rawAddr = HalpFixedAcpiDescTable.x_gp1_blk.Address;
            HalpFixedAcpiDescTable.x_gp1_blk.Address.QuadPart =
                (LONGLONG) HalpMapPhysicalMemory(rawAddr,ADDRESS_AND_SIZE_TO_SPAN_PAGES(rawAddr.LowPart, blkSize),MmCached);
        }
    }

    //
    // See if Static Resource Affinity Table is present.
    //

    HalpNumaInitializeStaticConfiguration(LoaderBlock);

    //
    // See if Windows Platform Properties Table is present.
    //

    HalpPlatformPropertiesTable =
        HalpGetAcpiTablePhase0(LoaderBlock, IPPT_SIGNATURE);

    //
    // Enable ACPI counter code since we need it in the boot
    // process.
    //

    HaliAcpiTimerInit(0, FALSE);

    //
    // Claim a page of memory below 1MB to be used for transitioning
    // a sleeping processor back from real mode to protected mode
    //

#ifdef IA64
    HalDebugPrint(( HAL_INFO, "HAL: WARNING - HalpSetupAcpi - Sleep transitions not yet implemented\n" ));
#else
    // check first to see if this has already been done by MP startup code
    if (!HalpLowStubPhysicalAddress) {

        HalpLowStubPhysicalAddress = (PVOID)HalpAllocPhysicalMemory (LoaderBlock,
                                            LOW_MEMORY, 1, FALSE);

        if (HalpLowStubPhysicalAddress) {

            HalpLowStub = HalpMapPhysicalMemory(HalpLowStubPhysicalAddress, 1, MmCached);
        }
    }

    //
    // Claim a PTE that will be used for cache flushing in states S2 and S3.
    //
    HalpVirtAddrForFlush = HalpMapPhysicalMemory((PVOID)LOW_MEMORY, 1, MmCached);

    HalpPteForFlush = MiGetPteAddress(HalpVirtAddrForFlush);
#endif

    return STATUS_SUCCESS;
}

VOID
HaliAcpiTimerInit(
// *** TBD should be ULONG_PTR
    IN ULONG      TimerPort  OPTIONAL,
    IN BOOLEAN    TimerValExt
    )
/*++
Routine Description:

    This routine initializes the ACPI timer.

Arguments:

    TimerPort - The address in I/O space of the ACPI timer.  If this is
                0, then the values from the cached FADT will be used.

    TimerValExt - signifies whether the timer is 24 or 32 bits.

--*/
{
#if defined(ACPI64)
    ULONG_PTR port = TimerPort;
#else
    ULONG port = TimerPort;
#endif

    BOOLEAN ext = TimerValExt;

    PAGED_CODE();

    if (port == 0) {
        port = HalpFixedAcpiDescTable.x_pm_tmr_blk.Address.LowPart;
        if (HalpFixedAcpiDescTable.flags & TMR_VAL_EXT) {
            ext = TRUE;
        } else {
            ext = FALSE;
        }
    }

    HalaAcpiTimerInit(port,
                      ext);
}

VOID
HaliAcpiMachineStateInit(
    IN PPROCESSOR_INIT ProcInit,
    IN PHAL_SLEEP_VAL  SleepValues,
    OUT PULONG         PicVal
    )
/*++
Routine Description:

    This function is a callback used by the ACPI driver
    to notify the HAL with the processor blocks.

Arguments:

--*/
{
    POWER_STATE_HANDLER powerState;
    SLEEP_STATE_CONTEXT sleepContext;
    NTSTATUS    status;

    PAGED_CODE();
    UNREFERENCED_PARAMETER(ProcInit);

    *PicVal = 1;    // We only support APIC on IA64

    RtlZeroMemory (&sleepContext, sizeof (sleepContext));
    powerState.Context = NULL;

    //
    // Set up fake handlers that do nothing so testing device power
    // transitions isn't blocked.  Only if hack flag is set, though
    //

    HalpReadRegistryAndApplyHacks ();

    if (HalpHackFlags & HalHackAddFakeSleepHandlersS1) {
        powerState.Type = PowerStateSleeping1;
        powerState.RtcWake = TRUE;
        powerState.Handler = &HaliAcpiFakeSleep;

        status = ZwPowerInformation(SystemPowerStateHandler,
                                    &powerState,
                                    sizeof(POWER_STATE_HANDLER),
                                    NULL,
                                    0);
    }

    if (HalpHackFlags & HalHackAddFakeSleepHandlersS2) {
        powerState.Type = PowerStateSleeping2;
        powerState.RtcWake = TRUE;
        powerState.Handler = &HaliAcpiFakeSleep;

        status = ZwPowerInformation(SystemPowerStateHandler,
                                    &powerState,
                                    sizeof(POWER_STATE_HANDLER),
                                    NULL,
                                    0);
    }

    if (HalpHackFlags & HalHackAddFakeSleepHandlersS3) {

        powerState.Type = PowerStateSleeping3;
        powerState.RtcWake = TRUE;
        powerState.Handler = &HaliAcpiFakeSleep;

        powerState.Context = ULongToPtr(sleepContext.AsULONG);

        status = ZwPowerInformation(SystemPowerStateHandler,
                                    &powerState,
                                    sizeof(POWER_STATE_HANDLER),
                                    NULL,
                                    0);
    }

    //
    // For now all we are going to do is register a shutdown handler
    // that will call shutdown-restart
    //

    if (SleepValues[4].Supported) {
        powerState.Type = PowerStateShutdownOff;
        powerState.RtcWake = FALSE;
        powerState.Handler = &HaliAcpiSleep;

        sleepContext.bits.Pm1aVal = SleepValues[4].Pm1aVal;
        sleepContext.bits.Pm1bVal = SleepValues[4].Pm1bVal;
        sleepContext.bits.Flags = SLEEP_STATE_OFF;
        HalpShutdownContext = sleepContext;

        powerState.Context = ULongToPtr(sleepContext.AsULONG);

        status = ZwPowerInformation(SystemPowerStateHandler,
                                    &powerState,
                                    sizeof(POWER_STATE_HANDLER),
                                    NULL,
                                    0);
        ASSERT(NT_SUCCESS(status));
    }
}

ULONG
HaliAcpiQueryFlags(
    VOID
    )
/*++

Routine Description:

    This routine is temporary is used to report the presence of the
    boot.ini switch

Arguments:

    None

Return Value:

    TRUE, if switch present

--*/
{
    return HalpAcpiFlags;
}


NTSTATUS
HaliInitPowerManagement(
    IN PPM_DISPATCH_TABLE  PmDriverDispatchTable,
    IN OUT PPM_DISPATCH_TABLE *PmHalDispatchTable
    )

/*++

Routine Description:

    This is called by the ACPI driver to start the PM
    code.

Arguments:

    PmDriverDispatchTable - table of functions provided
        by the ACPI driver for the HAL

    PmHalDispatchTable - table of functions provided by
        the HAL for the ACPI driver

Return Value:

    status

--*/
{
    OBJECT_ATTRIBUTES objAttributes;
    PCALLBACK_OBJECT  callback;
    PHYSICAL_ADDRESS  pAddr;
    UNICODE_STRING    callbackName;
    NTSTATUS          status;
    PFACS             facs;

    PAGED_CODE();

    //
    // Keep a pointer to the driver's dispatch table.
    //
//  ASSERT(PmDriverDispatchTable);
//  ASSERT(PmDriverDispatchTable->Signature == ACPI_HAL_DISPATCH_SIGNATURE);
    PmAcpiDispatchTable = PmDriverDispatchTable;

    //
    // Fill in the function table
    //
    HalAcpiDispatchTable.Signature = HAL_ACPI_DISPATCH_SIGNATURE;
    HalAcpiDispatchTable.Version = HAL_ACPI_DISPATCH_VERSION;

    HalAcpiDispatchTable.HalpAcpiTimerInit = &HaliAcpiTimerInit;

    HalAcpiDispatchTable.HalpAcpiTimerInterrupt =
        (pHalAcpiTimerInterrupt)&HalAcpiTimerCarry;

    HalAcpiDispatchTable.HalpAcpiMachineStateInit = &HaliAcpiMachineStateInit;
    HalAcpiDispatchTable.HalpAcpiQueryFlags = &HaliAcpiQueryFlags;
    HalAcpiDispatchTable.HalxPicStateIntact = &HalpAcpiPicStateIntact;
    HalAcpiDispatchTable.HalxRestorePicState = &HalpRestoreInterruptControllerState;
    HalAcpiDispatchTable.HalpSetVectorState = &HaliSetVectorState;

    HalAcpiDispatchTable.HalpPciInterfaceReadConfig = &HaliPciInterfaceReadConfig;
    HalAcpiDispatchTable.HalpPciInterfaceWriteConfig = &HaliPciInterfaceWriteConfig;
    HalAcpiDispatchTable.HalpSetMaxLegacyPciBusNumber = &HalpSetMaxLegacyPciBusNumber;
    HalAcpiDispatchTable.HalpIsVectorValid = &HaliIsVectorValid;


    *PmHalDispatchTable = (PPM_DISPATCH_TABLE)&HalAcpiDispatchTable;

    //
    // Fill in Hal's private dispatch table
    //
    HalSetWakeEnable = HaliSetWakeEnable;
    HalSetWakeAlarm  = HaliSetWakeAlarm;

    //
    // Register callback that tells us to make
    // anything we need for sleeping non-pageable.
    //

    RtlInitUnicodeString(&callbackName, L"\\Callback\\PowerState");

    InitializeObjectAttributes(
        &objAttributes,
        &callbackName,
        OBJ_CASE_INSENSITIVE | OBJ_PERMANENT,
        NULL,
        NULL
        );

    ExCreateCallback(&callback,
                     &objAttributes,
                     FALSE,
                     TRUE);

    ExRegisterCallback(callback,
                       (PCALLBACK_FUNCTION)&HalpPowerStateCallback,
                       NULL);

#if 0
    //
    // Find the location of the firmware waking vector.
    //  N.B.  If any of this fails, then HalpWakeVector will be NULL
    //        and we won't support S2 or S3.
    //
    if (HalpFixedAcpiDescTable.x_firmware_ctrl.Address.QuadPart) {

        facs = HalpMapPhysicalMemory(HalpFixedAcpiDescTable.x_firmware_ctrl.Address,
                            ADDRESS_AND_SIZE_TO_SPAN_PAGES(HalpFixedAcpiDescTable.x_firmware_ctrl.Address.LowPart, sizeof(FACS)),
                            MmCached);

        if (facs) {

            if (facs->Signature == FACS_SIGNATURE) {

                HalpWakeVector = &facs->x_FirmwareWakingVector;
            }
        }
    }
#endif

    return STATUS_SUCCESS;
}

NTSTATUS
HalpQueryAcpiResourceRequirements(
    IN  PIO_RESOURCE_REQUIREMENTS_LIST *Requirements
    )
/*++

Routine Description:

    This routine is a temporary stub that tries to detect the presence
    of an ACPI controller within the system. This code is meant to be
    inserted within NT's root system enumerator.

Arguents:

    Requirements - pointer to list of resources

Return Value:

    STATUS_SUCCESS                  - If we found a device object
    STATUS_NO_SUCH_DEVICE           - If we can't find info about the new PDO

--*/
{
    NTSTATUS                        ntStatus;
    PIO_RESOURCE_REQUIREMENTS_LIST  resourceList;
    ULONG                           resourceListSize;

    PAGED_CODE();

    //
    // Now figure out the number of resource that we need
    //
    ntStatus = HalpAcpiDetectResourceListSize(
        &resourceListSize
        );

    //
    // Convert this resourceListSize into the number of bytes that we
    // must allocate
    //
    resourceListSize = sizeof(IO_RESOURCE_REQUIREMENTS_LIST) +
        ( (resourceListSize - 1) * sizeof(IO_RESOURCE_DESCRIPTOR) );

    //
    // Allocate the correct number of bytes of the Resource List
    //
    resourceList = ExAllocatePoolWithTag(
        PagedPool,
        resourceListSize,
        HAL_POOL_TAG
        );

    //
    // This call must have succeeded or we cannot lay claim to ACPI
    //
    if (resourceList == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Set up the ListSize in the structure
    //
    RtlZeroMemory(resourceList, resourceListSize);
    resourceList->ListSize = resourceListSize;

    //
    // Build the ResourceList here
    //
    ntStatus = HalpBuildAcpiResourceList(resourceList);

    //
    // Did we build the list okay?
    //
    if (!NT_SUCCESS(ntStatus)) {

        //
        // Free memory and exit
        //
        ExFreePool(resourceList);
        return STATUS_NO_SUCH_DEVICE;
    }

    *Requirements = resourceList;
    return ntStatus;
}

NTSTATUS
HalpBuildAcpiResourceList(
    OUT PIO_RESOURCE_REQUIREMENTS_LIST  List
    )
/*++

Routine Description:

    This is the routine that builds the ResourceList given the FADT and
    an arbitrary number of ResourceDescriptors. We assume that the
    ResourceList has been properly allocated and sized

Arguments:

    List    - The list to fill in

Return Value:

    STATUS_SUCCESS if okay
    STATUS_UNSUCCESSUL if not

--*/
{
    PIO_RESOURCE_DESCRIPTOR partialResource;
    ULONG                   count = 0;

    PAGED_CODE();

    ASSERT( List != NULL );

    //
    // Specify some default values (for now) to determine the Bus Type and
    // the bus number
    //
    List->AlternativeLists = 1;
    List->InterfaceType = Isa;
    List->BusNumber = 0;
    List->List[0].Version = 1;
    List->List[0].Revision = 1;

    //
    // Is there an interrupt resource required?
    //
    if (HalpFixedAcpiDescTable.sci_int_vector != 0) {

        List->List[0].Descriptors[count].Type = CmResourceTypeInterrupt;
        List->List[0].Descriptors[count].ShareDisposition = CmResourceShareShared;
        List->List[0].Descriptors[count].Flags = CM_RESOURCE_INTERRUPT_LEVEL_SENSITIVE;
        List->List[0].Descriptors[count].u.Interrupt.MinimumVector =
        List->List[0].Descriptors[count].u.Interrupt.MaximumVector =
            HalpFixedAcpiDescTable.sci_int_vector;
        List->List[0].Count++;
        count++;
    }

#if DECLARE_FADT_RESOURCES_AT_ROOT

    //
    // Is there an SMI CMD IO Port?
    //
    if (HalpFixedAcpiDescTable.smi_cmd_io_port != 0) {

        List->List[0].Descriptors[count].Type = CmResourceTypePort;
        List->List[0].Descriptors[count].ShareDisposition = CmResourceShareDeviceExclusive;
        List->List[0].Descriptors[count].Flags =CM_RESOURCE_PORT_IO;
        List->List[0].Descriptors[count].u.Port.MinimumAddress.LowPart =
            PtrToUlong(HalpFixedAcpiDescTable.smi_cmd_io_port);
        List->List[0].Descriptors[count].u.Port.MaximumAddress.LowPart =
            PtrToUlong(HalpFixedAcpiDescTable.smi_cmd_io_port);
        List->List[0].Descriptors[count].u.Port.Length = 1;
        List->List[0].Descriptors[count].u.Port.Alignment = 1;
        List->List[0].Count++;
        count++;
    }

    //
    // Is there an PM1A Event Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm1a_evt_blk_io_port != 0) {

        List->List[0].Descriptors[count].Type = CmResourceTypePort;
        List->List[0].Descriptors[count].ShareDisposition = CmResourceShareDeviceExclusive;
        List->List[0].Descriptors[count].Flags = CM_RESOURCE_PORT_IO;
        List->List[0].Descriptors[count].u.Port.MinimumAddress.LowPart =
            HalpFixedAcpiDescTable.pm1a_evt_blk_io_port;
        List->List[0].Descriptors[count].u.Port.MaximumAddress.LowPart =
            HalpFixedAcpiDescTable.pm1a_evt_blk_io_port + (ULONG) HalpFixedAcpiDescTable.pm1_evt_len - 1;
        List->List[0].Descriptors[count].u.Port.Length = (ULONG) HalpFixedAcpiDescTable.pm1_evt_len;
        List->List[0].Descriptors[count].u.Port.Alignment = 1;
        List->List[0].Count++;
        count++;
    }

    //
    // Is there a PM1B Event Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm1b_evt_blk_io_port != 0) {

        List->List[0].Descriptors[count].Type = CmResourceTypePort;
        List->List[0].Descriptors[count].ShareDisposition = CmResourceShareDeviceExclusive;
        List->List[0].Descriptors[count].Flags = CM_RESOURCE_PORT_IO;
        List->List[0].Descriptors[count].u.Port.MinimumAddress.LowPart =
            HalpFixedAcpiDescTable.pm1b_evt_blk_io_port;
        List->List[0].Descriptors[count].u.Port.MaximumAddress.LowPart =
            HalpFixedAcpiDescTable.pm1b_evt_blk_io_port + (ULONG) HalpFixedAcpiDescTable.pm1_evt_len - 1;
        List->List[0].Descriptors[count].u.Port.Length = (ULONG) HalpFixedAcpiDescTable.pm1_evt_len;
        List->List[0].Descriptors[count].u.Port.Alignment = 1;
        List->List[0].Count++;
        count++;
    }

    //
    // Is there a PM1A Control Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm1a_ctrl_blk_io_port != 0) {

        List->List[0].Descriptors[count].Type = CmResourceTypePort;
        List->List[0].Descriptors[count].ShareDisposition = CmResourceShareDeviceExclusive;
        List->List[0].Descriptors[count].Flags = CM_RESOURCE_PORT_IO;
        List->List[0].Descriptors[count].u.Port.MinimumAddress.LowPart =
            HalpFixedAcpiDescTable.pm1a_ctrl_blk_io_port;
        List->List[0].Descriptors[count].u.Port.MaximumAddress.LowPart =
            HalpFixedAcpiDescTable.pm1a_ctrl_blk_io_port + (ULONG) HalpFixedAcpiDescTable.pm1_ctrl_len - 1;
        List->List[0].Descriptors[count].u.Port.Length = (ULONG) HalpFixedAcpiDescTable.pm1_ctrl_len;
        List->List[0].Descriptors[count].u.Port.Alignment = 1;
        List->List[0].Count++;
        count++;
    }

    //
    // Is there a PM1B Control Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm1b_ctrl_blk_io_port != 0) {

        List->List[0].Descriptors[count].Type = CmResourceTypePort;
        List->List[0].Descriptors[count].ShareDisposition = CmResourceShareDeviceExclusive;
        List->List[0].Descriptors[count].Flags = CM_RESOURCE_PORT_IO;
        List->List[0].Descriptors[count].u.Port.MinimumAddress.LowPart =
            HalpFixedAcpiDescTable.pm1b_ctrl_blk_io_port;
        List->List[0].Descriptors[count].u.Port.MaximumAddress.LowPart =
            HalpFixedAcpiDescTable.pm1b_ctrl_blk_io_port + (ULONG) HalpFixedAcpiDescTable.pm1_ctrl_len - 1;
        List->List[0].Descriptors[count].u.Port.Length = (ULONG) HalpFixedAcpiDescTable.pm1_ctrl_len;
        List->List[0].Descriptors[count].u.Port.Alignment = 1;
        List->List[0].Count++;
        count++;
    }

    //
    // Is there a PM2 Control Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm2_ctrl_blk_io_port != 0) {

        List->List[0].Descriptors[count].Type = CmResourceTypePort;
        List->List[0].Descriptors[count].ShareDisposition = CmResourceShareDeviceExclusive;
        List->List[0].Descriptors[count].Flags = CM_RESOURCE_PORT_IO;
        List->List[0].Descriptors[count].u.Port.MinimumAddress.LowPart =
            HalpFixedAcpiDescTable.pm2_ctrl_blk_io_port;
        List->List[0].Descriptors[count].u.Port.MaximumAddress.LowPart =
            HalpFixedAcpiDescTable.pm2_ctrl_blk_io_port + (ULONG) HalpFixedAcpiDescTable.pm2_ctrl_len - 1;
        List->List[0].Descriptors[count].u.Port.Length = (ULONG) HalpFixedAcpiDescTable.pm2_ctrl_len;
        List->List[0].Descriptors[count].u.Port.Alignment = 1;
        List->List[0].Count++;
        count++;
    }

    //
    // Is there a PM Timer Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm_tmr_blk_io_port != 0) {

        List->List[0].Descriptors[count].Type = CmResourceTypePort;
        List->List[0].Descriptors[count].ShareDisposition = CmResourceShareDeviceExclusive;
        List->List[0].Descriptors[count].Flags = CM_RESOURCE_PORT_IO;
        List->List[0].Descriptors[count].u.Port.MinimumAddress.LowPart =
            HalpFixedAcpiDescTable.pm_tmr_blk_io_port;
        List->List[0].Descriptors[count].u.Port.MaximumAddress.LowPart =
            HalpFixedAcpiDescTable.pm_tmr_blk_io_port + (ULONG) HalpFixedAcpiDescTable.pm_tmr_len - 1;
        List->List[0].Descriptors[count].u.Port.Length = (ULONG) HalpFixedAcpiDescTable.pm_tmr_len;
        List->List[0].Descriptors[count].u.Port.Alignment = 1;
        List->List[0].Count++;
        count++;
    }

    //
    // Is there a GP0 Block IO Port?
    //
    if (HalpFixedAcpiDescTable.gp0_blk_io_port != 0) {

        List->List[0].Descriptors[count].Type = CmResourceTypePort;
        List->List[0].Descriptors[count].ShareDisposition = CmResourceShareDeviceExclusive;
        List->List[0].Descriptors[count].Flags = CM_RESOURCE_PORT_IO;
        List->List[0].Descriptors[count].u.Port.MinimumAddress.LowPart =
            HalpFixedAcpiDescTable.gp0_blk_io_port;
        List->List[0].Descriptors[count].u.Port.MaximumAddress.LowPart =
            HalpFixedAcpiDescTable.gp0_blk_io_port + (ULONG) HalpFixedAcpiDescTable.gp0_blk_len - 1;
        List->List[0].Descriptors[count].u.Port.Length = (ULONG) HalpFixedAcpiDescTable.gp0_blk_len;
        List->List[0].Descriptors[count].u.Port.Alignment = 1;
        List->List[0].Count++;
        count++;
    }

    //
    // Is there a GP1 Block IO port?
    //
    if (HalpFixedAcpiDescTable.gp1_blk_io_port != 0) {

        List->List[0].Descriptors[count].Type = CmResourceTypePort;
        List->List[0].Descriptors[count].ShareDisposition = CmResourceShareDeviceExclusive;
        List->List[0].Descriptors[count].Flags = CM_RESOURCE_PORT_IO;
        List->List[0].Descriptors[count].u.Port.MinimumAddress.LowPart =
            HalpFixedAcpiDescTable.gp1_blk_io_port;
        List->List[0].Descriptors[count].u.Port.MaximumAddress.LowPart =
            HalpFixedAcpiDescTable.gp1_blk_io_port + (ULONG) HalpFixedAcpiDescTable.gp1_blk_len - 1;
        List->List[0].Descriptors[count].u.Port.Length = (ULONG) HalpFixedAcpiDescTable.gp1_blk_len;
        List->List[0].Descriptors[count].u.Port.Alignment = 1;
        List->List[0].Count++;
        count++;
    }
#endif // DECLARE_FADT_RESOURCES_AT_ROOT

    return STATUS_SUCCESS;
}

NTSTATUS
HalpAcpiDetectResourceListSize(
    OUT  PULONG   ResourceListSize
    )
/*++

Routine Description:

    Given a pointer to an FADT, determine the number of
    CM_PARTIAL_RESOURCE_DESCRIPTORS that are required to
    describe all the resource mentioned in the FADT

Arguments:

    ResourceListSize    - Location to store the answer

Return Value:

    STATUS_SUCCESS if everything went okay

--*/
{
    PAGED_CODE();

    //
    // First of all, assume that we need no resources
    //
    *ResourceListSize = 0;

    //
    // Is there an interrupt resource required?
    //
    if (HalpFixedAcpiDescTable.sci_int_vector != 0) {
        *ResourceListSize += 1;
    }

#if DECLARE_FADT_RESOURCES_AT_ROOT

    //
    // Is there an SMI CMD IO Port?
    //
    if (HalpFixedAcpiDescTable.smi_cmd_io_port != 0) {
        *ResourceListSize += 1;
    }

    //
    // Is there an PM1A Event Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm1a_evt_blk_io_port != 0) {
        *ResourceListSize += 1;
    }

    //
    // Is there a PM1B Event Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm1b_evt_blk_io_port != 0) {
        *ResourceListSize += 1;
    }

    //
    // Is there a PM1A Control Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm1a_ctrl_blk_io_port != 0) {
        *ResourceListSize += 1;
    }

    //
    // Is there a PM1B Control Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm1b_ctrl_blk_io_port != 0) {
        *ResourceListSize += 1;
    }

    //
    // Is there a PM2 Control Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm2_ctrl_blk_io_port != 0) {
        *ResourceListSize += 1;
    }

    //
    // Is there a PM Timer Block IO Port?
    //
    if (HalpFixedAcpiDescTable.pm_tmr_blk_io_port != 0) {
        *ResourceListSize += 1;
    }

    //
    // Is there a GP0 Block IO Port?
    //
    if (HalpFixedAcpiDescTable.gp0_blk_io_port != 0) {
        *ResourceListSize += 1;
    }

    //
    // Is there a GP1 Block IO Port?
    //
    if (HalpFixedAcpiDescTable.gp1_blk_io_port != 0) {
        *ResourceListSize += 1;
    }
#endif // DECALRE_FADT_RESOURCES_AT_ROOT

    return STATUS_SUCCESS;
}

/*++

Routine Description:

    Scans the registry for TestFlags and sets the global
    hackflag to whatever the registry value is, if it
    exists.

Arguments:

    None

Return Value:

    None

--*/

VOID
HalpReadRegistryAndApplyHacks (
    VOID
    )
{
    OBJECT_ATTRIBUTES               ObjectAttributes;
    UNICODE_STRING                  UnicodeString;
    HANDLE                          BaseHandle = NULL;
    NTSTATUS                        status;
    KEY_VALUE_PARTIAL_INFORMATION   hackflags;
    ULONG                           resultlength = 0;

    HalpHackFlags = 0;

    RtlInitUnicodeString (&UnicodeString,
                          L"\\REGISTRY\\MACHINE\\SYSTEM\\CURRENTCONTROLSET\\Control\\HAL");

    InitializeObjectAttributes(&ObjectAttributes,
                               &UnicodeString,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               (PSECURITY_DESCRIPTOR) NULL);

    status = ZwOpenKey (&BaseHandle,
                        KEY_READ,
                        &ObjectAttributes);

    if (!NT_SUCCESS (status)) {
        return;
    }

    RtlInitUnicodeString (&UnicodeString,
                          L"TestFlags");

    status = ZwQueryValueKey (BaseHandle,
                              &UnicodeString,
                              KeyValuePartialInformation,
                              &hackflags,
                              sizeof (hackflags),
                              &resultlength);

    if (!NT_SUCCESS (status)) {
        return;
    }

    if (hackflags.Type != REG_DWORD || hackflags.DataLength != sizeof (ULONG)) {
        return;
    }

    HalpHackFlags = (ULONG) *hackflags.Data;
}

ULONG
HalpReadGenAddr(
    IN  PGEN_ADDR   GenAddr
    )
{
    ULONG   i, result = 0, bitWidth, mask = 0;

    //
    // Figure out how wide our target register is.
    //

    bitWidth = GenAddr->BitWidth +
               GenAddr->BitOffset;


    if (bitWidth > 16) {
        bitWidth = 32;
    } else if (bitWidth <= 8) {
        bitWidth = 8;
    } else {
        bitWidth = 16;
    }

    switch (GenAddr->AddressSpaceID) {
    case AcpiGenericSpaceIO:

        ASSERT(!(GenAddr->Address.LowPart & 0Xffff0000));
        ASSERT(GenAddr->Address.HighPart == 0);

        switch (bitWidth) {
        case 8:

            result = READ_PORT_UCHAR((PUCHAR)(UINT_PTR)GenAddr->Address.LowPart);
            break;

        case 16:

            result = READ_PORT_USHORT((PUSHORT)(UINT_PTR)GenAddr->Address.LowPart);
            break;

        case 32:

            result = READ_PORT_ULONG((PULONG)(UINT_PTR)GenAddr->Address.LowPart);
            break;

        default:
            return 0;
        }

        break;

    case AcpiGenericSpaceMemory:

        //
        // This code path depends on the fact that the addresses
        // in these structures have already been converted to
        // virtual addresses.
        //

        switch (bitWidth) {
        case 8:

            result = READ_REGISTER_UCHAR((PUCHAR)GenAddr->Address.QuadPart);
            break;

        case 16:

            result = READ_REGISTER_USHORT((PUSHORT)GenAddr->Address.QuadPart);
            break;

        case 32:

            result = READ_REGISTER_ULONG((PULONG)GenAddr->Address.QuadPart);
            break;

        default:
            return 0;
        }

        break;

    default:
        return 0;
    }

    //
    // If the register is not actually byte-aligned, correct for
    // that.
    //

    if (result && (bitWidth != GenAddr->BitWidth)) {
           
      result >>= GenAddr->BitOffset;
      result &= ((0x1ul << GenAddr->BitWidth) - 1);
      
    }
    
    return result;
}

VOID
HalpWriteGenAddr(
    IN  PGEN_ADDR   GenAddr,
    IN  ULONG       Value
    )
{
    ULONG   i, result = 0, bitWidth, data, mask = 0;

    data = 0;

    //
    // Figure out how wide our target register is.
    //

    bitWidth = GenAddr->BitWidth +
               GenAddr->BitOffset;


    if (bitWidth > 16) {
        bitWidth = 32;
    } else if (bitWidth <= 8) {
        bitWidth = 8;
    } else {
        bitWidth = 16;
    }

    switch (GenAddr->AddressSpaceID) {
    case AcpiGenericSpaceIO:

        ASSERT(!(GenAddr->Address.LowPart & 0Xffff0000));
        ASSERT(GenAddr->Address.HighPart == 0);

        switch (bitWidth) {
        case 8:

            ASSERT(!(Value & 0xffffff00));

            if ((GenAddr->BitOffset != 0) ||
                (GenAddr->BitWidth != bitWidth)) {

                data = READ_PORT_UCHAR((PUCHAR)(UINT_PTR)GenAddr->Address.LowPart);
                mask = (UCHAR)~0 >> (8 - GenAddr->BitWidth);
                mask = (UCHAR)~(mask << GenAddr->BitOffset);
                data &= mask;
                data |= (UCHAR)Value << GenAddr->BitOffset;

            } else {
                data = Value;
            }

            WRITE_PORT_UCHAR((PUCHAR)(UINT_PTR)GenAddr->Address.LowPart,
                             (UCHAR)data);
            break;

        case 16:

            ASSERT(!(Value & 0xffff0000));

            if ((GenAddr->BitOffset != 0) ||
                (GenAddr->BitWidth != bitWidth)) {

                data = READ_PORT_USHORT((PUSHORT)(UINT_PTR)GenAddr->Address.LowPart);
                mask = (USHORT)~0 >> (16 - GenAddr->BitWidth);
                mask = (USHORT)~(mask << GenAddr->BitOffset);
                data &= mask;
                data |= (USHORT)Value << GenAddr->BitOffset;

            } else {
                data = Value;
            }

            WRITE_PORT_USHORT((PUSHORT)(UINT_PTR)GenAddr->Address.LowPart,
                              (USHORT)data);
            break;

        case 32:

            if ((GenAddr->BitOffset != 0) ||
                (GenAddr->BitWidth != bitWidth)) {

                data = READ_PORT_ULONG((PULONG)(UINT_PTR)GenAddr->Address.LowPart);
                mask = (ULONG)~0 >> (32 - GenAddr->BitWidth);
                mask = ~(mask << GenAddr->BitOffset);
                data &= mask;
                data |= Value << GenAddr->BitOffset;

            } else {
                data = Value;
            }

            WRITE_PORT_ULONG((PULONG)(UINT_PTR)GenAddr->Address.LowPart,
                             data);
            break;

        default:
            return;
        }

        break;

    case AcpiGenericSpaceMemory:

        //
        // This code path depends on the fact that the addresses
        // in these structures have already been converted to
        // virtual addresses.
        //

        switch (bitWidth) {
        case 8:

            ASSERT(!(Value & 0xffffff00));

            if ((GenAddr->BitOffset != 0) ||
                (GenAddr->BitWidth != bitWidth)) {

                data = READ_REGISTER_UCHAR((PUCHAR)GenAddr->Address.QuadPart);
                mask = (UCHAR)~0 >> (8 - GenAddr->BitWidth);
                mask = (UCHAR)~(mask << GenAddr->BitOffset);
                data &= mask;
                data |= (UCHAR)Value << GenAddr->BitOffset;

            } else {
                data = Value;
            }

            WRITE_REGISTER_UCHAR((PUCHAR)GenAddr->Address.QuadPart,
                                 (UCHAR)data);
            break;

        case 16:

            ASSERT(!(Value & 0xffff0000));

            if ((GenAddr->BitOffset != 0) ||
                (GenAddr->BitWidth != bitWidth)) {

                data = READ_REGISTER_USHORT((PUSHORT)GenAddr->Address.QuadPart);
                mask = (USHORT)~0 >> (16 - GenAddr->BitWidth);
                mask = (USHORT)~(mask << GenAddr->BitOffset);
                data &= mask;
                data |= (USHORT)Value << GenAddr->BitOffset;

            } else {
                data = Value;
            }

            WRITE_REGISTER_USHORT((PUSHORT)GenAddr->Address.QuadPart,
                                  (USHORT)data);
            break;

        case 32:

            if ((GenAddr->BitOffset != 0) ||
                (GenAddr->BitWidth != bitWidth)) {

                data = READ_REGISTER_ULONG((PULONG)GenAddr->Address.QuadPart);
                mask = (ULONG)~0 >> (32 - GenAddr->BitWidth);
                mask = ~(mask << GenAddr->BitOffset);
                data &= mask;
                data |= Value << GenAddr->BitOffset;

            } else {
                data = Value;
            }

            WRITE_REGISTER_ULONG((PULONG)GenAddr->Address.QuadPart, data);
            break;

        default:
            return;
        }

        break;

    default:
        return;
    }
}

NTSTATUS
HalpGetPlatformProperties(
    OUT PULONG Properties
    )
/*++

Routine Description:

    This function retrieves the platform properties as specified in
    the ACPI-style IPPT table if present on this platform.  The table
    itself would've been retrieved earlier.

Arguments:

    Properties - Pointer to a ULONG that will be updated
    to reflect the platform property flags if present.

Return Value:

    NTSTATUS - STATUS_SUCCESS indicates the table was present and the
    ULONG pointed to by Properties contains valid data.

--*/
{
    if (HalpPlatformPropertiesTable) {
        *Properties = HalpPlatformPropertiesTable->Flags;
        return STATUS_SUCCESS;
    } else {
        return STATUS_UNSUCCESSFUL;
    }
}

NTSTATUS
HalpGetCrossPartitionIpiInterface(
    OUT HAL_CROSS_PARTITION_IPI_INTERFACE * IpiInterface
    )
/*++

Routine Description:

    This function fills in the HAL_CROSS_PARTITION_IPI_INTERFACE
    structure pointed to by the argument with the appropriate hal
    function pointers.

Arguments:

    IpiInterface - Pointer to HAL_CROSS_PARTITION_IPI_INTERFACE
    structure.

Return Value:

    NTSTATUS

--*/
{
    PAGED_CODE();

    IpiInterface->HalSendCrossPartitionIpi = HalpSendCrossPartitionIpi;
    IpiInterface->HalReserveCrossPartitionInterruptVector =
        HalpReserveCrossPartitionInterruptVector;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\bushnd.c ===
//
// This file simply includes the common sources from the current HAL
// directory. When the structure is finally changed, the real file should
// be in this directory.
//

#include "..\bushnd.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\xxbiosc.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    xxbiosc.c

Abstract:

    This module implements the protect-mode routines necessary to make the
    transition to real mode and return to protected mode.

Author:

    John Vert (jvert) 29-Oct-1991


Environment:

    Kernel mode only.
    Probably a panic-stop, so we cannot use any system services.

Revision History:

--*/



//
// commented this file since real mode to protection switch
// requirement of 386 is not needed for ia64 
//

// #include "..\..\halx86\i386\xxbiosc.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\chiphacks.c ===
//
// This file simply includes the common sources from the current HAL
// directory.
//

#include "..\chiphacks.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\xxacpi.h ===
/*++

  Copyright (c) 1997  Microsoft Corporation

Module Name:

    xxacpi.h

Abstract:


    This module contains definitions specific to the HAL's
    ACPI function.

Author:

    Jake Oshins (jakeo) Feb. 18, 1997

Revision History:

	Todd Kjos (HP) (v-tkjos) 1-Jun-1998: Initial IA64 port

--*/

#if !defined(_XXACPI_H_)
#define _XXACPI_H_

#include "eisa.h"
#include "ntacpi.h"

//
// General ACPI structures
//
typedef struct {
    BOOLEAN     GeneralWakeupEnable;
    BOOLEAN     RtcWakeupEnable;
    TIME_FIELDS RtcWakeupTime;
} HAL_WAKEUP_STATE, *PHAL_WAKEUP_STATE;

//
// internal prototypes
//
PVOID
HalpGetAcpiTablePhase0(
    IN  PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN  ULONG   Signature
    );

NTSTATUS
HalpSetupAcpiPhase0(
    IN  PLOADER_PARAMETER_BLOCK LoaderBlock
    );

BOOLEAN
HalpAcpiPreSleep(
    SLEEP_STATE_CONTEXT Context
    );

NTSTATUS
HaliAcpiFakeSleep(
    IN PVOID                        Context,
    IN PENTER_STATE_SYSTEM_HANDLER  SystemHandler   OPTIONAL,
    IN PVOID                        SystemContext,
    IN LONG                         NumberProcessors,
    IN volatile PLONG               Number
    );

NTSTATUS
HaliAcpiSleep(
    IN PVOID                        Context,
    IN PENTER_STATE_SYSTEM_HANDLER  SystemHandler   OPTIONAL,
    IN PVOID                        SystemContext,
    IN LONG                         NumberProcessors,
    IN volatile PLONG               Number
    );

BOOLEAN
HalpAcpiPostSleep(
    ULONG Context
    );

NTSTATUS
HaliSetWakeAlarm (
	IN ULONGLONG	WakeSystemTime,
	IN PTIME_FIELDS	WakeTimeFields OPTIONAL
	);

NTSTATUS
HalpSetWakeAlarm (
	IN ULONGLONG	WakeSystemTime,
	IN PTIME_FIELDS	WakeTimeFields OPTIONAL
	);

VOID
HaliSetWakeEnable(
	IN BOOLEAN	Enable
	);

VOID
HalpSleepGetProcState(
    IN OUT PKPROCESSOR_STATE ProcState
    );
BOOLEAN
HalpAcpiPicStateIntact(
    VOID
	);

VOID
HalpAcpiRestorePicState(
    VOID
    );

//
// The kernel leaves some space (64 byte) of the PCR for the HAL to use
// as it needs.
//

typedef struct {
    ULONG   Reserved1;  // this space is used by APIC stuff
    union {
        ULONG       AddrAndFlags;
        struct {
            USHORT  Addr;
            UCHAR   Flags;
            UCHAR   Spare1;
        } ;
    } PBlk;
} HALPCR, *PHALPCR;

//
// Global HAL-ACPI stuff
//
extern FADT HalpFixedAcpiDescTable;
extern HAL_WAKEUP_STATE HalpWakeupState;
extern ULONG HalpThrottleScale;
extern SLEEP_STATE_CONTEXT HalpSleepContext;
extern KPROCESSOR_STATE    HalpSleepProcState;

extern PUCHAR  HalpLowStub;
extern PVOID   HalpLowStubPhysicalAddress;
extern PVOID   HalpWakeVector;
extern PVOID   HalpVirtAddrForFlush;
extern PVOID   HalpPteForFlush;

#endif // _XXACPI_X_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\xxmemory.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    xxmemory.c

Abstract:

    Provides routines to allow the HAL to map physical memory.

Author:

    John Vert (jvert) 3-Sep-1991

Environment:

    Phase 0 initialization only.

Revision History:

--*/

#include "halp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpAllocPhysicalMemory)
#endif


MEMORY_ALLOCATION_DESCRIPTOR    HalpExtraAllocationDescriptor;


PVOID
HalpMapPhysicalMemory(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG NumberPages,
    IN MEMORY_CACHING_TYPE CacheType
    )

/*++

Routine Description:

    This routine maps physical memory into the area of virtual memory
    reserved for the HAL.

Arguments:

    PhysicalAddress - Supplies the physical address of the start of the
                      area of physical memory to be mapped.

    NumberPages - This is not used for IA64.  It is here just to keep the
                  interface consistent.

Return Value:

    PVOID - Virtual address at which the requested block of physical memory
            was mapped

    NULL - The requested block of physical memory could not be mapped.

--*/

{

    if (CacheType == MmCached) {

        return (PVOID)(((ULONG_PTR)KSEG_ADDRESS(PhysicalAddress.QuadPart >> PAGE_SHIFT)) |
               (PhysicalAddress.QuadPart & ~(-1 << PAGE_SHIFT)));

    } else {

        return (PVOID)(((ULONG_PTR)KSEG4_ADDRESS(PhysicalAddress.QuadPart >> PAGE_SHIFT)) |
               (PhysicalAddress.QuadPart & ~(-1 << PAGE_SHIFT)));

    }

}


PVOID
HalpMapPhysicalMemory64(
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG            NumberPages
)
/*++

Routine Description:

    Maps a physical memory address into virtual space by calling HalpMapPhysicalMemory but
    always in the MmNonCached mode. MMIO.

Arguments:

    PhysicalAddress - Supplies a physical address of the memory to be mapped

    NumberPages - Number of pages to map

Return Value:

    Virtual address pointer to the requested physical address

--*/
{
    return HalpMapPhysicalMemory(PhysicalAddress, NumberPages, MmNonCached);
} // HalpMapPhysicalMemory64()


VOID
HalpUnmapVirtualAddress(
    IN PVOID    VirtualAddress,
    IN ULONG    NumberPages
    )

/*++

Routine Description:

    Release PTEs previously allocated to map memory by
    HalpMapPhysicalMemory.

    Note:  This routine does not free memory, it only releases
    the Virtual to Physical translation.

Arguments:

    VirtualAddress  Supplied the base VA of the address range to be
                    released.

    NumberPages     Supplied the length of the range.

Return Value.

    None.

--*/

{
    //
    // HalpMapPhysicalMemory returns an address in KSEG4 and it doesn't use a
    // page table, so no need to unmap.
    //
//    MmUnmapIoSpace(VirtualAddress, PAGE_SIZE * NumberPages);
    return;
}

PVOID
HalpAllocPhysicalMemory(
    IN PLOADER_PARAMETER_BLOCK LoaderBlock,
    IN ULONG_PTR MaxPhysicalAddress,
    IN ULONG NoPages,
    IN BOOLEAN bAlignOn64k
    )
/*++

Routine Description:

    Carves out N pages of physical memory from the memory descriptor
    list in the desired location.  This function is to be called only
    during phase zero initialization.  (ie, before the kernel's memory
    management system is running)

Arguments:

    MaxPhysicalAddress - The max address where the physical memory can be
    NoPages - Number of pages to allocate

Return Value:

    The physical address or NULL if the memory could not be obtained.

--*/
{
    PMEMORY_ALLOCATION_DESCRIPTOR Descriptor;
    PLIST_ENTRY NextMd;
    ULONG AlignmentOffset;
    ULONG_PTR MaxPageAddress;
    ULONG_PTR PhysicalAddress;

    MaxPageAddress = MaxPhysicalAddress >> PAGE_SHIFT;

    //
    // Scan the memory allocation descriptors and allocate map buffers
    //

    NextMd = LoaderBlock->MemoryDescriptorListHead.Flink;
    while (NextMd != &LoaderBlock->MemoryDescriptorListHead) {
        Descriptor = CONTAINING_RECORD(
                         NextMd,
                         MEMORY_ALLOCATION_DESCRIPTOR,
                         ListEntry
                         );

        AlignmentOffset = bAlignOn64k ?
            ((Descriptor->BasePage + 0x0f) & ~0x0f) - Descriptor->BasePage :
            0;

        //
        // Search for a block of memory which is contains a memory chuck
        // that is greater than size pages, and has a physical address less
        // than MAXIMUM_PHYSICAL_ADDRESS.
        //

        if ((Descriptor->MemoryType == LoaderFree ||
             Descriptor->MemoryType == MemoryFirmwareTemporary) &&
            (Descriptor->BasePage) &&
            (Descriptor->PageCount >= NoPages + AlignmentOffset) &&
            (Descriptor->BasePage + NoPages + AlignmentOffset < MaxPageAddress)) {

      PhysicalAddress =
         (Descriptor->BasePage + AlignmentOffset) << PAGE_SHIFT;
                break;
        }

        NextMd = NextMd->Flink;
    }

    //
    // Use the extra descriptor to define the memory at the end of the
    // original block.
    //


    ASSERT(NextMd != &LoaderBlock->MemoryDescriptorListHead);

    if (NextMd == &LoaderBlock->MemoryDescriptorListHead)
        return 0;

    //
    // Adjust the memory descriptors.
    //

    if (AlignmentOffset == 0) {

        Descriptor->BasePage  += NoPages;
        Descriptor->PageCount -= NoPages;

        if (Descriptor->PageCount == 0) {

            //
            // The whole block was allocated,
            // Remove the entry from the list completely.
            //

            RemoveEntryList(&Descriptor->ListEntry);

        }

    } else {

        if (Descriptor->PageCount - NoPages - AlignmentOffset) {

            //
            //  Currently we only allow one Align64K allocation
            //

            ASSERT (HalpExtraAllocationDescriptor.PageCount == 0);

            //
            // The extra descriptor is needed so intialize it and insert
            // it in the list.
            //

            HalpExtraAllocationDescriptor.PageCount =
                Descriptor->PageCount - NoPages - AlignmentOffset;

            HalpExtraAllocationDescriptor.BasePage =
                Descriptor->BasePage + NoPages + AlignmentOffset;

            HalpExtraAllocationDescriptor.MemoryType = MemoryFree;

            InsertHeadList(
                &Descriptor->ListEntry,
                &HalpExtraAllocationDescriptor.ListEntry
                );
        }


        //
        // Use the current entry as the descriptor for the first block.
        //

        Descriptor->PageCount = AlignmentOffset;
    }

    return (PVOID)PhysicalAddress;
}

BOOLEAN
HalpVirtualToPhysical(
    IN  ULONG_PTR           VirtualAddress,
    OUT PPHYSICAL_ADDRESS   PhysicalAddress
    )
{
    if (VirtualAddress >= KSEG3_BASE && VirtualAddress < KSEG3_LIMIT) {

        PhysicalAddress->QuadPart = VirtualAddress - KSEG3_BASE;

    } else if (VirtualAddress >= KSEG4_BASE && VirtualAddress < KSEG4_LIMIT) {

        PhysicalAddress->QuadPart = VirtualAddress - KSEG4_BASE;

    } else {

        return FALSE;

    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\rangesup.c ===
//
// This file simply includes the common sources from the current HAL
// directory. When the structure is finally changed, the real file should
// be in this directory.
//

#include "..\rangesup.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\halnls.h ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\halnls.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\ix8259.inc ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halx86\i386\ix8259.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\ixbeep.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halx86\i386\ixbeep.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\xxhal.c ===
/*++

Copyright (c) 1989-2000  Microsoft Corporation

Component Name:

    HALIA64

Module Name:

    xxhal.c

Abstract:

    This module determines the HAL IA64 common features based on processor 
    and platform types. This exposes the processor and system features 
    that the HAL would use to enable / disable its own features.
    By the mean of HAL exported interfaces or exported global variables, 
    the HAL exposes its supported features.

Author:

    David N. Cutler (davec) 5-Mar-1989

Environment:

    ToBeSpecified

Revision History:

    3/23/2000 Thierry Fevrier (v-thief@microsoft.com):

         Initial version

--*/

#include "halp.h"

extern ULONG HalpMaxCPEImplemented;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpGetFeatureBits)
#endif

ULONG
HalpGetFeatureBits (
    VOID
    )
{
    ULONG   bits = HALP_FEATURE_INIT;
    PKPRCB  prcb = KeGetCurrentPrcb();

    //
    // Determine Processor type and System type.
    //
    // For the processor, this could come from:
    //  - PAL_BUS_GET_FEATURES
    //  - PAL_DEBUG_INFO        ??
    //  - PAL_FREQ_BASE
    //  - PAL_FREQ_RATIOS
    //  - PAL_PERF_MON_INFO
    //  - PAL_PROC_GET_FEATURES
    //  - PAL_REGISTER_INFO
    //  - PAL_VERSION
    //

    // NOT-YET...

    //
    // Determine Processor features:
    // like support for Processor Hardware Performance Monitor Events and
    // - HAL_NO_SPECULATION
    // - HAL_MCA_PRESENT      
    
    // NOT-YET - should call PAL PERF_MON call.
    bits |= HAL_PERF_EVENTS;

    //
    // Determine Platform features:
    // like support for Platform Performance Monitor Events...
    //

    // NOT-YET - should call SAL calls.

    //
    // Default software HAL support for IA64 Errors (MCA, CMC, CPE).
    //
    // However, we already know if we found an ACPI platform interrupt entry which identifier
    // is PLATFORM_INT_CPE.
    //

    bits |= HAL_MCA_PRESENT;
    if ( HalpCmcInfo.Stats.MaxLogSize )   {
        if ( HalpCmcInfo.Stats.MaxLogSize >= sizeof( ERROR_RECORD_HEADER )) {
            bits |= HAL_CMC_PRESENT;
        }
        else if ( prcb->Number == 0 )    {
            HalDebugPrint(( HAL_ERROR, 
                            "HAL!HalpGetFeatureBits: Invalid max CMC log size from SAL\n" ));
        }
    }

    //
    // Thierry 03/11/2001: WARNING WARNING
    // For the final release, the following HalpMaxCPEImplemented should be eliminated.
    // However the current FWs MCE situation is rather pathetic:
    //   **** Do not allow the setting of HAL_CPE_PRESENT if HalpMaxCPEImplemented == 0 ****
    //
    // [good] reasons:
    //  - We bugcheck with the current BigSur SAL/FW (<= build 99) at SAL_GET_STATE_INFO calls,
    //    the FW assuming that we are calling the SAL MC related functions in physical mode.
    //  - With the Lion SAL/FW (<= build 75), we bugcheck after getting MCA logs at boot time,
    //    the FW having some virtualization issues.
    // Intel is committed to provide working FWs soon (< 2 weeks...).
    //

    if ( HalpMaxCPEImplemented && HalpCpeInfo.Stats.MaxLogSize )   {
        if ( HalpCpeInfo.Stats.MaxLogSize >= sizeof( ERROR_RECORD_HEADER ) ) {
            bits |= HAL_CPE_PRESENT;
        }
        else if ( prcb->Number == 0 )    {
           HalDebugPrint(( HAL_ERROR, 
                           "HAL!HalpGetFeatureBits: Invalid max CPE log size from SAL\n" ));
        }
    }

    return bits;

} // HalpGetFeatureBits()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\ixcmos.inc ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halx86\i386\ixcmos.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\ixdat.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixdat.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\xxstubs.c ===
//
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    stubs.c

Abstract:

    This implements the HAL routines which don't do anything on IA64.

Author:

    John Vert (jvert) 11-Jul-1991

Revision History:

--*/
#include "halp.h"



VOID
HalSaveState(
    VOID
    )

/*++

Routine Description:

    Saves the system state into the restart block.  Currently does nothing.

Arguments:

    None

Return Value:

    Does not return

--*/

{
    HalDebugPrint(( HAL_ERROR, "HAL: HalSaveState called - System stopped\n" ));

    KeBugCheck(0);
}


BOOLEAN
HalDataBusError(
    VOID
    )

/*++

Routine Description:

    Called when a data bus error occurs.  There is no way to fix this on
    IA64.

Arguments:

    None

Return Value:

    FALSE

--*/

{
    HalDebugPrint(( HAL_ERROR, "HAL: HalDataBusError called - System stopped\n" ));

    KeBugCheck(0);
    return(FALSE);
}

BOOLEAN
HalInstructionBusError(
    VOID
    )

/*++

Routine Description:

    Called when an instruction bus error occurs.  There is no way to fix this
    on IA64.

Arguments:

    None

Return Value:

    FALSE

--*/

{
    HalDebugPrint(( HAL_ERROR, "HAL: HalInstructionBusError called - System stopped\n" ));

    KeBugCheck(0);
    return(FALSE);
}

//*******************************************************************
// Added by T. Kjos to temporarily stub out unused functions that
// are needed at link time.  These should all be removed as the
// "real" versions are developed.

// Function called for by all stubbed functions.  Can be used for
// breakpoints on unimplemented functions
VOID DbgNop() { return; }

// Macro for stubbed function.  If function is called then BugCheck
#define STUBFUNC(Func) \
ULONG Func () \
{ \
    HalDebugPrint(( HAL_FATAL_ERROR, "HAL: " # Func " - not yet implemented - System stopped\n" )); \
    DbgNop(); \
    KeBugCheck(0); \
}

// Macro for stubbed function.  If function is called then print
// warning and continue
#define STUBFUNC_NOP(Func) \
ULONG Func () \
{ \
    HalDebugPrint(( HAL_INFO, "HAL: " # Func " - not yet implemented\n" )); \
    DbgNop(); \
    return TRUE; \
}

// Macro for stubbed void function.  If function is called then print
// warning and continue
#define STUBVOIDFUNC_NOP(Func) \
VOID Func ( VOID ) \
{ \
    HalDebugPrint(( HAL_INFO, "HAL: " # Func " - not yet implemented\n" )); \
    DbgNop(); \
    return; \
}

// Macro for stubbed void function with 3 PVOID arguments.  
// If function is called then print warning and continue
#define STUBVOIDFUNC3PVOID_NOP(Func) \
VOID Func ( PVOID pv0, PVOID pv1, PVOID pv2 ) \
{ \
    HalDebugPrint(( HAL_INFO, "HAL: " # Func " - not yet implemented\n" )); \
    DbgNop(); \
    return; \
}

// Macro for stubbed ULONG values
#define STUBULONG(UlongVar) ULONG UlongVar = 0;

// Functions that are not yet implemented...
STUBVOIDFUNC_NOP(HalpResetAllProcessors)
STUBFUNC_NOP(HalpSetClockBeforeSleep)
STUBFUNC_NOP(HalpSetClockAfterSleep)
STUBFUNC_NOP(HalpSetWakeAlarm)
STUBFUNC(HalpRemapVirtualAddress)
STUBFUNC_NOP(HalaAcpiTimerInit)
STUBFUNC_NOP(Stub_LockNMILock)
STUBFUNC_NOP(HalAcpiTimerCarry)
STUBVOIDFUNC3PVOID_NOP(HalpPowerStateCallback)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\ixenvirv.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixenvirv.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\halp.h ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\halp.h"

// #define NT_35           1       // build hal for NT 3.5

#ifdef NT_35
#undef ALLOC_PRAGMA
#undef MmLockPagableCodeSection(a)
#undef MmUnlockPagableImageSection(a)
#define MmLockPagableCodeSection(a)     NULL
#define MmUnlockPagableImageSection(a)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halia64\ia64\xxtime.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    xxtime.c

Abstract:

    This module implements the HAL set/query realtime clock routines for
    an x86 system.

Author:

    David N. Cutler (davec) 5-May-1991

Environment:

    Kernel mode

Revision History:

--*/

#include "halp.h"


BOOLEAN
HalQueryRealTimeClock (
    OUT PTIME_FIELDS TimeFields
    )

/*++

Routine Description:

    This routine queries the realtime clock.

    N.B. This routine assumes that the caller has provided any required
        synchronization to query the realtime clock information.

Arguments:

    TimeFields - Supplies a pointer to a time structure that receives
        the realtime clock information.

Return Value:

    If the power to the realtime clock has not failed, then the time
    values are read from the realtime clock and a value of TRUE is
    returned. Otherwise, a value of FALSE is returned.

--*/

{

    KIRQL OldIrql;
	EFI_TIME Time;
	EFI_STATUS Status;
    BOOLEAN    bstatus;
    
    KeRaiseIrql(HIGH_LEVEL, &OldIrql);

    //
    // Read the realtime clock values provided by the EFI Runtime interface.
    //
    
	Status = HalpCallEfi (
                  EFI_GET_TIME_INDEX,
                  (ULONGLONG)&Time,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0
                  );

#if 0
HalDebugPrint((HAL_INFO, "HalQueryRealTimeClock: EFI GetTime return status is %Id \n", Status));
#endif // 0

    if ( EFI_ERROR( Status ) )  {
        // if EFI error, let's reset the passed TIME_FIELDS structure.
        // The caller should check the return status.
	    TimeFields->Year         = 0;
        TimeFields->Day          = 0;
        TimeFields->Hour         = 0;
	    TimeFields->Minute       = 0;
        TimeFields->Second       = 0;
	    TimeFields->Milliseconds = 0;
        TimeFields->Weekday      = 0;
        bstatus = FALSE;
    }
    else    {

        LARGE_INTEGER ntTime;
    
	    TimeFields->Year         = Time.Year;
        TimeFields->Month        = Time.Month;
        TimeFields->Day          = Time.Day;
        TimeFields->Hour         = Time.Hour;
	    TimeFields->Minute       = Time.Minute;
        TimeFields->Second       = Time.Second;
	    TimeFields->Milliseconds = Time.Nanosecond / 1000000;

        //
        // Use RTL time functions to calculate the day of week.
        //  1/ RtlTimeFieldsToTime ignores the .Weekday field.
        //  2/ RtlTimeToTimeFields sets    the .Weekday field.
        //

        RtlTimeFieldsToTime( TimeFields, &ntTime );
        RtlTimeToTimeFields( &ntTime, TimeFields );

#if 0
HalDebugPrint(( HAL_INFO, "%d / %d / %d , %d:%d:%d:%d, %d\n",   TimeFields->Year, 
                                                                TimeFields->Month,
                                                                TimeFields->Day, 
                                                                TimeFields->Hour, 
                                                                TimeFields->Minute, 
                                                                TimeFields->Second, 
                                                                TimeFields->Milliseconds, 
                                                                TimeFields->Weekday));
HalDebugPrint((HAL_INFO, "Timezone is %d\n", Time.TimeZone));
#endif // 0
        bstatus = TRUE;

    }

	KeLowerIrql(OldIrql);

    return ( bstatus );

} // HalQueryRealTimeClock()


BOOLEAN
HalSetRealTimeClock (
    IN PTIME_FIELDS TimeFields
    )

/*++

Routine Description:

    This routine sets the realtime clock.

    N.B. This routine assumes that the caller has provided any required
        synchronization to set the realtime clock information.

Arguments:

    TimeFields - Supplies a pointer to a time structure that specifies the
        realtime clock information.

Return Value:

    If the power to the realtime clock has not failed, then the time
    values are written to the realtime clock and a value of TRUE is
    returned. Otherwise, a value of FALSE is returned.

--*/

{

    KIRQL OldIrql;
	EFI_TIME CurrentTime;
	EFI_TIME NewTime;
    EFI_STATUS Status;

    KeRaiseIrql(HIGH_LEVEL, &OldIrql);

    //
    // If the realtime clock battery is still functioning, then write
    // the realtime clock values, and return a function value of TRUE.
    // Otherwise, return a function value of FALSE.
    //

	Status = HalpCallEfi (
                  EFI_GET_TIME_INDEX,
                  (ULONGLONG)&CurrentTime,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0,
                  0
                  );       

    if ( EFI_ERROR( Status ) )  {
        KeLowerIrql(OldIrql);
		return FALSE;
    }
  
    NewTime.Year       = TimeFields->Year;
    NewTime.Month      = (UINT8)TimeFields->Month;
    NewTime.Day        = (UINT8)TimeFields->Day;
    NewTime.Hour       = (UINT8)TimeFields->Hour;
    NewTime.Minute     = (UINT8)TimeFields->Minute;
    NewTime.Second     = (UINT8)TimeFields->Second;
	NewTime.Nanosecond = TimeFields->Milliseconds * 1000000;
    NewTime.TimeZone   = CurrentTime.TimeZone;
    NewTime.Daylight   = CurrentTime.Daylight;

    //
    // Write the realtime clock values.
    //   

    Status = HalpCallEfi (
			  EFI_SET_TIME_INDEX,
			  (ULONGLONG)&NewTime,
			  0,
			  0,
			  0,
			  0,
			  0,
			  0,
			  0
			  );

#if 0
HalDebugPrint(( HAL_INFO, "HalSetRealTimeClock: EFI SetTime return status is %Id \n" 
                          "%d / %d / %d , %d:%d:%d:%d\n"
                          "Timezone is %d\n"
                          "Daylight is %d\n", 
                          Status,
                          NewTime.Month,
                          NewTime.Day, 
                          NewTime.Year, 
                          NewTime.Hour, 
                          NewTime.Minute, 
                          NewTime.Second, 
                          NewTime.Nanosecond,
                          NewTime.TimeZone,
                          NewTime.Daylight ));
#endif // 0

    KeLowerIrql(OldIrql);

    return( !EFI_ERROR( Status ) );

} // HalSetRealTimeClock()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\drivesup.c ===
#include "..\drivesup.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\ixfirm.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixfirm.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\ixbusdat.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixbusdat.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\ixhwsup.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixhwsup.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\ixidle.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halx86\i386\ixidle.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\ixinfo.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixinfo.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\ixcmos.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halx86\i386\ixcmos.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\ixisa.h ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixisa.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\ixaddr.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\halx86\i386\ixaddr.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\ixmca.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixmca.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\ixmcaa.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halx86\i386\ixmcaa.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\ixmovnti.asm ===
;
; Include code from halx86
;

include ..\..\halx86\i386\ixmovnti.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\ixnmi.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixnmi.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\ixmca.h ===
//
// Include code from halmca
// This is a cpp style symbolic link

#include "..\..\halmca\i386\ixmca.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\ixmcasup.c ===
//
// Include code from halmca
// This is a cpp style symbolic link

#ifdef MCA
#include "..\..\halmca\i386\ixmcasup.c"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\ixmcabus.c ===
//
// Include code from halmca
// This is a cpp style symbolic link

#ifdef MCA
#include "..\..\halmca\i386\ixmcabus.c"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\ixisabus.c ===
//
// Include code from halx86
// This is a cpp style symbolic link
//

#include "..\..\halx86\i386\ixisabus.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\ixpcibrd.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#define SUBCLASSPCI     1

#include "..\..\halx86\i386\ixpcibrd.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\ixisasup.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#ifndef MCA
#include "..\..\halx86\i386\ixisasup.c"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\ixphwsup.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixphwsup.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\ixreboot.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixreboot.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\ixsleep.h ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixsleep.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\ixslpsup.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixslpsup.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\ixslpctx.inc ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halx86\i386\ixslpctx.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\ixthunk.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixthunk.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\ixusage.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\..\halx86\i386\ixusage.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\ixpciint.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#define SUBCLASSPCI     1

#include "..\..\halx86\i386\ixpciint.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\ixpcibus.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#define SUBCLASSPCI     1

#include "..\..\halx86\i386\ixpcibus.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\ixpnpdrv.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#include "..\halx86\i386\ixpnpdrv.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\ixpcisup.c ===
//
// Include code from halx86
// This is a cpp style symbolic link

#define SUBCLASSPCI     1

#include "..\..\halx86\i386\ixpcisup.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\ixslpctx.asm ===
;
; Include code from halx86
; This is a cpp style symbolic link

include ..\..\halx86\i386\ixslpctx.asm
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\mp8254.inc ===
;++
;
;   Copyright (c) 1996-97  Microsoft Corporation
;
;   Module Name:
;
;       mp8254.inc
;
;   Abstract:
;
;       This module contains common definitions for the 8254 used
;       by the timer tick routine and the query peformance counter
;       routine.
;
;   Author:
;
;       Shivnandan Kaushik
;
;--

;
; Constants used to initialize timer 0
;

TIMER1_DATA_PORT0       EQU     40H     ; Timer1, channel 0 data port
TIMER1_CONTROL_PORT0    EQU     43H     ; Timer1, channel 0 control port

COMMAND_8254_COUNTER0   EQU     00H     ; Select count 0
COMMAND_8254_RW_16BIT   EQU     30H     ; Read/Write LSB first then MSB
COMMAND_8254_MODE2      EQU     4       ; Use mode 2
COMMAND_8254_BCD        EQU     0       ; Binary count down
COMMAND_8254_LATCH_READ EQU     0       ; Latch read command

PERFORMANCE_FREQUENCY   EQU     1193182 ; frequency of 8254
PERFORMANCE_INTERVAL    EQU     0ffffH  ; Maximum counter value

PERF_USE_8254           EQU     01h
PERF_8254_INITIALIZED   EQU     40h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\mpaddr.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
All rights reserved

Module Name:

    mpaddr.c

Abstract:

Author:

    Ken Reneris

Environment:

    Kernel mode only.

Revision History:


*/

#include "halp.h"
#include "apic.inc"
#include "pcmp_nt.inc"
#include "pci.h"

#if DEBUGGING
#include "stdio.h"
#endif

#define STATIC  // functions used internal to this module

#define KEY_VALUE_BUFFER_SIZE 1024

#if DBG
extern ULONG HalDebug;
#endif

extern struct   HalpMpInfo HalpMpInfoTable;
extern USHORT   HalpIoCompatibleRangeList0[];
extern USHORT   HalpIoCompatibleRangeList1[];
extern BOOLEAN  HalpPciLockSettings;
extern WCHAR    HalpSzSystem[];

struct PcMpTable *PcMpTablePtr;

BOOLEAN
HalpTranslateIsaBusAddress (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress
    );

ULONG
HalpNoBusData (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );

HalpGetEisaData (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN ULONG SlotNumber,
    IN PVOID Buffer,
    IN ULONG Offset,
    IN ULONG Length
    );


NTSTATUS
HalpAdjustEisaResourceList (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN OUT PIO_RESOURCE_REQUIREMENTS_LIST   *pResourceList
    );

ULONG
HalpGetEisaInterruptVector (
    IN PVOID BusHandler,
    IN PVOID RootHandler,
    IN ULONG BusInterruptLevel,
    IN ULONG BusInterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    );

// --------------------------------------------------------------------

VOID
HalpInitBusAddressMapInfo (
    VOID
    );

STATIC PSUPPORTED_RANGES
HalpBuildBusAddressMap (
    IN UCHAR  MpsBusId
    );

PBUS_HANDLER
HalpLookupCreateHandlerForBus (
    IN PPCMPBUSTRANS    pBusType,
    IN ULONG            BusNo
    );

VOID
HalpInheritBusAddressMapInfo (
    VOID
    );

BOOLEAN
HalpMPSBusId2NtBusId (
    IN UCHAR                ApicBusId,
    OUT PPCMPBUSTRANS       *ppBusType,
    OUT PULONG              BusNo
    );

STATIC PSUPPORTED_RANGES
HalpMergeRangesFromParent (
    PSUPPORTED_RANGES   CurrentList,
    UCHAR               MpsBusId
    );

#if DEBUGGING
VOID
HalpDisplayBusInformation (
    PBUS_HANDLER    Bus
    );
#endif

//
// Internal prototypes
//

struct {
    ULONG       Offset;
    UCHAR       MpsType;
} HalpMpsRangeList[] = {
    FIELD_OFFSET (SUPPORTED_RANGES, IO),            MPS_ADDRESS_MAP_IO,
    FIELD_OFFSET (SUPPORTED_RANGES, Memory),        MPS_ADDRESS_MAP_MEMORY,
    FIELD_OFFSET (SUPPORTED_RANGES, PrefetchMemory),MPS_ADDRESS_MAP_PREFETCH_MEMORY,
    FIELD_OFFSET (SUPPORTED_RANGES, Dma),           MPS_ADDRESS_MAP_UNDEFINED,
    0,                                              MPS_ADDRESS_MAP_UNDEFINED
    };

#define RANGE_LIST(a,i) ((PSUPPORTED_RANGE) ((PUCHAR) a + HalpMpsRangeList[i].Offset))

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,HalpInitBusAddressMapInfo)
#pragma alloc_text(INIT,HalpBuildBusAddressMap)
#pragma alloc_text(INIT,HalpInheritBusAddressMapInfo)
#pragma alloc_text(INIT,HalpMergeRangesFromParent)
#pragma alloc_text(INIT,HalpLookupCreateHandlerForBus)
#pragma alloc_text(PAGE,HalpAllocateNewRangeList)
#pragma alloc_text(PAGE,HalpFreeRangeList)
#pragma alloc_text(PAGE,HalpMpsGetParentBus)
#pragma alloc_text(PAGE,HalpMpsBusIsRootBus)
#endif


VOID
HalpInitBusAddressMapInfo (
    VOID
    )
/*++

Routine Description:

    Reads MPS bus addressing mapping table, and builds/replaces the
    supported address range mapping for the given bus.

    Note there's a little slop in this function as it doesn't reclaim
    memory allocated before this function is called, which it replaces
    pointers too.

--*/
{
    ULONG               BusNo;
    PPCMPBUSTRANS       pBusType;
    PMPS_EXTENTRY       ExtTable2, ExtTable;
    PBUS_HANDLER        Handler;
    PSUPPORTED_RANGES   Addresses;
    ULONG               i;
    BOOLEAN             Processed;

    //
    // Check for any address mapping information for the buses
    //
    // Note: We assume that if any MPS bus address map information
    // is found for a bus, that the MPS bios will supply all the
    // valid IO, Memory, and prefetch memory addresses for that BUS.
    // The bios can not supply some address tyeps for a given bus
    // without supplying them all.
    //

    ExtTable = HalpMpInfoTable.ExtensionTable;
    while (ExtTable < HalpMpInfoTable.EndOfExtensionTable) {

        //
        // Is this an address map entry?
        //

        if (ExtTable->Type == EXTTYPE_BUS_ADDRESS_MAP) {

            //
            // See if this bus has already been processed
            //

            Processed = FALSE;
            ExtTable2 = HalpMpInfoTable.ExtensionTable;
            while (ExtTable2 < ExtTable) {
                if (ExtTable2->Type == EXTTYPE_BUS_ADDRESS_MAP  &&
                    ExtTable2->u.AddressMap.BusId == ExtTable->u.AddressMap.BusId) {
                        Processed = TRUE;
                        break;
                }
                ExtTable2 = (PMPS_EXTENTRY) (((PUCHAR) ExtTable2) + ExtTable2->Length);
            }

            //
            // Determine the NT bus this map info is for
            //

            if (!Processed  &&
                HalpMPSBusId2NtBusId (ExtTable->u.AddressMap.BusId, &pBusType, &BusNo)) {

                //
                // Lookup the bushander for the bus
                //

                Handler = HalpLookupCreateHandlerForBus (pBusType, BusNo);

                if (Handler) {

                    //
                    // NOTE: Until we get better kernel PnP support, for now
                    // limit the ability of the system to move already BIOS
                    // initialized devices.  This is needed because the exteneded
                    // express BIOS can't give the OS any breathing space when
                    // it hands bus supported ranges, and there's currently not
                    // an interface to the kernel to obtain current PCI device
                    // settings.  (fixed in the future.)
                    //

                    HalpPciLockSettings = TRUE;

                    //
                    // Build BusAddress Map for this MPS bus
                    //

                    Addresses = HalpBuildBusAddressMap (ExtTable->u.AddressMap.BusId);




                    //
                    // Consoladate ranges
                    //

                    HalpConsolidateRanges (Addresses);

                    //
                    // Use current ranges for any undefined MPS ranges
                    //

                    for (i=0; HalpMpsRangeList[i].Offset; i++) {
                        if (HalpMpsRangeList[i].MpsType == MPS_ADDRESS_MAP_UNDEFINED) {
                            *RANGE_LIST(Addresses,i) = *RANGE_LIST(Handler->BusAddresses, i);
                        }
                    }

                    //
                    // Set bus'es support addresses
                    //

                    Handler->BusAddresses = Addresses;

                } else {

                    DBGMSG ("HAL: Initialize BUS address map - bus not an registered NT bus\n");

                }
            }
        }

        ExtTable = (PMPS_EXTENTRY) (((PUCHAR) ExtTable) + ExtTable->Length);
    }
}


STATIC PSUPPORTED_RANGES
HalpBuildBusAddressMap (
    IN UCHAR  MpsBusId
    )
/*++

Routine Description:

    Builds a SUPPORT_RANGES list for the supplied Mps Bus Id, by
    MPS bus addressing mapping descriptors.

    Note this function does not include any information contained
    in the MPS bus hierarchy descriptors.

Arguments:

    MpsBusId    - mps bus id of bus to build address map for.

Return:

    The bus'es supported ranges as defined by the MPS bus
    address mapping descriptors

--*/
{
    PMPS_EXTENTRY       ExtTable;
    PSUPPORTED_RANGES   Addresses;
    PSUPPORTED_RANGE    HRange, Range;
    ULONG               i, j, k;
    ULONG               Base, Limit, AddressSpace;
    PUSHORT             CompatibleList;

    Addresses = HalpAllocateNewRangeList();

    ExtTable = HalpMpInfoTable.ExtensionTable;
    while (ExtTable < HalpMpInfoTable.EndOfExtensionTable) {

        //
        // Is this an address map entry for the proper bus?
        //

        if (ExtTable->Type == EXTTYPE_BUS_ADDRESS_MAP  &&
            ExtTable->u.AddressMap.BusId == MpsBusId) {

            //
            // Find range type
            //

            for (i=0; HalpMpsRangeList[i].Offset; i++) {
                if (HalpMpsRangeList[i].MpsType == ExtTable->u.AddressMap.Type) {
                    HRange = RANGE_LIST(Addresses, i);
                    break;
                }
            }

            AddressSpace = HalpMpsRangeList[i].MpsType == MPS_ADDRESS_MAP_IO ? 1 : 0;
            if (HalpMpsRangeList[i].Offset) {
                HalpAddRange (
                    HRange,
                    AddressSpace,
                    0,      // SystemBase
                    ExtTable->u.AddressMap.Base,
                    ExtTable->u.AddressMap.Base + ExtTable->u.AddressMap.Length - 1
                );

            } else {

                DBGMSG ("HALMPS: Unkown address range type in MPS table\n");

            }
        }

        ExtTable = (PMPS_EXTENTRY) (((PUCHAR) ExtTable) + ExtTable->Length);
    }

    //
    // See if the BIOS wants to modify the buses supported addresses with
    // some pre-defined default information.  (yes, another case where the
    // bios wants to be lazy.)
    //

    ExtTable = HalpMpInfoTable.ExtensionTable;
    while (ExtTable < HalpMpInfoTable.EndOfExtensionTable) {

        //
        // Is this an CompatibleMap entry for the proper bus?
        //

        if (ExtTable->Type == EXTTYPE_BUS_COMPATIBLE_MAP  &&
            ExtTable->u.CompatibleMap.BusId == MpsBusId) {

            //
            // All currently defined default tables are for IO ranges,
            // we'll use that assumption here.
            //

            i = 0;
            ASSERT (HalpMpsRangeList[i].MpsType == MPS_ADDRESS_MAP_IO);
            HRange = RANGE_LIST(Addresses, i);
            AddressSpace = 1;

            CompatibleList = NULL;
            switch (ExtTable->u.CompatibleMap.List) {
                case 0: CompatibleList = HalpIoCompatibleRangeList0;        break;
                case 1: CompatibleList = HalpIoCompatibleRangeList1;        break;
                default: DBGMSG ("HAL: Unknown compatible range list\n");   continue; break;
            }

            for (j=0; j < 0x10; j++) {
                for (k=0; CompatibleList[k]; k += 2) {
                    Base  = (j << 12) | CompatibleList[k];
                    Limit = (j << 12) | CompatibleList[k+1];

                    if (ExtTable->u.CompatibleMap.Modifier) {

                        HalpRemoveRange (HRange, Base, Limit);

                    } else {

                        HalpAddRange (HRange, AddressSpace, 0, Base, Limit);

                    }
                }
            }

        }
        ExtTable = (PMPS_EXTENTRY) (((PUCHAR) ExtTable) + ExtTable->Length);
    }

    return Addresses;
}

NTSTATUS
HalpAddEisaBus (
    PBUS_HANDLER    Bus
    )
/*++

Routine Description:

    Adds another EISA bus handler to the system.
    Note: this is used for ISA buses as well - they are added as eisa
    buses, then cloned into isa bus handlers

--*/
{
    Bus->GetBusData = HalpGetEisaData;
    Bus->GetInterruptVector = HalpGetEisaInterruptVector;
    Bus->AdjustResourceList = HalpAdjustEisaResourceList;

    Bus->BusAddresses->Version      = BUS_SUPPORTED_RANGE_VERSION;
    Bus->BusAddresses->Dma.Limit    = 7;
    Bus->BusAddresses->Memory.Limit = 0xFFFFFFFF;
    Bus->BusAddresses->IO.Limit     = 0xFFFF;
    Bus->BusAddresses->IO.SystemAddressSpace = 1;
    Bus->BusAddresses->PrefetchMemory.Base = 1;

    return STATUS_SUCCESS;
}

NTSTATUS
HalpAddPciBus (
    PBUS_HANDLER    Bus
    )
{
    //
    // The firmware should have informed NT how many PCI buses
    // there where at NtDetect time
    //

    DBGMSG ("HAL: BIOS problem.  PCI bus must be report via IS_PCI_PRESENT bios call\n");
    return STATUS_UNSUCCESSFUL;
}

PBUS_HANDLER
HalpLookupCreateHandlerForBus (
    IN PPCMPBUSTRANS    pBusType,
    IN ULONG            BusNo
    )
{
    NTSTATUS        Status;
    PBUS_HANDLER    Handler;

    Handler = HaliHandlerForBus (pBusType->NtType, BusNo);

    if (!Handler  &&  pBusType->NewInstance) {

        //
        // This bus does not exist, but we know how to add it.
        //

        Status = HalRegisterBusHandler (
                    pBusType->NtType,
                    pBusType->NtConfig,
                    BusNo,
                    Internal,                   // parent bus
                    0,
                    pBusType->BusExtensionSize,
                    pBusType->NewInstance,
                    &Handler
                    );

        if (!NT_SUCCESS(Status)) {
            Handler = NULL;
        }
    }

    return Handler;
}


VOID
HalpDetectInvalidAddressOverlaps(
    VOID
    )
{
    ULONG i, j, k;
    PBUS_HANDLER Bus1, Bus2;
    PSUPPORTED_RANGE Entry;
    PSUPPORTED_RANGES NewRange;

    //
    // Find root PCI buses and detect invalid address overlaps
    //

    for(i=0; Bus1 = HaliHandlerForBus(PCIBus, i); ++i)  {
        if (((Bus1->ParentHandler) &&
             (Bus1->ParentHandler->InterfaceType != Internal)) ||
            !(Bus1->BusAddresses))  {
            continue;
        }

        for(j=i+1; Bus2 = HaliHandlerForBus(PCIBus, j); ++j)  {
            if (((Bus2->ParentHandler) &&
                (Bus2->ParentHandler->InterfaceType != Internal)) ||
                !(Bus2->BusAddresses))  {
                continue;
            }

            NewRange = HalpMergeRanges(Bus1->BusAddresses, Bus2->BusAddresses);
            HalpConsolidateRanges(NewRange);
            for(k=0; HalpMpsRangeList[k].Offset; k++) {
                Entry = RANGE_LIST(NewRange, k);
                while (Entry) {
                    if (Entry->Limit != 0)  {
                        // KeBugCheck(HAL_INITIALIZATION_FAILED);
                        DbgPrint("HalpDetectInvalidAddressOverlaps: Address Overlap Detected\n");
                        break;
                    } else  {
                        Entry = Entry->Next;
                    }
                }
            }
            HalpFreeRangeList(NewRange);
        }
    }
}

VOID
HalpInheritBusAddressMapInfo (
    VOID
    )
/*++

Routine Description:

    Reads MPS bus hierarchy descriptors and inherits any implied bus
    address mapping information.

    Note there's a little slop in this function as it doesn't reclaim
    memory allocated before this function is called, which it replaces
    pointers too.

--*/
{
    ULONG               BusNo, i, j;
    PPCMPBUSTRANS       pBusType;
    PMPS_EXTENTRY       ExtTable;
    PBUS_HANDLER        Bus, Bus2;
    PSUPPORTED_RANGES   Addresses;
    PUCHAR              p;

    //
    // Search for any bus hierarchy descriptors and inherit supported address
    // ranges accordingly.
    //

    ExtTable = HalpMpInfoTable.ExtensionTable;
    while (ExtTable < HalpMpInfoTable.EndOfExtensionTable) {

        //
        // Is this a bus hierarchy descriptor?
        //

        if (ExtTable->Type == EXTTYPE_BUS_HIERARCHY) {

            //
            // Determine the NT bus
            //

            if (HalpMPSBusId2NtBusId (ExtTable->u.BusHierarchy.BusId, &pBusType, &BusNo)) {

                Bus = HalpLookupCreateHandlerForBus (pBusType, BusNo);

                if (Bus) {
                    //
                    // Get ranges from parent
                    //

                    Addresses = HalpMergeRangesFromParent (
                                    Bus->BusAddresses,
                                    ExtTable->u.BusHierarchy.ParentBusId
                                    );

                    //
                    // Set bus'es support addresses
                    //

                    Bus->BusAddresses = HalpConsolidateRanges (Addresses);

                } else {

                    DBGMSG ("HAL: Inherit BUS address map - bus not an registered NT bus\n");
                }

            } else {

                DBGMSG ("HAL: Inherit BUS address map - unkown MPS bus type\n");
            }
        }

        ExtTable = (PMPS_EXTENTRY) (((PUCHAR) ExtTable) + ExtTable->Length);
    }

    //
    // Clone EISA bus ranges to matching ISA buses
    //

    BusNo = 0;
    for (; ;) {
        Bus  = HaliHandlerForBus(Eisa, BusNo);
        Bus2 = HaliHandlerForBus(Isa , BusNo);

        if (!Bus) {
            break;
        }

        if (!Bus2) {
            //
            // Matching ISA bus didn't exist, create it
            //

            HalRegisterBusHandler (
               Isa,
               ConfigurationSpaceUndefined,
               BusNo,
               Eisa,                // parent bus
               BusNo,
               0,
               NULL,
               &Bus2
               );

            Bus2->GetBusData = HalpNoBusData;
            Bus2->TranslateBusAddress = HalpTranslateIsaBusAddress;
        }

        //
        // Copy its parent bus ranges
        //

        Addresses = HalpCopyRanges (Bus->BusAddresses);

        //
        // Pull out memory ranges above the isa 24 bit supported ranges
        //

        HalpRemoveRange (
            &Addresses->Memory,
            0x1000000,
            0x7FFFFFFFFFFFFFFF
            );

        HalpRemoveRange (
            &Addresses->PrefetchMemory,
            0x1000000,
            0x7FFFFFFFFFFFFFFF
            );

        Bus2->BusAddresses = HalpConsolidateRanges (Addresses);
        BusNo += 1;
    }

    //
    // Inherit any implied interrupt routing from parent PCI buses
    //

    HalpMPSPCIChildren ();
    HalpDetectInvalidAddressOverlaps();

#if DBG
    if (HalDebug) {
        HalpDisplayAllBusRanges ();
    }
#endif
}

STATIC PSUPPORTED_RANGES
HalpMergeRangesFromParent (
    IN PSUPPORTED_RANGES  CurrentList,
    IN UCHAR              MpsBusId
    )
/*++
Routine Description:

    Shrinks this CurrentList to include only the ranges also
    supported by the supplied MPS bus id.


Arguments:

    CurrentList - Current supported range list
    MpsBusId    - mps bus id of bus to merge with

Return:

    The bus'es supported ranges as defined by the orignal list,
    shrunk by all parents buses supported ranges as defined by
    the MPS hierarchy descriptors

--*/
{
    ULONG               BusNo;
    PPCMPBUSTRANS       pBusType;
    PMPS_EXTENTRY       ExtTable;
    PBUS_HANDLER        Bus;
    PSUPPORTED_RANGES   NewList, MergeList, MpsBusList;
    BOOLEAN             FoundParentBus;
    ULONG               i;

    FoundParentBus = FALSE;
    MergeList      = NULL;
    MpsBusList     = NULL;

    //
    // Determine the NT bus
    //

    if (HalpMPSBusId2NtBusId (MpsBusId, &pBusType, &BusNo)) {

        //
        // Lookup the bushander for the bus
        //

        Bus = HaliHandlerForBus (pBusType->NtType, BusNo);
        if (Bus) {
            MergeList = Bus->BusAddresses;
        }
    }

    //
    // If NT bus not found, use supported range list from MPS bus
    // address map descriptors
    //

    if (!MergeList) {
        MpsBusList = HalpBuildBusAddressMap(MpsBusId);
        MergeList  = MpsBusList;
    }

    //
    // If no list to merge with use CurrentList
    //

    if (!MergeList) {
        return CurrentList;
    }


    if (!CurrentList) {

        //
        // If no CurrentList, then nothing to merge with
        //

        NewList = HalpCopyRanges (MergeList);

    } else {

        //
        // Merge lists together and build a new list
        //

        NewList = HalpMergeRanges (
                        CurrentList,
                        MergeList
                    );

        //
        // MPS doesn't define DMA ranges, so we don't
        // merge those down..   Add valid DMA ranges back
        //

        HalpAddRangeList (&NewList->Dma, &CurrentList->Dma);
    }


    //
    // See if bus has parent bus listed in the bus hierarchy descriptors
    //

    ExtTable = HalpMpInfoTable.ExtensionTable;
    while (ExtTable < HalpMpInfoTable.EndOfExtensionTable) {

        if (ExtTable->Type == EXTTYPE_BUS_HIERARCHY  &&
            ExtTable->u.BusHierarchy.BusId == MpsBusId) {

            //
            // BIOS can only list one parent per bus
            //

            ASSERT (FoundParentBus == FALSE);
            FoundParentBus = TRUE;

            //
            // Merge current list with parent's supported range list
            //

            CurrentList = NewList;
            NewList = HalpMergeRangesFromParent (
                        CurrentList,
                        ExtTable->u.BusHierarchy.ParentBusId
                        );

            //
            // Free old list
            //

            HalpFreeRangeList (CurrentList);
        }

        ExtTable = (PMPS_EXTENTRY) (((PUCHAR) ExtTable) + ExtTable->Length);
    }

    //
    // Clean up
    //

    if (MpsBusList) {
        HalpFreeRangeList (MpsBusList);
    }

    return NewList;
}

NTSTATUS
HalpMpsGetParentBus(
    IN  UCHAR MpsBus,
    OUT UCHAR *ParentMpsBus
    )
{
    PMPS_EXTENTRY       ExtTable;

    PAGED_CODE();

    ExtTable = HalpMpInfoTable.ExtensionTable;
    while (ExtTable < HalpMpInfoTable.EndOfExtensionTable) {

        //
        // Is this a bus hierarchy descriptor?
        //

        if (ExtTable->Type == EXTTYPE_BUS_HIERARCHY) {

            if (ExtTable->u.BusHierarchy.BusId == MpsBus) {

                *ParentMpsBus = ExtTable->u.BusHierarchy.ParentBusId;
                return STATUS_SUCCESS;
            }
        }

        ExtTable = (PMPS_EXTENTRY) (((PUCHAR) ExtTable) + ExtTable->Length);
    }

    return STATUS_NOT_FOUND;
}

BOOLEAN
HalpMpsBusIsRootBus(
    IN  UCHAR MpsBus
    )
//
// The criteria for a Root Bus are as follows:
//
// 1.1 and 1.4 BIOS:
//
// 1)  The bus is number 0.
//
//
// 1.4 BIOS only:
//
// 2)  The bus does not have a parent.
// 
// 3)  The bus has address descriptors, if
//     there are any present in the machine.
//
//
// 4)  Last resort.  Scan all possible parent busses
//     looking for a bridge that generates this bus.
//
#define BRIDGE_HEADER_BUFFER_SIZE (FIELD_OFFSET(PCI_COMMON_CONFIG, u.type1.SubordinateBus) + 1)
{
    NTSTATUS status;
    UCHAR parentBus;
    PMPS_EXTENTRY ExtTable;
    BOOLEAN biosContainsAddressInfo = FALSE;
    UCHAR parentPci, childPci;
    PCI_SLOT_NUMBER bridgeSlot;
    PCI_COMMON_CONFIG pciData;
    ULONG bytesRead, d, f;
    PPCMPBUSTRANS busType;
    ULONG busNumber;

    PAGED_CODE();

    if (MpsBus == 0) {
        return TRUE;
    }
    
    //
    // Check to see if this MPS bus, though not
    // itself numbered 0, represents a bus that
    // is numbered 0.
    //

    if (HalpMPSBusId2NtBusId(MpsBus,
                             &busType,
                             &busNumber)) {

        if (busNumber == 0) {
            return TRUE;
        }
    }
    
    if (PcMpTablePtr->Revision >= 4) {
        
        if (NT_SUCCESS(HalpMpsGetParentBus(MpsBus,&parentBus))) {
            return FALSE;
        }

        ExtTable = HalpMpInfoTable.ExtensionTable;
        while (ExtTable < HalpMpInfoTable.EndOfExtensionTable) {

            if ((ExtTable->Type == EXTTYPE_BUS_ADDRESS_MAP) ||
                (ExtTable->Type == EXTTYPE_BUS_COMPATIBLE_MAP)) {

                biosContainsAddressInfo = TRUE;

                if (ExtTable->u.AddressMap.BusId == MpsBus) {

                    //
                    // This entry corresponds to the bus that
                    // we care about.
                    //
                    return TRUE;
                }
            }

            ExtTable = (PMPS_EXTENTRY) (((PUCHAR) ExtTable) + ExtTable->Length);
        }

        //
        // Compaq machines have their own special ways to be busted.  So,
        // when dealing with Compaq, never believe their MP table at all.
        // Go straight to probing the hardware.
        //

        if (!strstr(PcMpTablePtr->OemId, "COMPAQ")) {

            //
            // If this is not Compaq, assume that probing the hardware
            // is not yet necessary.
            //

            if (biosContainsAddressInfo) {

                //
                // Some bus in this machine contained address
                // info, but ours didn't.
                //

                return FALSE;
            }

            //
            // We can't figure out much from the MPS tables.
            //

            status = HalpPci2MpsBusNumber(MpsBus,
                                          &childPci);

            //
            // This wasn't a PCI bus.  Guess that it is a root.
            //

            if (!NT_SUCCESS(status)) {
                 return TRUE;
            }
        }
    }
    
    //
    // This is a PCI bus, so scan the other PCI busses looking
    // for it's parent.
    //

    childPci = MpsBus;
    parentPci = childPci - 1;
    
    while (TRUE) {
        
        //
        // Find the bridge.
        //

        bridgeSlot.u.AsULONG = 0;

        for (d = 0; d < PCI_MAX_DEVICES; d++) {
            for (f = 0; f < PCI_MAX_FUNCTION; f++) {

                bridgeSlot.u.bits.DeviceNumber = d;
                bridgeSlot.u.bits.FunctionNumber = f;

                bytesRead = HalGetBusDataByOffset(PCIConfiguration,
                                                  parentPci,
                                                  bridgeSlot.u.AsULONG,
                                                  &pciData,
                                                  0,
                                                  BRIDGE_HEADER_BUFFER_SIZE);

                if (bytesRead == (ULONG)BRIDGE_HEADER_BUFFER_SIZE) {

                    if ((pciData.VendorID != PCI_INVALID_VENDORID) &&
                        (PCI_CONFIGURATION_TYPE((&pciData)) != PCI_DEVICE_TYPE)) {

                        //
                        // This is a bridge of some sort.
                        //

                        if (pciData.u.type1.SecondaryBus == childPci) {

                            //
                            // It is also the bridge that creates the 
                            // PCI bus.  Thus this isn't a root.

                            return FALSE;
                        }
                    }
                }
            }
        }
        
        //
        // No bridge found. Must be a root.
        //

        if (parentPci == 0) {
            return TRUE;
        }

        parentPci--;
    }   
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\mpclockc.c ===
/*++

Module Name:

    mpclockc.c

Abstract:

Author:

    Ron Mosgrove - Intel

Environment:

    Kernel mode

Revision History:



--*/

#include "halp.h"

//
// Define global data used to communicate new clock rates to the clock
// interrupt service routine.
//

struct RtcTimeIncStruc {
    ULONG RTCRegisterA;        // The RTC register A value for this rate
    ULONG RateIn100ns;         // This rate in multiples of 100ns
    ULONG RateAdjustmentNs;    // Error Correction (in ns)
    ULONG RateAdjustmentCnt;   // Error Correction (as a fraction of 256)
    ULONG IpiRate;             // IPI Rate Count (as a fraction of 256)
};

//
// The adjustment is expressed in terms of a fraction of 256 so that
// the ISR can easily determine when a 100ns slice needs to be subtracted
// from the count passed to the kernel without any expensive operations
//
// Using 256 as a base means that anytime the count becomes greater
// than 256 the time slice must be incremented, the overflow can then
// be cleared by AND'ing the value with 0xff
//

#define AVAILABLE_INCREMENTS  5

struct  RtcTimeIncStruc HalpRtcTimeIncrements[AVAILABLE_INCREMENTS] = {
    {0x026,      9766,   38,    96, /* 3/8 of 256 */   16},
    {0x027,     19532,   75,   192, /* 3/4 of 256 */   32},
    {0x028,     39063,   50,   128, /* 1/2 of 256 */   64},
    {0x029,     78125,    0,     0,                   128},
    {0x02a,    156250,    0,     0,                   256}
};


ULONG HalpInitialClockRateIndex = AVAILABLE_INCREMENTS-1;

extern ULONG HalpCurrentRTCRegisterA;
extern ULONG HalpCurrentClockRateIn100ns;
extern ULONG HalpCurrentClockRateAdjustment;
extern ULONG HalpCurrentIpiRate;
extern ULONG HalpNextMSRate;
extern ULONG HalpClockWork;
extern BOOLEAN HalpClockSetMSRate;


VOID
HalpSetInitialClockRate (
    VOID
    );

VOID
HalpInitializeTimerResolution (
    ULONG Rate
    );



#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGELK, HalpSetInitialClockRate)
#pragma alloc_text(INIT, HalpInitializeTimerResolution)
#endif


VOID
HalpInitializeTimerResolution (
    ULONG Rate
    )
/*++

Routine Description:

    This function is called to initialize the timer resolution to be
    something other then the default.   The rate is set to the closest
    supported setting below the requested rate.

Arguments:

    Rate - in 100ns units

Return Value:

    None

--*/

{
    ULONG   i, s;

    //
    // Find the table index of the rate to use
    //

    for (i=1; i < AVAILABLE_INCREMENTS; i++) {
        if (HalpRtcTimeIncrements[i].RateIn100ns > Rate) {
            break;
        }
    }

    HalpInitialClockRateIndex = i - 1;

    //
    // Scale IpiRate according to max TimeIncr rate which can be used
    //

    s = AVAILABLE_INCREMENTS - HalpInitialClockRateIndex - 1;
    for (i=0; i < AVAILABLE_INCREMENTS; i++) {
        HalpRtcTimeIncrements[i].IpiRate <<= s;
    }
}


VOID
HalpSetInitialClockRate (
    VOID
    )

/*++

Routine Description:

    This function is called to set the initial clock interrupt rate

Arguments:

    None

Return Value:

    None

--*/

{
    extern ULONG HalpNextMSRate;

    //
    // On ACPI timer machines, we need to init an index into the
    // milisecond(s) array used by pmtimerc.c's Piix4 workaround
    //
#ifdef ACPI_HAL
#ifdef NT_UP
    extern ULONG HalpCurrentMSRateTableIndex;

    HalpCurrentMSRateTableIndex = (1 << HalpInitialClockRateIndex) - 1;

    //
    // The Piix4 upper bound table ends at 15ms (index 14), so we'll have
    // to map our 15.6ms entry to it as a special case
    //
    if (HalpCurrentMSRateTableIndex == 0xF) {
        HalpCurrentMSRateTableIndex--;
    }
#endif
#endif

    HalpNextMSRate = HalpInitialClockRateIndex;

    HalpCurrentClockRateIn100ns =
        HalpRtcTimeIncrements[HalpNextMSRate].RateIn100ns;
    HalpCurrentClockRateAdjustment =
        HalpRtcTimeIncrements[HalpNextMSRate].RateAdjustmentCnt;
    HalpCurrentRTCRegisterA =
        HalpRtcTimeIncrements[HalpNextMSRate].RTCRegisterA;
    HalpCurrentIpiRate =
        HalpRtcTimeIncrements[HalpNextMSRate].IpiRate;
    HalpClockWork = 0;

    KeSetTimeIncrement (
        HalpRtcTimeIncrements[HalpNextMSRate].RateIn100ns,
        HalpRtcTimeIncrements[0].RateIn100ns
        );

}


#ifdef MMTIMER
ULONG
HalpAcpiTimerSetTimeIncrement(
    IN ULONG DesiredIncrement
    )
#else
ULONG
HalSetTimeIncrement (
    IN ULONG DesiredIncrement
    )
#endif
/*++

Routine Description:

    This function is called to set the clock interrupt rate to the frequency
    required by the specified time increment value.

Arguments:

    DesiredIncrement - Supplies desired number of 100ns units between clock
        interrupts.

Return Value:

    The actual time increment in 100ns units.

--*/

{
    ULONG   i;
    KIRQL   OldIrql;

    //
    // Set the new clock interrupt parameters, return the new time increment value.
    //


    for (i=1; i < HalpInitialClockRateIndex; i++) {
        if (HalpRtcTimeIncrements[i].RateIn100ns > DesiredIncrement) {
            i = i - 1;
            break;
        }
    }

    OldIrql = KfRaiseIrql(HIGH_LEVEL);

    HalpNextMSRate = i + 1;
    HalpClockSetMSRate = TRUE;

    KfLowerIrql (OldIrql);

    return (HalpRtcTimeIncrements[i].RateIn100ns);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\mpclksup.asm ===
title  "Query Performace Counter"
;++
;
; Copyright (c) 1989  Microsoft Corporation
;
; Module Name:
;
;    mpclksup.asm
;
; Abstract:
;
;    This module implements the code necessary to do 
;    QueryPerformaceCounter the MPS way.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 12-Jan-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;   bryanwi 20-Sep-90
;   jakeo 12-16-97  -- moved code from mpprofil.asm
;
;--

.586p
        .xlist
include hal386.inc
include callconv.inc                    ; calling convention macros
include i386\kimacro.inc
include mac386.inc
include apic.inc
include ntapic.inc
include i386\mp8254.inc

        .list

        EXTRNP  _HalpAcquireSystemHardwareSpinLock,0
        EXTRNP  _HalpReleaseSystemHardwareSpinLock,0
        extrn   _HalpUse8254:BYTE

_DATA   SEGMENT  DWORD PUBLIC 'DATA'

    ALIGN dword
;
; counters for the performance counter
;
        public _HalpPerfCounterLow, _HalpPerfCounterHigh
        public _HalpLastPerfCounterLow, _HalpLastPerfCounterHigh
_HalpPerfCounterLow             dd      0
_HalpPerfCounterHigh            dd      0
_HalpLastPerfCounterLow         dd      0
_HalpLastPerfCounterHigh        dd      0

_DATA   ends


_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Query Performance Counter"
;++
;
; LARGE_INTEGER
; KeQueryPerformanceCounter (
;    OUT PLARGE_INTEGER PerformanceFrequency OPTIONAL
;    )
;
; Routine Description:
;
;    This routine returns current 64-bit performance counter and,
;    optionally, the Performance Frequency.
;
;    Note this routine can NOT be called at Profiling interrupt
;    service routine.  Because this routine depends on IRR0 to determine
;    the actual count.
;
;    Also note that the performace counter returned by this routine
;    is not necessary the value when this routine is just entered.
;    The value returned is actually the counter value at any point
;    between the routine is entered and is exited.
;
; Arguments:
;
;    PerformanceFrequency [TOS+4] - optionally, supplies the address
;        of a variable to receive the performance counter frequency.
;
; Return Value:
;
;    Current value of the performance counter will be returned.
;
;--

;
; Parameter definitions
;

KqpcFrequency   EQU     [esp+4]         ; User supplied Performance Frequence

ifdef MMTIMER
cPublicProc _HalpAcpiTimerQueryPerfCount      ,1
else
cPublicProc _KeQueryPerformanceCounter      ,1
endif

        mov     al, _HalpUse8254
        or      al, al
        jnz     short KqpcUse8254

KqpcUseTSC:

        ; use time stamp counter as performance counter

        mov     ecx, KqpcFrequency
        or      ecx, ecx
        jz      short kpc10

        mov     eax, PCR[PcHal.TSCHz]
        mov     dword ptr [ecx], eax
        mov     dword ptr [ecx+4], 0

kpc10:
        rdtsc
        add     eax, PCR[PcHal.PerfCounterLow]
        adc     edx, PCR[PcHal.PerfCounterHigh]
ifdef MMTIMER
        stdRET _HalpAcpiTimerQueryPerfCount
else
        stdRET    _KeQueryPerformanceCounter
endif
	
KqpcUse8254:
        ; use 8254 as time base for performance counters
        mov     ecx, KqpcFrequency
        or      ecx, ecx
        jz      short Kqpc10

        mov     dword ptr [ecx], PERFORMANCE_FREQUENCY
        mov     dword ptr [ecx+4], 0
        xor     ecx, ecx

Kqpc10:
        test    al, PERF_8254_INITIALIZED
        jz      KqpcNoInit

        stdCall   _HalpAcquireSystemHardwareSpinLock      ; intr disabled

        ; Read current offset from 8254 counter 0

        ; Counter Latch PIT Ctr 0 command

        mov     al, COMMAND_8254_LATCH_READ+COMMAND_8254_COUNTER0
        out     TIMER1_CONTROL_PORT0, al
        IODelay
        in      al, TIMER1_DATA_PORT0   ; Read 8254 Ctr 0, LSByte.
        IODelay
        movzx   edx,al                  ; Zero upper bytes of (EDX).
        in      al, TIMER1_DATA_PORT0   ; Read 8254 Ctr 0, MSByte.
        mov     dh, al                  ; (DX) = 8254 Ctr 0 count.
        neg     edx                     ; PIT counts down, calculate interval
        add     edx, PERFORMANCE_INTERVAL

        ; (edx) = offset value from most recent base value in 
        ; _HalpPerfCounterHigh:_HalpPerfCounterLow

        mov     eax, _HalpPerfCounterLow
        add     eax, edx
        mov     edx, _HalpPerfCounterHigh
        adc     edx, ecx

        ; (edx:eax) = 64 bit counter value
        ;
        ; Check to see if the new value is sane - should be greater than 
        ; the last counter value returned by KeQueryPerformanceCounter. 
        ; Can happen only due to wrap around of the 8254. Correct by 
        ; updating the performance counter base.

        cmp     edx, _HalpLastPerfCounterHigh
        jg      short KqpcContinue      ; Current value > last returned value
        jl      short KqpcCatchupPerfCounter  ; Current value < last returned value
        
        ; high dwords equal, compare low dword

        cmp     eax, _HalpLastPerfCounterLow 
        jg      short KqpcContinue      ; Current value > last returned value

KqpcCatchupPerfCounter:
        ; Current counter value is not greater than the previously returned 
        ; counter value - can happen only due to the 8254 timer wraparound. 
        ; Update base to account for wrap around.

        add     eax, PERFORMANCE_INTERVAL
        adc     edx, ecx

        add     _HalpPerfCounterLow, PERFORMANCE_INTERVAL
        adc     _HalpPerfCounterHigh, ecx

KqpcContinue:
        mov     _HalpLastPerfCounterLow, eax 
        mov     _HalpLastPerfCounterHigh, edx 

        stdCall   _HalpReleaseSystemHardwareSpinLock
ifdef MMTIMER
        stdRET _HalpAcpiTimerQueryPerfCount
else
        stdRET _KeQueryPerformanceCounter
endif

KqpcNoInit:

        ; 8254 is not yet initialized. Just return 0 for now

        xor     eax, eax
        xor     edx, edx
ifdef MMTIMER
        stdRET _HalpAcpiTimerQueryPerfCount

stdENDP _HalpAcpiTimerQueryPerfCount
else
        stdRET _KeQueryPerformanceCounter

stdENDP _KeQueryPerformanceCounter
endif
	
        page ,132
        subttl  "Stall Execution"
;++
;
; VOID
; KeStallExecutionProcessor (
;    IN ULONG MicroSeconds
;    )
;
; Routine Description:
;
;    This function stalls execution for the specified number of microseconds.
;    KeStallExecutionProcessor
;
; Arguments:
;
;    MicroSeconds - Supplies the number of microseconds that execution is to be
;        stalled.
;
; Return Value:
;
;    None.
;
;--

MicroSeconds equ [esp + 12]

ifdef MMTIMER
cPublicProc _HalpAcpiTimerStallExecProc       ,1
else	
cPublicProc _KeStallExecutionProcessor       ,1
endif
cPublicFpo 1,2

        push    ebx
        push    edi

;
; Issue a CPUID to implement a "fence"
;
        xor     eax, eax
fence1: cpuid


;
; Get current TSC
;

        rdtsc

        mov     ebx, eax
        mov     edi, edx

;
; Determine ending TSC
;

        mov     ecx, MicroSeconds               ; (ecx) = Microseconds
        mov     eax, PCR[PcStallScaleFactor]    ; get per microsecond
        mul     ecx

        add     ebx, eax
        adc     edi, edx

;
; Wait for ending TSC
;

kese10: rdtsc
        cmp     edi, edx
        ja      short kese10
        jc      short kese20
        cmp     ebx, eax
        ja      short kese10

kese20: pop     edi
        pop     ebx
ifdef MMTIMER
        stdRET    _HalpAcpiTimerStallExecProc

stdENDP _HalpAcpiTimerStallExecProc
else
        stdRET    _KeStallExecutionProcessor

stdENDP _KeStallExecutionProcessor
endif

_TEXT   ends

INIT    SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

cPublicProc _HalpRemoveFences
        mov     word ptr fence1, 0c98bh
        stdRET    _HalpRemoveFences
stdENDP _HalpRemoveFences


INIT    ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\mpdebug.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1992  Intel Corporation
All rights reserved

INTEL CORPORATION PROPRIETARY INFORMATION

This software is supplied to Microsoft under the terms
of a license agreement with Intel Corporation and may not be
copied nor disclosed except in accordance with the terms
of that agreement.

Module Name:

    mpdebug.c

Abstract:

    This module has some useful modules for debug aid.

Author:

    Ron Mosgrove (Intel) - Aug 1993.

Environment:

    Kernel mode or from textmode setup.

Revision History:

--*/

#ifndef _NTOS_
#include "halp.h"
#endif

#include "apic.inc"
#include "pcmp_nt.inc"
#include "stdio.h"

#define PCMP_TABLE_PTR_BASE           0x09f000
#define PCMP_TABLE_PTR_OFFSET         0x00000c00

// Create dummy PC+MP table at physical address 400K
#define  PCMP_TEST_TABLE        0x64000
#define TEST_FLOAT_PTR          0x7d000

extern struct PcMpTable *PcMpTablePtr, *PcMpDefaultTablePtrs[];
//extern struct HalpMpInfo *HalpMpInfoPtr;

CHAR Cbuf[120];

UCHAR
ComputeCheckSum(
    IN PUCHAR SourcePtr,
    IN USHORT NumOfBytes
    );

#ifdef OLD_DEBUG
extern struct PcMpConfigTable *PcMpTablePtr;
#endif

#ifdef DEBUGGING

ULONG HalpUseDbgPrint = 0;

void
HalpDisplayString(
    IN PVOID String
    )
{
    if (!HalpUseDbgPrint) {
        HalDisplayString(String);
    } else {
        DbgPrint(String);
    }
}


void
HalpDisplayItemBuf(
    IN UCHAR Length,
    IN PUCHAR Buffer,
    IN PVOID Name
    )
{
    ULONG i;
    CHAR TmpBuf[80];
    
    sprintf(TmpBuf, "    %s -", Name);
    HalpDisplayString(TmpBuf);
    for (i=0; i< Length; i++) {
        sprintf(TmpBuf, " 0x%x", Buffer[i]);
        HalpDisplayString(TmpBuf);
    }
    HalpDisplayString("\n");
}    

void
HalpDisplayULItemBuf(
    IN UCHAR Length,
    IN PULONG Buffer,
    IN PVOID Name
    )
{
    ULONG i;
    CHAR TmpBuf[80];
    
    sprintf(TmpBuf, "    %s -", Name);
    HalpDisplayString(TmpBuf);
    for (i=0; i< Length; i++) {
        sprintf(TmpBuf, " 0x%lx", Buffer[i]);
        HalpDisplayString(TmpBuf);
    }
    HalpDisplayString("\n");
}    

void
HalpDisplayItem(
    IN ULONG Item,
    IN PVOID ItemStr
    )
{
    CHAR TmpBuf[80];

    sprintf(TmpBuf, "    %s - 0x%x\n", ItemStr, Item);
    HalpDisplayString(TmpBuf);
}

VOID
HalpDisplayBIOSSysCfg(
    IN struct SystemConfigTable *SysCfgPtr
    )
{
    HalpDisplayString("BIOS System Configuration Table\n");
    HalpDisplayItem(SysCfgPtr->ModelType, "ModelType");
    HalpDisplayItem(SysCfgPtr->SubModelType, "SubModelType");
    HalpDisplayItem(SysCfgPtr->BIOSRevision, "BIOSRevision");
    HalpDisplayItemBuf(3,SysCfgPtr->FeatureInfoByte,"FeatureInfoByte");
    HalpDisplayItem(SysCfgPtr->MpFeatureInfoByte1, "MpFeatureInfoByte1");
    HalpDisplayItem(SysCfgPtr->MpFeatureInfoByte2, "MpFeatureInfoByte2");
}

VOID
HalpDisplayLocalUnit(
    )
{
    ULONG Data;
    PKPCR   pPCR;

    pPCR = KeGetPcr();

    sprintf(Cbuf, "\nLocal Apic for P%d\n", pPCR->Prcb->Number);
    HalpDisplayString(Cbuf);

#define DisplayLuReg(Reg, RegStr)   Data = *((PVULONG) (LOCALAPIC+Reg)); \
                                    HalpDisplayItem(Data , RegStr);


    DisplayLuReg( LU_ID_REGISTER  , "LU_ID_REGISTER"  );
    DisplayLuReg( LU_VERS_REGISTER, "LU_VERS_REGISTER" );
    DisplayLuReg( LU_TPR, "LU_TPR");
    DisplayLuReg( LU_APR, "LU_APR");
    DisplayLuReg( LU_PPR, "LU_PPR");
    DisplayLuReg( LU_EOI, "LU_EOI");
    DisplayLuReg( LU_REMOTE_REGISTER, "LU_REMOTE_REGISTER");
    DisplayLuReg( LU_LOGICAL_DEST, "LU_LOGICAL_DEST");

    DisplayLuReg( LU_DEST_FORMAT, "LU_DEST_FORMAT");

    DisplayLuReg( LU_SPURIOUS_VECTOR , "LU_SPURIOUS_VECTOR" );

    DisplayLuReg( LU_ISR_0, "LU_ISR_0");
    DisplayLuReg( LU_TMR_0, "LU_TMR_0");
    DisplayLuReg( LU_IRR_0, "LU_IRR_0");
    DisplayLuReg( LU_ERROR_STATUS, "LU_ERROR_STATUS");
    DisplayLuReg( LU_INT_CMD_LOW, "LU_INT_CMD_LOW");
    DisplayLuReg( LU_INT_CMD_HIGH, "LU_INT_CMD_HIGH");
    DisplayLuReg( LU_TIMER_VECTOR, "LU_TIMER_VECTOR");
    DisplayLuReg( LU_INT_VECTOR_0, "LU_INT_VECTOR_0");
    DisplayLuReg( LU_INT_VECTOR_1, "LU_INT_VECTOR_1");
    DisplayLuReg( LU_INITIAL_COUNT, "LU_INITIAL_COUNT");
    DisplayLuReg( LU_CURRENT_COUNT, "LU_CURRENT_COUNT");

    DisplayLuReg( LU_DIVIDER_CONFIG, "LU_DIVIDER_CONFIG");
    HalpDisplayString("\n");
    
}

VOID
HalpDisplayIoUnit(
    )
/*++

Routine Description:

    Verify that an IO Unit exists at the specified address

 Arguments:

    BaseAddress - Address of the IO Unit to test.

 Return Value:
    BOOLEAN - TRUE if a IO Unit was found at the passed address
            - FALSE otherwise

--*/

{
#if 0
    struct ApicIoUnit *IoUnitPtr;
    ULONG Data,i,j;
    PKPCR   pPCR;

    pPCR = KeGetPcr();

    //
    //  The documented detection mechanism is to write all zeros to
    //  the Version register.  Then read it back.  The IO Unit exists if the
    //  same result is read both times and the Version is valid.
    //



    for (j=0; j<HalpMpInfoPtr->IOApicCount; j++) { 
        IoUnitPtr = (struct ApicIoUnit *) HalpMpInfoPtr->IoApicBase[j];

        sprintf(Cbuf,"\nIoApic %d at Vaddr 0x%x\n",j,(ULONG) IoUnitPtr);
        HalpDisplayString(Cbuf);

        IoUnitPtr->RegisterSelect = IO_ID_REGISTER;
        HalpDisplayItem(IoUnitPtr->RegisterWindow, "IO_ID_REGISTER");


        IoUnitPtr->RegisterSelect = IO_VERS_REGISTER;
        HalpDisplayItem(IoUnitPtr->RegisterWindow, "IO_VERS_REGISTER");

        for (i=0; i<16; i++) {

            IoUnitPtr->RegisterSelect = IO_REDIR_00_LOW+(i*2);
            Data = IoUnitPtr->RegisterWindow;
            sprintf(Cbuf, "    Redir [0x%x] - 0x%x, ", i, Data);
            HalpDisplayString(Cbuf);

            IoUnitPtr->RegisterSelect = IO_REDIR_00_LOW+(i*2)+1;
            Data = IoUnitPtr->RegisterWindow;
            sprintf(Cbuf, "0x%x\n", Data);
            HalpDisplayString(Cbuf);

        }  // for each Redirection entry
    } // for all Io Apics

#endif
}

void
HalpDisplayConfigTable ()
/*+++
    Debug routine  to display the PC+MP config table
--*/
{
    struct PcMpTable *MpPtr = PcMpTablePtr;
    PPCMPPROCESSOR ProcPtr;
    ULONG EntriesInTable = MpPtr->NumOfEntries;
    union PL {
        USHORT us;
        POLARITYANDLEVEL PnL;
        };

    HalpDisplayString("PcMp Configuration Table\n");

    HalpDisplayItem(MpPtr->Signature, "Signature");
    HalpDisplayItem(MpPtr->TableLength, "TableLength");
    HalpDisplayItem(MpPtr->Revision, "Revision");
    HalpDisplayItem(MpPtr->Checksum, "Checksum");

    HalpDisplayItemBuf(sizeof(MpPtr->OemId),
            MpPtr->OemId,"OemId");
    HalpDisplayItemBuf(sizeof(MpPtr->OemProductId),
            MpPtr->OemProductId,"OemProductId");
    
    HalpDisplayItem((ULONG) MpPtr->OemTablePtr, "OemTablePtr");
    HalpDisplayItem(MpPtr->OemTableSize, "OemTableSize");
    HalpDisplayItem(MpPtr->NumOfEntries, "NumOfEntries");
    HalpDisplayItem((ULONG) MpPtr->LocalApicAddress, "LocalApicAddress");
    HalpDisplayItem(MpPtr->Reserved, "Reserved");

    ProcPtr = (PPCMPPROCESSOR) ((PUCHAR) MpPtr + HEADER_SIZE);


    while (EntriesInTable) {
        EntriesInTable--;
        switch ( ProcPtr->EntryType ) {
            case ENTRY_PROCESSOR: {
                union xxx {
                    ULONG ul;
                    CPUIDENTIFIER CpuId;
                } u;
                
                sprintf (Cbuf, "Proc..: ApicId %x, Apic ver %x, Flags %x\n",
                    ProcPtr->LocalApicId,
                    ProcPtr->LocalApicVersion,
                    ProcPtr->CpuFlags
                    );
                HalpDisplayString (Cbuf);
                ProcPtr++;
                break;
            }

            case ENTRY_BUS: {
                PPCMPBUS BusPtr = (PPCMPBUS) ProcPtr;

                sprintf (Cbuf, "Bus...: id %02x, type '%.6s'\n",
                            BusPtr->BusId, BusPtr->BusType);

                HalpDisplayString (Cbuf);
                BusPtr++;
                ProcPtr = (PPCMPPROCESSOR) BusPtr;
                break;
            }

            case ENTRY_IOAPIC: {
                PPCMPIOAPIC IoApPtr = (PPCMPIOAPIC) ProcPtr;

                sprintf (Cbuf, "IoApic: id %02x, ver %x, Flags %x, Address %x\n",
                    IoApPtr->IoApicId,
                    IoApPtr->IoApicVersion,
                    IoApPtr->IoApicFlag,
                    (ULONG) IoApPtr->IoApicAddress
                    );
                HalpDisplayString (Cbuf);

                IoApPtr++;
                ProcPtr = (PPCMPPROCESSOR) IoApPtr;
                break;
            }

            case ENTRY_INTI: {
                PPCMPINTI IntiPtr = (PPCMPINTI) ProcPtr;
                union PL u;

                u.PnL = IntiPtr->Signal;

                sprintf (Cbuf, "Inti..: t%x, s%x, SInt %x-%x, Inti %x-%x\n",
                    IntiPtr->IntType,
                    u.us,
                    IntiPtr->SourceBusId,
                    IntiPtr->SourceBusIrq,
                    IntiPtr->IoApicId,
                    IntiPtr->IoApicInti
                );
                HalpDisplayString (Cbuf);

                IntiPtr++;
                ProcPtr = (PPCMPPROCESSOR) IntiPtr;
                break;
            }

            case ENTRY_LINTI: {
                PPCMPLINTI LIntiPtr = (PPCMPLINTI) ProcPtr;
                union PL u;

                u.PnL = LIntiPtr->Signal;

                sprintf (Cbuf, "Linti.: t%x, s%x, SInt %x-%x, Linti %x-%x\n",
                    LIntiPtr->IntType,
                    u.us,
                    LIntiPtr->SourceBusId,
                    LIntiPtr->SourceBusIrq,
                    LIntiPtr->DestLocalApicId,
                    LIntiPtr->DestLocalApicInti
                );
                HalpDisplayString (Cbuf);

                LIntiPtr++;
                ProcPtr = (PPCMPPROCESSOR) LIntiPtr;
                break;
            }
        
            default: {
                HalpDisplayItem(ProcPtr->EntryType, "Unknown Type");
                return;
            }
        }
    }
}

void
HalpDisplayExtConfigTable ()
{
    PMPS_EXTENTRY  ExtTable;
    extern struct HalpMpInfo HalpMpInfoTable;


    ExtTable = HalpMpInfoTable.ExtensionTable;
    while (ExtTable < HalpMpInfoTable.EndOfExtensionTable) {
        switch (ExtTable->Type) {

            case EXTTYPE_BUS_ADDRESS_MAP:
                sprintf (Cbuf, "BusMap: id %02x, t%x  Base %08x  Len %08x\n",
                    ExtTable->u.AddressMap.BusId,
                    ExtTable->u.AddressMap.Type,
                    (ULONG) ExtTable->u.AddressMap.Base,
                    (ULONG) ExtTable->u.AddressMap.Length
                );
                HalpDisplayString (Cbuf);
                break;

            case EXTTYPE_BUS_HIERARCHY:
                sprintf (Cbuf, "BusHie: id %02x, Parent:%x  sd:%x\n",
                    ExtTable->u.BusHierarchy.BusId,
                    ExtTable->u.BusHierarchy.ParentBusId,
                    ExtTable->u.BusHierarchy.SubtractiveDecode
                );
                HalpDisplayString (Cbuf);
                break;

            case EXTTYPE_BUS_COMPATIBLE_MAP:
                sprintf (Cbuf, "ComBus: id %02x %c List %x\n",
                    ExtTable->u.CompatibleMap.BusId,
                    ExtTable->u.CompatibleMap.Modifier ? '-' : '+',
                    ExtTable->u.CompatibleMap.List
                    );
                HalpDisplayString (Cbuf);
                break;

            case EXTTYPE_PERSISTENT_STORE:
                sprintf (Cbuf, "PreSTR: Address %08x Len %08x\n",
                    (ULONG) ExtTable->u.PersistentStore.Address,
                    (ULONG) ExtTable->u.PersistentStore.Length
                );
                HalpDisplayString (Cbuf);
                break;

            default:
                HalpDisplayItem(ExtTable->Type, "Unknown Type");
                break;
        }


        ExtTable = (PMPS_EXTENTRY) (((PUCHAR) ExtTable) + ExtTable->Length);
    }
    
}


void
HalpDisplayMpInfo()
{
#if 0
    struct HalpMpInfo *MpPtr = HalpMpInfoPtr;

    HalpDisplayString("\nHAL: Private Mp Info\n");

    HalpDisplayItem(MpPtr->ApicVersion, "ApicVersion");
    HalpDisplayItem(MpPtr->ProcessorCount, "ProcessorCount");
    HalpDisplayItem(MpPtr->BusCount, "BusCount");
    HalpDisplayItem(MpPtr->IOApicCount, "IOApicCount");
    HalpDisplayItem(MpPtr->IntiCount, "IntiCount");
    HalpDisplayItem(MpPtr->LintiCount, "LintiCount");
    HalpDisplayItem(MpPtr->IMCRPresent, "IMCRPresent");

    HalpDisplayULItemBuf(4,(PULONG) MpPtr->IoApicBase,"IoApicBase");
    HalpDisplayString("\n");
    HalpDisplayConfigTable();

#endif
}


#ifdef OLD_DEBUG

BOOLEAN
HalpVerifyLocalUnit(
    IN UCHAR ApicID
    )
/*++

Routine Description:

    Verify that a Local Apic has the specified Apic Id.

 Arguments:

    ApicId - Id to verify.

 Return Value:
    BOOLEAN - TRUE if found
            - FALSE otherwise

--*/

{
    union ApicUnion Temp;

    //
    //  The remote read command must be:
    //
    //      Vector - Bits 4-9 of the Version register
    //      Destination Mode - Physical
    //      Trigger Mode - Edge
    //      Delivery Mode - Remote Read
    //      Destination Shorthand - Destination Field
    //

#define LU_READ_REMOTE_VERSION   ( (LU_VERS_REGISTER >> 4) | \
                                    DELIVER_REMOTE_READ | \
                                    ICR_USE_DEST_FIELD)

#define DEFAULT_DELAY   100

    PVULONG LuDestAddress = (PVULONG) (LOCALAPIC + LU_INT_CMD_HIGH);
    PVULONG LuICR = (PVULONG) (LOCALAPIC + LU_INT_CMD_LOW);
    PVULONG LuRemoteReg = (PVULONG) (LOCALAPIC + LU_REMOTE_REGISTER);
    ULONG RemoteReadStatus;
    ULONG DelayCount = DEFAULT_DELAY;

    //
    //  First make sure we can get to the Apic Bus
    //

    while ( ( DelayCount-- ) && ( *LuICR & DELIVERY_PENDING ) );

    if (DelayCount == 0) {
        //
        //  We're toast, can't gain access to the APIC Bus
        //
        return (FALSE);
    }

    //
    //  Set the Address of the APIC we're looking for
    //

    *LuDestAddress = (ApicID << DESTINATION_SHIFT);

    //
    //  Issue the request
    //

    *LuICR = LU_READ_REMOTE_VERSION;

    //
    //  Reset the Delay so we can get out of here just in case...
    //

    DelayCount = DEFAULT_DELAY;

    while (DelayCount--) {

        RemoteReadStatus = *LuICR & ICR_RR_STATUS_MASK;

        if ( RemoteReadStatus == ICR_RR_INVALID) {
            //
            //  No One responded, device timed out
            //
            return (FALSE);
        }

        if ( RemoteReadStatus == ICR_RR_VALID) {
            //
            //  Someone is there and the Remote Register is valid
            //
            Temp.Raw = *LuRemoteReg;

            //
            // Do what we can to verify the Version
            //

            if (Temp.Ver.Version > 0x1f) {
                //
                //  Only known devices are 0.x and 1.x
                //
                return (FALSE);
            }

            return (TRUE);

        }   // RemoteRead Successfull

    }   // While DelayCount

    //
    //  No One responded, and the device did not time out
    //  This should never happen
    //

    return (FALSE);
}

#endif  // OLD_DEBUG

VOID
CreateBIOSTables(
    VOID)
/*++

Routine Description:
    This routine is used  to test the PC+MP detect code in the HAL.
    It creates the PC+MP structures that are really created by the
    BIOS. Since we presently do not have a BIOS that builds a PC+MP
    table, we need this for now.

Arguments:
    None.

 Return Value:
    None.

--*/

{
    PUCHAR TempPtr, BytePtr;
    UCHAR CheckSum;
    PULONG TraversePtr;
    USHORT BytesToCopy;

    HalpDisplayString("CreateBIOSTables : Entered\n");
    // First, copy default PC+MP configuration 2 table at physical
    // address PCMP_TEST_TABLE
    TempPtr = (PUCHAR) HalpMapPhysicalMemory(
                (PVOID) PCMP_TEST_TABLE, 1);

    BytesToCopy = (PcMpDefaultTablePtrs[1])->TableLength;
    RtlMoveMemory(TempPtr, (PUCHAR)PcMpDefaultTablePtrs[1],
        BytesToCopy);

    // Populate the checksum entry for the table.
    CheckSum = ComputeCheckSum(TempPtr, BytesToCopy);

    sprintf(Cbuf, "CreateBIOSTables: PC+MP table computed checksum = %x\n",
        CheckSum);
    HalpDisplayString(Cbuf);

    CheckSum = ~CheckSum + 1;
    ((struct PcMpTable *)TempPtr)->Checksum = CheckSum;

    sprintf(Cbuf, "CreateBIOSTables: PC+MP table written checksum = %x\n",
        CheckSum);
    HalpDisplayString(Cbuf);


    // Now create the floating pointer structure for the table.

    TraversePtr = (PULONG) HalpMapPhysicalMemory( (PVOID) TEST_FLOAT_PTR, 1);
    TempPtr = (PUCHAR) TraversePtr;

    *TraversePtr++ = MP_PTR_SIGNATURE;
    *TraversePtr++ = PCMP_TEST_TABLE;
    BytePtr = (PUCHAR)TraversePtr;
    *BytePtr++ = 1;  // Length in number of  16 byte paragraphs
    *BytePtr++ = 1;  // Spec Rev.
    *BytePtr++ = 0;  // CheckSum
    *BytePtr++ = 0;  // Reserved
    TraversePtr = (PULONG)BytePtr;
    *TraversePtr = 0; // Reserved

    CheckSum = ComputeCheckSum(TempPtr,16);

    sprintf(Cbuf, "CreateBIOSTables: FLOAT_PTR computed checksum = %x\n",
        CheckSum);
    HalpDisplayString(Cbuf);

    CheckSum = ~CheckSum + 1;

    sprintf(Cbuf, "CreateBIOSTables: FLOAT_PTR written checksum = %x\n",
        CheckSum);
    HalpDisplayString(Cbuf);

    ((struct PcMpTableLocator *)TempPtr)->TableChecksum = CheckSum;

    HalpDisplayString("CreateBIOSTables : Done\n");

}

#endif  // DEBUGGING
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\mpconfig.asm ===
title "PC+MP configuration table processing"

;++
;
;Copyright (c) 1991  Microsoft Corporation
;Copyright (c) 1992  Intel Corporation
;All rights reserved
;
;INTEL CORPORATION PROPRIETARY INFORMATION
;
;This software is supplied to Microsoft under the terms
;of a license agreement with Intel Corporation and may not be
;copied nor disclosed except in accordance with the terms
;of that agreement.
;
;
;Module Name:
;
;    mpconfig.asm
;
;Abstract:
;
;    Build the default PC+MP configuration tables defined in the PC+MP
;    specification. This file contains no code. It statically builds the
;    default PC+MP configurations in data. C code declaring structures to
;    use these tables must use the "pack(1)" pragma to ensure they are byte
;    aligned.
;
;
;Author:
;
;    Rajesh Shah (Intel) Oct 1993
;
;Revision History:
;
;--
.386p

include pcmp.inc
include apic.inc

;
; Entry size in bytes for Bus entries, Io Apic entries, Io Apic interrupt
; input entries and Local Apic interrupt input entries in the PC+MP table.
;
COMMON_ENTRY_SIZE   equ     08H
;
; Default values for Processor entries in the PC+MP table.
;
DEFAULT_NUM_CPUS    equ     02H
PROC_ENTRY_SIZE     equ     14H
CPU_i486            equ     0421H
CPU_FEATURES        equ     01H     ; On-chip FPU

;
;  Default Apic Version values.
;
VERSION_82489DX     equ     01H    ; 8 bit APIC version register value.
VERSION_INTEGRATED  equ     11H    ; 8 bit APIC version register value.

;
; Default values for Bus entries in the PC+MP table
;
BUS_ID_0            equ     0H
BUS_INTI_POLARITY   equ     0H
BUS_INTI_LEVEL      equ     0H

; Macros to emit the 6 byte bus type string. The string is not
; NULL terminated. If the Bus string consists of less than 6
; characters, it is padded with space characters(ASCII 20h).

BUS_TYPE_EISA macro
    db      "EISA  "
endm

BUS_TYPE_ISA macro
    db      "ISA   "
endm

BUS_TYPE_PCI macro
    db      "PCI   "
endm

BUS_TYPE_MCA macro
    db      "MCA   "
endm

;
; Macros to build the different parts of the PC+MP table. See pcmp.inc
; for the layout of the table and its entries.

; Macro to build the HEADER part of the PC+MP table.
; It takes a parameter (NumOfEntries) that specifies the total number of
; data entries in the table. Processor entries are 20(decimal) bytes long,
; all other entry types are 8 bytes long. All default configurations have
; 2 processors. The table length is computed based on the NumOfEntries
; parameter.
;
Header macro NumEntries
    dd      PCMP_SIGNATURE      ;; ASCII "PCMP"
    dw      ( (DEFAULT_NUM_CPUS * PROC_ENTRY_SIZE) \
              + ((NumEntries - DEFAULT_NUM_CPUS) * COMMON_ENTRY_SIZE)\
              + HEADER_SIZE )           ;; Total table length
    db      1                           ;; PC+MP spec. revision
    db      0                           ;; Checksum
    db      8   dup (0)                 ;; OEM Id
    db      12  dup (0)                 ;; OEM Product Id
    dd      0                           ;; OEM table pointer
    dw      0                           ;; OEM table size
    dw      NumOfEntries                ;; Number of entries in DATA portion
    dd      LU_BASE_ADDRESS             ;; Default Loacal Apic address
    dd      0                           ;; Reserved (Not Used)
endm ;;Header

;
; Macro to build Processor entries of the PC+MP table
;
; Parameter ApicVersion specifes the Apic version (82489DX or integrated)
; Parameter IsBsp is used in the CPU Flags field, and specifies if this
; processor is the BSP processor
;
Processor macro LocalApicId, ApicVersion, IsBspCpu
    db      ENTRY_PROCESSOR             ;; Processor entry type
    db      LocalApicId                 ;; ID of Loacal Apic unit.
    db      ApicVersion                 ;; Must agree with IO Apic Version
    db      CPU_ENABLED OR IsBspCpu     ;; CpuFlags
    dd      CPU_i486                    ;; Default CPU type
    dd      CPU_FEATURES                ;; Default CPU features
    db      8 dup (0)                   ;; Reserved
endm ;Processor

;
; Macro to build Bus entries of the PC+MP table
;
Bus  macro BusId, BusString
    db      ENTRY_BUS                   ;; Bus entry type
    db      BusId                       ;; ID of this bus
    BusString                           ;; This parameter is a macro that
                                        ;; emits the 6 byte bus type string.
endm ;Bus

;
; Macro to build Io Apic entries of the PC+MP table
; Parameter IoApicVersion specifes the Apic version (82489DX or integrated)
; All default configurations have a single IO Apic.
;
IoApic  macro IoApicVersion
    db      ENTRY_IOAPIC                ;; IO APIC entry type
    db      IOUNIT_APIC_ID              ;; Default Io Apic ID
    db      IoApicVersion               ;; Must agree with Local APIC ver.
    db      IO_APIC_ENABLED             ;; enable the IO APIC by default,
    dd      IO_BASE_ADDRESS             ;; Default physical address of 1st
                                        ;; IO APIC.
endm ;IoApic

;
; Macro to build Io Apic interrupt input entries of the PC+MP table
; Since all default configurations have a single IO Apic, all the IO Apic
; interrput input entries are built for the default IO Apic. For all default
; configurations, the interrupt source bus is assumed to have a bus ID 0.
;
IoApicInti macro IntType,SourceBusIrq,ApicInti
    db      ENTRY_INTI                  ;; IO Apic interrupt input entry type
    db      IntType                     ;; NMI,SMI,ExtINT or INTR
    dw      BUS_INTI_POLARITY OR BUS_INTI_LEVEL ;; Default polarity and level
    db      BUS_ID_0                    ;; Bus Id on which interrupt arrives
    db      SourceBusIrq                ;; Bus relative IRQ at which
                                        ;; interrupt arrives
    db      IOUNIT_APIC_ID              ;; Apic Id of destination IO Apic
    db      ApicInti                    ;; Io Apic Interrupt input pin
                                        ;; number this interrupt goes to
endm  ;IoApicInti

;
; Macro to build Io Apic interrupt input entries of the PC+MP table
; Since all default configurations have a single IO Apic, all the IO Apic
; interrput input entries are built for the default IO Apic. For all default
; configurations, the interrupt source bus is assumed to have a bus ID 0.
;
ApicInti macro IntType,SourceBusId,SourceBusIrq,AInti
    db      ENTRY_INTI                  ;; IO Apic interrupt input entry type
    db      IntType                     ;; NMI,SMI,ExtINT or INTR
    dw      BUS_INTI_POLARITY OR BUS_INTI_LEVEL ;; Default polarity and level
    db      SourceBusId                 ;; Bus Id on which interrupt arrives
    db      SourceBusIrq                ;; Bus relative IRQ at which
                                        ;; interrupt arrives
    db      IOUNIT_APIC_ID              ;; Apic Id of destination IO Apic
    db      AInti                       ;; Io Apic Interrupt input pin
                                        ;; number this interrupt goes to
endm  ;ApicInti

;
; Macro to build Local Apic interruptinput entries of the PC+MP table
;
Linti macro IntType,SourceBusId,SourceBusIrq,LocalApicId,ApicInti
    db      ENTRY_LINTI                 ;; Local Apic Interrupt Input
    db      IntType                     ;; NMI,SMI,ExtINT or INTR.
    dw      BUS_INTI_POLARITY OR BUS_INTI_LEVEL ;; Polarity and level
    db      SourceBusId                 ;; Bus Id on which interrupt arrives
    db      SourceBusIrq                ;; Bus relative IRQ at which
                                        ;; interrupt arrives
    db      LocalApicId                 ;; Apic Id of destination Local Apic
    db      ApicInti                    ;; Local Apic Interrupt input pin
                                        ;; number this interrupt goes to
endm  ;Linti


PAGELK   SEGMENT  DWORD PUBLIC 'CODE'

; The PC+MP table consists of a fixed size HEADER and a variable
; number of DATA entries. The order of the DATA entries is as
; follows:
;
;  1) Processor entries (20 decimal bytes long). The Boot Strap
;     Processor (BSP) entry must be the first entry.
;  2) Bus entries (8 bytes long).
;  3) IO Apic entries (8 bytes long).
;  4) IO Apic interrupt input entries (8 bytes long).
;  5) Local Apic interrupt input entries (8 bytes long).
;
; All interrupting devices are connected to Bus ID 0 in the
; default configurations.
;
; Any C code using these tables must use the pack(1) pragma.

;
; PC+MP default configuration 1: ISA bus, 82489DX Apic.
;
    public _PcMpDefaultConfig1
_PcMpDefaultConfig1 label byte

    ; Create table HEADER.
    Header 14h

    ; Create processor entries
    Processor 0, VERSION_82489DX, BSP_CPU
    Processor 1, VERSION_82489DX, 0

    ; Create bus entries
    Bus 0, BUS_TYPE_ISA

    ; Create IO Apic entries.
    IoApic VERSION_82489DX

    ; Create IO Apic interrupt input entries.
    IoApicInti INT_TYPE_INTR,1,1        ; IO APIC IRQ 1, INTIN 1
    IoApicInti INT_TYPE_INTR,0,2        ; IO APIC IRQ 0, INTIN 2
    IoApicInti INT_TYPE_INTR,3,3        ; IO APIC IRQ 3, INTIN 3
    IoApicInti INT_TYPE_INTR,4,4        ; IO APIC IRQ 4, INTIN 4
    IoApicInti INT_TYPE_INTR,5,5        ; IO APIC IRQ 5, INTIN 5
    IoApicInti INT_TYPE_INTR,6,6        ; IO APIC IRQ 6, INTIN 6
    IoApicInti INT_TYPE_INTR,7,7        ; IO APIC IRQ 7, INTIN 7
    IoApicInti INT_TYPE_INTR,8,8        ; IO APIC IRQ 8, INTIN 8
    IoApicInti INT_TYPE_INTR,9,9        ; IO APIC IRQ 9, INTIN 9
    IoApicInti INT_TYPE_INTR,0ah,0ah    ; IO APIC IRQ 10, INTIN 10
    IoApicInti INT_TYPE_INTR,0bh,0bh    ; IO APIC IRQ 11, INTIN 11
    IoApicInti INT_TYPE_INTR,0ch,0ch    ; IO APIC IRQ 12, INTIN 12
    IoApicInti INT_TYPE_INTR,0dH,0dH    ; IO APIC IRQ 13, INTIN 13
    IoApicInti INT_TYPE_INTR,0eH,0eH    ; IO APIC IRQ 14, INTIN 14
    IoApicInti INT_TYPE_INTR,0fH,0fH    ; IO APIC IRQ 15, INTIN 15

    ; Create Local Apic interrupt input entries.
    Linti INT_TYPE_NMI,0,2,0,1            ; IRQ 2,LocalApicId 0,Linti 1

;
; PC+MP default configuration 2: EISA bus, 82489DX Apic.
;
    public _PcMpDefaultConfig2
_PcMpDefaultConfig2 label byte

    ; Create table HEADER.
    Header 14h

    ; Create processor entries

    Processor 0H, VERSION_82489DX, BSP_CPU
    Processor 01H, VERSION_82489DX, 0

    ; Create bus entries
    Bus 0, BUS_TYPE_EISA

    ; Create IO Apic entries.
      IoApic VERSION_82489DX

    ; Create IO Apic interrupt input entries.
    ; In configuration 2, the 8259 PIC fields the timer and DMA interrupts.
    ; The PIC is connected to interrupt input pin 0 of the IO Apic, so this
    ; IO Apic interrupt pin can get 2 different interrupts.

    IoApicInti INT_TYPE_EXTINT,0,0      ; IO APIC IRQ 0, INTIN 0
    IoApicInti INT_TYPE_EXTINT,0dh,0    ; IO APIC IRQ 13, INTIN 0
    IoApicInti INT_TYPE_INTR,1,1        ; IO APIC IRQ 1, INTIN 1

    ; In this configuration, NMI comes through IO Apic interrupt
    ; input pin 2. In all other configurations, NMI comes through
    ; the Local Apic interrupt input LINTIN1

    IoApicInti INT_TYPE_NMI,2,2         ; IO APIC IRQ 2, INTIN 2

    IoApicInti INT_TYPE_INTR,3,3        ; IO APIC IRQ 3, INTIN 3
    IoApicInti INT_TYPE_INTR,4,4        ; IO APIC IRQ 4, INTIN 4
    IoApicInti INT_TYPE_INTR,5,5        ; IO APIC IRQ 5, INTIN 5
    IoApicInti INT_TYPE_INTR,6,6        ; IO APIC IRQ 6, INTIN 6
    IoApicInti INT_TYPE_INTR,7,7        ; IO APIC IRQ 7, INTIN 7
    IoApicInti INT_TYPE_INTR,8,8        ; IO APIC IRQ 8, INTIN 8
    IoApicInti INT_TYPE_INTR,9,9        ; IO APIC IRQ 9, INTIN 9
    IoApicInti INT_TYPE_INTR,0ah,0ah    ; IO APIC IRQ 10, INTIN 10
    IoApicInti INT_TYPE_INTR,0bh,0bh    ; IO APIC IRQ 11, INTIN 11
    IoApicInti INT_TYPE_INTR,0ch,0ch    ; IO APIC IRQ 12, INTIN 12
    IoApicInti INT_TYPE_INTR,0eH,0eH    ; IO APIC IRQ 14, INTIN 14
    IoApicInti INT_TYPE_INTR,0fH,0fH    ; IO APIC IRQ 15, INTIN 15

;
; PC+MP default configuration 3: EISA bus, 82489DX Apic, timer(Inti2)
;
    public _PcMpDefaultConfig3
_PcMpDefaultConfig3 label byte

    ; Create table HEADER.
    Header 14h

    ; Create processor entries
    Processor 0H, VERSION_82489DX, BSP_CPU
    Processor  01H, VERSION_82489DX, 0

    ; Create bus entries
    Bus 0, BUS_TYPE_EISA

    ; Create IO Apic entries.
    IoApic VERSION_82489DX

    ; Create IO Apic interrupt input entries.
    IoApicInti INT_TYPE_INTR,1,1        ; IO APIC IRQ 1, INTIN 1
    IoApicInti INT_TYPE_INTR,0,2        ; IO APIC IRQ 0, INTIN 2
    IoApicInti INT_TYPE_INTR,3,3        ; IO APIC IRQ 3, INTIN 3
    IoApicInti INT_TYPE_INTR,4,4        ; IO APIC IRQ 4, INTIN 4
    IoApicInti INT_TYPE_INTR,5,5        ; IO APIC IRQ 5, INTIN 5
    IoApicInti INT_TYPE_INTR,6,6        ; IO APIC IRQ 6, INTIN 6
    IoApicInti INT_TYPE_INTR,7,7        ; IO APIC IRQ 7, INTIN 7
    IoApicInti INT_TYPE_INTR,8,8        ; IO APIC IRQ 8, INTIN 8
    IoApicInti INT_TYPE_INTR,9,9        ; IO APIC IRQ 9, INTIN 9
    IoApicInti INT_TYPE_INTR,0ah,0ah    ; IO APIC IRQ 10, INTIN 10
    IoApicInti INT_TYPE_INTR,0bh,0bh    ; IO APIC IRQ 11, INTIN 11
    IoApicInti INT_TYPE_INTR,0ch,0ch    ; IO APIC IRQ 12, INTIN 12
    IoApicInti INT_TYPE_INTR,0dH,0dH    ; IO APIC IRQ 13, INTIN 13
    IoApicInti  INT_TYPE_INTR,0eH,0eH   ; IO APIC IRQ 14, INTIN 14
    IoApicInti  INT_TYPE_INTR,0fH,0fH   ; IO APIC IRQ 15, INTIN 15

    ; Create Local Apic interrupt input entries.
    Linti INT_TYPE_NMI,0,2,0,1            ; IRQ 2,LocalApicId 0,Linti 1

;
; PC+MP default configuration 4: MCA bus, 82489DX Apic.
;
     public _PcMpDefaultConfig4
_PcMpDefaultConfig4 label byte

    ; Create table HEADER.
    Header 14h

    ; Create processor entries
    Processor 0H, VERSION_82489DX, BSP_CPU
    Processor  01H, VERSION_82489DX, 0

    ; Create bus entries
    Bus 0, BUS_TYPE_MCA

    ; Create IO Apic entries.
    IoApic VERSION_82489DX

    ; Create IO Apic interrupt input entries.
    IoApicInti INT_TYPE_INTR,1,1        ; IO APIC IRQ 1, INTIN 1
    IoApicInti INT_TYPE_INTR,0,2        ; IO APIC IRQ 0, INTIN 2
    IoApicInti INT_TYPE_INTR,3,3        ; IO APIC IRQ 3, INTIN 3
    IoApicInti INT_TYPE_INTR,4,4        ; IO APIC IRQ 4, INTIN 4
    IoApicInti INT_TYPE_INTR,5,5        ; IO APIC IRQ 5, INTIN 5
    IoApicInti INT_TYPE_INTR,6,6        ; IO APIC IRQ 6, INTIN 6
    IoApicInti INT_TYPE_INTR,7,7        ; IO APIC IRQ 7, INTIN 7
    IoApicInti INT_TYPE_INTR,8,8        ; IO APIC IRQ 8, INTIN 8
    IoApicInti INT_TYPE_INTR,9,9        ; IO APIC IRQ 9, INTIN 9
    IoApicInti INT_TYPE_INTR,0ah,0ah    ; IO APIC IRQ 10, INTIN 10
    IoApicInti INT_TYPE_INTR,0bh,0bh    ; IO APIC IRQ 11, INTIN 11
    IoApicInti INT_TYPE_INTR,0ch,0ch    ; IO APIC IRQ 12, INTIN 12
    IoApicInti INT_TYPE_INTR,0dH,0dH    ; IO APIC IRQ 13, INTIN 13
    IoApicInti  INT_TYPE_INTR,0eH,0eH   ; IO APIC IRQ 14, INTIN 14
    IoApicInti  INT_TYPE_INTR,0fH,0fH   ; IO APIC IRQ 15, INTIN 15

    ; Create Local Apic interrupt input entries.
    Linti INT_TYPE_NMI,0,2,0,1            ; IRQ 2,LocalApicId 0,Linti 1

;
; PC+MP default configuration 5: ISA & PCI bus, Integrated Local Apic
;
    public _PcMpDefaultConfig5
_PcMpDefaultConfig5 label byte

    ; Create table HEADER.
    Header 15h

    ; Create processor entries
    Processor 0H, VERSION_INTEGRATED, BSP_CPU
    Processor  01H, VERSION_INTEGRATED, 0

    ; Create bus entries
    Bus 1, BUS_TYPE_ISA
    Bus 0, BUS_TYPE_PCI

    ; Create IO Apic entries.
    IoApic VERSION_INTEGRATED

    ; Create IO Apic interrupt input entries.
    ApicInti  INT_TYPE_INTR,1,1,1        ; IO APIC IRQ 1, INTIN 1
    ApicInti  INT_TYPE_INTR,1,0,2        ; IO APIC IRQ 0, INTIN 2
    ApicInti  INT_TYPE_INTR,1,3,3        ; IO APIC IRQ 3, INTIN 3
    ApicInti  INT_TYPE_INTR,1,4,4        ; IO APIC IRQ 4, INTIN 4
    ApicInti  INT_TYPE_INTR,1,5,5        ; IO APIC IRQ 5, INTIN 5
    ApicInti  INT_TYPE_INTR,1,6,6        ; IO APIC IRQ 6, INTIN 6
    ApicInti  INT_TYPE_INTR,1,7,7        ; IO APIC IRQ 7, INTIN 7
    ApicInti  INT_TYPE_INTR,1,8,8        ; IO APIC IRQ 8, INTIN 8
    ApicInti  INT_TYPE_INTR,1,9,9        ; IO APIC IRQ 9, INTIN 9
    ApicInti  INT_TYPE_INTR,1,0ah,0ah    ; IO APIC IRQ 10, INTIN 10
    ApicInti  INT_TYPE_INTR,1,0bh,0bh    ; IO APIC IRQ 11, INTIN 11
    ApicInti  INT_TYPE_INTR,1,0ch,0ch    ; IO APIC IRQ 12, INTIN 12
    ApicInti  INT_TYPE_INTR,1,0dH,0dH    ; IO APIC IRQ 13, INTIN 13
    ApicInti  INT_TYPE_INTR,1,0eH,0eH   ; IO APIC IRQ 14, INTIN 14
    ApicInti  INT_TYPE_INTR,1,0fH,0fH   ; IO APIC IRQ 15, INTIN 15

    ; Create Local Apic interrupt input entries.
    Linti INT_TYPE_NMI,1,2,0,1            ; IRQ 2,LocalApicId 0,Linti 1

;
; PC+MP default configuration 6 EISA & PCI bus, Integrated Local Apic
;
    public _PcMpDefaultConfig6
_PcMpDefaultConfig6 label byte

    ; Create table HEADER.
    Header 15h

    ; Create processor entries
    Processor 0H, VERSION_INTEGRATED, BSP_CPU
    Processor 1H, VERSION_INTEGRATED, 0

    ; Create bus entries
    Bus 1, BUS_TYPE_EISA
    Bus 0, BUS_TYPE_PCI

    ; Create IO Apic entries.
    IoApic VERSION_INTEGRATED

    ; Create IO Apic interrupt input entries.
    ApicInti   INT_TYPE_INTR,1,1,1        ; IO APIC IRQ 1, INTIN 1
    ApicInti   INT_TYPE_INTR,1,0,2        ; IO APIC IRQ 0, INTIN 2
    ApicInti   INT_TYPE_INTR,1,3,3        ; IO APIC IRQ 3, INTIN 3
    ApicInti   INT_TYPE_INTR,1,4,4        ; IO APIC IRQ 4, INTIN 4
    ApicInti   INT_TYPE_INTR,1,5,5        ; IO APIC IRQ 5, INTIN 5
    ApicInti   INT_TYPE_INTR,1,6,6        ; IO APIC IRQ 6, INTIN 6
    ApicInti   INT_TYPE_INTR,1,7,7        ; IO APIC IRQ 7, INTIN 7
    ApicInti   INT_TYPE_INTR,1,8,8        ; IO APIC IRQ 8, INTIN 8
    ApicInti   INT_TYPE_INTR,1,9,9        ; IO APIC IRQ 9, INTIN 9
    ApicInti   INT_TYPE_INTR,1,0ah,0ah    ; IO APIC IRQ 10, INTIN 10
    ApicInti   INT_TYPE_INTR,1,0bh,0bh    ; IO APIC IRQ 11, INTIN 11
    ApicInti   INT_TYPE_INTR,1,0ch,0ch    ; IO APIC IRQ 12, INTIN 12
    ApicInti   INT_TYPE_INTR,1,0dH,0dH    ; IO APIC IRQ 13, INTIN 13
    ApicInti   INT_TYPE_INTR,1,0eH,0eH   ; IO APIC IRQ 14, INTIN 14
    ApicInti   INT_TYPE_INTR,1,0fH,0fH   ; IO APIC IRQ 15, INTIN 15

    ; Create Local Apic interrupt input entries.
    Linti INT_TYPE_NMI,1,2,0,1            ; IRQ 2,LocalApicId 0,Linti 1


;
; PC+MP default configuration 7: MCA & PCI bus, Integrated Local Apic
;
    public _PcMpDefaultConfig7
_PcMpDefaultConfig7 label byte

    ; Create table HEADER.
    Header 15h

    ; Create processor entries
    Processor 0H, VERSION_INTEGRATED, BSP_CPU
    Processor  01H, VERSION_INTEGRATED, 0

    ; Create bus entries
    Bus 1, BUS_TYPE_MCA
    Bus 0, BUS_TYPE_PCI

    ; Create IO Apic entries.
    IoApic VERSION_INTEGRATED

    ; Create IO Apic interrupt input entries.
    ApicInti  INT_TYPE_INTR,1,1,1        ; IO APIC IRQ 1, INTIN 1
    ApicInti  INT_TYPE_INTR,1,0,2        ; IO APIC IRQ 0, INTIN 2
    ApicInti  INT_TYPE_INTR,1,3,3        ; IO APIC IRQ 3, INTIN 3
    ApicInti  INT_TYPE_INTR,1,4,4        ; IO APIC IRQ 4, INTIN 4
    ApicInti  INT_TYPE_INTR,1,5,5        ; IO APIC IRQ 5, INTIN 5
    ApicInti  INT_TYPE_INTR,1,6,6        ; IO APIC IRQ 6, INTIN 6
    ApicInti  INT_TYPE_INTR,1,7,7        ; IO APIC IRQ 7, INTIN 7
    ApicInti  INT_TYPE_INTR,1,8,8        ; IO APIC IRQ 8, INTIN 8
    ApicInti  INT_TYPE_INTR,1,9,9        ; IO APIC IRQ 9, INTIN 9
    ApicInti  INT_TYPE_INTR,1,0ah,0ah    ; IO APIC IRQ 10, INTIN 10
    ApicInti  INT_TYPE_INTR,1,0bh,0bh    ; IO APIC IRQ 11, INTIN 11
    ApicInti  INT_TYPE_INTR,1,0ch,0ch    ; IO APIC IRQ 12, INTIN 12
    ApicInti  INT_TYPE_INTR,1,0dH,0dH    ; IO APIC IRQ 13, INTIN 13
    ApicInti  INT_TYPE_INTR,1,0eH,0eH   ; IO APIC IRQ 14, INTIN 14
    ApicInti  INT_TYPE_INTR,1,0fH,0fH   ; IO APIC IRQ 15, INTIN 15

    ; Create Local Apic interrupt input entries.
    Linti INT_TYPE_NMI,1,2,0,1            ; IRQ 2,LocalApicId 0,Linti 1


    ;
    ; Pointers to the default configuration tables
    ;
    public _PcMpDefaultTablePtrs

    ; Array of pointers to the default configurations.
_PcMpDefaultTablePtrs label byte
    dd  offset _PcMpDefaultConfig1      ; Pointer to Default Config 1
    dd  offset _PcMpDefaultConfig2      ; Pointer to Default Config 2
    dd  offset _PcMpDefaultConfig3      ; Pointer to Default Config 3
    dd  offset _PcMpDefaultConfig4      ; Pointer to Default Config 4
    dd  offset _PcMpDefaultConfig5      ; Pointer to Default Config 5
    dd  offset _PcMpDefaultConfig6      ; Pointer to Default Config 6
    dd  offset _PcMpDefaultConfig7      ; Pointer to Default Config 7

PAGELK ENDS

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\mpdat.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ixdat.c

Abstract:

    Declares various data which is initialize data, or pagable data.

Author:

Environment:

    Kernel mode only.

Revision History:

--*/

#include "halp.h"
#include "apic.inc"
#include "pci.h"
#include "pcip.h"
#include "pcmp_nt.inc"
#include "ixsleep.h"


#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg("INIT")
#endif

//
// The following data is only valid during system initialiation
// and the memory will be re-claimed by the system afterwards
//

ADDRESS_USAGE HalpDefaultPcIoSpace = {
    NULL, CmResourceTypePort, InternalUsage,
    {
#ifndef MCA
        0x000,  0x10,   // ISA DMA
        0x0C0,  0x10,   // ISA DMA
#else
        0x000,  0x20,   // MCA DMA
        0x0C0,  0x20,   // MCA DMA
#endif
        0x080,  0x10,   // DMA

        0x020,  0x2,    // PIC
        0x0A0,  0x2,    // Cascaded PIC

        0x040,  0x4,    // Timer1, Referesh, Speaker, Control Word
        0x048,  0x4,    // Timer2, Failsafe

#if 0   // HACKHACK Remove for now since Intelille mouse software claims it.
        0x061,  0x1,    // NMI  (system control port B)
#endif
        0x092,  0x1,    // system control port A

        0x070,  0x2,    // Cmos/NMI enable
#ifdef MCA
        0x074,  0x3,    // Extended CMOS

        0x090,  0x2,    // Arbritration Control Port, Card Select Feedback
        0x093,  0x2,    // Reserved, System board setup
        0x096,  0x2,    // POS channel select
#endif
        0x0F0,  0x10,   // coprocessor ports
        0xCF8,  0x8,    // PCI Config Space Access Pair
        0,0
    }
};

ADDRESS_USAGE HalpEisaIoSpace = {
    NULL, CmResourceTypePort, InternalUsage,
    {
        0x0D0,  0x10,   // DMA
        0x400,  0x10,   // DMA
        0x480,  0x10,   // DMA
        0x4C2,  0xE,    // DMA
        0x4D4,  0x2C,   // DMA

        0x461,  0x2,    // Extended NMI
        0x464,  0x2,    // Last Eisa Bus Muster granted

        0x4D0,  0x2,    // edge/level control registers

        0xC84,  0x1,    // System board enable
        0, 0
    }
};

#ifndef ACPI_HAL

ADDRESS_USAGE HalpDetectedROM = {
    NULL,
    CmResourceTypeMemory,
    InternalUsage | RomResource,
    {
        0,0,                // 32 ROM blocks, get initialized in ixusage.c
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0,
        0,0
    }
};

#endif

ADDRESS_USAGE HalpImcrIoSpace = {
    NULL, CmResourceTypeMemory, InternalUsage,
    {
        0x022,  0x02,   // ICMR ports
        0, 0
    }
};

//
// From usage.c
//

WCHAR HalpSzSystem[] = L"\\Registry\\Machine\\Hardware\\Description\\System";
WCHAR HalpSzSerialNumber[] = L"Serial Number";

ADDRESS_USAGE  *HalpAddressUsageList = NULL;

//
// From ixpcibus.c
//

WCHAR rgzMultiFunctionAdapter[] = L"\\Registry\\Machine\\Hardware\\Description\\System\\MultifunctionAdapter";
WCHAR rgzConfigurationData[] = L"Configuration Data";
WCHAR rgzIdentifier[] = L"Identifier";
WCHAR rgzPCIIdentifier[] = L"PCI";
WCHAR rgzPCICardList[] = L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\PnP\\PCI\\CardList";

//
// From ixpcibrd.c
//

WCHAR rgzReservedResources[] = L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\SystemResources\\ReservedResources";

//
// From ixinfo.c
//

WCHAR rgzSuspendCallbackName[] = L"\\Callback\\SuspendHibernateSystem";

//
// Strings used for boot.ini options
// from mphal.c
//

UCHAR HalpSzBreak[]     = "BREAK";
UCHAR HalpSzOneCpu[]    = "ONECPU";
UCHAR HalpSzPciLock[]   = "PCILOCK";
UCHAR HalpSzTimerRes[]  = "TIMERES";
UCHAR HalpGenuineIntel[]= "GenuineIntel";
UCHAR HalpSzClockLevel[]= "CLKLVL";
UCHAR HalpSzUse8254[]   = "USE8254";
UCHAR HalpSzInterruptAffinity[]= "INTAFFINITY";
UCHAR HalpSzForceClusterMode[]= "MAXPROCSPERCLUSTER";

//
// From ixcmos.asm
//

UCHAR HalpSerialLen = 0;
UCHAR HalpSerialNumber[31] = {0};

//
// Copy of floating structure
// from detection code
//

struct FloatPtrStruct HalpFloatStruct;
UCHAR  rgzBadHal[] = "\n\n" \
            "HAL: This HAL.DLL requires an MPS version 1.1 system\n"    \
            "Replace HAL.DLL with the correct hal for this system\n"    \
            "The system is halting";

UCHAR  rgzRTCNotFound[]     = "HAL: No RTC device interrupt\n";

//
// Table to translate PCMP BusType to NT INTERFACE_TYPEs
// All Eisa, Isa, VL buses are squashed onto one space
// from mpsys.c
//

NTSTATUS
HalpAddEisaBus (
    PBUS_HANDLER    Bus
    );

NTSTATUS
HalpAddPciBus (
    PBUS_HANDLER    Bus
    );


//
// From ixmca.c
//
UCHAR   MsgMCEPending[] = MSG_MCE_PENDING;
WCHAR   rgzSessionManager[] = L"Session Manager";
WCHAR   rgzEnableMCE[] = L"EnableMCE";
WCHAR   rgzEnableMCA[] = L"EnableMCA";

//
// Timers
//

ULONG  HalpProc0TSCHz;

#ifdef ALLOC_DATA_PRAGMA
#pragma data_seg()
#endif

ULONG   HalpFeatureBits = 0;

UCHAR HalpDevPolarity [4][2] = {
    //
    //  Edge        Level
    {   CFG_HIGH,   CFG_LOW     },  // 00 - bus def
    {   CFG_HIGH,   CFG_HIGH    },  // 01 - high
    {   CFG_HIGH,   CFG_LOW     },  // 10 - undefined
    {   CFG_LOW,    CFG_LOW     }   // 11 - low
};


UCHAR HalpDevLevel [2][4] = {
    //                          must-be       must-be
    //  edge        level       edge          level
    {   CFG_EDGE,   CFG_EDGE,   CFG_EDGE,     CFG_ERR_LEVEL  },  // 0 - edge
    {   CFG_LEVEL,  CFG_LEVEL,  CFG_ERR_EDGE, CFG_LEVEL      }   // 1 - level
};

//
// Stuff for sleep or hibernate.
//


MOTHERBOARD_CONTEXT HalpMotherboardState = {0};
BOOLEAN             HalpOwnedDisplayBeforeSleep = FALSE;

volatile BOOLEAN HalpHiberInProgress = FALSE;
BOOLEAN HalpDisableHibernate = FALSE;

USHORT  HalpPciIrqMask = 0;
USHORT  HalpEisaIrqMask = 0;
USHORT  HalpEisaIrqIgnore = 0x1000;

//
// from mpdetect.c (needed because we reparse MPS table on hibernate resume)
//
UCHAR  rgzNoMpsTable[]      = "HAL: No MPS Table Found\n";
UCHAR  rgzNoApic[]          = "HAL: No IO APIC Found\n";
UCHAR  rgzBadApicVersion[]  = "HAL: Bad APIC Version\n";
UCHAR  rgzApicNotVerified[] = "HAL: APIC not verified\n";
UCHAR  rgzMPPTRCheck[]      = "HAL: MP_PTR invalid checksum\n";
UCHAR  rgzNoMPTable[]       = "HAL: MPS MP structure not found\n";
UCHAR  rgzMPSBadSig[]       = "HAL: MPS table invalid signature\n";
UCHAR  rgzMPSBadCheck[]     = "HAL: MPS table invalid checksum\n";
UCHAR  rgzBadDefault[]      = "HAL: MPS default configuration unknown\n";
UCHAR  rgzNoMem[]           = "HAL: Out of Memory\n";

//
// PAGELK handle
//
PVOID   HalpSleepPageLock = NULL;
PVOID   HalpSleepPage16Lock = NULL;

//
// Timer watchdog variables
//
ULONG   HalpTimerWatchdogEnabled = 0;
ULONG   HalpTimerWatchdogStorageOverflow = 0;
PVOID   HalpTimerWatchdogCurFrame;
PVOID   HalpTimerWatchdogLastFrame;
PCHAR   HalpTimerWatchdogStorage;

#ifndef ACPI_HAL
PCMPBUSTRANS    HalpTypeTranslation[] = {
  //    "INTERN", can't be interface_type internal
        "CBUS  ", FALSE, CFG_EDGE,     CBus,           NULL,           0,                 0,
        "CBUSII", FALSE, CFG_EDGE,     CBus,           NULL,           0,                 0,
        "EISA  ", FALSE, CFG_EDGE,     Eisa,           HalpAddEisaBus, EisaConfiguration, 0,
        "ISA   ", FALSE, CFG_EDGE,     Eisa,           HalpAddEisaBus, EisaConfiguration, 0,
        "MCA   ", FALSE, CFG_MB_LEVEL, MicroChannel,   NULL,           0,                 0,
        "MPI   ", FALSE, CFG_EDGE,     MPIBus,         NULL,           0,                 0,
        "MPSA  ", FALSE, CFG_EDGE,     MPSABus,        NULL,           0,                 0,
        "NUBUS ", FALSE, CFG_EDGE,     NuBus,          NULL,           0,                 0,
        "PCI   ", TRUE,  CFG_MB_LEVEL, PCIBus,         HalpAddPciBus,  PCIConfiguration,  sizeof (PCIPBUSDATA),
        "PCMCIA", FALSE, CFG_EDGE,     PCMCIABus,      NULL,           0,                 0,
        "TC    ", FALSE, CFG_EDGE,     TurboChannel,   NULL,           0,                 0,
        "VL    ", FALSE, CFG_EDGE,     Eisa,           HalpAddEisaBus, EisaConfiguration, 0,
        "VME   ", FALSE, CFG_EDGE,     VMEBus,         NULL,           0,                 0,
        "NEC98 ", FALSE, CFG_EDGE,     Isa,            HalpAddEisaBus, EisaConfiguration, 0,
        NULL,     FALSE, CFG_EDGE,     MaximumInterfaceType, NULL,     0,                 0
        } ;
#endif

UCHAR HalpInitLevel [4][4] = {
    //                               must-be          must-be
    //  edge          level          edge             level
    {   CFG_EDGE,     CFG_LEVEL,     CFG_MB_EDGE,     CFG_MB_LEVEL     },  // 00 - bus def
    {   CFG_MB_EDGE,  CFG_MB_EDGE,   CFG_MB_EDGE,     CFG_ERR_MB_LEVEL },  // 01 - edge
    {   CFG_ERR_EDGE, CFG_ERR_LEVEL, CFG_ERR_MB_EDGE, CFG_ERR_MB_LEVEL },  // 10 - undefined
    {   CFG_MB_LEVEL, CFG_MB_LEVEL,  CFG_ERR_MB_EDGE, CFG_MB_LEVEL     }   // 11 - level
};

BOOLEAN  HalpELCRChecked;


//
// From mpaddr.c
//

USHORT  HalpIoCompatibleRangeList0[] = {
    0x0100, 0x03ff,     0x0500, 0x07FF,     0x0900, 0x0BFF,     0x0D00, 0x0FFF,
    0, 0
    };

USHORT  HalpIoCompatibleRangeList1[] = {
    0x03B0, 0x03BB,     0x03C0, 0x03DF,     0x07B0, 0x07BB,     0x07C0, 0x07DF,
    0x0BB0, 0x0BBB,     0x0BC0, 0x0BDF,     0x0FB0, 0x0FBB,     0x0FC0, 0x0FDF,
    0, 0
    };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\mpclock.asm ===
title  "Interval Clock Interrupt"
;++
;
; Copyright (c) 1989  Microsoft Corporation
; Copyright (c) 1992  Intel Corporation
; All rights reserved
;
; INTEL CORPORATION PROPRIETARY INFORMATION
;
; This software is supplied to Microsoft under the terms
; of a license agreement with Intel Corporation and may not be
; copied nor disclosed except in accordance with the terms
; of that agreement.
;
;
; Module Name:
;
;    mpclock.asm
;
; Abstract:
;
;    This module implements the code necessary to field and process the
;    interval clock interrupt.
;
; Author:
;
;    Shie-Lin Tzong (shielint) 12-Jan-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;    Ron Mosgrove (Intel) Aug 1993
;       Modified to support PC+MP Systems
;--

.586p
        .xlist
include hal386.inc
include i386\ix8259.inc
include i386\ixcmos.inc
include callconv.inc
include i386\kimacro.inc
include mac386.inc
include apic.inc
include ntapic.inc
include i386\mp8254.inc

        .list

        EXTRNP  _KeUpdateSystemTime,0
        EXTRNP  _KeUpdateRunTime,1,IMPORT
        EXTRNP  Kei386EoiHelper,0,IMPORT
        EXTRNP  _HalEndSystemInterrupt,2
        EXTRNP  _HalBeginSystemInterrupt,3
        EXTRNP  _HalpAcquireCmosSpinLock  ,0
        EXTRNP  _HalpReleaseCmosSpinLock  ,0
        EXTRNP  _HalpAcquireSystemHardwareSpinLock  ,0
        EXTRNP  _HalpReleaseSystemHardwareSpinLock  ,0

        EXTRNP  _HalpSetInitialClockRate,0

        EXTRNP  _HalpMcaQueueDpc, 0
        EXTRNP  _KeQueryPerformanceCounter, 1

        extrn   _HalpRtcTimeIncrements:DWORD
        extrn   _KdEnteredDebugger:DWORD

        extrn   _HalpTimerWatchdogEnabled:DWORD
        extrn   _HalpTimerWatchdogStorage:DWORD
        extrn   _HalpTimerWatchdogCurFrame:DWORD
        extrn   _HalpTimerWatchdogLastFrame:DWORD
        extrn   _HalpTimerWatchdogStorageOverflow:DWORD
ifdef ACPI_HAL
ifdef NT_UP
        EXTRNP  _HalpBrokenPiix4TimerTick, 0
        extrn   _HalpBrokenAcpiTimer:byte
endif        
endif        

ifdef MMTIMER
	EXTRNP  _HalpmmTimerClockInterrupt, 0

MMT_VECTOR              EQU     0D3h
endif
	
;
; Constants used to initialize CMOS/Real Time Clock
;

CMOS_CONTROL_PORT       EQU     70h     ; command port for cmos
CMOS_DATA_PORT          EQU     71h     ; cmos data port
CMOS_STATUS_BUSY        EQU     80H     ; Time update in progress

D_INT032                EQU     8E00h   ; access word for 386 ring 0 interrupt gate
REGISTER_B_ENABLE_PERIODIC_INTERRUPT EQU     01000010B
                                        ; RT/CMOS Register 'B' Init byte
                                        ; Values for byte shown are
                                        ;  Bit 7 = Update inhibit
                                        ;  Bit 6 = Periodic interrupt enable
                                        ;  Bit 5 = Alarm interrupt disable
                                        ;  Bit 4 = Update interrupt disable
                                        ;  Bit 3 = Square wave disable
                                        ;  Bit 2 = BCD data format
                                        ;  Bit 1 = 24 hour time mode
                                        ;  Bit 0 = Daylight Savings disable

REGISTER_B_DISABLE_PERIODIC_INTERRUPT EQU    00000010B

;
; RegisterAInitByte sets 8Hz clock rate, used during init to set up
; KeStallExecutionProcessor, etc.  (See RegASystemClockByte below.)
;

RegisterAInitByte       EQU     00101101B ; RT/CMOS Register 'A' init byte
                                        ; 32.768KHz Base divider rate
                                        ;  8Hz int rate, period = 125.0ms
PeriodInMicroSecond     EQU     125000  ;

COUNTER_TICKS_AVG_SHIFT EQU     4
COUNTER_TICKS_FOR_AVG   EQU     16
PAGE_SIZE               EQU     1000H
FRAME_COPY_SIZE         EQU     64

_DATA   SEGMENT  DWORD PUBLIC 'DATA'

;
;  There is a "C" version of this structure in MPCLOCKC.C
;

TimeStrucSize EQU 20

RtcTimeIncStruc struc
    RTCRegisterA        dd  0   ;The RTC register A value for this rate
    RateIn100ns         dd  0   ;This rate in multiples of 100ns
    RateAdjustmentNs    dd  0   ;Error Correction (in ns)
    RateAdjustmentCnt   dd  0   ;Error Correction (as a fraction of 256)
    IpiRate             dd  0   ;IPI Rate Count (as a fraction of 256)
RtcTimeIncStruc ends

ifdef DBGSSF
DebugSSFStruc struc
        SSFCount1   dd      0
        SSFCount2   dd      0
        SSFRdtsc1   dd      0
        SSFRdtsc2   dd      0
        SSFRdtsc3   dd      0

        SSFRna1     dd      0
        SSFRna2     dd      0
        SSFRna3     dd      0

DebugSSFStruc ends

        public HalpDbgSSF
HalpDbgSSF  db  (size DebugSSFStruc) * 10 dup (0)

endif

    ALIGN dword

        public  RTCClockFreq
        public  RegisterAClockValue

RTCClockFreq          dd      156250
RegisterAClockValue   dd      00101010B ; default interval = 15.6250 ms

MINIMUM_STALL_FACTOR    EQU     10H     ; Reasonable Minimum

        public  HalpP0StallFactor
HalpP0StallFactor               dd    MINIMUM_STALL_FACTOR
        public  HalpInitStallComputedCount
HalpInitStallComputedCount      dd    0
        public  HalpInitStallLoopCount
HalpInitStallLoopCount          dd    0

    ALIGN   dword
;
; Clock Rate Adjustment Counter.  This counter is used to keep a tally of
;   adjustments needed to be applied to the RTC rate as passed to the
;   kernel.
;

        public  _HalpCurrentRTCRegisterA, _HalpCurrentClockRateIn100ns
        public  _HalpCurrentClockRateAdjustment, _HalpCurrentIpiRate
        public  _HalpIpiRateCounter, _HalpNextMSRate, _HalpPendingRate
        public  _HalpRateAdjustment
_HalpCurrentRTCRegisterA        dd      0
_HalpCurrentClockRateIn100ns    dd      0
_HalpCurrentClockRateAdjustment dd      0
_HalpCurrentIpiRate             dd      0
_HalpIpiRateCounter             dd      0
_HalpNextMSRate                 dd      0
_HalpPendingRate                dd      0
_HalpRateAdjustment             dd      0

ifdef ACPI_HAL
	public _HalpCurrentMSRateTableIndex
_HalpCurrentMSRateTableIndex    dd      0
endif
	
;
;  HalpUse8254      - flag to indicate 8254 should be used
;  HalpSample8254   - count to sample 8254
;
;   N.B. access to the 8254 is gaurded with the Cmos lock
;
        public  _HalpUse8254
_HalpUse8254                db  0
_HalpSample8254             db  0
_b8254Reserved              dw  0


;
; Flag to tell clock routine when P0 can Ipi Other processors
;

        public _HalpIpiClock
_HalpIpiClock dd 0

        public _HalpClockWork, _HalpClockSetMSRate, _HalpClockMcaQueueDpc
_HalpClockWork label dword
    _HalpClockSetMSRate     db  0
    _HalpClockMcaQueueDpc   db  0
    _bReserved1             db  0
    _bReserved2             db  0

;
; timer latency watchdog variables
;

        public  _HalpWatchdogAvgCounter, _HalpWatchdogCountLow, _HalpWatchdogCountHigh
        public  _HalpWatchdogTscLow, _HalpWatchdogTscHigh

    _HalpWatchdogAvgCounter dd  0
    _HalpWatchdogCountLow   dd  0
    _HalpWatchdogCountHigh  dd  0
    _HalpWatchdogTscLow     dd  0
    _HalpWatchdogTscHigh    dd  0

_DATA   ends


PAGELK    SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

        page ,132
        subttl  "Initialize Clock"
;++
;
; VOID
; HalpInitializeClock (
;    )
;
; Routine Description:
;
;   This routine initialize system time clock using RTC to generate an
;   interrupt at every 15.6250 ms interval at APIC_CLOCK_VECTOR
; 
;   It also initializes the 8254 if the 8254 is to be used for performance
;   counters.
;
;   See the definition of RegisterAClockValue if clock rate needs to be
;   changed.
;
;   This routine assumes it runs during Phase 0 on P0.
;
; Arguments:
;
;    None
;
; Return Value:
;
;    None.
;
;--
cPublicProc _HalpInitializeClock      ,0

;
; timer latency watchdog initialization
;
        cmp     _HalpTimerWatchdogEnabled, 0
        jz      short @f

        rdtsc
        mov     _HalpWatchdogAvgCounter, COUNTER_TICKS_FOR_AVG
        mov     _HalpWatchdogTscLow, eax
        mov     _HalpWatchdogTscHigh, edx
        xor     eax, eax
        mov     _HalpWatchdogCountLow, eax
        mov     _HalpWatchdogCountHigh, eax
@@:    

        pushfd                          ; save caller's eflag
        cli                             ; make sure interrupts are disabled

        stdCall _HalpSetInitialClockRate

;
;   Set the interrupt rate to what is actually needed
;
        stdCall   _HalpAcquireCmosSpinLock      ; intr disabled

        mov     eax, _HalpCurrentRTCRegisterA
        shl     ax, 8
        mov     al, 0AH                 ; Register A
        CMOS_WRITE                      ; Initialize it
;
; Don't clobber the Daylight Savings Time bit in register B, because we
; stash the LastKnownGood "environment variable" there.
;
        mov     ax, 0bh
        CMOS_READ
        and     al, 1
        mov     ah, al
        or      ah, REGISTER_B_ENABLE_PERIODIC_INTERRUPT
        mov     al, 0bh
        CMOS_WRITE                      ; Initialize it
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize
        mov     al,0DH                  ; Register D
        CMOS_READ                       ; Read to initialize

        stdCall   _HalpReleaseCmosSpinLock

;
; For HALAACPI (free), init the 8254 so we can use it to
; verify the ACPI timer frequency
; 
ifdef ACPI_HAL
ifdef NT_UP
	jmp	short Hic50	  
endif
endif
	cmp     _HalpUse8254, 0
	jz      short Hic90

Hic50:
        stdCall   _HalpAcquireSystemHardwareSpinLock      ; intr disabled

        ; Program 8254 to count down the maximum interval 
        ; (8254 access is gaurded with CmosSpinLock)

        mov     eax, PERFORMANCE_INTERVAL
        mov     ecx, eax

        ; set up counter 0 for periodic, binary count-down from max value
                
        mov     al,COMMAND_8254_COUNTER0+COMMAND_8254_RW_16BIT+COMMAND_8254_MODE2
        out     TIMER1_CONTROL_PORT0, al    ; program count mode of timer 0
        IoDelay
        mov     al, cl
        out     TIMER1_DATA_PORT0, al       ; program counter 0 LSB count
        IoDelay
        mov     al,ch
        out     TIMER1_DATA_PORT0, al       ; program counter 0 MSB count


        or      _HalpUse8254, PERF_8254_INITIALIZED
        stdCall   _HalpReleaseSystemHardwareSpinLock

Hic90:
        popfd                           ; restore caller's eflag
        stdRET    _HalpInitializeClock

stdENDP _HalpInitializeClock

PAGELK  ends

_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING


        page ,132
        subttl  "System Clock Interrupt"
;++
;
; Routine Description:
;
;
;    This routine is entered as the result of an interrupt generated by CLOCK2.
;    Its function is to dismiss the interrupt, raise system Irql to
;    CLOCK2_LEVEL, update performance counter and transfer control to the
;    standard system routine to update the system time and the execution
;    time of the current thread
;    and process.
;
;
; Arguments:
;
;    None
;    Interrupt is disabled
;
; Return Value:
;
;    Does not return, jumps directly to KeUpdateSystemTime, which returns
;
;    Sets Irql = CLOCK2_LEVEL and dismisses the interrupt
;
;--

APIC_ICR_CLOCK  equ (DELIVER_FIXED OR ICR_ALL_EXCL_SELF OR APIC_CLOCK_VECTOR)

        ENTER_DR_ASSIST Hci_a, Hci_t

cPublicProc _HalpClockInterrupt     ,0

;
; Save machine state in trap frame
;

        ENTER_INTERRUPT Hci_a, Hci_t

;
; (esp) - base of trap frame
;
; dismiss interrupt and raise Irql
;

        push    APIC_CLOCK_VECTOR
        sub     esp, 4                  ; allocate space to save OldIrql
        stdCall   _HalBeginSystemInterrupt, <CLOCK2_LEVEL,APIC_CLOCK_VECTOR,esp>

ifdef  NT_UP
ifdef ACPI_HAL
;
; Check to see if we need to fix up a broken PIIX4
;
        .if (_HalpBrokenAcpiTimer)
        stdCall _HalpBrokenPiix4TimerTick
        .endif
endif
endif        
        mov     al, _HalpUse8254
        or      al, al
        jz      short Hci90

        add     _HalpSample8254, 56h
        jnc     short Hci90

        ; Call KeQueryPerformanceCounter() so that wrap-around of 8254 is 
        ; detected and the base value for performance counters updated.
        ; Ignore returned value and reset HalpSample8254.
        ;
        ; WARNING - change increment value above if maximum RTC time increment
        ; is increased to be more than current maximum value of 15.625 ms.
        ; Currently the call will be made every 3rd timer tick.

        xor     eax, eax
        mov     _HalpSample8254, al
        stdCall _KeQueryPerformanceCounter, <eax>
        
Hci90:

;
; This is the RTC interrupt, so we have to clear the
; interrupt flag on the RTC.
;
        stdCall _HalpAcquireCmosSpinLock

;
; clear interrupt flag on RTC by banging on the CMOS.  On some systems this
; doesn't work the first time we do it, so we do it twice.  It is rumored that
; some machines require more than this, but that hasn't been observed with NT.
;

        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize

        stdCall _HalpReleaseCmosSpinLock

        mov     eax, _HalpCurrentClockRateIn100ns
        xor     ebx, ebx

        ;
        ;  Adjust the tick count as needed
        ;    

        mov     ecx, _HalpCurrentClockRateAdjustment
        add     byte ptr _HalpRateAdjustment, cl
        sbb     eax, ebx

;
; (esp)   = OldIrql
; (esp+4) = Vector
; (esp+8) = base of trap frame
; eax = time increment of this tick
; ebx = 0
;

;
; With an APIC Based System we will force a clock interrupt to all other
; processors.  This is not really an IPI in the NT sense of the word, it
; uses the Local Apic to generate interrupts to other CPU's.
;

ifdef  NT_UP

    ;   UP implemention, we don't care about IPI's here

else ; ! NT_UP

        ;
        ;  See if we need to IPI anyone,  this happens only at the
        ;  Lowest supported frequency (ie the value KeSetTimeIncrement
        ;  is called with.  We have a IPI Rate based upon the current
        ;  clock rate relative to the lowest clock rate.
        ;    

        mov     ecx, _HalpIpiRateCounter
        add     ecx, _HalpCurrentIpiRate
        cmp     ch, bl
        mov     byte ptr _HalpIpiRateCounter, cl
        jz      short HalpDontSendClockIpi      ; No, Skip it

        ;
        ; Don't send vectors onto the APIC bus until at least one other
        ; processor comes on line.  Vectors placed on the bus will hang
        ; around until someone picks them up.
        ;

        cmp     _HalpIpiClock, ebx
        je      short HalpDontSendClockIpi

        ;
        ; At least one other processor is alive, send clock pulse to all
        ; other processors
        ;

        ; We use a destination shorthand and therefore only needs to
        ; write the lower 32 bits of the ICR.


        pushfd
        cli

;
; Now issue the Clock IPI Command by writing to the Memory Mapped Register
;

        STALL_WHILE_APIC_BUSY
        mov     dword ptr APIC[LU_INT_CMD_LOW], APIC_ICR_CLOCK

        popfd

HalpDontSendClockIpi:

endif ; NT_UP

        cmp dword ptr _HalpTimerWatchdogEnabled, 0
        jz  Hci15
        push    eax


;
; Timer latency watchdog code
;

        rdtsc

;
; Compare difference to watchdog count, while storing a copy of the
; current counter.
;

        push    eax
        push    edx

        sub     eax, _HalpWatchdogTscLow
        sbb     edx, _HalpWatchdogTscHigh

        pop     _HalpWatchdogTscHigh
        pop     _HalpWatchdogTscLow
        js      Hci115                      ; Was this a bogus counter?
                                            ;   (e.g, negative delta)

        push    eax
        push    edx
        mov     ecx, dword ptr _KdEnteredDebugger
        mov     eax, [ecx]                  ; eax =
        xor     edx, edx                    ;   InterlockedExchange( 
@@:     cmpxchg [ecx], edx                  ;      &KdEnteredDebugger,
        jnz     short @b                    ;      TRUE );
        or      al, al                      
        pop     edx
        pop     eax
        jnz     Hci14                       ; In the debugger? Yes, skip it.

        cmp     _HalpPendingRate, ebx       ; Was a new rate set during last
        jnz     Hci14                       ; tick?  Yes, skip this compare

;
; If we need to compute the average of the time-stamp counter for
; the current period, add the delta to the counter.
;

        cmp     _HalpWatchdogAvgCounter, ebx
        jnz     Hci12

        cmp     edx, _HalpWatchdogCountHigh
        ja      short Hci11
        jb      Hci14

        cmp     eax, _HalpWatchdogCountLow
        jbe     Hci14

Hci11:  
        cmp     dword ptr [_HalpTimerWatchdogCurFrame], 0
        je      short Hci115
        cmp     dword ptr [_HalpTimerWatchdogStorageOverflow], 0
        jne     short Hci115

;
; copy FRAME_COPY_SIZE dwords from the stack, or to next page boundary,
; whichever is less
;       

        push    esi
        push    edi
        lea     esi, [esp+8]
        lea     ecx, [esi + PAGE_SIZE - 1]
        and     ecx, NOT(PAGE_SIZE - 1)
        sub     ecx, esi
        shr     ecx, 2
        cmp     ecx, FRAME_COPY_SIZE
        jbe     short Hci112
        mov     ecx, FRAME_COPY_SIZE
Hci111:
        mov     edi, dword ptr _HalpTimerWatchdogCurFrame
        rep     movsd
        add     _HalpTimerWatchdogCurFrame, (FRAME_COPY_SIZE*4)
;
; If we didn't copy an entire FRAME_COPY_SIZE dwords, zero fill.
;
        mov     ecx, dword ptr _HalpTimerWatchdogCurFrame
        sub     ecx, edi
        shr     ecx, 2
        xor     eax, eax
        rep     stosd
        cmp     edi, dword ptr _HalpTimerWatchdogLastFrame
        jbe     short Hci112
        mov     dword ptr [_HalpTimerWatchdogStorageOverflow], 1
Hci112:

        pop     edi
        pop     esi

Hci115:

;
; Reset last time so that we're accurate after the trap
;
        rdtsc
        mov     _HalpWatchdogTscHigh, edx
        mov     _HalpWatchdogTscLow, eax
        
        jmp     short Hci14

Hci12:
;
; Increment the total counter, perform average when the count is reached
;

        add     _HalpWatchdogCountLow, eax
        adc     _HalpWatchdogCountHigh, edx        
        dec     _HalpWatchdogAvgCounter
        jnz     short Hci14

        mov     edx, _HalpWatchdogCountHigh
        mov     eax, _HalpWatchdogCountLow

;
; compute the average * 2, this measures when we have missed 
; an interrupt at this rate.
;                 
        mov     ecx, COUNTER_TICKS_AVG_SHIFT - 1
Hci13:    
        shr     edx, 1
        rcr     eax, 1
        loop    short Hci13

        mov     _HalpWatchdogCountLow, eax
        mov     _HalpWatchdogCountHigh, edx

Hci14:
        pop     eax

Hci15:
;
; Check for any more work
;
        cmp     _HalpClockWork, ebx     ; Any clock interrupt work desired?
        jz      _KeUpdateSystemTime@0   ; No, process tick

        cmp     _HalpClockMcaQueueDpc, bl
        je      short CheckTimerRate

        mov     _HalpClockMcaQueueDpc, bl

;
; Queue MCA Dpc
;

        push    eax
        stdCall _HalpMcaQueueDpc            ; Queue MCA Dpc
        pop     eax

CheckTimerRate:
;
; (esp)   = OldIrql
; (esp+4) = Vector
; (esp+8) = base of trap frame
; ebp = trap frame
; eax = time increment of this tick
; ebx = 0
;
        cmp     _HalpClockSetMSRate, bl     ; New clock rate desired?
        jz      _KeUpdateSystemTime@0       ; No, process tick


;
; Time of clock frequency is being changed.  See if we have changed rates
; since the last tick
;
        cmp     _HalpPendingRate, ebx       ; Was a new rate set durning last
        jnz     SetUpForNextTick            ; tick?  Yes, go update globals

ProgramTimerRate:

; (eax) = time increment for current tick

;
; A new clock rate needs to be set.  Setting the rate here will
; cause the tick after the next tick to be at the new rate.
; (the next tick is already in progress and will occur at the same
; rate as this tick)
;

        push    eax

        stdCall _HalpAcquireCmosSpinLock

        mov     eax, _HalpNextMSRate
        mov     _HalpPendingRate, eax  ; pending rate

        dec     eax
        mov     ecx, TimeStrucSize
        xor     edx, edx
        mul     ecx

        mov     eax, _HalpRtcTimeIncrements[eax].RTCRegisterA
        mov     _HalpCurrentRTCRegisterA, eax

        shl     ax, 8                   ; (ah) = (al)
        mov     al, 0AH                 ; Register A
        CMOS_WRITE                      ; Set it

        cmp _HalpTimerWatchdogEnabled, 0
        jz  short @f
;
; Timer latency watchdog: schedule to recalibrate TSC delta
;
        rdtsc
        mov     _HalpWatchdogAvgCounter, COUNTER_TICKS_FOR_AVG
        mov     _HalpWatchdogTscLow, eax
        mov     _HalpWatchdogTscHigh, edx

        xor     eax,eax
        mov     _HalpWatchdogCountHigh, eax
        mov     _HalpWatchdogCountLow, eax
@@:

        stdCall _HalpReleaseCmosSpinLock

        pop     eax
        jmp     _KeUpdateSystemTime@0   ; dispatch this tick

SetUpForNextTick:

;
; The next tick will occur at the rate which was programmed during the last
; tick. Update globals for new rate which starts with the next tick.
;
; We will get here if there is a request for a rate change.  There could
; been two requests.  That is why we are conmparing the Pending with the
; NextRate.
;
; (eax) = time increment for current tick
;
        push    eax

        mov     eax, _HalpPendingRate
        dec     eax

ifdef ACPI_HAL
ifdef NT_UP
;
; Update the index used by Piix4 workaround; this maps RTC system clock
; milisecond indices into PM Timer (PMT) milisecond indices
;
;     RTC { 0=1ms, 1=2ms, 2=4ms, 3=8ms, 4=15.6ms }
;
;     PMT { 0=1ms, 1=2ms, 2=3ms, ..., 14=15ms }
;
; So to convert from RTC index to PMT:  PMT = (1 << RTC) - 1
;
; NOTE: Since the PM timer array only goes to 15ms, we map our last RTC
;       index (4=15.6) to PMT index 14 (15ms) as a special case
;
	mov     edx, 1
	mov     cl, al
	shl     edx, cl
	dec     edx
	cmp     edx, 0fh  ; Check for special case RTC 15.6ms -> PMT 15ms
	jne     short @f
	dec     edx
	
@@:	
	mov	_HalpCurrentMSRateTableIndex, edx
endif
endif

        mov     ecx, TimeStrucSize
        xor     edx, edx
        mul     ecx

        mov     ebx, _HalpRtcTimeIncrements[eax].RateIn100ns
        mov     ecx, _HalpRtcTimeIncrements[eax].RateAdjustmentCnt
        mov     edx, _HalpRtcTimeIncrements[eax].IpiRate
        mov     _HalpCurrentClockRateIn100ns, ebx
        mov     _HalpCurrentClockRateAdjustment, ecx
        mov     _HalpCurrentIpiRate, edx

        mov     ebx, _HalpPendingRate
        mov     _HalpPendingRate, 0     ; no longer pending, clear it

        pop     eax

        cmp     ebx, _HalpNextMSRate      ; new rate == NextRate?
        jne     ProgramTimerRate        ; no, go set new pending rate

        mov     _HalpClockSetMSRate, 0  ; all done setting new rate
        jmp     _KeUpdateSystemTime@0   ; dispatch this tick


stdENDP _HalpClockInterrupt

        page ,132
        subttl  "System Clock Interrupt - Non BSP"
;++
;
; Routine Description:
;
;
;   This routine is entered as the result of an interrupt generated by
;   CLOCK2. Its function is to dismiss the interrupt, raise system Irql
;   to CLOCK2_LEVEL, transfer control to the standard system routine to
;   the execution time of the current thread and process.
;
;   This routine is executed on all processors other than P0
;
;
; Arguments:
;
;   None
;   Interrupt is disabled
;
; Return Value:
;
;   Does not return, jumps directly to KeUpdateSystemTime, which returns
;
;   Sets Irql = CLOCK2_LEVEL and dismisses the interrupt
;
;--

        ENTER_DR_ASSIST HPn_a, HPn_t

cPublicProc _HalpClockInterruptPn    ,0

;
; Save machine state in trap frame
;

        ENTER_INTERRUPT HPn_a, HPn_t

;
; (esp) - base of trap frame
;
; dismiss interrupt and raise Irql
;

    push    APIC_CLOCK_VECTOR
    sub     esp, 4                  ; allocate space to save OldIrql
    stdCall   _HalBeginSystemInterrupt, <CLOCK2_LEVEL,APIC_CLOCK_VECTOR,esp>

    ;
    ; All processors will update RunTime for current thread
    ;

    sti
    ; TOS const PreviousIrql
    stdCall _KeUpdateRunTime,<dword ptr [esp]>

    INTERRUPT_EXIT          ; lower irql to old value, iret

    ;
    ; We don't return here
    ;

stdENDP _HalpClockInterruptPn


        page ,132
        subttl  "System Clock Interrupt - Stub"
;++
;
; Routine Description:
;
;
;   This routine is entered as the result of an interrupt generated by
;   CLOCK2. Its function is to interrupt and return.
;
;   This routine is executed on P0 During Phase 0
;
;
; Arguments:
;
;   None
;   Interrupt is disabled
;
; Return Value:
;
;--

APIC_ICR_CLOCK  equ (DELIVER_FIXED OR ICR_ALL_EXCL_SELF OR APIC_CLOCK_VECTOR)

        ENTER_DR_ASSIST HStub_a, HStub_t

cPublicProc _HalpClockInterruptStub    ,0

;
; Save machine state in trap frame
;

        ENTER_INTERRUPT HStub_a, HStub_t

;
; (esp) - base of trap frame
;

;
; clear interrupt flag on RTC by banging on the CMOS.  On some systems this
; doesn't work the first time we do it, so we do it twice.  It is rumored that
; some machines require more than this, but that hasn't been observed with NT.
;

        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize

Hpi10:  test    al, 80h
        jz      short Hpi15
        mov     al,0CH                  ; Register C
        CMOS_READ                       ; Read to initialize
        jmp     short Hpi10
Hpi15:

        mov     dword ptr APIC[LU_EOI], 0      ; send EOI to APIC local unit

        ;
        ; Do interrupt exit processing without EOI
        ;

        SPURIOUS_INTERRUPT_EXIT

        ;
        ; We don't return here
        ;

stdENDP _HalpClockInterruptStub

ifdef MMTIMER	
        page ,132
        subttl  "Multi Media Event Timer System Clock Interrupt Stub"
;++
;
; Routine Description:
;
;
;   This routine is entered as the result of an interrupt generated by
;   CLOCK2, its function is to interrupt, call HalpmmTimerClockInterrupt
;   to update performance counters and adjust the system clock frequency
;   if necessary, to IPI other processors, and update system time
;
;   This routine is executed on P0
;
; Arguments:
;
;   None - Interrupt is disabled
;
; Return Value:
;
;--
	
        ENTER_DR_ASSIST Hmmt_a, Hmmt_t

cPublicProc _HalpmmTimerClockInterruptStub

;
; Save machine state in trap frame
;

        ENTER_INTERRUPT Hmmt_a, Hmmt_t

;
; (esp) - base of trap frame
;
; dismiss interrupt and raise Irql
;

    push    MMT_VECTOR
    sub     esp, 4                  ; allocate space to save OldIrql
    stdCall   _HalBeginSystemInterrupt, <CLOCK2_LEVEL,MMT_VECTOR,esp>

    ;
    ; Update performace counter and adjust clock frequency if necessary
    ;

    stdCall _HalpmmTimerClockInterrupt

    INTERRUPT_EXIT          ; lower irql to old value, iret

    ;
    ; We don't return here
    ;

stdENDP _HalpmmTimerClockInterruptStub
endif	

ifdef ACPI_HAL
        page ,132
        subttl  "Query 8254 Counter"
;++
;
; ULONG
; HalpQuery8254Counter(
;    VOID
;    )
;
; Routine Description:
;
;    This routine returns the current value of the 8254 counter
;
; Arguments:
;
;    None
;
; Return Value:
;
;    Current value of the 8254 counter is returned
;
;--

	cPublicProc _HalpQuery8254Counter, 0

        stdCall   _HalpAcquireSystemHardwareSpinLock      ; intr disabled

;
; Fetch the current counter value from the hardware
;

        mov     al, COMMAND_8254_LATCH_READ + COMMAND_8254_COUNTER0
                                        ; Latch PIT Ctr 0 command.
        out     TIMER1_CONTROL_PORT0, al
        IODelay
        in      al, TIMER1_DATA_PORT0   ; Read PIT Ctr 0, LSByte.
        IODelay
        movzx   ecx, al                 ; Zero upper bytes of (ECX).
        in      al, TIMER1_DATA_PORT0   ; Read PIT Ctr 0, MSByte.
        mov     ch, al                  ; (CX) = PIT Ctr 0 count.

	mov     eax, ecx
		
        stdCall   _HalpReleaseSystemHardwareSpinLock

        stdRET    _HalpQuery8254Counter

stdENDP _HalpQuery8254Counter
endif
		
_TEXT   ends

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\mpdetect.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1992  Intel Corporation
All rights reserved

INTEL CORPORATION PROPRIETARY INFORMATION

This software is supplied to Microsoft under the terms
of a license agreement with Intel Corporation and may not be
copied nor disclosed except in accordance with the terms
of that agreement.

Module Name:

    mpdetect.c

Abstract:

    This module detects an MPS system.

Author:

    Ron Mosgrove (Intel) - Aug 1993.

Environment:

    Kernel mode or from textmode setup.

Revision History:
    Rajesh Shah (Intel) - Oct 1993. Added support for MPS table.

--*/

#ifndef _NTOS_
#include "halp.h"
#endif

#ifdef SETUP
#define FAILMSG(a)
#else
#define FAILMSG(a)  HalDisplayString(a)
extern UCHAR  rgzNoMpsTable[];
extern UCHAR  rgzNoApic[];
extern UCHAR  rgzBadApicVersion[];
extern UCHAR  rgzApicNotVerified[];
extern UCHAR  rgzMPPTRCheck[];
extern UCHAR  rgzNoMPTable[];
extern UCHAR  rgzMPSBadSig[];
extern UCHAR  rgzMPSBadCheck[];
extern UCHAR  rgzBadDefault[];
extern UCHAR  rgzNoMem[];
#endif


// Include the code that actually detect a MPS system
#include "pcmpdtct.c"


BOOLEAN
HalpVerifyIOUnit (
    IN PUCHAR BaseAddress
    );

VOID
HalpInitMpInfo (
    IN struct PcMpTable *MpTablePtr
    );

ULONG
DetectMPS (
    OUT PBOOLEAN IsConfiguredMp
    );

ULONG
DetectUPMPS (
    OUT PBOOLEAN IsConfiguredMp
    );

extern struct PcMpTable *GetPcMpTable( VOID );

ULONG UserSpecifiedNoIoApic = 0;

struct HalpMpInfo HalpMpInfoTable;
struct PcMpTable  HalpPcMpTable;

struct PcMpTable *PcMpTablePtr;

#ifndef SETUP

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGELK,HalpVerifyIOUnit)
#pragma alloc_text(PAGELK,HalpInitMpInfo)
#pragma alloc_text(PAGELK,DetectMPS)
#pragma alloc_text(PAGELK,DetectUPMPS)
#endif  // ALLOC_PRAGMA

extern struct PcMpTable *PcMpDefaultTablePtrs[];

#endif // SETUP


BOOLEAN
HalpVerifyIOUnit(
    IN PUCHAR BaseAddress
    )
/*++

Routine Description:

    Verify that an IO Unit exists at the specified address

 Arguments:

    BaseAddress - Virtual address of the IO Unit to test.

 Return Value:
    BOOLEAN - TRUE if a IO Unit was found at the passed address
            - FALSE otherwise

--*/

{
    union ApicUnion {
        ULONG Raw;
        struct ApicVersion Ver;
    } Temp1, Temp2;

    struct ApicIoUnit *IoUnitPtr = (struct ApicIoUnit *) BaseAddress;

    //
    //  The documented detection mechanism is to write all zeros to
    //  the Version register.  Then read it back.  The IO Unit exists if the
    //  same result is read both times and the Version is valid.
    //

    IoUnitPtr->RegisterSelect = IO_VERS_REGISTER;
    IoUnitPtr->RegisterWindow = 0;

    IoUnitPtr->RegisterSelect = IO_VERS_REGISTER;
    Temp1.Raw = IoUnitPtr->RegisterWindow;

    IoUnitPtr->RegisterSelect = IO_VERS_REGISTER;
    IoUnitPtr->RegisterWindow = 0;

    IoUnitPtr->RegisterSelect = IO_VERS_REGISTER;
    Temp2.Raw = IoUnitPtr->RegisterWindow;

    if ((Temp1.Ver.Version != Temp2.Ver.Version) ||
        (Temp1.Ver.MaxRedirEntries != Temp2.Ver.MaxRedirEntries)) {
        //
        //  No IO Unit There
        //
        return (FALSE);
    }

    return (TRUE);
}


VOID
HalpInitMpInfo (
    IN struct PcMpTable *MpTablePtr
    )

/*++
Routine Description:
    This routine initializes a HAL specific data structure that is
    used by the HAL to simplify access to MP information.

Arguments:
    MpTablePtr: Pointer to the MPS table.

 Return Value:
     Pointer to the HAL MP information table.

*/
{
    PUCHAR TraversePtr, EndOfBaseTable;
    UCHAR  CheckSum;

    // Walk the MPS table. The HAL MP information structure has
    // pointers to the first entry for each entry type in the MPS
    // table. Set these pointers.

    TraversePtr = (PUCHAR) MpTablePtr + HEADER_SIZE;
    EndOfBaseTable = (PUCHAR) MpTablePtr + MpTablePtr->TableLength;

    HalpMpInfoTable.ApicVersion =
    (ULONG) (((PPCMPPROCESSOR)(TraversePtr))->LocalApicVersion & 0xf0);

    while (TraversePtr < EndOfBaseTable)  {
        switch (*TraversePtr)  {
            case ENTRY_PROCESSOR:
                if(((PPCMPPROCESSOR)(TraversePtr))->CpuFlags & CPU_ENABLED) {
                    if (HalpMpInfoTable.ProcessorCount == 0) {
                        HalpMpInfoTable.ProcessorEntryPtr = 
                            (PPCMPPROCESSOR) TraversePtr;
                    }
                    HalpMpInfoTable.ProcessorCount++;
                }
                TraversePtr += sizeof(PCMPPROCESSOR);
                break;

            case ENTRY_BUS:
                if (HalpMpInfoTable.BusCount == 0)  {
                    HalpMpInfoTable.BusEntryPtr = (PPCMPBUS) TraversePtr;
                }
                HalpMpInfoTable.BusCount += 1;
                TraversePtr += sizeof(PCMPBUS);
                break;

            case ENTRY_IOAPIC:
                if ((((PPCMPIOAPIC)(TraversePtr))->IoApicFlag & 
                    IO_APIC_ENABLED) && (UserSpecifiedNoIoApic == 0)) {
                    if (HalpMpInfoTable.IOApicCount == 0)  {
                        HalpMpInfoTable.IoApicEntryPtr = 
                            (PPCMPIOAPIC) TraversePtr;
                    }
                    HalpMpInfoTable.IOApicCount += 1;
                }
                TraversePtr += sizeof(PCMPIOAPIC);
                break;

            case ENTRY_INTI:
                if (HalpMpInfoTable.IntiCount == 0)  {
                    HalpMpInfoTable.IntiEntryPtr = (PPCMPINTI) TraversePtr;
                }
                HalpMpInfoTable.IntiCount += 1;
                TraversePtr += sizeof(PCMPINTI);
                break;

            case ENTRY_LINTI:
                if (HalpMpInfoTable.LintiCount == 0)  {
                    HalpMpInfoTable.LintiEntryPtr = (PPCMPLINTI) TraversePtr;
                }
                HalpMpInfoTable.LintiCount += 1;
                TraversePtr += sizeof(PCMPLINTI);
                break;

            default:
                //
                // Unknown MPS entry. Since we don't know it's size, we will
                // terminate parsing here.
                //
                DBGMSG("HAL: Invalid MPS table entry type detected\n");
                TraversePtr = EndOfBaseTable;
                break;
        }  // switch
    } // while


    //
    // Check for Extension table defined
    //

    if (MpTablePtr->ExtTableLength  &&
        MpTablePtr->TableLength + MpTablePtr->ExtTableLength < 8192) {

        CheckSum = ComputeCheckSum(
                        (PUCHAR) MpTablePtr + MpTablePtr->TableLength,
                        MpTablePtr->ExtTableLength
                        );

        CheckSum += MpTablePtr->ExtTableChecksum;

        if (CheckSum != 0) {
            DBGMSG("HALMPS: InitMpInfo: Extension table checksum error\n");

        } else {
            HalpMpInfoTable.ExtensionTable = (PMPS_EXTENTRY)
                (((PUCHAR) MpTablePtr) + MpTablePtr->TableLength);

            HalpMpInfoTable.EndOfExtensionTable = (PMPS_EXTENTRY)
                (((PUCHAR) MpTablePtr) + MpTablePtr->TableLength +
                                        MpTablePtr->ExtTableLength);
        }
    }

    return;
}


ULONG
DetectMPS(
    OUT PBOOLEAN IsConfiguredMp
)

/*++

Routine Description:

   This function is called from HalInitializeProcessors to determine
   if this is an appropriate system to run the MPS hal on.

   The recommended detection mechanism is:

   if ( MPS information does not exist )
       then
           System is not MPS compliant. Return false.

   In MP table:
       if ( number IO APICs < 1 )
           then
               Not a MPS System - return false

       if ( # CPUs = 1 )
           then
               Found a Single Processor MPS System
           else
               Found a MP MPS System


    A side effect of this routine is the mapping of the IO UNits and
    Local unit virtual addresses.

   Return TRUE


 Arguments:

   IsConfiguredMp - TRUE if this machine is a MP instance of the MPS spec, else FALSE.

 Return Value:
   0 - if not a MPS
   1 - if MPS

*/
{

    UCHAR ApicVersion, i;
    PUCHAR  LocalApic;
    PPCMPIOAPIC IoEntryPtr;
    PHYSICAL_ADDRESS physicalAddress;

    //
    // Initialize MpInfo table
    //

    RtlZeroMemory (&HalpMpInfoTable, sizeof HalpMpInfoTable);

    //
    // Set the return Values to the default
    //

    *IsConfiguredMp = FALSE;

    //
    // See if there is a MP Table
    //

#if 1
    if ((PcMpTablePtr = GetPcMpTable()) == NULL) {
        FAILMSG (rgzNoMpsTable);
        return(FALSE);
    }
#else
    //********
    //******** HACK! To make down level 1.0 machine work
    //********

    if ((PcMpTablePtr = MPS10_GetPcMpTable()) == NULL) {
        FAILMSG (rgzNoMpsTable);
        return(FALSE);
    }
#endif

#ifdef SETUP
    // During setup, if we detected a default MPS configuration, we have
    // no more checking to do.
    if (PcMpTablePtr ==  (struct PcMpTable *) DEFAULT_MPS_INDICATOR)  {
        *IsConfiguredMp = TRUE;
        return(TRUE);
    }
#endif // SETUP

#if DEBUGGING
    HalpDisplayConfigTable();
#endif

    // We have a MPS table. Initialize a HAL specific MP information
    // structure that gets information from the MPS table.

    HalpInitMpInfo(PcMpTablePtr);


    // Verify the information in the MPS table as best as we can.

    if (HalpMpInfoTable.IOApicCount == 0) {
        //
        //  Someone Has a MP Table and no IO Units -- Weird
        //  We have to assume the BIOS knew what it was doing
        //  when it built the table.  so ..
        //
        FAILMSG (rgzNoApic);
        return (FALSE);
    }

    //
    //  It's a MPS System.  It could be a UP System though.
    //

#ifdef SETUP
    //
    // If this is a MPS (MPS) compliant system, but has only 1 processor,
    // for now we want to install a standard UP kernel and HAL.
    //

    if (HalpMpInfoTable.ProcessorCount <= 1) {
        return FALSE;
    }
#endif

    if (HalpMpInfoTable.ProcessorCount > 1) {
        *IsConfiguredMp = TRUE;
    }

    HalpMpInfoTable.LocalApicBase = (ULONG) PcMpTablePtr->LocalApicAddress;
    physicalAddress.QuadPart = HalpMpInfoTable.LocalApicBase;
    LocalApic = (PUCHAR) HalpMapPhysicalMemoryWriteThrough64(
                            physicalAddress,1);

    if (!LocalApic) {
        FAILMSG (rgzNoMem);
        return (FALSE);
    }

#ifndef SETUP
    HalpRemapVirtualAddress64 (
        (PVOID) LOCALAPIC,
        physicalAddress,
        TRUE
        );
#endif

    ApicVersion = (UCHAR) *(LocalApic + LU_VERS_REGISTER);

    if (ApicVersion > 0x1f) {
        //
        //  Only known Apics are 82489dx with version 0.x and
        //  Embedded Apics with version 1.x (where x is don't care)
        //
        //  Return of 0xFF?   Can't have an MPS system without a Local Unit.
        //

#ifdef DEBUGGING
        sprintf(Cbuf, "HALMPS: apic version %x, read from %x\n",
            ApicVersion, LocalApic + LU_VERS_REGISTER);

        HalDisplayString(Cbuf);
#endif

        FAILMSG (rgzBadApicVersion);
        return (FALSE);
    }

#ifdef SETUP
    //
    // MP MPS table, and the local APIC ID looked OK.
    //

    return TRUE;
#endif  //SETUP


#ifdef DEBUGGING
    if ((ApicVersion & 0xf0) == 0) {
        if (HalpMpInfoTable.ApicVersion != APIC_82489DX)
        HalDisplayString("HAL:Invalid Local Apic version in MP table\n");
        else {
            sprintf(Cbuf, "HAL: DetectMPS: Found 82489DX Local APIC (Ver 0x%x) at 0x%lx\n",
                    ApicVersion, LocalApic);
            HalDisplayString(Cbuf);
        }
    } else {
        sprintf(Cbuf, "HAL: DetectMPS: Found Embedded Local APIC (Ver 0x%x) at 0x%lx\n",
                ApicVersion, LocalApic);
        HalDisplayString(Cbuf);

    }
#endif // DEBUGGING

#ifndef SETUP
    HalpUnmapVirtualAddress(LocalApic,1);
#endif

    IoEntryPtr = HalpMpInfoTable.IoApicEntryPtr;

    for(i=0; i < HalpMpInfoTable.IOApicCount; i++, IoEntryPtr++)
    {
        if (IoEntryPtr->IoApicFlag & IO_APIC_ENABLED) {
            //
            //  Verify the existance of the IO Units
            //

            physicalAddress.QuadPart = (ULONG)IoEntryPtr->IoApicAddress;
            HalpMpInfoTable.IoApicPhys[i] = (ULONG)IoEntryPtr->IoApicAddress;
            HalpMpInfoTable.IoApicBase[i] = (PULONG)
                HalpMapPhysicalMemoryWriteThrough64(physicalAddress, 1);

            //
            //  Verify the existance of the IO Unit
            //

            if (!(HalpVerifyIOUnit((PUCHAR)HalpMpInfoTable.IoApicBase[i]))) {
                FAILMSG (rgzApicNotVerified);
                return (FALSE);
            }
        }
    }

    DBGMSG("HAL: DetectMPS: MPS system found - Returning TRUE\n");
    return(TRUE);
}


ULONG
DetectUPMPS(
    OUT PBOOLEAN IsConfiguredMp
)
/*++

Routine Description:

   This function is called by setup after DetectMPS has returned
   false.  During setup time DetectMPS will return false, if the
   machine is an MPS system, but only has one processor.   This
   function is used to detect such a machine at setup time.

 Arguments:

   IsConfiguredMp - FALSE

 Return Value:
   0 - if not a UP MPS
   1 - if UP MPS

--*/
{
    *IsConfiguredMp = FALSE;

    // we assume the caller has already called DetectMPS, and the
    // MPS table has already been parsed.

    return (HalpMpInfoTable.ProcessorCount == 1 ? TRUE : FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\mphibrnt.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    mphibrnt.c

Abstract:

    This file provides the code that changes the system from
        the ACPI S0 (running) state to S4 (hibernated).

Author:

    Jake Oshins (jakeo) May 6, 1997

Revision History:

--*/

#include "halp.h"
#include "apic.inc"
#include "pcmp_nt.inc"
#include "ixsleep.h"

NTSTATUS
HaliLegacyHibernate(
    IN PVOID                        Context,
    IN PENTER_STATE_SYSTEM_HANDLER  SystemHandler   OPTIONAL,
    IN PVOID                        SystemContext,
    IN LONG                         NumberProcessors,
    IN volatile PLONG               Number
    );

ULONG
DetectMPS (
    OUT PBOOLEAN IsConfiguredMp
    );

volatile extern BOOLEAN HalpHiberInProgress;
extern BOOLEAN HalpDisableHibernate;
extern UCHAR   HalpLastEnumeratedActualProcessor;

struct PcMpTable *PcMpTablePtr;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, HalpRegisterHibernate)
#pragma alloc_text(PAGELK, HaliLegacyHibernate)
#endif


VOID
HalpRegisterHibernate(
    VOID
    )
/*++
Routine Description:

    This function registers a hibernation handler (for
    state S4) with the Policy Manager.
    
Arguments:

--*/
{
    POWER_STATE_HANDLER powerState;
    OBJECT_ATTRIBUTES   objAttributes;
    PCALLBACK_OBJECT    callback;
    UNICODE_STRING      callbackName;
    
    PAGED_CODE();

    //
    // Register callback that tells us to make
    // anything we need for sleeping non-pageable.
    //
    
    RtlInitUnicodeString(&callbackName, L"\\Callback\\PowerState");

    InitializeObjectAttributes(
        &objAttributes,
        &callbackName,
        OBJ_CASE_INSENSITIVE | OBJ_PERMANENT,
        NULL,
        NULL
        );
    
    ExCreateCallback(&callback,
                     &objAttributes,
                     FALSE,
                     TRUE);
    
    ExRegisterCallback(callback,
                       (PCALLBACK_FUNCTION)&HalpPowerStateCallback,
                       NULL);

    if (HalpDisableHibernate == FALSE) {
        
        //
        // Register the hibernation handler.
        //
    
        powerState.Type = PowerStateSleeping4;
        powerState.RtcWake = FALSE;
        powerState.Handler = &HaliLegacyHibernate;
        powerState.Context = 0;
        
        ZwPowerInformation(SystemPowerStateHandler,
                           &powerState,
                           sizeof(POWER_STATE_HANDLER),
                           NULL,
                           0);
    }
}

NTSTATUS
HaliLegacyHibernate (
    IN PVOID                        Context,
    IN PENTER_STATE_SYSTEM_HANDLER  SystemHandler   OPTIONAL,
    IN PVOID                        SystemContext,
    IN LONG                         NumberProcessors,
    IN volatile PLONG               Number
    )
/*++
Routine Description:

    This function is called to hibernate legacy PCs.  It saves
    hardware state and waits here for the user to power off the system.
    
Arguments:

    
--*/
{
    volatile ULONG ThisProcessor;
    static volatile ULONG Barrier = 0;
    LONG ii;
    KIRQL oldIrql, dummyIrql;
    LOADER_PARAMETER_BLOCK LoaderBlock;
    KPRCB Prcb;
    NTSTATUS status = STATUS_SUCCESS;
    BOOLEAN IsMpSystem;
    KAFFINITY SavedActiveProcessors;
    extern ULONG HalpProfileRunning;

    ASSERT(SystemHandler);

    ThisProcessor = KeGetPcr()->Prcb->Number;
    
    if (ThisProcessor == 0) {
        
        HalpHiberInProgress = TRUE;
        
        if ((NumberProcessors > 1) &&
            (HalpHiberProcState == NULL)) {
            
            //
            // We could not allocate memory to save processor state.
            //
            
            HalpHiberInProgress = FALSE;
        }
    }
    
    oldIrql = KeGetCurrentIrql();
    
    //
    // Wait for all processors to arrive here.
    //

    InterlockedDecrement(Number);
    while (*Number != 0);

    if (!HalpHiberInProgress)  {
    
        //
        // We could not allocate memory to save processor state.
        //

        return(STATUS_INSUFFICIENT_RESOURCES);
    }


    //
    // Save non-boot processor state
    //
    
    if (ThisProcessor != 0)  {

        //
        // Save processor state and wait here.
        // N.B. We wait here rather than returning to the kernel because
        // the stack pointer in the saved processor context points to the
        // current stack and we want to resume execution in this routine
        // with our current stack.
        //

        HalpSaveProcessorStateAndWait(&HalpHiberProcState[ThisProcessor],
                                      (PULONG)&Barrier);

        //
        // Barrier will be 0 when we return from this function before 
        // hibernating.  It will non-zero the second time this
        // function returns.
        //
        // N.B.  The non-boot processors will spin in HalpSaveProcessorState
        //       until Barrier is zeroed.
        //

        if (Barrier == 0) {
            return STATUS_DEVICE_DOES_NOT_EXIST;
        } else {
            goto HalpPnHiberResume;
        }
    }

    //
    // Save motherboard state.
    //

    HalpSaveDmaControllerState();

    //
    // Wait for all the non-boot procs to finish saving state.
    //
    
    while (Barrier != (ULONG)NumberProcessors - 1);

    //
    // Change HAL's picture of the world to single processor while
    // the hibernate file is written.
    //

    SavedActiveProcessors = HalpActiveProcessors;
    HalpActiveProcessors = KeGetCurrentPrcb()->SetMember;

    //
    // If there's a system handler, invoke it.  The system handler will
    // write the hibernation file to disk
    //

    if (SystemHandler) {
        status = SystemHandler(SystemContext);
    }

    //
    // Hibernation is over. Boot processor gets control here. The
    // non boot processors are in the state that BIOS left them.
    //

    HalpActiveProcessors = SavedActiveProcessors;
    Barrier = 0;

    //
    // If this returns success, then the system is now effectively
    // hibernated. On the other hand, if this function returns something other
    // than success, then it means that we have just un-hibernated,
    // so restore state.
    //


    if ((status == STATUS_SUCCESS) ||
        (status == STATUS_DEVICE_DOES_NOT_EXIST)) {
        
        return STATUS_DEVICE_DOES_NOT_EXIST;
    }

    //
    // If you are remapping local apic, io apic and MPS table 
    // resources, you first have to unmap the current resources!!!
    // The BIOS may have created the MPS table at a different place or may
    // have changed values like processor local APIC IDs. Reparse it.
    //

    HalpUnMapIOApics();
    HalpUnMapPhysicalRange(PcMpTablePtr, 
                           (PcMpTablePtr->TableLength + PcMpTablePtr->ExtTableLength));
    DetectMPS(&IsMpSystem);
    HalpMpInfoTable.NtProcessors = NumberProcessors;
    HalpIpiClock = 0;
    RtlZeroMemory(&LoaderBlock, sizeof(LoaderBlock));
    RtlZeroMemory(&Prcb, sizeof(Prcb));
    LoaderBlock.Prcb = (ULONG) &Prcb;

    //
    // Reset Processor enumeration (so it starts at the beginning).
    //

    HalpLastEnumeratedActualProcessor = 0;

    //
    // Initialize minimum global hardware state needed.
    //

    HalpInitializeIOUnits();
    HalpInitializePICs(FALSE);

    //
    // Restore DMA controller state
    //

    HalpRestoreDmaControllerState();

    //
    // Initialize boot processor's local APIC so it can wake other processors
    //

    HalpInitializeLocalUnit ();
    KeRaiseIrql(HIGH_LEVEL, &dummyIrql);

    // 
    // Wake up the other processors
    //

    for(ii = 1; ii < NumberProcessors; ++ii)  {

        // Set processor number in dummy loader parameter block

        Prcb.Number = (UCHAR) ii;
        CurTiledCr3LowPart = HalpTiledCr3Addresses[ii].LowPart;
        if (!HalStartNextProcessor(&LoaderBlock, &HalpHiberProcState[ii]))  {

            //
            // We could not start a processor. This is a fatal error but
            // don't bail out yet until you try the remaining processors.
            //

            DBGMSG("HAL: Cannot start processor after hibernate resume\n");
        }
    }

HalpPnHiberResume:
    
    //
    // Finish up all the MP stuff that happens across multiple
    // HALs.
    //

    HalpPostSleepMP(NumberProcessors, Number);

    if (KeGetPcr()->Prcb->Number == 0)  {
        
        //
        // Restore the IO APIC state
        //
        
        HalpRestoreIoApicRedirTable();

        if (HalpProfileRunning == 1) {
            HalStartProfileInterrupt(0);
        }

    }

    KfLowerIrql(oldIrql);

    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\mpinfo.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ixinfo.c

Abstract:

Author:

    Ken Reneris (kenr)  08-Aug-1994

Environment:

    Kernel mode only.

Revision History:

--*/


#include "halp.h"
#include "pcmp_nt.inc"


extern ULONG  HalpPerfInterruptHandler;
static HANDLE HalpProcessId = NULL;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE,HalpSetSystemInformation)
#endif


NTSTATUS
HalpSetSystemInformation (
    IN HAL_SET_INFORMATION_CLASS    InformationClass,
    IN ULONG     BufferSize,
    IN PVOID     Buffer
    )
{
    PAGED_CODE();

    switch (InformationClass) {
        case HalProfileSourceInterruptHandler:

            //
            // Set ISR handler for PerfVector
            //

            if (!(HalpFeatureBits & HAL_PERF_EVENTS)) {
                return STATUS_UNSUCCESSFUL;
            }
            
            //
            // Accept the interrupt handler if no other process
            // has already hooked the interrupt or if we are in
            // the context of the process that already hooked it.
            //

            if (HalpProcessId == NULL) {
                HalpPerfInterruptHandler = *((PULONG) Buffer);
                if (HalpPerfInterruptHandler != 0) {
                    HalpProcessId = PsGetCurrentProcessId();
                }
            } else if (HalpProcessId == PsGetCurrentProcessId()) {
                HalpPerfInterruptHandler = *((PULONG) Buffer);
                if (HalpPerfInterruptHandler == 0) {
                    HalpProcessId = NULL;
                }
            } else {
                return STATUS_UNSUCCESSFUL;
            }
            return STATUS_SUCCESS;
    }

    return HaliSetSystemInformation (InformationClass, BufferSize, Buffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\mpirql.asm ===
title  "Irql Processing"
;++
;
; Copyright (c) 1989  Microsoft Corporation
; Copyright (c) 1992  Intel Corporation
; All rights reserved
;
; INTEL CORPORATION PROPRIETARY INFORMATION
;
; This software is supplied to Microsoft under the terms
; of a license agreement with Intel Corporation and may not be
; copied nor disclosed except in accordance with the terms
; of that agreement.
;
;
; Module Name:
;
;    mpirql.asm
;
; Abstract:
;
;    This module implements the mechanism for raising and lowering IRQL
;    and dispatching software interrupts for PC+MP compatible systems
;
; Author:
;
;    Shie-Lin Tzong (shielint) 8-Jan-1990
;
; Environment:
;
;    Kernel mode only.
;
; Revision History:
;
;    Ron Mosgrove (Intel) Sept 1993
;        Modified for PC+MP
;
;--

.386p
        .xlist
include hal386.inc
include callconv.inc                ; calling convention macros
include mac386.inc
include apic.inc
include ntapic.inc
include i386\kimacro.inc
        .list

        EXTRNP  _KeBugCheck,1,IMPORT

_DATA   SEGMENT  DWORD PUBLIC 'DATA'

        align   dword

;
; Global8259Mask is used to avoid reading the PIC to get the current
; interrupt mask; format is the same as for SET_8259_MASK, i.e.,
; bits 7:0 -> PIC1, 15:8 -> PIC2
;
        public  _HalpGlobal8259Mask
_HalpGlobal8259Mask     dw      0

_DATA ends

_TEXT   SEGMENT  DWORD PUBLIC 'DATA'

;
; IOunitRedirectionTable is the memory image of the redirection table to be
; loaded into APIC I/O unit 0 at initialization.  there is one 64-bit entry
; per interrupt input to the I/O unit.  the edge/level trigger mode bit will
; be set dynamically when the table is actually loaded.  the mask bit is set
; initially, and reset by EnableSystemInterrupt.
;

;
; _HalpIRQLtoTPR maps IRQL to an APIC TPR register value
;
                align   dword
                public  _HalpIRQLtoTPR
_HalpIRQLtoTPR  label   byte
                db      ZERO_VECTOR             ; IRQL 0
                db      APC_VECTOR              ; IRQL 1
                db      DPC_VECTOR              ; IRQL 2
                db      DPC_VECTOR              ; IRQL 3
                db      DEVICE_LEVEL1           ; IRQL 4
                db      DEVICE_LEVEL2           ; IRQL 5
                db      DEVICE_LEVEL3           ; IRQL 6
                db      DEVICE_LEVEL4           ; IRQL 7
                db      DEVICE_LEVEL5           ; IRQL 8
                db      DEVICE_LEVEL6           ; IRQL 9
                db      DEVICE_LEVEL7           ; IRQL 10
                db      DEVICE_LEVEL7           ; IRQL 11
                db      DEVICE_LEVEL7           ; IRQL 12
                db      DEVICE_LEVEL7           ; IRQL 13
                db      DEVICE_LEVEL7           ; IRQL 14
                db      DEVICE_LEVEL7           ; IRQL 15
                db      DEVICE_LEVEL7           ; IRQL 16
                db      DEVICE_LEVEL7           ; IRQL 17
                db      DEVICE_LEVEL7           ; IRQL 18
                db      DEVICE_LEVEL7           ; IRQL 19
                db      DEVICE_LEVEL7           ; IRQL 20
                db      DEVICE_LEVEL7           ; IRQL 21
                db      DEVICE_LEVEL7           ; IRQL 22
                db      DEVICE_LEVEL7           ; IRQL 23
                db      DEVICE_LEVEL7           ; IRQL 24
                db      DEVICE_LEVEL7           ; IRQL 25
                db      DEVICE_LEVEL7           ; IRQL 26
                db      APIC_GENERIC_VECTOR     ; IRQL 27
                db      APIC_CLOCK_VECTOR       ; IRQL 28
                db      APIC_IPI_VECTOR         ; IRQL 29
                db      POWERFAIL_VECTOR        ; IRQL 30
                db      NMI_VECTOR              ; IRQL 31

_TEXT ends

_DATA   SEGMENT  DWORD PUBLIC 'DATA'

;
; VECTOR_MAP_ENTRY macro generates sparse table required for APIC vectors
;

VECTOR_MAP_ENTRY    macro   vector_number, apic_inti
            current_entry = $ - _HalpVectorToINTI
            entry_count = vector_number - current_entry
                REPT    entry_count
                dw      0ffffh
                ENDM
            dw      apic_inti

            endm

;
; _HalpVectorToINTI maps interrupt vector to EISA interrupt level
; (APIC INTI input);
; NOTE:  this table must ordered by ascending vector numbers
; also note that there is no entry for unused INTI13.
;

                align   dword
                public  _HalpVectorToINTI
_HalpVectorToINTI       label   word
        VECTOR_MAP_ENTRY      NMI_VECTOR, 0FFFFh
        VECTOR_MAP_ENTRY      (1+MAX_NODES)*100h-1, 0FFFFh      ; End of Table

;
; _HalpVectorToIRQL maps interrupt vector to NT IRQLs
; NOTE:  this table must ordered by ascending vector numbers
;

VECTORTOIRQL_ENTRY    macro   idt_entry, irql
            current_entry = $ - _HalpVectorToIRQL
            priority_number = (idt_entry/16)
            entry_count = priority_number - current_entry
                REPT    entry_count
                db      0FFh
                ENDM
            db      irql

            endm

                align   dword
                public  _HalpVectorToIRQL
_HalpVectorToIRQL       label   byte
        VECTORTOIRQL_ENTRY    ZERO_VECTOR,         0 ; placeholder
        VECTORTOIRQL_ENTRY    APC_VECTOR,          APC_LEVEL
        VECTORTOIRQL_ENTRY    DPC_VECTOR,          DISPATCH_LEVEL
        VECTORTOIRQL_ENTRY    APIC_GENERIC_VECTOR, PROFILE_LEVEL
        VECTORTOIRQL_ENTRY    APIC_CLOCK_VECTOR,   CLOCK1_LEVEL
        VECTORTOIRQL_ENTRY    APIC_IPI_VECTOR,     IPI_LEVEL
        VECTORTOIRQL_ENTRY    POWERFAIL_VECTOR,    POWER_LEVEL

_DATA   ENDS

        page ,132
        subttl  "Raise Irql"

_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING
;++
;
; KIRQL
; FASTCALL
; KfRaiseIrql (
;    IN KIRQL NewIrql
;    )
;
; Routine Description:
;
;    This routine is used to raise IRQL to the specified value.
;    The APIC TPR is used to block all lower-priority HW interrupts.
;
; Arguments:
;
;    (cl) = NewIrql - the new irql to be raised to
;
;
; Return Value:
;
;    OldIrql - the addr of a variable which old irql should be stored
;
;--

cPublicFastCall KfRaiseIrql,1
cPublicFpo 0,0

        movzx   edx, cl                         ; (edx) = New Irql
        movzx   ecx, byte ptr _HalpIRQLtoTPR[edx] ; get TPR value for IRQL
        mov     eax, dword ptr APIC[LU_TPR]     ; (eax) = Old Priority
        mov     dword ptr APIC[LU_TPR], ecx     ; Write New Priority to the TPR

;
; get IRQL for Old Priority, and return it
;
        shr     eax, 4
        movzx   eax, _HalpVectorToIRQL[eax]   ; (al) = OldIrql
        fstRET  KfRaiseIrql

fstENDP KfRaiseIrql


;++
;
; VOID
; KIRQL
; KeRaiseIrqlToDpcLevel (
;    )
;
; Routine Description:
;
;    This routine is used to raise IRQL to DPC level.
;    The APIC TPR is used to block all lower-priority HW interrupts.
;
; Arguments:
;
; Return Value:
;
;    OldIrql - the addr of a variable which old irql should be stored
;
;--

cPublicProc _KeRaiseIrqlToDpcLevel,0
cPublicFpo 0, 0

        mov     edx, dword ptr APIC[LU_TPR]         ; (ecx) = Old Priority
        mov     dword ptr APIC[LU_TPR], DPC_VECTOR  ; Set New Priority
        shr     edx, 4
        movzx   eax, _HalpVectorToIRQL[edx]         ; (al) = OldIrql
        stdRET  _KeRaiseIrqlToDpcLevel

stdENDP _KeRaiseIrqlToDpcLevel


;++
;
; VOID
; KIRQL
; KeRaiseIrqlToSyncLevel (
;    )
;
; Routine Description:
;
;    This routine is used to raise IRQL to SYNC level.
;    The APIC TPR is used to block all lower-priority HW interrupts.
;
; Arguments:
;
; Return Value:
;
;    OldIrql - the addr of a variable which old irql should be stored
;
;--

cPublicProc _KeRaiseIrqlToSynchLevel,0
cPublicFpo 0, 0

        mov     edx, dword ptr APIC[LU_TPR]     ; (ecx) = Old Priority
        mov     dword ptr APIC[LU_TPR], APIC_SYNCH_VECTOR ; Write New Priority

        shr     edx, 4
        movzx   eax, _HalpVectorToIRQL[edx]     ; (al) = OldIrql
        stdRET  _KeRaiseIrqlToSynchLevel

stdENDP _KeRaiseIrqlToSynchLevel


        page ,132
        subttl  "Lower irql"
;++
;
; VOID
; FASTCALL
; KfLowerIrql (
;    IN KIRQL NewIrql
;    )
;
; Routine Description:
;
;    This routine is used to lower IRQL to the specified value.
;    The IRQL and PIRQL will be updated accordingly.
;
; Arguments:
;
;    (cl) = NewIrql - the new irql to be set.
;
; Return Value:
;
;    None.
;
;--

; equates for accessing arguments
;

cPublicFastCall KfLowerIrql    ,1
cPublicFpo 0,0

        xor     eax, eax
        mov     al, cl              ; get new irql value

if DBG
;
; Make sure we are not lowering to ABOVE current level
;

        mov     ecx, dword ptr APIC[LU_TPR]     ; (ebx) = Old Priority
        shr     ecx, 4
        movzx   ecx, _HalpVectorToIRQL[ecx]     ; get IRQL for Old Priority
        cmp     al, cl
        jbe     short KliDbg
        push    ecx                             ; new irql for debugging
        push    eax                             ; old irql for debugging
        stdCall   _KeBugCheck, <IRQL_NOT_LESS_OR_EQUAL>
KliDbg:
endif
        xor     ecx, ecx                        ; Avoid a partial stall
        mov     cl, _HalpIRQLtoTPR[eax]         ; get TPR value corresponding to IRQL
        mov     dword ptr APIC[LU_TPR], ecx

;
; We have to ensure that the requested priority is set before
; we return.  The caller is counting on it.
;
        mov     eax, dword ptr APIC[LU_TPR]

if DBG
        cmp     ecx, eax                        ; Verify IRQL read back is same as
        je      short @f                        ; set value
        int 3
@@:
endif
        fstRET  KfLowerIrql
fstENDP KfLowerIrql

        page ,132
        subttl  "Get current irql"
;++
;
; KIRQL
; KeGetCurrentIrql (VOID)
;
; Routine Description:
;
;    This routine returns to current IRQL.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    The current IRQL.
;
;--

cPublicProc _KeGetCurrentIrql   ,0

        mov     eax, dword ptr APIC[LU_TPR]     ; (eax) = Old Priority
        shr     eax, 4
        movzx   eax, _HalpVectorToIRQL[eax]     ; get IRQL for Old Priority
        stdRET    _KeGetCurrentIrql

stdENDP _KeGetCurrentIrql



;++
;
; KIRQL
; HalpDisableAllInterrupts (VOID)
;
; Routine Description:
;
;   This routine is called during a system crash.  The hal needs all
;   interrupts disabled.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    Old IRQL value.
;
;--

cPublicProc _HalpDisableAllInterrupts,0

    ;
    ; Raising to HIGH_LEVEL
    ;

        mov     ecx, HIGH_LEVEL
        fstCall KfRaiseIrql
        stdRET  _HalpDisableAllInterrupts

stdENDP _HalpDisableAllInterrupts

;++
;
; VOID
; HalpReenableInterrupts (
;     IN KIRQL Irql
;     )
;
; Routine Description:
;
;   Restores irql level.
;
; Arguments:
;
;    Irql - Irql state to restore to.
;
; Return Value:
;
;    None
;
;--

HriNewIrql      equ     [esp + 4]

cPublicProc _HalpReenableInterrupts,1
cPublicFpo 1, 0

        movzx   ecx, byte ptr HriNewIrql
        fstCall KfLowerIrql

        stdRET  _HalpReenableInterrupts

stdENDP _HalpReenableInterrupts

_TEXT   ends

PAGELK  SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING

;
; PIC initialization command strings - first word is port to write to,
; followed by bytes of Initialization Control Words (ICWs) and Operation
; Control Words (OCWs).  Last string is zero-terminated.
;

PICsInitializationString   label    byte
;
; Master PIC initialization commands
;
                dw      PIC1_PORT0
                db      ICW1_ICW + ICW1_EDGE_TRIG + ICW1_INTERVAL8 + \
                        ICW1_CASCADE + ICW1_ICW4_NEEDED
                db      PIC1_BASE
                db      1 SHL PIC_SLAVE_IRQ
                db      ICW4_NOT_SPEC_FULLY_NESTED + \
                        ICW4_NON_BUF_MODE + \
                        ICW4_NORM_EOI + \
                        ICW4_8086_MODE
PIC1InitMask    db      0FFh            ; OCW1 - mask all inputs
;
; Slave PIC initialization commands
;
                dw      PIC2_PORT0
                db      ICW1_ICW + ICW1_EDGE_TRIG + ICW1_INTERVAL8 + \
                        ICW1_CASCADE + ICW1_ICW4_NEEDED
                db      PIC2_BASE
                db      PIC_SLAVE_IRQ
                db      ICW4_NOT_SPEC_FULLY_NESTED + \
                        ICW4_NON_BUF_MODE + \
                        ICW4_NORM_EOI + \
                        ICW4_8086_MODE
PIC2InitMask    db      0FFh            ; OCW1 - mask all inputs
                dw      0               ; end of string


        page ,132
        subttl  "Interrupt Controller Chip Initialization"
;++
;
; VOID
; HalpInitializePICs (
;    BOOLEAN EnableInterrupts
;    )
;
; Routine Description:
;
;    This routine initializes the interrupt structures for the 8259A PIC.
;
; Context:
;
;    This procedure is executed by CPU 0 during Phase 0 initialization.
;
; Arguments:
;
;    None
;
; Return Value:
;
;    None.
;
;--
EnableInterrupts equ [esp + 0ch]

cPublicProc _HalpInitializePICs       ,1

        push    esi                             ; save caller's esi
        pushfd
        cli                                     ; disable interrupt

        lea     esi, PICsInitializationString
        lodsw                                   ; (AX) = PIC port 0 address
Hip10:  movzx   edx, ax
        outsb                                   ; output ICW1
        IODelay
        inc     edx                             ; (DX) = PIC port 1 address
        outsb                                   ; output ICW2
        IODelay
        outsb                                   ; output ICW3
        IODelay
        outsb                                   ; output ICW4
        IODelay
        outsb                                   ; output OCW1 (mask register)
        IODelay
        lodsw
        cmp     ax, 0                           ; end of init string?
        jne     short Hip10                     ; go init next PIC

        mov     al, PIC2InitMask                ; save the initial mask in
        shl     ax, 8                           ; mask in global variable
        mov     al, PIC1InitMask
        mov     _HalpGlobal8259Mask, ax

        mov     al, EnableInterrupts
        .if     (al != 0)
        or      [esp], EFLAGS_INTERRUPT_MASK    ; enable interrupts
        .endif
        popfd
        pop     esi                             ; restore caller's esi
        stdRET    _HalpInitializePICs
stdENDP _HalpInitializePICs

PAGELK  ends
       end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\mphal.c ===
/*++

Copyright (c) 1991  Microsoft Corporation
Copyright (c) 1992  Intel Corporation
All rights reserved

INTEL CORPORATION PROPRIETARY INFORMATION

This software is supplied to Microsoft under the terms
of a license agreement with Intel Corporation and may not be
copied nor disclosed except in accordance with the terms
of that agreement.

Module Name:

    mphal.c

Abstract:


    This module implements the initialization of the system dependent
    functions that define the Hardware Architecture Layer (HAL) for a
    PC+MP system.

Author:

    David N. Cutler (davec) 25-Apr-1991

Environment:

    Kernel mode only.

Revision History:

    Ron Mosgrove (Intel) - Modified to support the PC+MP Spec
    Jake Oshins (jakeo)  - Modified to support the ACPI Spec

*/

#include "halp.h"
#include "pcmp_nt.inc"
#include "string.h"
#include "stdlib.h"
#include "stdio.h"

ULONG HalpBusType;

extern ADDRESS_USAGE HalpDefaultPcIoSpace;
extern ADDRESS_USAGE HalpEisaIoSpace;
extern ADDRESS_USAGE HalpImcrIoSpace;
extern struct HalpMpInfo HalpMpInfoTable;
extern UCHAR rgzRTCNotFound[];
extern USHORT HalpVectorToINTI[];
extern UCHAR HalpGenuineIntel[];
extern const UCHAR HalName[];
extern BOOLEAN HalpDoingCrashDump;

extern PULONG KiEnableTimerWatchdog;
extern ULONG HalpTimerWatchdogEnabled;
extern PCHAR HalpTimerWatchdogStorage;
extern PVOID HalpTimerWatchdogCurFrame;
extern PVOID HalpTimerWatchdogLastFrame;
extern ULONG HalpTimerWatchdogStorageOverflow;

extern KSPIN_LOCK HalpDmaAdapterListLock;
extern LIST_ENTRY HalpDmaAdapterList;
extern ULONG HalpProc0TSCHz;

#ifdef ACPI_HAL
extern ULONG HalpPicVectorRedirect[];
#define ADJUSTED_VECTOR(x)  \
            HalpPicVectorRedirect[x]
#else
#define ADJUSTED_VECTOR(x) x
#endif

VOID
HalpInitMP(
    IN ULONG Phase,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );


KSPIN_LOCK HalpSystemHardwareLock;

VOID
HalpInitBusHandlers (
    VOID
    );

VOID
HalpClockInterruptPn(
    VOID
    );

VOID
HalpClockInterruptStub(
    VOID
    );

BOOLEAN
HalpmmTimer(
    VOID
    );

VOID
HalpmmTimerClockInit(
    VOID
    );

VOID
HalpmmTimerClockInterruptStub(
    VOID
    );

ULONG
HalpScaleTimers(
    VOID
    );

BOOLEAN
HalpPmTimerScaleTimers(
    VOID
    );

VOID
HalpApicRebootService(
    VOID
    );

VOID
HalpBroadcastCallService(
    VOID
    );

VOID
HalpDispatchInterrupt(
    VOID
    );

VOID
HalpApcInterrupt(
    VOID
    );

VOID
HalpIpiHandler(
    VOID
    );

VOID
HalpInitializeIOUnits (
    VOID
    );

VOID
HalpInitIntiInfo (
    VOID
    );

VOID
HalpGetParameters (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    );

VOID
HalpInitializeTimerResolution (
    ULONG Rate
    );

ULONG
HalpGetFeatureBits (
    VOID
    );

VOID
HalpInitializeApicAddressing(
    UCHAR Number
    );

VOID
HalpInitReservedPages(
    VOID
    );

VOID
HalpAcpiTimerPerfCountHack(
    VOID
    );

BOOLEAN
HalpFindBusAddressTranslation(
    IN PHYSICAL_ADDRESS BusAddress,
    IN OUT PULONG AddressSpace,
    OUT PPHYSICAL_ADDRESS TranslatedAddress,
    IN OUT PULONG_PTR Context,
    IN BOOLEAN NextBus
    );

#ifdef DEBUGGING
extern void HalpDisplayLocalUnit(void);
extern void HalpDisplayConfigTable(void);
extern void HalpDisplayExtConfigTable(void);
#endif // DEBUGGING

BOOLEAN         HalpStaticIntAffinity = FALSE;

BOOLEAN         HalpClockMode = Latched;

UCHAR           HalpMaxProcsPerCluster = 0;

extern BOOLEAN  HalpUse8254;
extern UCHAR    HalpSzInterruptAffinity[];
extern BOOLEAN  HalpPciLockSettings;
extern UCHAR    HalpVectorToIRQL[];
extern ULONG    HalpDontStartProcessors;
extern UCHAR    HalpSzOneCpu[];
extern UCHAR    HalpSzNoIoApic[];
extern UCHAR    HalpSzBreak[];
extern UCHAR    HalpSzPciLock[];
extern UCHAR    HalpSzTimerRes[];
extern UCHAR    HalpSzClockLevel[];
extern UCHAR    HalpSzUse8254[];
extern UCHAR    HalpSzForceClusterMode[];

ULONG UserSpecifiedCpuCount = 0;
KSPIN_LOCK  HalpAccountingLock;

#ifdef ACPI_HAL
extern KEVENT   HalpNewAdapter;
#endif

#ifdef ALLOC_PRAGMA
VOID
HalpInitTimerWatchdog(
    IN ULONG Phase
    );
#pragma alloc_text(INIT,HalpGetParameters)
#pragma alloc_text(INIT,HalpInitTimerWatchdog)
#pragma alloc_text(INIT,HalInitSystem)
#pragma alloc_text(INIT,HalpGetFeatureBits)
#endif // ALLOC_PRAGMA

#ifndef NT_UP
KIRQL
FASTCALL
KeAcquireSpinLockRaiseToSynchMCE(
    IN PKSPIN_LOCK SpinLock
    );

KIRQL
FASTCALL
KeAcquireSpinLockRaiseToSynch (
    IN PKSPIN_LOCK SpinLock
    );
#endif

//
// Define bug check callback record.
//

KBUGCHECK_CALLBACK_RECORD HalpCallbackRecord;


VOID
HalpBugCheckCallback (
    IN PVOID Buffer,
    IN ULONG Length
    )

/*++

Routine Description:

    This function is called when a bug check occurs. Its function is
    to perform anything the HAL needs done as the system bugchecks.

Arguments: (Unused in this callback).

    Buffer - Supplies a pointer to the bug check buffer.
    Length - Supplies the length of the bug check buffer in bytes.

Return Value:

    None.

--*/

{

    //
    // Make sure the HAL won't spin waiting on other processors
    // during a crashdump.
    //

    HalpDoingCrashDump = TRUE;
}

VOID
HalpGetParameters (
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )
/*++

Routine Description:

    This gets any parameters from the boot.ini invocation line.

Arguments:

    None.

Return Value:

    None

--*/
{
    PCHAR       Options;
    PCHAR       p;

    if (LoaderBlock != NULL  &&  LoaderBlock->LoadOptions != NULL) {

        Options = LoaderBlock->LoadOptions;

        //
        //  Has the user set the debug flag?
        //
        //
        //  Has the user requested a particular number of CPU's?
        //

        if (strstr(Options, HalpSzOneCpu)) {
            HalpDontStartProcessors++;
        }

        //
        // Check if PCI settings are locked down
        //

        if (strstr(Options, HalpSzPciLock)) {
            HalpPciLockSettings = TRUE;
        }

#ifndef ACPI_HAL
        //
        // Check if CLKLVL setting
        //

        if (strstr(Options, HalpSzClockLevel)) {
            HalpClockMode = LevelSensitive;
        }

        //
        // Check if 8254 is to be used as high resolution counter
        //

        if (strstr(Options, HalpSzUse8254)) {
            HalpUse8254 = TRUE;
        }
#endif

        //
        // Check if user wants device ints to go to highest numbered processor
        //

        if (strstr(Options, HalpSzInterruptAffinity)) {
            HalpStaticIntAffinity = TRUE;
        }

#ifndef ACPI_HAL
        //
        // Check for TIMERES setting
        //

        p = strstr(Options, HalpSzTimerRes);
        if (p) {
            // skip to value
            while (*p  &&  *p != ' ' &&  (*p < '0'  || *p > '9')) {
                p++;
            }

            HalpInitializeTimerResolution (atoi(p));
        }
#endif

        //
        //  Has the user asked for an initial BreakPoint?
        //

        if (strstr(Options, HalpSzBreak)) {
            DbgBreakPoint();
        }

        //
        // Does the user want to force Cluster mode APIC addressing?
        //
        p = strstr(Options, HalpSzForceClusterMode);
        if (p) {
            // skip to value
            while (*p  &&  *p != ' ' &&  (*p < '0'  || *p > '9')) {
                p++;
            }
            HalpMaxProcsPerCluster = (UCHAR)atoi(p);
            //
            // Current processors support maximum 4 processors per cluster.
            //
            if(HalpMaxProcsPerCluster > 4)   {
                HalpMaxProcsPerCluster = 4;
            }

            if (HalpMpInfoTable.ApicVersion == APIC_82489DX)   {
                //
                // Ignore user's attempt to force cluster mode if running
                // on 82489DX external APIC interrupt controller.
                //
                HalpMaxProcsPerCluster = 0;
            }
            //
            // Hack to reprogram the boot processor to use Cluster mode APIC
            // addressing if the user supplied a boot.ini switch
            // (/MAXPROCSPERCLUSTER=n) to force this. The boot.ini switch is
            // parsed after the boot processor's APIC is programmed originally
            // but before other non-boot processors were woken up.
            //
            HalpInitializeApicAddressing(0);
        }
    }

    return ;
}


VOID
HalpInitTimerWatchdog(
    IN ULONG Phase
    )
/*++

Routine Description:

    Determines if the system is running on a GenuineIntel part and initializes
    HalpTimerWatchdogEnabled accordingly.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if (Phase == 0) {
        ULONG   GenuinePentiumOrLater = FALSE, Junk;
        PKPRCB  Prcb;

        Prcb = KeGetCurrentPrcb();

        if (Prcb->CpuID) {
            UCHAR Buffer[50];

            //
            // Determine the processor type
            //

            HalpCpuID (0, &Junk, (PULONG) Buffer+0, (PULONG) Buffer+2, (PULONG) Buffer+1);
            Buffer[12] = 0;

            GenuinePentiumOrLater =
                ((strcmp(Buffer, HalpGenuineIntel) == 0) && (Prcb->CpuType >= 5));
            HalpTimerWatchdogEnabled = *KiEnableTimerWatchdog && GenuinePentiumOrLater;
        }
    } else if (HalpTimerWatchdogEnabled) {
        //
        // Allocate 2 pages for stack snapshots, each snapshot is 64 DWORDs.
        //
        if (HalpTimerWatchdogStorage =
                ExAllocatePoolWithTag( NonPagedPool, PAGE_SIZE * 2, HAL_POOL_TAG )) {
            HalpTimerWatchdogLastFrame =
                HalpTimerWatchdogStorage + (PAGE_SIZE * 2 - 64*4);
            HalpTimerWatchdogStorageOverflow = 0;
            HalpTimerWatchdogCurFrame = HalpTimerWatchdogStorage;
        } else {
            HalpTimerWatchdogEnabled = FALSE;
        }
    }
}



BOOLEAN
HalInitSystem (
    IN ULONG Phase,
    IN PLOADER_PARAMETER_BLOCK LoaderBlock
    )

/*++

Routine Description:

    This function initializes the Hardware Architecture Layer (HAL) for an
    x86 system.

Arguments:

    None.

Return Value:

    A value of TRUE is returned is the initialization was successfully
    complete. Otherwise a value of FALSE is returend.

--*/

{
    PMEMORY_ALLOCATION_DESCRIPTOR Descriptor;
    PLIST_ENTRY NextMd;
    PKPRCB      pPRCB;
    PKPCR       pPCR;
    BOOLEAN     Found;
    USHORT      RTCInti;
    USHORT      mmTInti;
    ULONG mapBufferSize;
    ULONG mapBufferAddress;

#ifdef DEBUGGING
extern ULONG HalpUseDbgPrint;
#endif // DEBUGGING

    pPRCB = KeGetCurrentPrcb();

    if (Phase == 0) {


        HalpBusType = LoaderBlock->u.I386.MachineType & 0x00ff;
        HalpGetParameters (LoaderBlock);

        //
        // Verify Prcb version and build flags conform to
        // this image
        //

#if DBG
        if (!(pPRCB->BuildType & PRCB_BUILD_DEBUG)) {
            // This checked hal requires a checked kernel
            KeBugCheckEx (MISMATCHED_HAL,
                2, pPRCB->BuildType, PRCB_BUILD_DEBUG, 0);
        }
#else
        if (pPRCB->BuildType & PRCB_BUILD_DEBUG) {
            // This free hal requires a free kernel
            KeBugCheckEx (MISMATCHED_HAL, 2, pPRCB->BuildType, 0, 0);
        }
#endif
#ifndef NT_UP
        if (pPRCB->BuildType & PRCB_BUILD_UNIPROCESSOR) {
            // This MP hal requires an MP kernel
            KeBugCheckEx (MISMATCHED_HAL, 2, pPRCB->BuildType, 0, 0);
        }
#endif
        if (pPRCB->MajorVersion != PRCB_MAJOR_VERSION) {
            KeBugCheckEx (MISMATCHED_HAL,
                1, pPRCB->MajorVersion, PRCB_MAJOR_VERSION, 0);
        }

        KeInitializeSpinLock(&HalpAccountingLock);

#ifdef ACPI_HAL
        //
        // Make sure that this is really an ACPI machine and initialize
        // the ACPI structures.
        //
        HalpSetupAcpiPhase0(LoaderBlock);
#endif

        //
        // Fill in handlers for APIs which this hal supports
        //

#ifndef NT_35
        HalQuerySystemInformation = HaliQuerySystemInformation;
        HalSetSystemInformation = HalpSetSystemInformation;
#endif
        //
        // check to see whether the kernel supports these calls
        //

        if (HALDISPATCH->Version >= HAL_DISPATCH_VERSION) {
            HalInitPnpDriver = HaliInitPnpDriver;
            HalGetDmaAdapter = HaliGetDmaAdapter;
            HalLocateHiberRanges = HaliLocateHiberRanges;
            HalResetDisplay = HalpBiosDisplayReset;

#ifdef ACPI_HAL
            HalInitPowerManagement = HaliInitPowerManagement;
            HalGetInterruptTranslator = HalacpiGetInterruptTranslator;
            HalHaltSystem = HaliHaltSystem;
#else
            HalGetInterruptTranslator = HaliGetInterruptTranslator;
#endif
        }

        //
        // Phase 0 initialization only called by P0
        //

#ifdef DEBUGGING
        HalpUseDbgPrint++;
        HalpDisplayLocalUnit();
#ifndef ACPI_HAL
        HalpDisplayConfigTable();
        HalpDisplayExtConfigTable();
#endif
#endif // DEBUGGING

        //
        // Keep track of which IRQs are level triggered.
        //
#if !defined(MCA) && !defined(ACPI_HAL)
        if (HalpBusType == MACHINE_TYPE_EISA) {
            HalpRecordEisaInterruptVectors();
        }
#endif
        //
        // Register PC style IO space used by hal
        //

        HalpRegisterAddressUsage (&HalpDefaultPcIoSpace);
        if (HalpBusType == MACHINE_TYPE_EISA) {
            HalpRegisterAddressUsage (&HalpEisaIoSpace);
        }

        if (HalpMpInfoTable.IMCRPresent) {
            HalpRegisterAddressUsage (&HalpImcrIoSpace);
        }

        //
        // initialize the APIC IO unit, this could be a NOP if none exist
        //

        HalpInitIntiInfo ();

        HalpInitializeIOUnits();

        HalpInitializePICs(TRUE);

        //
        // Initialize CMOS
        //

        HalpInitializeCmos();

        //
        // Find the RTC interrupt.
        //

        Found = HalpGetApicInterruptDesc (
                    DEFAULT_PC_BUS,
                    0,
                    ADJUSTED_VECTOR(RTC_IRQ),
                    &RTCInti
                    );

        if (!Found) {
            HalDisplayString (rgzRTCNotFound);
            return FALSE;
        }

        //
        // Initialize timers
        //

        //
        // We can cut down the boot time using the PM timer to scale,
        // but there are so many broken ACPI timers this might not work
        //
#ifdef SPEEDY_BOOT
        if (!HalpPmTimerScaleTimers())
#endif
            HalpScaleTimers();

        HalpProc0TSCHz = ((PHALPCR)(KeGetPcr()->HalReserved))->TSCHz;

        //
        //  Initialize the reboot handler
        //

        HalpSetInternalVector(APIC_REBOOT_VECTOR, HalpApicRebootService);
        HalpSetInternalVector(APIC_GENERIC_VECTOR, HalpBroadcastCallService);

        //
        // Initialize the clock for the processor that keeps
        // the system time. This uses a stub ISR until Phase 1
        //

        KiSetHandlerAddressToIDT(APIC_CLOCK_VECTOR, HalpClockInterruptStub );

        HalpVectorToINTI[APIC_CLOCK_VECTOR] = RTCInti;
        HalEnableSystemInterrupt(APIC_CLOCK_VECTOR, CLOCK2_LEVEL, HalpClockMode);

        //
        // Init timer watchdog if enabled.
        //

        HalpInitTimerWatchdog( Phase );

#ifdef MMTIMER_DEV

        //
        // Set up the multi media event timer to interrupt on P0 at
        // CLOCK2_LEVEL
        //

#define MMT_VECTOR 0xD3
#define MMT_IRQ 10

        HalpGetApicInterruptDesc(
            DEFAULT_PC_BUS,
            0,
            ADJUSTED_VECTOR(MMT_IRQ),
            &mmTInti
            );

        KiSetHandlerAddressToIDT(MMT_VECTOR, HalpmmTimerClockInterruptStub);

        HalpVectorToINTI[MMT_VECTOR] = mmTInti;

        HalEnableSystemInterrupt(MMT_VECTOR, CLOCK2_LEVEL, HalpClockMode);

        HalpRegisterVector(
            DeviceUsage | InterruptLatched,
            ADJUSTED_VECTOR(MMT_IRQ),
            MMT_VECTOR,
            HalpVectorToIRQL[MMT_VECTOR >> 4]
            );
#endif // MMTIMER_DEV

        HalpInitializeClock();

#ifndef ACPI_HAL
        HalpRegisterVector (
            DeviceUsage | InterruptLatched,
            ADJUSTED_VECTOR(RTC_IRQ),
            APIC_CLOCK_VECTOR,
            HalpVectorToIRQL [APIC_CLOCK_VECTOR >> 4]
            );
#endif

        //
        // Register NMI vector
        //

        HalpRegisterVector (
            InternalUsage,
            NMI_VECTOR,
            NMI_VECTOR,
            HIGH_LEVEL
        );


        //
        // Register spurious IDTs as in use
        //

        HalpRegisterVector (
            InternalUsage,
            APIC_SPURIOUS_VECTOR,
            APIC_SPURIOUS_VECTOR,
            HIGH_LEVEL
        );


        //
        // Initialize the profile interrupt vector.
        //

        KeSetProfileIrql(HIGH_LEVEL);
        HalStopProfileInterrupt(0);
        HalpSetInternalVector(APIC_PROFILE_VECTOR, HalpProfileInterrupt);

        //
        // Set performance interrupt vector
        //

        HalpSetInternalVector(APIC_PERF_VECTOR, HalpPerfInterrupt);

        //
        // Initialize the IPI, APC and DPC handlers
        //

        HalpSetInternalVector(DPC_VECTOR, HalpDispatchInterrupt);
        HalpSetInternalVector(APC_VECTOR, HalpApcInterrupt);
        HalpSetInternalVector(APIC_IPI_VECTOR, HalpIpiHandler);

        //
        // HALMPS doesn't actually do address translation on a
        // bus.  Register the quick version of FindBusAddressTranslation.
        //

        HALPDISPATCH->HalFindBusAddressTranslation =
           HalpFindBusAddressTranslation;

        //
        // Initialize spinlock used by HalGetBusData hardware access routines
        //

        KeInitializeSpinLock(&HalpSystemHardwareLock);

        //
        // Initialize data structures used to chain dma adapters
        // together for debugging purposes
        //
        KeInitializeSpinLock(&HalpDmaAdapterListLock);
        InitializeListHead(&HalpDmaAdapterList);

#ifdef ACPI_HAL
        //
        // Initialize synchronzation event used to serialize
        // new adapter events on the ACPI HAL (which has no notion of bus
        // handlers)
        //

        KeInitializeEvent (&HalpNewAdapter, SynchronizationEvent, TRUE);
#endif

        //
        // Determine if there is physical memory above 16 MB.
        //

        LessThan16Mb = TRUE;

        NextMd = LoaderBlock->MemoryDescriptorListHead.Flink;

        while (NextMd != &LoaderBlock->MemoryDescriptorListHead) {
            Descriptor = CONTAINING_RECORD( NextMd,
                                            MEMORY_ALLOCATION_DESCRIPTOR,
                                            ListEntry );

            if (Descriptor->MemoryType != LoaderFirmwarePermanent &&
                Descriptor->MemoryType != LoaderSpecialMemory  &&
                Descriptor->BasePage + Descriptor->PageCount > 0x1000) {
                LessThan16Mb = FALSE;
                break;
            }

            NextMd = Descriptor->ListEntry.Flink;
        }

#if !defined(_HALPAE_)

        HalpMapBufferSize = INITIAL_MAP_BUFFER_SMALL_SIZE;

        //
        // Allocate map buffers for the adapter objects
        //

        HalpMapBufferPhysicalAddress.LowPart =
            HalpAllocPhysicalMemory (LoaderBlock, MAXIMUM_PHYSICAL_ADDRESS,
                HalpMapBufferSize >> PAGE_SHIFT, TRUE);
        HalpMapBufferPhysicalAddress.HighPart = 0;


        if (!HalpMapBufferPhysicalAddress.LowPart) {

            //
            // There was not a satisfactory block.  Clear the allocation.
            //

            HalpMapBufferSize = 0;
        }

#else

        //
        // Initialize and allocate map buffers for the 24bit master adapter
        // object.
        //

        MasterAdapter24.MaxBufferPages =
            MAXIMUM_ISA_MAP_BUFFER_SIZE / PAGE_SIZE;

        mapBufferSize = INITIAL_MAP_BUFFER_SMALL_SIZE;
        mapBufferAddress =
            HalpAllocPhysicalMemory (LoaderBlock,
                                     MAXIMUM_PHYSICAL_ADDRESS,
                                     mapBufferSize >> PAGE_SHIFT,
                                     TRUE);

        if (mapBufferAddress == 0) {
            mapBufferSize = 0;
        }

        MasterAdapter24.MapBufferPhysicalAddress.LowPart = mapBufferAddress;
        MasterAdapter24.MapBufferPhysicalAddress.HighPart = 0;
        MasterAdapter24.MapBufferSize = mapBufferSize;

        if (HalPaeEnabled() != FALSE) {

            //
            // Initialize and allocate map buffers for the 32bit master adapter
            // object.  This should only be needed on a PAE-enabled system.
            //

            MasterAdapter32.MaxBufferPages =
                MAXIMUM_PCI_MAP_BUFFER_SIZE / PAGE_SIZE;

            mapBufferSize = INITIAL_MAP_BUFFER_LARGE_SIZE;
            mapBufferAddress =
                HalpAllocPhysicalMemory (LoaderBlock,
                                         (ULONG)-1,
                                         mapBufferSize >> PAGE_SHIFT,
                                         TRUE);

            if (mapBufferAddress == 0) {
                mapBufferSize = 0;
            }

            MasterAdapter32.MapBufferPhysicalAddress.LowPart = mapBufferAddress;
            MasterAdapter32.MapBufferPhysicalAddress.HighPart = 0;
            MasterAdapter32.MapBufferSize = mapBufferSize;
        }

#endif

        //
        // Initialize and register a bug check callback record.
        //

        KeInitializeCallbackRecord(&HalpCallbackRecord);
        KeRegisterBugCheckCallback(&HalpCallbackRecord,
                                   HalpBugCheckCallback,
                                   NULL,
                                   0,
                                   (PUCHAR)HalName);

    } else {

        //
        // Phase 1 initialization
        //

        pPCR = KeGetPcr();

        if (pPCR->Number == 0) {

            //
            // Back-pocket some PTEs for DMA during low mem
            //
            HalpInitReservedPages();

#ifdef ACPI_HAL
            HalpInitNonBusHandler ();
#else
            HalpRegisterInternalBusHandlers ();
#endif

#ifdef MMTIMER_DEV

            //
            // Fire up the multi media event timer clock interrupt
            //
            if (HalpmmTimer()) {
                HalpmmTimerClockInit();
            }
#endif

            //
            // Init timer watchdog if enabled (allocate snapshot buffer).
            //

            HalpInitTimerWatchdog( Phase );

            //
            // Initialize the clock for the processor
            // that keeps the system time.
            //

            KiSetHandlerAddressToIDT(APIC_CLOCK_VECTOR, HalpClockInterrupt );

            //
            // Set initial feature bits
            //

            HalpFeatureBits = HalpGetFeatureBits();

#if DBG_SPECIAL_IRQL

            //
            // Do Special IRQL initialization.
            //

            HalpInitializeSpecialIrqlSupport();

#endif

            //
            // Point to new movnti routine if Movnti is detected
            //

             if(HalpFeatureBits & HAL_WNI_PRESENT) {
                 HalpMoveMemory = HalpMovntiCopyBuffer;
             }

#ifdef ACPI_HAL
#ifdef NT_UP
            //
            // Perf counter patch for non-compliant ACPI machines
            //
            HalpAcpiTimerPerfCountHack();
#endif
#endif

        } else {
            //
            //  Initialization needed only on non BSP processors
            //
#ifdef SPEEDY_BOOT
            if (!HalpPmTimerScaleTimers())
#endif
                HalpScaleTimers();

            //
            // Hack.  Make all processors have the same value for
            // the timestamp counter frequency.
            //

            ((PHALPCR)(KeGetPcr()->HalReserved))->TSCHz = HalpProc0TSCHz;

            //
            // Initialize the clock for all other processors
            //

            KiSetHandlerAddressToIDT(APIC_CLOCK_VECTOR, HalpClockInterruptPn );

            //
            // Reduce feature bits to be a subset
            //

            HalpFeatureBits &= HalpGetFeatureBits();

        }

    }

    HalpInitMP (Phase, LoaderBlock);

    if (Phase == 1) {

        //
        // Enable system NMIs on Pn
        //

        HalpEnableNMI ();
    }

    return TRUE;
}

ULONG
HalpGetFeatureBits (
    VOID
    )
{
    UCHAR   Buffer[50];
    ULONG   Junk, ProcessorStepping, ProcessorFeatures, Bits;
    PULONG  p1, p2;
    PUCHAR  OrgRoutineAddress;
    PUCHAR  MCERoutineAddress;
    ULONG   newop;
    PKPRCB  Prcb;


    Bits = 0;

    Prcb = KeGetCurrentPrcb();

    if (!Prcb->CpuID) {
        Bits |= HAL_NO_SPECULATION;
        return Bits;
    }

    //
    // Determine the processor type
    //

    HalpCpuID (0, &Junk, (PULONG) Buffer+0, (PULONG) Buffer+2, (PULONG) Buffer+1);
    Buffer[12] = 0;

    //
    // Determine which features are present
    //

    HalpCpuID (1, &ProcessorStepping, &Junk, &Junk, &ProcessorFeatures);

    if (ProcessorFeatures & CPUID_MCA_MASK) {
        Bits |= HAL_MCA_PRESENT;
    }

    if (ProcessorFeatures & CPUID_MCE_MASK) {
        Bits |= HAL_MCE_PRESENT;
    }

    if (ProcessorFeatures & CPUID_VME_MASK) {
        Bits |= HAL_CR4_PRESENT;
    }

    if(ProcessorFeatures & CPUID_WNI_MASK) {
        Bits |= HAL_WNI_PRESENT;
    }

    //
    // Check Intel feature bits for HAL features needed
    //

    if (strcmp (Buffer, HalpGenuineIntel) == 0) {

        if ((Prcb->CpuType == 6) || (Prcb->CpuType == 0xf)) {
            Bits |= HAL_PERF_EVENTS;
        }

        if (Prcb->CpuType < 6) {
            Bits |= HAL_NO_SPECULATION;
        }

#ifndef NT_UP

        //
        // Check if IFU errata workaround is required
        //

        if (Prcb->Number == 0  &&  (Bits & HAL_MCA_PRESENT)  &&
            ((ProcessorStepping & 0x700) == 0x600) &&
            ((ProcessorStepping & 0xF0)  == 0x10) &&
            ((ProcessorStepping & 0xF)   <= 0x7) ) {

            //
            // If the stepping is 617 or earlier, provide software workaround
            //

            p1 = (PULONG) (KeAcquireSpinLockRaiseToSynch);
            p2 = (PULONG) (KeAcquireSpinLockRaiseToSynchMCE);
            newop = (ULONG) p2 - (ULONG) p1 - 2;    // compute offset
            ASSERT (newop < 0x7f);                  // verify within range
            newop = 0xeb | (newop << 8);            // short-jmp

            *(p1) = newop;                          // patch it
        }

#endif

    }

    return Bits;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\mppciint.c ===
/*++


Copyright (c) 1989  Microsoft Corporation

Module Name:

    ixpciint.c

Abstract:

    All PCI bus interrupt mapping is in this module, so that a real
    system which doesn't have all the limitations which PC PCI
    systems have can replaced this code easly.
    (bus memory & i/o address mappings can also be fix here)

Author:

    Ken Reneris

Environment:

    Kernel mode

Revision History:


--*/

#include "halp.h"
#include "pci.h"
#include "pcip.h"
#include "pcmp_nt.inc"

volatile ULONG PCIType2Stall;
extern struct HalpMpInfo HalpMpInfoTable;
extern BOOLEAN HalpHackNoPciMotion;
extern BOOLEAN HalpDoingCrashDump;

VOID
HalpPCIPin2MPSLine (
    IN PBUS_HANDLER         BusHandler,
    IN PBUS_HANDLER         RootHandler,
    IN PCI_SLOT_NUMBER      SlotNumber,
    IN PPCI_COMMON_CONFIG   PciData
    );

VOID
HalpPCIBridgedPin2Line (
    IN PBUS_HANDLER         BusHandler,
    IN PBUS_HANDLER         RootHandler,
    IN PCI_SLOT_NUMBER      SlotNumber,
    IN PPCI_COMMON_CONFIG   PciData
    );

VOID
HalpPCIMPSLine2Pin (
    IN PBUS_HANDLER          BusHandler,
    IN PBUS_HANDLER          RootHandler,
    IN PCI_SLOT_NUMBER      SlotNumber,
    IN PPCI_COMMON_CONFIG   PciNewData,
    IN PPCI_COMMON_CONFIG   PciOldData
    );

NTSTATUS
HalpGetFixedPCIMPSLine (
    IN PBUS_HANDLER      BusHandler,
    IN PBUS_HANDLER      RootHandler,
    IN PCI_SLOT_NUMBER  PciSlot,
    OUT PSUPPORTED_RANGE *Interrupt
    );

BOOLEAN
HalpMPSBusId2NtBusId (
    IN UCHAR                ApicBusId,
    OUT PPCMPBUSTRANS       *ppBusType,
    OUT PULONG              BusNo
    );

ULONG
HalpGetPCIBridgedInterruptVector (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG InterruptLevel,
    IN ULONG InterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, HalpSubclassPCISupport)
#pragma alloc_text(INIT, HalpMPSPCIChildren)
#pragma alloc_text(PAGE, HalpGetFixedPCIMPSLine)
#pragma alloc_text(PAGE, HalpGetPCIBridgedInterruptVector)
#pragma alloc_text(PAGE, HalpIrqTranslateRequirementsPci)
#pragma alloc_text(PAGE, HalpIrqTranslateResourcesPci)
#endif


//
// Turn PCI pin to inti via the MPS spec
// (note: pin must be non-zero)
//

#define PCIPin2Int(Slot,Pin)                                                \
                     ((((Slot.u.bits.DeviceNumber << 2) | (Pin-1)) != 0) ?  \
                      (Slot.u.bits.DeviceNumber << 2) | (Pin-1) : 0x80);

#define PCIInt2Pin(interrupt)                                               \
            ((interrupt & 0x3) + 1)

#define PCIInt2Slot(interrupt)                                              \
            ((interrupt  & 0x7f) >> 2)


VOID
HalpSubclassPCISupport (
    PBUS_HANDLER        Handler,
    ULONG               HwType
    )
{
    ULONG               d, pin, i, MaxDeviceFound;
    PPCIPBUSDATA        BusData;
    PCI_SLOT_NUMBER     SlotNumber;
    BOOLEAN             DeviceFound;


    BusData = (PPCIPBUSDATA) Handler->BusData;
    SlotNumber.u.bits.Reserved = 0;
    MaxDeviceFound = 0;
    DeviceFound = FALSE;

#ifdef P6_WORKAROUNDS
    BusData->MaxDevice = 0x10;
#endif

    //
    // Find any PCI bus which has MPS inti information, and provide
    // MPS handlers for dealing with it.
    //
    // Note: we assume that any PCI bus with any MPS information
    // is totally defined.  (Ie, it's not possible to connect some PCI
    // interrupts on a given PCI bus via the MPS table without connecting
    // them all).
    //
    // Note2: we assume that PCI buses are listed in the MPS table in
    // the same order the BUS declares them.  (Ie, the first listed
    // PCI bus in the MPS table is assumed to match physical PCI bus 0, etc).
    //
    //

    for (d=0; d < PCI_MAX_DEVICES; d++) {

        SlotNumber.u.bits.DeviceNumber = d;
        SlotNumber.u.bits.FunctionNumber = 0;

        for (pin=1; pin <= 4; pin++) {
            i = PCIPin2Int (SlotNumber, pin);
            if (HalpGetApicInterruptDesc(PCIBus, Handler->BusNumber, i, (PUSHORT)&i)) {
                MaxDeviceFound = d;
                DeviceFound = TRUE;
            }
        }
    }

    if (DeviceFound) {

        //
        // There are Inti mapping for interrupts on this PCI bus
        // Change handlers for this bus to MPS versions
        //

        Handler->GetInterruptVector  = HalpGetSystemInterruptVector;
        BusData->CommonData.Pin2Line = (PciPin2Line) HalpPCIPin2MPSLine;
        BusData->CommonData.Line2Pin = (PciLine2Pin) HalpPCIMPSLine2Pin;
        BusData->GetIrqRange         = HalpGetFixedPCIMPSLine;

        if (BusData->MaxDevice < MaxDeviceFound) {
            BusData->MaxDevice = MaxDeviceFound;
        }

    } else {

        //
        // Not all PCI machines are eisa machine, since the PCI interrupts
        // aren't coming into IoApics go check the Eisa ELCR for broken
        // behaviour.
        //

        HalpCheckELCR ();
    }
}


VOID
HalpMPSPCIChildren (
    VOID
    )
/*++

    Any PCI buses which don't have declared interrupt mappings and
    are children of parent buses that have MPS interrupt mappings
    need to inherit interrupts from parents via PCI barbar pole
    algorithm

--*/
{
    PBUS_HANDLER        Handler, Parent;
    PPCIPBUSDATA        BusData, ParentData;
    ULONG               b, cnt, i, id;
    PCI_SLOT_NUMBER     SlotNumber;
    struct {
        union {
            UCHAR       map[4];
            ULONG       all;
        } u;
    }                   Interrupt, Hold;

    //
    // Lookup each PCI bus in the system
    //

    for (b=0; Handler = HaliHandlerForBus(PCIBus, b); b++) {

        BusData = (PPCIPBUSDATA) Handler->BusData;

        if (BusData->CommonData.Pin2Line == (PciPin2Line) HalpPCIPin2MPSLine) {

            //
            // This bus already has mappings
            //

            continue;
        }


        //
        // Check if any parent has PCI MPS interrupt mappings
        //

        Interrupt.u.map[0] = 1;
        Interrupt.u.map[1] = 2;
        Interrupt.u.map[2] = 3;
        Interrupt.u.map[3] = 4;

        Parent = Handler;
        SlotNumber = BusData->CommonData.ParentSlot;

        while (Parent = Parent->ParentHandler) {

            if (Parent->InterfaceType != PCIBus) {
                break;
            }

            //
            // Check if parent has MPS interrupt mappings
            //

            ParentData = (PPCIPBUSDATA) Parent->BusData;
            if (ParentData->CommonData.Pin2Line == (PciPin2Line) HalpPCIPin2MPSLine) {

                //
                // This parent has MPS interrupt mappings.  Set the device
                // to get its InterruptLine values from the buses SwizzleIn table
                //

                Handler->GetInterruptVector  = HalpGetPCIBridgedInterruptVector;
                BusData->CommonData.Pin2Line = (PciPin2Line) HalpPCIBridgedPin2Line;
                BusData->CommonData.Line2Pin = (PciLine2Pin) HalpPCIMPSLine2Pin;

                for (i=0; i < 4; i++) {
                    id = PCIPin2Int (SlotNumber, Interrupt.u.map[i]);
                    BusData->SwizzleIn[i] = (UCHAR) id;
                }
                break;
            }

            //
            // Apply interrupt mapping
            //

            i = SlotNumber.u.bits.DeviceNumber;
            Hold.u.map[0] = Interrupt.u.map[(i + 0) & 3];
            Hold.u.map[1] = Interrupt.u.map[(i + 1) & 3];
            Hold.u.map[2] = Interrupt.u.map[(i + 2) & 3];
            Hold.u.map[3] = Interrupt.u.map[(i + 3) & 3];
            Interrupt.u.all = Hold.u.all;

            SlotNumber = ParentData->CommonData.ParentSlot;
        }

    }
}


VOID
HalpPCIPin2MPSLine (
    IN PBUS_HANDLER         BusHandler,
    IN PBUS_HANDLER         RootHandler,
    IN PCI_SLOT_NUMBER      SlotNumber,
    IN PPCI_COMMON_CONFIG   PciData
    )
/*++
--*/
{
    if (!PciData->u.type0.InterruptPin) {
        return ;
    }

    PciData->u.type0.InterruptLine = (UCHAR)
        PCIPin2Int (SlotNumber, PciData->u.type0.InterruptPin);
}

VOID
HalpPCIBridgedPin2Line (
    IN PBUS_HANDLER         BusHandler,
    IN PBUS_HANDLER         RootHandler,
    IN PCI_SLOT_NUMBER      SlotNumber,
    IN PPCI_COMMON_CONFIG   PciData
    )
/*++

    This function maps the device's InterruptPin to an InterruptLine
    value.

    test function particular to dec pci-pci bridge card

--*/
{
    PPCIPBUSDATA    BusData;
    ULONG           i;

    if (!PciData->u.type0.InterruptPin) {
        return ;
    }

    //
    // Convert slot Pin into Bus INTA-D.
    //

    BusData = (PPCIPBUSDATA) BusHandler->BusData;

    i = (PciData->u.type0.InterruptPin +
          SlotNumber.u.bits.DeviceNumber - 1) & 3;

    PciData->u.type0.InterruptLine = BusData->SwizzleIn[i];
}


VOID
HalpPCIMPSLine2Pin (
    IN PBUS_HANDLER         BusHandler,
    IN PBUS_HANDLER         RootHandler,
    IN PCI_SLOT_NUMBER      SlotNumber,
    IN PPCI_COMMON_CONFIG   PciNewData,
    IN PPCI_COMMON_CONFIG   PciOldData
    )
/*++
--*/
{
    //
    // PCI interrupts described in the MPS table are directly
    // connected to APIC Inti pins.
    // Do nothing...
    //
}

ULONG
HalpGetPCIBridgedInterruptVector (
    IN PBUS_HANDLER BusHandler,
    IN PBUS_HANDLER RootHandler,
    IN ULONG InterruptLevel,
    IN ULONG InterruptVector,
    OUT PKIRQL Irql,
    OUT PKAFFINITY Affinity
    )
{
    //
    // Get parent's translation
    //

    return  BusHandler->ParentHandler->GetInterruptVector (
                    BusHandler->ParentHandler,
                    BusHandler->ParentHandler,
                    InterruptLevel,
                    InterruptVector,
                    Irql,
                    Affinity
                    );

}



NTSTATUS
HalpGetFixedPCIMPSLine (
    IN PBUS_HANDLER     BusHandler,
    IN PBUS_HANDLER     RootHandler,
    IN PCI_SLOT_NUMBER  PciSlot,
    OUT PSUPPORTED_RANGE *Interrupt
    )
{
    UCHAR                   buffer[PCI_COMMON_HDR_LENGTH];
    PPCI_COMMON_CONFIG      PciData;

    PciData = (PPCI_COMMON_CONFIG) buffer;
    HalGetBusData (
        PCIConfiguration,
        BusHandler->BusNumber,
        PciSlot.u.AsULONG,
        PciData,
        PCI_COMMON_HDR_LENGTH
        );

    if (PciData->VendorID == PCI_INVALID_VENDORID) {
        return STATUS_UNSUCCESSFUL;
    }

    *Interrupt = ExAllocatePoolWithTag(PagedPool,
                                       sizeof(SUPPORTED_RANGE),
                                       HAL_POOL_TAG);
    if (!*Interrupt) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory (*Interrupt, sizeof (SUPPORTED_RANGE));
    (*Interrupt)->Base = 1;                 // base = 1, limit = 0


    if (!PciData->u.type0.InterruptPin) {
        return STATUS_SUCCESS;
    }

    (*Interrupt)->Base  = PciData->u.type0.InterruptLine;
    (*Interrupt)->Limit = PciData->u.type0.InterruptLine;
    return STATUS_SUCCESS;
}

VOID
HalpPCIType2TruelyBogus (
    ULONG Context
    )
/*++

    This is a piece of work.

    Type 2 of the PCI configuration space is bad.  Bad as in to
    access it one needs to block out 4K of I/O space.

    Video cards are bad.  The only decode the bits in an I/O address
    they feel like.  Which means one can't block out a 4K range
    or these video cards don't work.

    Combinding all these bad things onto an MP machine is even
    more (sic) bad.  The I/O ports can't be mapped out unless
    all processors stop accessing I/O space.

    Allowing access to device specific PCI control space during
    an interrupt isn't bad, (although accessing it on every interrupt
    is ineficent) but this cause the added grief that all processors
    need to obtained at above all device interrupts.

    And... naturally we have an MP machine with a wired down
    bad video controller, stuck in the bad Type 2 configuration
    space (when we told everyone about type 1!).   So the "fix"
    is to HALT ALL processors for the duration of reading/writing
    ANY part of PCI configuration space such that we can be sure
    no processor is touching the 4k I/O ports which get mapped out
    of existance when type2 accesses occur.

    ----

    While I'm flaming.  Hooking PCI interrupts ontop of ISA interrupts
    in a machine which has the potential to have 240+ interrupts
    sources (read APIC)  is bad.

--*/
{
    // oh - let's just wait here and not pay attention to that other processor
    // guy whom is punching holes into the I/O space
    while (PCIType2Stall == Context) {
        HalpPollForBroadcast ();
    }
}


VOID
HalpPCIAcquireType2Lock (
    PKSPIN_LOCK SpinLock,
    PKIRQL      OldIrql
    )
{
    if (!HalpDoingCrashDump) {
        *OldIrql = KfRaiseIrql (CLOCK2_LEVEL-1);
        KiAcquireSpinLock (SpinLock);

        //
        // Interrupt all other processors and have them wait until the
        // barrier is cleared.  (HalpGenericCall waits until the target
        // processors have been interrupted before returning)
        //

        HalpGenericCall (
            HalpPCIType2TruelyBogus,
            PCIType2Stall,
            HalpActiveProcessors & ~KeGetCurrentPrcb()->SetMember
            );
    } else {
        *OldIrql = HIGH_LEVEL;
    }
}

VOID
HalpPCIReleaseType2Lock (
    PKSPIN_LOCK SpinLock,
    KIRQL       Irql
    )
{
    if (!HalpDoingCrashDump) {
        PCIType2Stall++;                            // clear barrier
        KiReleaseSpinLock (SpinLock);
        KfLowerIrql (Irql);
    }
}

NTSTATUS
HalpIrqTranslateRequirementsPci(
    IN PVOID Context,
    IN PIO_RESOURCE_DESCRIPTOR Source,
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    )
/*++

Routine Description:

    This function translates IRQ resource requirements from
    a PCI bus that is described in the MPS table to the
    root.

Arguments:

    Context  - must hold the MPS bus number of this PCI bus

Return Value:

    STATUS_SUCCESS, so long as we can allocate the necessary
    memory

--*/
#define USE_INT_LINE_REGISTER_TOKEN  0xffffffff
{
    PIO_RESOURCE_DESCRIPTOR target;
    PPCMPBUSTRANS           busType;
    PBUS_HANDLER            busHandler;
    NTSTATUS                status;
    UCHAR                   mpsBusNumber;
    ULONG                   devPciBus, bridgePciBus;
    PCI_SLOT_NUMBER         pciSlot;
    UCHAR                   interruptLine, interruptPin;
    UCHAR                   dummy;
    PDEVICE_OBJECT          parentPdo;
    ROUTING_TOKEN           routingToken;
    KIRQL                   irql;
    KAFFINITY               affinity;
    ULONG                   busVector;
    ULONG                   vector;
    BOOLEAN                 success;

    PAGED_CODE();

    ASSERT(Source->Type == CmResourceTypeInterrupt);
    ASSERT(PciIrqRoutingInterface.GetInterruptRouting);

    devPciBus = (ULONG)-1;
    pciSlot.u.AsULONG = (ULONG)-1;
    status = PciIrqRoutingInterface.GetInterruptRouting(
                PhysicalDeviceObject,
                &devPciBus,
                &pciSlot.u.AsULONG,
                &interruptLine,
                &interruptPin,
                &dummy,
                &dummy,
                &parentPdo,
                &routingToken,
                &dummy
                );

    if (!NT_SUCCESS(status)) {

        //
        // We should never get here.  If we do, we have a bug.
        // It means that we're trying to arbitrate PCI IRQs for
        // a non-PCI device.
        //

#if DBG
        DbgPrint("HAL:  The PnP manager passed a non-PCI PDO to the PCI IRQ translator (%x)\n",
                 PhysicalDeviceObject);
#endif
        *TargetCount = 0;
        return STATUS_INVALID_PARAMETER_3;
    }

    target = ExAllocatePoolWithTag(PagedPool,
                                   sizeof(IO_RESOURCE_DESCRIPTOR),
                                   HAL_POOL_TAG);

    if (!target) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Copy the source to fill in all the relevant fields.
    //

    *target = *Source;

    if (Context == (PVOID)USE_INT_LINE_REGISTER_TOKEN) {

        //
        // This bus's vectors aren't described in
        // the MPS table.  So just use the Int Line
        // register.
        //

        busVector = interruptLine;

        busHandler = HaliHandlerForBus(Isa, 0);

    } else {

        mpsBusNumber = (UCHAR)Context;
        success = HalpMPSBusId2NtBusId(mpsBusNumber,
                                       &busType,
                                       &bridgePciBus);

        if (!success) {
            ExFreePool(target);
            return STATUS_UNSUCCESSFUL;
        }

        //
        // Start with the assumption that the incoming
        // resources will contain the proper MPS-style
        // interrupt vector.  This will be guaranteed
        // to be true if some previous translation has
        // been done on these resources.  And it might
        // be true otherwise.
        //

        busVector = Source->u.Interrupt.MinimumVector;

        if (bridgePciBus == devPciBus) {

            //
            // If this device sits on the bus for which
            // this translator has been ejected, we can
            // do better than to assume the incoming
            // resources are clever.
            //

            busVector = PCIPin2Int(pciSlot, interruptPin);
        }

        //
        // Find the PCI bus that corresponds to this MPS bus.
        //

        ASSERT(busType->NtType == PCIBus);

        //
        // TEMPTEMP  Use bus handlers for now.
        //

        busHandler = HaliHandlerForBus(PCIBus, devPciBus);

    }


    vector = busHandler->GetInterruptVector(busHandler,
                                            busHandler,
                                            busVector,
                                            busVector,
                                            &irql,
                                            &affinity);

    if (vector == 0) {

#if DBG
        DbgPrint("\nHAL: PCI Device 0x%02x, Func. 0x%x on bus 0x%x is not in the MPS table.\n   *** Note to WHQL:  Fail this machine. ***\n\n",
                 pciSlot.u.bits.DeviceNumber,
                 pciSlot.u.bits.FunctionNumber,
                 devPciBus);
#endif
        ExFreePool(target);
        *TargetCount = 0;

        return STATUS_PNP_BAD_MPS_TABLE;

    } else {

        target->u.Interrupt.MinimumVector = vector;
        target->u.Interrupt.MaximumVector = vector;

        *TargetCount = 1;
        *Target = target;
    }

    return STATUS_TRANSLATION_COMPLETE;
}

NTSTATUS
HalpIrqTranslateResourcesPci(
    IN PVOID Context,
    IN PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN RESOURCE_TRANSLATION_DIRECTION Direction,
    IN ULONG AlternativesCount, OPTIONAL
    IN IO_RESOURCE_DESCRIPTOR Alternatives[], OPTIONAL
    IN PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    )
/*++

Routine Description:

    This function translates IRQ resources between the
    IDT and PCI busses that are described in the MPS
    tables.  The translation can go in either direction.

Arguments:

    Context  - Must hold the slot number of the bridge in
               the lower sixteen bits.  Must hold the
               the bridge's primary bus number in the
               upper sixteen bits.

Return Value:

    status

--*/
{
    PPCMPBUSTRANS           busType;
    PBUS_HANDLER            busHandler;
    UCHAR                   mpsBusNumber = (UCHAR)Context;
    ULONG                   devPciBus, bridgePciBus;
    KIRQL                   irql;
    KAFFINITY               affinity;
    ULONG                   vector;
    ULONG                   busVector;
    NTSTATUS                status;
    PCI_SLOT_NUMBER         pciSlot;
    UCHAR                   interruptLine;
    UCHAR                   interruptPin;
    UCHAR                   dummy;
    PDEVICE_OBJECT          parentPdo;
    ROUTING_TOKEN           routingToken;
    BOOLEAN                 useAlternatives = FALSE;
    BOOLEAN                 foundBus = FALSE;

    ASSERT(Source->Type = CmResourceTypeInterrupt);
    ASSERT(PciIrqRoutingInterface.GetInterruptRouting);

    *Target = *Source;

    devPciBus = (ULONG)-1;
    pciSlot.u.AsULONG = (ULONG)-1;
    status = PciIrqRoutingInterface.GetInterruptRouting(
                PhysicalDeviceObject,
                &devPciBus,
                &pciSlot.u.AsULONG,
                &interruptLine,
                &interruptPin,
                &dummy,
                &dummy,
                &parentPdo,
                &routingToken,
                &dummy
                );

    ASSERT(NT_SUCCESS(status));

    switch (Direction) {
    case TranslateChildToParent:

        if (Context == (PVOID)USE_INT_LINE_REGISTER_TOKEN) {

            //
            // This bus's vectors aren't described in
            // the MPS table.  So just use the Int Line
            // register.
            //

            interruptLine = (UCHAR)Source->u.Interrupt.Vector;

            busVector = interruptLine;

            busHandler = HaliHandlerForBus(Isa, 0);

        } else {

            //
            // Find the PCI bus that corresponds to this MPS bus.
            //

            mpsBusNumber = (UCHAR)Context;
            foundBus = HalpMPSBusId2NtBusId(mpsBusNumber,
                                            &busType,
                                            &bridgePciBus);

            if (!foundBus) {
                return STATUS_INVALID_PARAMETER_1;
            }

            ASSERT(busType->NtType == PCIBus);

            //
            // Start with the assumption that the incoming
            // resources will contain the proper MPS-style
            // interrupt vector.  This will be guaranteed
            // to be true if some previous translation has
            // been done on these resources.  And it might
            // be true otherwise.
            //

            busVector = Source->u.Interrupt.Vector;

            if (devPciBus == bridgePciBus) {

                //
                // If this device sits on the bus for which
                // this translator has been ejected, we can
                // do better than to assume the incoming
                // resources are clever.
                //

                busVector = PCIPin2Int(pciSlot, interruptPin);
            }

            //
            // TEMPTEMP  Use bus handlers for now.
            //

            busHandler = HaliHandlerForBus(PCIBus, devPciBus);

        }

        vector = busHandler->GetInterruptVector(busHandler,
                                                busHandler,
                                                busVector,
                                                busVector,
                                                &irql,
                                                &affinity);

        ASSERT(vector != 0);

        Target->u.Interrupt.Vector   = vector;
        Target->u.Interrupt.Level    = irql;
        Target->u.Interrupt.Affinity = affinity;

        return STATUS_TRANSLATION_COMPLETE;

    case TranslateParentToChild:

        //
        // There is a problem here.  We are translating from the
        // context of the IDT down to the context of a specific
        // PCI bus.  (One decribed in the MPS tables.)  This may
        // not, however, be the bus that PhysicalDeviceObject's
        // hardware lives on.  There may be plug-in PCI to PCI
        // bridges between this bus and the device.
        //
        // But we are not being asked the question "What is the
        // bus-relative interrupt with respect to the bus that
        // the device lives on?"  We are being asked "What is the
        // bus-relative interrupt once that interrupt passes through
        // all those briges and makes it up to this bus?"  This
        // turns out to be a much harder question.
        //
        // There are really two cases:
        //
        // 1)  There are no bridges between this bus and the device.
        //
        // This is easy.  We answer the first question above and
        // we're done.  (This information will actually get used.
        // it will appear in the start device IRP and the device
        // manager.)
        //
        // 2)  There are bridges.
        //
        // This is the hard case.  And the information, were we
        // actually going to bother to dig it up, would get thrown
        // away.  Nobody actually cares what the answer is.  The
        // only place it is going is the "Source" argument to
        // the next translator.  And the translator for PCI to PCI
        // bridges won't end up using it.
        //
        // So we punt here and just answer the first question.
        //

        if (Context == (PVOID)USE_INT_LINE_REGISTER_TOKEN) {

            Target->u.Interrupt.Vector = interruptLine;

        } else {

            mpsBusNumber = (UCHAR)Context;
            if (HalpMPSBusId2NtBusId(mpsBusNumber,
                                     &busType,
                                     &bridgePciBus)) {

                if (devPciBus == bridgePciBus) {

                    Target->u.Interrupt.Vector = PCIPin2Int(pciSlot, interruptPin);

                } else {

                    useAlternatives = TRUE;
                }

            } else {

                useAlternatives = TRUE;
            }
        }

        if (useAlternatives) {

            //
            // Setup the default case.  We assume that the I/O
            // res list had the right answer.
            //

            ASSERT(AlternativesCount == 1);
            ASSERT(Alternatives[0].Type == CmResourceTypeInterrupt);

            Target->u.Interrupt.Vector = Alternatives[0].u.Interrupt.MinimumVector;
        }

        Target->u.Interrupt.Level = Target->u.Interrupt.Vector;
        Target->u.Interrupt.Affinity = 0xffffffff;

        return STATUS_SUCCESS;
    }

    return STATUS_INVALID_PARAMETER_3;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\mpprocst.c ===
/*++

Copyright (c) 1997  Microsoft Corporation
Copyright (c) 1992  Intel Corporation
All rights reserved

INTEL CORPORATION PROPRIETARY INFORMATION

This software is supplied to Microsoft under the terms
of a license agreement with Intel Corporation and may not be
copied nor disclosed except in accordance with the terms
of that agreement.

Module Name:

    mpprocst.c

Abstract:

    This code has been moved from mpsproc.c so that it
    can be included from both the MPS hal and the ACPI hal.

Author:

    Ken Reneris (kenr) 22-Jan-1991

Environment:

    Kernel mode only.

Revision History:

    Ron Mosgrove (Intel) - Modified to support the PC+MP
    
    Jake Oshins (jakeo) - moved from mpsproc.c

--*/

#include "halp.h"
#include "pcmp_nt.inc"
#include "apic.inc"
#include "stdio.h"

VOID
HalpMapCR3 (
    IN ULONG VirtAddress,
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG Length
    );

ULONG
HalpBuildTiledCR3 (
    IN PKPROCESSOR_STATE    ProcessorState
    );

VOID
HalpFreeTiledCR3 (
    VOID
    );

VOID
StartPx_PMStub (
    VOID
    );

ULONG
HalpBuildTiledCR3Ex (
    IN PKPROCESSOR_STATE    ProcessorState,
    IN ULONG                ProcNum
    );

VOID
HalpMapCR3Ex (
    IN ULONG VirtAddress,
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG Length,
    IN ULONG ProcNum
    );

VOID
HalpFreeTiledCR3Ex (
    ULONG ProcNum
    );

#define MAX_PT              16

PVOID   HiberFreeCR3[MAX_PROCESSORS][MAX_PT];          // remember pool memory to free

PVOID   HalpLowStubPhysicalAddress;   // pointer to low memory bootup stub
PUCHAR  HalpLowStub;                  // pointer to low memory bootup stub


#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGELK,HalpBuildTiledCR3)
#pragma alloc_text(PAGELK,HalpMapCR3)
#pragma alloc_text(PAGELK,HalpFreeTiledCR3)
#pragma alloc_text(PAGELK,HalpBuildTiledCR3Ex)
#pragma alloc_text(PAGELK,HalpMapCR3Ex)
#pragma alloc_text(PAGELK,HalpFreeTiledCR3Ex)
#endif

#define PTES_PER_PAGE (PAGE_SIZE / HalPteSize())

PHARDWARE_PTE
GetPdeAddressEx(
    ULONG Va,
    ULONG ProcessorNumber
    )
{
    PHARDWARE_PTE pageDirectories;
    PHARDWARE_PTE pageDirectoryEntry;
    ULONG pageDirectoryIndex;

    pageDirectories = (PHARDWARE_PTE)(HiberFreeCR3[ ProcessorNumber ][0]);

    if (HalPaeEnabled() != FALSE) {

        //
        // Skip over the first page, which contains the page directory pointer
        // table.
        //
    
        HalpAdvancePte( &pageDirectories, PTES_PER_PAGE );
    }

    pageDirectoryIndex = Va >> MiGetPdiShift();

    //
    // Note that in the case of PAE, pageDirectoryIndex includes the PDPT
    // bits.  This works because we know that the four page directory tables
    // are adjacent.
    //

    pageDirectoryEntry = HalpIndexPteArray( pageDirectories,
                                            pageDirectoryIndex );
    return pageDirectoryEntry;
}

PHARDWARE_PTE
GetPteAddress(
    IN ULONG Va,
    IN PHARDWARE_PTE PageTable
    )
{
    PHARDWARE_PTE pointerPte;
    ULONG index;

    index = MiGetPteIndex( (PVOID)Va );
    pointerPte = HalpIndexPteArray( PageTable, index );

    return pointerPte;
}

ULONG
HalpBuildTiledCR3 (
    IN PKPROCESSOR_STATE    ProcessorState
    )
/*++

Routine Description:
    When the x86 processor is reset it starts in real-mode.
    In order to move the processor from real-mode to protected
    mode with flat addressing the segment which loads CR0 needs
    to have its linear address mapped to the physical
    location of the segment for said instruction so the
    processor can continue to execute the following instruction.

    This function is called to build such a tiled page directory.
    In addition, other flat addresses are tiled to match the
    current running flat address for the new state.  Once the
    processor is in flat mode, we move to a NT tiled page which
    can then load up the remaining processor state.

Arguments:
    ProcessorState  - The state the new processor should start in.

Return Value:
    Physical address of Tiled page directory


--*/
{
    return(HalpBuildTiledCR3Ex(ProcessorState,0));
}

ULONG
HalpBuildTiledCR3Ex (
    IN PKPROCESSOR_STATE    ProcessorState,
    IN ULONG                ProcNum
    )
/*++

Routine Description:
    When the x86 processor is reset it starts in real-mode.
    In order to move the processor from real-mode to protected
    mode with flat addressing the segment which loads CR0 needs
    to have its linear address mapped to machine the physical
    location of the segment for said instruction so the
    processor can continue to execute the following instruction.

    This function is called to build such a tiled page directory.
    In addition, other flat addresses are tiled to match the
    current running flat address for the new state.  Once the
    processor is in flat mode, we move to a NT tiled page which
    can then load up the remaining processor state.

Arguments:
    ProcessorState  - The state the new processor should start in.

Return Value:
    Physical address of Tiled page directory


--*/
{
    ULONG allocationSize;
    PHARDWARE_PTE pte;
    PHARDWARE_PTE pdpt;
    PHARDWARE_PTE pdpte;
    PHARDWARE_PTE pageDirectory;
    PHYSICAL_ADDRESS physicalAddress;
    ULONG i;

    if (HalPaeEnabled() != FALSE) {

        //
        // Need 5 pages for PAE mode: one for the page directory pointer
        // table and one for each of the four page directories.  Note that
        // only the single PDPT page really needs to come from memory below 4GB
        // physical.
        //
    
        allocationSize = PAGE_SIZE * 5;
        physicalAddress.HighPart = 0;
        physicalAddress.LowPart = 0xffffffff;

        HiberFreeCR3[ProcNum][0] = 
            MmAllocateContiguousMemory (allocationSize, physicalAddress);

    } else {

        //
        // Just one page for the page directory.
        //
    
        allocationSize = PAGE_SIZE;
        HiberFreeCR3[ProcNum][0] = 
            ExAllocatePoolWithTag (NonPagedPool, allocationSize, HAL_POOL_TAG);
    }

    if (!HiberFreeCR3[ProcNum][0]) {
        // Failed to allocate memory.
        return 0;
    }
    
    RtlZeroMemory (HiberFreeCR3[ProcNum][0], allocationSize);

    if (HalPaeEnabled() != FALSE) {
    
        //
        // Initialize each of the four page directory pointer table entries
        //
    
        pdpt = (PHARDWARE_PTE)HiberFreeCR3[ProcNum][0];
        pageDirectory = pdpt;
        for (i = 0; i < 4; i++) {

            //
            // Get a pointer to the page directory pointer table entry
            //

            pdpte = HalpIndexPteArray( pdpt, i );
    
            //
            // Skip to the first (next) page directory.
            //

            HalpAdvancePte( &pageDirectory, PTES_PER_PAGE );

            //
            // Find its physical address and update the page directory pointer
            // table entry.
            //
    
            physicalAddress = MmGetPhysicalAddress( pageDirectory );
            pdpte->Valid = 1;
            HalpSetPageFrameNumber( pdpte,
                                    physicalAddress.QuadPart >> PAGE_SHIFT );
        }
    }

    //
    //  Map page for real mode stub (one page)
    //

    HalpMapCR3Ex ((ULONG) HalpLowStubPhysicalAddress,
                HalpPtrToPhysicalAddress( HalpLowStubPhysicalAddress ),
                PAGE_SIZE,
                ProcNum);

    //
    //  Map page for protect mode stub (one page)
    //

    HalpMapCR3Ex ((ULONG) &StartPx_PMStub,
                  HalpPtrToPhysicalAddress( NULL ),
                  PAGE_SIZE,
                  ProcNum);

    //
    //  Map page(s) for processors GDT
    //

    HalpMapCR3Ex (ProcessorState->SpecialRegisters.Gdtr.Base, 
                  HalpPtrToPhysicalAddress( NULL ),
                  ProcessorState->SpecialRegisters.Gdtr.Limit,
                  ProcNum);


    //
    //  Map page(s) for processors IDT
    //

    HalpMapCR3Ex (ProcessorState->SpecialRegisters.Idtr.Base, 
                  HalpPtrToPhysicalAddress( NULL ),
                  ProcessorState->SpecialRegisters.Idtr.Limit,
                  ProcNum);

    ASSERT (MmGetPhysicalAddress (HiberFreeCR3[ProcNum][0]).HighPart == 0);

    return MmGetPhysicalAddress (HiberFreeCR3[ProcNum][0]).LowPart;
}

VOID
HalpMapCR3 (
    IN ULONG VirtAddress,
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG Length
    )
/*++

Routine Description:
    Called to build a page table entry for the passed page
    directory.  Used to build a tiled page directory with
    real-mode & flat mode.

Arguments:
    VirtAddress     - Current virtual address
    PhysicalAddress - Optional. Physical address to be mapped
                      to, if passed as a NULL then the physical
                      address of the passed virtual address
                      is assumed.
    Length          - number of bytes to map

Return Value:
    none.

--*/
{
    HalpMapCR3Ex(VirtAddress,PhysicalAddress,Length,0);
}


VOID
HalpMapCR3Ex (
    IN ULONG VirtAddress,
    IN PHYSICAL_ADDRESS PhysicalAddress,
    IN ULONG Length,
    IN ULONG ProcNum
    )
/*++

Routine Description:
    Called to build a page table entry for the passed page
    directory.  Used to build a tiled page directory with
    real-mode & flat mode.

Arguments:
    VirtAddress     - Current virtual address
    PhysicalAddress - Optional. Physical address to be mapped
                      to, if passed as a NULL then the physical
                      address of the passed virtual address
                      is assumed.
    Length          - number of bytes to map

Return Value:
    none.

--*/
{
    ULONG         i;
    PHARDWARE_PTE PTE;
    PVOID         pPageTable;
    PHYSICAL_ADDRESS pPhysicalPage;


    while (Length) {
        PTE = GetPdeAddressEx (VirtAddress,ProcNum);
        if (HalpIsPteFree( PTE ) != FALSE) {
            pPageTable = ExAllocatePoolWithTag(NonPagedPool,
                                               PAGE_SIZE,
                                               HAL_POOL_TAG);
            if (!pPageTable) {

                //
                // This allocation is critical.
                //

                KeBugCheckEx(HAL_MEMORY_ALLOCATION,
                             PAGE_SIZE,
                             6,
                             (ULONG)__FILE__,
                             __LINE__
                             );
            }
            RtlZeroMemory (pPageTable, PAGE_SIZE);

            for (i=0; i < MAX_PT; i++) {
                if (!(HiberFreeCR3[ProcNum][i])) {
                    HiberFreeCR3[ProcNum][i] = pPageTable;
                    break;
                }
            }
            ASSERT (i < MAX_PT);

            pPhysicalPage = MmGetPhysicalAddress (pPageTable);
            HalpSetPageFrameNumber( PTE, pPhysicalPage.QuadPart >> PAGE_SHIFT );
            PTE->Valid = 1;
            PTE->Write = 1;
        }

        pPhysicalPage.QuadPart =
            HalpGetPageFrameNumber( PTE ) << PAGE_SHIFT;

        pPageTable = MmMapIoSpace (pPhysicalPage, PAGE_SIZE, TRUE);

        PTE = GetPteAddress (VirtAddress, pPageTable);

        if (PhysicalAddress.QuadPart == 0) {
            PhysicalAddress = MmGetPhysicalAddress((PVOID)VirtAddress);
        }

        HalpSetPageFrameNumber( PTE, PhysicalAddress.QuadPart >> PAGE_SHIFT );
        PTE->Valid = 1;
        PTE->Write = 1;

        MmUnmapIoSpace (pPageTable, PAGE_SIZE);

        PhysicalAddress.QuadPart = 0;
        VirtAddress += PAGE_SIZE;
        if (Length > PAGE_SIZE) {
            Length -= PAGE_SIZE;
        } else {
            Length = 0;
        }
    }
}

VOID
HalpFreeTiledCR3 (
    VOID
    )
/*++

Routine Description:
    Frees any memory allocated when the tiled page directory
    was built.

Arguments:
    none

Return Value:
    none
--*/
{
    HalpFreeTiledCR3Ex(0);
}

VOID
HalpFreeTiledCR3Ex (
    ULONG ProcNum
    )
/*++

Routine Description:
    Frees any memory allocated when the tiled page directory
    was built.

Arguments:
    none

Return Value:
    none
--*/
{
    ULONG   i;

    for (i = 0; HiberFreeCR3[ProcNum][i]; i++) {

        //
        // Only the very first entry for each processor might have been
        // allocated via MmAllocateContiguousMemory.  So only this one can
        // (and MUST) be freed via MmFreeContiguousMemory.
        //

        if ((i == 0) && (HalPaeEnabled() != FALSE)) {
            MmFreeContiguousMemory (HiberFreeCR3[ProcNum][i]);
        }
        else {
            ExFreePool (HiberFreeCR3[ProcNum][i]);
        }
        HiberFreeCR3[ProcNum][i] = 0;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\mpipi.asm ===
title "Interprocessor Interrupt"
;++
;
;Copyright (c) 1991  Microsoft Corporation
;Copyright (c) 1992  Intel Corporation
;All rights reserved
;
;INTEL CORPORATION PROPRIETARY INFORMATION
;
;This software is supplied to Microsoft under the terms
;of a license agreement with Intel Corporation and may not be
;copied nor disclosed except in accordance with the terms
;of that agreement.
;
;
;Module Name:
;
;    mpipi.asm
;
;Abstract:
;
;    PC+MP IPI code.
;    Provides the HAL support for Interprocessor Interrupts and Processor
;    initialization for PC+MP Systems
;
;Author:
;
;    Ken Reneris (kenr) 13-Jan-1992
;
;Revision History:
;
;    Ron Mosgrove (Intel) Aug 1993
;        Modified for PC+MP Systems
;--
.486p
        .xlist

;
; Normal includes
;

include hal386.inc
include i386\kimacro.inc
include mac386.inc
include apic.inc
include callconv.inc                ; calling convention macros
include ntapic.inc


        EXTRNP  Kei386EoiHelper,0,IMPORT

        EXTRNP  _HalBeginSystemInterrupt,3
        EXTRNP  _HalEndSystemInterrupt,2
        EXTRNP  _KiIpiServiceRoutine,2,IMPORT
        EXTRNP  _HalDisplayString,1
        EXTRNP  HalpAcquireHighLevelLock,1,,FASTCALL
        EXTRNP  HalpReleaseHighLevelLock,2,,FASTCALL
ifdef ACPI_HAL        
        EXTRNP  _DetectAcpiMP,2
else
        EXTRNP  _DetectMPS,1
endif        
        EXTRNP  _HalpRegisterKdSupportFunctions,1
        EXTRNP  _HalpInitializeLocalUnit,0
        EXTRNP  _HalpResetThisProcessor,0
if DBG OR DEBUGGING
        EXTRNP  _DbgBreakPoint,0,IMPORT
endif
        extrn   _HalpDefaultInterruptAffinity:DWORD
        extrn   _HalpActiveProcessors:DWORD

        extrn   _HalpGlobal8259Mask:WORD
        extrn   _HalpStaticIntAffinity:BYTE
        extrn   _HalpPICINTToVector:BYTE
        extrn   _rgzBadHal:BYTE

        extrn   _HalpMaxProcsPerCluster:BYTE
        extrn   _HalpIntDestMap:BYTE


I386_80387_BUSY_PORT    equ     0f0h

SEND_IPI    macro   IpiCommand
    ; Assumption:
    ; TargetProcessors KAFFINITY value is in eax at entry
    ; IpiCommand is a constant(i.e. an immediate value not in a register)

        local HsiGetProcessor, HsiGetNextProcInCluster, HsiDone, HsiSendIpi
        local HsiUseClusterMode, HsiExit

        cmp     _HalpMaxProcsPerCluster, 0
        jne     HsiUseClusterMode

        ; Fewer than 8 processors. Use APIC flat logical mode to send IPI.
        shl     eax, DESTINATION_SHIFT
        pushfd
        cli
        STALL_WHILE_APIC_BUSY
        mov     dword ptr APIC[LU_INT_CMD_HIGH], eax
        APICFIX edx
        mov     dword ptr APIC[LU_INT_CMD_LOW], IpiCommand
        STALL_WHILE_APIC_BUSY
        popfd
        jmp     HsiExit

        ; Use APIC cluster mode to send IPI
HsiUseClusterMode:
        pushad
        pushfd
        mov     ch, 0ffh
HsiGetProcessor:
        test    eax, eax
        jz      HsiDone
@@:
        inc     ch
        shr     eax, 1
        jnc     @b

        ; Found a processor. Get its hardware processor bitmask
        xor     ebx, ebx                ; Avoid partial stall on PentiumPro
        mov     bl, ch
        add     ebx, offset _HalpIntDestMap
        movzx   edx, byte ptr[ebx]

        ; Search for other target processors with the same cluster ID
        mov     edi, eax
        mov     cl, 0ffh
HsiGetNextProcInCluster:
        test    edi, edi
        jz      HsiSendIpi
@@:
        inc     cl
        shr     edi, 1
        jnc     @b
        xor     ebx, ebx
        mov     bl, cl
        add     bl, ch
        add     ebx, offset _HalpIntDestMap
        inc     ebx                     ; Both cl and ch indices are zero based
        movzx   esi, byte ptr[ebx]
        mov     ebx, esi

        ; Compare cluster ID of new processor with current processor
        ; Note that 0 is a valid cluster ID
        shr     bl, 4
        mov     bh, dl
        shr     bh, 4
        cmp     bl, bh
        jne     HsiGetNextProcInCluster

        ; Found another target processor with the same cluster ID. Or it in.
        or      edx, esi
        ; Remove this new processor from the set of remaining processors
        mov     esi, 1
        shl     esi, cl
        not     esi
        and     eax, esi
        jmp     HsiGetNextProcInCluster

HsiSendIpi:
        ; (edx) = Target Processor bitmask
        shl     edx, DESTINATION_SHIFT
        cli
        STALL_WHILE_APIC_BUSY
        mov     dword ptr APIC[LU_INT_CMD_HIGH], edx
        APICFIX edx
        mov     dword ptr APIC[LU_INT_CMD_LOW], IpiCommand
        STALL_WHILE_APIC_BUSY
        jmp     HsiGetProcessor

HsiDone:
        popfd
        popad
HsiExit:

endm  ;; SEND_IPI


_DATA   SEGMENT  DWORD PUBLIC 'DATA'

    ALIGN   dword

        public  _HalpProcessorPCR
_HalpProcessorPCR       dd  MAXIMUM_PROCESSORS dup (?) ; PCR pointer for each processor

;
;  The following symbols are used by the Local Apic Error handler.
;                
LogApicErrors   equ 1
if LogApicErrors

        public _HalpLocalApicErrorLock
        public _HalpLocalApicErrorCount
        public _HalpApicErrorLog

APIC_ERROR_LOG_SIZE     equ     128     ; Must be 2^n see usage below

    ALIGN   dword

_HalpApicErrorLog               dw  APIC_ERROR_LOG_SIZE dup(0)
_HalpLocalApicErrorLock         dd  0
_HalpLocalApicErrorCount        dd  0

    ;
    ; Bit:
    ;
    ;    0 - Send checksum error
    ;    1 - Recieve checksum error
    ;    2 - Send accept error
    ;    3 - Receive accept error
    ;    4 - reserved
    ;    5 - Send illegal vector
    ;    6 - Receive illegal vector
    ;    7 - illegal register address
    ; 8-31 - reserved
    ;


endif ; LogApicErrors

        public HalpBroadcastLock, HalpBroadcastTargets
        public HalpBroadcastFunction, HalpBroadcastContext
HalpBroadcastLock           dd  0
HalpBroadcastFunction       dd  0
HalpBroadcastContext        dd  0
HalpBroadcastTargets        dd  0

_DATA   ends

_TEXT   SEGMENT  DWORD PUBLIC 'DATA'

    ALIGN   dword
;
;   The _PicExtintIntiHandlers and the _PicNopIntiHandlers tables are
;   used by the enable and disable system interrupt routines to determine
;   the EXTINT interrupt handler to install.
;
        public _PicExtintIntiHandlers
_PicExtintIntiHandlers   label   dword
            dd         PicInterruptHandlerInti0     ; Inti 0  - PIC 1
            dd         PicInterruptHandlerInti1     ; Inti 1  - PIC 1
            dd         PicInterruptHandlerInti2     ; Inti 2  - PIC 1
            dd         PicInterruptHandlerInti3     ; Inti 3  - PIC 1
            dd         PicInterruptHandlerInti4     ; Inti 4  - PIC 1
            dd         PicInterruptHandlerInti5     ; Inti 5  - PIC 1
            dd         PicInterruptHandlerInti6     ; Inti 6  - PIC 1
            dd         PicInterruptHandlerInti7     ; Inti 7  - PIC 1
            dd         PicInterruptHandlerInti8     ; Inti 8  - PIC 2
            dd         PicInterruptHandlerInti9     ; Inti 9  - PIC 2
            dd         PicInterruptHandlerIntiA     ; Inti 10 - PIC 2
            dd         PicInterruptHandlerIntiB     ; Inti 11 - PIC 2
            dd         PicInterruptHandlerIntiC     ; Inti 12 - PIC 2
            dd         PicInterruptHandlerIntiD     ; Inti 13 - PIC 2
            dd         PicInterruptHandlerIntiE     ; Inti 14 - PIC 2
            dd         PicInterruptHandlerIntiF     ; Inti 15 - PIC 2

        public _PicNopIntiHandlers
_PicNopIntiHandlers   label   dword
            dd         PicNopHandlerInti0     ; Inti 0  - PIC 1
            dd         PicNopHandlerInti1     ; Inti 1  - PIC 1
            dd         PicNopHandlerInti2     ; Inti 2  - PIC 1
            dd         PicNopHandlerInti3     ; Inti 3  - PIC 1
            dd         PicNopHandlerInti4     ; Inti 4  - PIC 1
            dd         PicNopHandlerInti5     ; Inti 5  - PIC 1
            dd         PicNopHandlerInti6     ; Inti 6  - PIC 1
            dd         PicNopHandlerInti7     ; Inti 7  - PIC 1
            dd         CommonPic2NopHandler   ; Inti 8  - PIC 2
            dd         CommonPic2NopHandler   ; Inti 9  - PIC 2
            dd         CommonPic2NopHandler   ; Inti 10 - PIC 2
            dd         CommonPic2NopHandler   ; Inti 11 - PIC 2
            dd         CommonPic2NopHandler   ; Inti 12 - PIC 2
            dd         PicNopHandlerIntiD     ; Inti 13 - PIC 2
            dd         CommonPic2NopHandler   ; Inti 14 - PIC 2
            dd         CommonPic2NopHandler   ; Inti 15 - PIC 2

_TEXT   ends

        page ,132
        subttl  "Post InterProcessor Interrupt"
_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING


;++
;
; VOID
; HalInitializeProcessor(
;       ULONG   Number
;       PVOID   LoaderBlock
;       );
;
;Routine Description:
;
;    Initialize hal pcr values for current processor (if any)
;    (called shortly after processor reaches kernel, before
;    HalInitSystem if P0)
;
;    IPI's and KeReadir/LowerIrq's must be available once this function
;    returns.  (IPI's are only used once two or more processors are
;    available)
;
;   . Enable IPI interrupt (makes sense for P1, P2, ...).
;   . Save Processor Number in PCR.
;   . if (P0)
;       . determine if the system is a PC+MP,
;       . if not a PC+MP System Halt;
;   . Enable IPI's on CPU.
;
;Arguments:
;
;    Number - Logical processor number of calling processor
;
;Return Value:
;
;    None.
;
;--
cPublicProc _HalInitializeProcessor ,2

        mov     PCR[PcIDR], 0FFFFFFFFH            ; mark all INTs as disabled

        movzx   eax, byte ptr [esp+4]
        mov     PCR[PcHal.PcrNumber], al          ; Save processor # in PCR

        mov     ecx, PCR[PcSelfPcr]               ; Flat address of this PCR
        mov     _HalpProcessorPCR[eax*4], ecx   ; Save it away

        mov     dword ptr PCR[PcStallScaleFactor], INITIAL_STALL_COUNT

        ;
        ; set bit in affinity mask for this active processor
        ;

        lock bts _HalpActiveProcessors, eax

        ;
        ; set interrupt affinity to either be most-significant processor or
        ; a set of all processors
        ;

        mov     edx, eax
        mov     eax, _HalpDefaultInterruptAffinity

hip10:  cmp     _HalpStaticIntAffinity, 1           ; Signle or all?
        sbb     ecx, ecx                            ; set mask 0 or -1
        and     ecx, eax                            ; include existing set or not
        bts     ecx, edx                            ; include self

        cmp     ecx, eax                            ; new mask a better choice?
        jc      short hip20                         ; no, done

        lock cmpxchg _HalpDefaultInterruptAffinity, ecx     ; set new mask
        jnz     short hip10                         ; if it didn't take, do it again
hip20:


        ;
        ;  Most of the following code is only needed on P0
        ;

        or      edx, edx
        jnz     PnInitCode                  ; Not P0 skip a lot

        ; Run on P0 only

        ;
        ;  Determine if the system we are on is an PC+MP
        ;
        ;  DetectMPS has a parameter we don't currently use.  It's a boolean
        ;  which is set to TRUE if the system we're on is a MP system.  Remember,
        ;  we could have a UP PC+MP system.
        ;
        ;  The DetectMPS routine also allocates Virtual Addresses for all of
        ;  the APIC's in the system (it needs to access the devices anyway so ...)
        ;

        sub     esp, 4
ifdef ACPI_HAL
        mov     eax, esp
        stdCall _DetectAcpiMP <eax, [esp + 12]> ; Are we running on an ACPI MP
else        
        stdCall _DetectMPS <esp>                ; Are we running on an PC+MP
endif        
        add     esp,4

        cmp     eax, 0                          ;  Yes (nonZero) or
        je      NotPcMp                         ;  No (Zero)

;        stdCall _HalDisplayString, <offset HalSignonString>

        ;
        ; This next call has nothing to do with processor init.
        ; But this is the only function in the HAL that gets 
        ; called before KdInit.
        ;
        stdCall _HalpRegisterKdSupportFunctions <[esp + 8]>

        mov      ax, 0FFFFH                     ; mask all PIC interrupts
        mov     _HalpGlobal8259Mask, ax         ; save the mask
        SET_8259_MASK

        ;
        ; Other P0 initialization would go here
        ;
        jmp CommonInitCode

PnInitCode:
        ;
        ; Pn initialization goes here
        ;

CommonInitCode:

        stdCall  _HalInitApicInterruptHandlers

        ;
        ; initialize the APIC local unit for this Processor
        ;

        stdCall   _HalpInitializeLocalUnit

        stdRET    _HalInitializeProcessor

NotPcMp:
        stdCall   _HalDisplayString, <offset _rgzBadHal>
        hlt

stdENDP _HalInitializeProcessor

D_INT032                EQU     8E00h   ; access word for 386 ring 0 interrupt gate

;++
;
; VOID
; HalInitApicInterruptHandlers(
;       );
;
;Routine Description:
;
;    This routine installs the interrupt vector in the IDT for the APIC
;    spurious interrupt.
;
;Arguments:
;
;    None.
;
;Return Value:
;
;    None.
;
;--
cPublicProc _HalInitApicInterruptHandlers  ,0
        enter   8,0         ; setup ebp, reserve 8 bytes of stack

        sidt    fword ptr [ebp-8]           ; get IDT address
        mov     edx, [ebp-6]                ; (edx)->IDT

        mov     ecx, PIC1_SPURIOUS_VECTOR            ; Spurious Vector
        mov     eax, offset FLAT:PicSpuriousService37
        mov     word ptr [edx+8*ecx], ax    ; Lower half of handler addr
        mov     word ptr [edx+8*ecx+2], KGDT_R0_CODE  ; set up selector
        mov     word ptr [edx+8*ecx+4], D_INT032      ; 386 interrupt gate
        shr     eax, 16                 ; (ax)=higher half of handler addr
        mov     word ptr [edx+8*ecx+6], ax

        mov     ecx, APIC_SPURIOUS_VECTOR             ; Apic Spurious Vector
        mov     eax, offset FLAT:_HalpApicSpuriousService
        mov     word ptr [edx+8*ecx], ax    ; Lower half of handler addr
        mov     word ptr [edx+8*ecx+2], KGDT_R0_CODE  ; set up selector
        mov     word ptr [edx+8*ecx+4], D_INT032      ; 386 interrupt gate
        shr     eax, 16                     ; (ax)=higher half of handler addr
        mov     word ptr [edx+8*ecx+6], ax

        leave
        stdRET _HalInitApicInterruptHandlers
stdENDP _HalInitApicInterruptHandlers

cPublicProc PicSpuriousService37  ,0
    iretd
stdENDP PicSpuriousService37

;++
;
; VOID
; HalpApicRebootService(
;       );
;
;Routine Description:
;
;   This is the ISR that handles Reboot events
;
;--

    ENTER_DR_ASSIST HReboot_a, HReboot_t
cPublicProc _HalpApicRebootService  ,0
        ENTER_INTERRUPT_FORCE_STATE HReboot_a, HReboot_t  ; (ebp) -> Trap frame

        mov     eax, APIC_REBOOT_VECTOR

        mov     ecx, dword ptr APIC[LU_TPR]     ; get the old TPR
        push    ecx                             ; save it
        mov     dword ptr APIC[LU_TPR], eax     ; set the TPR
        APICFIX edx

        ;
        ;  EOI the local APIC, warm reset does not reset the 82489 APIC
        ;  so if we don't EOI here we'll never see an interrupt after
        ;  the reboot.
        ;

        mov     dword ptr APIC[LU_EOI], 0       ; send EOI to APIC local unit

        stdCall _HalpResetThisProcessor

        ;
        ;  We should never get here, but just in case someone is stepping
        ;  through this
        ;

        pop     eax
        mov     dword ptr APIC[LU_TPR], eax     ; reset the TPR
        APICFIX edx

        ;
        ; Do interrupt exit processing without EOI
        ;

        SPURIOUS_INTERRUPT_EXIT

stdENDP _HalpApicRebootService

;++
;
; VOID
; HalpGenericCallService(
;       );
;
; Routine Description:
;   This is the ISR that handles the GenericCall interrupt
;
;--
    ENTER_DR_ASSIST HGeneric_a, HGeneric_t
cPublicProc _HalpBroadcastCallService  ,0
        ENTER_INTERRUPT HGeneric_a, HGeneric_t  ; (ebp) -> Trap frame
;
; (esp) - base of trap frame
;
; dismiss interrupt and raise Irql
;
        push    APIC_GENERIC_VECTOR
        sub     esp, 4                  ; allocate space to save OldIrql
        stdCall _HalBeginSystemInterrupt, <CLOCK2_LEVEL-1,APIC_GENERIC_VECTOR,esp>

        call    _HalpPollForBroadcast

        INTERRUPT_EXIT          ; lower irql to old value, iret

stdENDP _HalpBroadcastCallService

;++
;
; VOID
; HalpGenericCall(
;       IN VOID (*WorkerFunction)(VOID),
;       IN ULONG Context,
;       IN KAFFINITY TargetProcessors
;       );
;
; Routine Description:
;   Causes the WorkerFunction to be called on the specified target
;   processors.  The WorkerFunction is called at CLOCK2_LEVEL-1
;   (Must be below IPI_LEVEL in order to prevent system deadlocks).
;
; Enviroment:
;   Must be called with interrupts enabled.
;   Must be called with IRQL = CLOCK2_LEVEL-1
;--

cPublicProc _HalpGenericCall,3
cPublicFpo 3, 0

GENERIC_IPI equ (DELIVER_FIXED OR LOGICAL_DESTINATION OR ICR_USE_DEST_FIELD OR APIC_GENERIC_VECTOR)

@@:     call    _HalpPollForBroadcast
        test    HalpBroadcastLock, 1        ; Is broadcast busy?
        jnz     short @b                    ; Yes, wait

   lock bts     HalpBroadcastLock, 0        ; Try to get lock
        jc      short @b                    ; didn't get it, loop

hgc30:  mov     ecx, [esp+4]
        mov     edx, [esp+8]
        mov     eax, [esp+12]
        mov     HalpBroadcastFunction, ecx
        mov     HalpBroadcastContext, edx
        mov     HalpBroadcastTargets, eax

        or      eax, eax                    ; (eax) = Targets
        jz      gc90

        SEND_IPI  GENERIC_IPI

;
; Wait for all processors to call broadcast function
;

@@:     call    _HalpPollForBroadcast
        cmp     HalpBroadcastTargets, 0
        jnz     short @b

gc90:   mov     HalpBroadcastLock, 0        ; Release BroadcastLock
        stdRET  _HalpGenericCall

stdENDP _HalpGenericCall

;++
;
; VOID
; _HalpPollForBroadcast (
;       VOID
;       );
;
; Routine Description:
;
;   IRQL = CLOCK2_LEVEL-1
;--
cPublicProc _HalpPollForBroadcast, 0
cPublicFpo 0, 0
        mov     eax, PCR[PcSetMember]
        test    HalpBroadcastTargets, eax
        jz      short pb90

        mov     ecx, HalpBroadcastFunction  ; Pickup broadcast function
        push    HalpBroadcastContext

        not     eax                         ; Remove our bit from destionations
   lock and     HalpBroadcastTargets, eax

        call    ecx

pb90:   stdRET  _HalpPollForBroadcast

stdENDP _HalpPollForBroadcast

;++
;
; ULONG
; FASTCALL
; HalpWaitForPending (
;       ULONG   Count   (ecx)
;       PULONG  LuICR   (edx)
;       );
;
; Routine Description:
;
;   Waits for DELIVERY_PENDING to clear and returns remaining iteration count
;--
cPublicFastCall HalpWaitForPending, 2
cPublicFpo 0, 0

wfp10:  test    dword ptr [edx], DELIVERY_PENDING
        jz      short wfp20

        dec     ecx
        jnz     short wfp10

wfp20:  mov     eax, ecx
        fstRet  HalpWaitForPending

fstENDP HalpWaitForPending


;++
;
; VOID
; HalpLocalApicErrorService(
;       );
;
;Routine Description:
;
;   This routine fields Local APIC error Events
;
;--

    ENTER_DR_ASSIST HApicErr_a, HApicErr_t

cPublicProc _HalpLocalApicErrorService  ,0

;
; Save machine state in trap frame
;

    ENTER_INTERRUPT HApicErr_a, HApicErr_t  ; (ebp) -> Trap frame

if LogApicErrors

        lea     ecx, _HalpLocalApicErrorLock
        fstCall HalpAcquireHighLevelLock
        push    eax

        mov     eax, _HalpLocalApicErrorCount
        inc     _HalpLocalApicErrorCount

        lea     ecx, _HalpApicErrorLog

        and     eax, APIC_ERROR_LOG_SIZE-1
        shl     eax, 1
        add     ecx, eax

endif ; LogApicErrors

        mov     dword ptr APIC[LU_EOI], 0   ; local unit EOI
        APICFIX eax

        ;
        ;  The Apic EDS (Rev 4.0) says you have to write before you read
        ;  this doesn't work.  The write clears the status bits.
        ;  But P6 works as according to the EDS!
        ;

        mov     eax, PCR[PcPrcb]
        cmp     byte ptr [eax].PbCpuType, 6
        jc      short lae10
        mov     dword ptr APIC[LU_ERROR_STATUS], 0

lae10:
        mov     eax, dword ptr APIC[LU_ERROR_STATUS] ; read error status


        ; Find out what kind of error it is and update the appropriate count.

if LogApicErrors
;    out     80h, al
        mov     byte ptr [ecx], al
        inc     ecx
        mov     al,  byte ptr PCR[PcHal.PcrNumber]
        mov     byte ptr [ecx], al

        lea     ecx, _HalpLocalApicErrorLock
        pop     edx
        fstCall HalpReleaseHighLevelLock

endif ; LogApicErrors

        SPURIOUS_INTERRUPT_EXIT     ; exit interrupt without eoi
stdENDP _HalpLocalApicErrorService

;++
;
; VOID
; HalRequestIpi(
;       IN ULONG Mask
;       );
;
;Routine Description:
;
;    Requests an interprocessor interrupt
;
;Arguments:
;
;    Mask - Supplies a mask of the processors to be interrupted
;
;Return Value:
;
;    None.
;
;--
APIC_IPI equ (DELIVER_FIXED OR LOGICAL_DESTINATION OR ICR_USE_DEST_FIELD OR APIC_IPI_VECTOR)

cPublicProc _HalRequestIpi  ,1
cPublicFpo 1, 0

        mov     eax, [esp+4]            ; (eax) = Processor bitmask

        SEND_IPI    APIC_IPI

        stdRET    _HalRequestIpi

stdENDP _HalRequestIpi

        page ,132
        subttl  "PC+MP IPI Interrupt Handler"
;++
;
; VOID
; HalpIpiHandler (
;    );
;
; Routine Description:
;
;    This routine is entered as the result of an interrupt generated by inter
;    processor communication.
;
; Arguments:
;
;    None.
;
; Return Value:
;
;    None.
;
;--

        ENTER_DR_ASSIST Hipi_a, Hipi_t

cPublicProc  _HalpIpiHandler    ,0

;
; Save machine state in trap frame
;

        ENTER_INTERRUPT Hipi_a, Hipi_t  ; (ebp) -> Trap frame

;
; Save previous IRQL
;
        push    APIC_IPI_VECTOR             ; Vector
        sub     esp, 4                      ; space for OldIrql
;
; We now dismiss the interprocessor interrupt and call its handler
;

        stdCall _HalBeginSystemInterrupt,<IPI_LEVEL,APIC_IPI_VECTOR,esp>

        stdCall _KiIpiServiceRoutine, <ebp,0>

;
; Do interrupt exit processing
;

        INTERRUPT_EXIT                      ; will return to caller

stdENDP _HalpIpiHandler

;++
;
; VOID
; HalpApicSpuriousService(
;       );
;
;Routine Description:
;
;   A place for spurious interrupts to end up.
;
;--
cPublicProc _HalpApicSpuriousService,0
        iretd
stdENDP _HalpApicSpuriousService


;++
;
; VOID
; _PicInterruptHandlerIntiXX(
;       );
;
;Routine Description:
;
;   These handlers receive interrupts from the PIC and reissues them via
;   a vector at the proper priority level.  This is used to provide a symetric
;   interrupt distribution on a non symetric system.
;
;   The PIC interrupts will normally only be received (in the PC+MP Hal) via an
;   interrupt input from on either the IO Unit or the Local unit which has been
;   programed as EXTINT.  EXTINT interrupts are received outside of the APIC
;   priority structure (the PIC provides the vector).  We use the APIC ICR to
;   generate interrupts to the proper handler at the proper priority.
;
;   The EXTINT interrupts are directed to a single processor, currently P0.
;   There is no good reason why they can't be directed to another processor.
;
;   Since one processor must absorb the overhead of redistributing PIC interrupts
;   the interrupt handling on a system using EXTINT interrupts is not symetric.
;
;--

        ENTER_DR_ASSIST Hcpic_a, Hcpic_t

cPublicProc PicHandler  ,0

PicInterruptHandlerInti0:
        push    0
        jmp     short CommonPicHandler

PicInterruptHandlerInti1:
        push    1
        jmp     short CommonPicHandler

PicInterruptHandlerInti2:
        push    2
        jmp     short CommonPicHandler

PicInterruptHandlerInti3:
        push    3
        jmp     short CommonPicHandler

PicInterruptHandlerInti4:
        push    4
        jmp     short CommonPicHandler

PicInterruptHandlerInti5:
        push    5
        jmp     short CommonPicHandler

PicInterruptHandlerInti6:
        push    6
        jmp     short CommonPicHandler

PicInterruptHandlerInti7:
;
; Check to see if this is a spurious interrupt
;
        push    eax
        mov     al, OCW3_READ_ISR       ; tell 8259 we want to read ISR
        out     PIC1_PORT0, al
        IODelay                         ; delay
        in      al, PIC1_PORT0          ; (al) = content of PIC 1 ISR
        test    al, 10000000B           ; Is In-Service register set?
        pop     eax
        jz      short pic7_spurious     ;

        push    7
        jmp     short CommonPicHandler

picf_spurious:
        mov     al, OCW2_SPECIFIC_EOI OR SlavePicInti   ; specific eoi to master for pic2 eoi
        out     PIC1_PORT0, al
        pop     eax
pic7_spurious:
        iretd                           ; ignore PIC

PicInterruptHandlerInti8:
        push    8
        jmp     short CommonPicHandler

PicInterruptHandlerInti9:
        push    9
        jmp     short CommonPicHandler

PicInterruptHandlerIntiA:
        push    10
        jmp     short CommonPicHandler

PicInterruptHandlerIntiB:
        push    11
        jmp     short CommonPicHandler

PicInterruptHandlerIntiC:
        push    12
        jmp     short CommonPicHandler

PicInterruptHandlerIntiD:
        push    13
        push    eax
        xor     eax, eax
        out     I386_80387_BUSY_PORT, al
        pop     eax
        jmp     short CommonPicHandler

PicInterruptHandlerIntiE:
        push    14
        jmp     short CommonPicHandler

PicInterruptHandlerIntiF:
        push    eax
        mov     al, OCW3_READ_ISR       ; tell 8259 we want to read ISR
        out     PIC2_PORT0, al
        IODelay                         ; delay
        in      al, PIC2_PORT0          ; (al) = content of PIC 1 ISR
        test    al, 10000000B           ; Is In-Service register set?
        jz      short picf_spurious     ; Go eoi PIC1 & Ignore PIC2

        pop     eax
        push    15
        jmp     short CommonPicHandler

CommonPicHandler:
        ENTER_INTERRUPT Hcpic_a, Hcpic_t,PassDwordParm ; (ebp) -> Trap frame

;
;  Need to determine if we have a level interrupt and if so don't EOI it
;  It should be EOI'd by end system interrupt
;

        cmp     bl, 8                           ; Pic or Slave Pic
        jae     short cph20

        mov     al, bl
        or      al, OCW2_SPECIFIC_EOI           ; specific eoi
        out     PIC1_PORT0, al                  ; dismiss the interrupt
        jmp     short cph30

cph20:
        mov     al, OCW2_NON_SPECIFIC_EOI               ; send non specific eoi to slave
        out     PIC2_PORT0, al
        mov     al, OCW2_SPECIFIC_EOI OR SlavePicInti   ; specific eoi to master for pic2 eoi
        out     PIC1_PORT0, al                          ; send irq2 specific eoi to master

cph30:
        mov     al, _HalpPICINTToVector[ebx]    ; Get vector for PIC interrupt
        or      al, al                          ; Is vector known?
        jz      short cph90                     ; No, don't dispatch it

;
;  Now gain exclusive access to the ICR
;

        STALL_WHILE_APIC_BUSY

        cmp     bl, 8
        je      short HandleClockInti

;
; Write the IPI Command to the Memory Mapped Register
;

        mov     dword ptr APIC[LU_INT_CMD_HIGH], DESTINATION_ALL_CPUS
        APICFIX edx
        mov     dword ptr APIC[LU_INT_CMD_LOW], eax
        jmp     short cph90


HandleClockInti:
;
; Write the IPI Command to the Memory Mapped Register
;

        mov     dword ptr APIC[LU_INT_CMD_LOW], (DELIVER_FIXED OR ICR_SELF OR APIC_CLOCK_VECTOR)


cph90:  APICFIX edx
        SPURIOUS_INTERRUPT_EXIT     ; exit interrupt without eoi

stdENDP PicHandler


;++
;
; VOID
; _PicXXNopHandler(
;       );
;
;Routine Description:
;
;   These handlers are designed to be installed on a system to field any PIC
;   interrupts when there are not supposed to be any delivered.
;
;   In the Debug case this routine increments an error count EOI's the PIC and
;   returns.  Normally the increment is not performed.
;--



cPublicProc PicNopHandler ,0

PicNopHandlerInti0:
        push    eax                                 ; Save Scratch Registers
        mov     al, 0
        jmp     short CommonPic1NopHandler

PicNopHandlerInti1:
        push    eax                                 ; Save Scratch Registers
        mov     al, 1
        jmp     short CommonPic1NopHandler

PicNopHandlerInti2:
        push    eax                                 ; Save Scratch Registers
        mov     al, 2
        jmp     short CommonPic1NopHandler

PicNopHandlerInti3:
        push    eax                                 ; Save Scratch Registers
        mov     al, 3
        jmp     short CommonPic1NopHandler

PicNopHandlerInti4:
        push    eax                                 ; Save Scratch Registers
        mov     al, 4
        jmp     short CommonPic1NopHandler

PicNopHandlerInti5:
        push    eax                                 ; Save Scratch Registers
        mov     al, 5
        jmp     short CommonPic1NopHandler

PicNopHandlerInti6:
        push    eax                                 ; Save Scratch Registers
        mov     al, 6
        jmp     short CommonPic1NopHandler

PicNopHandlerInti7:
        push    eax                                 ; Save Scratch Registers
        mov     al, 7

CommonPic1NopHandler:
    ;
    ;  Need to determine if we have a level interrupt and if so don't EOI it
    ;  It should be EOI'd by end system interrupt
    ;

        or      al, OCW2_SPECIFIC_EOI                   ; specific eoi
        out     PIC1_PORT0, al                          ; dismiss the interrupt
        pop     eax                                     ; Restore Scratch registers
        iretd

PicNopHandlerIntiD:
        push    eax
        xor     eax, eax
        out     I386_80387_BUSY_PORT, al
        pop     eax

CommonPic2NopHandler:
        push    eax

;
;  Need to determine if we have a level interrupt and if so don't EOI it
;  It should be EOI'd by end system interrupt
;

        mov     al, OCW2_NON_SPECIFIC_EOI               ; send non specific eoi to slave
        out     PIC2_PORT0, al
        mov     al, OCW2_SPECIFIC_EOI OR SlavePicInti   ; specific eoi to master for pic2 eoi
        out     PIC1_PORT0, al                          ; send irq2 specific eoi to master
        pop     eax
        iretd

stdENDP PicNopHandler


_TEXT   ENDS

        END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\hals\halmps\i386\mpspin.asm ===
if NT_INST

else
        TITLE   "Spin Locks"
;++
;
;  Copyright (c) 1989-1998  Microsoft Corporation
;
;  Module Name:
;
;     spinlock.asm
;
;  Abstract:
;
;     This module implements x86 spinlock functions for the PC+MP HAL.
;
;  Author:
;
;     Bryan Willman (bryanwi) 13 Dec 89
;
;  Environment:
;
;     Kernel mode only.
;
;  Revision History:
;
;   Ron Mosgrove (o-RonMo) Dec 93 - modified for PC+MP HAL.
;--

        PAGE

.486p

include callconv.inc                    ; calling convention macros
include i386\kimacro.inc
include hal386.inc
include mac386.inc
include apic.inc
include ntapic.inc

        EXTRNP _KeBugCheckEx,5,IMPORT
        EXTRNP KfRaiseIrql, 1,,FASTCALL
        EXTRNP KfLowerIrql, 1,,FASTCALL
        EXTRNP _KeSetEventBoostPriority, 2, IMPORT
        EXTRNP _KeWaitForSingleObject,5, IMPORT
        extrn  _HalpVectorToIRQL:byte
        extrn  _HalpIRQLtoTPR:byte

ifdef NT_UP
    LOCK_ADD        equ   add
    LOCK_DEC        equ   dec
    LOCK_CMPXCHG    equ   cmpxchg
else
    LOCK_ADD        equ   lock add
    LOCK_DEC        equ   lock dec
    LOCK_CMPXCHG    equ   lock cmpxchg
endif


_TEXT   SEGMENT PARA PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:FLAT, FS:NOTHING, GS:NOTHING

        PAGE
        SUBTTL "Acquire Kernel Spin Lock"
;++
;
;  KIRQL
;  FASTCALL
;  KfAcquireSpinLock (
;     IN PKSPIN_LOCK SpinLock
;     )
;
;  Routine Description:
;
;     This function raises to DISPATCH_LEVEL and then acquires a the
;     kernel spin lock.
;
;  Arguments:
;
;     (ecx) = SpinLock - Supplies a pointer to a kernel spin lock.
;
;  Return Value:
;
;     OldIrql  (TOS+8) - pointer to place old irql.
;
;--

align 16
cPublicFastCall KfAcquireSpinLock  ,1
cPublicFpo 0,0

        mov     edx, dword ptr APIC[LU_TPR]     ; (edx) = Old Priority (Vector)
        mov     dword ptr APIC[LU_TPR], DPC_VECTOR ; Write New Priority to the TPR

        shr     edx, 4
        movzx   eax, _HalpVectorToIRQL[edx]     ; (al) = OldIrql

ifndef NT_UP

        ;
        ;   Attempt to assert the lock
        ;

sl10:   ACQUIRE_SPINLOCK    ecx,<short sl20>
        fstRET  KfAcquireSpinLock

        ;
        ; Lock is owned, spin till it looks free, then go get it again.
        ;

        align dword

sl20:   SPIN_ON_SPINLOCK    ecx,sl10
endif


        fstRET  KfAcquireSpinLock
fstENDP KfAcquireSpinLock


        PAGE
        SUBTTL "Acquire Kernel Spin Lock"
;++
;
;  KIRQL
;  FASTCALL
;  KeAcquireSpinLockRaiseToSynch (
;     IN PKSPIN_LOCK SpinLock
;     )
;
;  Routine Description:
;
;     This function acquires the SpinLock at SYNCH_LEVEL.  The function
;     is optimized for hotter locks (the lock is tested before acquiring,
;     and any spin occurs at OldIrql).
;
;  Arguments:
;
;     (ecx) = SpinLock - Supplies a pointer to a kernel spin lock.
;
;  Return Value:
;
;     OldIrql  (TOS+8) - pointer to place old irql.
;
;--

align 16
cPublicFastCall KeAcquireSpinLockRaiseToSynch,1
cPublicFpo 0,0

        mov     edx, dword ptr APIC[LU_TPR]     ; (ecx) = Old Priority (Vector)
        mov     eax, edx
        shr     eax, 4
        movzx   eax, _HalpVectorToIRQL[eax]     ; (al) = OldIrql

ifdef NT_UP
        mov     dword ptr APIC[LU_TPR], APIC_SYNCH_VECTOR   ; Write New Priority to the TPR
        fstRET  KeAcquireSpinLockRaiseToSynch
else

        ;
        ; Test lock
        ;

        TEST_SPINLOCK   ecx,<short sls30>

        ;
        ; Raise irql.
        ;

sls10:  mov     dword ptr APIC[LU_TPR], APIC_SYNCH_VECTOR

        ;
        ; Attempt to assert the lock
        ;

        ACQUIRE_SPINLOCK    ecx,<short sls20>
        fstRET  KeAcquireSpinLockRaiseToSynch

        ;
        ; Lock is owned, spin till it looks free, then go get it
        ;

        align dword

sls20:  mov     dword ptr APIC[LU_TPR], edx

    align dword
sls30:  SPIN_ON_SPINLOCK    ecx,sls10
endif

fstENDP KeAcquireSpinLockRaiseToSynch



ifndef NT_UP
;++
;
;  KIRQL
;  FASTCALL
;  KeAcquireSpinLockRaiseToSynchMCE (
;     IN PKSPIN_LOCK SpinLock
;     )
;
;  Routine Description:
;
;     This function performs the same function as KeAcquireSpinLockRaiseToSynch
;     but provides a work around for an IFU errata for Pentium Pro processors
;     prior to stepping 619.
;
;  Arguments:
;
;     (ecx) = SpinLock - Supplies a pointer to a kernel spin lock.
;
;  Return Value:
;
;     OldIrql  (TOS+8) - pointer to place old irql.
;
;--

align 16
cPublicFastCall KeAcquireSpinLockRaiseToSynchMCE,1
cPublicFpo 0,0

        mov     edx, dword ptr APIC[LU_TPR]     ; (ecx) = Old Priority (Vector)
        mov     eax, edx
        shr     eax, 4
        movzx   eax, _HalpVectorToIRQL[eax]     ; (al) = OldIrql

        ;
        ; Test lock
        ;
        ; TEST_SPINLOCK   ecx,<short slm30>   ; NOTE - Macro expanded below:

        test    dword ptr [ecx], 1
        nop                           ; On a P6 prior to stepping B1 (619), we
        nop                           ; need these 5 NOPs to ensure that we
        nop                           ; do not take a machine check exception.
        nop                           ; The cost is just 1.5 clocks as the P6
        nop                           ; just tosses the NOPs.

        jnz     short slm30

        ;
        ; Raise irql.
        ;

slm10:  mov     dword ptr APIC[LU_TPR], APIC_SYNCH_VECTOR

        ;
        ; Attempt to assert the lock
        ;

        ACQUIRE_SPINLOCK    ecx,<short slm20>
        fstRET  KeAcquireSpinLockRaiseToSynchMCE

        ;
        ; Lock is owned, spin till it looks free, then go get it
        ;

        align dword

slm20:  mov     dword ptr APIC[LU_TPR], edx

    align dword
slm30:  SPIN_ON_SPINLOCK    ecx,slm10

fstENDP KeAcquireSpinLockRaiseToSynchMCE
endif


        PAGE
        SUBTTL "Release Kernel Spin Lock"

;++
;
;  VOID
;  FASTCALL
;  KeReleaseSpinLock (
;     IN PKSPIN_LOCK SpinLock,
;     IN KIRQL       NewIrql
;     )
;
;  Routine Description:
;
;     This function releases a kernel spin lock and lowers to the new irql.
;
;  Arguments:
;
;     (ecx) = SpinLock - Supplies a pointer to a kernel spin lock.
;     (dl)  = NewIrql  - New irql value to set.
;
;  Return Value:
;
;     None.
;
;--
align 16
cPublicFastCall KfReleaseSpinLock  ,2
cPublicFpo 0,0
        xor     eax, eax
        mov     al, dl                  ; (eax) =  new irql value

ifndef NT_UP
        RELEASE_SPINLOCK    ecx         ; release spinlock
endif

        xor     ecx, ecx
        mov     cl, _HalpIRQLtoTPR[eax] ; get TPR value corresponding to IRQL
        mov     dword ptr APIC[LU_TPR], ecx

        ;
        ; We have to ensure that the requested priority is set before
        ; we return.  The caller is counting on it.
        ;

        mov     eax, dword ptr APIC[LU_TPR]
if DBG
        cmp     ecx, eax                ; Verify IRQL read back is same as
        je      short @f                ; set value
        int 3
@@:
endif
        fstRET  KfReleaseSpinLock

fstENDP KfReleaseSpinLock

;++
;
;  KIRQL
;  FASTCALL
;  HalpAcquireHighLevelLock (
;     IN PKSPIN_LOCK SpinLock
;     )
;
;  Routine Description:
;
;    Acquires a spinlock with interrupts disabled.
;
; Arguments:
;
;    (ecx) = SpinLock - Supplies a pointer to a kernel spin lock.
;
; Return Value:
;
;    OldIrql  (TOS+8) - pointer to place old irql.
;
;--

cPublicFastCall