#include "precomp.hpp"


GpStatus
GpPath::MoveTo(const GpPointF point)
{
    INT origCount = GetPointCount();

    GpPointF* pointbuf = Points.AddMultiple(1);
    BYTE* typebuf = Types.AddMultiple(1);

    if (pointbuf == NULL || typebuf == NULL)
    {
        Points.SetCount(origCount);
        Types.SetCount(origCount);

        return OutOfMemory;
    }

    *typebuf = PathPointTypeStart;
    SubpathCount++;         // start a new subpath

    GpMemcpy(pointbuf, (PVOID)&point, sizeof(GpPointF));
    
    IsSubpathActive = TRUE;

    return Ok;
}


BOOL APIENTRY PATHOBJ_bMoveTo(
    PVOID      *ppo,
    POINTFIX    ptfx
    )
{
    GpPointF point(FIX4TOREAL(ptfx.x), FIX4TOREAL(ptfx.y));
    GpPath *path = (GpPath*)ppo;
    
    return (path->MoveTo(point) == Ok ? TRUE : FALSE);
}


GpStatus
GpPath::AddPoints(
    const GpPointF *points,
    ULONG count,
    PathPointType pointType)
{
    if (pointType != PathPointTypeLine && pointType != PathPointTypeBezier)
        return InvalidParameter;
    
    INT origCount = GetPointCount();

    GpPointF* pointbuf = Points.AddMultiple(count);
    BYTE* typebuf = Types.AddMultiple(count);

    if(pointbuf == NULL || typebuf == NULL)
    {
        // Resize the original size.

        Points.SetCount(origCount);
        Types.SetCount(origCount);

        return OutOfMemory;
    }

    // Copy path point data

    GpMemcpy(pointbuf, points, count*sizeof(GpPointF));
    GpMemset(typebuf, pointType, count);

    return Ok;
}

#define POINTS_BUFFER_SIZE   3*6

BOOL APIENTRY PATHOBJ_bPolyLineTo(
    PVOID     *ppo,
    POINTFIX  *pptfx,
    ULONG      cptfx
    )
{
    GpPath *path = (GpPath*)ppo;
    GpPointF *points = NULL, apoint[POINTS_BUFFER_SIZE];
    BOOL ret = FALSE;
    
    if (!path->IsValid() || !pptfx || cptfx == 0)
        return FALSE;
    
    if (cptfx > POINTS_BUFFER_SIZE)
    {
        points = new GpPointF[cptfx];
        
        if (points == NULL)
            return FALSE;
    }
    else
        points = apoint;

    // convert FIX4 to REAL

    for (ULONG i = 0; i < cptfx; i++)
    {
        points[i].X = FIX4TOREAL(pptfx[i].x);
        points[i].Y = FIX4TOREAL(pptfx[i].y);
    }
        
    if (path->AddPoints(points, cptfx, PathPointTypeLine) == Ok)
        ret = TRUE;
    
    if (points != apoint)
        delete [] points;
    
    return ret;
}


BOOL APIENTRY PATHOBJ_bPolyBezierTo(
    PVOID     *ppo,
    POINTFIX  *pptfx,
    ULONG      cptfx
    )
{
    GpPath *path = (GpPath*)ppo;
    GpPointF *points = NULL, apoint[POINTS_BUFFER_SIZE];
    BOOL ret = FALSE;

    ASSERT(cptfx % 3 == 0);

    if (!path->IsValid() || pptfx == NULL || cptfx == 0 || (cptfx % 3 != 0))
        return FALSE;

    if (cptfx > POINTS_BUFFER_SIZE)
    {
        points = new GpPointF[cptfx];
        
        if (points == NULL)
            return FALSE;
    }
    else
        points = apoint;

    // convert FIX4 to REAL

    for (ULONG i = 0; i < cptfx; i++)
    {
        points[i].X = FIX4TOREAL(pptfx[i].x);
        points[i].Y = FIX4TOREAL(pptfx[i].y);
    }
               
    if (path->AddPoints(points, cptfx, PathPointTypeBezier) == Ok)
    {
        path->SetHasBezier(TRUE);
        ret = TRUE;
    }
    
    if (points != apoint)
    delete [] points;
    
    return ret;
}

BOOL APIENTRY PATHOBJ_bCloseFigure(
    PVOID *ppo
    )
{
    ((GpPath*)ppo)->CloseFigure();

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\geometry.hpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Geometry: Some 2D geometry helper routines.
*
* Created:
*
*   08/26/2000 asecchia
*      Created it.
*
**************************************************************************/

#ifndef _GEOMETRY_HPP
#define _GEOMETRY_HPP


// return the square of the distance between point 1 and point 2.

inline REAL distance_squared(const GpPointF &p1, const GpPointF &p2)
{
    return ((p1.X-p2.X)*(p1.X-p2.X)+(p1.Y-p2.Y)*(p1.Y-p2.Y));
}

// return the dot product of two points treated as 2-vectors.

inline double dot_product(const GpPointF &a, const GpPointF &b)
{
    return (a.X*b.X + a.Y*b.Y);
}

// Return the intersection of a line specified by p0-p1 along the
// y axis. Returns FALSE if p0-p1 is parallel to the yaxis.
// Only returns intersections between p0 and p1 (inclusive).

BOOL intersect_line_yaxis(
    IN  const GpPointF &p0,
    IN  const GpPointF &p1,
    OUT REAL *length
);

// Return the intersection of a line p0-p1 with the line r0-r1
// The return value

BOOL IntersectLines(
    IN const GpPointF &line1Start,
    IN const GpPointF &line1End,
    IN const GpPointF &line2Start,
    IN const GpPointF &line2End,
    OUT REAL *line1Length,
    OUT REAL *line2Length,
    OUT GpPointF *intersectionPoint
);


INT intersect_circle_line(
    IN  const GpPointF &C,      // center
    IN  REAL radius2,           // radius * radius  (i.e. squared)
    IN  const GpPointF &P0,     // line first point (origin)
    IN  const GpPointF &P1,     // line last point (end)
    OUT GpPointF *intersection  // return intersection point.
);

// Return true if point is inside the polygon defined by poly and count.
// Use the FillModeAlternate (even-odd) rule.

BOOL PointInPolygonAlternate(
    GpPointF point,
    INT count, 
    GpPointF *poly
);

GpStatus GetFastAngle(REAL* angle, const GpPointF& vector);


class GpVector2D : public GpPointF
{
    public:
    GpVector2D()
    {
        X = Y = 0.0f;
    }

    GpVector2D(IN const PointF &point)
    {
        X = point.X;
        Y = point.Y;
    } 
    
    GpVector2D(IN const GpVector2D &vec)
    {
        X = vec.X;
        Y = vec.Y;
    } 

    GpVector2D(IN REAL x, IN REAL y)
    {
        X = x;
        Y = y;
    }

    // Scale.
    
    GpVector2D operator*(REAL k)
    {
        return GpVector2D(X*k, Y*k);
    }
    
    // Dot Product
    
    REAL operator*(IN const GpVector2D &V)
    {
        return (X*V.X+Y*V.Y);
    }
    
   
    VOID operator+=(IN const GpVector2D &V)
    {
        X += V.X;
        Y += V.Y;
    } 
    
    VOID operator-=(IN const GpVector2D &V)
    {
        X -= V.X;
        Y -= V.Y;
    } 
        
    VOID operator*=(IN const REAL k)
    {
        X *= k;
        Y *= k;
    } 

    // Length or Vector Norm of the Vector.
    
    REAL Norm()
    {
        double length = (double)X*X+(double)Y*Y;
        length = sqrt(length);
        
        if( fabs(length) < REAL_EPSILON )
        {
            return 0.0f;
        }
        else
        {
            return (REAL)length;
        }
    }
    
    // Unitize the vector. If it is degenerate, return 0.0f
    
    REAL Normalize()
    {
        double length = (double)X*X+(double)Y*Y;
        
        if( length < 0.0 )
        {
            X = 0.0f;
            Y = 0.0f;
            return 0.0f;
        }
        
        length = sqrt(length);
        
        if( fabs(length) < REAL_EPSILON )
        {
            X = 0.0f;
            Y = 0.0f;
            return 0.0f;
        }
        else
        {
            X /= (REAL)length;
            Y /= (REAL)length;
            return (REAL)length;
        }
    }
    
    // This is the determinant of two 2-vectors. The formula is defined to
    // be the determinant of the 2x2 matrix formed by using the two vectors
    // as the columns of the matrix.
    // This is also known as the cross product of the two input vectors
    // though some math texts claim that cross products are only defined
    // for 3-vectors.
    
    static REAL Determinant(const GpVector2D &a, const GpVector2D &b)
    {
        return (a.X*b.Y-a.Y*b.X);
    }
};
    

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\graphics.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998-1999  Microsoft Corporation
*
* Module Name:
*
*   Graphics.hpp
*
* Abstract:
*
*   Declarations for Graphics class
*
* Revision History:
*
*   12/04/1998 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _GRAPHICS_HPP
#define _GRAPHICS_HPP

#include "printer.hpp"

#define GDIP_NOOP_ROP3              0x00AA0029      // do-nothing ROP

// definitions copied from winddi.h :

#ifndef _WINDDI_

DECLARE_HANDLE(HSURF);
DECLARE_HANDLE(DHSURF);
DECLARE_HANDLE(DHPDEV);

typedef struct _SURFOBJ
{
    DHSURF  dhsurf;
    HSURF   hsurf;
    DHPDEV  dhpdev;
    HDEV    hdev;
    SIZEL   sizlBitmap;
    ULONG   cjBits;
    PVOID   pvBits;
    PVOID   pvScan0;
    LONG    lDelta;
    ULONG   iUniq;
    ULONG   iBitmapFormat;
    USHORT  iType;
    USHORT  fjBitmap;
} SURFOBJ;

#endif

// Forward declaration of the GpCachedBitmap class.
class GpCachedBitmap;
class CopyOnWriteBitmap;

/**
 * Represent a graphics context
 */
class GpGraphics
{
friend class GpBitmap;
friend class CopyOnWriteBitmap;
friend class GpMetafile;
friend class MetafilePlayer;
friend class HdcLock;
friend class DriverUni;
friend class MetafileRecorder;
friend class DriverStringImager;
friend class FullTextImager;
friend class FastTextImager;
friend class GpCachedBitmap;

private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

protected:
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagGraphics : ObjectTagInvalid;
    }

    // This method is here so that we have a virtual function table so
    // that we can add virtual methods in V2 without shifting the position
    // of the Tag value within the data structure.
    virtual VOID DontCallThis()
    {
        DontCallThis();
    }

public:
    LONG LockedByGetDC;         // Used by GdipGetDC and GdipReleaseDC

protected:
    static GpGraphics*
    GetForMetafile(
        IMetafileRecord *   metafile,
        EmfType             type,
        HDC                 hdc
        );

    // used by the MetafileRecorder in the EndRecording method
    VOID NoOpPatBlt(
        INT     left,
        INT     top,
        INT     width,
        INT     height
        )
    {
        // Get the devlock because the surface will be flushed when we get the
        // HDC
        Devlock devlock(Device);

        // Get the HDC in the correct state
        HDC hdc = Context->GetHdc(Surface);
        if (hdc != NULL)
        {
            ::PatBlt(hdc, left, top, width, height, GDIP_NOOP_ROP3);
            Context->ReleaseHdc(hdc);
        }

        // Now Reset the HDC so that this happens before the
        // EndOfFile record (which has to be the last record before the
        // EMF's EOF record).
        Context->ResetHdc();
    }

    // If we should send rects to the driver instead of a path
    BOOL UseDriverRects() const
    {
        return (Context->WorldToDevice.IsTranslateScale() &&
                ((!Context->AntiAliasMode) || DownLevel));
    }


public:

    // Get a graphics context from an existing Win32 HDC or HWND

    static GpGraphics* GetFromHdc(HDC hdc, HANDLE hDevice = NULL);

    // Default behaviour is to ignore ICM mode.

    static GpGraphics* GetFromHwnd(
        HWND hwnd,
        HdcIcmMode icmMode = IcmModeOff
        );

    ~GpGraphics();

    // Internal use only

    static GpGraphics* GetFromHdcSurf(HDC hdc,
                                      SURFOBJ* surfObj,
                                      RECTL* bandClip);

    static GpGraphics* GetFromGdiScreenDC(HDC hdc);

    // Get the lock object

    GpLockable *GetObjectLock() const
    {
        return &Lockable;
    }

    // Check to see if the object is valid

    BOOL IsValid() const
    {
    #ifdef _X86_
        // We have to guarantee that the Tag field doesn't move for
        // versioning to work between releases of GDI+.
        ASSERT(offsetof(GpGraphics, Tag) == 4);
    #endif

        ASSERT((Tag == ObjectTagGraphics) || (Tag == ObjectTagInvalid));
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid Graphics");
        }
    #endif

        return (Tag == ObjectTagGraphics);
    }

    // Derive a win32 HDC from the graphics context

    HDC GetHdc();
    VOID ReleaseHdc(HDC hdc);

    // Flush any pending rendering

    VOID Flush(GpFlushIntention intention)
    {
        Devlock devlock(Device);

        DrvFlush(intention);
    }

    //------------------------------------------------------------------------
    // Manipulate the current world transform
    //------------------------------------------------------------------------

    GpStatus SetWorldTransform(const GpMatrix& matrix);

    GpStatus ResetWorldTransform();

    GpStatus MultiplyWorldTransform(const GpMatrix& matrix,
                                    GpMatrixOrder order = MatrixOrderPrepend);

    GpStatus TranslateWorldTransform(REAL dx, REAL dy,
                                     GpMatrixOrder order = MatrixOrderPrepend);

    GpStatus ScaleWorldTransform(REAL sx, REAL sy,
                                 GpMatrixOrder order = MatrixOrderPrepend);

    GpStatus RotateWorldTransform(REAL angle,
                                  GpMatrixOrder order = MatrixOrderPrepend);

    VOID GetWorldTransform(GpMatrix & matrix) const
    {
        matrix = Context->WorldToPage;
    }

    GpStatus GetDeviceToWorldTransform(GpMatrix * matrix) const;

    VOID GetWorldToDeviceTransform(GpMatrix * matrix) const
    {
        *matrix = Context->WorldToDevice;
    }
    VOID GetWorldToDeviceTransform(REAL * m) const
    {
        Context->WorldToDevice.GetMatrix(m);
    }

    VOID GetWorldPixelSize(REAL & xSize, REAL & ySize);

    // Manipulate the current page transform

    // !! *PageTransform's to be phased out...
    GpStatus SetPageTransform(GpPageUnit unit, REAL scale = 1);

    GpStatus ResetPageTransform()
    {
        return SetPageTransform(UnitDisplay);
    }

    GpPageUnit GetPageUnit() const   { return Context->PageUnit; }
    REAL GetPageScale() const        { return Context->PageScale; }

    GpStatus SetPageUnit(GpPageUnit unit)
    {
        return SetPageTransform(unit, GetPageScale());
    }

    GpStatus SetPageScale(REAL scale)
    {
        return SetPageTransform(GetPageUnit(), scale);
    }

    GpStatus TransformPoints(
        GpPointF *          points,
        INT                 count,
        GpCoordinateSpace   source = CoordinateSpaceWorld,
        GpCoordinateSpace   dest   = CoordinateSpaceDevice
        );


    /// GetScaleForAlternatePageUnit
    //
    //  Return world unit scale factor corresponding to the difference
    //  between the page units selected in the graphics and a unit specified
    //  to an API such as pen thickness or font height.
    //
    //  The returned vector provides the amount by which to multiply world
    //  x and y coordinates so that they will behave according to the
    //  alternate unit when passed through Context.WorldToDevice.

    REAL GetScaleForAlternatePageUnit(Unit unit) const
    {
        // pen width and font height must not use UnitDisplay because
        // it is a device dependent unit.
        ASSERT(unit != UnitDisplay);

        // The x:Y aspect ratio of the device resolution doesn't matter here,
        // we get exactly the same values whether we use DpiX/PageMultiplierX
        // or DpiY/PageMiltiplierY.

        switch (unit)
        {
            case UnitDocument:
                return ((GetDpiX()/300.0f) / Context->PageMultiplierX);
            case UnitPoint:
                return ((GetDpiX()/72.0f)  / Context->PageMultiplierX);
            case UnitMillimeter:
                return ((GetDpiX()/25.4f)  / Context->PageMultiplierX);
            case UnitInch:
                return (GetDpiX()          / Context->PageMultiplierX);
            case UnitWorld:
            case UnitPixel:
            default:
                return 1.0f;
        }
    }



    // Clipping related methods

    GpStatus SetClip(GpGraphics* g, CombineMode combineMode);

    GpStatus SetClip(const GpRectF& rect, CombineMode combineMode);

    GpStatus SetClip(GpPath* path, CombineMode combineMode,
                     BOOL isDevicePath = FALSE);

    GpStatus SetClip(GpRegion* region, CombineMode combineMode);

    GpStatus SetClip(HRGN hRgn, CombineMode combineMode);

    GpStatus ResetClip();

    GpStatus OffsetClip(REAL dx, REAL dy);

    GpRegion* GetClip() const;

    GpStatus GetClip(GpRegion* region) const;

    // save and restore graphics state

    INT Save();
    VOID Restore(INT gstate);

    // start and end container drawing

    INT
    BeginContainer(
        const GpRectF &     destRect,
        const GpRectF &     srcRect,
        GpPageUnit          srcUnit,
        REAL                srcDpiX      = 0.0f,  // for metafile playback only
        REAL                srcDpiY      = 0.0f,
        BOOL                srcIsDisplay = TRUE   // for metafile playback only
        );

    INT BeginContainer(
        // all these params are only applicable for metafile playback
        BOOL                forceIdentityTransform = FALSE,
        REAL                srcDpiX      = 0.0f,
        REAL                srcDpiY      = 0.0f,
        BOOL                srcIsDisplay = TRUE
        );

    VOID EndContainer(INT containerState);

    // Hit testing operations

    VOID GetClipBounds(GpRectF& rect) const;

    BOOL IsClipEmpty() const;

    VOID GetVisibleClipBounds(GpRectF& rect) const;

    BOOL IsVisibleClipEmpty() const;

    GpRegion* GetVisibleClip() const;

    HRGN GetVisibleClipHRgn() const
    {
        return Context->VisibleClip.GetHRgn();
    }

    BOOL IsVisible(const GpPointF& point) const;

    BOOL IsVisible(const GpRectF& rect) const;

    GpStatus GetPixelColor(REAL x, REAL y, ARGB* argb) const;

    // Set antialiasing mode

    VOID SetAntiAliasMode( BOOL newMode )
    {
        ASSERT(Context);

        // for Printer DC never set AA
        if (IsPrinter())
        {
            Context->AntiAliasMode = FALSE;
            return;
        }

        if (IsRecording() && (newMode != Context->AntiAliasMode))
        {
            Metafile->RecordSetAntiAliasMode(newMode);
        }
        Context->AntiAliasMode = newMode;
    }

    BOOL GetAntiAliasMode() const
    {
        ASSERT(Context);
        return(Context->AntiAliasMode);
    }

  // Set antialiasing text

    VOID SetTextRenderingHint( TextRenderingHint newMode)
    {
        ASSERT(Context);

        // for Printer DC never set AA or Clear Type text
        if (IsPrinter())
        {
            Context->TextRenderHint = TextRenderingHintSingleBitPerPixelGridFit;
            return;
        }

        if (IsRecording() && (newMode != Context->TextRenderHint))
        {
            Metafile->RecordSetTextRenderingHint(newMode);
        }

        Context->TextRenderHint = newMode;
    }

    TextRenderingHint GetTextRenderingHint() const
    {
        ASSERT(Context);
        return(Context->TextRenderHint);
    }

    // this procedure is meant to be used by internal text routines
    // and will return real text rendering hint (not TextRenderingHintSystemDefault)
    // we should always call CalculateTextRenderingHintInternal() before
    // calling GetTextRenderingHintInternal()
    TextRenderingHint GetTextRenderingHintInternal() const
    {
        return TextRenderingHintInternal;
    }

    Status SetTextContrast(UINT contrast)
    {
        ASSERT(Context);

        if (contrast > MAX_TEXT_CONTRAST_VALUE)
            return InvalidParameter;

        // for Printer DC never set AA or Clear Type text
        if (IsPrinter())
        {
            Context->TextContrast = 0;
            return Ok;
        }

        if (IsRecording() && (contrast != Context->TextContrast))
        {
            Metafile->RecordSetTextContrast(contrast);
        }

        Context->TextContrast = contrast;
        return Ok;
    }

    UINT GetTextContrast() const
    {
        ASSERT(Context);

        return Context->TextContrast;
    }

    // Rendering Origin
    // This is the origin used for Dither and Halftone matrix origins
    // and should be used for any raster operations that need an origin.

    VOID SetRenderingOrigin(INT x, INT y)
    {
        ASSERT(Context);

        if (IsRecording() &&
            (x != Context->RenderingOriginX ||
             y != Context->RenderingOriginY)
           )
        {
            Metafile->RecordSetRenderingOrigin(x, y);
        }
        Context->RenderingOriginX = x;
        Context->RenderingOriginY = y;
    }


    // Rendering Origin
    // Returns the origin used for the Dither and Halftone matrix origin.

    VOID GetRenderingOrigin(INT *x, INT *y) const
    {
        ASSERT(Context);
        ASSERT(x);
        ASSERT(y);

        *x = Context->RenderingOriginX;
        *y = Context->RenderingOriginY;
    }


    // Compositing mode

    VOID SetCompositingMode( GpCompositingMode newMode )
    {
        ASSERT(Context);

        if (IsRecording() && (newMode != Context->CompositingMode))
        {
            Metafile->RecordSetCompositingMode(newMode);
        }
        Context->CompositingMode = newMode;
    }

    GpCompositingMode GetCompositingMode() const
    {
        ASSERT(Context);
        return(Context->CompositingMode);
    }

    // Compositing quality

    VOID SetCompositingQuality( GpCompositingQuality newQuality )
    {
        ASSERT(Context);

        if (IsRecording() && (newQuality != Context->CompositingQuality))
        {
            Metafile->RecordSetCompositingQuality(newQuality);
        }
        Context->CompositingQuality = newQuality;
    }

    GpCompositingQuality GetCompositingQuality() const
    {
        ASSERT(Context);
        return(Context->CompositingQuality);
    }

    VOID SetInterpolationMode(InterpolationMode newMode)
    {
        ASSERT(Context);

        if (IsRecording() && (newMode != Context->FilterType))
        {
            Metafile->RecordSetInterpolationMode(newMode);
        }

        Context->FilterType = newMode;
    }
    InterpolationMode GetInterpolationMode() const
    {
        ASSERT(Context);
        return Context->FilterType;
    }

    VOID SetPixelOffsetMode(PixelOffsetMode newMode)
    {
        ASSERT(Context);

        if (newMode != Context->PixelOffset)
        {
            if (IsRecording())
            {
                Metafile->RecordSetPixelOffsetMode(newMode);
            }
            Context->PixelOffset = newMode;
            Context->InverseOk = FALSE;
            Context->UpdateWorldToDeviceMatrix();
        }
    }

    PixelOffsetMode GetPixelOffsetMode() const
    {
        ASSERT(Context);
        return Context->PixelOffset;
    }

    //------------------------------------------------------------------------
    // GetNearestColor (for <= 8bpp surfaces)
    //------------------------------------------------------------------------

    ARGB
    GetNearestColor(
        ARGB        argb
        );

    //------------------------------------------------------------------------
    // Stroke vector shapes
    //------------------------------------------------------------------------

    GpStatus
    DrawLine(
        GpPen* pen,
        const GpPointF& pt1,
        const GpPointF& pt2
        )
    {
        GpPointF points[2];

        points[0] = pt1;
        points[1] = pt2;

        return(DrawLines(pen, &points[0], 2));
    }

    GpStatus
    DrawLine(
        GpPen* pen,
        REAL x1,
        REAL y1,
        REAL x2,
        REAL y2
        )
    {
        GpPointF points[2];

        points[0].X = x1;
        points[0].Y = y1;
        points[1].X = x2;
        points[1].Y = y2;

        return(DrawLines(pen, &points[0], 2));
    }

    GpStatus
    DrawLines(
        GpPen* pen,
        const GpPointF* points,
        INT count,
        BOOL closed = FALSE
        );

    GpStatus
    DrawArc(
        GpPen* pen,
        const GpRectF& rect,
        REAL startAngle,
        REAL sweepAngle
        );

    GpStatus
    DrawArc(
        GpPen* pen,
        REAL x,
        REAL y,
        REAL width,
        REAL height,
        REAL startAngle,
        REAL sweepAngle
        )
    {
        GpRectF rect(x, y, width, height);

        return DrawArc(pen, rect, startAngle, sweepAngle);
    }

    GpStatus
    DrawBezier(
        GpPen* pen,
        const GpPointF& pt1,
        const GpPointF& pt2,
        const GpPointF& pt3,
        const GpPointF& pt4
        )
    {
        GpPointF points[4];

        points[0] = pt1;
        points[1] = pt2;
        points[2] = pt3;
        points[3] = pt4;

        return DrawBeziers(pen, points, 4);
    }

    GpStatus
    DrawBezier(
        GpPen* pen,
        REAL x1, REAL y1,
        REAL x2, REAL y2,
        REAL x3, REAL y3,
        REAL x4, REAL y4
        )
    {
        GpPointF points[4];

        points[0].X = x1;
        points[0].Y = y1;
        points[1].X = x2;
        points[1].Y = y2;
        points[2].X = x3;
        points[2].Y = y3;
        points[3].X = x4;
        points[3].Y = y4;

        return DrawBeziers(pen, points, 4);
    }

    GpStatus
    DrawBeziers(
        GpPen* pen,
        const GpPointF* points,
        INT count
        );

    GpStatus
    DrawRect(
        GpPen* pen,
        const GpRectF& rect
        )
    {
        return(DrawRects(pen, &rect, 1));
    }

    GpStatus
    DrawRect(
        GpPen* pen,
        REAL x,
        REAL y,
        REAL width,
        REAL height
        )
    {
        GpRectF rect(x, y, width, height);
        return(DrawRects(pen, &rect, 1));
    }

    GpStatus
    DrawRects(
        GpPen* pen,
        const GpRectF* rects,
        INT count
        );

    GpStatus
    DrawEllipse(
        GpPen* pen,
        const GpRectF& rect
        );

    GpStatus
    DrawEllipse(
        GpPen* pen,
        REAL x,
        REAL y,
        REAL width,
        REAL height
        )
    {
        GpRectF rect(x, y, width, height);
        return DrawEllipse(pen, rect);
    }

    GpStatus
    DrawPie(
        GpPen* pen,
        const GpRectF& rect,
        REAL startAngle,
        REAL sweepAngle
        );

    GpStatus
    DrawPie(
        GpPen* pen,
        REAL x,
        REAL y,
        REAL width,
        REAL height,
        REAL startAngle,
        REAL sweepAngle
        )
    {
        GpRectF rect(x, y, width, height);
        return DrawPie(pen, rect, startAngle, sweepAngle);
    }

    GpStatus
    DrawPolygon(
        GpPen* pen,
        const GpPointF* points,
        INT count
        )
    {
        return(DrawLines(pen, points, count, TRUE));
    }

    GpStatus
    DrawPath(
        GpPen* pen,
        GpPath* path
        );

    GpStatus
    DrawPathData(
        GpPen* pen,
        const GpPointF* points,
        const BYTE *types,
        INT count,
        GpFillMode fillMode
        )
    {
        GpStatus status = GenericError;

        GpPath path(points, types, count, fillMode);
        if(path.IsValid())
            status = DrawPath(pen, &path);

        return status;
    }

    GpStatus
    DrawCurve(
        GpPen* pen,
        const GpPointF* points,
        INT count
        );

    GpStatus
    DrawCurve(
        GpPen* pen,
        const GpPointF* points,
        INT count,
        REAL tension,
        INT offset,
        INT numberOfSegments
        );

    GpStatus
    DrawClosedCurve(
        GpPen* pen,
        const GpPointF* points,
        INT count
        );

    GpStatus
    DrawClosedCurve(
        GpPen* pen,
        const GpPointF* points,
        INT count,
        REAL tension
        );


    //------------------------------------------------------------------------
    // Fill shapes
    //------------------------------------------------------------------------

    GpStatus
    Clear(
        const GpColor &color
        );

    GpStatus
    FillRect(
        GpBrush* brush,
        const GpRectF& rect
        )
    {
        return(FillRects(brush, &rect, 1));
    }

    GpStatus
    FillRect(
        GpBrush* brush,
        REAL x,
        REAL y,
        REAL width,
        REAL height
        )
    {
        GpRectF rect(x, y, width, height);
        return(FillRects(brush, &rect, 1));
    }

    GpStatus
    FillRects(
        GpBrush* brush,
        const GpRectF* rects,
        INT count
        );

    GpStatus
    FillPolygon(
        GpBrush* brush,
        const GpPointF* points,
        INT count
        )
    {
        return FillPolygon(brush, points, count, FillModeAlternate);
    }

    GpStatus
    FillPolygon(
        GpBrush* brush,
        const GpPointF* points,
        INT count,
        GpFillMode fillMode
        );

    GpStatus
    FillEllipse(
        GpBrush* brush,
        const GpRectF& rect
        );

    GpStatus
    FillEllipse(
        GpBrush* brush,
        REAL x,
        REAL y,
        REAL width,
        REAL height
        )
    {
        GpRectF rect(x, y, width, height);
        return FillEllipse(brush, rect);
    }

    GpStatus
    FillPie(
        GpBrush* brush,
        const GpRectF& rect,
        REAL startAngle,
        REAL sweepAngle
        );

    GpStatus
    FillPie(
        GpBrush* brush,
        REAL x,
        REAL y,
        REAL width,
        REAL height,
        REAL startAngle,
        REAL sweepAngle
        )
    {
        GpRectF rect(x, y, width, height);
        return FillPie(brush, rect, startAngle, sweepAngle);
    }

    GpStatus
    FillPath(
        const GpBrush* brush,
        GpPath* path
        );

    GpStatus
    FillPathData(
        GpBrush* brush,
        const GpPointF* points,
        const BYTE *types,
        INT count,
        GpFillMode fillMode
        )
    {
        GpStatus status = GenericError;

        GpPath path(points, types, count, fillMode);
        if(path.IsValid())
            status = FillPath(brush, &path);

        return status;
    }

    GpStatus
    FillClosedCurve(
        GpBrush* brush,
        const GpPointF* points,
        INT count,
        REAL tension = 0.5,
        GpFillMode fillMode = FillModeAlternate
        );

    GpStatus
    FillRegion(
        GpBrush* brush,
        GpRegion* region
        );


    //------------------------------------------------------------------------
    // Draw text strings
    //------------------------------------------------------------------------


#define DG_NOGDI        4   // Disable optimisation through GDI
#define DG_SIDEWAY      0x80000000   // flag used by the drivers (Meta Driver) for sideway runs.


    // To be removed, replaced by DrawRealizedGlyphs and GdiDrawGlyphs

    GpStatus
    DrawGlyphs(
        const UINT16     *glyphIndices,
        INT               count,
        const GpFontFace *face,
        INT               style,
        REAL              emSize,
        Unit              unit,
        const GpBrush    *brush,
        const UINT32     *px,
        const UINT32     *py,
        INT               flags,
        const GpMatrix   *pmx = NULL
    );


    // Internal text drawing APIs

protected:
    // should be called once per DrawString/DrawDriverString call
    // checks for invalid text rendering hint combinations
    GpStatus CheckTextMode();

    // this method is meant to calculate TextRenderingHintInternal
    // we call this method once and only once before using GetTextRenderingHintInternal()
    void CalculateTextRenderingHintInternal();

public:

    GpStatus DrawPlacedGlyphs(
        const GpFaceRealization *faceRealization,
        const GpBrush           *brush,
        INT                      flags,
        const WCHAR             *string,
        UINT                     stringLength,
        BOOL                     rightToLeft,
        const UINT16            *glyphs,
        const UINT16            *glyphMap,
        const PointF            *glyphOrigins,
        INT                      glyphCount,
        ItemScript               Script,
        BOOL                     sideways        // e.g. FE characters in vertical text
    );


    GpStatus DrawDriverGlyphs(
        const UINT16     *glyphs,
        INT               glyphCount,
        const GpFont     *font,
        const GpFontFace *face,
        const GpBrush    *brush,
        const WCHAR      *string,
        const PointF     *positions,
        INT               flags,
        const GpMatrix   *matrix
    );


    // External text drawing APIs
    GpStatus
    DrawString(
        const WCHAR          *string,
        INT                   length,
        const GpFont         *font,
        const RectF          *layoutRect,
        const GpStringFormat *format,
        const GpBrush        *brush
    );

    GpStatus
    MeasureString(
        const WCHAR          *string,
        INT                   length,
        const GpFont         *font,
        const RectF          *layoutRect,
        const GpStringFormat *format,
        RectF                *boundingBox,
        INT                  *codepointsFitted,
        INT                  *linesFilled
    );


    GpStatus
    MeasureCharacterRanges(
        const WCHAR          *string,
        INT                   length,
        const GpFont         *font,
        const RectF          &layoutRect,
        const GpStringFormat *format,
        INT                   regionCount,
        GpRegion            **regions
    );

/// Start API for graphicstext.cpp

    GpStatus
    RecordEmfPlusDrawDriverString(
        const UINT16     *text,
        INT               glyphCount,
        const GpFont     *font,
        const GpFontFace *face,
        const GpBrush    *brush,
        const PointF     *positions,
        INT               flags,
        const GpMatrix   *matrix        // optional
    );

    GpStatus
    DrawDriverString(
        const UINT16    *text,
        INT              length,
        const GpFont    *font,
        const GpBrush   *brush,
        const PointF    *positions,
        INT              flags,
        const GpMatrix        *matrix
    );

    GpStatus
    MeasureDriverString(
        const UINT16     *text,
        INT               glyphCount,
        const GpFont     *font,
        const PointF     *positions,
        INT               flags,
        const GpMatrix   *matrix,       // In  - Optional glyph transform
        RectF            *boundingBox   // Out - Overall bounding box of cells
    );

    GpStatus
    DrawFontStyleLine(
        const PointF        *baselineOrigin,    // baseline origin
        REAL                baselineLength,     // baseline length
        const GpFontFace    *face,              // font face
        const GpBrush       *brush,             // brush
        BOOL                vertical,           // vertical text?
        REAL                emSize,             // font EM size in world unit
        INT                 style,              // kind of lines to be drawn
        const GpMatrix      *matrix = NULL      // additional transform
    );

    REAL GetDevicePenWidth(
        REAL            widthInWorldUnits,
        const GpMatrix  *matrix = NULL
    );

/// End API for graphicstext.cpp


    GpStatus
    DrawCachedBitmap(
        GpCachedBitmap *cb,
        INT x,
        INT y
    )
    {
        return DrvDrawCachedBitmap(cb, x, y);
    }

    //------------------------------------------------------------------------
    // Draw images (both bitmap and metafile)
    //------------------------------------------------------------------------

    GpStatus
    DrawImage(
        GpImage* image,
        const GpPointF& point
        );

    GpStatus
    DrawImage(
        GpImage* image,
        REAL x,
        REAL y
        )
    {
        GpPointF point(x, y);
        return DrawImage(image, point);
    }

    GpStatus
    DrawImage(
        GpImage* image,
        const GpRectF& destRect
        );

    GpStatus
    DrawImage(
        GpImage* image,
        REAL x,
        REAL y,
        REAL width,
        REAL height
        )
    {
        GpRectF destRect(x, y, width, height);
        return DrawImage(image, destRect);
    }

    GpStatus
    DrawImage(
        GpImage* image,
        const GpPointF* destPoints,
        INT count
        );

    GpStatus
    DrawImage(
        GpImage* image,
        REAL            x,
        REAL            y,
        const GpRectF & srcRect,
        GpPageUnit      srcUnit
        );

    GpStatus
    DrawImage(
        GpImage*         image,
        const GpRectF&   destRect,
        const GpRectF&   srcRect,
        GpPageUnit       srcUnit,
        const GpImageAttributes* imageAttributes = NULL,
        DrawImageAbort   callback = NULL,
        VOID*            callbackData = NULL
        );

    GpStatus
    DrawImage(
        GpImage*             image,
        const GpPointF*      destPoints,
        INT                  count,
        const GpRectF&       srcRect,
        GpPageUnit           srcUnit,
        const GpImageAttributes*   imageAttributes = NULL,
        DrawImageAbort       callback = NULL,
        VOID*                callbackData = NULL
        );

    GpStatus
    EnumerateMetafile(
        const GpMetafile *      metafile,
        const PointF &          destPoint,
        EnumerateMetafileProc   callback,
        VOID *                  callbackData,
        const GpImageAttributes *     imageAttributes
        );

    GpStatus
    EnumerateMetafile(
        const GpMetafile *      metafile,
        const RectF &           destRect,
        EnumerateMetafileProc   callback,
        VOID *                  callbackData,
        const GpImageAttributes *     imageAttributes
        );

    GpStatus
    EnumerateMetafile(
        const GpMetafile *      metafile,
        const PointF *          destPoints,
        INT                     count,
        EnumerateMetafileProc   callback,
        VOID *                  callbackData,
        const GpImageAttributes *     imageAttributes
        );

    GpStatus
    EnumerateMetafile(
        const GpMetafile *      metafile,
        const PointF &          destPoint,
        const RectF &           srcRect,
        Unit                    srcUnit,
        EnumerateMetafileProc   callback,
        VOID *                  callbackData,
        const GpImageAttributes *     imageAttributes
        );

    GpStatus
    EnumerateMetafile(
        const GpMetafile *      metafile,
        const RectF &           destRect,
        const RectF &           srcRect,
        Unit                    srcUnit,
        EnumerateMetafileProc   callback,
        VOID *                  callbackData,
        const GpImageAttributes *     imageAttributes
        );

    GpStatus
    EnumerateMetafile(
        const GpMetafile *      metafile,
        const PointF *          destPoints,
        INT                     count,
        const RectF &           srcRect,
        Unit                    srcUnit,
        EnumerateMetafileProc   callback,
        VOID *                  callbackData,
        const GpImageAttributes *     imageAttributes
        );

    GpStatus
    Comment(
        UINT            sizeData,
        const BYTE *    data
        )
    {
        GpStatus        status = InvalidParameter;

        if (IsRecording())
        {
            status = Metafile->RecordComment(sizeData, data);
            if (status != Ok)
            {
                SetValid(FALSE);      // Prevent any more recording
            }
        }
        return status;
    }

   // Called only by metafile player
    GpStatus
    EnumEmf(
        MetafilePlayer *        player,
        HENHMETAFILE            hEmf,
        const GpRectF &         destRect,
        const GpRectF &         srcRect,
        const GpRectF &         deviceDestRect,
        MetafileType            type,
        BOOL                    isTranslateScale,
        BOOL                    renderToBitmap,
        const GpMatrix &        flipAndCropTransform
        );

    // Called only by metafile player
    GpStatus
    EnumEmfPlusDual(
        MetafilePlayer *        player,
        HENHMETAFILE            hEmf,
        const GpRectF&          destRect,       // inclusive, exclusive
        const GpRectF&          deviceDestRect, // inclusive, exclusive
        BOOL                    isTranslateScale,
        BOOL                    renderToBitmap
        );

protected:

    // if an HWND is passed in, the default ICM mode is off.
    // if an HDC is passed in, the icmMode flag is ignored.

    GpGraphics(
        HWND hwnd,
        HDC hdc,
        INT clientWidth,
        INT clientHeight,
        HdcIcmMode icmMode = IcmModeOff,
        BOOL gdiLayered = FALSE
    );

    GpGraphics(DpBitmap * surface);

    GpStatus GetDCDrawBounds(HDC hdc, RECT *rect);

public:

    // The Context dpi and the Surface dpi are always the same,
    // except possibly during metafile playback when the Context
    // may be using the metafile dpi (which is what rendering
    // should use).

    REAL GetDpiX() const        { return Context->GetDpiX(); }
    REAL GetDpiY() const        { return Context->GetDpiY(); }

    BOOL IsPrinter() const { return Printer; }

protected:

    enum HalftoneType
    {
        HalftoneTypeNone,
        HalftoneType16Color,
        HalftoneType216Color,
        HalftoneType15Bpp,
        HalftoneType16Bpp,
    };

    HalftoneType GetHalftoneType() const
    {
        EpPaletteMap* paletteMap = BottomContext.PaletteMap;

        // !! TODO: Verify this works on when switching modes
        if (paletteMap != NULL)
        {
            // we are doing 8bpp palette map
            if (paletteMap->IsVGAOnly())
            {
                return HalftoneType16Color;
            }
            else
            {
                return HalftoneType216Color;
            }
        }
        else if (Surface->PixelFormat == PixelFormat16bppRGB555)
        {
            return HalftoneType15Bpp;
        }
        else if (Surface->PixelFormat == PixelFormat16bppRGB565)
        {
            return HalftoneType16Bpp;
        }
        else
        {
            return HalftoneTypeNone;
        }
    }

    //--------------------------------------------------------------
    // Internal fill and draw routines that do not record
    // path, rect, or region in a metafile.
    //--------------------------------------------------------------

    GpStatus
    RenderFillRects(
        GpRectF*        bounds,
        INT             count,
        const GpRectF*  rects,
        GpBrush*        brush
        )
    {
        GpRect      deviceBounds;
        GpStatus status = BoundsFToRect(bounds, &deviceBounds);

        if (status == Ok && !IsTotallyClipped(&deviceBounds))
        {
            // Now that we've done a bunch of work in accumulating the bounds,
            // acquire the device lock before calling the driver:

            Devlock devlock(Device);

            return DrvFillRects(&deviceBounds, count, rects, brush->GetDeviceBrush());
        }
        return status;
    }

    GpStatus
    RenderFillRegion(
        GpRectF*    bounds,
        GpRegion*   region,
        GpBrush*    brush,
        GpRect*     metafileBounds
        )
    {
        GpRect      deviceBounds;
        GpStatus status = BoundsFToRect(bounds, &deviceBounds);
        BOOL isInfinite = FALSE;
        GpMatrix identity;

        if (status == Ok && !IsTotallyClipped(&deviceBounds))
        {
            // Now that we've done a bunch of work in accumulating the bounds,
            // acquire the device lock before calling the driver:

            status = region->UpdateDeviceRegion(&(Context->WorldToDevice));

            if (status == Ok)
            {
                DpRegion *  deviceRegion = &(region->DeviceRegion);
                DpRegion    metafileRegion;

                if (metafileBounds != NULL)
                {
                    metafileRegion.Set(metafileBounds);
                    metafileRegion.And(deviceRegion);
                    if (!metafileRegion.IsValid())
                    {
                        return GenericError;
                    }
                    deviceRegion = &metafileRegion;
                }

                // Get the actual bounds now to give to the driver
                deviceRegion->GetBounds(&deviceBounds);

                // Make sure there is still something to fill so we
                // don't ASSERT later on.
                if ((deviceBounds.Width > 0) && (deviceBounds.Height > 0))
                {
                    Devlock devlock(Device);

                    return DrvFillRegion(&deviceBounds, deviceRegion, brush->GetDeviceBrush());
                }
            }
        }
        return status;
    }

    GpStatus RenderDrawPath(
        GpRectF *bounds,
        GpPath *path,
        GpPen *pen
    );

    GpStatus RenderFillPath(
        GpRectF *bounds,
        GpPath *path,
        const GpBrush *brush
    );

    VOID
    GetImageDestPageSize(
        const GpImage *     image,
        REAL                srcWidth,
        REAL                srcHeight,
        GpPageUnit          srcUnit,
        REAL &              destWidth,
        REAL &              destHeight
        );

    VOID
    DeviceToWorldTransformRect(
        const GpRect &    deviceRect,
        GpRectF &   rect
        ) const;

    static GpGraphics *GetFromGdiBitmap(HDC hdc);
    static GpGraphics *GetFromGdipBitmap(
        GpBitmap*       bitmap,
        ImageInfo *     imageInfo,
        EpScanBitmap *  scanBitmap,
        BOOL            isDisplay
        );
    static GpGraphics *GetFromGdiPrinterDC(HDC hdc);
    static GpGraphics *GetFromGdiEmfDC(HDC hdc);
    static GpGraphics *GetFromDirectDrawSurface(IDirectDrawSurface7 * surface);
    static GpGraphics *GetFromGdiPrinterDC(HDC hdc, HANDLE hPrinter);

    static INT GetPostscriptLevel(HDC hdc, HANDLE hPrinter);

    GpStatus StartPrinterEMF();

    GpStatus EndPrinterEMF();

    BOOL IsTotallyClipped(GpRect *rect) const;

    BOOL IsRecording() const { return Metafile != NULL; }

    BOOL IsDisplay() const { return Context->IsDisplay; }

    VOID DoResetClip()
    {
        Context->AppClip.SetInfinite();

        // ContainerClip always contains the clipping for the container,
        // intersected with the WindowClip.
        Context->VisibleClip.Set(&(Context->ContainerClip));
    }

    // The AppClip has been set into VisibleClip; now intersect it with
    // the container clip and the window clip.
    GpStatus AndVisibleClip()
    {
        // ContainerClip always contains the clipping for the container,
        // intersected with the WindowClip.
        return Context->VisibleClip.And(&(Context->ContainerClip));
    }

    GpStatus
    CombineClip(
        const GpRectF & rect,
        CombineMode     combineMode
        );

    GpStatus
    CombineClip(
        const GpPath *  path,
        CombineMode     combineMode,
        BOOL            isDevicePath = FALSE
        );

    GpStatus
    CombineClip(
        GpRegion *      region,
        CombineMode     combineMode
        );

    GpStatus
    InheritAppClippingAndTransform(
        HDC hdc
        );

    VOID
    ResetState(
        INT x,
        INT y,
        INT width,
        INT height
        );

    VOID
    UpdateDrawBounds(
        INT x,
        INT y,
        INT width,
        INT height
        );

    //--------------------------------------------------------------------------
    // Routines for calling the driver
    //--------------------------------------------------------------------------

    VOID
    DrvFlush(
        GpFlushIntention intention
        )
    {
        ASSERTMSG(Device->DeviceLock.IsLockedByCurrentThread(),
            ("DeviceLock must be held by current thread"));

        Driver->Flush(Device, Surface, intention);

    }

    GpStatus
    DrvStrokePath(
        const GpRect *drawBounds,
        const DpPath *path,
        const DpPen  *pen
        )
    {
        ASSERTMSG(GetObjectLock()->IsLocked(),
                  ("Graphics object must be locked"));

        ASSERTMSG(Device->DeviceLock.IsLockedByCurrentThread(),
            ("DeviceLock must be held by current thread"));

        FPUStateSaver::AssertMode();

        Surface->Uniqueness = (DWORD)GpObject::GenerateUniqueness();
        return(Driver->StrokePath(Context, Surface, drawBounds, path, pen));
    }

    GpStatus
    DrvFillRects(
        const GpRect *drawBounds,
        INT numRects,
        const GpRectF *rects,
        const DpBrush *brush
        )
    {
        ASSERTMSG(GetObjectLock()->IsLocked(),
                  ("Graphics object must be locked"));

        ASSERTMSG(Device->DeviceLock.IsLockedByCurrentThread(),
            ("DeviceLock must be held by current thread"));

        FPUStateSaver::AssertMode();

        Surface->Uniqueness = (DWORD)GpObject::GenerateUniqueness();
        return(Driver->FillRects(Context, Surface, drawBounds,
                                 numRects, rects, brush));
    }

    GpStatus
    DrvFillPath(
        const GpRect *drawBounds,
        const DpPath *path,
        const DpBrush *brush
        )
    {
        ASSERTMSG(GetObjectLock()->IsLocked(),
                  ("Graphics object must be locked"));

        ASSERTMSG(Device->DeviceLock.IsLockedByCurrentThread(),
            ("DeviceLock must be held by current thread"));

        FPUStateSaver::AssertMode();

        Surface->Uniqueness = (DWORD)GpObject::GenerateUniqueness();
        return(Driver->FillPath(Context, Surface, drawBounds, path, brush));
    }

    GpStatus
    DrvFillRegion(
        const GpRect *drawBounds,
        const DpRegion *region,
        const DpBrush *brush
        )
    {
        ASSERTMSG(GetObjectLock()->IsLocked(),
                  ("Graphics object must be locked"));

        ASSERTMSG(Device->DeviceLock.IsLockedByCurrentThread(),
            ("DeviceLock must be held by current thread"));

        FPUStateSaver::AssertMode();

        Surface->Uniqueness = (DWORD)GpObject::GenerateUniqueness();
        return(Driver->FillRegion(Context, Surface, drawBounds, region, brush));
    }

    GpStatus
    DrvDrawGlyphs(
        const GpRect             *drawBounds,
        const GpGlyphPos         *glyphPos,
        const GpGlyphPos         *glyphPathPos,
        INT                       count,
        const DpBrush            *brush,
        const GpFaceRealization  *faceRealization,
        const UINT16             *glyphs,
        const UINT16             *glyphMap,
        const PointF             *glyphOrigins,
        INT                       glyphCount,
        const WCHAR              *string,
        UINT                      stringLength,
        ItemScript                script,
        INT                       edgeGlyphAdvance,
        BOOL                      rightToLeft,
        INT                       flags
    )
    {
        // check the input parameter!!

        GpStatus status;
        DrawGlyphData drawGlyphData;

        drawGlyphData.context           = Context;
        drawGlyphData.surface           = Surface;
        drawGlyphData.drawBounds        = drawBounds;
        drawGlyphData.glyphPos          = glyphPos;
        drawGlyphData.glyphPathPos      = glyphPathPos;
        drawGlyphData.count             = count;
        drawGlyphData.brush             = brush;
        drawGlyphData.faceRealization   = faceRealization;
        drawGlyphData.glyphs            = glyphs;
        drawGlyphData.glyphMap          = glyphMap;
        drawGlyphData.glyphOrigins      = glyphOrigins;
        drawGlyphData.glyphCount        =  glyphCount;
        drawGlyphData.string            = string;
        drawGlyphData.stringLength      = stringLength;
        drawGlyphData.script            = script;
        drawGlyphData.edgeGlyphAdvance  = edgeGlyphAdvance;
        drawGlyphData.rightToLeft       = rightToLeft;
        drawGlyphData.flags             =  flags;

        status = Driver->DrawGlyphs(&drawGlyphData);

        return status;
    }

    // Draw the CachedBitmap on this graphics.
    // This routine sets up the rendering origin and the locks
    // and calls the appropriate driver.

    GpStatus
    DrvDrawCachedBitmap(
        GpCachedBitmap *inputCachedBitmap,
        INT x,
        INT y
    );

    GpStatus
    DrvDrawImage(
        const GpRect *drawBounds,
        GpBitmap *intputBitmap,
        INT numPoints,
        const GpPointF *dstPoints,
        const GpRectF *srcRect,
        const GpImageAttributes *imageAttributes,
        DrawImageAbort callback,
        VOID *callbackData,
        DriverDrawImageFlags flags
    );

    GpStatus
    DrvMoveBits(
        const GpRect *drawBounds,
        const GpRect *dstRect,
        const GpPoint *srcPoint
        )
    {
        GpStatus status;

        ASSERTMSG(GetObjectLock()->IsLocked(),
                  ("Graphics object must be locked"));

        ASSERTMSG(Device->DeviceLock.IsLockedByCurrentThread(),
            ("DeviceLock must be held by current thread"));

        FPUStateSaver::AssertMode();

        Surface->Uniqueness = (DWORD)GpObject::GenerateUniqueness();
        status = Driver->MoveBits(Context, Surface, drawBounds, dstRect,
                                  srcPoint);

        return status;
    }

public:
    // Simple inline function to return the selected surface.

    DpBitmap *GetSurface() {
        return Surface;
    }

    // Simple inline function to return the driver.

    DpDriver *GetDriver() {
        return Driver;
    }

protected:

    enum GraphicsType
    {
        GraphicsBitmap   = 1,
        GraphicsScreen   = 2,
        GraphicsMetafile = 3,
    };

    mutable GpLockable Lockable;
    GpRect SurfaceBounds;       // Bounds of surface in device units.
    DpBitmap *Surface;          // Selected surface

    GpBitmap   *GdipBitmap;     // point to GpBitmap if the graphics is created from one

    IMetafileRecord * Metafile; // For recording metafiles

    BOOL Printer;               // Whether this object is a printer
    PGDIPPRINTINIT PrintInit;   // Initialization data for printer types
    HGLOBAL PrinterEMF;
    GpMetafile *PrinterMetafile;
    GpGraphics *PrinterGraphics;

    BOOL DownLevel;             // Whether or not to do down-level metafile
    GraphicsType Type;          // Type of GpGraphics created

    BOOL CreatedDevice;         // Whether 'Device' was created at GpGraphics
                                //    construction time, and so needs to be
                                //    freed in the GpGraphics destructor
    GpDevice *Device;           // Associated device
    DpDriver *Driver;           // Associate driver interface
    DpContext *Context;         // Contains all the driver-viewable state:
                                //   Transforms, clipping, alpha/antialias/etc.
                                //   modes
    DpContext BottomContext;    // Always the bottom of the Context Stack
    DpRegion WindowClip;        // The clip region of the window

    TextRenderingHint TextRenderingHintInternal; // cached internal value of TextRenderingHint
                                                 // valid during one call to Draw(Driver)String
};

#endif // !_GRAPHICS_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\gpbitmap.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   GpBitmap.hpp
*
* Abstract:
*
*   Bitmap related declarations
*
* Revision History:
*
*   12/09/1998 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _GPBITMAP_HPP
#define _GPBITMAP_HPP

#define NEARCONSTANTALPHA 0x10

//--------------------------------------------------------------------------
// Abstract base class for bitmap image and metafile
//--------------------------------------------------------------------------

class GpImage : public GpObject
{
protected:
    VOID SetValid(BOOL valid)
    {
        GpObject::SetValid(valid ? ObjectTagImage : ObjectTagInvalid);
    }

public:

    // Construct a GpImage object from a disk file

    static GpImage* LoadImage(const WCHAR* filename);

    // Construct a GpImage object from a data stream

    static GpImage* LoadImage(IStream* stream);

    virtual ObjectType GetObjectType() const { return ObjectTypeImage; }

    // Make a copy of the image object

    virtual GpImage* Clone() const= 0;

    virtual GpImage* CloneColorAdjusted(
        GpRecolor *             recolor,
        ColorAdjustType         type = ColorAdjustTypeDefault
        ) const = 0;

    // Get the encoder parameter list size

    virtual GpStatus
    GetEncoderParameterListSize(
        CLSID* clsidEncoder,
        UINT* size
        ) = 0;

    // Get the encoder parameter list

    virtual GpStatus
    GetEncoderParameterList(
        CLSID* clsidEncoder,
        UINT size,
        OUT EncoderParameters* pBuffer
        ) = 0;

    // Save images

    virtual GpStatus
    SaveToStream(
        IStream* stream,
        CLSID* clsidEncoder,
        EncoderParameters* encoderParams
        ) = 0;

    virtual GpStatus
    SaveToFile(
        const WCHAR* filename,
        CLSID* clsidEncoder,
        EncoderParameters* encoderParams
        ) = 0;

    virtual GpStatus
    SaveAdd(
        const EncoderParameters* encoderParams
        ) = 0;

    virtual GpStatus
    SaveAdd(
        GpImage*           newBits,
        const EncoderParameters*  encoderParams
        ) = 0;

    // Dispose of the image object

    virtual VOID Dispose() = 0;

    // Derive a graphics context to draw into the GpImage object

    virtual GpGraphics* GetGraphicsContext() = 0;

    // Check if the GpImage object is valid

    virtual BOOL IsValid() const
    {
        return GpObject::IsValid(ObjectTagImage);
    }

    virtual BOOL IsSolid()
    {
        return FALSE;
    }

    virtual BOOL IsOpaque()
    {
        return FALSE;
    }

    // Get image information:
    //  resolution
    //  physical dimension in 0.01mm units
    //  bounding rectangle
    //  structure ImageInfo
    //  thumbnail

    virtual GpStatus GetResolution(REAL* xdpi, REAL* ydpi)           const = 0;
    virtual GpStatus GetPhysicalDimension(REAL* width, REAL* height) const = 0;
    virtual GpStatus GetBounds(GpRectF* rect, GpPageUnit* unit)      const = 0;
    virtual GpStatus GetImageInfo(ImageInfo *imageInfo)              const = 0;
    virtual GpStatus GetFrameCount(const GUID* dimensionID,
                                   UINT* count)                      const = 0;
    virtual GpStatus GetFrameDimensionsCount(OUT UINT* count)        const = 0;
    virtual GpStatus GetFrameDimensionsList(OUT GUID* dimensionIDs,
                                            IN  UINT count)          const = 0;
    virtual GpStatus SelectActiveFrame(const GUID*  dimensionID,
                                       UINT frameIndex)                    = 0;
    virtual GpImage* GetThumbnail(UINT thumbWidth, UINT thumbHeight,
                                  GetThumbnailImageAbort callback, VOID *callbackData) = 0;
    virtual GpStatus GetPalette(ColorPalette *palette, INT size) = 0;
    virtual GpStatus SetPalette(ColorPalette *palette) = 0;
    virtual INT GetPaletteSize() = 0;

    // Rotate and Flip

    virtual GpStatus RotateFlip(RotateFlipType rfType) = 0;

    // Property related functions

    virtual GpStatus GetPropertyCount(UINT* numOfProperty) = 0;
    virtual GpStatus GetPropertyIdList(UINT numOfProperty, PROPID* list) = 0;
    virtual GpStatus GetPropertyItemSize(PROPID propId, UINT* size) = 0;
    virtual GpStatus GetPropertyItem(PROPID propId,UINT propSize,
                                     PropertyItem* buffer) = 0;
    virtual GpStatus GetPropertySize(UINT* totalBufferSize,
                                     UINT* numProperties) = 0;
    virtual GpStatus GetAllPropertyItems(UINT totalBufferSize,
                                         UINT numProperties,
                                         PropertyItem* allItems) = 0;
    virtual GpStatus RemovePropertyItem(PROPID propId) = 0;

    virtual GpStatus SetPropertyItem(PropertyItem* item) = 0;

    // Determine the type of image object

    GpImageType GetImageType() const
    {
        return ImgType;
    }

    GpLockable* GetObjectLock() const
    {
        return &Lockable;
    }

    // Default ICM mode is off. Default behaviour for this function is to
    // do nothing.
    // If a derived class supports embedded color correction, it needs
    // to respect this call to turn ICM on or off.

    virtual VOID SetICMConvert(BOOL icm) { }


private:

    // Prevent apps from directly using new and delete operators
    // on GpImage objects.

    GpImage()
    {
        ImgType = ImageTypeUnknown;

        // Set the tag in the object, even if IsValid overridden by
        // GpBitmap or GpMetafile.
        GpObject::SetValid(ObjectTagImage);
    }

protected:

    GpImage(GpImageType imgType)
    {
        ImgType = imgType;

        // Set the tag in the object, even if IsValid overridden by
        // GpBitmap or GpMetafile.
        GpObject::SetValid(ObjectTagImage);
    }

    virtual ~GpImage() {}

    GpImageType ImgType;    // type of image object

    // Object lock

    mutable GpLockable Lockable;
};


//--------------------------------------------------------------------------
// Represent raster bitmap objects
//--------------------------------------------------------------------------

class GpDecodedImage;
class GpMemoryBitmap;
class CopyOnWriteBitmap;

class GpBitmap : public GpImage
{
friend class GpObject;      // for empty constructor
friend class CopyOnWriteBitmap;

private:

    CopyOnWriteBitmap *     InternalBitmap;
    LONG ScanBitmapRef;         // ref count used for when a GpGraphics is wrapped around a GpBitmap
    EpScanBitmap ScanBitmap;

    VOID IncScanBitmapRef()
    {
         InterlockedIncrement(&ScanBitmapRef);
    }

    VOID DecScanBitmapRef()
    {
         InterlockedDecrement(&ScanBitmapRef);
    }

    GpBitmap(BOOL createInternalBitmap = TRUE);
    GpBitmap(const GpBitmap * bitmap);
    GpBitmap(const CopyOnWriteBitmap * internalBitmap);

    // Destructor
    //  We don't want apps to use delete operator directly.
    //  Instead, they should use the Dispose method.

    virtual ~GpBitmap();

protected:

    CopyOnWriteBitmap * LockForWrite();
    VOID Unlock() const;
    VOID LockForRead() const;

public:

    // Constructors

    GpBitmap(const WCHAR* filename);
    GpBitmap(IStream* stream);
    GpBitmap(INT width, INT height, PixelFormatID format);
    GpBitmap(INT width, INT height, PixelFormatID format, GpGraphics * graphics);
    GpBitmap(
        INT width,
        INT height,
        INT stride,     // negative for bottom-up bitmaps
        PixelFormatID format,
        BYTE *  scan0
        );
    GpBitmap(
        BITMAPINFO* gdiBitmapInfo,
        VOID* gdiBitmapData,
        BOOL ownBitmapData
        );
    GpBitmap(IDirectDrawSurface7 *surface);

    // Check if the GpBitmap object is valid

    virtual BOOL IsValid() const;

    GpImage*
    Clone() const;

    GpBitmap*
    Clone(
        const GpRect* rect,
        PixelFormatID format = PixelFormat32bppPARGB
    ) const;

    virtual GpImage*
    CloneColorAdjusted(
        GpRecolor *             recolor,
        ColorAdjustType         type = ColorAdjustTypeDefault
        ) const;

    // Similar to CloneColorAdjusted
    GpStatus Recolor(
        GpRecolor *recolor,
        GpBitmap **dstBitmap,
        DrawImageAbort callback,
        VOID *callbackData,
        GpRect *rect = NULL
    );

    GpStatus
    GetEncoderParameterListSize(
        IN  CLSID* clsidEncoder,
        OUT UINT* size
        );

    GpStatus
    GetEncoderParameterList(
        IN  CLSID* clsidEncoder,
        IN  UINT size,
        OUT EncoderParameters* pBuffer
        );

    GpStatus
    SaveToStream(
        IStream* stream,
        CLSID* clsidEncoder,
        EncoderParameters* encoderParams
        );

    GpStatus
    SaveToFile(
        const WCHAR* filename,
        CLSID* clsidEncoder,
        EncoderParameters* encoderParams
        );

    GpStatus
    SaveAdd(
        const EncoderParameters* encoderParams
        );

    GpStatus
    SaveAdd(
        GpImage*            newBits,
        const EncoderParameters*  encoderParams
        );

    // Dispose the bitmap object

    VOID Dispose();

    // Get bitmap information

    virtual GpStatus GetResolution(REAL* xdpi, REAL* ydpi)           const;
    virtual GpStatus GetPhysicalDimension(REAL* width, REAL* height) const;
    virtual GpStatus GetBounds(GpRectF* rect, GpPageUnit* unit)      const;
    virtual GpStatus GetSize(Size* size)                             const;
    virtual GpStatus GetImageInfo(ImageInfo *imageInfo)              const;
    virtual GpImage* GetThumbnail(UINT thumbWidth, UINT thumbHeight,
                                  GetThumbnailImageAbort callback,
                                  VOID *callbackData);
    virtual GpStatus GetFrameCount(const GUID* dimensionID,
                                   UINT* count)                      const;
    virtual GpStatus GetFrameDimensionsCount(OUT UINT* count)        const;
    virtual GpStatus GetFrameDimensionsList(OUT GUID* dimensionIDs,
                                            IN UINT count)           const;
    virtual GpStatus SelectActiveFrame(const GUID*  dimensionID,
                                       UINT frameIndex);
    virtual GpStatus GetPalette(ColorPalette *palette, INT size);
    virtual GpStatus SetPalette(ColorPalette *palette);
    virtual INT GetPaletteSize();

    GpStatus GetTransparencyHint(DpTransparency* transparency);
    GpStatus SetTransparencyHint(DpTransparency transparency);

    GpStatus GetTransparencyFlags(DpTransparency* transparency,
                                  PixelFormatID loadFormat = PixelFormatDontCare,
                                  BYTE* minAlpha = NULL,
                                  BYTE* maxAlpha = NULL);

    // Property related functions

    virtual GpStatus GetPropertyCount(UINT* numOfProperty);
    virtual GpStatus GetPropertyIdList(UINT numOfProperty, PROPID* list);
    virtual GpStatus GetPropertyItemSize(PROPID propId, UINT* size);
    virtual GpStatus GetPropertyItem(PROPID propId,UINT propSize,
                                     PropertyItem* buffer);
    virtual GpStatus GetPropertySize(UINT* totalBufferSize,UINT* numProperties);
    virtual GpStatus GetAllPropertyItems(UINT totalBufferSize,
                                         UINT numProperties,
                                         PropertyItem* allItems);
    virtual GpStatus RemovePropertyItem(PROPID propId);
    virtual GpStatus SetPropertyItem(PropertyItem* item);

    // Retrieve bitmap data

    GpStatus
    LockBits(
        const GpRect* rect,
        UINT flags,
        PixelFormatID pixelFormat,
        BitmapData* bmpdata,
        INT width = 0,
        INT height = 0
    ) const;

    GpStatus
    UnlockBits(
        BitmapData* bmpdata,
        BOOL Destroy=FALSE
    ) const;

    // Flush batched drawing operations and optionally wait for drawing to
    // complete.  This is currently a nop operation.  If the behavior
    // of a GpBitmap changes to a model where rendering operations are
    // non-immediate then this routine will need to be implemented.

    VOID
    Flush(GpFlushIntention intention) {};

    // Get and set pixel on the bitmap.
    GpStatus GetPixel(INT x, INT y, ARGB *color);
    GpStatus SetPixel(INT x, INT y, ARGB color);

    // Rotate and Flip

    GpStatus RotateFlip(
        RotateFlipType rfType
        );

    // Derive a graphics context on top of the bitmap object

    GpGraphics* GetGraphicsContext();

    GpStatus
    GpBitmap::InitializeSurfaceForGdipBitmap(
        DpBitmap *      surface,
        INT             width,
        INT             height
        );

    // Derive an HDC for interop on top of the bitmap object

    HDC GetHdc();
    VOID ReleaseHdc(HDC hdc);

    // Serialization

    virtual UINT GetDataSize() const;
    virtual GpStatus GetData(IStream * stream) const;
    virtual GpStatus SetData(const BYTE * dataBuffer, UINT size);

    GpStatus GetCompressedData(
            DpCompressedData * compressed_data,
            BOOL getJPEG = TRUE,
            BOOL getPNG = TRUE,
            HDC hdc = (HDC)NULL);

    GpStatus DeleteCompressedData(
            DpCompressedData * compressed_data);

    BOOL IsDirty() const;

    // Color adjust

    virtual GpStatus ColorAdjust(
        GpRecolor *     recolor,
        ColorAdjustType type
        );

    GpStatus
    ColorAdjust(
        GpRecolor * recolor,
        PixelFormatID pixfmt,
        DrawImageAbort callback,
        VOID *callbackData
        );

    GpStatus GetPixelFormatID(PixelFormatID* pixfmt);

    enum
    {
        Invalid = 0,        // bitmap object is invalid
        ImageRef = 1,       // contains a reference only (e.g. filename)
        ExtStream = 2,      // contains a reference to a stream
        DecodedImg = 3,     // contains a decoded image object,
                            // but it's not decoded yet - name is misleading.
        MemBitmap = 4       // contains an in-memory bitmap object
    };

    INT GetDecodeState();

    GpStatus ForceValidation();

    GpStatus SetResolution(REAL xdpi, REAL ydpi);

    GpStatus
    PreDraw(
        INT numPoints,
        GpPointF *dstPoints,
        GpRectF *srcRect,
        INT numBitsPerPixel
        );

    DWORD GetUniqueness() { return (DWORD)GetUid(); }

    // Interop:

    static GpStatus CreateFromHBITMAP(
        HBITMAP hbm,
        HPALETTE hpal,
        GpBitmap** bitmap
        );

    static GpStatus CreateBitmapAndFillWithBrush(
        InterpolationMode   interpolationMode,
        PixelOffsetMode     pixelOffsetMode,
        const GpMatrix *    worldToDevice,
        const GpRect *      drawBounds,
        GpBrush *           brush,
        GpBitmap **         bitmap,
        PixelFormatID       pixelFormat = PIXFMT_32BPP_ARGB
        );

    static GpStatus DrawAndHalftoneForStretchBlt(
        HDC                 hdc,
        BITMAPINFO *        bmpInfo,
        BYTE       *        bits,
        INT                 srcX,
        INT                 srcY,
        INT                 srcWidth,
        INT                 srcHeight,
        INT                 destWidth,
        INT                 destHeight,
        BITMAPINFO **       destBmpInfo,
        BYTE       **       destBmpBits,
        HBITMAP    *        destDIBSection,
        InterpolationMode   interpolationMode
        );

    GpStatus CreateHBITMAP(HBITMAP *phbm, ARGB background);

    GpStatus ICMFrontEnd(
        GpBitmap **dstBitmap,
        DrawImageAbort callback,
        VOID *callbackData,
        GpRect *rect = NULL
    );

    static GpStatus CreateFromHICON(
        HICON hicon,
        GpBitmap** bitmap
        );

    GpStatus CreateHICON(HICON *phicon);

    static GpStatus CreateFromResource(
        HINSTANCE hInstance,
        LPWSTR lpBitmapName,
        GpBitmap** bitmap
        );

    // We need to know if the bitmap is associated with a display
    // so we know how to handle the page transform when it is
    // set to UnitDisplay.
    BOOL IsDisplay() const;
    VOID SetDisplay(BOOL display);

    BOOL IsICMConvert() const;
    virtual VOID SetICMConvert(BOOL icm);
};

// This is the base class for any class that implements the CopyOnWrite
// technology that enable cloning to be very light-weight when cloning for
// read access. It implements read and write locking for synchronization
// using a critical section, and it keeps track of reference counting
// the object so that it can be deleted at the right time.

class CopyOnWrite
{
protected:
    // Constructor: notice that when an object is first
    // created, its reference count is set to 1.

    CopyOnWrite()
    {
        RefCount = 1;
#if DBG
        Lock = NotLocked;
        LockCount = 0;
#endif
        InitializeCriticalSection(&Semaphore);
    }

    virtual ~CopyOnWrite()
    {
        DeleteCriticalSection(&Semaphore);
    }

#if DBG
    enum LockedType
    {
        NotLocked,
        LockedForRead,
        LockedForWrite
    };
#endif

    virtual CopyOnWrite * Clone() const = 0;
    virtual BOOL IsValid() const = 0;

    // Returns NULL if it fails to lock for writing

    CopyOnWrite * LockForWrite()
    {
        EnterCriticalSection(&Semaphore);

        CopyOnWrite *  writeableObject = this;

        // If there is more than one reference to this object, we must
        // clone it before giving write access to it.

        if (RefCount > 1)
        {
            writeableObject = this->Clone();

            if (writeableObject == NULL)
            {
                LeaveCriticalSection(&Semaphore);
                return NULL;
            }

            ASSERT(writeableObject->IsValid());

            // else we succeeded in cloning the object

            RefCount--;

            EnterCriticalSection(&(writeableObject->Semaphore));
            LeaveCriticalSection(&Semaphore);
        }

#if DBG
        writeableObject->Lock = LockedForWrite;
        writeableObject->LockCount++;
#endif

        return writeableObject;
    }

    VOID LockForRead() const
    {
        EnterCriticalSection(&Semaphore);

#if DBG
        if (Lock == NotLocked)
        {
            Lock = LockedForRead;
        }
        LockCount++;
#endif
    }

    VOID Unlock() const
    {
#if DBG
        ASSERT(Lock != NotLocked);
        if (--LockCount <= 0)
        {
            Lock = NotLocked;
            LockCount = 0;
        }
#endif
        LeaveCriticalSection(&Semaphore);
    }

    // Increment reference count
    // Note that we must use the critical section to control access, rather
    // than using interlocked increment.

    LONG AddRef() const
    {
        EnterCriticalSection(&Semaphore);
        RefCount++;
        LeaveCriticalSection(&Semaphore);
        return RefCount;
    }

    // Decrement reference count
    // Note that we must use the critical section to control access, rather
    // than using interlocked decrement.

    LONG Release() const
    {
        EnterCriticalSection(&Semaphore);

        ULONG count = --RefCount;

        // must leave the critical section before calling delete so that
        // we don't try to access the freed memory.

        LeaveCriticalSection(&Semaphore);

        if (count == 0)
        {
            delete this;
        }

        return count;
    }

private:

    mutable LONG                RefCount;
    mutable CRITICAL_SECTION    Semaphore;

#if DBG
    mutable INT                 LockCount;
protected:
    mutable LockedType          Lock;
#endif
};

GpStatus
ConvertTo16BppAndFlip(
    GpBitmap *      sourceBitmap,
    GpBitmap * &    destBitmap
    );

VOID
HalftoneColorRef_216(
    COLORREF color,     // color to halftone
    UNALIGNED VOID *dib // packed 8 bpp DIB buffer with 8 colors
                        // The DIB buffer should be this size:
                        //     sizeof(BITMAPINFOHEADER) + // DIB 8 bpp header
                        //     (8 * sizeof(RGBQUAD)) +    // DIB 8 colors
                        //     (8 * 8)                    // DIB 8x8 pixels
    );

#endif // !_GPBITMAP_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\graphicsimage.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Abstract:
*
*   Graphics image APIs.
*
* Revision History:
*
*   12/02/1998 andrewgo
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\graphicsclip.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   GraphicsClip.cpp
*
* Abstract:
*
*   Clipping methods of Graphics class
*
* Created:
*
*   02/05/1999 DCurtis
*
\**************************************************************************/

#include "precomp.hpp"

/**************************************************************************\
*
* Function Description:
*
*   Get a copy of the current clipping region.  Transform it through the
*   inverse of the current world-to-device matrix, so that if this region
*   was immediately set as the clipping, then the clipping wouldn't change.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   GpRegion * region - a copy of the current clipping region; must be
*                       deleted by the application.
*
* Created:
*
*   02/09/1999 DCurtis
*
\**************************************************************************/
GpRegion*
GpGraphics::GetClip() const
{
    ASSERT(this->IsValid());

    GpRegion *  region = new GpRegion(&(Context->AppClip));

    if (region != NULL)
    {
        if (region->IsValid())
        {
            GpMatrix    deviceToWorld;

            if ((GetDeviceToWorldTransform(&deviceToWorld) == Ok) &&
                (region->Transform(&deviceToWorld) == Ok))
            {
                return region;
            }
        }
        delete region;
    }
    return NULL;
}

/**************************************************************************\
*
* Function Description:
*
*   Get a copy of the current clipping region.  Transform it through the
*   inverse of the current world-to-device matrix, so that if this region
*   was immediately set as the clipping, then the clipping wouldn't change.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   GpRegion * region - an already created region, we set the contents of it.
*
* Created:
*
*   02/09/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpGraphics::GetClip(GpRegion* region) const
{
    ASSERT(this->IsValid());

    region->Set(&(Context->AppClip));

    if (region->IsValid())
    {
        GpMatrix    deviceToWorld;

        if ((GetDeviceToWorldTransform(&deviceToWorld) == Ok) &&
            (region->Transform(&deviceToWorld) == Ok))
        {
            return Ok;
        }
    }
    
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Reset the clipping back to its default state.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   02/09/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpGraphics::ResetClip()
{
    ASSERT(this->IsValid());

    GpStatus    status = Ok;

    if (IsRecording())
    {
        status = Metafile->RecordResetClip();
        if (status != Ok)
        {
            SetValid(FALSE);      // Prevent any more recording
            return status;
        }
    }

    DoResetClip();
    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Set the clipping in the graphics context to be the specified rect.
*
* Arguments:
*
*   [IN]  rect        - the rectangle, in world units
*   [IN]  combineMode - the combine operator (and, or, xor, exclude, complement)
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   02/05/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpGraphics::SetClip(
    const GpRectF&  rect,
    CombineMode     combineMode
    )
{
    ASSERT(this->IsValid());

    GpStatus    status = Ok;

    GpRectF     tmpRect = rect;
    
    // handle flipped rects
    if (tmpRect.Width < 0)
    {
        tmpRect.X += tmpRect.Width;
        tmpRect.Width = -tmpRect.Width;
    }
    
    if (tmpRect.Height < 0)
    {
        tmpRect.Y += tmpRect.Height;
        tmpRect.Height = -tmpRect.Height;
    }

    // crop to infinity
    if (tmpRect.X < INFINITE_MIN)
    {
        if (tmpRect.Width < INFINITE_SIZE)
        {
            tmpRect.Width -= (INFINITE_MIN - tmpRect.X);
        }
        tmpRect.X = INFINITE_MIN;
    }
    if (tmpRect.Y < INFINITE_MIN)
    {
        if (tmpRect.Height < INFINITE_SIZE)
        {
            tmpRect.Height -= (INFINITE_MIN - tmpRect.Y);
        }
        tmpRect.Y = INFINITE_MIN;
    }

    if ((tmpRect.Width <= REAL_EPSILON) || (tmpRect.Height <= REAL_EPSILON))
    {
        GpRegion    emptyRegion;
        
        emptyRegion.SetEmpty();
        return this->SetClip(&emptyRegion, combineMode);
    }

    if (tmpRect.Width >= INFINITE_SIZE)
    {
        if (tmpRect.Height >= INFINITE_SIZE)
        {
            GpRegion    infiniteRegion;
            return this->SetClip(&infiniteRegion, combineMode);
        }
        tmpRect.Width = INFINITE_SIZE;  // crop to infinite
    }
    else if (tmpRect.Height > INFINITE_SIZE)
    {
        tmpRect.Height = INFINITE_SIZE; // crop to infinite
    }
    
    if (IsRecording())
    {
        status = Metafile->RecordSetClip(rect, combineMode);
        if (status != Ok)
        {
            SetValid(FALSE);      // Prevent any more recording
            return status;
        }
    }

    if (combineMode != CombineModeReplace)
    {
        return this->CombineClip(rect, combineMode);
    }
    
    if (Context->WorldToDevice.IsTranslateScale())
    {
        GpRectF     transformedRect = rect;

        Context->WorldToDevice.TransformRect(transformedRect);
        Context->AppClip.Set(transformedRect.X,
                             transformedRect.Y,
                             transformedRect.Width,
                             transformedRect.Height);

        // Try to match the GDI+ rasterizer
        // In theory, this could cause a floating point exception, but
        // the transform would have to be a very big scaling transform to do it.
        INT     left   = RasterizerCeiling(transformedRect.X);
        INT     top    = RasterizerCeiling(transformedRect.Y);
        INT     right  = RasterizerCeiling(transformedRect.GetRight());
        INT     bottom = RasterizerCeiling(transformedRect.GetBottom());

        Context->VisibleClip.Set(left, top, right - left, bottom - top);
        goto AndClip;
    }
    else
    {
        GpPointF    points[4];
        REAL        left   = rect.X;
        REAL        top    = rect.Y;
        REAL        right  = rect.X + rect.Width;
        REAL        bottom = rect.Y + rect.Height;

        points[0].X = left;
        points[0].Y = top;
        points[1].X = right;
        points[1].Y = top;
        points[2].X = right;
        points[2].Y = bottom;
        points[3].X = left;
        points[3].Y = bottom;

        // Transform the points now so we only have to do it once
        Context->WorldToDevice.Transform(points, 4);

        GpPath      path;

        path.AddLines(points, 4);

        if (path.IsValid())
        {
            GpMatrix    identityMatrix;

            if ((Context->AppClip.Set(&path) == Ok) &&
                (Context->VisibleClip.Set(&path, &identityMatrix) == Ok))
            {
                goto AndClip;
            }
        }
    }

ErrorExit:
    DoResetClip();
    return GenericError;

AndClip:
    if (AndVisibleClip() == Ok)
    {
        return status;
    }
    goto ErrorExit;
}

/**************************************************************************\
*
* Function Description:
*
*   Set the clipping in the graphics context to be the specified region.
*
* Arguments:
*
*   [IN]  region      - the region to clip to
*   [IN]  combineMode - the combine operator (and, or, xor, exclude, complement)
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   02/05/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpGraphics::SetClip(
    GpRegion *      region,
    CombineMode     combineMode
    )
{
    ASSERT(this->IsValid());
    ASSERT((region != NULL) && (region->IsValid()));

    GpStatus    status = Ok;

    if (IsRecording())
    {
        status = Metafile->RecordSetClip(region, combineMode);
        if (status != Ok)
        {
            SetValid(FALSE);      // Prevent any more recording
            return status;
        }
    }

    if (combineMode != CombineModeReplace)
    {
        return this->CombineClip(region, combineMode);
    }
    
    if ((Context->AppClip.Set(region) == Ok) &&
        (Context->AppClip.Transform(&(Context->WorldToDevice)) == Ok))
    {
        GpMatrix        identityMatrix;

        if ((Context->AppClip.UpdateDeviceRegion(&identityMatrix) == Ok) &&
            (Context->VisibleClip.Set(&(Context->AppClip.DeviceRegion)) == Ok)&&
            (AndVisibleClip() == Ok))
        {
            return status;
        }
    }

    DoResetClip();
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Set the clipping in the graphics context to be the specified region.
*
* Arguments:
*
*   [IN]  hRgn        - the region to clip to (already in device units)
*   [IN]  combineMode - the combine operator (and, or, xor, exclude, complement)
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   02/05/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpGraphics::SetClip(
    HRGN            hRgn,
    CombineMode     combineMode
    )
{
    ASSERT(this->IsValid());

    GpPath  path(hRgn);
    
    if (path.IsValid())
    {
        return this->SetClip(&path, combineMode, TRUE/*isDevicePath*/);
    }
    return OutOfMemory;
}

/**************************************************************************\
*
* Function Description:
*
*   Set the clipping in the graphics context to be the same as what
*   the specified graphics has.
*
*   Currently, this only works if the other graphics has the same
*   resolution as this one does.
*
* Arguments:
*
*   [IN]  g           - the graphics to copy the clipping from
*   [IN]  combineMode - the combine operator (and, or, xor, exclude, complement)
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   02/09/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpGraphics::SetClip(
    GpGraphics*     g,
    CombineMode     combineMode
    )
{
    ASSERT(this->IsValid() && (g != NULL) && g->IsValid());

    GpStatus    status = GenericError;
    GpRegion *  region = new GpRegion(&(g->Context->AppClip));

    if (region != NULL)
    {
        if (region->IsValid())
        {
            
            GpMatrix    deviceToWorld;

            if ((GetDeviceToWorldTransform(&deviceToWorld) == Ok) &&
                (region->Transform(&deviceToWorld) == Ok))
            {
                status = this->SetClip(region, combineMode);
            }
        }
        delete region;
    }
    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Set the clipping in the graphics context to be the specified path.
*
* Arguments:
*
*   [IN]  path        - the path to clip to
*   [IN]  combineMode - the combine operator (and, or, xor, exclude, complement)
*   [IN]  isDevicePath- if path is already in device units
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   02/09/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpGraphics::SetClip(
    GpPath*         path,
    CombineMode     combineMode,
    BOOL            isDevicePath    // if path is already in device units
    )
{
    ASSERT(this->IsValid() && (path != NULL) && path->IsValid());

    GpStatus        status = Ok;

    if (IsRecording())
    {
        status = Metafile->RecordSetClip(path, combineMode, isDevicePath);
        if (status != Ok)
        {
            SetValid(FALSE);      // Prevent any more recording
            return status;
        }
    }

    if (combineMode != CombineModeReplace)
    {
        return this->CombineClip(path, combineMode, isDevicePath);
    }
    
    if ((Context->AppClip.Set(path) == Ok) &&
        (isDevicePath ||
         (Context->AppClip.Transform(&(Context->WorldToDevice)) == Ok)))
    {
        GpMatrix        identityMatrix;

        if ((Context->AppClip.UpdateDeviceRegion(&identityMatrix) == Ok) &&
            (Context->VisibleClip.Set(&(Context->AppClip.DeviceRegion)) == Ok)&&
            (AndVisibleClip() == Ok))
        {
            return status;
        }
    }

    DoResetClip();
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Combine the region with the current clipping using the specified
*   combine type.
*
* Arguments:
*
*   [IN]  region      - the region to combine the clipping with.
*   [IN]  combineMode - the combine operator (and, or, xor, exclude, complement)
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   02/09/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpGraphics::CombineClip(
    GpRegion *      region,
    CombineMode     combineMode
    )
{
    ASSERT(this->IsValid());
    ASSERT((region != NULL) && (region->IsValid()));
    ASSERT(CombineModeIsValid(combineMode));

    GpRegion        regionCopy;

    if (!Context->WorldToDevice.IsIdentity())
    {
        regionCopy.Set(region);

        if ((!regionCopy.IsValid()) ||
            (regionCopy.Transform(&(Context->WorldToDevice)) != Ok))
        {
            return GenericError;
        }
        region = &regionCopy;
    }

    if (Context->AppClip.Combine(region, combineMode) == Ok)
    {
        GpMatrix        identityMatrix;

        if ((Context->AppClip.UpdateDeviceRegion(&identityMatrix) == Ok) &&
            (Context->VisibleClip.Set(&(Context->AppClip.DeviceRegion)) == Ok)&&
            (AndVisibleClip() == Ok))
        {
            return Ok;
        }
    }

    DoResetClip();
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Combine the rect with the current clipping using the specified
*   combine type.
*
* Arguments:
*
*   [IN]  path        - the path to combine the clipping with.
*   [IN]  combineMode - the combine operator (and, or, xor, exclude, complement)
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   02/09/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpGraphics::CombineClip(
    const GpPath *  path,
    CombineMode     combineMode,
    BOOL            isDevicePath    // if path is already in device units
    )
{
    ASSERT(this->IsValid());
    ASSERT((path != NULL) && (path->IsValid()));
    ASSERT(CombineModeIsValid(combineMode));

    GpPath *        pathCopy = NULL;

    if (!isDevicePath && (!Context->WorldToDevice.IsIdentity()))
    {
        pathCopy = path->Clone();

        if (!CheckValid(pathCopy))
        {
            return OutOfMemory;
        }
        pathCopy->Transform(&(Context->WorldToDevice));
        path = pathCopy;
    }

    GpStatus    status = Context->AppClip.Combine(path, combineMode);

    delete pathCopy;

    if (status == Ok)
    {
        GpMatrix        identityMatrix;

        if ((Context->AppClip.UpdateDeviceRegion(&identityMatrix) == Ok) &&
            (Context->VisibleClip.Set(&(Context->AppClip.DeviceRegion)) == Ok)&&
            (AndVisibleClip() == Ok))
        {
            return Ok;
        }
    }

    DoResetClip();
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Combine the rect with the current clipping using the specified
*   combine type.
*
* Arguments:
*
*   [IN]  rect        - the rect to combine the clipping with.
*   [IN]  combineMode - the combine operator (and, or, xor, exclude, complement)
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   02/09/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpGraphics::CombineClip(
    const GpRectF&  rect,
    CombineMode     combineMode
    )
{
    ASSERT(this->IsValid());
    ASSERT(CombineModeIsValid(combineMode));

    if (Context->WorldToDevice.IsTranslateScale())
    {
        GpRectF     transformedRect = rect;

        Context->WorldToDevice.TransformRect(transformedRect);

        if (Context->AppClip.Combine(&transformedRect, combineMode) == Ok)
        {
            goto SetVisibleClip;
        }
    }
    else
    {
        GpPointF    points[4];
        REAL        left   = rect.X;
        REAL        top    = rect.Y;
        REAL        right  = rect.X + rect.Width;
        REAL        bottom = rect.Y + rect.Height;

        points[0].X = left;
        points[0].Y = top;
        points[1].X = right;
        points[1].Y = top;
        points[2].X = right;
        points[2].Y = bottom;
        points[3].X = left;
        points[3].Y = bottom;

        Context->WorldToDevice.Transform(points, 4);

        GpPath      path;

        path.AddLines(points, 4);

        if (path.IsValid())
        {
            if ( Context->AppClip.Combine(&path, combineMode) == Ok)
            {
                goto SetVisibleClip;
            }
        }
    }

ErrorExit:
    DoResetClip();
    return GenericError;

SetVisibleClip:
    {
        GpMatrix        identityMatrix;

        if ((Context->AppClip.UpdateDeviceRegion(&identityMatrix) == Ok) &&
            (Context->VisibleClip.Set(&(Context->AppClip.DeviceRegion)) == Ok)&&
            (AndVisibleClip() == Ok))
        {
            return Ok;
        }
        goto ErrorExit;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Offset (translate) the current clipping region by the specified
*   world unit amounts.
*
* Arguments:
*
*   [IN]  dx - the amount of X to offset the region by, in world units
*   [IN]  dy - the amount of Y to offset the region by, in world units
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   02/09/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpGraphics::OffsetClip(
    REAL        dx,
    REAL        dy
    )
{
    ASSERT(this->IsValid());

    GpStatus        status = Ok;

    if (IsRecording())
    {
        status = Metafile->RecordOffsetClip(dx, dy);
        if (status != Ok)
        {
            SetValid(FALSE);      // Prevent any more recording
            return status;
        }
    }

    GpPointF    offset(dx, dy);

    Context->WorldToDevice.VectorTransform(&offset);

    if (Context->AppClip.Offset(offset.X, offset.Y) == Ok)
    {
        GpMatrix        identityMatrix;

        if ((Context->AppClip.UpdateDeviceRegion(&identityMatrix) == Ok) &&
            (Context->VisibleClip.Set(&(Context->AppClip.DeviceRegion)) == Ok)&&
            (AndVisibleClip() == Ok))
        {
            return status;
        }
    }

    DoResetClip();
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Determine if the specified rect is completely outside the current
*   clipping region.
*
* Arguments:
*
*   [IN]  rect - the rect to check, in device units
*
* Return Value:
*
*   TRUE  - the rect is completely outside the current clipping region
*   FALSE - the rect is at least partially visible
*
* Created:
*
*   02/05/1999 DCurtis
*
\**************************************************************************/
BOOL
GpGraphics::IsTotallyClipped(
    GpRect *        rect        // rect in device units
    ) const
{
    ASSERT(rect != NULL);

    return !(Context->VisibleClip.RectVisible(rect));
}

/**************************************************************************\
*
* Function Description:
*
*   Determine if the current clipping is empty or not
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   BOOL - whether or not the current clipping area is empty.
*
* Created:
*
*   02/09/1999 DCurtis
*
\**************************************************************************/
BOOL
GpGraphics::IsClipEmpty() const
{
    ASSERT(this->IsValid());

    GpMatrix    identityMatrix;
    BOOL        isEmpty = FALSE;

    Context->AppClip.IsEmpty(&identityMatrix, &isEmpty);

    return isEmpty;
}

/**************************************************************************\
*
* Function Description:
*
*   Return a rect with the bounds (in world units) of the current clip region.
*
* Arguments:
*
*   [OUT]  rect - the bounds of the current clip region, in world units
*
* Return Value:
*
*   NONE
*
* Created:
*
*   02/09/1999 DCurtis
*
\**************************************************************************/
VOID
GpGraphics::GetClipBounds(
    GpRectF&            rect
    ) const
{
    ASSERT(this->IsValid());

    GpRect      deviceRect;
    GpMatrix    identityMatrix;

    // We keep AppClip in device units
    Context->AppClip.GetBounds(&identityMatrix, &deviceRect);

    DeviceToWorldTransformRect(deviceRect, rect);
}


/**************************************************************************\
*
* Function Description:
*
*   Transform a device units rect to a world units rect.
*
* Arguments:
*
*   [IN]   deviceRect - the bounds in device units
*   [OUT]  rect       - the bounds, in world units
*
* Return Value:
*
*   NONE
*
* Created:
*
*   04/07/1999 DCurtis
*
\**************************************************************************/
VOID
GpGraphics::DeviceToWorldTransformRect(
    const GpRect &    deviceRect,
    GpRectF &   rect
    ) const
{
    if (Context->WorldToDevice.IsIdentity())
    {
        rect.X      = LTOF(deviceRect.X);
        rect.Y      = LTOF(deviceRect.Y);
        rect.Width  = LTOF(deviceRect.Width);
        rect.Height = LTOF(deviceRect.Height);
    }
    else
    {
        GpMatrix    deviceToWorld;

        if (GetDeviceToWorldTransform(&deviceToWorld) != Ok)
        {
            rect.X = rect.Y = rect.Width = rect.Height = 0;
            return;
        }

        if (deviceToWorld.IsTranslateScale())
        {
            rect.X      = LTOF(deviceRect.X);
            rect.Y      = LTOF(deviceRect.Y);
            rect.Width  = LTOF(deviceRect.Width);
            rect.Height = LTOF(deviceRect.Height);

            deviceToWorld.TransformRect(rect);
        }
        else
        {
            GpPointF    points[4];
            REAL        left   = LTOF(deviceRect.X);
            REAL        top    = LTOF(deviceRect.Y);
            REAL        right  = LTOF(deviceRect.X + deviceRect.Width);
            REAL        bottom = LTOF(deviceRect.Y + deviceRect.Height);

            points[0].X = left;
            points[0].Y = top;
            points[1].X = right;
            points[1].Y = top;
            points[2].X = right;
            points[2].Y = bottom;
            points[3].X = left;
            points[3].Y = bottom;

            deviceToWorld.Transform(points, 4);

            REAL    value;

            left   = points[0].X;
            right  = left;
            top    = points[0].Y;
            bottom = top;

            INT     count = 3;

            do
            {
                value = points[count].X;

                if (value < left)
                {
                    left = value;
                }
                else if (value > right)
                {
                    right = value;
                }

                value = points[count].Y;

                if (value < top)
                {
                    top = value;
                }
                else if (value > bottom)
                {
                    bottom = value;
                }
            } while (--count > 0);

            rect.X      = left;
            rect.Y      = top;
            rect.Width  = right - left;
            rect.Height = bottom - top;
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Return a rect with the bounds (in world units) of the current
*   visible clip region.
*
* Arguments:
*
*   [OUT]  rect - the bounds of the current clip region, in world units
*
* Return Value:
*
*   NONE
*
* Created:
*
*   02/09/1999 DCurtis
*
\**************************************************************************/
VOID
GpGraphics::GetVisibleClipBounds(
    GpRectF&            rect
    ) const
{
    ASSERT(this->IsValid());

    GpRect  deviceRect;
    Context->VisibleClip.GetBounds(&deviceRect);

    DeviceToWorldTransformRect(deviceRect, rect);
}

/**************************************************************************\
*
* Function Description:
*
*   Determine if the current visible clipping is empty or not
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   BOOL - whether or not the current clipping area is empty.
*
* Created:
*
*   02/09/1999 DCurtis
*
\**************************************************************************/
BOOL
GpGraphics::IsVisibleClipEmpty() const
{
    ASSERT(this->IsValid());

    return Context->VisibleClip.IsEmpty();
}

/**************************************************************************\
*
* Function Description:
*
*   Determine if the specified point is visible within the current clip region.
*
* Arguments:
*
*   point - the point to test, in world units.
*
* Return Value:
*
*   BOOL - whether or not the point is inside the current clipping.
*
* Created:
*
*   02/09/1999 DCurtis
*
\**************************************************************************/
BOOL
GpGraphics::IsVisible(
    const GpPointF&     point
    ) const
{
    ASSERT(this->IsValid());

    GpPointF    pointCopy = point;

    Context->WorldToDevice.Transform(&pointCopy);


    return Context->VisibleClip.PointInside(GpRound(pointCopy.X),
                                            GpRound(pointCopy.Y));
}

/**************************************************************************\
*
* Function Description:
*
*   Determine if the specified rect is visible within the current clip region.
*
* Arguments:
*
*   rect - the rect to test, in world units.
*
* Return Value:
*
*   BOOL - whether or not the rect is inside/overlaps the current clipping.
*
* Created:
*
*   02/09/1999 DCurtis
*
\**************************************************************************/
BOOL
GpGraphics::IsVisible(
    const GpRectF&      rect
    ) const
{
    ASSERT(this->IsValid());

    if (Context->WorldToDevice.IsTranslateScale())
    {
        GpRectF     transformedRect = rect;

        Context->WorldToDevice.TransformRect(transformedRect);

        // use ceiling to match rasterizer
        return Context->VisibleClip.RectVisible(
                    GpCeiling(transformedRect.X),
                    GpCeiling(transformedRect.Y),
                    GpCeiling(transformedRect.GetRight()),
                    GpCeiling(transformedRect.GetBottom()));
    }
    else
    {
        GpRectF     bounds;
        GpRect      deviceBounds;
        GpRect      clipBounds;

        TransformBounds(&(Context->WorldToDevice),
                        rect.X, rect.Y,
                        rect.GetRight(), rect.GetBottom(),
                        &bounds);

        GpStatus status = BoundsFToRect(&bounds, &deviceBounds);
        Context->VisibleClip.GetBounds(&clipBounds);

        // try trivial reject
        if (status == Ok && clipBounds.IntersectsWith(deviceBounds))
        {
            // couldn't reject, so do full test
            GpRegion        region(&rect);

            if (region.IsValid() &&
                (region.UpdateDeviceRegion(&(Context->WorldToDevice)) == Ok))
            {
                return Context->VisibleClip.RegionVisible(&region.DeviceRegion);
            }
        }
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\graphicsfill.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Abstract:
*
*   Graphics vector fill APIs.
*
* Revision History:
*
*   12/02/1998 andrewgo
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

#include "QuadTransforms.hpp"

/**************************************************************************\
*
* Function Description:
*
*   API to clear the surface to a specified color
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   03/13/2000 agodfrey
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::Clear(
    const GpColor &color
    )
{
    INT i;
    GpStatus status = Ok;

    ASSERT(this->IsValid());

    RectF drawRect(
        static_cast<float>(SurfaceBounds.X),
        static_cast<float>(SurfaceBounds.Y),
        static_cast<float>(SurfaceBounds.Width),
        static_cast<float>(SurfaceBounds.Height));

    if (IsRecording())
    {
        status = Metafile->RecordClear(&drawRect, color);

        if (status != Ok)
        {
            SetValid(FALSE);      // Prevent any more recording
            return status;
        }
        if (!DownLevel)
        {
            return Ok;
        }

        // else we need to record down-level GDI EMF records as well
    }

    GpSolidFill brush(color);

    if (!IsTotallyClipped(&SurfaceBounds))
    {
        // Remember the compositing mode, antialiasing mode, and world
        // transform, and then set them up for this call.

        GpMatrix oldWorldToDevice = Context->WorldToDevice;
        INT oldAntiAliasMode = Context->AntiAliasMode;
        GpCompositingMode oldCompositingMode = Context->CompositingMode;

        Context->WorldToDevice.Reset();
        Context->AntiAliasMode = 0;
        Context->CompositingMode = CompositingModeSourceCopy;

        Devlock devlock(Device);

        status = DrvFillRects(
            &SurfaceBounds,
            1,
            &drawRect,
            brush.GetDeviceBrush());

        // Restore the context state we changed

        Context->WorldToDevice = oldWorldToDevice;
        Context->AntiAliasMode = oldAntiAliasMode;
        Context->CompositingMode = oldCompositingMode;
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   API to fill rectangles using the specified brush
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   12/06/1998 andrewgo
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::FillRects(
    GpBrush* brush,
    const GpRectF* rects,
    INT count
    )
{
    INT i;
    GpStatus status = Ok;

    // Objects returned from the API must always be in a valid state:

    ASSERT((brush != NULL) && (rects != NULL));
    ASSERT(this->IsValid() && brush->IsValid());
    
    // See RAID bug:
    // 301407 GDI+ Globals::DesktopDC has thread affinity

    ASSERT(GetObjectType(Globals::DesktopIc) == OBJ_DC);

    if (count < 0)
    {
        return InvalidParameter;
    }

    if (count == 0)
    {
        return Ok;
    }

    // Zoom through the list and accumulate the bounds.  What a pain, but
    // we have to do this.

    REAL left   = rects[0].X;
    REAL top    = rects[0].Y;
    REAL right  = rects[0].GetRight();
    REAL bottom = rects[0].GetBottom();

    // !!![andrewgo] We have a bug here, in that we don't properly handle
    //               rectangles with negative dimensions (which after the
    //               transform might be positive dimensions):

    for (i = 1; i < count; i++)
    {
        if (rects[i].X < left)
        {
            left = rects[i].X;
        }
        if (rects[i].GetRight() > right)
        {
            right = rects[i].GetRight();
        }
        if (rects[i].Y < top)
        {
            top = rects[i].Y;
        }
        if (rects[i].GetBottom() > bottom)
        {
            bottom = rects[i].GetBottom();
        }
    }

    // Convert the bounds to device space:

    GpRectF bounds;

    TransformBounds(&(Context->WorldToDevice), left, top, right, bottom, &bounds);

    if (IsRecording())
    {
        status = Metafile->RecordFillRects(&bounds, brush, rects, count);
        if (status != Ok)
        {
            SetValid(FALSE);      // Prevent any more recording
            return status;
        }
        if (!DownLevel)
        {
            return Ok;
        }
        // else we need to record down-level GDI EMF records as well
    }

    if (UseDriverRects())
    {
        status = RenderFillRects(&bounds, count, rects, brush);
    }
    else
    {
        for (i = 0; i < count; i++)
        {
            if ((rects[i].Width > REAL_EPSILON) &&
                (rects[i].Height > REAL_EPSILON)   )
            {
                GpPointF points[4];

                REAL left = rects[i].X;
                REAL top = rects[i].Y;
                REAL right = rects[i].X + rects[i].Width;
                REAL bottom = rects[i].Y + rects[i].Height;

                points[0].X = left;
                points[0].Y = top;
                points[1].X = right;
                points[1].Y = top;
                points[2].X = right;
                points[2].Y = bottom;
                points[3].X = left;
                points[3].Y = bottom;

                const INT stackCount = 10;
                GpPointF stackPoints[stackCount];
                BYTE stackTypes[stackCount];

                GpPath path(
                    points,
                    4,
                    &stackPoints[0],
                    &stackTypes[0],
                    stackCount,
                    FillModeAlternate,
                    DpPath::ConvexRectangle
                );

                path.CloseFigure();

                if (path.IsValid())
                {
                    // Call internal FillPath so that path doesn't get recorded in
                    // the metafile again.

                    status = RenderFillPath(&bounds, &path, brush);

                    // Terminate if we failed to render.

                    if(status != Ok)
                    {
                        break;
                    }
                }
            }
        }
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   API to fill polygons using the specified brush
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   12/06/1998 andrewgo
*
\**************************************************************************/

GpStatus
GpGraphics::FillPolygon(
    GpBrush* brush,
    const GpPointF* points,
    INT count,
    GpFillMode fillMode
    )
{
    GpStatus status = Ok;

    ASSERT((brush != NULL) && (points != NULL));

    if ((count < 0) ||
        ((fillMode != FillModeWinding) && (fillMode != FillModeAlternate)))
    {
        return InvalidParameter;
    }

    // Two vertices or less constitutes an empty fill:

    if (count <= 2)
    {
        return Ok;
    }

    // Objects returned from the API must always be in a valid state:

    ASSERT(this->IsValid() && brush->IsValid());

    const stackCount = 30;
    GpPointF stackPoints[stackCount];
    BYTE stackTypes[stackCount];

    GpPath path(points, count, &stackPoints[0], &stackTypes[0], stackCount, fillMode);

    if (path.IsValid())
    {
        GpRectF     bounds;

        // If the path is a rectangle, we can draw it much faster and
        // save space in spool files and metafiles if we fill it as a
        // rect instead of as a path.
        if (this->UseDriverRects() && path.IsRectangle(&(Context->WorldToDevice)))
        {
            path.GetBounds(&bounds, NULL);
            return this->FillRects(brush, &bounds, 1);
        }

        path.GetBounds(&bounds, &(Context->WorldToDevice));

        if (IsRecording())
        {
            status = Metafile->RecordFillPolygon(&bounds, brush, points,
                                                 count, fillMode);
            if (status != Ok)
            {
                SetValid(FALSE);      // Prevent any more recording
                return status;
            }
            if (!DownLevel)
            {
                return Ok;
            }
            // else we need to record down-level GDI EMF records as well
        }

        // Call internal FillPath so that path doesn't get recorded in
        // the metafile again.
        status = RenderFillPath(&bounds, &path, brush);
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   API to fill an ellipse using the specified brush
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   02/18/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::FillEllipse(
    GpBrush* brush,
    const GpRectF& rect
    )
{
    ASSERT(brush != NULL);

    // Objects returned from the API must always be in a valid state:
    ASSERT(this->IsValid() && brush->IsValid());

    GpPath path;
    GpStatus status = path.AddEllipse(rect);

    if ((status == Ok) && path.IsValid())
    {
        GpRectF     bounds;

        path.GetBounds(&bounds, &(Context->WorldToDevice));

        if (IsRecording())
        {
            status = Metafile->RecordFillEllipse(&bounds, brush, rect);
            if (status != Ok)
            {
                SetValid(FALSE);      // Prevent any more recording
                return status;
            }
            if (!DownLevel)
            {
                return Ok;
            }
            // else we need to record down-level GDI EMF records as well
        }

        // Call internal FillPath so that path doesn't get recorded in
        // the metafile again.
        status = RenderFillPath(&bounds, &path, brush);
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   API to fill a pie shape using the specified brush
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   02/18/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::FillPie(
    GpBrush* brush,
    const GpRectF& rect,
    REAL startAngle,
    REAL sweepAngle
    )
{
    ASSERT(brush != NULL);

    // Objects returned from the API must always be in a valid state:
    ASSERT(this->IsValid() && brush->IsValid());

    GpPath      path;
    GpStatus    status = path.AddPie(rect, startAngle, sweepAngle);

    if ((status == Ok) && path.IsValid())
    {
        GpRectF     bounds;

        path.GetBounds(&bounds, &(Context->WorldToDevice));

        if (IsRecording())
        {
            status = Metafile->RecordFillPie(&bounds, brush, rect,
                                             startAngle, sweepAngle);
            if (status != Ok)
            {
                SetValid(FALSE);      // Prevent any more recording
                return status;
            }
            if (!DownLevel)
            {
                return Ok;
            }
            // else we need to record down-level GDI EMF records as well
        }

        // Call internal FillPath so that path doesn't get recorded in
        // the metafile again.
        status = RenderFillPath(&bounds, &path, brush);
    }

    return status;
}


/**************************************************************************\
*
* Function Description:
*
*   API to fill region  using the specified brush
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   12/18/1998 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::FillRegion(
    GpBrush* brush,
    GpRegion* region
    )
{
    GpStatus status;

    ASSERT((brush != NULL) && (region != NULL));

    // Objects returned from the API must always be in a valid state:

    ASSERT(this->IsValid() && brush->IsValid() && region->IsValid());

    BOOL    regionIsEmpty;

    if ((status = region->IsEmpty(&Context->WorldToDevice, &regionIsEmpty)) != Ok)
    {
        return status;
    }

    if (regionIsEmpty)
    {
        return Ok;
    }

    GpRectF     bounds;

    if ((status = region->GetBounds(this, &bounds, TRUE)) == Ok)
    {
        // The region may have very large bounds if it is infinite or if
        // an infinite region was combined with another region.  We don't
        // want to draw a huge region into a metafile, because it will
        // mess up the bounds of the metafile. So intersect the region
        // with the appropriate bounding rect.

        GpRect  metafileBounds; // in device units
        BOOL    isMetafileGraphics = (this->Type == GraphicsMetafile);

        if (isMetafileGraphics)
        {
            if (this->Metafile != NULL)
            {
                this->Metafile->GetMetafileBounds(metafileBounds);
                metafileBounds.Width++;     // make exclusive
                metafileBounds.Height++;
            }
            else    // use size of HDC
            {
                HDC         hdc = Context->GetHdc(Surface);
                metafileBounds.X = 0;
                metafileBounds.Y = 0;
                metafileBounds.Width  = ::GetDeviceCaps(hdc, HORZRES);
                metafileBounds.Height = ::GetDeviceCaps(hdc, VERTRES);
                Context->ReleaseHdc(hdc);
            }
            GpRectF     metafileBoundsF;
            metafileBoundsF.X      = (REAL)metafileBounds.X;
            metafileBoundsF.Y      = (REAL)metafileBounds.Y;
            metafileBoundsF.Width  = (REAL)metafileBounds.Width;
            metafileBoundsF.Height = (REAL)metafileBounds.Height;
            bounds.Intersect(metafileBoundsF);
        }

        if (IsRecording())
        {
            status = Metafile->RecordFillRegion(&bounds, brush, region);
            if (status != Ok)
            {
                SetValid(FALSE);      // Prevent any more recording
                return status;
            }
            if (!DownLevel)
            {
                return Ok;
            }
            // else we need to record down-level GDI EMF records as well
        }

        if (isMetafileGraphics)
        {
            status = RenderFillRegion(&bounds, region, brush, &metafileBounds);
        }
        else    // not an infinite region
        {
            // call internal FillRegion that doesn't do recording
            status = RenderFillRegion(&bounds, region, brush, NULL);
        }
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   API to fill path using the specified brush
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   12/18/1998 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::FillPath(
    const GpBrush* brush,
    GpPath* path
    )
{
    GpStatus status = Ok;

    ASSERT((brush != NULL) && (path != NULL));

    // Objects returned from the API must always be in a valid state:

    ASSERT(this->IsValid() && brush->IsValid() && path->IsValid());

    // Don't do anything with less then 2 points.

    if (path->GetPointCount() < 3)
    {
        return status;
    }

    GpRectF     bounds;

    // If the path is a rectangle, we can draw it much faster and
    // save space in spool files and metafiles if we fill it as a
    // rect instead of as a path.
    if (this->UseDriverRects() && path->IsRectangle(&(Context->WorldToDevice)))
    {
        path->GetBounds(&bounds, NULL);
        return this->FillRects(const_cast<GpBrush *>(brush), &bounds, 1);
    }

    path->GetBounds(&bounds, &(Context->WorldToDevice));

    if (IsRecording())
    {
        status = Metafile->RecordFillPath(&bounds, brush, path);
        if (status != Ok)
        {
            SetValid(FALSE);      // Prevent any more recording
            return status;
        }
        if (!DownLevel)
        {
            return Ok;
        }
        // else we need to record down-level GDI EMF records as well
    }

    // call internal FillPath that doesn't do recording
    status = RenderFillPath(&bounds, path, brush);

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   API to fill a closed curve using the specified brush
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   02/18/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::FillClosedCurve(
    GpBrush* brush,
    const GpPointF* points,
    INT count,
    REAL tension,
    GpFillMode fillMode
    )
{
    ASSERT((brush != NULL) && (points != NULL));

    // Objects returned from the API must always be in a valid state:
    ASSERT(this->IsValid() && brush->IsValid());

    if ((count < 0) ||
        ((fillMode != FillModeWinding) && (fillMode != FillModeAlternate)))
    {
        return InvalidParameter;
    }

    // Less than three vertices constitutes an empty fill:
    if (count < 3)
    {
        return Ok;
    }

    GpPath      path(fillMode);
    GpStatus    status = path.AddClosedCurve(points, count, tension);

    if ((status == Ok) && path.IsValid())
    {
        GpRectF     bounds;

        path.GetBounds(&bounds, &(Context->WorldToDevice));

        if (IsRecording())
        {
            status = Metafile->RecordFillClosedCurve(&bounds, brush,
                                                     points, count, tension,
                                                     fillMode);
            if (status != Ok)
            {
                SetValid(FALSE);      // Prevent any more recording
                return status;
            }
            if (!DownLevel)
            {
                return Ok;
            }
            // else we need to record down-level GDI EMF records as well
        }

        // Call internal FillPath so that path doesn't get recorded in
        // the metafile again.
        status = RenderFillPath(&bounds, &path, brush);
    }

    return status;
}


/**************************************************************************\
*
* Function Description:
*
*   API to draw polygons using the specified pen
*
* Arguments:
*
*   [IN] pen    - the pen for stroking.
*   [IN] points - the point data.
*   [IN] count  - the number of points given in points array.
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   01/06/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::DrawLines(
    GpPen* pen,
    const GpPointF* points,
    INT count,
    BOOL closed
    )
{
    GpStatus status = Ok;

    ASSERT((pen != NULL) && (points != NULL));

    if (count < 2)
    {
        return InvalidParameter;
    }

    // Objects returned from the API must always be in a valid state:

    ASSERT(this->IsValid() && pen->IsValid());

    const stackCount = 30;
    GpPointF stackPoints[stackCount];
    BYTE stackTypes[stackCount];

    GpPath path(points, count, stackPoints, stackTypes, stackCount, FillModeWinding);
    if(closed)
        path.CloseFigure();

    if (path.IsValid())
    {
        GpRectF     bounds;

        REAL dpiX = GetDpiX();
        REAL dpiY = GetDpiY();
        path.GetBounds(&bounds, &(Context->WorldToDevice), pen->GetDevicePen(), dpiX, dpiY);

        if (IsRecording())
        {
            status = Metafile->RecordDrawLines(&bounds, pen, points,
                                               count, closed);
            if (status != Ok)
            {
                SetValid(FALSE);      // Prevent any more recording
                return status;
            }
            if (!DownLevel)
            {
                return Ok;
            }
            // else we need to record down-level GDI EMF records as well
        }

        // Call internal DrawPath so that path doesn't get recorded in
        // the metafile again.
        status = RenderDrawPath(&bounds, &path, pen);
   }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   API to draw an arc using the specified pen
*
* Arguments:
*
*   [IN] pen            - the pen for stroking.
*   [IN] rect           - the boundary rect.
*   [IN] startAndle     - the start angle in degrees
*   [IN] sweepAngle     - the sweep angle in degrees in clockwise
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   02/18/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::DrawArc(
    GpPen* pen,
    const GpRectF& rect,
    REAL startAngle,
    REAL sweepAngle
    )
{
    ASSERT(pen != NULL);

    // Objects returned from the API must always be in a valid state:
    ASSERT(this->IsValid() && pen->IsValid());

    GpPath      path;
    GpStatus    status = path.AddArc(rect, startAngle, sweepAngle);

    if ((status == Ok) && path.IsValid())
    {
        GpRectF     bounds;

        REAL dpiX = GetDpiX();
        REAL dpiY = GetDpiY();
        path.GetBounds(&bounds, &(Context->WorldToDevice), pen->GetDevicePen(), dpiX, dpiY);

        if (IsRecording())
        {
            status = Metafile->RecordDrawArc(&bounds, pen, rect,
                                             startAngle, sweepAngle);
            if (status != Ok)
            {
                SetValid(FALSE);      // Prevent any more recording
                return status;
            }
            if (!DownLevel)
            {
                return Ok;
            }
            // else we need to record down-level GDI EMF records as well
        }

        // Call internal DrawPath so that path doesn't get recorded in
        // the metafile again.
        status = RenderDrawPath(&bounds, &path, pen);
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   API to draw Cubic Bezier curves using the specified pen
*
* Arguments:
*
*   [IN] pen    - the pen for stroking.
*   [IN] points - the control points.
*   [IN] count  - the number of control points (must be 3n + 1).
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   02/18/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::DrawBeziers(
    GpPen* pen,
    const GpPointF* points,
    INT count
    )
{
    ASSERT((pen != NULL) && (points != NULL));

    // Objects returned from the API must always be in a valid state:
    ASSERT(this->IsValid() && pen->IsValid());

    // Nothing to draw
    if (count <= 3)
    {
        return Ok;
    }

    GpPath      path;
    GpStatus    status = path.AddBeziers(points, count);

    if ((status == Ok) && path.IsValid())
    {
        GpRectF     bounds;

        REAL dpiX = GetDpiX();
        REAL dpiY = GetDpiY();
        path.GetBounds(&bounds, &(Context->WorldToDevice), pen->GetDevicePen(), dpiX, dpiY);

        if (IsRecording())
        {
            status = Metafile->RecordDrawBeziers(&bounds, pen,
                                                 points, count);
            if (status != Ok)
            {
                SetValid(FALSE);      // Prevent any more recording
                return status;
            }
            if (!DownLevel)
            {
                return Ok;
            }
            // else we need to record down-level GDI EMF records as well
        }

        // Call internal DrawPath so that path doesn't get recorded in
        // the metafile again.
        status = RenderDrawPath(&bounds, &path, pen);
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   API to draw rectangles using the specified brush
*
* Arguments:
*
*   [IN] pen    - the pen for stroking.
*   [IN] rects  - the rectangle array.
*   [IN] count  - the number of rectangles given in rects array.
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   01/15/1998 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::DrawRects(
    GpPen* pen,
    const GpRectF* rects,
    INT count
    )
{
    INT i;
    GpStatus status = Ok;

    // !!! Change Eng function to do clipping
    // !!! Create a stack path
    // !!! Fix multiple inheritence thing
    // !!! Check tail merging
    // !!! Add alignment checks
    // !!! Change DDIs to return GpStatus?
    // !!! Add ICM hooks?
    // !!! Change path constant to include 'single figure'?
    // !!! Create .LIB
    // !!! Add convention for alpha

    // Objects returned from the API must always be in a valid state:

    ASSERT((pen != NULL) && (rects != NULL));
    ASSERT(this->IsValid() && pen->IsValid());

    if (count < 0)
    {
        return InvalidParameter;
    }

    if (count == 0)
    {
        return Ok;
    }

    // Zoom through the list and accumulate the bounds.  What a pain, but
    // we have to do this.

    // !!! We're doing 'double' goop, so we should ensure correct stack
    //     alignment

    REAL left   = rects[0].X;
    REAL top    = rects[0].Y;
    REAL right  = rects[0].GetRight();
    REAL bottom = rects[0].GetBottom();

    for (i = 1; i < count; i++)
    {
        if (rects[i].X < left)
        {
            left = rects[i].X;
        }
        if (rects[i].GetRight() > right)
        {
            right = rects[i].GetRight();
        }
        if (rects[i].Y < top)
        {
            top = rects[i].Y;
        }
        if (rects[i].GetBottom() > bottom)
        {
            bottom = rects[i].GetBottom();
        }
    }

    GpRectF     bounds;

    // Convert the bounds to device space and adjust for the pen width

    REAL dpiX = GetDpiX();
    REAL dpiY = GetDpiY();

    DpPen *dpPen = pen->GetDevicePen();

    REAL penWidth = 0;
    Unit penUnit = UnitWorld;
    REAL delta = 0;

    if(dpPen)
    {
        penWidth = dpPen->Width;
        penUnit = dpPen->Unit;

        if(penUnit == UnitWorld)
        {
            // If the pen is in World unit, strech the rectangle
            // by pen width before the transform.

            // For a case of the centered pen.
            // penWidth/2 is OK. But here, we
            // just use penWidth for all pen mode.

            delta = penWidth;

            left -= delta;
            top -= delta;
            right += delta;
            bottom += delta;
        }
    }

    TransformBounds(&(Context->WorldToDevice), left, top, right, bottom,
        &bounds);

    if(dpPen)
    {
        if(penUnit != UnitWorld)
        {
            // If the pen is not in World unit, strech the rectangle
            // by pen's device width after the transform.

            REAL dpi = max(dpiX, dpiY);
            penWidth = ::GetDeviceWidth(penWidth, penUnit, dpi);

            // For a case of the centered pen.
            // penWidth/2 is OK. But here, we
            // just use penWidth for all pen mode.

            delta = penWidth;

            bounds.X -= delta;
            bounds.Y -= delta;
            bounds.Width += 2*delta;
            bounds.Height += 2*delta;
        }
    }

    if (IsRecording())
    {
        status = Metafile->RecordDrawRects(&bounds, pen, rects, count);
        if (status != Ok)
        {
            SetValid(FALSE);      // Prevent any more recording
            return status;
        }
        if (!DownLevel)
        {
            return Ok;
        }
        // else we need to record down-level GDI EMF records as well
    }

    // Increase the bounds to account for the widener's minimum pen width.
    // For some arcane reason, the widener doesn't use 1.0 as the minimum
    // pen width. Rather it uses 1.000001f. Also it has some interesting
    // rounding properties, so our epsilon here is much larger 0.001f

    bounds.Inflate(1.001f, 1.001f);

    for (i = 0; i < count; i++)
    {
        if ((rects[i].Width > REAL_EPSILON) &&
            (rects[i].Height > REAL_EPSILON)   )
        {
            // !!! Should use a stack-path
            // !!! For StrokePath case, should check start of rectangle
            //     for styled lines

            GpPointF points[4];

            REAL left = rects[i].X;
            REAL top = rects[i].Y;
            REAL right = rects[i].X + rects[i].Width;
            REAL bottom = rects[i].Y + rects[i].Height;

            points[0].X = left;
            points[0].Y = top;
            points[1].X = right;
            points[1].Y = top;
            points[2].X = right;
            points[2].Y = bottom;
            points[3].X = left;
            points[3].Y = bottom;

            const INT stackCount = 10;
            GpPointF stackPoints[stackCount];
            BYTE stackTypes[stackCount];

            GpPath path(
                points,
                4,
                stackPoints,
                stackTypes,
                stackCount,
                FillModeAlternate,
                DpPath::ConvexRectangle
            );

            path.CloseFigure();

            if(path.IsValid())
            {
                // Call internal DrawPath so that path doesn't get recorded in
                // the metafile again.
                status = RenderDrawPath(&bounds, &path, pen);

                if(status != Ok)
                {
                    break;
                }
            }
        }
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   API to draw an ellipse using the specified pen
*
* Arguments:
*
*   [IN] pen    - the pen for stroking.
*   [IN] rect   - the boundary rectangle
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   02/18/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::DrawEllipse(
    GpPen* pen,
    const GpRectF& rect
    )
{
    ASSERT(pen != NULL);

    // Objects returned from the API must always be in a valid state:
    ASSERT(this->IsValid() && pen->IsValid());

    GpPath      path;
    GpStatus    status = path.AddEllipse(rect);

    if ((status == Ok) && path.IsValid())
    {
        GpRectF     bounds;

        REAL dpiX = GetDpiX();
        REAL dpiY = GetDpiY();
        path.GetBounds(&bounds, &(Context->WorldToDevice), pen->GetDevicePen(), dpiX, dpiY);

        if (IsRecording())
        {
            status = Metafile->RecordDrawEllipse(&bounds, pen, rect);
            if (status != Ok)
            {
                SetValid(FALSE);      // Prevent any more recording
                return status;
            }
            if (!DownLevel)
            {
                return Ok;
            }
            // else we need to record down-level GDI EMF records as well
        }

        // Call internal DrawPath so that path doesn't get recorded in
        // the metafile again.
        status = RenderDrawPath(&bounds, &path, pen);
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   API to draw a pie using the specified pen
*
* Arguments:
*
*   [IN] pen    - the pen for stroking.
*   [IN] rect   - the boundary rectangle
*   [IN] startAngle - the start angle in degrees.
*   [IN] sweepAngle - the sweep angle in degrees in clockwise.
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   02/18/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::DrawPie(
    GpPen* pen,
    const GpRectF& rect,
    REAL startAngle,
    REAL sweepAngle
    )
{
    ASSERT(pen != NULL);

    // Objects returned from the API must always be in a valid state:
    ASSERT(this->IsValid() && pen->IsValid());

    GpPath      path;
    GpStatus    status = path.AddPie(rect, startAngle, sweepAngle);

    if ((status == Ok) && path.IsValid())
    {
        GpRectF     bounds;

        REAL dpiX = GetDpiX();
        REAL dpiY = GetDpiY();
        path.GetBounds(&bounds, &(Context->WorldToDevice), pen->GetDevicePen(), dpiX, dpiY);

        if (IsRecording())
        {
            status = Metafile->RecordDrawPie(&bounds, pen, rect,
                                             startAngle, sweepAngle);
            if (status != Ok)
            {
                SetValid(FALSE);      // Prevent any more recording
                return status;
            }
            if (!DownLevel)
            {
                return Ok;
            }
            // else we need to record down-level GDI EMF records as well
        }

        // Call internal DrawPath so that path doesn't get recorded in
        // the metafile again.
        status = RenderDrawPath(&bounds, &path, pen);
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   API to draw path using the specified pen
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   01/27/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::DrawPath(
        GpPen* pen,
        GpPath* path
    )
{
    GpStatus status = Ok;

    ASSERT((pen != NULL) && (path != NULL));


    // Objects returned from the API must always be in a valid state:

    ASSERT(this->IsValid() && pen->IsValid() && path->IsValid());

    // Don't do anything unless we have at least one point

    if (path->GetPointCount() < 1)
    {
        return status;
    }

    GpRectF     bounds;

    REAL dpiX = GetDpiX();
    REAL dpiY = GetDpiY();
    path->GetBounds(&bounds, &(Context->WorldToDevice), pen->GetDevicePen(), dpiX, dpiY);

    if (IsRecording())
    {
        status = Metafile->RecordDrawPath(&bounds, pen, path);
        if (status != Ok)
        {
            SetValid(FALSE);      // Prevent any more recording
            return status;
        }
        if (!DownLevel)
        {
            return Ok;
        }
        // else we need to record down-level GDI EMF records as well
    }

    // call internal DrawPath that doesn't do recording
    status = RenderDrawPath(&bounds, path, pen);

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   API to draw a curve using the specified pen.
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   02/18/1999 ikkof
*       Created it.
*
\**************************************************************************/

#define DEFAULT_TENSION     0.5

GpStatus
GpGraphics::DrawCurve(
    GpPen* pen,
    const GpPointF* points,
    INT count
    )
{
    return DrawCurve(pen, points, count, DEFAULT_TENSION, 0, count - 1);
}

GpStatus
GpGraphics::DrawCurve(
    GpPen* pen,
    const GpPointF* points,
    INT count,
    REAL tension,
    INT offset,
    INT numberOfSegments
    )
{
    ASSERT((pen != NULL) && (points != NULL));

    // Objects returned from the API must always be in a valid state:
    ASSERT(this->IsValid() && pen->IsValid());

    if (count < 2)
    {
        return InvalidParameter;
    }

    GpPath      path;
    GpStatus    status = path.AddCurve(points,
                                       count,
                                       tension,
                                       offset,
                                       numberOfSegments);

    if ((status == Ok) && path.IsValid())
    {
        GpRectF     bounds;

        REAL dpiX = GetDpiX();
        REAL dpiY = GetDpiY();
        path.GetBounds(&bounds, &(Context->WorldToDevice), pen->GetDevicePen(), dpiX, dpiY);

        if (IsRecording())
        {
            status = Metafile->RecordDrawCurve(&bounds, pen, points,
                                               count, tension, offset,
                                               numberOfSegments);
            if (status != Ok)
            {
                SetValid(FALSE);      // Prevent any more recording
                return status;
            }
            if (!DownLevel)
            {
                return Ok;
            }
            // else we need to record down-level GDI EMF records as well
        }

        // Call internal DrawPath so that path doesn't get recorded in
        // the metafile again.
        status = RenderDrawPath(&bounds, &path, pen);
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   API to draw a closed curve using the specified pen.
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   02/18/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::DrawClosedCurve(
    GpPen* pen,
    const GpPointF* points,
    INT count
    )
{
    return DrawClosedCurve (pen, points, count, DEFAULT_TENSION);
}

GpStatus
GpGraphics::DrawClosedCurve(
        GpPen* pen,
        const GpPointF* points,
        INT count,
        REAL tension
    )
{
    ASSERT((pen != NULL) && (points != NULL));

    // Objects returned from the API must always be in a valid state:
    ASSERT(this->IsValid() && pen->IsValid());

    if (count < 3)
    {
        return InvalidParameter;
    }

    GpPath      path;
    GpStatus    status = path.AddClosedCurve(points, count, tension);

    if ((status == Ok) && path.IsValid())
    {
        GpRectF     bounds;

        REAL dpiX = GetDpiX();
        REAL dpiY = GetDpiY();
        path.GetBounds(&bounds, &(Context->WorldToDevice), pen->GetDevicePen(), dpiX, dpiY);

        if (IsRecording())
        {
            status = Metafile->RecordDrawClosedCurve(&bounds, pen, points,
                                                     count, tension);
            if (status != Ok)
            {
                SetValid(FALSE);      // Prevent any more recording
                return status;
            }
            if (!DownLevel)
            {
                return Ok;
            }
            // else we need to record down-level GDI EMF records as well
        }

        // Call internal DrawPath so that path doesn't get recorded in
        // the metafile again.
        status = RenderDrawPath(&bounds, &path, pen);
    }

    return status;
}


/**************************************************************************\
*
* Function Description:
*
*   Internal Drawing routine for a path.  Various functions will
*   call RenderFillPath.
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   09/18/2000 asecchia
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::RenderFillPath(
    GpRectF*    bounds,
    GpPath*     path,
    const GpBrush*    brush
    )
{
    // Are they asking us to draw nothing?

    if( REALABS(bounds->Width) < REAL_EPSILON ||
        REALABS(bounds->Height) < REAL_EPSILON )
    {
        // Yes. Ok, we did it.
        return Ok;
    }

    GpRect      deviceBounds;
    GpStatus status = BoundsFToRect(bounds, &deviceBounds);

    if (status == Ok && !IsTotallyClipped(&deviceBounds))
    {
        // Now that we've done a bunch of work in accumulating the bounds,
        // acquire the device lock before calling the driver:

        Devlock devlock(Device);

        return DrvFillPath(&deviceBounds, path, brush->GetDeviceBrush());
    }
    return status;
}


/**************************************************************************\
*
* Function Description:
*
*   Internal Drawing routine for a path.  Various functions will
*   call RenderDrawPath.
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   10/28/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::RenderDrawPath(
    GpRectF *   bounds,
    GpPath *    path,
    GpPen *     pen
    )
{
    // Are they asking us to draw nothing?

    if( REALABS(bounds->Width) < REAL_EPSILON ||
        REALABS(bounds->Height) < REAL_EPSILON )
    {
        // Yes. Ok, we did it.
        return Ok;
    }

    GpRect      deviceBounds;
    GpStatus status = BoundsFToRect(bounds, &deviceBounds);
    INT         savedState = 0;

    if (status == Ok && !IsTotallyClipped(&deviceBounds))
    {
        // Now that we've done a bunch of work in accumulating the bounds,
        // acquire the device lock before calling the driver:

        Devlock devlock(Device);

        status = DrvStrokePath(&deviceBounds, path, pen->GetDevicePen());
    }
    return status;
}

VOID
GetEmfDpi(
    HDC     hdc,
    REAL *  dpiX,
    REAL *  dpiY
    )
{
    SIZEL   szlDevice;          // Size of the reference device in pels
    SIZEL   szlMillimeters;     // Size of the reference device in millimeters

    szlDevice.cx = GetDeviceCaps(hdc, HORZRES);
    szlDevice.cy = GetDeviceCaps(hdc, VERTRES);

    szlMillimeters.cx = GetDeviceCaps(hdc, HORZSIZE);
    szlMillimeters.cy = GetDeviceCaps(hdc, VERTSIZE);

    if ((szlDevice.cx > 0) && (szlDevice.cy > 0) &&
        (szlMillimeters.cx > 0) && (szlMillimeters.cy > 0))
    {
        *dpiX = (static_cast<REAL>(szlDevice.cx) /
                 static_cast<REAL>(szlMillimeters.cx)) * 25.4f;
        *dpiY = (static_cast<REAL>(szlDevice.cy) /
                 static_cast<REAL>(szlMillimeters.cy)) * 25.4f;
    }
    else
    {
        WARNING(("GetDeviceCaps failed"));

        *dpiX = DEFAULT_RESOLUTION;
        *dpiY = DEFAULT_RESOLUTION;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Get the size of the destination image in the current page units.
*
* Arguments:
*
*   [IN]  srcDpiX    - horizontal resolution of the source image
*   [IN]  srcDpiY    - vertical resolution of the source image
*   [IN]  srcWidth   - width  of the source image in srcUnit units
*   [IN]  srcHeight  - height of the source image in srcUnit units
*   [IN]  srcUnit    - units of the srcWidth and srcHeight
*   [OUT] destWidth  - destination width  in the current page units
*   [OUT] destHeight - destination height in the current page units
*
* Return Value:
*
*   NONE
*
* Created:
*
*   05/10/1999 DCurtis
*
\**************************************************************************/
VOID
GpGraphics::GetImageDestPageSize(
    const GpImage *     image,
    REAL                srcWidth,
    REAL                srcHeight,
    GpPageUnit          srcUnit,
    REAL &              destWidth,
    REAL &              destHeight
    )
{
    // UnitDisplay is device-dependent and cannot be used for a source unit
    ASSERT(srcUnit != UnitDisplay);

    if (srcUnit == UnitPixel)
    {
        REAL        srcDpiX;
        REAL        srcDpiY;
        REAL        destDpiX;
        REAL        destDpiY;

        image->GetResolution(&srcDpiX, &srcDpiY);

        // We don't want to create a bitmap just to get the dpi
        // so check if we can get an Hdc easily from the context.
        if ((image->GetImageType() == ImageTypeMetafile) &&
            (((GpMetafile *)(image))->IsEmfOrEmfPlus()) &&
            (Context->Hwnd || Context->Hdc))
        {
            // EMFs use a different style of dpi than other images that
            // is based off the screen size instead of the font size.

            if (Context->Hwnd)
            {
                // We don't need a clean dc to find out the dpi
                HDC     hdc = GetDC(Context->Hwnd);
                GetEmfDpi(hdc, &destDpiX, &destDpiY);
                ReleaseDC(Context->Hwnd, hdc);
            }
            else
            {
                GetEmfDpi(Context->Hdc, &destDpiX, &destDpiY);
            }
        }
        else
        {
            destDpiX = GetDpiX();
            destDpiY = GetDpiY();
        }

        // To get the dest size, convert the width and height from the image
        // resolution to the resolution of this graphics and then convert
        // them to page units by going through the inverse of the page to
        // device transform.

        destWidth  = (srcWidth * destDpiX) /
                     (srcDpiX * Context->PageMultiplierX);
        destHeight = (srcHeight * destDpiY) /
                     (srcDpiY * Context->PageMultiplierY);
    }
    else
    {
        // Just convert from the units of the image to the current
        // page units.

        REAL        unitMultiplierX;
        REAL        unitMultiplierY;

        Context->GetPageMultipliers(&unitMultiplierX, &unitMultiplierY,
                                    srcUnit);

        destWidth  = (srcWidth  * unitMultiplierX) / Context->PageMultiplierX;
        destHeight = (srcHeight * unitMultiplierY) / Context->PageMultiplierY;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   API to draw image
*
* Arguments:
*
*   [IN] image  - the image to draw.
*   [IN] point  - the top-left corner of the drawing boundary.
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   01/06/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::DrawImage(
    GpImage* image,
    const GpPointF& point
    )
{
    GpStatus status;

    ASSERT((image != NULL));

    // Objects returned from the API must always be in a valid state:

    ASSERT(this->IsValid() && image->IsValid());

    GpRectF     srcRect;
    GpPageUnit  srcUnit;
    REAL        destWidth;
    REAL        destHeight;

    status = image->GetBounds(&srcRect, &srcUnit);
    if(status != Ok) {return status;}

    // UnitDisplay is device-dependent and cannot be used for a source unit
    ASSERT(srcUnit != UnitDisplay);

    if (status == Ok)
    {
        // Get the dest size in page units
        GetImageDestPageSize(image, srcRect.Width, srcRect.Height,
                             srcUnit, destWidth, destHeight);

        GpRectF destRect(point.X, point.Y, destWidth, destHeight);

        return DrawImage(image, destRect, srcRect, srcUnit);
    }
    return status;
}

GpStatus
GpGraphics::DrawImage(
    GpImage*        image,
    REAL            x,
    REAL            y,
    const GpRectF & srcRect,
    GpPageUnit      srcUnit
    )
{
    // UnitDisplay is device-dependent and cannot be used for a source unit
    ASSERT(srcUnit != UnitDisplay);

    REAL        srcDpiX, srcDpiY;
    REAL        destWidth;
    REAL        destHeight;

    // Get the dest size in page units
    GetImageDestPageSize(image, srcRect.Width, srcRect.Height,
                         srcUnit, destWidth, destHeight);

    GpRectF destRect(x, y, destWidth, destHeight);

    return DrawImage(image, destRect, srcRect, srcUnit);
}

/**************************************************************************\
*
* Function Description:
*
*   API to draw image.
*
*   [IN] image  - the image to draw.
*   [IN] rect   - the the drawing boundary.
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   01/12/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::DrawImage(
    GpImage* image,
    const GpRectF& destRect
    )
{
    GpStatus status;

    ASSERT((image != NULL));

    // Objects returned from the API must always be in a valid state:

    ASSERT(this->IsValid() && image->IsValid());

    GpPageUnit  srcUnit;
    GpRectF     srcRect;

    status = image->GetBounds(&srcRect, &srcUnit);
    if(status != Ok) { return status; }

    // UnitDisplay is device-dependent and cannot be used for a source unit
    ASSERT(srcUnit != UnitDisplay);

    if (status == Ok)
    {
        return DrawImage(image, destRect, srcRect, srcUnit);
    }
    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   API to draw image.
*
*   [IN] image    - the image to draw.
*   [IN] destPoints - the destination quad.
*   [IN] count - the number of count in destPoints[] (3 or 4).
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   04/14/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::DrawImage(
        GpImage* image,
        const GpPointF* destPoints,
        INT count
        )
{
    GpStatus status;

    // count of 4 is not implemented yet (perspective blt)

    if(count == 4)
    {
        return NotImplemented;
    }

    if(count != 3)
    {
        return InvalidParameter;
    }

    ASSERT(count == 3); // Currently only supports Affine transform.
    ASSERT((image != NULL));

    // Objects returned from the API must always be in a valid state:

    ASSERT(this->IsValid() && image->IsValid());

    GpPageUnit  srcUnit;
    GpRectF     srcRect;

    status = image->GetBounds(&srcRect, &srcUnit);
    if(status != Ok) { return status; }

    // UnitDisplay is device-dependent and cannot be used for a source unit
    ASSERT(srcUnit != UnitDisplay);

    if (status == Ok)
    {
        return DrawImage(image, destPoints, count, srcRect, srcUnit);
    }
    return status;
}


/**************************************************************************\
*
* Function Description:
*
*   API to draw image.
*
*   [IN] image    - the image to draw.
*   [IN] destRect - the destination rectangle.
*   [IN] srcRect  - the portion of the image to copy.
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   01/12/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::DrawImage(
    GpImage*           image,
    const GpRectF&     destRect,
    const GpRectF&     srcRect,
    GpPageUnit         srcUnit,
    const GpImageAttributes* imageAttributes,
    DrawImageAbort     callback,
    VOID*              callbackData
    )
{
    GpStatus status = Ok;

    ASSERT((image != NULL));

    // Objects returned from the API must always be in a valid state:

    ASSERT(this->IsValid() && image->IsValid());

    // UnitDisplay is device-dependent and cannot be used for a source unit
    ASSERT(srcUnit != UnitDisplay);

    GpRectF offsetSrcRect = srcRect ;

    GpPointF destPoints[3];
    destPoints[0].X = destRect.X;
    destPoints[0].Y = destRect.Y;
    destPoints[1].X = destRect.X + destRect.Width;
    destPoints[1].Y = destRect.Y;
    destPoints[2].X = destRect.X;
    destPoints[2].Y = destRect.Y + destRect.Height;

    GpRectF     bounds;
    TransformBounds(
        &(Context->WorldToDevice),
        destPoints[0].X,
        destPoints[0].Y,
        destPoints[1].X,
        destPoints[2].Y,
        &bounds
        );

    GpImageType     imageType = image->GetImageType();

    DriverDrawImageFlags flags = 0;

    GpRecolor *     recolor = NULL;

    if (imageAttributes != NULL)
    {
        if (imageAttributes->cachedBackground)
            flags |= DriverDrawImageCachedBackground;

        if (imageType == ImageTypeBitmap)
        {
            if (imageAttributes->HasRecoloring(ColorAdjustTypeBitmap))
            {
                goto HasRecoloring;
            }
        }
        else if (imageAttributes->HasRecoloring())
        {
HasRecoloring:
            recolor = imageAttributes->recolor;
            recolor->Flush();
        }
    }

    GpImage *           adjustedImage = NULL;
    GpImageAttributes   noRecoloring;

    if (IsRecording())
    {
        if (recolor != NULL)
        {
            // We assume that the image is a bitmap.
            // For Bitmaps, we want to recolor into an image that will have an
            // alpha. CloneColorAdjusted keeps the same pixel format as the
            // original image and therefore might not have an alpha channel.
            // recolor will convert to ARGB. When recording to a metafile this
            // will only create an ARGB image if the original image is not
            // palettized, therefore only for 16bit and higher. The most
            // space we can waste is twice the image.
            if(image->GetImageType() == ImageTypeBitmap)
            {
                GpBitmap * bitmap         = reinterpret_cast<GpBitmap*>(image);
                GpBitmap * adjustedBitmap = NULL;
                if (bitmap != NULL)
                {
                    status = bitmap->Recolor(recolor, &adjustedBitmap, NULL, NULL);
                    if (status == Ok)
                    {
                        adjustedImage = adjustedBitmap;
                    }
                }
            }
            else
            {
                adjustedImage = image->CloneColorAdjusted(recolor);
            }
            if (adjustedImage != NULL)
            {
                image = adjustedImage;

                // have to set the recolor to NULL in the image attributes
                // or else the down-level image will be double recolored.
                GpRecolor *     saveRecolor = noRecoloring.recolor;
                noRecoloring = *imageAttributes;
                noRecoloring.recolor = saveRecolor;
                imageAttributes = &noRecoloring;
                recolor         = noRecoloring.recolor;
            }
        }

        //  Record recolored image.
        status = Metafile->RecordDrawImage(
            &bounds,
            image,
            destRect,
            srcRect,
            srcUnit,
            imageAttributes
        );

        if (status != Ok)
        {
            SetValid(FALSE);      // Prevent any more recording
            goto Done;
        }

        if (!DownLevel)
        {
            goto Done;
        }
        // else we need to record down-level GDI EMF records as well
    }

    // Metafiles do not require PixelOffsetting, in fact it results in bad
    // side effects in some cases when the source metafile dpi is low. But
    // we still need to offset the DestRect to match the rendering with other
    // primitives
    // GillesK: If we are in HalfPixelMode, then offset the source and the
    // destination rects by -0.5 pixels

    if ((image->GetImageType() != ImageTypeMetafile) &&
        (!Context->IsPrinter) &&
        ((Context->PixelOffset == PixelOffsetModeHalf) ||
         (Context->PixelOffset == PixelOffsetModeHighQuality)))
    {
        offsetSrcRect.Offset(-0.5f, -0.5f);
    }

    {
        GpRect   deviceBounds;
        status = BoundsFToRect(&bounds, &deviceBounds);

        if (status == Ok && !IsTotallyClipped(&deviceBounds))
        {
            if (imageType == ImageTypeBitmap)
            {
                INT numPoints = 3;

                if (status == Ok)
                {
                    // Now that we've done a bunch of work in accumulating the bounds,
                    // acquire the device lock before calling the driver:

                    Devlock devlock(Device);
                    ASSERT(srcUnit == UnitPixel); // !!! for now

                    // Set the fpu state.
                    FPUStateSaver fpuState;

                    status = DrvDrawImage(
                        &deviceBounds,
                        (GpBitmap*)(image),
                        numPoints,
                        &destPoints[0],
                        &offsetSrcRect, imageAttributes,
                        callback, callbackData,
                        flags
                        );
                }
            }
            else if (imageType == ImageTypeMetafile)
            {
                // If we are recording to a different metafile, then we have
                // already recorded this metafile as an image, and now we just
                // want to record the down-level parts, so we have to set
                // g->Metafile to NULL so we don't record all the GDI+ records
                // in the metafile again -- only the down-level ones.
                // Make sure to pass in the imageAttributes recolorer since it
                // might have been changed if we already recolored the image
                IMetafileRecord * recorder = this->Metafile;
                this->Metafile = NULL;

                status = (static_cast<const GpMetafile *>(image))->Play(
                            destRect, offsetSrcRect, srcUnit, this, recolor,
                            ColorAdjustTypeDefault, callback, callbackData);

                this->Metafile = recorder;     // restore the recorder (if any)
            }
            else
            {
                ASSERT(0);
                status = NotImplemented;
            }
        }
    }

Done:
    if (adjustedImage != NULL)
    {
        adjustedImage->Dispose();
    }

    return status;
}


/**************************************************************************\
*
* Function Description:
*
*   API to draw image.
*
*   [IN] image    - the image to draw.
*   [IN] destPoints - the destination quad.
*   [IN] count - the number of count in destPoints[] (3 or 4).
*   [IN] srcRect  - the portion of the image to copy.
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   04/14/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::DrawImage(
        GpImage*           image,
        const GpPointF*    destPoints,
        INT                count,
        const GpRectF&     srcRect,
        GpPageUnit         srcUnit,
        const GpImageAttributes* imageAttributes,
        DrawImageAbort     callback,
        VOID*              callbackData
        )
{
    GpStatus status = Ok;

    // count of 4 is not implemented yet (perspective blt)

    if(count == 4)
    {
        return NotImplemented;
    }

    if(count != 3)
    {
        return InvalidParameter;
    }

    ASSERT(count == 3); // Currently only supports Affine transform.
    ASSERT((image != NULL));

    // Objects returned from the API must always be in a valid state:

    ASSERT(this->IsValid() && image->IsValid());

    // UnitDisplay is device-dependent and cannot be used for a source unit
    ASSERT(srcUnit != UnitDisplay);

    GpRectF offsetSrcRect = srcRect ;

    // NOTE: We could do this for all image types, including Bitmaps!!!
    //       It would save code to do this always.
    if (image->GetImageType() != ImageTypeBitmap)
    {
        // Metafiles don't handle the destPoints API directly, so we
        // have to convert to using the destRect API instead.  To do so,
        // we assume a canonical destRect and set up the transform to
        // map from that destRect to the destPoints.

        if (count == 3)
        {
            GpMatrix    matrix;
            GpRectF     destRect(0.0f, 0.0f, 1000.0f, 1000.0f);

            if (matrix.InferAffineMatrix(destPoints, destRect) == Ok)
            {
                INT         gstate;

                if ((gstate = this->Save()) != 0)
                {
                    if ((status = this->MultiplyWorldTransform(
                                                matrix, MatrixOrderPrepend)) == Ok)
                    {
                        status = this->DrawImage(image,
                                                 destRect,
                                                 srcRect,
                                                 srcUnit,
                                                 imageAttributes,
                                                 callback,
                                                 callbackData);
                    }
                    this->Restore(gstate);
                    return status;
                }
            }
            return GenericError;
        }
        return NotImplemented;
    }
    // else it is a Bitmap

    REAL xmin, xmax, ymin, ymax;

    ASSERT(count == 3); // Currently only supports Affine transform.

    // Set to the fourth corner point.

    xmin = xmax = destPoints[1].X + destPoints[2].X - destPoints[0].X;
    ymin = ymax = destPoints[1].Y + destPoints[2].Y - destPoints[0].Y;

    // Compare with the other three corners.

    for(INT i = 0; i < 3; i++)
    {
        xmin = min(xmin, destPoints[i].X);
        xmax = max(xmax, destPoints[i].X);
        ymin = min(ymin, destPoints[i].Y);
        ymax = max(ymax, destPoints[i].Y);
    }

    GpRectF     bounds;
    TransformBounds(&(Context->WorldToDevice), xmin, ymin, xmax, ymax, &bounds);

    INT numPoints = 3;

    GpImageType     imageType = image->GetImageType();

    DriverDrawImageFlags flags = 0;

    GpRecolor *     recolor = NULL;

    if (imageAttributes != NULL)
    {
        if (imageAttributes->cachedBackground)
            flags |= DriverDrawImageCachedBackground;

        if (imageType == ImageTypeBitmap)
        {
            if (imageAttributes->HasRecoloring(ColorAdjustTypeBitmap))
            {
                goto HasRecoloring;
            }
        }
        else if (imageAttributes->HasRecoloring())
        {
HasRecoloring:
            recolor = imageAttributes->recolor;
            recolor->Flush();
        }
    }

    GpImage *           adjustedImage = NULL;
    GpImageAttributes   noRecoloring;

    if (IsRecording())
    {
        if (recolor != NULL)
        {
            // We assume that the image is a bitmap.
            // For Bitmaps, we want to recolor into an image that will have an
            // alpha. CloneColorAdjusted keeps the same pixel format as the
            // original image and therefore might not have an alpha channel.
            // recolor will convert to ARGB. When recording to a metafile this
            // will only create an ARGB image if the original image is not
            // palettized, therefore only for 16bit and higher. The most
            // space we can waste is twice the image.
            if(image->GetImageType() == ImageTypeBitmap)
            {
                GpBitmap * bitmap         = reinterpret_cast<GpBitmap*>(image);
                GpBitmap * adjustedBitmap = NULL;
                if (bitmap != NULL)
                {
                    status = bitmap->Recolor(recolor, &adjustedBitmap, NULL, NULL);
                    if (status == Ok)
                    {
                        adjustedImage = adjustedBitmap;
                    }
                }
            }
            else
            {
                adjustedImage = image->CloneColorAdjusted(recolor);
            }
            if (adjustedImage != NULL)
            {
                image = adjustedImage;

                // have to set the recolor to NULL in the image attributes
                // or else the down-level image will be double recolored.
                GpRecolor *     saveRecolor = noRecoloring.recolor;
                noRecoloring = *imageAttributes;
                noRecoloring.recolor = saveRecolor;
                imageAttributes = &noRecoloring;
            }
        }

        //  Record recolored image.
        status = Metafile->RecordDrawImage(
            &bounds,
            image,
            destPoints,
            count,
            srcRect,
            srcUnit,
            imageAttributes
        );

        if (status != Ok)
        {
            SetValid(FALSE);      // Prevent any more recording
            goto Done;
        }
        if (!DownLevel)
        {
            goto Done;
        }
        // else we need to record down-level GDI EMF records as well
    }

    // GillesK: If we are in HalfPixelMode, then offset the source and the
    // destination rects by -0.5 pixels
    if ((image->GetImageType() != ImageTypeMetafile) &&
        (!Context->IsPrinter) &&
        ((Context->PixelOffset == PixelOffsetModeHalf) ||
         (Context->PixelOffset == PixelOffsetModeHighQuality)))
    {
        offsetSrcRect.Offset(-0.5f, -0.5f);
    }

    {
        GpRect      deviceBounds;
        status = BoundsFToRect(&bounds, &deviceBounds);

        if (status == Ok && !IsTotallyClipped(&deviceBounds))
        {
            // Now that we've done a bunch of work in accumulating the bounds,
            // acquire the device lock before calling the driver:

            Devlock devlock(Device);

            ASSERT(srcUnit == UnitPixel); // !!! for now

            // Set the fpu state.
            FPUStateSaver fpuState;

            // We assume that the image is a bitmap.
            ASSERT(image->GetImageType() == ImageTypeBitmap);

            status = DrvDrawImage(
                &deviceBounds,
                static_cast<GpBitmap*>(image),
                numPoints,
                &destPoints[0], &offsetSrcRect,
                imageAttributes,
                callback, callbackData,
                flags
            );
        }
    }

Done:
    if (adjustedImage != NULL)
    {
        adjustedImage->Dispose();
    }

    return status;
}

GpStatus
GpGraphics::EnumerateMetafile(
    const GpMetafile *      metafile,
    const PointF &          destPoint,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    const GpImageAttributes *     imageAttributes
    )
{
    GpStatus    status;

    ASSERT(metafile != NULL);
    ASSERT(callback != NULL);

    // Objects from the API must always be in a valid state:

    ASSERT(this->IsValid() && metafile->IsValid());

    GpPageUnit  srcUnit;
    GpRectF     srcRect;

    status = metafile->GetBounds(&srcRect, &srcUnit);
    if(status != Ok) { return status; }

    // UnitDisplay is device-dependent and cannot be used for a source unit
    ASSERT(srcUnit != UnitDisplay);

    if (status == Ok)
    {
        return this->EnumerateMetafile(
                    metafile,
                    destPoint,
                    srcRect,
                    srcUnit,
                    callback,
                    callbackData,
                    imageAttributes
                    );
    }
    return status;
}

GpStatus
GpGraphics::EnumerateMetafile(
    const GpMetafile *      metafile,
    const RectF &           destRect,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    const GpImageAttributes *     imageAttributes
    )
{
    GpStatus    status;

    ASSERT(metafile != NULL);
    ASSERT(callback != NULL);

    // Objects from the API must always be in a valid state:

    ASSERT(this->IsValid() && metafile->IsValid());

    GpPageUnit  srcUnit;
    GpRectF     srcRect;

    status = metafile->GetBounds(&srcRect, &srcUnit);
    if(status != Ok) { return status; }

    // UnitDisplay is device-dependent and cannot be used for a source unit
    ASSERT(srcUnit != UnitDisplay);

    if (status == Ok)
    {
        return this->EnumerateMetafile(
                    metafile,
                    destRect,
                    srcRect,
                    srcUnit,
                    callback,
                    callbackData,
                    imageAttributes
                    );
    }
    return status;
}

GpStatus
GpGraphics::EnumerateMetafile(
    const GpMetafile *      metafile,
    const PointF *          destPoints,
    INT                     count,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    const GpImageAttributes *     imageAttributes
    )
{
    GpStatus    status;

    ASSERT(metafile != NULL);
    ASSERT(callback != NULL);

    // Objects from the API must always be in a valid state:

    ASSERT(this->IsValid() && metafile->IsValid());

    GpPageUnit  srcUnit;
    GpRectF     srcRect;

    status = metafile->GetBounds(&srcRect, &srcUnit);
    if(status != Ok) { return status; }

    // UnitDisplay is device-dependent and cannot be used for a source unit
    ASSERT(srcUnit != UnitDisplay);

    if (status == Ok)
    {
        return this->EnumerateMetafile(
                    metafile,
                    destPoints,
                    count,
                    srcRect,
                    srcUnit,
                    callback,
                    callbackData,
                    imageAttributes
                    );
    }
    return status;
}

GpStatus
GpGraphics::EnumerateMetafile(
    const GpMetafile *      metafile,
    const PointF &          destPoint,
    const RectF &           srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    const GpImageAttributes *     imageAttributes
    )
{
    ASSERT(metafile != NULL);
    ASSERT(callback != NULL);

    // Objects from the API must always be in a valid state:

    ASSERT(this->IsValid() && metafile->IsValid());

    // UnitDisplay is device-dependent and cannot be used for a source unit
    ASSERT(srcUnit != UnitDisplay);

    REAL        srcDpiX, srcDpiY;
    REAL        destWidth;
    REAL        destHeight;

    // Get the dest size in page units
    GetImageDestPageSize(metafile, srcRect.Width, srcRect.Height,
                         srcUnit, destWidth, destHeight);

    GpRectF destRect(destPoint.X, destPoint.Y, destWidth, destHeight);

    return this->EnumerateMetafile(
                metafile,
                destRect,
                srcRect,
                srcUnit,
                callback,
                callbackData,
                imageAttributes
                );
}

// All the EnumerateMetafile methods end up calling this one
GpStatus
GpGraphics::EnumerateMetafile(
    const GpMetafile *      metafile,
    const RectF &           destRect,
    const RectF &           srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    const GpImageAttributes *     imageAttributes
    )
{
    ASSERT(metafile != NULL);
    ASSERT(callback != NULL);

    // Objects from the API must always be in a valid state:

    ASSERT(this->IsValid() && metafile->IsValid());

    // UnitDisplay is device-dependent and cannot be used for a source unit
    ASSERT(srcUnit != UnitDisplay);

    GpStatus    status;

    GpRecolor *     recolor = NULL;

    if ((imageAttributes != NULL) && imageAttributes->HasRecoloring())
    {
        recolor = imageAttributes->recolor;
        recolor->Flush();
    }

    // NOTE: I don't check the bounds, because even if the entire
    // metafile is out of the clip bounds, I still want to enumerate it.

    status = metafile->EnumerateForPlayback(
                            destRect,
                            srcRect,
                            srcUnit,
                            this,
                            callback,
                            callbackData,
                            recolor
                            );
    return status;
}

GpStatus
GpGraphics::EnumerateMetafile(
    const GpMetafile *      metafile,
    const PointF *          destPoints,
    INT                     count,
    const RectF &           srcRect,
    Unit                    srcUnit,
    EnumerateMetafileProc   callback,
    VOID *                  callbackData,
    const GpImageAttributes *     imageAttributes
    )
{
    ASSERT(metafile != NULL);
    ASSERT(callback != NULL);

    // Objects from the API must always be in a valid state:

    ASSERT(this->IsValid() && metafile->IsValid());

    // UnitDisplay is device-dependent and cannot be used for a source unit
    ASSERT(srcUnit != UnitDisplay);

    GpStatus    status = Ok;

    // Metafiles don't handle the destPoints API directly, so we
    // have to convert to using the destRect API instead.  To do so,
    // we assume a canonical destRect and set up the transform to
    // map from that destRect to the destPoints.

    ASSERT(count == 3); // Currently only supports Affine transform.

    if (count == 3)
    {
        GpMatrix    matrix;
        GpRectF     destRect(0.0f, 0.0f, 100.0f, 100.0f);

        if (matrix.InferAffineMatrix(destPoints, destRect) == Ok)
        {
            INT         gstate;

            if ((gstate = this->Save()) != 0)
            {
                if ((status = this->MultiplyWorldTransform(
                                            matrix, MatrixOrderPrepend)) == Ok)
                {
                    status = this->EnumerateMetafile(
                                metafile,
                                destRect,
                                srcRect,
                                srcUnit,
                                callback,
                                callbackData,
                                imageAttributes
                                );
                }
                this->Restore(gstate);
                return status;
            }
        }
        return GenericError;
    }
    return NotImplemented;
}

/**************************************************************************\
*
* Function Description:
*
*   API to get color ARGB value at pixel x,y.  This is private GDI+ API.
*
*   [IN] x - horizontal position
*   [IN] y - vertical position
*   [IN] argb - argb color value
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   05/13/1999 ericvan
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::GetPixelColor(
        REAL            x,
        REAL            y,
        ARGB*           argb
        ) const
{
    GpPointF pt(x,y);

    if (!IsVisible(pt))
        return InvalidParameter;

    Devlock devlock(Device);

    DpScanBuffer scan(Surface->Scan,
                      Driver,
                      Context,
                      Surface,
                      CompositingModeSourceCopy);

    Context->WorldToDevice.Transform(&pt, 1);

    ARGB* buffer = scan.NextBuffer((INT)x, (INT)y, 1);

    if (buffer)
       *argb = *buffer;
    else
       return InvalidParameter;

    return Ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\graphics.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Abstract:
*
*   Graphics APIs.
*
* Revision History:
*
*   11/23/1999 asecchia
*       Created it.
*   05/08/2000 gillesk
*       Added code to handle rotations and shears in metafiles
*
\**************************************************************************/

#include "precomp.hpp"

const CLSID EncoderTransformationInternal =
{
    0x8d0eb2d1,
    0xa58e,
    0x4ea8,
    {0xaa, 0x14, 0x10, 0x80, 0x74, 0xb7, 0xb6, 0xf9}
};

const CLSID JpegCodecClsIDInternal =
{
    0x557cf401,
    0x1a04,
    0x11d3,
    {0x9a, 0x73, 0x00, 0x00, 0xf8, 0x1e, 0xf3, 0x2e}
};

/**************************************************************************\
*
* Function Description:
*
*   Engine function to draw image.
*   Note: this function is not a driver function despite it's name.
*   it probably makes more sense to call this EngDrawImage.
*   This function sets up the call to the driver to draw an image.
*
* Return Value:
*
*   A GpStatus value indicating success or failure.
*
* History:
*
*   11/23/1999 asecchia
*       Created it.
*
\**************************************************************************/

GpStatus
GpGraphics::DrvDrawImage(
    const GpRect *drawBounds,
    GpBitmap *inputBitmap,
    INT numPoints,
    const GpPointF *dstPointsOriginal,
    const GpRectF *srcRectOriginal,
    const GpImageAttributes *imageAttributes,
    DrawImageAbort callback,
    VOID *callbackData,
    DriverDrawImageFlags flags
    )
{
    // Validate the input state.
    
    ASSERTMSG(
        GetObjectLock()->IsLocked(),
        ("Graphics object must be locked")
    );
    
    ASSERTMSG(
        Device->DeviceLock.IsLockedByCurrentThread(),
        ("DeviceLock must be held by current thread")
    );

    FPUStateSaver::AssertMode();

    // must be called with a parallelogram destination.

    ASSERT(numPoints==3);
    
    // Make a local copy of the points.
    
    GpPointF dstPoints[3];
    memcpy(dstPoints, dstPointsOriginal, sizeof(dstPoints));
    GpRectF srcRect = *srcRectOriginal;
    

    // trivial return if the parallelogram is empty, either there are at least
    // two points overlap or they are on one line

    // We check if the slope between point2 and point1 equals to the slope
    // between point0 and point1

    if (REALABS(
        (dstPoints[2].Y - dstPoints[0].Y) * (dstPoints[0].X - dstPoints[1].X) -
        (dstPoints[2].X - dstPoints[0].X) * (dstPoints[0].Y - dstPoints[1].Y)
        ) < REAL_EPSILON)
    {
        return Ok;
    }

    // Done input parameter validation.
    
    
    // Check some useful state up front.
    
    BOOL IsMetafile = (Driver == Globals::MetaDriver);

    BOOL IsRecolor = (
       (imageAttributes != NULL) &&
       (imageAttributes->recolor != NULL) &&
       (imageAttributes->recolor->HasRecoloring(ColorAdjustTypeBitmap))
    );

    // This is the format we will use to lock the bits.
    // Default is premultiplied, but some cases require non-premultiplied.
    
    PixelFormat lockedPixelFormat = PixelFormat32bppPARGB;
    
    // Metafiles need non-premultiplied pixel data.
    // Also, Recoloring uses ARGB as it's initial format, so we want
    // to respect that if we load the image into memory before the 
    // recolor code.
    
    if(IsMetafile || IsRecolor)
    {
        lockedPixelFormat = PixelFormat32bppARGB;
    }

    Surface->Uniqueness = (DWORD)GpObject::GenerateUniqueness();

    // Set up the local tracking state.
    // Note: inputBitmap can change during the processing in this routine -
    // specifically when recoloring is done, it may be pointing to a clone
    // of the input bitmap with recoloring applied. Because of this, the
    // inputBitmap should never be directly referenced from here onward.

    GpStatus status = Ok;
    GpBitmap *srcBitmap = inputBitmap;
    GpBitmap *xformBitmap = NULL;
    BOOL     restoreClipping = FALSE;
    GpRegion *clipRegion     = NULL;

    // Compute the transform between the source rectangle and the destination
    // points transformed to device coordinates. This is used to detect and
    // intercept processing for some high level optimizations and workarounds.
    
    GpMatrix xForm;
    xForm.InferAffineMatrix(dstPoints, srcRect);

    // Special optimization for JPEG passthrough of rotated bitmaps.
    // Why does this not take the world to device matrix into account?
    // If the world to device is a non-trivial rotation, then this is invalid.
    
    if (IsPrinter())
    {
        MatrixRotate rotateBy;

        DriverPrint *dprint = (DriverPrint*)Driver;
        
        // Check if the source rectangle to destination point map is
        // simply a 90, 180, or 270 rotation, and the driver supports JPEG
        // passthrough, It's a JPEG image, no recoloring, not dirty.

        if (!Globals::IsWin95 && 
            dprint->SupportJPEGpassthrough && 
            Context->WorldToDevice.IsTranslateScale() &&
            ((rotateBy = xForm.GetRotation()) != MatrixRotateByOther) &&
            (rotateBy != MatrixRotateBy0) && 
            (!srcBitmap->IsDirty()) &&
            ((imageAttributes == NULL) ||
             (imageAttributes->recolor == NULL) ||
             (!imageAttributes->recolor->HasRecoloring(ColorAdjustTypeBitmap))))
        {
            ImageInfo imageInfo;
            status = srcBitmap->GetImageInfo(&imageInfo);
            
            if((status == Ok) && 
               (imageInfo.RawDataFormat == IMGFMT_JPEG))
            {
                // Allocate a stream to store the rotated JPEG.
                                
                IStream * outputStream = NULL;
                BOOL succeededWithRotate = FALSE;

                if ((CreateStreamOnHGlobal(NULL,
                                           FALSE,
                                           &outputStream) == S_OK) &&
                    outputStream != NULL)
                {
                    EncoderParameters encoderParams;
                    EncoderValue encoderValue;

                    encoderParams.Count = 1;

                    // Re-orient the destination parallelogram (rectangle) since
                    // we now are assuming a 0 degree rotation.

                    GpPointF newDestPoints[3] = 
                    { 
                      GpPointF(min(min(dstPoints[0].X, dstPoints[1].X), dstPoints[2].X),
                               min(min(dstPoints[0].Y, dstPoints[1].Y), dstPoints[2].Y)),
                      GpPointF(max(max(dstPoints[0].X, dstPoints[1].X), dstPoints[2].X),
                               min(min(dstPoints[0].Y, dstPoints[1].Y), dstPoints[2].Y)),
                      GpPointF(min(min(dstPoints[0].X, dstPoints[1].X), dstPoints[2].X),
                               max(max(dstPoints[0].Y, dstPoints[1].Y), dstPoints[2].Y)) 
                    };

                    // Since the image is potentially flipped, the srcRect needs
                    // to be flipped also. 
                    
                    GpRectF newSrcRect = srcRect;
                    GpMatrix transformSrc;
                    
                    // Construct the appropriate encoder parameters type.
                    switch (rotateBy) 
                    {
                    case MatrixRotateBy90:
                        transformSrc.SetMatrix(0.0f, 
                                               1.0f, 
                                               -1.0f, 
                                               0.0f, 
                                               TOREAL(imageInfo.Height), 
                                               0.0f);
                        encoderValue = EncoderValueTransformRotate90;
                        break;

                    case MatrixRotateBy180:
                        transformSrc.SetMatrix(-1.0f, 
                                               0.0f, 
                                               0.0f, 
                                               -1.0f, 
                                               TOREAL(imageInfo.Width),
                                               TOREAL(imageInfo.Height));
                        encoderValue = EncoderValueTransformRotate180;
                        break;
                    
                    case MatrixRotateBy270:
                        transformSrc.SetMatrix(0.0f, 
                                               -1.0f, 
                                               1.0f, 
                                               0.0f, 
                                               0.0f,
                                               TOREAL(imageInfo.Width));
                        encoderValue = EncoderValueTransformRotate270;
                        break;
                    
                    default:
                        encoderParams.Count = 0;
                        ASSERT(FALSE);
                        break;
                    }
                
                    // Transform the source rectangle from source image space
                    // to rotated image space.  Normalize the destination source
                    // rectangle.
                    
                    // Note that the source rectangle may not originally be
                    // normalized, but any rotational effects it emparts on the
                    // draw image is represented by the xForm and thus our
                    // newDestPoints. 
                    
                    // NTRAID#NTBUG9-407211-2001-05-31-gillessk "Bad assert triggers when it shouldn't" 
                    // assert was transformSrc.IsTranslateScale, which fires when rotation is involved
                     
                    ASSERT(transformSrc.IsTranslateScale() || (transformSrc.GetRotation()==MatrixRotateBy90) 
                        || (transformSrc.GetRotation()==MatrixRotateBy270));
                    transformSrc.TransformRect(newSrcRect);

                    encoderParams.Parameter[0].Guid = EncoderTransformationInternal;
                    encoderParams.Parameter[0].Type = EncoderParameterValueTypeLong;
                    encoderParams.Parameter[0].NumberOfValues = 1;
                    encoderParams.Parameter[0].Value = (VOID*)&encoderValue;

                    // Specify built in JPEG enocder for simplicity.  We should
                    // really copy the CLSID encoder from the srcBitmap.
                    
                    if (encoderParams.Count != 0 &&
                        srcBitmap->SaveToStream(outputStream, 
                                                const_cast<CLSID*>(&JpegCodecClsIDInternal),
                                                &encoderParams) == Ok)
                    {
                        // The stream contains the rotated JPEG.  Wrap a bitmap
                        // around this and recursively call on ourself.  This sucks,
                        // but the destructor to rotatedJPEG is private so we can't
                        // define it as a stack variable.  
                        
                        GpBitmap *rotatedJPEG = new GpBitmap(outputStream);

                        if (rotatedJPEG != NULL)
                        {
                            if (rotatedJPEG->IsValid()) 
                            {
                                // Transform the source rectangle by the scale & translate
                                // of the original xForm, but not the rotation!  This could
                                // equivalently be determined by querying M11,M22, Dx, Dy.

                                status = DrvDrawImage(drawBounds,
                                                      rotatedJPEG,
                                                      numPoints,
                                                      &newDestPoints[0],
                                                      &newSrcRect,
                                                      imageAttributes,
                                                      callback,
                                                      callbackData,
                                                      flags);

                                succeededWithRotate = TRUE;
                            }

                            rotatedJPEG->Dispose();
                        }
                    }

                    outputStream->Release();

                    if (succeededWithRotate) 
                    {
                        return status;
                    }
                    else
                    {
                        return OutOfMemory;
                    }
                }
            }
        }
    }

    // Create complete source image to device space transform.
    
    xForm.Append(Context->WorldToDevice);
    
    GpBitmap *cloneBitmap = NULL;
    
    // GpMatrix has a default constructor which sets it to ID so we may 
    // as well copy it always.
    
    GpMatrix saveWorldToDevice = Context->WorldToDevice;

    // Check for special case rotate or flip.
    // Integer translate is handled natively by the driver.
    
    if(!xForm.IsIntegerTranslate()) 
    {
        RotateFlipType specialRotate = xForm.AnalyzeRotateFlip();
        if(specialRotate != RotateNoneFlipNone)
        {
            ImageInfo imageInfo;
            status = srcBitmap->GetImageInfo(&imageInfo);
            if(status != Ok)
            {
                goto cleanup;
            }
            
            // Clone the bitmap in the same format we'll be using later.
            // This will save a format conversion.
            // !!! PERF [asecchia]
            // This clones the entire image. When we do the RotateFlip call
            // it'll decode the entire image - which is potentially a
            // waste - we should clone only the relevant rectangle.
            // Note: this would have to be accounted for in the transform and
            // Clone would need to be fixed to account for outcropping.
            
            cloneBitmap = srcBitmap->Clone(NULL, lockedPixelFormat);
            
            if(cloneBitmap == NULL)
            {
                status = OutOfMemory;
                goto cleanup;
            }
            
            srcBitmap = cloneBitmap;
            
            // perform lossless pixel rotation in place.
            
            srcBitmap->RotateFlip(specialRotate);

            // Undo the pixel offset mode. We know we're not scaling so 
            // this is correct.
            // Why do we have two different enums meaning exactly 
            // the same thing?
            
            if((Context->PixelOffset == PixelOffsetModeHalf) ||
               (Context->PixelOffset == PixelOffsetModeHighQuality))
            {
                // Undo the pixel offset in the source rectangle.
                
                srcRect.Offset(0.5f, 0.5f);
                
                // Undo the pixel offset in the matrix. We apply the pre-offset
                // from the source rect and the post offset from the W2D matrix
                // For identity this would be a NOP because the matrixes for 
                // pixel offset and non-pixel offset are identical, but they 
                // apply in two different spaces for rotation.
                
                xForm.Translate(0.5f, 0.5f, MatrixOrderAppend);
                xForm.Translate(-0.5f, -0.5f, MatrixOrderPrepend);
            }

            
            // Remove the world to device rotation.
            
            xForm.SetMatrix(
                1.0f, 0.0f,
                0.0f, 1.0f,
                xForm.GetDx(),
                xForm.GetDy()
            );
            
            // Because RotateFlip applies in place, the resulting bitmap is 
            // always still at the origin. This is actually a non-trivial 
            // rotation in most cases - i.e. there is an implied translate 
            // from where the real simple rotate matrix puts the image and
            // where it is now. Fix up the translate in the xForm to take
            // this into account.
            
            REAL temp;
            
            switch(specialRotate)
            {
                case RotateNoneFlipX:
                    temp = (2.0f*srcRect.X+srcRect.Width);
                    xForm.Translate(-(REAL)imageInfo.Width, 0.0f);
                    srcRect.Offset(imageInfo.Width-temp, 0.0f);
                break;
                
                case RotateNoneFlipY:
                    temp = (2.0f*srcRect.Y+srcRect.Height);
                    xForm.Translate(0.0f, -(REAL)imageInfo.Height);
                    srcRect.Offset(0.0f, imageInfo.Height-temp);
                break;
                
                case Rotate90FlipNone:
                    SWAP(temp, srcRect.X, srcRect.Y);
                    SWAP(temp, srcRect.Width, srcRect.Height);
                    temp = (2.0f*srcRect.X+srcRect.Width);
                    xForm.Translate(-(REAL)imageInfo.Height, 0.0f);
                    srcRect.Offset(imageInfo.Height-temp, 0.0f);
                break;
                
                case Rotate90FlipX:
                    SWAP(temp, srcRect.X, srcRect.Y);
                    SWAP(temp, srcRect.Width, srcRect.Height);
                break;
                
                case Rotate180FlipNone:
                    xForm.Translate(
                        -(REAL)imageInfo.Width, 
                        -(REAL)imageInfo.Height
                    );
                    srcRect.Offset(
                        imageInfo.Width -(2.0f*srcRect.X+srcRect.Width),
                        imageInfo.Height-(2.0f*srcRect.Y+srcRect.Height)
                    );
                break;
                
                case Rotate270FlipX:
                    SWAP(temp, srcRect.X, srcRect.Y);
                    SWAP(temp, srcRect.Width, srcRect.Height);
                    xForm.Translate(
                        -(REAL)imageInfo.Height, 
                        -(REAL)imageInfo.Width
                    );
                    srcRect.Offset(
                        imageInfo.Height-(2.0f*srcRect.X+srcRect.Width),
                        imageInfo.Width -(2.0f*srcRect.Y+srcRect.Height)
                    );
                break;
                
                case Rotate270FlipNone:
                    SWAP(temp, srcRect.X, srcRect.Y);
                    SWAP(temp, srcRect.Width, srcRect.Height);
                    temp = (2.0f*srcRect.Y+srcRect.Height);
                    xForm.Translate(0.0f, -(REAL)imageInfo.Width);
                    srcRect.Offset(0.0f, imageInfo.Width-temp);
                break;
            };
            
            // Set the world to device transform in the context. This causes
            // the driver to use our updated transform. We fix this up at the 
            // end of this routine. (see goto cleanup)
            
            Context->WorldToDevice = xForm;
            
            // Normalize the destination because we've incorporated the 
            // entire affine transform into the world to device matrix.
            
            dstPoints[0].X = srcRect.X;
            dstPoints[0].Y = srcRect.Y;
            dstPoints[1].X = srcRect.X+srcRect.Width;
            dstPoints[1].Y = srcRect.Y;
            dstPoints[2].X = srcRect.X;
            dstPoints[2].Y = srcRect.Y+srcRect.Height;
        }
    }
    
    // HighQuality filters doing rotation/shear?
    // This is a workable temporary solution to high quality bicubic
    // rotation. Note that when the underlying bicubic filtering code
    // is updated to support rotation, this block should be removed.

    if( (!xForm.IsTranslateScale()) && (!IsMetafile) && // don't scale down-level metafile record
        ((Context->FilterType==InterpolationModeHighQualityBicubic) ||
         (Context->FilterType==InterpolationModeHighQualityBilinear))
         )
    {
        // Before allocating the srcBitmap, see if we can save some memory
        // by only allocating the part of the srcBitmap that gets transfromed
        // in the case that we are outcropping.
        // This is only valid if we are in ClampMode and printing

        // We should do this all the time, but we would have to calculate the
        // area of influence of the kernel.
        // Printing doesn't support PixelOffsetting yet, so don't move the
        // srcRect
        
        if (IsPrinter() &&
            ((!imageAttributes) ||
             (imageAttributes->DeviceImageAttributes.wrapMode == WrapModeClamp)))
        {
            RectF clampedSrcRect;
            Unit  srcUnit;
            srcBitmap->GetBounds(&clampedSrcRect, &srcUnit);

            ASSERT(srcUnit == UnitPixel);

            // Find the area of the srcrect that is included in the image
            clampedSrcRect.Intersect(srcRect);

            // If there's no intersection then don't do anything
            if (clampedSrcRect.IsEmptyArea())
            {
                goto cleanup;
            }

            // Don't do anything else if the srcRect is not outcropping
            if (!clampedSrcRect.Equals(srcRect))
            {
                GpMatrix srcDstXForm;
                if (srcDstXForm.InferAffineMatrix(dstPoints, srcRect) == Ok)
                {
                    // Modify the srcRect and the dstPoints to match the new
                    // section of the bitmap
                    dstPoints[0] = PointF(clampedSrcRect.X, clampedSrcRect.Y);
                    dstPoints[1].X = clampedSrcRect.GetRight();
                    dstPoints[1].Y = clampedSrcRect.Y;
                    dstPoints[2].X = clampedSrcRect.X;
                    dstPoints[2].Y = clampedSrcRect.GetBottom();
                    srcDstXForm.Transform(dstPoints, 3);

                    srcRect = clampedSrcRect;
                }
            }
        }

        // Must make the determination of intermediate size based on the actual
        // device coordinates of the final destination points.
        
        GpPointF points[3];
        memcpy(points, dstPoints, sizeof(points));
        Context->WorldToDevice.Transform(points, 3);
        
        // Compute the width and height of the scale factor so that we
        // can decompose into a scale and then rotation.

        INT iwidth = GpCeiling( REALSQRT(
            (points[1].X-points[0].X)*(points[1].X-points[0].X)+
            (points[1].Y-points[0].Y)*(points[1].Y-points[0].Y)
        ));

        INT iheight = GpCeiling( REALSQRT(
            (points[2].X-points[0].X)*(points[2].X-points[0].X)+
            (points[2].Y-points[0].Y)*(points[2].Y-points[0].Y)
        ));

        ASSERT(iwidth>0);
        ASSERT(iheight>0);

        // Only do the scale if we really need to.
        // Note: This if statement prevents infinite recursion in DrvDrawImage

        if( (REALABS(iwidth-srcRect.Width) > REAL_EPSILON) &&
            (REALABS(iheight-srcRect.Height) > REAL_EPSILON) )
        {
            // Create a temporary bitmap to scale the image into.

            GpBitmap *scaleBitmap = NULL;

            // Crack the recoloring to figure out the optimal temporary bitmap
            // format.
            // Metafiles also need non-premultiplied (see the final LockBits
            // in this routine before calling the driver)

            PixelFormatID scaleFormat = PixelFormat32bppPARGB;

            if((IsMetafile) ||
               ( (imageAttributes) &&
                 (imageAttributes->recolor) &&
                 (imageAttributes->recolor->HasRecoloring(ColorAdjustTypeBitmap))
              ))
            {
                // Recoloring is enabled - optimal format is non-premultiplied.
                // In fact it's incorrect (lossy) to go to premultiplied before
                // recoloring is applied.

                scaleFormat = PixelFormat32bppARGB;
            }

            scaleBitmap = new GpBitmap(
                iwidth,
                iheight,
                scaleFormat
            );

            GpGraphics *scaleG = NULL;

            if(scaleBitmap && scaleBitmap->IsValid())
            {
                // The high quality filtering should be to an equivalent
                // dpi surface, bounded by the ultimate surface destination dpi.

                REAL dpiX, dpiY;

                srcBitmap->GetResolution(&dpiX, &dpiY);

                scaleBitmap->SetResolution(min(dpiX, Context->ContainerDpiX), 
                                           min(dpiY, Context->ContainerDpiY));
                
                scaleG = scaleBitmap->GetGraphicsContext();
            }

            if(scaleG && scaleG->IsValid())
            {
                GpLock lock(scaleG->GetObjectLock());
                scaleG->SetInterpolationMode(Context->FilterType);
                scaleG->SetCompositingMode(CompositingModeSourceCopy);

                GpRectF scaleDst(
                    0,
                    0,
                    (REAL)iwidth,
                    (REAL)iheight
                );

                // To avoid bleeding transparent black into our image when 
                // printing we temporarily set the WrapMode to TileFlipXY on 
                // our preliminary drawimage (the scaling part) and clip to the 
                // bounds later on when we do the rotate/skew.
                GpImageAttributes *tempImageAttributes = const_cast<GpImageAttributes*>(imageAttributes);
                if (IsPrinter())
                {
                    if (imageAttributes == NULL)
                    {
                        tempImageAttributes = new GpImageAttributes();
                        if(tempImageAttributes)
                        {
                            tempImageAttributes->SetWrapMode(WrapModeTileFlipXY);
                        }
                    }
                    else if (imageAttributes->DeviceImageAttributes.wrapMode == WrapModeClamp)
                    {
                        tempImageAttributes = imageAttributes->Clone();
                        if(tempImageAttributes)
                        {
                            tempImageAttributes->SetWrapMode(WrapModeTileFlipXY);
                        }
                    }
                }
                
                // Do the scale.

                status = scaleG->DrawImage(
                    srcBitmap,
                    scaleDst,
                    srcRect,
                    UnitPixel,
                    tempImageAttributes,
                    callback,
                    callbackData
                );

                // If we allocated a new copy of the imageAttributes then delete it.
                if (tempImageAttributes != imageAttributes)
                {
                    delete tempImageAttributes;
                }

                // Now we're at the right size, lets actually do some rotation.
                // Note we don't bother resetting the filtering mode because the
                // underlying driver code for HighQuality filters defaults to
                // the correct resampling code.
                // Also we shouldn't get recursion because of the width and height
                // check protecting this codeblock.

                if(status==Ok)
                {
                    status = this->DrawImage(
                        scaleBitmap,
                        dstPoints,
                        3,
                        scaleDst,
                        UnitPixel,
                        NULL,
                        callback,
                        callbackData
                    );
                }
            }
            else
            {
                status = OutOfMemory;
            }

            delete scaleG;
            
            if (scaleBitmap)
            {
                scaleBitmap->Dispose();
            }

            goto cleanup;                 // completed or error.
        }
    }

    // Prep the bitmap for drawing:
    // if rendering to a meta surface (multimon) assume 32bpp for
    // the icon codec.

    status = srcBitmap->PreDraw(
        numPoints,
        dstPoints,
        &srcRect,
        GetPixelFormatSize(
            (Surface->PixelFormat == PixelFormatMulti) ? 
             PixelFormat32bppRGB : Surface->PixelFormat
        )
    );

    if (status != Ok)
    {
        goto cleanup;
    }

    // Get the cached ImageInfo from the source bitmap. Any time the image
    // is changed or forced to be re-decoded, this will be invalidated and
    // will require an explicit re-initialization.

    ImageInfo srcBitmapImageInfo;
    status = srcBitmap->GetImageInfo(&srcBitmapImageInfo);
    if(status != Ok)
    {
        goto cleanup;
    }

    // Do the recoloring.
    // Note that Recoloring will clone the image if it needs to change the bits.
    // This means that srcBitmap will not be pointing to inputBitmap after
    // a successful call to the recoloring code.

    if((status == Ok) && (IsRecolor))
    {
        // cloneBitmap is set to NULL. Recolor into a cloned bitmap
        // cloneBitmap != NULL - we previously cloned, so it's ok to 
        // recolor in place.
        
        status = srcBitmap->Recolor(
            imageAttributes->recolor,
            (cloneBitmap == NULL) ? &cloneBitmap : NULL,
            callback,
            callbackData
        );

        // Recoloring worked - set the srcBitmap to the clone that's been
        // recolored so that the rest of the pipe works on the recolored bitmap.

        if(status == Ok)
        {
            srcBitmap = cloneBitmap;
            status = srcBitmap->GetImageInfo(&srcBitmapImageInfo);
            
            // If it's not a metafile, we need to convert to PARGB for the 
            // filtering.
            
            if(!IsMetafile)
            {
                lockedPixelFormat = PixelFormat32bppPARGB;
            }
        }
    }

    // Check the callbacks.

    if ((status == Ok) &&
        (callback) &&
        ((*callback)(callbackData)))
    {
        status = Aborted;
    }


    if(status == Ok)
    {
        // The code below explicitly assumes numPoints == 3. Yes I know we've
        // already asserted this above, but you can't be too careful.
        
        ASSERT(numPoints==3);

        // If we don't write a rotation into a metafile, copy the
        // points to the buffers that are used by the driver
        // These will only be changed if everything succeeded
        
        GpPointF fDst[3];
        GpRectF  bboxSrcRect;
        GpMatrix worldDevice = Context->WorldToDevice;

        GpMemcpy(fDst, dstPoints, sizeof(GpPointF)*numPoints);
        bboxSrcRect = srcRect;

        // Before calling the driver if we have a rotated bitmap then try to 
        // rotate it now and draw it transparent
        
        INT complexity = xForm.GetComplexity() ;
        if (!xForm.IsTranslateScale() && IsMetafile)
        {
            // We have a shear/rotate transformation.
            // Create a transparent bitmap and render into it

            // first, get new dest points
            GpPointF newDestPoints[3];

            GpRectF bboxWorkRectF;
            TransformBounds(&xForm,
                srcRect.X,
                srcRect.Y,
                srcRect.X+srcRect.Width,
                srcRect.Y+srcRect.Height,
                &bboxWorkRectF
            );

            newDestPoints[0].X = bboxWorkRectF.X;
            newDestPoints[0].Y = bboxWorkRectF.Y;
            newDestPoints[1].X = bboxWorkRectF.X + bboxWorkRectF.Width;
            newDestPoints[1].Y = bboxWorkRectF.Y;
            newDestPoints[2].X = bboxWorkRectF.X;
            newDestPoints[2].Y = bboxWorkRectF.Y + bboxWorkRectF.Height;

            // To keep the metafile size small, take out most of the
            // scaling up from the transform.  We could do this by
            // a sophisticated algorithm to calculate the amount of
            // scaling in the matrix, but instead just assume anything
            // greater than 1 is a scale, which means we could actually
            // scale up by as much as 1.4 (for a 45-degree angle), but
            // that's close enough.
            
            GpMatrix    unscaledXform = xForm;
            
            REAL    xScale = 1.0f;
            REAL    yScale = 1.0f;
            REAL    col1;
            REAL    col2;
            REAL    max;
            
            // This should really use REALABS and max()
            
            col1 = xForm.GetM11();
            if (col1 < 0.0f)
            {
                col1 = -col1;                       // get absolute value
            }
            
            col2 = xForm.GetM12();
            if (col2 < 0.0f)
            {
                col2 = -col2;                       // get absolute value
            }
            
            max = (col1 >= col2) ? col1 : col2;     // max scale value
            if (max > 1.0f)
            {
                xScale = 1.0f / max;
            }

            col1 = xForm.GetM21();
            if (col1 < 0.0f)
            {
                col1 = -col1;                       // get absolute value
            }
            
            col2 = xForm.GetM22();
            if (col2 < 0.0f)
            {
                col2 = -col2;                       // get absolute value
            }
            
            max = (col1 >= col2) ? col1 : col2;     // max scale value
            if (max > 1.0f)
            {
                yScale = 1.0f / max;
            }
            
            unscaledXform.Scale(xScale, yScale, MatrixOrderPrepend);

            // Transform the original src coordinates to obtain the 
            // dimensions of the bounding box for the rotated bitmap.

            TransformBounds(&unscaledXform,
                srcRect.X,
                srcRect.Y,
                srcRect.X+srcRect.Width,
                srcRect.Y+srcRect.Height,
                &bboxWorkRectF
            );

            // Add 1 because the rect for bitmaps is inclusive-inclusive
            INT     rotatedWidth  = GpRound(bboxWorkRectF.GetRight()  - bboxWorkRectF.X + 1.0f);
            INT     rotatedHeight = GpRound(bboxWorkRectF.GetBottom() - bboxWorkRectF.Y + 1.0f);

            // Convert the bounding box back to a 3 point system
            // This will be what's passed to the driver
            
            xformBitmap = new GpBitmap(rotatedWidth, rotatedHeight, PIXFMT_32BPP_ARGB);
            if (xformBitmap != NULL && xformBitmap->IsValid())
            {
                GpGraphics *graphics = xformBitmap->GetGraphicsContext();
                if (graphics != NULL && graphics->IsValid())
                {
                    // we have to lock the graphics so the driver doesn't assert
                    GpLock lockGraphics(graphics->GetObjectLock());

                    graphics->Clear(GpColor(0,0,0,0));

                    // Translate the world to be able to draw the whole image
                    graphics->TranslateWorldTransform(-bboxWorkRectF.X, -bboxWorkRectF.Y);

                   // Apply the transform from the Src to the Destination
                    if (graphics->MultiplyWorldTransform(unscaledXform, MatrixOrderPrepend) == Ok)
                    {
                        GpImageAttributes   imageAttributes;
                        
                        imageAttributes.SetWrapMode(WrapModeTileFlipXY);
                        graphics->SetPixelOffsetMode(Context->PixelOffset);
                        
                        // Draw the rotated xformBitmap at the origin
                        if (graphics->DrawImage(srcBitmap, srcRect, srcRect, UnitPixel, &imageAttributes) == Ok)
                        {
                            // Now that we have succeeded change the parameters
                            bboxSrcRect.X      = 0.0f;
                            bboxSrcRect.Y      = 0.0f;
                            bboxSrcRect.Width  = (REAL)rotatedWidth;
                            bboxSrcRect.Height = (REAL)rotatedHeight;
                            
                            // Set the clipping in the graphics to be able to
                            // mask out the edges
                            clipRegion = GetClip();
                            if (clipRegion != NULL)
                            {
                                // Create the outline of the picture as a path
                                GpPointF pathPoints[4];
                                BYTE     pathTypes[4] = {
                                    PathPointTypeStart,
                                    PathPointTypeLine,
                                    PathPointTypeLine,
                                    PathPointTypeLine | PathPointTypeCloseSubpath };

                                GpPointF pixelOffset(0.0f, 0.0f);

                                if (Context->PixelOffset == PixelOffsetModeHalf || Context->PixelOffset == PixelOffsetModeHighQuality)
                                {
                                    // Cannot use GetWorldPixelSize because it does an ABS
                                    GpMatrix deviceToWorld;
                                    if (GetDeviceToWorldTransform(&deviceToWorld) == Ok)
                                    {
                                        pixelOffset = GpPointF(-0.5f, -0.5f);
                                        deviceToWorld.VectorTransform(&pixelOffset);
                                    }
                                }

                                pathPoints[0] = dstPoints[0] + pixelOffset;
                                pathPoints[1] = dstPoints[1] + pixelOffset;
                                pathPoints[2].X = dstPoints[1].X - dstPoints[0].X + dstPoints[2].X + pixelOffset.X;
                                pathPoints[2].Y = dstPoints[2].Y - dstPoints[0].Y + dstPoints[1].Y + pixelOffset.Y; 
                                pathPoints[3] = dstPoints[2] + pixelOffset;

                                GpPath path(pathPoints, pathTypes, 4);
                                if (path.IsValid())
                                {
                                    if (SetClip(&path, CombineModeIntersect) == Ok)
                                    {
                                        restoreClipping = TRUE;
                                    }
                                }
                            }
                            GpMemcpy(fDst, newDestPoints, sizeof(GpPointF)*3);
                            Context->WorldToDevice.Reset();
                            srcBitmap = xformBitmap;
                            srcBitmap->GetImageInfo(&srcBitmapImageInfo);
                        }
                    }
                }
                if( graphics != NULL )
                {
                    delete graphics ;
                }
            }

        }


        // This is the size we're going to request the codec decode into.
        // Both width and height == 0 means use the source width and height.
        // If a width and height are specified, the codec may decode to
        // something close - always larger than the requested size.

        REAL width  = 0.0f;
        REAL height = 0.0f;

        // !!! PERF [asecchia] We should probably compute the size of
        // a rotational minification and work out the correct transforms
        // to take advantage of the codec minification for rotation.

        // Is an axis aligned minification happening?

        if(xForm.IsMinification())
        {
            // The code below explicitly assumes numPoints == 3. Yes I know 
            // we've already asserted this above, but you can't be too careful.

            ASSERT(numPoints == 3);

            // We're axis aligned so we can assume a simplified width and
            // height computation.

            RectF boundsRect;
            
            TransformBounds(
                &xForm,
                srcRect.X,
                srcRect.Y,
                srcRect.X+srcRect.Width,
                srcRect.Y+srcRect.Height,                
                &boundsRect
            );
            
            // Compute an upper bound on the width and height of the
            // destination.
            // we'll let the driver handle vertical an horizontal flips with
            // the scale transform.
            
            width = REALABS(boundsRect.GetRight()-boundsRect.GetLeft());
            height = REALABS(boundsRect.GetBottom()-boundsRect.GetTop());

            // In this case the Nyquist limit specifies that we can use a
            // cheap averaging decimation type algorithm for minification
            // down to double the size of the destination - after which we
            // must use the more expensive filter convolution for minification.
            
            // Note that the decimation algorithm is roughly equivalient to our 
            // regular Bilinear interpolation so we can decimate below the 
            // Nyquist limit for Bilinear.

            if(Context->FilterType != InterpolationModeBilinear)
            {
                width *= 2.0f;
                height *= 2.0f;
            }

            // The source image is smaller than the Nyquist limit in X
            // simply use the source width.

            if(width >= srcRect.Width)
            {
                width = srcRect.Width;
            }

            // The source image is smaller than the Nyquist limit in Y
            // simply use the source height.

            if(height >= srcRect.Height)
            {
                height = srcRect.Height;
            }

            // The source image is smaller than the Nyquist limit in
            // both X and Y. Set the parameters to zero to do no scaling
            // in the codec.
            // If width,height greater or equal to srcRect, set zero in the 
            // width to ask the codec to return us the image native size.

            if( (width - srcRect.Width >= -REAL_EPSILON) &&
                (height - srcRect.Height >= -REAL_EPSILON) )
            {
                width = 0.0f;
                height = 0.0f;
            }
            
            // Undo the cropping effect to figure out how much to decimate
            // the entire image before cropping takes place.
            
            width = width * srcBitmapImageInfo.Width / srcRect.Width;
            height = height * srcBitmapImageInfo.Height / srcRect.Height;
        }
        
        BitmapData bmpDataSrc;
        DpCompressedData compressedData;
        DpTransparency transparency;
        BYTE minAlpha = 0, maxAlpha = 0xFF;
        
        // Determine the transparency status of the bitmap.  If printing, then
        // must be accurate, otherwise we use cached flag.
        
        if ((status == Ok) &&
            (srcBitmap != NULL) &&
            (srcBitmap->IsValid()))
        {
            // Mark that we haven't locked the bits yet.
            BOOL bitsLoaded = FALSE;

            POINT     gdiPoints[3];

            // When printing we want to punt simple DrawImage calls to
            // GDI using StretchDIBits.  We check the criteria here, must
            // have simple transoformation.

            if (IsPrinter() &&
                (Context->WorldToDevice.IsTranslateScale()) &&
                (numPoints == 3) &&
                (REALABS(fDst[0].X - fDst[2].X) < REAL_EPSILON) &&
                (REALABS(fDst[0].Y - fDst[1].Y) < REAL_EPSILON) &&
                (fDst[1].X > fDst[0].X) && 
                (fDst[2].Y > fDst[0].Y) &&
                (Context->WorldToDevice.Transform(fDst, gdiPoints, 3),
                ((gdiPoints[1].x > gdiPoints[0].x) &&        // no flipping
                 (gdiPoints[2].y > gdiPoints[0].y)) ) )
            {
                // try PNG or JPG passthrough of compressed bits on Win98/NT
                if (!Globals::IsWin95 && 
                    (cloneBitmap == NULL) && // no recoloring
                    (srcRect.Height >= ((height*9)/10)) &&
                    (srcRect.Width >= ((width*9)/10)) &&
                    (srcRect.Height >= 32) &&
                    (srcRect.Width >= 32))
                {
                    
                    // !! ICM convert??
                    // !! Source rectangle is outside of image or WrapMode* on bitmap

                    HDC hdc;
                    
                    {   // FPU Sandbox for potentially unsafe FPU code.
                        FPUStateSandbox fpsb;
                        hdc = Context->GetHdc(Surface);
                    }   // FPU Sandbox for potentially unsafe FPU code.
                    
                    if (hdc != NULL) 
                    {
                        DriverPrint *dprint = (DriverPrint*)Driver;

                        status = srcBitmap->GetCompressedData(&compressedData,
                                               dprint->SupportJPEGpassthrough,
                                               dprint->SupportPNGpassthrough,
                                               hdc);
                    
                        if (compressedData.buffer != NULL) 
                        {
                            if (REALABS(width) < REAL_EPSILON || 
                                REALABS(height) < REAL_EPSILON )
                            {
                                bmpDataSrc.Width = srcBitmapImageInfo.Width;
                                bmpDataSrc.Height = srcBitmapImageInfo.Height;
                            }
                            else
                            {
                                bmpDataSrc.Width = GpRound(width);
                                bmpDataSrc.Height = GpRound(height);
                            }

                            bmpDataSrc.Stride = 0;
                            bmpDataSrc.PixelFormat = PixelFormatDontCare; 
                            bmpDataSrc.Scan0 = NULL;
                            bmpDataSrc.Reserved = 0;
                            bitsLoaded = TRUE;

                            // Since the driver supports passthrough of 
                            // this image, it is responsible for any
                            // transparency at printer level.  From here,
                            // we treat image as opaque.

                            transparency = TransparencyOpaque;
                            
                            lockedPixelFormat = PixelFormatDontCare;
                        }

                        Context->ReleaseHdc(hdc, Surface);
                    }
                }

                if (!bitsLoaded) 
                {
                    // If reasonable pixel format then get GDI to understand
                    // the format natively.
                    
                    if (((srcBitmapImageInfo.PixelFormat & PixelFormatGDI) != 0) &&
                        !IsAlphaPixelFormat(srcBitmapImageInfo.PixelFormat) &&
                        !IsExtendedPixelFormat(srcBitmapImageInfo.PixelFormat) && 
                        (GetPixelFormatSize(srcBitmapImageInfo.PixelFormat) <= 8))
                    {
                        lockedPixelFormat = srcBitmapImageInfo.PixelFormat;
                    }

                    if (Context->CompositingMode == CompositingModeSourceCopy)
                    {
                        transparency = TransparencyNoAlpha;
                    }
                    else
                    {
                        if (srcBitmap->GetTransparencyFlags(&transparency,
                                                        lockedPixelFormat,
                                                        &minAlpha,
                                                        &maxAlpha) != Ok)
                        {
                            transparency = TransparencyUnknown;
                        }

                        // We only want to lock at this pixel format if it 
                        // is opaque, otherwise we won't punt to GDI.  We take
                        // the hit of decoding twice, but notice it will likely
                        // be cheaper to load & test transparency at original 
                        // depth.

                        if (transparency != TransparencyOpaque &&
                            transparency != TransparencyNoAlpha)
                        {
                            lockedPixelFormat = PIXFMT_32BPP_PARGB;
                        }
                    }
                }
            }
            else
            {
                if (IsPrinter()) 
                {
                    // SourceCopy implies there is no alpha transfer to 
                    // destination.
                    if (Context->CompositingMode == CompositingModeSourceCopy)
                    {
                        transparency = TransparencyNoAlpha;
                    }
                    else
                    {
                        // Query image for accurate transparency flags.  If
                        // necessary, load into memory at 32bpp PARGB. 
                        if (srcBitmap->GetTransparencyFlags(&transparency,
                                                            lockedPixelFormat,
                                                            &minAlpha,
                                                            &maxAlpha) != Ok)
                        {
                            transparency = TransparencyUnknown;
                        }
                    }
                }
                else
                {
                    // non-printing scenarios query transparency flags only
                    if (srcBitmap->GetTransparencyHint(&transparency) != Ok)
                    {
                        transparency = TransparencyUnknown;
                    }
                }
            }
            
            // Lock the bits.
            // It's important that we lock the bits in a premultiplied
            // pixel format because the image filtering code for stretches
            // and rotation requires premultiplied input data to avoid the
            // "halo effect" on transparent borders.
            // This is going to trigger an expensive image format conversion
            // if the input data is not already premultiplied. This is 
            // obviously true if we've done Recoloring which requires 
            // and outputs non-premultiplied data.
            
            // A notable exception is metafiling which requires 
            // non-premultiplied data.

            // Note that the width and height that we get back in the
            // bmpDataSrc are the 'real' width and height. They represent
            // what the codec was actually able to do for us and may not
            // be equal to the width and height passed in.

            if (!bitsLoaded) 
            {
                status = srcBitmap->LockBits(
                    NULL,
                    IMGLOCK_READ,
                    lockedPixelFormat,
                    &bmpDataSrc,
                    GpRound(width),
                    GpRound(height)
                );
            }
        }
        else
        {
            status = InvalidParameter;
        }

        // We have been successful at everything including locking the bits.
        // Now lets actually set up the driver call.

        if(status == Ok)
        {
            DpBitmap driverSurface;

            // Fake up a DpBitmap for the driver call.
            // We do this because the GpBitmap doesn't maintain the
            // DpBitmap as a driver surface - instead it uses a
            // GpMemoryBitmap.
            
            srcBitmap->InitializeSurfaceForGdipBitmap(
                &driverSurface, 
                bmpDataSrc.Width, 
                bmpDataSrc.Height
            );

            driverSurface.Bits = bmpDataSrc.Scan0;
            driverSurface.Width = bmpDataSrc.Width;
            driverSurface.Height = bmpDataSrc.Height;
            driverSurface.Delta = bmpDataSrc.Stride;

            driverSurface.PixelFormat = lockedPixelFormat;
            
            // only valid when PixelFormat is 32bpp
            
            driverSurface.NumBytes = 
                bmpDataSrc.Width*
                bmpDataSrc.Height*
                sizeof(ARGB);

            if (compressedData.buffer != NULL)
            {
                driverSurface.CompressedData = &compressedData;
            }

            if (IsIndexedPixelFormat(lockedPixelFormat)) 
            {
                INT size = srcBitmap->GetPaletteSize();

                if (size > 0) 
                {   
                    driverSurface.PaletteTable = (ColorPalette*)GpMalloc(size);
                    
                    if(driverSurface.PaletteTable)
                    {
                        status = srcBitmap->GetPalette(
                            driverSurface.PaletteTable, 
                            size
                        );
                    }
                    else
                    {
                        status = OutOfMemory;
                    }
                    
                    if(Ok != status)
                    {
                        goto cleanup;
                    }
                }
            }

            driverSurface.SurfaceTransparency = transparency;
            driverSurface.MinAlpha = minAlpha;
            driverSurface.MaxAlpha = maxAlpha;

            // Fake up a DpImageAttributes if the imageAttributes is NULL

            // !!! PERF: [asecchia] It would be more efficient to not have
            // to do the multiple DpImageAttributes copies here - rather
            // we should pass it by pointer - that way we could use NULL
            // for the common case (no imageAttributes).

            DpImageAttributes dpImageAttributes;
            if(imageAttributes)
            {
                dpImageAttributes = imageAttributes->DeviceImageAttributes;
            }

            BOOL DestroyBitsWhenDone = FALSE;

            if(((INT)(bmpDataSrc.Width) != srcBitmapImageInfo.Width) ||
               ((INT)(bmpDataSrc.Height) != srcBitmapImageInfo.Height))
            {
                ASSERT(srcBitmapImageInfo.Width != 0);
                ASSERT(srcBitmapImageInfo.Height != 0);

                // The size we got back from LockBits is different from
                // the queried size of the image. This means that the codec
                // was able to perform some scaling for us (presumably for
                // some performance benefit).
                // Scale the source rectangle appropriately.

                REAL scaleFactorX = (REAL)(bmpDataSrc.Width)/srcBitmapImageInfo.Width;
                REAL scaleFactorY = (REAL)(bmpDataSrc.Height)/srcBitmapImageInfo.Height;
                bboxSrcRect.X = scaleFactorX*bboxSrcRect.X;
                bboxSrcRect.Y = scaleFactorY*bboxSrcRect.Y;
                bboxSrcRect.Width = scaleFactorX*bboxSrcRect.Width;
                bboxSrcRect.Height = scaleFactorY*bboxSrcRect.Height;

                // We have only a partial decode. That means the bits we have
                // in memory may not be sufficient for the next draw, so
                // blow the bits away to force a decode on the next draw.

                DestroyBitsWhenDone = TRUE;
            }

            // Call the driver to draw the image.

            status = Driver->DrawImage(
                Context, &driverSurface, Surface,
                drawBounds,
                &dpImageAttributes,
                numPoints, fDst,
                &bboxSrcRect, flags
             );

            if (lockedPixelFormat != PixelFormatDontCare) 
            {
                ASSERT(bmpDataSrc.Scan0 != NULL);

                srcBitmap->UnlockBits(&bmpDataSrc, DestroyBitsWhenDone);
            }

        }

        // delete compressed data allocation if any
        
        if (compressedData.buffer != NULL)
        {
            srcBitmap->DeleteCompressedData(&compressedData);
        }

        // Restore the Transformation
        
        Context->WorldToDevice = worldDevice;

        if (clipRegion != NULL)
        {
            // What if we fail this?
            if (restoreClipping)
            {
                SetClip(clipRegion, CombineModeReplace);
            }
            delete clipRegion;
        }

    }

    
    cleanup:
    
    // Throw away any temporary storage we used and clean up any state changes.

    Context->WorldToDevice = saveWorldToDevice;
    
    if (cloneBitmap)
    {
        cloneBitmap->Dispose();
    }
    
    if (xformBitmap)
    {
        xformBitmap->Dispose();
    }

    return status;
}

// This is really an ARGB array
BYTE GdipSolidColors216[224 * 4] = {
//  blue  grn   red   alpha
    0x00, 0x00, 0x00, 0xFF,
    0x00, 0x00, 0x80, 0xFF,
    0x00, 0x80, 0x00, 0xFF,
    0x00, 0x80, 0x80, 0xFF,
    0x80, 0x00, 0x00, 0xFF,
    0x80, 0x00, 0x80, 0xFF,
    0x80, 0x80, 0x00, 0xFF,
    0x80, 0x80, 0x80, 0xFF,
    0xC0, 0xC0, 0xC0, 0xFF,
    0xFF, 0x00, 0x00, 0xFF,
    0x00, 0xFF, 0x00, 0xFF,
    0xFF, 0xFF, 0x00, 0xFF,
    0x00, 0x00, 0xFF, 0xFF,
    0xFF, 0x00, 0xFF, 0xFF,
    0x00, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF,
    0x33, 0x00, 0x00, 0xFF,
    0x66, 0x00, 0x00, 0xFF,
    0x99, 0x00, 0x00, 0xFF,
    0xCC, 0x00, 0x00, 0xFF,
    0x00, 0x33, 0x00, 0xFF,
    0x33, 0x33, 0x00, 0xFF,
    0x66, 0x33, 0x00, 0xFF,
    0x99, 0x33, 0x00, 0xFF,
    0xCC, 0x33, 0x00, 0xFF,
    0xFF, 0x33, 0x00, 0xFF,
    0x00, 0x66, 0x00, 0xFF,
    0x33, 0x66, 0x00, 0xFF,
    0x66, 0x66, 0x00, 0xFF,
    0x99, 0x66, 0x00, 0xFF,
    0xCC, 0x66, 0x00, 0xFF,
    0xFF, 0x66, 0x00, 0xFF,
    0x00, 0x99, 0x00, 0xFF,
    0x33, 0x99, 0x00, 0xFF,
    0x66, 0x99, 0x00, 0xFF,
    0x99, 0x99, 0x00, 0xFF,
    0xCC, 0x99, 0x00, 0xFF,
    0xFF, 0x99, 0x00, 0xFF,
    0x00, 0xCC, 0x00, 0xFF,
    0x33, 0xCC, 0x00, 0xFF,
    0x66, 0xCC, 0x00, 0xFF,
    0x99, 0xCC, 0x00, 0xFF,
    0xCC, 0xCC, 0x00, 0xFF,
    0xFF, 0xCC, 0x00, 0xFF,
    0x33, 0xFF, 0x00, 0xFF,
    0x66, 0xFF, 0x00, 0xFF,
    0x99, 0xFF, 0x00, 0xFF,
    0xCC, 0xFF, 0x00, 0xFF,
    0x00, 0x00, 0x33, 0xFF,
    0x33, 0x00, 0x33, 0xFF,
    0x66, 0x00, 0x33, 0xFF,
    0x99, 0x00, 0x33, 0xFF,
    0xCC, 0x00, 0x33, 0xFF,
    0xFF, 0x00, 0x33, 0xFF,
    0x00, 0x33, 0x33, 0xFF,
    0x33, 0x33, 0x33, 0xFF,
    0x66, 0x33, 0x33, 0xFF,
    0x99, 0x33, 0x33, 0xFF,
    0xCC, 0x33, 0x33, 0xFF,
    0xFF, 0x33, 0x33, 0xFF,
    0x00, 0x66, 0x33, 0xFF,
    0x33, 0x66, 0x33, 0xFF,
    0x66, 0x66, 0x33, 0xFF,
    0x99, 0x66, 0x33, 0xFF,
    0xCC, 0x66, 0x33, 0xFF,
    0xFF, 0x66, 0x33, 0xFF,
    0x00, 0x99, 0x33, 0xFF,
    0x33, 0x99, 0x33, 0xFF,
    0x66, 0x99, 0x33, 0xFF,
    0x99, 0x99, 0x33, 0xFF,
    0xCC, 0x99, 0x33, 0xFF,
    0xFF, 0x99, 0x33, 0xFF,
    0x00, 0xCC, 0x33, 0xFF,
    0x33, 0xCC, 0x33, 0xFF,
    0x66, 0xCC, 0x33, 0xFF,
    0x99, 0xCC, 0x33, 0xFF,
    0xCC, 0xCC, 0x33, 0xFF,
    0xFF, 0xCC, 0x33, 0xFF,
    0x00, 0xFF, 0x33, 0xFF,
    0x33, 0xFF, 0x33, 0xFF,
    0x66, 0xFF, 0x33, 0xFF,
    0x99, 0xFF, 0x33, 0xFF,
    0xCC, 0xFF, 0x33, 0xFF,
    0xFF, 0xFF, 0x33, 0xFF,
    0x00, 0x00, 0x66, 0xFF,
    0x33, 0x00, 0x66, 0xFF,
    0x66, 0x00, 0x66, 0xFF,
    0x99, 0x00, 0x66, 0xFF,
    0xCC, 0x00, 0x66, 0xFF,
    0xFF, 0x00, 0x66, 0xFF,
    0x00, 0x33, 0x66, 0xFF,
    0x33, 0x33, 0x66, 0xFF,
    0x66, 0x33, 0x66, 0xFF,
    0x99, 0x33, 0x66, 0xFF,
    0xCC, 0x33, 0x66, 0xFF,
    0xFF, 0x33, 0x66, 0xFF,
    0x00, 0x66, 0x66, 0xFF,
    0x33, 0x66, 0x66, 0xFF,
    0x66, 0x66, 0x66, 0xFF,
    0x99, 0x66, 0x66, 0xFF,
    0xCC, 0x66, 0x66, 0xFF,
    0xFF, 0x66, 0x66, 0xFF,
    0x00, 0x99, 0x66, 0xFF,
    0x33, 0x99, 0x66, 0xFF,
    0x66, 0x99, 0x66, 0xFF,
    0x99, 0x99, 0x66, 0xFF,
    0xCC, 0x99, 0x66, 0xFF,
    0xFF, 0x99, 0x66, 0xFF,
    0x00, 0xCC, 0x66, 0xFF,
    0x33, 0xCC, 0x66, 0xFF,
    0x66, 0xCC, 0x66, 0xFF,
    0x99, 0xCC, 0x66, 0xFF,
    0xCC, 0xCC, 0x66, 0xFF,
    0xFF, 0xCC, 0x66, 0xFF,
    0x00, 0xFF, 0x66, 0xFF,
    0x33, 0xFF, 0x66, 0xFF,
    0x66, 0xFF, 0x66, 0xFF,
    0x99, 0xFF, 0x66, 0xFF,
    0xCC, 0xFF, 0x66, 0xFF,
    0xFF, 0xFF, 0x66, 0xFF,
    0x00, 0x00, 0x99, 0xFF,
    0x33, 0x00, 0x99, 0xFF,
    0x66, 0x00, 0x99, 0xFF,
    0x99, 0x00, 0x99, 0xFF,
    0xCC, 0x00, 0x99, 0xFF,
    0xFF, 0x00, 0x99, 0xFF,
    0x00, 0x33, 0x99, 0xFF,
    0x33, 0x33, 0x99, 0xFF,
    0x66, 0x33, 0x99, 0xFF,
    0x99, 0x33, 0x99, 0xFF,
    0xCC, 0x33, 0x99, 0xFF,
    0xFF, 0x33, 0x99, 0xFF,
    0x00, 0x66, 0x99, 0xFF,
    0x33, 0x66, 0x99, 0xFF,
    0x66, 0x66, 0x99, 0xFF,
    0x99, 0x66, 0x99, 0xFF,
    0xCC, 0x66, 0x99, 0xFF,
    0xFF, 0x66, 0x99, 0xFF,
    0x00, 0x99, 0x99, 0xFF,
    0x33, 0x99, 0x99, 0xFF,
    0x66, 0x99, 0x99, 0xFF,
    0x99, 0x99, 0x99, 0xFF,
    0xCC, 0x99, 0x99, 0xFF,
    0xFF, 0x99, 0x99, 0xFF,
    0x00, 0xCC, 0x99, 0xFF,
    0x33, 0xCC, 0x99, 0xFF,
    0x66, 0xCC, 0x99, 0xFF,
    0x99, 0xCC, 0x99, 0xFF,
    0xCC, 0xCC, 0x99, 0xFF,
    0xFF, 0xCC, 0x99, 0xFF,
    0x00, 0xFF, 0x99, 0xFF,
    0x33, 0xFF, 0x99, 0xFF,
    0x66, 0xFF, 0x99, 0xFF,
    0x99, 0xFF, 0x99, 0xFF,
    0xCC, 0xFF, 0x99, 0xFF,
    0xFF, 0xFF, 0x99, 0xFF,
    0x00, 0x00, 0xCC, 0xFF,
    0x33, 0x00, 0xCC, 0xFF,
    0x66, 0x00, 0xCC, 0xFF,
    0x99, 0x00, 0xCC, 0xFF,
    0xCC, 0x00, 0xCC, 0xFF,
    0xFF, 0x00, 0xCC, 0xFF,
    0x00, 0x33, 0xCC, 0xFF,
    0x33, 0x33, 0xCC, 0xFF,
    0x66, 0x33, 0xCC, 0xFF,
    0x99, 0x33, 0xCC, 0xFF,
    0xCC, 0x33, 0xCC, 0xFF,
    0xFF, 0x33, 0xCC, 0xFF,
    0x00, 0x66, 0xCC, 0xFF,
    0x33, 0x66, 0xCC, 0xFF,
    0x66, 0x66, 0xCC, 0xFF,
    0x99, 0x66, 0xCC, 0xFF,
    0xCC, 0x66, 0xCC, 0xFF,
    0xFF, 0x66, 0xCC, 0xFF,
    0x00, 0x99, 0xCC, 0xFF,
    0x33, 0x99, 0xCC, 0xFF,
    0x66, 0x99, 0xCC, 0xFF,
    0x99, 0x99, 0xCC, 0xFF,
    0xCC, 0x99, 0xCC, 0xFF,
    0xFF, 0x99, 0xCC, 0xFF,
    0x00, 0xCC, 0xCC, 0xFF,
    0x33, 0xCC, 0xCC, 0xFF,
    0x66, 0xCC, 0xCC, 0xFF,
    0x99, 0xCC, 0xCC, 0xFF,
    0xCC, 0xCC, 0xCC, 0xFF,
    0xFF, 0xCC, 0xCC, 0xFF,
    0x00, 0xFF, 0xCC, 0xFF,
    0x33, 0xFF, 0xCC, 0xFF,
    0x66, 0xFF, 0xCC, 0xFF,
    0x99, 0xFF, 0xCC, 0xFF,
    0xCC, 0xFF, 0xCC, 0xFF,
    0xFF, 0xFF, 0xCC, 0xFF,
    0x33, 0x00, 0xFF, 0xFF,
    0x66, 0x00, 0xFF, 0xFF,
    0x99, 0x00, 0xFF, 0xFF,
    0xCC, 0x00, 0xFF, 0xFF,
    0x00, 0x33, 0xFF, 0xFF,
    0x33, 0x33, 0xFF, 0xFF,
    0x66, 0x33, 0xFF, 0xFF,
    0x99, 0x33, 0xFF, 0xFF,
    0xCC, 0x33, 0xFF, 0xFF,
    0xFF, 0x33, 0xFF, 0xFF,
    0x00, 0x66, 0xFF, 0xFF,
    0x33, 0x66, 0xFF, 0xFF,
    0x66, 0x66, 0xFF, 0xFF,
    0x99, 0x66, 0xFF, 0xFF,
    0xCC, 0x66, 0xFF, 0xFF,
    0xFF, 0x66, 0xFF, 0xFF,
    0x00, 0x99, 0xFF, 0xFF,
    0x33, 0x99, 0xFF, 0xFF,
    0x66, 0x99, 0xFF, 0xFF,
    0x99, 0x99, 0xFF, 0xFF,
    0xCC, 0x99, 0xFF, 0xFF,
    0xFF, 0x99, 0xFF, 0xFF,
    0x00, 0xCC, 0xFF, 0xFF,
    0x33, 0xCC, 0xFF, 0xFF,
    0x66, 0xCC, 0xFF, 0xFF,
    0x99, 0xCC, 0xFF, 0xFF,
    0xCC, 0xCC, 0xFF, 0xFF,
    0xFF, 0xCC, 0xFF, 0xFF,
    0x33, 0xFF, 0xFF, 0xFF,
    0x66, 0xFF, 0xFF, 0xFF,
    0x99, 0xFF, 0xFF, 0xFF,
    0xCC, 0xFF, 0xFF, 0xFF,
};

ARGB
GpGraphics::GetNearestColor(
    ARGB        argb
    )
{
    HalftoneType    halftoneType = this->GetHalftoneType();

    // See if we are doing any halftoning
    if (halftoneType < HalftoneType16Color)
    {
        return argb;
    }

    INT         r = GpColor::GetRedARGB(argb);
    INT         g = GpColor::GetGreenARGB(argb);
    INT         b = GpColor::GetBlueARGB(argb);

    // Handle 15 and 16 bpp halftoning:
    
    if (halftoneType == HalftoneType15Bpp)
    {
        if (!Globals::IsNt)
        {
            // Subtract the bias, saturated to 0:

            r = (r < 4) ? 0 : (r - 4);
            g = (g < 4) ? 0 : (g - 4);
            b = (b < 4) ? 0 : (b - 4);
        }

        // Clear low 3 bits of each for a solid color:
        
        r &= 248;
        g &= 248;
        b &= 248;

        return GpColor((BYTE) r, (BYTE) g, (BYTE) b).GetValue();
    }
    else if (halftoneType == HalftoneType16Bpp)
    {
        if (!Globals::IsNt)
        {
            // Subtract the bias, saturated to 0:

            r = (r < 4) ? 0 : (r - 4);
            g = (g < 2) ? 0 : (g - 2);
            b = (b < 4) ? 0 : (b - 4);
        }

        // Clear low n bits of each for a solid color:

        r &= 248; // 5, n = 3
        g &= 252; // 6, n = 2
        b &= 248; // 5, n = 3

        return GpColor((BYTE) r, (BYTE) g, (BYTE) b).GetValue();
    }

    // Handle remaining cases, 4 bpp and 8 bpp halftoning:
    
    ASSERT((halftoneType == HalftoneType16Color) ||
           (halftoneType == HalftoneType216Color));

    INT         i;
    INT         deltaR;
    INT         deltaG;
    INT         deltaB;
    INT         curError;
    INT         minError = (255 * 255) + (255 * 255) + (255 * 255) + 1;
    ARGB        nearestColor;
    INT         max = (halftoneType == HalftoneType216Color) ? 224 * 4 : 16 * 4;

    i = 0;
    do
    {
        deltaR = GdipSolidColors216[i+2] - r;
        deltaG = GdipSolidColors216[i+1] - g;
        deltaB = GdipSolidColors216[i+0] - b;

        curError = (deltaR * deltaR) + (deltaG * deltaG) + (deltaB * deltaB);

        if (curError < minError)
        {
            nearestColor = *((ARGB *)(GdipSolidColors216 + i));
            if (curError == 0)
            {
                goto Found;
            }
            minError = curError;
        }
        i += 4;
    }  while (i < max);

    // Check to see if it is one of the four system colors.
    // Only return a system color if it is an exact match.
    
    COLORREF    rgb;
    rgb = RGB(r,g,b);

    if ((rgb == Globals::SystemColors[16]) ||
        (rgb == Globals::SystemColors[17]) ||
        (rgb == Globals::SystemColors[18]) ||
        (rgb == Globals::SystemColors[19]))
    {
        return argb;
    }

Found:
    // return the same alpha value

    INT         a = argb & Color::AlphaMask;

    if (a != Color::AlphaMask)
    {
        nearestColor = (nearestColor & (~Color::AlphaMask)) | a;
    }

    return nearestColor;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\gpbitmap.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Abstract:
*
*   Implemenation of GpBitmap class
*
* Revision History:
*
*   06/28/1998 davidx
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

#include "..\imaging\api\comutils.hpp"
#include "..\imaging\api\decodedimg.hpp"
#include "..\imaging\api\icmdll.hpp"
#include "..\imaging\api\memstream.hpp"
#include "..\imaging\api\imgutils.hpp"
#include "..\imaging\api\imgfactory.hpp"
#include "..\render\scanoperationinternal.hpp"
#include "..\render\FormatConverter.hpp"
#include "CopyOnWriteBitmap.hpp"

#define GDIP_TRANSPARENT_COLOR_KEY  0x000D0B0C
static const CLSID InternalJpegClsID =
{
    0x557cf401,
    0x1a04,
    0x11d3,
    {0x9a, 0x73, 0x00, 0x00, 0xf8, 0x1e, 0xf3, 0x2e}
};

//!!! TO DO: need to go through all the routines to
// map image error codes to gdi+ error codes

GpStatus
MapHRESULTToGpStatus(HRESULT hr)
{
    GpStatus status;

    switch(hr)
    {
    case S_OK:
        status = Ok;
        break;
    case E_INVALIDARG:
        status = InvalidParameter;
        break;
    case E_OUTOFMEMORY:
        status = OutOfMemory;
        break;
    case IMGERR_OBJECTBUSY:
        status = ObjectBusy;
        break;
    case E_NOTIMPL:
        status = NotImplemented;
        break;
    case IMGERR_ABORT:
        status = Aborted;
        break;
    case IMGERR_CODECNOTFOUND:
    case IMGERR_FAILLOADCODEC:
        status = FileNotFound;
        break;
    case IMGERR_PROPERTYNOTFOUND:
        status = PropertyNotFound;
        break;
    case IMGERR_PROPERTYNOTSUPPORTED:
        status = PropertyNotSupported;
        break;
    default:
        status = Win32Error;
   }
   return status;
}

/**************************************************************************\
*
* Function Description:
*   ICM conversion from the embedded profile - if any - to SRGB
*
* Arguments:
*   dstBitmap - pass in pointer to destination buffer or NULL to do conversion
*   in place.
*
* Return Value:
*
*   The image is cloned and the operations performed on the clone.
*   The result is returned in dst.
*   NULL indicates that the operation didn't happen
*
\**************************************************************************/

GpStatus CopyOnWriteBitmap::ICMFrontEnd(
    CopyOnWriteBitmap **dstBitmap,
    DrawImageAbort callback,
    VOID *callbackData,
    GpRect *rect
)
{

    // check to see if we're doing a conversion.
    if(!ICMConvert || Globals::NoICM)
    {
        return Ok;
    }

    GpStatus status = Ok;
    UINT size;
    CopyOnWriteBitmap *dst = NULL;

    status = GetPropertyItemSize(TAG_ICC_PROFILE, &size);

    if(status==Ok)
    {
        PropertyItem *pi = (PropertyItem *)GpMalloc(size);

        if(pi)
        {
            status = GetPropertyItem(TAG_ICC_PROFILE, size, pi);
        }
        else
        {
            status = OutOfMemory;
        }

        if(status == Ok)
        {
            HRESULT hr = LoadICMDll();
            if(SUCCEEDED(hr))
            {
                // Get Embedded profile
                PROFILE p;
                p.dwType = PROFILE_MEMBUFFER;
                p.pProfileData = pi->value;
                p.cbDataSize = size-sizeof(PropertyItem);

                // destination profile for our internal space.
                char profilename[40] = "sRGB Color Space Profile.icm";
                PROFILE srgb;
                srgb.dwType = PROFILE_FILENAME;
                srgb.pProfileData = profilename;
                srgb.cbDataSize = 40;

                HPROFILE profiles[2];
                profiles[0] = (*pfnOpenColorProfile)(&p,
                                                     PROFILE_READ,
                                                     FILE_SHARE_READ,
                                                     OPEN_EXISTING);
                profiles[1] = (*pfnOpenColorProfile)(&srgb,
                                                     PROFILE_READ,
                                                     FILE_SHARE_READ,
                                                     OPEN_EXISTING);

                if ( profiles[0] && profiles[1] )
                {
                    HTRANSFORM trans;
                    DWORD intent[2] = {INTENT_PERCEPTUAL, INTENT_PERCEPTUAL};
                    trans = (*pfnCreateMultiProfileTransform)(
                        profiles, 2, intent, 2,
                        BEST_MODE | USE_RELATIVE_COLORIMETRIC,
                        0
                    );
                    if(trans)
                    {
                        // Translate bitmap bits at bit depth.
                        PixelFormatID pixFmt = PixelFormat32bppARGB;
                        if (IsIndexedPixelFormat(PixelFormatInMem))
                        {
                            pixFmt = PixelFormatInMem;
                        }

                        if(dstBitmap)
                        {
                            *dstBitmap = Clone(rect, pixFmt);
                            dst = *dstBitmap;
                        }
                        else
                        {
                            dst = this;
                            if (pixFmt != PixelFormatInMem)
                            {
                                ConvertFormat(pixFmt, callback, callbackData);
                            }
                        }

                        // Up to this point, PixelFormatInMem is preserved if
                        // indexed palette is available, otherwise we set to
                        // PIXFMT_32BPP_ARGB.

                        if(dst)
                        {
                            ASSERT(dst->Bmp != NULL);
                            ASSERT(dst->State == CopyOnWriteBitmap::MemBitmap);

                            BOOL result = FALSE;

                            if (IsIndexedPixelFormat(pixFmt))
                            {
                                // Translate the palette on bitmap
                                const ColorPalette *srcPalette;

                                srcPalette = dst->Bmp->GetCurrentPalette();

                                if (srcPalette != NULL)
                                {
                                    ColorPalette *dstPalette;
                                    dstPalette = CloneColorPalette(srcPalette, FALSE);

                                    if (dstPalette != NULL)
                                    {
                                        // Do ICM
                                        result = (*pfnTranslateBitmapBits)(
                                                trans,
                                                (PVOID)&(srcPalette->Entries[0]),
                                                BM_xRGBQUADS,
                                                1,
                                                srcPalette->Count,
                                                sizeof(ARGB),
                                                (PVOID)&(dstPalette->Entries[0]),
                                                BM_xRGBQUADS,
                                                sizeof(ARGB),
                                                NULL,
                                                NULL
                                            );

                                        if (result)
                                        {
                                            // Set transformed palette into
                                            // the destination MemoryBitmap

                                            HRESULT hr;

                                            hr = dst->Bmp->SetPalette(dstPalette);
                                            if (FAILED(hr))
                                            {
                                                result = FALSE;
                                            }
                                        }
                                        else
                                        {
                                            DWORD err = GetLastError();
                                            status = Win32Error;
                                            WARNING(("TranslateBitmapBits failed %d", err));
                                        }
                                        

                                        GpFree(dstPalette);
                                    }
                                }
                            }// Indexed format conversion
                            else
                            {
                                // Make a new Bmp structure.
                                GpMemoryBitmap *icmBmp = new GpMemoryBitmap();
                                
                                if(icmBmp)
                                {
                                    icmBmp->InitNewBitmap(
                                        dst->Bmp->Width,
                                        dst->Bmp->Height,
                                        pixFmt
                                    );
    
                                    // Do ICM
    
                                    BMFORMAT ulSrcColorMode = BM_xRGBQUADS;
                                    BMFORMAT ulDstColorMode = BM_xRGBQUADS;
    
                                    if ( dst->SrcImageInfo.Flags
                                        & IMGFLAG_COLORSPACE_CMYK )
                                    {
                                        // Source image is in CMYK color space
    
                                        ulSrcColorMode = BM_CMYKQUADS;
                                    }
    
                                    result = (*pfnTranslateBitmapBits)(
                                            trans,
                                            dst->Bmp->Scan0,
                                            ulSrcColorMode,
                                            dst->Bmp->Width,
                                            dst->Bmp->Height,
                                            dst->Bmp->Stride,
    
                                            icmBmp->Scan0,
                                            ulDstColorMode,
                                            icmBmp->Stride,
                                            NULL,
                                            NULL
                                        );
    
                                    if (result)
                                    {
                                        // switch in the corrected bmp.
    
                                        GpMemoryBitmap *tmp = dst->Bmp;
                                        dst->Bmp = icmBmp;
                                        icmBmp = tmp;
                                    } 
                                    else
                                    {
                                        DWORD err = GetLastError();
                                        status = Win32Error;
                                        WARNING(("TranslateBitmapBits failed %d", err));
                                    }
    
    
                                    // delete the appropriate one - based on success or failure
                                    // of the TranslateBitmapBits
                                    
                                    delete icmBmp;
                                    
                                    // Convert from RGB to 32 ARGB
                                    // Note: ICC doesn't support alpha. If we fall into
                                    // this piece of code, we are sure we are in
                                    // 32BPP_RGB mode. So we can just set the image as
                                    // opaque.
                                    
                                    ASSERT(dst->PixelFormatInMem==PixelFormat32bppARGB);
        
                                    BYTE* pBits = (BYTE*)dst->Bmp->Scan0;
        
                                    for ( int i = 0; i < (int)dst->Bmp->Height; ++i )
                                    {
                                        BYTE* pTemp = pBits;
                                        for ( int j = 0; j < (int)dst->Bmp->Width; ++j )
                                        {
                                            pTemp[3] = 0xff;
                                            pTemp += 4;
                                        }
        
                                        pBits += dst->Bmp->Stride;
                                    }
    
                                    // If we have hacked the color format in
                                    // LoadIntomemory() to avoid the color format
                                    // conversion, then we need to restore it back
                                    // here
    
                                    if ( HasChangedRequiredPixelFormat == TRUE )
                                    {
                                        PixelFormatInMem = PixelFormat32bppPARGB;
                                        HasChangedRequiredPixelFormat = FALSE;
                                    }
                                }
                                else  //if icmBmp
                                {
                                    status = OutOfMemory;
                                }
                            }
                        }
                        else
                        {
                            status = Win32Error;
                            WARNING(("Failed to clone bitmap\n"));
                        }

                        (*pfnDeleteColorTransform)(trans);
                    }// if ( trans )
                    else
                    {
                        status = Win32Error;
                        WARNING(("CreateMultiProfileTransform failed"));
                    }
                }// if ( profiles[0] && profiles[1] )
                else
                {
                    status = Win32Error;
                    WARNING(("OpenColorProfile failed"));
                }

                if(profiles[0])
                {
                    (*pfnCloseColorProfile)(profiles[0]);
                }

                if(profiles[1])
                {
                    (*pfnCloseColorProfile)(profiles[1]);
                }
            }
            else
            {
                status = Win32Error;
                WARNING(("Failed to load ICM dll\n"));
            }
        }
        else
        {
            WARNING(("Failed to get the ICC property"));
        }
        GpFree(pi);
    }
    else
    {
        // Try do gamma and chromaticity.
        PropertyItem *piGamma= NULL;
        status = GetPropertyItemSize(TAG_GAMMA, &size);
        if(status==Ok)
        {
            piGamma = (PropertyItem *)GpMalloc(size);
            status = GetPropertyItem(TAG_GAMMA, size, piGamma);
        }
        else
        {
            status = Ok;
        }

        PropertyItem *piWhitePoint= NULL;
        PropertyItem *piRGBPoint= NULL;
        status = GetPropertyItemSize(TAG_WHITE_POINT, &size);
        if(status==Ok)
        {
            piWhitePoint = (PropertyItem *)GpMalloc(size);
            status = GetPropertyItem(TAG_WHITE_POINT, size, piWhitePoint);
        }

        status = GetPropertyItemSize(TAG_PRIMAY_CHROMATICS, &size);
        if(status==Ok)
        {
            piRGBPoint = (PropertyItem *)GpMalloc(size);
            status = GetPropertyItem(TAG_PRIMAY_CHROMATICS, size,
                                     piRGBPoint);
        }
        else
        {
            status = Ok;
        }

        GpImageAttributes imageAttributes;

        if(piGamma)
        {
            REAL gamma;
            ASSERT((piGamma->type == TAG_TYPE_RATIONAL));

            // get 1.0/gamma from the (source) gamma chunk
            // formula is dstgamma/srcgamma
            // we have to invert the gamma to account to how it is stored
            // in the file format
            gamma = (REAL)*((long *)piGamma->value)/ *((long *)piGamma->value+1);
            gamma = gamma * 0.4545f;   // our destination gamma is 1/2.2

            // don't do any work if gamma is 1.0
            // !!! need to work out what the best value for the tolerance is.
            if(REALABS(gamma-1.0f) >= REAL_EPSILON)
            {
                imageAttributes.SetGamma(
                    ColorAdjustTypeBitmap, TRUE, gamma
                );
            }

        }
        using namespace VectorMath;

        if(piWhitePoint && piRGBPoint)
        {
            Matrix R;

            // Please refer to gdiplus\Specs\pngchrm.xls for all the formula
            // and calculations below

            LONG* llTemp = (long*)(piWhitePoint->value);

            REAL Rx, Ry, Gx, Gy, Bx, By, Wx, Wy;

            Wx = (REAL)llTemp[0] / llTemp[1];
            Wy = (REAL)llTemp[2] / llTemp[3];

            llTemp = (long*)(piRGBPoint->value);

            Rx = (REAL)llTemp[0] / llTemp[1];
            Ry = (REAL)llTemp[2] / llTemp[3];
            Gx = (REAL)llTemp[4] / llTemp[5];
            Gy = (REAL)llTemp[6] / llTemp[7];
            Bx = (REAL)llTemp[8] / llTemp[9];
            By = (REAL)llTemp[10] / llTemp[11];

            // White point
            Vector Wp(Wx, Wy, 1.0f-(Wx+Wy));

            // Within some obscurely small amount
            // !!! We need to work out what the actual tolerance should be.
            BOOL accelerate =
                (REALABS(Wx-0.3127f) < REAL_EPSILON) &&
                (REALABS(Wy-0.3290f) < REAL_EPSILON);

            Wp = Wp * (1.0f/Wy);

            // Transpose of the input matrix.
            Matrix I(
                Rx,           Gx,           Bx,
                Ry,           Gy,           By,
                1.0f-(Rx+Ry), 1.0f-(Gx+Gy), 1.0f-(Bx+By)
            );

            Matrix II = I.Inverse();

            Vector IIW = II*Wp;
            Matrix DIIW(IIW);   // Diagonalize vector IIW
            Matrix Q = I*DIIW;
            Matrix sRGB(
                3.2406f, -1.5372f, -0.4986f,
               -0.9689f,  1.8758f,  0.0415f,
                0.0557f, -0.2040f,  1.0570f
            );

            if(accelerate)
            {
                R = sRGB*Q;
            }
            else
            {

                Matrix B(
                    0.40024f, 0.70760f, -0.08081f,
                   -0.22630f, 1.16532f,  0.04570f,
                    0.00000f, 0.00000f,  0.91822f
                );

                Matrix BI(
                    1.859936387f, -1.129381619f,    0.21989741f,
                    0.361191436f, 0.638812463f,-6.3706E-06f,
                    0.000000000f, 0.000000000f, 1.089063623f
                );

                Vector LMS = B * Wp;

                // Get Diag( LMS^(-1) ), cell F50 in the XLS file

                if ( LMS.data[0] != 0 )
                {
                    LMS.data[0] = 1.0f / LMS.data[0];
                }

                if ( LMS.data[1] != 0 )
                {
                    LMS.data[1] = 1.0f / LMS.data[1];
                }

                if ( LMS.data[2] != 0 )
                {
                    LMS.data[2] = 1.0f / LMS.data[2];
                }

                Matrix L(LMS);      // Diagonalize vector LMS

                Matrix T = BI * L * B;
                R = sRGB * T * Q;
            }

            // Make a 5x5 Color matrix for the recolor pipeline.
            ColorMatrix ChM = {
                R.data[0][0], R.data[1][0], R.data[2][0], 0, 0,
                R.data[0][1], R.data[1][1], R.data[2][1], 0, 0,
                R.data[0][2], R.data[1][2], R.data[2][2], 0, 0,
                0,            0,            0,            1, 0,
                0,            0,            0,            0, 1
            };

            imageAttributes.SetColorMatrix(
                ColorAdjustTypeBitmap, TRUE, &ChM, NULL, ColorMatrixFlagsDefault
            );
        }

        // If we initialized the imageAttributes to anything other than
        // no-op then do the recoloring.

        if(piGamma || (piWhitePoint && piRGBPoint))
        {
            // Note under certain conditions, the imageAttributes could still
            // be no-op at this point. For instance if the gamma was really
            // close to 1 and we had no chromaticities.
            // Fortunately the recolor pipeline knows how to optimize the
            // no-op case.

            // Apply the Chromaticities and Gamma if they have been set.
            status = Recolor(
                imageAttributes.recolor,
                dstBitmap, NULL, NULL, rect
            );

            // Recolor() will set Dirty flag on this image. Actually it is not
            // dirty since we just apply the color correction on the image to
            // display it. So we should reverse it back to not dirty.
            // Note: this is a real issue for digital images from some cameras
            // like Fuji. It always have White balance in it. If we don't do
            // the reverse below, we can't do lossless transform on these
            // images.
            // Note: Unfortunately this kind of "dirty flag restore" breaks this
            // scenario: (windows bug #583962)
            // Source image is a 48 BPP PNG with embedded gamma. Without
            // restoring the dirty flag here, if the caller asks for save(), we
            // will save PNG using the bits in memory. If we set it to not dirty
            // the save code path will let the PNG decoder talk to the encoder
            // which will have 48 to 32 and to 48 conversion. This is a known
            // GDI+ issue that this kind of conversion will produce wrong data.
            // In order to avoid the PNG problem, we only restore the dirty flag
            // here if the source is a JPEG image.

            if (SrcImageInfo.RawDataFormat == IMGFMT_JPEG)
            {
                SetDirtyFlag(FALSE);
            }
        }

        GpFree(piGamma);
        GpFree(piWhitePoint);
        GpFree(piRGBPoint);
    }

    return status;
}


/**************************************************************************\
*
* Function Description:
*   Performs recoloring
*
* Arguments:
*
*   recolor contains the recolor object.
*   dstBitmap is the destination bitmap - set to NULL to recolor in place
*
* Return Value:
*
*   The image is cloned and the operations performed on the clone.
*   The result is returned in dst.
*   NULL indicates that the operation didn't happen
*
\**************************************************************************/
GpStatus
CopyOnWriteBitmap::Recolor(
    GpRecolor *recolor,
    CopyOnWriteBitmap **dstBitmap,
    DrawImageAbort callback,
    VOID *callbackData,
    GpRect *rect
    )
{
    GpStatus status = Ok;
    CopyOnWriteBitmap *dst = NULL;

    // If recolor exists, do color adjustment in a temporary bitmap.

    if (recolor)
    {
        PixelFormatID pixfmt;

        if (State >= MemBitmap)
        {
            // Bitmap has been decoded already

            pixfmt = PixelFormatInMem;
        }
        else
        {
            // Bitmap hasn't been decoded yet.  Let's make sure we
            // decode it in a good format to avoid an expensive format
            // conversion step later.

            pixfmt = SrcImageInfo.PixelFormat;
        }

        // If indexed, color adjust natively; otherwise,
        // convert to 32bpp ARGB and then do color adjust.

        if (!IsIndexedPixelFormat(pixfmt))
        {
            pixfmt = PIXFMT_32BPP_ARGB;
        }

        if (dstBitmap)
        {
            *dstBitmap = Clone(rect, pixfmt);
            dst = *dstBitmap;
        }
        else
        {
            dst = this;
            ConvertFormat(pixfmt, callback, callbackData);
        }

        if (dst)
        {
            if (callback && ((*callback)(callbackData)))
            {
                status = Aborted;
            }

            if (status == Ok)
            {
                status = dst->ColorAdjust(recolor, pixfmt,
                                          callback, callbackData);
            }
        }
        else
        {
            status = OutOfMemory;
        }
    }
    return status;
}// Recolor()

/**************************************************************************\
*
* Function Description:
*
*   ICM corrects from an embedded profile - if any - to SRGB and then
*   performs Recoloring.
*
* Arguments:
*
*   ImageAttributes contains the recolor object and the ICM on/off flag.
*
* Return Value:
*
*   The image is cloned and the operations performed on the clone.
*   The result is returned in dst.
*   NULL indicates that the operation didn't happen
*
\**************************************************************************/

/*GpStatus CopyOnWriteBitmap::RecolorAndICM(
    GpImageAttributes *imageAttributes,
    CopyOnWriteBitmap **dstBitmap,
    DrawImageAbort callback,
    VOID *callbackData,
    GpRect *rect
)
{
    GpStatus status = Ok;

    if(imageAttributes)
    {
        *dstBitmap = NULL;

        if(imageAttributes->DeviceImageAttributes.ICMMode)
        {

            status = ICMFrontEnd(
                dstBitmap, callback, callbackData, rect
            );

            if( (status == Ok) && (imageAttributes->recolor != NULL) )
            {
                status = (*dstBitmap)->ColorAdjust(
                    imageAttributes->recolor,
                    callback, callbackData
                );
            }
        }

        if(*dstBitmap == NULL)
        {
            status = Recolor(
                imageAttributes->recolor,
                dstBitmap, callback, callbackData, rect
            );
        }
    }
    return status;
}
*/




/**************************************************************************\
*
* Function Description:
*
*   Load an image from a file
*
* Arguments:
*
*   filename - Specifies the name of the image file
*
* Return Value:
*
*   Pointer to the newly loaded image object
*   NULL if there is an error
*
\**************************************************************************/

GpImage*
GpImage::LoadImage(
    const WCHAR* filename
    )
{
    // Try to create a metafile.
    // If we do, and the metafile is valid then return it
    // if the metafile isn't valid then create a bitmap
    GpMetafile* metafile = new GpMetafile(filename);
    if (metafile != NULL && !metafile->IsValid())
    {
        if (metafile->IsCorrupted())
        {
            metafile->Dispose();
            return NULL;
        }

        // Dispose of the bad metafile and try a Bitmap
        metafile->Dispose();

        GpImage* bitmap = new GpBitmap(filename);
        if (bitmap != NULL && !bitmap->IsValid())
        {
            bitmap->Dispose();
            return NULL;
        }
        else
        {
            return bitmap;
        }
    }
    else
    {
        return metafile;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Load an image from an input data stream
*
* Arguments:
*
*   stream - Specifies the input data stream
*
* Return Value:
*
*   Pointer to the newly loaded image object
*   NULL if there is an error
*
\**************************************************************************/

GpImage*
GpImage::LoadImage(
    IStream* stream
    )
{
    // See if the stream is a metafile
    GpMetafile* metafile = new GpMetafile(stream);
    if (metafile != NULL)
    {
        if (metafile->IsValid())
            return metafile;
        else
        {
            BOOL isCorrupted = metafile->IsCorrupted();
            metafile->Dispose();
            if (isCorrupted)
            {
                return NULL;
            }
        }
    }

    // it's not a valid metafile -- it must be a bitmap
    GpBitmap* bitmap = new GpBitmap(stream);

    return bitmap;
}


/**************************************************************************\
*
* Function Description:
*
*   Construct a bitmap image object from a file
*
* Arguments:
*
*   filename - Specifies the name of the bitmap image file
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

CopyOnWriteBitmap::CopyOnWriteBitmap(
    const WCHAR* filename
    )
{
    InitDefaults();
    Filename = UnicodeStringDuplicate(filename);

    if ( Filename != NULL )
    {
        State = ImageRef;
    }

    if ( DereferenceStream() == Ok )
    {
        ASSERT(Img != NULL);

        // Get source image info

        if ( Img->GetImageInfo(&SrcImageInfo) == S_OK )
        {
            return;
        }

        // If we can't do a GetImageInfo(), there must be something wrong
        // with this image. So we should release the DecodedImage object
        // and set the State to Invalid

        WARNING(("CopyOnWriteBitmap::CopyOnWriteBitmap(filename)---GetImageInfo() failed"));
        Img->Release();
        Img = NULL;
    }

    GpFree(Filename);
    Filename = NULL;

    State = Invalid;
}

/**************************************************************************\
*
* Function Description:
*
*   Construct a bitmap image object from a stream
*
* Arguments:
*
*   stream - Specifies the input data stream
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

CopyOnWriteBitmap::CopyOnWriteBitmap(
    IStream* stream
    )
{
    InitDefaults();

    Stream = stream;
    Stream->AddRef();
    State = ExtStream;

    if ( DereferenceStream() == Ok )
    {
        ASSERT(Img != NULL);

        // Get source image info

        if ( Img->GetImageInfo(&SrcImageInfo) == S_OK )
        {
            return;
        }

        // If we can't do a GetImageInfo(), there must be something wrong
        // with this image. So we should release the DecodedImage object
        // and set the State to Invalid

        WARNING(("CopyOnWriteBitmap::CopyOnWriteBitmap(stream)---GetImageInfo() failed"));

        Img->Release();
        Img = NULL;
    }

    Stream->Release();
    Stream = NULL;
    State = Invalid;
}

/**************************************************************************\
*
* Function Description:
*
*   Macro style function to save some common code in some constructors. The
*   main purpose of this method is to cache the image info structure
*
* Arguments:
*
*   hr - Specifies the return code from previous function call
*
* Return Value:
*
*   NONE
*
* Note:
*   Not an elegant method. Just for reducing code size
*
\**************************************************************************/

inline VOID
CopyOnWriteBitmap::CacheImageInfo(
    HRESULT hr
    )
{
    if ( SUCCEEDED(hr) )
    {
        // Fill image info structure

        if ( Bmp->GetImageInfo(&SrcImageInfo) == S_OK )
        {
            State = MemBitmap;
            PixelFormatInMem = SrcImageInfo.PixelFormat;

            return;
        }

        // There must be some problems if the basic GetImageInfo() failed.
        // So we let it fall through to clean up even though the previous
        // function succeed
        // Notice: we haven't change the State yet. It is still at Invaliad
    }

    WARNING(("CopyOnWriteBitmap::CopyOnWriteBitmap()----failed"));
    delete Bmp;
    Bmp = NULL;

    return;
}// CacheImageInfo()

/**************************************************************************\
*
* Function Description:
*
*   INTEROP
*
*   Derive a bitmap image from the given direct draw surface
*
* Arguments:
*
*   surface - Direct draw surface
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

CopyOnWriteBitmap::CopyOnWriteBitmap(
    IDirectDrawSurface7 * surface
    )
{
    InitDefaults();
    Bmp = new GpMemoryBitmap();

    if (!Bmp)
    {
        WARNING(("CopyOnWriteBitmap::CopyOnWriteBitmap(IDirectDrawSurface7)----Out of memory"));
        return;
    }

    HRESULT hr = Bmp->InitDirectDrawBitmap(surface);

    CacheImageInfo(hr);
}

/**************************************************************************\
*
* Function Description:
*
*   Create a bitmap image with the specified dimension and pixel format
*
* Arguments:
*
*   width, height - Desired bitmap image dimension
*   format - Desired pixel format
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

CopyOnWriteBitmap::CopyOnWriteBitmap(
    INT width,
    INT height,
    PixelFormatID format
    )
{
    InitDefaults();
    Bmp = new GpMemoryBitmap();

    if (!Bmp)
    {
        WARNING(("CopyOnWriteBitmap::GpBimap(w, h, p)---Out of memory"));
        return;
    }

    // Initialize the bitmap, clearing it (to opaque black).

    HRESULT hr = Bmp->InitNewBitmap(width, height, format, TRUE);

    CacheImageInfo(hr);
}

CopyOnWriteBitmap::CopyOnWriteBitmap(
    INT width,
    INT height,
    PixelFormatID format,
    GpGraphics * graphics
    )
{
    InitDefaults();
    Bmp = new GpMemoryBitmap();

    if (!Bmp)
    {
        WARNING(("CopyOnWriteBitmap::CopyOnWriteBitmap(w, h, f, g)----Out of memory"));
        return;
    }

    // Initialize the bitmap, clearing it (to opaque black).

    HRESULT hr = Bmp->InitNewBitmap(width, height, format, TRUE);

    if ( SUCCEEDED(hr) )
    {
        if ( Bmp->GetImageInfo(&SrcImageInfo) == S_OK )
        {
            REAL    dpiX = graphics->GetDpiX();
            REAL    dpiY = graphics->GetDpiY();

            // Note: SrcImageInfo will be updated for dpi in SetResolution()

            if ( this->SetResolution(dpiX, dpiY) == Ok )
            {
                this->Display = graphics->IsDisplay();
            }

            State = MemBitmap;
            PixelFormatInMem = SrcImageInfo.PixelFormat;

            return;
        }

        // There must be some problems if the basic GetImageInfo() failed. So we
        // let it fall through to clean up even though InitNewBitmap() succeed
        // Notice: we haven't change the State yet. It is still at Invaliad
    }

    WARNING(("CopyOnWriteBitmap::CopyOnWriteBitmap(w, h, f, g)---InitNewBitmap() failed"));
    delete Bmp;
    Bmp = NULL;

    return;
}

/**************************************************************************\
*
* Function Description:
*
*   Create a bitmap image with the specified dimension and pixel format
*
* Arguments:
*
*   width, height - Desired bitmap image dimension
*   format - Desired pixel format
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

CopyOnWriteBitmap::CopyOnWriteBitmap(
    INT width,
    INT height,
    INT stride,     // negative for bottom-up bitmaps
    PixelFormatID format,
    BYTE *  scan0
    )
{
    this->InitDefaults();
    Bmp = new GpMemoryBitmap();

    if (Bmp != NULL)
    {
        BitmapData      bmData;

        bmData.Width       = width;
        bmData.Height      = height;
        bmData.Stride      = stride;
        bmData.PixelFormat = format;
        bmData.Scan0       = scan0;
        bmData.Reserved    = NULL;

        HRESULT hr = Bmp->InitMemoryBitmap(&bmData);

        CacheImageInfo(hr);
    }
    else
    {
        WARNING(("CopyOnWriteBitmap::CopyOnWriteBitmap(w, h, s, f, scan)----Out of memory"));
    }
    return;
}

/**************************************************************************\
*
* Function Description:
*
*   Create an in-memory bitmap image
*
* Arguments:
*
*   membmp - [IN]Memory bitmap current object is based on
*
* Return Value:
*
*   NONE
*
* Note:
*   This is a private constructor
*
*   [minliu] It would be safer if this constructor did a Bmp->AddRef() and
*   the caller was required to do a Bmp->Release() during its own cleanup.
*   However, since we don't currently call Bmp->AddRef(), the caller MUST
*   be very careful not to delete/release the GpMemoryBitmap passed into
*   this contructor.  Fortunately, this this constructor is only
*   used in Clone() and GetThumbnail() and in each case the caller is
*   properly managing the objects.
*
*   New code which uses this contructor will similarly have to manage
*   the membmp passed in properly.
*
\**************************************************************************/
inline
CopyOnWriteBitmap::CopyOnWriteBitmap(
    GpMemoryBitmap* membmp
    )
{
    ASSERT(membmp != NULL);

    InitDefaults();
    Bmp = membmp;   // [minliu] Dangerous assignment, see header comments above

    if ( Bmp->GetImageInfo(&SrcImageInfo) == S_OK )
    {
        PixelFormatInMem = SrcImageInfo.PixelFormat;

        State = MemBitmap;
    }
    else
    {
        Bmp = NULL;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   INTEROP
*
*   Decode an RLE_8 bitmap into an 8bpp allocated bitmap.  This only works
*   for bitmaps with positive stride because the RLE stream doesn't necessarily
*   respect end of line tags, and we would otherwise need to keep track of it.
*   Caller must fix up in such cases.
*
* Arguments:
*
*   gdiBitmapInfo - Points to a BITMAPINFO, describing bitmap format
*   gdiBitmapData - Points to the bits used to initialize image
*   bitmapData----- Points to the BitmapData we return to the caller
*
* Comments:
*
*   10/13/2000 ericvan
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID *
DecodeCompressedRLEBitmap(
    BITMAPINFO *    gdiBitmapInfo,
    VOID *          gdiBitmapData,
    BitmapData *    bitmapData
)
{
    ASSERT(gdiBitmapInfo->bmiHeader.biCompression == BI_RLE8);
    ASSERT(gdiBitmapInfo->bmiHeader.biSizeImage>0);
    ASSERT(gdiBitmapData != NULL);

    BYTE* outputBitmap;
    INT stride = bitmapData->Stride;
    if (stride<0)
    {
        stride = -stride;
    }

    outputBitmap = (BYTE*)GpMalloc(stride*gdiBitmapInfo->bmiHeader.biHeight);

    if (outputBitmap != NULL)
    {
        BYTE * srcPtr = (BYTE*)gdiBitmapData;
        BYTE * endStrPtr = srcPtr + gdiBitmapInfo->bmiHeader.biSizeImage;
        BYTE * dstPtr = outputBitmap;
        BYTE * dstRasterPtr = outputBitmap;
        BYTE * endDstPtr = outputBitmap + stride*gdiBitmapInfo->bmiHeader.biHeight;

        while (srcPtr < endStrPtr)
        {
            INT numPixels = *srcPtr++;

            if (numPixels == 0)
            {
                BYTE encode = *srcPtr++;
                switch (encode)
                {
                case 0: // End of line.
                    dstRasterPtr += stride;
                    dstPtr = dstRasterPtr;

                    ASSERT(dstRasterPtr <= endDstPtr);
                    if (dstRasterPtr > endDstPtr)
                    {
                        GpFree(outputBitmap);
                        return NULL;
                    }
                    break;

                case 1: // End of bitmap.
                    goto FinishedDecode;

                case 2: // Delta.  The 2 bytes following the escape contain
                        // unsigned values indicating the horizontal and vertical
                        // offsets of the next pixel from the current position.
                    {
                        BYTE horzOff = *srcPtr++;
                        BYTE vertOff = *srcPtr++;

                        dstPtr = dstPtr + horzOff + vertOff*stride;
                        dstRasterPtr += vertOff*stride;

                        ASSERT(dstRasterPtr <= endDstPtr);
                        if (dstRasterPtr > endDstPtr)
                        {
                            GpFree(outputBitmap);
                            return NULL;
                        }

                        break;
                    }

                default:
                    numPixels = (INT)encode;

                    while (numPixels--)
                    {
                        *dstPtr++ = *srcPtr++;
                    }

                    // Force word alignment if not WORD aligned
                    if (((ULONG_PTR)srcPtr) % 2 == 1) srcPtr++;
                }
            }
            else
            {
                BYTE outPixel = *srcPtr++;

                while (numPixels--)
                {
                    *dstPtr++ = outPixel;
                }
            }
        }
    }

FinishedDecode:

    if (outputBitmap && bitmapData->Stride<0)
    {
        BYTE* flippedBitmap = (BYTE *)GpMalloc(stride*gdiBitmapInfo->bmiHeader.biHeight);

        if (flippedBitmap != NULL)
        {
            BYTE * srcPtr = outputBitmap + stride*(bitmapData->Height-1);
            BYTE * dstPtr = flippedBitmap;

            for (UINT cntY = 0; cntY<bitmapData->Height; cntY++)
            {
                GpMemcpy(dstPtr, srcPtr, stride);
                srcPtr -= stride;
                dstPtr += stride;
            }

            GpFree(outputBitmap);
            outputBitmap = flippedBitmap;
            bitmapData->Stride = stride;
        }
    }

    return outputBitmap;
}

/**************************************************************************\
*
* Function Description:
*
*   INTEROP
*
*   Create a bitmap image from a GDI-style BITMAPINFO and pointer to
*   the bits. Also, fill the ColorPalette info
*
* Arguments:
*
*   gdiBitmapInfo - Points to a BITMAPINFO, describing bitmap format
*   gdiBitmapData - Points to the bits used to initialize image
*   bitmapData----- Points to the BitmapData we return to the caller
*   palette-------- Points to a ColorPalette which will be filled in this method
*
* Comments:
*
*   Does not handle compressed formats.  Not identified as a customer need,
*   but could add for completeness...
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

BOOL
ValidateBitmapInfo(
    BITMAPINFO* gdiBitmapInfo,
    VOID* gdiBitmapData,
    BitmapData* bitmapData,
    ColorPalette* palette
    )
{
    BOOL status = FALSE;

    ASSERT(gdiBitmapInfo != NULL);
    ASSERT(gdiBitmapData != NULL);
    ASSERT(bitmapData != NULL);
    ASSERT(palette != NULL);

    // Only understand BI_RGB and BI_BITFIELDS.

    //!!!TODO: could handle BI_JPEG and BI_PNG by creating a GpMemoryStream
    //!!!      and passing to Bitmap::Bitmap(IStream*)

    //!!!TODO: could handle BI_RLEx by creating a DIB to render into and
    //!!!      grabbing the decompressed bits

    if ((gdiBitmapInfo->bmiHeader.biCompression != BI_RGB) &&
        (gdiBitmapInfo->bmiHeader.biCompression != BI_BITFIELDS) &&
        (gdiBitmapInfo->bmiHeader.biCompression != BI_RLE8))
    {
        return status;
    }

    // Scanlines are aligned to 4 byte boundaries.

    INT colorBits = gdiBitmapInfo->bmiHeader.biPlanes *
                    gdiBitmapInfo->bmiHeader.biBitCount;

    INT stride = (((gdiBitmapInfo->bmiHeader.biWidth * colorBits) + 31)
                  & ~31) / 8;

    // Determine GDI+ Pixelformat.  Note that GDI bitmaps do not have alpha.

    PixelFormatID format = PIXFMT_UNDEFINED;

    switch (colorBits)
    {
    case 1:

        format = PIXFMT_1BPP_INDEXED;
        break;

    case 4:

        format = PIXFMT_4BPP_INDEXED;
        break;

    case 8:

        format = PIXFMT_8BPP_INDEXED;
        break;

    case 16:

        if (gdiBitmapInfo->bmiHeader.biCompression == BI_RGB)
            format = PIXFMT_16BPP_RGB555;
        else
        {
            ASSERT(gdiBitmapInfo->bmiHeader.biCompression == BI_BITFIELDS);

            ULONG* colorMasks = reinterpret_cast<ULONG*>
                                (&gdiBitmapInfo->bmiColors[0]);

            if ((colorMasks[0] == 0x00007c00) &&        // red
                (colorMasks[1] == 0x000003e0) &&        // green
                (colorMasks[2] == 0x0000001f))          // blue
                format = PIXFMT_16BPP_RGB555;
            else if ((colorMasks[0] == 0x0000F800) &&   // red
                     (colorMasks[1] == 0x000007e0) &&   // green
                     (colorMasks[2] == 0x0000001f))     // blue
                format = PIXFMT_16BPP_RGB565;

            //!!!TODO: Win9x does not support any other combination for
            //!!!      16bpp BI_BITFIELDS.  WinNT does and we could support
            //!!!      via same mechanism as for BI_RLEx, but is it worth it?
        }
        break;

    case 24:

        format = PIXFMT_24BPP_RGB;
        break;

    case 32:

        if (gdiBitmapInfo->bmiHeader.biCompression == BI_RGB)
            format = PIXFMT_32BPP_RGB;
        else
        {
            ASSERT(gdiBitmapInfo->bmiHeader.biCompression == BI_BITFIELDS);

            ULONG* colorMasks = reinterpret_cast<ULONG*>
                                (&gdiBitmapInfo->bmiColors[0]);

            if ((colorMasks[0] == 0x00ff0000) &&        // red
                (colorMasks[1] == 0x0000ff00) &&        // green
                (colorMasks[2] == 0x000000ff))          // blue
                format = PIXFMT_32BPP_RGB;
            else
                format = PIXFMT_UNDEFINED;

            //!!!TODO: Win9x does not support any other combination for
            //!!!      32bpp BI_BITFIELDS.  WinNT does and we could support
            //!!!      via same mechanism as for BI_RLEx, but is it worth it?
        }
        break;

    default:

        format = PIXFMT_UNDEFINED;
        break;
    }

    if (format == PIXFMT_UNDEFINED)
        return status;

    // Deal with color table.

    switch(format)
    {
    case PIXFMT_1BPP_INDEXED:
    case PIXFMT_4BPP_INDEXED:
    case PIXFMT_8BPP_INDEXED:

        palette->Count = 1 << colorBits;

        if ((gdiBitmapInfo->bmiHeader.biClrUsed > 0) &&
            (gdiBitmapInfo->bmiHeader.biClrUsed < palette->Count))
            palette->Count = gdiBitmapInfo->bmiHeader.biClrUsed;

        break;

    default:

        palette->Count = 0;
        break;
    }

    ASSERT(palette->Count <= 256);
    if (palette->Count)
    {
        palette->Flags = 0;

        RGBQUAD* rgb = gdiBitmapInfo->bmiColors;
        ARGB* argb = palette->Entries;
        ARGB* argbEnd = argb + palette->Count;

        for (; argb < argbEnd; argb++, rgb++)
        {
            *argb = Color::MakeARGB(255, rgb->rgbRed, rgb->rgbGreen, rgb->rgbBlue);
        }
    }

    // Compute scan0.  The stride will allow us to determine top-down or
    // bottom-up.

    VOID* scan0;
    INT height;

    if (gdiBitmapInfo->bmiHeader.biHeight > 0)
    {
        // Bottom-up:

        height = gdiBitmapInfo->bmiHeader.biHeight;
        scan0  = static_cast<VOID*>
                 (static_cast<BYTE*>(gdiBitmapData) + (height - 1) * stride);
        stride = -stride;
    }
    else
    {
        // Top-down:

        height = -gdiBitmapInfo->bmiHeader.biHeight;
        scan0  = gdiBitmapData;
    }

    // Setup the BitmapData.

    bitmapData->Width       = gdiBitmapInfo->bmiHeader.biWidth;
    bitmapData->Height      = height;
    bitmapData->Stride      = stride;
    bitmapData->PixelFormat = format;
    bitmapData->Scan0       = scan0;
    bitmapData->Reserved    = NULL;

    status = TRUE;

    return status;
}

CopyOnWriteBitmap::CopyOnWriteBitmap(
    BITMAPINFO* gdiBitmapInfo,
    VOID*       gdiBitmapData,
    BOOL        ownBitmapData
    )
{
    this->InitDefaults();

    if ( ownBitmapData )
    {
        cleanupBitmapData = gdiBitmapData;
    }

    Bmp = new GpMemoryBitmap();

    if ( Bmp != NULL )
    {
        BitmapData bitmapData;
        UINT colorTableSize;
        BYTE paletteBuffer[sizeof(ColorPalette) + 255*sizeof(ARGB)];
        ColorPalette* palette = reinterpret_cast<ColorPalette*>
                                (&paletteBuffer[0]);

        // Validate image info
        // Note: "palette" and "bitmapData" structures will be filled after
        // return from ValidateBitmapInfo()

        if ( ValidateBitmapInfo(gdiBitmapInfo, gdiBitmapData,
                                &bitmapData, palette) )
        {
            HRESULT hr;

            if (gdiBitmapInfo->bmiHeader.biCompression == BI_RLE8)
            {
                VOID* decodedBitmapBits;

                decodedBitmapBits = DecodeCompressedRLEBitmap(gdiBitmapInfo,
                                                              gdiBitmapData,
                                                              &bitmapData);
                if (decodedBitmapBits == NULL)
                {
                    goto CleanupBmp;
                }

                if (ownBitmapData)
                {
                    GpFree(gdiBitmapData);
                }

                cleanupBitmapData = decodedBitmapBits;
                ownBitmapData = TRUE;
                bitmapData.Scan0 = cleanupBitmapData;
            }

            hr = Bmp->InitMemoryBitmap(&bitmapData);

            if ( SUCCEEDED(hr) )
            {
                // Set the current state

                State = MemBitmap;

                // If it is indexed mode, set the palette

                if ( palette->Count )
                {
                    hr = Bmp->SetPalette(palette);
                }

                if ( SUCCEEDED(hr) )
                {
                    // Set proper image flags

                    UINT imageFlags;
                    BITMAPINFOHEADER *bmih = &gdiBitmapInfo->bmiHeader;
                    imageFlags = SinkFlagsTopDown
                               | SinkFlagsFullWidth
                               | ImageFlagsHasRealPixelSize
                               | ImageFlagsColorSpaceRGB;

                    // If both XPelsPerMeter and YPelsPerMeter are greater than
                    // 0, then we claim that the file has real dpi info in the
                    // flags.  Otherwise, claim that the dpi's are fake.

                    if ( (bmih->biXPelsPerMeter > 0)
                       &&(bmih->biYPelsPerMeter > 0) )
                    {
                        imageFlags |= ImageFlagsHasRealDPI;
                    }

                    hr = Bmp->SetImageFlags(imageFlags);

                    if ( SUCCEEDED(hr) )
                    {
                        // Get source image info

                        hr = Bmp->GetImageInfo(&SrcImageInfo);
                        if ( SUCCEEDED(hr) )
                        {
                            PixelFormatInMem = SrcImageInfo.PixelFormat;

                            // Return successfully

                            return;
                        }
                        else
                        {
                            WARNING(("::CopyOnWriteBitmap(b, d)-GetImageInfo() failed"));
                        }
                    }
                }
            }// If ( SUCCEEDED() on InitMemoryBitmap() )

CleanupBmp:
            ;
        }// if ( ValidateBitmapInfo() )

        // If we fall into here, it means something is wrong above if the basic
        // GetImageInfo() or SetImageFlags() failed.
        // So we let it fall through to clean up
        // Notice: we have to reset the State to Invaliad afetr clean up

        WARNING(("CopyOnWriteBitmap::CopyOnWriteBitmap(bmpinfo, data)--InitMemoryBitmap failed"));
        Bmp->Release();
        Bmp = NULL;
        State = Invalid;

        return;
    }// If ( Bmp != NULL )

    WARNING(("Out of memory"));
    return;
}

/**************************************************************************\
*
* Function Description:
*
*   INTEROP
*
*   Create CopyOnWriteBitmap from a GDI HBITMAP.  The HBITMAP must not be selected
*   into an HDC.  The hpal defines the color table if hbm is a 4bpp or 8bpp
*   DDB.
*
* Arguments:
*
*   hbm -- Initialize CopyOnWriteBitmap with contents of this HBITMAP
*   hpal -- Defines color table if hbm is palettized DDB
*   bitmap -- Return created bitmap via this buffer
*
* Return Value:
*
*   Ok if successful
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::CreateFromHBITMAP(
    HBITMAP hbm,
    HPALETTE hpal,
    CopyOnWriteBitmap** bitmap
    )
{
    GpStatus status = Win32Error;

    BYTE bufferBitmapInfo[sizeof(BITMAPINFO) + 255*sizeof(RGBQUAD)];
    BITMAPINFO *gdiBitmapInfo = (BITMAPINFO *) bufferBitmapInfo;

    memset(bufferBitmapInfo, 0, sizeof(bufferBitmapInfo));

    HDC hdc = CreateCompatibleDC(NULL);
    if (hdc)
    {
        // Select palette (ignored if bitmap is not DDB or not palettized):

        HPALETTE hpalOld = (HPALETTE) SelectObject(hdc, hpal);

        // Call GetDIBits to get info about size, etc. of the GDI bitmap:

        gdiBitmapInfo->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);

        if (GetDIBits(hdc, hbm, 0, 0, NULL, gdiBitmapInfo, DIB_RGB_COLORS) &&
            (gdiBitmapInfo->bmiHeader.biSizeImage != 0))
        {
            // Allocate memory for the bitmap bits:

            VOID *gdiBitmapData = GpMalloc(gdiBitmapInfo->bmiHeader.biSizeImage);

            if (gdiBitmapData != NULL)
            {
                // Get the bitmap bits:

                if (GetDIBits(hdc, hbm,
                              0, abs(gdiBitmapInfo->bmiHeader.biHeight),
                              gdiBitmapData, gdiBitmapInfo, DIB_RGB_COLORS))
                {
                    // Create a GDI+ bitmap from the BITMAPINFO and bits.
                    // Let the GDI+ bitmap take ownership of the memory
                    // (i.e., Bitmap::Dispose() will delete the bitmap
                    // bits buffer):

                    *bitmap = new CopyOnWriteBitmap(gdiBitmapInfo, gdiBitmapData, TRUE);

                    if (*bitmap != NULL)
                    {
                        if ((*bitmap)->IsValid())
                            status = Ok;
                        else
                        {
                            (*bitmap)->Dispose();
                            *bitmap = NULL;
                            status = InvalidParameter;
                        }
                    }
                    else
                    {
                        // Bitmap ctor failed, so we still have responsiblity
                        // for cleaning up the bitmap bits buffer:

                        GpFree(gdiBitmapData);
                        status = OutOfMemory;
                    }
                }
                else
                {
                    GpFree(gdiBitmapData);
                }
            }
            else
            {
                status = OutOfMemory;
            }
        }

        SelectObject(hdc, hpalOld);
        DeleteDC(hdc);
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   INTEROP
*
*   Create CopyOnWriteBitmap from a Win32 HICON.
*
* Arguments:
*
*   hicon -- Initialize CopyOnWriteBitmap with contents of this HICON
*   bitmap -- Return created bitmap via this buffer
*
* Return Value:
*
*   Ok if successful
*
\**************************************************************************/

VOID ImportMask32BPP(BitmapData* dst, BitmapData* mask)
{
    ASSERT(dst->PixelFormat == PIXFMT_32BPP_ARGB);
    ASSERT(mask->PixelFormat == PIXFMT_32BPP_RGB);
    ASSERT(dst->Width == mask->Width);
    ASSERT(dst->Height == mask->Height);
    ASSERT(dst->Scan0 != NULL);
    ASSERT(mask->Scan0 != NULL);

    BYTE* dstScan = static_cast<BYTE*>(dst->Scan0);
    BYTE* maskScan = static_cast<BYTE*>(mask->Scan0);

    for (UINT row = 0; row < dst->Height; row++)
    {
        ARGB *dstPixel = static_cast<ARGB*>(static_cast<VOID*>(dstScan));
        ARGB *maskPixel = static_cast<ARGB*>(static_cast<VOID*>(maskScan));

        for (UINT col = 0; col < dst->Width; col++)
        {
            if (*maskPixel)
                *dstPixel = 0;

            dstPixel++;
            maskPixel++;
        }

        dstScan = dstScan + dst->Stride;
        maskScan = maskScan + mask->Stride;
    }
}

GpStatus
CopyOnWriteBitmap::CreateFromHICON(
    HICON hicon,
    CopyOnWriteBitmap** bitmap
    )
{
    GpStatus status = Ok;

    // Get icon bitmaps via Win32:

    ICONINFO iconInfo;

    if (GetIconInfo(hicon, &iconInfo))
    {
        if (iconInfo.fIcon && (iconInfo.hbmColor != NULL))
        {
            // Create a Bitmap from the icon's hbmColor:

            status = CreateFromHBITMAP(iconInfo.hbmColor,
                                       (HPALETTE)GetStockObject(DEFAULT_PALETTE),
                                       bitmap);

            // Convert Bitmap to 32bpp ARGB (need the alpha channel):

            if (status == Ok && (*bitmap != NULL))
                (*bitmap)->ConvertFormat(PIXFMT_32BPP_ARGB, NULL, NULL);

            // Retrieve the icon mask:

            if ((status == Ok) && (iconInfo.hbmMask != NULL))
            {
                status = Win32Error;

                HDC hdc = GetDC(NULL);

                if (hdc)
                {
                    // Get some basic information about the bitmap mask:

                    BYTE bufferBitmapInfo[sizeof(BITMAPINFO) + 255*sizeof(RGBQUAD)];
                    BITMAPINFO *gdiBitmapInfo = (BITMAPINFO *) bufferBitmapInfo;

                    memset(bufferBitmapInfo, 0, sizeof(bufferBitmapInfo));
                    gdiBitmapInfo->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);

                    if (GetDIBits(hdc,
                                  iconInfo.hbmMask,
                                  0,
                                  0,
                                  NULL,
                                  gdiBitmapInfo,
                                  DIB_RGB_COLORS))
                    {
                        // Get the bitmap mask as a 32bpp top-down DIB:

                        gdiBitmapInfo->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
                        gdiBitmapInfo->bmiHeader.biHeight = -abs(gdiBitmapInfo->bmiHeader.biHeight);
                        gdiBitmapInfo->bmiHeader.biPlanes       = 1;
                        gdiBitmapInfo->bmiHeader.biBitCount     = 32;
                        gdiBitmapInfo->bmiHeader.biCompression  = BI_RGB;
                        gdiBitmapInfo->bmiHeader.biSizeImage    = 0;
                        gdiBitmapInfo->bmiHeader.biClrUsed      = 0;
                        gdiBitmapInfo->bmiHeader.biClrImportant = 0;

                        VOID *gdiBitmapData = GpMalloc(gdiBitmapInfo->bmiHeader.biHeight
                                                       * gdiBitmapInfo->bmiHeader.biHeight
                                                       * 4);

                        if (gdiBitmapData != NULL)
                        {
                            if (GetDIBits(hdc,
                                          iconInfo.hbmMask,
                                          0,
                                          -gdiBitmapInfo->bmiHeader.biHeight,
                                          gdiBitmapData,
                                          gdiBitmapInfo,
                                          DIB_RGB_COLORS))
                            {
                                // Convert non-zero mask values to alpha = 0:

                                BitmapData bmpData;

                                status = (*bitmap)->LockBits(NULL,
                                                             IMGLOCK_READ|IMGLOCK_WRITE,
                                                             PIXFMT_32BPP_ARGB,
                                                             &bmpData);

                                if (status == Ok)
                                {
                                    BitmapData maskData;

                                    maskData.Width = gdiBitmapInfo->bmiHeader.biWidth;
                                    maskData.Height = -gdiBitmapInfo->bmiHeader.biHeight;
                                    maskData.Stride = gdiBitmapInfo->bmiHeader.biWidth * 4;
                                    maskData.PixelFormat = PIXFMT_32BPP_RGB;
                                    maskData.Scan0 = gdiBitmapData;
                                    maskData.Reserved = 0;

                                    ImportMask32BPP(&bmpData, &maskData);

                                    (*bitmap)->UnlockBits(&bmpData);
                                }
                            }
                            else
                            {
                                WARNING(("GetDIBits failed on icon mask bitmap"));
                            }

                            GpFree(gdiBitmapData);
                        }
                        else
                        {
                            WARNING(("memory allocation failed"));
                            status = OutOfMemory;
                        }
                    }
                    else
                    {
                        WARNING(("GetDIBits failed on icon color bitmap"));
                    }

                    ReleaseDC(NULL, hdc);
                }
            }
        }
        else
        {
            status = InvalidParameter;
        }

        if (iconInfo.hbmMask != NULL)
            DeleteObject(iconInfo.hbmMask);

        if (iconInfo.hbmColor != NULL)
            DeleteObject(iconInfo.hbmColor);
    }
    else
    {
        status = InvalidParameter;
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   INTEROP
*
*   Create CopyOnWriteBitmap from a resource.
*
* Arguments:
*
*   hInstance -- Specifies instance that contains resource
*   lpBitmapName -- Specifies resource name or ordinal
*   bitmap -- Return created bitmap via this buffer
*
* Return Value:
*
*   Ok if successful
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::CreateFromResource(
    HINSTANCE hInstance,
    LPWSTR lpBitmapName,
    CopyOnWriteBitmap** bitmap
    )
{
    GpStatus status = Ok;

    HBITMAP hbm = (HBITMAP) _LoadBitmap(hInstance, lpBitmapName);

    if (hbm)
    {
        status = CreateFromHBITMAP(hbm, (HPALETTE) NULL, bitmap);
        DeleteObject(hbm);
    }
    else
    {
        status = InvalidParameter;
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   CopyOnWriteBitmap object destructor
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

CopyOnWriteBitmap::~CopyOnWriteBitmap()
{
    this->FreeData();
    
    // Close the encoder object attached to this

    TerminateEncoder();    
}

VOID
CopyOnWriteBitmap::FreeData()
{
    GpFree(Filename);
    if (Stream) Stream->Release();
    if (Img) Img->Release();
    if (Bmp) Bmp->Release();
    if (InteropData.Hdc) DeleteDC(InteropData.Hdc);
    if (InteropData.Hbm) DeleteObject(InteropData.Hbm);
    if (cleanupBitmapData) GpFree(cleanupBitmapData);
}


/**************************************************************************\
*
* Function Description:
*
*   Dereferences the stream or filename image into a non-decoded image.
*
* Arguments:
*
*   format - Specifies the preferred pixel format
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::DereferenceStream() const
{
    HRESULT hr;

    if (State < DecodedImg)
    {
        ASSERT(Img == NULL);

        if (State == ExtStream)
        {
            ASSERT(Stream != NULL);
            hr = GpDecodedImage::CreateFromStream(Stream, &Img);
        }
        else
        {
            ASSERT(State == ImageRef && Filename != NULL);
            hr = GpDecodedImage::CreateFromFile(Filename, &Img);
        }

        if (FAILED(hr))
        {
            WARNING(("Failed to create decoded image: %x", hr));
            State = Invalid;
            return (MapHRESULTToGpStatus(hr));
        }

        State = DecodedImg;
    }

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Load the memory image into memory
*
* Arguments:
*
*   format - Specifies the preferred pixel format
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::LoadIntoMemory(
    PixelFormatID format,
    DrawImageAbort callback,
    VOID *callbackData,
    INT width,
    INT height
) const
{
    ASSERT(IsValid());

    if (State >= MemBitmap)
        return Ok;

    // Create decoded image object if necessary

    HRESULT hr;

    // Dereference the stream or file pointer and create an encoded image
    // object that can be decoded by the codec.
    // If the bitmap is already greater or equal to DecodedImg state, this
    // is a nop.

    GpStatus status = DereferenceStream();
    if ( status != Ok )
    {
        return status;
    }

    ASSERT(Img != NULL);

    if ( format == PixelFormatUndefined )
    {
        // If the caller doesn't care about the pixel format, then we load it
        // as the source image format

        format = SrcImageInfo.PixelFormat;
    }

    if ( ICMConvert == TRUE )
    {
        // Check if the OS supports ICM. We are doing this by checking if the
        // ICM dlls we need are available on the system or not.
        // Note: NT4 doesn't have ICM2 functionality. So the LoadICMDll() call
        // should fail
        // Note: LoadICMDll() is expensive only for the first time. If it has
        // already beed loaded, then it is a very small cost

        hr = LoadICMDll();
        if(SUCCEEDED(hr))
        {
            // We should let the codec know that we need the native data format
            // and we will do the conversion in ICMFrontEnd()
            
            BOOL    fUseICC = TRUE;
            hr = Img->SetDecoderParam(DECODER_USEICC, 1, &fUseICC);

            // Note: we don't need to check the return code of this call because
            // it just pass the info down to the codec. If the codec doesn't
            // support this. It is still fine

            // If the source is in CMYK color space and we need to do ICM
            // conversion, then we can't load the image in as 32PARGB. The reason
            // is that the lower lever codec will return CMYK in native format,
            // as we require it to. But if we ask
            // GpMemoryBitmap::CreateFromImage() to create a 32PARGB, then it
            // will do a format conversion and treat the C channel as ALPHA.
            // That's completely wrong.
            // So the solution here is to change the caller's requirement from
            // 32PARGB to 32ARGB, remember it. Load the image in as 32ARGB, call
            // ICMFrontEnd() to do the ICM conversion. Then before it is done,
            // change the format back to 32 PARGB
            // A complicated work around.  MinLiu (01/25/2001)

            if ( (format == PixelFormat32bppPARGB)
               &&(SrcImageInfo.Flags & IMGFLAG_COLORSPACE_CMYK) )
            {
                HasChangedRequiredPixelFormat = TRUE;
                format = PixelFormat32bppARGB;
            }
        }

        // If the OS doesn't support ICM, then we don't set DECODER_USEICC and
        // the codec will return RGB format to us
    }

    // Now load the image into memory

    ASSERT(Bmp == NULL);

    hr = GpMemoryBitmap::CreateFromImage(
        Img,
        width,
        height,
        format,
        InterpolationHintAveraging,
        &Bmp,
        callback,
        callbackData
    );

    if (FAILED(hr))
    {
        WARNING(("Failed to load image into memory: %x", hr));

        return MapHRESULTToGpStatus(hr);
    }

    // If resolution has been overridden, make sure GpMemoryBitmap is
    // consistent with the set value

    if ( (XDpiOverride > 0.0) && (YDpiOverride > 0.0) )
    {
        // Note: we don't need to check return code here since SetResolution()
        // will not fail if both parameters are > 0

        Bmp->SetResolution(XDpiOverride, YDpiOverride);
    }

    State = MemBitmap;

    // Remember pixel format in the memory

    PixelFormatInMem = format;

    // We must be in MemBitmap state otherwise ICMFrontEnd will call us
    // recursively.
    ASSERT((State == MemBitmap));

    // !!! ack - we have to call a huge chain of non-const stuff here from this
    // const function. This should be fixed by removing the const from this
    // function, but it's a pretty massive change.
    const_cast<CopyOnWriteBitmap *>(this)->ICMFrontEnd(NULL, callback, callbackData, NULL);

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Get the encoder parameter list size from an encoder object specified by
*   input clsid
*
* Arguments:
*
*   clsidEncoder - Specifies the encoder class ID
*   size---------- The size of the encoder parameter list
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   03/22/2000 minliu
*       Created it.
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::GetEncoderParameterListSize(
    CLSID* clsidEncoder,
    UINT*  size
    )
{
    ASSERT(IsValid());

    GpStatus status;

    HRESULT hResult;

    // If the image has a source and it is not dirty, we let the decoder
    // directly talk to the encoder

    if ( (Img != NULL) && (IsDirty() == FALSE) )
    {
        hResult = Img->GetEncoderParameterListSize(clsidEncoder, size);
    }
    else
    {
        status = LoadIntoMemory();

        if ( status != Ok )
        {
            return status;
        }

        hResult = Bmp->GetEncoderParameterListSize(clsidEncoder, size);
    }

    return MapHRESULTToGpStatus(hResult);
}// GetEncoderParameterListSize()

/**************************************************************************\
*
* Function Description:
*
*   Get the encoder parameter list from an encoder object specified by
*   input clsid
*
* Arguments:
*
*   clsidEncoder --- Specifies the encoder class ID
*   size------------ The size of the encoder parameter list
*   pBuffer--------- Buffer for storing the list
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   03/22/2000 minliu
*       Created it.
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::GetEncoderParameterList(
    CLSID* clsidEncoder,
    UINT  size,
    EncoderParameters* pBuffer
    )
{
    ASSERT(IsValid());

    GpStatus status;
    HRESULT hResult;

    // If the image has a source and it is not dirty, we let the decoder
    // directly talk to the encoder

    if ( (Img != NULL) && (IsDirty() == FALSE) )
    {
        hResult = Img->GetEncoderParameterList(clsidEncoder, size, pBuffer);
    }
    else
    {
        status = LoadIntoMemory();

        if ( status != Ok )
        {
            return status;
        }

        hResult = Bmp->GetEncoderParameterList(clsidEncoder, size, pBuffer);
    }

    return MapHRESULTToGpStatus(hResult);
}// GetEncoderParameterList()

/**************************************************************************\
*
* Function Description:
*
*   Parse the input encoder parameter
*
* Arguments:
*
*   encoderParams ------ Pointer to a set of encoder parameters
*   pbIsMultiFrameSave--Return flag to tell the caller if this is a multi-frame
*                       saving operation or not
*
* Return Value:
*
*   Status code
*
* Note:
*   We don't validate input parameter because this is a private function.
*   For performance reason the caller should validate the parameter before it
*   calls this function. For the moment only those saving methods call it
*
* Revision History:
*
*   07/19/2000 minliu
*       Created it.
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::ParseEncoderParameter(
    const EncoderParameters*    encoderParams,
    BOOL*                       pfIsMultiFrameSave,
    BOOL*                       pfSpecialJPEG,
    RotateFlipType*             rfType
    )
{
    ASSERT(encoderParams != NULL);
    ASSERT(pfIsMultiFrameSave != NULL);
    ASSERT(pfSpecialJPEG != NULL);
    ASSERT(rfType != NULL);

    *pfIsMultiFrameSave = FALSE;
    *pfSpecialJPEG = FALSE;
    *rfType = RotateNoneFlipNone;

    // Parse the encoder parameter caller set for:
    // 1) Check if the caller has specified this is a multi-frame save OP or not
    // 2) The caller can't set lossless transformation for JPEG if the image is
    //    dirty or the image size is not multiple of 16

    for ( UINT i = 0; (i < encoderParams->Count); ++i )
    {
        if ( (encoderParams->Parameter[i].Guid == ENCODER_SAVE_FLAG)
             &&(encoderParams->Parameter[i].Type == EncoderParameterValueTypeLong)
             &&(encoderParams->Parameter[i].NumberOfValues == 1) )
        {
            UINT*   pValue = (UINT*)encoderParams->Parameter[i].Value;

            if ( *pValue == EncoderValueMultiFrame )
            {
                *pfIsMultiFrameSave = TRUE;
            }
        }
        else if ( encoderParams->Parameter[i].Guid == ENCODER_TRANSFORMATION )
        {
            // We should check if the image format user wants to save is
            // JPEG or not. But we can't do this since it might possible that
            // other image codec supports "transformation". Also, we don't need
            // to check this now since the codec will return "InvalidParameter"
            // if it doesn't supports it.
            //
            // For transformation, the type has to be "ValueTypeLong" and
            // "NumberOfValue" should be "1" because you can set only one
            // transformation at a time
            // Of course, the image has to be not dirty

            if ( (encoderParams->Parameter[i].Type
                   != EncoderParameterValueTypeLong)
               ||(encoderParams->Parameter[i].NumberOfValues != 1)
               ||(encoderParams->Parameter[i].Value == NULL)
               ||(IsDirty() == TRUE) )
            {
                WARNING(("COWBmap::ParseEncoderParameter-invalid input args"));
                return InvalidParameter;
            }

            if (SrcImageInfo.RawDataFormat == IMGFMT_JPEG)
            {
                // If the width or height is not multiple of 16, set it as a
                // special JPEG so that we have to tranform it in memory

                if (((SrcImageInfo.Width & 0x000F) != 0) ||
                    ((SrcImageInfo.Height & 0x000F) != 0))
                {
                    *pfSpecialJPEG = TRUE;
                }

                // If the source is JPEG, we will return "rfType" according to
                // the encoder parameter

                EncoderValue requiredTransform =
                           *((EncoderValue*)encoderParams->Parameter[i].Value);

                switch ( requiredTransform )
                {
                case EncoderValueTransformRotate90:
                    *rfType = Rotate90FlipNone;
                    break;

                case EncoderValueTransformRotate180:
                    *rfType = Rotate180FlipNone;
                    break;

                case EncoderValueTransformRotate270:
                    *rfType = Rotate270FlipNone;
                    break;

                case EncoderValueTransformFlipHorizontal:
                    *rfType = RotateNoneFlipX;
                    break;

                case EncoderValueTransformFlipVertical:
                    *rfType = RotateNoneFlipY;
                    break;

                default:
                    break;
                }
            }
        }// GUID == ENCODER_TRANSFORMATION
    }// Loop all the settings

    return Ok;
}// ParseEncoderParameter()

/**************************************************************************\
*
* Function Description:
*
*   Transform embedded JPEG thumbnail so that it matches the transform applied
*   to the main image.
*
* Return Value:
*
*   Status code
*
* Note:
*   This function should be called iff and source image is JPEG and the caller
*   wants to do a lossless transformation during save.
*   Of course, if the source is not JPEG, this function won't do any harm to the
*   result, just waste of time.
*
* Revision History:
*
*   01/10/2002 minliu
*       Created it.
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::TransformThumbanil(
    IN CLSID* clsidEncoder,                 // CLSID for Destination format
    IN EncoderParameters* encoderParams,    // Encoder parameters
    OUT PropertyItem **ppOriginalItem       // Pointer to original thumbnail
                                            // property item
    )
{
    if (ppOriginalItem == NULL)
    {
        return InvalidParameter;
    }

    if (NULL == encoderParams)
    {
        // Nothing we need to do

        return Ok;
    }

    *ppOriginalItem = NULL;

    Status status = Ok;
    HRESULT hr = S_OK;

    // The condition to transform the thumbnail are:
    // 1) Source and dest are JPEGs. But we can't check the format here since it
    //    might have been transformed in memory due to the non-multiple of 16
    //    issue. The caller should control this, as said above.
    // 2) Has a meaningful transform type

    if (*clsidEncoder == InternalJpegClsID)
    {
        // Check if the source has thumbnail

        UINT cSize = 0;
        status = GetPropertyItemSize(PropertyTagThumbnailData, &cSize);
        if (Ok == status)
        {
            // Allocate memory buffer for receiving it

            PropertyItem *pItem = (PropertyItem*)GpMalloc(cSize);
            if (pItem)
            {
                // Get the thumbnail data

                status = GetPropertyItem(PropertyTagThumbnailData, cSize,pItem);
                if (Ok == status)
                {
                    GpImagingFactory imgFact;
                    GpDecodedImage *pThumbImage = NULL;
                    GpReadOnlyMemoryStream *pSrcStream =
                        new GpReadOnlyMemoryStream();

                    if (pSrcStream)
                    {
                        pSrcStream->InitBuffer(pItem->value, pItem->length);

                        // Create a decoded image object from the stream

                        hr = GpDecodedImage::CreateFromStream(
                            pSrcStream,
                            &pThumbImage
                            );

                        if (SUCCEEDED(hr))
                        {
                            // Check the thumbnail size to see if it is multiple
                            // of 16 or not

                            ImageInfo imgInfo;
                            hr = pThumbImage->GetImageInfo(&imgInfo);

                            if (SUCCEEDED(hr))
                            {
                                BOOL fTrimEdge = FALSE;

                                // Number of encoder parameters to set

                                int cParams = 1;

                                if (((imgInfo.Width & 0x000F) != 0) ||
                                    ((imgInfo.Height & 0x000F) != 0))
                                {
                                    // Do edge trim if it is non-multiple of 16

                                    fTrimEdge = TRUE;
                                    cParams++;
                                }

                                // Parameter index

                                int iParam = 0;

                                // Make up a transform encoder parameter

                                EncoderParameters *pThumbParam =
                                    (EncoderParameters*)GpMalloc(
                                        sizeof(EncoderParameters) +
                                        cParams * sizeof(EncoderParameter));
                                UINT uTransformType = 0;

                                if (pThumbParam)
                                {
                                    // Get the transform info from the main
                                    // image's encoder parameter

                                    for (UINT i = 0; i < (encoderParams->Count);
                                         ++i)
                                    {
                                        if (encoderParams->Parameter[i].Guid ==
                                            ENCODER_TRANSFORMATION)
                                        {
                                 pThumbParam->Parameter[iParam].Guid=
                                                ENCODER_TRANSFORMATION;
                                 pThumbParam->Parameter[iParam].NumberOfValues =
                                    encoderParams->Parameter[i].NumberOfValues;
                                            pThumbParam->Parameter[iParam].Type=
                                    encoderParams->Parameter[i].Type;

                                            uTransformType =
                                    *((UINT*)encoderParams->Parameter[i].Value);
                                 pThumbParam->Parameter[iParam].Value =
                                     &uTransformType;
                                            
                                            iParam++;

                                            // Only one transform parameter is
                                            // allowed

                                            break;
                                        }
                                    }

                                    // Set the trim edge info if necessary

                                    if (fTrimEdge)
                                    {
                                        BOOL trimFlag = TRUE;

                                        pThumbParam->Parameter[iParam].Guid =
                                            ENCODER_TRIMEDGE;
                                        pThumbParam->Parameter[iParam].Type =
                                            EncoderParameterValueTypeByte;
                                   pThumbParam->Parameter[iParam].NumberOfValues
                                        = 1;
                               pThumbParam->Parameter[iParam].Value = &trimFlag;
                                        iParam++;
                                    }

                                    pThumbParam->Count = iParam;

                                    // Create a memory stream for writing JPEG

                                    GpWriteOnlyMemoryStream *pDestStream =
                                        new GpWriteOnlyMemoryStream();
                                    if (pDestStream)
                                    {
                                        // Set initiali buffer size to 2 times
                                        // the source thumbnail image. This
                                        // should be enough. On the other hand,
                                        // GpWriteOnlyMemoryStream object will
                                        // do realloc if necessary

                                        hr = pDestStream->InitBuffer(
                                            2 * pItem->length);

                                        if (SUCCEEDED(hr))
                                        {
                                            // Save thumbnail to memory stream

                                            IImageEncoder *pDstJpegEncoder =
                                                NULL;
                                            hr = pThumbImage->SaveToStream(
                                                pDestStream,
                                                clsidEncoder,
                                                pThumbParam,
                                                &pDstJpegEncoder
                                                );

                                            // Note: SaveToStream might fail.
                                            // But the encoder might still be
                                            // allocated before the failure.
                                            // There are some  code path
                                            // limitations which causes this.
                                            // Need to be revisited in Avalon.
                                            // For now, we should release the
                                            // encoder object if it is not NULL

                                            if (pDstJpegEncoder)
                                            {
                                            pDstJpegEncoder->TerminateEncoder();
                                                pDstJpegEncoder->Release();
                                            }

                                            if (SUCCEEDED(hr))
                                            {
                                                // Get the bits from the stream
                                                // and set the property

                                                BYTE *pRawBits = NULL;
                                                UINT nLength = 0;

                                                hr = pDestStream->GetBitsPtr(
                                                    &pRawBits,
                                                    &nLength
                                                    );

                                                if (SUCCEEDED(hr))
                                                {
                                                    PropertyItem dstItem;
                                                    
                                                    dstItem.id =
                                                       PropertyTagThumbnailData;
                                                    dstItem.length = nLength;
                                                    dstItem.type =
                                                       PropertyTagTypeByte;
                                                    dstItem.value = pRawBits;

                                                    status = SetPropertyItem(
                                                        &dstItem);
                                                }
                                            }// SaveToStream succeed
                                        }// InitBuffer() succeed

                                        pDestStream->Release();
                                    }// Create GpWriteOnlyMemoryStream() succeed

                                    GpFree(pThumbParam);
                                }// Allocate a encoder parameter block succeed
                            }// GetImageInfo succeed

                            pThumbImage->Release();
                        }// Create thumbImage succeed

                        pSrcStream->Release();
                    }// Create source stream
                    else
                    {
                        status = OutOfMemory;
                    }
                }// Get thumbnail data

                if ((Ok == status) && SUCCEEDED(hr))
                {
                    // Pass the original thumbnail property item to the caller
                    // so that it can undo the transformation after the save()

                    *ppOriginalItem = pItem;
                }
                else
                {
                    GpFree(pItem);
                }
            }// GpMalloc() succeed
            else
            {
                status = OutOfMemory;
            }
        }// GetPropertyItemSize() Ok

        if (PropertyNotFound == status)
        {
            // If we can't find thumbnail in the image, that's OK. We don't need
            // to transform it. So this function should return Ok

            status = Ok;
        }
    }// Condition check

    if ((Ok == status) && FAILED(hr))
    {
        status = MapHRESULTToGpStatus(hr);
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Validate if the encoder we created can really support multi-frame saving.
*   If not, call TerminateEncoder()
*   This method is called after we saved the image and we are not sure if we
*   need to keep the encoder pointer.
*
* Arguments:
*
*   VOID
*
* Return Value:
*
*   Status code
*
* Note:
*   We don't validate input parameter because this is a private function.
*   For performance reason the caller should validate the parameter before it
*   calls this method. For the moment only those saving methods call it
*
* Revision History:
*
*   07/19/2000 minliu
*       Created it.
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::ValidateMultiFrameSave()
{
    // Though the user sets the encoder parameter for multi-frame save, we
    // still need to check if the lower level codec supports saving multi-
    // frame or not.
    // The reason we need to do this is that if the user sets this flag, we
    // don't close the image file handle so that it can saving multi-frame.
    // But for images like JPEG, it supports only single frame. If the user
    // calls SaveAdd() subsequently, we will damage the file which has been
    // saved with current Save() call

    ASSERT(EncoderPtr != NULL);

    UINT    uiSize;
    HRESULT hResult = EncoderPtr->GetEncoderParameterListSize(&uiSize);

    if ( hResult == S_OK )
    {
        EncoderParameters*  pParams = (EncoderParameters*)GpMalloc(uiSize);

        if ( pParams == NULL )
        {
            // Though we are out of memory here. But we succeed in saving
            // the image. So we should keep that result

            WARNING(("CopyOnWriteBitmap::ValidateMultiFrameSave---Out of memory"));
            TerminateEncoder();

            return OutOfMemory;
        }

        hResult = EncoderPtr->GetEncoderParameterList(uiSize, pParams);
        if ( hResult == S_OK )
        {
            // Check if the codec supports multi-frame save or not

            UINT uiTemp;

            for ( uiTemp = 0; (uiTemp < pParams->Count); ++uiTemp )
            {
                if ( (pParams->Parameter[uiTemp].Guid == ENCODER_SAVE_FLAG)
                   &&(pParams->Parameter[uiTemp].Type == EncoderParameterValueTypeLong)
                   &&(pParams->Parameter[uiTemp].NumberOfValues == 1)
                   &&(EncoderValueMultiFrame
                        == *((ULONG*)pParams->Parameter[uiTemp].Value) ) )
                {
                    break;
                }
            }

            if ( uiTemp == pParams->Count )
            {
                // Not found clue for supporting multi-frame save

                TerminateEncoder();
            }
        }

        GpFree(pParams);
    }
    else
    {
        // This encoder doesn't provide encoder parameter query. It mustn't
        // support multi-frame save

        TerminateEncoder();
    }

    return Ok;
}// ValidateFrameSave()

/**************************************************************************\
*
* Function Description:
*
*   Save the image to a stream using the specified encoder
*
* Arguments:
*
*   stream - Specifies the target stream
*   clsidEncoder - Specifies the CLSID of the encoder
*   encoderParams - Parameters passed to the encoder
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::SaveToStream(
    IStream* stream,
    CLSID* clsidEncoder,
    EncoderParameters* encoderParams
    )
{
    return DoSave(stream, NULL, clsidEncoder, encoderParams);
}// SaveToStream()

/**************************************************************************\
*
* Function Description:
*
*   Save the image to a file using the specified encoder
*
* Arguments:
*
*   stream - Specifies the filename to save to
*   clsidEncoder - Specifies the CLSID of the encoder
*   encoderParams - Parameters passed to the encoder
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::SaveToFile(
    const WCHAR* filename,
    CLSID* clsidEncoder,
    EncoderParameters* encoderParams
    )
{
    return DoSave(NULL,filename,clsidEncoder,encoderParams);
}// SaveToFile()

GpStatus
CopyOnWriteBitmap::DoSave(
    IStream* stream,
    const WCHAR* filename,
    CLSID* clsidEncoder,
    EncoderParameters* pEncoderParams
    )
{
    ASSERT(IsValid());

    // We already have an encoder attached to this bitmap. Need to close it
    // first before we open a new one

    TerminateEncoder();

    GpStatus status = Ok;
    HRESULT hr = S_OK;

    BOOL fMultiFrameSave = FALSE;
    BOOL fSpecialJPEG = FALSE;
    RotateFlipType  rfType = RotateNoneFlipNone;

    if (pEncoderParams)
    {
        // Validate the encoder parameter caller set

        status = ParseEncoderParameter(
            pEncoderParams,
            &fMultiFrameSave,
            &fSpecialJPEG,
            &rfType
            );

        if (status != Ok)
        {
            WARNING(("CopyOnWriteBitmap::DoSave--ParseEncoderParameter() failed"));
            return status;
        }
    }

    // If the destination file format is JPEG and it needs special JPEG
    // treatment, that is, the size doesn't meet the lossless transformation
    // requirement. But the caller wants to do a lossless transformation. So we
    // rotate or flip it in memory. Then pass this flag down to GpMemoryBitmap
    // which will set the luminance and chrominance table before save. This way
    // we can do our best to preserve the original JPEG image quality

    if ((fSpecialJPEG == TRUE) &&
        (rfType != RotateNoneFlipNone) &&
        (*clsidEncoder == InternalJpegClsID))
    {
        // We are handling special lossless JPEG transform saving request

        SpecialJPEGSave = TRUE;

        // Rotate or flip in memory.

        hr = RotateFlip(rfType);

        if (FAILED(hr))
        {
            WARNING(("CopyOnWriteBitmap::DoSave-RotateFlip() failed"));
            return MapHRESULTToGpStatus(hr);
        }
    }

    // If the image has a source and it is not dirty, we let the decoder
    // directly talk to the encoder

    PropertyItem *pSrcItem = NULL;
    BOOL fNeedToRestoreThumb = FALSE;

    if ((Img != NULL) && (IsDirty() == FALSE))
    {
        // Since we can't save CMYK TIFF for now. So we shouldn't pass CMYK bits
        // to the encoder. JPEG decoder doesn't support this decoder parameter
        // yet. See windows bug#375298 for more details.
        // In V2, after we add CMYK as one of the color format, after we move
        // all the color conversion stuff to an approprite place, we will
        // re-visit the code here.

        BOOL fUseICC = FALSE;
        hr = Img->SetDecoderParam(DECODER_USEICC, 1, &fUseICC);

        // Note: we don't need to check the return code for SetDecoderParam()
        // Most codec not support it. Then it will be a Nop.
        
        // Handle thumbnail transformation if it is lossless JPEG transformation
        // Note: rfType will be set to a non-RotateNoneFlipNone value iff the
        // source image is JPEG

        if (rfType != RotateNoneFlipNone)
        {
            status = TransformThumbanil(clsidEncoder,pEncoderParams, &pSrcItem);
        }

        if (Ok == status)
        {
            fNeedToRestoreThumb = TRUE;

            if (stream)
            {
                hr = Img->SaveToStream(
                    stream,
                    clsidEncoder,
                    pEncoderParams,
                    &EncoderPtr
                    );
            }
            else if (filename)
            {
                hr = Img->SaveToFile(
                    filename,
                    clsidEncoder,
                    pEncoderParams,
                    &EncoderPtr
                    );
            }
            else
            {
                // This should not happen that both stream and filename are NULL

                hr = E_FAIL;
            }
        }
    }
    else
    {
        status = LoadIntoMemory();

        if (status != Ok)
        {
            return status;
        }

        EncoderParameters *pNewParam = pEncoderParams;
        BOOL fFreeExtraParamBlock = FALSE;

        // PAY attention to the scope of "fSuppressAPP0". Its address is used as
        // parameter passed into Save() call below. So this variable can't be
        // destroyed before the save() is called.

        BOOL fSuppressAPP0 = TRUE;

        if (fSpecialJPEG == TRUE)
        {
            // We are in a situation that the caller asks us to do a lossless
            // transformation. Due to the size limitation, we have to
            // transform it in memory.
            // Since it is not correct to save APP0 in a Exif file. So we check
            // if the source is Exif, then we suppress APP0 header

            int cParams = 1;

            pNewParam = (EncoderParameters*)GpMalloc(
                sizeof(EncoderParameters) +
                cParams * sizeof(EncoderParameter));

            if (pNewParam)
            {
                // Set the Suppress APP0 parameter

                pNewParam->Parameter[cParams - 1].Guid = ENCODER_SUPPRESSAPP0;
                pNewParam->Parameter[cParams - 1].NumberOfValues = 1;
                pNewParam->Parameter[cParams - 1].Type = TAG_TYPE_BYTE;
                pNewParam->Parameter[cParams - 1].Value = (VOID*)&fSuppressAPP0;

                pNewParam->Count = cParams;
                
                // Set the flag to TRUE so that we can free it later

                fFreeExtraParamBlock = TRUE;
                
                // Handle thumbnail transformation if it is lossless
                // transformation

                if (rfType != RotateNoneFlipNone)
                {
                    status = TransformThumbanil(
                        clsidEncoder,
                        pEncoderParams,
                        &pSrcItem
                        );

                    if (Ok == status)
                    {
                        fNeedToRestoreThumb = TRUE;
                    }
                }
            }
            else
            {
                status = OutOfMemory;
            }
        }// Special JPEG case

        if (SUCCEEDED(hr) && (Ok == status))
        {
            // Determine how should we pass the GpDecodedImage pointer down to
            // the save() call. If we are handling special lossless transform,
            // we know that we have RotateFlip() the image in memory, so we
            // should not pass any GpDecodedImage info down, just pass NULL.
            // Otherwise, pass the pointer to GpDecodedImage down.

            GpDecodedImage *pSrc = Img;
            if (SpecialJPEGSave == TRUE)
            {
                pSrc = NULL;
            }

            if (stream)
            {
                hr = Bmp->SaveToStream(
                    stream,
                    clsidEncoder,
                    pNewParam,
                    fSpecialJPEG,
                    &EncoderPtr,
                    pSrc
                    );
            }
            else if (filename)
            {
                hr = Bmp->SaveToFile(
                    filename,
                    clsidEncoder,
                    pNewParam,
                    fSpecialJPEG,
                    &EncoderPtr,
                    pSrc
                    );
            }
            else
            {
                // This should not happen that both stream and filename are NULL

                hr = E_FAIL;
            }
        }

        // When we handle the special lossless transform request, we rotate/flip
        // the image in memory. The Img pointer should be released when
        // RotateFlip() is done. But we couldn't do that since Save() function
        // in JPEG encoder needs to get all the private APP headers from the
        // source image. So we delay the release for the Img pointer until the
        // save() is done.

        if (Img && (SpecialJPEGSave == TRUE))
        {
            Img->Release();
            Img = NULL;
            SpecialJPEGSave = FALSE;
        }

        if (fFreeExtraParamBlock && pNewParam)
        {
            GpFree(pNewParam);
        }
    }

    if ((TRUE == fNeedToRestoreThumb) && pSrcItem)
    {
        // If pSrcIetm is not NULL, it means we have transformed the thumbnail
        // of current image. Restore the original thumbnail info

        status = SetPropertyItem(pSrcItem);
        GpFree(pSrcItem);
    }
    
    if (FAILED(hr))
    {
        // If SaveToFile/Stream() filed, we should terminate the encoder
        // immediately.
        // We don't need to check if it is multi-frame save or not.

        TerminateEncoder();
        return MapHRESULTToGpStatus(hr);
    }

    // If it is a single frame save OP, close the encoder

    if (fMultiFrameSave == FALSE)
    {
        TerminateEncoder();
    }
    else
    {
        // The caller set the multi-frame save flag in encoder parameter. But
        // we still need to check if the encoder really supports it. If not,
        // the encoder will be closed in ValidateMultiFrameSave()

        ValidateMultiFrameSave();
    }

    return status;
}// DoSave()

/**************************************************************************\
*
* Function Description:
*
* Append current frame to current encoder object
*
* Arguments:
*
*   encoderParams - Encoder parameters
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   04/21/2000 minliu
*       Created it.
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::SaveAdd(
    const EncoderParameters* encoderParams
    )
{
    // Caller has to call Save() first to establish the encoder object

    if ( EncoderPtr == NULL )
    {
        WARNING(("CopyOnWriteBitmap::SaveAdd---Caller hasn't call Save() yet"));
        return Win32Error;
    }

    // We don't need to check if encoderParams is NULL or not because it has
    // been checked in flatapi.cpp

    ASSERT(encoderParams != NULL);
    ASSERT(IsValid());

    BOOL bLastFrame = FALSE;
    BOOL bSetFrameDimension = FALSE;
    GUID tempGuid;

    // Check if the caller has specified this is the last frame or a flush OP
    // Also, according to spec, the caller also has to specify the type of
    // dimension for next frame

    for ( UINT i = 0; (i < encoderParams->Count); ++i )
    {
        if ( (encoderParams->Parameter[i].Guid == ENCODER_SAVE_FLAG )
           &&(encoderParams->Parameter[i].Type == EncoderParameterValueTypeLong)
           &&(encoderParams->Parameter[i].NumberOfValues == 1) )
        {
            UINT   ulValue = *((UINT*)(encoderParams->Parameter[i].Value));

            if ( ulValue == EncoderValueLastFrame )
            {
                bLastFrame = TRUE;
            }
            else if ( ulValue == EncoderValueFlush )
            {
                // The caller just wants to close the file

                TerminateEncoder();

                return Ok;
            }
            else if ( ulValue == EncoderValueFrameDimensionPage )
            {
                tempGuid = FRAMEDIM_PAGE;
                bSetFrameDimension = TRUE;
            }
            else if ( ulValue == EncoderValueFrameDimensionTime )
            {
                tempGuid = FRAMEDIM_TIME;
                bSetFrameDimension = TRUE;
            }
            else if ( ulValue == EncoderValueFrameDimensionResolution )
            {
                tempGuid = FRAMEDIM_RESOLUTION;
                bSetFrameDimension = TRUE;
            }
        }
    }// Loop all the settings

    HRESULT hResult = S_OK;
    GpStatus status;

    if ( bSetFrameDimension == FALSE )
    {
        WARNING(("CopyOnWriteBitmap::SaveAdd---Caller doesn't set frame dimension"));
        return InvalidParameter;
    }
    else
    {
        hResult = EncoderPtr->SetFrameDimension(&tempGuid);
        if ( FAILED(hResult) )
        {
            return MapHRESULTToGpStatus(hResult);
        }
    }

    // If the image has a source and it is not dirty, we let the decoder
    // directly talk to the encoder

    if ( (Img != NULL) && (IsDirty() == FALSE) )
    {
        hResult = Img->SaveAppend(encoderParams, EncoderPtr);
    }
    else
    {
        status = LoadIntoMemory();

        if ( status != Ok )
        {
            return status;
        }

        hResult = Bmp->SaveAppend(encoderParams, EncoderPtr, Img);
    }

    if ( FAILED(hResult) )
    {
        return MapHRESULTToGpStatus(hResult);
    }

    // If it is the last frame, close the encoder

    if ( bLastFrame == TRUE )
    {
        TerminateEncoder();
    }

    return Ok;
}// SaveAdd()

/**************************************************************************\
*
* Function Description:
*
* Append the bitmap object(newBits) to current encoder object
*
* Arguments:
*
*   newBits-------- Image object to be appended
*   encoderParams - Encoder parameters
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   04/21/2000 minliu
*       Created it.
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::SaveAdd(
    CopyOnWriteBitmap*        newBits,
    const EncoderParameters*  encoderParams
    )
{
    // Caller has to call Save() first to establish the encoder object

    if ( EncoderPtr == NULL )
    {
        WARNING(("CopyOnWriteBitmap::SaveAdd---Caller hasn't call Save() yet"));
        return Win32Error;
    }

    // Note: we don't need to check if "newBits" is NULL and encoderParams is
    // NULL since it has been checked in flatapi.cpp

    ASSERT(newBits != NULL);
    ASSERT(encoderParams != NULL);
    ASSERT(IsValid());

    BOOL bLastFrame = FALSE;
    BOOL bSetFrameDimension = FALSE;
    GUID tempGuid;

    // Check if the caller has specified this is the last frame
    // Also, according to spec, the caller also has to specify the type of
    // dimension for next frame

    for ( UINT i = 0; (i < encoderParams->Count); ++i )
    {
        if ( (encoderParams->Parameter[i].Guid == ENCODER_SAVE_FLAG)
           &&(encoderParams->Parameter[i].Type == EncoderParameterValueTypeLong)
           &&(encoderParams->Parameter[i].NumberOfValues == 1) )
        {
            UINT    ulValue = *((UINT*)(encoderParams->Parameter[i].Value));

            if ( ulValue == EncoderValueLastFrame )
            {
                bLastFrame = TRUE;
            }
            else if ( ulValue == EncoderValueFrameDimensionPage )
            {
                tempGuid = FRAMEDIM_PAGE;
                bSetFrameDimension = TRUE;
            }
            else if ( ulValue == EncoderValueFrameDimensionTime )
            {
                tempGuid = FRAMEDIM_TIME;
                bSetFrameDimension = TRUE;
            }
            else if ( ulValue == EncoderValueFrameDimensionResolution )
            {
                tempGuid = FRAMEDIM_RESOLUTION;
                bSetFrameDimension = TRUE;
            }
        }
    }// Loop all the settings

    HRESULT hResult = S_OK;

    if ( bSetFrameDimension == FALSE )
    {
        WARNING(("CopyOnWriteBitmap::SaveAdd---Caller doesn't set frame dimension"));
        return InvalidParameter;
    }
    else
    {
        hResult = EncoderPtr->SetFrameDimension(&tempGuid);
        if ( FAILED(hResult) )
        {
            return (MapHRESULTToGpStatus(hResult));
        }
    }

    // We just need to call newBits->SaveAppend() and passing the EncoderPtr to
    // it. newBits->SaveAppend() should append all the frames in the object at
    // the end of the stream pointed by EncoderPtr

    CopyOnWriteBitmap* newBitmap = (CopyOnWriteBitmap*)newBits;
    Status rCode = newBitmap->SaveAppend(encoderParams, EncoderPtr);

    // If it is the last frame, close the encoder

    if ( bLastFrame == TRUE )
    {
        TerminateEncoder();
    }

    return rCode;
}// SaveAdd()

/**************************************************************************\
*
* Function Description:
*
* Append current frame to the encoder object caller passed in
* Note: This function is called from another CopyOnWriteBitmap object which holds the
*       encoder object. It asks current frame to be appended at the end of its
*       encoder object
*
* Arguments:
*
*   encoderParams - Encoder parameters
*   pDestEncoderPtr---Encoder object for saving this frame to
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   04/21/2000 minliu
*       Created it.
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::SaveAppend(
    const EncoderParameters* encoderParams,
    IImageEncoder* pDestEncoderPtr
    )
{
    // We don't need to check if EncoderPtr is NULL since this is not a public
    // function. The caller should check

    ASSERT(pDestEncoderPtr != NULL);

    ASSERT(IsValid());

    HRESULT hResult;
    GpStatus status;

    // If the image has a source and it is not dirty, we let the decoder
    // directly talk to the encoder

    if ( (Img != NULL) && (IsDirty() == FALSE) )
    {
        hResult = Img->SaveAppend(encoderParams, pDestEncoderPtr);
    }
    else
    {
        status = LoadIntoMemory();

        if ( status != Ok )
        {
            return status;
        }

        hResult = Bmp->SaveAppend(encoderParams, pDestEncoderPtr, Img);
    }

    if ( FAILED(hResult) )
    {
        return (MapHRESULTToGpStatus(hResult));
    }

    return Ok;
}// SaveAppend()

/**************************************************************************\
*
* Function Description:
*
*   Make a copy of the bitmap image object
*
* Arguments:
*
*   rect - Specifies the area of the bitmap to be copied
*   format - Specifies the desired pixel format
*
* Return Value:
*
*   Pointer to the newly copied bitmap image object
*   NULL if there is an error
*
* Revision History:
*
*   06/30/2000 minliu
*       Rewrote it.
*
\**************************************************************************/

CopyOnWriteBitmap*
CopyOnWriteBitmap::Clone(
    const GpRect* rect,
    PixelFormatID format
    ) const
{
    // At this stage, the state should be >= 3 for a CopyOnWriteBitmap

    ASSERT(State >= 3);

    // Input parameter validate

    if ( (rect != NULL)
       &&( (rect->X < 0)
         ||(rect->Y < 0)
         ||(rect->Width < 0)
         ||(rect->Height < 0) ) )
    {
        // We can't clone negative coordinates or size

        WARNING(("CopyOnWriteBitmap::Clone---invalid input rect"));
        return NULL;
    }

    if ( (rect != NULL)
       &&( ( (rect->X + rect->Width) > (INT)SrcImageInfo.Width)
         ||( (rect->Y + rect->Height) > (INT)SrcImageInfo.Height) ) )
    {
        // We can't clone an area which is bigger than the source image

        WARNING(("CopyOnWriteBitmap::Clone---invalid input rect size"));
        return NULL;
    }

    if ( format == PixelFormatUndefined )
    {
        // If the caller doesn't care about the pixel format, then we clone it
        // as the source image format
        // Note: This is the most frequently used the scenario since we have
        // Image::Clone() which doesn't take any parameters.
        // And we have
        // GpImage* Clone() const
        // {
        //      return Clone(NULL, PixelFormatDontCare);
        // }

        format = SrcImageInfo.PixelFormat;
    }

    CopyOnWriteBitmap*   pRetBmp = NULL;

    // Flag to indicate if we need to undo the LoadIntoMemory() or not
    // Note: This flag will be set to TRUE iff the current State is "DecodedImg"
    // and this function does a LoadIntoMemory()

    BOOL        bNeedToDiscard = FALSE;

    // A non-identical clone will happen if:
    // 1) the caller wants clone only a portion of the source image
    // 2) the dest image has a different pixel format than the current one
    // A non-identical clone means the newly created image doesn't have any
    // connections to the original image in terms of FileName or Stream etc.
    // Note: For a non-identical clone, we don't clone the property items either

    BOOL        bIdenticalClone = TRUE;

    if ( (rect != NULL)
       &&(  (rect->X != 0)
         || (rect->Y != 0)
         || (rect->Width != (INT)SrcImageInfo.Width)
         || (rect->Height != (INT)SrcImageInfo.Height)
         || (SrcImageInfo.PixelFormat != format) ) )
    {
        bIdenticalClone = FALSE;
    }

    // If the image is:
    // 1) Not dirty
    // 2) We have an source image
    // 3) The image has been loaded into memory
    //
    // Then we need to throw away the memory copy. The reasons are:
    // 1) Avoid the color conversion failure. One example will be: if the
    //    source image is 1 bpp indexed and we load it into memory at 32 PARGB
    //    for drawing. If we don't throw away the 32PARGB copy in memory, we
    //    will fail the clone() because the color conversion will fail
    // 2) Keep property item intact. for example, if the image is 24 bpp with
    //    property items in it. But it was loaded into memory for some reason.
    //    If we don't throw away the memory copy here, the code below will fall
    //    into "else if ( State == MemBitmap )" case. Then it will call
    //    Bmp->Clone() to make another copy in memory. Since the source "Bmp"
    //    doesn't contain any property info. The cloned one won't have any
    //    property info either. See Windows bug#325413
    // 3) If current image is "Dirty", we don't need to keep property items.

    if ( (IsDirty() == FALSE)
       &&(State >= MemBitmap)
       &&(Img != NULL) )
    {
        ASSERT( Bmp != NULL )
        Bmp->Release();
        Bmp = NULL;
        State = DecodedImg;
        PixelFormatInMem = PixelFormatUndefined;
    }

    // We have to clone the image in memory if it is not an identical clone.
    // So if the image hasn't been loaded into memory yet, load it

    if ( (State == DecodedImg)
       &&(FALSE == bIdenticalClone) )
    {
        // Note: Due to some general pixel format conversion limitation in the
        // whole Engine, we try to avoid doing LoadIntoMemory(). Hopefully this
        // will be fixed sometime later. So I add a !!!TODO {minliu} here.
        // But for now, we have to load the current image into memory with the
        // desired pixel format and throw it away when we are done.

        if ( LoadIntoMemory(format) != Ok )
        {
            WARNING(("CopyOnWriteBitmap::Clone---LoadIntoMemory() failed"));
            return NULL;
        }

        bNeedToDiscard = TRUE;
    }

    // Do clone according to the current Image State

    if ( State == DecodedImg )
    {
        // Current source image hasn't been loaded and the caller wants to
        // clone the WHOLE image
        // Note: there are only two ways to construct a CopyOnWriteBitmap object
        // and with the State = DecodedImg: CopyOnWriteBitmap(IStream*) and
        // CopyOnWriteBitmap(WCHAR*). So what we need to do is to create a
        // CopyOnWriteBitmap object by calling the same constructor

        if ( this->Filename != NULL )
        {
            pRetBmp = new CopyOnWriteBitmap(this->Filename);
            if ( pRetBmp == NULL )
            {
                WARNING(("CopyOnWrite::Clone--new CopyOnWriteBitmap() failed"));
                return NULL;
            }
        }
        else if ( this->Stream != NULL )
        {
            pRetBmp = new CopyOnWriteBitmap(this->Stream);

            if ( pRetBmp == NULL )
            {
                WARNING(("CopyOnWrite::Clone--new CopyOnWriteBitmap() failed"));
                return NULL;
            }
        }
    }// State == DecodedImg
    else if ( State == MemBitmap )
    {
        // Current source image has already been loaded into memory
        // Note: the above checking (State == MemBitmap) might not be necessary.
        // But we leave it here just to prevent someone adds another state in
        // the State enum later.

        IBitmapImage* newbmp = NULL;
        HRESULT hResult;

        if ( rect == NULL )
        {
            hResult = Bmp->Clone(NULL, &newbmp, bIdenticalClone);
        }
        else
        {
            RECT r =
            {
                rect->X,
                rect->Y,
                rect->GetRight(),
                rect->GetBottom()
            };

            hResult = Bmp->Clone(&r, &newbmp, bIdenticalClone);
        }

        if ( FAILED(hResult) )
        {
            WARNING(("CopyOnWriteBitmap::Clone---Bmp->clone() failed"));
            goto cleanup;
        }

        // !!! TODO
        //  We assume that IBitmapImage is the very first
        //  interface implemented by GpMemoryBitmap class.

        pRetBmp = new CopyOnWriteBitmap((GpMemoryBitmap*)newbmp);

        if ( pRetBmp == NULL )
        {
            WARNING(("CopyOnWriteBmp::Clone---new CopyOnWriteBitmap() failed"));
            newbmp->Release();
            goto cleanup;
        }

        // Clone the source info as well if it is an identical clone

        if ( TRUE == bIdenticalClone )
        {
            if ( this->Filename != NULL )
            {
                pRetBmp->Filename = UnicodeStringDuplicate(this->Filename);
            }
            else if ( this->Stream != NULL )
            {
                pRetBmp->Stream = this->Stream;
                pRetBmp->Stream->AddRef();
            }
        }

        // Make sure clone has requested format. The reason we need to do this
        // is because the source image might have different pixel format as the
        // caller wants. This would be caused someone already did an
        // LoadIntoMemory() call on current object before this clone() is called

        PixelFormatID formatRetbmp;

        GpStatus status = pRetBmp->GetPixelFormatID(&formatRetbmp);

        if ( (status == Ok) && (format != formatRetbmp) )
        {
            status = pRetBmp->ConvertFormat(format, NULL, NULL);
        }

        if ( status != Ok )
        {
            WARNING(("CopyOnWrite:Clone-GetPixelFormatID() or Convert failed"));
            pRetBmp->Dispose();
            pRetBmp = NULL;
        }
    }// State == MemBitmap

cleanup:
    if ( bNeedToDiscard == TRUE )
    {
        // Throw away the memory bits we loaded in this function and restore
        // the State

        if ( Bmp != NULL )
        {
            Bmp->Release();
            Bmp = NULL;
            State = DecodedImg;
        }
    }

    // We need to check if the result of the clone is valid or not. If it is
    // not valid, we should return a NULL pointer

    if ( (pRetBmp != NULL) && (!pRetBmp->IsValid()) )
    {
        pRetBmp->Dispose();
        pRetBmp = NULL;
    }
    
    return pRetBmp;
}// Clone()

/**************************************************************************\
*
* Function Description:
*
*   Set the palette for this bitmap
*
* Arguments:
*
*   OUT palette - contains the palette.
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::SetPalette(
    ColorPalette *palette
)
{
    ASSERT(IsValid());

    GpStatus status;

    switch(State) {
    case ImageRef:
    case ExtStream:
        status = DereferenceStream();
        if(status != Ok) { return status; }
        // Put the image in at least DecodedImg state and
        // fallthrough

    case DecodedImg:
        // Get the info from the encoded image without forcing the codec
        // to decode the entire thing.

        // !!! TODO: Actually we don't yet have a way of setting the palette
        // directly from the codec.

        status = LoadIntoMemory(PIXFMT_DONTCARE);

        // Load into memory failed? Return the error code.

        if(status != Ok) { return status; }

        // !!! break; Fallthrough for now - till we get the codec query implemented

    case MemBitmap:
        {
            // We're already fully decoded, just set the information.

            HRESULT hr = Bmp->SetPalette(palette);

            // Did we fail to set the palette?

            if(hr != S_OK)
            {
                return GenericError;
            }

        }
    break;

    default:
        // All image states need to be handled above.
        // If we get in here, we have a CopyOnWriteBitmap in an invalid state or
        // someone added a new state and needs to update the switch above.
        ASSERT(FALSE);
        return InvalidParameter;
    }

    return Ok;
}


/**************************************************************************\
*
* Function Description:
*
*   Get the palette for this bitmap
*
* Arguments:
*
*   OUT palette - contains the palette.
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::GetPalette(
    ColorPalette *palette,
    INT size
)
{
    ASSERT(IsValid());
    ASSERT(palette != NULL);    // need a buffer to store the data in.

    if ( size < sizeof(ColorPalette) )
    {
        return InvalidParameter;
    }

    GpStatus status;

    switch(State) {
    case ImageRef:
    case ExtStream:
        status = DereferenceStream();
        if(status != Ok) { return status; }
        // Put the image in at least DecodedImg state and
        // fallthrough

    case DecodedImg:
        // Get the info from the encoded image without forcing the codec
        // to decode the entire thing.

        // !!! TODO: Actually we don't yet have a way of getting the palette
        // directly from the codec.

        status = LoadIntoMemory(PIXFMT_DONTCARE);

        // Load into memory failed? Return the error code.

        if(status != Ok) { return status; }

        // !!! break; Fallthrough for now - till we get the codec query implemented

    case MemBitmap:
        {
            // We're already fully decoded, just get the information.
            const ColorPalette *pal = Bmp->GetCurrentPalette();
            if(pal)
            {
                // Make sure the size is correct.
                if(size != (INT) (sizeof(ColorPalette)+(pal->Count-1)*sizeof(ARGB)) )
                {
                    return InvalidParameter;
                }
                // Copy the palette into the user buffer.
                GpMemcpy(palette, pal, sizeof(ColorPalette)+(pal->Count-1)*sizeof(ARGB));
            }
            else
            {
                // If there is no palette, we need to properly set the
                // ColorPalette structure.

                palette->Count = 0;
            }
        }
    break;

    default:
        // All image states need to be handled above.
        // If we get in here, we have a CopyOnWriteBitmap in an invalid state or
        // someone added a new state and needs to update the switch above.
        ASSERT(FALSE);
        return InvalidParameter;
    }

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Returns the size, in bytes, needed for holding a palette for this bitmap
*
* Arguments:
*
* Return Value:
*
*   The size, in bytes. Return 0 if there is no palette or something is wrong
*
* Note: should return -1 for something wrong.
*
\**************************************************************************/

INT
CopyOnWriteBitmap::GetPaletteSize(
    )
{
    ASSERT(IsValid());

    GpStatus status;

    switch(State)
    {
    case ImageRef:
    case ExtStream:
        status = DereferenceStream();

        if(status != Ok)
        {
            return 0;
        }

        // Put the image in at least DecodedImg state and
        // fallthrough

    case DecodedImg:
        // Get the info from the encoded image without forcing the codec
        // to decode the entire thing.

        // !!! TODO: Actually we don't yet have a way of getting the palette
        // directly from the codec.

        status = LoadIntoMemory(PIXFMT_DONTCARE);

        // Load into memory failed? Return a zero palette size.

        if ( status != Ok )
        {
            return 0;
        }

        // !!! break; Fallthrough for now - till we get the codec query implemented

    case MemBitmap:
        {
            // We're already fully decoded, just get the information.

            const ColorPalette *pal = Bmp->GetCurrentPalette();

            // Extract the size.

            if(pal)
            {
                return (sizeof(ColorPalette)+(pal->Count-1)*sizeof(ARGB));
            }
            else
            {
                // Note: if the image doesn't have a palette, we should still
                // return at least the size of a ColorPalette, not zero here.
                // The reason is to prevent some bad app which can cause GDI+'s
                // GetPalette() to AV, see bug#372163

                return sizeof(ColorPalette);
            }
        }
        break;

    default:
        // All image states need to be handled above.
        // If we get in here, we have a CopyOnWriteBitmap in an invalid state or
        // someone added a new state and needs to update the switch above.

        ASSERT(FALSE);
        return 0;
    }

    return 0;
}

/**************************************************************************\
*
* Function Description:
*
*   Returns total number of frames in the bitmap image
*
* Arguments:
*
*   dimensionID  - Dimension GUID the caller wants to query the count
*   count        - Total number of frames under specified dimension
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   11/19/1999 minliu
*       Created it.
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::GetFrameCount(
    const GUID* dimensionID,
    UINT* count
    ) const
{
    ASSERT(IsValid());

    if ( Img == NULL )
    {
        // This CopyOnWriteBitmap is not created from a source image. It doesn't
        // have source Stream, nor source file name. It might be created
        // from a BITMAPINFO structure or a memory bitmap. But anyway, it has
        // one frame. So we return 1 here.

        *count = 1;
        return Ok;
    }

    HRESULT hResult = Img->GetFrameCount(dimensionID, count);

    if ( hResult == E_NOTIMPL )
    {
        return NotImplemented;
    }
    else if ( hResult != S_OK )
    {
        return Win32Error;
    }

    return Ok;
}// GetFrameCount()

/**************************************************************************\
*
* Function Description:
*
*     Get the total number of dimensions the image supports
*
* Arguments:
*
*     count -- number of dimensions this image format supports
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   03/20/2000 minliu
*       Created it.
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::GetFrameDimensionsCount(
    UINT* count
    ) const
{
    ASSERT(IsValid());

    if ( count == NULL )
    {
        return InvalidParameter;
    }

    if ( Img == NULL )
    {
        // This CopyOnWriteBitmap is not created from a source image. It doesn't
        // have source Stream, nor source file name. It might be created
        // from a BITMAPINFO structure or a memory bitmap. But anyway, it has
        // one PAGE frame. So we set the return values accordingly.

        *count = 1;

        return Ok;
    }

    // Ask the lower level codec to give us the answer

    HRESULT hResult = Img->GetFrameDimensionsCount(count);

    if ( hResult == E_NOTIMPL )
    {
        return NotImplemented;
    }
    else if ( hResult != S_OK )
    {
        return Win32Error;
    }

    return Ok;
}// GetFrameDimensionsCount()

/**************************************************************************\
*
* Function Description:
*
*     Get an ID list of dimensions the image supports
*
* Arguments:
*
*     dimensionIDs---Memory buffer to hold the result ID list
*     count -- number of dimensions this image format supports
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   03/20/2000 minliu
*       Created it.
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::GetFrameDimensionsList(
    GUID*   dimensionIDs,
    UINT    count
    ) const
{
    ASSERT(IsValid());

    if ( dimensionIDs == NULL )
    {
        return InvalidParameter;
    }

    if ( Img == NULL )
    {
        // This CopyOnWriteBitmap is not created from a source image. It doesn't
        // have source Stream, nor source file name. It might be created
        // from a BITMAPINFO structure or a memory bitmap. But anyway, it has
        // one PAGE frame. So we set the return values accordingly.
        // Note: in this case, the "count" has to be 1

        if ( count == 1 )
        {
            dimensionIDs[0] = FRAMEDIM_PAGE;

            return Ok;
        }
        else
        {
            return InvalidParameter;
        }
    }

    // Ask the lower level codec to give us the answer

    HRESULT hResult = Img->GetFrameDimensionsList(dimensionIDs, count);

    if ( hResult == E_NOTIMPL )
    {
        return NotImplemented;
    }
    else if ( hResult != S_OK )
    {
        return Win32Error;
    }

    return Ok;
}// GetFrameDimensionsList()

/**************************************************************************\
*
* Function Description:
*
*   Select active frame in a bitmap image
*
* Arguments:
*
*   dimensionID - dimension GUID used to specify which dimention you want to
*                 set the active frame, PAGE, TIMER, RESOLUTION
*   frameIndex -- Index number of the frame you want to set
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   11/19/1999 minliu
*       Created it.
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::SelectActiveFrame(
    const GUID* dimensionID,
    UINT        frameIndex
    )
{
    ASSERT(IsValid());

    if ( frameIndex == CurrentFrameIndex )
    {
        // We are already at the required frame. Do nothing

        return Ok;
    }

    // Cannot move onto another frame if the current bits is locked

    if ( ObjRefCount > 1 )
    {
        return WrongState;
    }

    // Set active frame to caller asks for
    // Note: we don't need to validate the "frameIndex" range since the lower
    // level will return fail if the page number if not correct. By doing this
    // way, we avoid remembering the total number of frames in an image

    HRESULT hResult = S_OK;

    if ( Img == NULL )
    {
        // Try to create a GpDecodedImage*

        if ( NULL != Stream )
        {
            hResult = GpDecodedImage::CreateFromStream(Stream, &Img);
        }
        else if ( NULL != Filename )
        {
            hResult = GpDecodedImage::CreateFromFile(Filename, &Img);
        }
        else
        {
            // This CopyOnWriteBitmap is not created from a source image. It
            // might be created from a BITMAPINFO structure or a memory bitmap.
            // But anyway, the caller is allowed to call this function though it
            // is just a NO-OP.

            return Ok;
        }

        if ( FAILED(hResult) )
        {
            WARNING(("CopyOnWriteBitmap::SelectActiveFrame-Create Img failed"));
            return Win32Error;
        }
    }

    hResult = Img->SelectActiveFrame(dimensionID, frameIndex);

    if ( hResult == E_NOTIMPL )
    {
        return NotImplemented;
    }
    else if ( hResult != S_OK )
    {
        WARNING(("Bitmap::SelectActiveFrame--Img->SelectActiveFrame() failed"));
        return Win32Error;
    }

    // Get the image info of the new frame
    // Note: we can't overwrite our "SrcImageInfo" for now until all the OPs
    // are successful

    ImageInfo   tempImageInfo;
    hResult = Img->GetImageInfo(&tempImageInfo);

    if ( FAILED(hResult) )
    {
        return Win32Error;
    }

    // Create a temporary memory bitmap for the active frame.
    // Note: we can't release Bmp first and stick &Bmp in the call because
    // this call might fail. We don't want to lose the original if this happens

    GpMemoryBitmap* newbmp;

    hResult = GpMemoryBitmap::CreateFromImage(Img,
                                              0,
                                              0,
                                              tempImageInfo.PixelFormat,
                                              InterpolationHintDefault,
                                              &newbmp,
                                              NULL,
                                              NULL);

    if ( FAILED(hResult) )
    {
        return Win32Error;
    }

    // We can release the old one if there is one since we got the new frame
    // successfully
    // Note: it is possible there is no any old one because we haven't load the
    // image into memory yet (Bmp == NULL)

    if ( Bmp != NULL )
    {
        Bmp->Release();
    }

    Bmp = newbmp;
    State = MemBitmap;

    // Remember the image info of the source image and the pixel format in the
    // memory. They are the same at this moment

    GpMemcpy(&SrcImageInfo, &tempImageInfo, sizeof(ImageInfo));
    PixelFormatInMem = SrcImageInfo.PixelFormat;

    // Remember current frame index number

    CurrentFrameIndex = frameIndex;

    return Ok;
}// SelectActiveFrame()

/**************************************************************************\
*
* Function Description:
*
*   Get the count of property items in the image
*
* Arguments:
*
*   [OUT]numOfProperty - The number of property items in the image
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   02/28/2000 minliu
*       Created it.
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::GetPropertyCount(
    UINT* numOfProperty
    )
{
    ASSERT(IsValid());

    // Check if we have a source image. Img is NULL means this CopyOnWriteBitmap
    // is not created from a source image.It might be created from a BITMAPINFO
    // structure or a memory bitmap.

    HRESULT hResult = S_OK;

    if ( Img != NULL )
    {
        hResult = Img->GetPropertyCount(numOfProperty);
    }
    else
    {
        ASSERT(Bmp != NULL);

        hResult = Bmp->GetPropertyCount(numOfProperty);
    }

    return MapHRESULTToGpStatus(hResult);
}// GetPropertyCount()

/**************************************************************************\
*
* Function Description:
*
*   Get a list of property IDs for all the property items in the image
*
* Arguments:
*
*   [IN]  numOfProperty - The number of property items in the image
*   [OUT] list----------- A memory buffer the caller provided for storing the
*                         ID list
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   02/28/2000 minliu
*       Created it.
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::GetPropertyIdList(
    IN UINT numOfProperty,
    IN OUT PROPID* list
    )
{
    ASSERT(IsValid());

    // Check if we have a source image. Img is NULL means this CopyOnWriteBitmap
    // is not created from a source image.It might be created from a BITMAPINFO
    // structure or a memory bitmap.

    HRESULT hResult = S_OK;

    if ( Img != NULL )
    {
        hResult = Img->GetPropertyIdList(numOfProperty, list);
    }
    else
    {
        ASSERT(Bmp != NULL);
        hResult = Bmp->GetPropertyIdList(numOfProperty, list);
    }

    return MapHRESULTToGpStatus(hResult);
}// GetPropertyIdList()

/**************************************************************************\
*
* Function Description:
*
*   Get the size, in bytes, of a specific property item, specified by the
*   property ID
*
* Arguments:
*
*   [IN]propId - The ID of a property item caller is interested
*   [OUT]size--- Size of this property, in bytes
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   02/28/2000 minliu
*       Created it.
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::GetPropertyItemSize(
    IN PROPID propId,
    OUT UINT* size
    )
{
    ASSERT(IsValid());

    HRESULT hResult = S_OK;

    // Check if we have a source image. Img is NULL means this CopyOnWriteBitmap
    // is not created from a source image.It might be created from a BITMAPINFO
    // structure or a memory bitmap.

    if ( Img != NULL )
    {
        hResult = Img->GetPropertyItemSize(propId, size);
    }
    else
    {
        ASSERT(Bmp != NULL);

        hResult = Bmp->GetPropertyItemSize(propId, size);
    }
    
    return MapHRESULTToGpStatus(hResult);
}// GetPropertyItemSize()

/**************************************************************************\
*
* Function Description:
*
*   Get a specific property item, specified by the prop ID.
*
* Arguments:
*
*   [IN]propId -- The ID of the property item caller is interested
*   [IN]propSize- Size of the property item. The caller has allocated these
*                 "bytes of memory" for storing the result
*   [OUT]pBuffer- A memory buffer for storing this property item
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   02/28/2000 minliu
*       Created it.
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::GetPropertyItem(
    IN PROPID               propId,
    IN UINT                 propSize,
    IN OUT PropertyItem*    pBuffer
    )
{
    ASSERT(IsValid());

    // Check if we have a source image. Img is NULL means this CopyOnWriteBitmap
    // is not created from a source image.It might be created from a BITMAPINFO
    // structure or a memory bitmap.

    HRESULT hResult = S_OK;

    if ( Img != NULL )
    {
        hResult = Img->GetPropertyItem(propId, propSize, pBuffer);
    }
    else
    {
        ASSERT(Bmp != NULL);
        hResult = Bmp->GetPropertyItem(propId, propSize, pBuffer);
    }
    
    return MapHRESULTToGpStatus(hResult);
}// GetPropertyItem()

/**************************************************************************\
*
* Function Description:
*
*   Get the size of ALL property items in the image
*
* Arguments:
*
*   [OUT]totalBufferSize-- Total buffer size needed, in bytes, for storing all
*                          property items in the image
*   [OUT]numOfProperty --- The number of property items in the image
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   02/28/2000 minliu
*       Created it.
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::GetPropertySize(
    OUT UINT* totalBufferSize,
    OUT UINT* numProperties
    )
{
    ASSERT(IsValid());

    // Check if we have a source image. Img is NULL means this CopyOnWriteBitmap
    // is not created from a source image.It might be created from a BITMAPINFO
    // structure or a memory bitmap.

    HRESULT hResult = S_OK;

    if ( Img != NULL )
    {
        hResult = Img->GetPropertySize(totalBufferSize, numProperties);
    }
    else
    {
        ASSERT(Bmp != NULL);
        hResult = Bmp->GetPropertySize(totalBufferSize, numProperties);
    }

    return MapHRESULTToGpStatus(hResult);
}// GetPropertySize()

/**************************************************************************\
*
* Function Description:
*
*   Get ALL property items in the image
*
* Arguments:
*
*   [IN]totalBufferSize-- Total buffer size, in bytes, the caller has allocated
*                         memory for storing all property items in the image
*   [IN]numOfProperty --- The number of property items in the image
*   [OUT]allItems-------- A memory buffer caller has allocated for storing all
*                         the property items
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   02/28/2000 minliu
*       Created it.
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::GetAllPropertyItems(
    IN UINT totalBufferSize,
    IN UINT numProperties,
    IN OUT PropertyItem* allItems
    )
{
    ASSERT(IsValid());

    // Check if we have a source image. Img is NULL means this CopyOnWriteBitmap
    // is not created from a source image.It might be created from a BITMAPINFO
    // structure or a memory bitmap.

    HRESULT hResult = S_OK;

    if ( Img != NULL )
    {
        hResult = Img->GetAllPropertyItems(totalBufferSize, numProperties,
                                           allItems);
    }
    else
    {
        ASSERT(Bmp != NULL);
        hResult = Bmp->GetAllPropertyItems(totalBufferSize, numProperties,
                                           allItems);
    }

    return MapHRESULTToGpStatus(hResult);
}// GetAllPropertyItems()

/**************************************************************************\
*
* Function Description:
*
*   Remove a specific property item, specified by the prop ID.
*
* Arguments:
*
*   [IN]propId -- The ID of the property item to be removed
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   02/28/2000 minliu
*       Created it.
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::RemovePropertyItem(
    IN PROPID   propId
    )
{
    ASSERT(IsValid());

    // Check if we have a source image. Img is NULL means this CopyOnWriteBitmap
    // is not created from a source image.It might be created from a BITMAPINFO
    // structure or a memory bitmap.

    HRESULT hResult = S_OK;

    if ( Img != NULL )
    {
        hResult = Img->RemovePropertyItem(propId);
    }
    else
    {
        ASSERT(Bmp != NULL);
        hResult = Bmp->RemovePropertyItem(propId);
    }

    return MapHRESULTToGpStatus(hResult);
}// RemovePropertyItem()

/**************************************************************************\
*
* Function Description:
*
*   Set a property item, specified by the propertyitem structure. If the item
*   already exists, then its contents will be updated. Otherwise a new item
*   will be added
*
* Arguments:
*
*   [IN]item -- A property item the caller wants to set
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   02/28/2000 minliu
*       Created it.
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::SetPropertyItem(
    IN PropertyItem* item
    )
{
    if ( item == NULL )
    {
        WARNING(("CopyOnWriteBitmap::SetPropertyItem-Invalid input parameter"));
        return InvalidParameter;
    }

    ASSERT(IsValid());

    HRESULT hResult = S_OK;

    // Check if we have a source image. Img is NULL means this CopyOnWriteBitmap
    // is not created from a source image.It might be created from a BITMAPINFO
    // structure or a memory bitmap.
    // If "SpecialJPEGSave" is TRUE, it means, the image has been rotated in
    // memory, but the "Img" pointer might not be released yet

    if (( Img != NULL ) && (SpecialJPEGSave == FALSE))
    {
        hResult = Img->SetPropertyItem(*item);
    }
    else
    {
        ASSERT(Bmp != NULL);

        hResult = Bmp->SetPropertyItem(*item);
    }

    return MapHRESULTToGpStatus(hResult);
}// SetPropertyItem()

/**************************************************************************\
*
* Function Description:
*
*   Get bitmap image thumbnail
*
* Arguments:
*
*   thumbWidth, thumbHeight - Desired width and height of thumbnail
*       Both zero means pick a default size
*
* Return Value:
*
*   Pointer to the new thumbnail image object
*   NULL if there is an error
*
\**************************************************************************/

CopyOnWriteBitmap *
CopyOnWriteBitmap::GetThumbnail(
    UINT thumbWidth,
    UINT thumbHeight,
    GetThumbnailImageAbort callback,
    VOID *callbackData
    )
{
    ASSERT(IsValid());

    HRESULT hr = S_OK;
    IImage *newImage = NULL;

    // Ask the lower level codec to give us the thumbnail stored in the image.
    // Note: If there is no thumbnail stored in the original image, this
    // function will return us a scaled version of the original image as the
    // thumbnail image, at DEFAULT_THUMBNAIL_SIZE
    // Note: Img might be zero, it means this CopyOnWriteBitmap is not created from an
    // stream or file. It might be created from an memory buffer or something
    // else. One scenario will be Do a GetThumbnail() and then do another
    // GetThumbnail from this thumbnail. Though it is a weird scenario. But it
    // could happen. So if the Img is NULL, then we create a thumbnail from
    // the memory bitmap

    if ( Img != NULL )
    {
        hr = Img->GetThumbnail(thumbWidth, thumbHeight, &newImage);
    }
    else
    {
        GpStatus status = LoadIntoMemory();

        if ( status != Ok )
        {
            return NULL;
        }

        hr = Bmp->GetThumbnail(thumbWidth, thumbHeight, &newImage);
    }

    if ( FAILED(hr) )
    {
        return NULL;
    }

    // Create a GpMemoryBitmap from IImage

    ImageInfo   srcImageInfo;
    newImage->GetImageInfo(&srcImageInfo);

    GpMemoryBitmap* pMemBitmap;

    hr = GpMemoryBitmap::CreateFromImage(newImage,
                                         srcImageInfo.Width,
                                         srcImageInfo.Height,
                                         srcImageInfo.PixelFormat,
                                         InterpolationHintDefault,
                                         &pMemBitmap,
                                         (DrawImageAbort) callback,
                                         callbackData
                                         );

    // Release the COM obj IImage

    newImage->Release();

    if ( FAILED(hr) )
    {
        return NULL;
    }

    CopyOnWriteBitmap* thumbBitmap = new CopyOnWriteBitmap(pMemBitmap);

    return thumbBitmap;
}

/**************************************************************************\
*
* Function Description:
*
*   Access bitmap pixel data
*
* Arguments:
*
*   rect - Specifies the interested image area
*       NULL means the entire image
*   flags - Desired access mode
*   format - Desired pixel format
*   bmpdata - Returns information about bitmap pixel data
*   width,
*   height  - suggested width and height to decode to.
*             zero is the source image width and height.
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::LockBits(
    const GpRect* rect,
    UINT flags,
    PixelFormatID format,
    BitmapData* bmpdata,
    INT width,
    INT height
) const
{
    ASSERT(IsValid());
    ASSERT(width>=0);
    ASSERT(height>=0);

    // LockBits cannot be nested

    if ( ObjRefCount > 1 )
    {
        return WrongState;
    }

    // Do some sanity check to see if we can do it or not

    if ( (format == PIXFMT_DONTCARE)
       ||(!IsValidPixelFormat(format)) )
    {
        // Wrong pixel format

        WARNING(("CopyOnWriteBitmap::LockBits---invalid format"));
        return InvalidParameter;
    }

    // Valid format. If the lock is for READ, we need to check if we can
    // convert the current source to this format

    EpFormatConverter linecvt;

    if ( flags & ImageLockModeRead )
    {
        if ( IsDirty() == FALSE )
        {
            if ( linecvt.CanDoConvert(SrcImageInfo.PixelFormat, format)==FALSE )
            {
                WARNING(("LockBits--can't convert src to specified fmt"));
                return InvalidParameter;
            }
        }
        else if (linecvt.CanDoConvert(PixelFormatInMem, format) == FALSE )
        {
            WARNING(("LockBits--can't convert src to specified fmt"));
            return InvalidParameter;
        }
    }

    // If the lock is for WRITE, we need to check if we can convert the format
    // back to current source format. The reason we need to do this checking is
    // when the user calls UnLockBits() after he has modified the locked area,
    // we need to convert this small area back to the format the whole image is
    // at. E.x. For an 4 bpp image, the caller can lock a small area at 32 bpp
    // (this makes the app code easier), do some pixel modification on that
    // area, unlock it. We need to convert that small area back to 4 bpp.

    if ( flags & ImageLockModeWrite )
    {
        if ( IsDirty() == FALSE )
        {
            if ( linecvt.CanDoConvert(format, SrcImageInfo.PixelFormat)==FALSE )
            {
                WARNING(("LockBits--can't convert specified fmt back to src"));
                return InvalidParameter;
            }
        }
        else if (linecvt.CanDoConvert(format, PixelFormatInMem) == FALSE )
        {
            WARNING(("LockBits--can't convert specified format back to src"));
            return InvalidParameter;
        }
    }

    HRESULT hr;

    if ( (IsDirty() == FALSE)
       &&(State >= MemBitmap)
       &&(format != PixelFormatInMem)
       &&(SrcImageInfo.PixelFormat != PixelFormatInMem)
       &&(Img != NULL) )
    {
        // If the image is:
        // 1) Not dirty
        // 2) Was loaded into memory with different color depth for some reason,
        //    like DrawImage()
        // 3) The color depth the caller wants to locked for is different than
        //    the one in memory
        // 4) We have an source image
        //
        // Then we can throw away the bits in memory and reload the bits from
        // the original with the color depth user asks for. The purpose of this
        // is to increase the success rate for LockBits(). One of the problem
        // we are having now is that our DrawImage() always load image into
        // memory at 32PARGB format. This makes tasks like printing very
        // expensive because it has to send 32PARGB format to the print. We'd
        // like to send the original color depth to the printer
        //
        // Note: this "throw away" approach won't hurt our DrawImage() work flow
        // Here is the reason why: say we have a 4 bpp source image. We do a
        // DrawImage() first, thus we load it into memory at 32 PARGB. When the
        // printing request coming. It prefers to send down 4bpp to the printer.
        // So we through away the 32 PARGB in memory and reload the image in
        // 4 bpp mode and send it to printer. Later on, if DrawImage() is called
        // again. It can still pass the above "if" checking condition and reload
        // the image in as 32 PARGB.

        ASSERT( Bmp != NULL )
        Bmp->Release();
        Bmp = NULL;
        State = DecodedImg;
        PixelFormatInMem = PixelFormatUndefined;
    }

    // Load the image into memory using the suggested width and height.
    // if the suggested width and height are zero, use the source
    // image width and height.
    // Load the image into memory before querying the pixel format because
    // the load could potentially change the in-memory format.

    GpStatus status = LoadIntoMemory(format, NULL, NULL, width, height);

    if (status != Ok)
    {
        WARNING(("CopyOnWriteBitmap::LockBits()----LoadIntoMemory() failed"));
        return status;
    }

    if ( rect == NULL )
    {
        hr = Bmp->LockBits(NULL, flags, format, bmpdata);
    }
    else
    {
        RECT r =
        {
            rect->X,
            rect->Y,
            rect->GetRight(),
            rect->GetBottom()
        };

        hr = Bmp->LockBits(&r, flags, format, bmpdata);
    }

    if ( FAILED(hr) )
    {
        WARNING(("CopyOnWriteBitmap::LockBits()----LockBits() failed"));
        return (MapHRESULTToGpStatus(hr));
    }

    ObjRefCount++;

    if ( flags & ImageLockModeWrite )
    {
        // Mark the bits dirty since the user might have changed the bits during
        // the lock period

        SetDirtyFlag(TRUE);
    }

    return Ok;
}// LockBits()

GpStatus
CopyOnWriteBitmap::UnlockBits(
    BitmapData* bmpdata,
    BOOL Destroy
) const
{
    ASSERT(ObjRefCount == 2);

    if ( NULL == Bmp )
    {
        // The caller should not call UnlockBits() if it hasn't called
        // LockBits() yet

        WARNING(("UnlockBits---Call UnlockBits() without calling LockBits()"));
        return GenericError;
    }

    HRESULT hr = Bmp->UnlockBits(bmpdata);
    ObjRefCount--;

    // Called to destroy the decoded bits because we decoded a partial image
    // and it won't be valid on the next call.

    if(Destroy)
    {
        // Revert the state back to DecodedImg (which means not decoded).

        ASSERT(Img != NULL);
        delete Bmp;
        Bmp = NULL;
        State = DecodedImg;
    }

    if (FAILED(hr))
    {
        WARNING(("GpBitmap::UnlockBits---Bmp->UnlockBits() failed"));
        return (MapHRESULTToGpStatus(hr));
    }

    return Ok;
}// UnlockBits()

/**************************************************************************\
*
* Function Description:
*
*   Get a pixel
*
* Arguments:
*
*   IN x, y: Coordinates of the pixel to get.
*   OUT color: color value of the specified pixel.
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::GetPixel(INT x, INT y, ARGB *color)
{
    // Get the bitmap info.
    BitmapData bmpData;

    // Only lock the required rectangle.
    GpRect pixelRect(x, y, 1, 1);

    GpStatus status = LockBits(
        &pixelRect,
        IMGLOCK_READ,
        PIXFMT_32BPP_ARGB,
        &bmpData
    );

    // Failed to lock the bits.
    if(status != Ok)
    {
        return(status);
    }

    ARGB *pixel = static_cast<ARGB *>(bmpData.Scan0);
    *color = *pixel;

    return UnlockBits(&bmpData);
}

/**************************************************************************\
*
* Function Description:
*
*   Set a pixel
*
* Arguments:
*
*   IN x, y: Coordinates of the pixel to set.
*   IN color: color value for the specified pixel.
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::SetPixel(INT x, INT y, ARGB color)
{
    // Get the bitmap info.
    BitmapData bmpData;

    // Only lock the required rectangle.
    GpRect pixelRect(x, y, 1, 1);

    GpStatus status = LockBits(
        &pixelRect,
        IMGLOCK_WRITE,
        PIXFMT_32BPP_ARGB,
        &bmpData
    );

    // Failed to lock the bits.
    if(status != Ok)
    {
        return(status);
    }

    ARGB* pixel = static_cast<ARGB *>(bmpData.Scan0);
    *pixel = color;

    return UnlockBits(&bmpData);
}

/**************************************************************************\
*
* Function Description:
*
*   Convert bitmap image to a different pixel format
*
* Arguments:
*
*   format - Specifies the new pixel format
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::ConvertFormat(
    PixelFormatID format,
    DrawImageAbort callback,
    VOID *callbackData
    )
{
    ASSERT(ObjRefCount == 1);

    // If bitmap not in memory yet, simply force load using specified format:

    if ( State < MemBitmap )
    {
        return LoadIntoMemory(format, callback, callbackData);
    }

    HRESULT hr;

    if ( PixelFormatInMem != format)
    {
        GpMemoryBitmap* newbmp;

        hr = GpMemoryBitmap::CreateFromImage(
                    Bmp,
                    0,
                    0,
                    format,
                    InterpolationHintDefault,
                    &newbmp,
                    callback,
                    callbackData);

        if ( FAILED(hr) )
        {
            WARNING(("CopyOnWriteBitmap::ConvertFormat---CreateFromImage() failed"));
            return OutOfMemory;
        }

        Bmp->Release();
        Bmp = newbmp;

        PixelFormatInMem = format;

        // We change the source pixel format info as well because this image
        // is dirty now and we should not convert it back to original format

        SrcImageInfo.PixelFormat = format;

        // Mark the bits dirty since the original image bits got changed

        // !!! TODO: we can't set it dirty for now because DrawImage() always
        // convert an image to 32 bpp first. When this temporary solution is removed
        // we should reset this flag
        //
        // SetDirtyFlag(TRUE);
    }

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Derive a graphics context on top of the bitmap object
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   Pointer to the derived graphics context
*   NULL if there is an error
*
\**************************************************************************/

/******************************Public*Routine******************************\
*
* Function Description:
*
*   Derive an HDC on top of the bitmap object for GDI interop
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   HDC with a bitmap selected into it that is associated with this GDI+
*   bitmap.
*   NULL if there is an error
*
\**************************************************************************/

HDC
CopyOnWriteBitmap::GetHdc()
{
    HDC hdc = NULL;
    HBITMAP hbm = NULL;

    // Create the HDC and HBITMAP if needed.

    if (InteropData.Hdc == NULL)
    {
        ImageInfo imageInfo;

        CopyOnWriteBitmap::GetImageInfo(&imageInfo);

        hdc = CreateCompatibleDC(NULL);

        if (hdc == NULL)
        {
            goto cleanup_exit;
        }

        BITMAPINFO gdiBitmapInfo;

        gdiBitmapInfo.bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
        gdiBitmapInfo.bmiHeader.biWidth         = imageInfo.Width;
        gdiBitmapInfo.bmiHeader.biHeight        = - static_cast<LONG>
                                                    (imageInfo.Height);
        gdiBitmapInfo.bmiHeader.biPlanes        = 1;
        gdiBitmapInfo.bmiHeader.biBitCount      = 32;
        gdiBitmapInfo.bmiHeader.biCompression   = BI_RGB;
        gdiBitmapInfo.bmiHeader.biSizeImage     = 0;
        gdiBitmapInfo.bmiHeader.biXPelsPerMeter = 0;
        gdiBitmapInfo.bmiHeader.biYPelsPerMeter = 0;
        gdiBitmapInfo.bmiHeader.biClrUsed       = 0;
        gdiBitmapInfo.bmiHeader.biClrImportant  = 0;

        hbm = CreateDIBSection(hdc,
                               &gdiBitmapInfo,
                               DIB_RGB_COLORS,
                               &InteropData.Bits,
                               NULL,
                               0);

        DIBSECTION gdiDibInfo;

        if ((hbm == NULL) ||
            (GetObjectA(hbm, sizeof(gdiDibInfo), &gdiDibInfo) == 0) ||
            (gdiDibInfo.dsBmih.biSize == 0) ||
            (SelectObject(hdc, hbm) == NULL))
        {
            goto cleanup_exit;
        }

        InteropData.Hdc = hdc;
        InteropData.Hbm = hbm;

        InteropData.Width  = imageInfo.Width;
        InteropData.Height = imageInfo.Height;
        InteropData.Stride = gdiDibInfo.dsBm.bmWidthBytes;

        // Since it's a 32bpp bitmap, we can assume that a tightly packed
        // bitmap is already satisfies the scanline align constraints
        // (letting us fill the bitmap with a very simple loop).
        ASSERT(gdiDibInfo.dsBm.bmWidthBytes == static_cast<LONG>(imageInfo.Width * 4));
    }

    ASSERT(InteropData.Hdc != NULL);

    // Fill the bitmap with a sentinal pattern.

    {
        INT count = InteropData.Width * InteropData.Height;
        UINT32 *bits = static_cast<UINT32*>(InteropData.Bits);

        while (count--)
        {
            *bits++ = GDIP_TRANSPARENT_COLOR_KEY;
        }
    }

    return InteropData.Hdc;

cleanup_exit:

    if (hdc)
        DeleteDC(hdc);

    if (hbm)
        DeleteObject(hbm);

    return reinterpret_cast<HDC>(NULL);
}


/******************************Public*Routine******************************\
*
* Function Description:
*
*   Release the HDC returned by CopyOnWriteBitmap::GetHdc.  If necessary, updates
*   the GDI+ bitmap with the GDI drawing (may not be necessary if the
*   GDI and GDI+ bitmaps share a common underlying pixel buffer).
*
* Arguments:
*
*   HDC to release
*
* Return Value:
*
*   Pointer to the derived graphics context
*   NULL if there is an error
*
\**************************************************************************/

VOID
CopyOnWriteBitmap::ReleaseHdc(HDC hdc)
{
    ASSERT(hdc == InteropData.Hdc);

    GdiFlush();

    // Scan the GDI bitmap to see if any of the sentinal pixels have changed.
    // If any are detected, copy it to the GDI+ bitmap with opaque alpha set.

    int curRow, curCol;
    BYTE *interopScan = static_cast<BYTE*>(InteropData.Bits);

    GpStatus status = Ok;

    for (curRow = 0; (curRow < InteropData.Height) && (status == Ok); curRow++)
    {
        BOOL rowLocked = FALSE;
        BitmapData bitmapData;

        ARGB *interopPixel = static_cast<ARGB*>(static_cast<VOID*>(interopScan));
        ARGB *pixel = NULL;

        for (curCol = 0; curCol < InteropData.Width; curCol++)
        {
            if ((*interopPixel & 0x00ffffff) != GDIP_TRANSPARENT_COLOR_KEY)
            {
                if (!rowLocked)
                {
                    GpRect lockRect(0, curRow, InteropData.Width, 1);

                    status = LockBits(&lockRect,
                                      IMGLOCK_READ | IMGLOCK_WRITE,
                                      PIXFMT_32BPP_ARGB,
                                      &bitmapData);

                    if (status == Ok)
                    {
                        pixel = static_cast<ARGB*>(bitmapData.Scan0) + curCol;
                        rowLocked = TRUE;
                    }
                    else
                    {
                        break;
                    }
                }

                *pixel = *interopPixel | 0xFF000000;
            }

            interopPixel++;
            pixel++;
        }

        if (rowLocked)
            UnlockBits(&bitmapData);

        interopScan += InteropData.Stride;
    }
}

// Data flags
#define COMPRESSED_IMAGE 0x00000001

class BitmapRecordData : public ObjectTypeData
{
public:
    INT32       Width;
    INT32       Height;
    INT32       Stride;
    INT32       PixelFormat;
    INT32       Flags;
};

/**************************************************************************\
*
* Function Description:
*
*   Get the bitmap data.
*
* Arguments:
*
*   [IN] dataBuffer - fill this buffer with the data
*   [IN/OUT] size   - IN - size of buffer; OUT - number bytes written
*
* Return Value:
*
*   GpStatus - Ok or error code
*
* Created:
*
*   9/13/1999 DCurtis
*
\**************************************************************************/
GpStatus
CopyOnWriteBitmap::GetData(
    IStream *   stream
    ) const
{
    ASSERT(stream);

    GpStatus            status;
    BitmapRecordData    bitmapRecordData;

    IStream*    imageStream = NULL;
    STATSTG     statStg;
    BOOL        needRelease = FALSE;

    // variables used to track the stream state

    LARGE_INTEGER zero = {0,0};
    LARGE_INTEGER oldPos;
    BOOL          isSeekableStream = FALSE;

    // try to get a imageStream

    if (!IsDirty())
    {
        HRESULT hr;

        if (Stream != NULL)
        {
            hr = Stream->Seek(zero, STREAM_SEEK_CUR, (ULARGE_INTEGER *)&oldPos);

            if (SUCCEEDED(hr))
            {
                hr = Stream->Seek(zero, STREAM_SEEK_SET, NULL);

                if (SUCCEEDED(hr))
                {
                    isSeekableStream = TRUE;
                    imageStream = Stream;
                }
            }
        }

        // if we don't have a CopyOnWriteBitmap::Stream but we have a filename

        if ((imageStream == NULL) && (Filename != NULL))
        {
            hr = CreateStreamOnFileForRead(Filename, &imageStream);

            if (SUCCEEDED(hr))
            {
                needRelease = TRUE;
            }
        }

    }

    // try to write the imageStream out to the metafile Stream
    if (imageStream && imageStream->Stat(&statStg, STATFLAG_NONAME) == S_OK)
    {
        bitmapRecordData.Type        = ImageTypeBitmap;
        bitmapRecordData.Width       = 0;
        bitmapRecordData.Height      = 0;
        bitmapRecordData.Stride      = 0;
        bitmapRecordData.PixelFormat = 0;
        bitmapRecordData.Flags       = COMPRESSED_IMAGE;
        stream->Write(&bitmapRecordData, sizeof(bitmapRecordData), NULL);

        // Read data from the imageStream into the dest stream
        // Unfortunately, we can't assume that CopyTo has been implemented.
        // Is there some way to find out? !!!
    #define COPY_BUFFER_SIZE    2048

        BYTE    buffer[COPY_BUFFER_SIZE];
        UINT    streamSize  = statStg.cbSize.LowPart;
        UINT    sizeToRead  = COPY_BUFFER_SIZE;
        UINT    numPadBytes = 0;

        if ((streamSize & 0x03) != 0)
        {
            numPadBytes = 4 - (streamSize & 0x03);
        }

        status = Ok;

        if (status == Ok)
        {
            HRESULT hr;
            ULONG bytesRead = 0;
            ULONG bytesWrite = 0;

            while (streamSize > 0)
            {
                if (sizeToRead > streamSize)
                {
                    sizeToRead = streamSize;
                }

                hr = imageStream->Read(buffer, sizeToRead, &bytesRead);

                if (!SUCCEEDED(hr) || (sizeToRead != bytesRead))
                {
                    WARNING(("Failed to read stream in CopyOnWriteBitmap::GetData"));
                    status = Win32Error;
                    break;
                }

                hr = stream->Write(buffer, sizeToRead, &bytesWrite);

                if (!SUCCEEDED(hr) || (sizeToRead != bytesWrite))
                {
                    WARNING(("Failed to write stream in CopyOnWriteBitmap::GetData"));
                    status = Win32Error;
                    break;
                }

                streamSize -= sizeToRead;
            }

            // align
            if (numPadBytes > 0)
            {
                INT     pad = 0;
                stream->Write(&pad, numPadBytes, NULL);
            }
        }

        if (isSeekableStream)
        {
            // move back to the old pos
            Stream->Seek(oldPos, STREAM_SEEK_SET, NULL);
        }

        if (needRelease)
        {
            imageStream->Release();
        }

        return status;
    }

    // we can't record compressed data, record the uncompressed data

    if ((status = (const_cast<CopyOnWriteBitmap *>(this))->LoadIntoMemory()) != Ok)
    {
        WARNING(("Couldn't load the image into memory"));
        return status;
    }

    BitmapData  bitmapData     = *Bmp;
    INT         positiveStride = bitmapData.Stride;
    BOOL        upsideDown     = FALSE;
    INT         paletteSize    = 0;
    INT         pixelDataSize;

    if (positiveStride < 0)
    {
        positiveStride = -positiveStride;
        upsideDown = TRUE;
    }

    pixelDataSize = (bitmapData.Height * positiveStride);

    if (IsIndexedPixelFormat(bitmapData.PixelFormat))
    {
        // We're an indexed pixel format - must have a valid palette.
        ASSERT(Bmp->colorpal != NULL);

        // Note sizeof(ColorPalette) includes the first palette entry.
        paletteSize = sizeof(ColorPalette) +
                      sizeof(ARGB)*(Bmp->colorpal->Count-1);
    }

    bitmapRecordData.Type        = ImageTypeBitmap;
    bitmapRecordData.Width       = bitmapData.Width;
    bitmapRecordData.Height      = bitmapData.Height;
    bitmapRecordData.Stride      = positiveStride;
    bitmapRecordData.PixelFormat = bitmapData.PixelFormat;
    bitmapRecordData.Flags       = 0;
    stream->Write(&bitmapRecordData, sizeof(bitmapRecordData), NULL);

    if (paletteSize > 0)
    {
        // Write out the palette
        stream->Write(Bmp->colorpal, paletteSize, NULL);
    }

    if (pixelDataSize > 0)
    {
        if (!upsideDown)
        {
            stream->Write(bitmapData.Scan0, pixelDataSize, NULL);
        }
        else
        {
            BYTE *      scan = (BYTE *)bitmapData.Scan0;
            for (INT i = bitmapData.Height; i > 0; i--)
            {
                stream->Write(scan, positiveStride, NULL);
                scan -= positiveStride;
            }
        }
    }

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Get the compressed image data.
*
* Arguments:
*
*   OUT compressed_data
*
* Return Value:
*
*   GpStatus - Ok or error code
*
* Created:
*
\**************************************************************************/
GpStatus
CopyOnWriteBitmap::GetCompressedData(
    DpCompressedData * compressed_data,
    BOOL getJPEG,
    BOOL getPNG,
    HDC hdc
    )
{
    GpStatus    status = Ok;

    IStream*    imageStream = NULL;
    STATSTG     statStg;
    BOOL        needRelease = FALSE;

    // variables used to track the stream state

    LARGE_INTEGER zero = {0,0};
    LARGE_INTEGER oldPos;
    BOOL          isSeekableStream = FALSE;

    ASSERT(compressed_data->buffer == NULL);

    if (Img)
    {
        if (SrcImageInfo.RawDataFormat == IMGFMT_JPEG)
        {
            if (!getJPEG)
            {
                return Ok;
            }
            compressed_data->format = BI_JPEG;
        }
        else if (SrcImageInfo.RawDataFormat == IMGFMT_PNG)
        {
            if (!getPNG)
            {
                return Ok;
            }
            compressed_data->format = BI_PNG;
        }
        else
            return Ok;
    }
    else
    {
        WARNING(("GetCompressedData: Decoded image not available."));
        return Ok;
    }
    // try to get a imageStream

    if (!IsDirty())
    {
        HRESULT hr;

        if (Stream != NULL)
        {
            hr = Stream->Seek(zero, STREAM_SEEK_CUR, (ULARGE_INTEGER *)&oldPos);

            if (SUCCEEDED(hr))
            {
                hr = Stream->Seek(zero, STREAM_SEEK_SET, NULL);

                if (SUCCEEDED(hr))
                {
                    isSeekableStream = TRUE;
                    imageStream = Stream;
                }
            }
        }

        // if we don't have a CopyOnWriteBitmap::Stream but we have a filename

        if ((imageStream == NULL) && (Filename != NULL))
        {
            hr = CreateStreamOnFileForRead(Filename, &imageStream);

            if (SUCCEEDED(hr))
            {
                needRelease = TRUE;
            }
        }

    }

    if (imageStream && (imageStream->Stat(&statStg, STATFLAG_NONAME) == S_OK))
    {
        UINT streamSize  = statStg.cbSize.LowPart;
        ULONG bytesRead = 0;

        VOID * buffer = (PVOID)GpMalloc(streamSize);

        if (buffer)
        {
            HRESULT hr;

            hr = imageStream->Read(buffer, streamSize, &bytesRead);

            if (!SUCCEEDED(hr) || (streamSize != bytesRead))
            {
                WARNING(("Failed to read stream in CopyOnWriteBitmap::GetData"));
                status = Win32Error;
            }
            else
            {
                compressed_data->bufferSize = streamSize;
                compressed_data->buffer = buffer;
            }
        }
        else
        {
            WARNING(("Out of memory"));
            status = OutOfMemory;
        }
    }

    if (isSeekableStream)
    {
        // move back to the old pos
        Stream->Seek(oldPos, STREAM_SEEK_SET, NULL);
    }

    if (needRelease)
    {
        imageStream->Release();
    }

    if ((hdc != NULL) && (compressed_data->buffer != NULL))
    {
        DWORD EscapeValue = (compressed_data->format == BI_JPEG) ?
                             CHECKJPEGFORMAT : CHECKPNGFORMAT;

        DWORD result = 0;

        // Call escape to determine if this particular image is supported
        if ((ExtEscape(hdc,
                      EscapeValue,
                      compressed_data->bufferSize,
                      (LPCSTR)compressed_data->buffer,
                      sizeof(DWORD),
                      (LPSTR)&result) <= 0) || (result != 1))
        {
            // Failed to support passthrough of this image, delete the
            // compressed bits.

            DeleteCompressedData(compressed_data);
        }
    }

    return status;
}

GpStatus
CopyOnWriteBitmap::DeleteCompressedData(
    DpCompressedData * compressed_data
    )
{
    GpStatus    status = Ok;

    if (compressed_data && compressed_data->buffer)
    {
        GpFree(compressed_data->buffer);
        compressed_data->buffer = NULL;
    }

    return status;
}


UINT
CopyOnWriteBitmap::GetDataSize() const
{
    UINT    dataSize = 0;

    // if CopyOnWriteBitmap is not dirty, we look at compressed data

    if (!IsDirty())
    {
        STATSTG     statStg;
        HRESULT     hr;

        if (Stream != NULL)
        {
            // variables used to track the stream state
            LARGE_INTEGER zero = {0,0};
            LARGE_INTEGER oldPos;
            BOOL          isSeekableStream = FALSE;

            hr = Stream->Seek(zero, STREAM_SEEK_CUR, (ULARGE_INTEGER *)&oldPos);

            if (SUCCEEDED(hr))
            {
                hr = Stream->Seek(zero, STREAM_SEEK_SET, NULL);

                if (SUCCEEDED(hr))
                {
                    if (Stream->Stat(&statStg, STATFLAG_NONAME) == S_OK)
                    {
                        dataSize = sizeof(BitmapRecordData) + statStg.cbSize.LowPart;
                    }

                    // move back to the old pos

                    Stream->Seek(oldPos, STREAM_SEEK_SET, NULL);

                    return ((dataSize + 3) & (~3)); // align

                }
            }

        }

        if (Filename != NULL)
        {
            IStream* stream = NULL;

            HRESULT hr = CreateStreamOnFileForRead(Filename, &stream);

            if (SUCCEEDED(hr))
            {
                if (stream->Stat(&statStg, STATFLAG_NONAME) == S_OK)
                {
                    dataSize = sizeof(BitmapRecordData) + statStg.cbSize.LowPart;
                }

                stream->Release();
            }

            return ((dataSize + 3) & (~3)); // align
        }
    }

    // if we cannot get the compressed data
    if ((const_cast<CopyOnWriteBitmap *>(this))->LoadIntoMemory() == Ok)
    {
        BitmapData  bitmapData     = *Bmp;
        INT         positiveStride = bitmapData.Stride;
        INT         paletteSize    = 0;
        INT         pixelDataSize;

        if (positiveStride < 0)
        {
            positiveStride = -positiveStride;
        }

        pixelDataSize = (bitmapData.Height * positiveStride);

        if (IsIndexedPixelFormat(bitmapData.PixelFormat))
        {
            // We're an indexed pixel format - must have a valid palette.
            ASSERT(Bmp->colorpal != NULL);

            // Note sizeof(ColorPalette) includes the first palette entry.
            paletteSize = sizeof(ColorPalette) +
                          sizeof(ARGB)*(Bmp->colorpal->Count - 1);
        }

        dataSize = sizeof(BitmapRecordData) + paletteSize + pixelDataSize;
    }

    return ((dataSize + 3) & (~3)); // align
}

/**************************************************************************\
*
* Function Description:
*
*   Read the bitmap object from memory.
*
* Arguments:
*
*   [IN] dataBuffer - the data that was read from the stream
*   [IN] size - the size of the data
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   4/26/1999 DCurtis
*
\**************************************************************************/
GpStatus
CopyOnWriteBitmap::SetData(
    const BYTE *        dataBuffer,
    UINT                size
    )
{
    ASSERT ((GpImageType)(((BitmapRecordData *)dataBuffer)->Type) == ImageTypeBitmap);

    GpStatus    status = Ok;

    this->FreeData();
    this->InitDefaults();

    if (dataBuffer == NULL)
    {
        WARNING(("dataBuffer is NULL"));
        return InvalidParameter;
    }

    if (size < sizeof(BitmapRecordData))
    {
        WARNING(("size too small"));
        return InvalidParameter;
    }

    const BitmapRecordData *    bitmapData;

    bitmapData = reinterpret_cast<const BitmapRecordData *>(dataBuffer);

    if (!bitmapData->MajorVersionMatches())
    {
        WARNING(("Version number mismatch"));
        return InvalidParameter;
    }

    if (!(bitmapData->Flags & COMPRESSED_IMAGE))
    {
        Bmp = new GpMemoryBitmap();

        if (Bmp != NULL)
        {
            HRESULT hr = Bmp->InitNewBitmap(bitmapData->Width,
                                            bitmapData->Height,
                                            (PixelFormatID)bitmapData->PixelFormat);

            if (FAILED(hr))
            {
                WARNING(("InitNewBitmap failed"));
                delete Bmp;
                Bmp = NULL;
                return GenericError;
            }

            // Fill image info structure

            if ( Bmp->GetImageInfo(&SrcImageInfo) != S_OK )
            {
                WARNING(("InitNewBitmap failed"));
                delete Bmp;
                Bmp = NULL;
                return GenericError;
            }

            PixelFormatInMem = SrcImageInfo.PixelFormat;

            ASSERT(Bmp->Stride == bitmapData->Stride);
            dataBuffer += sizeof(BitmapRecordData);
            size       -= sizeof(BitmapRecordData);

            State = MemBitmap;

            // If it's an indexed format, we'll have stored the palette next
            if(IsIndexedPixelFormat((PixelFormatID)bitmapData->PixelFormat))
            {
                if (size < sizeof(ColorPalette))
                {
                    WARNING(("size too small"));
                    return InvalidParameter;
                }

                UINT paletteSize;
                ColorPalette *pal;
                pal = (ColorPalette *)dataBuffer;

                // Work out how big the palette is.
                // sizeof(ColorPalette) includes the first entry.
                paletteSize = sizeof(ColorPalette)+sizeof(ARGB)*(pal->Count-1);

                if (size < paletteSize)
                {
                    WARNING(("size too small"));
                    return InvalidParameter;
                }

                // Make the GpMemoryBitmap clone the palette into the right place
                Bmp->SetPalette(pal);

                // Update the dataBuffer stream to the beginning of the pixel data
                dataBuffer += paletteSize;
                size       -= paletteSize;
            }
        }
        else
        {
            WARNING(("Out of memory"));
            return OutOfMemory;
        }

        ASSERT((Bmp != NULL) && (Bmp->Scan0 != NULL));

        ULONG   pixelSize = Bmp->Stride * Bmp->Height;

        if (size >= pixelSize)
        {
            size = pixelSize;
        }
        else
        {
            WARNING(("Insufficient data to fill bitmap"));
            status = InvalidParameter;
        }

        if (size > 0)
        {
            GpMemcpy(Bmp->Scan0, dataBuffer, size);
        }
    }
    else
    {
        // Create an IStream on top of the memory buffer

        GpReadOnlyMemoryStream* stream;

        stream = new GpReadOnlyMemoryStream();

        if (!stream)
        {
            WARNING(("Out of memory"));
            return OutOfMemory;
        }

        dataBuffer += sizeof(BitmapRecordData);
        size -= sizeof(BitmapRecordData);

        stream->InitBuffer(dataBuffer, size);

        // since we don't want to hold dataBuffer or make a copy of
        // it, we just Load it into memory here.

        Stream = stream;
        State = ExtStream;

        status = LoadIntoMemory();

        if ( status == Ok )
        {
            // The source image is loaded into memory and we are not going to
            // keep the source image connection any more. So we fill the image
            // info with the memory bits info

            if ( Bmp->GetImageInfo(&SrcImageInfo) != S_OK )
            {
                status = GenericError;
            }
            else
            {
                PixelFormatInMem = SrcImageInfo.PixelFormat;
            }
        }

        stream->Release();
        Stream = NULL;

        if (Img)
        {
            Img->Release();
            Img = NULL;
        }
    }

    return status;
}

char    ColorChannelName[4] = {'C', 'M', 'Y', 'K'};

/**************************************************************************\
*
* Function Description:
*
*   Do the color adjustment if the lower level codec can do it.
*
* Arguments:
*
*   [IN]  recolor     - Pointer to image attributes
*
* Return Value:
*
*   Status code
*       Return Ok -------------Lower level does it
*       Return NotImplemented--Lower level can't do it
*       Other status code
*
* Revision History:
*
*   11/22/1999 minliu
*       Created it.
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::ColorAdjustByCodec(
    GpRecolor * recolor,
    DrawImageAbort callback,
    VOID *callbackData
    )
{
    if (recolor == NULL)
    {
        // The lower level codec doesn't know how to handle this, let the
        // up level do it

        return NotImplemented;
    }

    HRESULT     hResult;

    UINT    uiCurrentFlag = recolor->GetValidFlags(ColorAdjustTypeBitmap);
    BOOL    bImgCreatedHere = FALSE;

    // First we need to check if the current lower level decoder can do the
    // job or not

    if ( Img == NULL )
    {
        // Create a GpDecodedImage*

        if ( NULL != Stream )
        {
            hResult = GpDecodedImage::CreateFromStream(Stream, &Img);
        }
        else
        {
            if ( Filename == NULL )
            {
                // We can't continue. Let the higher level do it

                return NotImplemented;
            }

            hResult = GpDecodedImage::CreateFromFile(Filename, &Img);
        }

        if ( FAILED(hResult) )
        {
            WARNING(("Failed to create decoded image: %x", hResult));
            return Win32Error;
        }

        // Remember that we creat a copy of Img here. Should be freed when done

        bImgCreatedHere = TRUE;
    }// (Img == NULL)

    GUID        DecoderParamGuid;
    UINT        DecoderParamLength;
    PVOID       DecoderParamPtr;
    GpStatus    rCode = Win32Error;

    // Set the GUID and other parameters with respect to the image attributes
    // Note: we won't have a recolor which has both ValidColorKeys and
    // ValidOutputChannel set. This function won't be called if this case is
    // TRUE. We checked this in ColorAdjust()

    UINT value[2];
    if ( uiCurrentFlag & (GpRecolorObject::ValidColorKeys) )
    {
        // Set color key

        DecoderParamGuid = DECODER_TRANSCOLOR;
        DecoderParamLength = 8;

        value[0] = (UINT)(recolor->GetColorKeyLow(ColorAdjustTypeBitmap));
        value[1] = (UINT)(recolor->GetColorKeyHigh(ColorAdjustTypeBitmap));

        DecoderParamPtr = (VOID*)value;
    }
    else if ( uiCurrentFlag & (GpRecolorObject::ValidOutputChannel) )
    {
        // Asks the codec doing a color separation makes sense only when the
        // source image is in CMYK space. Otherwise, we do it in our recolor
        // object which contains a generic algorithem for doing it

        if ( !( (SrcImageInfo.Flags & ImageFlagsColorSpaceCMYK)
              ||(SrcImageInfo.Flags & ImageFlagsColorSpaceYCCK) ) )
        {
            // Not a CMYK image, do it in recolor object

            rCode = NotImplemented;
            goto CleanUp;
        }

        // Set channel output

        DecoderParamGuid = DECODER_OUTPUTCHANNEL;
        DecoderParamLength = 1;

        DecoderParamPtr =
            (VOID*)(&ColorChannelName[recolor->GetChannelIndex(ColorAdjustTypeBitmap)]);
    }

    // Query to see if the decoder can do it or not

    hResult = Img->QueryDecoderParam(DecoderParamGuid);

    if ( (hResult != E_NOTIMPL) && (hResult != S_OK) )
    {
        WARNING(("Failed to query decoder param: %x", hResult));
        goto CleanUp;
    }
    else if ( hResult == E_NOTIMPL )
    {
        // The lower level decoder doesn't support this.

        rCode = NotImplemented;
        goto CleanUp;
    }

    // Set the decoder param to tell the lower level how to decode

    hResult = Img->SetDecoderParam(DecoderParamGuid, DecoderParamLength,
                                   DecoderParamPtr);

    if ( (hResult != E_NOTIMPL) && (hResult != S_OK) )
    {
        WARNING(("Failed to set decoder param: %x", hResult));
        goto CleanUp;
    }
    else if ( hResult == E_NOTIMPL )
    {
        // The lower level decoder doesn't support this.

        rCode = NotImplemented;
        goto CleanUp;
    }

    // Now we don't need the previous "Bmp" since we are going to ask the
    // lower level decoder to create one for us

    if ( Bmp != NULL )
    {
        Bmp->Release();
        Bmp = NULL;
    }

    // Ask the decoder to create a 32BPP ARGB GpMemoryBitmap.

    hResult = GpMemoryBitmap::CreateFromImage(Img,
                                              0,
                                              0,
                                              PIXFMT_32BPP_ARGB,
                                              InterpolationHintDefault,
                                              &Bmp,
                                              callback,
                                              callbackData);

    if ( FAILED(hResult) )
    {
        WARNING(("Failed to load image into memory: %x", hResult));
        goto CleanUp;
    }

    State = MemBitmap;
    PixelFormatInMem = PIXFMT_32BPP_ARGB;

    // The lower level does the job for us.

    rCode = Ok;

CleanUp:
    if ( bImgCreatedHere == TRUE )
    {
        // Note: we don't need to check if Img == NULL or not because this flag
        // would only be set when we successed in creating Img

        Img->Release();
        Img = NULL;
    }

    return rCode;
}// ColorAdjustByCodec()

GpStatus
CopyOnWriteBitmap::ColorAdjust(
    GpRecolor * recolor,
    PixelFormatID pixfmt,
    DrawImageAbort callback,
    VOID *callbackData
    )
{
    HRESULT hr;

    ASSERT(ObjRefCount == 1);
    ASSERT(recolor != NULL);

    // Mark the result image (color adjusted image) as dirty
    // Note: this won't damage the original source image because we always
    // color adjust on a cloned copy of the original image

    SetDirtyFlag(TRUE);

    UINT    uiCurrentFlag = recolor->GetValidFlags(ColorAdjustTypeBitmap);

    // For color key output: we will ask the lower level decoder to do the job
    //    if there is no other recoloring flag is specified
    // For color separation(channel output), we will ask the lower level decoder
    //    to do the job if there is no other recoloring flag is specified except
    //    for ValidColorProfile.
    //    If the codec can handle CMYK separation, then the profile is ignored.
    //    If the source is RGB image, then ColorAdjustByCodec() will do nothing
    //    and we will use the profile to do RGB to CMYK conversion before
    //    channel separation

    if ( uiCurrentFlag
       &&( ((uiCurrentFlag & GpRecolorObject::ValidColorKeys) == uiCurrentFlag)
         ||((uiCurrentFlag
           &(~GpRecolorObject::ValidChannelProfile)
           &(GpRecolorObject::ValidOutputChannel))
             == (GpRecolorObject::ValidOutputChannel) ) ) )
    {
        Status rCode = ColorAdjustByCodec(recolor, callback, callbackData);

        if ( rCode != NotImplemented )
        {
            // Either the lower level did the job for us (rCode == Ok) or it
            // failed somehow (rCode == Win32Error etc.). We just return here

            return rCode;
        }

        // Lower level can't do it. We can just slip here to do the normal
        // software version of color adjust

    }// Color key and color channel handling

    GpStatus status = LoadIntoMemory(pixfmt);

    if ( status != Ok )
    {
        return status;
    }

    hr = Bmp->PerformColorAdjustment(recolor,
                                     ColorAdjustTypeBitmap,
                                     callback, callbackData);

    if ( SUCCEEDED(hr) )
    {
        Bmp->SetAlphaHint(GpMemoryBitmap::ALPHA_UNKNOWN);
        return Ok;
    }
    else if (hr == IMGERR_ABORT)
    {
        WARNING(("CopyOnWriteBitmap::ColorAdjust---Aborted"));
        return Aborted;
    }
    else
    {
        WARNING(("CopyOnWriteBitmap::ColorAdjust---PerformColorAdjustment() failed"));
        return GenericError;
    }
}// ColorAdjust()

/**************************************************************************\
*
* Function Description:
*
*   Get the (current) pixel format of the CopyOnWriteBitmap.
*   Here "current" means the pixel format in the memory if it has been loaded,
*   aka, a GpMemoryBitmap. If it is not in the memory, then we return the
*   PixelFormat of the original image
*
*
* Arguments:
*
*   [OUT]  pixfmt     - Pointer to pixel format
*
* Return Value:
*
*   Status code
*       Ok - success
*       Win32Error - failed
*
* Revision History:
*
*   06/10/2000   asecchia
*       Created it.
*   07/26/2000   minliu
*       Re-wrote it
*
\**************************************************************************/


GpStatus
CopyOnWriteBitmap::GetPixelFormatID(
    PixelFormatID *pixfmt
)
{
    ASSERT(IsValid());

    // If the image is in the memory, then we return the memory bitmap pixel
    // format. Otherwise, return the source image format

    if ( (State == MemBitmap) && (PixelFormatInMem != PixelFormatDontCare) )
    {
        *pixfmt = PixelFormatInMem;
    }
    else
    {
        *pixfmt = SrcImageInfo.PixelFormat;
    }

    return Ok;
}

CopyOnWriteBitmap*
CopyOnWriteBitmap::CloneColorAdjusted(
    GpRecolor *             recolor,
    ColorAdjustType         type
    ) const
{
    ASSERT(recolor != NULL);

    CopyOnWriteBitmap *  clonedBitmap = (CopyOnWriteBitmap *)this->Clone();

    if (clonedBitmap != NULL)
    {
        if ((clonedBitmap->IsValid()) &&
            (clonedBitmap->ColorAdjust(recolor, type) == Ok))
        {
            clonedBitmap->SetDirtyFlag(TRUE);
            return clonedBitmap;
        }
        delete clonedBitmap;
    }
    return NULL;
}

GpStatus
CopyOnWriteBitmap::ColorAdjust(
    GpRecolor *     recolor,
    ColorAdjustType type
    )
{
    ASSERT(recolor != NULL);
    ASSERT(ObjRefCount == 1);

    GpStatus status = LoadIntoMemory();

    if (status != Ok)
    {
        return status;
    }

    if (type == ColorAdjustTypeDefault)
    {
        type = ColorAdjustTypeBitmap;
    }

    HRESULT hr = Bmp->PerformColorAdjustment(recolor, type, NULL, NULL);

    if ( SUCCEEDED(hr) )
    {
        SetDirtyFlag(TRUE);
        return Ok;
    }

    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Override the native resolution of the bitmap.
*
* Arguments:
*
*   xdpi, ydpi - New resolution
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::SetResolution(
    REAL    xdpi,
    REAL    ydpi
    )
{
    if ( (xdpi > 0.0) && (ydpi > 0.0) )
    {
        XDpiOverride = xdpi;
        YDpiOverride = ydpi;

        if ( Img )
        {
            Img->SetResolution(xdpi, ydpi);
        }

        if ( Bmp )
        {
            Bmp->SetResolution(xdpi, ydpi);
        }

        SrcImageInfo.Xdpi = xdpi;
        SrcImageInfo.Ydpi = ydpi;

        // Mark the bits dirty since we have to save the image with the new
        // resolution info.

        SetDirtyFlag(TRUE);

        return Ok;
    }
    else
    {
        return InvalidParameter;
    }
}// SetResolution()

/**************************************************************************\
*
* Function Description:
*
*   INTEROP
*
*   Create a GDI bitmap (HBITMAP) from a GDI+ bitmap.
*
* Arguments:
*
*   phbm -- Return HBITMAP via this pointer
*   background -- If GDI+ bitmap has alpha, blend with this color as the
*                 background
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::CreateHBITMAP(HBITMAP *phbm, ARGB background)
{
    GpStatus status;

    // These objects need cleanup:

    HDC hdc = NULL;
    HBITMAP hbmOld = NULL;
    HBITMAP hbmNew = NULL;
    HBRUSH hbr = NULL;
    HBRUSH hbrOld = NULL;
    GpGraphics *g = NULL;

    // Get format information for this bitmap:

    // Create HDC:

    hdc = CreateCompatibleDC(NULL);
    if (!hdc)
    {
        WARNING(("CreateHBITMAP: CreateCompatibleDC failed"));
        status = Win32Error;
        goto error_cleanup;
    }

    // Create DIB section:

    BITMAPINFO bmi;
    VOID *pv;

    GpMemset(&bmi, 0, sizeof(bmi));
    bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth       = SrcImageInfo.Width;
    bmi.bmiHeader.biHeight      = SrcImageInfo.Height;
    bmi.bmiHeader.biPlanes      = 1;
    bmi.bmiHeader.biBitCount    = 32;
    bmi.bmiHeader.biCompression = BI_RGB;

    hbmNew = CreateDIBSection(hdc, &bmi, DIB_RGB_COLORS, &pv, NULL, 0);
    if (!hbmNew)
    {
        WARNING(("CreateHBITMAP: CreateDIBSection failed\n"));
        status = Win32Error;
        goto error_cleanup;
    }

    // Select DIB into DC:

    hbmOld = (HBITMAP) SelectObject(hdc, hbmNew);
    if (!hbmOld)
    {
        WARNING(("CreateHBITMAP: SelectObject(hbm) failed\n"));
        status = Win32Error;
        goto error_cleanup;
    }

    // Clear DIB to specified ARGB color:

    LOGBRUSH lbr;

    lbr.lbStyle = BS_SOLID;
    lbr.lbColor = RGB(background & 0x00ff0000,
                      background & 0x0000ff00,
                      background & 0x000000ff);

    hbr = CreateBrushIndirect(&lbr);
    if (!hbr)
    {
        WARNING(("CreateHBITMAP: CreateBrushIndirect failed\n"));
        status = Win32Error;
        goto error_cleanup;
    }

    hbrOld = (HBRUSH) SelectObject(hdc, hbr);
    if (!hbrOld)
    {
        WARNING(("CreateHBITMAP: SelectObject(hbr) failed\n"));
        status = Win32Error;
        goto error_cleanup;
    }

    PatBlt(hdc, 0, 0, SrcImageInfo.Width, SrcImageInfo.Height, PATCOPY);

    // Derive Graphics from HDC:

    g = GpGraphics::GetFromHdc(hdc);
    if (!g)
    {
        WARNING(("CreateHBITMAP: GpGraphics::GetFromHdc failed\n"));
        status = OutOfMemory;
        goto error_cleanup;
    }

    // DrawImage bitmap to Graphics:

    {
        GpLock lock(g->GetObjectLock());
        if (lock.IsValid())
        {
            FPUStateSaver fpState;

            GpRectF rect(0.0, 0.0, TOREAL(SrcImageInfo.Width),
                         TOREAL(SrcImageInfo.Height));
            GpBitmap tmpBitmap(this);
            status = g->DrawImage(&tmpBitmap, rect, rect, UnitPixel);

            if (status == Ok)
            {
                // Bypass cleanup of the bitmap, we want to keep it:

                *phbm = hbmNew;
                hbmNew = NULL;
            }
            else
            {
                WARNING(("CreateHBITMAP: GpGraphics::DrawImage failed"));
            }
        }
        else
        {
            status = ObjectBusy;
        }
    }

error_cleanup:

    if (hdc)
    {
        if (hbmOld)
            SelectObject(hdc, hbmOld);

        if (hbrOld)
            SelectObject(hdc, hbrOld);

        DeleteDC(hdc);
    }

    if (hbmNew)
        DeleteObject(hbmNew);

    if (hbr)
        DeleteObject(hbr);

    if (g)
        delete g;

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   INTEROP
*
*   Create a Win32 icon (HICON) from a GDI+ bitmap.
*
* Arguments:
*
*   phicon -- Return HICON via this pointer
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

VOID ExportMask32BPP(BitmapData* mask, BitmapData* src)
{
    ASSERT(src->PixelFormat == PIXFMT_32BPP_ARGB);
    ASSERT(mask->PixelFormat == PIXFMT_32BPP_RGB);
    ASSERT(src->Width == mask->Width);
    ASSERT(src->Height == mask->Height);
    ASSERT(src->Scan0 != NULL);
    ASSERT(mask->Scan0 != NULL);

    BYTE* srcScan = static_cast<BYTE*>(src->Scan0);
    BYTE* maskScan = static_cast<BYTE*>(mask->Scan0);

    for (UINT row = 0; row < src->Height; row++)
    {
        ARGB *srcPixel = static_cast<ARGB*>(static_cast<VOID*>(srcScan));
        ARGB *maskPixel = static_cast<ARGB*>(static_cast<VOID*>(maskScan));

        for (UINT col = 0; col < src->Width; col++)
        {
            if ((*srcPixel & 0xff000000) == 0xff000000)
                *maskPixel = 0;            // Opaque
            else
                *maskPixel = 0x00ffffff;   // Transparent

            srcPixel++;
            maskPixel++;
        }

        srcScan = srcScan + src->Stride;
        maskScan = maskScan + mask->Stride;
    }
}

GpStatus
CopyOnWriteBitmap::CreateHICON(
    HICON *phicon
    )
{
    GpStatus status = Win32Error;

    ICONINFO iconInfo;

    iconInfo.fIcon = TRUE;

    status = CreateHBITMAP(&iconInfo.hbmColor, 0);

    if (status == Ok)
    {
        BitmapData bmpDataSrc;

        status = this->LockBits(NULL,
                                IMGLOCK_READ,
                                PIXFMT_32BPP_ARGB,
                                &bmpDataSrc);

        if (status == Ok)
        {
            // From this point on, assume failure until we succeed:

            status = Win32Error;

            // Create empty bitmap for the icon mask:

            iconInfo.hbmMask = CreateBitmap(bmpDataSrc.Width,
                                            bmpDataSrc.Height,
                                            1, 1, NULL);

            if (iconInfo.hbmMask != NULL)
            {
                VOID *gdiBitmapData = GpMalloc(bmpDataSrc.Width
                                               * bmpDataSrc.Height
                                               * 4);

                if (gdiBitmapData)
                {
                    // Convert alpha channel into a 32bpp DIB mask:

                    BitmapData bmpDataMask;

                    bmpDataMask.Width  = bmpDataSrc.Width;
                    bmpDataMask.Height = bmpDataSrc.Height;
                    bmpDataMask.Stride = bmpDataSrc.Width * 4;
                    bmpDataMask.PixelFormat = PIXFMT_32BPP_RGB;
                    bmpDataMask.Scan0 = gdiBitmapData;
                    bmpDataMask.Reserved = 0;

                    ExportMask32BPP(&bmpDataMask, &bmpDataSrc);

                    // Set mask bits:

                    BYTE bufferBitmapInfo[sizeof(BITMAPINFO)];
                    BITMAPINFO *gdiBitmapInfo = (BITMAPINFO *) bufferBitmapInfo;

                    memset(bufferBitmapInfo, 0, sizeof(bufferBitmapInfo));
                    gdiBitmapInfo->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);

                    gdiBitmapInfo->bmiHeader.biWidth  = bmpDataSrc.Width;
                    gdiBitmapInfo->bmiHeader.biHeight = - static_cast<LONG>
                                                          (bmpDataSrc.Height);
                    gdiBitmapInfo->bmiHeader.biPlanes       = 1;
                    gdiBitmapInfo->bmiHeader.biBitCount     = 32;
                    gdiBitmapInfo->bmiHeader.biCompression  = BI_RGB;

                    HDC hdc = GetDC(NULL);

                    if (hdc != NULL)
                    {
                        SetTextColor(hdc, RGB(0, 0, 0));
                        SetBkColor(hdc, RGB(0xff, 0xff, 0xff));
                        SetBkMode(hdc, OPAQUE);

                        if (SetDIBits(hdc,
                                      iconInfo.hbmMask,
                                      0,
                                      bmpDataSrc.Height,
                                      gdiBitmapData,
                                      gdiBitmapInfo,
                                      DIB_RGB_COLORS
                                     ))
                        {
                            // Create icon:

                            *phicon = CreateIconIndirect(&iconInfo);

                            if (*phicon != NULL)
                                status = Ok;
                            else
                            {
                                WARNING(("CreateIconIndirect failed"));
                            }
                        }
                        else
                        {
                            WARNING(("SetDIBits failed"));
                        }

                        ReleaseDC(NULL, hdc);
                    }

                    GpFree(gdiBitmapData);
                }
                else
                {
                    WARNING(("memory allocation failed"));
                    status = OutOfMemory;
                }

                DeleteObject(iconInfo.hbmMask);
            }
            else
            {
                WARNING(("CreateBitmap failed"));
            }

            this->UnlockBits(&bmpDataSrc);
        }
        else
        {
            WARNING(("LockBits failed"));
        }

        DeleteObject(iconInfo.hbmColor);
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Prep the bitmap for drawing.
*
*   Currently, the only thing we do is check if the bitmap is an ICON.
*   If so, we set the DECODER_ICONRES parameters if supported.
*
* Arguments:
*
*   numPoints
*   dstPoints           Specifies the destination area
*
*   srcRect             Specifies the source area
*
*   numBitsPerPixel     Specifies the bits-per-pixel of the destination
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::PreDraw(
    INT numPoints,
    GpPointF *dstPoints,
    GpRectF *srcRect,
    INT numBitsPerPixel
    )
{
    // Check if ICON:

    GpStatus status = Ok;

    if ( SrcImageInfo.RawDataFormat == IMGFMT_ICO )
    {
        status = SetIconParameters(numPoints, dstPoints, srcRect,
                                   numBitsPerPixel);
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Set the decode parameters for multi-resolution icons.
*
* Arguments:
*
*   numPoints
*   dstPoints           Specifies the destination area
*
*   srcRect             Specifies the source area
*
*   numBitsPerPixel     Specifies the bits-per-pixel of the destination
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::SetIconParameters(
    INT numPoints,
    GpPointF *dstPoints,
    GpRectF *srcRect,
    INT numBitsPerPixel
    )
{
    // Check if DECODER_ICONRES supported:

    HRESULT hResult;

    BOOL imageCleanupNeeded = FALSE;

    // First we need to check if the current lower level decoder can do the
    // job or not

    if (Img == NULL)
    {
        // Create a GpDecodedImage*

        if (NULL != Stream)
        {
            hResult = GpDecodedImage::CreateFromStream(Stream, &Img);
        }
        else
        {
            if (Filename == NULL)
            {
                // We can't continue. Let the higher level do it

                return GenericError;
            }

            hResult = GpDecodedImage::CreateFromFile(Filename, &Img);
        }

        if (FAILED(hResult))
        {
            WARNING(("Failed to create decoded image: %x", hResult));
            return Win32Error;
        }

        // Remember that we creat a copy of Img here. Should be freed when done

        imageCleanupNeeded = TRUE;
    }

    GpStatus status = Win32Error;

    // Query to see if the decoder can do it or not

    hResult = Img->QueryDecoderParam(DECODER_ICONRES);

    if (hResult != S_OK)
    {
        if ((hResult == E_FAIL) || (hResult == E_NOTIMPL))
        {
            // Decoder doesn't want it, which is OK.

            status = Ok;
            goto CleanUp;
        }
        else
        {
            // Something else is wrong

            goto CleanUp;
        }
    }

    // Setup the GUID and decode parameters

    {
        UINT value[3];
        value[0] = static_cast<UINT>
                   (GetDistance(dstPoints[0], dstPoints[1]) + 0.5);
        value[1] = static_cast<UINT>
                   (GetDistance(dstPoints[0], dstPoints[2]) + 0.5);
        value[2] = numBitsPerPixel;

        UINT  DecoderParamLength = 3*sizeof(UINT);
        PVOID DecoderParamPtr = (VOID*) value;

        // Set the decoder param to tell the lower level how to decode

        hResult = Img->SetDecoderParam(DECODER_ICONRES,
                                       DecoderParamLength,
                                       DecoderParamPtr);
    }

    if (hResult != S_OK)
    {
        if ((hResult == E_FAIL) || (hResult == E_NOTIMPL))
        {
            // Decoder doesn't want it, which is OK.

            status = Ok;
            goto CleanUp;
        }
        else
        {
            // Something else is wrong

            goto CleanUp;
        }
    }

    // Now we don't need the previous "Bmp" since we are going to ask the
    // lower level decoder to create one for us

    if ( Bmp != NULL )
    {
        Bmp->Release();
        Bmp = NULL;
    }

    // Ask the decoder to create a 32BPP ARGB GpMemoryBitmap.

    hResult = GpMemoryBitmap::CreateFromImage(Img,
                                              0,
                                              0,
                                              PIXFMT_32BPP_ARGB,
                                              InterpolationHintDefault,
                                              &Bmp,
                                              NULL,
                                              NULL);

    if ( FAILED(hResult) )
    {
        WARNING(("Failed to load image into memory: %x", hResult));
        goto CleanUp;
    }

    State = MemBitmap;
    PixelFormatInMem = PIXFMT_32BPP_ARGB;

    // The lower level does the job for us.

    status = Ok;

CleanUp:

    if ((status == Ok) && (srcRect != NULL))
    {
        // Icons are not allowed to clip

        srcRect->X = 0;
        srcRect->Y = 0;
        srcRect->Width  = (REAL) SrcImageInfo.Width;
        srcRect->Height = (REAL) SrcImageInfo.Height;
    }

    if (imageCleanupNeeded == TRUE)
    {
        Img->Release();
        Img = NULL;
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Get the transparency state of the bitmap
*
* Arguments:
*
*   transparency        Returned state
*
* Return Value:
*
*   Status code
*
\**************************************************************************/
GpStatus
CopyOnWriteBitmap::GetTransparencyHint(
    DpTransparency* transparency
    )
{
    GpStatus status = GenericError;

    if (Bmp != NULL)
    {
        INT alphaHint;

        HRESULT hr = Bmp->GetAlphaHint(&alphaHint);

        if (SUCCEEDED(hr))
        {
            // It's unfortunate that GpMemoryBitmap does not have
            // a DpTransparency flag internally, but there's a conflict
            // with imaging.dll and the include file structure that for
            // now makes it necessary to keep a separate type for this info.

            // In fact, ultimately it would be best if the overlap
            // between DpBitmap and GpMemoryBitmap is resolved including
            // a DpBitmap structure within the GpMemoryBitmap and then
            // removing the redundant info out GpMemoryBitmap.

            switch (alphaHint)
            {
            case GpMemoryBitmap::ALPHA_SIMPLE:
                *transparency = TransparencySimple;
                break;

            case GpMemoryBitmap::ALPHA_OPAQUE:
                *transparency = TransparencyOpaque;
                break;

            case GpMemoryBitmap::ALPHA_NONE:
                *transparency = TransparencyNoAlpha;
                break;

            case GpMemoryBitmap::ALPHA_COMPLEX:
                *transparency = TransparencyComplex;
                break;

            default:
                *transparency = TransparencyUnknown;
                break;
            }

            status = Ok;
        }
        else
        {
            ASSERT(SUCCEEDED(hr));
            *transparency = TransparencyUnknown;
        }
    }
    else
    {
        *transparency = TransparencyUnknown;
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Get the transparency state of the bitmap.  This routine returns accurate
* info while GetTransparencyHint just returns a hint
*
*   This routine could scan the whole bitmap (32bpp) so whoever uses it should
* consider the perf hit.
*
*   This is currently only for use by the printer drivers.
*
* Arguments:
*
*   transparency        Returned state
*
* Return Value:
*
*   Status code
*
\**************************************************************************/
GpStatus
CopyOnWriteBitmap::GetTransparencyFlags(
    DpTransparency* transparency,
    PixelFormatID   loadFormat,
    BYTE*           minA,
    BYTE*           maxA
    )
{
    GpStatus status = GenericError;

    ARGB argb;
    ARGB minAlpha = 0xff000000;
    ARGB maxAlpha = 0;

    INT newAlphaHint = GpMemoryBitmap::ALPHA_OPAQUE;

TestBmp:
    if (Bmp != NULL)
    {
        INT alphaHint;

        // the alpha transparency could change if the bitmap has changed

        HRESULT hr = Bmp->GetAlphaHint(&alphaHint);

        if (SUCCEEDED(hr))
        {
            // It's unfortunate that GpMemoryBitmap does not have
            // a DpTransparency flag internally, but there's a conflict
            // with imaging.dll and the include file structure that for
            // now makes it necessary to keep a separate type for this info.

            // In fact, ultimately it would be best if the overlap
            // between DpBitmap and GpMemoryBitmap is resolved including
            // a DpBitmap structure within the GpMemoryBitmap and then
            // removing the redundant info out GpMemoryBitmap.

            switch (alphaHint)
            {
            case GpMemoryBitmap::ALPHA_SIMPLE:
                *transparency = TransparencySimple;
                break;

            case GpMemoryBitmap::ALPHA_OPAQUE:
                *transparency = TransparencyOpaque;
                break;

            case GpMemoryBitmap::ALPHA_NONE:
                *transparency = TransparencyNoAlpha;
                break;

            case GpMemoryBitmap::ALPHA_COMPLEX:
                *transparency = TransparencyComplex;
                break;

            case GpMemoryBitmap::ALPHA_NEARCONSTANT:
                *transparency = TransparencyNearConstant;

                if (minA != NULL && maxA != NULL)
                {
                    // if the flag is nearconstant alpha, we must have got valid min and max alpha
                    Bmp->GetMinMaxAlpha(minA, maxA);
                }

                break;

            default:
                *transparency = TransparencyUnknown;
                break;
            }

            status = Ok;

            // printing needs more accuarate info and is always loaded into memory
            // before send down to the printer drivers

            // 16bpp1555 is handled at initialization already.

            // TransparencyUnknown means the bitmap can have alpha we just don't know what we have
            // TransparencyNoAlpha means the bitmap format doesn't support alpha

            if (*transparency == TransparencyUnknown)
            {
                if (IsAlphaPixelFormat(Bmp->PixelFormat))
                {
                    // the memory bitmap must be locked before we enter here
                    // We don't require the object to be locked.  The object should be
                    // decoded already in memory.  This is true in the case of DrvDrawImage
                    // and texture brush images.
                    //ASSERT(ObjRefCount > 1);
                    *transparency = TransparencyOpaque;


                    if ((Bmp->PixelFormat == PIXFMT_32BPP_ARGB) || (Bmp->PixelFormat == PIXFMT_32BPP_PARGB))
                    {
                        ARGB argb;
                        *transparency = TransparencyOpaque;

                        UINT x, y;

                        BYTE *scanStart = static_cast<BYTE *>(Bmp->Scan0);
                        ARGB *scanPtr;

                        for (y = 0; y < Bmp->Height; y++)
                        {
                            scanPtr = reinterpret_cast<ARGB *>(scanStart);

                            for (x = 0; x < Bmp->Width; x++)
                            {
                                argb = (*scanPtr++) & 0xff000000;

                                if (argb < minAlpha)
                                {
                                    minAlpha = argb;
                                }

                                if (argb > maxAlpha)
                                {
                                    maxAlpha = argb;
                                }

                                if (argb != 0xff000000)
                                {
                                    if (argb == 0)
                                    {
// Prefast bug 518296 - the condition below is always true, this is definitely a bug
// and the || must be replaced with &&. We have no precedent however that this
// causes customer problems, hence it does not meet the SP bar.
/*
                                        if ((*transparency != TransparencyComplex) ||
                                            (*transparency != TransparencyNearConstant))
*/
                                        {
                                            *transparency = TransparencySimple;
                                        }
                                    }
                                    else
                                    {
                                        if ((maxAlpha - minAlpha) <= (NEARCONSTANTALPHA << 24))
                                        {
                                            *transparency = TransparencyNearConstant;
                                        }
                                        else
                                        {
                                            *transparency = TransparencyComplex;
                                            goto done;
                                        }
                                    }
                                }
                            }

                            scanStart += Bmp->Stride;
                        }

                        goto done;
                    }
                    else
                    {
                        RIP(("TransparencyUnknown returned for pixel format w/ alpha"));

                        goto done;
                    }
                }
                else if (IsIndexedPixelFormat(Bmp->PixelFormat) &&
                         Bmp->colorpal)
                {
                    // Compute transparancy hint from palette
                    // if we worry about cases
                    // that the transparent index is not used in the bitmap
                    // then we have to scan the whole bitmap.
                    // I believe this is sufficient for now unless someone
                    // run into problems that really need to scan the whole bitmap

                    *transparency = TransparencyOpaque;

                    for (UINT i = 0; i < Bmp->colorpal->Count; i++)
                    {
                        argb = Bmp->colorpal->Entries[i] & 0xff000000;

                        if (argb < minAlpha)
                        {
                            minAlpha = argb;
                        }

                        if (argb > maxAlpha)
                        {
                            maxAlpha = argb;
                        }

                        if (argb != 0xff000000)
                        {
                            if (argb == 0)
                            {
// See the comments above.
/*

                                if ((*transparency != TransparencyComplex) ||
                                    (*transparency != TransparencyNearConstant))
*/                                    
                                {
                                    *transparency = TransparencySimple;
                                }
                            }
                            else
                            {
                                if ((maxAlpha - minAlpha) <= (NEARCONSTANTALPHA << 24))
                                {
                                    *transparency = TransparencyNearConstant;
                                }
                                else
                                {
                                    *transparency = TransparencyComplex;
                                    goto done;
                                }
                            }
                        }

                    }

                    goto done;
                }
                else
                {
                    // Native pixel format does not support alpha
                    *transparency = TransparencyNoAlpha;
                }
            }
        }
        else
        {
            *transparency = TransparencyUnknown;
        }
    }
    else
    {
        status = LoadIntoMemory(loadFormat);

        if (status == Ok)
        {
            ASSERT(Bmp != NULL);
            goto TestBmp;
        }

        *transparency = TransparencyUnknown;
    }

    return status;

done:
    // Set alpha hint back into GpMemoryBitmap
    // so we don't have to scan the bitmap again later

    if (*transparency == TransparencySimple)
    {
        newAlphaHint = GpMemoryBitmap::ALPHA_SIMPLE;
    }
    else if (*transparency == TransparencyComplex)
    {
        newAlphaHint = GpMemoryBitmap::ALPHA_COMPLEX;
    }
    else if (*transparency == TransparencyNearConstant)
    {
        if (minA != NULL && maxA != NULL)
        {
            *minA = (BYTE)(minAlpha >> 24);
            *maxA = (BYTE)(maxAlpha >> 24);
        }

        Bmp->SetMinMaxAlpha((BYTE)(minAlpha >> 24), (BYTE)(maxAlpha >> 24));

        newAlphaHint = GpMemoryBitmap::ALPHA_NEARCONSTANT;
    }
    else if (*transparency == TransparencyOpaque)
    {
        newAlphaHint = GpMemoryBitmap::ALPHA_OPAQUE;
    }

    Bmp->SetAlphaHint(newAlphaHint);

   return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Set the transparency state of the bitmap
*
* Arguments:
*
*   transparency        Returned state
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::SetTransparencyHint(
    DpTransparency transparency
    )
{
    GpStatus status = GenericError;

    if (Bmp != NULL)
    {
        INT alphaHint;

        // It's unfortunate that GpMemoryBitmap does not have
        // a DpTransparency flag internally, but there's a conflict
        // with imaging.dll and the include file structure that for
        // now makes it necessary to keep a separate type for this info.

        // In fact, ultimately it would be best if the overlap
        // between DpBitmap and GpMemoryBitmap is resolved including
        // a DpBitmap structure within the GpMemoryBitmap and then
        // removing the redundant info out GpMemoryBitmap.

        switch (transparency)
        {
        case TransparencySimple:
            alphaHint = GpMemoryBitmap::ALPHA_SIMPLE;
            break;

        case TransparencyOpaque:
            alphaHint = GpMemoryBitmap::ALPHA_OPAQUE;
            break;

        case TransparencyNoAlpha:
            alphaHint = GpMemoryBitmap::ALPHA_NONE;
            break;

        case TransparencyUnknown:
            alphaHint = GpMemoryBitmap::ALPHA_UNKNOWN;
            break;

        default:
            alphaHint = GpMemoryBitmap::ALPHA_COMPLEX;
            break;
        }

        HRESULT hr = Bmp->SetAlphaHint(alphaHint);

        if (SUCCEEDED(hr))
            status = Ok;
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Rotate and Flip the image in memory.
*
* Arguments:
*
*   [IN]rfType -- Rotate and Flip type
*
* Return Value:
*
*   Status code
*
* Revision History:
*
*   10/06/2000 minliu
*       Created it.
*
\**************************************************************************/

GpStatus
CopyOnWriteBitmap::RotateFlip(
    RotateFlipType rfType
    )
{
    if ( rfType == RotateNoneFlipNone )
    {
        // Same for Rotate180FlipXY, this is a No-OP

        return Ok;
    }

    if ( (IsDirty() == FALSE)
       &&(State >= MemBitmap)
       &&(SrcImageInfo.PixelFormat != PixelFormatInMem)
       &&(Img != NULL) )
    {
        // If the image is:
        // 1) Not dirty
        // 2) Was loaded into memory with different color depth for some reason,
        //    like DrawImage()
        // 3) We have an source image
        //
        // Then we can throw away the bits in memory and reload the bits from
        // the original. The purpose of this is that we should always do Rotate
        // or Flip on the original image.

        ASSERT( Bmp != NULL )
        Bmp->Release();
        Bmp = NULL;
        State = DecodedImg;
        PixelFormatInMem = PixelFormatUndefined;
    }

    // Rotate and Flip OP can only be done in memory
    // If the image hasn't been loaded, load into memory with the original
    // pixel format

    GpStatus    status = LoadIntoMemory(SrcImageInfo.PixelFormat);
    if ( status != Ok )
    {
        WARNING(("CopyOnWriteBitmap::RotateFlip---LoadIntoMemory() failed"));
        return status;
    }

    IBitmapImage* newBmp = NULL;

    HRESULT hResult = S_OK;

    switch ( rfType )
    {
    case Rotate90FlipNone:
        // Rotate270FlipXY    = Rotate90FlipNone

        hResult = Bmp->Rotate(90, INTERP_DEFAULT, &newBmp);
        break;

    case Rotate180FlipNone:
        // RotateNoneFlipXY   = Rotate180FlipNone

        hResult = Bmp->Rotate(180, INTERP_DEFAULT, &newBmp);
        break;

    case Rotate270FlipNone:
        // Rotate90FlipXY

        hResult = Bmp->Rotate(270, INTERP_DEFAULT, &newBmp);
        break;

    case RotateNoneFlipX:
        // Rotate180FlipY     = RotateNoneFlipX

        hResult = Bmp->Flip(TRUE, FALSE, &newBmp);
        break;

    case Rotate90FlipX:
        // Rotate270FlipY     = Rotate90FlipX

        hResult = Bmp->Rotate(90, INTERP_DEFAULT, &newBmp);
        if ( SUCCEEDED(hResult) )
        {
            Bmp->Release();
            Bmp = (GpMemoryBitmap*)newBmp;

            hResult = Bmp->Flip(TRUE, FALSE, &newBmp);
        }

        break;

    case Rotate180FlipX:
        // RotateNoneFlipY    = Rotate180FlipX

        hResult = Bmp->Rotate(180, INTERP_DEFAULT, &newBmp);
        if ( SUCCEEDED(hResult) )
        {
            Bmp->Release();
            Bmp = (GpMemoryBitmap*)newBmp;

            hResult = Bmp->Flip(TRUE, FALSE, &newBmp);
        }

        break;

    case Rotate270FlipX:
        // Rotate90FlipY      = Rotate270FlipX

        hResult = Bmp->Rotate(270, INTERP_DEFAULT, &newBmp);
        if ( SUCCEEDED(hResult) )
        {
            Bmp->Release();
            Bmp = (GpMemoryBitmap*)newBmp;

            hResult = Bmp->Flip(TRUE, FALSE, &newBmp);
        }

        break;

    default:
        WARNING(("CopyOnWriteBitmap::RotateFlip---Invalid input parameter"));
        return InvalidParameter;
    }

    if ( FAILED(hResult) )
    {
        WARNING(("CopyOnWriteBitmap::RotateFlip---Rotate failed"));
        return Win32Error;
    }

    // Check how many property items in this image

    UINT    uiNumOfProperty = 0;
    status = GetPropertyCount(&uiNumOfProperty);

    if ( status != Ok )
    {
        // It is OK if we failed to get property. We still have the Rotate/Flip
        // result

        WARNING(("CopyOnWriteBitmap::RotateFlip---GetPropertyCount() failed"));
    }

    if ( uiNumOfProperty > 0 )
    {
        PROPID* pList = (PROPID*)GpMalloc(uiNumOfProperty * sizeof(PROPID));
        if ( pList == NULL )
        {
            WARNING(("CopyOnWriteBitmap::RotateFlip---GpMalloc() failed"));
            return OutOfMemory;
        }

        status = GetPropertyIdList(uiNumOfProperty, pList);
        if ( status != Ok )
        {
            WARNING(("COnWriteBitmap::RotateFlip-GetPropertyIdList() failed"));
            GpFree(pList);
            return status;
        }

        UINT            uiItemSize = 0;
        PropertyItem*   pItem = NULL;

        GpMemoryBitmap* pTempBmp = (GpMemoryBitmap*)newBmp;

        // Loop through all the property items, get it from current image and
        // set it to the new image. Filter out and adjust some if necessary

        for ( int i = 0; i < (int)uiNumOfProperty; ++i )
        {
            // Get size for the i th property item

            status = GetPropertyItemSize(pList[i], &uiItemSize);
            if ( status != Ok )
            {
                WARNING(("COWBitmap::RotateFlip-GetPropertyItemSize() failed"));
                GpFree(pList);
                return status;
            }

            // Allocate memory buffer for receiving it

            pItem = (PropertyItem*)GpMalloc(uiItemSize);
            if ( pItem == NULL )
            {
                WARNING(("CopyOnWriteBitmap::RotateFlip---GpMalloc() failed"));
                GpFree(pList);
                return OutOfMemory;
            }

            // Get the i th property item

            status = GetPropertyItem(pList[i], uiItemSize, pItem);
            if ( status != Ok )
            {
                WARNING(("COWriteBitmap::RotateFlip-GetPropertyItem() failed"));
                GpFree(pItem);
                GpFree(pList);
                return status;
            }

            // We need to do some property information adjustment here according
            // to the rfType

            if ( (rfType == Rotate90FlipNone)
               ||(rfType == Rotate270FlipNone)
               ||(rfType == Rotate90FlipX)
               ||(rfType == Rotate270FlipX) )
            {
                // Swap the X and Y dimension info if rotate 90 or 270

                switch ( pList[i] )
                {
                case PropertyTagImageWidth:
                    pItem->id = PropertyTagImageHeight;
                    break;

                case PropertyTagImageHeight:
                    pItem->id = PropertyTagImageWidth;
                    break;

                case PropertyTagXResolution:
                    pItem->id = PropertyTagYResolution;
                    break;

                case PropertyTagYResolution:
                    pItem->id = PropertyTagXResolution;
                    break;

                case PropertyTagResolutionXUnit:
                    pItem->id = PropertyTagResolutionYUnit;
                    break;

                case PropertyTagResolutionYUnit:
                    pItem->id = PropertyTagResolutionXUnit;
                    break;

                case PropertyTagResolutionXLengthUnit:
                    pItem->id = PropertyTagResolutionYLengthUnit;
                    break;

                case PropertyTagResolutionYLengthUnit:
                    pItem->id = PropertyTagResolutionXLengthUnit;
                    break;

                case PropertyTagExifPixXDim:
                    pItem->id = PropertyTagExifPixYDim;
                    break;

                case PropertyTagExifPixYDim:
                    pItem->id = PropertyTagExifPixXDim;
                    break;

                default:
                    // For rest of property IDs, no need to swap

                    break;
                }
            }// Case of rotate 90 degree

            // Set the property item in the new GpMemoryBitmap object

            hResult = pTempBmp->SetPropertyItem(*pItem);
            if ( hResult != S_OK )
            {
                WARNING(("COWriteBitmap::RotateFlip-SetPropertyItem() failed"));
                GpFree(pItem);
                GpFree(pList);
                return MapHRESULTToGpStatus(hResult);
            }

            GpFree(pItem);
            pItem = NULL;
        }// Loop through all the property items

        GpFree(pList);
    }// if ( uiNumOfProperty > 0 )

    // Replace the image

    Bmp->Release();
    Bmp = (GpMemoryBitmap*)newBmp;
    State = MemBitmap;

    // Set special hack for JPEG image

    if (Img && (SpecialJPEGSave == TRUE))
    {
        Bmp->SetSpecialJPEG(Img);
    }

    SetDirtyFlag(TRUE);

    // Since this image is dirty now, we don't need to have any connection
    // with the original image if there is one

    GpFree(Filename);
    Filename = NULL;

    if ( NULL != Stream )
    {
        Stream->Release();
        Stream = NULL;
    }

    // We can't release the Img pointer until save() is called if this is a
    // special JPEG lossless transform save case

    if (Img && (SpecialJPEGSave == FALSE))
    {
        Img->Release();
        Img = NULL;
    }

    // Update image info

    hResult = Bmp->GetImageInfo(&SrcImageInfo);

    if ( SUCCEEDED(hResult) )
    {
        PixelFormatInMem = SrcImageInfo.PixelFormat;
    }
    else
    {
        WARNING(("CopyOnWriteBitmap::RotateFlip---GetImageInfo() failed"));
        return MapHRESULTToGpStatus(hResult);
    }

    return Ok;
}// RotateFlip()

// -------------------------------------------------------------------------

GpBitmap::GpBitmap(
    const CopyOnWriteBitmap *   internalBitmap
    ) : GpImage(ImageTypeBitmap), ScanBitmapRef(1)
{
    ASSERT((internalBitmap != NULL) && internalBitmap->IsValid());
    InternalBitmap = (CopyOnWriteBitmap *)internalBitmap;
    InternalBitmap->AddRef();
    ScanBitmap.SetBitmap(this);
}

GpBitmap::GpBitmap(
    BOOL    createInternalBitmap
    ) : GpImage(ImageTypeBitmap), ScanBitmapRef(1)
{
    if (createInternalBitmap)
    {
        // this case is used by the object factory for metafile playback
        InternalBitmap = new CopyOnWriteBitmap();
    }
    else
    {
        InternalBitmap = NULL;
    }
    ScanBitmap.SetBitmap(this);
}

GpBitmap::GpBitmap(
    const GpBitmap *    bitmap
    ) : GpImage(ImageTypeBitmap), ScanBitmapRef(1)
{
    ASSERT ((bitmap != NULL) && (bitmap->InternalBitmap != NULL) && bitmap->InternalBitmap->IsValid());
    InternalBitmap = (CopyOnWriteBitmap *)bitmap->InternalBitmap;
    InternalBitmap->AddRef();
    ScanBitmap.SetBitmap(this);
}

// Destructor
//  We don't want apps to use delete operator directly.
//  Instead, they should use the Dispose method.

GpBitmap::~GpBitmap()
{
    if (InternalBitmap != NULL)
    {
        InternalBitmap->Release();
        InternalBitmap = NULL;
    }
    ScanBitmap.FreeData();
}

CopyOnWriteBitmap *
GpBitmap::LockForWrite()
{
    ASSERT(InternalBitmap != NULL);

    CopyOnWriteBitmap *     writeableBitmap;

    writeableBitmap = (CopyOnWriteBitmap *)InternalBitmap->LockForWrite();

    if (writeableBitmap != NULL)
    {
        InternalBitmap = writeableBitmap;
        UpdateUid();
        return writeableBitmap;
    }

    return NULL;
}

VOID
GpBitmap::Unlock() const
{
    ASSERT(InternalBitmap != NULL);

    BOOL    valid = InternalBitmap->IsValid();

    InternalBitmap->Unlock();

    // If the operation we did on the internal bitmap somehow invalidated
    // it then invalidate this GpBitmap object as well.
    if (!valid)
    {
        InternalBitmap->Release();
        ((GpBitmap *)this)->InternalBitmap = NULL;
    }
}

VOID
GpBitmap::LockForRead() const
{
    ASSERT(InternalBitmap != NULL);

    InternalBitmap->LockForRead();
}

// Constructors

GpBitmap::GpBitmap(
    const WCHAR*    filename
    ) : GpImage(ImageTypeBitmap), ScanBitmapRef(1)
{
    InternalBitmap = CopyOnWriteBitmap::Create(filename);
    ASSERT((InternalBitmap == NULL) || InternalBitmap->IsValid());
    ScanBitmap.SetBitmap(this);
}

GpBitmap::GpBitmap(
    IStream*    stream
    ) : GpImage(ImageTypeBitmap), ScanBitmapRef(1)
{
    InternalBitmap = CopyOnWriteBitmap::Create(stream);
    ASSERT((InternalBitmap == NULL) || InternalBitmap->IsValid());
    ScanBitmap.SetBitmap(this);
}

GpBitmap::GpBitmap(
    INT             width,
    INT             height,
    PixelFormatID   format
    ) : GpImage(ImageTypeBitmap), ScanBitmapRef(1)
{
    InternalBitmap = CopyOnWriteBitmap::Create(width, height, format);
    ASSERT((InternalBitmap == NULL) || InternalBitmap->IsValid());
    ScanBitmap.SetBitmap(this);
}

GpBitmap::GpBitmap(
    INT             width,
    INT             height,
    PixelFormatID   format,
    GpGraphics *    graphics
    ) : GpImage(ImageTypeBitmap), ScanBitmapRef(1)
{
    InternalBitmap = CopyOnWriteBitmap::Create(width, height, format, graphics);
    ASSERT((InternalBitmap == NULL) || InternalBitmap->IsValid());
    ScanBitmap.SetBitmap(this);
}

GpBitmap::GpBitmap(
    INT             width,
    INT             height,
    INT             stride,     // negative for bottom-up bitmaps
    PixelFormatID   format,
    BYTE *          scan0
    ) : GpImage(ImageTypeBitmap), ScanBitmapRef(1)
{
    InternalBitmap = CopyOnWriteBitmap::Create(width, height, stride, format, scan0);
    ASSERT((InternalBitmap == NULL) || InternalBitmap->IsValid());
    ScanBitmap.SetBitmap(this);
}

GpBitmap::GpBitmap(
    BITMAPINFO*     gdiBitmapInfo,
    VOID*           gdiBitmapData,
    BOOL            ownBitmapData
    ) : GpImage(ImageTypeBitmap), ScanBitmapRef(1)
{
    InternalBitmap = CopyOnWriteBitmap::Create(gdiBitmapInfo, gdiBitmapData, ownBitmapData);
    ASSERT((InternalBitmap == NULL) || InternalBitmap->IsValid());
    ScanBitmap.SetBitmap(this);
}

GpBitmap::GpBitmap(
    IDirectDrawSurface7 *   surface
    ) : GpImage(ImageTypeBitmap), ScanBitmapRef(1)
{
    InternalBitmap = CopyOnWriteBitmap::Create(surface);
    ASSERT((InternalBitmap == NULL) || InternalBitmap->IsValid());
    ScanBitmap.SetBitmap(this);
}

GpImage*
GpBitmap::Clone() const
{
    return new GpBitmap(this);
}

GpBitmap*
GpBitmap::Clone(
    const GpRect*   rect,
    PixelFormatID   format
    ) const
{
    BOOL            isFullRect;

    isFullRect = ((rect == NULL) ||
                  ((rect->X == 0) && (rect->Y == 0) &&
                   (rect->Width == (INT)InternalBitmap->SrcImageInfo.Width) &&
                   (rect->Height == (INT)InternalBitmap->SrcImageInfo.Height)));

    // If rect is full size and format is same,
    // don't have to clone InternalBitmap.
    if (isFullRect &&
        ((format == PixelFormatDontCare) ||
         (format == InternalBitmap->SrcImageInfo.PixelFormat)))
    {
        return (GpBitmap *)this->Clone();
    }

    // else we have to do a clone of the internal bitmap
    GpBitmap *      newBitmap = new GpBitmap(FALSE);

    if (newBitmap != NULL)
    {
        LockForRead();
        if (isFullRect)
        {
            // It's faster to do the clone followed by the convert than
            // to do the convert as part of the clone.
            newBitmap->InternalBitmap = (CopyOnWriteBitmap *)InternalBitmap->Clone();
            if (newBitmap->InternalBitmap != NULL)
            {
                if (newBitmap->InternalBitmap->ConvertFormat(format, NULL, NULL) != Ok)
                {
                    newBitmap->InternalBitmap->Release();
                    newBitmap->InternalBitmap = NULL;
                }
            }
        }
        else
        {
            newBitmap->InternalBitmap = InternalBitmap->Clone(rect, format);
        }
        Unlock();
        if (newBitmap->InternalBitmap == NULL)
        {
            delete newBitmap;
            newBitmap = NULL;
        }
        else
        {
            ASSERT(newBitmap->InternalBitmap->IsValid());
        }
    }
    return newBitmap;
}

GpImage*
GpBitmap::CloneColorAdjusted(
    GpRecolor *             recolor,
    ColorAdjustType         type
    ) const
{
    GpBitmap * newBitmap = new GpBitmap(FALSE);

    if (newBitmap != NULL)
    {
        LockForRead();
        newBitmap->InternalBitmap = InternalBitmap->CloneColorAdjusted(recolor, type);
        Unlock();
        if (newBitmap->InternalBitmap == NULL)
        {
            delete newBitmap;
            newBitmap = NULL;
        }
        else
        {
            ASSERT(newBitmap->InternalBitmap->IsValid());
        }
    }
    return newBitmap;
}

// Similar to CloneColorAdjusted
GpStatus
GpBitmap::Recolor(
    GpRecolor *             recolor,
    GpBitmap **             dstBitmap,
    DrawImageAbort          callback,
    VOID *                  callbackData,
    GpRect *                rect
    )
{
    GpStatus        status    = GenericError;

    if (dstBitmap == NULL)
    {
        // recolor this object -- need write lock
        CopyOnWriteBitmap *     writeableBitmap = LockForWrite();

        if (writeableBitmap != NULL)
        {
            status = writeableBitmap->Recolor(recolor, NULL, callback, callbackData, rect);
            writeableBitmap->Unlock();
            UpdateUid();
        }
    }
    else    // recolor into dstBitmap
    {
        GpBitmap *      newBitmap = new GpBitmap(FALSE);

        if (newBitmap != NULL)
        {
            LockForRead();
            status = InternalBitmap->Recolor(recolor, &newBitmap->InternalBitmap, callback, callbackData, rect);
            Unlock();

            if (status != Ok)
            {
                delete newBitmap;
                newBitmap = NULL;
            }
            else
            {
                ASSERT((newBitmap->InternalBitmap != NULL) && (newBitmap->InternalBitmap->IsValid()));
            }
        }
        *dstBitmap = newBitmap;
    }
    return status;
}

GpStatus
GpBitmap::GetEncoderParameterListSize(
    IN  CLSID*              clsidEncoder,
    OUT UINT*               size
    )
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->GetEncoderParameterListSize(clsidEncoder, size);
    Unlock();
    return status;
}

GpStatus
GpBitmap::GetEncoderParameterList(
    IN  CLSID*              clsidEncoder,
    IN  UINT                size,
    OUT EncoderParameters*  pBuffer
    )
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->GetEncoderParameterList(clsidEncoder, size, pBuffer);
    Unlock();
    return status;
}

GpStatus
GpBitmap::SaveToStream(
    IStream*                stream,
    CLSID*                  clsidEncoder,
    EncoderParameters*      encoderParams
    )
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->SaveToStream(stream, clsidEncoder, encoderParams);
    Unlock();
    return status;
}

GpStatus
GpBitmap::SaveToFile(
    const WCHAR*            filename,
    CLSID*                  clsidEncoder,
    EncoderParameters*      encoderParams
    )
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->SaveToFile(filename, clsidEncoder, encoderParams);
    Unlock();
    return status;
}

GpStatus
GpBitmap::SaveAdd(
    const EncoderParameters*    encoderParams
    )
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->SaveAdd(encoderParams);
    Unlock();
    return status;
}

GpStatus
GpBitmap::SaveAdd(
    GpImage*                    newBits,
    const EncoderParameters*    encoderParams
    )
{
    ASSERT(newBits != NULL);

    GpStatus status = InvalidParameter;

    if (newBits->GetImageType() == ImageTypeBitmap)
    {
        LockForRead();
        status = InternalBitmap->SaveAdd(((GpBitmap *)newBits)->InternalBitmap, encoderParams);
        Unlock();
    }
    return status;
}

// Dispose the bitmap object

VOID
GpBitmap::Dispose()
{
    if (InterlockedDecrement(&ScanBitmapRef) <= 0)
    {
        delete this;
    }
}

// Get bitmap information

GpStatus
GpBitmap::GetResolution(
    REAL*               xdpi,
    REAL*               ydpi
    ) const
{
    GpStatus status = Ok;
    LockForRead();
    *xdpi = (REAL)InternalBitmap->SrcImageInfo.Xdpi;
    *ydpi = (REAL)InternalBitmap->SrcImageInfo.Ydpi;
    Unlock();
    return status;
}

GpStatus
GpBitmap::GetPhysicalDimension(
    REAL*               width,
    REAL*               height
    ) const
{
    GpStatus status = Ok;
    LockForRead();
    *width  = (REAL)InternalBitmap->SrcImageInfo.Width;
    *height = (REAL)InternalBitmap->SrcImageInfo.Height;
    Unlock();
    return status;
}

GpStatus
GpBitmap::GetBounds(
    GpRectF*            rect,
    GpPageUnit*         unit
    ) const
{
    GpStatus status = Ok;
    LockForRead();
    rect->X = rect->Y = 0;
    rect->Width  = (REAL) InternalBitmap->SrcImageInfo.Width;
    rect->Height = (REAL) InternalBitmap->SrcImageInfo.Height;
    *unit = UnitPixel;
    Unlock();
    return status;
}

GpStatus
GpBitmap::GetSize(
    Size*               size
    ) const
{
    GpStatus status = Ok;
    LockForRead();
    size->Width  = InternalBitmap->SrcImageInfo.Width;
    size->Height = InternalBitmap->SrcImageInfo.Height;
    Unlock();
    return status;
}

GpStatus
GpBitmap::GetImageInfo(
    ImageInfo *         imageInfo
    ) const
{
    if (NULL == imageInfo)
    {
        return InvalidParameter;
    }

    GpStatus status = Ok;
    LockForRead();
    InternalBitmap->GetImageInfo(imageInfo);
    Unlock();
    return status;
}

GpImage*
GpBitmap::GetThumbnail(
    UINT                    thumbWidth,
    UINT                    thumbHeight,
    GetThumbnailImageAbort  callback,
    VOID *                  callbackData
    )
{
    GpBitmap * newBitmap = new GpBitmap(FALSE);

    if (newBitmap != NULL)
    {
        LockForRead();
        newBitmap->InternalBitmap = InternalBitmap->GetThumbnail(thumbWidth, thumbHeight, callback, callbackData);
        Unlock();
        if (newBitmap->InternalBitmap == NULL)
        {
            delete newBitmap;
            newBitmap = NULL;
        }
        else
        {
            ASSERT(newBitmap->InternalBitmap->IsValid());
        }
    }
    return newBitmap;
}

GpStatus
GpBitmap::GetFrameCount(
    const GUID*     dimensionID,
    UINT*           count
    ) const
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->GetFrameCount(dimensionID, count);
    Unlock();
    return status;
}

GpStatus
GpBitmap::GetFrameDimensionsCount(
    OUT UINT*       count
    ) const
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->GetFrameDimensionsCount(count);
    Unlock();
    return status;
}

GpStatus
GpBitmap::GetFrameDimensionsList(
    OUT GUID*       dimensionIDs,
    IN UINT         count
    ) const
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->GetFrameDimensionsList(dimensionIDs, count);
    Unlock();
    return status;
}

GpStatus
GpBitmap::SelectActiveFrame(
    const GUID*     dimensionID,
    UINT            frameIndex
    )
{
    CopyOnWriteBitmap *     writeableBitmap = LockForWrite();

    if (writeableBitmap != NULL)
    {
        GpStatus    status;
        status = writeableBitmap->SelectActiveFrame(dimensionID, frameIndex);
        writeableBitmap->Unlock();
        UpdateUid();
        return status;
    }
    return GenericError;
}

GpStatus
GpBitmap::GetPalette(
    ColorPalette *      palette,
    INT                 size
    )
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->GetPalette(palette, size);
    Unlock();
    return status;
}

GpStatus
GpBitmap::SetPalette(
    ColorPalette *      palette
    )
{
    CopyOnWriteBitmap *     writeableBitmap = LockForWrite();

    if (writeableBitmap != NULL)
    {
        GpStatus    status;
        status = writeableBitmap->SetPalette(palette);
        writeableBitmap->Unlock();
        UpdateUid();
        return status;
    }
    return GenericError;
}

INT
GpBitmap::GetPaletteSize()
{
    INT size;
    LockForRead();
    size = InternalBitmap->GetPaletteSize();
    Unlock();
    return size;
}

GpStatus
GpBitmap::GetTransparencyHint(
    DpTransparency*     transparency
    )
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->GetTransparencyHint(transparency);
    Unlock();
    return status;
}

GpStatus
GpBitmap::SetTransparencyHint(
    DpTransparency      transparency
    )
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->SetTransparencyHint(transparency);
    Unlock();
    UpdateUid();
    return status;
}

GpStatus
GpBitmap::GetTransparencyFlags(
    DpTransparency*     transparency,
    PixelFormatID       loadFormat,
    BYTE*               minAlpha,
    BYTE*               maxAlpha
    )
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->GetTransparencyFlags(transparency, loadFormat, minAlpha, maxAlpha);
    Unlock();
    return status;
}

// Property related functions

GpStatus
GpBitmap::GetPropertyCount(
    UINT*       numOfProperty
    )
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->GetPropertyCount(numOfProperty);
    Unlock();
    return status;
}

GpStatus
GpBitmap::GetPropertyIdList(
    UINT        numOfProperty,
    PROPID*     list
    )
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->GetPropertyIdList(numOfProperty, list);
    Unlock();
    return status;
}

GpStatus
GpBitmap::GetPropertyItemSize(
    PROPID      propId,
    UINT*       size
    )
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->GetPropertyItemSize(propId, size);
    Unlock();
    return status;
}

GpStatus
GpBitmap::GetPropertyItem(
    PROPID          propId,
    UINT            propSize,
    PropertyItem*   buffer
    )
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->GetPropertyItem(propId, propSize, buffer);
    Unlock();
    return status;
}

GpStatus
GpBitmap::GetPropertySize(
    UINT*           totalBufferSize,
    UINT*           numProperties
    )
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->GetPropertySize(totalBufferSize, numProperties);
    Unlock();
    return status;
}

GpStatus
GpBitmap::GetAllPropertyItems(
    UINT            totalBufferSize,
    UINT            numProperties,
    PropertyItem*   allItems
    )
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->GetAllPropertyItems(totalBufferSize, numProperties, allItems);
    Unlock();
    return status;
}

GpStatus
GpBitmap::RemovePropertyItem(
    PROPID      propId
    )
{
    CopyOnWriteBitmap *     writeableBitmap = LockForWrite();

    if (writeableBitmap != NULL)
    {
        GpStatus    status;
        status = writeableBitmap->RemovePropertyItem(propId);
        writeableBitmap->Unlock();
        UpdateUid();
        return status;
    }
    return GenericError;
}

GpStatus
GpBitmap::SetPropertyItem(
    PropertyItem*       item
    )
{
    CopyOnWriteBitmap *     writeableBitmap = LockForWrite();

    if (writeableBitmap != NULL)
    {
        GpStatus    status;
        status = writeableBitmap->SetPropertyItem(item);
        writeableBitmap->Unlock();
        UpdateUid();
        return status;
    }
    return GenericError;
}

// Retrieve bitmap data

GpStatus
GpBitmap::LockBits(
    const GpRect*   rect,
    UINT            flags,
    PixelFormatID   pixelFormat,
    BitmapData*     bmpdata,
    INT             width,
    INT             height
    ) const
{
    ASSERT(InternalBitmap != NULL);
    
    if (flags & ImageLockModeWrite)
    {
        CopyOnWriteBitmap *     writeableBitmap = ((GpBitmap *)this)->LockForWrite();

        if (writeableBitmap != NULL)
        {
            GpStatus    status;
            status = writeableBitmap->LockBits(rect, flags, pixelFormat, bmpdata, width, height);
            writeableBitmap->Unlock();
            return status;
        }
        return GenericError;
    }
    else
    {
        // Lock For read case
        // First we need to check if this is the 1st LockForRead on this image
        // object or not.

        if ( InternalBitmap->ObjRefCount > 1 )
        {
            // We have more than one LockForRead on this object
            // Note: this part needs to be re-visited in V2. We have a big
            // problem here not allowing user to do more than once for LockBits
            // for read. So we need to make a copy even though theory says
            // that we should not have to.

            CopyOnWriteBitmap *     writeableBitmap = ((GpBitmap *)this)->LockForWrite();

            if (writeableBitmap != NULL)
            {
                GpStatus    status;
                status = writeableBitmap->LockBits(rect, flags, pixelFormat, bmpdata, width, height);
                writeableBitmap->Unlock();
                return status;
            }
            return GenericError;
        }
        else
        {
            GpStatus status;
            LockForRead();
            status = InternalBitmap->LockBits(rect, flags, pixelFormat, bmpdata, width, height);
            Unlock();
            return status;
        }
    }
}

GpStatus
GpBitmap::UnlockBits(
    BitmapData*     bmpdata,
    BOOL            Destroy
    ) const
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->UnlockBits(bmpdata, Destroy);
    Unlock();
    return status;
}

// Get and set pixel on the bitmap.
GpStatus
GpBitmap::GetPixel(
    INT         x,
    INT         y,
    ARGB *      color
    )
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->GetPixel(x, y, color);
    Unlock();
    return status;
}

GpStatus
GpBitmap::SetPixel(
    INT         x,
    INT         y,
    ARGB        color
    )
{
    CopyOnWriteBitmap *     writeableBitmap = LockForWrite();

    if (writeableBitmap != NULL)
    {
        GpStatus    status;
        status = writeableBitmap->SetPixel(x, y, color);
        writeableBitmap->Unlock();
        UpdateUid();
        return status;
    }
    return GenericError;
}

GpStatus
GpBitmap::RotateFlip(
    RotateFlipType rfType
    )
{
    CopyOnWriteBitmap*     pWriteableBitmap = LockForWrite();

    if ( pWriteableBitmap != NULL )
    {
        GpStatus    status = pWriteableBitmap->RotateFlip(rfType);

        pWriteableBitmap->Unlock();
        UpdateUid();

        return status;
    }

    return GenericError;
}// RotateFlip()

BOOL
GpBitmap::IsDirty() const
{
    LockForRead();
    BOOL dirty = InternalBitmap->IsDirty();
    Unlock();
    return dirty;
}

// Derive a graphics context on top of the bitmap object

GpGraphics*
GpBitmap::GetGraphicsContext()
{
    CopyOnWriteBitmap *     writeableBitmap = LockForWrite();

    if (writeableBitmap != NULL)
    {
        GpGraphics *    g = NULL;

        // NTRAID#NTBUG9-368452-2001-04-13-gilmanw "ISSUE: allow only one GpGraphics per bitmap"
        //
        // Currently create a new GpGraphics each time GetGraphicsContext
        // is called.  Perhaps should cache the GpGraphics and return that
        // to all callers.  Otherwise, there may be synchronization issues
        // if there are multiple GpGraphics per surface.

        if (writeableBitmap->State == MemBitmap && writeableBitmap->Bmp != NULL &&
            writeableBitmap->Bmp->creationFlag == GpMemoryBitmap::CREATEDFROM_DDRAWSURFACE)
        {
            // NTRAID#NTBUG9-368458-2001-04-13-gilmanw "ISSUE: lose association with Image for DDraw surfs"
            //
            // The Image as well as the graphics are only wrappers around the
            // direct draw surface.  When we create the GpGraphics in this
            // way we lose all association with the Image (CopyOnWriteBitmap)
            // object.  This may not be the right behavior.

            g = GpGraphics::GetFromDirectDrawSurface(writeableBitmap->Bmp->ddrawSurface);
        }
        else
        {
            ImageInfo imageInfo;
            writeableBitmap->GetImageInfo(&imageInfo);

            // since GpGraphics will end up pointing to ScanBitmap structure
            // we need to make sure bitmap won't be deleted while
            // there is a graphics wrapped around it

            IncScanBitmapRef();
            g = GpGraphics::GetFromGdipBitmap(this, &imageInfo, &ScanBitmap, writeableBitmap->Display);
            if (!CheckValid(g))
            {
                DecScanBitmapRef();
            }
        }

        writeableBitmap->Unlock();
        return g;
    }
    return NULL;
}

GpStatus
GpBitmap::InitializeSurfaceForGdipBitmap(
    DpBitmap *      surface,
    INT             width,
    INT             height
    )
{
    GpStatus status = Ok;

    // Currently this is only called when preparing a surface as a source
    // surface, not as a dest surface, so we only need a read lock.
    LockForRead();
    ImageInfo imageInfo;
    InternalBitmap->GetImageInfo(&imageInfo);
    surface->InitializeForGdipBitmap(width, height, &imageInfo, &ScanBitmap, InternalBitmap->Display);
    Unlock();
    return status;
}

// Derive an HDC for interop on top of the bitmap object

HDC
GpBitmap::GetHdc()
{
    CopyOnWriteBitmap *     writeableBitmap = LockForWrite();

    if (writeableBitmap != NULL)
    {
        HDC     hdc;
        hdc = writeableBitmap->GetHdc();
        writeableBitmap->Unlock();
        return hdc;
    }
    return NULL;
}

VOID
GpBitmap::ReleaseHdc(HDC hdc)
{
    LockForRead();
    InternalBitmap->ReleaseHdc(hdc);
    Unlock();
    return;
}

// Serialization

UINT
GpBitmap::GetDataSize() const
{
    UINT dataSize;
    LockForRead();
    dataSize = InternalBitmap->GetDataSize();
    Unlock();
    return dataSize;
}

GpStatus
GpBitmap::GetData(
    IStream *       stream
    ) const
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->GetData(stream);
    Unlock();
    return status;
}

GpStatus
GpBitmap::SetData(
    const BYTE *        dataBuffer,
    UINT                size
    )
{
    CopyOnWriteBitmap *     writeableBitmap = LockForWrite();

    if (writeableBitmap != NULL)
    {
        GpStatus    status;
        status = writeableBitmap->SetData(dataBuffer, size);
        writeableBitmap->Unlock();
        UpdateUid();
        return status;
    }
    return GenericError;
}

GpStatus
GpBitmap::GetCompressedData(
    DpCompressedData *      compressed_data,
    BOOL                    getJPEG,
    BOOL                    getPNG,
    HDC                     hdc
    )
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->GetCompressedData(compressed_data, getJPEG, getPNG, hdc);
    Unlock();
    return status;
}

GpStatus
GpBitmap::DeleteCompressedData(
    DpCompressedData *  compressed_data
    )
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->DeleteCompressedData(compressed_data);
    Unlock();
    UpdateUid();
    return status;
}

// Color adjust

GpStatus
GpBitmap::ColorAdjust(
    GpRecolor *         recolor,
    ColorAdjustType     type
    )
{
    CopyOnWriteBitmap *     writeableBitmap = LockForWrite();

    if (writeableBitmap != NULL)
    {
        GpStatus    status;
        status = writeableBitmap->ColorAdjust(recolor, type);
        writeableBitmap->Unlock();
        UpdateUid();
        return status;
    }
    return GenericError;
}

GpStatus
GpBitmap::ColorAdjust(
    GpRecolor *         recolor,
    PixelFormatID       pixfmt,
    DrawImageAbort      callback,
    VOID *              callbackData
    )
{
    CopyOnWriteBitmap *     writeableBitmap = LockForWrite();

    if (writeableBitmap != NULL)
    {
        GpStatus    status;
        status = writeableBitmap->ColorAdjust(recolor, pixfmt, callback, callbackData);
        writeableBitmap->Unlock();
        UpdateUid();
        return status;
    }
    return GenericError;
}

GpStatus
GpBitmap::GetPixelFormatID(
    PixelFormatID*      pixfmt
    )
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->GetPixelFormatID(pixfmt);
    Unlock();
    return status;
}

INT
GpBitmap::GetDecodeState()
{
    INT decodeState;
    LockForRead();
    decodeState = InternalBitmap->State;
    Unlock();
    return decodeState;
}

GpStatus
GpBitmap::ForceValidation()
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->LoadIntoMemory(PixelFormatDontCare, NULL, NULL);
    Unlock();
    return status;
}

GpStatus
GpBitmap::SetResolution(
    REAL    xdpi,
    REAL    ydpi
    )
{
    CopyOnWriteBitmap *     writeableBitmap = LockForWrite();

    if (writeableBitmap != NULL)
    {
        GpStatus    status;
        status = writeableBitmap->SetResolution(xdpi, ydpi);
        writeableBitmap->Unlock();
        UpdateUid();
        return status;
    }
    return GenericError;
}

GpStatus
GpBitmap::PreDraw(
    INT             numPoints,
    GpPointF *      dstPoints,
    GpRectF *       srcRect,
    INT             numBitsPerPixel
    )
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->PreDraw(numPoints, dstPoints, srcRect, numBitsPerPixel);
    Unlock();
    return status;
}

// Interop:

GpStatus
GpBitmap::CreateFromHBITMAP(
    HBITMAP         hbm,
    HPALETTE        hpal,
    GpBitmap**      bitmap
    )
{
    ASSERT(bitmap != NULL);
    GpStatus        status    = GenericError;
    GpBitmap *      newBitmap = new GpBitmap(FALSE);

    if (newBitmap != NULL)
    {
        status = CopyOnWriteBitmap::CreateFromHBITMAP(hbm, hpal, &newBitmap->InternalBitmap);

        if (status != Ok)
        {
            delete newBitmap;
            newBitmap = NULL;
        }
        else
        {
            ASSERT((newBitmap->InternalBitmap != NULL) && (newBitmap->InternalBitmap->IsValid()));
        }
    }
    *bitmap = newBitmap;
    return status;
}

GpStatus
GpBitmap::CreateBitmapAndFillWithBrush(
    InterpolationMode   interpolationMode,
    PixelOffsetMode     pixelOffsetMode,
    const GpMatrix *    worldToDevice,
    const GpRect *      drawBounds,
    GpBrush *           brush,
    GpBitmap **         bitmap,
    PixelFormatID       pixelFormat
    )
{
    ASSERT ((drawBounds->Width > 0) && (drawBounds->Height > 0));
    ASSERT (bitmap != NULL);

    GpStatus    status = GenericError;

    *bitmap = NULL;

    // First, construct the correct brush transform to use when rendering
    // into the bitmap.  The brush transform is the concatenation of the
    // current brush transform, the current worldToDevice transform, and
    // a translation transform that maps from the drawBounds to the
    // bitmap bounds.

    GpMatrix    saveBrushMatrix;
    GpMatrix *  deviceMatrix = const_cast<GpMatrix *>(&((brush->GetDeviceBrush())->Xform));

    saveBrushMatrix = *deviceMatrix;

    GpMatrix    newBrushMatrix = saveBrushMatrix;

    if (worldToDevice != NULL)
    {
        newBrushMatrix.Append(*worldToDevice);
    }

    newBrushMatrix.Translate(
        (REAL)-(drawBounds->X),
        (REAL)-(drawBounds->Y),
        MatrixOrderAppend
    );


    BOOL    restoreWrapMode = FALSE;

    // When we're drawing a texture brush into a bitmap, if the texture is
    // supposed to fill the bitmap, then don't use clamp mode, because clamp
    // mode will end up bleeding alpha into the image along the right and
    // bottom edges, which is undesirable -- especially for down-level bitmaps
    // where we end up with what looks like a dotted line along the edges
    // of the bitmap.
    if ((brush->GetBrushType() == BrushTypeTextureFill) &&
        (((GpTexture *)brush)->GetWrapMode() == WrapModeClamp) &&
        (newBrushMatrix.IsTranslateScale()))
    {
        GpBitmap* brushBitmap = ((GpTexture *)brush)->GetBitmap();
        if (brushBitmap != NULL)
        {
            Size    size;
            brushBitmap->GetSize(&size);

            GpRectF     transformedRect(0.0f, 0.0f, (REAL)size.Width, (REAL)size.Height);
            newBrushMatrix.TransformRect(transformedRect);

            // get the transformed width
            INT     deltaValue = abs(GpRound(transformedRect.Width) - drawBounds->Width);

            // We might be off a little because of the pixel offset mode
            // or a matrix that isn't quite right for whatever reason.
            if (deltaValue <= 2)
            {
                // get the transformed height
                deltaValue = abs(GpRound(transformedRect.Height) - drawBounds->Height);

                if (deltaValue <= 2)
                {
                    if ((abs(GpRound(transformedRect.X)) <= 2) &&
                        (abs(GpRound(transformedRect.Y)) <= 2))
                    {
                        ((GpTexture *)brush)->SetWrapMode(WrapModeTileFlipXY);
                        restoreWrapMode = TRUE;
                    }
                }
            }
        }
    }

    if (newBrushMatrix.IsInvertible())
    {
        *deviceMatrix = newBrushMatrix;

        GpBitmap *  bitmapImage = new GpBitmap(drawBounds->Width, drawBounds->Height, pixelFormat);

        if (bitmapImage != NULL)
        {
            if (bitmapImage->IsValid())
            {
                GpGraphics *    graphics = bitmapImage->GetGraphicsContext();

                if (graphics != NULL)
                {
                    if (graphics->IsValid())
                    {
                        // we have to lock the graphics so the driver doesn't assert
                        GpLock  lockGraphics(graphics->GetObjectLock());

                        ASSERT(lockGraphics.IsValid());

                        graphics->SetCompositingMode(CompositingModeSourceCopy);
                        graphics->SetInterpolationMode(interpolationMode);
                        graphics->SetPixelOffsetMode(pixelOffsetMode);

                        // now fill the bitmap image with the brush
                        GpRectF     destRect(0.0f, 0.0f, (REAL)drawBounds->Width, (REAL)drawBounds->Height);
                        status = graphics->FillRects(brush, &destRect, 1);
                    }
                    else
                    {
                        WARNING(("graphics from bitmap image not valid"));
                    }
                    delete graphics;
                }
                else
                {
                    WARNING(("could not create graphics from bitmap image"));
                }
            }
            else
            {
                WARNING(("bitmap image is not valid"));
            }
            if (status == Ok)
            {
                *bitmap = bitmapImage;
            }
            else
            {
                bitmapImage->Dispose();
            }
        }
        else
        {
            WARNING(("could not create bitmap image"));
        }
        *deviceMatrix = saveBrushMatrix;
    }

    if (restoreWrapMode)
    {
        ((GpTexture *)brush)->SetWrapMode(WrapModeClamp);
    }
    return status;
}

GpStatus
GpBitmap::DrawAndHalftoneForStretchBlt(
    HDC                 hdc,
    BITMAPINFO *        bmpInfo,
    BYTE       *        bits,
    INT                 srcX,
    INT                 srcY,
    INT                 srcWidth,
    INT                 srcHeight,
    INT                 destWidth,
    INT                 destHeight,
    BITMAPINFO **       destBmpInfo,
    BYTE       **       destBmpBits,
    HBITMAP    *        destDIBSection,
    InterpolationMode   interpolationMode
    )
{
    ASSERT(hdc != NULL && bmpInfo != NULL && bits != NULL &&
           destBmpInfo != NULL && destBmpBits != NULL &&
           destDIBSection != NULL);
    ASSERT(destWidth > 0 && destHeight > 0);

    GpStatus status = GenericError;

    ASSERT(::GetDeviceCaps(hdc, BITSPIXEL) == 8);
    *destBmpInfo = (BITMAPINFO*) GpMalloc(sizeof(BITMAPINFOHEADER) + 256 * sizeof(RGBQUAD));

    if (*destBmpInfo == NULL)
    {
        return OutOfMemory;
    }

    BITMAPINFO *dst = *destBmpInfo;
    GpMemset(dst, 0, sizeof(BITMAPINFOHEADER) + 256 * sizeof(RGBQUAD));
    dst->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    dst->bmiHeader.biPlanes = 1;
    dst->bmiHeader.biBitCount = 8;
    dst->bmiHeader.biWidth = destWidth;
    dst->bmiHeader.biHeight = destHeight;

    // We need to create a Memory DC to select a DibSection into it and finally
    // wrap a graphics around it.

    HPALETTE currentPalette = (HPALETTE)::GetCurrentObject(hdc, OBJ_PAL);
    WORD paletteEntries;
    ::GetObjectA(currentPalette, sizeof(WORD), (LPVOID)&paletteEntries);
    ::GetPaletteEntries(currentPalette, 0, paletteEntries, (LPPALETTEENTRY) &(dst->bmiColors));
    dst->bmiHeader.biClrUsed = paletteEntries;
    HDC     memDC   = ::CreateCompatibleDC(hdc);
    *destDIBSection = ::CreateDIBSection(hdc, dst, DIB_RGB_COLORS,
                                         (VOID**) destBmpBits, NULL, 0);

    if (*destDIBSection != NULL && memDC != NULL)
    {
        ::SelectObject(memDC, *destDIBSection);
        ::SelectPalette(memDC, currentPalette, FALSE);
        ::RealizePalette(memDC);
        GpGraphics *g = GpGraphics::GetFromHdc(memDC);
        if (g != NULL)
        {
            if(g->IsValid())
            {
                GpBitmap *src = new GpBitmap(bmpInfo, bits, FALSE);
                if (src != NULL)
                {
                    if( src->IsValid())
                    {
                        GpLock lock(g->GetObjectLock());
                        g->SetCompositingMode(CompositingModeSourceCopy);
                        g->SetInterpolationMode(interpolationMode);
                        g->SetPixelOffsetMode(PixelOffsetModeHalf);
                        status = g->DrawImage(src,
                                              GpRectF(0.0f, 0.0f, (REAL)destWidth, (REAL)destHeight),
                                              GpRectF((REAL)srcX, (REAL)srcY, (REAL)srcWidth, (REAL)srcHeight),
                                              UnitPixel);
                    }
                    src->Dispose();
                }
                delete g;
            }
        }
    }


    if (memDC != NULL)
    {
        ::DeleteDC(memDC);
    }

    // If we failed delete our allocations
    if (status != Ok)
    {
        GpFree(*destBmpInfo);
        *destBmpInfo = NULL;
        if (*destDIBSection != NULL)
        {
            ::DeleteObject(*destDIBSection);
            *destDIBSection = NULL;
        }
        *destBmpBits = NULL;
    }

    return status;
}



GpStatus
GpBitmap::CreateHBITMAP(
    HBITMAP *       phbm,
    ARGB            background
    )
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->CreateHBITMAP(phbm, background);
    Unlock();
    return status;
}

GpStatus
GpBitmap::ICMFrontEnd(
    GpBitmap **     dstBitmap,
    DrawImageAbort  callback,
    VOID *          callbackData,
    GpRect *        rect
    )
{
    GpStatus        status    = GenericError;

    if (dstBitmap == NULL)
    {
        // change this object -- need write lock
        CopyOnWriteBitmap *     writeableBitmap = LockForWrite();

        if (writeableBitmap != NULL)
        {
            GpStatus    status;
            status = writeableBitmap->ICMFrontEnd(NULL, callback, callbackData, rect);
            writeableBitmap->Unlock();
            UpdateUid();
        }
    }
    else    // use dstBitmap
    {
        GpBitmap *      newBitmap = new GpBitmap(FALSE);

        if (newBitmap != NULL)
        {
            LockForRead();
            status = InternalBitmap->ICMFrontEnd(&newBitmap->InternalBitmap, callback, callbackData, rect);
            Unlock();

            if (status != Ok)
            {
                delete newBitmap;
                newBitmap = NULL;
            }
            else
            {
                ASSERT((newBitmap->InternalBitmap != NULL) && (newBitmap->InternalBitmap->IsValid()));
            }
        }
        *dstBitmap = newBitmap;
    }
    return status;
}

GpStatus
GpBitmap::CreateFromHICON(
    HICON           hicon,
    GpBitmap**      bitmap
    )
{
    ASSERT(bitmap != NULL);
    GpStatus        status    = GenericError;
    GpBitmap *      newBitmap = new GpBitmap(FALSE);

    if (newBitmap != NULL)
    {
        status = CopyOnWriteBitmap::CreateFromHICON(hicon, &newBitmap->InternalBitmap);

        if (status != Ok)
        {
            delete newBitmap;
            newBitmap = NULL;
        }
        else
        {
            ASSERT((newBitmap->InternalBitmap != NULL) && (newBitmap->InternalBitmap->IsValid()));
        }
    }
    *bitmap = newBitmap;
    return status;
}

GpStatus
GpBitmap::CreateHICON(
    HICON *     phicon
    )
{
    GpStatus status;
    LockForRead();
    status = InternalBitmap->CreateHICON(phicon);
    Unlock();
    return status;
}

GpStatus
GpBitmap::CreateFromResource(
    HINSTANCE       hInstance,
    LPWSTR          lpBitmapName,
    GpBitmap**      bitmap
    )
{
    ASSERT(bitmap != NULL);
    GpStatus        status    = GenericError;
    GpBitmap *      newBitmap = new GpBitmap(FALSE);

    if (newBitmap != NULL)
    {
        status = CopyOnWriteBitmap::CreateFromResource(hInstance, lpBitmapName, &newBitmap->InternalBitmap);

        if (status != Ok)
        {
            delete newBitmap;
            newBitmap = NULL;
        }
        else
        {
            ASSERT((newBitmap->InternalBitmap != NULL) && (newBitmap->InternalBitmap->IsValid()));
        }
    }
    *bitmap = newBitmap;
    return status;
}

// We need to know if the bitmap is associated with a display
// so we know how to handle the page transform when it is
// set to UnitDisplay.
BOOL
GpBitmap::IsDisplay() const
{
    BOOL    isDisplay;
    LockForRead();
    isDisplay = InternalBitmap->Display;
    Unlock();
    return isDisplay;
}

VOID
GpBitmap::SetDisplay(
    BOOL        display
    )
{
    CopyOnWriteBitmap *     writeableBitmap = LockForWrite();

    if (writeableBitmap != NULL)
    {
        writeableBitmap->Display = display;
        writeableBitmap->Unlock();
        UpdateUid();
    }
    return;
}

BOOL
GpBitmap::IsICMConvert() const
{
    BOOL    isICMConvert;
    LockForRead();
    isICMConvert = InternalBitmap->ICMConvert;
    Unlock();
    return isICMConvert;
}

VOID
GpBitmap::SetICMConvert(
    BOOL        icm
    )
{
    CopyOnWriteBitmap *     writeableBitmap = LockForWrite();

    if (writeableBitmap != NULL)
    {
        writeableBitmap->ICMConvert = icm;
        writeableBitmap->Unlock();
        UpdateUid();
    }
    return;
}

BOOL
GpBitmap::IsValid() const
{
    // If the bitmap came from a different version of GDI+, its tag
    // will not match, and it won't be considered valid.
    return ((InternalBitmap != NULL) && InternalBitmap->IsValid()
            && GpImage::IsValid());
}

GpStatus
ConvertTo16BppAndFlip(
    GpBitmap *      sourceBitmap,
    GpBitmap * &    destBitmap
    )
{
    ASSERT ((sourceBitmap != NULL) && sourceBitmap->IsValid());

    GpStatus    status = GenericError;
    Size        size;

    sourceBitmap->GetSize(&size);
    
    destBitmap = new GpBitmap(size.Width, size.Height, PixelFormat16bppRGB555);
    if ((destBitmap != NULL) && destBitmap->IsValid())
    {
        // We have to draw it with a graphics, because if we just
        // clone it, then the format converter is used which doesn't
        // do dithering.
        GpGraphics * g = destBitmap->GetGraphicsContext();

        if (g != NULL)
        {
            if (g->IsValid())
            {
                // we have to lock the graphics so the driver doesn't assert
                GpLock  lockGraphics(g->GetObjectLock());

                ASSERT(lockGraphics.IsValid());

                // flip it upside down like GDI wants it
                GpRectF realDestRect(0.0f, (REAL)size.Height, (REAL)size.Width, (REAL)(-size.Height));
                g->SetCompositingMode(CompositingModeSourceCopy);
                g->SetInterpolationMode(InterpolationModeNearestNeighbor);
                g->SetPixelOffsetMode(PixelOffsetModeHalf);
                status = g->DrawImage(sourceBitmap, realDestRect);
            }
            delete g;
        }
    }
    if ((status != Ok) && (destBitmap != NULL))
    {
        destBitmap->Dispose();
        destBitmap = NULL;
    }
    
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\initialize.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998-1999  Microsoft Corporation
*
* Abstract:
*
*  Initialization routines for GDI+.
*
* Revision History:
*
*   7/19/99 ericvan
*       Created it.
*
\**************************************************************************/

BOOL InitImagingLibrary(BOOL suppressExternalCodecs);
VOID CleanupImagingLibrary();

BOOL BackgroundThreadStartup();
VOID BackgroundThreadShutdown();

ULONG_PTR GenerateInitToken();

GpStatus InternalGdiplusStartup(
    const GdiplusStartupInput *input);
VOID InternalGdiplusShutdown();
    
GpStatus WINAPI NotificationStartup(OUT ULONG_PTR *token);
VOID WINAPI NotificationShutdown(ULONG_PTR token);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\imageattr.hpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   ImageAttr.hpp
*
* Abstract:
*
*   ImageAttribute (recolor) related declarations
*
* Revision History:
*
*   14-Nov-1999 gilmanw
*       Created it.
*
\**************************************************************************/

#ifndef _IMAGEATTR_HPP
#define _IMAGEATTR_HPP

class GpImageAttributes : public GpObject
{
protected:
    VOID SetValid(BOOL valid)
    {
        GpObject::SetValid(valid ? ObjectTagImageAttributes : ObjectTagInvalid);
    }

public:
    GpImageAttributes();

    GpImageAttributes* Clone() const;

    VOID Dispose();

    GpLockable* GetObjectLock() const
    {
        return &Lockable;
    }

    // Set to identity, regardless of what the default color adjustment is.
    GpStatus
    SetToIdentity(
        ColorAdjustType     type
        );

    // Remove any individual color adjustments, and go back to using the default
    GpStatus
    Reset(
        ColorAdjustType     type
        );

    GpStatus
    SetColorMatrix(
        ColorAdjustType type,
        BOOL enable,
        ColorMatrix* colorMatrix,
        ColorMatrix* grayMatrix,
        ColorMatrixFlags flags);

    GpStatus
    SetThreshold(
        ColorAdjustType type,
        BOOL enable,
        REAL threshold);

    GpStatus
    SetGamma(
        ColorAdjustType type,
        BOOL enable,
        REAL gamma);

    GpStatus SetNoOp(
        ColorAdjustType type,
        BOOL enable);

    GpStatus
    SetColorKeys(
        ColorAdjustType type,
        BOOL enable,
        Color* colorLow,
        Color* colorHigh);

    GpStatus
    SetOutputChannel(
        ColorAdjustType type,
        BOOL enable,
        ColorChannelFlags channelFlags);

    GpStatus
    SetOutputChannelProfile(
        ColorAdjustType type,
        BOOL enable,
        WCHAR *profile);

    GpStatus
    SetRemapTable(
        ColorAdjustType type,
        BOOL enable,
        UINT mapSize,
        ColorMap* map);

    GpStatus
    SetCachedBackground(
        BOOL enableFlag);

    BOOL HasRecoloring(
        ColorAdjustType type = ColorAdjustTypeAny
        ) const;

    GpStatus SetWrapMode(WrapMode wrap, ARGB color = 0, BOOL Clamp = FALSE); 
    GpStatus SetICMMode(BOOL on); 
    
    VOID GetAdjustedPalette(
        ColorPalette * colorPalette,
        ColorAdjustType colorAdjustType
        );

    //----------------------------------------------------------------------
    // GpObject virtuals
    //----------------------------------------------------------------------

    virtual BOOL IsValid() const
    {
        // If the image attribtes came from a different version of GDI+, its tag
        // will not match, and it won't be considered valid.
        return ((recolor != NULL) && GpObject::IsValid(ObjectTagImageAttributes));
    }

    virtual ObjectType GetObjectType() const
    {
        return ObjectTypeImageAttributes;
    }

    // Serialization

    virtual UINT GetDataSize() const;
    virtual GpStatus GetData(IStream * stream) const;
    virtual GpStatus SetData(const BYTE * dataBuffer, UINT size);

public:
    GpRecolor* recolor;

    // !!! should move this into the DpImageAttributes
    BOOL cachedBackground;

    // Contains DrawImage Wrap-Mode settings
    DpImageAttributes DeviceImageAttributes;

protected:

    // Object lock

    mutable GpLockable Lockable;

public:

    ~GpImageAttributes();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\imageattr.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   ImageAttr.cpp
*
* Abstract:
*
*   GpImageAttributes (recolor) methods
*
* Revision History:
*
*   14-Nov-1999 gilmanw
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

#include "..\imaging\api\comutils.hpp"
#include "..\imaging\api\decodedimg.hpp"

/**************************************************************************\
*
* Function Description:
*
*   Create a default GpImageAttributes.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

GpImageAttributes::GpImageAttributes()
{
    SetValid(TRUE);     // default is valid

    recolor = new GpRecolor();

    // default WrapMode settings;
    DeviceImageAttributes.wrapMode = WrapModeClamp;
    DeviceImageAttributes.clampColor = (ARGB)0x00000000;    // Fully transparent black
    DeviceImageAttributes.srcRectClamp = FALSE;

    cachedBackground = TRUE;
}

/**************************************************************************\
*
* Function Description:
*
*   Release GpImageAttributes.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID GpImageAttributes::Dispose()
{
    delete this;
}

GpImageAttributes::~GpImageAttributes()
{
    if (recolor)
        recolor->Dispose();
}

/**************************************************************************\
*
* Function Description:
*
*   Clone GpImageAttributes.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   Pointer to new GpImageAttributes if successful.
*
\**************************************************************************/

GpImageAttributes* GpImageAttributes::Clone() const
{
    GpImageAttributes* clone = new GpImageAttributes();

    if (clone)
    {
        if ( clone->IsValid() && this->IsValid() )
        {
            *clone->recolor = *this->recolor;
        }
        else
        {
            clone->Dispose();
            clone = NULL;
        }
    }

    return clone;
}

// Set to identity, regardless of what the default color adjustment is.
GpStatus
GpImageAttributes::SetToIdentity(
    ColorAdjustType     type
    )
{
    recolor->SetToIdentity(type);
    UpdateUid();
    return Ok;
}

// Remove any individual color adjustments, and go back to using the default
GpStatus
GpImageAttributes::Reset(
    ColorAdjustType     type
    )
{
    recolor->Reset(type);
    UpdateUid();
    return Ok;
}

GpStatus
GpImageAttributes::SetColorMatrix(
    ColorAdjustType type,
    BOOL enable,
    ColorMatrix* colorMatrix,
    ColorMatrix* grayMatrix,
    ColorMatrixFlags flags)
{
    HRESULT result;

    if (enable)
        result = recolor->SetColorMatrices(type, colorMatrix, grayMatrix, flags);
    else
        result = recolor->ClearColorMatrices(type);

    UpdateUid();

    if (FAILED(result))
    {
        if (result == E_OUTOFMEMORY)
            return OutOfMemory;
        else
            return InvalidParameter;
    }
    else
        return Ok;
}

GpStatus
GpImageAttributes::SetThreshold(
    ColorAdjustType type,
    BOOL enable,
    REAL threshold)
{
    HRESULT result;

    if (enable)
        result = recolor->SetThreshold(type, threshold);
    else
        result = recolor->ClearThreshold(type);

    UpdateUid();

    if (FAILED(result))
        return InvalidParameter;
    else
        return Ok;
}

GpStatus
GpImageAttributes::SetGamma(
    ColorAdjustType type,
    BOOL enable,
    REAL gamma)
{
    HRESULT result;

    if (enable)
        result = recolor->SetGamma(type, gamma);
    else
        result = recolor->ClearGamma(type);

    UpdateUid();

    if (FAILED(result))
        return InvalidParameter;
    else
        return Ok;
}

GpStatus GpImageAttributes::SetNoOp(
    ColorAdjustType type,
    BOOL enable
    )
{
    HRESULT result;

    if (enable)
        result = recolor->SetNoOp(type);
    else
        result = recolor->ClearNoOp(type);

    UpdateUid();

    if (FAILED(result))
        return InvalidParameter;
    else
        return Ok;
}

GpStatus
GpImageAttributes::SetColorKeys(
    ColorAdjustType type,
    BOOL enable,
    Color* colorLow,
    Color* colorHigh)
{
    HRESULT result;

    if (enable)
        result = recolor->SetColorKey(type, colorLow, colorHigh);
    else
        result = recolor->ClearColorKey(type);

    UpdateUid();

    if (FAILED(result))
        return InvalidParameter;
    else
        return Ok;
}

GpStatus
GpImageAttributes::SetOutputChannel(
    ColorAdjustType type,
    BOOL enable,
    ColorChannelFlags channelFlags
    )
{
    HRESULT result;

    if (enable)
        result = recolor->SetOutputChannel(type, channelFlags);
    else
        result = recolor->ClearOutputChannel(type);

    UpdateUid();

    if (FAILED(result))
        return InvalidParameter;
    else
        return Ok;
}

GpStatus
GpImageAttributes::SetOutputChannelProfile(
    ColorAdjustType type,
    BOOL enable,
    WCHAR *profile)
{
    HRESULT result;

    if (enable)
        result = recolor->SetOutputChannelProfile(type, profile);
    else
        result = recolor->ClearOutputChannelProfile(type);

    UpdateUid();

    if (SUCCEEDED(result))
        return Ok;
    else
    {
        if (result == E_INVALIDARG)
            return InvalidParameter;
        else if (result == E_OUTOFMEMORY)
            return OutOfMemory;
        else
            return Win32Error;
    }
}

GpStatus
GpImageAttributes::SetRemapTable(
    ColorAdjustType type,
    BOOL enable,
    UINT mapSize,
    ColorMap* map)
{
    HRESULT result;

    if (enable)
        result = recolor->SetRemapTable(type, mapSize, map);
    else
        result = recolor->ClearRemapTable(type);

    UpdateUid();

    if (FAILED(result))
        return InvalidParameter;
    else
        return Ok;
}

GpStatus
GpImageAttributes::SetCachedBackground(
    BOOL enableFlag
    )
{
    if (cachedBackground != enableFlag)
    {
        cachedBackground = enableFlag;
        UpdateUid();
    }

    return Ok;
}

BOOL
GpImageAttributes::HasRecoloring(
    ColorAdjustType type
    ) const
{
    return (recolor) && (recolor->HasRecoloring(type) != 0);
}

GpStatus GpImageAttributes::SetWrapMode(WrapMode wrap, ARGB color, BOOL Clamp)
{
    DeviceImageAttributes.wrapMode = wrap;
    DeviceImageAttributes.clampColor = color;
    DeviceImageAttributes.srcRectClamp = Clamp;
    UpdateUid();
    return Ok;
}

GpStatus GpImageAttributes::SetICMMode(BOOL on)
{
    if( DeviceImageAttributes.ICMMode!= on)
    {
        DeviceImageAttributes.ICMMode = on;
        UpdateUid();
    }
    return Ok;
}

VOID GpImageAttributes::GetAdjustedPalette(
    ColorPalette * colorPalette,
    ColorAdjustType colorAdjustType
    )
{
    ASSERT((colorPalette != NULL) && (colorPalette->Count > 0));

    if (!this->HasRecoloring(colorAdjustType))
    {
        return;
    }
    this->recolor->Flush();
    this->recolor->ColorAdjust(colorPalette->Entries, colorPalette->Count,
                               colorAdjustType);
}


// Serialization


class ImageAttributesData : public ObjectData
{
public:
    BOOL                CachedBackground;
    DpImageAttributes   DeviceImageAttributes;
};


/**************************************************************************\
*
* Function Description:
*
*   Get the data from the GpImageAttributes for serialization.
*
* Return - size of GpImageAttributes
*
* 05/15/2000 asecchia - created it.
*
\**************************************************************************/

GpStatus
GpImageAttributes::GetData(
    IStream *   stream
    ) const
{
    ASSERT (stream != NULL);

    ImageAttributesData     imageAttributesData;
    imageAttributesData.CachedBackground      = cachedBackground;
    imageAttributesData.DeviceImageAttributes = DeviceImageAttributes;
    stream->Write(&imageAttributesData, sizeof(imageAttributesData), NULL);

    return Ok;
}

UINT
GpImageAttributes::GetDataSize() const
{
    return sizeof(ImageAttributesData);
}

/**************************************************************************\
*
* Function Description:
*
*   Set the GpImageAttributes from the data buffer for serialization.
*
* 05/15/2000 asecchia - created it.
*
\**************************************************************************/

GpStatus
GpImageAttributes::SetData(
    const BYTE *        dataBuffer,
    UINT                size
    )
{
    if (dataBuffer == NULL)
    {
        WARNING(("dataBuffer is NULL"));
        return InvalidParameter;
    }

    if (size < sizeof(ImageAttributesData))
    {
        WARNING(("size too small"));
        return InvalidParameter;
    }

    const ImageAttributesData *imageAttributes;
    imageAttributes = reinterpret_cast<const ImageAttributesData *>(dataBuffer);

    if (!imageAttributes->MajorVersionMatches())
    {
        WARNING(("Version number mismatch"));
        return InvalidParameter;
    }

    cachedBackground = imageAttributes->CachedBackground;
    DeviceImageAttributes = imageAttributes->DeviceImageAttributes;

    UpdateUid();

    // Might consider resetting the recolor objects to identity, but
    // for now don't need to since we know this method only gets called
    // right after the object has been constructed.
    
    return Ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\graphicsstroke.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Abstract:
*
*   Graphics vector stroke APIs.
*
* Revision History:
*
*   12/02/1998 andrewgo
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\graphicstext.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999-2000  Microsoft Corporation
*
* Module Name:
*
*   GraphicsText.cpp
*
* Abstract:
*
*   Text layout and display, Text measurement, Unicode to glyph mapping
*
* Notes:
*
*   Provides support to allow apps to work with Unicode in logical order,
*   hides the mapping from Unicode to glyphs.
*
* Created:
*
*   06/01/99 dbrown
*
\**************************************************************************/


#include "precomp.hpp"

const DOUBLE PI = 3.1415926535897932384626433832795;


/////   Coordinate systems
//
//      The following coordinate systems are used:
//
//      World coordinates (REAL) - the coordinate system used by client
//      applications and passed to most Graphics APIs (for example
//      DrawLine). Text is always purely vertical or purely horizontal in
//      world coordinates. Fonts constructed with emSize specified in
//      alternate units are first converted to world units by calling
//      GetScaleForAlternatePageUnit.
//
//      Device coordinates (REAL) - Coordinates used on the device surface.
//      World coordinates are transformed to device coordinates using the
//      Graphics.Context.WorldToDevice.Transform function. REAL device
//      coordinates may have non-integral values when addressing sub-pixels.
//
//      Font nominal coordinates (INT) - (aka deign units) coordinates used to
//      define a scalable font independant of scaled size.
//      GpFontFace.GetDesignEmHeight is the emSize of a font in nominal units.
//      Nominal coordinates are always a pure scale factor of world units with
//      no shear. For horizontal text there there is no rotation between
//      nominal and world coordinates. For vertical text, most non Far East
//      script characters are rotated by 90 degrees.
//
//      Ideal coordinates (INT) - world coordinates mapped to integers by
//      a pure scale factor for use in Line Services, OpenType services and
//      Uniscribe shaping engine interfaces. The scale factor is usually
//      2048 divided by the emSize of the default font in a text imager.


/////   Transforms
//
//      WorldToDevice - stored in a Graphics. May include scaling,
//      shearing and/or translation.
//
//      WorldToIdeal - stored in a text imager while the imager is attached
//      to a Graphics. A pure scale factor, usually 2048 divided by the emSize
//      of the imager default font.
//
//      FontTransform - stored in a FaceRealization. Maps font nominal units
//      to device coordinates, May include scaling, shearing and rotation, but
//      not translation.


/////   Common buffer parameters
//
//      glyphAdvance - per-glyph advance widths stored in ideal units measured
//      along the text baseline.
//
//      glyphOffset - combining character offsets stored in ideal units
//      measured along and perpendicular to the baseline. The glyphOffset
//      buffer is required by Line Services, OpenType services and the
//      complex script shaping engines, but may somethimes be bypassed for
//      simple scripts.
//
//      glyphOrigins - per glyph device coordinates of the glyph origin (the
//      initial point on the baseline of the glyhps advance vector).
//      Represented as PointF. Non integer values represent sub pixel
//      positions.


/////   Glyph positioning functions
//
//
//      DrawPlacedGlyphs - Builds glyphPos array and passes it to the device driver.
//          ALL text device output output eventually comes through here.
//
//      GetDeviceGlyphOriginsNominal
//          Used when there's no hinting to be accounted for.
//          Places glyph on device using nominal metrics passed in glyphAdvances
//          and glyphOffsets.
//
//      GetDeviceGlyphOriginsAdjusted
//          Used to adjust for the difference between nominal and hinted metrics
//          Generates glyph origins in device units, and adjusts the width of spaces
//          to achieve the totalRequiredIdealAdvance parameter.
//          !!! Need to add support for kashida and inter-glyph justification.
//
//      GetRealizedGlyphPlacement
//          Used to obtain hinted advance metrics along the baseline.
//          !!! Needs to be updated to call complex script shaping engines.
//
//      GetFontTransformForAlternateResolution
//          Used during XMF playback.
//          Generates a font transform to match a font that was recorded at
//          a different resolution.
//
//      MeasureGlyphsAtAlternateResolution
//          Used during XMF playback.
//          Measures glyphs passed to DrawDriverString as if they were to be rendered
//          at the original XMF recording resolution.

/**************************************************************************\
*
* GpGraphics::DrawString
*
*   Draw plain, marked up  or formatted text in a rectangle
*
* Arguments:
*
*
* Return Value:
*
*   GDIPlus status
*
* Created:
*
*   06/25/99 dbrown
*
\**************************************************************************/

GpStatus
GpGraphics::DrawString(
    const WCHAR          *string,
    INT                   length,
    const GpFont         *font,
    const RectF          *layoutRect,
    const GpStringFormat *format,
    const GpBrush        *brush
)
{
    ASSERT(string && font && brush);

    GpStatus status = CheckTextMode();
    if (status != Ok)
    {
        if (IsRecording())
            SetValid(FALSE);      // Prevent any more recording
        return status;
    }

    // Check that the clipping rectangle, if any, is visible, at least in part.

    if (    !IsRecording()       // Metafile clipping happens at playback
        &&  layoutRect->Width
        &&  layoutRect->Height
        &&  (    !format
             ||  !(format->GetFormatFlags() & StringFormatFlagsNoClip)))
    {
        if (    layoutRect->Width < 0
            ||  layoutRect->Height < 0)
        {
            // Client has requested clipping to an empty rectangle, nothing
            // will display.
            return Ok;
        }

        // If client clipping rectangle is outside the visible clipping region -- were done.

        GpRectF     deviceClipRectFloat;
        GpRect      deviceClipRectPixel;
        GpMatrix    worldToDevice;

        TransformBounds(
            &Context->WorldToDevice,
            layoutRect->X,
            layoutRect->Y,
            layoutRect->X + layoutRect->Width,
            layoutRect->Y + layoutRect->Height,
            &deviceClipRectFloat
        );

        status = BoundsFToRect(&deviceClipRectFloat, &deviceClipRectPixel);
        if(status != Ok)
        {
            return status;
        }

        if (IsTotallyClipped(&deviceClipRectPixel))
        {
            // Since nothing will be visible, we need do no more.
            return Ok;
        }
    }



    REAL emSize = font->GetEmSize() * GetScaleForAlternatePageUnit(font->GetUnit());

    if (IsRecording())
    {
        // Record Gdiplus metafile record

        // first measure the text bounding rectangle

        RectF   boundingBox;

        status = MeasureString(
             string,
             length,
             font,
             layoutRect,
             format,
            &boundingBox,
             NULL,
             NULL);

        if (status != Ok)
        {
            SetValid(FALSE);      // Prevent any more recording
            return status;
        }


        GpRectF bounds;
        TransformBounds(&(Context->WorldToDevice), boundingBox.X, boundingBox.Y,
                         boundingBox.GetRight(), boundingBox.GetBottom(), &bounds);

        status = Metafile->RecordDrawString(
            &bounds,
            string,
            length,
            font,
            layoutRect,
            format,
            brush
        );

        if (status != Ok)
        {
            SetValid(FALSE);      // Prevent any more recording
            return status;
        }

        if (!DownLevel)
        {
            return Ok;
        }
        // else we need to record down-level GDI EMF records as well

        // Since we have recorded all the parameters to DrawString,
        // we don't need to do anything more.  For the downlevel case,
        // we need to record the DrawString call as a sequence of
        // ExtTextOut calls.
    }
    else
    {
        // Not recording a metafile, so it is safe to try using the fast text imager.

        FastTextImager fastImager;
        status = fastImager.Initialize(
            this,
            string,
            length,
            *layoutRect,
            font->GetFamily(),
            font->GetStyle(),
            emSize,
            format,
            brush
        );

        if (status == Ok)
        {
            status = fastImager.DrawString();
        }

        // If the fast text imager couldn't handle this case, it returns
        // NotImplemented, and we continue into the full text imager.
        // Otherwise it either completed successfully or hit an error
        // that we need to report.

        if (status != NotImplemented)
        {
            return status;
        }
    }

    // Draw text with the full text imager

    GpTextImager *imager;
    status = newTextImager( // Always creates a fulltextimager.
        string,
        length,
        layoutRect->Width,
        layoutRect->Height,
        font->GetFamily(),
        font->GetStyle(),
        emSize,
        format,
        brush,
        &imager,
        TRUE        // Fast way to set NoChange flag to allow simple imager
    );

    IF_NOT_OK_WARN_AND_RETURN(status);

    imager->GetMetaFileRecordingFlag() = IsRecording();

    EmfPlusDisabler disableEmfPlus(&Metafile);

    status = imager->Draw(this, &PointF(layoutRect->X, layoutRect->Y));

    delete imager;

    return status;
}





/**************************************************************************\
*
* GpGraphics::MeasureString
*
*   Measure plain, marked up  or formatted text in a rectangle
*
* Arguments:
*
*
* Return Value:
*
*   GDIPlus status
*
* Created:
*
*   10/26/99 dbrown
*
\**************************************************************************/


GpStatus
GpGraphics::MeasureString(
    const WCHAR          *string,
    INT                   length,
    const GpFont         *font,
    const RectF          *layoutRect,
    const GpStringFormat *format,
    RectF                *boundingBox,
    INT                  *codepointsFitted,
    INT                  *linesFilled
)
{
    CalculateTextRenderingHintInternal();
    ASSERT(string && font && boundingBox);
    if (!string || !font || !boundingBox)
    {
        return InvalidParameter;
    }

    GpStatus status;

    REAL emSize = font->GetEmSize() * GetScaleForAlternatePageUnit(font->GetUnit());

    if (!IsRecording())
    {
        // Try using the fast imager

        FastTextImager fastImager;
        status = fastImager.Initialize(
            this,
            string,
            length,
            *layoutRect,
            font->GetFamily(),
            font->GetStyle(),
            emSize,
            format,
            NULL
        );

        if (status == Ok)
        {
            status = fastImager.MeasureString(
                boundingBox,
                codepointsFitted,
                linesFilled
            );
        }

        // If the fast text imager couldn't handle this case, it returns
        // NotImplemented, and we continue into the full text imager.
        // Otherwise it either completed successfully or hit an error
        // that we need to report.

        if (status != NotImplemented)
        {
            return status;
        }
    }


    // Measure text with the full text imager

    GpTextImager *imager;
    status = newTextImager(
        string,
        length,
        layoutRect->Width,
        layoutRect->Height,
        font->GetFamily(),
        font->GetStyle(),
        emSize,
        format,
        NULL,
        &imager,
        TRUE        // Enable use of simple formatter when no format passed
    );
    IF_NOT_OK_WARN_AND_RETURN(status);

    *boundingBox = *layoutRect;

    REAL nearGlyphEdge;
    REAL farGlyphEdge;
    REAL textDepth;

    status = imager->Measure(   // Returned edges exclude overhang
        this,
        &nearGlyphEdge,
        &farGlyphEdge,
        &textDepth,
        codepointsFitted,
        linesFilled
    );


    // Generate bounding box (excluding overhang) from near and far glyph edges

    if (status == Ok)
    {
        // Fix up near/far glyph edges for empty box

        if (nearGlyphEdge > farGlyphEdge)
        {
            nearGlyphEdge = 0;
            farGlyphEdge = 0;
        }

        if (   format
            && format->GetFormatFlags() & StringFormatFlagsDirectionVertical)
        {
            boundingBox->Y      = layoutRect->Y + nearGlyphEdge;
            boundingBox->Height = farGlyphEdge - nearGlyphEdge;

            if (format)
            {
                StringAlignment lineAlign = format->GetLineAlign();
                REAL leadingOffset = 0.0;   // positive offset to the leading side edge of the textbox

                if (lineAlign == StringAlignmentCenter)
                {
                    leadingOffset = (boundingBox->Width - textDepth)/2;
                }
                else if (lineAlign == StringAlignmentFar)
                {
                    leadingOffset = boundingBox->Width - textDepth;
                }

                if (format->GetFormatFlags() & StringFormatFlagsDirectionRightToLeft)
                {
                    boundingBox->X += (boundingBox->Width - textDepth - leadingOffset);
                }
                else
                {
                    boundingBox->X += leadingOffset;
                }
            }
            boundingBox->Width  = textDepth;
        }
        else
        {
            boundingBox->X      = layoutRect->X + nearGlyphEdge;
            boundingBox->Width  = farGlyphEdge - nearGlyphEdge;

            if (format)
            {
                StringAlignment lineAlign = format->GetLineAlign();

                if (lineAlign == StringAlignmentCenter)
                {
                    boundingBox->Y += (boundingBox->Height - textDepth) / 2;
                }
                else if (lineAlign == StringAlignmentFar)
                {
                    boundingBox->Y += boundingBox->Height - textDepth;
                }
            }
            boundingBox->Height = textDepth;
        }

        if (!format
            || !(format->GetFormatFlags() & StringFormatFlagsNoClip))
        {
            //  Make sure display bounding box never exceeds layout rectangle
            //  in case of clipping.

            if (   layoutRect->Width > 0.0
                && boundingBox->Width > layoutRect->Width)
            {
                boundingBox->Width = layoutRect->Width;
                boundingBox->X     = layoutRect->X;
            }

            if (   layoutRect->Height > 0.0
                && boundingBox->Height > layoutRect->Height)
            {
                boundingBox->Height = layoutRect->Height;
                boundingBox->Y      = layoutRect->Y;
            }
        }
    }

    delete imager;

    return status;
}



/**************************************************************************\
*
* GpGraphics::MeasureCharacterRanges
*
*   Produce a bounding regions of all given character ranges in stringformat
*
* Arguments:
*
*
* Return Value:
*
*   GDIPlus status
*
* Created:
*
*   10-9-2000 wchao
*
\**************************************************************************/
GpStatus
GpGraphics::MeasureCharacterRanges(
    const WCHAR          *string,
    INT                   length,
    const GpFont         *font,
    const RectF          &layoutRect,
    const GpStringFormat *format,
    INT                   regionCount,
    GpRegion            **regions
)
{
    CalculateTextRenderingHintInternal();
    ASSERT(format && string && font && regions);


    INT rangeCount = format->GetMeasurableCharacterRanges();

    if (regionCount < rangeCount)
    {
        return InvalidParameter;
    }

    INT stringLength;
    if (length == -1)
    {
        stringLength = 0;
        while (string[stringLength])
        {
            stringLength++;
        }
    }
    else
    {
        stringLength = length;
    }

    GpStatus status;

    REAL emSize = font->GetEmSize() * GetScaleForAlternatePageUnit(font->GetUnit());

    GpTextImager *imager;
    status = newTextImager(
        string,
        stringLength,
        layoutRect.Width,
        layoutRect.Height,
        font->GetFamily(),
        font->GetStyle(),
        emSize,
        format,
        NULL,
        &imager,
        TRUE        // Enable use of simple formatter when no format passed
    );
    IF_NOT_OK_WARN_AND_RETURN(status);

    imager->GetMetaFileRecordingFlag() = IsRecording();

    PointF imagerOrigin(layoutRect.X , layoutRect.Y);

    status = imager->MeasureRanges(
        this,
        &imagerOrigin,
        regions
    );

    delete imager;

    return status;
}




/////   DrawPlacedGlyphs - Draw glyphs with arbitrary transform at device coordinates
//
//


GpStatus
GpGraphics::DrawPlacedGlyphs(
    const GpFaceRealization *faceRealization,
    const GpBrush           *brush,
    INT                      flags,         // For DG_NOGDI
    const WCHAR             *string,
    UINT                     stringLength,
    BOOL                     rightToLeft,
    const UINT16            *glyphs,
    const UINT16            *glyphMap,
    const PointF            *glyphOrigins,
    INT                      glyphCount,
    ItemScript               Script,
    BOOL                     sideways        // e.g. FE characters in vertical text
)
{
    IF_NOT_OK_WARN_AND_RETURN(faceRealization->GetStatus());

    INT     i;
    BOOL    bNeedPath = FALSE;
    GpFaceRealization cloneFaceRealization;
    GpGlyphPos *glyphPositions = NULL;
    GpGlyphPos *glyphPathPositions = NULL;

    // Display glyphs for Bits. Handle as many as possible in one go.

    INT glyphStart = 0;     // start of this display run
    INT glyphsProcessed;    // Number of glyphs processed by this GetGlyphPos call
    INT glyphPositionCount; // Number of glyphPositions generated by this GetGlyphPos call

    // Display glyphs for path. Handle as many as possible in one go.

    INT glyphPathStart = 0;     // start of this display run
    INT glyphsPathProcessed, glyphsPathProcessedTemp;    // Number of glyphs processed by this GetGlyphPos call
    INT glyphPathPositionCount, glyphPathPositionCountTemp; // Number of glyphPositions generated by this GetGlyphPos call


    GpStatus status = Ok;

    if (!glyphOrigins)
    {
        ASSERT(glyphOrigins);
        return GenericError;
    }


    // For sideways text, we have been passed glyph origins at the
    // top baseline, but we need to pass leftside baseline origins
    // to DrvDrawGlyphs for the benefit of metafiles and GDI positioning.

    AutoBuffer<PointF, 16> adjustedGlyphOrigins;
    const PointF *leftsideGlyphOrigins = glyphOrigins;

    if (sideways && Driver != Globals::MetaDriver)
    {
        adjustedGlyphOrigins.SetSize(glyphCount);
        if (!adjustedGlyphOrigins)
        {
            status = OutOfMemory;
            goto error;
        }

        status = faceRealization->GetGlyphStringVerticalOriginOffsets(
            glyphs,
            glyphCount,
            adjustedGlyphOrigins.Get()
        );
        if (status != Ok)
        {
            goto error;
        }

        for (INT i=0; i<glyphCount; i++)
        {
            adjustedGlyphOrigins[i].X = glyphOrigins[i].X - adjustedGlyphOrigins[i].X;
            adjustedGlyphOrigins[i].Y = glyphOrigins[i].Y - adjustedGlyphOrigins[i].Y;
        }

        leftsideGlyphOrigins = adjustedGlyphOrigins.Get();
    }



    glyphPositions = new GpGlyphPos[glyphCount];

    if (!glyphPositions)
    {
        status = OutOfMemory;
        goto error;
    }

    ASSERT(!faceRealization->IsPathFont() || Driver == Globals::MetaDriver);

    if (Driver == Globals::MetaDriver)
    {
        INT     minX = MAXLONG;
        INT     minY = MAXLONG;
        INT     maxX = MINLONG;
        INT     maxY = MINLONG;
        INT     glyphPositionCountTemp = 0;

        while (glyphStart < glyphCount)
        {
            glyphPositionCount = faceRealization->GetGlyphPos(
                glyphCount     - glyphStart,
                glyphs         + glyphStart,
                glyphPositions + glyphStart,
                glyphOrigins   + glyphStart,
                &glyphsProcessed,
                sideways
            );

            if (glyphPositionCount == 0 && ((glyphsProcessed +  glyphStart) < glyphCount))
            {
                status = OutOfMemory;
                goto error;
            }

            for (i = 0; i < glyphPositionCount; i++)
            {
                INT j = glyphPositionCountTemp + i;

                if (glyphPositions[j].GetWidth()  != 0 &&
                    glyphPositions[j].GetHeight() != 0)
                {
                    minX = min(minX, glyphPositions[j].GetLeft());
                    minY = min(minY, glyphPositions[j].GetTop());
                    maxX = max(maxX, glyphPositions[j].GetLeft() + glyphPositions[j].GetWidth());
                    maxY = max(maxY, glyphPositions[j].GetTop()  + glyphPositions[j].GetHeight());
                }

                if (glyphPositions[j].GetTempBits() != NULL)
                {
                    GpFree(glyphPositions[j].GetTempBits());
                    glyphPositions[j].SetTempBits(0);
                }
            }

            glyphStart += glyphsProcessed;
            glyphPositionCountTemp += glyphPositionCount;
        }

        glyphPositionCount = glyphPositionCountTemp;


        if (minX < maxX && minY < maxY)
        {
            // must grab the devlock before going into the driver.

            Devlock devlock(Device);

            GpRect drawBounds(minX, minY, maxX-minX, maxY-minY);

            REAL edgeGlyphAdvance;

            if (rightToLeft)
            {
                status = faceRealization->GetGlyphStringDeviceAdvanceVector(glyphs,
                                                                   1,
                                                                   FALSE,
                                                                   &edgeGlyphAdvance);
            }
            else
            {
                status = faceRealization->GetGlyphStringDeviceAdvanceVector(&glyphs[glyphCount-1],
                                                                    1,
                                                                    FALSE,
                                                                    &edgeGlyphAdvance);
            }
            if (status != Ok)
                goto error;


            if (sideways)
            {
                flags |= DG_SIDEWAY;
            }

            status = DrvDrawGlyphs(
                &drawBounds,
                glyphPositions,
                NULL,
                glyphPositionCount,
                brush->GetDeviceBrush(),
                faceRealization,
                glyphs,
                glyphMap,
                leftsideGlyphOrigins,
                glyphCount,
                string,
                stringLength,
                Script,
                GpRound(edgeGlyphAdvance),
                rightToLeft,
                flags
            );
            if (status != Ok)
                goto error;
        }
    }
    else
    {
        if (IsPrinter())
        {
            DriverPrint *pdriver = (DriverPrint*) Driver;

            if (pdriver->DriverType == DriverPostscript)
            {
                if (brush->GetBrushType() != BrushTypeSolidColor)
                {
                // generate bitmap & path in glyphPos
                    bNeedPath = TRUE;
                }
             }
        }

        if (bNeedPath)
        {
            cloneFaceRealization.CloneFaceRealization(faceRealization, TRUE);

            if (!cloneFaceRealization.IsValid())
            {
                status = OutOfMemory;
                goto error;
            }

            ASSERT(cloneFaceRealization.IsPathFont());
        }


        if (bNeedPath)
        {
            glyphPathPositions = new GpGlyphPos[glyphCount];

            if (!glyphPathPositions)
            {
                status = OutOfMemory;
                goto error;
            }
        }


        while (glyphStart < glyphCount)
        {
            glyphPositionCount = faceRealization->GetGlyphPos(
                glyphCount   - glyphStart,
                glyphs       + glyphStart,
                glyphPositions,
                glyphOrigins + glyphStart,
                &glyphsProcessed,
                sideways
            );

            // glyphPositionCount = number of entries added to glyphPositions array
            // glyphsPositioned   = number of glyph indices processed from glyph buffer


            if (glyphPositionCount == 0 && ((glyphsProcessed +  glyphStart) < glyphCount))
            {
                status = OutOfMemory;
                goto error;
            }

            glyphsPathProcessed = 0;
            glyphPathPositionCount = 0;

            while (glyphsPathProcessed < glyphsProcessed)
            {
                INT     minX = MAXLONG;
                INT     minY = MAXLONG;
                INT     maxX = MINLONG;
                INT     maxY = MINLONG;

                if (bNeedPath)
                {
                    glyphPathPositionCountTemp = cloneFaceRealization.GetGlyphPos(
                        glyphsProcessed - glyphsPathProcessed,
                        glyphs + glyphPathStart + glyphsPathProcessed,
                        glyphPathPositions,
                        glyphOrigins + glyphPathStart + glyphsPathProcessed,
                        &glyphsPathProcessedTemp,
                        sideways
                    );

                    glyphsPathProcessed += glyphsPathProcessedTemp;

                    if (glyphPathPositionCountTemp == 0 && (glyphsPathProcessed < glyphsProcessed))
                    {
                        ASSERT(glyphPathPositionCount != glyphPositionCount);

                        status = OutOfMemory;
                        goto error;
                    }
                }
                else
                {
                    glyphsPathProcessed = glyphsProcessed;
                    glyphPathPositionCountTemp = glyphPositionCount;
                }

                for (i = 0; i < glyphPathPositionCountTemp; i++)
                {
                    INT j = glyphPathPositionCount + i;

                    if (glyphPositions[j].GetWidth()  != 0 &&
                        glyphPositions[j].GetHeight() != 0)
                    {
                        minX = min(minX, glyphPositions[j].GetLeft());
                        minY = min(minY, glyphPositions[j].GetTop());
                        maxX = max(maxX, glyphPositions[j].GetLeft() + glyphPositions[j].GetWidth());
                        maxY = max(maxY, glyphPositions[j].GetTop()  + glyphPositions[j].GetHeight());
                    }
                }

                if (minX < maxX && minY < maxY)
                {
                    // must grab the devlock before going into the driver.

                    Devlock devlock(Device);

                    GpRect drawBounds(minX, minY, maxX-minX, maxY-minY);

                    REAL edgeGlyphAdvance;

                    if (rightToLeft)
                    {
                        status = faceRealization->GetGlyphStringDeviceAdvanceVector(glyphs,
                                                                            1,
                                                                            FALSE,
                                                                            &edgeGlyphAdvance);
                    }
                    else
                    {
                        status = faceRealization->GetGlyphStringDeviceAdvanceVector(&glyphs[glyphCount-1],
                                                                            1,
                                                                            FALSE,
                                                                            &edgeGlyphAdvance);
                    }
                    if (status != Ok)
                        goto error;

                    status = DrvDrawGlyphs(
                        &drawBounds,
                        &glyphPositions[glyphPathPositionCount],
                        glyphPathPositions,
                        glyphPathPositionCountTemp,
                        brush->GetDeviceBrush(),
                        faceRealization,
                        glyphs + glyphPathStart,
                        glyphMap + glyphPathStart,
                        leftsideGlyphOrigins + glyphPathStart,
                        glyphsProcessed,
                        string,
                        stringLength,
                        Script,
                        GpRound(edgeGlyphAdvance),
                        rightToLeft,
                        flags
                    );
                    if (status != Ok)
                        goto error;
                }

                glyphPathPositionCount += glyphPathPositionCountTemp;
            }

            ASSERT (glyphsPathProcessed == glyphsProcessed);
            ASSERT (glyphPathPositionCount == glyphPositionCount);

            // Free any temporary bitmap buffers created by subpixelling

            for (i=0; i<glyphPositionCount; i++)
            {
                if (glyphPositions[i].GetTempBits() != NULL)
                {
                    GpFree(glyphPositions[i].GetTempBits());
                    glyphPositions[i].SetTempBits(0);
                }
            }

            glyphStart += glyphsProcessed;
            glyphPathStart += glyphsPathProcessed;
        }
    }
error:

    // free memory allocated

    if (glyphPositions)
        delete [] glyphPositions;

    if (glyphPathPositions)
        delete [] glyphPathPositions;

    return status;
}

// GpGraphics::CheckTextMode
// disallow ClearType text for CompositingModeSourceCopy
GpStatus GpGraphics::CheckTextMode()
{
    CalculateTextRenderingHintInternal();

    if (GetCompositingMode() == CompositingModeSourceCopy &&
        GetTextRenderingHintInternal() == TextRenderingHintClearTypeGridFit)
    {
        ONCE(WARNING(("CompositingModeSourceCopy cannot be used with ClearType text")));
        return InvalidParameter;
    }
    return Ok;
} // GpGraphics::CheckTextMode


void GpGraphics::CalculateTextRenderingHintInternal()
{
    // this procedure is meant to be used by internal text routine and will convert TextRenderingHintSystemDefault
    // to the current system mode
    ASSERT(Context);

    TextRenderingHint  textMode = Context->TextRenderHint;

    if (IsPrinter())
    {
        textMode = TextRenderingHintSingleBitPerPixelGridFit;
    }
    else if (textMode == TextRenderingHintSystemDefault)
    {
        if (Globals::CurrentSystemRenderingHintInvalid)
        {
            // Get the current text antialiazing mode from the system
            DWORD       bOldSF, dwOldSFT;
            SystemParametersInfoA( SPI_GETFONTSMOOTHING, 0, (PVOID)&bOldSF, 0 );
            if (bOldSF)
            {
                SystemParametersInfoA( SPI_GETFONTSMOOTHINGTYPE, 0, (PVOID)&dwOldSFT, 0 );

                if( dwOldSFT & FE_FONTSMOOTHINGCLEARTYPE )
                {
                    Globals::CurrentSystemRenderingHint = TextRenderingHintClearTypeGridFit;
                } else
                {
                    Globals::CurrentSystemRenderingHint = TextRenderingHintAntiAliasGridFit;
                }
            } else
            {
                Globals::CurrentSystemRenderingHint = TextRenderingHintSingleBitPerPixelGridFit;
            }
        }
        textMode = Globals::CurrentSystemRenderingHint;
    }

    // Lead and PM decision to disable ClearType on downlevel system, we allow only on Windows NT 5.1 or later
    if ((textMode == TextRenderingHintClearTypeGridFit) &&
          (!Globals::IsNt ||
             (Globals::OsVer.dwMajorVersion < 5) ||
             ((Globals::OsVer.dwMajorVersion == 5) && (Globals::OsVer.dwMinorVersion < 1))
             )
           )
    {
        textMode = TextRenderingHintSingleBitPerPixelGridFit;
    }

    if (textMode == TextRenderingHintClearTypeGridFit ||
        textMode == TextRenderingHintAntiAlias ||
        textMode == TextRenderingHintAntiAliasGridFit)
    {
        if (Surface &&
            GetPixelFormatSize(Surface->PixelFormat) <= 8 &&
            Surface->PixelFormat != PixelFormatMulti)
        {
            // disable AA & ClearType in 256 bit color mode and less
            textMode = TextRenderingHintSingleBitPerPixelGridFit;
        }
        else if (Globals::IsTerminalServer)
        {
            // disable AA & ClearType for Terminal Server desktop surface
            if (Surface && Surface->IsDesktopSurface())
            {
                textMode = TextRenderingHintSingleBitPerPixelGridFit;
            } 
        }
    }
    
    if (textMode == TextRenderingHintClearTypeGridFit)
    {
        if (Globals::CurrentSystemRenderingHintInvalid)
        {
            // get ClearType orientation setting from the system
            UpdateLCDOrientation();
        }
    }

    Globals::CurrentSystemRenderingHintInvalid = FALSE;
    TextRenderingHintInternal = textMode;
} // GpGraphics::CalculateTextRenderingHintInternal




/////   DrawFontStyleLine
//
//      Draw underline or strikethrough or both depending on what style is used
//      in the font. Given points are in world coordinate.
//
//      Make sure the line thickness is at least 1 pixel wide.


GpStatus GpGraphics::DrawFontStyleLine(
    const PointF        *baselineOrigin,    // baseline origin
    REAL                baselineLength,     // baseline length
    const GpFontFace    *face,              // font face
    const GpBrush       *brush,             // brush
    BOOL                vertical,           // vertical text?
    REAL                emSize,             // font EM size in world unit
    INT                 style,              // kind of lines to be drawn
    const GpMatrix      *matrix             // additional transform
)
{
    REAL fontToWorld = emSize / TOREAL(face->GetDesignEmHeight());

    PointF  drawingParams[2];   // X is offset from baseline, Y is device pen width
    INT     count = 0;

    GpStatus status = Ok;

    if (style & FontStyleUnderline)
    {
        //  underlining metric

        const REAL penPos   = face->GetDesignUnderscorePosition() * fontToWorld;
        REAL penWidth = face->GetDesignUnderscoreSize() * fontToWorld;
        penWidth = GetDevicePenWidth(penWidth, matrix);

        drawingParams[count].X   = penPos;
        drawingParams[count++].Y = penWidth;
    }

    if (style & FontStyleStrikeout)
    {
        //  strikethrough metric

        const REAL penPos   = face->GetDesignStrikeoutPosition() * fontToWorld;
        REAL penWidth = face->GetDesignStrikeoutSize() * fontToWorld;
        penWidth = GetDevicePenWidth(penWidth, matrix);

        drawingParams[count].X   = penPos;
        drawingParams[count++].Y = penWidth;
    }


    for (INT i = 0; i < count; i++)
    {
        PointF points[2];
        points[0] = *baselineOrigin;

        if (vertical)
        {
            points[0].X += drawingParams[i].X;  // offset from baseline
            points[1].X = points[0].X;
            points[1].Y = points[0].Y + baselineLength;
        }
        else
        {
            points[0].Y -= drawingParams[i].X;  // offset from baseline
            points[1].Y = points[0].Y;
            points[1].X = points[0].X + baselineLength;
        }

        if (matrix)
        {
            matrix->Transform(points, 2);
        }

        status = DrawLine(
            &GpPen(
                brush,
                drawingParams[i].Y,
                UnitPixel
            ),
            points[0],
            points[1]
        );

        IF_NOT_OK_WARN_AND_RETURN(status);
    }

    return status;
}




//  fix up pen width for strikeout/underline/hotkey cases
//  to avoid varying line width within the same paragraph
//  return value is in pixel units

REAL GpGraphics::GetDevicePenWidth(
    REAL            widthInWorldUnits,
    const GpMatrix  *matrix
)
{
    GpMatrix worldToDevice;
    GetWorldToDeviceTransform(&worldToDevice);

    if (matrix)
    {
        worldToDevice.Prepend(*matrix);
    }

    PointF underlineVector(widthInWorldUnits, 0.0f);
    worldToDevice.VectorTransform(&underlineVector);
    REAL penWidth = (REAL)GpRound(VectorLength(underlineVector));
    if (penWidth < 1.0f)
        penWidth = 1.0f;
    return penWidth;
}


/////   DriverString APIs
//
//      Driver string APIs are in engine\text\DriverStringImager.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\initialize.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998-1999  Microsoft Corporation
*
* Abstract:
*
*   Initialization routines for GDI+.
*
* Revision History:
*
*   12/02/1998 andrewgo
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

#if GP_ICECAP>1
#include "icecap.h"
#endif


// Add this to the Globals namespace.

namespace Globals {
    extern BOOL RuntimeInitialized;
};


/**************************************************************************\
*
* Function Description:
*
*   Generates a token that an init API can return, used to match the
*   startup call with the shutdown call.
*
* Return value:
*
*   A non-zero value. It doesn't really matter what it is - it could be
*   a simple magic number, but we don't want apps relying on it being a
*   particular value.
*
* History:
*
*   09/15/2000 agodfrey
*       Created it.
*
\**************************************************************************/

ULONG_PTR GenerateInitToken()
{
    ULONG_PTR ret = GetTickCount();
    if (ret == 0)
    {
        ret = 1;
    }
    return ret;
}

/**************************************************************************\
*
* Function Description:
*
*   This routine should undo all of the initialization done in
*   'InternalGdiplusStartup'.
*
* Notes:
*
*   Whenever this function, or the functions it calls, frees a pointer or
*   destroys a resource, it should set the corresponding global to NULL.
*   This is because it's legal for clients to call GdiplusStartup later.
*
*   In addition, for resources, like DC's and DLL handles, we don't want to
*   call the "destroy" API if the handle is NULL, since it can waste time -
*   some API's take their time about recognizing the NULL.
*
*   "delete" doesn't have this problem (the compiler generates a
*   NULL check for us.)
*
* Preconditions:
*
*   GdiplusStartupCriticalSection must be held.
*
* History:
*
*   12/02/1998 andrewgo
*       Created it.
*   10/03/2000 agodfrey
*       Changed it to zero out any pointers/handles that it cleans up,
*       so that InternalGdiplusStartup can safely be called later.
*
\**************************************************************************/

VOID
InternalGdiplusShutdown(
    VOID
    )
{
    if (Globals::ThreadNotify != NULL)
    {
        BackgroundThreadShutdown();
    }

    // BackgroundThreadShutdown should NULL this variable itself:
    ASSERT(Globals::ThreadNotify == NULL);

    delete Globals::PathLookAside;        Globals::PathLookAside   = NULL;
    delete Globals::MatrixLookAside;      Globals::MatrixLookAside = NULL;
    delete Globals::PenLookAside;         Globals::PenLookAside    = NULL;

    delete Globals::DesktopDevice;        Globals::DesktopDevice   = NULL;
    delete Globals::DeviceList;           Globals::DeviceList      = NULL;
    delete Globals::EngineDriver;         Globals::EngineDriver    = NULL;
    delete Globals::DesktopDriver;        Globals::DesktopDriver   = NULL;
    delete Globals::GdiDriver;            Globals::GdiDriver       = NULL;
    delete Globals::D3DDriver;            Globals::D3DDriver       = NULL;
    delete Globals::InfoDriver;           Globals::InfoDriver      = NULL;
    delete Globals::MetaDriver;           Globals::MetaDriver      = NULL;
    delete Globals::DesktopSurface;       Globals::DesktopSurface  = NULL;

    if (Globals::DdrawHandle)
    {
        FreeLibrary(Globals::DdrawHandle);
        Globals::DdrawHandle = NULL;
    }
    if (Globals::CachedGdiRegion)
    {
        DeleteObject(Globals::CachedGdiRegion);
        Globals::CachedGdiRegion = NULL;
    }
    if (Globals::DesktopIc)
    {
        DeleteDC(Globals::DesktopIc);
        Globals::DesktopIc = NULL;
    }

    delete Globals::FontCollection;       Globals::FontCollection  = NULL;
    delete Globals::FontLinkTable;        Globals::FontLinkTable   = NULL;

    if (Globals::SurrogateFontsTable!= NULL &&
        Globals::SurrogateFontsTable!= (GpFontFamily **)-1)
    {
        GpFree(Globals::SurrogateFontsTable);
    }
    Globals::SurrogateFontsTable = (GpFontFamily **) -1;

    delete Globals::FontCacheLastRecentlyUsedList;
        Globals::FontCacheLastRecentlyUsedList = NULL;

    delete Globals::NationalDigitCache;   Globals::NationalDigitCache = NULL;

    // destroy the Generic objects
    GpStringFormat::DestroyStaticObjects();

    delete [] Globals::SystemDirW;        Globals::SystemDirW      = NULL;
    delete [] Globals::SystemDirA;        Globals::SystemDirA      = NULL;
    delete [] Globals::FontsDirW;         Globals::FontsDirW       = NULL;
    delete [] Globals::FontsDirA;         Globals::FontsDirA       = NULL;

    if (Globals::LookAsideBuffer)
    {
        GpFree(Globals::LookAsideBuffer);
        Globals::LookAsideBuffer = NULL;
    }

    if (Globals::TextCriticalSectionInitialized)
    {
        DeleteCriticalSection(&Globals::TextCriticalSection);
        Globals::TextCriticalSectionInitialized = FALSE;
    }

    if (Globals::DcimanHandle)
    {
        FreeLibrary(Globals::DcimanHandle);
        Globals::DcimanHandle = NULL;
    }

    // Uninitialize imaging library

    CleanupImagingLibrary();

    GpTextImager::CleanupTextImager();

    if (Globals::UniscribeDllModule)
    {
        FreeLibrary(Globals::UniscribeDllModule);
        Globals::UniscribeDllModule = NULL;
    }

    if (Globals::RuntimeInitialized)
    {
        GpRuntime::Uninitialize();
        Globals::RuntimeInitialized = FALSE;
    }

    // We leak Globals::Monitors intentionally, so that it can be used
    // around GdiplusShutdown as well. It's okay because:
    //
    // 1) Unless the user has called GdipMonitorControl (to be removed before
    //    we ship), nothing will be leaked.
    // 2) GpMonitors defines its own new and delete, which bypass GpMalloc/
    //    GpFree. So, this won't cause us to hit the memory leak assertion.
    
    // delete Globals::Monitors;             Globals::Monitors = NULL;

    LoadLibraryCriticalSection::DeleteCriticalSection();
    BackgroundThreadCriticalSection::DeleteCriticalSection();

    // Perform memory leak detection.
    // Must be done after all memory cleanup.

    GpAssertShutdownNoMemoryLeaks();

    VERBOSE(("InternalGdiplusShutdown completed"));

    // This must be done last.

    GpMallocTrackingCriticalSection::DeleteCriticalSection();

    if (GpRuntime::GpMemHeap)
    {
        HeapDestroy(GpRuntime::GpMemHeap);
        GpRuntime::GpMemHeap = NULL;
    }
}

/******************************Public*Routine******************************\
*
* Routine Name:
*
*   GetLanguageID
*
* Routine Description:
*
*   This routines returns the default language ID.  Normally, we would call
*   GetLocaleInfoW to get this information but that API is not available in
*   kernel mode.  Since GetLocaleInfoW gets it from the registry we'll do the
*   same.
*
* Arguments: none
*
* Called by:
*
* Return Value:
*
*   The default language ID.  If the call fails it will just return 0x0409
*   for English.
*
\**************************************************************************/

USHORT GetLanguageID(VOID)
{
    //  Language ID is the low word of lcid
    DWORD lcid = GetSystemDefaultLCID();
    USHORT result = USHORT(lcid & 0x0000ffff);

#if INITIALIZE_DBG
    TERSE(("Language ID = 0x%04x", result));
#endif

    return(result);
}

/**************************************************************************\
*
* Function Description:
*
*   Initialize the version-related data.  This may be called several times,
*   so this must not allocate memory, etc.  This is called both by
*   InternalGdiplusStartup() and by the GpObject class constructor.  Since an
*   object can be global, an object may be created before
*   InternalGdiplusStartup() is called, which is why the GpObject
*   constructor may need to call this.
*
*   Only state that is needed by our initialization routines should be
*   initialized here.
*
*   !!! [agodfrey] I disagree with the above. I don't think it's safe to let
*   apps call us before they call GdiplusStartup. For one thing, we will
*   erroneously assert that memory was leaked - but I think we could AV.
*
*   It does make life a little tricky for app developers if
*   they want global objects that call us in their constructors.
*   We need to publish sample code for how to do this safely
*   (e.g. see test\gpinit.inc)
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* Created:
*
*   7/26/1999 DCurtis
*
\**************************************************************************/

VOID
InitVersionInfo()
{
    if (!Globals::VersionInfoInitialized)
    {
        Globals::OsVer.dwOSVersionInfoSize = sizeof(Globals::OsVer);
        GetVersionExA(&Globals::OsVer);

        Globals::IsNt = (Globals::OsVer.dwPlatformId == VER_PLATFORM_WIN32_NT);
        Globals::IsWin95 = ((Globals::OsVer.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) &&
                            (Globals::OsVer.dwMajorVersion == 4) &&
                            (Globals::OsVer.dwMinorVersion == 0));
        Globals::ACP = GetACP();

        #if defined(_X86_)

            // InterlockedCompareExchange isn't exported on Win95, so we have to
            // roll our own:

            // Note that we shouldn't call directly through this function
            // pointer, since we don't initialize it for Alpha.  Instead,
            // use either CompareExchangeLong_Ptr or CompareExchangePointer.

            // InterlockedIncrement is defined differently on Win95 vs. Win98
            // so we include a copy here.

            if (Globals::IsNt)
            {
                HMODULE module = GetModuleHandle(TEXT("kernel32.dll"));

                Globals::InterlockedCompareExchangeFunction
                    = (INTERLOCKEDCOMPAREEXCHANGEFUNCTION)
                        GetProcAddress(module, "InterlockedCompareExchange");
            }
            else
            {
                Globals::InterlockedCompareExchangeFunction
                    = InterlockedCompareExchangeWin95;
            }

        #endif

        Globals::VersionInfoInitialized = TRUE;
    }
}

VOID SysColorNotify();

/**************************************************************************\
*
* Function Description:
*
*   Initialize globals for the GDI+ engine.
*
*   NOTE: Initialization should not be extremely expensive!
*         Do NOT put a lot of gratuitous junk into here; consider instead
*         doing lazy initialization.
*
* Arguments:
*
*   debugEventFunction - A function the caller can give us that we'll call
*                        to report ASSERTs or WARNINGs. Can be NULL.
*
* Preconditions:
*
*   GdiplusStartupCriticalSection must be held.
*
* Return Value:
*
*   FALSE if failure (such as low memory).
*
* History:
*
*   12/02/1998 andrewgo
*       Created it.
*
\**************************************************************************/

GpStatus
InternalGdiplusStartup(
    const GdiplusStartupInput *input)
{
    // Set up the debug event reporting function, before we use ASSERT or
    // WARNING.

    Globals::UserDebugEventProc = input->DebugEventCallback;

#if GDIPPRIVATEBUILD
#define GDIPCREATEUSERNAMEMESSAGE() "This is a private build from " USERNAME \
"\nBuilt on " __DATE__ " " __TIME__
        ::MessageBoxA(NULL, GDIPCREATEUSERNAMEMESSAGE(), "Private Build", MB_OK);
#undef GDIPCREATEUSERNAMEMESSAGE
#endif
        

    // Create the GDI+ heap...
    ASSERT(!GpRuntime::GpMemHeap);
    GpRuntime::GpMemHeap = HeapCreate(GPMEMHEAPFLAGS, GPMEMHEAPINITIAL, GPMEMHEAPLIMIT);

    // If we cannot create the heap, give up!
    if (!GpRuntime::GpMemHeap)
        goto ErrorOut;

    // This must happen first.

    __try
    {
        GpMallocTrackingCriticalSection::InitializeCriticalSection();
        BackgroundThreadCriticalSection::InitializeCriticalSection();
        LoadLibraryCriticalSection::InitializeCriticalSection();
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // We couldn't allocate the criticalSection
        // Return an error
        goto ErrorOut;
    }


    // If Allocation failures are turned on, do some initialization here.

    GpInitializeAllocFailures();
    GpStartInitializeAllocFailureMode();

    INT height;
    INT width;
    GpDevice *device;

    Globals::RuntimeInitialized = GpRuntime::Initialize();
    if (!Globals::RuntimeInitialized)
        goto ErrorOut;

    InitVersionInfo();

    Globals::CachedGdiRegion = CreateRectRgn(0, 0, 1, 1);
    if (!Globals::CachedGdiRegion)
        goto ErrorOut;


    // Initialize Stack Back Trace functionality if necessary.
    
    Globals::CaptureStackBackTraceFunction = NULL;
    
    // This stuff requires NT (ntdll.dll)
    
    #if GPMEM_ALLOC_CHK
    
    if(Globals::IsNt)
    {
        HMODULE module = GetModuleHandleA("ntdll.dll");

        Globals::CaptureStackBackTraceFunction = (CAPTURESTACKBACKTRACEFUNCTION)
            GetProcAddress(module, "RtlCaptureStackBackTrace");
    }

    #endif

    // Memory allocation subsystem is initialized. It is now safe to use
    // GpMalloc.




    // Initialize multi-monitor and window event related function pointers

    {
        HMODULE module = GetModuleHandleA("user32.dll");

        Globals::GetWindowInfoFunction = (GETWINDOWINFOFUNCTION)
            GetProcAddress(module, "GetWindowInfo");

        Globals::GetAncestorFunction = (GETANCESTORFUNCTION)
            GetProcAddress(module, "GetAncestor");

        Globals::GetMonitorInfoFunction = (GETMONITORINFOFUNCTION)
            GetProcAddress(module, "GetMonitorInfoA");

        Globals::EnumDisplayMonitorsFunction = (ENUMDISPLAYMONITORSFUNCTION)
            GetProcAddress(module, "EnumDisplayMonitors");

        Globals::EnumDisplayDevicesFunction = (ENUMDISPLAYDEVICESFUNCTION)
            GetProcAddress(module, "EnumDisplayDevicesA");

        Globals::SetWinEventHookFunction = (SETWINEVENTHOOKFUNCTION)
            GetProcAddress(module, "SetWinEventHook");

        Globals::UnhookWinEventFunction = (UNHOOKWINEVENTFUNCTION)
            GetProcAddress(module, "UnhookWinEvent");
    }

    // Create the default desktop device representation.

    if (GetSystemMetrics(SM_REMOTESESSION))
    {
        // it is a remote session
        Globals::IsTerminalServer = TRUE;
    }
    else
    {
        // it isn't a remote session.
        Globals::IsTerminalServer = FALSE;
    }

    // On the NT codebase, the CreateDC(DISPLAY, NULL, NULL, NULL) call has
    // thread affinity. This means that the desktop DC would go away if the
    // thread which called GdiplusStartup terminated even if we were still 
    // using it.
    // On NT we create an Info DC which has process affinity. Rendering onto
    // an Info DC is not supported but that's ok because we always create
    // DriverMulti on NT - and therefore always render on a monitor specific
    // DC instead.
    // Win9x does not have the thread affinity problem and we'd use an IC
    // if it weren't for the fact that win95 doesn't have EnumDisplayMonitors
    // and hence uses DriverGdi instead of DriverMulti - rendering directly
    // on the DesktopIc
    // see RAID:
    // 301407 GDI+ Globals::DesktopDc has thread affinity
    // 312342 CreateDC("Display", NULL, NULL, NULL) has thread affinity.
    // and gdiplus/test/multithread for a test app that exposes this problem.

    
    if(Globals::IsNt)
    {
        Globals::DesktopIc = CreateICA("DISPLAY", NULL, NULL, NULL);
    }
    else
    {
        Globals::DesktopIc = CreateDCA("DISPLAY", NULL, NULL, NULL);
    }
    
    if (!Globals::DesktopIc)
    {
        goto ErrorOut;
    }

    Globals::DesktopDpiX = (REAL)::GetDeviceCaps(Globals::DesktopIc, LOGPIXELSX);
    Globals::DesktopDpiY = (REAL)::GetDeviceCaps(Globals::DesktopIc, LOGPIXELSY);

    if ((Globals::DesktopDpiX <= 0) || (Globals::DesktopDpiY <= 0))
    {
        WARNING(("GetDeviceCaps failed"));
        Globals::DesktopDpiX = DEFAULT_RESOLUTION;
        Globals::DesktopDpiY = DEFAULT_RESOLUTION;
    }

    device = Globals::DesktopDevice = new GpDevice(Globals::DesktopIc);
    if (!CheckValid(Globals::DesktopDevice))
        goto ErrorOut;

    Globals::DeviceList = new GpDeviceList();
    if(Globals::DeviceList == NULL)
        goto ErrorOut;

    // Create the virtual driver representing all GDI+ Eng drawing:

    Globals::EngineDriver = new DpDriver(device);
    if (!CheckValid(Globals::EngineDriver))
        goto ErrorOut;

    // Create the driver for use with the desktop device
    // NOTE: for now we always use the multimon driver.  In the future
    //       we will be able to dynamically redirect desktop drawing
    //       through different drivers as the desktop changes.  This will
    //       require that we have a mechanism to safely modify various
    //       GDI+ objects in response to the mode change.

    // Only use multi-mon driver on multi-mon capable systems

    if(Globals::GetMonitorInfoFunction != NULL &&
       Globals::EnumDisplayMonitorsFunction != NULL)
    {
        Globals::DesktopDriver = new DriverMulti(device);
        if (!CheckValid(Globals::DesktopDriver))
            goto ErrorOut;
    }
    else
    {
        Globals::DesktopDriver = new DriverGdi(device);
        if (!CheckValid(Globals::DesktopDriver))
            goto ErrorOut;
    }

    Globals::GdiDriver = new DriverGdi(device);
    if (!CheckValid(Globals::GdiDriver))
        goto ErrorOut;

    Globals::D3DDriver = new DriverD3D(device);
    if (!CheckValid(Globals::D3DDriver))
        goto ErrorOut;

    Globals::InfoDriver = new DriverInfo(device);
    if (!CheckValid(Globals::InfoDriver))
        goto ErrorOut;

    Globals::MetaDriver = new DriverMeta(device);
    if (!CheckValid(Globals::MetaDriver))
        goto ErrorOut;

    Globals::DesktopSurface = new DpBitmap();
    if (!CheckValid(Globals::DesktopSurface))
        goto ErrorOut;

    // Get the multimon meta-desktop resolution.  SM_CX/CYVIRTUALSCREEN
    // doesn't work on Win95 or NT4, though...

    width = GetSystemMetrics(SM_CXVIRTUALSCREEN);
    height = GetSystemMetrics(SM_CYVIRTUALSCREEN);

    if ((width == 0) || (height == 0))
    {
        width = GetSystemMetrics(SM_CXSCREEN);
        height = GetSystemMetrics(SM_CYSCREEN);
    }

    Globals::DesktopSurface->InitializeForGdiScreen(
        Globals::DesktopDevice,
        width,
        height);

    // Give the driver an opportunity to adjust the surface.
    // If we're on multimon, we need to fix up the
    // pixel format for the DesktopSurface.

    Globals::DesktopDriver->UpdateSurfacePixelFormat(
        Globals::DesktopSurface
    );

    // GDI+ v1 DCR 336742
    // We are disabling image codecs for v1, so ignore the 
    // input->SuppressExternalCodecs flag and hardwire to TRUE.
    // Jbronsk
    if (!InitImagingLibrary(TRUE /* suppressExternalCodecs */))
    {
        // If we couldn't initialize the ImagingLibrary
        goto ErrorOut;
    }

    // Initialize the system colors in fastest search order
    Globals::SystemColors [0] = RGB(0x00,0x00,0x00);
    Globals::SystemColors [1] = RGB(0xFF,0xFF,0xFF);
    Globals::SystemColors [2] = RGB(0xC0,0xC0,0xC0);
    Globals::SystemColors [3] = RGB(0x80,0x80,0x80);
    Globals::SystemColors [4] = RGB(0x00,0x00,0xFF);
    Globals::SystemColors [5] = RGB(0x00,0x00,0x80);
    Globals::SystemColors [6] = RGB(0x00,0xFF,0x00);
    Globals::SystemColors [7] = RGB(0x00,0x80,0x00);
    Globals::SystemColors [8] = RGB(0xFF,0x00,0x00);
    Globals::SystemColors [9] = RGB(0x80,0x00,0x00);
    Globals::SystemColors[10] = RGB(0xFF,0xFF,0x00);
    Globals::SystemColors[11] = RGB(0x80,0x80,0x00);
    Globals::SystemColors[12] = RGB(0x00,0xFF,0xFF);
    Globals::SystemColors[13] = RGB(0x00,0x80,0x80);
    Globals::SystemColors[14] = RGB(0xFF,0x00,0xFF);
    Globals::SystemColors[15] = RGB(0x80,0x00,0x80);
    SysColorNotify();   // update last 4 colors


    if (Globals::IsNt)
    {
        HMODULE module = GetModuleHandle(TEXT("gdi32.dll"));

        Globals::ExtTextOutFunction = (EXTTEXTOUTFUNCTION)
            GetProcAddress(module, "ExtTextOutW");

        Globals::GdiIsMetaPrintDCFunction = (GDIISMETAPRINTDCFUNCTION)
            GetProcAddress(module, "GdiIsMetaPrintDC");
    }
    else
    {
        HMODULE module = GetModuleHandleA("gdi32.dll");

        Globals::ExtTextOutFunction = (EXTTEXTOUTFUNCTION)
            GetProcAddress(module, "ExtTextOutA");

        Globals::GdiIsMetaPrintDCFunction = GdiIsMetaPrintDCWin9x;
    }

    Globals::LanguageID = GetLanguageID();
    if (!InitSystemFontsDirs())
       goto ErrorOut;

    // globals are initialized to NULL
    ASSERT(Globals::NationalDigitCache == NULL);

    Globals::UserDigitSubstituteInvalid = TRUE;
    Globals::CurrentSystemRenderingHintInvalid  = TRUE;
    Globals::CurrentSystemRenderingHint = TextRenderingHintSingleBitPerPixelGridFit;

    VERBOSE(("Loading fonts..."));

    Globals::FontCollection = GpInstalledFontCollection::GetGpInstalledFontCollection();
    if (!Globals::FontCollection || !(Globals::FontCollection->GetFontTable()))
        goto ErrorOut;

    // font caching, least recently used list
    Globals::FontCacheLastRecentlyUsedList = new GpCacheFaceRealizationList;
    if (!Globals::FontCacheLastRecentlyUsedList)
        goto ErrorOut;

    // Initialize for font file cache criticalization

    __try
    {
        InitializeCriticalSection(&Globals::TextCriticalSection);
        Globals::TextCriticalSectionInitialized = TRUE;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // We couldn't allocate the criticalSection
        // Return an error
        goto ErrorOut;
    }

    // If allocation failures are on, start default failure rate

    GpDoneInitializeAllocFailureMode();

    // Now that everything's initialized, it's safe to start the background
    // thread. (The danger: It may immediately receive a message, and the
    // message-handling code assumes that we've been initialized already.)

    if (!input->SuppressBackgroundThread)
    {
        if (!BackgroundThreadStartup())
        {
            goto ErrorOut;
        }
    }

#if GP_ICECAP>1
    CommentMarkProfile(1, "InternalGdiplusStartup completed");
#endif
    VERBOSE(("InternalGdiplusStartup completed successfully"));
    return Ok;

ErrorOut:

    WARNING(("InternalGdiplusStartup: Initialization failed"));

    // Note that the following should free anything we've stuck in
    // the 'globals' class:

    InternalGdiplusShutdown();

    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Initialize font directory goop.
*
* Return Value:
*
*   FALSE if failure (such as low memory).
*
* History:
*
*   6/10/1999 bodind
*       Created it.
*
\**************************************************************************/

const CHAR SystemSubdirA[] = "\\system";
const CHAR FontsSubdirA[] = "\\fonts";

const WCHAR SystemSubdirW[] = L"\\system";
const WCHAR FontsSubdirW[] = L"\\fonts";

BOOL InitSystemFontsDirs(void)
{
    BOOL   result = TRUE;

    // Check if already initialized
    if (Globals::SystemDirW == NULL)
    {
        // Compute the windows and font directory pathname lengths (including NULL).
        // Note that cwchWinPath may have a trailing '\', in which case we will
        // have computed the path length to be one greater than it should be.
        WCHAR windowsStr[MAX_PATH];
        UINT  windowsStrLength;

        if (Globals::IsNt)
        {
        // GetWindowsDirectoryW is not working with TS
        // Also GetSystemWidowsDirectoryW is not supported in NT4
        // So we only can use GetSystemDirectory and truncated system32
            windowsStrLength = GetSystemDirectoryW(windowsStr, MAX_PATH);

            if(windowsStrLength > 0)
            {
                for (INT i = windowsStrLength - 1; i >= 0; i--)
                {
                    if (windowsStr[i] == L'\\')
                    {
                        windowsStrLength = (UINT)i;
                        break;
                    }
                }
            }

        }
        else
        {
            CHAR windowsStrA[MAX_PATH];
            windowsStrLength = GetWindowsDirectoryA(windowsStrA, MAX_PATH);
            UnicodeStrFromAnsi strW(windowsStrA);
            UnicodeStringCopy(windowsStr, strW);
        }

        // Handle zero termination
        if ((windowsStrLength > 0) &&
            (windowsStr[windowsStrLength - 1] == L'\\'))
        {
            windowsStrLength -= 1;
        }
        windowsStr[windowsStrLength] = L'\0'; // make sure to zero terminate

        UINT systemSubstrLength = sizeof(SystemSubdirA);
        UINT fontsSubstrLength  = sizeof(FontsSubdirA);

        UINT systemTotalLength = windowsStrLength + systemSubstrLength;
        UINT fontsTotalLength  = windowsStrLength + fontsSubstrLength;

        Globals::SystemDirW = new WCHAR[systemTotalLength];
        Globals::SystemDirA = new CHAR[systemTotalLength];
        Globals::FontsDirW = new WCHAR[fontsTotalLength];
        Globals::FontsDirA = new CHAR[fontsTotalLength];

        if (Globals::SystemDirW && Globals::SystemDirA && Globals::FontsDirW && Globals::FontsDirA)
        {
            UnicodeStringCopy(Globals::SystemDirW, windowsStr);
            UnicodeStringCopy(Globals::FontsDirW, windowsStr);

            // Append the system and font subdirectories
            if (Globals::IsNt)
            {
                UnicodeStringConcat(Globals::SystemDirW, SystemSubdirW);
                UnicodeStringConcat(Globals::FontsDirW, FontsSubdirW);
            }
            else
            {
                //  Juggle Unicode and Ansi string concatenations
                AnsiStrFromUnicode systemStrA(Globals::SystemDirW);
                AnsiStrFromUnicode fontsStrA(Globals::FontsDirW);

                //  String cat ascii onto wide char
                for (UINT c = 0; c < systemSubstrLength && c < MAX_PATH; c++)
                    systemStrA[windowsStrLength + c] = SystemSubdirA[c];

                //  String cat ascii onto wide char
                for (c = 0; c < fontsSubstrLength && c < MAX_PATH; c++)
                    fontsStrA[windowsStrLength + c] = FontsSubdirA[c];

                UnicodeStrFromAnsi systemStrW(systemStrA);
                UnicodeStrFromAnsi fontsStrW(fontsStrA);

                UnicodeStringCopy(Globals::SystemDirW, systemStrW);
                UnicodeStringCopy(Globals::FontsDirW, fontsStrW);

                memcpy(Globals::SystemDirA, systemStrA, strlen(systemStrA)+1);
                memcpy(Globals::FontsDirA, fontsStrA, strlen(fontsStrA)+1);

            }
#if INITIALIZE_DBG
            TERSE(("System path is %ws (%d chars).", Globals::SystemDirW, systemTotalLength));
            TERSE(("Fonts  path is %ws (%d chars).", Globals::FontsDirW, fontsTotalLength));
#endif
        }
        else
        {
            result = FALSE;
        }
    }
    return result;
}
/**************************************************************************\
*
* Function Description:
*
*   Initializes direct draw and direct 3D related globals.
*
* Arguments:
*
*       NONE
*
* Return Value:
*
*   TRUE for success otherwise FALSE.
*
* History:
*
*   10/06/1999 bhouse
*       Created it.
*
\**************************************************************************/

BOOL InitializeDirectDrawGlobals(void)
{
    if(Globals::DirectDrawInitialized)
            return TRUE;

    if(Globals::DirectDrawInitAttempted)
            return FALSE;

    // This critical section is used to protect LoadLibrary calls.
    
    LoadLibraryCriticalSection llcs;

    Globals::DirectDrawInitAttempted = TRUE;

    Globals::DdrawHandle = LoadLibraryA("ddraw.dll");

    if(Globals::DdrawHandle == NULL)
    {
        WARNING(("Unable to load direct draw library"));
        return(FALSE);
    }

    Globals::GetDdrawSurfaceFromDcFunction
        = (GETDDRAWSURFACEFROMDCFUNCTION)
                GetProcAddress(Globals::DdrawHandle,
                               "GetSurfaceFromDC");

    if(Globals::GetDdrawSurfaceFromDcFunction == NULL)
    {
        WARNING(("Unable to get GetSurfaceFromDC procedure address"));
        return(FALSE);
    }

    Globals::DirectDrawCreateExFunction
            = (DIRECTDRAWCREATEEXFUNCTION)
                            GetProcAddress(Globals::DdrawHandle,
                                                       "DirectDrawCreateEx");

    if(Globals::DirectDrawCreateExFunction == NULL)
    {
        WARNING(("Unable to get DirectDrawCreateEx procedure address"));
        return(FALSE);
    }


    Globals::DirectDrawEnumerateExFunction
            = (DIRECTDRAWENUMERATEEXFUNCTION)
                            GetProcAddress(Globals::DdrawHandle,
                                          "DirectDrawEnumerateExA");

    if(Globals::DirectDrawEnumerateExFunction == NULL)
    {
        WARNING(("Unable to get DirectDrawEnumerateEx procedure address"));
        return(FALSE);
    }


    HRESULT hr;

    hr = Globals::DirectDrawCreateExFunction(NULL,
                                                &Globals::DirectDraw,
                                                IID_IDirectDraw7,
                                                NULL);

    if(hr != DD_OK)
    {
        WARNING(("Unable to create Direct Draw interface"));
        return(FALSE);
    }

    hr = Globals::DirectDraw->SetCooperativeLevel(NULL, DDSCL_NORMAL);

    if(hr != DD_OK)
    {
        WARNING(("Unable to set DDSCL_NORMAL cooperative level"));
        return(FALSE);
    }

    hr = Globals::DirectDraw->QueryInterface(IID_IDirect3D7,
                                              (void **) &Globals::Direct3D);

    if(hr != DD_OK)
    {
        WARNING(("Unable to get D3D interface"));
        return(FALSE);
    }

    Globals::DirectDrawInitialized = TRUE;

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\intmap.hpp ===
#ifndef _INTMAP_HPP
#define _INTMAP_HPP

/////   IntMap - sparse array indexed by int value
//
//      Used to store tables indexed by Unicode codepoint or
//      by glyph index.
//
//      !!! This implementation maps values in the range [0..1114112]
//          which is the subset of ISO 10664 addressable (using surrogates)
//          in Unicode UTF16.
//
//      (1114112 is 17*65536)


template <class C> class IntMap {
public:

    IntMap() : Status(Ok)
    {
        if (UsageCount == 0)
        {
            // Note that this is not thread safe.
            // Currently all font/text APIs are protected by a single critical
            // section.

            if (!EmptyPage)
                EmptyPage = new C[256];

            if (!EmptyPage)
            {
                Status = OutOfMemory;
                return;
            }

            for (INT i=0; i<256; i++)
            {
                EmptyPage[i] = 0;
            }

            if (!EmptyPlane)
                EmptyPlane = new C*[256];

            if (!EmptyPlane)
            {
                Status = OutOfMemory;
                return;
            }

            for (INT i=0; i<256; i++)
            {
                EmptyPlane[i] = EmptyPage;
            }
        }
        ++UsageCount;

        for (INT i=0; i<17; i++)
        {
            map[i] = EmptyPlane;
        }

        #if DBG
        ASSERT(map[0][0x05][0x31] == 0);
        for (INT i=0; i<256; i++)
        {
            ASSERT(EmptyPlane[i] == EmptyPage);
            ASSERT(EmptyPage[i] == 0);
        }
        #endif
    }

    ~IntMap()
    {
        if (Status != Ok)
            return;

        for (INT i=0; i<17; i++)
        {
            if (map[i] != EmptyPlane)
            {
                for (INT j=0; j<256; j++)
                {
                    if (map[i][j] != EmptyPage)
                    {
                        delete map[i][j];
                    }
                }
                delete map[i];
            }
        }

        --UsageCount;
        if (UsageCount == 0)
        {
            // Release memory used by static empty pages for IntMap<C>
            delete [] EmptyPlane, EmptyPlane = 0;
            delete [] EmptyPage, EmptyPage = 0;
        }
    }


    // Insert value for single codepoint

    GpStatus Insert(INT i, const C &v)
    {
        ASSERT(Status == Ok);
        ASSERT(i < 17*65536);

        ASSERT(map[i>>16] != NULL);

        if (map[i>>16] == EmptyPlane)
        {
            map[i>>16] = new C*[256];

            if (!map[i>>16])
            {
                map[i>>16] = EmptyPlane;
                return OutOfMemory;
            }

            for (INT j=0; j<256; j++)
            {
                map [i>>16] [j] = EmptyPage;
            }
        }

        ASSERT(map [i>>16] [i>>8 & 0xff] != NULL);

        if (map [i>>16] [i>>8 & 0xff] == EmptyPage)
        {
            if (!(map [i>>16] [i>>8 & 0xff] = new C[256]))
            {
                map [i>>16] [i>>8 & 0xff] = EmptyPage;
                return OutOfMemory;
            }

            memcpy(map [i>>16] [i>>8 & 0xff], EmptyPage, sizeof(C) * 256);
        }

        map [i>>16] [i>>8 & 0xff] [i & 0xff] = v;
        return Ok;
    }

    ////    Lookup single codepoint

    C& Lookup(INT i) const
    {
        ASSERT(Status == Ok);
        ASSERT(i < 17*65536);
        return map [i>>16] [i>>8 & 0xff] [i & 0xff];
    }


    ////    Lookup codepoint expressed as surrogate pair

    C& Lookup(UINT16 h, UINT16 l) const
    {
        ASSERT(Status == Ok);
        ASSERT((h & 0xFC00) == 0xD800);
        ASSERT((l & 0xFC00) == 0xDC00);

        INT i = 0x10000 + (((h & 0x3ff) << 10) | (l & 0x3ff));

        ASSERT(i < 17*65536);
        return map [i>>16] [i>>8 & 0xff] [i & 0xff];
    }


    ////    Lookup array of 16 bit unsigned values

    void Lookup(
        const UINT16 *source,
        INT           sourceCount,
        C            *values
    ) const
    {
        ASSERT(Status == Ok);
        for (INT i=0; i<sourceCount; i++)
        {
            values[i] = Lookup(source[i]);
        }
    }


    ////    Lookup 16 bit Unicode character string with surrogate interpretation
    //
    //      If the oneToOne parameter is set, surrogate pairs are translated to
    //      the correct glyph, followed by 0xffff so as to generate the same
    //      number of glyphs as codepoints.

    void LookupUnicode(
        const WCHAR *characters,
        INT          characterCount,
        C           *values,
        UINT32      *valueCount,
        BOOL         oneToOne            // Glyph count == character count
    ) const
    {
        ASSERT(Status == Ok);
        ASSERT(characterCount >= 0);

        INT ci = 0;  // Character array index
        INT vi = 0;  // Value array index

        while (    ci < characterCount)
        {
            // Efficient loop through non-surrogates

            while (    ci < characterCount
                   &&  (characters[ci] & 0xF800) != 0xD800)
            {
                values[vi++] = Lookup(characters[ci++]);
            }

            // Loop through surrogates

            while (    ci < characterCount
                   &&  (characters[ci] & 0xF800) == 0xD800)
            {

                // Fast loop through valid surrogate pairs

                while (    ci+1 < characterCount
                       &&  (characters[ci]   & 0xFC00) == 0xD800
                       &&  (characters[ci+1] & 0xFC00) == 0xDC00)
                {
                    values[vi++] = Lookup(characters[ci], characters[ci+1]);
                    if (oneToOne)
                    {
                        values[vi++] = 0xffff;
                    }
                    ci += 2;
                }

                // Either
                // 1. We came to the end of the run of surrogate codepoints
                // 2. There's one or more high surrogates with no matching low surrogates
                // 3. There's one or more low surrogates

                // Handle any misplaced high surrogates as normal codepoints

                while (    ci < characterCount
                       &&  (characters[ci] & 0xFC00) == 0xD800
                       &&  (    ci+1 >= characterCount
                            ||  (characters[ci+1] & 0xFC00) != 0xDC00))
                {
                    values[vi++] = Lookup(characters[ci++]);
                }


                // Handle any misplaced low surrogates as normal codepoints

                while (    ci < characterCount
                       &&  (characters[ci] & 0xFC00) == 0xDC00)
                {
                    values[vi++] = Lookup(characters[ci++]);
                }
            }
        }

        if (valueCount)
        {
            *valueCount = vi;
        }
        else
        {
            ASSERT(vi == characterCount);
        }
    }

    GpStatus GetStatus() const
    {
        return Status;
    }

private:
    GpStatus    Status;
    C            **map[17];
    static C     **EmptyPlane;
    static C      *EmptyPage;
    static LONG   UsageCount;
};


template<class C> LONG IntMap<C>::UsageCount = 0;  // Tracks static memory usage
template<class C> C **IntMap<C>::EmptyPlane;
template<class C> C *IntMap<C>::EmptyPage;
#endif _INTMAP_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\metaemf.cpp ===
/**************************************************************************\
*
* Copyright (c) 2000  Microsoft Corporation
*
* Module Name:
*
*   MetaEmf.cpp
*
* Abstract:
*
*   Methods for playing and recoloring an EMF.
*
* Created:
*
*   1/6/2000 DCurtis
*
\**************************************************************************/

#include "Precomp.hpp"
#include "MetaWmf.hpp"

//----------------------------------------------------------------------------
//  File format signatures for Office Art data.
//------------------------------------------------------------------- JohnBo
#define msoszOfficeSignature "MSOFFICE"
#define msocbOfficeSignature 8
#define msoszOfficeAuthentication "9.0"
#define msocbOfficeAuthentication 3
#define msoszOfficeIdent msoszOfficeSignature msoszOfficeAuthentication
#define msocbOfficeIdent (msocbOfficeSignature+msocbOfficeAuthentication)

#define msoszOAPNGChunk "msOA"
#define msocbOAPNGChunk 4
#define msoszOADataHeader msoszOAPNGChunk msoszOfficeIdent
#define msocbOADataHeader (msocbOAPNGChunk+msocbOfficeIdent)

#define msoszOAKind "OA"
#define msocbOAKind 2

/* This defines an OZ chunk, like OA but Zlib compressed. */
#define msoszOZPNGChunk "msOZ"
#define msocbOZPNGChunk 4
#define msoszOZDataHeader msoszOZPNGChunk msoszOfficeIdent
#define msocbOZDataHeader (msocbOZPNGChunk+msocbOfficeIdent)

// These are needed for IA64 compatibility with X86
// Since we are reading this record from a stream, on IA64
// The EXTLOGPEN structure has a ULONG_PTR member which is not the same size
// on IA64 and X86. Since all output to files will keep the X86 format we need
// to make sure that we can read this format in IA64, so we make it compatible
// by changing the ULONG_PTR to a ULONG (32bit). The packing of the structure
// will them be the same and the members will be at the same offset

typedef struct tagEXTLOGPEN32 {
    DWORD       elpPenStyle;
    DWORD       elpWidth;
    UINT        elpBrushStyle;
    COLORREF    elpColor;
    ULONG       elpHatch;
    DWORD       elpNumEntries;
    DWORD       elpStyleEntry[1];
} EXTLOGPEN32, *PEXTLOGPEN32;

typedef struct tagEMREXTCREATEPEN32
{
    EMR     emr;
    DWORD   ihPen;              // Pen handle index
    DWORD   offBmi;             // Offset to the BITMAPINFO structure if any
    DWORD   cbBmi;              // Size of the BITMAPINFO structure if any
                                // The bitmap info is followed by the bitmap
                                // bits to form a packed DIB.
    DWORD   offBits;            // Offset to the brush bitmap bits if any
    DWORD   cbBits;             // Size of the brush bitmap bits if any
    EXTLOGPEN32 elp;              // The extended pen with the style array.
} EMREXTCREATEPEN32, *PEMREXTCREATEPEN32;

typedef struct tagEMRRCLBOUNDS
{
    EMR     emr;
    RECTL   rclBounds;
} EMRRCLBOUNDS, *PEMRRCLBOUNDS;

typedef struct EMROFFICECOMMENT
{
    EMR     emr;
    DWORD   cbData;             // Size of following fields and data
    DWORD   ident;              // GDICOMMENT_IDENTIFIER
    DWORD   iComment;           // Comment type e.g. GDICOMMENT_WINDOWS_METAFILE
} EMROFFICECOMMENT, *PEMROFFICECOMMENT;

RecolorStockObject RecolorStockObjectList[NUM_STOCK_RECOLOR_OBJS] =
{
    { WHITE_BRUSH,    (COLORREF)RGB(0xFF, 0xFF, 0xFF),   TRUE  },
    { LTGRAY_BRUSH,   (COLORREF)RGB(0xC0, 0xC0, 0xC0),   TRUE  },
    { GRAY_BRUSH,     (COLORREF)RGB(0x80, 0x80, 0x80),   TRUE  },
    { DKGRAY_BRUSH,   (COLORREF)RGB(0x40, 0x40 ,0x40),   TRUE  },
    { BLACK_BRUSH,    (COLORREF)RGB(0, 0, 0),            TRUE  },
    { WHITE_PEN,      (COLORREF)RGB(0xFF, 0xFF, 0xFF),   FALSE },
    { BLACK_PEN,      (COLORREF)RGB(0, 0 ,0),            FALSE }
};

inline static RGBQUAD *
GetDibColorTable(
    BITMAPINFOHEADER *      dibInfo
    )
{
    return ( RGBQUAD *)(((BYTE *)dibInfo) + dibInfo->biSize);
}

BOOL
EmfEnumState::CreateCopyOfCurrentRecord()
{
    if (ModifiedRecordSize > 0)
    {
        // We already made a modified record.  Don't do it again.
        ASSERT(ModifiedRecord != NULL);
        return TRUE;
    }

    INT     size = this->GetCurrentRecordSize();

    if (CreateRecordToModify(size))
    {
        ENHMETARECORD * modifiedRecord = (ENHMETARECORD *)ModifiedRecord;

        modifiedRecord->iType = RecordType;
        modifiedRecord->nSize = size;

        if (RecordDataSize > 0)
        {
            GpMemcpy(modifiedRecord->dParm, RecordData, RecordDataSize);
        }
        return TRUE;
    }

    WARNING(("Failed to create copy of current record"));
    return FALSE;
}

BOOL
EmfEnumState::CreateAndPlayOutputDIBRecord(
    HDC                           hdc,
    const RECTL *                 bounds,
    INT                           dstX,
    INT                           dstY,
    INT                           dstWidth,
    INT                           dstHeight,
    INT                           srcX,
    INT                           srcY,
    INT                           srcWidth,
    INT                           srcHeight,
    UNALIGNED BITMAPINFOHEADER *  dibInfo,
    BYTE *                        bits,   // if NULL, this is a packed DIB
    UINT                          usage,
    DWORD                         rop
    )
{
    ASSERT(!Globals::IsNt);

    INT  bitsSize = GetDibBitsSize(dibInfo);
    UINT sizePalEntries;

    if (GetDibNumPalEntries(FALSE,
                            dibInfo->biSize,
                            dibInfo->biBitCount,
                            dibInfo->biCompression,
                            dibInfo->biClrUsed,
                            &sizePalEntries))
    {
        // We need to get the palette size that corresponds to the type
        // If we have a DIB_PAL_COLORS then each entry is 16bits
        sizePalEntries *= ((usage == DIB_PAL_COLORS)?2:sizeof(RGBQUAD));
    }
    else
    {
        sizePalEntries = 0 ;
    }

    // We need at least a BITMAPINFO structure in there, but if there is a
    // palette, calculate the full size of the structure including the
    // palette

    INT bitmapHeaderSize = sizeof(BITMAPINFOHEADER) + sizePalEntries;
    INT size = sizeof(EMRSTRETCHDIBITS) + bitmapHeaderSize + bitsSize ;

    // We cannot use the CreateRecordToModify because the record has already
    // been modified
    size = (size + 3) & ~3;
    EMRSTRETCHDIBITS* emrStretchDIBits = (EMRSTRETCHDIBITS*) GpMalloc(size);
    if (emrStretchDIBits != NULL)
    {
        emrStretchDIBits->emr.iType = EmfRecordTypeStretchDIBits;
        emrStretchDIBits->emr.nSize = size;
        emrStretchDIBits->rclBounds = *bounds;
        emrStretchDIBits->xDest = dstX;
        emrStretchDIBits->yDest = dstY;
        emrStretchDIBits->xSrc = srcX;
        emrStretchDIBits->ySrc = srcY;
        emrStretchDIBits->cxSrc = srcWidth;
        emrStretchDIBits->cySrc = srcHeight;
        emrStretchDIBits->offBmiSrc = sizeof(EMRSTRETCHDIBITS);
        emrStretchDIBits->cbBmiSrc = bitmapHeaderSize;
        emrStretchDIBits->offBitsSrc = emrStretchDIBits->offBmiSrc + emrStretchDIBits->cbBmiSrc;
        emrStretchDIBits->cbBitsSrc = bitsSize;
        emrStretchDIBits->iUsageSrc = usage;
        emrStretchDIBits->dwRop = rop;
        emrStretchDIBits->cxDest = dstWidth;
        emrStretchDIBits->cyDest = dstHeight;
        GpMemcpy((BYTE*)emrStretchDIBits + emrStretchDIBits->offBmiSrc, dibInfo, emrStretchDIBits->cbBmiSrc);
        GpMemcpy((BYTE*)emrStretchDIBits + emrStretchDIBits->offBitsSrc, bits, emrStretchDIBits->cbBitsSrc);

        ::PlayEnhMetaFileRecord(hdc, HandleTable, (ENHMETARECORD *)emrStretchDIBits, NumObjects);
        GpFree(emrStretchDIBits);
        return TRUE;
    }
    return FALSE;
}

BITMAPINFOHEADER *
EmfEnumState::CreateModifiedDib(
    BITMAPINFOHEADER *  srcDibInfo,
    BYTE *              srcBits,
    UINT &              usage,
    DWORD               rop
    )
{
    BITMAPINFOHEADER *  dstDibInfo = NULL;
    UINT                numPalEntries;
    UINT                dibBitsSize;

    if ((srcDibInfo->biSize >= sizeof(BITMAPINFOHEADER)) &&
        GetDibNumPalEntries(FALSE,
                            srcDibInfo->biSize,
                            srcDibInfo->biBitCount,
                            srcDibInfo->biCompression,
                            srcDibInfo->biClrUsed,
                            &numPalEntries) &&
        ((dibBitsSize = GetDibBitsSize(srcDibInfo)) > 0))
    {
        if (numPalEntries == 2 && rop != SRCCOPY)
        {
            DWORD  *rgb = (DWORD*) GetDibColorTable(srcDibInfo);
            if (rgb[0] == 0x00000000 && rgb[1] == 0x00FFFFFF)
            {
                return dstDibInfo;
            }
        }

        // We need to pass in to ModifyDib the old Usage value because we haven't modified
        // the bitmap yet. Once we do then we will return the new usage of the palette.
        UINT oldUsage = usage;
        INT dstDibSize = GetModifiedDibSize(srcDibInfo, numPalEntries, dibBitsSize, usage);

        if ((dstDibSize > 0) && CreateRecordToModify(dstDibSize))
        {
            dstDibInfo = (BITMAPINFOHEADER *)ModifiedRecord;
            ModifyDib(oldUsage, srcDibInfo, srcBits, dstDibInfo,
                      numPalEntries, dibBitsSize, ColorAdjustTypeBitmap);
        }
    }
    return dstDibInfo;
}

VOID
EmfEnumState::BitBlt(
    )
{
    const EMRBITBLT *  bitBltRecord = (const EMRBITBLT *)GetPartialRecord();

    DWORD rop = bitBltRecord->dwRop;

    // If No-Op ROP, do nothing; just return
    if ((rop & 0xFFFF0000) == (GDIP_NOOP_ROP3 & 0xFFFF0000))
    {
        return;
    }

    // On NT4, PATCOPYs fail to draw correctly if there is a skew/rotate
    // in the matrix.  So use a rectangle call instead.
    if ((rop == PATCOPY) && Globals::IsNt && (Globals::OsVer.dwMajorVersion <= 4))
    {
        XFORM   xform;
        if (::GetWorldTransform(Hdc, &xform) &&
            ((xform.eM12 != 0.0f) || (xform.eM21 != 0.0f)))
        {
            HPEN    hPenOld = (HPEN)::SelectObject(Hdc, ::GetStockObject(NULL_PEN));
            DWORD   dcRop = ::GetROP2(Hdc);

            if (dcRop != R2_COPYPEN)
            {
                ::SetROP2(Hdc, R2_COPYPEN);
            }
            ::Rectangle(Hdc, bitBltRecord->xDest, bitBltRecord->yDest,
                        bitBltRecord->xDest + bitBltRecord->cxDest,
                        bitBltRecord->yDest + bitBltRecord->cyDest);
            ::SelectObject(Hdc, hPenOld);
            if (dcRop != R2_COPYPEN)
            {
                ::SetROP2(Hdc, dcRop);
            }
            return;
        }
    }

    if (rop != SRCCOPY &&
        rop != NOTSRCCOPY &&
        rop != PATCOPY &&
        rop != BLACKNESS &&
        rop != WHITENESS)
    {
        RopUsed = TRUE;
    }

    if ((bitBltRecord->cbBitsSrc > 0) &&
        (bitBltRecord->cbBmiSrc > 0)  &&
        IsSourceInRop3(rop))
    {
        // Should we modify the dib if it is monochrome?
        // What if there is a non-identity transform for the src DC?

        UINT                usage      = bitBltRecord->iUsageSrc;
        BITMAPINFOHEADER *  srcDibInfo = (BITMAPINFOHEADER *)(((BYTE *)bitBltRecord) + bitBltRecord->offBmiSrc);
        BYTE *              srcBits    = ((BYTE *)bitBltRecord) + bitBltRecord->offBitsSrc;
        BITMAPINFOHEADER *  dstDibInfo = CreateModifiedDib(srcDibInfo, srcBits, usage, rop);

        if (dstDibInfo != NULL)
        {
            srcDibInfo = dstDibInfo;
            srcBits = NULL;
        }

        if (SrcCopyOnly && rop != SRCCOPY)
        {
            rop = SRCCOPY;
        }

        OutputDIB(Hdc,
                  &bitBltRecord->rclBounds,
                  bitBltRecord->xDest,  bitBltRecord->yDest,
                  bitBltRecord->cxDest, bitBltRecord->cyDest,
                  bitBltRecord->xSrc,   bitBltRecord->ySrc,
                  bitBltRecord->cxDest, bitBltRecord->cyDest,
                  srcDibInfo, srcBits, usage, rop, FALSE);
    }
    else
    {
        if (SrcCopyOnly && rop != PATCOPY && !IsSourceInRop3(rop) && CreateCopyOfCurrentRecord())
        {
            EMRBITBLT *  newBitBltRecord = (EMRBITBLT *) ModifiedEmfRecord;
            newBitBltRecord->dwRop = PATCOPY;
        }
        ResetRecordBounds();
        this->PlayRecord();
    }
}

VOID
EmfEnumState::StretchBlt(
    )
{
    const EMRSTRETCHBLT *  stretchBltRecord = (const EMRSTRETCHBLT *)GetPartialRecord();

    DWORD rop = stretchBltRecord->dwRop;

    // If No-Op ROP, do nothing; just return
    if ((rop & 0xFFFF0000) == (GDIP_NOOP_ROP3 & 0xFFFF0000))
    {
        return;
    }

    if (rop != SRCCOPY &&
        rop != NOTSRCCOPY &&
        rop != PATCOPY &&
        rop != BLACKNESS &&
        rop != WHITENESS)
    {
        RopUsed = TRUE;
    }

    if ((stretchBltRecord->cbBitsSrc > 0) &&
        (stretchBltRecord->cbBmiSrc > 0)  &&
        IsSourceInRop3(rop))
    {
        // Should we modify the dib if it is monochrome?
        // What if there is a non-identity transform for the src DC?

        UINT                usage      = stretchBltRecord->iUsageSrc;
        BITMAPINFOHEADER *  srcDibInfo = (BITMAPINFOHEADER *)(((BYTE *)stretchBltRecord) + stretchBltRecord->offBmiSrc);
        BYTE *              srcBits    = ((BYTE *)stretchBltRecord) + stretchBltRecord->offBitsSrc;
        BITMAPINFOHEADER *  dstDibInfo = CreateModifiedDib(srcDibInfo, srcBits, usage, rop);

        if (SrcCopyOnly && rop != SRCCOPY)
        {
            rop = SRCCOPY;
        }

        ASSERT(sizeof(XFORM) == sizeof(REAL)*6);

        GpMatrix xForm((REAL*) &(stretchBltRecord->xformSrc));

        if (dstDibInfo != NULL)
        {
            srcDibInfo = dstDibInfo;
            srcBits = NULL;
        }

        GpRectF  srcRect((REAL)stretchBltRecord->xSrc,
                         (REAL)stretchBltRecord->ySrc,
                         (REAL)stretchBltRecord->cxSrc,
                         (REAL)stretchBltRecord->cySrc);

        if (!xForm.IsIdentity())
        {
            // We cannot use TransformRect, because the output rect will always
            // have a positive Width and Height which we don't want
            GpPointF points[2];
            points[0] = GpPointF(srcRect.X, srcRect.Y);
            points[1] = GpPointF(srcRect.GetRight(), srcRect.GetBottom());
            xForm.Transform(points, 2);
            srcRect.X = points[0].X;
            srcRect.Y = points[0].Y;
            srcRect.Width = points[1].X - points[0].X;
            srcRect.Height = points[1].Y - points[0].Y;
        }

        // StretchBlt takes as parameters the top left corner of the dest
        // whereas StretchDIBits takes the offset in the source image.
        // For bottom up dibs those are not the same and we need to offset
        // the srcrect's Y coodinate by the difference
        if (srcDibInfo->biHeight > 0 &&
            srcRect.Height < srcDibInfo->biHeight)
        {
            srcRect.Y = srcDibInfo->biHeight - srcRect.Height - srcRect.Y;
        }

        OutputDIB(Hdc,
                  &stretchBltRecord->rclBounds,
                  stretchBltRecord->xDest,  stretchBltRecord->yDest,
                  stretchBltRecord->cxDest, stretchBltRecord->cyDest,
                  GpRound(srcRect.X),   GpRound(srcRect.Y),
                  GpRound(srcRect.Width), GpRound(srcRect.Height),
                  srcDibInfo, srcBits, usage, rop, FALSE);
    }
    else
    {
        if (SrcCopyOnly && rop != PATCOPY && !IsSourceInRop3(rop) && CreateCopyOfCurrentRecord())
        {
            EMRSTRETCHBLT *  stretchBltRecord = (EMRSTRETCHBLT *)ModifiedEmfRecord;
            stretchBltRecord->dwRop = PATCOPY;
        }
        ResetRecordBounds();
        this->PlayRecord();
    }
}

VOID
EmfEnumState::StretchDIBits(
    )
{
    const EMRSTRETCHDIBITS *  stretchDIBitsRecord = (const EMRSTRETCHDIBITS *)GetPartialRecord();

    DWORD rop = stretchDIBitsRecord->dwRop;

    // If No-Op ROP, do nothing; just return
    if ((rop & 0xFFFF0000) == (GDIP_NOOP_ROP3 & 0xFFFF0000))
    {
        return;
    }

    if (rop != SRCCOPY &&
        rop != NOTSRCCOPY &&
        rop != PATCOPY &&
        rop != BLACKNESS &&
        rop != WHITENESS)
    {
        RopUsed = TRUE;
    }

    if ((stretchDIBitsRecord->cbBitsSrc > 0) &&
        (stretchDIBitsRecord->cbBmiSrc > 0)  &&
        IsSourceInRop3(rop))
    {
        UINT                usage      = stretchDIBitsRecord->iUsageSrc;
        BITMAPINFOHEADER *  srcDibInfo = (BITMAPINFOHEADER *)(((BYTE *)stretchDIBitsRecord) + stretchDIBitsRecord->offBmiSrc);
        BYTE *              srcBits    = ((BYTE *)stretchDIBitsRecord) + stretchDIBitsRecord->offBitsSrc;
        BITMAPINFOHEADER *  dstDibInfo = CreateModifiedDib(srcDibInfo, srcBits, usage, rop);

        if (dstDibInfo != NULL)
        {
            srcDibInfo = dstDibInfo;
            srcBits = NULL;
        }

        if (SrcCopyOnly && rop != SRCCOPY)
        {
            rop = SRCCOPY;
        }

        OutputDIB(Hdc,
                  &stretchDIBitsRecord->rclBounds,
                  stretchDIBitsRecord->xDest,  stretchDIBitsRecord->yDest,
                  stretchDIBitsRecord->cxDest, stretchDIBitsRecord->cyDest,
                  stretchDIBitsRecord->xSrc,   stretchDIBitsRecord->ySrc,
                  stretchDIBitsRecord->cxSrc,  stretchDIBitsRecord->cySrc,
                  srcDibInfo, srcBits, usage,  rop, FALSE);
    }
    else
    {
        if (SrcCopyOnly && rop != PATCOPY && !IsSourceInRop3(rop) && CreateCopyOfCurrentRecord())
        {
            EMRSTRETCHDIBITS*  stretchDIBitsRecord = (EMRSTRETCHDIBITS *)ModifiedEmfRecord;
            stretchDIBitsRecord->dwRop = PATCOPY;
        }
        ResetRecordBounds();
        this->PlayRecord();
    }
}

VOID
EmfEnumState::SetDIBitsToDevice(
    )
{
    // !!! to do

    // In SetDIBitsToDevice, the destination width and height
    // are in device units but in StretchDIBits, they are in world units.
    // Plus, the DIB header is for the entire DIB, but only part of the
    // DIB may be here (based on the number of scans).
    // So this record requires special handling if we are to process it.

    ResetRecordBounds();
    this->PlayRecord();
}

VOID
EmfEnumState::CreateDibPatternBrushPt(
    )
{
    const EMRCREATEDIBPATTERNBRUSHPT *  brushRecord = (const EMRCREATEDIBPATTERNBRUSHPT *)GetPartialRecord();
    INT     objectIndex = brushRecord->ihBrush;

    if (ValidObjectIndex(objectIndex) && (HandleTable != NULL))
    {
        UINT                usage      = brushRecord->iUsage;
        BITMAPINFOHEADER *  srcDibInfo = (BITMAPINFOHEADER *)(((UNALIGNED BYTE *)brushRecord) + brushRecord->offBmi);
        BITMAPINFOHEADER *  dstDibInfo = CreateModifiedDib(srcDibInfo, NULL, usage, SRCCOPY);

        if (dstDibInfo != NULL)
        {
            HandleTable->objectHandle[objectIndex] =
                    CreateDIBPatternBrushPt((BITMAPINFO *)dstDibInfo, usage);
            return;
        }
    }

    this->PlayRecord();
}

inline static BOOL
IsOfficeArtData(
    UINT                    recordSize,
    const EMRGDICOMMENT *   commentRecord
    )
{
    return ((recordSize >= (12 + 4 + msocbOADataHeader)) &&
            (commentRecord->cbData >= (msocbOADataHeader + 4)) &&
            ((GpMemcmp(commentRecord->Data, msoszOADataHeader, msocbOADataHeader) == 0) ||
             (GpMemcmp(commentRecord->Data, msoszOZDataHeader, msocbOZDataHeader) == 0)));
}

inline static const EMROFFICECOMMENT *
GetEmfComment(
    const BYTE *        emfRecord,
    ULONG               signature,
    UINT                kind
    )
{
    const EMROFFICECOMMENT *  emfComment = (const EMROFFICECOMMENT*)(emfRecord);
    if ((emfComment->ident == signature) && (emfComment->iComment == kind))
    {
        return emfComment;
    }
    return NULL;
}



VOID
EmfEnumState::GdiComment(
    )
{
    // Skip Office Art data when playing into another metafile
    if (IsMetafile() &&
        IsOfficeArtData(
            GetCurrentRecordSize(),
            (const EMRGDICOMMENT *)GetPartialRecord()))
    {
        return;
    }

    if (IsPostscript())
    {
        if (GetEmfComment((BYTE*)CurrentEmfRecord, msosignature, msocommentBeginSrcCopy))
        {
            SrcCopyOnly = TRUE;
            return;
        }
        if (GetEmfComment((BYTE*)CurrentEmfRecord, msosignature, msocommentEndSrcCopy))
        {
            SrcCopyOnly = FALSE;
            return;
        }
    }

    this->PlayRecord();
}

BOOL
IsPenCosmetic(
    HDC     hdc,
    int     penWidth
    )
{
    penWidth <<= 7;

    INT     newPenWidth = penWidth;
    POINT   points[2];

    points[0].x = 0;
    points[0].y = 0;
    points[1].x = 1 << 7;
    points[1].y = 0;

    if (::DPtoLP(hdc, points, 2))
    {
        newPenWidth = points[1].x - points[0].x;
        if (newPenWidth < 0)
        {
            newPenWidth = -newPenWidth;
        }
    }
    return (penWidth <= newPenWidth);
}

VOID
EmfEnumState::CreatePen(
    )
{
    const EMRCREATEPEN *    penRecord = (const EMRCREATEPEN *)GetPartialRecord();
    DWORD                   oldStyle  = penRecord->lopn.lopnStyle;

    if (oldStyle == PS_NULL)
    {
        this->PlayRecord();
    }
    else if (IsMetafile())
    {
        ModifyRecordColor(4, ColorAdjustTypePen);
        this->PlayRecord();
    }
    else
    {
        INT     objectIndex = penRecord->ihPen;

        if (ValidObjectIndex(objectIndex) && (HandleTable != NULL))
        {
            LOGBRUSH    logBrush;

            logBrush.lbStyle = PS_SOLID;
            logBrush.lbColor = ModifyColor(penRecord->lopn.lopnColor, ColorAdjustTypePen);
            logBrush.lbHatch = 0;

            INT         penWidth = penRecord->lopn.lopnWidth.x;
            DWORD       style;

            if (!Globals::IsNt && !IsMetafile())
            {
                //IsPenCosmetic is gonna call DPtoLP... Make sure to invalidate
                //the transform before
                CreateAndPlayCommentRecord();
            }

            if (IsPenCosmetic(Hdc, penWidth))
            {
                switch (oldStyle)
                {
                case PS_SOLID:
                case PS_DASH:           // on Win9x, cosmetic only
                case PS_DOT:            // on Win9x, cosmetic only
                case PS_DASHDOT:        // on Win9x, cosmetic only
                case PS_DASHDOTDOT:     // on Win9x, cosmetic only
                    break;

                case PS_ALTERNATE:      // cosmetic only, NT only
                    if (Globals::IsNt)
                    {
                        break;
                    }
                    // FALLTHRU

                case PS_USERSTYLE:      // NT only
                case PS_INSIDEFRAME:    // geometric only
                default:
                    oldStyle = PS_SOLID;
                    break;
                }
                penWidth = 1;
                style = PS_COSMETIC | oldStyle;
            }
            else
            {
                switch (oldStyle)
                {
                case PS_SOLID:
                case PS_INSIDEFRAME:    // geometric only
                    break;

                case PS_DASH:           // on Win9x, cosmetic only
                case PS_DOT:            // on Win9x, cosmetic only
                case PS_DASHDOT:        // on Win9x, cosmetic only
                case PS_DASHDOTDOT:     // on Win9x, cosmetic only
                    if (Globals::IsNt)
                    {
                        break;
                    }
                    // FALLTHRU

                case PS_ALTERNATE:      // cosmetic only, NT only
                case PS_USERSTYLE:      // NT only
                default:
                    oldStyle = PS_SOLID;
                    break;
                }
                style = PS_GEOMETRIC | oldStyle | PS_ENDCAP_ROUND | PS_JOIN_ROUND;
            }

            HandleTable->objectHandle[objectIndex] = ::ExtCreatePen(style, penWidth, &logBrush, 0, NULL);
        }
    }
}

HFONT CreateTrueTypeFont(
    HFONT   hFont
    )
{
    if (hFont)
    {
        if (Globals::IsNt)
        {
            LOGFONT  logFont;
            
            if (GetObject(hFont, sizeof(logFont), &logFont) > 0)
            {
                logFont.lfOutPrecision = OUT_TT_ONLY_PRECIS;
                return CreateFontIndirect(&logFont);
            }
            else
            {
                WARNING1("GetObject for hFont failed");
            }

        }
        else
        {
            LOGFONTA  logFont;

            if (GetObjectA(hFont, sizeof(logFont), &logFont) > 0)
            {
                logFont.lfOutPrecision = OUT_TT_ONLY_PRECIS;
                // We have a bug in Win9x that the OUT_TT_ONLY_PRECIS flag is
                // not always respected so if the font name is MS SANS SERIF
                // change it to Times New Roman
                if (lstrcmpiA(logFont.lfFaceName, "MS SANS SERIF") == 0)
                {
                    GpMemcpy(logFont.lfFaceName, "Times New Roman", sizeof("Times New Roman"));
                }
                return CreateFontIndirectA(&logFont);
            }
            else
            {
                WARNING1("GetObject for hFont failed");
            }
        }            
    }
    else
    {
        WARNING1("NULL hFont");
    }
    return NULL;
}

VOID
EmfEnumState::ExtCreateFontIndirect(
    )
{
    const EMREXTCREATEFONTINDIRECTW *    fontRecord = (const EMREXTCREATEFONTINDIRECTW *)GetPartialRecord();
    BOOL recordCopied = FALSE;
    if (!Globals::IsNt)
    {
        // We have a bug in Win9x that the OUT_TT_ONLY_PRECIS flag is
        // not always respected so if the font name is MS SANS SERIF
        // change it to Times New Roman
        if (UnicodeStringCompareCI(fontRecord->elfw.elfFullName, L"MS SANS SERIF") == 0)
        {
            if (CreateCopyOfCurrentRecord())
            {
                GpMemcpy(((EMREXTCREATEFONTINDIRECTW *)ModifiedEmfRecord)->elfw.elfFullName,
                         L"Times New Roman", sizeof(L"Times New Roman"));
                recordCopied = TRUE;
            }
        }
    }


    if (fontRecord->elfw.elfLogFont.lfOutPrecision != OUT_TT_ONLY_PRECIS)
    {
        if (recordCopied || CreateCopyOfCurrentRecord())
        // Instruct GDI to use only True Type fonts, since bitmap fonts
        // are not scalable.
        {
            ((EMREXTCREATEFONTINDIRECTW *)ModifiedEmfRecord)->elfw.elfLogFont.lfOutPrecision = OUT_TT_ONLY_PRECIS;
        }
    }
    this->PlayRecord();
}

VOID
EmfEnumState::SelectObject(
    )
{
    const EMRSELECTOBJECT *     selectRecord = (const EMRSELECTOBJECT *)GetPartialRecord();
    DWORD                       handleIndex  = selectRecord->ihObject;

    // See if we're selecting in a stock font
    if ((handleIndex & ENHMETA_STOCK_OBJECT) != 0)
    {
        handleIndex &= (~ENHMETA_STOCK_OBJECT);

        // handleIndex >= (WHITE_BRUSH==0) && <= BLACK_PEN
        if ((handleIndex <= BLACK_PEN) && (Recolor != NULL))
        {
            union {
                LOGBRUSH lb;
                LOGPEN lp;
            };

            RecolorStockObject* stockObj;
            int i;

            for (stockObj = &RecolorStockObjectList[0],
                 i = 0;
                 i < NUM_STOCK_RECOLOR_OBJS;
                 i++,
                 stockObj++)
            {
                if (stockObj->Handle == handleIndex)
                {
                    // Already have a cached recolored handle lying around.
                    HGDIOBJ stockHandle = RecoloredStockHandle[i];

                    if (stockHandle == NULL)
                    {
                        // No cached recolored stock object handle, recreate
                        // one here.
                        COLORREF newColor;

                        if (stockObj->Brush)
                        {
                            newColor = ModifyColor(stockObj->Color, ColorAdjustTypeBrush);

                            lb.lbStyle = BS_SOLID;
                            lb.lbColor = newColor;
                            lb.lbHatch = 0;

                            stockHandle = ::CreateBrushIndirect(&lb);

                            RecoloredStockHandle[i] = stockHandle;
                        }
                        else
                        {
                            newColor = ModifyColor(stockObj->Color, ColorAdjustTypePen);

                            lp.lopnStyle = PS_SOLID;
                            lp.lopnWidth.x = 1;
                            lp.lopnWidth.y = 0;
                            lb.lbColor = newColor;

                            stockHandle = ::CreatePenIndirect(&lp);

                            RecoloredStockHandle[i] = stockHandle;
                        }
                    }

                    if (stockHandle != NULL)
                    {
                        ::SelectObject(Hdc, stockHandle);
                        return;
                    }
                }
            }
        }
        else if ((handleIndex >= OEM_FIXED_FONT) &&
                 (handleIndex <= DEFAULT_GUI_FONT))
        {
            // It is a stock font -- create a true type font, instead of
            // using the stock font directly to guarantee that we don't
            // use bitmap fonts which don't scale well.

            HFONT   hFont = StockFonts[handleIndex - OEM_FIXED_FONT];

            if (hFont == NULL)
            {
                hFont = CreateTrueTypeFont((HFONT)GetStockObject(handleIndex));
                StockFonts[handleIndex - OEM_FIXED_FONT] = hFont;
            }

            if (hFont != NULL)
            {
                ::SelectObject(Hdc, hFont);
                return;
            }
        }
    }
    this->PlayRecord();

    // In case we select a region, intersect with the destrect
    if (!Globals::IsNt)
    {
        if (((handleIndex & ENHMETA_STOCK_OBJECT) == 0) &&
            (GetObjectTypeInternal((*HandleTable).objectHandle[handleIndex]) == OBJ_REGION))
        {
            this->IntersectDestRect();
        }
    }
}

VOID
EmfEnumState::ExtCreatePen(
    )
{
    const EMREXTCREATEPEN32 *  penRecord = (const EMREXTCREATEPEN32 *)GetPartialRecord();
    UINT    brushStyle = penRecord->elp.elpBrushStyle;

    if (brushStyle != BS_HOLLOW)
    {
        if (IsMetafile())
        {
            if ((brushStyle == BS_SOLID) || (brushStyle == BS_HATCHED))
            {
                ModifyRecordColor(8, ColorAdjustTypePen);
            }
            // else don't worry about recoloring pattern brushes for now

            this->PlayRecord();
            return;
        }

        INT     objectIndex = penRecord->ihPen;

        if (ValidObjectIndex(objectIndex) && (HandleTable != NULL))
        {
            if (!Globals::IsNt && !IsMetafile())
            {
                //IsPenCosmetic is gonna call DPtoLP... Make sure to invalidate
                //the transform before
                CreateAndPlayCommentRecord();
            }

            DWORD       penWidth   = penRecord->elp.elpWidth;
            BOOL        isCosmetic = IsPenCosmetic(Hdc, penWidth);
            DWORD       oldStyle   = penRecord->elp.elpPenStyle;

            if (!Globals::IsNt)
            {
                DWORD       style;

                if (isCosmetic)
                {
                    oldStyle &= PS_STYLE_MASK;

                    switch (oldStyle)
                    {
                    case PS_SOLID:
                    case PS_DASH:           // on Win9x, cosmetic only
                    case PS_DOT:            // on Win9x, cosmetic only
                    case PS_DASHDOT:        // on Win9x, cosmetic only
                    case PS_DASHDOTDOT:     // on Win9x, cosmetic only
                        break;

                    case PS_ALTERNATE:      // cosmetic only, NT only
                    case PS_USERSTYLE:      // NT only
                    case PS_INSIDEFRAME:    // geometric only
                    default:
                        oldStyle = PS_SOLID;
                        break;
                    }
                    penWidth = 1;
                    style = PS_COSMETIC | oldStyle;
                }
                else
                {
                    oldStyle &= (~PS_TYPE_MASK);

                    switch (oldStyle & PS_STYLE_MASK)
                    {
                    case PS_SOLID:
                    case PS_INSIDEFRAME:    // geometric only
                        break;

                    case PS_DASH:           // on Win9x, cosmetic only
                    case PS_DOT:            // on Win9x, cosmetic only
                    case PS_DASHDOT:        // on Win9x, cosmetic only
                    case PS_DASHDOTDOT:     // on Win9x, cosmetic only
                    case PS_ALTERNATE:      // cosmetic only, NT only
                    case PS_USERSTYLE:      // NT only
                    default:
                        oldStyle = (oldStyle & (~PS_STYLE_MASK)) | PS_SOLID;
                        break;
                    }
                    style = PS_GEOMETRIC | oldStyle;
                }

                COLORREF    color = RGB(0,0,0);

                if ((brushStyle == BS_SOLID) || (brushStyle == BS_HATCHED))
                {
                    color = penRecord->elp.elpColor;
                }

                color = ModifyColor(color, ColorAdjustTypePen);

                // Only solid brushes are supported on Win9x
                LOGBRUSH    logBrush;
                logBrush.lbStyle = PS_SOLID;
                logBrush.lbColor = color;
                logBrush.lbHatch = 0;

                HandleTable->objectHandle[objectIndex] = ::ExtCreatePen(style, penWidth, &logBrush, 0, NULL);
                return;
            }

            // else it is NT
            if ((brushStyle == BS_SOLID) || (brushStyle == BS_HATCHED))
            {
                ModifyRecordColor(8, ColorAdjustTypePen);
            }
            // else don't worry about recoloring pattern brushes for now

            if (isCosmetic && CreateCopyOfCurrentRecord())
            {
                oldStyle &= PS_STYLE_MASK;
                if (oldStyle == PS_INSIDEFRAME) // geometric only
                {
                    oldStyle = PS_SOLID;
                }
                ((EMREXTCREATEPEN32 *)ModifiedEmfRecord)->elp.elpPenStyle = PS_COSMETIC | oldStyle;
                ((EMREXTCREATEPEN32 *)ModifiedEmfRecord)->elp.elpWidth    = 1;
            }
        }
    }
    this->PlayRecord();
}

VOID
EmfEnumState::CreateBrushIndirect(
    )
{
    const EMRCREATEBRUSHINDIRECT *  brushRecord = (const EMRCREATEBRUSHINDIRECT *)GetPartialRecord();

    if (brushRecord->lb.lbStyle != BS_HOLLOW)
    {
        ModifyRecordColor(2, ColorAdjustTypeBrush);

        if (ModifiedEmfRecord != NULL)
        {
            brushRecord = (const EMRCREATEBRUSHINDIRECT *)ModifiedEmfRecord;
        }

        // See if we need to halftone the color.  We do if it is a solid
        // color, and we have a halftone palette, and the color is not
        // an exact match in the palette.

        COLORREF    color;

        if (IsHalftonePalette && (brushRecord->lb.lbStyle == BS_SOLID) &&
            (((color = brushRecord->lb.lbColor) & 0x02000000) == 0))
        {
            // create a halftone brush, instead of a solid brush

            INT     objectIndex = brushRecord->ihBrush;

            if (ValidObjectIndex(objectIndex) && (HandleTable != NULL))
            {
                BYTE dib[sizeof(BITMAPINFOHEADER) + // DIB 8 bpp header
                         (8 * sizeof(RGBQUAD)) +    // DIB 8 colors
                         (8* 8)];                   // DIB 8x8 pixels

                HalftoneColorRef_216(color, dib);

                HandleTable->objectHandle[objectIndex] =
                        CreateDIBPatternBrushPt(dib, DIB_RGB_COLORS);
                return;
            }
        }
    }
    this->PlayRecord();
}

BOOL
EmfEnumState::PlayRecord(
    )
{
    const ENHMETARECORD *  recordToPlay = ModifiedEmfRecord;

    // See if we've modified the record
    if (recordToPlay == NULL)
    {
        // We haven't.  See if we have a valid current record
        if (CurrentEmfRecord != NULL)
        {
            recordToPlay = CurrentEmfRecord;
        }
        else
        {
            // we don't so we have to create one
            if (!CreateCopyOfCurrentRecord())
            {
                return FALSE;
            }
            recordToPlay = ModifiedEmfRecord;
        }
    }
    return PlayEnhMetaFileRecord(Hdc, HandleTable, recordToPlay, NumObjects);
}

VOID
EmfEnumState::RestoreHdc(
    )
{
    LONG    relativeCount = ((const EMRRESTOREDC *)GetPartialRecord())->iRelative;

    if (SaveDcCount < 0)
    {
        if (relativeCount >= SaveDcCount)
        {
            if (relativeCount >= 0)
            {
                // Modify the record
                CreateCopyOfCurrentRecord();    // guaranteed to succeed
                relativeCount = -1;
                ((EMRRESTOREDC *)ModifiedEmfRecord)->iRelative = -1;
            }
        }
        else
        {
            // Modify the record
            CreateCopyOfCurrentRecord();    // guaranteed to succeed
            relativeCount = SaveDcCount;
            ((EMRRESTOREDC *)ModifiedEmfRecord)->iRelative = relativeCount;
        }
        SaveDcCount -= relativeCount;
        this->PlayRecord();
    }
    else
    {
        WARNING(("RestoreDC not matched to a SaveDC"));
    }
}

VOID
EmfEnumState::ModifyRecordColor(
    INT             paramIndex,
    ColorAdjustType adjustType
    )
{
    COLORREF    origColor = ((COLORREF *)RecordData)[paramIndex];
    COLORREF    modifiedColor = ModifyColor(origColor, adjustType);

    if (modifiedColor != origColor)
    {
        if (CreateCopyOfCurrentRecord())
        {
            *((COLORREF*)&(ModifiedEmfRecord->dParm[paramIndex])) = modifiedColor;
        }
    }
}

VOID
EmfEnumState::ExtEscape(
    )
{
    if (IsPostscriptPrinter())
    {
        // Bug #98743 (Windows Bugs) Gdiplus must overcome GDI limitation
        // with POSTSCRIPT_INJECTION.  Comments from Rammanohar Arumugam:
        //
        // Being in xx-centric mode means POSTSCRIPT_DATA won't work. I
        // take that to mean that PlayMetaFileRecord only works in
        // compatibility mode.
        //
        // GdiPlus will check for the printer mode. In GDI-centric and
        // Postscript-centric mode, it will not do PlayMetaFileRecord for
        // any record that has POSTSCRIPT_DATA. Instead, it will output
        // the postscript data through a PASSTHRU (for GDI-centric mode)
        // or a POSTSCRIPT_PASSTHRU (for Postscript-Centric mode).
        //
        // You can find out the mode by querying the escape support.
        // 1. Query for POSTSCRIPT_INJECTION support. If not supported,
        // it's compat mode. If supported, find out the mode by doing step 2/3
        // 2. Query for PASSTHROUGH support. If supported, it's GDI-centric.
        // 3. Query for POSTSCRIPT_PASSTHROUGH support. If supported, it's PS-centric.

        PEMREXTESCAPE escRecord = (PEMREXTESCAPE) RecordData;

        //    EMR     emr;
        //    INT     iEscape;            // Escape code
        //    INT     cbEscData;          // Size of escape data
        //    BYTE    EscData[1];         // Escape data

        if (escRecord->iEscape == POSTSCRIPT_DATA)
        {
            if (Globals::IsNt)
            {
                DWORD EscapeValue = POSTSCRIPT_IDENTIFY;

                if (::ExtEscape(Hdc,
                              QUERYESCSUPPORT,
                              sizeof(DWORD),
                              (LPSTR)&EscapeValue,
                              0,
                              NULL) <= 0)
                {
                    // POSTSCRIPT_IDENTITY is not supported if the mode has
                    // been set because it can only be set once.

                    EscapeValue = POSTSCRIPT_PASSTHROUGH;
                    if (::ExtEscape(Hdc,
                                  QUERYESCSUPPORT,
                                  sizeof(DWORD),
                                  (LPSTR)&EscapeValue,
                                  0,
                                  NULL) <= 0)
                    {
                        // GDI-centric mode
                        if (CreateCopyOfCurrentRecord())
                        {
                            ((EMREXTESCAPE *)ModifiedEmfRecord)->iEscape = PASSTHROUGH;
                        }
                    }
                    else
                    {
                        // PS-centric mode
                        if (CreateCopyOfCurrentRecord())
                        {
                            ((EMREXTESCAPE *)ModifiedEmfRecord)->iEscape = POSTSCRIPT_PASSTHROUGH;
                        }
                    }

                    this->PlayRecord();
                    return;
                }
                else
                {
                    // compatibility mode uses POSTSCRIPT_DATA
                }
            }
            else
            {
                // Win98 doesn't distinguish between GDI & compatibility mode
                if (CreateCopyOfCurrentRecord())
                {
                    ((EMREXTESCAPE *)ModifiedEmfRecord)->iEscape = PASSTHROUGH;
                }
            }
        }
    }

    this->PlayRecord();
}

EmfEnumState::EmfEnumState(
    HDC                 hdc,
    HENHMETAFILE        hEmf,
    const RECT *        dest,
    const RECT *        deviceRect,
    BOOL                externalEnumeration,
    InterpolationMode   interpolation,
    DpContext *         context,
    GpRecolor *         recolor,
    ColorAdjustType     adjustType
    )
    : MfEnumState(hdc, externalEnumeration, interpolation,
                  recolor, adjustType, deviceRect, context)
{
    if (IsValid())
    {
        ClipRgn    = NULL;
        Palette    = NULL;
        BrushOrg.x = 0;
        BrushOrg.y = 0;

        // Bug 166280 from Office:
        // PROBLEM: If the DC has any clipping region in it, EnumEnhMetaFile
        //          will create a region before calling the EnumProc for the
        //          first time.  And, this region is not deleted and cannot be
        //          recovered through RestoreDC. (Only on Win9x)
        // FIX:     Before calling EnumEnhMetafile, save the clipping region
        //          and set the Clipping region to NULL.  Select the saved
        //          clipping region in the CallBack at EMR_HEADER.
        //          We will not do this on Metafile DC.  Put clipping region
        //          records in Metafile may cause other rendering problems.

        if (!Globals::IsNt && !IsMetafile())
        {
            HRGN    clipRgn = ::CreateRectRgn(0,0,0,0);

            if (clipRgn != NULL)
            {
                switch (::GetClipRgn(hdc, clipRgn))
                {
                case -1:        // error
                case 0:         // no initial clip region
                    ::DeleteObject(clipRgn);
                    break;
                case 1:         // has initial clip region
                    ::SelectClipRgn(hdc, NULL);
                    ClipRgn = clipRgn;
                    break;
                }
            }
        }

        // Bug 160932 from Office:  Redraw problems with EMFs
        // The fix is to make the drawing independent of where
        // the EMF is drawn - this can be done easily by setting the
        // brush origin before the first record is played (in the
        // record callback proc) to a value which is the top left of the
        // output rectangle of the EMF in device coordinates (i.e. LPtoDP of
        // the logical coordinate top left).

        BrushOrg.x = dest->left;
        BrushOrg.y = dest->top;
        LPtoDP(hdc, &BrushOrg, 1);

        // EnumEnhMetafile selects in the DEFAULT_PALETTE, but we may need
        // another palette to remain selected in (for halftoning, etc.)
        // so save the current palette and select it back in when the
        // header record is received.

        HPALETTE    hpal = (HPALETTE)GetCurrentObject(hdc, OBJ_PAL);
        if (hpal != (HPALETTE)GetStockObject(DEFAULT_PALETTE))
        {
            Palette = hpal;
        }
        BkColor   = ::GetBkColor(hdc);
        TextColor = ::GetTextColor(hdc);
    }
}

VOID
EmfEnumState::Header(
    )
{
    ::SetBrushOrgEx(Hdc, BrushOrg.x, BrushOrg.y, NULL);
    if (ClipRgn != (HRGN)0)
    {
        ::SelectClipRgn(Hdc, ClipRgn);
        ::DeleteObject(ClipRgn);
        ClipRgn = NULL;
    }
    if (Palette != NULL)
    {
        ::SelectPalette(Hdc, Palette, TRUE);
    }

    // Bitmap fonts are not good for playing metafiles because they
    // don't scale well, so use a true type font instead as the default font.

    HFONT hFont = CreateTrueTypeFont((HFONT)GetCurrentObject(Hdc, OBJ_FONT));

    if (hFont != NULL)
    {
        DefaultFont = hFont;
        ::SelectObject(Hdc, hFont);
    }

    this->PlayRecord();
}

VOID
EmfEnumState::SelectPalette(INT objectIndex)
{
    if (objectIndex == (ENHMETA_STOCK_OBJECT | DEFAULT_PALETTE))
    {
        CurrentPalette = (HPALETTE)::GetStockObject(DEFAULT_PALETTE);
    }
    else
    {
        MfEnumState::SelectPalette(objectIndex);
    }
}

VOID
EmfEnumState::IntersectDestRect()
{
    if (!IsMetafile())
    {
        // Make the transform the identity
        POINT windowOrg;
        SIZE  windowExt;
        POINT viewportOrg;
        SIZE  viewportExt;
        ::SetViewportOrgEx(Hdc, 0, 0, &viewportOrg);
        ::SetViewportExtEx(Hdc, 1, 1, &viewportExt);
        ::SetWindowOrgEx(Hdc, 0, 0, &windowOrg);
        ::SetWindowExtEx(Hdc, 1, 1, &windowExt);

        // We are always in device units
        ::IntersectClipRect(Hdc, DestRectDevice.left, DestRectDevice.top,
                            DestRectDevice.right, DestRectDevice.bottom);

        // Restore the transform
        ::SetViewportOrgEx(Hdc, viewportOrg.x, viewportOrg.y, NULL);
        ::SetViewportExtEx(Hdc, viewportExt.cx, viewportExt.cy, NULL);
        ::SetWindowOrgEx(Hdc, windowOrg.x, windowOrg.y, NULL);
        ::SetWindowExtEx(Hdc, windowExt.cx, windowExt.cy, NULL);
    }
}

VOID EmfEnumState::SetROP2()
{
    DWORD    dwROP = ((const EMRSETROP2 *)GetPartialRecord())->iMode;

    if (dwROP != R2_BLACK &&
        dwROP != R2_COPYPEN &&
        dwROP != R2_NOTCOPYPEN &&
        dwROP != R2_WHITE )
    {
        RopUsed = TRUE;
    }
    this->PlayRecord();
}

VOID EmfEnumState::ExtTextOutW()
{
    if (!this->PlayRecord())
    {
        BYTE* emrTextOut = (BYTE*) GetPartialRecord();
        if(CreateCopyOfCurrentRecord())
        {
            // !!! Shouldn't this use the offset in the record?

            BYTE * ptr = emrTextOut + sizeof(EMREXTTEXTOUTW);
            AnsiStrFromUnicode ansistr((WCHAR*)ptr);
            INT len = strlen(ansistr);
            // Don't forget to copy the NULL byte
            GpMemcpy((BYTE*)ModifiedEmfRecord + sizeof(EMREXTTEXTOUTW), (char*)ansistr, len+1);
            EMREXTTEXTOUTA *record = (EMREXTTEXTOUTA*) ModifiedEmfRecord;
            record->emr.iType = EmfRecordTypeExtTextOutA;

            // Keep the size of the record intact because of the spacing vector
            this->PlayRecord();
        }
    }
}

VOID EmfEnumState::Rectangle()
{
    // On NT convert the rectangle call to a polygon call because rectangle
    // seem to have a special case that can draw outside of the metafile
    // bounds. GDI seems to Ceil the coordinates instead of rounding them for
    // rectangles.

    if (!Globals::IsNt || IsMetafile())
    {
        this->PlayRecord();
        return;
    }
    const EMRRECTANGLE *emrRect = (const EMRRECTANGLE*) GetPartialRecord();
    
    POINT points[4] = {emrRect->rclBox.left,  emrRect->rclBox.top,
                       emrRect->rclBox.right, emrRect->rclBox.top,
                       emrRect->rclBox.right, emrRect->rclBox.bottom,
                       emrRect->rclBox.left,  emrRect->rclBox.bottom};

    ::Polygon(Hdc, points, 4);
    return;
}

BOOL
EmfEnumState::ProcessRecord(
    EmfPlusRecordType       recordType,
    UINT                    recordDataSize,
    const BYTE *            recordData
    )
{
    BOOL        forceCallback = FALSE;

    // See if we're doing enumeration for an external app
    if (ExternalEnumeration)
    {
        if (recordData == NULL)
        {
            recordDataSize = 0;
        }
        else if (recordDataSize == 0)
        {
            recordData = NULL;
        }

        // See if the app changed the record at all.
        if ((recordType != RecordType) ||
            (recordDataSize != RecordDataSize) ||
            ((recordDataSize > 0) &&
             ((CurrentEmfRecord == NULL) ||
              (recordData != (const BYTE *)(const BYTE *)CurrentEmfRecord->dParm))))
        {
            // Yes, we need to override what happened in StartRecord
            CurrentEmfRecord  = NULL;
            RecordType        = recordType;
            RecordData        = recordData;
            RecordDataSize    = recordDataSize;
        }
    }

    GDIP_TRY

    switch (recordType)
    {
    case EmfRecordTypeHeader:
        this->Header();
        break;

#if 0
    // Do we really need to do anything for PolyPolygon records?
    // If so, why not for PolyPolyline too?
    case EmfRecordTypePolyPolygon:
        this->PolyPolygon();
        break;

    case EmfRecordTypePolyPolygon16:
        this->PolyPolygon16();
        break;
#endif

    case EmfRecordTypeExtEscape:
        this->ExtEscape();
        break;

    case EmfRecordTypeSetPixelV:
        this->SetPixelV();
        break;

    case EmfRecordTypeSetTextColor:
        this->SetTextColor();
        break;

    case EmfRecordTypeSetBkColor:
        this->SetBkColor();
        break;

    case EmfRecordTypeSetMetaRgn:
        // Office Bug 154881.  Win9x doesn't handle MetaRgn correctly.
        if (Globals::IsNt)
        {
            this->PlayRecord();
        }
        break;

    case EmfRecordTypeSaveDC:
        this->SaveHdc();
        break;

    case EmfRecordTypeRestoreDC:
        this->RestoreHdc();
        break;

    case EmfRecordTypeCreatePen:
        this->CreatePen();
        break;

   case EmfRecordTypeCreateBrushIndirect:
        this->CreateBrushIndirect();
        break;

    case EmfRecordTypeSelectPalette:
        // We don't select in any palettes when playing the metafile,
        // because we don't want to invalidate our halftoning palette.
        // Keep track of the palette so we can map from PALETTEINDEXes
        // to RGB values.
        this->SelectPalette(((UINT32 *)recordData)[0]);
        break;

    case EmfRecordTypeRealizePalette:
        // We don't want to invalidate our halftoning palette by realizing one
        // from a metafile.
        break;

    case EmfRecordTypeExtFloodFill:
        this->ExtFloodFill();
        break;

    case EmfRecordTypeGdiComment:
        this->GdiComment();
        break;

    case EmfRecordTypeBitBlt:
        this->BitBlt();
        forceCallback = TRUE;
        break;

    case EmfRecordTypeStretchBlt:
        this->StretchBlt();
        forceCallback = TRUE;
        break;

    case EmfRecordTypeMaskBlt:
        this->MaskBlt();
        forceCallback = TRUE;
        break;

    case EmfRecordTypePlgBlt:
        this->PlgBlt();
        forceCallback = TRUE;
        break;

    case EmfRecordTypeSetDIBitsToDevice:
        this->SetDIBitsToDevice();
        forceCallback = TRUE;
        break;

    case EmfRecordTypeStretchDIBits:
        this->StretchDIBits();
        forceCallback = TRUE;
        break;

   // case EMR_CREATEMONOBRUSH:
   // A monochrome brush uses the text color and the background color,
   // so we shouldn't need to make any changes to the brush itself.

   case EmfRecordTypeCreateDIBPatternBrushPt:
        this->CreateDibPatternBrushPt();
        break;

    case EmfRecordTypeExtCreatePen:
        this->ExtCreatePen();
        break;

    case EmfRecordTypeSetICMMode:
    case EmfRecordTypeCreateColorSpace:
    case EmfRecordTypeSetColorSpace:
    case EmfRecordTypeDeleteColorSpace:
    case EmfRecordTypeSetICMProfileA:
    case EmfRecordTypeSetICMProfileW:
    case EmfRecordTypeCreateColorSpaceW:
        if (Globals::IsNt ||
            (!this->IsScreen() && !this->IsBitmap()))
        {
            this->PlayRecord();
        }
        // else skip the record
        break;

    case EmfRecordTypeAlphaBlend:
        this->AlphaBlend();
        forceCallback = TRUE;
        break;

    case EmfRecordTypeTransparentBlt:
        this->TransparentBlt();
        forceCallback = TRUE;
        break;

    case EmfRecordTypeGradientFill:
        this->GradientFill();
        forceCallback = TRUE;
        break;

    case EmfRecordTypeExtCreateFontIndirect:
        this->ExtCreateFontIndirect();
        break;

    case EmfRecordTypeSelectObject:
        this->SelectObject();
        break;

    case EmfRecordTypeSelectClipPath:
    case EmfRecordTypeExtSelectClipRgn:
    case EmfRecordTypeOffsetClipRgn:
        this->PlayRecord();
        if (!Globals::IsNt)
        {
            this->IntersectDestRect();
        }
        break;

    case EmfRecordTypeSetROP2:
        this->SetROP2();
        break;

    case EmfRecordTypeFillRgn:
    case EmfRecordTypeFrameRgn:
    case EmfRecordTypeInvertRgn:
    case EmfRecordTypePaintRgn:
        this->ResetRecordBounds();
        this->PlayRecord();
        break;

    case EmfRecordTypeExtTextOutW:
        this->ExtTextOutW();
        break;

    case EmfRecordTypeRectangle:
        this->Rectangle();
        break;

    case EmfRecordTypeSetMapMode:
    case EmfRecordTypeSetViewportExtEx:
    case EmfRecordTypeSetViewportOrgEx:
    case EmfRecordTypeSetWindowExtEx:
    case EmfRecordTypeSetWindowOrgEx:
    case EmfRecordTypePolyBezier:
    case EmfRecordTypePolygon:
    case EmfRecordTypePolyline:
    case EmfRecordTypePolyBezierTo:
    case EmfRecordTypePolyLineTo:
    case EmfRecordTypePolyPolyline:
    case EmfRecordTypePolyPolygon:
    case EmfRecordTypeSetBrushOrgEx:
    case EmfRecordTypeEOF:
    case EmfRecordTypeSetMapperFlags:
    case EmfRecordTypeSetBkMode:
    case EmfRecordTypeSetPolyFillMode:
    case EmfRecordTypeSetStretchBltMode:
    case EmfRecordTypeSetTextAlign:
    case EmfRecordTypeSetColorAdjustment:
    case EmfRecordTypeMoveToEx:
    case EmfRecordTypeExcludeClipRect:
    case EmfRecordTypeIntersectClipRect:
    case EmfRecordTypeScaleViewportExtEx:
    case EmfRecordTypeScaleWindowExtEx:
    case EmfRecordTypeSetWorldTransform:
    case EmfRecordTypeModifyWorldTransform:
    case EmfRecordTypeDeleteObject:
    case EmfRecordTypeAngleArc:
    case EmfRecordTypeEllipse:
    case EmfRecordTypeRoundRect:
    case EmfRecordTypeArc:
    case EmfRecordTypeChord:
    case EmfRecordTypePie:
    case EmfRecordTypeCreatePalette:
    case EmfRecordTypeSetPaletteEntries:
    case EmfRecordTypeResizePalette:
    case EmfRecordTypeLineTo:
    case EmfRecordTypeArcTo:
    case EmfRecordTypePolyDraw:
    case EmfRecordTypeSetArcDirection:
    case EmfRecordTypeSetMiterLimit:
    case EmfRecordTypeBeginPath:
    case EmfRecordTypeEndPath:
    case EmfRecordTypeCloseFigure:
    case EmfRecordTypeFillPath:
    case EmfRecordTypeStrokeAndFillPath:
    case EmfRecordTypeStrokePath:
    case EmfRecordTypeFlattenPath:
    case EmfRecordTypeWidenPath:
    case EmfRecordTypeAbortPath:
    case EmfRecordTypeReserved_069:
    case EmfRecordTypeExtTextOutA:
    case EmfRecordTypePolyBezier16:
    case EmfRecordTypePolygon16:
    case EmfRecordTypePolyline16:
    case EmfRecordTypePolyBezierTo16:
    case EmfRecordTypePolylineTo16:
    case EmfRecordTypePolyPolyline16:
    case EmfRecordTypePolyPolygon16:
    case EmfRecordTypePolyDraw16:
    case EmfRecordTypeCreateMonoBrush:
    case EmfRecordTypePolyTextOutA:
    case EmfRecordTypePolyTextOutW:
    case EmfRecordTypeGLSRecord:
    case EmfRecordTypeGLSBoundedRecord:
    case EmfRecordTypePixelFormat:
    case EmfRecordTypeDrawEscape:
    case EmfRecordTypeStartDoc:
    case EmfRecordTypeSmallTextOut:
    case EmfRecordTypeForceUFIMapping:
    case EmfRecordTypeNamedEscape:
    case EmfRecordTypeColorCorrectPalette:
    case EmfRecordTypeSetLayout:
    case EmfRecordTypeReserved_117:
    case EmfRecordTypeSetLinkedUFIs:
    case EmfRecordTypeSetTextJustification:
    case EmfRecordTypeColorMatchToTargetW:
        // Play the current record.
        // Even if it fails, we keep playing the rest of the metafile.
        this->PlayRecord();
        break;

    default:
        // unknown record -- ignore it
        WARNING1("Unknown EMF Record");
        break;
    }

    GDIP_CATCH
        forceCallback = TRUE;
    GDIP_ENDCATCH

    return forceCallback;
}

VOID EmfEnumState::ResetRecordBounds()
{
    if (Globals::IsNt && IsMetafile())
    {
        if (ModifiedEmfRecord == NULL)
        {
            CreateCopyOfCurrentRecord();
        }
        // In case the previous call failed
        if (ModifiedEmfRecord != NULL)
        {
            RECTL rect = {INT_MIN, INT_MIN, INT_MAX, INT_MAX};
            EMRRCLBOUNDS *record = (EMRRCLBOUNDS*) ModifiedEmfRecord;
            record->rclBounds = rect;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\metafile.hpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   MetaFile.hpp
*
* Abstract:
*
*   Metafile definitions
*
* Created:
*
*   4/14/1999 DCurtis
*
\**************************************************************************/

#ifndef _METAFILE_HPP
#define _METAFILE_HPP

#define EMFPLUS_SIGNATURE           0x2B464D45
#define EMFPLUS_DUAL                0x4C415544      // EMF+ with down-level GDI records
#define EMFPLUS_ONLY                0x594C4E4F      // EMF+ only -- no down-level

/* The following are defined in Object.hpp:
#define EMFPLUS_VERSION
#define EMFPLUS_MAJORVERSION_BITS
#define EMFPLUS_MINORVERSION_BITS
*/


// Constants for MFCOMMENT Escape

#define MFCOMMENT_IDENTIFIER           0x43464D57
#define MFCOMMENT_ENHANCED_METAFILE    1

// When serializing an object, we need to leave room for the record header
// and possibly a dependent object id.  Also, an image can be part of a
// texture brush, so leave room for the texture brush data.
// Subtract 480 for good measure.
#define GDIP_MAX_OBJECT_SIZE          (GDIP_MAX_COMMENT_SIZE - 480)
#define GDIP_METAFILE_BUFFERSIZE      2048
#define GDIP_MAX_OBJECTS              64      // max num cached objects
#define GDIP_SAVE_STACK_SIZE          16      // for save/restores
#define GDIP_LIST_NIL                 0xFFFFFFFF
#define GDIP_OBJECTID_NONE            GDIP_LIST_NIL  // no object present

#define GDIP_REAL_SIZE                4
#define GDIP_RECTF_SIZE               (4 * GDIP_REAL_SIZE)
#define GDIP_POINTF_SIZE              (2 * GDIP_REAL_SIZE)
#define GDIP_MATRIX_SIZE              (6 * GDIP_REAL_SIZE)

// Set in Flags in EMF+ record header
// Flags Used in Object Records
#define GDIP_EPRFLAGS_CONTINUEOBJECT  0x8000  // more data for previous object
#define GDIP_EPRFLAGS_OBJECTTYPE      0x7F00

// Used in Object records and "Fill..." and "Draw..." and many other records
#define GDIP_EPRFLAGS_METAOBJECTID    0x00FF
#define GDIP_BACKUP_OBJECTID          255   // the object is a "backup object"

// Used in "Fill..." records
#define GDIP_EPRFLAGS_SOLIDCOLOR      0x8000

// Used in "Fill..." and "Draw..." records
#define GDIP_EPRFLAGS_COMPRESSED      0x4000  // point data is compressed

// Used in some "Fill..." records
#define GDIP_EPRFLAGS_WINDINGFILL     0x2000

// Used in DrawLines record
#define GDIP_EPRFLAGS_CLOSED          0x2000

// Used in matrix operations
#define GDIP_EPRFLAGS_APPEND          0x2000

// Used in SetAntiAliasMode record
#define GDIP_EPRFLAGS_ANTIALIAS       0x0001

// Used in SetTextRenderingHint record
#define GDIP_EPRFLAGS_TEXTRENDERINGHINT 0x00FF

// Used in SetTextContrast record (1000~2200)
#define GDIP_EPRFLAGS_CONTRAST        0x0FFF

// Used in EndOfFile record
#define GDIP_EPRFLAGS_DIDGETDC        0x2000

// Used in BeginContainer and SetPageTransform records
#define GDIP_EPRFLAGS_PAGEUNIT        0x00FF  // can't be mixed with Ids

// Used in SetInterpolationMode record
#define GDIP_EPRFLAGS_INTERPOLATIONMODE 0x00FF

// Used in SetPixelOffsetMode record
#define GDIP_EPRFLAGS_PIXELOFFSETMODE 0x00FF

// Used in SetCompositingMode record
#define GDIP_EPRFLAGS_COMPOSITINGMODE 0x00FF

// Used in SetCompositingQuality record
#define GDIP_EPRFLAGS_COMPOSITINGQUALITY 0x00FF

// Used in SetClipRect, SetClipPath, and SetClipRegion records
#define GDIP_EPRFLAGS_COMBINEMODE     0x0F00

// Used in SetClipPath record
#define GDIP_EPRFLAGS_ISDEVICEPATH    0x2000

// Used in Header record
#define GDIP_EPRFLAGS_EMFPLUSDUAL     0x0001

inline ObjectType
GetObjectType(
    INT     flags
    )
{
    return static_cast<ObjectType>((flags & GDIP_EPRFLAGS_OBJECTTYPE) >> 8);
}

inline GpFillMode
GetFillMode(
    INT     flags
    )
{
    return ((flags & GDIP_EPRFLAGS_WINDINGFILL) == 0) ?
                FillModeAlternate : FillModeWinding;
}

inline BOOL
IsClosed(
    INT     flags
    )
{
    return ((flags & GDIP_EPRFLAGS_CLOSED) != 0);
}

inline BOOL
DidGetDC(
    INT     flags
    )
{
    return ((flags & GDIP_EPRFLAGS_DIDGETDC) != 0);
}

inline GpMatrixOrder
GetMatrixOrder(
    INT     flags
    )
{
    return ((flags & GDIP_EPRFLAGS_APPEND) == 0) ? MatrixOrderPrepend : MatrixOrderAppend;
}

inline BOOL
GetAntiAliasMode(
    INT     flags
    )
{
    return ((flags & GDIP_EPRFLAGS_ANTIALIAS) != 0);
}

inline TextRenderingHint
GetTextRenderingHint(
    INT     flags
    )
{
    return static_cast<TextRenderingHint>
        (flags & GDIP_EPRFLAGS_TEXTRENDERINGHINT);
}

inline UINT
GetTextContrast(
    INT     flags
    )
{
    return static_cast<UINT>
        (flags & GDIP_EPRFLAGS_CONTRAST);
}

inline InterpolationMode
GetInterpolationMode(
    INT     flags
    )
{
    return static_cast<InterpolationMode>
        (flags & GDIP_EPRFLAGS_INTERPOLATIONMODE);
}

inline PixelOffsetMode
GetPixelOffsetMode(
    INT     flags
    )
{
    return static_cast<PixelOffsetMode>
        (flags & GDIP_EPRFLAGS_PIXELOFFSETMODE);
}

inline GpCompositingMode
GetCompositingMode(
    INT     flags
    )
{
    return static_cast<GpCompositingMode>
        (flags & GDIP_EPRFLAGS_COMPOSITINGMODE);
}

inline GpCompositingQuality
GetCompositingQuality(
    INT     flags
    )
{
    return static_cast<GpCompositingQuality>
        (flags & GDIP_EPRFLAGS_COMPOSITINGQUALITY);
}

inline UINT
GetMetaObjectId(
    INT     flags
    )
{
    return flags & GDIP_EPRFLAGS_METAOBJECTID;
}

inline GpPageUnit
GetPageUnit(
    INT     flags
    )
{
    return static_cast<GpPageUnit>(flags & GDIP_EPRFLAGS_PAGEUNIT);
}

inline CombineMode
GetCombineMode(
    INT     flags
    )
{
    return static_cast<CombineMode>((flags & GDIP_EPRFLAGS_COMBINEMODE) >> 8);
}

inline BOOL
GetIsDevicePath(
    INT     flags
    )
{
    return ((flags & GDIP_EPRFLAGS_ISDEVICEPATH) != 0);
}

inline BOOL
GetIsEmfPlusDual(
    INT     flags
    )
{
    return ((flags & GDIP_EPRFLAGS_EMFPLUSDUAL) != 0);
}

class MetafileRecorder;
class MetafilePlayer;

class EmfPlusRecord
{
public:
    INT16           Type;
    UINT16          Flags;      // This has to be unsigned or the code breaks!
    UINT32          Size;       // Record size in bytes (including size field)
    UINT32          DataSize;   // Record size in bytes, excluding header size.
};

class EmfPlusContinueObjectRecord : public EmfPlusRecord
{
public:
    UINT32          TotalObjectSize;
};

class EmfPlusRecordPlay
{
public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        return;
    }
};

class EmfPlusHeaderRecord : public EmfPlusRecordPlay
{
public:
    INT32       Version;        // Version of the file
    INT32       EmfPlusFlags;   // flags (display and non-dual)
    INT32       LogicalDpiX;    // DpiX of referenceHdc
    INT32       LogicalDpiY;    // DpiY of referenceHdc

    EmfPlusHeaderRecord() { /* no initialization */ }
    EmfPlusHeaderRecord(INT emfPlusFlags, INT logicalDpiX, INT logicalDpiY)
    {
        Version      = EMFPLUS_VERSION;
        EmfPlusFlags = emfPlusFlags;
        LogicalDpiX  = logicalDpiX;
        LogicalDpiY  = logicalDpiY;
    }
};

#ifdef GDIP_RECORD_DEVICEBOUNDS
class EmfPlusBoundsRecord : public EmfPlusRecordPlay
{
public:
    GpRectF         DeviceBounds;
};
#else
#define EmfPlusBoundsRecord     EmfPlusRecordPlay
#endif

// When recording, we convert REAL data to INT16 data if we can without
// losing precision.
typedef struct
{
    INT16   X;
    INT16   Y;
} GpPoint16;

typedef struct
{
    INT16   X;
    INT16   Y;
    INT16   Width;
    INT16   Height;
} GpRect16;

inline BOOL
EmfHeaderIsValid(
    ENHMETAHEADER3 &        emfHeader
    )
{
    return ((emfHeader.iType == EMR_HEADER) &&
            (emfHeader.dSignature == ENHMETA_SIGNATURE) &&
            (emfHeader.nSize >= sizeof(ENHMETAHEADER3)) &&
            (emfHeader.nHandles > 0) &&
            (emfHeader.nRecords >= 2) &&    // must have at least header and EOF record
            ((emfHeader.nBytes & 3) == 0) &&
            (emfHeader.szlDevice.cx > 0) &&
            (emfHeader.szlDevice.cy > 0) &&
            (emfHeader.szlMillimeters.cx > 0) &&
            (emfHeader.szlMillimeters.cy > 0));
}

GpStatus
GetMetafileHeader(
    HMETAFILE                        hWmf,
    const WmfPlaceableFileHeader *   wmfPlaceableFileHeader,
    MetafileHeader &                 header
    );

GpStatus
GetMetafileHeader(
    HENHMETAFILE        hEmf,
    MetafileHeader &    header,
    BOOL *              isCorrupted = NULL
    );

GpStatus
GetMetafileHeader(
    IStream *           stream,
    MetafileHeader &    header,
    BOOL                tryWmfOnly = FALSE
    );

GpStatus
GetMetafileHeader(
    const WCHAR *       filename,
    MetafileHeader &    header
    );

///////////////////////////////////////////////////////////////////////////
// Stream helper methods

IStream *
CreateStreamOnFile(
    const OLECHAR * pwcsName,
    UINT            access = GENERIC_WRITE  // GENERIC_READ and/or GENERIC_WRITE
    );

inline INT
HResultSuccess(
    HRESULT     hResult
    )
{
    return (!FAILED(hResult)) ? 1 : 0;
}

inline INT
GetStreamPosition(
    IStream *               stream,
    LONGLONG &              position
    )
{
    HRESULT         hResult;
    ULARGE_INTEGER  curPosition;
    LARGE_INTEGER   zeroOffset;

    zeroOffset.QuadPart = 0;
    hResult = stream->Seek(zeroOffset, STREAM_SEEK_CUR, &curPosition);
    position = curPosition.QuadPart;
    return HResultSuccess(hResult);
}

inline INT
SeekFromHere(
    IStream *               stream,
    const LONGLONG &        offsetFromHere
    )
{
    HRESULT         hResult;
    LARGE_INTEGER   offset;

    offset.QuadPart = offsetFromHere;
    hResult = stream->Seek(offset, STREAM_SEEK_CUR, NULL);
    return HResultSuccess(hResult);
}

inline INT
SeekFromStart(
    IStream *               stream,
    const LONGLONG &        offsetFromStart
    )
{
    HRESULT         hResult;
    LARGE_INTEGER   offset;

    offset.QuadPart = offsetFromStart;
    hResult = stream->Seek(offset, STREAM_SEEK_SET, NULL);
    return HResultSuccess(hResult);
}

inline INT
CopyStream(
    IStream *               srcStream,
    IStream *               destStream,
    const LONGLONG &        bytesToCopy
    )
{
    HRESULT                 hResult;
    ULARGE_INTEGER          numBytes;
    ULARGE_INTEGER          bytesWritten;

    ASSERT (bytesToCopy > 0);

    numBytes.QuadPart = bytesToCopy;
    hResult = srcStream->CopyTo(destStream, numBytes, NULL, &bytesWritten);
    return ((!FAILED(hResult)) &&
            (bytesWritten.QuadPart == numBytes.QuadPart)) ? 1 : 0;
}

///////////////////////////////////////////////////////////////////////////
// Read methods to read values from a stream

inline INT
ReadInt16(
    IStream *           stream,
    INT16 *             value
    )
{
    ASSERT(sizeof(INT16) == 2);

    HRESULT     hResult;
    hResult = stream->Read(value, sizeof(INT16), NULL);
    return HResultSuccess(hResult);
}

inline INT
ReadInt32(
    IStream *           stream,
    INT32 *             value
    )
{
    ASSERT(sizeof(INT32) == 4);

    HRESULT     hResult;
    hResult = stream->Read(value, sizeof(INT32), NULL);
    return HResultSuccess(hResult);
}

inline INT
ReadInt32(
    IStream *           stream,
    UINT32 *            value
    )
{
    ASSERT(sizeof(UINT32) == 4);

    HRESULT     hResult;
    hResult = stream->Read(value, sizeof(UINT32), NULL);
    return HResultSuccess(hResult);
}

inline INT
ReadReal(
    IStream *           stream,
    REAL *              value
    )
{
    ASSERT(sizeof(REAL) == 4);

    HRESULT     hResult;
    hResult = stream->Read(value, sizeof(REAL), NULL);
    return HResultSuccess(hResult);
}

inline INT
ReadRect(
    IStream *           stream,
    GpRectF *           value
    )
{
    ASSERT(sizeof(GpRectF) == GDIP_RECTF_SIZE);

    HRESULT     hResult;
    hResult = stream->Read(value, sizeof(GpRectF), NULL);
    return HResultSuccess(hResult);
}

inline INT
ReadMatrix(
    IStream *           stream,
    GpMatrix *          value
    )
{
    ASSERT(sizeof(REAL) == GDIP_REAL_SIZE);

    REAL        matrix[6];
    HRESULT     hResult;
    hResult = stream->Read(matrix, GDIP_MATRIX_SIZE, NULL);
    value->SetMatrix(matrix);
    return HResultSuccess(hResult);
}

inline INT
ReadBytes(
    IStream *           stream,
    VOID *              bytes,
    INT                 count
    )
{
    ASSERT(sizeof(BYTE) == 1);

    HRESULT     hResult;
    hResult = stream->Read(bytes, count, NULL);
    return HResultSuccess(hResult);
}

inline INT
ReadPoints(
    IStream *           stream,
    GpPointF *          points,
    INT                 count
    )
{
    ASSERT(sizeof(GpPointF) == GDIP_POINTF_SIZE);

    HRESULT     hResult;
    hResult = stream->Read(points, sizeof(GpPointF) * count, NULL);
    return HResultSuccess(hResult);
}

///////////////////////////////////////////////////////////////////////////
// Write methods to write values to a stream

inline INT
WriteByte(
    IStream *           stream,
    BYTE                value
    )
{
    ASSERT(sizeof(value) == 1);

    HRESULT     hResult;
    hResult = stream->Write(&value, sizeof(value), NULL);
    return HResultSuccess(hResult);
}

inline INT
WriteInt16(
    IStream *           stream,
    INT16               value
    )
{
    ASSERT(sizeof(value) == 2);

    HRESULT     hResult;
    hResult = stream->Write(&value, sizeof(value), NULL);
    return HResultSuccess(hResult);
}

inline INT
WriteInt32(
    IStream *           stream,
    INT32               value
    )
{
    ASSERT(sizeof(value) == 4);

    HRESULT     hResult;
    hResult = stream->Write(&value, sizeof(value), NULL);
    return HResultSuccess(hResult);
}

inline INT
WriteReal(
    IStream *           stream,
    REAL                value
    )
{
    ASSERT(sizeof(value) == GDIP_REAL_SIZE);

    HRESULT     hResult;
    hResult = stream->Write(&value, sizeof(value), NULL);
    return HResultSuccess(hResult);
}

inline INT
WriteColor64(
    IStream *           stream,
    const ARGB64 &      value
    )
{
    ASSERT(sizeof(value) == 8);

    HRESULT     hResult;
    hResult = stream->Write(&value, sizeof(value), NULL);
    return HResultSuccess(hResult);
}

inline INT
WriteRect(
    IStream *           stream,
    const GpRectF &     value
    )
{
    ASSERT(sizeof(value) == GDIP_RECTF_SIZE);

    HRESULT     hResult;
    hResult = stream->Write(&value, sizeof(value), NULL);
    return HResultSuccess(hResult);
}

inline INT
WriteMatrix(
    IStream *           stream,
    const GpMatrix &    value
    )
{
    ASSERT(sizeof(REAL) == GDIP_REAL_SIZE);

    REAL        matrix[6];
    value.GetMatrix(matrix);
    HRESULT     hResult;
    hResult = stream->Write(matrix, GDIP_MATRIX_SIZE, NULL);
    return HResultSuccess(hResult);
}

inline INT
WriteBytes(
    IStream *           stream,
    const VOID *        bytes,
    INT                 count       // number of bytes
    )
{
    ASSERT(sizeof(BYTE) == 1);

    HRESULT     hResult;
    hResult = stream->Write(bytes, count, NULL);
    return HResultSuccess(hResult);
}

inline INT
WritePoints(
    IStream *           stream,
    const GpPointF *    points,
    INT                 count
    )
{
    ASSERT(sizeof(GpPointF) == GDIP_POINTF_SIZE);

    HRESULT     hResult;
    hResult = stream->Write(points, sizeof(GpPointF) * count, NULL);
    return HResultSuccess(hResult);
}

inline INT
WriteRects(
    IStream *           stream,
    const GpRectF *     rects,
    INT                 count
    )
{
    ASSERT(sizeof(GpRectF) == GDIP_RECTF_SIZE);

    HRESULT     hResult;
    hResult = stream->Write(rects, sizeof(GpRectF) * count, NULL);
    return HResultSuccess(hResult);
}

GpPointF *
GetPointsForPlayback(
    const BYTE *            pointData,
    UINT                    pointDataSize,
    INT                     count,
    INT                     flags,
    UINT                    bufferSize,
    BYTE *                  buffer,
    BYTE * &                allocedBuffer
    );

GpRectF *
GetRectsForPlayback(
    BYTE *                  rectData,
    UINT                    rectDataSize,
    INT                     count,
    INT                     flags,
    UINT                    bufferSize,
    BYTE *                  buffer,
    BYTE * &                allocedBuffer
    );

#define GDIP_POINTDATA_BUFFERSIZE   64  // Number of points for the PointBuffer
class MetafilePointData
{
public:
    MetafilePointData(const GpPointF * points, INT count);
    ~MetafilePointData() { delete [] AllocedPoints; }
    INT WriteData(IStream * stream) const { return WriteBytes(stream, PointData, PointDataSize); }
    BYTE * GetData() const { return PointData; }
    INT GetDataSize() const { return PointDataSize; }
    INT GetFlags() const { return Flags; }

protected:
    /**************************************************************************\
    *
    * Function Description:
    *
    *   Determine if a GpPointF is equal to a GpPoint16 (within the tolerance).
    *
    * Arguments:
    *
    *   [IN]  point16 - the 16-bit integer point
    *   [IN]  point   - the REAL point
    *
    * Return Value:
    *
    *   BOOL - whether or not the points are equal
    *
    * Created:
    *
    *   6/15/1999 DCurtis
    *
    \**************************************************************************/
    BOOL
    IsPoint16Equal(
        const GpPoint16 *   point16,
        const GpPointF *    point
        )
    {
        REAL    dx = point->X - (REAL)(point16->X);
        REAL    dy = point->Y - (REAL)(point16->Y);

        return ((dx > -REAL_TOLERANCE) && (dx < REAL_TOLERANCE) &&
                (dy > -REAL_TOLERANCE) && (dy < REAL_TOLERANCE));
    }

protected:
    GpPoint16       PointBuffer[GDIP_POINTDATA_BUFFERSIZE];
    BYTE *          PointData;
    GpPoint16 *     AllocedPoints;
    INT             PointDataSize;
    INT             Flags;
};

#define GDIP_RECTDATA_BUFFERSIZE    16  // Number of rects for the RectBuffer
class MetafileRectData
{
public:
    MetafileRectData(const GpRectF * rects, INT count);
    ~MetafileRectData() { delete [] AllocedRects; }
    INT WriteData(IStream * stream) const { return WriteBytes(stream, RectData, RectDataSize); }
    BYTE * GetData() const { return RectData; }
    INT GetDataSize() const { return RectDataSize; }
    INT GetFlags() const { return Flags; }

protected:
    /**************************************************************************\
    *
    * Function Description:
    *
    *   Determine if a GpRectF is equal to a GpRect16 (within the toleranc).
    *
    * Arguments:
    *
    *   [IN]  rect16 - the 16-bit integer rect
    *   [IN]  rect   - the REAL rect
    *
    * Return Value:
    *
    *   BOOL - whether or not the rects are equal
    *
    * Created:
    *
    *   6/15/1999 DCurtis
    *
    \**************************************************************************/
    BOOL
    IsRect16Equal(
        const GpRect16 *    rect16,
        const GpRectF *     rect
        )
    {
        REAL    dx = rect->X      - static_cast<REAL>(rect16->X);
        REAL    dy = rect->Y      - static_cast<REAL>(rect16->Y);
        REAL    dw = rect->Width  - static_cast<REAL>(rect16->Width);
        REAL    dh = rect->Height - static_cast<REAL>(rect16->Height);

        return ((dx > -REAL_TOLERANCE) && (dx < REAL_TOLERANCE) &&
                (dy > -REAL_TOLERANCE) && (dy < REAL_TOLERANCE) &&
                (dw > -REAL_TOLERANCE) && (dw < REAL_TOLERANCE) &&
                (dh > -REAL_TOLERANCE) && (dh < REAL_TOLERANCE));
    }

protected:
    GpRect16        RectBuffer[GDIP_RECTDATA_BUFFERSIZE];
    BYTE *          RectData;
    GpRect16 *      AllocedRects;
    INT             RectDataSize;
    INT             Flags;
};

class IMetafileRecord
{
public:
    virtual ~IMetafileRecord() {}

    virtual VOID GetMetafileBounds(GpRect & metafileBounds) const = 0;

    // Record methods to be called only from API classes

    // This is for backward compatiblity.  If we are using a new object
    // (such as a new kind of brush), then we can record a backup object
    // for down-level apps to use when they see a new object that they
    // don't know how to deal with.
    virtual GpStatus
    RecordBackupObject(
        const GpObject *            object
        ) = 0;

    virtual GpStatus
    RecordClear(
        const GpRectF *             deviceBounds,
        GpColor                     color
        ) = 0;
    virtual GpStatus
    RecordFillRects(
        const GpRectF *             deviceBounds,
        GpBrush *                   brush,
        const GpRectF *             rects,
        INT                         count
        ) = 0;
    virtual GpStatus
    RecordDrawRects(
        const GpRectF *             deviceBounds,
        GpPen *                     pen,
        const GpRectF *             rects,
        INT                         count
        ) = 0;
    virtual GpStatus
    RecordFillPolygon(
        const GpRectF *             deviceBounds,
        GpBrush*                    brush,
        const GpPointF *            points,
        INT                         count,
        GpFillMode                  fillMode
        ) = 0;
    virtual GpStatus
    RecordDrawLines(
        const GpRectF *             deviceBounds,
        GpPen *                     pen,
        const GpPointF *            points,
        INT                         count,
        BOOL                        closed
        ) = 0;
    virtual GpStatus
    RecordFillEllipse(
        const GpRectF *             deviceBounds,
        GpBrush *                   brush,
        const GpRectF &             rect
        ) = 0;
    virtual GpStatus
    RecordDrawEllipse(
        const GpRectF *             deviceBounds,
        GpPen *                     pen,
        const GpRectF &             rect
        ) = 0;
    virtual GpStatus
    RecordFillPie(
        const GpRectF *             deviceBounds,
        GpBrush *                   brush,
        const GpRectF &             rect,
        REAL                        startAngle,
        REAL                        sweepAngle
        ) = 0;
    virtual GpStatus
    RecordDrawPie(
        const GpRectF *             deviceBounds,
        GpPen *                     pen,
        const GpRectF &             rect,
        REAL                        startAngle,
        REAL                        sweepAngle
        ) = 0;
    virtual GpStatus
    RecordDrawArc(
        const GpRectF *             deviceBounds,
        GpPen *                     pen,
        const GpRectF &             rect,
        REAL                        startAngle,
        REAL                        sweepAngle
        ) = 0;
    virtual GpStatus
    RecordFillRegion(
        const GpRectF *             deviceBounds,
        GpBrush *                   brush,
        GpRegion *                  region
        ) = 0;
    virtual GpStatus
    RecordFillPath(
        const GpRectF *             deviceBounds,
        const GpBrush *             brush,
        GpPath *                    path
        ) = 0;
    virtual GpStatus
    RecordDrawPath(
        const GpRectF *             deviceBounds,
        GpPen *                     pen,
        GpPath *                    path
        ) = 0;
    virtual GpStatus
    RecordFillClosedCurve(
        const GpRectF *             deviceBounds,
        GpBrush *                   brush,
        const GpPointF *            points,
        INT                         count,
        REAL                        tension,
        GpFillMode                  fillMode
        ) = 0;
    virtual GpStatus
    RecordDrawClosedCurve(
        const GpRectF *             deviceBounds,
        GpPen *                     pen,
        const GpPointF *            points,
        INT                         count,
        REAL                        tension
        ) = 0;
    virtual GpStatus
    RecordDrawCurve(
        const GpRectF *             deviceBounds,
        GpPen *                     pen,
        const GpPointF *            points,
        INT                         count,
        REAL                        tension,
        INT                         offset,
        INT                         numberOfSegments
        ) = 0;
    virtual GpStatus
    RecordDrawBeziers(
        const GpRectF *             deviceBounds,
        GpPen *                     pen,
        const GpPointF *            points,
        INT                         count
        ) = 0;
    virtual GpStatus
    RecordDrawImage(
        const GpRectF *             deviceBounds,
        const GpImage *             image,
        const GpRectF &             destRect,
        const GpRectF &             srcRect,
        GpPageUnit                  srcUnit,
        const GpImageAttributes *         imageAttributes
        ) = 0;
    virtual GpStatus
    RecordDrawImage(
        const GpRectF *             deviceBounds,
        const GpImage *             image,
        const GpPointF *            destPoints,
        INT                         count,
        const GpRectF &             srcRect,
        GpPageUnit                  srcUnit,
        const GpImageAttributes *         imageAttributes
        ) = 0;
    virtual GpStatus
    RecordDrawString(
        const GpRectF *             deviceBounds,
        const WCHAR                *string,
        INT                         length,
        const GpFont               *font,
        const RectF                *layoutRect,
        const GpStringFormat       *format,
        const GpBrush              *brush
        ) = 0;
    virtual GpStatus
    RecordDrawDriverString(
        const GpRectF               *deviceBounds,
        const UINT16                *text,
        INT                         glyphCount,
        const GpFont                *font,
        const GpBrush               *brush,
        const PointF                *positions,
        INT                         flags,
        const GpMatrix              *matrix
        ) = 0;

    virtual GpStatus
    RecordSave(
        INT                         gstate
        ) = 0;
    virtual GpStatus
    RecordRestore(
        INT                         gstate
        ) = 0;
    virtual GpStatus
    RecordBeginContainer(
        const GpRectF &             destRect,
        const GpRectF &             srcRect,
        GpPageUnit                  srcUnit,
        INT                         containerState
        ) = 0;
    virtual GpStatus
    RecordBeginContainer(
        INT                         containerState
        ) = 0;
    virtual GpStatus
    RecordEndContainer(
        INT                         containerState
        ) = 0;
    virtual GpStatus
    RecordSetWorldTransform(
        const GpMatrix &            matrix
        ) = 0;
    virtual GpStatus
    RecordResetWorldTransform() = 0;
    virtual GpStatus
    RecordMultiplyWorldTransform(
        const GpMatrix &            matrix,
        GpMatrixOrder               order
        ) = 0;
    virtual GpStatus
    RecordTranslateWorldTransform(
        REAL                        dx,
        REAL                        dy,
        GpMatrixOrder               order
        ) = 0;
    virtual GpStatus
    RecordScaleWorldTransform(
        REAL                        sx,
        REAL                        sy,
        GpMatrixOrder               order
        ) = 0;
    virtual GpStatus
    RecordRotateWorldTransform(
        REAL                        angle,
        GpMatrixOrder               order
        ) = 0;
    virtual GpStatus
    RecordSetPageTransform(
        GpPageUnit                  unit,
        REAL                        scale
        ) = 0;
    virtual GpStatus
    RecordResetClip() = 0;
    virtual GpStatus
    RecordSetClip(
        const GpRectF &             rect,
        CombineMode                 combineMode
        ) = 0;
    virtual GpStatus
    RecordSetClip(
        GpRegion *                  region,
        CombineMode                 combineMode
        ) = 0;
    virtual GpStatus
    RecordSetClip(
        GpPath *                    path,
        CombineMode                 combineMode,
        BOOL                        isDevicePath
        ) = 0;
    virtual GpStatus
    RecordOffsetClip(
        REAL                        dx,
        REAL                        dy
        ) = 0;
    virtual GpStatus
    RecordGetDC() = 0;
    virtual GpStatus
    RecordSetAntiAliasMode(
        BOOL                        newMode
        ) = 0;
    virtual GpStatus
    RecordSetTextRenderingHint(
        TextRenderingHint           newMode
        ) = 0;
    virtual GpStatus
    RecordSetTextContrast(
        UINT                        gammaValue
        ) = 0;
    virtual GpStatus
    RecordSetInterpolationMode(
        InterpolationMode           newMode
        ) = 0;
    virtual GpStatus
    RecordSetPixelOffsetMode(
        PixelOffsetMode             newMode
        ) = 0;
    virtual GpStatus
    RecordSetCompositingMode(
        GpCompositingMode           newMode
        ) = 0;
    virtual GpStatus
    RecordSetCompositingQuality(
        GpCompositingQuality        newQuality
        ) = 0;

    virtual GpStatus
    RecordSetRenderingOrigin(
        INT x,
        INT y
    ) = 0;

    virtual GpStatus
    RecordComment(
        UINT            sizeData,
        const BYTE *    data
        ) = 0;
    virtual VOID EndRecording() = 0;
};

class GpMetafile : public GpImage
{
friend class GpGraphics;            // so graphics can call Play
friend class MetafileRecorder;      // to write Header when recording
friend class MetafilePlayer;
friend class GpObject;              // for empty constructor
public:
    // Constructors for playback only
    GpMetafile(HMETAFILE hWmf, 
               const WmfPlaceableFileHeader * wmfPlaceableFileHeader,
               BOOL deleteWmf);
    GpMetafile(HENHMETAFILE hEmf, BOOL deleteEmf);
    GpMetafile(const WCHAR* filename,
               const WmfPlaceableFileHeader * wmfPlaceableFileHeader = NULL);
    GpMetafile(IStream* stream);    // this requires an extra copy

    // Constructors for recording followed (optionally) by playback
    GpMetafile(
        HDC                 referenceHdc,
        EmfType             type        = EmfTypeEmfPlusDual,
        const GpRectF *     frameRect   = NULL,
        MetafileFrameUnit   frameUnit   = MetafileFrameUnitGdi,
        const WCHAR *       description = NULL
        );
    GpMetafile(
        const WCHAR*        fileName,
        HDC                 referenceHdc,
        EmfType             type        = EmfTypeEmfPlusDual,
        const GpRectF *     frameRect   = NULL,
        MetafileFrameUnit   frameUnit   = MetafileFrameUnitGdi,
        const WCHAR *       description = NULL
        );
    GpMetafile(                     // this requires an extra copy
        IStream*            stream,
        HDC                 referenceHdc,
        EmfType             type        = EmfTypeEmfPlusDual,
        const GpRectF *     frameRect   = NULL,
        MetafileFrameUnit   frameUnit   = MetafileFrameUnitGdi,
        const WCHAR *       description = NULL
        );

    // Make a copy of the image object
    virtual GpImage* Clone() const;

    virtual GpImage* CloneColorAdjusted(
        GpRecolor *             recolor,
        ColorAdjustType         adjustType = ColorAdjustTypeDefault
        ) const;

    // Dispose of the image object
    virtual VOID Dispose();

    // Derive a graphics context to draw into the GpImage object
    virtual GpGraphics* GetGraphicsContext();

    // When deleting the metafile, we have to lock the graphics, so
    // no one can use the graphics while the metafile is being deleted --
    // so we need a private method to get the graphics just for that purpose.

    // Also, when setting the down-level rasterization limit, we have to
    // make sure the graphics is locked as well as the metafile, so we
    // use this method for that too.
    GpGraphics* PrivateAPIForGettingMetafileGraphicsContext() const
    {
        // If they haven't requested the graphics, then we don't need
        // to worry about locking it.
        return (RequestedMetaGraphics) ? MetaGraphics : NULL;
    }

    // Check if the GpImage object is valid
    virtual BOOL IsValid() const
    {
        // If the metafile came from a different version of GDI+, its tag
        // will not match, and it won't be considered valid.
        return ((State >= RecordingMetafileState) &&
                (State <= PlayingMetafileState) &&
                GpImage::IsValid());
    }

    virtual BOOL IsCorrupted() const
    {
        return (State == CorruptedMetafileState);
    }

    VOID
    GetHeader(
        MetafileHeader &    header
        ) const
    {
        ASSERT(IsValid());
        header = Header;
    }

    // Is this an EMF or EMF+ file?
    BOOL IsEmfOrEmfPlus() const { return Header.IsEmfOrEmfPlus(); }

    GpStatus GetHemf(HENHMETAFILE *  hEmf) const;

    GpStatus PlayRecord(
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize,
        const BYTE *            data
        ) const;

    VOID SetThreadId(DWORD threadId) const { ThreadId = threadId; }
    DWORD GetThreadId() const { return ThreadId; }

    // Create a bitmap and play the metafile into it.
    GpBitmap *
    GetBitmap(
        INT                 width           = 0,    // 0 means figure use default size
        INT                 height          = 0,
        const GpImageAttributes * imageAttributes = NULL
        );

    ////////////////////////////////////////////////////////////
    // GpObject virtual methods
    ////////////////////////////////////////////////////////////

    virtual UINT GetDataSize() const;
    virtual GpStatus GetData(IStream * stream) const;
    virtual GpStatus SetData(const BYTE * dataBuffer, UINT size);

    virtual GpStatus ColorAdjust(
        GpRecolor *             recolor,
        ColorAdjustType         adjustType
        );

    ////////////////////////////////////////////////////////////
    // GpImage virtual methods
    ////////////////////////////////////////////////////////////


    // Get metafile resolution

    virtual GpStatus
    GetResolution(
        REAL* xdpi,
        REAL* ydpi
    ) const
    {
        ASSERT(IsValid());

        *xdpi = Header.GetDpiX();
        *ydpi = Header.GetDpiY();

        return Ok;
    }

    // Get metafile physical dimension in 0.01mm units
    virtual GpStatus
    GetPhysicalDimension(
        REAL* width,
        REAL* height
    ) const
    {
        ASSERT(IsValid());

        const MetafileHeader *      header = &Header;

        if (header->IsEmfOrEmfPlus())
        {
            // Don't forget to add one Device Unit
            *width  = (REAL)(header->EmfHeader.rclFrame.right -
                             header->EmfHeader.rclFrame.left) + 
                             2540.0f / (header->GetDpiX());
            *height = (REAL)(header->EmfHeader.rclFrame.bottom -
                             header->EmfHeader.rclFrame.top) +
                             2540.0f / (header->GetDpiY());
        }
        else
        {
            *width  = ((REAL)(header->Width)  / (header->GetDpiX())) * 2540.0f;
            *height = ((REAL)(header->Height) / (header->GetDpiY())) * 2540.0f;
        }

        return Ok;
    }

    // Get metafile bounding rectangle in pixels
    virtual GpStatus
    GetBounds(
        GpRectF* rect,
        GpPageUnit* unit
    ) const
    {
        ASSERT(IsValid());

        const MetafileHeader *      header = &Header;

#if 0
        if (header->IsEmfOrEmfPlus())
        {
            rect->X      = (REAL)(header->EmfHeader.rclFrame.left) / 2540.0f;
            rect->Y      = (REAL)(header->EmfHeader.rclFrame.top)  / 2540.0f;
            rect->Width  = (REAL)(header->EmfHeader.rclFrame.right -
                                  header->EmfHeader.rclFrame.left) / 2540.0f;
            rect->Height = (REAL)(header->EmfHeader.rclFrame.bottom -
                                  header->EmfHeader.rclFrame.top)  / 2540.0f;
        }
        else
        {
            rect->X      = header->X      / header->GetDpiX();
            rect->Width  = header->Width  / header->GetDpiX();
            rect->Y      = header->Y      / header->GetDpiY();
            rect->Height = header->Height / header->GetDpiY();
        }
        *unit = UnitInch;
#else
        rect->X      = (REAL)header->X;
        rect->Width  = (REAL)header->Width;
        rect->Y      = (REAL)header->Y;
        rect->Height = (REAL)header->Height;
        *unit = UnitPixel;
#endif

        return Ok;
    }

    virtual GpStatus GetImageInfo(ImageInfo* imageInfo) const;

    virtual GpImage* GetThumbnail(UINT thumbWidth, UINT thumbHeight,
                         GetThumbnailImageAbort callback, VOID *callbackData)
    {
        if ((thumbWidth == 0) && (thumbHeight == 0))
        {
            thumbWidth = thumbHeight = DEFAULT_THUMBNAIL_SIZE;
        }
        if ((thumbWidth > 0) && (thumbHeight > 0))
        {
            return this->GetBitmap(thumbWidth, thumbHeight);
        }
        return NULL;
    }

    virtual GpStatus GetPalette(ColorPalette *palette, INT size)
    {
        return NotImplemented;  // There is no palette support for metafiles
    }

    virtual GpStatus SetPalette(ColorPalette *palette)
    {
        return NotImplemented;
    }

    virtual INT GetPaletteSize() { return 0; }

    // Save images
    // !!!TODO: save functionality?

    virtual GpStatus
    GetEncoderParameterListSize(
        CLSID* clsidEncoder,
        UINT* size
        )
    {
        // Create a new temp bitmap to query
        GpStatus status = OutOfMemory;
        GpBitmap *bitmap = new GpBitmap(1, 1, PixelFormat32bppARGB);
        if (bitmap != NULL)
        {
            if (bitmap->IsValid())
            {
                status = bitmap->GetEncoderParameterListSize(clsidEncoder, size);
            }
            bitmap->Dispose();
        }
        return status;
    }

    virtual GpStatus
    GetEncoderParameterList(
        CLSID* clsidEncoder,
        UINT size,
        EncoderParameters* pBuffer
        )
    {
        GpStatus status = OutOfMemory;
        GpBitmap *bitmap = new GpBitmap(1, 1, PixelFormat32bppARGB);
        if (bitmap != NULL)
        {
            if (bitmap->IsValid())
            {
                status = bitmap->GetEncoderParameterList(clsidEncoder, size, pBuffer);
            }
            bitmap->Dispose();
        }
        return status;
    }

    virtual GpStatus
    SaveToStream(
        IStream* stream,
        CLSID* clsidEncoder,
        EncoderParameters* encoderParams
        )
    {
        GpStatus status = GenericError;
        GpBitmap *bitmap = GetBitmap();
        if (bitmap != NULL)
        {
            status = bitmap->SaveToStream(stream, clsidEncoder, encoderParams);
            bitmap->Dispose();
        }
        return status;
    }

    virtual GpStatus
    SaveToFile(
        const WCHAR* filename,
        CLSID* clsidEncoder,
        EncoderParameters* encoderParams
        )
    {
        GpStatus status = GenericError;
        GpBitmap *bitmap = GetBitmap();
        if (bitmap != NULL)
        {
            status = bitmap->SaveToFile(filename, clsidEncoder, encoderParams);
            bitmap->Dispose();
        }
        return status;
    }

    GpStatus
    SaveAdd(
        const EncoderParameters* encoderParams
        )
    {
        return NotImplemented;
    }

    GpStatus
    SaveAdd(
        GpImage* newBits,
        const EncoderParameters* encoderParams
        )
    {
        return NotImplemented;
    }

    // !!!TODO: what do I do with the dimensionID?
    virtual GpStatus GetFrameCount(const GUID* dimensionID, UINT* count) const
    {
        if (count != NULL)
        {
            *count = 1;
            return Ok;
        }
        return InvalidParameter;
    }

    virtual GpStatus GetFrameDimensionsCount(OUT UINT* count) const
    {
        if (count != NULL)
        {
            *count = 1;
            return Ok;
        }
        return InvalidParameter;
    }

    virtual GpStatus GetFrameDimensionsList(OUT GUID* dimensionIDs,
                                            IN UINT count) const
    {
        // Note: the "count" has to be 1
        if ((count == 1) && (dimensionIDs != NULL))
        {
            dimensionIDs[0] = FRAMEDIM_PAGE;
            return Ok;
        }
        return InvalidParameter;
    }

    virtual GpStatus SelectActiveFrame(const GUID* dimensionID, UINT index)
    {
        // There is only 1 frame in a metafile, so we always succeed
        return Ok;
    }

    virtual GpStatus RotateFlip(RotateFlipType rfType)
    {
        return NotImplemented;
    }

    virtual GpStatus GetPropertyCount(UINT* numOfProperty)
    {
        if (numOfProperty != NULL)
        {
            *numOfProperty = 0;
            return Ok;
        }
        return InvalidParameter;
    }

    virtual GpStatus GetPropertyIdList(UINT numOfProperty, PROPID* list)
    {
        if (list != NULL)
        {
            return NotImplemented;
        }
        return InvalidParameter;
    }

    virtual GpStatus GetPropertyItemSize(PROPID propId, UINT* size)
    {
        if (size != NULL)
        {
            return NotImplemented;
        }
        return InvalidParameter;
    }

    virtual GpStatus GetPropertyItem(PROPID propId,UINT propSize, PropertyItem* buffer)
    {
        if (buffer != NULL)
        {
            return NotImplemented;
        }
        return InvalidParameter;
    }

    virtual GpStatus GetPropertySize(UINT* totalBufferSize, UINT* numProperties)
    {
        if ((totalBufferSize != NULL) && (numProperties != NULL))
        {
            return NotImplemented;
        }
        return InvalidParameter;
    }

    virtual GpStatus GetAllPropertyItems(UINT totalBufferSize, UINT numProperties,
                                 PropertyItem* allItems)
    {
        if (allItems != NULL)
        {
            return NotImplemented;
        }
        return InvalidParameter;
    }

    virtual GpStatus RemovePropertyItem(PROPID propId)
    {
        return NotImplemented;
    }

    virtual GpStatus SetPropertyItem(PropertyItem* item)
    {
        return NotImplemented;
    }

    GpStatus
    SetDownLevelRasterizationLimit(
        UINT                    metafileRasterizationLimitDpi
        );

    GpStatus
    GetDownLevelRasterizationLimit(
        UINT *                  metafileRasterizationLimitDpi
        ) const;

protected:
    enum MetafileState
    {
        InvalidMetafileState,
        CorruptedMetafileState,
        RecordingMetafileState,
        DoneRecordingMetafileState,
        ReadyToPlayMetafileState,
        PlayingMetafileState,
    };
    MetafileHeader              Header;
    mutable DWORD               ThreadId;       // for syncing enumeration
    mutable MetafileState       State;
    mutable HENHMETAFILE        Hemf;           // for playing metafiles
    WCHAR *                     Filename;
    IStream *                   Stream;
    GpGraphics *                MetaGraphics;   // for recording to metafile
    mutable MetafilePlayer *    Player;         // for playing the metafile
    INT                         MaxStackSize;
    BOOL                        DeleteHemf;
    BOOL                        RequestedMetaGraphics;

    // Dummy constructors and destructors to prevent
    // apps from directly using new and delete operators
    // on GpImage objects.

    GpMetafile() : GpImage(ImageTypeMetafile) { /* used by object factory */ InitDefaults(); }
    ~GpMetafile();

    VOID InitDefaults();
    VOID CleanUp();

    BOOL
    InitForRecording(
        HDC                 referenceHdc,
        EmfType             type,
        const GpRectF *     frameRect,      // can be NULL
        MetafileFrameUnit   frameUnit,      // if NULL frameRect, doesn't matter
        const WCHAR *       description     // can be NULL
        );

    GpStatus
    PrepareToPlay(
        GpGraphics *            g,
        GpRecolor *             recolor,
        ColorAdjustType         adjustType,
        EnumerateMetafileProc   enumerateCallback,
        VOID *                  callbackData,
        DrawImageAbort          drawImageCallback,
        VOID*                   drawImageCallbackData
        ) const;

    GpStatus
    EnumerateForPlayback(
        const RectF &           destRect,
        const RectF &           srcRect,
        Unit                    srcUnit,
        GpGraphics *            g,
        EnumerateMetafileProc   callback,   // if null, just play the metafile
        VOID *                  callbackData,
        GpRecolor *             recolor               = NULL,
        ColorAdjustType         adjustType            = ColorAdjustTypeDefault,
        DrawImageAbort          drawImageCallback     = NULL,
        VOID*                   drawImageCallbackData = NULL
        ) const;

    // Play is only to be called by GpGraphics::DrawImage()
    GpStatus
    Play(
        const GpRectF&          destRect,
        const GpRectF&          srcRect,
        GpPageUnit              srcUnit,
        GpGraphics *            graphics,
        GpRecolor *             recolor               = NULL,
        ColorAdjustType         adjustType            = ColorAdjustTypeDefault,
        DrawImageAbort          drawImageCallback     = NULL,
        VOID*                   drawImageCallbackData = NULL
        ) const
    {
        return EnumerateForPlayback(
                    destRect,
                    srcRect,
                    srcUnit,
                    graphics,
                    NULL,
                    NULL,
                    recolor,
                    adjustType,
                    drawImageCallback,
                    drawImageCallbackData
                    );
    }

    VOID
    InitWmf(
        HMETAFILE                        hWmf,
        const WmfPlaceableFileHeader *   wmfPlaceableFileHeader,
        BOOL                             deleteWmf
        );

    VOID
    InitEmf(
        HENHMETAFILE                     hEmf,
        BOOL                             deleteEmf
        );                      
                                
    VOID                        
    InitStream(                 
        IStream*                         stream,
        BOOL                             tryWmfOnly = FALSE
        );
};




HENHMETAFILE
GetEmf(
    const WCHAR *       fileName,
    MetafileType        type
    );


// GillesK 05/12/2000
// Data types needed for WMF to EMF conversion.
#pragma pack(2)

typedef struct _META_ESCAPE_ENHANCED_METAFILE {
    DWORD       rdSize;             // Size of the record in words
    WORD        rdFunction;         // META_ESCAPE
    WORD        wEscape;            // MFCOMMENT
    WORD        wCount;             // Size of the following data + emf in bytes
    DWORD       ident;              // MFCOMMENT_IDENTIFIER
    DWORD       iComment;           // MFCOMMENT_ENHANCED_METAFILE
    DWORD       nVersion;           // Enhanced metafile version 0x10000
    WORD        wChecksum;          // Checksum - used by 1st record only
    DWORD       fFlags;             // Compression etc - used by 1st record only
    DWORD       nCommentRecords;    // Number of records making up the emf
    DWORD       cbCurrent;          // Size of emf data in this record in bytes
    DWORD       cbRemainder;        // Size of remainder in following records
    DWORD       cbEnhMetaFile;      // Size of enhanced metafile in bytes
                                    // The enhanced metafile data follows here
} META_ESCAPE_ENHANCED_METAFILE;
typedef META_ESCAPE_ENHANCED_METAFILE UNALIGNED *PMETA_ESCAPE_ENHANCED_METAFILE;
#pragma pack()

// Macro to check that it is a meta_escape embedded enhanced metafile record.

inline BOOL IsMetaEscapeEnhancedMetafile(
    PMETA_ESCAPE_ENHANCED_METAFILE pmfeEnhMF
    )
{
        return ((pmfeEnhMF)->rdFunction == META_ESCAPE
      && (pmfeEnhMF)->rdSize     >  sizeof(META_ESCAPE_ENHANCED_METAFILE) / 2
      && (pmfeEnhMF)->wEscape    == MFCOMMENT
      && (pmfeEnhMF)->ident      == MFCOMMENT_IDENTIFIER
      && (pmfeEnhMF)->iComment   == MFCOMMENT_ENHANCED_METAFILE) ;
}

// Macro to check the checksum of an EMF file

inline WORD GetWordCheckSum(UINT cbData, PWORD pwData)
{
    WORD   wCheckSum = 0;
    UINT   cwData = cbData / sizeof(WORD);

    ASSERTMSG(!(cbData%sizeof(WORD)), ("GetWordCheckSum data not WORD multiple"));
    ASSERTMSG(!((ULONG_PTR)pwData%sizeof(WORD)), ("GetWordCheckSum data not WORD aligned"));

    while (cwData--)
        wCheckSum += *pwData++;

    return(wCheckSum);
}

extern "C"
UINT ConvertEmfToPlaceableWmf
(   HENHMETAFILE hemf,
    UINT         cbData16,
    LPBYTE       pData16,
    INT          iMapMode,
    INT          eFlags );





#endif // !_METAFILE_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\iterator.hpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Iterator definitions.
*
* Abstract:
*
*   Describes a general iterator interface.
*
* Created:
*
*   09/01/2000 asecchia
*      Created it.
*
**************************************************************************/

#ifndef _ITERATOR_HPP
#define _ITERATOR_HPP

/**************************************************************************\
*
* Class Description:
*
*    This is an interface for a general list iterator.
*    See Design Patterns (Erich Gamma, et al) pp 257 ITERATOR pattern.
*
* Interface:
*    SeekFirst()     - set the current pointer (CP) to the beginning of the list
*    SeekLast()      - set CP to the end of the list.
*    CurrentItem()   - return a pointer to the current item.
*    CurrentIndex()  - return the value of CP (index into the array)
*    Next()          - advance CP by one element
*    Prev()          - rewind CP by one element
*    IsDone()        - are we beyond either end of the list.
*
* History:
*
*   09/01/2000 asecchia   created it
*
\**************************************************************************/

template<class T>
class GpIterator
{
public:
    virtual void SeekFirst() = 0;         
    virtual void SeekLast() = 0;
    virtual T *CurrentItem() const = 0;
    virtual INT CurrentIndex() const = 0;
    virtual void Next() = 0;
    virtual void Prev() = 0;
    virtual BOOL IsDone() = 0;
    
    // Used for our debug tracking. Make all GpIterator objects allocated using
    // the default new operator have an appropriate tag.
    // Most often, however, iterators will be stack allocations.
    
    void *(operator new)(size_t in_size)
    {
       return ::operator new (in_size, GpIteratorTag, FALSE);
    }
    
    void *(operator new[])(size_t in_size)
    {
       return ::operator new[] (in_size, GpIteratorTag, FALSE);
    }

};

/**************************************************************************\
*
* Class Description:
*
*    This is a PROXY iterator that adds the behaviour of 
*    wrapping the list when the end is encountered.
* 
*    See Design Patterns (Erich Gamma, et al) pp 207 for the 
*    definition of a PROXY 
*
* Interface:
*    ... see GpIterator ...
*    IsDone()        - private - unimplemented. Not meaningful for 
*                      circular lists
*
* History:
*
*   09/01/2000 asecchia   created it
*
\**************************************************************************/

template<class T>
class GpCircularIterator : public GpIterator<T>
{
    GpIterator<T> *iterator;
public:
    GpCircularIterator(GpIterator<T> *_iterator)
    {
        iterator = _iterator;
    }
    
    virtual void SeekFirst()
    {
        iterator->SeekFirst();
    }
    
    virtual void SeekLast()
    {
        iterator->SeekLast();
    }
    
    virtual void Next()
    {
        ASSERT(!iterator->IsDone());
        
        iterator->Next();
        if(iterator->IsDone())
        {
            iterator->SeekFirst();
        }
    }
    
    virtual void Prev()
    {
        ASSERT(!iterator->IsDone());
        
        iterator->Prev();
        if(iterator->IsDone())
        {
            iterator->SeekLast();
        }
    }
    virtual T *CurrentItem() const
    {
        return iterator->CurrentItem();
    }
    
    virtual INT CurrentIndex() const
    {
        return iterator->CurrentIndex();
    }
    
private:

    // It's not meaningful to call IsDone on a circular iterator.
    
    virtual BOOL IsDone() {
        ASSERT(FALSE);
        return FALSE;
    }
};

/**************************************************************************\
*
* Class Description:
*
*    This is a PROXY iterator that modifies the behaviour of the 
*    underlying iterator by making it traverse the list backwards.
*
* Interface:
*    ... see GpIterator ...
*
*    Note the sense of the following interfaces is reversed.
*
*    SeekFirst()     - Call proxy SeekLast()
*    SeekLast()      - Call proxy SeekFirst()
*    Next()          - Call proxy Prev()
*    Prev()          - Call proxy Next()
*
* History:
*
*   09/01/2000 asecchia   created it
*
\**************************************************************************/

template<class T>
class GpReverseIterator : public GpIterator<T>
{
    GpIterator<T> *iterator;
    
public:
    GpReverseIterator(GpIterator<T> *_iterator)
    {
        iterator = _iterator;
    }
    
    virtual GpIterator<T> *GetIterator()
    {
        return iterator;
    }
    
    virtual void SeekFirst()
    {
        iterator->SeekLast();
    }
    
    virtual void SeekLast()
    {
        iterator->SeekFirst();
    }
    
    virtual void Next()
    {
        iterator->Prev();
    }
    
    virtual void Prev()
    {
        iterator->Next();
    }
    
    virtual T *CurrentItem() const
    {
        return iterator->CurrentItem();
    }
    
    virtual INT CurrentIndex() const
    {
        return iterator->CurrentIndex();
    }
    
    virtual BOOL IsDone() 
    {
        return iterator->IsDone();
    }
};

/**************************************************************************\
*
* Class Description:
*
*    This is a concrete iterator for an arbitrary C array of objects
*    The constructor takes the array pointer and the number of elements
*    and the iterator is constructed to traverse the elements in the
*    standard (forward) direction.
*
* Interface:
*    ... see GpIterator ...
*
* History:
*
*   09/01/2000 asecchia   created it
*
\**************************************************************************/

template<class T>
class GpArrayIterator : public GpIterator<T>
{
public:
    GpArrayIterator(T *array, INT count)
    {
        Array = array;
        Count = count;
        SeekFirst();
    }
    
    virtual void SeekFirst() 
    { 
        CurrentItemPosition = 0; 
    }
    
    virtual void SeekLast() 
    { 
        CurrentItemPosition = Count-1; 
    }
    
    virtual T *CurrentItem() const
    {
        ASSERT(CurrentItemPosition >= 0);
        ASSERT(CurrentItemPosition < Count);
        
        return Array+CurrentItemPosition;
    }
    
    virtual INT CurrentIndex() const
    {
        return CurrentItemPosition;
    }
    
    virtual void Next()
    {
        CurrentItemPosition++;
    }
    
    virtual void Prev()
    {
        CurrentItemPosition--;
    }
    
    virtual BOOL IsDone()
    {
        return (CurrentItemPosition < 0 || 
                CurrentItemPosition >= Count);
    }
    
private:
    T *Array;
    INT Count;
    
    // Internal State
    INT CurrentItemPosition;
};


/**************************************************************************\
*
* Class Description:
*
*    This is a concrete iterator for a set of path points.
*    Path points are defined by an array of GpPointFs and an array
*    of BYTEs representing the point types. Both arrays are of size
*    count and have to be kept in step with each other.
*
* Interface:
*    ... see GpIterator ...
*
*    We extend the interface with this class by defining the 
*    point array to be the primary sub iterator and providing
*    a CurrentType() method to return the current item in the 
*    type array.
*
* History:
*
*   09/03/2000 asecchia   created it
*
\**************************************************************************/

class GpPathPointIterator : public GpIterator<GpPointF>
{
public:
    GpPathPointIterator(GpPointF *points, BYTE *types, INT count) : 
        _points(points, count),
        _types(types, count)
    {
        SeekFirst();
    }
    virtual void SeekFirst() 
    { 
        _points.SeekFirst();
        _types.SeekFirst();
    }
    
    virtual void SeekLast() 
    { 
        _points.SeekLast();
        _types.SeekLast();
    }
    
    virtual GpPointF *CurrentItem() const
    {
        return _points.CurrentItem();
    }
    
    virtual BYTE *CurrentType() const
    {
        return _types.CurrentItem();
    }
    
    virtual INT CurrentIndex() const
    {
        return _points.CurrentIndex();
    }
    
    virtual void Next()
    {
        _points.Next();
        _types.Next();   
    }
    
    virtual void Prev()
    {
        _points.Prev();
        _types.Prev();
    }
    
    virtual BOOL IsDone()
    {
        return _points.IsDone();
    }
    
private:
    GpArrayIterator<GpPointF> _points;
    GpArrayIterator<BYTE> _types;
};

/**************************************************************************\
*
* Class Description:
*
*    This is a PROXY iterator for a GpPathPointIterator that advances
*    the base GpPathPointIterator to the next subpath defined by the 
*    start marker in the types array.
*
* Interface:
*    ... see GpIterator ...
*
* History:
*
*   09/03/2000 asecchia   created it
*
\**************************************************************************/

class GpSubpathIterator : public GpIterator<GpPointF>
{
public:
    GpSubpathIterator(GpPathPointIterator *iterator)
    {
        _iterator = iterator;
    }
    
    virtual void SeekFirst() 
    {
        _iterator->SeekFirst(); 
    }
    
    virtual void SeekLast()
    { 
        _iterator->SeekLast(); 
    }
    
    virtual GpPointF *CurrentItem() const { return _iterator->CurrentItem(); }
    virtual BYTE *CurrentType() const { return _iterator->CurrentType(); }
    virtual INT CurrentIndex() const { return _iterator->CurrentIndex(); }
    
    virtual void Next() 
    {
        // Call the base _iterator Next() method till either we run out of
        // path or we encounter another PathPointTypeStart marker.
        
        do {
            _iterator->Next(); 
        } while (
            !_iterator->IsDone() && 
            ((*_iterator->CurrentType() & PathPointTypePathTypeMask) != 
                PathPointTypeStart)
        );
    }
    
    virtual void Prev() 
    { 
        // Call the base _iterator Prev() method till either we run out of
        // path or we encounter another PathPointTypeStart marker.
        
        do {
            _iterator->Prev(); 
        } while (
            !_iterator->IsDone() && 
            ((*_iterator->CurrentType() & PathPointTypePathTypeMask) != 
                PathPointTypeStart)
        );
    }
    
    virtual BOOL IsDone() { return _iterator->IsDone(); }
    
private:
    GpPathPointIterator *_iterator;
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\metaplay.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   MetaFile.cpp
*
* Abstract:
*
*   Metafile object handling
*
* Created:
*
*   4/14/1999 DCurtis
*
\**************************************************************************/

#include "precomp.hpp"
#include "MetaWmf.hpp"

#define GDIP_TRANSPARENT_COLOR_KEY  0xAA0D0B0C
#define GDIP_WMF_PLACEABLEKEY       0x9AC6CDD7      // for Placeable WMFs
#define GDIP_DO_CALLBACK_MASK       0x00000003      // when to do callback

// Metafile constants not in Windows.h
#define METAVERSION300              0x0300
#define METAVERSION100              0x0100
#define MEMORYMETAFILE              1
#define DISKMETAFILE                2


typedef VOID (EmfPlusRecordPlay::*PLAYRECORDFUNC)(MetafilePlayer * player, EmfPlusRecordType recordType, UINT flags, UINT dataSize) const;
PLAYRECORDFUNC RecordPlayFuncs[];

/**************************************************************************\
*
* Function Description:
*
*   If the points were stored as 16-bit points, then convert them back to
*   REAL points.  Otherwise, just return convert the point data pointer
*   to a REAL point pointer and return.
*
* Arguments:
*
*   [IN]     pointData     - the point data that was recorded
*   [IN]     count         - the number of points
*   [IN]     flags         - says if the point data is 16-bit points or not
*   [IN]     bufferSize    - the size of the buffer
*   [IN/OUT] buffer        - for converting back to REAL points
*   [IN/OUT] allocedBuffer - if buffer not big enough, alloc new one here
*
* Return Value:
*
*   GpPointF * - the REAL points to play back
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpPointF *
GetPointsForPlayback(
    const BYTE *            pointData,
    UINT                    pointDataSize,
    INT                     count,
    INT                     flags,
    UINT                    bufferSize,
    BYTE *                  buffer,
    BYTE * &                allocedBuffer
    )
{
    GpPointF *      points = NULL;

    if (count > 0)
    {
        if ((flags & GDIP_EPRFLAGS_COMPRESSED) != 0)
        {
            if (pointDataSize >= (sizeof(GpPoint16) * count))
            {
                UINT    sizePoints = count * sizeof(GpPointF);

                if (sizePoints <= bufferSize)
                {
                    points = reinterpret_cast<GpPointF *>(buffer);
                }
                else
                {
                    if ((allocedBuffer = new BYTE[sizePoints]) == NULL)
                    {
                        return NULL;
                    }
                    points = reinterpret_cast<GpPointF *>(allocedBuffer);
                }
                const GpPoint16 *  points16 =
                                    reinterpret_cast<const GpPoint16 *>(pointData);
                do
                {

                    count--;
                    points[count].X = points16[count].X;
                    points[count].Y = points16[count].Y;
                } while (count > 0);
            }
            else
            {
                WARNING(("pointDataSize is too small"));
            }
        }
        else if (pointDataSize >= (sizeof(GpPointF) * count))
        {
            points = (GpPointF *)(pointData);
        }
        else
        {
            WARNING(("pointDataSize is too small"));
        }
    }
    return points;
}

/**************************************************************************\
*
* Function Description:
*
*   If the rects were stored as 16-bit rects, then convert them back to
*   REAL rects.  Otherwise, just return convert the rect data pointer
*   to a REAL rect pointer and return.
*
* Arguments:
*
*   [IN]     rectData      - the rect data that was recorded
*   [IN]     count         - the number of rects
*   [IN]     flags         - says if the point data is 16-bit rects or not
*   [IN]     bufferSize    - the size of the buffer
*   [IN/OUT] buffer        - for converting back to REAL rects
*   [IN/OUT] allocedBuffer - if buffer not big enough, alloc new one here
*
* Return Value:
*
*   GpPointF * - the REAL points to play back
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpRectF *
GetRectsForPlayback(
    const BYTE *            rectData,
    UINT                    rectDataSize,
    INT                     count,
    INT                     flags,
    UINT                    bufferSize,
    BYTE *                  buffer,
    BYTE * &                allocedBuffer
    )
{
    GpRectF *   rects = NULL;

    if (count > 0)
    {
        if ((flags & GDIP_EPRFLAGS_COMPRESSED) != 0)
        {
            if (rectDataSize >= (sizeof(GpRect16) * count))
            {
                UINT    sizeRects = count * sizeof(GpRectF);

                if (sizeRects <= bufferSize)
                {
                    rects = reinterpret_cast<GpRectF *>(buffer);
                }
                else
                {
                    if ((allocedBuffer = new BYTE[sizeRects]) == NULL)
                    {
                        return NULL;
                    }
                    rects = reinterpret_cast<GpRectF *>(allocedBuffer);
                }
                const GpRect16 *  rects16 =
                                    reinterpret_cast<const GpRect16 *>(rectData);
                do
                {

                    count--;
                    rects[count].X      = rects16[count].X;
                    rects[count].Y      = rects16[count].Y;
                    rects[count].Width  = rects16[count].Width;
                    rects[count].Height = rects16[count].Height;
                } while (count > 0);
            }
            else
            {
                WARNING(("rectDataSize is too small"));
            }
        }
        else if (rectDataSize >= (sizeof(GpRectF) * count))
        {
            rects = (GpRectF *)(rectData);
        }
        else
        {
            WARNING(("rectDataSize is too small"));
        }
    }
    return rects;
}

inline INT16
GetWmfPlaceableCheckSum(
    const WmfPlaceableFileHeader *     wmfPlaceableFileHeader
    )
{
    const INT16 * headerWords = (const INT16 *)wmfPlaceableFileHeader;
    INT16         checkSum = *headerWords++;

    for (INT i = 9; i > 0; i--)
    {
        checkSum ^= *headerWords++;
    }
    return checkSum;
}

inline BOOL
WmfPlaceableHeaderIsValid(
    const WmfPlaceableFileHeader *   wmfPlaceableFileHeader
    )
{
    ASSERT(wmfPlaceableFileHeader != NULL);

    return ((wmfPlaceableFileHeader->Key == GDIP_WMF_PLACEABLEKEY) &&
            (wmfPlaceableFileHeader->Checksum == GetWmfPlaceableCheckSum(wmfPlaceableFileHeader)) &&
            (wmfPlaceableFileHeader->BoundingBox.Left !=
             wmfPlaceableFileHeader->BoundingBox.Right) &&
            (wmfPlaceableFileHeader->BoundingBox.Top !=
             wmfPlaceableFileHeader->BoundingBox.Bottom));
}

inline BOOL
WmfHeaderIsValid(
    const METAHEADER *      wmfHeader
    )
{
    return  (((wmfHeader->mtType == MEMORYMETAFILE) ||
              (wmfHeader->mtType == DISKMETAFILE)) &&
             (wmfHeader->mtHeaderSize == (sizeof(METAHEADER)/sizeof(WORD))) &&
             ((wmfHeader->mtVersion == METAVERSION300) ||
              (wmfHeader->mtVersion ==METAVERSION100)));
}

VOID
Init32BppDibToTransparent(
    UINT32 *                bits,
    UINT                    numPixels
    );

GpStatus
Draw32BppDib(
    GpGraphics *            g,
    UINT32 *                bits,
    INT                     width,
    INT                     height,
    const GpRectF &         destRect,
    REAL                    dpi,
    BOOL                    compareAlpha
    );

extern "C"
BOOL CALLBACK
GdipPlayMetafileRecordCallback(
    EmfPlusRecordType       recordType,
    UINT                    recordFlags,
    UINT                    recordDataSize,
    const BYTE *            recordData,
    VOID *                  callbackData    // player
    );

// This method (defined below) enumerates/plays EMF+ comment records and also
// plays down-level GDI records, when appropriate.
extern "C"
int CALLBACK
EnumEmfWithDownLevel(
    HDC                     hdc,
    HANDLETABLE FAR *       gdiHandleTable,
    CONST ENHMETARECORD *   emfRecord,
    int                     numHandles,
    LPARAM                  play
    );

extern "C"
int CALLBACK
EnumEmfDownLevel(
    HDC                     hdc,
    HANDLETABLE FAR *       gdiHandleTable,
    CONST ENHMETARECORD *   emfRecord,
    int                     numHandles,
    LPARAM                  play
    );

extern "C"
int CALLBACK
EnumEmfToStream(
    HDC                     hdc,
    HANDLETABLE FAR *       gdiHandleTable,
    CONST ENHMETARECORD *   emfRecord,
    int                     numHandles,
    LPARAM                  stream
    );

// Separate this out so we can initialize it to 0 all at once
class MetafilePlayerBuffers
{
protected:
    BYTE                RecordBuffer  [GDIP_METAFILE_BUFFERSIZE];
    BYTE                PointsBuffer  [GDIP_METAFILE_BUFFERSIZE];
    GpObject *          ObjectList    [GDIP_MAX_OBJECTS];
    INT                 MemberStack   [GDIP_SAVE_STACK_SIZE];
    GpObject *          BackupObject  [ObjectTypeMax - ObjectTypeMin + 1];
};

class MetafilePlayer : public MetafilePlayerBuffers
{
protected:
    BOOL                    Valid;
    UINT32                  MaxStackSize;
    INT *                   Stack;
    IStream *               Stream;
    BYTE *                  RecordAllocedBuffer;
    BYTE *                  PointsAllocedBuffer;
    GpSolidFill             SolidBrush;
    BYTE *                  ConcatRecordBuffer;
    INT                     ConcatRecordBufferSize;
    BYTE *                  ConcatRecord;
    INT                     ConcatRecordTotalSize;
    INT                     ConcatRecordSize;
    UINT                    ConcatRecordFlags;
    InterpolationMode       Interpolation;

public:
    GpGraphics *            Graphics;           // The graphics we're playing to
    BOOL                    PlayEMFRecords;     // TRUE when we see GetDC record
    HDC                     Hdc;                // For playing downlevel records
    GpMatrix                PreContainerMatrix; // Xform to use for down-level
    UINT32 *                BitmapBits;
    INT                     BitmapWidth;
    INT                     BitmapHeight;
    GpRectF                 BitmapDestRect;
    REAL                    BitmapDpi;
    GpRecolor *             Recolor;
    MfEnumState *           MfState;
    ColorAdjustType         AdjustType;
    UINT                    MultiFormatSection;
    UINT                    CurFormatSection;
    BOOL                    PlayMultiFormatSection;
    EnumerateMetafileProc   EnumerateCallback;  // for metafile enumeration
    VOID *                  CallbackData;       // for metafile enumeration
    BOOL                    EnumerateAborted;
    DrawImageAbort          DrawImageCallback;
    VOID*                   DrawImageCallbackData;
    INT                     DrawImageCallbackCount;
    BOOL                    RopUsed;

public:
    // stream is NULL if using GDI to enumerate the hEmf.
    MetafilePlayer(
        GpGraphics *            g,
        UINT                    maxStackSize,
        GpRecolor *             recolor,
        ColorAdjustType         adjustType,
        EnumerateMetafileProc   enumerateCallback,
        VOID *                  callbackData,
        DrawImageAbort          drawImageCallback,
        VOID*                   drawImageCallbackData
        );

    ~MetafilePlayer();

    BOOL IsValid() const { return Valid; }

    VOID
    PrepareToPlay(
        GpGraphics *            g,
        GpRecolor *             recolor,
        ColorAdjustType         adjustType,
        EnumerateMetafileProc   enumerateCallback,
        VOID *                  callbackData,
        DrawImageAbort          drawImageCallback,
        VOID*                   drawImageCallbackData
    );

    VOID DonePlaying();

    VOID InitForDownLevel()
    {
        if (Hdc == NULL)
        {
            Hdc = Graphics->GetHdc();
            ASSERT(Hdc != NULL);

            if (BitmapBits != NULL)
            {
                Init32BppDibToTransparent(BitmapBits, BitmapWidth*BitmapHeight);
                MfState->ResetRopUsed();
            }
        }
    }

    VOID DoneWithDownLevel()
    {
        PlayEMFRecords = FALSE;
        if (Hdc != NULL)
        {
            Graphics->ReleaseHdc(Hdc);
            Hdc = NULL;

            if (BitmapBits != NULL)
            {
                // This is a hack to get around the problem that we are
                // inside a container, but we don't want to be in the
                // container for drawing the down-level records.  We also
                // don't want any transforms inside the EMF+ to affect the
                // down-level records.
                // We should probably do something about the clipping too,
                // but for now, we won't worry about it.
                GpMatrix saveWorldToDevice = Graphics->Context->WorldToDevice;
                Graphics->Context->WorldToDevice = PreContainerMatrix;

                // Don't use NearestNeighbor to draw the rotated metafile --
                // it looks bad, and doesn't really save any time.

                InterpolationMode   saveInterpolationMode = Graphics->Context->FilterType;

                if (saveInterpolationMode == InterpolationModeNearestNeighbor)
                {
                    Graphics->Context->FilterType = InterpolationModeBilinear;
                }

                Graphics->Context->InverseOk = FALSE;
                Draw32BppDib(Graphics, BitmapBits, BitmapWidth, BitmapHeight,
                             BitmapDestRect, BitmapDpi, !RopUsed);

                // restore the interpolation mode (in case we changed it).
                Graphics->Context->FilterType    = saveInterpolationMode;
                Graphics->Context->WorldToDevice = saveWorldToDevice;
                Graphics->Context->InverseOk = FALSE;
            }
        }
    }

    // returns 0 to abort playback, 1 to continue
    INT
    ProcessDrawImageCallback(
        BOOL    forceCallback
        )
    {
        if (DrawImageCallback)
        {
            // A DrawImage record could have already been aborted, so
            // we should immediately return.
            if (EnumerateAborted)
            {
                return 0;   // abort
            }
            if (forceCallback)
            {
                DrawImageCallbackCount = 0;
            }
            if ((DrawImageCallbackCount++ & GDIP_DO_CALLBACK_MASK) == 0)
            {
                // The callback returns TRUE to abort, FALSE to continue.
                return ((*DrawImageCallback)(DrawImageCallbackData)) ? 0 : 1;
            }
        }
        return 1;
    }

    GpPointF *
    GetPoints(
        const BYTE *        pointData,
        UINT                pointDataSize,
        INT                 count,
        INT                 flags
        )
    {
        return GetPointsForPlayback(pointData, pointDataSize, count, flags,
                                    GDIP_METAFILE_BUFFERSIZE,
                                    PointsBuffer, PointsAllocedBuffer);
    }

    GpRectF *
    GetRects(
        const BYTE *        rectData,
        UINT                rectDataSize,
        INT                 count,
        INT                 flags
        )
    {
        return GetRectsForPlayback(rectData, rectDataSize, count, flags,
                                   GDIP_METAFILE_BUFFERSIZE,
                                   PointsBuffer, PointsAllocedBuffer);
    }

    GpObject *
    GetObject(
        UINT                metaObjectId,
        ObjectType          objectType
        );

    GpBrush *
    GetBrush(
        UINT                brushValue,
        INT                 flags
        );

    GpString *
    GetString(
        const BYTE *    stringData,
        INT             len,
        INT             flags
        )
    {
        // !!! convert back from 8-bit to 16-bit chars if necessary
        return new GpString((const WCHAR *)stringData, len);
    }

    VOID
    AddObject(
        INT                 flags,
        const BYTE *        data,
        UINT                dataSize
        );

    VOID
    NewSave(
        UINT        stackIndex,
        INT         saveID
        );

    INT
    GetSaveID(
        UINT        stackIndex
        );

    VOID FreePointsBuffer()
    {
        if (PointsAllocedBuffer != NULL)
        {
            delete [] PointsAllocedBuffer;
            PointsAllocedBuffer = NULL;
        }
    }

    GpStatus
    ConcatenateRecords(
        UINT                recordFlags,
        INT                 recordDataSize,
        const BYTE *        recordData
        );

    GpStatus
    EnumerateEmfPlusRecords(
        UINT                dataSize,   // size of EMF+ record data
        const BYTE *        data        // pointer to the EMF+ record data
        );

    GpStatus
    EnumerateEmfRecords(
        HDC                 hdc,
        HENHMETAFILE        hEmf,
        const RECT *        dest,
        const RECT *        deviceRect,
        ENHMFENUMPROC       enumProc
        );

    GpStatus
    EnumerateWmfRecords(
        HDC                 hdc,
        HMETAFILE           hWmf,
        const RECT *        dstRect,
        const RECT *        deviceRect
        );
};

VOID
MetafilePlayer::PrepareToPlay(
    GpGraphics *            g,
    GpRecolor *             recolor,
    ColorAdjustType         adjustType,
    EnumerateMetafileProc   enumerateCallback,
    VOID *                  callbackData,
    DrawImageAbort          drawImageCallback,
    VOID*                   drawImageCallbackData
    )
{
    ASSERT(g != NULL);

    GpMemset(Stack, 0, MaxStackSize * sizeof (INT));

    // Initialize all the buffers to 0
    MetafilePlayerBuffers *     buffers = this;
    GpMemset(buffers, 0, sizeof(MetafilePlayerBuffers));

    PlayEMFRecords         = FALSE;
    Hdc                    = NULL;
    Graphics               = g;
    BitmapBits             = NULL;
    BitmapWidth            = 0;
    BitmapHeight           = 0;
    Interpolation          = g->GetInterpolationMode();
    Recolor                = recolor;
    AdjustType             = adjustType;
    MultiFormatSection     = 0;
    CurFormatSection       = 0;
    PlayMultiFormatSection = TRUE;
    EnumerateAborted       = FALSE;
    RopUsed                = FALSE;
    if (enumerateCallback == NULL)
    {
        EnumerateCallback  = GdipPlayMetafileRecordCallback;
        CallbackData       = this;
    }
    else
    {
        EnumerateCallback  = enumerateCallback;
        CallbackData       = callbackData;
    }
    DrawImageCallback      = drawImageCallback;
    DrawImageCallbackData  = drawImageCallbackData;
    DrawImageCallbackCount = 0;
    ConcatRecord           = NULL;
    ConcatRecordTotalSize  = 0;
    ConcatRecordSize       = 0;
    ConcatRecordFlags      = 0;

    // We need this for rendering GDI records within a GDI+ file.
    // We have to do it before starting the container.
    g->GetWorldToDeviceTransform(&(this->PreContainerMatrix));
}

MetafilePlayer::MetafilePlayer(
    GpGraphics *            g,
    UINT                    maxStackSize,
    GpRecolor *             recolor,
    ColorAdjustType         adjustType,
    EnumerateMetafileProc   enumerateCallback,
    VOID *                  callbackData,
    DrawImageAbort          drawImageCallback,
    VOID*                   drawImageCallbackData
    )
{
    Valid        = FALSE;
    MaxStackSize = GDIP_SAVE_STACK_SIZE;
    Stack        = MemberStack;
    if (maxStackSize > GDIP_SAVE_STACK_SIZE)
    {
        Stack = new INT[maxStackSize];
        if (Stack == NULL)
        {
            return; // Valid is FALSE
        }
        MaxStackSize = maxStackSize;
    }

    RecordAllocedBuffer    = NULL;
    PointsAllocedBuffer    = NULL;
    Recolor                = NULL;
    MfState                = NULL;
    ConcatRecordBuffer     = NULL;
    ConcatRecordBufferSize = 0;
    PrepareToPlay(g, recolor, adjustType, enumerateCallback, callbackData,
                  drawImageCallback, drawImageCallbackData
                  );
    Valid                  = TRUE;
}

MetafilePlayer::~MetafilePlayer()
{
    if (Stack != MemberStack)
    {
        delete [] Stack;
    }
    if (ConcatRecordBuffer)
    {
        GpFree(ConcatRecordBuffer);
    }
}

VOID
MetafilePlayer::DonePlaying()
{
    INT i;

    i = 0;
    do
    {
        delete ObjectList[i];
    } while ((++i) < GDIP_MAX_OBJECTS);
}

GpObject *
MetafilePlayer::GetObject(
    UINT                metaObjectId,
    ObjectType          objectType
    )
{
    GpObject *          object = NULL;

    // If the object was an unused optional parameter of some kind
    // it knows how to handle a NULL object, so we return that.

    if(metaObjectId == GDIP_OBJECTID_NONE)
    {
        return NULL;
    }

    ASSERT(metaObjectId < GDIP_MAX_OBJECTS);

    if (metaObjectId < GDIP_MAX_OBJECTS)
    {
        object = ObjectList[metaObjectId];
        ASSERT (object != NULL);
        if (object != NULL)
        {
            ASSERT(object->GetObjectType() == objectType);
            if (object->GetObjectType() == objectType)
            {
                return object;
            }
        }
    }
    if (ObjectTypeIsValid(objectType))
    {
        return BackupObject[objectType - ObjectTypeMin];
    }
    return NULL;
}

GpBrush *
MetafilePlayer::GetBrush(
    UINT                brushValue,
    INT                 flags
    )
{
    GpBrush *   brush;

    if ((flags & GDIP_EPRFLAGS_SOLIDCOLOR) != 0)
    {
        brush = &SolidBrush;
        (reinterpret_cast<GpSolidFill *>(brush))->SetColor(GpColor(brushValue));
        if (Recolor != NULL)
        {
            brush->ColorAdjust(Recolor, AdjustType);
        }
    }
    else
    {
        brush = (GpBrush *)this->GetObject(brushValue, ObjectTypeBrush);
    }
    return brush;
}

VOID
MetafilePlayer::AddObject(
    INT                 flags,
    const BYTE *        data,
    UINT                dataSize
    )
{
    ObjectType  objectType = GetObjectType(flags);
    UINT        objectId   = GetMetaObjectId(flags);
    GpObject ** objectList = ObjectList;

    ASSERT((objectId < GDIP_MAX_OBJECTS) || (objectId == GDIP_BACKUP_OBJECTID));

    // First see if this is a backup object
    if ((objectId == GDIP_BACKUP_OBJECTID) &&
         ObjectTypeIsValid(objectType))
    {
        objectList = BackupObject;
        objectId   = objectType - ObjectTypeMin;
    }
    if (objectId < GDIP_MAX_OBJECTS)
    {
        GpObject *  object = objectList[objectId];

        if (object != NULL)
        {
            object->Dispose();
        }

        object = GpObject::Factory(objectType, (const ObjectData *)data, dataSize);

        if (object)
        {
            if (object->SetData(data, dataSize) == Ok)
            {
                if (Recolor != NULL)
                {
                    object->ColorAdjust(Recolor, AdjustType);
                }
                if (!object->IsValid())
                {
                    WARNING(("Object is not valid"));
                    object->Dispose();
                    object = NULL;
                }
            }
            else
            {
                WARNING(("Object Set Data failed"));
                object->Dispose();
                object = NULL;
            }
        }
        else
        {
            WARNING(("Object Factory failed to create object"));
        }
        objectList[objectId] = object;
    }
}

VOID
MetafilePlayer::NewSave(
    UINT        stackIndex,
    INT         saveID
    )
{
    if (stackIndex >= MaxStackSize)
    {
        UINT    maxStackSize = MaxStackSize + GDIP_SAVE_STACK_SIZE;

        if (stackIndex >= maxStackSize)
        {
            ASSERT (0);
            return;
        }
        INT *       newStack = new INT[maxStackSize];

        if (newStack == NULL)
        {
            return;
        }

        GpMemcpy(newStack, Stack, MaxStackSize * sizeof(INT));
        GpMemset(newStack + MaxStackSize, 0,
                 GDIP_SAVE_STACK_SIZE * sizeof (INT));
        MaxStackSize = maxStackSize;
        if (Stack != MemberStack)
        {
            delete [] Stack;
        }
        Stack = newStack;
    }

    Stack[stackIndex] = saveID;
}

INT
MetafilePlayer::GetSaveID(
    UINT        stackIndex
    )
{
    ASSERT(stackIndex < MaxStackSize);

    INT     saveID = 0;

    if (stackIndex < MaxStackSize)
    {
        saveID = Stack[stackIndex];
        Stack[stackIndex] = 0;
    }
    return saveID;
}

GpStatus
MetafilePlayer::ConcatenateRecords(
    UINT                recordFlags,
    INT                 recordDataSize,
    const BYTE *        recordData
    )
{
    ASSERT((recordData != NULL) && (recordDataSize > sizeof(INT32)));

    GpStatus    status = Ok;

    if ((recordFlags & GDIP_EPRFLAGS_CONTINUEOBJECT) != 0)
    {
        INT     dataSizeLeft = ((const INT32 *)recordData)[0];
        recordData     += sizeof(INT32);
        recordDataSize -= sizeof(INT32);

        if (dataSizeLeft <= recordDataSize)
        {
            WARNING(("Total Data Size incorrect"));
            status = InvalidParameter;
            goto DoneWithRecord;
        }

        recordFlags &= ~GDIP_EPRFLAGS_CONTINUEOBJECT;

        if (ConcatRecord == NULL)
        {
            if ((ConcatRecordBuffer == NULL) ||
                (ConcatRecordBufferSize < dataSizeLeft))
            {
                GpFree(ConcatRecordBuffer);
                ConcatRecordBuffer = (BYTE *)GpMalloc(dataSizeLeft);
                if (ConcatRecordBuffer == NULL)
                {
                    ConcatRecordBufferSize = 0;
                    return OutOfMemory;
                }
                ConcatRecordBufferSize = dataSizeLeft;
            }
            ConcatRecord          = ConcatRecordBuffer;
            ConcatRecordTotalSize = dataSizeLeft;
            ConcatRecordSize      = 0;
            ConcatRecordFlags     = recordFlags;
            goto SkipContinueChecks;
        }
    }
    if (recordFlags != ConcatRecordFlags)
    {
        WARNING(("Record headers do not match"));
        status = InvalidParameter;
        goto DoneWithRecord;
    }

SkipContinueChecks:
    if (recordDataSize + ConcatRecordSize > ConcatRecordTotalSize)
    {
        WARNING(("sizes do not match"));
        recordDataSize = ConcatRecordTotalSize - ConcatRecordSize;
    }

    GpMemcpy(ConcatRecord + ConcatRecordSize, recordData, recordDataSize);
    ConcatRecordSize += recordDataSize;

    // see if we're done concatenating this record
    if (ConcatRecordSize >= ConcatRecordTotalSize)
    {
        if (EnumerateCallback(EmfPlusRecordTypeObject, recordFlags,
                              ConcatRecordTotalSize, ConcatRecord,
                              CallbackData) == 0)
        {
            status = Aborted;
        }
DoneWithRecord:
        ConcatRecord          = NULL;
        ConcatRecordTotalSize = 0;
        ConcatRecordSize      = 0;
        ConcatRecordFlags     = 0;
    }
    return status;
}

// Enumerate a set of EMF+ record contained inside an EMF comment record
// which has been enumerated from an EMF file.
//
// NOTE that we can't change the metafile data.  If we need to change it,
// we must change a copy of it.
GpStatus
MetafilePlayer::EnumerateEmfPlusRecords(
    UINT                dataSize,   // size of EMF+ record data
    const BYTE *        data        // pointer to the EMF+ record data
    )
{
    ASSERT((dataSize > 0) && (data != NULL));

    UINT                curSize = 0;
    UINT                recordSize;
    EmfPlusRecordType   recordType;
    UINT                recordFlags;
    UINT                recordDataSize;
    const BYTE *        recordData;

    // while there is at least one record header size left
    while (curSize <= (dataSize - sizeof(EmfPlusRecord)))
    {
        recordSize = ((const EmfPlusRecord *)data)->Size;
        recordDataSize = recordSize - sizeof(EmfPlusRecord);

        // Make sure we don't read past the end of the buffer
        // and make sure the size field is valid.
        if ((recordSize >= sizeof(EmfPlusRecord)) &&
            ((curSize + recordSize) <= dataSize)  &&
            (recordDataSize == ((const EmfPlusRecord *)data)->DataSize))
        {
            recordType = (EmfPlusRecordType)(((const EmfPlusRecord *)data)->Type);

            // make sure the recordType is in some reasonable range
            // before we enumerate this record
            if ((recordType >= EmfPlusRecordTypeMin) &&
                (recordType < (EmfPlusRecordTypeMax + 1000)))
            {
                recordFlags = ((const EmfPlusRecord *)data)->Flags;

                if (recordDataSize == 0)
                {
                    recordData = NULL;
                }
                else
                {
                    recordData = data + sizeof(EmfPlusRecord);

                    // if this object record is spread over several GDI comment
                    // records, then we need to concatenate them together before
                    // giving it to the callback

                    // The GDIP_EPRFLAGS_CONTINUEOBJECT flag is only valid
                    // with object records (since that bit is reused for other
                    // flags with other record types).

                    if ((recordType == EmfPlusRecordTypeObject) &&
                        (((recordFlags & GDIP_EPRFLAGS_CONTINUEOBJECT) != 0) ||
                         (ConcatRecord != NULL)))
                    {
                        if (this->ConcatenateRecords(recordFlags,
                                                     recordDataSize,
                                                     recordData) == Aborted)
                        {
                            return Aborted;
                        }
                        goto Increment;
                    }
                }

                if (EnumerateCallback(recordType, recordFlags, recordDataSize,
                                      recordData, CallbackData) == 0)
                {
                    return Aborted;
                }
            }
            else
            {
                WARNING1("Bad EMF+ record type");
            }

Increment:
            data += recordSize;
            curSize += recordSize;

            // We have to set this here, because if we are just enumerating
            // for an application (not playing), then the GetDCEPR::Play
            // method will never be hit, so it will never get set!
            if (recordType == EmfPlusRecordTypeGetDC)
            {
                // Flag that the next down-level records should be played.
                PlayEMFRecords = TRUE;
            }
        }
        else
        {
            WARNING1("Bad EMF+ record size");
            return InvalidParameter;
        }
    }
    return Ok;
}

// Callback for EnumerateMetafile methods.  The parameters are:

//      recordType      (if >= EmfPlusRecordTypeMin, it's an EMF+ record)
//      flags           (always 0 for EMF records)
//      dataSize        size of the data, or 0 if no data
//      data            pointer to the data, or NULL if no data (UINT32 aligned)
//      callbackData    pointer to callbackData, if any

// This method can then call Metafile::PlayRecord to play the
// record that was just enumerated.  If this method  returns
// FALSE, the enumeration process is aborted.  Otherwise, it continues.

extern "C"
BOOL CALLBACK
GdipPlayMetafileRecordCallback(
    EmfPlusRecordType   recordType,
    UINT                recordFlags,
    UINT                recordDataSize,
    const BYTE *        recordData,
    VOID *              callbackData    // player
    )
{
    MetafilePlayer *    player = (MetafilePlayer *)callbackData;

    // See if it is an EMF+ record
    if ((recordType >= EmfPlusRecordTypeMin) && (recordType <= EmfPlusRecordTypeMax))
    {
        if (player->PlayMultiFormatSection)
        {
            (((const EmfPlusRecordPlay *)recordData)->*RecordPlayFuncs[recordType-EmfPlusRecordTypeMin])(player, recordType, recordFlags, recordDataSize);
            return player->ProcessDrawImageCallback(FALSE);
        }
        return 1;
    }

    // See if we should play the WMF or EMF record
    // Always play the header and EOF EMF records
    if (player->PlayEMFRecords ||
        (recordType == EmfRecordTypeHeader) ||
        (recordType == EmfRecordTypeEOF))
    {
        ASSERT(player->MfState != NULL);

        BOOL    forceCallback = player->MfState->ProcessRecord(
                                    recordType,
                                    recordDataSize,
                                    recordData);
        return player->ProcessDrawImageCallback(forceCallback);
    }

    ASSERT (0); // shouldn't get here unless caller is doing something strange

    return 1;   // Keep playing
}

GpStatus
GpMetafile::PlayRecord(
    EmfPlusRecordType       recordType,
    UINT                    recordFlags,
    UINT                    recordDataSize, // must be multiple of 4 for EMF
    const BYTE *            recordData
    ) const
{
    if ((State != PlayingMetafileState) ||
        (((recordDataSize & 0x03) != 0) &&
         (!GDIP_IS_WMF_RECORDTYPE(recordType))))
    {
        return InvalidParameter;
    }

    ASSERT(Player != NULL);

    GdipPlayMetafileRecordCallback(
        recordType,
        recordFlags,
        recordDataSize,
        recordData,
        Player
        );

    return Ok;
}

inline BOOL
IsEmfPlusRecord(
    CONST ENHMETARECORD *   emfRecord
    )
{
    // dParm[0] is the comment data size
    return ((emfRecord->iType == EMR_GDICOMMENT) &&
            (emfRecord->nSize >= (sizeof(EMR) + (2 * sizeof(DWORD)))) &&
            (emfRecord->dParm[1] == EMFPLUS_SIGNATURE));
}

// This method enumerates/plays EMF+ comment records and also
// plays down-level GDI records, when appropriate.
extern "C"
int CALLBACK
EnumEmfWithDownLevel(
    HDC                     hdc,    // should be non-NULL
    HANDLETABLE FAR *       gdiHandleTable,
    CONST ENHMETARECORD *   emfRecord,
    int                     numHandles,
    LPARAM                  play
    )
{
    if ((emfRecord != NULL) && (emfRecord->nSize >= sizeof(EMR)) &&
        (play != NULL))
    {
        MetafilePlayer *    player = (MetafilePlayer *)play;

        if (IsEmfPlusRecord(emfRecord))
        {
            // We're done displaying GDI down-level records
            player->DoneWithDownLevel();

            // NOTE: cbData is the size of the comment data, not including
            //       the record header and not including itself.
            //
            //       Must subtract out the Signature

            INT     dataSize = ((CONST EMRGDICOMMENT *)emfRecord)->cbData;

            // subtract out signature
            dataSize -= sizeof(INT32);

            if (dataSize > 0)
            {
                if (player->EnumerateEmfPlusRecords(
                            dataSize,
                            ((CONST EMRGDICOMMENT *)emfRecord)->Data + sizeof(INT32))
                            == Aborted)
                {
                    player->EnumerateAborted = TRUE;
                    return 0;
                }
            }
        }
        else
        {
            EmfPlusRecordType   recordType = (EmfPlusRecordType)(emfRecord->iType);

            if (player->PlayEMFRecords ||
                (recordType == EmfRecordTypeHeader) ||
                (recordType == EmfRecordTypeEOF))
            {
                if ((recordType != EmfRecordTypeHeader) &&
                    (recordType != EmfRecordTypeEOF))
                {
                    player->InitForDownLevel();
                }

                INT                 recordDataSize = emfRecord->nSize - sizeof(EMR);
                const BYTE *        recordData = (const BYTE *)emfRecord->dParm;

                if (recordDataSize <= 0)
                {
                    recordDataSize = 0;
                    recordData     = NULL;
                }

                player->MfState->StartRecord(hdc, gdiHandleTable, numHandles, emfRecord,
                                             recordType, recordDataSize, recordData);

                if (player->EnumerateCallback(recordType, 0, recordDataSize,
                                              recordData,
                                              player->CallbackData) == 0)
                {
                    player->EnumerateAborted = TRUE;
                    return 0;
                }
            }
        }
    }
    else
    {
        WARNING(("Bad Enumeration Parameter"));
    }
    return 1;
}

#define GDIP_MAX_DIBSECTION_SIZE   1024
#define GDIP_MINSCALED_DIBSECTION_SIZE   (GDIP_MAX_DIBSECTION_SIZE / 2)

inline VOID
AdjustForMaximumSize(
    LONG &      bigSide,
    LONG &      smallSide
    )
{
    // Try to keep the aspect ratio the same,
    // but don't let the smaller side get too small.
    REAL    scaleFactor = GDIP_MAX_DIBSECTION_SIZE / (REAL)bigSide;

    bigSide   = GDIP_MAX_DIBSECTION_SIZE;
    if (smallSide > GDIP_MINSCALED_DIBSECTION_SIZE)
    {
        smallSide = GpRound(scaleFactor * smallSide);

        if (smallSide < GDIP_MINSCALED_DIBSECTION_SIZE)
        {
            smallSide = GDIP_MINSCALED_DIBSECTION_SIZE;
        }
   }
}

// !!! If the hdc is a EMF, we really should take the rasterization limit
// into account when deciding the size of the dest bitmap.
static HBITMAP
CreateDibSection32Bpp(
    HDC                     hdc,
    const GpRectF &         destRect,
    RECT &                  dest,       // actual dest
    UINT32 **               bits,
    REAL *                  dpi,        // must init dpi before calling this method
    GpMatrix *              matrix
    )
{
    GpPointF    destPoints[3];
    REAL        width;
    REAL        height;


    // When we rasterize a WMF or EMF into a Dib Section, we limit the size
    // so that we don't use huge amounts of memory when printing or when
    // drawing the rotated metafile into another metafile.

    *bits = NULL;

    // the capped dpi keeps the image from getting too large

    destPoints[0].X = destRect.X;
    destPoints[0].Y = destRect.Y;
    destPoints[1].X = destRect.GetRight();
    destPoints[1].Y = destRect.Y;
    destPoints[2].X = destRect.X;
    destPoints[2].Y = destRect.GetBottom();

    matrix->Transform(destPoints, 3);

    // determine the size of the image by getting the distance
    // between the transformed device points

    width  = ::GetDistance(destPoints[0], destPoints[1]);
    height = ::GetDistance(destPoints[0], destPoints[2]);

    dest.left   = 0;
    dest.top    = 0;
    dest.right  = GpRound(width);
    dest.bottom = GpRound(height);

    // make sure we don't transform down to 0 size

    if ((dest.right == 0) || (dest.bottom == 0))
    {
        return NULL;
    }

    if ((dest.right  > GDIP_MAX_DIBSECTION_SIZE) ||
        (dest.bottom > GDIP_MAX_DIBSECTION_SIZE))
    {
        REAL area = (REAL) dest.right * dest.bottom;

        if (dest.right >= dest.bottom)
        {
            AdjustForMaximumSize(dest.right, dest.bottom);
        }
        else
        {
            AdjustForMaximumSize(dest.bottom, dest.right);
        }

        REAL newArea = (REAL) dest.right * dest.bottom;

        ASSERT(newArea > 0.0f && newArea <= area);

        // Adjust the effective DPI of the bitmap based on how much smaller it is.
        *dpi = (*dpi)*newArea/area;
    }

    BITMAPINFO      bmi;

    // Create a 32-bpp dib section so we can add alpha to it

    GpMemset(&bmi, 0, sizeof(bmi));

    bmi.bmiHeader.biSize        = sizeof(bmi.bmiHeader);
    bmi.bmiHeader.biWidth       = dest.right;
    bmi.bmiHeader.biHeight      = dest.bottom;
    bmi.bmiHeader.biPlanes      = 1;
    bmi.bmiHeader.biBitCount    = 32;
    bmi.bmiHeader.biCompression = BI_RGB;
    bmi.bmiHeader.biSizeImage   = dest.right * dest.bottom * 4;

    return CreateDIBSection(hdc, &bmi, DIB_RGB_COLORS, (VOID**)(bits), NULL, 0);
}

VOID
Init32BppDibToTransparent(
    UINT32 *                bits,
    UINT                    numPixels
    )
{
    ASSERT((bits != NULL) && (numPixels > 0));

    // initialize the image to a "transparent" color

    while (numPixels--)
    {
        *bits++ = GDIP_TRANSPARENT_COLOR_KEY;
    }
}

GpStatus
Draw32BppDib(
    GpGraphics *            g,
    UINT32 *                bits,
    INT                     width,
    INT                     height,
    const GpRectF &         destRect,
    REAL                    dpi,
    BOOL                    compareAlpha
    )
{
    // Make sure Gdi is done drawing to the dib section
    ::GdiFlush();

    // Set the alpha value to 0 whereever the transparent
    // color is still in the image and to FF everywhere else

    UINT32 *    bitmapBits = bits;
    UINT        numPixels  = width * height;

    if (compareAlpha)
    {
        while (numPixels--)
        {
            if (*bitmapBits != GDIP_TRANSPARENT_COLOR_KEY)
            {
                *bitmapBits |= 0xFF000000;
            }
            else
            {
                *bitmapBits = 0;
            }
            bitmapBits++;
        }
    }
    else
    {
        while (numPixels--)
        {
            if ((*bitmapBits & 0x00FFFFFF) != (GDIP_TRANSPARENT_COLOR_KEY & 0x00FFFFFF))
            {
                *bitmapBits |= 0xFF000000;
            }
            else
            {
                *bitmapBits = 0;
            }
            bitmapBits++;
        }
    }

    // Create a bitamp from the dib section memory (which
    // we've added alpha to).  This constructor uses the
    // memory we give it without doing a copy.

    GpStatus    status = GenericError;

    GpBitmap *  bitmap = new GpBitmap(width, height, -(width * 4),
                                      PIXFMT_32BPP_PARGB,
                                      (BYTE *)(bits + (width * (height - 1))));

    if (bitmap != NULL)
    {
        if (bitmap->IsValid())
        {
            bitmap->SetResolution(dpi, dpi);

            // If we want the outside edges to look smooth, then we have
            // to outcrop both the src and dest rects (by at least a pixel).

            GpRectF     srcRect(-1.0f, -1.0f, width + 2.0f, height + 2.0f);
            GpRectF     outCroppedDestRect;
            REAL        xSize;
            REAL        ySize;

            g->GetWorldPixelSize(xSize, ySize);

            if (destRect.Width < 0.0f)
            {
                xSize = -xSize;
            }
            if (destRect.Height < 0.0f)
            {
                ySize = -ySize;
            }

            outCroppedDestRect.X      = destRect.X      - xSize;
            outCroppedDestRect.Width  = destRect.Width  + (xSize * 2.0f);
            outCroppedDestRect.Y      = destRect.Y      - ySize;
            outCroppedDestRect.Height = destRect.Height + (ySize * 2.0f);

            if (g->IsPrinter())
            {
                // If the resulting transform (and source rect/dest rect) is
                // a rotation by 90, 180, or 270 degrees.  Then flip the bitmap
                // appropriately.  Fix up source rect, dest rect, and world to
                // device appropriately.  Restore W2D afterwards.

                GpMatrix worldToDevice;
                g->GetWorldToDeviceTransform(&worldToDevice);

                // Create the entire image source to device mapping to determine
                // the entire rotation.

                GpMatrix transform;
                transform.InferAffineMatrix(destRect, srcRect);
                GpMatrix::MultiplyMatrix(transform, transform, worldToDevice);

                MatrixRotate rotation = transform.GetRotation();

                if (rotation == MatrixRotateBy90 ||
                    rotation == MatrixRotateBy180 ||
                    rotation == MatrixRotateBy270)
                {
                    // Normalize the destination rectangle
                    TransformBounds(NULL,
                                    outCroppedDestRect.GetLeft(),
                                    outCroppedDestRect.GetTop(),
                                    outCroppedDestRect.GetRight(),
                                    outCroppedDestRect.GetBottom(),
                                    &outCroppedDestRect);
                    // Compute the destination rectangle in device space.  Transform
                    // to device space and normalize.
                    // We know the world transform can have a 90 degree rotation
                    // so we need to do a point transform. We can do a 2 point
                    // transform and get the min and the max to make the bounding
                    // box

                    GpRectF deviceDestRect;
                    TransformBounds(&worldToDevice,
                                    outCroppedDestRect.GetLeft(),
                                    outCroppedDestRect.GetTop(),
                                    outCroppedDestRect.GetRight(),
                                    outCroppedDestRect.GetBottom(),
                                    &deviceDestRect);

                    // Construct new world to page transform.  Infers from the
                    // normalized outCroppedDestRect to normalized deviceDestRect.
                    //
                    //  The World To Device is ordinarily computed as:
                    //
                    //          World-To-Page * Scale(PageMultipliers) *
                    //          Translate-By-Pixel-Offset * ContainerTransform
                    //
                    // The SetWorldTransform API only sets the World-To-Page.
                    //
                    //  So we set the new World Transform as:
                    //
                    //    World-To-Page * Inverse(World-To-Device)*
                    //    Transform-CroppedDestRect-To-DeviceDestRect
                    //
                    //    The result, as you can see from substitution is just
                    //    Transform-CroppedDestRect-To-DeviceDestRect


                    GpMatrix newTransform;
                    newTransform.InferAffineMatrix(deviceDestRect, outCroppedDestRect);
                    g->GetDeviceToWorldTransform(&transform);
                    GpMatrix::MultiplyMatrix(newTransform, newTransform, transform);
                    g->GetWorldTransform(transform);   // really World To Page XForm
                    GpMatrix::MultiplyMatrix(newTransform, newTransform, transform);

                    ASSERT(newTransform.IsTranslateScale());

                    // We are free to rotate in place because we know this is a
                    // throw away bitmap.

                    switch (rotation)
                    {
                    case MatrixRotateBy90:
                        status = bitmap->RotateFlip(Rotate90FlipNone);
                        break;

                    case MatrixRotateBy180:
                        status = bitmap->RotateFlip(Rotate180FlipNone);
                        break;

                    case MatrixRotateBy270:
                        status = bitmap->RotateFlip(Rotate270FlipNone);
                        break;

                    default:
                        status = GenericError;
                        ASSERT(FALSE);
                        break;
                    }

                    if (status == Ok)
                    {
                        g->SetWorldTransform(newTransform);

                        // Get new size (in case Height & Width were flipped.
                        Size bitmapSize;
                        bitmap->GetSize(&bitmapSize);

                        srcRect.Width = bitmapSize.Width + 2.0f;
                        srcRect.Height = bitmapSize.Height + 2.0f;

                        // Because the bitmap is already at device resolution
                        // (in most cases), nearest neighbor best preserves
                        // the image when printing.
                        InterpolationMode interpolationMode= g->GetInterpolationMode();
                        if (interpolationMode != InterpolationModeNearestNeighbor)
                        {
                            g->SetInterpolationMode(InterpolationModeNearestNeighbor);
                        }

                        // Draw the new image with the rotation/shear
                        status = g->DrawImage(bitmap, outCroppedDestRect, srcRect, UnitPixel);

                        if (interpolationMode != InterpolationModeNearestNeighbor)
                        {
                            g->SetInterpolationMode(interpolationMode);
                        }

                        g->SetWorldTransform(worldToDevice);
                    }

                    goto cleanupBitmap;
                }
            }

            // Draw the new image with the rotation/shear
            status = g->DrawImage(bitmap, outCroppedDestRect, srcRect, UnitPixel);
        }

cleanupBitmap:
        // Now clean up everything
        bitmap->Dispose();
    }
    return status;
}

// Get multipliers to convert to pixel units
VOID
GetPixelMultipliers(
    GpPageUnit                  srcUnit,
    REAL                        srcDpiX,
    REAL                        srcDpiY,
    REAL *                      pixelMultiplierX,
    REAL *                      pixelMultiplierY
    )
{
    REAL    multiplierX;
    REAL    multiplierY;

    // UnitDisplay is device-dependent and cannot be used for a source unit
    ASSERT(srcUnit != UnitDisplay);

    switch (srcUnit)
    {
    default:
        ASSERT(0);
        // FALLTHRU

    case UnitPixel:             // Each unit represents one device pixel.
        multiplierX = 1.0f;
        multiplierY = 1.0f;
        break;

    case UnitPoint:             // Each unit represents a 1/72 inch.
        multiplierX = srcDpiX / 72.0f;
        multiplierY = srcDpiY / 72.0f;
        break;

      case UnitInch:            // Each unit represents 1 inch.
        multiplierX = srcDpiX;
        multiplierY = srcDpiY;
        break;

      case UnitDocument:        // Each unit represents 1/300 inch.
        multiplierX = srcDpiX / 300.0f;
        multiplierY = srcDpiY / 300.0f;
        break;

      case UnitMillimeter:      // Each unit represents 1 millimeter.
                                // One Millimeter is 0.03937 inches
                                // One Inch is 25.4 millimeters
        multiplierX = srcDpiX / 25.4f;
        multiplierY = srcDpiY / 25.4f;
        break;
    }
    *pixelMultiplierX = multiplierX;
    *pixelMultiplierY = multiplierY;
}

extern "C"
int CALLBACK
EnumEmfDownLevel(
    HDC                     hdc,            // handle to device context
    HANDLETABLE FAR *       gdiHandleTable, // pointer to metafile handle table
    CONST ENHMETARECORD *   emfRecord,      // pointer to metafile record
    int                     numHandles,     // count of objects
    LPARAM                  play            // pointer to optional data
    )
{
    if ((emfRecord != NULL) && (emfRecord->nSize >= sizeof(EMR)) &&
        (play != NULL))
    {
        // If we're in this method, we don't want to play any EMF+ records,
        // so skip them, so we don't record them into another metafile.
        if (!IsEmfPlusRecord(emfRecord))
        {
            EmfPlusRecordType   recordType = (EmfPlusRecordType)(emfRecord->iType);
            const BYTE *        recordData = (const BYTE *)emfRecord->dParm;
            INT                 recordDataSize = emfRecord->nSize - sizeof(EMR);

            if (recordDataSize <= 0)
            {
                recordDataSize = 0;
                recordData     = NULL;
            }

            MetafilePlayer *    player = (MetafilePlayer *)play;

            player->MfState->StartRecord(hdc, gdiHandleTable, numHandles, emfRecord,
                                         recordType, recordDataSize, recordData);

            if (player->EnumerateCallback(recordType, 0, recordDataSize,
                                          recordData,
                                          player->CallbackData) == 0)
            {
                player->EnumerateAborted = TRUE;
                return 0;
            }
        }
    }
    else
    {
        WARNING(("Bad Enumeration Parameter"));
    }
    return 1;
}

// Assumes the hdc has already been set up with the correct transform and
// clipping for displaying the metafile.
GpStatus
MetafilePlayer::EnumerateEmfRecords(
    HDC                 hdc,
    HENHMETAFILE        hEmf,
    const RECT *        dest,
    const RECT *        deviceRect,
    ENHMFENUMPROC       enumProc
    )
{
    ASSERT(hdc != NULL);
    ASSERT(hEmf != NULL);
    ASSERT(dest->bottom > dest->top && dest->right > dest->left);

    // GDI uses an Inclusive-Inclusive bound for Metafile Playback
    RECT destRect = *dest;
    destRect.bottom--;
    destRect.right--;

    GpStatus    status = GenericError;
    BOOL        externalEnumeration =
                    (EnumerateCallback != GdipPlayMetafileRecordCallback);

    EmfEnumState    emfState(hdc, hEmf, &destRect, deviceRect, externalEnumeration,
                             Interpolation, Graphics->Context, Recolor, AdjustType);

    if (emfState.IsValid())
    {
        MfState = &emfState;

        // If the metafile is empty the following fails.
        status = ::EnumEnhMetaFile(hdc, hEmf, enumProc, this, &destRect) ?
                        Ok : GenericError;
        RopUsed = MfState->GetRopUsed();
        MfState = NULL;
        if (EnumerateAborted)
        {
            status = Aborted;
        }
    }
    return status;
}

extern "C"
int CALLBACK
EnumWmfDownLevel(
    HDC                     hdc,
    HANDLETABLE FAR *       gdiHandleTable,
    METARECORD FAR *        wmfRecord,
    int                     numHandles,
    LPARAM                  play
    )
{
    if ((wmfRecord != NULL) &&
        (((UNALIGNED METARECORD *)wmfRecord)->rdSize >= 3) &&
        (play != NULL))
    {
        EmfPlusRecordType   recordType     = (EmfPlusRecordType)(GDIP_WMF_RECORD_TO_EMFPLUS(wmfRecord->rdFunction));
        const BYTE *        recordData     = (const BYTE *)((UNALIGNED METARECORD *)wmfRecord)->rdParm;
        INT                 recordDataSize = (((UNALIGNED METARECORD *)wmfRecord)->rdSize * 2) - SIZEOF_METARECORDHEADER;

        if (recordDataSize <= 0)
        {
            recordDataSize = 0;
            recordData     = NULL;
        }

        MetafilePlayer *    player = (MetafilePlayer *)play;

        player->MfState->StartRecord(hdc, gdiHandleTable, numHandles, wmfRecord,
                                         recordType, recordDataSize, recordData);

        if (player->EnumerateCallback(recordType, 0, recordDataSize,
                                      recordData,
                                      player->CallbackData) == 0)
        {
            player->EnumerateAborted = TRUE;
            return 0;
        }
    }
    else
    {
        WARNING(("Bad Enumeration Parameter"));
    }
    return 1;
}

// Assumes the hdc has already been set up with the correct transform and
// clipping for displaying the metafile.
GpStatus
MetafilePlayer::EnumerateWmfRecords(
    HDC                 hdc,
    HMETAFILE           hWmf,
    const RECT *        dstRect,
    const RECT *        deviceRect
    )
{
    ASSERT(hdc != NULL);
    ASSERT(hWmf != NULL);

    GpStatus    status = GenericError;
    BOOL        externalEnumeration =
                    (EnumerateCallback != GdipPlayMetafileRecordCallback);

    WmfEnumState    wmfState(hdc, hWmf, externalEnumeration, Interpolation,
                             dstRect, deviceRect, Graphics->Context, Recolor, AdjustType);

    if (wmfState.IsValid())
    {
        MfState = &wmfState;

        // If the metafile is empty the following fails.
        status = ::EnumMetaFile(hdc, hWmf, EnumWmfDownLevel, (LPARAM)this) ?
                        Ok : GenericError;
        RopUsed = MfState->GetRopUsed();
        MfState = NULL;
        if (EnumerateAborted)
        {
            status = Aborted;
        }
    }
    return status;
}

inline BOOL
IsMetafileHdc(
    HDC     hdc
    )
{
    DWORD   hdcType = GetDCType(hdc);
    return ((hdcType == OBJ_ENHMETADC) || (hdcType == OBJ_METADC));
}

class SetupClippingForMetafilePlayback
{
public:

    SetupClippingForMetafilePlayback(
        HDC                     hdc,
        DpDriver *              driver,
        DpContext *             context,
        BOOL                    forEMFPlus = FALSE
        )
    {
        Hdc = hdc;
        Driver = driver;
        IsClip = FALSE;
        ClippedOut = FALSE;
        ReenableClipEscapes = FALSE;

        if (!context->VisibleClip.IsInfinite())
        {
            // Use GDI path clipping for playback to metafile only
            UsePathClipping = IsMetafileHdc(hdc) && !context->IsPrinter;

            // NT4 has a postscript driver bug where embedded EPS corrupt the
            // current postscript clipping stack.  To get around this, we resort to
            // using GDI to clip for us.

            // The problem is not limited to NT4 drivers alooe.  There seems to
            // be a family of injected EPS which doesn't interop with embedded
            // postscript clipping escapes. The reason may have to do with the
            // fact that many implementations don't reset the current path after
            // sending the escape.  See Office bugs 284388, 316074

            if (context->IsPrinter)
            {
                if ((!forEMFPlus && !Globals::IsNt) ||
                    (Globals::IsNt &&
                     Globals::VersionInfoInitialized &&
                    ((Globals::OsVer.dwMajorVersion <= 4) ||
                     ((Globals::OsVer.dwMajorVersion >= 5) &&
                      (context->VisibleClip.IsSimple())) )))
                {
                    DriverPrint *pdriver = (DriverPrint*) Driver;

                    pdriver->DisableClipEscapes();
                    ReenableClipEscapes = TRUE;
                }
            }

            // The trick here is we want to force the driver to clip, even if
            // totally visible because cropping requires this. We pass in the flag
            // to force clipping

            GpRect drawBounds;
            context->VisibleClip.GetBounds(&drawBounds);
            if (drawBounds.IsEmpty())
            {
                ClippedOut = TRUE;
                return;
            }

            // Use appropriate driver clipping on playback
            Driver->SetupClipping(Hdc,
                                  context,
                                  &drawBounds,
                                  IsClip,
                                  UsePathClipping,
                                  TRUE);

            // Prevent metafile from drawing outside of the DestRect
            // Can only do it for NT because Win9x doesn't restore the
            // MetaRgn properly
            // We handle this in the Metafile Player for Win9x
            if (Globals::IsNt)
            {
                ::SetMetaRgn(hdc);
            }
        }
    }

    ~SetupClippingForMetafilePlayback()
    {
        if (IsClip)
        {
            Driver->RestoreClipping(Hdc,
                                    IsClip,
                                    UsePathClipping);

            if (ReenableClipEscapes)
            {
                DriverPrint *pdriver = (DriverPrint*) Driver;
                pdriver->EnableClipEscapes();
            }
        }
    }

    BOOL IsClippedOut()
    {
        return ClippedOut;
    }

private:
    DpDriver *  Driver;
    HDC         Hdc;
    BOOL        IsClip;
    BOOL        UsePathClipping;
    BOOL        ClippedOut;
    BOOL        ReenableClipEscapes;
};

// We already set up the transform to handle the srcRect and also to
// handle any flipping in the srcRect and destRect, so the 2 rects
// should have positive widths and heights at this point.
GpStatus
GpGraphics::EnumEmf(
    MetafilePlayer *        player,
    HENHMETAFILE            hEmf,
    const GpRectF &         destRect,
    const GpRectF &         srcRect,    // in pixel units
    const GpRectF &         deviceDestRect, // The destRect in Device Units
    MetafileType            type,
    BOOL                    isTranslateScale,
    BOOL                    renderToBitmap,
    const GpMatrix &        flipAndCropTransform
    )
{
    ASSERT(hEmf != NULL);

    HDC     hdc  = Context->GetHdc(Surface);

    if (hdc == NULL)
    {
        return GenericError;
    }

    INT saveDC;
    if ((saveDC = ::SaveDC(hdc)) == 0)
    {
        Context->ReleaseHdc(hdc, Surface);
        return GenericError;
    }

    // Since we might have an HDC from a GpBitmap that's not clean, clean the
    // HDC for now....
    Context->CleanTheHdc(hdc);

    player->PlayEMFRecords = TRUE;  // play all EMF records

    GpStatus    status = Ok;

    // the srcRect is already in pixel units
    GpRect      deviceSrcRect;
    deviceSrcRect.X      = GpRound(srcRect.X);
    deviceSrcRect.Y      = GpRound(srcRect.Y);
    deviceSrcRect.Width  = GpRound(srcRect.Width);
    deviceSrcRect.Height = GpRound(srcRect.Height);

    RECT        deviceClipRect;
    deviceClipRect.left   = RasterizerCeiling(deviceDestRect.X);
    deviceClipRect.top    = RasterizerCeiling(deviceDestRect.Y);
    deviceClipRect.right  = RasterizerCeiling(deviceDestRect.GetRight());
    deviceClipRect.bottom = RasterizerCeiling(deviceDestRect.GetBottom());

    // If it's a translate/scale matrix, do the transform ourselves,
    // even on NT, so that we can control how the rounding is done
    // to avoid cases where we round the metafile dest differently
    // than the clipping rect, resulting in clipped out edges.
    if (isTranslateScale)
    {
        SetupClippingForMetafilePlayback clipPlayback(hdc, Driver, Context);
        if (!clipPlayback.IsClippedOut())
        {
            RECT        deviceRect;
            GpPointF    points[2];

            points[0] = GpPointF(destRect.X, destRect.Y);
            points[1] = GpPointF(destRect.GetRight(), destRect.GetBottom());
            player->PreContainerMatrix.Transform(points, 2);
            
            // We have to use the same method to convert REAL -> INT
            // that we do when we set up the clipping.  Otherwise, some
            // of the points get rounded differently, causing a
            // portion of the metafile to get clipped out.
            deviceRect.left   = RasterizerCeiling(points[0].X);
            deviceRect.top    = RasterizerCeiling(points[0].Y);
            deviceRect.right  = RasterizerCeiling(points[1].X);
            deviceRect.bottom = RasterizerCeiling(points[1].Y);

            if (deviceRect.left < deviceRect.right &&
                deviceRect.top < deviceRect.bottom)
            {
                if ((type == MetafileTypeWmf) || (type == MetafileTypeWmfPlaceable))
                {
                    // map the source rect to the dest rect to play the metafile
                    ::SetMapMode(hdc, MM_ANISOTROPIC);
                    ::SetWindowOrgEx(hdc, deviceSrcRect.X, deviceSrcRect.Y, NULL);
                    ::SetWindowExtEx(hdc, deviceSrcRect.Width, deviceSrcRect.Height,
                                     NULL);
                    ::SetViewportOrgEx(hdc, deviceRect.left, deviceRect.top, NULL);
                    ::SetViewportExtEx(hdc, deviceRect.right - deviceRect.left,
                                       deviceRect.bottom - deviceRect.top, NULL);

                    status = player->EnumerateWmfRecords(hdc, (HMETAFILE)hEmf,
                                                         &deviceRect, &deviceClipRect);
                }
                else    // play as down-level EMF
                {
                    ASSERT((type == MetafileTypeEmf) || (type == MetafileTypeEmfPlusDual));
                    
                    status = player->EnumerateEmfRecords(hdc, hEmf, &deviceRect,
                                                         &deviceClipRect, EnumEmfDownLevel);
                }

            }
            // else empty rect, nothing to draw
        }
        // else it's all clipped out
    }
    else    // flip and/or rotate and/or shear
    {
        RECT        dest;

        // Can't play a WMF with any rotate or skew transformation.
        // If we're on NT but we're drawing to a metafile hdc, then we
        // can't rely on the transforms working for that case.
        if (!renderToBitmap)
        {
            dest.left   = GpRound(destRect.X);
            dest.top    = GpRound(destRect.Y);
            dest.right  = GpRound(destRect.GetRight());
            dest.bottom = GpRound(destRect.GetBottom());

            if ((dest.bottom > dest.top) && (dest.right > dest.left))
            {
                // If NT, then set the transform in GDI, and play the metafile

                SetupClippingForMetafilePlayback clipPlayback(hdc, Driver, Context);
                if (!clipPlayback.IsClippedOut())
                {
                    ASSERT(Globals::IsNt);

                    SetGraphicsMode(hdc, GM_ADVANCED);

                    ASSERT(sizeof(XFORM) == sizeof(REAL)*6);

                    XFORM   xform;
                    player->PreContainerMatrix.GetMatrix((REAL*) &xform);
                    ::SetWorldTransform(hdc, &xform);

                    RECT    dummyRect = {0,0,0,0};
                    
                    status = player->EnumerateEmfRecords(hdc, hEmf, &dest,
                                                         &dummyRect, EnumEmfDownLevel);
                }
            }
        }
        else // Win9x with rotation or shear
             // WinNT WMF with Rotate or shear
        {
            // 1 - Draw into a 32-bit DIB Section
            // 2 - Create an image from the DIB Section
            // 3 - Call g->DrawImage

            status = GenericError;

            UINT32 *    bits;
            HBITMAP     hBitmap;

            player->BitmapDpi = Context->ContainerDpiX;
            hBitmap = CreateDibSection32Bpp(hdc, destRect, dest, &bits, &player->BitmapDpi, &player->PreContainerMatrix);
            if (hBitmap != NULL)
            {
                Init32BppDibToTransparent(bits, dest.right * dest.bottom);

                HDC     hdcDib = CreateCompatibleDC(NULL);

                if (hdcDib != NULL)
                {
                    ::SelectObject(hdcDib, hBitmap);

                    if ((type == MetafileTypeWmf) || (type == MetafileTypeWmfPlaceable))
                    {
                        // map the source rect to the dest rect to play the metafile
                        ::SetMapMode(hdcDib, MM_ANISOTROPIC);
                        ::SetWindowOrgEx(hdcDib, deviceSrcRect.X, deviceSrcRect.Y, NULL);
                        ::SetWindowExtEx(hdcDib, deviceSrcRect.Width, deviceSrcRect.Height,
                                         NULL);
                        ::SetViewportOrgEx(hdcDib, 0, 0, NULL);
                        ::SetViewportExtEx(hdcDib, dest.right, dest.bottom, NULL);

                        status = player->EnumerateWmfRecords(hdcDib, (HMETAFILE)hEmf,
                                                             &dest, &dest);
                    }
                    else    // play as down-level EMF
                    {
                        ASSERT((type == MetafileTypeEmf) || (type == MetafileTypeEmfPlusDual));


                        status = player->EnumerateEmfRecords(hdcDib, hEmf, &dest,
                                                             &dest, EnumEmfDownLevel);
                    }
                    ::DeleteDC(hdcDib);

                    if (status != Aborted)
                    {
                        // Don't use NearestNeighbor to draw the rotated metafile --
                        // it looks bad, and doesn't really save any time.

                        InterpolationMode   saveInterpolationMode = Context->FilterType;

                        if (saveInterpolationMode == InterpolationModeNearestNeighbor)
                        {
                            Context->FilterType = InterpolationModeBilinear;
                        }

                        // Apply the flip/crop transform.  Now the worldToDevice transform
                        // should be equivalent to the PreContainerMatrix.
                        this->SetWorldTransform(flipAndCropTransform);

                        status = Draw32BppDib(this, bits, dest.right,
                                              dest.bottom, destRect,
                                              player->BitmapDpi, !player->RopUsed);

                        // restore the interpolation mode (in case we changed it).
                        Context->FilterType = saveInterpolationMode;
                    }
                }
                DeleteObject(hBitmap);
            }
            else if ((dest.right == 0) || (dest.bottom == 0))
            {
                status = Ok;
            }
        }
    }

    ::RestoreDC(hdc, saveDC);
    Context->ReleaseHdc(hdc, Surface);
    return status;
}

// We already set up the transform to handle the srcRect and also to
// handle any flipping in the srcRect and destRect, so the 2 rects
// should have positive widths and heights at this point.
GpStatus
GpGraphics::EnumEmfPlusDual(
    MetafilePlayer *        player,
    HENHMETAFILE            hEmf,
    const GpRectF&          destRect,        // inclusive, exclusive
    const GpRectF&          deviceDestRect,  // inclusive, exclusive
    BOOL                    isTranslateScale,
    BOOL                    renderToBitmap
    )
{
    GpStatus    status = Ok;
    HDC         hdc;
    HWND        hwnd   = Context->Hwnd;
    INT         saveDC = -1;
    BOOL        needToReleaseHdc = FALSE;

    // We are going to take the role of the application and set up the HDC
    // like we want it and then let GDI+ change it from there.  This is so
    // that when we play back the GDI records, the HDC will already be set
    // up correctly so those records get played back in the right place.
    // In other words, I'm doing my own version of Context->GetHdc().

    Surface->Flush(FlushIntentionFlush);

    if (hwnd != NULL)
    {
        // We have to guarantee that we use the same HDC throughout the
        // enumeration/playing of the metafile -- so change how the HDC is
        // set up in the graphics context (if we need to).

        ASSERT(Context->Hdc == NULL);
        ASSERT(Context->SaveDc == 0);

        hdc = ::GetCleanHdc(hwnd);
        if (hdc == NULL)
        {
            WARNING(("GetCleanHdc failed"));
            return Win32Error;
        }

        Context->Hwnd = NULL;
        Context->Hdc  = hdc;
    }
    else
    {
        if ((hdc = Context->Hdc) != NULL)
        {
            // Restore the HDC back to the state the application had it in.
            Context->ResetHdc();
        }
        else    // might be a bitmap surface
        {
            hdc = Context->GetHdc(Surface);

            // Still have to call CleanTheHdc to fix bug #121666.
            // It seems like the hdc should have come back clean
            // from the context.

            if (hdc == NULL)
            {
                WARNING(("Could not get an hdc"));
                return InvalidParameter;
            }
            needToReleaseHdc = TRUE;
        }
        // Now save the state of the HDC so we can get back to it later.
        saveDC = SaveDC(hdc);

        // Get the hdc into a clean state before we start.
        Context->CleanTheHdc(hdc);
    }

    // This block needs to be within braces so that SetupClippingForMetafile
    // will have it's destructor called before the cleanup code.
    {
        // set the clipping for the down-level records
        SetupClippingForMetafilePlayback clipPlayback(hdc, Driver, Context, TRUE);
        if (!clipPlayback.IsClippedOut())
        {
            RECT        deviceClipRect;
            deviceClipRect.left   = RasterizerCeiling(deviceDestRect.X);
            deviceClipRect.top    = RasterizerCeiling(deviceDestRect.Y);
            deviceClipRect.right  = RasterizerCeiling(deviceDestRect.GetRight());
            deviceClipRect.bottom = RasterizerCeiling(deviceDestRect.GetBottom());


            // If it's a translate/scale matrix, do the transform ourselves,
            // even on NT, so that we can control how the rounding is done
            // to avoid cases where we round the metafile dest differently
            // than the clipping rect, resulting in clipped out edges.
            if (isTranslateScale)
            {
                RECT        deviceRect;
                GpPointF    points[2];

                points[0] = GpPointF(destRect.X, destRect.Y);
                points[1] = GpPointF(destRect.GetRight(), destRect.GetBottom());
                player->PreContainerMatrix.Transform(points, 2);

                // We have to use the same method to convert REAL -> INT
                // that we do when we set up the clipping.  Otherwise, some
                // of the points get rounded differently, causing a
                // portion of the metafile to get clipped out.
                deviceRect.left   = RasterizerCeiling(points[0].X);
                deviceRect.top    = RasterizerCeiling(points[0].Y);
                deviceRect.right  = RasterizerCeiling(points[1].X);
                deviceRect.bottom = RasterizerCeiling(points[1].Y);

                 // If we don't have a destrect then we are done
                if (deviceRect.left < deviceRect.right &&
                    deviceRect.top < deviceRect.bottom)
                {
                    status = player->EnumerateEmfRecords(hdc, hEmf, &deviceRect,
                                                         &deviceClipRect, EnumEmfWithDownLevel);
                }
            }
            else    // flip and/or rotate and/or shear
            {
                RECT        dest;

                dest.left   = GpRound(destRect.X);
                dest.top    = GpRound(destRect.Y);
                dest.right  = GpRound(destRect.GetRight());
                dest.bottom = GpRound(destRect.GetBottom());

                if ((dest.bottom > dest.top) && (dest.right > dest.left))
                {
                    // If we're on NT but we're drawing to a metafile hdc, then we
                    // can't rely on the transforms working for that case.
                    if (!renderToBitmap)
                    {
                        ASSERT(Globals::IsNt);

                        // set the transform for the down-level records
                        SetGraphicsMode(hdc, GM_ADVANCED);

                        ASSERT(sizeof(XFORM) == sizeof(REAL)*6);

                        // We want to set the transform in the HDC to the Pre-container matrix,
                        // so that it will be used to render the down-level records.
                        XFORM   xform;
                        player->PreContainerMatrix.GetMatrix((REAL*)(&xform));
                        ::SetWorldTransform(hdc, &xform);

                        RECT    dummyRect = {0,0,0,0};

                        status = player->EnumerateEmfRecords(hdc, hEmf, &dest,
                                                             &dummyRect, EnumEmfWithDownLevel);
                    }
                    else
                    {
                        UINT32 *    bits;
                        HBITMAP     hBitmap;

                        // The down-level records will get drawn into a dib section HDC
                        // which will then be drawn to the real hdc by g->DrawImage.
                        // !!! I should probably save the visible clip region at this
                        // point so that clipping in the EMF+ doesn't affect the down-level
                        // records.

                        // Set the World Tranform to be the PreContainer Transform
                        // And restore it after we're transformed the dest

                        player->BitmapDpi = Context->ContainerDpiX;
                        hBitmap = CreateDibSection32Bpp(hdc, destRect, dest, &bits, &player->BitmapDpi, &player->PreContainerMatrix);

                        status = GenericError;

                        if (hBitmap != NULL)
                        {
                            HDC     hdcDib = CreateCompatibleDC(NULL);

                            if (hdcDib != NULL)
                            {
                                // set up the player data
                                player->BitmapBits     = bits;
                                player->BitmapWidth    = dest.right;
                                player->BitmapHeight   = dest.bottom;
                                player->BitmapDestRect = destRect;

                                ::SelectObject(hdcDib, hBitmap);

                                status = player->EnumerateEmfRecords(hdcDib, hEmf, &dest,
                                                                     &dest, EnumEmfWithDownLevel);

                                ::DeleteDC(hdcDib);

                                // so DoneWithDownLevel call below works right
                                player->BitmapBits = NULL;
                            }
                            DeleteObject(hBitmap);
                        }
                        else if ((dest.right == 0) || (dest.bottom == 0))
                        {
                            status = Ok;
                        }
                    }
                }
            }
        }
        // else Nothing to play Everything is clipped out
    }

    // The Hdc should get set back to null when we reach the EMF+ EOF record
    // But clean up anyway, just in case something went wrong.
    player->DoneWithDownLevel();

    // Restore the HDC back to the state we initially set up.
    Context->ResetHdc();

    if (hwnd != NULL)
    {
        ReleaseDC(hwnd, hdc);

        // Now, restore the hwnd in the graphics context.
        Context->Hwnd = hwnd;
        Context->Hdc  = NULL;
    }
    else
    {
        // Now restore the HDC back to the real application state.
        RestoreDC(hdc, saveDC);

        if (needToReleaseHdc)
        {
            Context->ReleaseHdc(hdc);
        }
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   GpMetafile destructor
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpMetafile::~GpMetafile()
{
    CleanUp();
}

VOID
GpMetafile::CleanUp()
{
    if ((MetaGraphics != NULL) && (!RequestedMetaGraphics))
    {
        // If for some reason the app never requsted the MetaGraphics,
        // then we'd better delete it.
        delete MetaGraphics;
    }

    if (State == RecordingMetafileState)
    {
        // EndRecording was never called, which means that the MetaGraphics
        // was never deleted.  So clean things up and invalidate the
        // MetaGraphics.
        ASSERT(MetaGraphics->Metafile != NULL);
        MetaGraphics->Metafile->EndRecording(); // deletes the recorder
        // Endrecording sets the MetaGraphics to NULL so don't touch it anymore
        WARNING(("Deleted Metafile before deleting MetaGraphics"));
    }

    if ((Hemf != NULL) && DeleteHemf)
    {
        if (Header.IsEmfOrEmfPlus())
        {
            DeleteEnhMetaFile(Hemf);
        }
        else
        {
            DeleteMetaFile((HMETAFILE)Hemf);
        }
    }
    if (Filename != NULL)
    {
        GpFree(Filename);
    }
    else if (Stream != NULL)    // only for recording
    {
        // the stream position should already be at the end
        // of the metafile.
        Stream->Release();
    }

    delete Player;
}

extern "C"
int CALLBACK
EnumGetEmfPlusHeader(
    HDC                     hdc,    // should be NULL
    HANDLETABLE FAR *       gdiHandleTable,
    CONST ENHMETARECORD *   emfRecord,
    int                     numHandles,
    LPARAM                  emfPlusHeader
    )
{
    if ((emfRecord != NULL) && (emfRecord->nSize >= sizeof(EMR)) &&
        (emfPlusHeader != NULL))
    {
        if (emfRecord->iType == EMR_HEADER)
        {
            return 1;       // skip the header and keep enumerating
        }
        if (IsEmfPlusRecord(emfRecord) &&
            (emfRecord->nSize >= (sizeof(EMR) + sizeof(DWORD) + // comment data size
                                  sizeof(INT32) + // signature
                                  sizeof(EmfPlusRecord) +
                                  sizeof(EmfPlusHeaderRecord))))
        {
            GpMemcpy((VOID*)emfPlusHeader,
                     ((CONST EMRGDICOMMENT *)emfRecord)->Data + sizeof(INT32),
                     sizeof(EmfPlusRecord) + sizeof(EmfPlusHeaderRecord));
        }
    }
    else
    {
        WARNING(("Bad Enumeration Parameter"));
    }
    return 0;   // don't enumerate any more records
}


HENHMETAFILE
GetEmfFromWmfData(
    HMETAFILE hWmf,
    BYTE *    wmfData,
    UINT      size
    )
{
    if (wmfData == NULL ||
        hWmf == NULL ||
        size < (sizeof(METAHEADER)+sizeof(META_ESCAPE_ENHANCED_METAFILE)))
    {
        ASSERTMSG(FALSE, ("GetEmfFromWmfData: Someone passed an invalid argument"));
        return NULL;
    }

    HENHMETAFILE hemf32 = NULL;
    HDC hMFDC = NULL;
    PMETA_ESCAPE_ENHANCED_METAFILE pmfeEnhMF;
    PBYTE   pMetaData32 = (PBYTE) NULL;

    pmfeEnhMF = (PMETA_ESCAPE_ENHANCED_METAFILE) &wmfData[sizeof(METAHEADER)];
    if (IsMetaEscapeEnhancedMetafile(pmfeEnhMF))
    {
        UINT    i;
        UINT    cbMetaData32;

        if (pmfeEnhMF->fFlags != 0)
        {
            ASSERTMSG(FALSE, ("GetEmfFromWmfData: Unrecognized Windows metafile\n"));
            goto SWMFB_UseConverter;
        }

        // Validate checksum

        if (GetWordCheckSum(size, (PWORD) wmfData))
        {
            ASSERTMSG(FALSE, ("GetEmfFromWmfData: Metafile has been modified\n"));
            goto SWMFB_UseConverter;
        }

        // Unpack the data from the small chunks of metafile comment records
        // Windows 3.0 chokes on Comment Record > 8K?
        // We probably could probably just error out if out of memory but
        // lets try to convert just because the embedded comment might be bad.

        TERSE(("GetEmfFromWmfData: Using embedded enhanced metafile\n"));

        cbMetaData32 = (UINT) pmfeEnhMF->cbEnhMetaFile;
        if (!(pMetaData32 = (PBYTE) GpMalloc(cbMetaData32)))
        {
            ASSERTMSG(FALSE, ("GetEmfFromWmfData: LocalAlloc Failed"));
            goto SWMFB_UseConverter;
        }

        i = 0;
        do
        {
            if (i + pmfeEnhMF->cbCurrent > cbMetaData32)
            {
                ASSERTMSG(FALSE, ("GetEmfFromWmfData: Bad metafile comment"));
                goto SWMFB_UseConverter;
            }

            GpMemcpy(&pMetaData32[i], (PBYTE) &pmfeEnhMF[1], pmfeEnhMF->cbCurrent);
            i += (UINT) pmfeEnhMF->cbCurrent;
            pmfeEnhMF = (PMETA_ESCAPE_ENHANCED_METAFILE)
                ((PWORD) pmfeEnhMF + pmfeEnhMF->rdSize);
        } while (IsMetaEscapeEnhancedMetafile(pmfeEnhMF));

        if (i != cbMetaData32)
        {
            ASSERTMSG(FALSE, ("GetEmfFromWmfData: Insufficient metafile data"));
            goto SWMFB_UseConverter;
        }

        // Set the memory directly into the enhanced metafile and return the
        // metafile.

        hemf32 = SetEnhMetaFileBits(cbMetaData32, pMetaData32);
    }
SWMFB_UseConverter:
    if( hemf32 == NULL)
    {
        hMFDC = CreateEnhMetaFileA(NULL, NULL, NULL, NULL);
        if (hMFDC != NULL)
        {
            // Set the MapMode and Extent to
            INT iMapMode = MM_ANISOTROPIC;

            HDC hdcRef = ::GetDC(NULL);

            INT xExtPels = ::GetDeviceCaps(hdcRef, HORZRES);
            INT yExtPels = ::GetDeviceCaps(hdcRef, VERTRES);

            ::ReleaseDC(NULL, hdcRef);

            BOOL success = (::SetMapMode(hMFDC, iMapMode) &&
                            ::SetViewportExtEx(hMFDC, xExtPels, yExtPels, NULL) &&
                            ::SetWindowExtEx(hMFDC, xExtPels, yExtPels, NULL) &&
                            ::PlayMetaFile(hMFDC, hWmf));
            hemf32 = CloseEnhMetaFile(hMFDC);
            if ((!success) && (hemf32 != NULL))
            {
                DeleteEnhMetaFile(hemf32);
                hemf32 = NULL;
            }
        }
    }
    if (pMetaData32 != NULL)
    {
        GpFree(pMetaData32);
    }

    return hemf32 ;
}

GpStatus
GetEmfHeader(
    MetafileHeader &        header,
    ENHMETAHEADER3 &        emfHeader,
    EmfPlusRecord *         record,
    INT                     signature
    )
{
    GpStatus        status = Ok;

    // !!! how to handle versioning for shipping?
    // !!! allow different minor versions, but not major versions?

    EmfPlusHeaderRecord *   emfPlusHeader = (EmfPlusHeaderRecord *)(record + 1);

    // See if this is an EMF+ file
    if ((signature == EMFPLUS_SIGNATURE) &&
        (record->Size >= (sizeof(EmfPlusRecord) + sizeof(EmfPlusHeaderRecord))) &&
        (record->Type == EmfPlusRecordTypeHeader) &&
        (record->DataSize == (record->Size - sizeof(EmfPlusRecord))) &&
        (ObjectData::MajorVersionMatches(emfPlusHeader->Version)) &&
        (emfPlusHeader->LogicalDpiX > 0) &&
        (emfPlusHeader->LogicalDpiY > 0))
    {
        if (GetIsEmfPlusDual(record->Flags))
        {
            header.Type = MetafileTypeEmfPlusDual;
        }
        else
        {
            header.Type = MetafileTypeEmfPlusOnly;
        }
        header.EmfPlusHeaderSize = record->Size;
        header.Version           = emfPlusHeader->Version;
        header.EmfPlusFlags      = emfPlusHeader->EmfPlusFlags;
        header.LogicalDpiX       = emfPlusHeader->LogicalDpiX;
        header.LogicalDpiY       = emfPlusHeader->LogicalDpiY;
    }
    else
    {
        header.Type    = MetafileTypeEmf;
        header.Version = emfHeader.nVersion;
    }

    header.Size = emfHeader.nBytes;

    // EmfHeaderIsValid() verifies that these are all > 0
    REAL    dpmmX = ((REAL)(emfHeader.szlDevice.cx) /
                     (REAL)(emfHeader.szlMillimeters.cx));
    REAL    dpmmY = ((REAL)(emfHeader.szlDevice.cy) /
                     (REAL)(emfHeader.szlMillimeters.cy));

    header.DpiX = dpmmX * 25.4f;
    header.DpiY = dpmmY * 25.4f;

    INT     top;
    INT     left;
    INT     right;
    INT     bottom;

    // Make sure we have a normalized frameRect
    if (emfHeader.rclFrame.left <= emfHeader.rclFrame.right)
    {
        left  = emfHeader.rclFrame.left;
        right = emfHeader.rclFrame.right;
    }
    else
    {
        left  = emfHeader.rclFrame.right;
        right = emfHeader.rclFrame.left;
    }

    if (emfHeader.rclFrame.top <= emfHeader.rclFrame.bottom)
    {
        top    = emfHeader.rclFrame.top;
        bottom = emfHeader.rclFrame.bottom;
    }
    else
    {
        top    = emfHeader.rclFrame.bottom;
        bottom = emfHeader.rclFrame.top;
    }

    // Make the device bounds reflect the frameRect,
    // not the actual size of the drawing.
    dpmmX *= 0.01f;
    dpmmY *= 0.01f;

    // The frameRect is inclusive-inclusive, but the bounds in
    // the header is inclusive-exclusive.
    REAL    x = (REAL)(left) * dpmmX;
    REAL    y = (REAL)(top)  * dpmmY;
    REAL    w = ((REAL)(right  - left) * dpmmX) + 1.0f;
    REAL    h = ((REAL)(bottom - top)  * dpmmY) + 1.0f;

    header.X         = GpRound(x);
    header.Y         = GpRound(y);
    header.Width     = GpRound(w);
    header.Height    = GpRound(h);
    header.EmfHeader = emfHeader;

    if ((header.Width == 0) || (header.Height == 0))
    {
        status = InvalidParameter;
    }
    return status;
}

HENHMETAFILE
GetEmf(
    IStream *       stream,
    BOOL            isWmf,
    UINT            size
    )
{
    HENHMETAFILE    hEmf = NULL;
#if PROFILE_MEMORY_USAGE
    MC_LogAllocation(size);
#endif
    HGLOBAL         hGlobal = GlobalAlloc(GMEM_MOVEABLE | GMEM_NODISCARD, size);

    if (hGlobal != NULL)
    {
        HRESULT     hResult;
        IStream *   memoryStream = NULL;

        hResult = CreateStreamOnHGlobal(hGlobal, TRUE, &memoryStream);
        if (HResultSuccess(hResult) && (memoryStream != NULL))
        {
            if (CopyStream(stream, memoryStream, size))
            {
                BYTE *  metaData = (BYTE *)GlobalLock(hGlobal);

                if (metaData != NULL)
                {
                    if (isWmf)
                    {
                        hEmf = (HENHMETAFILE)SetMetaFileBitsEx(size, metaData);
                    }
                    else
                    {
                        hEmf = SetEnhMetaFileBits(size, metaData);
                    }
                }
                GlobalUnlock(hGlobal);
            }
            memoryStream->Release();    // frees the memory
        }
        else
        {
            GlobalFree(hGlobal);
        }
    }
    return hEmf;
}


static VOID
GetWmfHeader(
    MetafileHeader &                header,
    METAHEADER &                    wmfHeader,
    const WmfPlaceableFileHeader *  wmfPlaceableFileHeader
    )
{
    ASSERT(WmfPlaceableHeaderIsValid(wmfPlaceableFileHeader));
    ASSERT(WmfHeaderIsValid(&wmfHeader));

    header.Type      = MetafileTypeWmfPlaceable;
    header.Size      = wmfHeader.mtSize * 2L;
    header.Version   = wmfHeader.mtVersion;
    header.WmfHeader = wmfHeader;

    if (wmfPlaceableFileHeader->Inch > 0)
    {
        header.DpiX = wmfPlaceableFileHeader->Inch;
        header.DpiY = wmfPlaceableFileHeader->Inch;
    }
    else    // guess at the Dpi
    {
        header.DpiX = 1440.0f;
        header.DpiY = 1440.0f;
        // Something wrong but continue
    }

    // already verified the checksum

    // Unlike the EMF header the Placeable header is Inclusive-Exclusive
    // So don't add 1 device unit
    if (wmfPlaceableFileHeader->BoundingBox.Left <
        wmfPlaceableFileHeader->BoundingBox.Right)
    {
        header.X      = wmfPlaceableFileHeader->BoundingBox.Left;
        header.Width  = wmfPlaceableFileHeader->BoundingBox.Right -
                        wmfPlaceableFileHeader->BoundingBox.Left;
    }
    else
    {
        header.X      = wmfPlaceableFileHeader->BoundingBox.Right;
        header.Width  = wmfPlaceableFileHeader->BoundingBox.Left -
                        wmfPlaceableFileHeader->BoundingBox.Right;
    }
    if (wmfPlaceableFileHeader->BoundingBox.Top <
        wmfPlaceableFileHeader->BoundingBox.Bottom)
    {
        header.Y      = wmfPlaceableFileHeader->BoundingBox.Top;
        header.Height = wmfPlaceableFileHeader->BoundingBox.Bottom -
                        wmfPlaceableFileHeader->BoundingBox.Top;
    }
    else
    {
        header.Y      = wmfPlaceableFileHeader->BoundingBox.Bottom;
        header.Height = wmfPlaceableFileHeader->BoundingBox.Top -
                        wmfPlaceableFileHeader->BoundingBox.Bottom;
    }
}

extern "C"
int CALLBACK
EnumWmfToGetHeader(
    HDC                     hdc,    // should be NULL
    HANDLETABLE FAR *       gdiHandleTable,
    METARECORD FAR *        wmfRecord,
    int                     numHandles,
    LPARAM                  wmfHeader
    )
{
    ASSERT(wmfHeader != NULL);

    if ((wmfRecord != NULL) &&
        (((UNALIGNED METARECORD *)wmfRecord)->rdSize >= 3))
    {
        // The first record that it gives us is the first one past the header,
        // not the header itself, so we have to back up on the pointer.
        GpMemcpy((VOID *)wmfHeader, ((BYTE *)wmfRecord) - sizeof(METAHEADER),
                 sizeof(METAHEADER));
    }
    else
    {
        WARNING(("Bad Enumeration Parameter"));
    }
    return 0;   // Don't enumerate any more records
}

GpStatus
GetMetafileHeader(
    HMETAFILE               hWmf,
    const WmfPlaceableFileHeader *   wmfPlaceableFileHeader,
    MetafileHeader &        header
    )
{
    ASSERT((hWmf != NULL) && (wmfPlaceableFileHeader != NULL));

    GpMemset(&header, 0, sizeof(header));

    if (WmfPlaceableHeaderIsValid(wmfPlaceableFileHeader))
    {
        METAHEADER      wmfHeader;

        GpMemset(&wmfHeader, 0, sizeof(wmfHeader));
        ::EnumMetaFile(NULL, hWmf, EnumWmfToGetHeader, (LPARAM)&wmfHeader);

        if (!WmfHeaderIsValid(&wmfHeader))
        {
            //ASSERT(WmfHeaderIsValid(&wmfHeader));
            WARNING(("GetMetafileHeader: WmfHeaderIsValid FAILED!"));
            wmfHeader.mtType         = MEMORYMETAFILE;
            wmfHeader.mtHeaderSize   = sizeof(METAHEADER) / sizeof(WORD);
            wmfHeader.mtVersion      = METAVERSION300;
            wmfHeader.mtSize         = GetMetaFileBitsEx(hWmf, 0, NULL) / 2;
            wmfHeader.mtNoObjects    = 0;
            wmfHeader.mtMaxRecord    = 0;
            wmfHeader.mtNoParameters = 0;
        }

        GetWmfHeader(header, wmfHeader, wmfPlaceableFileHeader);
        return Ok;
    }
    return InvalidParameter;
}

GpStatus
GetMetafileHeader(
    HENHMETAFILE        hEmf,
    MetafileHeader &    header,
    BOOL *              isCorrupted
    )
{
    ASSERT(hEmf != NULL);

    GpMemset(&header, 0, sizeof(header));

    ENHMETAHEADER3      emfHeader;

    if ((GetEnhMetaFileHeader(hEmf, sizeof(emfHeader),
                              (ENHMETAHEADER*)(&emfHeader)) <= 0) ||
        !EmfHeaderIsValid(emfHeader))
    {
        if (isCorrupted != NULL)
        {
            *isCorrupted = FALSE;
        }
        return InvalidParameter;
    }

    // Now we know it is an EMF

    BYTE    buffer[sizeof(EmfPlusRecord) + sizeof(EmfPlusHeaderRecord)];

    GpMemset(buffer, 0, sizeof(EmfPlusRecord) + sizeof(EmfPlusHeaderRecord));

    // No reason to enumerate the metafile if there are only
    // header and EOF records.
    if (emfHeader.nRecords > 2)
    {
        ::EnumEnhMetaFile(NULL, hEmf, EnumGetEmfPlusHeader, buffer, NULL);
    }

    GpStatus status;
    status = GetEmfHeader(header, emfHeader, (EmfPlusRecord *)buffer,
                          (((EmfPlusRecord *)buffer)->Size != 0) ? EMFPLUS_SIGNATURE : 0);

    if (isCorrupted != NULL)
    {
        *isCorrupted = (status != Ok);
    }
    return status;
}

GpStatus
GetEmfFromWmf(
    IStream        * stream,
    UINT             streamSize,
    MetafileHeader & header,
    HENHMETAFILE   * hEMF
    )
{
    if (stream == NULL || hEMF == NULL)
    {
        ASSERT(FALSE);
        return InvalidParameter;
    }

    GpStatus    status = Win32Error;
    IStream *   memStream;

    ASSERT(hEMF != NULL);
    *hEMF = NULL ;

    HMETAFILE hWMF = (HMETAFILE) GetEmf(stream, TRUE, streamSize);
    if (hWMF != NULL)
    {
        BYTE * wmfData = (BYTE*)GpMalloc(streamSize);
        if (wmfData != NULL)
        {
            GetMetaFileBitsEx(hWMF, streamSize, wmfData);
            *hEMF = GetEmfFromWmfData(hWMF, wmfData, streamSize);
            if (*hEMF != NULL)
            {
                status = GetMetafileHeader(*hEMF, header);
            }
            GpFree(wmfData);
        }
    }
    if (hWMF != NULL)
    {
        DeleteMetaFile(hWMF);
    }
    return status;
}

// If we fail, the stream position will be right where it started.
// If we succeed, the stream position will be at the end of the WMF/EMF
static GpStatus
GetHeaderAndMetafile(
    IStream *           stream,
    MetafileHeader &    header,
    HENHMETAFILE *      hEMF,   // We can have a NULL hEMF, then we just want the header.
    BOOL *              isCorrupted,
    BOOL                tryWmfOnly = FALSE
    )
{
    GpMemset(&header, 0, sizeof(header));
    if (stream == NULL || isCorrupted == NULL)
    {
        WARNING(("IN Parameter Stream or Corruption flag is NULL"));
        return InvalidParameter;
    }

    GpStatus            status = InvalidParameter;
    LONGLONG            startPosition;
    LONGLONG            streamSize;
    STATSTG             statstg;
    BOOL                corrupted = FALSE;

    // Save the start position of the metafile in case we have to try
    // more than once.
    if (!GetStreamPosition(stream, startPosition))
    {
        return Win32Error;
    }

    // We don't want to read past the end of the steam so make sure
    // that we don't exceed it. If we succeed the set the streamSize
    if(SUCCEEDED(stream->Stat(&statstg, STATFLAG_NONAME)))
    {
        streamSize = statstg.cbSize.QuadPart;
    }
    else
    {
        WARNING1("Couldn't get size of Stream");
        streamSize = INT_MAX;
    }

    if (!tryWmfOnly)
    {
        ENHMETAHEADER3      emfHeader;
        BOOL                isEmf;

        // Read the EMF header and make sure it's valid
        isEmf = (ReadBytes(stream, &emfHeader, sizeof(emfHeader)) &&
                 EmfHeaderIsValid(emfHeader));

        if (isEmf)
        {
            struct EmfPlusSecondMetafileRecord {
                EMR                 emr;
                DWORD               commentDataSize;
                INT32               signature;
                EmfPlusRecord       record;
                EmfPlusHeaderRecord emfPlusHeader;
            } secondRecord;

            GpMemset(&secondRecord, 0, sizeof(secondRecord));

            // No reason to read the metafile if there are only
            // header and EOF records.
            if ((emfHeader.nRecords > 2) &&
                (emfHeader.nBytes >= (emfHeader.nSize + sizeof(secondRecord))))
            {
                if (SeekFromStart(stream, startPosition + emfHeader.nSize))
                {
                    ReadBytes(stream, &secondRecord, sizeof(secondRecord));
                    if (!IsEmfPlusRecord((ENHMETARECORD *)&secondRecord))
                    {
                        // make sure that whatever data was there isn't
                        // interpreted as a EMF+ header
                        secondRecord.signature = 0;
                    }
                }
            }

            status = GetEmfHeader(header, emfHeader, &secondRecord.record, secondRecord.signature);

            // Seek back to the start of the metafile.
            if ((hEMF != NULL) && (status == Ok))
            {
                if (!SeekFromStart(stream, startPosition))
                {
                    *isCorrupted = TRUE;
                    return Win32Error;
                }

                
                *hEMF = GetEmf(stream, FALSE /*isWMF*/,
                               (UINT)min(header.GetMetafileSize(), streamSize - startPosition));
                if (*hEMF == NULL)
                {
                    status = GenericError;
                }
            }

            corrupted = (status != Ok);
            goto Exit;
        }

        // Seek back to the start of the metafile so we can try WMF
        if (!SeekFromStart(stream, startPosition))
        {
            *isCorrupted = FALSE;
            return Win32Error;
        }
    }

    // It's not an EMF, try a WMF
    {
        WmfPlaceableFileHeader  wmfPlaceableFileHeader;
        METAHEADER              wmfHeader;
        BOOL                    isPlaceable;
        BOOL                    isWMF;

        isPlaceable = (ReadBytes(stream, &wmfPlaceableFileHeader, sizeof(wmfPlaceableFileHeader)) &&
                   WmfPlaceableHeaderIsValid(&wmfPlaceableFileHeader) &&
                   ReadBytes(stream, &wmfHeader, sizeof(wmfHeader)) &&
                   WmfHeaderIsValid(&wmfHeader));

        if (isPlaceable)
        {
            GetWmfHeader(header, wmfHeader, &wmfPlaceableFileHeader);

            status = Ok;
            corrupted = FALSE;

            if (hEMF != NULL)
            {
                if (!SeekFromStart(stream, startPosition + sizeof(wmfPlaceableFileHeader)))
                {
                    *isCorrupted = TRUE;
                    return Win32Error;
                }

                *hEMF = GetEmf(stream, TRUE /* isWMF */,
                               (UINT)min(header.GetMetafileSize(), streamSize - (startPosition + sizeof(wmfPlaceableFileHeader))));
                if (*hEMF == NULL)
                {
                    status = GenericError;
                    corrupted = TRUE;
                }
            }
            goto Exit;
        }

        // We could have an placeableWmf header with bad data in it, so skip
        // the placeable header for subsequent access to the WMF.
        INT     wmfOffset = (wmfPlaceableFileHeader.Key == GDIP_WMF_PLACEABLEKEY) ?
                             sizeof(WmfPlaceableFileHeader) : 0;

        if (!SeekFromStart(stream, startPosition + wmfOffset))
        {
            *isCorrupted = FALSE;
            return Win32Error;
        }

        isWMF = (ReadBytes(stream, &wmfHeader, sizeof(wmfHeader)) &&
                 WmfHeaderIsValid(&wmfHeader));

        if (isWMF)
        {
            // Seek to the start of the WMF metafile.
            if (!SeekFromStart(stream, startPosition + wmfOffset))
            {
                *isCorrupted = TRUE;
                return Win32Error;
            }

            UINT    wmfSize = min((wmfHeader.mtSize * 2L),
                                  (UINT)(streamSize - (startPosition + wmfOffset)));

            if (hEMF != NULL)
            {
                status = GetEmfFromWmf(stream, wmfSize, header, hEMF);
            }
            else
            {
                HENHMETAFILE    tmpEMF = NULL;

                status = GetEmfFromWmf(stream, wmfSize, header, &tmpEMF);
                if (tmpEMF != NULL)
                {
                    DeleteEnhMetaFile(tmpEMF);
                }
            }
            corrupted = (status != Ok);
        }
    }

Exit:
    *isCorrupted = corrupted;
    if (status == Ok)
    {
        // set the stream position to the end of the metafile
        SeekFromStart(stream, startPosition + header.GetMetafileSize());
        return Ok;
    }

    // set the stream position to the start of the metafile
    SeekFromStart(stream, startPosition);
    return status;
}

VOID
GpMetafile::InitStream(
    IStream*                stream,
    BOOL                    tryWmfOnly
    )
{
    BOOL        isCorrupted = FALSE;

    // We just use the stream long enough to create an hEMF
    stream->AddRef();
    if ((GetHeaderAndMetafile(stream, Header, &Hemf, &isCorrupted, tryWmfOnly) == Ok) &&
        (Hemf != NULL))
    {
        State = DoneRecordingMetafileState;
    }
    else if (isCorrupted)
    {
        State = CorruptedMetafileState;
    }
    stream->Release();
}

GpStatus
GetMetafileHeader(
    IStream *           stream,
    MetafileHeader &    header,
    BOOL                tryWmfOnly
    )
{
    BOOL isCorrupted = FALSE;
    return GetHeaderAndMetafile(stream, header, NULL, &isCorrupted, tryWmfOnly);
}

GpStatus
GetMetafileHeader(
    const WCHAR *       filename,
    MetafileHeader &    header
    )
{
    GpStatus status = InvalidParameter;

    ASSERT(filename != NULL);

    if (filename != NULL)
    {
        const WCHAR* ext = UnicodeStringReverseSearch(filename, L'.');

        // Get a stream only long enough to validate the metafile
        IStream *   metaStream = CreateStreamOnFile(filename, GENERIC_READ);
        if (metaStream != NULL)
        {
            // apm is for a Placeable Metafile
            BOOL tryWmf = (ext &&
                           (UnicodeStringCompareCI(ext, L".WMF") ||
                            UnicodeStringCompareCI(ext, L".APM")));
            BOOL isCorrupted = FALSE;

            status = GetHeaderAndMetafile(metaStream, header, NULL, &isCorrupted, tryWmf);

            // if we tried a WMF, but it's not a WMF, then try an EMF
            if ((status != Ok) && tryWmf && !isCorrupted)
            {
                status = GetHeaderAndMetafile(metaStream, header, NULL, &isCorrupted, FALSE);
            }
            metaStream->Release();
        }
    }
    return status;
}

VOID
GpMetafile::InitWmf(
    HMETAFILE               hWmf,
    const WmfPlaceableFileHeader *   wmfPlaceableFileHeader,
    BOOL                    deleteWmf
    )
{
    // See if there is an wmfPlaceableFileHeader we can use
    if ((wmfPlaceableFileHeader != NULL) && (WmfPlaceableHeaderIsValid(wmfPlaceableFileHeader)))
    {
        if (GetMetafileHeader(hWmf, wmfPlaceableFileHeader, Header) == Ok)
        {
            DeleteHemf = (deleteWmf != 0);
            Hemf       = (HENHMETAFILE)hWmf;
            State      = DoneRecordingMetafileState;
            return;
        }
        else
        {
            // we know it's a WMF, but we couldn't get the header from it
            State = CorruptedMetafileState;
        }
    }
    else    // no valid wmfPlaceableFileHeader
    {
        // We can have a null or invalid header since we accept WMF files
        // (by turning them into EMFs).
        UINT size = GetMetaFileBitsEx(hWmf, 0, NULL);
        if (size > 0)
        {
            BYTE * wmfData = (BYTE*) GpMalloc(size);
            if (wmfData != NULL)
            {
                if (GetMetaFileBitsEx(hWmf, size, wmfData) > 0)
                {
                    HENHMETAFILE hEmf = GetEmfFromWmfData(hWmf, wmfData, size);
                    if (hEmf != NULL)
                    {
                        BOOL    isCorrupted;

                        if (GetMetafileHeader(hEmf, Header, &isCorrupted) == Ok)
                        {
                            // Since we created this EMF we need to delete it afterwards
                            DeleteHemf = TRUE;
                            Hemf       = hEmf;
                            State      = DoneRecordingMetafileState;
                        }
                        else
                        {
                            if (isCorrupted)
                            {
                                // we know it's a metafile, but we couldn't get the header
                                State = CorruptedMetafileState;
                            }
                            DeleteEnhMetaFile(hEmf);
                        }
                    }
                }
                GpFree(wmfData);
            }
        }
    }
    if (deleteWmf)
    {
        DeleteMetaFile(hWmf);
    }
}

VOID
GpMetafile::InitEmf(
    HENHMETAFILE            hEmf,
    BOOL                    deleteEmf
    )
{
    BOOL    isCorrupted;

    if (GetMetafileHeader(hEmf, Header, &isCorrupted) == Ok)
    {
        DeleteHemf = (deleteEmf != 0);
        Hemf       = hEmf;
        State      = DoneRecordingMetafileState;
        return;
    }
    if (deleteEmf)
    {
        DeleteEnhMetaFile(hEmf);
    }
    if (isCorrupted)
    {
        State = CorruptedMetafileState;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   GpMetafile constructor for read-only access to a metafile.
*
* Arguments:
*
*   [IN]  hWmf          - the handle to the metafile to open for playback
*   [IN]  wmfPlaceableFileHeader - the Placeable header to give size info about the WMF
*
* Return Value:
*
*   NONE
*
* Created:
*
*   10/06/1999 DCurtis
*
\**************************************************************************/
GpMetafile::GpMetafile(
    HMETAFILE               hWmf,
    const WmfPlaceableFileHeader *   wmfPlaceableFileHeader,
    BOOL                    deleteWmf
    ) : GpImage(ImageTypeMetafile)
{
    ASSERT(hWmf != NULL);

    InitDefaults();
    if (IsValidMetaFile(hWmf))
    {
        InitWmf(hWmf, wmfPlaceableFileHeader, deleteWmf);
    }
}

/**************************************************************************\
*
* Function Description:
*
*   GpMetafile constructor for read-only access to a metafile.
*
* Arguments:
*
*   [IN]  hEmf - the handle to the metafile to open for playback
*
* Return Value:
*
*   NONE
*
* Created:
*
*   10/06/1999 DCurtis
*
\**************************************************************************/
GpMetafile::GpMetafile(
    HENHMETAFILE        hEmf,
    BOOL                deleteEmf
    ) : GpImage(ImageTypeMetafile)
{
    ASSERT(hEmf != NULL);

    InitDefaults();
    if (GetObjectTypeInternal(hEmf) == OBJ_ENHMETAFILE)
    {
        InitEmf(hEmf, deleteEmf);
    }
}

/**************************************************************************\
*
* Function Description:
*
*   GpMetafile constructor for read-only access to a metafile.
*
* Arguments:
*
*   [IN]  filename - the metafile to open for playback
*
* Return Value:
*
*   NONE
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpMetafile::GpMetafile(
    const WCHAR*            filename,
    const WmfPlaceableFileHeader *   wmfPlaceableFileHeader
    ) : GpImage(ImageTypeMetafile)
{
    ASSERT(filename != NULL);

    InitDefaults();

    if ((Filename = UnicodeStringDuplicate(filename)) != NULL)
    {
        const WCHAR* ext = UnicodeStringReverseSearch(filename, L'.');

        // apm is for a Placeable Metafile
        BOOL    tryWmf = ((wmfPlaceableFileHeader != NULL) ||
                          (ext &&
                           (!UnicodeStringCompareCI(ext, L".WMF") ||
                            !UnicodeStringCompareCI(ext, L".APM"))));

        BOOL    triedEmf = FALSE;

        AnsiStrFromUnicode nameStr(filename);

        // If possible, use the filename to create the metafile handle
        // so that we don't have to load the metafile into memory
        // (GDI uses memory mapped files to access the metafile data).
        if (Globals::IsNt || nameStr.IsValid())
        {
TryWmf:
            if (tryWmf)
            {
                HMETAFILE   hWmf;

                if (Globals::IsNt)
                {
                    hWmf = ::GetMetaFileW(filename);
                }
                else
                {
                    hWmf = ::GetMetaFileA(nameStr);
                }

                if (hWmf != NULL)
                {
                    InitWmf(hWmf, wmfPlaceableFileHeader, TRUE);
                    if (IsValid() || IsCorrupted())
                    {
                        return;
                    }
                }
                else // might be a Placeable WMF file
                {
                    IStream *   metaStream = CreateStreamOnFile(filename, GENERIC_READ);
                    if (metaStream != NULL)
                    {
                        InitStream(metaStream, TRUE /* tryWmfOnly */);
                        metaStream->Release();
                        if (IsValid() || IsCorrupted())
                        {
                            return;
                        }
                    }
                }
            }
            if (!triedEmf)
            {
                triedEmf = TRUE;

                HENHMETAFILE    hEmf;

                if (Globals::IsNt)
                {
                    hEmf = ::GetEnhMetaFileW(filename);
                }
                else
                {
                    hEmf = ::GetEnhMetaFileA(nameStr);
                }

                if (hEmf != NULL)
                {
                    InitEmf(hEmf, TRUE);
                    if (IsValid() || IsCorrupted())
                    {
                        return;
                    }
                }
                if (!tryWmf)
                {
                    tryWmf = TRUE;
                    goto TryWmf;
                }
            }
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
*   GpMetafile constructor for read-only access to a metafile.
*
* Arguments:
*
*   [IN]  stream - the metafile to read for playback
*
* Return Value:
*
*   NONE
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpMetafile::GpMetafile(
    IStream*        stream
    ) : GpImage(ImageTypeMetafile)
{
    ASSERT(stream != NULL);

    InitDefaults();
    InitStream(stream);
}

GpStatus
GpMetafile::GetHemf(
    HENHMETAFILE *      hEmf
    ) const
{
    if ((State == DoneRecordingMetafileState) ||
        (State == ReadyToPlayMetafileState))
    {
        ASSERT(Hemf != NULL);
        *hEmf = Hemf;
        Hemf = NULL;
        State = InvalidMetafileState;
        return Ok;
    }
    *hEmf = NULL;
    return InvalidParameter;
}

GpStatus
GpMetafile::PrepareToPlay(
    GpGraphics *            g,
    GpRecolor *             recolor,
    ColorAdjustType         adjustType,
    EnumerateMetafileProc   enumerateCallback,
    VOID *                  callbackData,
    DrawImageAbort          drawImageCallback,
    VOID*                   drawImageCallbackData
    ) const
{
    if (State == DoneRecordingMetafileState)
    {
        ASSERT(Hemf != NULL);
        if (Player == NULL)
        {
            // Create a Player object
            Player = new MetafilePlayer(g, MaxStackSize, recolor, adjustType,
                                        enumerateCallback, callbackData,
                                        drawImageCallback,
                                        drawImageCallbackData
                                        );
            if (!CheckValid(Player))
            {
                return GenericError;
            }
        }
        State = ReadyToPlayMetafileState;
        return Ok;
    }
    if (State == ReadyToPlayMetafileState)
    {
        ASSERT(Hemf != NULL);
        ASSERT(Player != NULL);
        Player->PrepareToPlay(g, recolor, adjustType, enumerateCallback,
                              callbackData,
                              drawImageCallback,
                              drawImageCallbackData
                              );
        return Ok;
    }
    return InvalidParameter;
}

GpStatus
GpMetafile::EnumerateForPlayback(
    const RectF &           destRect,
    const RectF &           srcRect,
    Unit                    srcUnit,
    GpGraphics *            g,
    EnumerateMetafileProc   callback,       // if null, just play the metafile
    VOID *                  callbackData,
    GpRecolor *             recolor,
    ColorAdjustType         adjustType,
    DrawImageAbort          drawImageCallback,
    VOID*                   drawImageCallbackData
    ) const
{
    ASSERT (IsValid());

    if ((destRect.Width == 0) || (destRect.Height == 0) ||
        (srcRect.Width  == 0) || (srcRect.Height  == 0) ||
        (Header.IsEmf() && (Header.EmfHeader.nRecords <= 2)))
    {
        return Ok;  // nothing to play
    }

    GpRectF     metaSrcRect  = srcRect;
    GpRectF     metaDestRect = destRect;

    // The metafile player does not handle negative width/height
    // in srcRect and destRect, so handle any negative values
    // by setting up a flipping transform.

    GpMatrix    flipMatrix; // starts as identity

    BOOL    posWidths;
    BOOL    posHeights;

    posWidths  = ((metaSrcRect.Width  >= 0) && (metaDestRect.Width  >= 0));
    posHeights = ((metaSrcRect.Height >= 0) && (metaDestRect.Height >= 0));

    if (!posWidths || !posHeights)
    {
        if (!posWidths)
        {
            if (metaSrcRect.Width < 0)
            {
                if (metaDestRect.Width < 0)
                {
                    posWidths = TRUE;
                    metaSrcRect.X      = metaSrcRect.GetRight();
                    metaSrcRect.Width  = -(metaSrcRect.Width);
                    metaDestRect.X     = metaDestRect.GetRight();
                    metaDestRect.Width = -(metaDestRect.Width);
                }
                else
                {
                    metaSrcRect.X      = metaSrcRect.GetRight();
                    metaSrcRect.Width  = -(metaSrcRect.Width);
                }
            }
            else    // metaDestRect.Width < 0
            {
                metaDestRect.X     = metaDestRect.GetRight();
                metaDestRect.Width = -(metaDestRect.Width);
            }
        }
        if (!posHeights)
        {
            if (metaSrcRect.Height < 0)
            {
                if (metaDestRect.Height < 0)
                {
                    posHeights = TRUE;
                    metaSrcRect.Y       = metaSrcRect.GetBottom();
                    metaSrcRect.Height  = -(metaSrcRect.Height);
                    metaDestRect.Y      = metaDestRect.GetBottom();
                    metaDestRect.Height = -(metaDestRect.Height);
                }
                else
                {
                    metaSrcRect.Y      = metaSrcRect.GetBottom();
                    metaSrcRect.Height = -(metaSrcRect.Height);
                }
            }
            else    // metaDestRect.Height < 0
            {
                metaDestRect.Y      = metaDestRect.GetBottom();
                metaDestRect.Height = -(metaDestRect.Height);
            }
        }
        REAL    scaleX = 1.0f;
        REAL    scaleY = 1.0f;
        REAL    dX     = 0.0f;
        REAL    dY     = 0.0f;

        // Create a matrix that is the equivalent of:
        //      1) translate to the origin
        //      2) do the flip
        //      3) translate back
        if (!posWidths)
        {
            scaleX = -1.0f;
            dX     = metaDestRect.X + metaDestRect.GetRight();
        }
        if (!posHeights)
        {
            scaleY = -1.0f;
            dY     = metaDestRect.Y + metaDestRect.GetBottom();
        }

        flipMatrix.Translate(dX, dY, MatrixOrderPrepend);
        flipMatrix.Scale(scaleX, scaleY, MatrixOrderPrepend);
    }

    // Note that even though the visibility of the destRect might be
    // fully visible, we should still setup the clipping because:
    //    (1) we might do cropping based on the srcRect
    //    (2) the frameRect of the metafile might not include all
    //        the actual drawing within the metafile.

    GpStatus            status;

    // Must convert the source rect into UnitPixels (if not already
    // in pixel units), to account for the dpi of the source metafile.
    REAL    multiplierX;
    REAL    multiplierY;

    GetPixelMultipliers(srcUnit, Header.GetDpiX(), Header.GetDpiY(),
                        &multiplierX, &multiplierY);

    GpRectF     pixelsSrcRect;

    pixelsSrcRect.X      = metaSrcRect.X * multiplierX;
    pixelsSrcRect.Y      = metaSrcRect.Y * multiplierY;
    pixelsSrcRect.Width  = metaSrcRect.Width  * multiplierX;
    pixelsSrcRect.Height = metaSrcRect.Height * multiplierY;

    INT     saveId = g->Save();

    if (saveId != 0)
    {
        // We need to take into account the region from the source that we
        // are drawing in order to do that we need to re-translate and
        // rescale and the transform. The clipping will take care of only
        // drawing the region that we are interested in.
        // In order to acheive this we need to translate the dest rect back
        // to the origin. Scale it by the same factor as the scale of the
        // src rect and then translate it back to when it should be which
        // is the scaled version of the left cropping of the src image.
        GpMatrix    preFlipPreCropTransform;
        g->GetWorldTransform(preFlipPreCropTransform);

        // apply the flipping transform
        g->MultiplyWorldTransform(flipMatrix, MatrixOrderPrepend);

        BOOL    widthsDifferent  = (Header.Width  != pixelsSrcRect.Width);
        BOOL    heightsDifferent = (Header.Height != pixelsSrcRect.Height);
        BOOL    cropOrOffset     = ((Header.X != pixelsSrcRect.X) ||
                                    (Header.Y != pixelsSrcRect.Y) ||
                                    widthsDifferent || heightsDifferent);

        if (cropOrOffset)
        {
            g->TranslateWorldTransform(((((REAL)(Header.X - pixelsSrcRect.X))
                                         *metaDestRect.Width) /pixelsSrcRect.Width)
                                        + metaDestRect.X,
                                       ((((REAL)(Header.Y - pixelsSrcRect.Y))
                                         *metaDestRect.Height)/pixelsSrcRect.Height)
                                        + metaDestRect.Y);

            REAL    xScale       = 1.0f;
            REAL    yScale       = 1.0f;

            if (widthsDifferent)
            {
                xScale = (REAL) Header.Width / pixelsSrcRect.Width;
            }
            if (heightsDifferent)
            {
                yScale = (REAL) Header.Height / pixelsSrcRect.Height;
            }
            g->ScaleWorldTransform(xScale, yScale);

            g->TranslateWorldTransform(-metaDestRect.X, -metaDestRect.Y);
        }

        // We don't use the deviceRect if we're rendering to a bitmap.
        GpMatrix    flipAndCropTransform;
        GpRectF     deviceRect = metaDestRect;

        // sets the PreContainerMatrix to the WorldToDevice Transform, which
        // includes the flipping and cropping transforms.
        if ((status = this->PrepareToPlay(g, recolor, adjustType,
                                          callback, callbackData,
                                          drawImageCallback,
                                          drawImageCallbackData)) != Ok)
        {
            goto CleanUp;
        }

        ASSERT(Player != NULL);

        State = PlayingMetafileState;

        BOOL        renderToBitmap   = FALSE;
        GpMatrix *  playMatrix       = &(Player->PreContainerMatrix);
        BOOL        isTranslateScale = playMatrix->IsTranslateScale();

        // On Win9x and WinNT (except Whistler and beyond), stretchblt calls
        // don't work if there is any flipping.

        // On Win9x text does not work if there is any flipping.
        // On WinNT, bitmap fonts don't work for 90,180,270 degree rotation
        // (but we map all bitmap fonts to true-type fonts anyway).

        if (isTranslateScale)
        {
            // if there is any flipping, render to a bitmap
            if ((playMatrix->GetM11() < 0.0f) ||
                (playMatrix->GetM22() < 0.0f))
            {
                isTranslateScale = FALSE;
                renderToBitmap   = TRUE;
            }
        }
        else
        {
            // It's okay to render rotated directly to the HDC on NT,
            // unless the dest is a metafile or the src is a WMF.
            renderToBitmap = (!Globals::IsNt ||
                              (g->Type == GpGraphics::GraphicsMetafile) ||
                              Header.IsWmf());
        }

        // Save what we have done into flipAndCropTransform. We will prepare the
        // container with this world transform since the precontainerMatrix
        // is only for the Downlevel and it needs that modified transform
        g->GetWorldTransform(flipAndCropTransform);

        // Restore the world transform to it's original self
        // (w/o flipping and cropping transform applied).
        g->SetWorldTransform(preFlipPreCropTransform);

        // When we render to a bitmap, we render the entire metafile to
        // the entire bitmap and then we clip out the cropped part of the
        // metafile from the bitmap.  So we have to set the clipping
        // when we render to a bitmap if there is any cropping.

        // It would be nice as an enhancement to just draw to a pre-cropped
        // bitmap instead of clipping out part of the bitmap, but the math
        // for that is tricky.
        if ((!renderToBitmap) || cropOrOffset)
        {
            GpMatrix    worldToDeviceTransform;
            g->GetWorldToDeviceTransform(&worldToDeviceTransform);
            if (isTranslateScale)
            {
                worldToDeviceTransform.TransformRect(deviceRect);
            }

            // Don't set the clipping if we're rendering to a bitmap,
            // because the rendering into the bitmap will do the clipping
            // automatically, and if we also clip against the graphics, we
            // sometimes clip too much, which can cause jagged edges on
            // rotated metafiles.

            // Clipping into a metafile causes problems.  For example, if
            // we're drawing outside the bounds of the referenece HDC, it
            // works fine, but then when we add clipping into the HDC, it doesn't
            // work anymore -- nothing gets drawn into the metafile, even though
            // everything is within the clipping rect (but the clipping rect is
            // outside the bounds of the reference HDC).

            if (g->Type != GpGraphics::GraphicsMetafile)
            {
                if ((!(renderToBitmap && cropOrOffset)) && isTranslateScale)
                {
                    g->SetClip(metaDestRect, CombineModeIntersect);
                }
                else    // rendering to a bitmap with cropping or
                        // rotating to the screen 
                {
                    // Since we want the filtered (smooth) edges on the
                    // bitmap, we have to add in a little extra room on
                    // the edges of our clip rect.

                    // On rotations we need to inflate by one pixel also
                    // because it seems that GDI doesn't rasterize clipregions
                    // the same we that it rasterized rects. Do rects on the
                    // edges can have pixels missing. We might be introducing
                    // more pixels that should have been clipped out but we
                    // can live with that for now.

                    GpRectF     tmpClipRect = metaDestRect;
                    REAL        xSize;
                    REAL        ySize;

                    g->GetWorldPixelSize(xSize, ySize);

                    // add 1 pixel all the way around
                    tmpClipRect.Inflate(xSize, ySize);

                    g->SetClip(tmpClipRect, CombineModeIntersect);
                }

                if (isTranslateScale)
                {
                    // We need to intersect the destRect with the Visible Clip
                    // in order to make sure that we don't draw outside the bounds
                    // in Win9x since we can't use a MetaRgn
                    GpRectF clipBounds;
                    g->GetVisibleClipBounds(clipBounds);
                    worldToDeviceTransform.TransformRect(clipBounds);
                    GpRectF::Intersect(deviceRect, deviceRect, clipBounds);
                }
            }
        }

        // If we're playing an EMF+ into another metafile, we have to be
        // careful not to double-transform points.  The HDC will have
        // the srcRect to destRect transform in it, and the graphics might
        // have a transform too, so we can end up double-transforming the
        // points of any GDI+ records that are in an EMF+ file.

        // One easy way to get around that is that if we are playing an
        // EMF+ dual, we could just play the down-level records (i.e. play it
        // as an EMF, not an EMF+), so that all the records get transformed
        // the same way.  But of course, that doesn't work if it's an
        // EMF+ only file.  A solution that works for both EMF+ dual and
        // EMF+ only is to force the GDI+ transform to be the identity so that
        // the down-level records that are generated by DriverMeta are in
        // the original coordinate system of the metafile, not in the
        // destination coordinate system (which then get transformed again
        // erroneously).
        if (Header.IsWmf() || Header.IsEmf())
        {
            status = g->EnumEmf(Player, Hemf, metaDestRect, pixelsSrcRect,
                                deviceRect, Header.GetType(),
                                isTranslateScale, renderToBitmap,
                                flipAndCropTransform);
        }
        else
        {
            ASSERT(Header.IsEmfPlus());

            // When playing from a metafile into a metafile, Win9x does NOT
            // allow you to override (reset) the srcRect->destRect metafile
            // transform.  So to keep from double transforming the records,
            // we have to set the GDI+ transform to identity, instead of
            // setting the HDC transform to identity as we would typically do.

            // When rendering to a bitmap, we don't have to worry about
            // double-transforming, because we play the metafile to the
            // bitmap HDC, not to the dest metafile hdc, so there won't
            // be a transform on the metafile hdc to mess us up.

            INT containerId;

            if ((g->Type != GpGraphics::GraphicsMetafile) || renderToBitmap)
            {
                // Now apply the flipping matrix.
                // The g->Restore call below will reset the transform.
                g->MultiplyWorldTransform(flipMatrix, MatrixOrderPrepend);

                GpRectF gdiDestRect = metaDestRect;

                // We need to calculate our transform so that the last point in the
                // src maps to the last point in the destination. This is how GDI does
                // it and we also need to do it so that we can play metafile properly
                if (pixelsSrcRect.Width >= 2.0f)
                {
                    pixelsSrcRect.Width -= 1.0f;
                }
                if (pixelsSrcRect.Height >= 2.0f)
                {
                    pixelsSrcRect.Height -= 1.0f;
                }

                if (gdiDestRect.Width >= 2.0f)
                {
                    gdiDestRect.Width -= 1.0f;
                }
                if (gdiDestRect.Height >= 2.0f)
                {
                    gdiDestRect.Height -= 1.0f;
                }

                containerId = g->BeginContainer(
                                        gdiDestRect,
                                        pixelsSrcRect,
                                        UnitPixel,
                                        (REAL)Header.LogicalDpiX,
                                        (REAL)Header.LogicalDpiY,
                                        Header.IsDisplay());
            }
            else    // we're drawing into a metafile
            {
                containerId = g->BeginContainer(
                                        TRUE,   // force xform to identity
                                        (REAL)Header.LogicalDpiX,
                                        (REAL)Header.LogicalDpiY,
                                        Header.IsDisplay());
            }

            if (containerId != 0)
            {
                // There may be GDI records that we need to play!
                status = g->EnumEmfPlusDual(Player, Hemf, metaDestRect,
                                            deviceRect, isTranslateScale, 
                                            renderToBitmap);
                g->EndContainer(containerId);
                Player->DonePlaying();  // free up objects created by Player
            }
            // make sure the status reflect the abort state of the player
            ASSERT(!Player->EnumerateAborted || (status == Aborted));
        }
CleanUp:
        g->Restore(saveId);
    }

    // Don't change the state unless we were playing the metafile
    if (State == PlayingMetafileState)
    {
        State = ReadyToPlayMetafileState;
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Initialize the metafile object members to their default values.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
VOID
GpMetafile::InitDefaults()
{
    ThreadId                = 0;
    State                   = InvalidMetafileState;
    Filename                = NULL;
    Stream                  = NULL;
    Hemf                    = NULL;
    MetaGraphics            = NULL;
    Player                  = NULL;
    MaxStackSize            = GDIP_SAVE_STACK_SIZE;
    DeleteHemf              = TRUE;
    RequestedMetaGraphics   = FALSE;

    GpMemset(&Header, 0, sizeof(Header));

    // Set the version for recording.  If we're plyaing back,
    // this will get overwritten later.
    Header.Version          = EMFPLUS_VERSION;
}

GpStatus
GpMetafile::GetImageInfo(
    ImageInfo *     imageInfo
    ) const
{
    ASSERT(imageInfo != NULL);
    ASSERT(IsValid());

    if ((State == DoneRecordingMetafileState) ||
        (State == ReadyToPlayMetafileState))
    {
        if (Header.IsEmfOrEmfPlus())
        {
            imageInfo->RawDataFormat = IMGFMT_EMF;
        }
        else    // Wmf
        {
            imageInfo->RawDataFormat = IMGFMT_WMF;
        }

        imageInfo->PixelFormat = PIXFMT_32BPP_RGB;
        imageInfo->Width       = Header.Width;
        imageInfo->Height      = Header.Height;
        imageInfo->TileWidth   = Header.Width;
        imageInfo->TileHeight  = 1;
        imageInfo->Xdpi        = Header.DpiX;
        imageInfo->Ydpi        = Header.DpiY;
        imageInfo->Flags       = SinkFlagsTopDown |
                                 SinkFlagsFullWidth |
                                 SinkFlagsScalable |
                                 SinkFlagsHasAlpha;

        return Ok;
    }
    return InvalidParameter;
}

GpImage *
GpMetafile::Clone() const
{
    GpMetafile *    clonedMetafile = NULL;

    if ((State == DoneRecordingMetafileState) ||
        (State == ReadyToPlayMetafileState))
    {
        if (Header.IsEmfOrEmfPlus())
        {
            HENHMETAFILE    hEmf = CopyEnhMetaFileA(Hemf, NULL);

            if (hEmf != NULL)
            {
                clonedMetafile = new GpMetafile(hEmf, TRUE);
                if (clonedMetafile != NULL)
                {
                    if (!clonedMetafile->IsValid())
                    {
                        DeleteEnhMetaFile(hEmf);
                        clonedMetafile->Hemf = NULL;
                        clonedMetafile->Dispose();
                        clonedMetafile = NULL;
                    }
                }
            }
        }
        else    // Wmf
        {
            HMETAFILE       hWmf = CopyMetaFileA((HMETAFILE)Hemf, NULL);

            if (hWmf != NULL)
            {
                WmfPlaceableFileHeader   wmfPlaceableFileHeader;

                wmfPlaceableFileHeader.Key                = GDIP_WMF_PLACEABLEKEY;
                wmfPlaceableFileHeader.Hmf                = 0;
                wmfPlaceableFileHeader.BoundingBox.Left   = static_cast<INT16>(Header.X);
                wmfPlaceableFileHeader.BoundingBox.Right  = static_cast<INT16>(Header.X + Header.Width);
                wmfPlaceableFileHeader.BoundingBox.Top    = static_cast<INT16>(Header.Y);
                wmfPlaceableFileHeader.BoundingBox.Bottom = static_cast<INT16>(Header.Y + Header.Height);
                wmfPlaceableFileHeader.Inch               = static_cast<INT16>(GpRound(Header.DpiX));
                wmfPlaceableFileHeader.Reserved           = 0;
                wmfPlaceableFileHeader.Checksum           = GetWmfPlaceableCheckSum(&wmfPlaceableFileHeader);

                clonedMetafile = new GpMetafile(hWmf, &wmfPlaceableFileHeader, TRUE);
                if (clonedMetafile != NULL)
                {
                    if (!clonedMetafile->IsValid())
                    {
                        DeleteMetaFile(hWmf);
                        clonedMetafile->Hemf = NULL;
                        clonedMetafile->Dispose();
                        clonedMetafile = NULL;
                    }
                }
            }
        }
    }
    return clonedMetafile;
}

GpImage*
GpMetafile::CloneColorAdjusted(
    GpRecolor *             recolor,
    ColorAdjustType         adjustType
    ) const
{
    ASSERT(recolor != NULL);

    if ((State == DoneRecordingMetafileState) ||
        (State == ReadyToPlayMetafileState))
    {
        GpMetafile* clonedMetafile;

        // FrameRect is Inclusive-Inclusive so subtrace 1 device unit
        GpRectF     frameRect((REAL)Header.X, (REAL)Header.Y,
                              (REAL)(Header.Width - 1), (REAL)(Header.Height - 1));
        EmfType     type;

        if (Header.Type <= MetafileTypeEmf)
        {
            type = EmfTypeEmfOnly;
        }
        else
        {
            // we don't need the down-level dual sections for embedded files
            type = EmfTypeEmfPlusOnly;
        }

        // It doesn't matter if we lose the description string, since this
        // metafile is just being embedded inside another one anyway.
        clonedMetafile = new GpMetafile(Globals::DesktopIc, type,
                                        &frameRect,MetafileFrameUnitPixel,NULL);

        if ((clonedMetafile != NULL) &&
            (clonedMetafile->IsValid()))
        {
            GpStatus    status;
            GpPageUnit  srcUnit;
            GpRectF     srcRect;
            GpGraphics *    g = clonedMetafile->GetGraphicsContext();
            ASSERT (g != NULL);

            this->GetBounds(&srcRect, &srcUnit);

            // We pass Inclusive-Exclusive bounds to play so add 1 device
            // unit to the framerect
            frameRect.Width++;
            frameRect.Height++;
            status = this->Play(frameRect, srcRect, srcUnit, g, recolor, adjustType);

            delete g;

            if ((status == Ok) &&
                (clonedMetafile->State == DoneRecordingMetafileState))
            {
                return clonedMetafile;
            }
        }
        delete clonedMetafile;
    }
    return NULL;
}

GpStatus
GpMetafile::ColorAdjust(
    GpRecolor *             recolor,
    ColorAdjustType         adjustType
    )
{
    ASSERT(recolor != NULL);

    GpMetafile *    clone;

    if (DeleteHemf &&
        ((clone = (GpMetafile *)CloneColorAdjusted(recolor, adjustType)) != NULL))
    {
        CleanUp();
        InitDefaults();

        if (GetMetafileHeader(clone->Hemf, Header) == Ok)
        {
            Hemf       = clone->Hemf;
            DeleteHemf = TRUE;
            State      = DoneRecordingMetafileState;
            clone->DeleteHemf = FALSE;
            delete clone;
            return Ok;
        }
    }
    return GenericError;
}

VOID
GpMetafile::Dispose()
{
    delete this;
}

class RemoveDualRecords
{
public:
    BYTE *      MetaData;
    INT         Size;
    INT         NumRecords;
    BOOL        GetGdiRecords;

    RemoveDualRecords()
    {
        Init();
    }

    VOID Init()
    {
        MetaData      = NULL;
        Size          = 0;
        NumRecords    = 0;
        GetGdiRecords = TRUE;   // so we write the EMR_HEADER record
    }

    VOID GetRecord(CONST ENHMETARECORD * emfRecord)
    {
        UINT    recordSize = emfRecord->nSize;

        if (MetaData != NULL)
        {
            GpMemcpy(MetaData, emfRecord, recordSize);
            MetaData += recordSize;
        }
        Size += recordSize;
        NumRecords++;
    }
};

extern "C"
int CALLBACK
EnumEmfRemoveDualRecords(
    HDC                     hdc,    // should be NULL
    HANDLETABLE FAR *       gdiHandleTable,
    CONST ENHMETARECORD *   emfRecord,
    int                     numHandles,
    LPARAM                  removeDualRecords
    )
{
    if ((emfRecord != NULL) && (emfRecord->nSize >= sizeof(EMR)) &&
        (removeDualRecords != NULL))
    {
        if (IsEmfPlusRecord(emfRecord))
        {
            // See if the last record of this set of EMF+ records is a GetDC
            // record.  If it is, then we know to play the next set of
            // GDI records that we encounter.

            // I prefer not to have to parse through all these records,
            // but there is always the slight possibility that this will
            // result in a false positive.  But the worst thing that can
            // happen is that we write a little too much data to the stream.

            EmfPlusRecord *     lastRecord;

            lastRecord = (EmfPlusRecord *)(((BYTE *)emfRecord) + emfRecord->nSize -
                                           sizeof(EmfPlusRecord));

            ((RemoveDualRecords *)removeDualRecords)->GetGdiRecords =
                ((lastRecord->Type == EmfPlusRecordTypeGetDC) &&
                 (lastRecord->Size == sizeof(EmfPlusRecord)) &&
                 (lastRecord->DataSize == 0));
        }
        else if ((emfRecord->iType != EMR_EOF) &&   // Write EOF record
                 (!(((RemoveDualRecords *)removeDualRecords)->GetGdiRecords)))
        {
            return 1;   // skip this GDI record
        }
        ((RemoveDualRecords *)removeDualRecords)->GetRecord(emfRecord);
    }
    else
    {
        WARNING(("Bad Enumeration Parameter"));
    }
    return 1;
}

extern "C"
int CALLBACK
EnumEmfToStream(
    HDC                     hdc,            // handle to device context
    HANDLETABLE FAR *       gdiHandleTable, // pointer to metafile handle table
    CONST ENHMETARECORD *   emfRecord,      // pointer to metafile record
    int                     numHandles,     // count of objects
    LPARAM                  stream          // pointer to optional data
    )
{
    if ((emfRecord != NULL) && (emfRecord->nSize >= sizeof(EMR)) &&
        (stream != NULL))
    {
        ((IStream *)stream)->Write(emfRecord, emfRecord->nSize, NULL);
    }
    else
    {
        WARNING(("Bad Enumeration Parameter"));
    }
    return 1;
}

class MetafileData : public ObjectTypeData
{
public:
    INT32       MetaType;
    INT32       MetaDataSize;
};

/**************************************************************************\
*
* Function Description:
*
*   Get the metafile data.
*
* Arguments:
*
*   [IN] dataBuffer - fill this buffer with the data
*   [IN/OUT] size   - IN - size of buffer; OUT - number bytes written
*
* Return Value:
*
*   GpStatus - Ok or error code
*
* Created:
*
*   9/13/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpMetafile::GetData(
    IStream *   stream
    ) const
{
    ASSERT (stream != NULL);

    if ((State != DoneRecordingMetafileState) &&
        (State != ReadyToPlayMetafileState))
    {
        WARNING(("Wrong State To GetData"));
        return WrongState;
    }

    ASSERT(Hemf != NULL);

    MetafileData    metafileData;
    metafileData.Type = ImageTypeMetafile;

    if (Header.IsWmf())
    {
        INT     wmfDataSize = GetMetaFileBitsEx((HMETAFILE)Hemf, 0, NULL);

        if (wmfDataSize <= 0)
        {
            WARNING(("Empty WMF"));
            return Win32Error;
        }

        BYTE *  wmfData = (BYTE *)GpMalloc(wmfDataSize);
        if (wmfData == NULL)
        {
            return OutOfMemory;
        }

        if (GetMetaFileBitsEx((HMETAFILE)Hemf, wmfDataSize, wmfData) == 0)
        {
            WARNING(("Problem retrieving WMF Data"));
            GpFree(wmfData);
            return Win32Error;
        }

        // We don't save MetafileTypeWmf -- we convert it to the Placeable type
        metafileData.MetaType     = MetafileTypeWmfPlaceable;
        metafileData.MetaDataSize = wmfDataSize;
        stream->Write(&metafileData, sizeof(metafileData), NULL);

        ASSERT(sizeof(WmfPlaceableFileHeader) == 22);
#define PLACEABLE_BUFFER_SIZE     (sizeof(WmfPlaceableFileHeader) + 2)
        BYTE                      placeableBuffer[PLACEABLE_BUFFER_SIZE];
        WmfPlaceableFileHeader *  wmfPlaceableFileHeader = (WmfPlaceableFileHeader *)placeableBuffer;
        REAL                      aveDpi;

        // set pad word to 0
        *((INT16 *)(placeableBuffer + sizeof(WmfPlaceableFileHeader))) = 0;

        aveDpi = (Header.GetDpiX() + Header.GetDpiY()) / 2.0f;

        wmfPlaceableFileHeader->Key                = GDIP_WMF_PLACEABLEKEY;
        wmfPlaceableFileHeader->Hmf                = 0;
        wmfPlaceableFileHeader->BoundingBox.Left   = static_cast<INT16>(Header.X);
        wmfPlaceableFileHeader->BoundingBox.Top    = static_cast<INT16>(Header.Y);
        wmfPlaceableFileHeader->BoundingBox.Right  = static_cast<INT16>(Header.X + Header.Width);
        wmfPlaceableFileHeader->BoundingBox.Bottom = static_cast<INT16>(Header.Y + Header.Height);
        wmfPlaceableFileHeader->Inch               = static_cast<INT16>(GpRound(aveDpi));
        wmfPlaceableFileHeader->Reserved           = 0;
        wmfPlaceableFileHeader->Checksum           = GetWmfPlaceableCheckSum(wmfPlaceableFileHeader);
        stream->Write(placeableBuffer, PLACEABLE_BUFFER_SIZE, NULL);
        stream->Write(wmfData, wmfDataSize, NULL);
        GpFree(wmfData);

        // align
        if ((wmfDataSize & 0x03) != 0)
        {
            INT     pad = 0;
            stream->Write(&pad, 4 - (wmfDataSize & 0x03), NULL);
        }
    }
    else if (!Header.IsEmfPlusDual())
    {
        INT     emfDataSize = GetEnhMetaFileBits(Hemf, 0, NULL);

        if (emfDataSize <= 0)
        {
            WARNING(("Empty EMF"));
            return Win32Error;
        }

        metafileData.MetaType     = Header.GetType();
        metafileData.MetaDataSize = emfDataSize;
        stream->Write(&metafileData, sizeof(metafileData), NULL);

        if (!::EnumEnhMetaFile(NULL, Hemf, EnumEmfToStream, stream, NULL))
        {
            WARNING(("Problem retrieving EMF Data"));
            return Win32Error;
        }
    }
    else    // it is EMF+ Dual.  Remove the dual records for embedding.
    {
        RemoveDualRecords   removeDualRecords;

        // First, figure out how big a buffer we need to allocate
        if (!::EnumEnhMetaFile(NULL, Hemf, EnumEmfRemoveDualRecords,
                               &removeDualRecords, NULL))
        {
            WARNING(("Problem retrieving EMF Data"));
            return Win32Error;
        }

        INT     emfDataSize = removeDualRecords.Size;

        BYTE *  emfData = (BYTE *)GpMalloc(emfDataSize);
        if (emfData == NULL)
        {
            return OutOfMemory;
        }

        removeDualRecords.Init();
        removeDualRecords.MetaData = emfData;

        if (!::EnumEnhMetaFile(NULL, Hemf, EnumEmfRemoveDualRecords,
                               &removeDualRecords, NULL))
        {
            WARNING(("Problem retrieving EMF Data"));
            GpFree(emfData);
            return Win32Error;
        }

        // make sure we get the same value back the 2nd time
        ASSERT(emfDataSize == removeDualRecords.Size);

        // We convert MetafileTypeEmfPlusDual into MetafileTypeEmfPlusOnly
        metafileData.MetaType     = MetafileTypeEmfPlusOnly;
        metafileData.MetaDataSize = removeDualRecords.Size;
        stream->Write(&metafileData, sizeof(metafileData), NULL);

        ((ENHMETAHEADER3 *)emfData)->nBytes   = removeDualRecords.Size;
        ((ENHMETAHEADER3 *)emfData)->nRecords = removeDualRecords.NumRecords;
        stream->Write(emfData, removeDualRecords.Size, NULL);
        GpFree(emfData);
    }

    return Ok;
}

UINT
GpMetafile::GetDataSize() const
{
    if ((State != DoneRecordingMetafileState) &&
        (State != ReadyToPlayMetafileState))
    {
        WARNING(("Wrong State To GetDataSize"));
        return 0;
    }

    ASSERT(Hemf != NULL);

    UINT        dataSize  = sizeof(MetafileData);

    if (Header.IsWmf())
    {
        INT     wmfDataSize = GetMetaFileBitsEx((HMETAFILE)Hemf, 0, NULL);

        if (wmfDataSize <= 0)
        {
            WARNING(("Empty WMF"));
            return 0;
        }
        // add aligned size of the placeable header and aligned wmf size
        dataSize += 24 + ((wmfDataSize + 3) & ~3);
    }
    else if (!Header.IsEmfPlusDual())
    {
        INT     emfDataSize = GetEnhMetaFileBits(Hemf, 0, NULL);

        if (emfDataSize <= 0)
        {
            WARNING(("Empty EMF"));
            return 0;
        }
        dataSize += emfDataSize;
    }
    else    // it is EMF+ Dual.  Remove the dual records for embedding.
    {
        RemoveDualRecords   removeDualRecords;

        if (!::EnumEnhMetaFile(NULL, Hemf, EnumEmfRemoveDualRecords,
                               &removeDualRecords, NULL))
        {
            WARNING(("Problem retrieving EMF Data"));
            return 0;
        }

        dataSize += removeDualRecords.Size;
    }

    return dataSize;
}

/**************************************************************************\
*
* Function Description:
*
*   Read the metafile object from memory.
*
* Arguments:
*
*   [IN] data - the data to set the metafile with
*   [IN] size - the size of the data
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   4/26/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpMetafile::SetData(
    const BYTE *        dataBuffer,
    UINT                size
    )
{
    ASSERT ((GpImageType)(((MetafileData *)dataBuffer)->Type) == ImageTypeMetafile);

    InitDefaults();

    if (dataBuffer == NULL)
    {
        WARNING(("dataBuffer is NULL"));
        return InvalidParameter;
    }

    if (size < sizeof(MetafileData))
    {
        WARNING(("size too small"));
        return InvalidParameter;
    }

    const MetafileData *    metaData;

    metaData = reinterpret_cast<const MetafileData *>(dataBuffer);

    if (!metaData->MajorVersionMatches())
    {
        WARNING(("Version number mismatch"));
        return InvalidParameter;
    }

    dataBuffer += sizeof(MetafileData);
    size -= sizeof(MetafileData);

    MetafileType    type         = (MetafileType)metaData->MetaType;
    UINT            metaDataSize = metaData->MetaDataSize;

    if (type == MetafileTypeWmfPlaceable)
    {
        HMETAFILE   hWmf;

        if (size < (metaDataSize + 24))
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        hWmf = SetMetaFileBitsEx(metaDataSize, dataBuffer + 24);
        if (hWmf != NULL)
        {
            if (GetMetafileHeader(hWmf, (WmfPlaceableFileHeader*)dataBuffer, Header) == Ok)
            {
                Hemf  = (HENHMETAFILE)hWmf;
                State = DoneRecordingMetafileState;
                return Ok;
            }
            DeleteMetaFile(hWmf);
        }
    }
    else
    {
        // We'll let the object think it's dual, even if we've removed
        // all the dual records.  It shouldn't hurt anything.
        HENHMETAFILE    hEmf;

        if (size < metaDataSize)
        {
            WARNING(("size too small"));
            return InvalidParameter;
        }

        hEmf = SetEnhMetaFileBits(metaDataSize, dataBuffer);

        if (hEmf != NULL)
        {
            BOOL    isCorrupted;

            if (GetMetafileHeader(hEmf, Header, &isCorrupted) == Ok)
            {
                Hemf  = hEmf;
                State = DoneRecordingMetafileState;
                return Ok;
            }
            if (isCorrupted)
            {
                State = CorruptedMetafileState;
            }
            DeleteEnhMetaFile(hEmf);
        }
    }
    return GenericError;
}

class CommentEPR : public EmfPlusRecordPlay
{
public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeComment);

        return;
    }
};

class GetDCEPR : public EmfPlusRecordPlay
{
public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeGetDC);

        // Flag that the next down-level records should be played.
#if 0
        // This is now done in the enumerator, so that it will happen
        // for enumeration as well as playback.
        player->PlayEMFRecords = TRUE;
#endif
    }
};

#define EMFPLUS_MAJORVERSION(v)             ((v) & 0xFFFF0000)
#define EMFPLUS_MINORVERSION(v)             ((v) & 0x0000FFFF)
#define EMF_SKIP_ALL_MULTIFORMAT_SECTIONS   0x7FFFFFFF

#define MULTIFORMATSTARTEPR_MINSIZE    (sizeof(UINT32) + sizeof(UINT32))

// Note: nesting multiformat records does NOT work.
class MultiFormatStartEPR : public EmfPlusRecordPlay
{
protected:
    UINT32          NumSections;
    UINT32          Version[1];

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeMultiFormatStart);

        if (dataSize < MULTIFORMATSTARTEPR_MINSIZE)
        {
            WARNING(("MultiFormatStartEPR::Play dataSize is too small"));
            return;
        }

        UINT    sectionToPlay = EMF_SKIP_ALL_MULTIFORMAT_SECTIONS;

        if (NumSections > 0)
        {
            if (dataSize < MULTIFORMATSTARTEPR_MINSIZE + ((NumSections - 1) * sizeof(UINT32)))
            {
                WARNING(("MultiFormatStartEPR::Play dataSize is too small"));
                return;
            }

            if ((Version[0] == EMFPLUS_VERSION) || (NumSections == 1))
            {
                sectionToPlay = 1;  // start counting from 1, not 0
            }
            else
            {
                UINT    playVersion = 0;
                UINT    curVersion;

                // The multiformat section must match the major version.
                // The first format whose minor version <= the current
                // minor version is the one we play.  If we don't find
                // one of those, then we play the one whose minor version
                // is closest to the current minor version.
                for (UINT i = 0; i < NumSections; i++)
                {
                    curVersion = Version[i];
                    if (EMFPLUS_MAJORVERSION(curVersion) ==
                        EMFPLUS_MAJORVERSION(EMFPLUS_VERSION))
                    {
                        if (EMFPLUS_MINORVERSION(curVersion) <=
                            EMFPLUS_MINORVERSION(EMFPLUS_VERSION))
                        {
                            sectionToPlay = i + 1;
                            break;
                        }
                        else if ((playVersion == 0) ||
                                 (EMFPLUS_MINORVERSION(curVersion) <
                                  EMFPLUS_MINORVERSION(playVersion)))
                        {
                            playVersion = curVersion;
                            sectionToPlay = i + 1;
                        }
                    }
                }
            }
        }
        player->MultiFormatSection     = sectionToPlay;
        player->CurFormatSection       = 0;
        player->PlayMultiFormatSection = FALSE;
    }
};

class MultiFormatSectionEPR : public EmfPlusRecordPlay
{
public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeMultiFormatSection);

        if (player->MultiFormatSection != 0)
        {
            player->PlayMultiFormatSection =
                (++(player->CurFormatSection) == player->MultiFormatSection);
        }
    }
};

class MultiFormatEndEPR : public EmfPlusRecordPlay
{
public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeMultiFormatEnd);

        player->MultiFormatSection     = 0;
        player->CurFormatSection       = 0;
        player->PlayMultiFormatSection = TRUE;
    }
};

class SetAntiAliasModeEPR : public EmfPlusRecordPlay
{
public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeSetAntiAliasMode);

        player->Graphics->SetAntiAliasMode(GetAntiAliasMode(flags));
    }
};

class SetTextRenderingHintEPR : public EmfPlusRecordPlay
{
public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeSetTextRenderingHint);

        player->Graphics->SetTextRenderingHint(GetTextRenderingHint(flags));
    }
};

class SetTextContrastEPR : public EmfPlusRecordPlay
{
public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeSetTextContrast);

        player->Graphics->SetTextContrast(GetTextContrast(flags));
    }
};

class SetInterpolationModeEPR : public EmfPlusRecordPlay
{
public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeSetInterpolationMode);

        player->Graphics->SetInterpolationMode(GetInterpolationMode(flags));
    }
};

class SetPixelOffsetModeEPR : public EmfPlusRecordPlay
{
public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeSetPixelOffsetMode);

        player->Graphics->SetPixelOffsetMode(GetPixelOffsetMode(flags));
    }
};

class SetCompositingModeEPR : public EmfPlusRecordPlay
{
public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeSetCompositingMode);

        player->Graphics->SetCompositingMode(GetCompositingMode(flags));
    }
};

class SetCompositingQualityEPR : public EmfPlusRecordPlay
{
public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeSetCompositingQuality);

        player->Graphics->SetCompositingQuality(GetCompositingQuality(flags));
    }
};

class SetRenderingOriginEPR : public EmfPlusRecordPlay
{
    INT x;
    INT y;
public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeSetRenderingOrigin);

        player->Graphics->SetRenderingOrigin(x, y);
    }
};

#define SAVEEPR_MINSIZE    (sizeof(UINT32))

class SaveEPR : public EmfPlusRecordPlay
{
protected:
    UINT32          StackIndex;

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeSave);

        if (dataSize < SAVEEPR_MINSIZE)
        {
            WARNING(("SaveEPR::Play dataSize is too small"));
            return;
        }

        player->NewSave(StackIndex, player->Graphics->Save());
    }
};

#define RESTOREEPR_MINSIZE    (sizeof(UINT32))

class RestoreEPR : public EmfPlusRecordPlay
{
protected:
    UINT32          StackIndex;

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeRestore);

        if (dataSize < RESTOREEPR_MINSIZE)
        {
            WARNING(("RestoreEPR::Play dataSize is too small"));
            return;
        }

        player->Graphics->Restore(player->GetSaveID(StackIndex));
    }
};

#define BEGINCONTAINEREPR_MINSIZE    (sizeof(GpRectF) + sizeof(GpRectF) + sizeof(UINT32))

class BeginContainerEPR : public EmfPlusRecordPlay
{
protected:
    GpRectF         DestRect;
    GpRectF         SrcRect;
    UINT32          StackIndex;

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeBeginContainer);

        if (dataSize < BEGINCONTAINEREPR_MINSIZE)
        {
            WARNING(("BeginContainerEPR::Play dataSize is too small"));
            return;
        }

        player->NewSave(StackIndex,
                        player->Graphics->BeginContainer(DestRect, SrcRect, GetPageUnit(flags)));
    }
};

#define BEGINCONTAINERNOPARAMSEPR_MINSIZE    (sizeof(UINT32))

class BeginContainerNoParamsEPR : public EmfPlusRecordPlay
{
protected:
    UINT32          StackIndex;

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeBeginContainerNoParams);

        if (dataSize < BEGINCONTAINERNOPARAMSEPR_MINSIZE)
        {
            WARNING(("BeginContainerNoParamsEPR::Play dataSize is too small"));
            return;
        }

        player->NewSave(StackIndex, player->Graphics->BeginContainer());
    }
};

#define ENDCONTAINEREPR_MINSIZE    (sizeof(UINT32))

class EndContainerEPR : public EmfPlusRecordPlay
{
protected:
    UINT32          StackIndex;

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeEndContainer);

        if (dataSize < ENDCONTAINEREPR_MINSIZE)
        {
            WARNING(("EndContainerEPR::Play dataSize is too small"));
            return;
        }

        player->Graphics->EndContainer(player->GetSaveID(StackIndex));
    }
};

#define SETWORLDTRANSFORMEPR_MINSIZE    GDIP_MATRIX_SIZE

class SetWorldTransformEPR : public EmfPlusRecordPlay
{
protected:
    REAL        MatrixData[6];

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeSetWorldTransform);

        if (dataSize < SETWORLDTRANSFORMEPR_MINSIZE)
        {
            WARNING(("SetWorldTransformEPR::Play dataSize is too small"));
            return;
        }

        GpMatrix    matrix(MatrixData[0], MatrixData[1],
                           MatrixData[2], MatrixData[3],
                           MatrixData[4], MatrixData[5]);
        player->Graphics->SetWorldTransform(matrix);
    }
};

class ResetWorldTransformEPR : public EmfPlusRecordPlay
{
public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeResetWorldTransform);

        player->Graphics->ResetWorldTransform();
    }
};

#define MULTIPLYWORLDTRANSFORMEPR_MINSIZE    GDIP_MATRIX_SIZE

class MultiplyWorldTransformEPR : public EmfPlusRecordPlay
{
protected:
    REAL        MatrixData[6];

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeMultiplyWorldTransform);

        if (dataSize < MULTIPLYWORLDTRANSFORMEPR_MINSIZE)
        {
            WARNING(("MultiplyWorldTransformEPR::Play dataSize is too small"));
            return;
        }

        GpMatrix    matrix(MatrixData[0], MatrixData[1],
                           MatrixData[2], MatrixData[3],
                           MatrixData[4], MatrixData[5]);
        player->Graphics->MultiplyWorldTransform(matrix, GetMatrixOrder(flags));
    }
};

#define TRANSLATEWORLDTRANSFORMEPR_MINSIZE    (sizeof(REAL) + sizeof(REAL))

class TranslateWorldTransformEPR : public EmfPlusRecordPlay
{
protected:
    REAL            Dx;
    REAL            Dy;

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeTranslateWorldTransform);

        if (dataSize < TRANSLATEWORLDTRANSFORMEPR_MINSIZE)
        {
            WARNING(("TranslateWorldTransformEPR::Play dataSize is too small"));
            return;
        }

        player->Graphics->TranslateWorldTransform(Dx, Dy, GetMatrixOrder(flags));
    }
};

#define SCALEWORLDTRANSFORMEPR_MINSIZE    (sizeof(REAL) + sizeof(REAL))

class ScaleWorldTransformEPR : public EmfPlusRecordPlay
{
protected:
    REAL            Sx;
    REAL            Sy;

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeScaleWorldTransform);

        if (dataSize < SCALEWORLDTRANSFORMEPR_MINSIZE)
        {
            WARNING(("ScaleWorldTransformEPR::Play dataSize is too small"));
            return;
        }

        player->Graphics->ScaleWorldTransform(Sx, Sy, GetMatrixOrder(flags));
    }
};

#define ROTATEWORLDTRANSFORMEPR_MINSIZE    (sizeof(REAL))

class RotateWorldTransformEPR : public EmfPlusRecordPlay
{
protected:
    REAL            Angle;

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeRotateWorldTransform);

        if (dataSize < ROTATEWORLDTRANSFORMEPR_MINSIZE)
        {
            WARNING(("RotateWorldTransformEPR::Play dataSize is too small"));
            return;
        }

        player->Graphics->RotateWorldTransform(Angle, GetMatrixOrder(flags));
    }
};

#define SETPAGETRANSFORMEPR_MINSIZE    (sizeof(REAL))

class SetPageTransformEPR : public EmfPlusRecordPlay
{
protected:
    REAL            Scale;

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeSetPageTransform);

        if (dataSize < SETPAGETRANSFORMEPR_MINSIZE)
        {
            WARNING(("SetPageTransformEPR::Play dataSize is too small"));
            return;
        }

        player->Graphics->SetPageTransform(GetPageUnit(flags), Scale);
    }
};

class ResetClipEPR : public EmfPlusRecordPlay
{
public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeResetClip);

        player->Graphics->ResetClip();
    }
};

#define SETCLIPRECTEPR_MINSIZE    (sizeof(GpRectF))

class SetClipRectEPR : public EmfPlusRecordPlay
{
protected:
    GpRectF     ClipRect;   // !!! Handle 16-bit rect

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeSetClipRect);

        if (dataSize < SETCLIPRECTEPR_MINSIZE)
        {
            WARNING(("SetClipRectEPR::Play dataSize is too small"));
            return;
        }

        player->Graphics->SetClip(ClipRect, GetCombineMode(flags));
    }
};

class SetClipPathEPR : public EmfPlusRecordPlay
{
public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeSetClipPath);

        player->Graphics->SetClip((GpPath *)player->GetObject(GetMetaObjectId(flags), ObjectTypePath), GetCombineMode(flags), GetIsDevicePath(flags));
    }
};

class SetClipRegionEPR : public EmfPlusRecordPlay
{
public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeSetClipRegion);

        player->Graphics->SetClip((GpRegion *)player->GetObject(GetMetaObjectId(flags), ObjectTypeRegion), GetCombineMode(flags));

    }
};

#define OFFSETCLIPEPR_MINSIZE    (sizeof(REAL) + sizeof(REAL))

class OffsetClipEPR : public EmfPlusRecordPlay
{
protected:
    REAL        Dx;
    REAL        Dy;

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeOffsetClip);

        if (dataSize < OFFSETCLIPEPR_MINSIZE)
        {
            WARNING(("OffsetClipEPR::Play dataSize is too small"));
            return;
        }

        player->Graphics->OffsetClip(Dx, Dy);
    }
};

#define OBJECTEPR_MINSIZE    (sizeof(UINT32))

class ObjectEPR : public EmfPlusRecordPlay
{
protected:
    BYTE        ObjectData[1];

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        if (dataSize < OBJECTEPR_MINSIZE)
        {
            WARNING(("ObjectEPR::Play dataSize is too small"));
            return;
        }

        player->AddObject(flags, ObjectData, dataSize);
    }
};

#define CLEAREPR_MINSIZE    (sizeof(UINT32))

class ClearEPR : public EmfPlusBoundsRecord
{
protected:
    ARGB      Color;

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeClear);

        if (dataSize < CLEAREPR_MINSIZE)
        {
            WARNING(("ClearEPR::Play dataSize is too small"));
            return;
        }

        GpColor color;

        color.SetColor(Color);

        player->Graphics->Clear(color);
    }
};

#define FILLRECTSEPR_MINSIZE    (sizeof(UINT32) + sizeof(UINT32))

class FillRectsEPR : public EmfPlusBoundsRecord
{
protected:
    UINT32      BrushValue;
    UINT32      Count;
    BYTE        RectData[1];    // GpRect16 or GpRectF

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeFillRects);

        if (dataSize < FILLRECTSEPR_MINSIZE)
        {
            WARNING(("FillRectsEPR::Play dataSize is too small"));
            return;
        }

        GpBrush *       brush = player->GetBrush(BrushValue, flags);
        GpRectF *       rects = player->GetRects(RectData, dataSize - FILLRECTSEPR_MINSIZE, Count, flags);

        if (rects != NULL)
        {
            if (brush != NULL)
            {
                player->Graphics->FillRects(brush, rects, Count);
            }
            player->FreePointsBuffer();
        }
    }
};

#define DRAWRECTSEPR_MINSIZE    (sizeof(UINT32))

class DrawRectsEPR : public EmfPlusBoundsRecord
{
protected:
    UINT32      Count;
    BYTE        RectData[1];    // GpRect16 or GpRectF

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeDrawRects);

        if (dataSize < DRAWRECTSEPR_MINSIZE)
        {
            WARNING(("DrawRectsEPR::Play dataSize is too small"));
            return;
        }

        GpPen *         pen   = (GpPen *)player->GetObject(GetMetaObjectId(flags), ObjectTypePen);
        GpRectF *       rects = player->GetRects(RectData, dataSize - DRAWRECTSEPR_MINSIZE, Count, flags);

        if (rects != NULL)
        {
            if (pen != NULL)
            {
                player->Graphics->DrawRects(pen, rects, Count);
            }
            player->FreePointsBuffer();
        }
    }
};

#define FILLPOLYGONEPR_MINSIZE    (sizeof(UINT32) + sizeof(UINT32))

class FillPolygonEPR : public EmfPlusBoundsRecord
{
protected:
    UINT32      BrushValue;
    UINT32      Count;
    BYTE        PointData[1];   // GpPoint16 or GpPointF

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeFillPolygon);

        if (dataSize < FILLPOLYGONEPR_MINSIZE)
        {
            WARNING(("FillPolygonEPR::Play dataSize is too small"));
            return;
        }

        GpBrush *       brush  = player->GetBrush(BrushValue, flags);
        GpPointF *      points = player->GetPoints(PointData, dataSize - FILLPOLYGONEPR_MINSIZE, Count, flags);

        if (points != NULL)
        {
            if (brush != NULL)
            {
                player->Graphics->FillPolygon(brush, points, Count, GetFillMode(flags));
            }
            player->FreePointsBuffer();
        }
    }
};

#define DRAWLINESEPR_MINSIZE    (sizeof(UINT32))

class DrawLinesEPR : public EmfPlusBoundsRecord
{
protected:
    UINT32      Count;
    BYTE        PointData[1];   // GpPoint16 or GpPointF

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeDrawLines);

        if (dataSize < DRAWLINESEPR_MINSIZE)
        {
            WARNING(("DrawLinesEPR::Play dataSize is too small"));
            return;
        }

        GpPen *         pen   = (GpPen *)player->GetObject(GetMetaObjectId(flags), ObjectTypePen);
        GpPointF *      points = player->GetPoints(PointData, dataSize - DRAWLINESEPR_MINSIZE, Count, flags);

        if (points != NULL)
        {
            if (pen != NULL)
            {
                player->Graphics->DrawLines(pen, points, Count, IsClosed(flags));
            }
            player->FreePointsBuffer();
        }
    }
};

#define FILLELLIPSEEPR_MINSIZE    (sizeof(UINT32))

class FillEllipseEPR : public EmfPlusBoundsRecord
{
protected:
    UINT32      BrushValue;
    BYTE        RectData[1];    // GpRect16 or GpRectF

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeFillEllipse);

        if (dataSize < FILLELLIPSEEPR_MINSIZE)
        {
            WARNING(("FillEllipseEPR::Play dataSize is too small"));
            return;
        }

        GpBrush *       brush = player->GetBrush(BrushValue, flags);
        GpRectF *       rect  = player->GetRects(RectData, dataSize - FILLELLIPSEEPR_MINSIZE, 1, flags);

        if (brush != NULL)
        {
            player->Graphics->FillEllipse(brush, *rect);
        }
    }
};

class DrawEllipseEPR : public EmfPlusBoundsRecord
{
protected:
    BYTE        RectData[1];    // GpRect16 or GpRectF

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeDrawEllipse);

        GpPen *         pen   = (GpPen *)player->GetObject(GetMetaObjectId(flags), ObjectTypePen);
        GpRectF *       rect  = player->GetRects(RectData, dataSize, 1, flags);

        if (pen != NULL)
        {
            player->Graphics->DrawEllipse(pen, *rect);
        }
    }
};

#define FILLPIEEPR_MINSIZE    (sizeof(UINT32) + sizeof(REAL) + sizeof(REAL))

class FillPieEPR : public EmfPlusBoundsRecord
{
protected:
    UINT32      BrushValue;
    REAL        StartAngle;
    REAL        SweepAngle;
    BYTE        RectData[1];    // GpRect16 or GpRectF

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeFillPie);

        if (dataSize < FILLPIEEPR_MINSIZE)
        {
            WARNING(("FillPieEPR::Play dataSize is too small"));
            return;
        }

        GpBrush *       brush = player->GetBrush(BrushValue, flags);
        GpRectF *       rect  = player->GetRects(RectData, dataSize - FILLPIEEPR_MINSIZE, 1, flags);

        if (brush != NULL)
        {
            player->Graphics->FillPie(brush, *rect, StartAngle, SweepAngle);
        }
    }
};

#define DRAWPIEEPR_MINSIZE    (sizeof(REAL) + sizeof(REAL))

class DrawPieEPR : public EmfPlusBoundsRecord
{
protected:
    REAL        StartAngle;
    REAL        SweepAngle;
    BYTE        RectData[1];    // GpRect16 or GpRectF

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeDrawPie);

        if (dataSize < DRAWPIEEPR_MINSIZE)
        {
            WARNING(("DrawPieEPR::Play dataSize is too small"));
            return;
        }

        GpPen *         pen   = (GpPen *)player->GetObject(GetMetaObjectId(flags), ObjectTypePen);
        GpRectF *       rect  = player->GetRects(RectData, dataSize - DRAWPIEEPR_MINSIZE, 1, flags);

        if (pen != NULL)
        {
            player->Graphics->DrawPie(pen, *rect, StartAngle, SweepAngle);
        }
    }
};

#define DRAWARCEPR_MINSIZE    (sizeof(REAL) + sizeof(REAL))

class DrawArcEPR : public EmfPlusBoundsRecord
{
protected:
    REAL        StartAngle;
    REAL        SweepAngle;
    BYTE        RectData[1];    // GpRect16 or GpRectF

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeDrawArc);

        if (dataSize < DRAWARCEPR_MINSIZE)
        {
            WARNING(("DrawArcEPR::Play dataSize is too small"));
            return;
        }

        GpPen *         pen   = (GpPen *)player->GetObject(GetMetaObjectId(flags), ObjectTypePen);
        GpRectF *       rect  = player->GetRects(RectData, dataSize - DRAWARCEPR_MINSIZE, 1, flags);

        if (pen != NULL)
        {
            player->Graphics->DrawArc(pen, *rect, StartAngle, SweepAngle);
        }
    }
};

#define FILLREGIONEPR_MINSIZE    (sizeof(UINT32))

class FillRegionEPR : public EmfPlusBoundsRecord
{
protected:
    UINT32      BrushValue;

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeFillRegion);

        if (dataSize < FILLREGIONEPR_MINSIZE)
        {
            WARNING(("FillRegionEPR::Play dataSize is too small"));
            return;
        }

        GpBrush *       brush  = player->GetBrush(BrushValue, flags);
        GpRegion *      region = (GpRegion *)player->GetObject(GetMetaObjectId(flags), ObjectTypeRegion);

        if ((brush != NULL) && (region != NULL))
        {
            player->Graphics->FillRegion(brush, region);
        }
    }
};

#define FILLPATHEPR_MINSIZE    (sizeof(UINT32))

class FillPathEPR : public EmfPlusBoundsRecord
{
protected:
    UINT32      BrushValue;

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeFillPath);

        if (dataSize < FILLPATHEPR_MINSIZE)
        {
            WARNING(("FillPathEPR::Play dataSize is too small"));
            return;
        }

        GpBrush *       brush = player->GetBrush(BrushValue, flags);
        GpPath *        path  = (GpPath *)player->GetObject(GetMetaObjectId(flags), ObjectTypePath);
        if ((brush != NULL) && (path != NULL))
        {
            player->Graphics->FillPath(brush, path);
        }
    }
};

#define DRAWPATHEPR_MINSIZE    (sizeof(UINT32))

class DrawPathEPR : public EmfPlusBoundsRecord
{
protected:
    UINT32      PenId;

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeDrawPath);

        if (dataSize < DRAWPATHEPR_MINSIZE)
        {
            WARNING(("DrawPathEPR::Play dataSize is too small"));
            return;
        }

        GpPen *         pen   = (GpPen *)player->GetObject(PenId, ObjectTypePen);
        GpPath *        path  = (GpPath *)player->GetObject(GetMetaObjectId(flags), ObjectTypePath);

        if ((pen != NULL) && (path != NULL))
        {
            player->Graphics->DrawPath(pen, path);
        }
    }
};

#define FILLCLOSEDCURVEEPR_MINSIZE    (sizeof(UINT32) + sizeof(REAL) + sizeof(UINT32))

class FillClosedCurveEPR : public EmfPlusBoundsRecord
{
protected:
    UINT32      BrushValue;
    REAL        Tension;
    UINT32      Count;
    BYTE        PointData[1];   // GpPoint16 or GpPointF

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeFillClosedCurve);

        if (dataSize < FILLCLOSEDCURVEEPR_MINSIZE)
        {
            WARNING(("FillClosedCurveEPR::Play dataSize is too small"));
            return;
        }

        GpBrush *       brush  = player->GetBrush(BrushValue, flags);
        GpPointF *      points = player->GetPoints(PointData, dataSize - FILLCLOSEDCURVEEPR_MINSIZE, Count, flags);

        if (points != NULL)
        {
            if (brush != NULL)
            {
                player->Graphics->FillClosedCurve(brush, points, Count,Tension,GetFillMode(flags));
            }
            player->FreePointsBuffer();
        }
    }
};

#define DRAWCLOSEDCURVEEPR_MINSIZE    (sizeof(REAL) + sizeof(UINT32))

class DrawClosedCurveEPR : public EmfPlusBoundsRecord
{
protected:
    REAL        Tension;
    UINT32      Count;
    BYTE        PointData[1];   // GpPoint16 or GpPointF

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeDrawClosedCurve);

        if (dataSize < DRAWCLOSEDCURVEEPR_MINSIZE)
        {
            WARNING(("DrawClosedCurveEPR::Play dataSize is too small"));
            return;
        }

        GpPen *         pen   = (GpPen *)player->GetObject(GetMetaObjectId(flags), ObjectTypePen);
        GpPointF *      points = player->GetPoints(PointData, dataSize - DRAWCLOSEDCURVEEPR_MINSIZE, Count, flags);

        if (points != NULL)
        {
            if (pen != NULL)
            {
                player->Graphics->DrawClosedCurve(pen, points, Count, Tension);
            }
            player->FreePointsBuffer();
        }
    }
};

#define DRAWCURVEEPR_MINSIZE    (sizeof(REAL) + sizeof(INT32) + sizeof(UINT32) + sizeof(UINT32))

class DrawCurveEPR : public EmfPlusBoundsRecord
{
protected:
    REAL        Tension;
    INT32       Offset;
    UINT32      NumSegments;
    UINT32      Count;
    BYTE        PointData[1];   // GpPoint16 or GpPointF

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeDrawCurve);

        if (dataSize < DRAWCURVEEPR_MINSIZE)
        {
            WARNING(("DrawCurveEPR::Play dataSize is too small"));
            return;
        }

        GpPen *         pen   = (GpPen *)player->GetObject(GetMetaObjectId(flags), ObjectTypePen);
        GpPointF *      points = player->GetPoints(PointData, dataSize - DRAWCURVEEPR_MINSIZE, Count, flags);

        if (points != NULL)
        {
            if (pen != NULL)
            {
                player->Graphics->DrawCurve(pen, points, Count, Tension, Offset, NumSegments);
            }
            player->FreePointsBuffer();
        }
    }
};

#define DRAWBEZIERSEPR_MINSIZE    (sizeof(UINT32))

class DrawBeziersEPR : public EmfPlusBoundsRecord
{
protected:
    UINT32      Count;
    BYTE        PointData[1];   // GpPoint16 or GpPointF

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeDrawBeziers);

        if (dataSize < DRAWBEZIERSEPR_MINSIZE)
        {
            WARNING(("DrawBeziersEPR::Play dataSize is too small"));
            return;
        }

        GpPen *         pen   = (GpPen *)player->GetObject(GetMetaObjectId(flags), ObjectTypePen);
        GpPointF *      points = player->GetPoints(PointData, dataSize - DRAWBEZIERSEPR_MINSIZE, Count, flags);

        if (points != NULL)
        {
            if (pen != NULL)
            {
                player->Graphics->DrawBeziers(pen, points, Count);
            }
            player->FreePointsBuffer();
        }
    }
};

#define DRAWIMAGEEPR_MINSIZE    (sizeof(INT32) + sizeof(GpRectF))

class DrawImageEPR : public EmfPlusBoundsRecord
{
protected:
    UINT32      ImageAttributesId;
    INT32       SrcUnit;
    GpRectF     SrcRect;
    BYTE        RectData[1];    // GpRect16 or GpRectF

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeDrawImage);

        if (dataSize < DRAWIMAGEEPR_MINSIZE)
        {
            WARNING(("DrawImageEPR::Play dataSize is too small"));
            return;
        }

        GpImage *image    = (GpImage *)player->GetObject(GetMetaObjectId(flags), ObjectTypeImage);
        GpRectF *destRect = player->GetRects(RectData, dataSize - DRAWIMAGEEPR_MINSIZE, 1, flags);
        GpImageAttributes *imageAttributes =
            (GpImageAttributes *)player->GetObject(
                ImageAttributesId,
                ObjectTypeImageAttributes
            );

        if ( (image != NULL) && (NULL != destRect) )
        {
            GpStatus status = player->Graphics->DrawImage(
                image,
                *destRect,
                SrcRect,
                static_cast<GpPageUnit>(SrcUnit),
                imageAttributes,
                player->DrawImageCallback,
                player->DrawImageCallbackData
                );
            if (status == Aborted)
            {
                // stop enumerating records
                player->EnumerateAborted = TRUE;
            }
        }
    }
};

#define DRAWIMAGEPOINTSEPR_MINSIZE    (sizeof(INT32) + sizeof(GpRectF) + sizeof(UINT32))

class DrawImagePointsEPR : public EmfPlusBoundsRecord
{
protected:
    UINT32      ImageAttributesId;
    INT32       SrcUnit;
    GpRectF     SrcRect;
    UINT32      Count;
    BYTE        PointData[1];   // GpPoint16 or GpPointF

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeDrawImagePoints);

        if (dataSize < DRAWIMAGEPOINTSEPR_MINSIZE)
        {
            WARNING(("DrawImagePointsEPR::Play dataSize is too small"));
            return;
        }

        GpImage *image      = (GpImage *)player->GetObject(GetMetaObjectId(flags), ObjectTypeImage);
        GpPointF *destPoints = player->GetPoints(PointData, dataSize - DRAWIMAGEPOINTSEPR_MINSIZE, Count, flags);
        GpImageAttributes *imageAttributes =
            (GpImageAttributes *)player->GetObject(
                ImageAttributesId,
                ObjectTypeImageAttributes
            );

        if (destPoints != NULL)
        {
            if (image != NULL)
            {
                GpStatus status = player->Graphics->DrawImage(
                    image,
                    destPoints,
                    Count,
                    SrcRect,
                    static_cast<GpPageUnit>(SrcUnit),
                    imageAttributes,
                    player->DrawImageCallback,
                    player->DrawImageCallbackData
                    );
                if (status == Aborted)
                {
                    // stop enumerating records
                    player->EnumerateAborted = TRUE;
                }
            }
            player->FreePointsBuffer();
        }
    }
};

#define DRAWSTRINGEPR_MINSIZE    (sizeof(UINT32) + sizeof(UINT32) + sizeof(UINT32) + sizeof(GpRectF))

class DrawStringEPR : public EmfPlusBoundsRecord
{
protected:
    UINT32      BrushValue;
    UINT32      FormatId;
    UINT32      Length;
    GpRectF     LayoutRect;
    BYTE        StringData[1];

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeDrawString);

        if (dataSize < DRAWSTRINGEPR_MINSIZE)
        {
            WARNING(("DrawStringEPR::Play dataSize is too small"));
            return;
        }

        GpBrush *       brush  = player->GetBrush(BrushValue, flags);
        GpFont *        font   = (GpFont *)player->GetObject(GetMetaObjectId(flags), ObjectTypeFont);

        // Optional parameter - can return NULL.

        GpStringFormat *format = (GpStringFormat *)player->GetObject(
            FormatId,
            ObjectTypeStringFormat
        );

        if (Length > 0)
        {
            if (dataSize >= (DRAWSTRINGEPR_MINSIZE + (Length * sizeof(WCHAR))))
            {
                if ((brush != NULL) && (font != NULL))
                {
                    // !!! TODO:
                    // Determine whether the string is compressed or not.
                    // If so, decompress it.

                    player->Graphics->DrawString(
                        (WCHAR *)StringData,
                        Length,
                        font,
                        &LayoutRect,
                        format,
                        brush
                    );
                }
            }
            else
            {
                WARNING(("DrawStringEPR::Play dataSize is too small"));
                return;
            }

            player->FreePointsBuffer();
        }
    }
};


#define DRAWDRIVERSTRINGEPR_MINSIZE    (sizeof(UINT32) + sizeof(INT) + sizeof(UINT32) + sizeof(UINT32))

class DrawDriverStringEPR : public EmfPlusBoundsRecord
{
protected:
    UINT32      BrushValue;
    INT         ApiFlags;
    UINT32      MatrixPresent;
    UINT32      GlyphCount;
    BYTE        Data[1];

public:
    VOID Play(
        MetafilePlayer *        player,
        EmfPlusRecordType       recordType,
        UINT                    flags,
        UINT                    dataSize
        ) const
    {
        ASSERT(recordType == EmfPlusRecordTypeDrawDriverString);

        if (dataSize < DRAWDRIVERSTRINGEPR_MINSIZE)
        {
            WARNING(("DrawDriverStringEPR::Play dataSize is too small"));
            return;
        }

        GpBrush *       brush  = player->GetBrush(BrushValue, flags);
        GpFont *        font   = (GpFont *)player->GetObject(GetMetaObjectId(flags), ObjectTypeFont);

        if (GlyphCount > 0)
        {
            UINT requiredSize = DRAWDRIVERSTRINGEPR_MINSIZE  +
                                (GlyphCount * sizeof(WCHAR)) +
                                (GlyphCount * sizeof(PointF));
            if (dataSize >= requiredSize)
            {
                if ((brush != NULL) && (font != NULL))
                {
                    WCHAR  *text      = (WCHAR *) Data;
                    PointF *positions = (PointF *) (Data + (GlyphCount * sizeof(WCHAR)));

                    if (MatrixPresent > 0)
                    {
                        if (dataSize < requiredSize + GDIP_MATRIX_SIZE)
                        {
                            WARNING(("DrawDriverStringEPR::Play dataSize is too small"));
                            return;
                        }

                        REAL *matrixData = (REAL *)((BYTE *) ((BYTE *)positions) +
                                           (GlyphCount * sizeof(PointF)));

                        GpMatrix matrix(matrixData);

                        player->Graphics->DrawDriverString(
                            (unsigned short *)text,
                            GlyphCount,
                            font,
                            brush,
                            positions,
                            ApiFlags | DriverStringOptionsMetaPlay,
                            &matrix);
                    }
                    else
                    {
                        player->Graphics->DrawDriverString(
                            (unsigned short *)text,
                            GlyphCount,
                            font,
                            brush,
                            positions,
                            ApiFlags,
                            NULL);
                    }
                }
            }
            else
            {
                WARNING(("DrawDriverStringEPR::Play dataSize is too small"));
                return;
            }

            player->FreePointsBuffer();
        }
    }
};



// The order of these methods must exactly match
// the order of the enums of the record numbers.
PLAYRECORDFUNC RecordPlayFuncs[EmfPlusRecordTypeMax - EmfPlusRecordTypeMin + 1] = {
    (PLAYRECORDFUNC)&EmfPlusHeaderRecord::Play, // Header
    (PLAYRECORDFUNC)&EmfPlusRecordPlay::Play,   // EndOfFile

    (PLAYRECORDFUNC)&CommentEPR::Play,

    (PLAYRECORDFUNC)&GetDCEPR::Play,

    (PLAYRECORDFUNC)&MultiFormatStartEPR::Play,
    (PLAYRECORDFUNC)&MultiFormatSectionEPR::Play,
    (PLAYRECORDFUNC)&MultiFormatEndEPR::Play,

    // For all persistent objects
    (PLAYRECORDFUNC)&ObjectEPR::Play,

    // Drawing Records
    (PLAYRECORDFUNC)&ClearEPR::Play,
    (PLAYRECORDFUNC)&FillRectsEPR::Play,
    (PLAYRECORDFUNC)&DrawRectsEPR::Play,
    (PLAYRECORDFUNC)&FillPolygonEPR::Play,
    (PLAYRECORDFUNC)&DrawLinesEPR::Play,
    (PLAYRECORDFUNC)&FillEllipseEPR::Play,
    (PLAYRECORDFUNC)&DrawEllipseEPR::Play,
    (PLAYRECORDFUNC)&FillPieEPR::Play,
    (PLAYRECORDFUNC)&DrawPieEPR::Play,
    (PLAYRECORDFUNC)&DrawArcEPR::Play,
    (PLAYRECORDFUNC)&FillRegionEPR::Play,
    (PLAYRECORDFUNC)&FillPathEPR::Play,
    (PLAYRECORDFUNC)&DrawPathEPR::Play,
    (PLAYRECORDFUNC)&FillClosedCurveEPR::Play,
    (PLAYRECORDFUNC)&DrawClosedCurveEPR::Play,
    (PLAYRECORDFUNC)&DrawCurveEPR::Play,
    (PLAYRECORDFUNC)&DrawBeziersEPR::Play,
    (PLAYRECORDFUNC)&DrawImageEPR::Play,
    (PLAYRECORDFUNC)&DrawImagePointsEPR::Play,
    (PLAYRECORDFUNC)&DrawStringEPR::Play,

    // Graphics State Records
    (PLAYRECORDFUNC)&SetRenderingOriginEPR::Play,
    (PLAYRECORDFUNC)&SetAntiAliasModeEPR::Play,
    (PLAYRECORDFUNC)&SetTextRenderingHintEPR::Play,
    (PLAYRECORDFUNC)&SetTextContrastEPR::Play,
    (PLAYRECORDFUNC)&SetInterpolationModeEPR::Play,
    (PLAYRECORDFUNC)&SetPixelOffsetModeEPR::Play,
    (PLAYRECORDFUNC)&SetCompositingModeEPR::Play,
    (PLAYRECORDFUNC)&SetCompositingQualityEPR::Play,
    (PLAYRECORDFUNC)&SaveEPR::Play,
    (PLAYRECORDFUNC)&RestoreEPR::Play,
    (PLAYRECORDFUNC)&BeginContainerEPR::Play,
    (PLAYRECORDFUNC)&BeginContainerNoParamsEPR::Play,
    (PLAYRECORDFUNC)&EndContainerEPR::Play,
    (PLAYRECORDFUNC)&SetWorldTransformEPR::Play,
    (PLAYRECORDFUNC)&ResetWorldTransformEPR::Play,
    (PLAYRECORDFUNC)&MultiplyWorldTransformEPR::Play,
    (PLAYRECORDFUNC)&TranslateWorldTransformEPR::Play,
    (PLAYRECORDFUNC)&ScaleWorldTransformEPR::Play,
    (PLAYRECORDFUNC)&RotateWorldTransformEPR::Play,
    (PLAYRECORDFUNC)&SetPageTransformEPR::Play,
    (PLAYRECORDFUNC)&ResetClipEPR::Play,
    (PLAYRECORDFUNC)&SetClipRectEPR::Play,
    (PLAYRECORDFUNC)&SetClipPathEPR::Play,
    (PLAYRECORDFUNC)&SetClipRegionEPR::Play,
    (PLAYRECORDFUNC)&OffsetClipEPR::Play,
    (PLAYRECORDFUNC)&DrawDriverStringEPR::Play,

    // New record types must be added here (at the end) -- do not add above,
    // since that will invalidate previous metafiles!
};

HENHMETAFILE
GetEmf(
    const WCHAR *               fileName,
    MetafileType                type
    )
{
    HENHMETAFILE    hEmf = NULL;

    if (type == MetafileTypeWmfPlaceable)
    {
        IStream *       wmfStream;
        IStream *       memStream;

        wmfStream = CreateStreamOnFile(fileName, GENERIC_READ);
        if (wmfStream != NULL)
        {
            STATSTG     statstg;
            HRESULT     hResult;

            hResult = wmfStream->Stat(&statstg, STATFLAG_NONAME);
            if (!HResultSuccess(hResult))
            {
                wmfStream->Release();
                return hEmf;
            }
            INT size = (INT)(statstg.cbSize.QuadPart - sizeof(WmfPlaceableFileHeader));

            if (SeekFromStart(wmfStream, sizeof(WmfPlaceableFileHeader)))
            {
                HGLOBAL     hGlobal;

                hGlobal = GlobalAlloc(GMEM_MOVEABLE | GMEM_NODISCARD, size);
                if (hGlobal != NULL)
                {
                    hResult = CreateStreamOnHGlobal(hGlobal, TRUE, &memStream);
                    if (HResultSuccess(hResult) && (memStream != NULL))
                    {
                        if (CopyStream(wmfStream, memStream, size))
                        {
                            BYTE *  wmfData = (BYTE *)GlobalLock(hGlobal);

                            if (wmfData != NULL)
                            {
                                hEmf = (HENHMETAFILE)
                                            SetMetaFileBitsEx(size, wmfData);
                                GlobalUnlock(hGlobal);
                            }
                        }
                        memStream->Release();
                    }
                    else
                    {
                        GlobalFree(hGlobal);
                    }
                }
            }
            wmfStream->Release();
        }
    }
    else
    {
        if (Globals::IsNt)
        {
            hEmf = GetEnhMetaFileW(fileName);
        }
        else // Windows 9x - non-Unicode
        {
            AnsiStrFromUnicode nameStr(fileName);

            if (nameStr.IsValid())
            {
                hEmf = GetEnhMetaFileA(nameStr);
            }
        }
    }

    return hEmf;
}

#if 0   // don't need this right now
WCHAR *
GetTemporaryFilename()
{
    if (Globals::IsNt)
    {
        WCHAR   pathBuffer[MAX_PATH + 1];
        WCHAR   fileBuffer[MAX_PATH + 12 + 1];  // 12 for filename itself
        UINT    len = GetTempPathW(MAX_PATH, pathBuffer);

        if ((len == 0) || (len > MAX_PATH))
        {
            pathBuffer[0] = L'.';
            pathBuffer[1] = L'\0';
        }
        if (GetTempFileNameW(pathBuffer, L"Emp", 0, fileBuffer) == 0)
        {
            return NULL;
        }
        return UnicodeStringDuplicate(fileBuffer);
    }
    else // Windows 9x - non-Unicode
    {
        CHAR    pathBuffer[MAX_PATH + 1];
        CHAR    fileBuffer[MAX_PATH + 12 + 1];  // 12 for filename itself
        UINT    len = GetTempPathA(MAX_PATH, pathBuffer);

        if ((len == 0) || (len > MAX_PATH))
        {
            pathBuffer[0] = '.';
            pathBuffer[1] = '\0';
        }
        if (GetTempFileNameA(pathBuffer, "Emp", 0, fileBuffer) == 0)
        {
            return NULL;
        }
        len = (strlen(fileBuffer) + 1) * sizeof(WCHAR);
        WCHAR * filename = (WCHAR *)GpMalloc(len);
        if (filename != NULL)
        {
            if (AnsiToUnicodeStr(fileBuffer, filename, len))
            {
                return filename;
            }
            GpFree(filename);
        }
        return NULL;
    }
}
#endif

// For now, don't handle a source rect
GpBitmap *
GpMetafile::GetBitmap(
    INT                 width,
    INT                 height,
    const GpImageAttributes * imageAttributes
    )
{
    GpRectF         srcRect;
    GpPageUnit      srcUnit;

    this->GetBounds(&srcRect, &srcUnit);

    ASSERT(srcUnit == UnitPixel);

    // Determine what size to make the bitmap.

    if ((width <= 0) || (height <= 0))
    {
        if (this->IsEmfOrEmfPlus())
        {
            width  = GpRound(srcRect.Width);
            height = GpRound(srcRect.Height);
        }
        else    // must be a WMF
        {
            // Convert size to use the dpi of this display.
            // This is somewhat of a hack, but what else could I do,
            // since I don't know where this brush will be used?
            REAL        srcDpiX;
            REAL        srcDpiY;
            REAL        destDpiX = Globals::DesktopDpiX;    // guess
            REAL        destDpiY = Globals::DesktopDpiY;

            this->GetResolution(&srcDpiX, &srcDpiY);

            if ((srcDpiX <= 0) || (srcDpiY <= 0))
            {
                WARNING(("bad dpi for WMF"));
                return NULL;
            }

            width  = GpRound((srcRect.Width  / srcDpiX) * destDpiX);
            height = GpRound((srcRect.Height / srcDpiY) * destDpiY);
        }
        if ((width <= 0) || (height <= 0))
        {
            WARNING(("bad size for metafile"));
            return NULL;
        }
    }

    GpBitmap *  bitmapImage = new GpBitmap(width, height, PIXFMT_32BPP_ARGB);

    if (bitmapImage != NULL)
    {
        if (bitmapImage->IsValid())
        {
            GpGraphics *    graphics = bitmapImage->GetGraphicsContext();

            if (graphics != NULL)
            {
                if (graphics->IsValid())
                {
                    // we have to lock the graphics so the driver doesn't assert
                    GpLock * lockGraphics = new GpLock(graphics->GetObjectLock());

                    if (lockGraphics != NULL)
                    {
                        ASSERT(lockGraphics->IsValid());

                        // now draw the metafile into the bitmap image
                        GpRectF     destRect(0.0f, 0.0f, (REAL)width, (REAL)height);

                        // We don't want to interpolate the bitmaps in WMFs
                        // and EMFs when converting them to a texture.
                        graphics->SetInterpolationMode(InterpolationModeNearestNeighbor);

                        GpStatus status;

                        status = graphics->DrawImage(
                                        this,
                                        destRect,
                                        srcRect,
                                        srcUnit,
                                        imageAttributes);

                        // have to delete the lock before deleting the graphics
                        delete lockGraphics;

                        if (status == Ok)
                        {
                            delete graphics;
                            return bitmapImage;
                        }
                        WARNING(("DrawImage failed"));
                    }
                    else
                    {
                        WARNING(("Could not create graphics lock"));
                    }
                }
                else
                {
                    WARNING(("graphics from bitmap image not valid"));
                }
                delete graphics;
            }
            else
            {
                WARNING(("could not create graphics from bitmap image"));
            }
        }
        else
        {
            WARNING(("bitmap image is not valid"));
        }
        bitmapImage->Dispose();
    }
    else
    {
        WARNING(("could not create bitmap image"));
    }
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\largeint.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   LargeInt.hpp
*
* Abstract:
*
*   Large Integer Wrapper
*
* Created:
*
*   4/26/1999 Mike Hillberg
*
\**************************************************************************/

#ifndef _LARGEINT_HPP
#define _LARGEINT_HPP


template <class TXLargeInteger, class TSubType, class TQuadType>
// Either LARGE_INTEGER/LONG/LONGLONG or ULARGE_INTEGER/ULONG/ULONGLONG
class TXLargeIntegerWrapper
{

public:

    TXLargeIntegerWrapper()
    {
        QuadPart = 0;
    }

    TXLargeIntegerWrapper( const TXLargeIntegerWrapper &xliWrapper )
    {
        QuadPart = xliWrapper.QuadPart;
    }

    TXLargeIntegerWrapper( const TXLargeInteger xli )
    {
        QuadPart = xli.QuadPart;
    }

    TXLargeIntegerWrapper( const int i )
    {
        QuadPart = i;
    }

    TXLargeIntegerWrapper( const ULONG ul )
    {
        LowPart = ul;
        HighPart = 0;
    }

    TXLargeIntegerWrapper( const UINT ui )
    {
        LowPart = ui;
        HighPart = 0;
    }

    TXLargeIntegerWrapper( const LONG l )
    {
        QuadPart = static_cast<TSubType>(l);    // Sign-extend
    }

    TXLargeIntegerWrapper( const TQuadType q )
    {
        QuadPart = q;
    }


public:

    TXLargeIntegerWrapper &operator=( const TXLargeIntegerWrapper xli )
    {
        QuadPart = xli.QuadPart;
        return(*this);
    }


public:

    BOOL operator==( const TXLargeIntegerWrapper xli ) const
    {
        return( QuadPart == xli.QuadPart );
    }

    BOOL operator!=( const TXLargeIntegerWrapper xli ) const
    {
        return( QuadPart != xli.QuadPart );
    }

    BOOL operator<( const TXLargeIntegerWrapper xli ) const 
    {
        return( QuadPart < xli.QuadPart );
    }

    BOOL operator<=( const TXLargeIntegerWrapper xli ) const
    {
        return( QuadPart <= xli.QuadPart );
    }

    BOOL operator>( const TXLargeIntegerWrapper xli ) const
    {
        return( QuadPart > xli.QuadPart );
    }

    BOOL operator>=( TXLargeIntegerWrapper xli ) const
    {
        return( QuadPart >= xli.QuadPart );
    }

    TXLargeIntegerWrapper operator-() const
    {
	TXLargeIntegerWrapper ret;
	ret.QuadPart = -QuadPart;
	return( ret );
    }

public:

    TXLargeIntegerWrapper operator+( TXLargeIntegerWrapper xli )
    {
        TXLargeIntegerWrapper ret;
        ret.QuadPart = QuadPart + xli.QuadPart;
        return(ret);
    }

    TXLargeIntegerWrapper& operator+=( TXLargeIntegerWrapper xli )
    {
        QuadPart += xli.QuadPart;
        return(*this);
    }

    TXLargeIntegerWrapper& operator++( )	// prefix
    {
        ++QuadPart;
        return(*this);
    }

    TXLargeIntegerWrapper operator++(int)	// postfix
    {
		TQuadType QuadPartReturn = QuadPart++;
        return(QuadPartReturn);
    }

    TXLargeIntegerWrapper operator-( TXLargeIntegerWrapper xli )
    {
        TXLargeIntegerWrapper ret;
        ret.QuadPart = QuadPart - xli.QuadPart;
        return(ret);
    }
	
    TXLargeIntegerWrapper& operator-=( TXLargeIntegerWrapper xli )
    {
        QuadPart -= xli.QuadPart;
        return(*this);
    }

    TXLargeIntegerWrapper& operator--( )	// prefix
    {
        --QuadPart;
        return(*this);
    }

    TXLargeIntegerWrapper operator--(int)	// postfix
    {
		TQuadType QuadPartReturn = QuadPart--;
        return(QuadPartReturn);
    }

public:

    TXLargeIntegerWrapper& operator*( TXLargeIntegerWrapper xli )
    {
        TXLargeIntegerWrapper ret;
        ret.QuadPart = QuadPart * xli.QuadPart;
        return(ret);
    }

    TXLargeIntegerWrapper& operator*=( TXLargeIntegerWrapper xli )
    {
        QuadPart *= xli.QuadPart;
        return( *this );
    }


public:

    TXLargeInteger* operator&()
    {
        return( reinterpret_cast<TXLargeInteger*>(this) );
    }

public:

    operator ULARGE_INTEGER() const
    {
        ULARGE_INTEGER uli;
        uli.HighPart = HighPart;
        uli.LowPart = LowPart;
        return( uli );
    }

    operator LARGE_INTEGER() const
    {
        LARGE_INTEGER li;
        li.HighPart = HighPart;
        li.LowPart = LowPart;
        return( li );
    }


public:

    typedef DWORD          typeLowPart;
    typedef TSubType       typeHighPart;
    typedef TQuadType      typeQuadPart;
    typedef TXLargeInteger typeWholePart;

    union
    {
        struct
        {
            typeLowPart LowPart;
            typeHighPart HighPart;
        };
        typeQuadPart QuadPart;
    };
};


typedef TXLargeIntegerWrapper<LARGE_INTEGER, LONG, LONGLONG>   CLargeInteger;
typedef TXLargeIntegerWrapper<ULARGE_INTEGER, ULONG, ULONGLONG> CULargeInteger;

#endif // #ifndef _LARGEINT_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\metarecord.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   MetaFile.cpp
*
* Abstract:
*
*   Metafile object handling
*
* Created:
*
*   4/14/1999 DCurtis
*
\**************************************************************************/

#include "precomp.hpp"
#include "..\imaging\api\comutils.hpp"

#define META_FORMAT_ENHANCED        0x10000         // Windows NT format

VOID
FrameToMM100(
    const GpRectF *         frameRect,
    GpPageUnit              frameUnit,
    GpRectF &               frameRectMM100,
    REAL                    dpiX,               // only used for pixel case
    REAL                    dpiY
    );

/**************************************************************************\
*
* Function Description:
*
*   Determine if the REAL points can be converted to GpPoint16 points without
*   losing accuracy.  If so, then do the conversion, and set the flags to say
*   we're using 16-bit points.
*
* Arguments:
*
*   [IN]      points        - the REAL points to try to convert
*   [IN]      count         - the number of points
*
* Return Value:
*
*   NONE
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
MetafilePointData::MetafilePointData(
    const GpPointF *    points,
    INT                 count
    )
{
    ASSERT((count > 0) && (points != NULL));

    // Assume that the conversion to GpPoint16 will fail
    PointData     = (BYTE *)points;
    PointDataSize = count * sizeof(points[0]);
    Flags         = 0;
    AllocedPoints = NULL;

    GpPoint16 *  points16 = PointBuffer;

    if (count > GDIP_POINTDATA_BUFFERSIZE)
    {
        AllocedPoints = new GpPoint16[count];
        if (AllocedPoints == NULL)
        {
            return; // live with REAL data
        }
        points16 = AllocedPoints;
    }

    GpPoint16 *     curPoint16 = points16;
    INT             i          = count;

    do
    {
        curPoint16->X = (INT16)GpRound(points->X);
        curPoint16->Y = (INT16)GpRound(points->Y);

        if (!IsPoint16Equal(curPoint16, points))
        {
            return; // the point data doesn't fit in 16 bits per value
        }
        curPoint16++;
        points++;
    } while (--i > 0);

    // We succeeded in converting the point data to 16 bits per value
    PointData     = (BYTE *)points16;
    PointDataSize = count * sizeof(points16[0]);
    Flags         = GDIP_EPRFLAGS_COMPRESSED;
}

/**************************************************************************\
*
* Function Description:
*
*   Determine if the REAL rects can be converted to GpRect16 points without
*   losing accuracy.  If so, then do the conversion, and set the flags to say
*   we're using 16-bit rects.
*
* Arguments:
*
*   [IN]      rects         - the REAL rects to try to convert
*   [IN]      count         - the number of rects
*
* Return Value:
*
*   NONE
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
MetafileRectData::MetafileRectData(
    const GpRectF *     rects,
    INT                 count
    )
{
    ASSERT((count > 0) && (rects != NULL));

    // Assume that the conversion to GpRect16 will fail
    RectData     = (BYTE *)rects;
    RectDataSize = count * sizeof(rects[0]);
    Flags        = 0;
    AllocedRects = NULL;

    GpRect16 *  rects16 = RectBuffer;

    if (count > GDIP_RECTDATA_BUFFERSIZE)
    {
        AllocedRects = new GpRect16[count];
        if (AllocedRects == NULL)
        {
            return; // live with REAL data
        }
        rects16 = AllocedRects;
    }

    GpRect16 *  curRect16 = rects16;
    INT         i         = count;

    do
    {
        curRect16->X      = (INT16)GpRound(rects->X);
        curRect16->Y      = (INT16)GpRound(rects->Y);
        curRect16->Width  = (INT16)GpRound(rects->Width);
        curRect16->Height = (INT16)GpRound(rects->Height);

        if (!IsRect16Equal(curRect16, rects))
        {
            return; // the rect data doesn't fit in 16 bits per value
        }
        curRect16++;
        rects++;
    } while (--i > 0);

    // We succeeded in converting the rect data to 16 bits per value
    RectData     = (BYTE *)rects16;
    RectDataSize = count * sizeof(rects16[0]);
    Flags        = GDIP_EPRFLAGS_COMPRESSED;
}

///////////////////////////////////////////////////////////////////////////
// classes for handling recording of objects within the metafile

class MetafileRecordObject
{
friend class MetafileRecordObjectList;
protected:
    const GpObject *    ObjectPointer;
    UINT                Uid;
    ObjectType          Type;
    UINT                Next;
    UINT                Prev;

public:
    MetafileRecordObject()
    {
        ObjectPointer     = NULL;
        Uid               = 0;
        Type              = ObjectTypeInvalid;
        Next              = GDIP_LIST_NIL;
        Prev              = GDIP_LIST_NIL;
    }

    const GpObject * GetObject() const
    {
        return ObjectPointer;
    }
    UINT GetUid() const
    {
        return Uid;
    }
    ObjectType GetType() const
    {
        return Type;
    }
};

class MetafileRecordObjectList
{
protected:
    INT                     Count;
    UINT                    LRU;
    UINT                    MRU;
    MetafileRecordObject    Objects[GDIP_MAX_OBJECTS];

public:
    MetafileRecordObjectList()
    {
        Count    = 0;
        LRU      = GDIP_LIST_NIL;
        MRU      = GDIP_LIST_NIL;
    }

    MetafileRecordObject * GetMetaObject(UINT metaObjectID)
    {
        ASSERT(metaObjectID < GDIP_MAX_OBJECTS);
        return Objects + metaObjectID;
    }

    // Search through the list, starting at the MRU entry, to see if we
    // can find the object.  If we do find it, return the index to the
    // object in metaObjectId (even if the Uid's don't match).  Return
    // TRUE only if we found the object and the Uid's match.
    BOOL
    IsInList(
        const GpObject *            object,
        ObjectType                  objectType,
        UINT32 *                    metaObjectId
        );

#if 0   // not used
    VOID
    RemoveAt(
        UINT32                      metaObjectId
        );
#endif

    // if metaObjectId is GDIP_LIST_NIL, use the next available slot
    VOID
    InsertAt(
        const GpObject *            object,
        UINT32 *                    metaObjectId
        );

    VOID
    UpdateMRU(
        UINT32                      metaObjectId
        );
};

// Search through the list, starting at the MRU entry, to see if we
// can find the object.  If we do find it, return the index to the
// object in metaObjectId (even if the Uid's don't match).  Return
// TRUE only if we found the object and the Uid's match.
BOOL
MetafileRecordObjectList::IsInList(
    const GpObject *            object,
    ObjectType                  objectType,
    UINT32 *                    metaObjectId
    )
{
    ASSERT(object != NULL);
    ASSERT(metaObjectId != NULL);

    BOOL        isInList = FALSE;

    isInList = FALSE;               // indicate object not found
    *metaObjectId = GDIP_LIST_NIL;  // indicate object not found

    if (Count != 0)
    {
        UINT    curIndex;
        UINT    uid;

        curIndex = MRU;
        uid      = object->GetUid();

        do
        {
            if (Objects[curIndex].ObjectPointer == object)
            {
                *metaObjectId = curIndex;
                isInList = ((Objects[curIndex].Uid  == uid) &&
                            (Objects[curIndex].Type == objectType));
                break;
            }
            curIndex = Objects[curIndex].Prev;
        } while (curIndex != GDIP_LIST_NIL);
    }

    return isInList;
}

#if 0   // not used
// We don't actually remove it from the list, we just put it at the
// front of the LRU so its spot gets used next.  So the count stays
// the same.
VOID
MetafileRecordObjectList::RemoveAt(
    UINT32                  metaObjectId
    )
{
    ASSERT(metaObjectId < GDIP_MAX_OBJECTS);

    MetafileRecordObject *      removeObject = Objects + metaObjectId;

    ASSERT(Count > 0);
    removeObject->ObjectPointer     = NULL;
    removeObject->Uid               = 0;
    removeObject->Type              = EmfPlusRecordTypeInvalid;

    INT     removeNext = removeObject->Next;
    INT     removePrev = removeObject->Prev;

    if (removeNext != GDIP_LIST_NIL)
    {
        Objects[removeNext].Prev = removePrev;
    }
    else
    {
        ASSERT(MRU == metaObjectId);
        if (removePrev != GDIP_LIST_NIL)
        {
            MRU = removePrev;
        }
    }

    if (removePrev != GDIP_LIST_NIL)
    {
        ASSERT(LRU != metaObjectId);
        Objects[removePrev].Next = removeNext;
        removeObject->Prev = GDIP_LIST_NIL;
        removeObject->Next = LRU;
        Objects[LRU].Prev = metaObjectId;
        LRU = metaObjectId;
    }
    else
    {
        ASSERT(LRU == metaObjectId);
    }
}
#endif

// Make the specified object the MRU object.
VOID
MetafileRecordObjectList::UpdateMRU(
    UINT32                      metaObjectId
    )
{
    if (MRU != metaObjectId)
    {
        // Now we know there are at least 2 objects
        MetafileRecordObject *      object = &Objects[metaObjectId];
        if (LRU != metaObjectId)
        {
            Objects[object->Prev].Next = object->Next;
        }
        else
        {
            LRU = object->Next;
        }
        Objects[object->Next].Prev = object->Prev;
        object->Prev = MRU;
        object->Next = GDIP_LIST_NIL;
        Objects[MRU].Next = metaObjectId;
        MRU = metaObjectId;
    }
}

// if metaObjectId is GDIP_LIST_NIL, use the next available slot
VOID
MetafileRecordObjectList::InsertAt(
    const GpObject *            object,
    UINT32 *                    metaObjectId
    )
{
    MetafileRecordObject *      newObject;
    UINT                        newIndex = *metaObjectId;

    if (newIndex == GDIP_LIST_NIL)
    {
        if (Count != 0)
        {
            // use freed object before adding new one
            if ((Objects[LRU].ObjectPointer == NULL) ||
                (Count == GDIP_MAX_OBJECTS))
            {
                newIndex = LRU;
UseLRU:
                LRU = Objects[newIndex].Next;
                Objects[LRU].Prev = GDIP_LIST_NIL;
            }
            else
            {
                newIndex = Count++;
            }
InsertObject:
            Objects[MRU].Next = newIndex;

SetupObject:
            *metaObjectId                = newIndex;
            newObject                    = &Objects[newIndex];
            newObject->Next              = GDIP_LIST_NIL;
            newObject->Prev              = MRU;
            MRU                          = newIndex;
UseMRU:
            newObject->ObjectPointer     = object;
            newObject->Uid               = object->GetUid();
            newObject->Type              = object->GetObjectType();
            return;
        }
        // else first object
        newIndex = 0;
        LRU      = 0;
        Count    = 1;
        goto SetupObject;
    }
    else    // we already know where to put the object
    {
        ASSERT(Count > 0);
        ASSERT(newIndex < GDIP_MAX_OBJECTS);

        if (newIndex == MRU)
        {
            // This covers the case where there is only 1 object
            newObject = &Objects[newIndex];
            goto UseMRU;
        }
        // else there must be at least 2 objects
        ASSERT(Count > 1);

        if (newIndex == LRU)
        {
            goto UseLRU;
        }
        // Move middle object to MRU
        newObject = &Objects[newIndex];
        Objects[newObject->Prev].Next = newObject->Next;
        Objects[newObject->Next].Prev = newObject->Prev;
        goto InsertObject;
    }
}

#define GDIP_MAX_COMMENT_SIZE         65020 // must be <= 65520 for Win9x bug

class EmfPlusCommentStream : public IUnknownBase<IStream>
{
private:
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

protected:
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagEmfPlusCommentStream : ObjectTagInvalid;
    }

public:
    EmfPlusCommentStream(HDC hdc)
    {
        ASSERT(hdc != NULL);

        MetafileHdc                 = hdc;
        Position                    = 0;   // starts after signature
        ((INT32 *)CommentBuffer)[0] = EMFPLUS_SIGNATURE;
        RecordDataStart             = CommentBuffer + sizeof(INT32);
        ContinuingObjectRecord      = FALSE;
        SetValid(TRUE);
    }

    ~EmfPlusCommentStream()
    {
        this->Flush();
    }

    BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagEmfPlusCommentStream) || (Tag == ObjectTagInvalid));
        return (Tag == ObjectTagEmfPlusCommentStream);
    }

    ULONG SpaceLeft() const
    {
        return (GDIP_MAX_COMMENT_SIZE - Position);
    }

    VOID
    EndObjectRecord()
    {
        ASSERT ((Position & 0x03) == 0);    // records should be 4-byte aligned

        if (ContinuingObjectRecord)
        {
            ContinuingObjectRecord = FALSE;
            if (Position > sizeof(EmfPlusContinueObjectRecord))
            {
                // Fix up the size of the last chunck of this object record
                EmfPlusContinueObjectRecord *   recordData;
                recordData = (EmfPlusContinueObjectRecord *)RecordDataStart;
                recordData->Size     = Position;
                recordData->DataSize = Position - sizeof(EmfPlusRecord);
            }
            else
            {
                // The object record ended exacly at the end of the buffer
                // and has already been flushed.
                Position = 0;
            }
        }
    }

    VOID
    WriteRecordHeader(
        UINT32                      dataSize,       // size of data (w/o record header)
        EmfPlusRecordType           type,
        INT                         flags           // 16 bits of flags
        );

    VOID Flush();

    HRESULT STDMETHODCALLTYPE Write(
        VOID const HUGEP *pv,
        ULONG cb,
        ULONG *pcbWritten)
    {
        if (cb == 0)
        {
            if (pcbWritten != NULL)
            {
                *pcbWritten = cb;
            }
            return S_OK;
        }

        ASSERT (pv != NULL);

        if (IsValid())
        {
            // We've already written the record header; now we're writing
            // the record data.
            ASSERT(Position >= sizeof(EmfPlusRecord));

            ULONG   spaceLeft = SpaceLeft();
            BYTE *  recordData = RecordDataStart + Position;

            // We flush as soon as we reach the end.  We don't wait for
            // the next write call to flush.
            ASSERT(spaceLeft > 0);

            if (pcbWritten)
            {
                *pcbWritten = cb;
            }

            // see if there is enough room for the data
            if (cb <= spaceLeft)
            {
                GpMemcpy(recordData, pv, cb);
                Position += cb;

                if (Position < GDIP_MAX_COMMENT_SIZE)
                {
                    return S_OK;
                }
                this->Flush();
                if (IsValid())
                {
                    return S_OK;
                }
                if (pcbWritten)
                {
                    *pcbWritten = 0;
                }
                return E_FAIL;
            }

            ASSERT(ContinuingObjectRecord);

        LoopStart:
            GpMemcpy(recordData, pv, spaceLeft);
            Position += spaceLeft;
            if (Position == GDIP_MAX_COMMENT_SIZE)
            {
                this->Flush();
                if (!IsValid())
                {
                    if (pcbWritten)
                    {
                        *pcbWritten = 0;    // not accurate, but who cares!
                    }
                    return E_FAIL;
                }
            }
            cb -= spaceLeft;
            if (cb == 0)
            {
                return S_OK;
            }
            pv = ((BYTE *)pv) + spaceLeft;
            recordData = RecordDataStart + sizeof(EmfPlusContinueObjectRecord);
            spaceLeft  = GDIP_MAX_COMMENT_SIZE-sizeof(EmfPlusContinueObjectRecord);
            if (spaceLeft > cb)
            {
                spaceLeft = cb;
            }
            goto LoopStart;
        }
        return E_FAIL;
    }

    HRESULT STDMETHODCALLTYPE Read(
        VOID HUGEP *pv,
        ULONG cb,
        ULONG *pcbRead)
    {
        return E_NOTIMPL;
    }

    HRESULT STDMETHODCALLTYPE Seek(
        LARGE_INTEGER dlibMove,
        DWORD dwOrigin,
        ULARGE_INTEGER *plibNewPosition)
    {
        return E_NOTIMPL;
    }

    HRESULT STDMETHODCALLTYPE SetSize(
        ULARGE_INTEGER libNewSize)
    {
        return E_NOTIMPL;
    }

    HRESULT STDMETHODCALLTYPE CopyTo(
        IStream *pstm,
        ULARGE_INTEGER cb,
        ULARGE_INTEGER *pcbRead,
        ULARGE_INTEGER *pcbWritten)
    {
        return E_NOTIMPL;
    }

    HRESULT STDMETHODCALLTYPE Commit(
        DWORD grfCommitFlags)
    {
        return E_NOTIMPL;
    }

    HRESULT STDMETHODCALLTYPE Revert(VOID)
    {
        return E_NOTIMPL;
    }

    HRESULT STDMETHODCALLTYPE LockRegion(
        ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb,
        DWORD dwLockType)
    {
        return E_NOTIMPL;
    }

    HRESULT STDMETHODCALLTYPE UnlockRegion(
        ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb,
        DWORD dwLockType)
    {
        return E_NOTIMPL;
    }

    HRESULT STDMETHODCALLTYPE Stat(
        STATSTG *pstatstg,
        DWORD grfStatFlag)
    {
        return E_NOTIMPL;
    }

    HRESULT STDMETHODCALLTYPE Clone(
        IStream **ppstm)
    {
        return E_NOTIMPL;
    }

private:
    BYTE    CommentBuffer[GDIP_MAX_COMMENT_SIZE + sizeof(INT32)];
    BYTE *  RecordDataStart;
    ULONG   Position;
    HDC     MetafileHdc;
    BOOL    ContinuingObjectRecord;
};

VOID
EmfPlusCommentStream::Flush()
{
    ASSERT ((Position & 0x03) == 0);    // records should be 4-byte aligned

    if (IsValid() && (Position >= sizeof(EmfPlusRecord)))
    {
        // write the signature as well as the records
        SetValid(GdiComment(MetafileHdc, (INT)Position + sizeof(INT32),
                            CommentBuffer) != 0);

#if DBG
        if (!IsValid())
        {
            WARNING(("Failed to write GdiComment"));
        }
#endif

        if (!ContinuingObjectRecord)
        {
            Position = 0;
        }
        else
        {
            ASSERT(Position == GDIP_MAX_COMMENT_SIZE);

            // Leave the object record header intact for the rest of the
            // object data.
            Position = sizeof(EmfPlusContinueObjectRecord);
        }
    }
}

VOID
EmfPlusCommentStream::WriteRecordHeader(
    UINT32                      dataSize,       // size of data (w/o record header)
    EmfPlusRecordType           type,
    INT                         flags           // 16 bits of flags
    )
{
    ASSERT ((flags & 0xFFFF0000) == 0);
    ASSERT (ContinuingObjectRecord == FALSE);
    ASSERT ((Position & 0x03) == 0);    // records should be 4-byte aligned
    ASSERT ((dataSize & 0x03) == 0);    // records should be 4-byte aligned

    if (IsValid())
    {
        ULONG   spaceLeft  = SpaceLeft();
        ULONG   recordSize = sizeof(EmfPlusRecord) + dataSize;

        ASSERT(spaceLeft > 0);

        // see if the record fits in the space left
        if (recordSize <= spaceLeft)
        {
    RecordFits:
            EmfPlusRecord *     recordData;

            recordData = (EmfPlusRecord *)(RecordDataStart + Position);

            recordData->Type     = type;
            recordData->Flags    = (INT16)flags;
            recordData->Size     = recordSize;
            recordData->DataSize = dataSize;
            Position         += sizeof(EmfPlusRecord);
            if (Position < GDIP_MAX_COMMENT_SIZE)
            {
                return;
            }
            ASSERT((recordSize == sizeof(EmfPlusRecord)) && (dataSize == 0));
            this->Flush();
            return;
        }
        else // it doesn't fit in the space left
        {
            // maybe it will fit after flushing the current record buffer
            if (spaceLeft < GDIP_MAX_COMMENT_SIZE)
            {
                this->Flush();
                if (!IsValid())
                {
                    return;
                }
                if (recordSize <= GDIP_MAX_COMMENT_SIZE)
                {
                    goto RecordFits;
                }
            }

            // Now we know the record does not fit in a single comment.
            // This better be an object record!
            ASSERT(type == EmfPlusRecordTypeObject);

            flags |= GDIP_EPRFLAGS_CONTINUEOBJECT;
            ContinuingObjectRecord = TRUE;

            // We know that Position is 0
            EmfPlusContinueObjectRecord *   recordData;
            recordData = (EmfPlusContinueObjectRecord *)RecordDataStart;

            recordData->Type             = type;
            recordData->Flags            = (INT16)flags;
            recordData->Size             = GDIP_MAX_COMMENT_SIZE;
            recordData->DataSize         = GDIP_MAX_COMMENT_SIZE - sizeof(EmfPlusRecord);
            recordData->TotalObjectSize  = dataSize;    // size of object data (w/o header size)
            Position                     = sizeof(EmfPlusContinueObjectRecord);
        }
    }
}

class MetafileRecorder : public IMetafileRecord
{
friend class GpMetafile;

private:
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

protected:
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagMetafileRecorder : ObjectTagInvalid;
    }

public:
    BOOL                                    WroteFrameRect;
    SIZEL                                   Millimeters;

protected:
    EmfPlusCommentStream *                  EmfPlusStream; // memory buffer stream
    GpMetafile *                            Metafile;   // being recorded
    EmfType                                 Type;
    REAL                                    XMinDevice; // device bounds
    REAL                                    YMinDevice;
    REAL                                    XMaxDevice;
    REAL                                    YMaxDevice;
    BOOL                                    BoundsInit;
    INT                                     NumRecords; // for debugging only
    INT                                     MaxStackSize;
    HDC                                     MetafileHdc;
    DynArrayIA<INT,GDIP_SAVE_STACK_SIZE>    SaveRestoreStack;
    MetafileRecordObjectList                ObjectList;
    GpRectF                                 MetafileBounds;

public:
    MetafileRecorder(
        GpMetafile *    metafile,
        EmfType         type,
        HDC             metafileHdc,
        BOOL            wroteFrameRect,
        SIZEL &         effectiveMillimeters,
        GpRectF &       metafileBounds
        );

    ~MetafileRecorder() // called by EndRecording
    {
        // Release the memory stream for writing the GdiComments
        if (EmfPlusStream != NULL)
        {
            EmfPlusStream->Release();
        }
    }

    BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagMetafileRecorder) || (Tag == ObjectTagInvalid));
        return (Tag == ObjectTagMetafileRecorder);
    }

    virtual VOID GetMetafileBounds(GpRect & metafileBounds) const
    {
        // Use Floor to make sure we don't miss any pixels
        metafileBounds.X      = GpFloor(MetafileBounds.X);
        metafileBounds.Y      = GpFloor(MetafileBounds.Y);
        metafileBounds.Width  = GpCeiling(MetafileBounds.GetRight())  - metafileBounds.X;
        metafileBounds.Height = GpCeiling(MetafileBounds.GetBottom()) - metafileBounds.Y;
    }

    virtual GpStatus
    RecordClear(
        const GpRectF *             deviceBounds,
        GpColor                     color
        );

    virtual GpStatus
    RecordFillRects(
        const GpRectF *             deviceBounds,
        GpBrush *                   brush,
        const GpRectF *             rects,
        INT                         count
        );

    virtual GpStatus
    RecordDrawRects(
        const GpRectF *             deviceBounds,
        GpPen *                     pen,
        const GpRectF *             rects,
        INT                         count
        );

    virtual GpStatus
    RecordFillPolygon(
        const GpRectF *             deviceBounds,
        GpBrush*                    brush,
        const GpPointF *            points,
        INT                         count,
        GpFillMode                  fillMode
        );

    virtual GpStatus
    RecordDrawLines(
        const GpRectF *             deviceBounds,
        GpPen *                     pen,
        const GpPointF *            points,
        INT                         count,
        BOOL                        closed
        );

    virtual GpStatus
    RecordFillEllipse(
        const GpRectF *             deviceBounds,
        GpBrush *                   brush,
        const GpRectF &             rect
        );

    virtual GpStatus
    RecordDrawEllipse(
        const GpRectF *             deviceBounds,
        GpPen *                     pen,
        const GpRectF &             rect
        );

    virtual GpStatus
    RecordFillPie(
        const GpRectF *             deviceBounds,
        GpBrush *                   brush,
        const GpRectF &             rect,
        REAL                        startAngle,
        REAL                        sweepAngle
        );

    virtual GpStatus
    RecordDrawPie(
        const GpRectF *             deviceBounds,
        GpPen *                     pen,
        const GpRectF &             rect,
        REAL                        startAngle,
        REAL                        sweepAngle
        );

    virtual GpStatus
    RecordDrawArc(
        const GpRectF *             deviceBounds,
        GpPen *                     pen,
        const GpRectF &             rect,
        REAL                        startAngle,
        REAL                        sweepAngle
        );

    virtual GpStatus
    RecordFillRegion(
        const GpRectF *             deviceBounds,
        GpBrush *                   brush,
        GpRegion *                  region
        );

    virtual GpStatus
    RecordFillPath(
        const GpRectF *             deviceBounds,
        const GpBrush *             brush,
        GpPath *                    path
        );

    virtual GpStatus
    RecordDrawPath(
        const GpRectF *             deviceBounds,
        GpPen *                     pen,
        GpPath *                    path
        );

    virtual GpStatus
    RecordFillClosedCurve(
        const GpRectF *             deviceBounds,
        GpBrush *                   brush,
        const GpPointF *            points,
        INT                         count,
        REAL                        tension,
        GpFillMode                  fillMode
        );

    virtual GpStatus
    RecordDrawClosedCurve(
        const GpRectF *             deviceBounds,
        GpPen *                     pen,
        const GpPointF *            points,
        INT                         count,
        REAL                        tension
        );

    virtual GpStatus
    RecordDrawCurve(
        const GpRectF *             deviceBounds,
        GpPen *                     pen,
        const GpPointF *            points,
        INT                         count,
        REAL                        tension,
        INT                         offset,
        INT                         numberOfSegments
        );

    virtual GpStatus
    RecordDrawBeziers(
        const GpRectF *             deviceBounds,
        GpPen *                     pen,
        const GpPointF *            points,
        INT                         count
        );

    virtual GpStatus
    RecordDrawImage(
        const GpRectF *             deviceBounds,
        const GpImage *             image,
        const GpRectF &             destRect,
        const GpRectF &             srcRect,
        GpPageUnit                  srcUnit,
        const GpImageAttributes *         imageAttributes
        );

    virtual GpStatus
    RecordDrawImage(
        const GpRectF *             deviceBounds,
        const GpImage *             image,
        const GpPointF *            destPoints,
        INT                         count,
        const GpRectF &             srcRect,
        GpPageUnit                  srcUnit,
        const GpImageAttributes *         imageAttributes
        );

    virtual GpStatus
    RecordDrawString(
        const GpRectF *             deviceBounds,
        const WCHAR                *string,
        INT                         length,
        const GpFont               *font,
        const RectF                *layoutRect,
        const GpStringFormat       *format,
        const GpBrush              *brush
        );

    virtual GpStatus
    RecordDrawDriverString(
        const GpRectF *             deviceBounds,
        const UINT16               *text,
        INT                         glyphCount,
        const GpFont               *font,
        const GpBrush              *brush,
        const PointF               *positions,
        INT                         flags,
        const GpMatrix             *matrix
        );

    virtual GpStatus
    RecordSave(
        INT         gstate
        );

    virtual GpStatus
    RecordRestore(
        INT         gstate
        );

    virtual GpStatus
    RecordBeginContainer(
        const GpRectF &             destRect,
        const GpRectF &             srcRect,
        GpPageUnit                  srcUnit,
        INT                         containerState
        );

    virtual GpStatus
    RecordBeginContainer(
        INT                         containerState
        );

    virtual GpStatus
    RecordEndContainer(
        INT                         containerState
        );

    virtual GpStatus
    RecordSetWorldTransform(
        const GpMatrix &            matrix
        );

    virtual GpStatus
    RecordResetWorldTransform();

    virtual GpStatus
    RecordMultiplyWorldTransform(
        const GpMatrix &            matrix,
        GpMatrixOrder               order
        );

    virtual GpStatus
    RecordTranslateWorldTransform(
        REAL                        dx,
        REAL                        dy,
        GpMatrixOrder               order
        );

    virtual GpStatus
    RecordScaleWorldTransform(
        REAL                        sx,
        REAL                        sy,
        GpMatrixOrder               order
        );

    virtual GpStatus
    RecordRotateWorldTransform(
        REAL                        angle,
        GpMatrixOrder               order
        );

    virtual GpStatus
    RecordSetPageTransform(
        GpPageUnit                  unit,
        REAL                        scale
        );

    virtual GpStatus
    RecordResetClip();

    virtual GpStatus
    RecordSetClip(
        const GpRectF &             rect,
        CombineMode                 combineMode
        );

    virtual GpStatus
    RecordSetClip(
        GpRegion *                  region,
        CombineMode                 combineMode
        );

    virtual GpStatus
    RecordSetClip(
        GpPath *                    path,
        CombineMode                 combineMode,
        BOOL                        isDevicePath
        );

    virtual GpStatus
    RecordOffsetClip(
        REAL                        dx,
        REAL                        dy
        );

    virtual GpStatus
    RecordGetDC();

    virtual GpStatus
    RecordSetAntiAliasMode(
        BOOL                        newMode
        );

    virtual GpStatus
    RecordSetTextRenderingHint(
        TextRenderingHint           newMode
        );

    virtual GpStatus
    RecordSetTextContrast(
        UINT                        gammaValue
        );

    virtual GpStatus
    RecordSetInterpolationMode(
        InterpolationMode           newMode
        );

    virtual GpStatus
    RecordSetPixelOffsetMode(
        PixelOffsetMode             newMode
        );

    virtual GpStatus
    RecordSetCompositingMode(
        GpCompositingMode           newMode
        );

    virtual GpStatus
    RecordSetCompositingQuality(
        GpCompositingQuality        newQuality
        );

    virtual GpStatus
    RecordSetRenderingOrigin(
        INT x,
        INT y
    );

    virtual GpStatus
    RecordComment(
        UINT            sizeData,
        const BYTE *    data
        );

    virtual VOID
    EndRecording();

    virtual GpStatus
    RecordBackupObject(
        const GpObject *            object
        );

protected:

    GpStatus
    RecordHeader(
        INT                 logicalDpiX,
        INT                 logicalDpiY,
        INT                 emfPlusFlags
        );
    VOID RecordEndOfFile();

    VOID
    WriteObject(
        ObjectType                  type,
        const GpObject *            object,
        UINT32                      metaObjectId
        );

    VOID
    RecordObject(
        const GpObject *            object,
        UINT32*                     metaObjectId
        );

    GpStatus
    RecordZeroDataRecord(
        EmfPlusRecordType           type,
        INT                         flags
        );

    VOID
    WriteRecordHeader(
        UINT32                      dataSize,
        EmfPlusRecordType           type,
        INT                         flags        = 0,   // 16 bits of flags
        const GpRectF *             deviceBounds = NULL
        );

    // To keep the number of comments low, this only needs to be called
    // when there is a down-level representation of the GDI+ record.
    VOID
    WriteGdiComment()
    {
        // If we're doing dual (which means we're about to write
        // down-level records) then write out the current list
        // of records in the EmfPlusStream buffer.
        if (Type == EmfTypeEmfPlusDual)
        {
            EmfPlusStream->Flush();
        }
    }

    VOID
    GetBrushValueForRecording(
        const GpBrush *brush,
        UINT32        &brushValue,
        INT           &flags
        );
};

/**************************************************************************\
*
* Function Description:
*
*   Construct a MetafileRecorder object and initialize it.
*
* Arguments:
*
*   [IN]  metafile    - pointer to the metafile object being recorded
*   [IN]  stream      - the stream being recorded into (if any)
*   [IN]  metafileHdc - handle to metafile DC being recorded into (if any)
*   [IN]  dpiX        - the horizontal DPI
*   [IN]  dpiY        - the vertical   DPI
*
* Return Value:
*
*   NONE
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
MetafileRecorder::MetafileRecorder(
    GpMetafile *    metafile,
    EmfType         emfType,
    HDC             metafileHdc,
    BOOL            wroteFrameRect,
    SIZEL &         effectiveMillimeters,
    GpRectF &       metafileBounds
    )
{
    SetValid(FALSE);
    Type                    = emfType;
    Metafile                = metafile;
    WroteFrameRect          = wroteFrameRect;
    NumRecords              = 0;        // currently for debugging only
    MaxStackSize            = 0;
    MetafileHdc             = metafileHdc;
    XMinDevice              = FLT_MAX;
    YMinDevice              = FLT_MAX;
    XMaxDevice              = -FLT_MAX;
    YMaxDevice              = -FLT_MAX;
    BoundsInit              = FALSE;
    EmfPlusStream           = NULL;
    Millimeters             = effectiveMillimeters;

    // The metafileBounds are used as the bounds for FillRegion
    // calls when the region has infinite bounds, to keep from
    // exploding the bounds of the metafile.
    MetafileBounds          = metafileBounds;

    if (emfType == EmfTypeEmfOnly)
    {
        Metafile->Header.Type = MetafileTypeEmf;
        SetValid(TRUE);
    }
    else
    {
        // gets freed in the destructor
        EmfPlusStream = new EmfPlusCommentStream(metafileHdc);

        if (EmfPlusStream == NULL)
        {
            return;
        }

        SetValid(TRUE);

        INT                 logicalDpiX  = GetDeviceCaps(metafileHdc, LOGPIXELSX);
        INT                 logicalDpiY  = GetDeviceCaps(metafileHdc, LOGPIXELSY);
        INT                 emfPlusFlags = 0;

        if (GetDeviceCaps(metafileHdc, TECHNOLOGY) == DT_RASDISPLAY)
        {
            emfPlusFlags |= GDIP_EMFPLUSFLAGS_DISPLAY;
        }

        MetafileHeader * header = &(metafile->Header);

        header->EmfPlusHeaderSize = sizeof(EmfPlusRecord) + sizeof(EmfPlusHeaderRecord);
        header->LogicalDpiX       = logicalDpiX;
        header->LogicalDpiY       = logicalDpiY;
        header->EmfPlusFlags      = emfPlusFlags;
        if (emfType == EmfTypeEmfPlusOnly)
        {
            header->Type          = MetafileTypeEmfPlusOnly;
        }
        else
        {
            ASSERT(emfType == EmfTypeEmfPlusDual);
            header->Type          = MetafileTypeEmfPlusDual;
        }

        if (RecordHeader(logicalDpiX, logicalDpiY, emfPlusFlags) != Ok)
        {
            SetValid(FALSE);
            EmfPlusStream->Release();
            EmfPlusStream = NULL;
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordClear.
*
* Arguments:
*
*   [IN]  deviceBounds - the bounding rect, in device units
*   [IN]  color        - the clear color
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*  04/28/2000 AGodfrey
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordClear(
    const GpRectF *             deviceBounds,
    GpColor                     color
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        if (IsValid())
        {
            ASSERT (deviceBounds != NULL);

            ARGB argbColor = color.GetValue();

            UINT32              dataSize = sizeof(argbColor);
            EmfPlusRecordType   type     = EmfPlusRecordTypeClear;
            INT                 flags    = 0;

            WriteRecordHeader(dataSize, type, flags, deviceBounds);
            WriteInt32(EmfPlusStream, argbColor);
            WriteGdiComment();  // is down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write Clear record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordFillRects.
*
* Arguments:
*
*   [IN]  deviceBounds - the bounding rect, in device units
*   [IN]  brush        - brush to draw with
*   [IN]  rects        - rectangles to fill
*   [IN]  count        - number of rects
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordFillRects(
    const GpRectF *             deviceBounds,
    GpBrush *                   brush,
    const GpRectF *             rects,
    INT                         count
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        ASSERT ((deviceBounds != NULL) && (brush != NULL) &&
                (rects != NULL) && (count > 0));

        if (IsValid())
        {
            MetafileRectData    rectData(rects, count);
            UINT32              brushValue; // Metafile Brush Id or ARGB value
            UINT32              dataSize = sizeof(brushValue) +
                                           sizeof(UINT32/* count */) +
                                           rectData.GetDataSize();
            EmfPlusRecordType   type     = EmfPlusRecordTypeFillRects;
            INT                 flags    = rectData.GetFlags();

            GetBrushValueForRecording(brush, brushValue, flags);

            WriteRecordHeader(dataSize, type, flags, deviceBounds);
            WriteInt32(EmfPlusStream, brushValue);
            WriteInt32(EmfPlusStream, count);
            rectData.WriteData(EmfPlusStream);
            WriteGdiComment();  // is down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write FillRects record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordDrawRects.
*
* Arguments:
*
*   [IN]  deviceBounds - the bounding rect, in device units
*   [IN]  pen          - pen to draw with
*   [IN]  rects        - rectangles to draw
*   [IN]  count        - number of rects
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordDrawRects(
    const GpRectF *             deviceBounds,
    GpPen *                     pen,
    const GpRectF *             rects,
    INT                         count
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        ASSERT ((deviceBounds != NULL) && (pen != NULL) &&
                (rects != NULL) && (count > 0));

        if (IsValid())
        {
            MetafileRectData    rectData(rects, count);
            UINT32              metaPenId;
            UINT32              dataSize = sizeof(UINT32/* count */) +
                                           rectData.GetDataSize();
            EmfPlusRecordType   type     = EmfPlusRecordTypeDrawRects;
            INT                 flags    = rectData.GetFlags();

            RecordObject(pen, &metaPenId);
            ASSERT((metaPenId & (~GDIP_EPRFLAGS_METAOBJECTID)) == 0);
            flags |= metaPenId;

            WriteRecordHeader(dataSize, type, flags, deviceBounds);
            WriteInt32(EmfPlusStream, count);
            rectData.WriteData(EmfPlusStream);
            WriteGdiComment();  // is down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write DrawRects record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordFillPolygon.
*
* Arguments:
*
*   [IN]  deviceBounds - the bounding rect, in device units
*   [IN]  brush        - brush to draw with
*   [IN]  points       - polygon points
*   [IN]  count        - number of points
*   [IN]  fillMode     - Alternate or Winding
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordFillPolygon(
    const GpRectF *             deviceBounds,
    GpBrush*                    brush,
    const GpPointF *            points,
    INT                         count,
    GpFillMode                  fillMode
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        ASSERT ((deviceBounds != NULL) && (brush != NULL) &&
                (points != NULL) && (count > 0));

        if (IsValid())
        {
            MetafilePointData   pointData(points, count);
            UINT32              brushValue; // Metafile Brush Id or ARGB value
            UINT32              dataSize = sizeof(brushValue) +
                                           sizeof(UINT32/* count */) +
                                           pointData.GetDataSize();
            EmfPlusRecordType   type     = EmfPlusRecordTypeFillPolygon;
            INT                 flags    = pointData.GetFlags();

            GetBrushValueForRecording(brush, brushValue, flags);

            if (fillMode == FillModeWinding)
            {
                flags |= GDIP_EPRFLAGS_WINDINGFILL;
            }

            WriteRecordHeader(dataSize, type, flags, deviceBounds);
            WriteInt32(EmfPlusStream, brushValue);
            WriteInt32(EmfPlusStream, count);
            pointData.WriteData(EmfPlusStream);
            WriteGdiComment();  // is down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write FillPolygon record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordDrawLines.
*
* Arguments:
*
*   [IN]  deviceBounds - the bounding rect, in device units
*   [IN]  pen          - pen to draw with
*   [IN]  points       - polyline points
*   [IN]  count        - number of points
*   [IN]  closed       - TRUE if closed
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordDrawLines(
    const GpRectF *             deviceBounds,
    GpPen *                     pen,
    const GpPointF *            points,
    INT                         count,
    BOOL                        closed
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        ASSERT ((deviceBounds != NULL) && (pen != NULL) &&
                (points != NULL) && (count > 0));

        if (IsValid())
        {
            MetafilePointData   pointData(points, count);
            UINT32              metaPenId;
            UINT32              dataSize = sizeof(UINT32/* count */) +
                                           pointData.GetDataSize();
            EmfPlusRecordType   type     = EmfPlusRecordTypeDrawLines;
            INT                 flags    = pointData.GetFlags();

            RecordObject(pen, &metaPenId);
            ASSERT((metaPenId & (~GDIP_EPRFLAGS_METAOBJECTID)) == 0);
            flags |= metaPenId;

            if (closed)
            {
                flags |= GDIP_EPRFLAGS_CLOSED;
            }

            WriteRecordHeader(dataSize, type, flags, deviceBounds);
            WriteInt32(EmfPlusStream, count);
            pointData.WriteData(EmfPlusStream);
            WriteGdiComment();  // is down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write DrawLines record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordFillEllipse.
*
* Arguments:
*
*   [IN]  deviceBounds - the bounding rect, in device units
*   [IN]  brush        - brush to draw with
*   [IN]  rect         - bounding rect of ellipse
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordFillEllipse(
    const GpRectF *             deviceBounds,
    GpBrush *                   brush,
    const GpRectF &             rect
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        ASSERT ((deviceBounds != NULL) && (brush != NULL));

        if (IsValid())
        {
            MetafileRectData    rectData(&rect, 1);
            UINT32              brushValue; // Metafile Brush Id or ARGB value
            UINT32              dataSize = sizeof(brushValue) +
                                           rectData.GetDataSize();
            EmfPlusRecordType   type     = EmfPlusRecordTypeFillEllipse;
            INT                 flags    = rectData.GetFlags();

            GetBrushValueForRecording(brush, brushValue, flags);

            WriteRecordHeader(dataSize, type, flags, deviceBounds);
            WriteInt32(EmfPlusStream, brushValue);
            rectData.WriteData(EmfPlusStream);
            WriteGdiComment();  // is down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write FillEllipse record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordDrawEllipse.
*
* Arguments:
*
*   [IN]  deviceBounds - the bounding rect, in device units
*   [IN]  pen          - pen to draw with
*   [IN]  rect         - bounding rect of ellipse
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordDrawEllipse(
    const GpRectF *             deviceBounds,
    GpPen *                     pen,
    const GpRectF &             rect
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        ASSERT ((deviceBounds != NULL) && (pen != NULL));

        if (IsValid())
        {
            MetafileRectData    rectData(&rect, 1);
            UINT32              metaPenId;
            UINT32              dataSize = rectData.GetDataSize();
            EmfPlusRecordType   type     = EmfPlusRecordTypeDrawEllipse;
            INT                 flags    = rectData.GetFlags();

            RecordObject(pen, &metaPenId);
            ASSERT((metaPenId & (~GDIP_EPRFLAGS_METAOBJECTID)) == 0);
            flags |= metaPenId;

            WriteRecordHeader(dataSize, type, flags, deviceBounds);
            rectData.WriteData(EmfPlusStream);
            WriteGdiComment();  // is down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write DrawEllipse record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordFillPie.
*
* Arguments:
*
*   [IN]  deviceBounds - the bounding rect, in device units
*   [IN]  brush        - brush to draw with
*   [IN]  rect         - bounding rect of ellipse
*   [IN]  startAngle   - starting angle of pie
*   [IN]  sweepAngle   - sweep angle of pie
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordFillPie(
    const GpRectF *             deviceBounds,
    GpBrush *                   brush,
    const GpRectF &             rect,
    REAL                        startAngle,
    REAL                        sweepAngle
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        ASSERT ((deviceBounds != NULL) && (brush != NULL));

        if (IsValid())
        {
            MetafileRectData    rectData(&rect, 1);
            UINT32              brushValue; // Metafile Brush Id or ARGB value
            UINT32              dataSize = sizeof(brushValue) +
                                           sizeof(startAngle) +
                                           sizeof(sweepAngle) +
                                           rectData.GetDataSize();
            EmfPlusRecordType   type     = EmfPlusRecordTypeFillPie;
            INT                 flags    = rectData.GetFlags();

            GetBrushValueForRecording(brush, brushValue, flags);

            WriteRecordHeader(dataSize, type, flags, deviceBounds);
            WriteInt32(EmfPlusStream, brushValue);
            WriteReal (EmfPlusStream, startAngle);
            WriteReal (EmfPlusStream, sweepAngle);
            rectData.WriteData(EmfPlusStream);
            WriteGdiComment();  // is down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write FillPie record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordDrawPie.
*
* Arguments:
*
*   [IN]  deviceBounds - the bounding rect, in device units
*   [IN]  pen          - pen to draw with
*   [IN]  rect         - bounding rect of ellipse
*   [IN]  startAngle   - starting angle of pie
*   [IN]  sweepAngle   - sweep angle of pie
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordDrawPie(
    const GpRectF *             deviceBounds,
    GpPen *                     pen,
    const GpRectF &             rect,
    REAL                        startAngle,
    REAL                        sweepAngle
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        ASSERT ((deviceBounds != NULL) && (pen != NULL));

        if (IsValid())
        {
            MetafileRectData    rectData(&rect, 1);
            UINT32              metaPenId;
            UINT32              dataSize = sizeof(startAngle) +
                                           sizeof(sweepAngle) +
                                           rectData.GetDataSize();
            EmfPlusRecordType   type     = EmfPlusRecordTypeDrawPie;
            INT                 flags    = rectData.GetFlags();

            RecordObject(pen, &metaPenId);
            ASSERT((metaPenId & (~GDIP_EPRFLAGS_METAOBJECTID)) == 0);
            flags  |= metaPenId;

            WriteRecordHeader(dataSize, type, flags, deviceBounds);
            WriteReal (EmfPlusStream, startAngle);
            WriteReal (EmfPlusStream, sweepAngle);
            rectData.WriteData(EmfPlusStream);
            WriteGdiComment();  // is down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write DrawPie record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordDrawArc.
*
* Arguments:
*
*   [IN]  deviceBounds - the bounding rect, in device units
*   [IN]  pen          - pen to draw with
*   [IN]  rect         - bounding rect of ellipse
*   [IN]  startAngle   - starting angle of arc
*   [IN]  sweepAngle   - sweep angle of arc
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordDrawArc(
    const GpRectF *             deviceBounds,
    GpPen *                     pen,
    const GpRectF &             rect,
    REAL                        startAngle,
    REAL                        sweepAngle
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        ASSERT ((deviceBounds != NULL) && (pen != NULL));

        if (IsValid())
        {
            MetafileRectData    rectData(&rect, 1);
            UINT32              metaPenId;
            UINT32              dataSize = sizeof(startAngle) +
                                           sizeof(sweepAngle) +
                                           rectData.GetDataSize();
            EmfPlusRecordType   type     = EmfPlusRecordTypeDrawArc;
            INT                 flags    = rectData.GetFlags();

            RecordObject(pen, &metaPenId);
            ASSERT((metaPenId & (~GDIP_EPRFLAGS_METAOBJECTID)) == 0);
            flags  |= metaPenId;

            WriteRecordHeader(dataSize, type, flags, deviceBounds);
            WriteReal (EmfPlusStream, startAngle);
            WriteReal (EmfPlusStream, sweepAngle);
            rectData.WriteData(EmfPlusStream);
            WriteGdiComment();  // is down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write DrawArc record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordFillRegion.
*
* Arguments:
*
*   [IN]  deviceBounds - the bounding rect, in device units
*   [IN]  brush        - brush to draw with
*   [IN]  region       - region to fill
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordFillRegion(
    const GpRectF *             deviceBounds,
    GpBrush *                   brush,
    GpRegion *                  region
    )
{
    // The deviceBounds should never be infinite, because they are
    // intersected with the metafileBounds before being passed in.

    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        ASSERT ((deviceBounds != NULL) && (brush != NULL) && (region != NULL));

        if (IsValid())
        {
            UINT32              metaRegionId;
            UINT32              brushValue; // Metafile Brush Id or ARGB value
            UINT32              dataSize = sizeof(brushValue);
            EmfPlusRecordType   type     = EmfPlusRecordTypeFillRegion;
            INT                 flags    = 0;

            GetBrushValueForRecording(brush, brushValue, flags);

            RecordObject(region, &metaRegionId);
            ASSERT((metaRegionId & (~GDIP_EPRFLAGS_METAOBJECTID)) == 0);
            flags |= metaRegionId;

            WriteRecordHeader(dataSize, type, flags, deviceBounds);
            WriteInt32(EmfPlusStream, brushValue);
            WriteGdiComment();  // is down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write FillRegion record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordFillPath.
*
* Arguments:
*
*   [IN]  deviceBounds - the bounding rect, in device units
*   [IN]  brush        - brush to draw with
*   [IN]  path         - path to fill
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordFillPath(
    const GpRectF *             deviceBounds,
    const GpBrush *                   brush,
    GpPath *                    path
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        ASSERT ((deviceBounds != NULL) && (brush != NULL) && (path != NULL));

        if (IsValid())
        {
            UINT32              metaPathId;
            UINT32              brushValue; // Metafile Brush Id or ARGB value
            UINT32              dataSize = sizeof(brushValue);
            EmfPlusRecordType   type     = EmfPlusRecordTypeFillPath;
            INT                 flags    = 0;

            GetBrushValueForRecording(brush, brushValue, flags);

            RecordObject(path, &metaPathId);
            ASSERT((metaPathId & (~GDIP_EPRFLAGS_METAOBJECTID)) == 0);
            flags |= metaPathId;

            WriteRecordHeader(dataSize, type, flags, deviceBounds);
            WriteInt32(EmfPlusStream, brushValue);
            WriteGdiComment();  // is down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write FillPath record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordDrawPath.
*
* Arguments:
*
*   [IN]  deviceBounds - the bounding rect, in device units
*   [IN]  pen          - pen to draw with
*   [IN]  path         - path to draw
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordDrawPath(
    const GpRectF *             deviceBounds,
    GpPen *                     pen,
    GpPath *                    path
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        ASSERT ((deviceBounds != NULL) && (pen != NULL) && (path != NULL));

        if (IsValid())
        {
            UINT32              metaPathId;
            UINT32              metaPenId;
            UINT32              dataSize = sizeof(metaPenId);
            EmfPlusRecordType   type     = EmfPlusRecordTypeDrawPath;
            INT                 flags    = 0;

            RecordObject(pen, &metaPenId);

            RecordObject(path, &metaPathId);
            ASSERT((metaPathId & (~GDIP_EPRFLAGS_METAOBJECTID)) == 0);
            flags  |= metaPathId;

            WriteRecordHeader(dataSize, type, flags, deviceBounds);
            WriteInt32(EmfPlusStream, metaPenId);
            WriteGdiComment();  // is down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write DrawPath record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordFillClosedCurve.
*
* Arguments:
*
*   [IN]  deviceBounds - the bounding rect, in device units
*   [IN]  brush        - brush to draw with
*   [IN]  points       - curve points
*   [IN]  count        - number of points
*   [IN]  tension      - how tight to make curve
*   [IN]  fillMode     - Alternate or Winding
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordFillClosedCurve(
    const GpRectF *             deviceBounds,
    GpBrush *                   brush,
    const GpPointF *            points,
    INT                         count,
    REAL                        tension,
    GpFillMode                  fillMode
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        ASSERT ((deviceBounds != NULL) && (brush != NULL) &&
                (points != NULL) && (count > 0));

        if (IsValid())
        {
            MetafilePointData   pointData(points, count);
            UINT32              brushValue; // Metafile Brush Id or ARGB value
            UINT32              dataSize = sizeof(brushValue) +
                                           sizeof(tension) +
                                           sizeof(UINT32 /* count */) +
                                           pointData.GetDataSize();
            EmfPlusRecordType   type     = EmfPlusRecordTypeFillClosedCurve;
            INT                 flags    = pointData.GetFlags();

            GetBrushValueForRecording(brush, brushValue, flags);

            if (fillMode == FillModeWinding)
            {
                flags |= GDIP_EPRFLAGS_WINDINGFILL;
            }

            WriteRecordHeader(dataSize, type, flags, deviceBounds);
            WriteInt32(EmfPlusStream, brushValue);
            WriteReal (EmfPlusStream, tension);
            WriteInt32(EmfPlusStream, count);
            pointData.WriteData(EmfPlusStream);
            WriteGdiComment();  // is down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write FillClosedCurve record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordDrawClosedCurve.
*
* Arguments:
*
*   [IN]  deviceBounds - the bounding rect, in device units
*   [IN]  pen          - pen to draw with
*   [IN]  points       - curve points
*   [IN]  count        - number of points
*   [IN]  tension      - how tight to make curve
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordDrawClosedCurve(
    const GpRectF *             deviceBounds,
    GpPen *                     pen,
    const GpPointF *            points,
    INT                         count,
    REAL                        tension
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        ASSERT ((deviceBounds != NULL) && (pen != NULL) &&
                (points != NULL) && (count > 0));

        if (IsValid())
        {
            MetafilePointData   pointData(points, count);
            UINT32              metaPenId;
            UINT32              dataSize = sizeof(tension) +
                                           sizeof(UINT32/* count */) +
                                           pointData.GetDataSize();
            EmfPlusRecordType   type     = EmfPlusRecordTypeDrawClosedCurve;
            INT                 flags    = pointData.GetFlags();

            RecordObject(pen, &metaPenId);
            ASSERT((metaPenId & (~GDIP_EPRFLAGS_METAOBJECTID)) == 0);
            flags  |= metaPenId;

            WriteRecordHeader(dataSize, type, flags, deviceBounds);
            WriteReal (EmfPlusStream, tension);
            WriteInt32(EmfPlusStream, count);
            pointData.WriteData(EmfPlusStream);
            WriteGdiComment();  // is down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write DrawClosedCurve record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordDrawCurve.
*
* Arguments:
*
*   [IN]  deviceBounds     - the bounding rect, in device units
*   [IN]  pen              - pen to draw with
*   [IN]  points           - curve points
*   [IN]  count            - number of points
*   [IN]  tension          - how tight to make curve
*   [IN]  offset           - offset
*   [IN]  numberOfSegments - number of segments
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordDrawCurve(
    const GpRectF *             deviceBounds,
    GpPen *                     pen,
    const GpPointF *            points,
    INT                         count,
    REAL                        tension,
    INT                         offset,
    INT                         numberOfSegments
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        ASSERT ((deviceBounds != NULL) && (pen != NULL) &&
                (points != NULL) && (count > 0));

        if (IsValid())
        {
            MetafilePointData   pointData(points, count);
            UINT32              metaPenId;
            UINT32              dataSize = sizeof(tension) +
                                           sizeof(INT32 /* offset */) +
                                           sizeof(UINT32/* numberOfSegments */) +
                                           sizeof(UINT32/* count */) +
                                           pointData.GetDataSize();
            EmfPlusRecordType   type     = EmfPlusRecordTypeDrawCurve;
            INT                 flags    = pointData.GetFlags();

            RecordObject(pen, &metaPenId);
            ASSERT((metaPenId & (~GDIP_EPRFLAGS_METAOBJECTID)) == 0);
            flags  |= metaPenId;

            WriteRecordHeader(dataSize, type, flags, deviceBounds);
            WriteReal (EmfPlusStream, tension);
            WriteInt32(EmfPlusStream, offset);
            WriteInt32(EmfPlusStream, numberOfSegments);
            WriteInt32(EmfPlusStream, count);
            pointData.WriteData(EmfPlusStream);
            WriteGdiComment();  // is down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write DrawCurve record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordDrawBeziers.
*
* Arguments:
*
*   [IN]  deviceBounds     - the bounding rect, in device units
*   [IN]  pen              - pen to draw with
*   [IN]  points           - curve points
*   [IN]  count            - number of points
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordDrawBeziers(
    const GpRectF *             deviceBounds,
    GpPen *                     pen,
    const GpPointF *            points,
    INT                         count
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        ASSERT ((deviceBounds != NULL) && (pen != NULL) &&
                (points != NULL) && (count > 0));

        if (IsValid())
        {
            MetafilePointData   pointData(points, count);
            UINT32              metaPenId;
            UINT32              dataSize = sizeof(UINT32/* count */) +
                                           pointData.GetDataSize();
            EmfPlusRecordType   type     = EmfPlusRecordTypeDrawBeziers;
            INT                 flags    = pointData.GetFlags();

            RecordObject(pen, &metaPenId);
            ASSERT((metaPenId & (~GDIP_EPRFLAGS_METAOBJECTID)) == 0);
            flags  |= metaPenId;

            WriteRecordHeader(dataSize, type, flags, deviceBounds);
            WriteInt32(EmfPlusStream, count);
            pointData.WriteData(EmfPlusStream);
            WriteGdiComment();  // is down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write DrawBeziers record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordDrawImage.
*
* Arguments:
*
*   [IN]  deviceBounds     - the bounding rect, in device units
*   [IN]  image            - image to draw
*   [IN]  destRect         - where to draw image
*   [IN]  srcRect          - portion of image to draw
*   [IN]  srcUnit          - units of srcRect
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordDrawImage(
    const GpRectF *             deviceBounds,
    const GpImage *             image,
    const GpRectF &             destRect,
    const GpRectF &             srcRect,
    GpPageUnit                  srcUnit,
    const GpImageAttributes *         imageAttributes
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        ASSERT ((deviceBounds != NULL) && (image != NULL));

        if (IsValid())
        {
            MetafileRectData    rectData(&destRect, 1);
            UINT32              metaImageId;
            UINT32              metaImageAttributesId;

            UINT32              dataSize = sizeof(INT32) +   /* metaImageAttributesId*/
                                           sizeof(INT32) +   /* srcUnit */
                                           sizeof(srcRect) +
                                           rectData.GetDataSize();
            EmfPlusRecordType   type     = EmfPlusRecordTypeDrawImage;
            INT                 flags    = rectData.GetFlags();

            RecordObject(image, &metaImageId);
            ASSERT((metaImageId & (~GDIP_EPRFLAGS_METAOBJECTID)) == 0);
            flags  |= metaImageId;

            // Record the imageAttributes;
            // imageAttributes can be NULL

            RecordObject(imageAttributes, &metaImageAttributesId);

            WriteRecordHeader(dataSize, type, flags, deviceBounds);
            WriteInt32(EmfPlusStream, metaImageAttributesId);
            WriteInt32(EmfPlusStream, srcUnit);
            WriteRect (EmfPlusStream, srcRect);
            rectData.WriteData(EmfPlusStream);
            WriteGdiComment();  // is down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write DrawImage record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordDrawImage.
*
* Arguments:
*
*   [IN]  deviceBounds     - the bounding rect, in device units
*   [IN]  image            - image to draw
*   [IN]  destPoints       - where to draw image
*   [IN]  count            - number of destPoints
*   [IN]  srcRect          - portion of image to draw
*   [IN]  srcUnit          - units of srcRect
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordDrawImage(
    const GpRectF *             deviceBounds,
    const GpImage *             image,
    const GpPointF *            destPoints,
    INT                         count,
    const GpRectF &             srcRect,
    GpPageUnit                  srcUnit,
    const GpImageAttributes *         imageAttributes
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        ASSERT ((deviceBounds != NULL) && (image != NULL) &&
                (destPoints != NULL) && (count > 0));

        if (IsValid())
        {
            MetafilePointData   pointData(destPoints, count);
            UINT32              metaImageId;
            UINT32              metaImageAttributesId;

            UINT32              dataSize = sizeof(INT32) +   /* metaImageAttributesId*/
                                           sizeof(INT32) +   /* srcUnit */
                                           sizeof(srcRect) +
                                           sizeof(UINT32) +  /* count */
                                           pointData.GetDataSize();
            EmfPlusRecordType   type     = EmfPlusRecordTypeDrawImagePoints;
            INT                 flags    = pointData.GetFlags();

            RecordObject(image, &metaImageId);
            ASSERT((metaImageId & (~GDIP_EPRFLAGS_METAOBJECTID)) == 0);
            flags |= metaImageId;

            // Record the imageAttributes;
            // imageAttributes can be NULL

            RecordObject(imageAttributes, &metaImageAttributesId);

            WriteRecordHeader(dataSize, type, flags, deviceBounds);
            WriteInt32(EmfPlusStream, metaImageAttributesId);
            WriteInt32(EmfPlusStream, srcUnit);
            WriteRect (EmfPlusStream, srcRect);
            WriteInt32(EmfPlusStream, count);
            pointData.WriteData(EmfPlusStream);
            WriteGdiComment();  // is down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write DrawImagePoints record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordDrawString.
*
* Arguments:
*
*   [IN]  string           - string to draw
*   [IN]  length           - length of string
*   [IN]  font             - font to use when drawing string
*   [IN]  layoutRect       - where to draw the string
*   [IN]  format           - format
*   [IN]  brush            - brush to draw with
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordDrawString(
    const GpRectF *             deviceBounds,
    const WCHAR                *string,
    INT                         length,
    const GpFont               *font,
    const RectF                *layoutRect,
    const GpStringFormat       *format,
    const GpBrush              *brush
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        ASSERT (string && font && brush && layoutRect);

        if (length < 0)
        {
            if (length == -1)
            {
                length = 0;
                while (string[length] && (length < INT_MAX))
                {
                    length++;
                }
            }
            else
            {
                return InvalidParameter;
            }
        }

        ASSERT (length > 0);

        if (IsValid())
        {
            const BYTE *        strData    = (BYTE *)string;    // BYTE or WCHAR
            INT                 sizeString = length * sizeof(WCHAR);
            INT                 flags      = 0;

            // !!! TODO:
            // Compress the Unicode string.
            // Use the GDIP_EPRFLAGS_COMPRESSED to indicate that
            // the string has been compressed to ANSI.

            UINT32              metaFontId;
            UINT32              metaFormatId;
            UINT32              brushValue; // Metafile Brush Id or ARGB value
            UINT32              dataSize = sizeof(brushValue) +
                                           sizeof(metaFormatId) +
                                           sizeof(INT32 /* len */) +
                                           sizeof(*layoutRect) +
                                           sizeString;
            EmfPlusRecordType   type     = EmfPlusRecordTypeDrawString;

            dataSize = (dataSize + 3) & (~3);    // align

            RecordObject(font, &metaFontId);
            ASSERT((metaFontId & (~GDIP_EPRFLAGS_METAOBJECTID)) == 0);
            flags |= metaFontId;

            // the format can be NULL
            RecordObject(format, &metaFormatId);

            GetBrushValueForRecording(brush, brushValue, flags);
            WriteRecordHeader(dataSize, type, flags, deviceBounds);
            WriteInt32(EmfPlusStream, brushValue);
            WriteInt32(EmfPlusStream, metaFormatId);
            WriteInt32(EmfPlusStream, length);
            WriteRect (EmfPlusStream, *layoutRect);
            WriteBytes(EmfPlusStream, strData, sizeString);

            // align
            if ((length & 0x01) != 0)
            {
                length = 0;
                EmfPlusStream->Write(&length, sizeof(WCHAR), NULL);
            }

            WriteGdiComment();  // is down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write DrawString record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordDrawdriverString.
*
* Arguments:
*
*   [IN]  text              - string/glyphs
*   [IN]  glyphCount        - string length
*   [IN]  font              - font to use when drawing string
*   [IN]  brush             - brush to draw with
*   [IN]  positions         - character/glyphs origins
*   [IN]  flags             - API flags
*   [IN]  matrix            - transofrmation matrix
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   7/11/2000 Tarekms
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordDrawDriverString(
    const GpRectF       *deviceBounds,
    const UINT16        *text,
    INT                  glyphCount,
    const GpFont        *font,
    const GpBrush       *brush,
    const PointF        *positions,
    INT                  flags,
    const GpMatrix      *matrix
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        ASSERT (text && font && brush && positions);

        if (glyphCount <= 0)
        {
            return InvalidParameter;
        }

        if (IsValid())
        {
            const BYTE *        textData      = (BYTE *)text;
            const BYTE *        positionData  = (BYTE *)positions;
            INT                 sizeText      = glyphCount * sizeof(UINT16);
            INT                 sizePositions = glyphCount * sizeof(PointF);
            INT                 metaFlags     = 0;

            UINT32              metaFontId;
            UINT32              brushValue; // Metafile Brush Id or ARGB value
            UINT32              matrixPresent;
            UINT32              dataSize = sizeof(brushValue)   + // brush value
                                           sizeof(flags)        + // API flags
                                           sizeof(matrixPresent)+ // matix prensences
                                           sizeof(UINT32)       + // glyphCoumt
                                           sizeText             + // Text
                                           sizePositions;         // Positions
            if (matrix == NULL)
            {
                matrixPresent = 0;
            }
            else
            {
                matrixPresent = 1;
                dataSize += GDIP_MATRIX_SIZE;
            }

            EmfPlusRecordType   type     = EmfPlusRecordTypeDrawDriverString;

            dataSize = (dataSize + 3) & (~3);    // align

            RecordObject(font, &metaFontId);
            ASSERT((metaFontId & (~GDIP_EPRFLAGS_METAOBJECTID)) == 0);
            metaFlags |= metaFontId;

            GetBrushValueForRecording(brush, brushValue, metaFlags);
            WriteRecordHeader(dataSize, type, metaFlags, deviceBounds);
            WriteInt32(EmfPlusStream, brushValue);
            WriteInt32(EmfPlusStream, flags);
            WriteInt32(EmfPlusStream, matrixPresent);
            WriteInt32(EmfPlusStream, glyphCount);
            WriteBytes(EmfPlusStream, textData, sizeText);
            WriteBytes(EmfPlusStream, positionData, sizePositions);

            if (matrix != NULL)
            {
                WriteMatrix(EmfPlusStream, *matrix);
            }

            // align
            if ((glyphCount & 0x01) != 0)
            {
                sizeText = 0;
                EmfPlusStream->Write(&sizeText, sizeof(WCHAR), NULL);
            }

            WriteGdiComment();  // is down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write DrawDriverString record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordSave.
*
* Arguments:
*
*   [IN]  gstate - the pushed state (restore to state before this)
*
* Return Value:
*
*   NONE
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordSave(
    INT         gstate
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        if (IsValid())
        {
            UINT32              dataSize = sizeof(UINT32/* index */);
            EmfPlusRecordType   type     = EmfPlusRecordTypeSave;
            INT                 index    = SaveRestoreStack.GetCount();

            SaveRestoreStack.Add(gstate);

            WriteRecordHeader(dataSize, type);
            WriteInt32(EmfPlusStream, index);
            // WriteGdiComment(); no down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write Save record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordRestore.
*
* Arguments:
*
*   [IN]  gstate - the pushed state (restore to state before this)
*
* Return Value:
*
*   NONE
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordRestore(
    INT         gstate
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        if (IsValid())
        {
            INT         count = SaveRestoreStack.GetCount();
            INT *       stack = SaveRestoreStack.GetDataBuffer();

            if ((count > 0) && (stack != NULL))
            {
                UINT32              dataSize = sizeof(UINT32/* index */);
                EmfPlusRecordType   type     = EmfPlusRecordTypeRestore;

                do
                {
                    if (stack[--count] == gstate)
                    {
                        SaveRestoreStack.SetCount(count);
                        WriteRecordHeader(dataSize, type);
                        WriteInt32(EmfPlusStream, count);
                        // WriteGdiComment(); no down-level for this record

                        if (EmfPlusStream->IsValid())
                        {
                            return Ok;
                        }
                        SetValid(FALSE);
                        break;
                    }
                } while (count > 0);
            }
        }
        WARNING(("Failed to write Restore record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordBeginContainer.
*
* Arguments:
*
*   [IN]  destRect       - rect to draw container inside of
*   [IN]  srcRect        - maps source size to destRect
*   [IN]  srcUnit        - units of srcRect
*   [IN]  containerState - the pushed state (restore to state before this)
*
* Return Value:
*
*   NONE
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordBeginContainer(
    const GpRectF &             destRect,
    const GpRectF &             srcRect,
    GpPageUnit                  srcUnit,
    INT                         containerState
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        if (IsValid())
        {
            UINT32              dataSize = GDIP_RECTF_SIZE /* destRect */ +
                                           GDIP_RECTF_SIZE /* srcRect */ +
                                           sizeof(UINT32/* index */);
            EmfPlusRecordType   type     = EmfPlusRecordTypeBeginContainer;
            INT                 index    = SaveRestoreStack.GetCount();
            INT                 flags    = srcUnit;

            ASSERT((flags & (~GDIP_EPRFLAGS_PAGEUNIT)) == 0);

            if (index >= MaxStackSize)
            {
                MaxStackSize = index + 1;
            }

            SaveRestoreStack.Add(containerState);

            WriteRecordHeader(dataSize, type, flags);
            WriteRect(EmfPlusStream, destRect);
            WriteRect(EmfPlusStream, srcRect);
            WriteInt32(EmfPlusStream, index);
            // WriteGdiComment(); no down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write BeginContainer record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordBeginContainer.
*
* Arguments:
*
*   [IN]  containerState - the pushed state (restore to state before this)
*
* Return Value:
*
*   NONE
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordBeginContainer(
    INT                         containerState
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        if (IsValid())
        {
            UINT32              dataSize = sizeof(UINT32/* index */);
            EmfPlusRecordType   type     = EmfPlusRecordTypeBeginContainerNoParams;
            INT                 index    = SaveRestoreStack.GetCount();
            INT                 flags    = 0;

            if (index >= MaxStackSize)
            {
                MaxStackSize = index + 1;
            }

            SaveRestoreStack.Add(containerState);

            WriteRecordHeader(dataSize, type, flags);
            WriteInt32(EmfPlusStream, index);
            // WriteGdiComment(); no down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write BeginContainer record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordEndContainer.
*
* Arguments:
*
*   [IN]  containerState - the pushed state (restore to state before this)
*
* Return Value:
*
*   NONE
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordEndContainer(
    INT                         containerState
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        if (IsValid())
        {
            INT         count = SaveRestoreStack.GetCount();
            INT *       stack = SaveRestoreStack.GetDataBuffer();

            if ((count > 0) && (stack != NULL))
            {
                UINT32              dataSize = sizeof(UINT32/* index */);
                EmfPlusRecordType   type     = EmfPlusRecordTypeEndContainer;

                do
                {
                    if (stack[--count] == containerState)
                    {
                        SaveRestoreStack.SetCount(count);
                        WriteRecordHeader(dataSize, type);
                        WriteInt32(EmfPlusStream, count);
                        // WriteGdiComment(); no down-level for this record

                        if (EmfPlusStream->IsValid())
                        {
                            return Ok;
                        }
                        SetValid(FALSE);
                        break;
                    }
                } while (count > 0);
            }
        }
        WARNING(("Failed to write EndContainer record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordSetWorldTransform.
*
* Arguments:
*
*   [IN]  matrix - matrix to set in graphics
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordSetWorldTransform(
    const GpMatrix &            matrix
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        if (IsValid())
        {
            UINT32              dataSize = GDIP_MATRIX_SIZE;
            EmfPlusRecordType   type     = EmfPlusRecordTypeSetWorldTransform;

            WriteRecordHeader(dataSize, type);
            WriteMatrix(EmfPlusStream, matrix);
            // WriteGdiComment(); no down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write SetWorldTransform record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordResetWorldTransform.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordResetWorldTransform()
{
    return RecordZeroDataRecord(EmfPlusRecordTypeResetWorldTransform, 0);
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordMultiplyWorldTransform.
*
* Arguments:
*
*   [IN]  matrix - matrix to set in graphics
*   [IN]  order  - Append or Prepend
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordMultiplyWorldTransform(
    const GpMatrix &            matrix,
    GpMatrixOrder               order
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        if (IsValid())
        {
            UINT32              dataSize = GDIP_MATRIX_SIZE;
            EmfPlusRecordType   type     = EmfPlusRecordTypeMultiplyWorldTransform;
            INT                 flags    = 0;

            if (order == MatrixOrderAppend)
            {
                flags |= GDIP_EPRFLAGS_APPEND;
            }

            WriteRecordHeader(dataSize, type, flags);
            WriteMatrix(EmfPlusStream, matrix);
            // WriteGdiComment(); no down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write MultiplyWorldTransform record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordTranslateWorldTransform.
*
* Arguments:
*
*   [IN]  dx     - x translation
*   [IN]  dy     - y translation
*   [IN]  order  - Append or Prepend
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordTranslateWorldTransform(
    REAL                        dx,
    REAL                        dy,
    GpMatrixOrder               order
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        if (IsValid())
        {
            UINT32              dataSize = sizeof(dx) + sizeof(dy);
            EmfPlusRecordType   type     = EmfPlusRecordTypeTranslateWorldTransform;
            INT                 flags    = 0;

            if (order == MatrixOrderAppend)
            {
                flags |= GDIP_EPRFLAGS_APPEND;
            }

            WriteRecordHeader(dataSize, type, flags);
            WriteReal(EmfPlusStream, dx);
            WriteReal(EmfPlusStream, dy);
            // WriteGdiComment(); no down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write TranslateWorldTransform record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordScaleWorldTransform.
*
* Arguments:
*
*   [IN]  sx     - x scale
*   [IN]  sy     - y scale
*   [IN]  order  - Append or Prepend
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordScaleWorldTransform(
    REAL                        sx,
    REAL                        sy,
    GpMatrixOrder               order
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        if (IsValid())
        {
            UINT32              dataSize = sizeof(sx) + sizeof(sy);
            EmfPlusRecordType   type     = EmfPlusRecordTypeScaleWorldTransform;
            INT                 flags    = 0;

            if (order == MatrixOrderAppend)
            {
                flags |= GDIP_EPRFLAGS_APPEND;
            }

            WriteRecordHeader(dataSize, type, flags);
            WriteReal(EmfPlusStream, sx);
            WriteReal(EmfPlusStream, sy);
            // WriteGdiComment(); no down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write ScaleWorldTransform record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordRotateWorldTransform.
*
* Arguments:
*
*   [IN]  angle  - rotation angle
*   [IN]  order  - Append or Prepend
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordRotateWorldTransform(
    REAL                        angle,
    GpMatrixOrder               order
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        if (IsValid())
        {
            UINT32              dataSize = sizeof(angle);
            EmfPlusRecordType   type     = EmfPlusRecordTypeRotateWorldTransform;
            INT                 flags    = 0;

            if (order == MatrixOrderAppend)
            {
                flags |= GDIP_EPRFLAGS_APPEND;
            }

            WriteRecordHeader(dataSize, type, flags);
            WriteReal(EmfPlusStream, angle);
            // WriteGdiComment(); no down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write RotateWorldTransform record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordSetPageTransform.
*
* Arguments:
*
*   [IN]  unit   - units to use
*   [IN]  scale  - scale factor to apply
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordSetPageTransform(
    GpPageUnit                  unit,
    REAL                        scale
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        if (IsValid())
        {
            UINT32              dataSize = sizeof(scale);
            EmfPlusRecordType   type     = EmfPlusRecordTypeSetPageTransform;
            INT                 flags    = unit;

            ASSERT((flags & (~GDIP_EPRFLAGS_PAGEUNIT)) == 0);

            WriteRecordHeader(dataSize, type, flags);
            WriteReal(EmfPlusStream, scale);
            // WriteGdiComment(); no down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write SetPageTransform record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordResetClip.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordResetClip()
{
    return RecordZeroDataRecord(EmfPlusRecordTypeResetClip, 0);
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordSetClip.
*
* Arguments:
*
*   [IN]  rect        - set clipping to this rect
*   [IN]  combineMode - the combine operator (and, or, xor, exclude, complement)
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordSetClip(
    const GpRectF &             rect,
    CombineMode                 combineMode
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        if (IsValid())
        {
            UINT32              dataSize = GDIP_RECTF_SIZE;
            EmfPlusRecordType   type     = EmfPlusRecordTypeSetClipRect;
            INT                 flags    = (combineMode << 8);

            ASSERT((flags & (~GDIP_EPRFLAGS_COMBINEMODE)) == 0);

            WriteRecordHeader(dataSize, type, flags);
            WriteRect(EmfPlusStream, rect);
            // WriteGdiComment(); no down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write SetClipRect record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordSetClip.
*
* Arguments:
*
*   [IN]  region      - set clipping to this region
*   [IN]  combineMode - the combine operator (and, or, xor, exclude, complement)
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordSetClip(
    GpRegion *                  region,
    CombineMode                 combineMode
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        if (IsValid())
        {
            UINT32              dataSize = 0;
            EmfPlusRecordType   type     = EmfPlusRecordTypeSetClipRegion;
            INT                 flags    = (combineMode << 8);
            UINT32              metaRegionId;

            ASSERT((flags & (~GDIP_EPRFLAGS_COMBINEMODE)) == 0);

            RecordObject(region, &metaRegionId);
            ASSERT((metaRegionId & (~GDIP_EPRFLAGS_METAOBJECTID)) == 0);
            flags |= metaRegionId;

            WriteRecordHeader(dataSize, type, flags);
            // WriteGdiComment(); no down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write SetClipRegion record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordSetClip.
*
* Arguments:
*
*   [IN]  path        - set clipping to this path
*   [IN]  combineMode - the combine operator (and, or, xor, exclude, complement)
*   [IN]  isDevicePath- if path is already in device units
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordSetClip(
    GpPath *                    path,
    CombineMode                 combineMode,
    BOOL                        isDevicePath
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        if (IsValid())
        {
            UINT32              dataSize = 0;
            EmfPlusRecordType   type     = EmfPlusRecordTypeSetClipPath;
            INT                 flags    = (combineMode << 8);
            UINT32              metaPathId;

            ASSERT((flags & (~GDIP_EPRFLAGS_COMBINEMODE)) == 0);

            RecordObject(path, &metaPathId);
            ASSERT((metaPathId & (~GDIP_EPRFLAGS_METAOBJECTID)) == 0);
            flags |= metaPathId;

            if (isDevicePath)
            {
                flags |= GDIP_EPRFLAGS_ISDEVICEPATH;
            }

            WriteRecordHeader(dataSize, type, flags);
            // WriteGdiComment(); no down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write SetClipPath record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordOffsetClip.
*
* Arguments:
*
*   [IN]  dx   - x translation amount
*   [IN]  dy   - y translation amount
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordOffsetClip(
    REAL                        dx,
    REAL                        dy
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        if (IsValid())
        {
            UINT32              dataSize = sizeof(dx) + sizeof(dy);
            EmfPlusRecordType   type     = EmfPlusRecordTypeOffsetClip;

            WriteRecordHeader(dataSize, type);
            WriteReal(EmfPlusStream, dx);
            WriteReal(EmfPlusStream, dy);
            // WriteGdiComment(); no down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write OffsetClip record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordGetDC.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordGetDC()
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        GpStatus status = RecordZeroDataRecord(EmfPlusRecordTypeGetDC, 0);
        // WriteGdiComment();  // is down-level for this record
        // WriteGdiComment will only flush if writing EMF+ dual,
        // but for EMF+-only, we also have to flush GetDC records!
        EmfPlusStream->Flush();
        return status;
    }
    return Ok;
}

// Write a record with no data besides the EMF+ record header
GpStatus
MetafileRecorder::RecordZeroDataRecord(
    EmfPlusRecordType   type,
    INT                 flags
    )
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        if (IsValid())
        {
            UINT32              dataSize = 0;

            WriteRecordHeader(dataSize, type, flags);
            // WriteGdiComment(); no down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write record"));
        return Win32Error;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordSetAntiAliasMode.
*
* Arguments:
*
*   [IN]  newMode   - new anti aliasing mode
*
* Return Value:
*
*   NONE
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordSetAntiAliasMode(
    BOOL                        newMode
    )
{
    return RecordZeroDataRecord(EmfPlusRecordTypeSetAntiAliasMode,
                                newMode ? GDIP_EPRFLAGS_ANTIALIAS : 0);
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordSetTextRenderingHint.
*
* Arguments:
*
*   [IN]  newMode   - new rendering hint
*
* Return Value:
*
*   NONE
*
* Created:
*
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordSetTextRenderingHint(
    TextRenderingHint               newMode
    )
{
    ASSERT ((newMode & (~GDIP_EPRFLAGS_TEXTRENDERINGHINT)) == 0);
    return RecordZeroDataRecord(EmfPlusRecordTypeSetTextRenderingHint, newMode);
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordSetTextContrast.
*
* Arguments:
*
*   [IN]  gammaValue   - new contrast value
*
* Return Value:
*
*   NONE
*
* Created:
*
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordSetTextContrast(
    UINT                    contrast
    )
{
    ASSERT ((contrast & (~GDIP_EPRFLAGS_CONTRAST)) == 0);
    return RecordZeroDataRecord(EmfPlusRecordTypeSetTextContrast, contrast);
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordSetInterpolationMode.
*
* Arguments:
*
*   [IN]  newMode   - new interpolation mode
*
* Return Value:
*
*   NONE
*
* Created:
*
*   5/1/2000 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordSetInterpolationMode(
    InterpolationMode           newMode
    )
{
    ASSERT ((newMode & (~GDIP_EPRFLAGS_INTERPOLATIONMODE)) == 0);
    return RecordZeroDataRecord(EmfPlusRecordTypeSetInterpolationMode, newMode);
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordSetPixelOffsetMode.
*
* Arguments:
*
*   [IN]  newMode   - new pixel offset mode
*
* Return Value:
*
*   NONE
*
* Created:
*
*   5/1/2000 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordSetPixelOffsetMode(
    PixelOffsetMode             newMode
    )
{
    ASSERT ((newMode & (~GDIP_EPRFLAGS_PIXELOFFSETMODE)) == 0);
    return RecordZeroDataRecord(EmfPlusRecordTypeSetPixelOffsetMode, newMode);
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordSetRenderingOrigin.
*
* Arguments:
*
*   [IN]  x, y   - new rendering origin
*
* Return Value:
*
*   NONE
*
* Created:
*
*   5/4/2000 asecchia
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordSetRenderingOrigin(
    INT x,
    INT y
)
{
    // If doing down-level only, then EmfPlusStream will be NULL
    if (EmfPlusStream != NULL)
    {
        if (IsValid())
        {
            UINT32              dataSize = sizeof(x) + sizeof(y);
            EmfPlusRecordType   type     = EmfPlusRecordTypeSetRenderingOrigin;

            WriteRecordHeader(dataSize, type);
            WriteInt32(EmfPlusStream, x);
            WriteInt32(EmfPlusStream, y);

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        WARNING(("Failed to write SetRenderingOrigin record"));
        return Win32Error;
    }
    return Ok;
}


/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordSetCompositingMode.
*
* Arguments:
*
*   [IN]  newMode   - new compositing mode
*
* Return Value:
*
*   NONE
*
* Created:
*
*   10/11/1999 AGodfrey
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordSetCompositingMode(
    GpCompositingMode newMode
    )
{
    ASSERT ((newMode & (~GDIP_EPRFLAGS_COMPOSITINGMODE)) == 0);
    return RecordZeroDataRecord(EmfPlusRecordTypeSetCompositingMode, newMode);
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordSetCompositingQuality.
*
* Arguments:
*
*   [IN]  newQuality   - new quality setting
*
* Return Value:
*
*   NONE
*
* Created:
*
*   04/22/2000 AGodfrey
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordSetCompositingQuality(
    GpCompositingQuality newQuality
    )
{
    ASSERT ((newQuality & (~GDIP_EPRFLAGS_COMPOSITINGQUALITY)) == 0);
    return RecordZeroDataRecord(EmfPlusRecordTypeSetCompositingQuality, newQuality);
}

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - RecordComment.
*
* Arguments:
*
*   [IN]  sizeData - number of bytes of data
*   [IN]  data     - pointer to the data
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/29/1999 DCurtis
*
\**************************************************************************/
GpStatus
MetafileRecorder::RecordComment(
    UINT            sizeData,
    const BYTE *    data
    )
{
    if (IsValid() && (sizeData > 0) && (data != NULL))
    {
        // If doing down-level only, then EmfPlusStream will be NULL
        if (EmfPlusStream != NULL)
        {
            UINT32              dataSize = (sizeData + 3) & (~3);
            EmfPlusRecordType   type     = EmfPlusRecordTypeComment;
            INT                 pad      = dataSize - sizeData;
            INT                 flags    = pad;

            WriteRecordHeader(dataSize, type, flags);
            WriteBytes(EmfPlusStream, data, sizeData);
            while(pad--)
            {
                WriteByte(EmfPlusStream, 0);
            }
            // WriteGdiComment(); no down-level for this record

            if (EmfPlusStream->IsValid())
            {
                return Ok;
            }
            SetValid(FALSE);
        }
        else if (Type == EmfTypeEmfOnly)
        {
            GdiComment(MetafileHdc, sizeData, data);
            return Ok;
        }
    }
    WARNING(("Failed to write Comment record"));
    return GenericError;
}

GpStatus
MetafileRecorder::RecordHeader(
    INT                 logicalDpiX,
    INT                 logicalDpiY,
    INT                 emfPlusFlags
    )
{
    // Don't need to check for EmfPlusStream or Valid

    UINT32              dataSize     = sizeof(EmfPlusHeaderRecord);
    EmfPlusRecordType   type         = EmfPlusRecordTypeHeader;
    INT                 flags        = 0;

    if (Type != EmfTypeEmfPlusOnly)
    {
        flags |= GDIP_EPRFLAGS_EMFPLUSDUAL;
    }

    EmfPlusHeaderRecord emfPlusHeader(emfPlusFlags, logicalDpiX, logicalDpiY);

    WriteRecordHeader(dataSize, type, flags);
    WriteBytes(EmfPlusStream, &emfPlusHeader, sizeof(emfPlusHeader));

    // We have to flush the EMF+ header immediately to guarantee that it
    // is the first record in the EMF after the EMF header.  Otherwise,
    // CloneColorAdjusted fails, because immediately after the metafile
    // constructor, it calls Play into the new metafile which writes a
    // SaveDC record into the metafile.
    EmfPlusStream->Flush();

    if (EmfPlusStream->IsValid())
    {
        return Ok;
    }
    SetValid(FALSE);
    WARNING(("Failed to write Metafile Header record"));
    return Win32Error;
}

VOID
MetafileRecorder::RecordEndOfFile()
{
    RecordZeroDataRecord(EmfPlusRecordTypeEndOfFile, 0);
}

extern "C"
int CALLBACK
EnumEmfToStream(
    HDC                     hdc,
    HANDLETABLE FAR *       gdiHandleTable,
    CONST ENHMETARECORD *   emfRecord,
    int                     numHandles,
    LPARAM                  stream
    );

/**************************************************************************\
*
* Function Description:
*
*   IMetafileRecord interface method - EndRecording.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
VOID
MetafileRecorder::EndRecording()
{
    GpMetafile::MetafileState   state = GpMetafile::InvalidMetafileState;

    if (IsValid() && (Metafile->State == GpMetafile::RecordingMetafileState))
    {
        INT         success = 1;    // assume success

        // If doing down-level only, then EmfPlusStream will be NULL
        if (EmfPlusStream != NULL)
        {
            // Force a flush of the Stream buffer to the EMF+ file
            EmfPlusStream->Flush();

            // We put a no-op PatBlt into the metafile to guarantee that
            // the header of the metafile has the same size bounds and
            // frame rect that GDI+ has recorded so that the EMF will
            // play back the same way, whether GDI plays it back or we do.
            // Otherwise, this may not be the case.  For example, on a
            // bezier curve, the GDI+ bounds would include the control
            // points, whereas the down-level representation may not.

            // If we haven't written any records to the file, then XMinDevice
            // and other bounds are still initialized at FLT_MAX and can cause
            // an exception. We don't need the empty PatBlt record in that case
            // because we haven't written anything.
            if (BoundsInit != FALSE)
            {
                // Try to match the GDI+ rasterizer
                INT     left   = RasterizerCeiling(XMinDevice);
                INT     top    = RasterizerCeiling(YMinDevice);
                INT     right  = RasterizerCeiling(XMaxDevice); // exclusive
                INT     bottom = RasterizerCeiling(YMaxDevice); // exclusive

                // to get the inclusive right and bottom, we'd now
                // have to subtract 1 from each of them
                if ((right > left) && (bottom > top))
                {
                    Metafile->MetaGraphics->NoOpPatBlt(left, top, right - left, bottom - top);
                }
            }

            // must be the last record in the file, except the EMF EOF record
            RecordEndOfFile();
            EmfPlusStream->Flush();
        }

        HENHMETAFILE    hEmf = CloseEnhMetaFile(MetafileHdc);

        if (hEmf == NULL)
        {
            goto Done;
        }

        // Get the EMF header
        ENHMETAHEADER3      emfHeader;
        if ((GetEnhMetaFileHeader(hEmf, sizeof(emfHeader),
                                  (ENHMETAHEADER*)(&emfHeader)) <= 0) ||
            !EmfHeaderIsValid(emfHeader))
        {
            DeleteEnhMetaFile(hEmf);
            goto Done;
        }

#if DBG
        if ((emfHeader.rclBounds.right  == -1) &&
            (emfHeader.rclBounds.bottom == -1) &&
            (emfHeader.rclBounds.left   ==  0) &&
            (emfHeader.rclBounds.top    ==  0))
        {
            WARNING1("Empty metafile -- no drawing records");
        }
#endif

        MetafileHeader *    header       = &Metafile->Header;
        INT32               emfPlusFlags = header->EmfPlusFlags;

        // Save the header and various other info in the Metafile
        Metafile->Hemf         = hEmf;
        Metafile->MaxStackSize = MaxStackSize;
        header->EmfPlusFlags   = emfPlusFlags;
        header->EmfHeader      = emfHeader;
        header->Size           = emfHeader.nBytes;

        // Set the bounds in the Metafile header
        {
            REAL    multiplierX = header->DpiX / 2540.0f;
            REAL    multiplierY = header->DpiY / 2540.0f;

            // The frameRect is inclusive-inclusive, but the bounds in
            // the header is inclusive-exclusive.
            REAL    x = (multiplierX * (REAL)(emfHeader.rclFrame.left));
            REAL    y = (multiplierY * (REAL)(emfHeader.rclFrame.top));
            REAL    w = (multiplierX * (REAL)(emfHeader.rclFrame.right -
                                              emfHeader.rclFrame.left)) + 1.0f;
            REAL    h = (multiplierY * (REAL)(emfHeader.rclFrame.bottom -
                                              emfHeader.rclFrame.top)) + 1.0f;
            header->X      = GpRound(x);
            header->Y      = GpRound(y);
            header->Width  = GpRound(w);
            header->Height = GpRound(h);
        }

        // The metafile is either supposed to be in memory, in a file,
        // or in a stream.

        // If it goes in a file, we're done unless we need to rewrite
        // any of the header information.
        if (Metafile->Filename != NULL)
        {
            state = GpMetafile::DoneRecordingMetafileState;
        }
        else
        {
            // If it goes in memory, we're done.

            // If it goes in a stream, then we have to write
            // the bits to the stream.

            if (Metafile->Stream != NULL)
            {
                // Write the emf data buffer to the stream,
                // and leave the stream position at the end of the metafile.
                if (!::EnumEnhMetaFile(NULL, hEmf, EnumEmfToStream,
                    Metafile->Stream, NULL))
                {
                    WARNING(("Problem retrieving EMF Data"));
                    DeleteEnhMetaFile(hEmf);
                    Metafile->Hemf = NULL;
                    goto Done;
                }

                // Don't need the Stream any longer
                Metafile->Stream->Release();
                Metafile->Stream = NULL;
            }
            state = GpMetafile::DoneRecordingMetafileState;
        }
    }
    else
    {
        DeleteEnhMetaFile(CloseEnhMetaFile(MetafileHdc));
        WARNING(("Metafile in wrong state in EndRecording"));
    }

Done:
    Metafile->MetaGraphics->Metafile = NULL; // Graphics can't point to us anymore
    Metafile->MetaGraphics->SetValid(FALSE); // Don't allow anymore operations on
                                           // the graphics
    Metafile->MetaGraphics = NULL;         // graphics is not valid any more
    Metafile->State        = state;
    delete this;
}

#if 0
inline INT
WriteActualSize(
    IStream *   stream,
    LONGLONG &  startOfRecord,
    ULONG       actualSize
    )
{
    ASSERT (actualSize > 0);

    // get to size field
    INT success = SeekFromStart(stream, startOfRecord + sizeof(INT32));

    if (success)
    {
        success &= WriteInt32(stream, actualSize);
    }

    // get back to end of record
    success &= SeekFromStart(stream, startOfRecord + actualSize);

    return success;
}
#endif

/**************************************************************************\
*
* Function Description:
*
*   Write an object (pen, brush, image, region, path, font) to metafile by
*   writing its header, calling its serialize method, and then re-writing
*   the size.
*
* Arguments:
*
*   [IN]  type           - the record type
*   [IN]  flags          - any flags for the record header
*   [IN]  object         - pointer to the object to be recorded
*   [IN]  metaObjectId   - ID to store in file that identifies object
*   [IN]  extraData      - any extra data to store with object
*   [IN]  extraDataSize  - size in BYTES of extraData
*
* Return Value:
*
*   INT - 1 if we succeeded, else 0 if we failed
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
VOID
MetafileRecorder::WriteObject(
    ObjectType                  type,
    const GpObject *            object,
    UINT32                      metaObjectId
    )
{
    ULONG               objectDataSize  = object->GetDataSize();
    INT                 flags = ((INT)type << 8);

    ASSERT((objectDataSize & 0x03) == 0);
    ASSERT((flags & (~GDIP_EPRFLAGS_OBJECTTYPE)) == 0);
    ASSERT((metaObjectId & (~GDIP_EPRFLAGS_METAOBJECTID)) == 0);
    ASSERT(objectDataSize != 0);    // cannot have an empty object

    flags |= metaObjectId;

    WriteRecordHeader(objectDataSize, EmfPlusRecordTypeObject, flags, NULL);

    if (object->GetData(EmfPlusStream) != Ok)
    {
        WARNING(("GetData failed"));
    }
    EmfPlusStream->EndObjectRecord();
}

VOID
MetafileRecorder::RecordObject(
    const GpObject *            object,
    UINT32*                     metaObjectId
    )
{
    if (object)
    {
        ObjectType      type  = object->GetObjectType();

        if (ObjectList.IsInList(object, type, metaObjectId))
        {
            ObjectList.UpdateMRU(*metaObjectId);
        }
        else
        {
            ObjectList.InsertAt(object, metaObjectId);
            WriteObject(type, object, *metaObjectId);
        }
    }
    else
    {
        *metaObjectId = GDIP_OBJECTID_NONE;
    }
}

// This is for backward compatiblity.  If we are using a new object
// (such as a new kind of brush), then we can record a backup object
// for down-level apps to use when they see a new object that they
// don't know how to deal with.
GpStatus
MetafileRecorder::RecordBackupObject(
    const GpObject *            object
    )
{
    WriteObject(object->GetObjectType(), object, GDIP_BACKUP_OBJECTID) ;
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Write the initial portion of an EMF+ record.  Every EMF+ record contains
*   a size, a type, and some flags.  Many also contain a rect that specifies
*   the bounds of a drawing operation in REAL device units.
*
* Arguments:
*
*   [IN]  size         - the size of the record (excluding the header)
*   [IN]  type         - the EMF+ record type
*   [IN]  flags        - any flags that are defined for this record
*   [IN]  deviceBounds - bounds of drawing operation, or NULL
*
* Return Value:
*
*   INT - 1 if we succeeded, else 0 if we failed
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
VOID
MetafileRecorder::WriteRecordHeader(
    UINT32                      dataSize,
    EmfPlusRecordType           type,
    INT                         flags,          // 16 bits of flags
    const GpRectF *             deviceBounds
    )
{
    ASSERT((dataSize & 0x03) == 0);

    EmfPlusStream->WriteRecordHeader(dataSize, type, flags);

    NumRecords++;

    if (deviceBounds != NULL)
    {
        // If the bounds aren't initalized then make sure we have 4 valid
        // coordinates
        ASSERT(BoundsInit ||
               ((deviceBounds->X < XMinDevice) &&
                (deviceBounds->GetRight() > XMaxDevice) &&
                (deviceBounds->Y < YMinDevice) &&
                (deviceBounds->GetBottom() > YMaxDevice)));
        BoundsInit = TRUE;
        // Update the device bounds
        if (deviceBounds->X < XMinDevice)
        {
            XMinDevice = deviceBounds->X;
        }
        if (deviceBounds->GetRight() > XMaxDevice)
        {
            XMaxDevice = deviceBounds->GetRight();  // exclusive
        }
        if (deviceBounds->Y < YMinDevice)
        {
            YMinDevice = deviceBounds->Y;
        }
        if (deviceBounds->GetBottom() > YMaxDevice)
        {
            YMaxDevice = deviceBounds->GetBottom(); // exclusive
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
*   If the brush is a 32-bit solid color, then return the solid color as
*   the brush value and set the flags to indicate it's a solid color.
*   Otherwise, record the brush and return the metafile brush id as the
*   brush value.
*
* Arguments:
*
*   [IN]  brush      - the brush that needs to be recorded
*   [OUT] brushValue - the 32-bit color or metafile brush ID
*   [OUT] flags      - set if we're using a solid color
*
* Return Value:
*
*   INT - 1 if we succeeded, else 0 if we failed
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
VOID
MetafileRecorder::GetBrushValueForRecording(
    const GpBrush *brush,
    UINT32        &brushValue,
    INT           &flags
    )
{
    if (brush->GetBrushType() == BrushTypeSolidColor)
    {
        const GpSolidFill * solidBrush = static_cast<const GpSolidFill *>(brush);
        brushValue = solidBrush->GetColor().GetValue();
        flags |= GDIP_EPRFLAGS_SOLIDCOLOR;
    }
    else
    {
        RecordObject(brush, &brushValue);
    }
}

/**************************************************************************\
*
* Function Description:
*
*   GpMetafile constructor for write/read access to a metafile.  (Write must
*   precede the read.)
*
*   This version records an EMF+ to memory.  The type specifies whether
*   to record dual GDI records or not.
*
*   If the frameRect is NULL, it will be calculated by accumulating the
*   device bounds of the metafile.  Otherwise, the supplied frameRect and
*   corresponding frameUnit will be used to record the frameRect in the
*   metafile header. The frameRect is inclusive-inclusive, which means
*   that the width value is actually 1 less than the actual width.
*   For example, a width of 0 is accepted and really means a width of 1.
*
*   If the optional description is supplied, it will become part of the
*   EMF header.
*
* Arguments:
*
*   [IN]  fileName      - where to write the metafile
*   [IN]  referenceHdc  - an HDC to use as a reference for creating metafile
*   [IN]  type          - whether to record EMF+-only or EMF+-dual
*   [IN]  frameRect     - optional frame rect for recording in header
*   [IN]  frameUnit     - the units of the frameRect
*   [IN]  description   - optional metafile description
*
* Return Value:
*
*   NONE
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpMetafile::GpMetafile(
    HDC                 referenceHdc,
    EmfType             type,
    const GpRectF *     frameRect,      // can be NULL
    MetafileFrameUnit   frameUnit,      // if NULL frameRect, doesn't matter
    const WCHAR *       description     // can be NULL
    ) : GpImage(ImageTypeMetafile)
{
    ASSERT(referenceHdc != NULL);

    InitDefaults();

    if ((referenceHdc != NULL) &&
        InitForRecording(
            referenceHdc,
            type,
            frameRect,      // can be NULL
            frameUnit,      // if NULL frameRect, doesn't matter
            description     // can be NULL
            ))
    {
        State = RecordingMetafileState;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   GpMetafile constructor for write/read access to a metafile.  (Write must
*   precede the read.)
*
*   This version records an EMF+ to a file.  The type specifies whether
*   to record dual GDI records or not.
*
*   If the frameRect is NULL, it will be calculated by accumulating the
*   device bounds of the metafile.  Otherwise, the supplied frameRect and
*   corresponding frameUnit will be used to record the frameRect in the
*   metafile header. The frameRect is inclusive-inclusive, which means
*   that the width value is actually 1 less than the actual width.
*   For example, a width of 0 is accepted and really means a width of 1.
*
*   If the optional description is supplied, it will become part of the
*   EMF header.
*
* Arguments:
*
*   [IN]  fileName      - where to write the metafile
*   [IN]  referenceHdc  - an HDC to use as a reference for creating metafile
*   [IN]  type          - whether to record EMF+-only or EMF+-dual
*   [IN]  frameRect     - optional frame rect for recording in header
*   [IN]  frameUnit     - the units of the frameRect
*   [IN]  description   - optional metafile description
*
* Return Value:
*
*   NONE
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpMetafile::GpMetafile(
    const WCHAR*        fileName,
    HDC                 referenceHdc,
    EmfType             type,
    const GpRectF *     frameRect,      // can be NULL
    MetafileFrameUnit   frameUnit,      // if NULL frameRect, doesn't matter
    const WCHAR *       description     // can be NULL
    ) : GpImage(ImageTypeMetafile)
{
    ASSERT((fileName != NULL) && (referenceHdc != NULL));

    InitDefaults();

    if ((fileName != NULL) && (referenceHdc != NULL) &&
        ((Filename = UnicodeStringDuplicate(fileName)) != NULL) &&
        InitForRecording(
            referenceHdc,
            type,
            frameRect,      // can be NULL
            frameUnit,      // if NULL frameRect, doesn't matter
            description     // can be NULL
            ))
    {
        State = RecordingMetafileState;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   GpMetafile constructor for write/read access to a metafile.  (Write must
*   precede the read.)
*
*   This version records an EMF+ to a file.  The type specifies whether
*   to record dual GDI records or not.
*
*   The metafile is first recorded to a temporary file, then it is copied
*   from the file into the stream.
*
*   If the frameRect is NULL, it will be calculated by accumulating the
*   device bounds of the metafile.  Otherwise, the supplied frameRect and
*   corresponding frameUnit will be used to record the frameRect in the
*   metafile header. The frameRect is inclusive-inclusive, which means
*   that the width value is actually 1 less than the actual width.
*   For example, a width of 0 is accepted and really means a width of 1.
*
*   If the optional description is supplied, it will become part of the
*   EMF header.
*
* Arguments:
*
*   [IN]  stream        - where to copy the metafile, after it's recorded
*   [IN]  referenceHdc  - an HDC to use as a reference for creating metafile
*   [IN]  type          - whether to record EMF+-only or EMF+-dual
*   [IN]  frameRect     - optional frame rect for recording in header
*   [IN]  frameUnit     - the units of the frameRect
*   [IN]  description   - optional metafile description
*
* Return Value:
*
*   NONE
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
GpMetafile::GpMetafile(
    IStream *           stream,
    HDC                 referenceHdc,
    EmfType             type,
    const GpRectF *     frameRect,      // can be NULL
    MetafileFrameUnit   frameUnit,      // if NULL frameRect, doesn't matter
    const WCHAR *       description     // can be NULL
    ) : GpImage(ImageTypeMetafile)
{
    ASSERT((stream != NULL) && (referenceHdc != NULL));

    InitDefaults();

    if ((stream != NULL) && (referenceHdc != NULL))
    {
        if (InitForRecording(
                referenceHdc,
                type,
                frameRect,      // can be NULL
                frameUnit,      // if NULL frameRect, doesn't matter
                description     // can be NULL
                ))
        {
            stream->AddRef();
            Stream = stream;
            State = RecordingMetafileState;
        }
    }
}

inline HDC CreateEmf(
    HDC             referenceHdc,
    const WCHAR *   fileName,
    RECT *          frameRect
    )
{
    HDC         metafileHdc = NULL;

    if (Globals::IsNt)
    {
        metafileHdc = CreateEnhMetaFileW(referenceHdc, fileName, frameRect, NULL);
    }
    else
    {
        AnsiStrFromUnicode fileBuffer(fileName);

        if (fileBuffer.IsValid())
        {
            metafileHdc = CreateEnhMetaFileA(referenceHdc, fileBuffer, frameRect, NULL);
        }
    }
    return metafileHdc;
}

static BOOL
GetFrameRectInMM100Units(
    HDC                 hdc,
    const GpRectF *     frameRect,
    MetafileFrameUnit   frameUnit,
    RECT &              rclFrame
    )
{
    SIZEL   szlDevice;              // Size of device in pels
    SIZEL   szlMillimeters;         // Size of device in millimeters
    REAL    dpiX;
    REAL    dpiY;

    // NOTE: We have to use the szlDevice and szlMillimeters to get
    // the dpi (instead of getting it directly from LOGPIXELSX/Y)
    // so that the frame rect that is calculated for the metafile by GDI
    // matches the one that GDI+ would have calculated.  Because it's
    // these 2 metrics that the GDI metafile code uses to get the frame
    // rect from the bounds, not the logical DPI.

    szlDevice.cx      = ::GetDeviceCaps(hdc, HORZRES);
    szlDevice.cy      = ::GetDeviceCaps(hdc, VERTRES);
    szlMillimeters.cx = ::GetDeviceCaps(hdc, HORZSIZE);
    szlMillimeters.cy = ::GetDeviceCaps(hdc, VERTSIZE);

    if ((szlDevice.cx <= 0) || (szlDevice.cy <= 0) ||
        (szlMillimeters.cx <= 0) || (szlMillimeters.cy <= 0))
    {
        WARNING(("GetDeviceCaps failed"));
        return FALSE;
    }

    // Now get the real DPI, adjusted for the round-off error.
    dpiX = ((REAL)(szlDevice.cx) / (REAL)(szlMillimeters.cx)) * 25.4f;
    dpiY = ((REAL)(szlDevice.cy) / (REAL)(szlMillimeters.cy)) * 25.4f;

    GpRectF     frameRectMM100;

    FrameToMM100(frameRect, (GpPageUnit)frameUnit, frameRectMM100,
                 dpiX, dpiY);

    rclFrame.left   = GpRound(frameRectMM100.X);
    rclFrame.top    = GpRound(frameRectMM100.Y);
    rclFrame.right  = GpRound(frameRectMM100.GetRight());
    rclFrame.bottom = GpRound(frameRectMM100.GetBottom());
    
    // Make sure the .01MM frameRect is valid
    // It's okay for left == right, because the frameRect
    // is inclusive-inclusive.
    if ((rclFrame.left > rclFrame.right) ||
        (rclFrame.top  > rclFrame.bottom))
    {
        WARNING(("Invalid GDI frameRect"));
        return FALSE;
    }

    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*
*   Convert a frameRect in any units, to a frame rect that is in .01 MM units.
*
* Arguments:
*
*   [IN]  frameRect      - the source frameRect
*   [IN]  frameUnit      - the units of the source frameRect
*   [OUT] frameRectMM100 - the frameRect in inch units
*   [IN]  dpiX           - the horizontal DPI
*   [IN]  dpiY           - the vertical   DPI
*
* Return Value:
*
*   NONE
*
* Created:
*
*   6/15/1999 DCurtis
*
\**************************************************************************/
static VOID
FrameToMM100(
    const GpRectF *         frameRect,
    GpPageUnit              frameUnit,
    GpRectF &               frameRectMM100,
    REAL                    dpiX,               // only used for pixel case
    REAL                    dpiY
    )
{
    REAL        pixelsToMM100X   = (2540.0f / dpiX);
    REAL        pixelsToMM100Y   = (2540.0f / dpiY);

    // The GDI frameRect has right and bottom values that are
    // inclusive, whereas the GDI+ frameRect has GetRight() and
    // GetBottom() values that are exclusive (because GDI+ rects
    // are specified with width/height, not right/bottom.  To convert
    // from the GDI+ value to the GDI value, we have to subtract 1 pixel.
    // This means that we first convert the units to pixel units, then 
    // subtract one, then convert to MM100 units.
    switch (frameUnit)
    {
    default:
        ASSERT(0);
        // FALLTHRU

    case UnitPixel:             // Each unit represents one device pixel.
        frameRectMM100.X      = frameRect->X * pixelsToMM100X;
        frameRectMM100.Y      = frameRect->Y * pixelsToMM100Y;
        frameRectMM100.Width  = frameRect->Width;
        frameRectMM100.Height = frameRect->Height;
        break;

    case UnitPoint:             // Each unit represents 1/72 inch.
        frameRectMM100.X      = frameRect->X * (2540.0f / 72.0f);
        frameRectMM100.Y      = frameRect->Y * (2540.0f / 72.0f);
        frameRectMM100.Width  = frameRect->Width  * (dpiX / 72.0f);
        frameRectMM100.Height = frameRect->Height * (dpiY / 72.0f);
        break;

    case UnitInch:              // Each unit represents 1 inch.
        frameRectMM100.X      = frameRect->X * 2540.0f;
        frameRectMM100.Y      = frameRect->Y * 2540.0f;
        frameRectMM100.Width  = frameRect->Width  * dpiX;
        frameRectMM100.Height = frameRect->Height * dpiY;
        break;

    case UnitDocument:          // Each unit represents 1/300 inch.
        frameRectMM100.X      = frameRect->X * (2540.0f / 300.0f);
        frameRectMM100.Y      = frameRect->Y * (2540.0f / 300.0f);
        frameRectMM100.Width  = frameRect->Width  * (dpiX / 300.0f);
        frameRectMM100.Height = frameRect->Height * (dpiY / 300.0f);
        break;

    case UnitMillimeter:        // Each unit represents 1 millimeter.
                                // One Millimeter is 0.03937 inches
                                // One Inch is 25.4 millimeters
        frameRectMM100.X      = frameRect->X * (100.0f);
        frameRectMM100.Y      = frameRect->Y * (100.0f);
        frameRectMM100.Width  = frameRect->Width  * (dpiX / 25.4f);
        frameRectMM100.Height = frameRect->Height * (dpiY / 25.4f);
        break;
    }
    frameRectMM100.Width  = (frameRectMM100.Width  - 1.0f) * pixelsToMM100X;
    frameRectMM100.Height = (frameRectMM100.Height - 1.0f) * pixelsToMM100Y;
}

BOOL
GpMetafile::InitForRecording(
    HDC                 referenceHdc,
    EmfType             type,
    const GpRectF *     frameRect,      // can be NULL
    MetafileFrameUnit   frameUnit,      // if NULL frameRect, doesn't matter
    const WCHAR *       description     // can be NULL
    )
{
    RECT *  frameRectParam = NULL;
    RECT    rclFrame;

    if (frameRect != NULL)
    {
        // Validate the frameRect
        // 0 is allowed, since the frameRect is inclusive-inclusive, which
        // means that a width of 0 is actually a width of 1
        if ((frameRect->Width < 0.0f) || (frameRect->Height < 0.0f))
        {
            WARNING(("Invalid frameRect"));
            return FALSE;
        }

        if (frameUnit == MetafileFrameUnitGdi)
        {
            // Typically, the GDI+ frameRect is inclusive/exclusive
            // as far as the GetLeft()/GetRight() values go, but the
            // MetafileFrameUnitGdi unit is a special type of unit
            // that specifies compatibility with GDI which is
            // inclusive/inclusive, so we don't do any adjustment
            // on those values at all -- we just assume they are ready
            // to pass directly to GDI.
            rclFrame.left   = GpRound(frameRect->X);
            rclFrame.top    = GpRound(frameRect->Y);
            rclFrame.right  = GpRound(frameRect->GetRight());
            rclFrame.bottom = GpRound(frameRect->GetBottom());

            // Make sure the .01MM frameRect is valid
            // It's okay for left == right, because the GDI frameRect
            // is inclusive-inclusive.
            if ((rclFrame.left > rclFrame.right) ||
                (rclFrame.top  > rclFrame.bottom))
            {
                WARNING(("Invalid GDI frameRect"));
                return FALSE;
            }
        }
        else
        {
            if (!GetFrameRectInMM100Units(referenceHdc, frameRect, frameUnit, rclFrame))
            {
                return FALSE;
            }
        }

        frameRectParam = &rclFrame;
    }
    
    HDC     metafileHdc;

    // Now create the metafile HDC
    // Note that FileName might be NULL
    metafileHdc = CreateEmf(referenceHdc, Filename, frameRectParam);
    if (metafileHdc == NULL)
    {
        return FALSE;       // failed
    }

    // Now get the dpi based on the metafileHdc (which could be different
    // than the referenceHdc).
    
    SIZEL   szlDevice;              // Size of metafile device in pels
    SIZEL   szlMillimeters;         // Size of metafile device in millimeters
    GpRectF metafileBounds;
    
    // NOTE: We have to use the szlDevice and szlMillimeters to get
    // the dpi (instead of getting it directly from LOGPIXELSX/Y)
    // so that the frame rect that is calculated for the metafile by GDI
    // matches the one that GDI+ would have calculated.  Because it's
    // these 2 metrics that the GDI metafile code uses to get the frame
    // rect from the bounds, not the logical DPI.

    szlDevice.cx      = ::GetDeviceCaps(metafileHdc, HORZRES);
    szlDevice.cy      = ::GetDeviceCaps(metafileHdc, VERTRES);
    szlMillimeters.cx = ::GetDeviceCaps(metafileHdc, HORZSIZE);
    szlMillimeters.cy = ::GetDeviceCaps(metafileHdc, VERTSIZE);

    if ((szlDevice.cx <= 0) || (szlDevice.cy <= 0) ||
        (szlMillimeters.cx <= 0) || (szlMillimeters.cy <= 0))
    {
        WARNING(("GetDeviceCaps failed"));
        goto ErrorExit;
    }

    REAL    dpiX;
    REAL    dpiY;
    REAL    dpmmX = (REAL)(szlDevice.cx) / (REAL)(szlMillimeters.cx);
    REAL    dpmmY = (REAL)(szlDevice.cy) / (REAL)(szlMillimeters.cy);

    // Now get the real DPI, adjusted for the round-off error.
    dpiX = dpmmX * 25.4f;
    dpiY = dpmmY * 25.4f;

    // Set the DPI in the metafile
    this->Header.DpiX = dpiX;
    this->Header.DpiY = dpiY;

    // NOTE: On Win9x there are some hi-res printer drivers that use a
    // different resolution for the metafileHdc than they do for the 
    // referenceHdc (Probably to avoid overflow.)  The problem with that 
    // is, that the differing resolutions make it impossible for us to 
    // know which frameRect to use, because we don't know for certain 
    // what DPI the application is going to assume to do its drawing -- 
    // whether the metafile resolution or the printer resolution.  In any
    // case, it's a safe bet that the original frameRect is wrong.

    if (!Globals::IsNt && (frameRectParam != NULL) &&
        (::GetDeviceCaps(metafileHdc, LOGPIXELSX) != ::GetDeviceCaps(referenceHdc, LOGPIXELSX)))
    {
        frameRectParam = NULL;  // give up on the frameRect

        // Now recreate the metafile HDC
        ::DeleteEnhMetaFile(::CloseEnhMetaFile(metafileHdc));
        metafileHdc = CreateEmf(referenceHdc, Filename, frameRectParam);
        if (metafileHdc == NULL)
        {
            return FALSE;       // failed
        }
    }

    // The metafileBounds are used as the bounds for FillRegion
    // calls when the region has infinite bounds, to keep from
    // exploding the bounds of the metafile.
    if (frameRectParam != NULL)
    {

        dpmmX *= 0.01f;
        dpmmY *= 0.01f;

        metafileBounds.X      = rclFrame.left * dpmmX;
        metafileBounds.Y      = rclFrame.top  * dpmmY;
        metafileBounds.Width  = (rclFrame.right  - rclFrame.left) * dpmmX;
        metafileBounds.Height = (rclFrame.bottom - rclFrame.top)  * dpmmY;
    }
    else
    {
        metafileBounds.X      = 0.0f;
        metafileBounds.Y      = 0.0f;
        metafileBounds.Width  = (REAL)szlDevice.cx - 1; // metafile bounds are inclusive
        metafileBounds.Height = (REAL)szlDevice.cy - 1;
    }

    // Now create the recorder object
    MetafileRecorder *  recorder = new MetafileRecorder(
                                        this,
                                        type,
                                        metafileHdc,
                                        (frameRectParam != NULL),
                                        szlMillimeters,
                                        metafileBounds);
    if (CheckValid(recorder))
    {
        MetaGraphics = GpGraphics::GetForMetafile(recorder, type, metafileHdc);
        if (MetaGraphics != NULL)
        {
            if (MetaGraphics->IsValid())
            {
                return TRUE;
            }
            recorder->SetValid(FALSE);// so we don't record stuff in EndRecording
            delete MetaGraphics;    // calls EndRecording which deletes recorder
            MetaGraphics = NULL;
        }
        else
        {
            delete recorder;
        }
    }
ErrorExit:
    DeleteEnhMetaFile(CloseEnhMetaFile(metafileHdc));
    return FALSE;
}

// Returns NULL if the metafile was opened for reading or if already got
// the context for writing.
GpGraphics *
GpMetafile::GetGraphicsContext()
{
    if (!RequestedMetaGraphics)
    {
        RequestedMetaGraphics = TRUE;
        return MetaGraphics;
    }
    WARNING(("Requesting MetaGraphics more than once"));
    return NULL;
}

GpStatus 
GpMetafile::SetDownLevelRasterizationLimit(
    UINT                    metafileRasterizationLimitDpi
    )
{
    ASSERT(IsValid());
    // 0 means restore it to the default value; otherwise, the minumum is 10 dpi
    if ((metafileRasterizationLimitDpi == 0) || (metafileRasterizationLimitDpi >= 10))
    {
        if ((State == GpMetafile::RecordingMetafileState) &&
            (MetaGraphics != NULL))
        {
            MetaGraphics->Context->SetMetafileDownLevelRasterizationLimit(metafileRasterizationLimitDpi);
            return Ok;
        }
        WARNING1("Metafile in Wrong State for this operation");
        return WrongState;
    }
    WARNING1("rasterizationDpiLimit is non-zero but too small");
    return InvalidParameter;
}

GpStatus 
GpMetafile::GetDownLevelRasterizationLimit(
    UINT *                  metafileRasterizationLimitDpi
    ) const
{
    ASSERT(metafileRasterizationLimitDpi != NULL);
    ASSERT(IsValid());
    if ((State == GpMetafile::RecordingMetafileState) &&
        (MetaGraphics != NULL))
    {
        *metafileRasterizationLimitDpi = MetaGraphics->Context->GetMetafileDownLevelRasterizationLimit();
        return Ok;
    }
    WARNING1("Metafile in Wrong State for this operation");
    return WrongState;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\metawmf.hpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   MetaWmf.hpp
*
* Abstract:
*
*   Metafile definitions for WMF and EMF playback
*
* Created:
*
*   1/6/2000 DCurtis
*
\**************************************************************************/

#ifndef _METAWMF_HPP
#define _METAWMF_HPP

//#define GDIP_EXCEPTIONS 0
#define GDIP_TRY        __try {
#define GDIP_CATCH      } __except(EXCEPTION_EXECUTE_HANDLER) {
#define GDIP_ENDCATCH   }

#define GDIP_RECORDBUFFER_SIZE      2048    // >= 1138 so pattern brushes work

#define SIZEOF_METARECORDHEADER     (sizeof(DWORD) + sizeof(WORD))

#define NUM_STOCK_FONTS             (DEFAULT_GUI_FONT - OEM_FIXED_FONT + 1)

#define NUM_STOCK_RECOLOR_OBJS      7

/*****************************************************************************
    Commenting.

    These interfaces allow comments to be added to a metafile DC which describe
    grouping and other information useful for decoding metafiles, the
    interfaces which take an MSODC have no effect if the DC is not a picture
    (PICT, WMF or EMF) DC.

    For PICT files there are two levels of structure, the public comment
    "kind" which is a globally defined comment and the "private" comment kind,
    which is used for application-specific comments.  In a PICT the public
    comment kind is the kind argument to PicComment and the private kind is
    used if the public value is pictApplicationComment.

    In a WMF the signature indicates whether the comment is public or private,
    all comments look like the PICT private comment.

    In an EMF GdiComment() defines some "public" comments plus a format for
    "private" comments - see the Win32 API documentation.
******************************************************************* JohnBo **/

// Definition of the comment codes used in the various metafile formats.
const ULONG msosignaturePublic =0xFFFFFFFF; // WMF public signature.
const ULONG msosignaturePPOld  =0x5050FE54; // PowerPoint 2 signature
const ULONG msosignaturePP     =0x50504E54; // PowerPoint signature
const ULONG msosignature       =0x50504E54; // Office/Escher signature

// The following enumeration defines the ukind values in the above structure,
// note that these duplicate the PICT comment kinds for groups because in
// a WMF (but *NOT* a PICT or EMF) and MSOMFCOMMENT structure must be used,
// this enumeration contains all the valid kinds, including both the public
// and private kinds, these may overlap because they are distinguished by
// the "signature".
typedef enum
{
    // Public WMF comments - signature == msosignaturePublic.
    msocommentBeginGroup         = 0x0000,  // Public WMF begin group.
    msocommentEndGroup           = 0x0001,  // Public WMF end group.
    msocommentBeginHeader        = 0x0002,
    msocommentEndHeader          = 0x0003,
    msocommentCreator            = 0x0004,
    msocommentWinVersion         = 0x0005,

    // Private PICT and WMF comments - signature == msosignature.
    msocommentVersion            = 0x0000,
    msocommentBFileBlock         = 0x0001,  // UNUSED
    msocommentBeginPicture       = 0x0002,
    msocommentEndPicture         = 0x0003,
    msocommentDevInfo            = 0x0004,
    msocommentBeginHyperOpaque   = 0x0005,  // UNUSED
    msocommentEndHyperOpaque     = 0x0006,  // UNUSED
    msocommentBeginFade          = 0x0007,
    msocommentEndFade            = 0x0008,
    msocommentDitherDetect       = 0x0009,  // Not used now?

    // New values used in Office97.
    msocommentPictureDescription = 0x0101, // Description text.
    msocommentBeginGelEffect     = 0x0102,
    msocommentEndGelEffect       = 0x0103,
    msocommentBeginClipPath      = 0x0104,
    msocommentEndClipPath        = 0x0105,
    msocommentBeginSrcCopy       = 0x0106,
    msocommentEndSrcCopy         = 0x0107,

    // Reserved comments used internally by Mac PP4.
    msocommentPictUnmute         = 0x7FFE,
    msocommentPictMute           = 0x7FFF,

    // The following is a flag - what is it for?
    msocommentRegistered         = 0x8000
} MSOMFCOMMENTKIND;



typedef struct
{
    UINT Handle;
    COLORREF Color;
    BOOL Brush;
}
RecolorStockObject;

extern RecolorStockObject RecolorStockObjectList[NUM_STOCK_RECOLOR_OBJS];

enum GdipHdcType
{
    UnknownHdc           = 0x00000000,
    ScreenHdc            = 0x00000001,
    BitmapHdc            = 0x00000002,
    MetafileHdc          = 0x00000004,
    PrinterHdc           = 0x00000008,
    PostscriptHdc        = 0x00010000,
    PostscriptPrinterHdc = PrinterHdc | PostscriptHdc,
    EmfHdc               = 0x00100000 | MetafileHdc,
    WmfHdc               = 0x00200000 | MetafileHdc,
};

enum MfFsmState
{
    MfFsmStart,
    MfFsmPSData,
    MfFsmCreateBrushIndirect,
    MfFsmSelectBrush,
    MfFsmCreatePenIndirect,
    MfFsmSelectPen,
    MfFsmSetROP,
};

class MfEnumState
{
protected:
    GdipHdcType                 HdcType;
    HDC                         Hdc;
    INT                         SaveDcVal;
    INT                         SaveDcCount;
    INT                         NumObjects;     // num objects in handle table
    INT                         SizeAllocedRecord;
    INT                         ModifiedRecordSize;
    INT                         BytesEnumerated;
    BOOL                        ExternalEnumeration;
    HPALETTE                    CurrentPalette;
    HFONT                       DefaultFont;
    HFONT                       StockFonts[NUM_STOCK_FONTS];
    HANDLETABLE *               HandleTable;
    GpRecolor *                 Recolor;
    ColorAdjustType             AdjustType;
    const BYTE *                RecordData;
    UINT                        RecordDataSize;
    EmfPlusRecordType           RecordType;
    InterpolationMode           Interpolation;
    BOOL                        Is8Bpp;
    BOOL                        IsHalftonePalette;
    COLORREF                    BkColor;
    COLORREF                    TextColor;
    RECT                        DestRectDevice;
    BOOL                        RopUsed;
    DpContext *                 Context;
    union
    {
        const VOID *            CurrentRecord;
        const METARECORD *      CurrentWmfRecord;
        const ENHMETARECORD *   CurrentEmfRecord;
    };
    union
    {
        VOID *                  ModifiedRecord;
        METARECORD *            ModifiedWmfRecord;
        ENHMETARECORD *         ModifiedEmfRecord;
    };
    union
    {
        VOID *                  AllocedRecord;
        METARECORD *            AllocedWmfRecord;
        ENHMETARECORD *         AllocedEmfRecord;
    };
    BYTE                        RecordBuffer[GDIP_RECORDBUFFER_SIZE];
    MfFsmState                  FsmState;
    BOOL                        GdiCentricMode;
    BOOL                        SoftekFilter;
    HGDIOBJ                     RecoloredStockHandle[NUM_STOCK_RECOLOR_OBJS];
    BOOL                        SrcCopyOnly;

public:
    MfEnumState(
        HDC                 hdc,
        BOOL                externalEnumeration,
        InterpolationMode   interpolation,
        GpRecolor *         recolor,
        ColorAdjustType     adjustType,
        const RECT *        dest,
        DpContext *         context
        );
    ~MfEnumState();

    BOOL IsValid()      { return (SaveDcVal != 0); }
    BOOL IsMetafile()   { return ((HdcType & MetafileHdc) == MetafileHdc); }
    BOOL IsPostscript() { return ((HdcType & PostscriptHdc) == PostscriptHdc); }
    BOOL IsPrinter()    { return ((HdcType & PrinterHdc) == PrinterHdc);}
    BOOL IsPostscriptPrinter(){ return ((HdcType & PostscriptPrinterHdc) == PostscriptPrinterHdc);}
    BOOL IsBitmap()     { return ((HdcType & BitmapHdc) == BitmapHdc); }
    BOOL IsScreen()     { return ((HdcType & ScreenHdc) == ScreenHdc); }
    BOOL GetRopUsed()   { return RopUsed; }
    VOID ResetRopUsed() { RopUsed = FALSE; }

    VOID
    StartRecord(
        HDC                     hdc,
        HANDLETABLE *           handleTable,
        INT                     numObjects,
        const VOID *            currentRecord,
        EmfPlusRecordType       recordType,
        UINT                    recordDataSize,
        const BYTE *            recordData
        )
    {
        ASSERT(hdc != NULL);

        Hdc                = hdc;
        ModifiedRecord     = NULL;
        ModifiedRecordSize = 0;
        CurrentRecord      = currentRecord;
        RecordType         = recordType;
        RecordDataSize     = recordDataSize;
        RecordData         = recordData;
        BytesEnumerated   += GetCurrentRecordSize();

        if ((handleTable != NULL) && (numObjects > 0))
        {
            HandleTable    = handleTable;
            NumObjects     = numObjects;
        }
        else
        {
            WARNING(("NULL handle table and/or no objects"));
            HandleTable    = NULL;
            NumObjects     = 0;
        }
    }

    virtual BOOL
    ProcessRecord(
        EmfPlusRecordType       recordType,
        UINT                    recordDataSize,
        const BYTE *            recordData
        ) = 0;

    virtual BOOL PlayRecord() = 0;

    VOID SaveHdc()
    {
        SaveDcCount--;
        this->PlayRecord();
    }

    virtual VOID RestoreHdc() = 0;
    VOID SelectPalette(INT objectIndex);

protected:
    virtual INT GetCurrentRecordSize() const = 0;
    BOOL CreateRecordToModify(INT size = 0);
    COLORREF ModifyColor(
        COLORREF        color,
        ColorAdjustType adjustType
        );
    INT
    GetModifiedDibSize(
        BITMAPINFOHEADER UNALIGNED *  dibInfo,
        UINT                          numPalEntries,
        UINT                          dibBitsSize,
        UINT &                        usage
        );
    VOID
    ModifyDib(
        UINT                          usage,
        BITMAPINFOHEADER  UNALIGNED * srcDibInfo,
        BYTE *                        srcBits,
        BITMAPINFOHEADER UNALIGNED *  dstDibInfo,
        UINT                          numPalEntries,
        UINT                          srcDibBitsSize,
        ColorAdjustType               adjustType
        );
    VOID
    Modify16BppDib(
        INT               width,
        INT               posHeight,
        BYTE *            srcPixels,
        DWORD UNALIGNED * bitFields,
        BYTE *            dstPixels,
        ColorAdjustType   adjustType
        );
    VOID
    Modify24BppDib(
        INT               width,
        INT               posHeight,
        BYTE *            srcPixels,
        DWORD UNALIGNED * bitFields,
        BYTE *            dstPixels,
        ColorAdjustType   adjustType
        );
    VOID
    Modify32BppDib(
        INT               width,
        INT               posHeight,
        BYTE *            srcPixels,
        DWORD UNALIGNED * bitFields,
        BYTE *            dstPixels,
        ColorAdjustType   adjustType
        );
    VOID
    OutputDIB(
        HDC                 hdc,
        const RECTL *       bounds,
        INT                 dstX,
        INT                 dstY,
        INT                 dstWidth,
        INT                 dstHeight,
        INT                 srcX,
        INT                 srcY,
        INT                 srcWidth,
        INT                 srcHeight,
        BITMAPINFOHEADER UNALIGNED * dibInfo,
        BYTE *              bits,   // if NULL, this is a packed DIB
        UINT                usage,
        DWORD               rop,
        BOOL                isWmfDib
        );
    virtual BOOL CreateAndPlayOutputDIBRecord(
        HDC                           hdc,
        const RECTL *                 bounds,
        INT                           dstX,
        INT                           dstY,
        INT                           dstWidth,
        INT                           dstHeight,
        INT                           srcX,
        INT                           srcY,
        INT                           srcWidth,
        INT                           srcHeight,
        BITMAPINFOHEADER UNALIGNED *  dibInfo,
        BYTE *                        bits,   // if NULL, this is a packed DIB
        UINT                          usage,
        DWORD                         rop
        )=0;

    virtual BOOL CreateAndPlayCommentRecord()
    {
        return TRUE;
    }

    virtual VOID IntersectDestRect()=0;
};

class WmfEnumState : public MfEnumState
{
public:
    BOOL            IgnorePostscript;

protected:
    INT             MetafileSize;
    HPEN            HpenSave;
    HBRUSH          HbrushSave;
    HPALETTE        HpaletteSave;
    HFONT           HfontSave;
    HBITMAP         HbitmapSave;
    HRGN            HregionSave;
    BOOL            FirstViewportOrg;
    BOOL            FirstViewportExt;
    GpMatrix        ViewportXForm;
    POINT           ImgViewportOrg;
    SIZE            ImgViewportExt;
    POINT           DstViewportOrg;
    SIZE            DstViewportExt;
    BOOL            IsFirstRecord;

public:
    WmfEnumState(
        HDC                 hdc,
        HMETAFILE           hWmf,
        BOOL                externalEnumeration,
        InterpolationMode   interpolation,
        const RECT *        dstRect,
        const RECT *        deviceRect,
        DpContext *         context,
        GpRecolor *         recolor    = NULL,
        ColorAdjustType     adjustType = ColorAdjustTypeDefault
        );
    ~WmfEnumState();

    virtual BOOL
    ProcessRecord(
        EmfPlusRecordType       recordType,
        UINT                    recordDataSize,
        const BYTE *            recordData
        );

    virtual BOOL PlayRecord();
    virtual VOID RestoreHdc();

    VOID EndRecord();
    VOID SetBkColor()
    {
        BkColor  = *((COLORREF UNALIGNED *)&(((WORD UNALIGNED *)RecordData)[0]));
        ModifyRecordColor(0, ColorAdjustTypeBrush);
        this->PlayRecord();
    }
    VOID SetTextColor()
    {
        TextColor  = *((COLORREF UNALIGNED *)&(((WORD UNALIGNED *)RecordData)[0]));
        ModifyRecordColor(0, ColorAdjustTypeText);
        this->PlayRecord();
    }
    VOID FloodFill()
    {
        ModifyRecordColor(0, ColorAdjustTypeBrush);
        this->PlayRecord();
    }
    VOID ExtFloodFill()
    {
        ModifyRecordColor(1, ColorAdjustTypeBrush);
        this->PlayRecord();
    }
    VOID SetPixel()
    {
        ModifyRecordColor(0, ColorAdjustTypePen);
        this->PlayRecord();
    }
    VOID DibCreatePatternBrush();
    VOID CreatePatternBrush();
    VOID CreatePenIndirect();
    VOID CreateBrushIndirect();
    VOID BitBlt();
    VOID StretchBlt()
    {
        this->BitBlt();
    }
    VOID Escape();
    VOID SetDIBitsToDevice();
    VOID PolyPolygon();
    VOID DIBBitBlt();
    VOID DIBStretchBlt()
    {
        this->DIBBitBlt();
    }
    VOID StretchDIBits();
    VOID SetViewportOrg();
    VOID SetViewportExt();
    VOID Rectangle();
    VOID CreateFontIndirect();
    VOID SelectObject();
    VOID CreateRegion();
    VOID SetROP2();

protected:
    virtual INT GetCurrentRecordSize() const { return RecordDataSize + SIZEOF_METARECORDHEADER; }
    BOOL CreateCopyOfCurrentRecord();
    VOID ModifyRecordColor(
        INT             paramIndex,
        ColorAdjustType adjustType
        );
    VOID MakeSolidBlackBrush();
    VOID CalculateViewportMatrix();
    virtual BOOL CreateAndPlayOutputDIBRecord(
        HDC                           hdc,
        const RECTL *                 bounds,
        INT                           dstX,
        INT                           dstY,
        INT                           dstWidth,
        INT                           dstHeight,
        INT                           srcX,
        INT                           srcY,
        INT                           srcWidth,
        INT                           srcHeight,
        BITMAPINFOHEADER UNALIGNED *  dibInfo,
        BYTE *                        bits,   // if NULL, this is a packed DIB
        UINT                          usage,
        DWORD                         rop
        );

    virtual VOID IntersectDestRect();
};

class EmfEnumState : public MfEnumState
{
protected:
    HRGN                    ClipRgn;
    POINT                   BrushOrg;
    HPALETTE                Palette;

public:
    EmfEnumState(
        HDC                 hdc,
        HENHMETAFILE        hEmf,
        const RECT *        dest,
        const RECT *        deviceRect,
        BOOL                externalEnumeration,
        InterpolationMode   interpolation,
        DpContext *         context,
        GpRecolor *         recolor             = NULL,
        ColorAdjustType     adjustType          = ColorAdjustTypeDefault
        );
    ~EmfEnumState()
    {
        GpFree(AllocedRecord);

        if (IsMetafile())
        {
            // Bug 106406 from Office:  Missing RestoreDC in EMF
            // Account for unbalanced SaveDC/RestoreDC pairs and
            // restore to the saveDC state
            ::RestoreDC(Hdc, SaveDcCount - 1);
        }
        else
        {
            ::RestoreDC(Hdc, SaveDcVal);
        }
    }

    virtual BOOL
    ProcessRecord(
        EmfPlusRecordType       recordType,
        UINT                    recordDataSize,
        const BYTE *            recordData
        );

    // returns a pointer to the current record, but the header may
    // not actually be there -- just the data of the record.
    const ENHMETARECORD * GetPartialRecord()
    {
        if (CurrentEmfRecord != NULL)
        {
            return CurrentEmfRecord;
        }
        ASSERT(RecordData != NULL);
        return (const ENHMETARECORD *)(((const BYTE *)RecordData) - sizeof(EMR));
    }

    virtual BOOL PlayRecord();
    virtual VOID RestoreHdc();

    VOID Header();
    VOID SelectPalette(INT objectIndex);
    VOID SetPixelV()
    {
        ModifyRecordColor(2, ColorAdjustTypePen);
        this->PlayRecord();
    }
    VOID SetTextColor()
    {
        TextColor  = ((COLORREF *)RecordData)[0];
        ModifyRecordColor(0, ColorAdjustTypeText);
        this->PlayRecord();
    }
    VOID SetBkColor()
    {
        BkColor  = ((COLORREF *)RecordData)[0];
        ModifyRecordColor(0, ColorAdjustTypeBrush);
        this->PlayRecord();
    }
    VOID CreatePen();
    VOID CreateBrushIndirect();
    VOID ExtFloodFill()
    {
        ModifyRecordColor(2, ColorAdjustTypeBrush);
        this->PlayRecord();
    }
    VOID GdiComment();
    VOID BitBlt();
    VOID StretchBlt();
    VOID SetDIBitsToDevice();
    VOID StretchDIBits();
    VOID CreateDibPatternBrushPt();
    VOID ExtCreatePen();
    VOID MaskBlt()
    {
        // !!! to do
        ResetRecordBounds();
        this->PlayRecord();
    }
    VOID PlgBlt()
    {
        // !!! to do
        ResetRecordBounds();
        this->PlayRecord();
    }
    VOID GradientFill()
    {
        // !!! to do
        this->PlayRecord();
    }
    VOID TransparentBlt()
    {
        // !!! to do
        ResetRecordBounds();
        this->PlayRecord();
    }
    VOID AlphaBlend()
    {
        // !!! to do
        ResetRecordBounds();
        this->PlayRecord();
    }
    VOID ExtEscape();
    VOID ExtCreateFontIndirect();
    VOID SelectObject();
    VOID SetROP2();
    VOID ExtTextOutW();
    VOID Rectangle();

protected:
    virtual INT GetCurrentRecordSize() const { return RecordDataSize + sizeof(EMR); }
    BOOL CreateCopyOfCurrentRecord();
    VOID ModifyRecordColor(
        INT             paramIndex,
        ColorAdjustType adjustType
        );
    BOOL ValidObjectIndex(INT objectIndex)
    {
        return ((objectIndex > 0) && (objectIndex < NumObjects));
    }
    BITMAPINFOHEADER *
    CreateModifiedDib(
        BITMAPINFOHEADER *  srcDibInfo,
        BYTE *              srcBits,
        UINT &              usage,
        DWORD               rop
        );
    virtual BOOL CreateAndPlayOutputDIBRecord(
        HDC                           hdc,
        const RECTL *                 bounds,
        INT                           dstX,
        INT                           dstY,
        INT                           dstWidth,
        INT                           dstHeight,
        INT                           srcX,
        INT                           srcY,
        INT                           srcWidth,
        INT                           srcHeight,
        BITMAPINFOHEADER UNALIGNED *  dibInfo,
        BYTE *                        bits,   // if NULL, this is a packed DIB
        UINT                          usage,
        DWORD                         rop
        );
    virtual VOID IntersectDestRect();

    VOID ResetRecordBounds();
    virtual BOOL CreateAndPlayCommentRecord()
    {
        // This will create an Empty comment record and play it through GDI
        // This is necessary to invalidate the Transform cache that Win9x keeps
        // while playing metafiles. If we need to query the current transform
        // this makes sure that the result is the current one and not the 
        // previously cached transform

        // Allocate a comment buffer that has 1 DWORD in the Data field.
        BYTE buffer[(sizeof(EMRGDICOMMENT)+3) & ~3];
        EMRGDICOMMENT* comment = (EMRGDICOMMENT*) buffer;
        comment->emr.iType = EMR_GDICOMMENT;
        comment->emr.nSize = (sizeof(EMRGDICOMMENT)+3) & ~3;
        comment->cbData = 4;
        *(DWORD*)(comment->Data) = 0;

        return PlayEnhMetaFileRecord(Hdc, HandleTable, (ENHMETARECORD*)comment, NumObjects);
    }

};

BOOL
GetDibNumPalEntries(
    BOOL        isWmfDib,
    UINT        biSize,
    UINT        biBitCount,
    UINT        biCompression,
    UINT        biClrUsed,
    UINT *      numPalEntries
    );

UINT
GetDibBitsSize(
    BITMAPINFOHEADER UNALIGNED *  dibInfo
    );

inline static BOOL
IsSourceInRop3(
    DWORD       rop3
    )
{
    return (rop3 & 0xCCCC0000) != ((rop3 << 2) & 0xCCCC0000);
}

#endif // !_METAWMF_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\metawmf.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   MetaWmf.cpp
*
* Abstract:
*
*   Methods for playing and recoloring a WMF.
*
* Created:
*
*   12/13/1999 DCurtis
*
\**************************************************************************/

#include "Precomp.hpp"
#include "MetaWmf.hpp"

#ifndef BI_CMYK     // from wingdip.h
#define BI_CMYK         10L
#define BI_CMYKRLE8     11L
#define BI_CMYKRLE4     12L
#endif

inline static BOOL
IsDwordAligned(
    VOID *      pointer
    )
{
    return (((ULONG_PTR)pointer & (sizeof(DWORD) - 1)) == 0);
}

inline static BOOL
IsPostscriptPrinter(
    HDC     hdc
    )
{
    // It is a PostScript printer if POSTSCRIPT_PASSTHROUGH or
    // POSTSCRIPT_IGNORE is available

    int iWant1 = POSTSCRIPT_PASSTHROUGH;
    int iWant2 = POSTSCRIPT_IGNORE;

    return ((Escape(hdc, QUERYESCSUPPORT, sizeof(iWant1), (LPCSTR)&iWant1, NULL) != 0) ||
            (Escape(hdc, QUERYESCSUPPORT, sizeof(iWant2), (LPCSTR)&iWant2, NULL) != 0));
}

// Some escapes apparently cause NT 3.51 to crash, so skip them
inline static BOOL
SkipEscape(
    INT     escapeCode
    )
{
    switch (escapeCode)
    {
    case GETPHYSPAGESIZE:       // 12
    case GETPRINTINGOFFSET:     // 13
    case GETSCALINGFACTOR:      // 14
    case BEGIN_PATH:            // 4096
    case CLIP_TO_PATH:          // 4097
    case END_PATH:              // 4098
        return TRUE;
    default:
        return FALSE;
    }
}

inline static BOOL
IsOfficeArtData(
    UINT                recordSize,
    const WORD *        recordData
    )
{
    return (recordData[0] == MFCOMMENT) &&
           (recordSize > 16) &&
           ((INT)recordSize >= (recordData[1] + 10)) &&
           (GpMemcmp(recordData + 2, "TNPPOA", 6) == 0);
}

// The structure which defines the contents of a comment for a WMF or PICT,
// for an EMF use GdiComment() and the "approved" format (see the Win32
// documentation) - this basically is the same except that it has a 4 byte
// kind field.  For a PICT this is the format of an ApplicationComment (kind
// 100).
#pragma pack(push, GDIP_pack, 2)
typedef struct
{
    ULONG       Signature;   // Identifes the comment writer.
    USHORT      Kind;        // Type of comment (writer specific)
    // Comment data follows here.

} WmfComment;

typedef struct
{
    WORD     lbStyle;
    COLORREF lbColor;
    SHORT    lbHatch;
} LOGBRUSH16;

typedef struct
{
    WORD     lopnStyle;
    POINTS   lopnWidth;
    COLORREF lopnColor;
} LOGPEN16;

typedef struct
{
    SHORT   bmType;
    SHORT   bmWidth;
    SHORT   bmHeight;
    SHORT   bmWidthBytes;
    BYTE    bmPlanes;
    BYTE    bmBitsPixel;
    LPBYTE  bmBits;
} BITMAP16;

typedef struct tagLOGFONT16
{
    SHORT     lfHeight;
    SHORT     lfWidth;
    SHORT     lfEscapement;
    SHORT     lfOrientation;
    SHORT     lfWeight;
    BYTE      lfItalic;
    BYTE      lfUnderline;
    BYTE      lfStrikeOut;
    BYTE      lfCharSet;
    BYTE      lfOutPrecision;
    BYTE      lfClipPrecision;
    BYTE      lfQuality;
    BYTE      lfPitchAndFamily;
    BYTE      lfFaceName[LF_FACESIZE];
} LOGFONT16;

#pragma pack(pop, GDIP_pack)

inline static const WmfComment UNALIGNED *
GetWmfComment(
    const WORD *        recordData,
    ULONG               signature,
    UINT                kind
    )
{
    // Assumes you've already checked that
    //     (wmfCommentRecord->rdFunction == META_ESCAPE &&
    //      wmfCommentRecord->rdParm[0] == MFCOMMENT)

    const WmfComment UNALIGNED * wmfComment = (const WmfComment UNALIGNED *)&(recordData[2]);
    if ((wmfComment->Signature == signature) && (wmfComment->Kind == kind))
    {
        return wmfComment;
    }
    return NULL;
}

inline static INT
GetDibByteWidth(
    INT     biWidth,
    INT     biPlanes,
    INT     biBitCount
    )
{
    return (((biWidth * biPlanes * biBitCount) + 31) & ~31) / 8;
}

inline static RGBQUAD UNALIGNED *
GetDibColorTable(
    BITMAPINFOHEADER UNALIGNED * dibInfo
    )
{
    return (RGBQUAD UNALIGNED *)(((BYTE *)dibInfo) + dibInfo->biSize);
}

static BYTE *
GetDibBits(
    BITMAPINFOHEADER UNALIGNED * dibInfo,
    UINT                         numPalEntries,
    UINT                         usage
    )
{
    ASSERT(dibInfo->biSize >= sizeof(BITMAPINFOHEADER));

    INT         colorSize = 0;

    if (numPalEntries > 0)
    {
        if ((usage == DIB_PAL_COLORS) &&
            (dibInfo->biCompression != BI_BITFIELDS) &&
            (dibInfo->biCompression != BI_CMYK))
        {
            // Make sure it is aligned
            colorSize = ((numPalEntries * sizeof(INT16)) + 3) & ~3;
        }
        else
        {
            colorSize = numPalEntries * sizeof(RGBQUAD);
        }
    }

    return ((BYTE *)GetDibColorTable(dibInfo)) + colorSize;
}

UINT
GetDibBitsSize(
    BITMAPINFOHEADER UNALIGNED *  dibInfo
    )
{
    // Check for PM-style DIB
    if (dibInfo->biSize >= sizeof(BITMAPINFOHEADER))
    {
        // not a core header

        if (dibInfo->biWidth > 0)   // can't handle negative width
        {
            if ((dibInfo->biCompression == BI_RGB) ||
                (dibInfo->biCompression == BI_BITFIELDS) ||
                (dibInfo->biCompression == BI_CMYK))
            {
                INT     posHeight = dibInfo->biHeight;

                if (posHeight < 0)
                {
                    posHeight = -posHeight;
                }
                return posHeight *
                       GetDibByteWidth(dibInfo->biWidth, dibInfo->biPlanes,
                                       dibInfo->biBitCount);
            }
            return dibInfo->biSizeImage;
        }
        WARNING(("0 or negative DIB width"));
        return 0;
    }
    else    // it is a PM-style DIB
    {
        BITMAPCOREHEADER UNALIGNED * coreDibInfo = (BITMAPCOREHEADER UNALIGNED *)dibInfo;

        // width and height must be > 0 for COREINFO dibs
        if ((coreDibInfo->bcWidth  > 0) &&
            (coreDibInfo->bcHeight > 0))
        {
            return coreDibInfo->bcHeight *
                   GetDibByteWidth(coreDibInfo->bcWidth,coreDibInfo->bcPlanes,
                                   coreDibInfo->bcBitCount);
        }
        WARNING(("0 or negative DIB width or height"));
        return 0;
    }
}

BOOL
GetDibNumPalEntries(
    BOOL        isWmfDib,
    UINT        biSize,
    UINT        biBitCount,
    UINT        biCompression,
    UINT        biClrUsed,
    UINT *      numPalEntries
    )
{
    UINT        maxPalEntries = 0;

    // Dibs in a WMF always have the bitfields for 16 and 32-bpp dibs.
    if (((biBitCount == 16) || (biBitCount == 32)) && isWmfDib)
    {
        biCompression = BI_BITFIELDS;
    }

    switch (biCompression)
    {
    case BI_BITFIELDS:
        //
        // Handle 16 and 32 bit per pel bitmaps.
        //

        switch (biBitCount)
        {
        case 16:
        case 32:
            break;
        default:
            WARNING(("BI_BITFIELDS not Valid for this biBitCount"));
            return FALSE;
        }

        if (biSize <= sizeof(BITMAPINFOHEADER))
        {
            biClrUsed = maxPalEntries = 3;
        }
        else
        {
            //
            // masks are part of BITMAPV4 and greater
            //

            biClrUsed = maxPalEntries = 0;
        }
        break;

    case BI_RGB:
        switch (biBitCount)
        {
        case 1:
        case 4:
        case 8:
            maxPalEntries = 1 << biBitCount;
            break;
        default:
            maxPalEntries = 0;

            switch (biBitCount)
            {
            case 16:
            case 24:
            case 32:
                break;
            default:
                WARNING(("Invalid biBitCount in BI_RGB"));
                return FALSE;
            }
        }
        break;

    case BI_CMYK:
        switch (biBitCount)
        {
        case 1:
        case 4:
        case 8:
            maxPalEntries = 1 << biBitCount;
            break;
        case 32:
            maxPalEntries = 0;
            break;
        default:
            WARNING(("Invalid biBitCount in BI_CMYK"));
            return FALSE;
        }
        break;

    case BI_RLE4:
    case BI_CMYKRLE4:
        if (biBitCount != 4)
        {
            WARNING(("Invalid biBitCount in BI_RLE4"));
            return FALSE;
        }

        maxPalEntries = 16;
        break;

    case BI_RLE8:
    case BI_CMYKRLE8:
        if (biBitCount != 8)
        {
            WARNING(("Invalid biBitCount in BI_RLE8"));
            return FALSE;
        }

        maxPalEntries = 256;
        break;

    case BI_JPEG:
    case BI_PNG:
        maxPalEntries = 0;
        break;

    default:
        WARNING(("Invalid biCompression"));
        return FALSE;
    }

    if (biClrUsed != 0)
    {
        if (biClrUsed <= maxPalEntries)
        {
            maxPalEntries = biClrUsed;
        }
    }

    *numPalEntries = maxPalEntries;
    return TRUE;
}

GdipHdcType
GetHdcType(
    HDC     hdc
    )
{
    GdipHdcType     hdcType = UnknownHdc;
    UINT            dcType  = GetDCType(hdc);

    switch (dcType)
    {
    case OBJ_DC:
        {
            INT technology = GetDeviceCaps(hdc, TECHNOLOGY);

            if (technology == DT_RASDISPLAY)
            {
                hdcType = ScreenHdc;
            }
            else if (technology == DT_RASPRINTER)
            {
                if (IsPostscriptPrinter(hdc))
                {
                    hdcType = PostscriptPrinterHdc;
                }
                else
                {
                    hdcType = PrinterHdc;
                }
            }
            else
            {
                WARNING(("Unknown HDC technology!"));
            }
        }
        break;

    case OBJ_MEMDC:
        hdcType = BitmapHdc;
        break;

    case OBJ_ENHMETADC:
        // When metafile spooling, the printer DC will be of type
        // OBJ_ENHMETADC on Win9x and NT4 (but not NT5 due to a fix
        // to NT bug 98810).  We need to do some more work to figure
        // out whether it's really a printer DC or a true metafile
        // DC:

        if (Globals::GdiIsMetaPrintDCFunction(hdc))
        {
            if (IsPostscriptPrinter(hdc))
            {
                hdcType = PostscriptPrinterHdc;
            }
            else
            {
                hdcType = PrinterHdc;
            }
        }
        else
        {
            hdcType = EmfHdc;
        }
        break;

    case OBJ_METADC:
        hdcType = WmfHdc;
        break;

    default:
        WARNING(("Unknown HDC type!"));
        break;
    }

    return hdcType;
}

DWORD
GetHdcBitmapBitsPixel(
    HDC hdc
    )
{
    // This function returns the number of bits per pixel for a bitmap DC.
    // On error, 0 is returned.

    ASSERT(GetDCType(hdc) == OBJ_MEMDC);

    HBITMAP hbm = (HBITMAP) GetCurrentObject(hdc, OBJ_BITMAP);

    if (hbm)
    {
        BITMAP bm;

        if (GetObjectA(hbm, sizeof(bm), &bm) >= sizeof(BITMAP))
        {
            return bm.bmBitsPixel;
        }
    }
    
    return 0;
}

MfEnumState::MfEnumState(
    HDC                 hdc,
    BOOL                externalEnumeration,
    InterpolationMode   interpolation,
    GpRecolor *         recolor,
    ColorAdjustType     adjustType,
    const RECT *        deviceRect,
    DpContext *         context
    )
{
    HdcType             = GetHdcType(hdc);
    Hdc                 = hdc;
    HandleTable         = NULL;
    NumObjects          = 0;
    CurrentPalette      = (HPALETTE)::GetStockObject(DEFAULT_PALETTE);
    SizeAllocedRecord   = 0;
    ModifiedRecordSize  = 0;
    SaveDcCount         = 0;
    BytesEnumerated     = 0;
    ExternalEnumeration = externalEnumeration;
    Recolor             = recolor;
    AdjustType          = adjustType;
    CurrentRecord       = NULL;
    ModifiedRecord      = NULL;
    AllocedRecord       = NULL;
    Interpolation       = interpolation;
    SaveDcVal           = SaveDC(hdc);
    FsmState            = MfFsmStart;
    GdiCentricMode      = FALSE;
    SoftekFilter        = FALSE;
    DefaultFont         = NULL;
    RopUsed             = FALSE;
    Context             = context;
    SrcCopyOnly         = FALSE;
    GpMemset(StockFonts, 0, sizeof(StockFonts[0]) * NUM_STOCK_FONTS);
    GpMemset(RecoloredStockHandle, 0, sizeof(HGDIOBJ) * NUM_STOCK_RECOLOR_OBJS);

    // See if we should halftone solid colors
    if ((IsScreen() && (::GetDeviceCaps(hdc, BITSPIXEL) == 8)) ||
        (IsBitmap() && (GetHdcBitmapBitsPixel(hdc) == 8)))
    {
        Is8Bpp = TRUE;
        EpPaletteMap    paletteMap(hdc);
        IsHalftonePalette = (paletteMap.IsValid() && (!paletteMap.IsVGAOnly()));
    }
    else
    {
        Is8Bpp = FALSE;
        IsHalftonePalette = FALSE;
    }

    // Since the transform can change as we are playing the metafile
    // convert the destrect into DeviceUnits. We will make sure to have an
    // identity matrix when we apply it.
    DestRectDevice = *deviceRect;
}

MfEnumState::~MfEnumState()
{
    // Delete all the true type fonts we created (first make sure they
    // are not selected into the Hdc.

    ::SelectObject(Hdc, GetStockObject(SYSTEM_FONT));

    if (DefaultFont)
    {
        DeleteObject(DefaultFont);
    }
    for (int i = 0; i < NUM_STOCK_FONTS; i++)
    {
        if (StockFonts[i] != NULL)
        {
            DeleteObject(StockFonts[i]);
        }
    }

    // Not necessary to delete NULL_BRUSH, NULL_PEN into HDC.  The subclasses
    // restore DC state which should dissolve any selections of these pen/brushes.
    for (int i = 0; i < NUM_STOCK_RECOLOR_OBJS; i++)
    {
        if (RecoloredStockHandle[i] != NULL)
        {
            DeleteObject(RecoloredStockHandle[i]);
        }
    }
}

WmfEnumState::WmfEnumState(
    HDC                 hdc,
    HMETAFILE           hWmf,
    BOOL                externalEnumeration,
    InterpolationMode   interpolation,
    const RECT *        dstRect,
    const RECT *        deviceRect,
    DpContext *         context,
    GpRecolor *         recolor,
    ColorAdjustType     adjustType
    )
    : MfEnumState(hdc, externalEnumeration, interpolation,
                  recolor, adjustType, deviceRect, context)
{
    if (IsValid())
    {
        IgnorePostscript = FALSE;
        BytesEnumerated  = sizeof(METAHEADER); // in WMF enumeration, we don't get header
        MetafileSize     = GetMetaFileBitsEx(hWmf, 0, NULL);
        FirstViewportExt = TRUE;
        FirstViewportOrg = TRUE;
        IsFirstRecord    = TRUE;

        // The bad thing about this is that if the metafile is being recolored,
        // the default pen, brush, text color, and background colors have NOT
        // been recolored.  So let's hope they're not really used.
        HpenSave   = (HPEN)  ::SelectObject(hdc, GetStockObject(BLACK_PEN));
        HbrushSave = (HBRUSH)::SelectObject(hdc, GetStockObject(WHITE_BRUSH));

        if (!Globals::IsNt)
        {
            HpaletteSave    = (HPALETTE)GetCurrentObject(hdc, OBJ_PAL);
            HfontSave       = (HFONT)   GetCurrentObject(hdc, OBJ_FONT);
            HbitmapSave     = (HBITMAP) GetCurrentObject(hdc, OBJ_BITMAP);
            HregionSave     = (HRGN)    GetCurrentObject(hdc, OBJ_REGION);
        }
        else
        {
            HpaletteSave    = NULL;
            HfontSave       = NULL;
            HbitmapSave     = NULL;
            HregionSave     = NULL;
        }

        // Make sure a few default values are set in the hdc
        ::SetTextAlign(hdc, 0);
        ::SetTextJustification(hdc, 0, 0);
        ::SetTextColor(hdc, RGB(0,0,0));
        TextColor = RGB(0,0,0);
        ::SetBkColor(hdc, RGB(255,255,255));
        BkColor = RGB(255,255,255);
        ::SetROP2(hdc, R2_COPYPEN);

        DstViewportOrg.x  = dstRect->left;
        DstViewportOrg.y  = dstRect->top;
        DstViewportExt.cx = dstRect->right - DstViewportOrg.x;
        DstViewportExt.cy = dstRect->bottom - DstViewportOrg.y;
    }
}

WmfEnumState::~WmfEnumState()
{
    // Turn POSTSCRIPT_IGNORE back off if we need to.
    if (IsPostscriptPrinter() && IgnorePostscript)
    {
        WORD    wOn = FALSE;
        ::Escape(Hdc, POSTSCRIPT_IGNORE, sizeof(wOn), (LPCSTR)&wOn, NULL);
    }

    // According to Office GEL, SaveDC/RestoreDC doesn't always restore
    // the brush and the pen correctly, so we have to do that ourselves.
    ::SelectObject(Hdc, HbrushSave);
    ::SelectObject(Hdc, HpenSave);

    GpFree(AllocedRecord);

    if (IsMetafile())
    {
        // Account for unbalanced SaveDC/RestoreDC pairs and
        // restore to the saveDC state
        ::RestoreDC(Hdc, SaveDcCount - 1);
    }
    else
    {
        ::RestoreDC(Hdc, SaveDcVal);
    }
}

VOID
WmfEnumState::EndRecord(
    )
{
    // We rely on the number of bytes enumerated to determine if
    // this is the last record of the WMF.
    if ((MetafileSize - BytesEnumerated) < SIZEOF_METARECORDHEADER)
    {
        if (!Globals::IsNt)
        {
            // GDI won't delete objects that are still selected, so
            // select out all WMF objects before proceeding.
            ::SelectObject(Hdc, HpenSave);
            ::SelectObject(Hdc, HbrushSave);
            ::SelectObject(Hdc, HpaletteSave);
            ::SelectObject(Hdc, HfontSave);
            ::SelectObject(Hdc, HbitmapSave);
            ::SelectObject(Hdc, HregionSave);

            INT     i;
            HANDLE  handle;

            if (HandleTable != NULL)
            {
                for (i = 0; i < NumObjects; i++)
                {
                    if ((handle = HandleTable->objectHandle[i]) != NULL)
                    {
                        ::DeleteObject(handle);
                        HandleTable->objectHandle[i] = NULL;
                    }
                }
            }
        }
    }
}

BOOL
WmfEnumState::PlayRecord(
    )
{
    const METARECORD *  recordToPlay = ModifiedWmfRecord;

    // See if we've modified the record
    if (recordToPlay == NULL)
    {
        // We haven't.  See if we have a valid current record
        if (CurrentWmfRecord != NULL)
        {
            recordToPlay = CurrentWmfRecord;
        }
        else
        {
            // we don't so we have to create one
            if (!CreateCopyOfCurrentRecord())
            {
                return FALSE;
            }
            recordToPlay = ModifiedWmfRecord;
        }
    }
    return PlayMetaFileRecord(Hdc, HandleTable, (METARECORD *)recordToPlay, NumObjects);
}

INT
MfEnumState::GetModifiedDibSize(
    BITMAPINFOHEADER UNALIGNED * dibInfo,
    UINT                         numPalEntries,
    UINT                         dibBitsSize,
    UINT &                       usage
    )
{
    ASSERT(dibInfo->biSize >= sizeof(BITMAPINFOHEADER));

    INT     byteWidth;
    INT     bitCount = dibInfo->biBitCount;

    if ((usage == DIB_PAL_COLORS) &&
        ((bitCount > 8) || (dibInfo->biCompression == BI_BITFIELDS)))
    {
        usage = DIB_RGB_COLORS;
    }

    if ((Recolor != NULL) || (usage == DIB_PAL_COLORS))
    {
        INT     biSize = dibInfo->biSize;

        if (bitCount > 8)
        {
            if ((dibInfo->biCompression != BI_RGB) &&
                (dibInfo->biCompression != BI_BITFIELDS))
            {
                return 0;    // don't handle compressed images
            }

            ASSERT((bitCount == 16) || (bitCount == 24) || (bitCount == 32));

            INT posHeight = dibInfo->biHeight;
            if (posHeight < 0)
            {
                posHeight = -posHeight;
            }

            // We have to recolor the object, so we will convert it to a
            // 24 bit image and send it down.
            // Even if we have less then 256 pixels, it's not worth palettizing
            // anymore because the palette will be the size of the image anyway
            // make sure that the bitmap is width is aligned
            // PERF: We could create a GpBitmap from the bitmap and recolor the
            // GpBitmap
            dibBitsSize = posHeight * (((dibInfo->biWidth * 3) + 3) & ~3);
            numPalEntries = 0;
            biSize = sizeof(BITMAPINFOHEADER);
        }
        else if ((numPalEntries == 0) ||
                 (dibInfo->biCompression == BI_CMYK) ||
                 (dibInfo->biCompression == BI_CMYKRLE4) ||
                 (dibInfo->biCompression == BI_CMYKRLE8))
        {
            return 0;    // don't handle CMYK images
        }
        usage = DIB_RGB_COLORS;
        return biSize + (numPalEntries * sizeof(RGBQUAD)) + dibBitsSize;
    }

    return 0;       // no modifications needed
}

inline static INT
GetMaskShift(
    INT     maskValue
    )
{
    ASSERT (maskValue != 0);

    INT     shift = 0;

    while (((maskValue & 1) == 0) && (shift < 24))
    {
        shift++;
        maskValue >>= 1;
    }
    return shift;
}

inline static INT
GetNumMaskBits(
    INT     maskValue
    )
{
    ASSERT ((maskValue & 1) != 0);

    INT     numBits = 0;

    while ((maskValue & 1) != 0)
    {
        numBits++;
        maskValue >>= 1;
    }
    return numBits;
}

VOID
MfEnumState::Modify16BppDib(
    INT               width,
    INT               posHeight,
    BYTE *            srcPixels,
    DWORD UNALIGNED * bitFields,
    BYTE *            dstPixels,
    ColorAdjustType   adjustType
    )
{
    INT     rMask       = 0x00007C00;   // same as GDI default
    INT     gMask       = 0x000003E0;
    INT     bMask       = 0x0000001F;
    INT     rMaskShift  = 10;
    INT     gMaskShift  = 5;
    INT     bMaskShift  = 0;
    INT     rNumBits    = 5;
    INT     gNumBits    = 5;
    INT     bNumBits    = 5;
    INT     rRightShift = 2;
    INT     gRightShift = 2;
    INT     bRightShift = 2;

    if (bitFields != NULL)
    {
        rMask       = (INT)((WORD)(*bitFields++));
        gMask       = (INT)((WORD)(*bitFields++));
        bMask       = (INT)((WORD)(*bitFields));
        rMaskShift  = GetMaskShift(rMask);
        gMaskShift  = GetMaskShift(gMask);
        bMaskShift  = GetMaskShift(bMask);
        rNumBits    = GetNumMaskBits(rMask >> rMaskShift);
        gNumBits    = GetNumMaskBits(gMask >> gMaskShift);
        bNumBits    = GetNumMaskBits(bMask >> bMaskShift);
        rRightShift = (rNumBits << 1) - 8;
        gRightShift = (gNumBits << 1) - 8;
        bRightShift = (bNumBits << 1) - 8;
    }

    INT         palIndex = 0;
    INT         pixel;
    INT         r, g, b;
    COLORREF    color;
    INT         w, h;
    INT         srcByteWidth = ((width * 2) + 3) & (~3);
    INT         dstByteWidth = ((width * 3) + 3) & (~3);

    for (h = 0; h < posHeight; h++)
    {
        for (w = 0; w < width; w++)
        {
            pixel = (INT)(((INT16 *)srcPixels)[w]);

            r = (pixel & rMask) >> rMaskShift;
            r = (r | (r << rNumBits)) >> rRightShift;

            g = (pixel & gMask) >> gMaskShift;
            g = (g | (g << gNumBits)) >> gRightShift;

            b = (pixel & bMask) >> bMaskShift;
            b = (b | (b << bNumBits)) >> bRightShift;

            color = ModifyColor(RGB(r, g, b), adjustType);

            dstPixels[3*w + 2] = GetRValue(color);
            dstPixels[3*w + 1] = GetGValue(color);
            dstPixels[3*w]     = GetBValue(color);
        }
        srcPixels += srcByteWidth;
        dstPixels += dstByteWidth;
    }
}

inline static INT
Get24BppColorIndex(
    INT     maskValue
    )
{
    switch(GetMaskShift(maskValue))
    {
    default:
        WARNING(("Invalid BitFields Mask"));
        // FALLTHRU

    case 0:
        return 0;
    case 8:
        return 1;
    case 16:
        return 2;
    }
}

VOID
MfEnumState::Modify24BppDib(
    INT               width,
    INT               posHeight,
    BYTE *            srcPixels,
    DWORD UNALIGNED * bitFields,
    BYTE *            dstPixels,
    ColorAdjustType   adjustType
    )
{
    INT     rIndex = 2;
    INT     gIndex = 1;
    INT     bIndex = 0;

    if (bitFields != NULL)
    {
        INT     rMask = (INT)((*bitFields++));
        INT     gMask = (INT)((*bitFields++));
        INT     bMask = (INT)((*bitFields));

        rIndex = Get24BppColorIndex(rMask);
        gIndex = Get24BppColorIndex(gMask);
        bIndex = Get24BppColorIndex(bMask);
    }

    INT         palIndex = 0;
    INT         r, g, b;
    COLORREF    color;
    INT         w, h;
    INT         srcByteWidth = ((width * 3) + 3) & (~3);
    INT         dstByteWidth = ((width * 3) + 3) & (~3);
    BYTE *      srcRaster = srcPixels;

    for (h = 0; h < posHeight; h++)
    {
        srcPixels = srcRaster;
        for (w = 0; w < width; w++)
        {
            r = srcPixels[rIndex];
            g = srcPixels[gIndex];
            b = srcPixels[bIndex];
            srcPixels += 3;

            color = ModifyColor(RGB(r, g, b), adjustType);

            dstPixels[3*w + 2] = GetRValue(color);
            dstPixels[3*w + 1] = GetGValue(color);
            dstPixels[3*w]     = GetBValue(color);
        }
        srcRaster += srcByteWidth;
        dstPixels += dstByteWidth;
    }
}

inline static INT
Get32BppColorIndex(
    INT     maskValue
    )
{
    switch(GetMaskShift(maskValue))
    {
    default:
        WARNING(("Invalid BitFields Mask"));
        // FALLTHRU

    case 0:
        return 0;
    case 8:
        return 1;
    case 16:
        return 2;
    case 24:
        return 3;
    }
}

VOID
MfEnumState::Modify32BppDib(
    INT               width,
    INT               posHeight,
    BYTE *            srcPixels,
    DWORD UNALIGNED * bitFields,
    BYTE *            dstPixels,
    ColorAdjustType   adjustType
    )
{
    INT     rIndex = 2;
    INT     gIndex = 1;
    INT     bIndex = 0;

    if (bitFields != NULL)
    {
        INT     rMask = (INT)((*bitFields++));
        INT     gMask = (INT)((*bitFields++));
        INT     bMask = (INT)((*bitFields));

        rIndex = Get32BppColorIndex(rMask);
        gIndex = Get32BppColorIndex(gMask);
        bIndex = Get32BppColorIndex(bMask);
    }

    INT         palIndex = 0;
    INT         r, g, b;
    COLORREF    color;
    INT         w, h;
    INT         dstByteWidth = ((width * 3) + 3) & (~3);

    for (h = 0; h < posHeight; h++)
    {
        for (w = 0; w < width; w++)
        {
            r = srcPixels[rIndex];
            g = srcPixels[gIndex];
            b = srcPixels[bIndex];
            srcPixels += 4;

            color = ModifyColor(RGB(r, g, b), adjustType);

            dstPixels[3*w + 2] = GetRValue(color);
            dstPixels[3*w + 1] = GetGValue(color);
            dstPixels[3*w]     = GetBValue(color);
        }
        dstPixels += dstByteWidth;
    }
}

VOID
MfEnumState::ModifyDib(
    UINT                          usage,
    BITMAPINFOHEADER UNALIGNED *  srcDibInfo,
    BYTE *                        srcBits,    // if NULL, it's a packed DIB
    BITMAPINFOHEADER UNALIGNED *  dstDibInfo,
    UINT                          numPalEntries,
    UINT                          srcDibBitsSize,
    ColorAdjustType               adjustType
    )
{
    INT      srcBitCount = srcDibInfo->biBitCount;
    BYTE *   srcPixels   = srcBits;
    COLORREF color;

    if (srcBitCount <= 8)
    {
        GpMemcpy(dstDibInfo, srcDibInfo, srcDibInfo->biSize);

        RGBQUAD UNALIGNED * srcRgb = GetDibColorTable(srcDibInfo);
        RGBQUAD UNALIGNED * dstRgb = GetDibColorTable(dstDibInfo);

        dstDibInfo->biClrUsed = numPalEntries;

        if ((usage == DIB_PAL_COLORS) &&
            (dstDibInfo->biCompression != BI_BITFIELDS))
        {
            WORD *      srcPal = (WORD *)srcRgb;

            if (srcPixels == NULL)
            {
                srcPixels = (BYTE *)(srcPal + ((numPalEntries + 1) & ~1)); // align
            }

            // Copy the Dib pixel data
            GpMemcpy(dstRgb + numPalEntries, srcPixels, srcDibBitsSize);

            // Modify the palette colors
            while (numPalEntries--)
            {
                color = ModifyColor(*srcPal++ | 0x01000000, adjustType);
                dstRgb->rgbRed      = GetRValue(color);
                dstRgb->rgbGreen    = GetGValue(color);
                dstRgb->rgbBlue     = GetBValue(color);
                dstRgb->rgbReserved = 0;
                dstRgb++;
            }
        }
        else
        {
            if (srcPixels == NULL)
            {
                srcPixels = (BYTE *)(srcRgb + numPalEntries);
            }

            // Copy the Dib pixel data
            GpMemcpy(dstRgb + numPalEntries, srcPixels, srcDibBitsSize);

            // Modify the palette colors
            while (numPalEntries--)
            {
                color = ModifyColor(RGB(srcRgb->rgbRed, srcRgb->rgbGreen, srcRgb->rgbBlue), adjustType);
                dstRgb->rgbRed      = GetRValue(color);
                dstRgb->rgbGreen    = GetGValue(color);
                dstRgb->rgbBlue     = GetBValue(color);
                dstRgb->rgbReserved = 0;
                dstRgb++;
                srcRgb++;
            }
        }
    }
    else    // Recolor the bitmap. There is no need to palettize the image since
            // the palette will be as big as the image
    {
        INT posHeight = srcDibInfo->biHeight;

        if (posHeight < 0)
        {
            posHeight = -posHeight;
        }

        ASSERT((srcDibInfo->biCompression == BI_RGB) ||
               (srcDibInfo->biCompression == BI_BITFIELDS));

        GpMemset(dstDibInfo, 0, sizeof(BITMAPINFOHEADER));

        dstDibInfo->biSize     = sizeof(BITMAPINFOHEADER);
        dstDibInfo->biWidth    = srcDibInfo->biWidth;
        dstDibInfo->biHeight   = srcDibInfo->biHeight;
        dstDibInfo->biPlanes   = 1;
        dstDibInfo->biBitCount = 24;

        BYTE *                dstPixels = GetDibBits(dstDibInfo,0,0);
        DWORD UNALIGNED *     bitFields = NULL;

        if (srcPixels == NULL)
        {
            srcPixels = (BYTE *)GetDibBits(srcDibInfo, numPalEntries, usage);
        }

        dstDibInfo->biClrUsed = 0;
        dstDibInfo->biClrImportant = 0;

        if (numPalEntries == 3)
        {
            ASSERT((srcBitCount == 16) || (srcBitCount == 32));
            bitFields = (DWORD*) GetDibColorTable(srcDibInfo);
            if ((bitFields[0] == 0) ||
                (bitFields[1] == 0) ||
                (bitFields[2] == 0))
            {
                bitFields = NULL;
            }
        }
        else if (srcDibInfo->biSize >= sizeof(BITMAPV4HEADER))
        {
            BITMAPV4HEADER *    srcHeaderV4 = (BITMAPV4HEADER *)srcDibInfo;

            if ((srcHeaderV4->bV4RedMask != 0) &&
                (srcHeaderV4->bV4GreenMask != 0) &&
                (srcHeaderV4->bV4BlueMask != 0))
            {
                bitFields = &(srcHeaderV4->bV4RedMask);
            }
        }

        switch (srcBitCount)
        {
        case 16:
            Modify16BppDib(srcDibInfo->biWidth, posHeight, srcPixels,
                           bitFields, dstPixels, adjustType);
            break;
        case 24:
            Modify24BppDib(srcDibInfo->biWidth, posHeight, srcPixels,
                           bitFields, dstPixels, adjustType);
            break;
        case 32:
            Modify32BppDib(srcDibInfo->biWidth, posHeight, srcPixels,
                           bitFields, dstPixels, adjustType);
            break;
        }
    }
}

VOID
WmfEnumState::DibCreatePatternBrush(
    )
{
    INT                           style      = (INT)((INT16)(((WORD *)RecordData)[0]));
    UINT                          usage      = (UINT)((UINT16)(((WORD *)RecordData)[1]));
    BITMAPINFOHEADER UNALIGNED *  srcDibInfo = (BITMAPINFOHEADER UNALIGNED *)(&(((WORD *)RecordData)[2]));
    UINT                          numPalEntries;

    // Pattern brush should mean that it is a monochrome DIB
    if (style == BS_PATTERN)
    {
        if (Recolor != NULL)
        {
            DWORD UNALIGNED *   rgb = (DWORD UNALIGNED *)GetDibColorTable(srcDibInfo);

            // See if it is a monochrome pattern brush.  If it is, then
            // the text color will be used for 0 bits and the background
            // color will be used for 1 bits.  These colors are already
            // modified by their respective records, so there is no need
            // to do anything here.

            // If it is not a monochrome pattern brush, just create a
            // solid black brush.
            if ((usage != DIB_RGB_COLORS) ||
                (srcDibInfo->biSize < sizeof(BITMAPINFOHEADER)) ||
                !GetDibNumPalEntries(TRUE,
                                     srcDibInfo->biSize,
                                     srcDibInfo->biBitCount,
                                     srcDibInfo->biCompression,
                                     srcDibInfo->biClrUsed,
                                     &numPalEntries) ||
                (numPalEntries != 2) ||
                (srcDibInfo->biBitCount != 1) || (srcDibInfo->biPlanes != 1) ||
                (rgb[0] != 0x00000000) || (rgb[1] != 0x00FFFFFF))
            {
                // This shouldn't happen, at least not if recorded on NT
                WARNING(("Non-monochrome pattern brush"));
                MakeSolidBlackBrush();
            }
        }
    }
    else
    {
        UINT    dibBitsSize;

        if ((srcDibInfo->biSize >= sizeof(BITMAPINFOHEADER)) &&
            GetDibNumPalEntries(TRUE,
                                srcDibInfo->biSize,
                                srcDibInfo->biBitCount,
                                srcDibInfo->biCompression,
                                srcDibInfo->biClrUsed,
                                &numPalEntries) &&
            ((dibBitsSize = GetDibBitsSize(srcDibInfo)) > 0))
        {
            UINT    oldUsage = usage;
            INT     dstDibSize = GetModifiedDibSize(srcDibInfo, numPalEntries, dibBitsSize, usage);

            if (dstDibSize > 0)
            {
                INT     size = SIZEOF_METARECORDHEADER + (2 * sizeof(WORD)) + dstDibSize;

                CreateRecordToModify(size);
                ModifiedWmfRecord->rdSize      = size / 2;
                ModifiedWmfRecord->rdFunction  = META_DIBCREATEPATTERNBRUSH;
                ModifiedWmfRecord->rdParm[0]   = BS_DIBPATTERN;
                ModifiedWmfRecord->rdParm[1]   = DIB_RGB_COLORS;
                ModifyDib(oldUsage, srcDibInfo, NULL,
                          (BITMAPINFOHEADER UNALIGNED *)(&(ModifiedWmfRecord->rdParm[2])),
                          numPalEntries, dibBitsSize, ColorAdjustTypeBrush);
            }
        }
    }

    this->PlayRecord();
}

// This record is obsolete, because it uses a compatible bitmap
// instead of a DIB.  It has a BITMAP16 structure that is
// used to call CreateBitmapIndirect.  That HBITMAP is, in turn,
// used to call CreatePatternBrush.  If this record is present,
// it is likely that the bitmap is monochrome, in which case
// the TextColor and the BkColor will be used, and these colors
// already get modified by their respective records.
VOID
WmfEnumState::CreatePatternBrush(
    )
{
    WARNING(("Obsolete META_CREATEPATTERNBRUSH record"));

    BITMAP16 UNALIGNED *  bitmap = (BITMAP16 UNALIGNED *)RecordData;

    if (bitmap->bmBitsPixel != 1)
    {
        WARNING(("Non-monochrome pattern brush"));
        MakeSolidBlackBrush();
    }

    this->PlayRecord();
}

VOID
WmfEnumState::CreatePenIndirect(
    )
{
    LOGPEN16 UNALIGNED * logPen = (LOGPEN16 UNALIGNED *)RecordData;

    switch (logPen->lopnStyle)
    {
    default:
        WARNING(("Unrecognized Pen Style"));
    case PS_NULL:
        break;      // leave the pen alone

    case PS_SOLID:
    case PS_INSIDEFRAME:
    case PS_DASH:
    case PS_DOT:
    case PS_DASHDOT:
    case PS_DASHDOTDOT:
        ModifyRecordColor(3, ColorAdjustTypePen);
        break;
    }

    this->PlayRecord();
}

VOID
WmfEnumState::CreateBrushIndirect(
    )
{
    LOGBRUSH16 UNALIGNED * logBrush = (LOGBRUSH16 UNALIGNED *)RecordData;

    switch (logBrush->lbStyle)
    {
    case BS_SOLID:
    case BS_HATCHED:
        {
            ModifyRecordColor(1, ColorAdjustTypeBrush);
            if (ModifiedWmfRecord != NULL)
            {
                logBrush = (LOGBRUSH16 UNALIGNED *)(ModifiedWmfRecord->rdParm);
            }
            // See if we need to halftone the color.  We do if it is a solid
            // color, and we have a halftone palette, and the color is not
            // an exact match in the palette.

            COLORREF    color;

            if (IsHalftonePalette && (logBrush->lbStyle == BS_SOLID) &&
                (((color = logBrush->lbColor) & 0x02000000) == 0))
            {
                // create a halftone brush, instead of a solid brush

                INT     size = SIZEOF_METARECORDHEADER + (2 * sizeof(WORD)) +
                               sizeof(BITMAPINFOHEADER) + // DIB 8 bpp header
                               (8 * sizeof(RGBQUAD)) +    // DIB 8 colors
                               (8 * 8);                   // DIB 8x8 pixels

                ModifiedRecordSize = 0; // in case we already modified the record
                CreateRecordToModify(size);
                ModifiedWmfRecord->rdSize      = size / 2;
                ModifiedWmfRecord->rdFunction  = META_DIBCREATEPATTERNBRUSH;
                ModifiedWmfRecord->rdParm[0]   = BS_DIBPATTERN;
                ModifiedWmfRecord->rdParm[1]   = DIB_RGB_COLORS;

                HalftoneColorRef_216(color, &(ModifiedWmfRecord->rdParm[2]));
            }
        }
        break;

    case BS_HOLLOW:
        break;  // leave the record alone

    default:
        // Looking at the NT source code, there shouldn't be any
        // other brush styles for an indirect brush.
        WARNING(("Brush Style Not Valid"));
        MakeSolidBlackBrush();
        break;
    }

    this->PlayRecord();
}

// Also handles StretchBlt.
// These records are obsolete (when there is a source bitmap) because they
// have a compatible bitmap instead of a DIB.  For that reason, we don't
// recolor them.
VOID
WmfEnumState::BitBlt(
    )
{
    DWORD   rop = *((UNALIGNED DWORD *)RecordData);

    // If No-Op ROP, do nothing; just return
    if ((rop & 0xFFFF0000) == (GDIP_NOOP_ROP3 & 0xFFFF0000))
    {
        return;
    }

    if (!IsMetafile())
    {
        if (IsSourceInRop3(rop))
        {
            WARNING(("Obsolete META_BITBLT/META_STRETCHBLT record"));

            if ((rop != SRCCOPY) && SrcCopyOnly &&
                CreateCopyOfCurrentRecord())
            {
                *((DWORD UNALIGNED *)ModifiedWmfRecord->rdParm) = SRCCOPY;
            }
        }
        else
        {
            if ((rop != PATCOPY) && SrcCopyOnly &&
                CreateCopyOfCurrentRecord())
            {
                *((DWORD UNALIGNED *)ModifiedWmfRecord->rdParm) = PATCOPY;
            }
        }
    }

    this->PlayRecord();
}

VOID
WmfEnumState::Escape(
    )
{
    INT     escapeCode = (INT)((INT16)(((WORD *)RecordData)[0]));

    if (!IsPostscript())
    {
        if (SkipEscape(escapeCode))
        {
            return;
        }

        // Skip Office Art data when playing into another metafile
        if (IsMetafile() &&
            IsOfficeArtData(GetCurrentRecordSize(), (WORD *)RecordData))
        {
            return;
        }
    }
    else // it is postscript
    {
        if (escapeCode == MFCOMMENT)
        {
            if (GetWmfComment((WORD *)RecordData, msosignature, msocommentBeginSrcCopy))
            {
                SrcCopyOnly = TRUE;
                return;
            }
            if (GetWmfComment((WORD *)RecordData, msosignature, msocommentEndSrcCopy))
            {
                SrcCopyOnly = FALSE;
                return;
            }
        }

        if (escapeCode == POSTSCRIPT_DATA)
        {
            // Bug #98743 (Windows Bugs) Gdiplus must overcome GDI limitation
            // with POSTSCRIPT_INJECTION.  Comments from Rammanohar Arumugam:
            //
            // Being in xx-centric mode means POSTSCRIPT_DATA won't work. I
            // take that to mean that PlayMetaFileRecord only works in
            // compatibility mode.
            //
            // GdiPlus will check for the printer mode. In GDI-centric and
            // Postscript-centric mode, it will not do PlayMetaFileRecord for
            // any record that has POSTSCRIPT_DATA. Instead, it will output
            // the postscript data through a PASSTHRU (for GDI-centric mode)
            // or a POSTSCRIPT_PASSTHRU (for Postscript-Centric mode).
            //
            // You can find out the mode by querying the escape support.
            // 1. Query for POSTSCRIPT_INJECTION support. If not supported,
            // it's compat mode. If supported, find out the mode by doing step 2/3
            // 2. Query for PASSTHROUGH support. If supported, it's GDI-centric.
            // 3. Query for POSTSCRIPT_PASSTHROUGH support. If supported, it's
            // PS-centric.

            if (Globals::IsNt)
            {
                if (!SoftekFilter)
                {
                    // Determine presence of Softek Filter EPS, if so, then
                    // we apply workaround patches.

                    WORD size = *((WORD*)RecordData);
                    LPSTR escape = (LPSTR)(&RecordData[6]);
                    const LPSTR softekString = "%MSEPS Preamble [Softek";

                    INT softekLen = strlen(softekString);

                    if (size >= softekLen)
                    {
                        SoftekFilter = !GpMemcmp(softekString, escape, softekLen);
                    }
                }

                DWORD EscapeValue = POSTSCRIPT_IDENTIFY;

                if (::ExtEscape(Hdc,
                              QUERYESCSUPPORT,
                              sizeof(DWORD),
                              (LPSTR)&EscapeValue,
                              0,
                              NULL) <= 0)
                {
                    // POSTSCRIPT_IDENTITY is not supported if the mode has
                    // been set because it can only be set once.

                    EscapeValue = POSTSCRIPT_PASSTHROUGH;
                    if (::ExtEscape(Hdc,
                                  QUERYESCSUPPORT,
                                  sizeof(DWORD),
                                  (LPSTR)&EscapeValue,
                                  0,
                                  NULL) <= 0)
                    {
                        // GDI-centric mode
                        if (CreateCopyOfCurrentRecord())
                        {
                            *((WORD *)ModifiedWmfRecord->rdParm) = PASSTHROUGH;
                        }
                        GdiCentricMode = TRUE;
                    }
                    else
                    {
                        // PS-centric mode
                        if (CreateCopyOfCurrentRecord())
                        {
                            *((WORD *)ModifiedWmfRecord->rdParm) = POSTSCRIPT_PASSTHROUGH;
                        }
                    }

                    this->PlayRecord();
                    return;
                }
                else
                {
                    // compatibility mode, uses POSTSCRIPT_DATA
                }
            }
            else
            {
                // Win98 doesn't distinguish between GDI & compatibility mode
                if (CreateCopyOfCurrentRecord())
                {
                    *((WORD *)ModifiedWmfRecord->rdParm) = PASSTHROUGH;
                }
            }
        }
    }

    // Keep track of the POSTSCRIPT_IGNORE state.  If it is still on at
    // the of the metafile, then turn it OFF
    if (escapeCode == POSTSCRIPT_IGNORE && IsPostscript())
    {
        IgnorePostscript = ((WORD *)RecordData)[2] ? TRUE : FALSE;
    }
    this->PlayRecord();
}

VOID
WmfEnumState::Rectangle(
    )
{
    if (FsmState == MfFsmSetROP)
    {
        // There is a bug using PlayMetaFileRecord on Win2K for this
        // type of escape, we must explicitly call ExtEscape.  See bug
        // #98743.

        WORD* rdParm = (WORD*)&(RecordData[0]);
        CHAR postscriptEscape[512];

        RECT rect;
        rect.left = (SHORT)rdParm[3];
        rect.top = (SHORT)rdParm[2];
        rect.right = (SHORT)rdParm[1];
        rect.bottom = (SHORT)rdParm[0];

        if (LPtoDP(Hdc, (POINT*)&rect, 2))
        {
            // Some injected postscript, strangely enough contains the equivalent
            // of a stroke which is erroroneously executed on the current path.  In
            // one case, bug #281856 it results in a border about the object.  To
            // get around this, we output a 'N' which is newpath operator if it's
            // defined (which should be always.)  This, incidently, is done when
            // calling GDI Rectangle() succeeds, it outputs "N x y w h B", so we
            // are doing the equivalent here.

            GpRect  clipRect;
            Context->VisibleClip.GetBounds(&clipRect);

            wsprintfA(&postscriptEscape[2],
                      "\r\n%d %d %d %d CB\r\n"
                      "%s"
                      "%d %d %d %d B\r\n",
                      clipRect.Width,
                      clipRect.Height,
                      clipRect.X,
                      clipRect.Y,
                      Globals::IsNt ? "newpath\r\n" : "",
                      rect.right - rect.left,
                      rect.bottom - rect.top,
                      rect.left,
                      rect.top);
            ASSERT(strlen(&postscriptEscape[2]) < 512);
            *(WORD*)(&postscriptEscape[0]) = (WORD)(strlen(&postscriptEscape[2]));

            ::ExtEscape(Hdc,
                        PASSTHROUGH,
                        *(WORD*)(&postscriptEscape[0]) + sizeof(WORD) + 1,
                        (CHAR*)&postscriptEscape[0],
                        0,
                        NULL);
            return;
        }
    }

    this->PlayRecord();
}

VOID
WmfEnumState::RestoreHdc(
    )
{
    INT     relativeCount = (INT)((INT16)(((WORD *)RecordData)[0]));

    if (SaveDcCount < 0)
    {
        if (relativeCount >= SaveDcCount)
        {
            if (relativeCount >= 0)
            {
                // Modify the record
                CreateCopyOfCurrentRecord();    // guaranteed to succeed
                relativeCount = -1;
                ModifiedWmfRecord->rdParm[0] = (INT16)(-1);
            }
        }
        else
        {
            // Modify the record
            CreateCopyOfCurrentRecord();    // guaranteed to succeed
            relativeCount = SaveDcCount;
            ModifiedWmfRecord->rdParm[0] = (INT16)(relativeCount);
        }

        SaveDcCount -= relativeCount;
        this->PlayRecord();
    }
    else
    {
        WARNING(("RestoreDC not matched to a SaveDC"));
    }
}

// The rop for this command is always SRCCOPY
VOID
WmfEnumState::SetDIBitsToDevice(
    )
{
    // !!!

    // Office doesn't do anything with this record.  For now, I don't think
    // I will either.  It's a tough one to deal with for a couple reasons:
    // 1st -    The xDest and yDest values are in world units, but the
    //          width and height values are in device units
    //          (unlike StretchDIBits).
    // 2nd -    The amount of bits data present may be different than
    //          what is in the DIB header (based on the cScanLines param).
    //          This makes it harder to deal with as a packed DIB.

    this->PlayRecord();
}

VOID
MfEnumState::SelectPalette(
    INT     objectIndex
    )
{
    // For EMF the check really should be > 0
    if ((objectIndex >= 0) && (objectIndex < NumObjects) && (HandleTable != NULL))
    {
        HGDIOBJ    hPal = HandleTable->objectHandle[objectIndex];
        if ((hPal != NULL) && (GetObjectTypeInternal(hPal) == OBJ_PAL))
        {
            CurrentPalette = (HPALETTE)hPal;
            return;
        }
    }
    WARNING(("SelectPalette Failure"));
}

inline static VOID
Point32FromPoint16(
    POINTL *    dstPoints,
    POINTS UNALIGNED * srcPoints,
    UINT        numPoints
    )
{
    for (UINT i = 0; i < numPoints; i++, dstPoints++, srcPoints++)
    {
        dstPoints->x = (INT)((INT16)(srcPoints->x));
        dstPoints->y = (INT)((INT16)(srcPoints->y));
    }
}

// Apparently there is a bug on Win9x with PolyPolygons, so we
// parse the record ourselves.
VOID
WmfEnumState::PolyPolygon(
    )
{
    UINT        numPolygons = ((WORD *)RecordData)[0];
    UINT        numPoints   = 0;
    UINT        i;

    for (i = 0; i < numPolygons; i++)
    {
        numPoints += ((LPWORD)&((WORD *)RecordData)[1])[i];
    }

    INT *       polyCounts;
    POINTL *    points;
    INT         size = (numPolygons * sizeof(INT)) +
                       (numPoints * sizeof(POINTL));

    if (CreateRecordToModify(size))
    {
        polyCounts = (INT *)ModifiedRecord;
        points = (POINTL *)(polyCounts + numPolygons);

        for (i = 0; i < numPolygons; i++)
        {
            polyCounts[i] = (INT)(UINT)((LPWORD)&((WORD *)RecordData)[1])[i];
        }
        Point32FromPoint16(points,
                           (POINTS UNALIGNED *)(((WORD *)RecordData) + numPolygons + 1),
                           numPoints);
        ::PolyPolygon(Hdc, (POINT *)points, polyCounts, numPolygons);
        return;
    }

    this->PlayRecord();
}

#ifdef NEED_TO_KNOW_IF_BITMAP
static INT
GetBppFromMemDC(
    HDC     hMemDC
    )
{
    HBITMAP     hBitmap = (HBITMAP)::GetCurrentObject(hMemDC, OBJ_BITMAP);
    BITMAP      bitmap;

    if ((hBitmap == NULL) ||
        (::GetObjectA(hBitmap, sizeof(bitmap), &bitmap) == 0))
    {
        WARNING(("Couldn't get Bitmap object"));
        return 0;   // error
    }

    if (bitmap.bmPlanes <= 0)
    {
        WARNING(("Bitmap with no planes"));
        bitmap.bmPlanes = 1;
    }

    INT     bpp = bitmap.bmPlanes * bitmap.bmBitsPixel;

    if (bpp > 32)
    {
        WARNING(("Bitmap with too many bits"));
        bpp = 32;
    }

    return bpp;
}
#endif

#define GDI_INTERPOLATION_MAX   (1 << 23)

VOID
MfEnumState::OutputDIB(
    HDC                          hdc,
    const RECTL *                bounds,
    INT                          dstX,
    INT                          dstY,
    INT                          dstWidth,
    INT                          dstHeight,
    INT                          srcX,
    INT                          srcY,
    INT                          srcWidth,
    INT                          srcHeight,
    BITMAPINFOHEADER UNALIGNED * dibInfo,
    BYTE *                       bits,   // if NULL, this is a packed DIB
    UINT                         usage,
    DWORD                        rop,
    BOOL                         isWmfDib
    )
{
    BITMAPINFO       dibHeaderBuffer[1]; // To be sure it's aligned for 64Bits

    BOOL             restoreColors = FALSE;
    COLORREF         oldBkColor;
    COLORREF         oldTextColor;

    ASSERT(dibInfo->biSize >= sizeof(BITMAPINFOHEADER));

    if (bits == NULL)
    {
        UINT        numPalEntries;

        if (GetDibNumPalEntries(isWmfDib,
                                dibInfo->biSize,
                                dibInfo->biBitCount,
                                dibInfo->biCompression,
                                dibInfo->biClrUsed,
                                &numPalEntries))
        {
            bits = GetDibBits(dibInfo, numPalEntries, usage);
        }
        else
        {
            WARNING(("GetDibNumPalEntries failure"));
            return;
        }
    }


    INT     posDstWidth = dstWidth;

    if (posDstWidth < 0)
    {
        posDstWidth = -posDstWidth;
    }

    INT     posDstHeight = dstHeight;

    if (posDstHeight < 0)
    {
        posDstHeight = -posDstHeight;
    }

    INT             stretchBltMode = HALFTONE;
    GpBitmap *      destBitmap     = NULL;
    POINT           destPoints[3];
    BitmapData      bmpData;
    BitmapData *    bmpDataPtr = NULL;
    HBITMAP         hBitmap = NULL;
    BYTE *          bmpBits = NULL;
    BITMAPINFO *    dibBmpInfo = NULL;
    BOOL            deleteDIBSection = FALSE;

    // Don't use GDI+ stretching for a mask
    // Make this the first thing so that we are sure that they are set
    if ((dibInfo->biBitCount == 1) && (rop != SRCCOPY))
    {
        oldBkColor = ::SetBkColor(hdc, BkColor);
        oldTextColor = ::SetTextColor(hdc, TextColor);
        restoreColors = TRUE;
        goto DoGdiStretch;
    }

    // On Win9x we need to create an play a comment record so that the transform
    // gets invalidated and recalculated
    if (!Globals::IsNt && !IsMetafile())
    {
        CreateAndPlayCommentRecord();
    }

    destPoints[0].x = dstX;
    destPoints[0].y = dstY;
    destPoints[1].x = dstX + posDstWidth;
    destPoints[1].y = dstY;
    destPoints[2].x = dstX;
    destPoints[2].y = dstY + posDstHeight;

    if (!::LPtoDP(hdc, destPoints, 3))
    {
        goto DoGdiStretch;
    }

    posDstWidth  = ::GetIntDistance(destPoints[0], destPoints[1]);
    posDstHeight = ::GetIntDistance(destPoints[0], destPoints[2]);

    if ((posDstWidth == 0) || (posDstHeight == 0))
    {
        return;
    }

    INT     posSrcWidth;
    INT     srcWidthSign;

    posSrcWidth  = srcWidth;
    srcWidthSign = 1;

    if (posSrcWidth < 0)
    {
        posSrcWidth  = -posSrcWidth;
        srcWidthSign = -1;
    }

    INT     posSrcHeight;
    INT     srcHeightSign;

    posSrcHeight  = srcHeight;
    srcHeightSign = 1;

    if (posSrcHeight < 0)
    {
        posSrcHeight  = -posSrcHeight;
        srcHeightSign = -1;
    }

    INT     posSrcDibWidth;

    posSrcDibWidth = dibInfo->biWidth;

    if (posSrcDibWidth <= 0)
    {
        WARNING(("Bad biWidth value"));
        return; // negative source dib width not allowed
    }

    INT     posSrcDibHeight;

    posSrcDibHeight = dibInfo->biHeight;

    if (posSrcDibHeight < 0)
    {
        posSrcDibHeight = -posSrcDibHeight;
    }

    // We can have a negative source Width or height
    // we need to verify that the two corners of the srcRect lie in the
    // bitmap bounds
    if (srcX < 0)
    {
        srcX = 0;
        WARNING(("srcX < 0"));
    }

    if (srcX > posSrcDibWidth)
    {
        WARNING(("Bad srcWidth or srcX value"));
        srcX = posSrcDibWidth;
    }

    if (srcY < 0)
    {
        srcY = 0;
        WARNING(("srcY < 0"));
    }

    if (srcY > posSrcDibHeight)
    {
        WARNING(("Bad srcWidth or srcX value"));
        srcY = posSrcDibHeight;
    }

    INT srcRight;
    srcRight     = srcX + srcWidth;
    if (srcRight < 0)
    {
        WARNING(("Bad srcWidth or srcX value"));
        srcWidth = -srcX;
    }

    if(srcRight > posSrcDibWidth)
    {
        WARNING(("Bad srcWidth or srcX value"));
        srcWidth = posSrcDibWidth - srcX;
    }

    INT srcBottom;
    srcBottom = srcY + srcHeight;
    if (srcBottom < 0)
    {
        WARNING(("Bad srcWidth or srcX value"));
        srcHeight = -srcY;
    }

    if (srcBottom > posSrcDibHeight)
    {
        WARNING(("Bad srcWidth or srcX value"));
        srcHeight = posSrcDibHeight - srcY;
    }
    // This also catches the case where
    // (posSrcDibWidth == 0) || (posSrcDibHeight == 0)
    if ((posSrcWidth <= 0) || (posSrcHeight <= 0))
    {
        return;
    }

    // If we are drawing into an 8Bpp surface and we have a different ROP then
    // srcCopy.
    if (Is8Bpp && rop != SRCCOPY)
    {
        BOOL         freeDibInfo    = FALSE;
        UINT         size;
        BITMAPINFO * alignedDibInfo = NULL;
        if (GetDibNumPalEntries(TRUE,
                                dibInfo->biSize,
                                dibInfo->biBitCount,
                                dibInfo->biCompression,
                                dibInfo->biClrUsed,
                                &size))
        {
            if (IsDwordAligned(dibInfo))
            {
                alignedDibInfo = (BITMAPINFO*) dibInfo;
            }
            else
            {
                // Mutliply the number of entries by the size of each entry
                size *= ((usage==DIB_RGB_COLORS)?sizeof(RGBQUAD):sizeof(WORD));
                // WMF's can't use System Palette
                alignedDibInfo = (BITMAPINFO*) GpMalloc(dibInfo->biSize + size);
                if (alignedDibInfo != NULL)
                {
                    memcpy((void*)&alignedDibInfo, dibInfo, dibInfo->biSize + size);
                    freeDibInfo = TRUE;
                }
            }
            if (alignedDibInfo != NULL)
            {
                if (GpBitmap::DrawAndHalftoneForStretchBlt(hdc, alignedDibInfo, bits, srcX, srcY,
                                                           posSrcWidth, posSrcHeight,
                                                           posDstWidth, posDstHeight,
                                                           &dibBmpInfo, &bmpBits, &hBitmap,
                                                           Interpolation) == Ok)
                {
                    deleteDIBSection = TRUE;
                    srcX = 0;
                    srcY = 0;
                    srcWidth = posDstWidth;
                    srcHeight = posDstHeight;
                    dibInfo = (BITMAPINFOHEADER*) dibBmpInfo;
                    bits = bmpBits;
                    if (freeDibInfo)
                    {
                        GpFree(alignedDibInfo);
                    }
                    goto DoGdiStretch;
                }
                if (freeDibInfo)
                {
                    GpFree(alignedDibInfo);
                }
            }
        }
    }

    // if not stretching, let GDI do the blt
    if ((posSrcWidth == posDstWidth) && (posSrcHeight == posDstHeight))
    {
        goto DoGdiStretch;
    }

    InterpolationMode interpolationMode;

    interpolationMode = Interpolation;

    // if not going to the screen or to a bitmap, use GDI to do the stretch
    // otherwise, use GDI+ to do the stretch (but let GDI do the blt)

    // if going to printer on Win98 and it is RLE8 compressed bitmap, then
    // always decode and blit from GDI+.  The reason is that print drivers
    // commonly don't support RLEx encoding and punt to GDI.  In this
    // context it creates a compatible printer dc and bitmap and then does a
    // StretchBlt, but it only does this at 1bpp, the result is black and white.

    if ((IsPrinter() && !Globals::IsNt &&
         dibInfo->biCompression == BI_RLE8) ||
        ((IsScreen() || IsBitmap()) &&
        (interpolationMode != InterpolationModeNearestNeighbor) &&
        (posSrcWidth > 1) && (posSrcHeight > 1) &&
        ((posDstWidth * posDstHeight) < GDI_INTERPOLATION_MAX)))
    {
        GpStatus status = GenericError;

        destBitmap = new GpBitmap(posDstWidth, posDstHeight, PIXFMT_24BPP_RGB);

        if (destBitmap != NULL)
        {
            if (destBitmap->IsValid())
            {
                BITMAPINFO * alignedDibInfo = NULL;
                UINT         size;
                BOOL         freeDibInfo = FALSE;
                if (GetDibNumPalEntries(TRUE,
                                        dibInfo->biSize,
                                        dibInfo->biBitCount,
                                        dibInfo->biCompression,
                                        dibInfo->biClrUsed,
                                        &size))
                {
                    if (IsDwordAligned(dibInfo))
                    {
                        alignedDibInfo = (BITMAPINFO*) dibInfo;
                    }
                    else
                    {
                        // Mutliply the number of entries by the size of each entry
                        size *= ((usage==DIB_RGB_COLORS)?sizeof(RGBQUAD):sizeof(WORD));
                        // WMF's can't use System Palette
                        alignedDibInfo = (BITMAPINFO*) GpMalloc(dibInfo->biSize + size);
                        if (alignedDibInfo != NULL)
                        {
                            memcpy((void*)&alignedDibInfo, dibInfo, dibInfo->biSize + size);
                            freeDibInfo = TRUE;
                        }
                    }
                    if (alignedDibInfo != NULL)
                    {
                        GpBitmap *  srcBitmap = new GpBitmap(alignedDibInfo,
                                                             bits, FALSE);
                        if (srcBitmap != NULL)
                        {
                            if (srcBitmap->IsValid())
                            {
                                GpGraphics *    destGraphics = destBitmap->GetGraphicsContext();

                                if (destGraphics != NULL)
                                {
                                    if (destGraphics->IsValid())
                                    {
                                        // we have to lock the graphics so the driver doesn't assert
                                        GpLock  lockGraphics(destGraphics->GetObjectLock());

                                        ASSERT(lockGraphics.IsValid());

                                        GpRectF     dstRect(0.0f, 0.0f, (REAL)posDstWidth, (REAL)posDstHeight);
                                        GpRectF     srcRect;

                                        // StretchDIBits takes a srcY parameter relative to the lower-left
                                        // (bottom) corner of the bitmap, not the top-left corner,
                                        // like DrawImage does
                                        srcRect.Y      = (REAL)(posSrcDibHeight - srcY - srcHeight);
                                        srcRect.X      = (REAL)srcX;

                                        // !!! We have to subtract one to keep the
                                        // filter from blending black into the image
                                        // on the right and bottom.
                                        srcRect.Width  = (REAL)(srcWidth - (srcWidthSign));
                                        srcRect.Height = (REAL)(srcHeight - (srcHeightSign));

                                        // don't do any blending as part of the stretch
                                        destGraphics->SetCompositingMode(CompositingModeSourceCopy);
                                        destGraphics->SetInterpolationMode(interpolationMode);

                                        // Set the image attributes to Wrap since we don't want to
                                        // use black pixels for the edges
                                        GpImageAttributes imgAttr;
                                        imgAttr.SetWrapMode(WrapModeTileFlipXY);

                                        // now draw the source into the dest bitmap
                                        status = destGraphics->DrawImage(srcBitmap,
                                                                         dstRect,
                                                                         srcRect,
                                                                         UnitPixel,
                                                                         &imgAttr);
                                    }
                                    else
                                    {
                                        WARNING(("destGraphics not valid"));
                                    }
                                    delete destGraphics;
                                }
                                else
                                {
                                    WARNING(("Could not construct destGraphics"));
                                }
                            }
                            else
                            {
                                WARNING(("srcGraphics not valid"));
                            }
                            srcBitmap->Dispose();   // doesn't delete the source data
                        }
                        else
                        {
                            WARNING(("Could not allocate a new BitmapInfoHeader"));
                        }
                        if (freeDibInfo)
                        {
                            GpFree(alignedDibInfo);
                        }
                    }
                    else
                    {
                        WARNING(("Could not construct srcGraphics"));
                    }
                }
                else
                {
                    WARNING(("Could not clone the bitmap header"));
                }

                if ((status == Ok) &&
                    (destBitmap->LockBits(NULL, IMGLOCK_READ, PIXFMT_24BPP_RGB,
                                          &bmpData) == Ok))
                {
                    ASSERT((bmpData.Stride & 3) == 0);

                    GpMemset(dibHeaderBuffer, 0, sizeof(BITMAPINFO));
                    bmpDataPtr = &bmpData;
                    bits       = (BYTE *)bmpData.Scan0;
                    srcX       = 0;
                    srcY       = 0;
                    srcWidth   = posDstWidth;
                    srcHeight  = posDstHeight;
                    usage      = DIB_RGB_COLORS;
                    dibInfo    = (BITMAPINFOHEADER *)dibHeaderBuffer;
                    dibInfo->biSize     = sizeof(BITMAPINFOHEADER);
                    dibInfo->biWidth    = posDstWidth;
                    dibInfo->biHeight   = -posDstHeight;
                    dibInfo->biPlanes   = 1;
                    dibInfo->biBitCount = 24;

                    // We don't want to set the StretchBltMode to COLORONCOLOR here
                    // because we might draw this into non 8Bpp surface and we still
                    // have to halftone in this case
                }
            }
            else
            {
                WARNING(("destBitmap not valid"));
            }
        }
        else
        {
            WARNING(("Could not construct destBitmap"));
        }
    }

DoGdiStretch:

    // Halftoning on NT4 with 8bpp does not work very well -- it gets
    // the wrong color hue.
    // We cannot halftone to metafile for that same reason
    if ((rop != SRCCOPY) ||
        (Is8Bpp && Globals::IsNt && (Globals::OsVer.dwMajorVersion <= 4)) ||
        IsMetafile())
    {
        // don't let halftoning mess up some kind of masking or other effect
        stretchBltMode = COLORONCOLOR;
    }
    ::SetStretchBltMode(hdc, stretchBltMode);

    // There is a bug in Win9x that some StretchDIBits calls don't work
    // so we need to create an actual StretchDIBits record to play.
    // Also, NT4 postscript printing can't handle anything but SRCCOPY,
    // so change any ROPs that are not source copy.
    BOOL processed = FALSE;
    if (!Globals::IsNt)
    {
        processed = CreateAndPlayOutputDIBRecord(hdc, bounds, dstX, dstY, dstWidth,
            dstHeight, srcX, srcY, srcWidth, srcHeight, dibInfo, bits, usage,
            rop);
    }
    else if (rop != SRCCOPY &&
             Globals::OsVer.dwMajorVersion <= 4 &&
             IsPostscript())
    {
        rop = SRCCOPY;
    }

    // In MSO, at this point they would check if this is NT running
    // on a non-true-color surface.  If so, they would set the
    // color adjustment gamma to be 20000.  The comment said that
    // this was needed for NT 3.5.  I'm assuming we don't need to
    // worry about that anymore.

    if (!processed)
    {
        ::StretchDIBits(hdc,
                        dstX, dstY, dstWidth, dstHeight,
                        srcX, srcY, srcWidth, srcHeight,
                        bits, (BITMAPINFO *)dibInfo, usage, rop);
    }

    if (destBitmap)
    {
        if (bmpDataPtr != NULL)
        {
            destBitmap->UnlockBits(bmpDataPtr);
        }
        destBitmap->Dispose();
    }
    if (restoreColors)
    {
        ::SetBkColor(hdc, oldBkColor);
        ::SetTextColor(hdc, oldTextColor);
    }
    if (deleteDIBSection)
    {
        // This will get rid of the Bitmap and it's bits
        ::DeleteObject(hBitmap);
        GpFree(dibBmpInfo);
    }
}

// Also handles META_DIBSTRETCHBLT
// There is not a usage parameter with these records -- the
// usage is always DIB_RGB_COLORS.
VOID
WmfEnumState::DIBBitBlt(
    )
{
    DWORD   rop = *((DWORD UNALIGNED *)RecordData);

    // If No-Op ROP, do nothing; just return
    if ((rop & 0xFFFF0000) == (GDIP_NOOP_ROP3 & 0xFFFF0000))
    {
        return;
    }

    if (rop != SRCCOPY &&
        rop != NOTSRCCOPY &&
        rop != PATCOPY &&
        rop != BLACKNESS &&
        rop != WHITENESS)
    {
        RopUsed = TRUE;
    }

    INT     paramIndex = 7;

    if (RecordType != WmfRecordTypeDIBBitBlt)
    {
        paramIndex = 9;      // META_DIBSTRETCHBLT
    }

    INT     dibIndex = paramIndex + 1;

    if (!IsSourceInRop3(rop))
    {
        if (((GetCurrentRecordSize() / 2) - 3) ==
            (GDIP_EMFPLUS_RECORD_TO_WMF(RecordType) >> 8))
        {
            paramIndex++;
        }

        INT dstX      = (INT)((INT16)((WORD *)RecordData)[paramIndex--]);
        INT dstY      = (INT)((INT16)((WORD *)RecordData)[paramIndex--]);
        INT dstWidth  = (INT)((INT16)((WORD *)RecordData)[paramIndex--]);
        INT dstHeight = (INT)((INT16)((WORD *)RecordData)[paramIndex]);


        // We know that this call will succeed because we have a 2K buffer
        // by default
        CreateRecordToModify(20);

        // For some strange reason we need to play the record on both
        // Win2K and Win9x. So create a WMF record for PatBlt and play it
        ModifiedWmfRecord->rdFunction = GDIP_EMFPLUS_RECORD_TO_WMF(WmfRecordTypePatBlt);
        ModifiedWmfRecord->rdSize     = 10;
        ModifiedWmfRecord->rdParm[5]  = (WORD) dstX;
        ModifiedWmfRecord->rdParm[4]  = (WORD) dstY;
        ModifiedWmfRecord->rdParm[3]  = (WORD) dstWidth;
        ModifiedWmfRecord->rdParm[2]  = (WORD) dstHeight;

        if (rop != PATCOPY && SrcCopyOnly)
        {
            *((DWORD*) ModifiedWmfRecord->rdParm) = PATCOPY;
        }
        else
        {
            *((DWORD*) ModifiedWmfRecord->rdParm) = rop;
        }

        // Now play the record (below)
    }
    else
    {
        BITMAPINFOHEADER UNALIGNED *  srcDibInfo = (BITMAPINFOHEADER UNALIGNED *)(((WORD *)RecordData) + dibIndex);
        UINT                          numPalEntries;
        UINT                          dibBitsSize;

        if ((srcDibInfo->biSize >= sizeof(BITMAPINFOHEADER)) &&
            GetDibNumPalEntries(TRUE,
                                srcDibInfo->biSize,
                                srcDibInfo->biBitCount,
                                srcDibInfo->biCompression,
                                srcDibInfo->biClrUsed,
                                &numPalEntries) &&
            ((dibBitsSize = GetDibBitsSize(srcDibInfo)) > 0))
        {
            if ((srcDibInfo->biBitCount == 1) && (srcDibInfo->biPlanes == 1))
            {
                DWORD UNALIGNED * rgb = (DWORD UNALIGNED *)GetDibColorTable(srcDibInfo);

                if ((rgb[0] == 0x00000000) &&
                    (rgb[1] == 0x00FFFFFF))
                {
                    if (SrcCopyOnly && (rop != SRCCOPY) && CreateCopyOfCurrentRecord())
                    {
                        *((DWORD UNALIGNED *)ModifiedWmfRecord->rdParm) = SRCCOPY;
                        goto PlayTheRecord;
                    }
                    else
                    {
                        // It is a compatible monochrome bitmap, which means it
                        // will use the TextColor and BkColor, so no recoloring
                        // is needed. Since we are not using SrcCopy that means
                        // that it's a mask
                        COLORREF oldBkColor = ::SetBkColor(Hdc, BkColor);
                        COLORREF oldTextColor = ::SetTextColor(Hdc, TextColor);
                        this->PlayRecord();
                        ::SetBkColor(Hdc, oldBkColor);
                        ::SetTextColor(Hdc, oldTextColor);
                        return;
                    }
                }
            }

            UINT    usage      = DIB_RGB_COLORS;
            INT     dstDibSize = GetModifiedDibSize(srcDibInfo, numPalEntries, dibBitsSize, usage);

            if (IsMetafile())
            {
                if (dstDibSize > 0)
                {
                    INT     size = SIZEOF_METARECORDHEADER + (dibIndex * sizeof(WORD)) + dstDibSize;

                    if (CreateRecordToModify(size))
                    {
                        ModifiedWmfRecord->rdFunction = GDIP_EMFPLUS_RECORD_TO_WMF(RecordType);
                        ModifiedWmfRecord->rdSize     = size / 2;
                        GpMemcpy(ModifiedWmfRecord->rdParm, RecordData, (dibIndex * sizeof(WORD)));
                        ModifyDib(DIB_RGB_COLORS, srcDibInfo, NULL,
                                  (BITMAPINFOHEADER UNALIGNED *)(ModifiedWmfRecord->rdParm + dibIndex),
                                  numPalEntries, dibBitsSize, ColorAdjustTypeBitmap);
                    }
                }
                goto PlayTheRecord;
            }
            // At this point, we are not going to play the record.  We're
            // going to call StretchDIBits.  One reason is because we want
            // to set the StretchBltMode, which is only used if a stretching
            // method is called.

            // Also, it avoids us doing an allocation/copy and then GDI doing
            // another allocation/copy (GDI has to do this to align the
            // DIB on a DWORD boundary).

            BITMAPINFOHEADER UNALIGNED * dstDibInfo = srcDibInfo;

            if (dstDibSize > 0)
            {
                if (CreateRecordToModify(dstDibSize))
                {
                    // ModifiedRecord is Aligned
                    dstDibInfo = (BITMAPINFOHEADER UNALIGNED *)ModifiedRecord;

                    ModifyDib(DIB_RGB_COLORS, srcDibInfo, NULL, dstDibInfo,
                              numPalEntries, dibBitsSize, ColorAdjustTypeBitmap);
                }
            }
            else if (!IsDwordAligned(dstDibInfo))
            {
                // The srcDibInfo may not aligned properly, so we make
                // a copy of it, so that it will be aligned.

                dstDibSize = GetCurrentRecordSize() - (SIZEOF_METARECORDHEADER + (dibIndex * sizeof(WORD)));
                if (CreateRecordToModify(dstDibSize))
                {
                    dstDibInfo = (BITMAPINFOHEADER *)ModifiedRecord;

                    GpMemcpy(dstDibInfo, srcDibInfo, dstDibSize);
                }
            }

            if (SrcCopyOnly)
            {
                rop = SRCCOPY;
            }

            INT srcX, srcY;
            INT dstX, dstY;
            INT srcWidth, srcHeight;
            INT dstWidth, dstHeight;

            dstX      = (INT)((INT16)((WORD *)RecordData)[paramIndex--]);
            dstY      = (INT)((INT16)((WORD *)RecordData)[paramIndex--]);
            dstWidth  = (INT)((INT16)((WORD *)RecordData)[paramIndex--]);
            dstHeight = (INT)((INT16)((WORD *)RecordData)[paramIndex--]);
            srcX      = (INT)((INT16)((WORD *)RecordData)[paramIndex--]);
            srcY      = (INT)((INT16)((WORD *)RecordData)[paramIndex--]);

            if (RecordType != WmfRecordTypeDIBBitBlt)
            {
                // META_DIBSTRETCHBLT
                srcWidth  = (INT)((INT16)((WORD *)RecordData)[paramIndex--]);
                srcHeight = (INT)((INT16)((WORD *)RecordData)[paramIndex--]);
            }
            else
            {
                srcWidth  = dstWidth;
                srcHeight = dstHeight;
            }

            // Need to flip the source y coordinate to call StretchDIBits.
            srcY = dstDibInfo->biHeight - srcY - srcHeight;

            OutputDIB(Hdc,
                      NULL,
                      dstX, dstY, dstWidth, dstHeight,
                      srcX, srcY, srcWidth, srcHeight,
                      dstDibInfo, NULL, DIB_RGB_COLORS, rop, TRUE);
            return;
        }
    }

PlayTheRecord:
    this->PlayRecord();
}

VOID
WmfEnumState::StretchDIBits(
    )
{
    DWORD   rop = *((DWORD UNALIGNED *)RecordData);

    // If No-Op ROP, do nothing; just return
    if ((rop & 0xFFFF0000) == (GDIP_NOOP_ROP3 & 0xFFFF0000))
    {
        return;
    }

    if (rop != SRCCOPY &&
        rop != NOTSRCCOPY &&
        rop != PATCOPY &&
        rop != BLACKNESS &&
        rop != WHITENESS)
    {
        RopUsed = TRUE;
    }

    if (IsSourceInRop3(rop))
    {
        if(((GetCurrentRecordSize() / 2) > (SIZEOF_METARECORDHEADER / sizeof(WORD)) + 11))
        {
            BITMAPINFOHEADER UNALIGNED *  srcDibInfo = (BITMAPINFOHEADER UNALIGNED *)(((WORD *)RecordData) + 11);
            UINT                          numPalEntries;
            UINT                          dibBitsSize;
    
            if ((srcDibInfo->biSize >= sizeof(BITMAPINFOHEADER)) &&
                GetDibNumPalEntries(TRUE,
                                    srcDibInfo->biSize,
                                    srcDibInfo->biBitCount,
                                    srcDibInfo->biCompression,
                                    srcDibInfo->biClrUsed,
                                    &numPalEntries) &&
                ((dibBitsSize = GetDibBitsSize(srcDibInfo)) > 0))
            {
                UINT                          usage      = ((WORD *)RecordData)[2];
                UINT                          oldUsage = usage;
                INT                           dstDibSize = GetModifiedDibSize(srcDibInfo, numPalEntries, dibBitsSize, usage);
                BITMAPINFOHEADER UNALIGNED *  dstDibInfo = srcDibInfo;
    
                if (dstDibSize > 0)
                {
                    if ((srcDibInfo->biBitCount == 1) && (srcDibInfo->biPlanes == 1))
                    {
                        DWORD UNALIGNED *     rgb = (DWORD UNALIGNED *)GetDibColorTable(srcDibInfo);
    
                        if ((rgb[0] == 0x00000000) &&
                            (rgb[1] == 0x00FFFFFF))
                        {
                            if (SrcCopyOnly && (rop != SRCCOPY) && CreateCopyOfCurrentRecord())
                            {
                                *((DWORD UNALIGNED *)ModifiedWmfRecord->rdParm) = SRCCOPY;
                                goto PlayTheRecord;
                            }
                            else
                            {
                                // It is a compatible monochrome bitmap, which means it
                                // will use the TextColor and BkColor, so no recoloring
                                // is needed. Since we are not using SrcCopy that means
                                // that it's a mask
                                COLORREF oldBkColor = ::SetBkColor(Hdc, BkColor);
                                COLORREF oldTextColor = ::SetTextColor(Hdc, TextColor);
                                this->PlayRecord();
                                ::SetBkColor(Hdc, oldBkColor);
                                ::SetTextColor(Hdc, oldTextColor);
                                return;
                            }
                        }
                    }
    
    
                    INT     size = SIZEOF_METARECORDHEADER + (11 * sizeof(WORD)) + dstDibSize;
    
                    if (CreateRecordToModify(size))
                    {
                        ModifiedWmfRecord->rdFunction = GDIP_EMFPLUS_RECORD_TO_WMF(RecordType);
                        ModifiedWmfRecord->rdSize     = size / 2;
                        GpMemcpy(ModifiedWmfRecord->rdParm, RecordData, (11 * sizeof(WORD)));
                        // This will be aligned.... Do we want to take a chance?
                        dstDibInfo = (BITMAPINFOHEADER UNALIGNED *)(ModifiedWmfRecord->rdParm + 11);
                        ModifyDib(oldUsage, srcDibInfo, NULL, dstDibInfo,
                                  numPalEntries, dibBitsSize, ColorAdjustTypeBitmap);
                    }
                }
    
                if (!IsMetafile())
                {
                    if ((dstDibInfo == srcDibInfo) && (!IsDwordAligned(dstDibInfo)))
                    {
                        // The srcDibInfo may not aligned properly, so we make
                        // a copy of it, so that it will be aligned.
    
                        dstDibSize = GetCurrentRecordSize() - (SIZEOF_METARECORDHEADER + (11 * sizeof(WORD)));
                        if (CreateRecordToModify(dstDibSize))
                        {
                            dstDibInfo = (BITMAPINFOHEADER UNALIGNED *)ModifiedRecord;
    
                            GpMemcpy(dstDibInfo, srcDibInfo, dstDibSize);
                        }
                    }
    
                    if (SrcCopyOnly)
                    {
                        rop = SRCCOPY;
                    }
    
                    INT dstX      = (INT)((INT16)((WORD *)RecordData)[10]);
                    INT dstY      = (INT)((INT16)((WORD *)RecordData)[9]);
                    INT dstWidth  = (INT)((INT16)((WORD *)RecordData)[8]);
                    INT dstHeight = (INT)((INT16)((WORD *)RecordData)[7]);
                    INT srcX      = (INT)((INT16)((WORD *)RecordData)[6]);
                    INT srcY      = (INT)((INT16)((WORD *)RecordData)[5]);
                    INT srcWidth  = (INT)((INT16)((WORD *)RecordData)[4]);
                    INT srcHeight = (INT)((INT16)((WORD *)RecordData)[3]);
    
                    OutputDIB(Hdc,
                              NULL,
                              dstX, dstY, dstWidth, dstHeight,
                              srcX, srcY, srcWidth, srcHeight,
                              dstDibInfo, NULL, usage, rop, TRUE);
                    return;
                }
            }
        }
    }
    else // !IsSourceRop3
    {
        if (rop != PATCOPY && SrcCopyOnly && CreateCopyOfCurrentRecord())
        {
            *((DWORD UNALIGNED *)ModifiedWmfRecord->rdParm) = PATCOPY;
        }
    }
PlayTheRecord:
    this->PlayRecord();
}

BOOL
WmfEnumState::CreateAndPlayOutputDIBRecord(
    HDC                           hdc,
    const RECTL *                 bounds,
    INT                           dstX,
    INT                           dstY,
    INT                           dstWidth,
    INT                           dstHeight,
    INT                           srcX,
    INT                           srcY,
    INT                           srcWidth,
    INT                           srcHeight,
    BITMAPINFOHEADER UNALIGNED *  dibInfo,
    BYTE *                        bits,   // if NULL, this is a packed DIB
    UINT                          usage,
    DWORD                         rop
    )
{
    INT  bitsSize = GetDibBitsSize(dibInfo);
    UINT sizePalEntries;

    if (GetDibNumPalEntries(TRUE,
                            dibInfo->biSize,
                            dibInfo->biBitCount,
                            dibInfo->biCompression,
                            dibInfo->biClrUsed,
                            &sizePalEntries))
    {
        // We need to get the palette size that corresponds to the type
        // If we have a DIB_PAL_COLORS then each entry is 16bits
        sizePalEntries *= ((usage == DIB_PAL_COLORS)?2:sizeof(RGBQUAD));
    }
    else
    {
        sizePalEntries = 0 ;
    }

    // We need at least a BITMAPINFO structure in there, but if there is a
    // palette, calculate the full size of the structure including the
    // palette

    INT bitmapHeaderSize = sizeof(BITMAPINFOHEADER) + sizePalEntries;
    INT size = SIZEOF_METARECORDHEADER + (11 * sizeof(WORD)) + bitmapHeaderSize + bitsSize ;

    // We cannot use the CreateRecordToModify because the record has already
    // been modified
    size = (size + 1) & ~1;
    METARECORD* metaRecord = (METARECORD*) GpMalloc(size);
    if (metaRecord != NULL)
    {
        metaRecord->rdFunction = GDIP_EMFPLUS_RECORD_TO_WMF(WmfRecordTypeStretchDIB);
        metaRecord->rdSize     = size / 2;
        metaRecord->rdParm[10] = (WORD) dstX;
        metaRecord->rdParm[9]  = (WORD) dstY;
        metaRecord->rdParm[8]  = (WORD) dstWidth;
        metaRecord->rdParm[7]  = (WORD) dstHeight;
        metaRecord->rdParm[6]  = (WORD) srcX;
        metaRecord->rdParm[5]  = (WORD) srcY;
        metaRecord->rdParm[4]  = (WORD) srcWidth;
        metaRecord->rdParm[3]  = (WORD) srcHeight;
        metaRecord->rdParm[2]  = (WORD) usage;
        *(DWORD UNALIGNED *)(&(metaRecord->rdParm[0])) = rop;

        GpMemcpy((BYTE*)(&(metaRecord->rdParm[11])), dibInfo, bitmapHeaderSize);
        GpMemcpy((BYTE*)(&(metaRecord->rdParm[11])) + bitmapHeaderSize, bits, bitsSize);

        ::PlayMetaFileRecord(hdc, HandleTable, metaRecord, NumObjects);
        GpFree(metaRecord);
        return TRUE;
    }
    return FALSE;
}

VOID
WmfEnumState::ModifyRecordColor(
    INT             paramIndex,
    ColorAdjustType adjustType
    )
{
    COLORREF    origColor = *((COLORREF UNALIGNED *)&(((WORD *)RecordData)[paramIndex]));
    COLORREF    modifiedColor = ModifyColor(origColor, adjustType);

    if (modifiedColor != origColor)
    {
        if (CreateCopyOfCurrentRecord())
        {
            *((COLORREF UNALIGNED *)&(ModifiedWmfRecord->rdParm[paramIndex])) = modifiedColor;
        }
    }
}

COLORREF
MfEnumState::ModifyColor(
    COLORREF        color,
    ColorAdjustType adjustType
    )
{
    if (AdjustType != ColorAdjustTypeDefault)
    {
        adjustType = AdjustType;
    }

    switch (color & 0xFF000000)
    {
    case 0x00000000:
        break;

    case 0x01000000:    // Palette Index
        {
            PALETTEENTRY    palEntry;

            if (::GetPaletteEntries(CurrentPalette, color & 0x000000FF, 1, &palEntry) == 1)
            {
                color = RGB(palEntry.peRed, palEntry.peGreen, palEntry.peBlue);
            }
            else
            {
                color = RGB(0, 0, 0);
                WARNING(("Failed to get palette entry"));
            }
        }
        break;

    case 0x02000000:    // Palette RGB
    default:
        color &= 0x00FFFFFF;
        break;
    }
    // Possible perfomance improvement: recolor the SelectedPalette so only
    // RGB values need to be recolored here.
    if (Recolor != NULL)
    {
        Recolor->ColorAdjustCOLORREF(&color, adjustType);
    }

    // Palette RGB values don't get dithered (at least not on NT), so we
    // only want to make it a PaletteRGB value if it is a solid color in
    // the palette.

    if (Is8Bpp)
    {
        COLORREF    matchingColor;

        matchingColor = (::GetNearestColor(Hdc, color | 0x02000000) & 0x00FFFFFF);

        // Pens and Text don't get Dithered so match them to the logical palette
        // the other adjustTypes do so they will get halftoned
        if ((matchingColor == color) ||
            (adjustType == ColorAdjustTypePen) ||
            (adjustType == ColorAdjustTypeText))
        {
            return color | 0x02000000;
        }
    }

    return color;
}

BOOL
MfEnumState::CreateRecordToModify(
    INT         size
    )
{
    if (size <= 0)
    {
        size = this->GetCurrentRecordSize();
    }

    // add a little padding to help insure we don't read past the end of the buffer
    size += 16;

    if (ModifiedRecordSize < size)
    {
        ASSERT(ModifiedRecordSize == 0);

        if (size <= GDIP_RECORDBUFFER_SIZE)
        {
            ModifiedRecord = RecordBuffer;
        }
        else if (size <= SizeAllocedRecord)
        {
            ModifiedRecord = AllocedRecord;
        }
        else
        {
            VOID *          newRecord;
            INT             allocSize;

            // alloc in increments of 1K
            allocSize = (size + 1023) & (~1023);

            ModifiedRecord = NULL;
            newRecord = GpRealloc(AllocedRecord, allocSize);
            if (newRecord != NULL)
            {
                ModifiedRecord    = newRecord;
                AllocedRecord     = newRecord;
                SizeAllocedRecord = allocSize;
            }
        }
    }
    else
    {
        ASSERT(ModifiedRecord != NULL);
        ASSERT(ModifiedRecordSize == size);
    }

    if (ModifiedRecord != NULL)
    {
        ModifiedRecordSize = size;
        return TRUE;
    }

    WARNING(("Failed to create ModifiedRecord"));
    return FALSE;
}

BOOL
WmfEnumState::CreateCopyOfCurrentRecord()
{
    if (ModifiedRecordSize > 0)
    {
        // We already made a modified record.  Don't do it again.
        ASSERT(ModifiedRecord != NULL);
        return TRUE;
    }

    INT     size = this->GetCurrentRecordSize();

    if (CreateRecordToModify(size))
    {
        METARECORD *    modifiedRecord = (METARECORD *)ModifiedRecord;

        modifiedRecord->rdFunction = GDIP_EMFPLUS_RECORD_TO_WMF(RecordType);
        modifiedRecord->rdSize     = size / 2;

        if (RecordDataSize > 0)
        {
            GpMemcpy(modifiedRecord->rdParm, RecordData, RecordDataSize);
        }
        return TRUE;
    }

    WARNING(("Failed to create copy of current record"));
    return FALSE;
}

VOID
WmfEnumState::MakeSolidBlackBrush()
{
    INT     size = SIZEOF_METARECORDHEADER + sizeof(LOGBRUSH16);

    CreateRecordToModify(size);
    ModifiedWmfRecord->rdSize = size / 2;
    ModifiedWmfRecord->rdFunction = META_CREATEBRUSHINDIRECT;

    LOGBRUSH16 *    logBrush = (LOGBRUSH16 *)(ModifiedWmfRecord->rdParm);

    logBrush->lbStyle = BS_SOLID;
    logBrush->lbColor = PALETTERGB(0,0,0);
    logBrush->lbHatch = 0;
}

VOID
WmfEnumState::CalculateViewportMatrix()
{
    GpRectF destViewport((REAL)DstViewportOrg.x, (REAL)DstViewportOrg.y,
                         (REAL)DstViewportExt.cx, (REAL)DstViewportExt.cy);
    GpRectF srcViewport((REAL)ImgViewportOrg.x, (REAL)ImgViewportOrg.y,
                        (REAL)ImgViewportExt.cx, (REAL)ImgViewportExt.cy);

    Status status = ViewportXForm.InferAffineMatrix(destViewport, srcViewport);
    if (status != Ok)
    {
        ViewportXForm.Reset();
    }
}

VOID
WmfEnumState::SetViewportOrg()
{
    // If this is the first SetViewportOrg then we need to save that value and
    // calculate a transform from out viewport to this viewport
    ImgViewportOrg.x = (INT)((INT16)((WORD *)RecordData)[1]);
    ImgViewportOrg.y = (INT)((INT16)((WORD *)RecordData)[0]);
    if (FirstViewportOrg || FirstViewportExt)
    {
        FirstViewportOrg = FALSE;
        // If we have processed the first ViewportExt call then we can calculate
        // the transform from our current viewport to the new viewport
        if (!FirstViewportExt)
        {
            CalculateViewportMatrix();
        }
    }
    else
    {
        // We need to keep the new Viewport origin to be able to calculate
        // the viewport bottom right corner before passing it through a
        // transform
        GpPointF newOrg((REAL) ImgViewportOrg.x,
                        (REAL) ImgViewportOrg.y);
        // Transform the new viewport with our viewport transformation
        ViewportXForm.Transform(&newOrg);
        DstViewportOrg.x = GpRound(newOrg.X);
        DstViewportOrg.y = GpRound(newOrg.Y);
        if(CreateRecordToModify())
        {
            ModifiedWmfRecord->rdFunction = CurrentWmfRecord->rdFunction;
            ModifiedWmfRecord->rdSize     = CurrentWmfRecord->rdSize;
            ModifiedWmfRecord->rdParm[0]  = (WORD)GpRound(newOrg.Y);
            ModifiedWmfRecord->rdParm[1]  = (WORD)GpRound(newOrg.X);
        }

        this->PlayRecord();
    }

}

VOID
WmfEnumState::SetViewportExt()
{
    // If this is the first SetViewportOrg then we need to save that value and
    // calculate a transform from out viewport to this viewport
    ImgViewportExt.cx = (INT)((INT16)((WORD *)RecordData)[1]);
    ImgViewportExt.cy = (INT)((INT16)((WORD *)RecordData)[0]);
    if (FirstViewportOrg || FirstViewportExt)
    {
        FirstViewportExt = FALSE;
        // If we have processed the first ViewportExt call then we can calculate
        // the transform from our current viewport to the new viewport
        if (!FirstViewportOrg)
        {
            CalculateViewportMatrix();
        }
    }
    else
    {
        // We need to transform the point, so add the current origin
        // of the Viewport
        GpPointF newExt((REAL) ImgViewportExt.cx,
                        (REAL) ImgViewportExt.cy);

        // Transform the new viewport with our viewport transformation
        ViewportXForm.VectorTransform(&newExt);
        if(CreateRecordToModify())
        {
            ModifiedWmfRecord->rdFunction = CurrentWmfRecord->rdFunction;
            ModifiedWmfRecord->rdSize     = CurrentWmfRecord->rdSize;
            ModifiedWmfRecord->rdParm[0]  = (WORD)GpRound(newExt.Y);
            ModifiedWmfRecord->rdParm[1]  = (WORD)GpRound(newExt.X);
        }

        this->PlayRecord();
    }
}

VOID
WmfEnumState::CreateRegion()
{
    // Check if the region it too big when mapped to device space.

    if (!Globals::IsNt)
    {

        // There is a bug in Win9x GDI where the code which plays METACREATEREGION doesn't copy the
        // entire region data, it is off by 8 bytes.  This seems to have been introduced to allow
        // for compatibility with an older header format, WIN2OBJECT.  We get around this by increasing
        // the size of the record by 8 bytes.  No other harm done.

        if (CreateCopyOfCurrentRecord())
        {
            // When we create a copy of the record, we add 16 bytes of padding so we know this
            // won't overflow into other memory.
            ModifiedWmfRecord->rdSize += 4;
        }
    }

    this->PlayRecord();
}

HFONT CreateTrueTypeFont(
    HFONT   hFont
    );

VOID
WmfEnumState::CreateFontIndirect(
    )
{
    LOGFONT16 *     logFont = (LOGFONT16 *)RecordData;
    BOOL            recordCopied = FALSE;

    if (!Globals::IsNt)
    {
        // We have a bug in Win9x that the OUT_TT_ONLY_PRECIS flag is
        // not always respected so if the font name is MS SANS SERIF
        // change it to Times New Roman
        // Since we don't have a string compare in ASCII do it in UNICODE
        WCHAR faceName[32];
        if (AnsiToUnicodeStr((char*)(logFont->lfFaceName), faceName, sizeof(faceName)/sizeof(WCHAR)) &&
            (UnicodeStringCompareCI(faceName, L"MS SANS SERIF") == 0))
        {
            if (CreateCopyOfCurrentRecord())
            {
                GpMemcpy(((LOGFONT16 *)(ModifiedWmfRecord->rdParm))->lfFaceName,
                         "Times New Roman", sizeof("Times New Roman"));
                recordCopied = TRUE;
            }
        }
    }
    if (logFont->lfOutPrecision != OUT_TT_ONLY_PRECIS)
    {
        // Instruct GDI to use only True Type fonts, since bitmap fonts
        // are not scalable.
        if (recordCopied || CreateCopyOfCurrentRecord())
        {
            ((LOGFONT16 *)(ModifiedWmfRecord->rdParm))->lfOutPrecision = OUT_TT_ONLY_PRECIS;
        }
    }
    this->PlayRecord();
}

VOID WmfEnumState::SelectObject()
{
    this->PlayRecord();

    // In case we selected a region on Win9x, we need to intersect
    if (!Globals::IsNt)
    {
        DWORD index = CurrentWmfRecord->rdParm[0];
        if (GetObjectTypeInternal((*HandleTable).objectHandle[index]) == OBJ_REGION)
        {
            this->IntersectDestRect();
        }
    }
}

VOID WmfEnumState::IntersectDestRect()
{
    if (!IsMetafile())
    {
        POINT windowOrg;
        SIZE  windowExt;
        ::SetWindowOrgEx(Hdc, DstViewportOrg.x, DstViewportOrg.y, &windowOrg);
        ::SetWindowExtEx(Hdc, DstViewportExt.cx, DstViewportExt.cy, &windowExt);

        // We are always in device units
        ::IntersectClipRect(Hdc, DestRectDevice.left, DestRectDevice.top,
                            DestRectDevice.right, DestRectDevice.bottom);

        ::SetWindowOrgEx(Hdc, windowOrg.x, windowOrg.y, NULL);
        ::SetWindowExtEx(Hdc, windowExt.cx, windowExt.cy, NULL);
    }
}

VOID WmfEnumState::SetROP2()
{
    INT rop = (INT)((INT16)(((WORD *)RecordData)[0]));

    if (rop != R2_BLACK &&
        rop != R2_COPYPEN &&
        rop != R2_NOTCOPYPEN &&
        rop != R2_WHITE )
    {
        RopUsed = TRUE;
    }
    this->PlayRecord();
}

BOOL
WmfEnumState::ProcessRecord(
    EmfPlusRecordType       recordType,
    UINT                    recordDataSize,
    const BYTE *            recordData
    )
{
    BOOL        forceCallback = FALSE;

    MfFsmState  nextState = MfFsmStart;

    if (IsFirstRecord)
    {
        // Bitmap fonts are not good for playing metafiles because they
        // don't scale well, so use a true type font instead as the default font.

        HFONT hFont = CreateTrueTypeFont((HFONT)GetCurrentObject(Hdc, OBJ_FONT));

        if (hFont != NULL)
        {
            DefaultFont = hFont;
            ::SelectObject(Hdc, hFont);
        }

        IsFirstRecord = FALSE;
    }

    // See if we're doing enumeration for an external app
    if (ExternalEnumeration)
    {
        if (recordData == NULL)
        {
            recordDataSize = 0;
        }
        else if (recordDataSize == 0)
        {
            recordData = NULL;
        }

        // make sure it's an EMF enum type
        recordType = GDIP_WMF_RECORD_TO_EMFPLUS(recordType);

        // See if the app changed the record at all.
        if ((recordType != RecordType) ||
            (recordDataSize != RecordDataSize) ||
            ((recordDataSize > 0) &&
             ((CurrentWmfRecord == NULL) ||
              (recordData != (const BYTE *)CurrentWmfRecord->rdParm))))
        {
            // Yes, we need to override what happened in StartRecord
            CurrentWmfRecord  = NULL;
            RecordType        = recordType;
            RecordData        = recordData;
            RecordDataSize    = recordDataSize;
        }
    }

    // Ignore all non-escape records if IgnorePostcript is TRUE
    if (recordType == WmfRecordTypeEscape || !IgnorePostscript)
    {
        GDIP_TRY

        switch (recordType)
        {
        // According to NT playback code, this is a EOF record, but it
        // is just skipped by the NT player.
        case GDIP_WMF_RECORD_TO_EMFPLUS(0x0000):  // End of metafile record
            break;

        // These records are not played back (at least in Win2000).
        // Apparently they haven't been supported since before Win3.1!
        case WmfRecordTypeSetRelAbs:
        case WmfRecordTypeDrawText:
        case WmfRecordTypeResetDC:
        case WmfRecordTypeStartDoc:
        case WmfRecordTypeStartPage:
        case WmfRecordTypeEndPage:
        case WmfRecordTypeAbortDoc:
        case WmfRecordTypeEndDoc:
        case WmfRecordTypeCreateBrush:
        case WmfRecordTypeCreateBitmapIndirect:
        case WmfRecordTypeCreateBitmap:
            ONCE(WARNING1("Unsupported WMF record"));
            break;

        default:
            // unknown record -- ignore it
            WARNING1("Unknown WMF Record");
            break;

        case WmfRecordTypeSetBkMode:
        case WmfRecordTypeSetMapMode:
        case WmfRecordTypeSetPolyFillMode:
        case WmfRecordTypeSetStretchBltMode:
        case WmfRecordTypeSetTextCharExtra:
        case WmfRecordTypeSetTextJustification:
        case WmfRecordTypeSetWindowOrg:
        case WmfRecordTypeSetWindowExt:
        case WmfRecordTypeOffsetWindowOrg:
        case WmfRecordTypeScaleWindowExt:
        case WmfRecordTypeOffsetViewportOrg:
        case WmfRecordTypeScaleViewportExt:
        case WmfRecordTypeLineTo:
        case WmfRecordTypeMoveTo:
        case WmfRecordTypeExcludeClipRect:
        case WmfRecordTypeIntersectClipRect:
        case WmfRecordTypeArc:
        case WmfRecordTypeEllipse:
        case WmfRecordTypePie:
        case WmfRecordTypeRoundRect:
        case WmfRecordTypePatBlt:
        case WmfRecordTypeTextOut:
        case WmfRecordTypePolygon:
        case WmfRecordTypePolyline:
        case WmfRecordTypeFillRegion:
        case WmfRecordTypeFrameRegion:
        case WmfRecordTypeInvertRegion:
        case WmfRecordTypePaintRegion:
        case WmfRecordTypeSetTextAlign:
        case WmfRecordTypeChord:
        case WmfRecordTypeSetMapperFlags:
        case WmfRecordTypeExtTextOut:
        case WmfRecordTypeAnimatePalette:
        case WmfRecordTypeSetPalEntries:
        case WmfRecordTypeResizePalette:
        case WmfRecordTypeSetLayout:
        case WmfRecordTypeDeleteObject:
        case WmfRecordTypeCreatePalette:
            // Play the current record.
            // Even if it fails, we keep playing the rest of the metafile.
            // There is a case that GdiComment with EPS may fail.
            this->PlayRecord();
            break;

        case WmfRecordTypeCreateRegion:
            this->CreateRegion();
            break;

        case WmfRecordTypeCreateFontIndirect:
            this->CreateFontIndirect();
            break;

        case WmfRecordTypeSetBkColor:
            this->SetBkColor();
            break;

        case WmfRecordTypeSetTextColor:
            this->SetTextColor();
            break;

        case WmfRecordTypeFloodFill:
            this->FloodFill();
            break;

        case WmfRecordTypeExtFloodFill:
            this->ExtFloodFill();
            break;

        case WmfRecordTypeSaveDC:
            this->SaveHdc();        // plays the record
            break;

        case WmfRecordTypeSetPixel:
            this->SetPixel();
            break;

        case WmfRecordTypeDIBCreatePatternBrush:
            this->DibCreatePatternBrush();
            break;

        case WmfRecordTypeCreatePatternBrush:   // Obsolete but still played back
            this->CreatePatternBrush();
            break;

        case WmfRecordTypeCreatePenIndirect:
            this->CreatePenIndirect();
            if (FsmState == MfFsmSelectBrush)
            {
                nextState = MfFsmCreatePenIndirect;
            }
            break;

        case WmfRecordTypeCreateBrushIndirect:
            this->CreateBrushIndirect();
            if (FsmState == MfFsmPSData)
            {
                nextState = MfFsmCreateBrushIndirect;
            }
            break;

        case WmfRecordTypeSelectObject:
            // What if we break out of the FSM, we do want to Create the appropriate
            // brush and pens right?!
            if (FsmState == MfFsmCreateBrushIndirect)
            {
                nextState = MfFsmSelectBrush;
                break;
            }
            else if (FsmState == MfFsmSelectBrush ||
                     FsmState == MfFsmCreatePenIndirect)
            {
                nextState = MfFsmSelectPen;
                break;
            }
            this->SelectObject();
            break;

        case WmfRecordTypeRectangle:
            this->Rectangle();
            break;

        case WmfRecordTypeSetROP2:
            {
                INT rdParm = (INT)((INT16)(((WORD *)RecordData)[0]));

                if (FsmState == MfFsmSelectPen &&
                    (INT)(rdParm == R2_NOP))
                {
                    nextState = MfFsmSetROP;
                }
                this->SetROP2();
            }
            break;

        case WmfRecordTypeBitBlt:       // Obsolete but still played back
            this->BitBlt();
            forceCallback = TRUE;
            break;

        case WmfRecordTypeStretchBlt:   // Obsolete but still played back
            this->StretchBlt();
            forceCallback = TRUE;
            break;

        case WmfRecordTypeEscape:
            {
                INT     escapeCode = (INT)((INT16)(((WORD *)RecordData)[0]));

                this->Escape();         // optionally plays the record

                if (FsmState == MfFsmStart && escapeCode == POSTSCRIPT_DATA &&
                    Globals::IsNt && IsPostscriptPrinter() &&
                    GdiCentricMode && SoftekFilter)
                {
                    nextState = MfFsmPSData;
                }

                // Comments do not change the current state
                if (escapeCode == MFCOMMENT)
                {
                    nextState = FsmState;
                }
            }
            break;

        case WmfRecordTypeRestoreDC:
            this->RestoreHdc();     // optionally plays the record
            break;

        case WmfRecordTypeSetDIBToDev:
            this->SetDIBitsToDevice();
            forceCallback = TRUE;
            break;

        case WmfRecordTypeSelectPalette:
            // We don't select in any palettes when playing the metafile,
            // because we don't want to invalidate our halftoning palette.
            // Keep track of the palette so we can map from PALETTEINDEXes
            // to RGB values.
            this->SelectPalette((INT)((INT16)(((WORD *)recordData)[0])));
            break;

        case WmfRecordTypeRealizePalette:
            // We don't want to invalidate our halftoning palette by realizing one
            // from a metafile.
            break;

        case WmfRecordTypePolyPolygon:
            this->PolyPolygon();
            break;

        case WmfRecordTypeDIBBitBlt:
            this->DIBBitBlt();
            forceCallback = TRUE;
            break;

        case WmfRecordTypeDIBStretchBlt:
            this->DIBStretchBlt();
            forceCallback = TRUE;
            break;

        case WmfRecordTypeStretchDIB:
            this->StretchDIBits();
            forceCallback = TRUE;
            break;

        case WmfRecordTypeSetViewportOrg:
            this->SetViewportOrg();
            break;

        case WmfRecordTypeSetViewportExt:
            this->SetViewportExt();
            break;

        case WmfRecordTypeSelectClipRegion:
        case WmfRecordTypeOffsetClipRgn:
            this->PlayRecord();
            if (!Globals::IsNt)
            {
                this->IntersectDestRect();
            }
            break;
        }

        GDIP_CATCH
            forceCallback = TRUE;
        GDIP_ENDCATCH

    }
    FsmState = nextState;
    this->EndRecord();

    return forceCallback;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\ntfsstream.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   NtfsStream.cpp
*
* Abstract:
*
*   This file provides the Flat File IStream definition.
*
* Created:
*
*   4/26/1999 Mike Hillberg
*
\**************************************************************************/

#include "precomp.hpp"
#include "LargeInt.hpp"
#include "time.h"
#include "FileTime.hpp"
#include "NtfsStream.hpp"

IStream *
CreateStreamOnFile(
    const OLECHAR * pwcsName,
    UINT            access  // GENERIC_READ and/or GENERIC_WRITE
    )
{
    HANDLE          hFile;
    FileStream *    stream;
    UINT            disposition;
    DWORD           grfMode = STGM_SHARE_EXCLUSIVE;
    DWORD           shareMode = 0;
    
    switch (access)
    {
    case GENERIC_READ:
        disposition = OPEN_EXISTING;
        shareMode = FILE_SHARE_READ;
        grfMode |= STGM_READ;
        break;
    
    case GENERIC_WRITE:
        disposition = CREATE_ALWAYS;
        grfMode |= STGM_WRITE;
        break;
        
    // Note that OPEN_ALWAYS does NOT clear existing file attributes (like size)    
    case GENERIC_READ|GENERIC_WRITE:
        disposition = OPEN_ALWAYS;
        grfMode |= STGM_READWRITE;
        break;
        
    default:
        return NULL;
    }

    if (Globals::IsNt)
    {
        hFile = CreateFileW(pwcsName, access, shareMode, NULL, 
                            disposition, FILE_ATTRIBUTE_NORMAL, NULL);
    }
    else // Windows 9x - non-Unicode
    {
        AnsiStrFromUnicode nameStr(pwcsName);

        if (nameStr.IsValid())
        {
            hFile =  CreateFileA(nameStr, access, shareMode, NULL, 
                                 disposition, FILE_ATTRIBUTE_NORMAL, NULL);
        }
        else
        {
            hFile = INVALID_HANDLE_VALUE;
        }
    }

    if ((hFile != INVALID_HANDLE_VALUE) && (hFile != NULL))
    {
        stream = new FileStream();
        if (stream != NULL)
        {
            HRESULT     hResult;
            
            hResult = stream->Init(hFile, grfMode, pwcsName);
                                   
            if (!FAILED(hResult))
            {
                return stream;
            }
            delete stream;
        }
        CloseHandle(hFile);
    }
    return NULL;
}

//+----------------------------------------------------------------------------
//
//  Method:     FileStream::AddRef (IUnknown)
//
//+----------------------------------------------------------------------------

ULONG
FileStream::AddRef()
{
    LONG cRefs;

    cRefs = InterlockedIncrement( &_cRefs );
    return cRefs;
}


//+----------------------------------------------------------------------------
//
//  Method:     FileStream::Release (IUnknown)
//
//+----------------------------------------------------------------------------

ULONG
FileStream::Release()
{
    ULONG ulRet = InterlockedDecrement( &_cRefs );

    if( 0 == ulRet )
        delete this;

    return( ulRet );
}


//+----------------------------------------------------------------------------
//
//  Method:     FileStream::AddRef (IUnknown)
//
//+----------------------------------------------------------------------------

HRESULT
FileStream::QueryInterface(
        REFIID riid,
        void** ppv )
{
    HRESULT sc=S_OK;

    if( IsEqualIID( riid, IID_IUnknown )
        ||
        IsEqualIID( riid, IID_IStream )
        ||
        IsEqualIID( riid, IID_ISequentialStream ) )
    {
        *ppv = static_cast<IStream*>(this);
        AddRef();
        return( S_OK );
    }
    else
    {
        return( E_NOINTERFACE );
    }

    return sc;
}


//+----------------------------------------------------------------------------
//
//  Method:     FileStream::Seek (IStream)
//
//+----------------------------------------------------------------------------

HRESULT
FileStream::Seek(
        LARGE_INTEGER dlibMove,
        DWORD dwOrigin,
        ULARGE_INTEGER *puliNewPos)
{
    HRESULT sc = S_OK;
    LARGE_INTEGER liFileSize;
    LARGE_INTEGER liNewPos;

    Lock( INFINITE );

    switch( dwOrigin )
    {
    case STREAM_SEEK_SET:
        liNewPos.QuadPart = dlibMove.QuadPart;
        break;

    case STREAM_SEEK_CUR:
        liNewPos.QuadPart = _liCurrentSeekPosition.QuadPart + dlibMove.QuadPart;
        break;

    case STREAM_SEEK_END:
        liFileSize.LowPart = GetFileSize( _hFile,
                                         (ULONG*)(&liFileSize.HighPart) );

        if( 0xFFFFFFFF == liFileSize.LowPart && NO_ERROR != GetLastError() )
        {
            nffChk( HRESULT_FROM_WIN32( GetLastError() ) );
        }

        liNewPos.QuadPart = liFileSize.QuadPart + dlibMove.QuadPart;
        break;

    default:
        break;
    }

    // Compatibility with Docfile.  Seeking < 0 fails.
    if( liNewPos.QuadPart < 0 )
        nffErr( EH_Err, STG_E_INVALIDFUNCTION );

    _liCurrentSeekPosition = liNewPos;


    // If desired, give the caller the now-current seek position.
    if( NULL != puliNewPos )
        *puliNewPos = _liCurrentSeekPosition;

EH_Err:
    Unlock();
    return( sc );
}


//+----------------------------------------------------------------------------
//
//  Method:     FileStream::SetSize (IStream)
//
//+----------------------------------------------------------------------------

HRESULT
FileStream::SetSize(
        ULARGE_INTEGER uliNewSize)
{
    HRESULT sc = S_OK;
    CLargeInteger liEOF;

    if ( uliNewSize.HighPart != 0 )
        nffErr(EH_Err, STG_E_INVALIDFUNCTION);


    Lock( INFINITE );

    nffChk( CheckReverted() );

    // If this stream is mapped, set the size accordingly

    sc = SetFileSize( CULargeInteger(uliNewSize) );

    if( !FAILED(sc) )
        sc = S_OK;

EH_Err:

    Unlock();
    return( sc);

}

//+----------------------------------------------------------------------------
//
//  Method:     FileStream::CopyTo (IStream)
//
//+----------------------------------------------------------------------------

HRESULT
FileStream::CopyTo(
        IStream *pstm,
        ULARGE_INTEGER cb,
        ULARGE_INTEGER *pcbRead,
        ULARGE_INTEGER *pcbWritten)
{

    HRESULT sc = S_OK;
    PVOID pv = NULL;
    ULONG cbRead = 0, cbWritten = 0;
    CULargeInteger cbReadTotal = 0, cbWrittenTotal = 0;
    CLargeInteger liZero = 0;
    CULargeInteger uliOriginalSourcePosition, uliOriginalDestPosition;
    CULargeInteger cbSourceSize, cbDestSize;
    ULONG cbPerCopy = 0;
    STATSTG statstg;
    CULargeInteger cbRequested = cb;
    BOOL fCopyForward;

    Lock( INFINITE );

    nffChk( CheckReverted() );

    if( NULL == pstm)
        nffErr( EH_Err, STG_E_INVALIDPARAMETER );

    // Determine how much we'll copy at a time.
    // As of this writing, STREAMBUFFERSIZE is 8192 bytes

    if( cbRequested > STREAMBUFFERSIZE )
        cbPerCopy = STREAMBUFFERSIZE;
    else
        cbPerCopy = cbRequested.LowPart;

    //  ------------------------------------------------------------------
    //  Get the current stream sizes/positions, and adjust the destination
    //  size if necessary
    //  ------------------------------------------------------------------

    nffChk( this->Seek( liZero, STREAM_SEEK_CUR, &uliOriginalSourcePosition ) );

    nffChk( pstm->Seek( liZero, STREAM_SEEK_CUR, &uliOriginalDestPosition ) );

    nffChk( this->Stat( &statstg, STATFLAG_NONAME ) );

    cbSourceSize = statstg.cbSize;

    nffChk( pstm->Stat( &statstg, STATFLAG_NONAME ) );

    cbDestSize = statstg.cbSize;

    // Ensure the sizes are valid (we can't handle anything with the high bit
    // set, because Seek takes a signed offset).

    if( static_cast<CLargeInteger>(cbSourceSize) < 0
        ||
        static_cast<CLargeInteger>(cbDestSize) < 0 )
    {
        nffErr( EH_Err, STG_E_INVALIDHEADER );
    }

    // Don't copy more than the source stream has available
    if( cbRequested > cbSourceSize - uliOriginalSourcePosition )
        cbRequested = cbSourceSize - uliOriginalSourcePosition;

    // If necessary, grow the destination stream.

    if( cbSourceSize - uliOriginalSourcePosition > cbDestSize - uliOriginalDestPosition )
    {
        cbDestSize = cbSourceSize - uliOriginalSourcePosition + uliOriginalDestPosition;
        nffChk( pstm->SetSize( cbDestSize ) );
    }

    //  ----------------------
    //  Allocate a copy buffer
    //  ----------------------

    nffMem( pv = CoTaskMemAlloc( cbPerCopy ) );

    //  -----------------------------------------------------------------------------
    //  Determine if we're copying forwards (high seek position to low) or backwards.
    //  -----------------------------------------------------------------------------

    fCopyForward = TRUE;
    if( uliOriginalSourcePosition < uliOriginalDestPosition )
    {
        // E.g., say we're copying 15 bytes from offset 0 to offset 5,
        // and we're only able to copy 10 bytes at a time.
        // If we copy bytes 0-9 to offset 5, we'll end up overwriting
        // bytes 10-14, and be unable to complete the copy.
        // So instead, we'll copy bytes 5-14 to offset 10, and finish
        // up by copying bytes 0-4 to offset 5.

        fCopyForward = FALSE;

        // To do this kind of backwards copy, we need to start by seeking
        // towards the end of the stream.

        CULargeInteger uliNewSourcePosition, uliNewDestPosition;

        uliNewSourcePosition = cbSourceSize - cbPerCopy;
        nffChk( this->Seek( uliNewSourcePosition, STREAM_SEEK_SET, NULL ) );

        uliNewDestPosition = cbDestSize - cbPerCopy;
        nffChk( pstm->Seek( uliNewDestPosition, STREAM_SEEK_SET, NULL ) );

    }

    //  --------------
    //  Copy in chunks
    //  --------------

    cbPerCopy = cbRequested > cbPerCopy ? cbPerCopy : cbRequested.LowPart;
    while( cbRequested > 0 )
    {
        // Read from the source
        nffChk( this->Read( pv, cbPerCopy, &cbRead ) );

        if( cbRead != cbPerCopy )
            nffErr(EH_Err, STG_E_READFAULT);

        cbReadTotal += cbRead;

        // Write to the dest
        nffChk( pstm->Write( pv, cbPerCopy, &cbWritten ) );

        if( cbWritten != cbPerCopy )
            nffErr( EH_Err, STG_E_WRITEFAULT );

        cbWrittenTotal += cbWritten;

        // Adjust the amount remaining to be copied
        cbRequested -= cbPerCopy;


        // Determine how much to copy in the next iteration (this will
        // always be cbPerCopy until the last iteration).  If copying
        // backwards, we need to manually adjust the seek pointer.

        cbPerCopy = (cbRequested > cbPerCopy) ? cbPerCopy : cbRequested.LowPart;
        if( !fCopyForward && (cbRequested > 0))
        {
            nffChk( this->Seek( -static_cast<CLargeInteger>(cbPerCopy+STREAMBUFFERSIZE),
                                                STREAM_SEEK_CUR, NULL ) );

            nffChk( pstm->Seek( -static_cast<CLargeInteger>(cbPerCopy+STREAMBUFFERSIZE),
                                                STREAM_SEEK_CUR, NULL ) );
        }

    }

    // If we were backward-copying, adjust the seek pointers
    // as if we had forward-copied

    if( !fCopyForward )
    {
        uliOriginalSourcePosition += cbReadTotal;
        nffChk( this->Seek( uliOriginalSourcePosition, STREAM_SEEK_SET, NULL ) );

        uliOriginalDestPosition += cbWrittenTotal;
        nffChk( pstm->Seek( uliOriginalDestPosition, STREAM_SEEK_SET, NULL ) );
    }

    //  ----
    //  Exit
    //  ----

    if( NULL != pcbRead )
        *pcbRead = cbReadTotal;
    if( NULL != pcbWritten )
        *pcbWritten = cbWrittenTotal;

EH_Err:

    if( NULL != pv )
        CoTaskMemFree(pv);

    Unlock();
    return(sc);

}


//+----------------------------------------------------------------------------
//
//  Method:     FileStream::Commit (IStream)
//
//+----------------------------------------------------------------------------

HRESULT
FileStream::Commit( DWORD grfCommitFlags )
{
    HRESULT sc = S_OK;

    Lock( INFINITE );

    nffChk( CheckReverted() );

    // NTRAID#NTBUG9-368729-2001-04-13-gilmanw "ISSUE: FileStream object - handle other stream commit flags"
    // Are there other commit flags that need to be handled?

    if( !(STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE  & grfCommitFlags) )
    {
        if( !FlushFileBuffers( _hFile ))
            sc = HRESULT_FROM_WIN32( GetLastError() );
    }

EH_Err:
    Unlock();
    return sc;

}


//+----------------------------------------------------------------------------
//
//  Method:     FileStream::Revert (IStream)
//
//+----------------------------------------------------------------------------

HRESULT
FileStream::Revert(void)
{
    // We only support direct-mode.

    return CheckReverted();
}



//+----------------------------------------------------------------------------
//
//  Method:     FileStream::LockRegion (IStream)
//
//+----------------------------------------------------------------------------

HRESULT
FileStream::LockRegion(
    ULARGE_INTEGER libOffset,
    ULARGE_INTEGER cb,
    DWORD dwLockType)
{
    HRESULT sc = S_OK;

    Lock( INFINITE );

    nffChk( CheckReverted() );

    // NTRAID#NTBUG9-368745-2001-04-13-gilmanw "ISSUE: FileStream::LockRegion - handle other lock flags"
    // Are all the lock types supported here?

    if (dwLockType != LOCK_EXCLUSIVE && dwLockType != LOCK_ONLYONCE)
        nffErr( EH_Err, STG_E_INVALIDFUNCTION );

    if( !LockFile( _hFile, libOffset.LowPart, libOffset.HighPart,
                   cb.LowPart, cb.HighPart))
    {
        nffErr( EH_Err, HRESULT_FROM_WIN32( GetLastError() ));
    }

EH_Err:

    Unlock();
    return( sc );

}


//+----------------------------------------------------------------------------
//
//  Method:     FileStream::Stat (IStream)
//
//+----------------------------------------------------------------------------

HRESULT
FileStream::Stat(
        STATSTG *pstatstg,
        DWORD grfStatFlag)
{
    STATSTG statstg;
    HRESULT sc = S_OK;

    BY_HANDLE_FILE_INFORMATION ByHandleFileInformation;

    statstg.pwcsName = NULL;

    Lock( INFINITE );

    nffChk( CheckReverted() );

    ZeroMemory((void*)&statstg, sizeof(STATSTG));

    // Get the name, if desired

    if( (STATFLAG_NONAME & grfStatFlag) )
        statstg.pwcsName = NULL;
    else
    {
        nffMem( statstg.pwcsName = reinterpret_cast<WCHAR*>
                                   ( CoTaskMemAlloc( sizeof(WCHAR)*(UnicodeStringLength(_pwcsName) + 1) )));
        UnicodeStringCopy( statstg.pwcsName, _pwcsName );
    }

    // Get the type
    statstg.type = STGTY_STREAM;

    statstg.grfLocksSupported = LOCK_EXCLUSIVE | LOCK_ONLYONCE;

    // Get the size & times.

    if( !GetFileInformationByHandle( _hFile, &ByHandleFileInformation ))
        nffErr( EH_Err, HRESULT_FROM_WIN32( GetLastError() ));

    statstg.cbSize.LowPart = ByHandleFileInformation.nFileSizeLow;
    statstg.cbSize.HighPart = ByHandleFileInformation.nFileSizeHigh;

    // We get a time back in ByHandleFileInformation, but it's the file's times,
    // not the streams times.  So really the stream times are not supported, and
    // we'll just set them to zero.

    statstg.mtime = statstg.atime = statstg.ctime = CFILETIME(0);

    // Get the STGM modes
    statstg.grfMode = _grfMode & ~STGM_CREATE;

    *pstatstg = statstg;

EH_Err:
    if( FAILED(sc) && NULL != statstg.pwcsName )
        CoTaskMemFree( statstg.pwcsName );

    Unlock();
    return( sc );

}



//+----------------------------------------------------------------------------
//
//  Method:     FileStream::Clone (IStream)
//
//+----------------------------------------------------------------------------

HRESULT
FileStream::Clone(
        IStream** ppstm)
{
    // NTRAID#NTBUG9-368747-2001-04-13-gilmanw "ISSUE: FileStream::Clone returns E_NOTIMPL"

    return( E_NOTIMPL );
}


//+----------------------------------------------------------------------------
//
//  Method:     FileStream::Read (IStream)
//
//+----------------------------------------------------------------------------

HRESULT
FileStream::Read(
        void* pv,
        ULONG cb,
        ULONG* pcbRead)
{
    LARGE_INTEGER   lOffset;
    HRESULT         sc     = S_OK;
    ULONG           cbRead = 0;

    lOffset.LowPart  = _liCurrentSeekPosition.LowPart;
    lOffset.HighPart = _liCurrentSeekPosition.HighPart;

    if (lOffset.HighPart < 0)
    {
        return( TYPE_E_SIZETOOBIG );
    }

    Lock( INFINITE );

    nffChk( CheckReverted() );

    if(SetFilePointer(_hFile, lOffset.LowPart, &lOffset.HighPart, 
                      FILE_BEGIN) == INVALID_SET_FILE_POINTER)
    {
        nffChk( HRESULT_FROM_WIN32(GetLastError()));
    }

    if(!ReadFile(_hFile, pv, cb, &cbRead, NULL))
    {
        nffChk( HRESULT_FROM_WIN32(GetLastError()));
    }

    _liCurrentSeekPosition += cbRead;
    if( NULL != pcbRead )
        *pcbRead = cbRead;

EH_Err:

    Unlock();
    return( sc );

}


//+----------------------------------------------------------------------------
//
//  Method:     FileStream::Write (IStream)
//
//+----------------------------------------------------------------------------

HRESULT
FileStream::Write(
        const void* pv,
        ULONG cb,
        ULONG* pcbWritten)
{
    LARGE_INTEGER   lOffset;
    HRESULT         sc = S_OK;
    ULONG           cbWritten = 0;

    lOffset.LowPart  = _liCurrentSeekPosition.LowPart;
    lOffset.HighPart = _liCurrentSeekPosition.HighPart;

    if (lOffset.HighPart < 0)
    {
        return( TYPE_E_SIZETOOBIG );
    }

    Lock( INFINITE );

    nffChk( CheckReverted() );

    if(SetFilePointer(_hFile, lOffset.LowPart, &lOffset.HighPart, 
                      FILE_BEGIN) == INVALID_SET_FILE_POINTER)
    {
        nffChk( HRESULT_FROM_WIN32(GetLastError()));
    }

    if(!WriteFile(_hFile, pv, cb, &cbWritten, NULL))
    {
        nffChk(HRESULT_FROM_WIN32(GetLastError()));
    }

    _liCurrentSeekPosition += cbWritten;

    if( NULL != pcbWritten )
        *pcbWritten = cbWritten;

EH_Err:

    Unlock();
    return( sc );

}


//+-------------------------------------------------------------------
//
//  Member:     FileStream  Constructor
//
//--------------------------------------------------------------------

FileStream::FileStream(  )
{
    _cRefs = 1;
    _grfMode = 0;
    _hFile = INVALID_HANDLE_VALUE;
    _liCurrentSeekPosition = 0;
    _pwcsName = NULL;
    _bCritSecInitialized = FALSE;

    __try
    {
        InitializeCriticalSection( &_critsec );
        _bCritSecInitialized = TRUE;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        // If we've thrown then _bCritSecInitialized will be FALSE and
        // Init() will automatically fail.
    }

}


//+-------------------------------------------------------------------
//
//  Member:     FileStream  Destructor
//
//--------------------------------------------------------------------

FileStream::~FileStream()
{

    // Close the file
    if( INVALID_HANDLE_VALUE != _hFile )
        CloseHandle( _hFile );

    if( NULL != _pwcsName )
        CoTaskMemFree( _pwcsName );

    if (_bCritSecInitialized)
    {
        // We don't need to reset _bCrisSecInitialized to FALSE since the
        // object has been destroyed
        DeleteCriticalSection( &_critsec );
    }
}


//+-------------------------------------------------------------------
//
//  Member:     FileStream::Init
//
//--------------------------------------------------------------------

HRESULT
FileStream::Init(
        HANDLE hFile,               // File handle of this Stream.
        DWORD grfMode,              // Open Modes
        const OLECHAR * pwcsName)   // Name of the Stream
{
    // If we couldn't allocate the critical section then return an Error
    if (!_bCritSecInitialized)
    {
        return E_FAIL;
    }

    HRESULT sc=S_OK;
    HANDLE ev;

    // We now own this file handle, and are responsible for closing it.
    _hFile = hFile;

    // Save the STGM_ flags so we can return them in a Stat call.
    _grfMode = grfMode;

    // Save the stream name

    if( NULL != _pwcsName )
    {
        CoTaskMemFree( _pwcsName );
        _pwcsName = NULL;
    }

    if( NULL != pwcsName )
    {
        nffMem( _pwcsName = reinterpret_cast<WCHAR*>
                            ( CoTaskMemAlloc( sizeof(WCHAR)*(UnicodeStringLength(pwcsName) + 1) )));
        UnicodeStringCopy( _pwcsName, pwcsName );
    }

EH_Err:
    return sc;
}


//+----------------------------------------------------------------------------
//
//  FileStream    Non-Interface::ShutDown
//
//  Flush data, Close File handle and mark the object as reverted.
//  This is called when the Storage is released and when the Oplock Breaks.
//
//+----------------------------------------------------------------------------

HRESULT
FileStream::ShutDown()
{
    HRESULT sc=S_OK;

    if( INVALID_HANDLE_VALUE == _hFile )
        return S_OK;

    //
    // Close the file/stream handle and mark the IStream object as
    // Reverted by giving the file handle an invalid value.
    //
    CloseHandle(_hFile);
    _hFile = INVALID_HANDLE_VALUE;

    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  FileStream::SetFileSize (private, non-interface method)
//
//  Set the size of the _hFile.  This is used by the IStream & IMappedStream
//  SetSize methods
//
//+----------------------------------------------------------------------------

HRESULT // private
FileStream::SetFileSize( const CULargeInteger &uliNewSize )
{
    HRESULT sc = S_OK;
    CLargeInteger liEOF;

    // We have to convert uliNewSize into a LARGE_INTEGER, so ensure that it can
    // be cast without loss of data.

    liEOF = static_cast<CLargeInteger>(uliNewSize);
    if( liEOF < 0 )
        nffErr( EH_Err, STG_E_INVALIDPARAMETER );

    // Move to what will be the new end-of-file position.

    liEOF.LowPart = SetFilePointer( _hFile, liEOF.LowPart,
                                    &liEOF.HighPart, FILE_BEGIN );
    if( 0xFFFFFFFF == liEOF.LowPart && NO_ERROR != GetLastError() )
        nffErr( EH_Err, HRESULT_FROM_WIN32( GetLastError() ));

    // Set this as the new eof

    if( !SetEndOfFile( _hFile ))
        nffErr( EH_Err, HRESULT_FROM_WIN32( GetLastError() ));

EH_Err:

    return( sc );

}


HRESULT
FileStream::UnlockRegion(
        ULARGE_INTEGER libOffset,
        ULARGE_INTEGER cb,
        DWORD dwLockType)
{
    HRESULT sc = S_OK;

    Lock( INFINITE );

    nffChk( CheckReverted() );

    if (dwLockType != LOCK_EXCLUSIVE && dwLockType != LOCK_ONLYONCE)
    {
        nffErr( EH_Err, STG_E_INVALIDFUNCTION );
    }

    if( !UnlockFile(_hFile, libOffset.LowPart, libOffset.HighPart,
                    cb.LowPart, cb.HighPart))
    {
        nffErr( EH_Err, HRESULT_FROM_WIN32(GetLastError()) );
    }

EH_Err:

    Unlock();
    return( sc );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\object.hpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   Object.hpp
*
* Abstract:
*
*   GpObject interface class
*
* Created:
*
*   4/22/1999 DCurtis
*
\**************************************************************************/

#ifndef _OBJECT_HPP
#define _OBJECT_HPP

// The version must be changed when any EMF+ record is changed, including
// when an object record is changed.
// Changes that invalidate previous files require a major version number change.
// Other changes just require a minor version number change.
#define EMFPLUS_VERSION             0xdbc01001
#define EMFPLUS_MAJORVERSION_BITS   0xFFFFF000
#define EMFPLUS_MINORVERSION_BITS   0x00000FFF

// The GetData methods for all objects must all return a data buffer that
// has a version number as the first INT32 field.
class ObjectData
{
public:
    INT32       Version;

    ObjectData()
    {
        Version = EMFPLUS_VERSION;
    }

    // We should be able to understand the data format as long as the
    // major version numbers match.  The code must be able to handle
    // minor version number changes.
    BOOL MajorVersionMatches() const
    {
        return MajorVersionMatches(Version);
    }

    static BOOL MajorVersionMatches(INT version)
    {
        return ((version & EMFPLUS_MAJORVERSION_BITS) ==
                (EMFPLUS_VERSION & EMFPLUS_MAJORVERSION_BITS));
    }
};

class ObjectTypeData : public ObjectData
{
public:
    INT32       Type;
};

VOID InitVersionInfo();

enum EmfPlusRecordType;
enum ColorAdjustType;
class GpRecolor;

class GpObject
{
public:
    GpObject()
    {
        Uid = 0;
        Tag = ObjectTagInvalid;    // Invalid state
    }

    virtual ~GpObject()
    {
        // Force the object to be invalid so we can't reuse this
        // deleted object accidentally.
        Tag = ObjectTagInvalid;    // Invalid state
    }
    virtual BOOL IsValid() const = 0;
    BOOL IsValid(ObjectTag objectTag) const
    {
    #ifdef _X86_
        // We have to guarantee that the Tag field doesn't move for
        // versioning to work between releases of GDI+.
        ASSERT(offsetof(GpObject, Tag) == 4);
    #endif

        ASSERT((objectTag & 0xff) == '1');

    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid Object");
        }
        else if ((Tag & 0xff) != '1')
        {
            WARNING1("Object created by different version of GDI+")
        }
        else
        {
            ASSERT(objectTag == Tag);
        }
    #endif

        return (objectTag == Tag);
    }
    VOID SetValid(ObjectTag objectTag)
    {
        ASSERT((objectTag == ObjectTagInvalid) || ((objectTag & 0xff) == '1'))
        Tag = objectTag;
    }

    virtual ObjectType GetObjectType() const = 0;
    virtual UINT GetDataSize() const = 0;
    virtual GpStatus GetData(BYTE * dataBuffer, UINT & size) const;
    virtual GpStatus GetData(IStream * stream) const = 0;
    virtual GpStatus SetData(const BYTE * dataBuffer, UINT size) = 0;
    virtual GpStatus ColorAdjust(
        GpRecolor *             recolor,
        ColorAdjustType         type
        )
    {
        return Ok;
    }
    virtual VOID Dispose() { delete this; }

    UINT GetExternalDataSize() const;
    GpStatus GetExternalData(BYTE * dataBuffer, UINT & size);
    GpStatus SetExternalData(const BYTE * data, UINT size);

    UINT GetUid() const
    {   if(Uid == 0)
        {
            Uid = GpObject::GenerateUniqueness();
        }
        return (UINT)Uid;
    }
    VOID UpdateUid() { Uid = 0; }

    // SetUid is useful in cloning operations.
    VOID SetUid(UINT newUid) { Uid = (LONG_PTR)newUid; }

    // Object factory for creating an object from metafile memory
    static GpObject *
    Factory(
        ObjectType          type,
        const ObjectData *  objectData,
        UINT                size
        );

    static LONG_PTR
    GenerateUniqueness(
        )
    {
        LONG_PTR Uid;

        // !!! Until we get a way to make sure GDI+ has been initialized when
        // !!! using it as a static lib, we need this check because if there
        // !!! is a global object, this could get called before
        // !!! InitializeGdiplus() is called (for static lib case).

        if (!Globals::VersionInfoInitialized)
        {
            InitVersionInfo();
        }

        // Use InterlockedCompareExchangeFunction instead of
        // InterlockedIncrement, because InterlockedIncrement doesn't work
        // the way we need it to on Win9x.

        do
        {
            Uid = Uniqueness;
        } while (CompareExchangeLong_Ptr(&Uniqueness, (Uid + 1), Uid) != Uid);

        return (Uid + 1);
    }

private:
    // These members are declared as LONG_PTR because they have to be aligned
    // to, and sized according to the minimum atomically exchangable object.
    // On x86 this is 32bits and on IA64 this is 64bits.
    static LONG_PTR     Uniqueness;

    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!
    mutable LONG_PTR            Uid;
};

#endif // !_OBJECT_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\path.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   path.cpp
*
* Abstract:
*
*   Implementation of the GpPath and DpPath classes
*
* Revision History:
*
*   12/11/1998 davidx
*       Add path functions.
*
*   12/07/1998 davidx
*       Initial placeholders.
*
\**************************************************************************/

#include "precomp.hpp"

//-------------------------------------------------------------
// ReversePath(), CombinePaths(), CalculateGradientArray(), and
// GetMajorAndMinorAxis(), and GetFastAngle are defined in
// PathWidener.cpp.
//-------------------------------------------------------------

extern GpStatus
ReversePath(
    INT count,
    GpPointF* points,
    BYTE* types
    );

extern INT
CombinePaths(
    INT count,
    GpPointF* points,
    BYTE* types,
    INT count1,
    const GpPointF* points1,
    const BYTE* types1,
    BOOL forward1,
    INT count2,
    const GpPointF* points2,
    const BYTE* types2,
    BOOL forward2,
    BOOL connect
    );

extern GpStatus
CalculateGradientArray(
    GpPointF* grad,
    REAL* distances,
    const GpPointF* points,
    INT count
    );

extern GpStatus
GetMajorAndMinorAxis(
    REAL* majorR,
    REAL* minorR,
    const GpMatrix* matrix
    );

VOID NormalizeAngle(REAL* angle, REAL width, REAL height);

INT NormalizeArcAngles(
    REAL* startAngle,
    REAL* sweepAngle,
    REAL width,
    REAL height
    );

// Note that this is different from GpPathData.

class MetaPathData : public ObjectData
{
public:
    UINT32      Count;
    INT32       Flags;
};


/**************************************************************************\
*
* Function Description:
*
*   Get the path data.
*
* Arguments:
*
*   [IN] dataBuffer - fill this buffer with the data
*   [IN/OUT] size   - IN - size of buffer; OUT - number bytes written
*
* Return Value:
*
*   GpStatus - Ok or error code
*
* Created:
*
*   9/13/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpPath::GetData(
    IStream *   stream
    ) const
{
    ASSERT (stream != NULL);

    INT                 count      = Points.GetCount();
    MetafilePointData   pointData(Points.GetDataBuffer(), count);
    UINT                pointsSize = pointData.GetDataSize();
    INT                 flags      = pointData.GetFlags();

    if (FillMode == FillModeWinding)
    {
        flags |= GDIP_EPRFLAGS_WINDINGFILL;
    }

    MetaPathData    pathData;
    pathData.Count = count;
    pathData.Flags = flags;
    stream->Write(&pathData, sizeof(pathData), NULL);

    stream->Write(pointData.GetData(), pointsSize, NULL);
    stream->Write(Types.GetDataBuffer(), count, NULL);

    // align
    if ((count & 0x03) != 0)
    {
        INT     pad = 0;
        stream->Write(&pad, 4 - (count & 0x03), NULL);
    }

    return Ok;
}

UINT
DpPath::GetDataSize() const
{
    INT                 count      = Points.GetCount();
    MetafilePointData   pointData(Points.GetDataBuffer(), count);
    UINT                pointsSize = pointData.GetDataSize();
    UINT                dataSize   = sizeof(MetaPathData) + pointsSize + count;

    return ((dataSize + 3) & (~3)); // align
}

/**************************************************************************\
*
* Function Description:
*
*   Read the path object from memory.
*
* Arguments:
*
*   [IN] memory - the data that was read from the stream
*   [IN] size   - the size of the memory data
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   4/26/1999 DCurtis
*
\**************************************************************************/
GpStatus
DpPath::SetData(
    const BYTE *    dataBuffer,
    UINT            size
    )
{
    Points.Reset();
    Types.Reset();

    if (dataBuffer == NULL)
    {
        WARNING(("dataBuffer is NULL"));
        return InvalidParameter;
    }

    if (size >= sizeof(MetaPathData))
    {
        const MetaPathData *    pathData = reinterpret_cast<const MetaPathData *>(dataBuffer);

        if (!pathData->MajorVersionMatches())
        {
            WARNING(("Version number mismatch"));
            return InvalidParameter;
        }

        InitDefaultState(::GetFillMode(pathData->Flags));
        SetValid(TRUE);

        INT     count = pathData->Count;

        if (count > 0)
        {
            UINT        pointDataSize;

            if ((pathData->Flags & GDIP_EPRFLAGS_COMPRESSED) != 0)
            {
                pointDataSize = count * sizeof(GpPoint16);
            }
            else
            {
                pointDataSize = count * sizeof(GpPointF);
            }

            if (size >= sizeof(MetaPathData) + count + pointDataSize)
            {
                GpPointF *      points = Points.AddMultiple(count);
                BYTE *          types  = Types.AddMultiple(count);
                const BYTE *    typeData;
                const BYTE *    pointData = dataBuffer + sizeof(MetaPathData);

                if ((points != NULL) && (types != NULL))
                {
                    if ((pathData->Flags & GDIP_EPRFLAGS_COMPRESSED) != 0)
                    {
                        BYTE *  tmp = NULL;

                        ::GetPointsForPlayback(
                                pointData,
                                size - (sizeof(MetaPathData) + count),
                                count,
                                pathData->Flags,
                                sizeof(GpPointF) * count,
                                (BYTE *)points,
                                tmp);
                        typeData = pointData + (count * 4);
                    }
                    else
                    {
                        GpMemcpy(points, pointData, count * sizeof(points[0]));
                        typeData = pointData + (count * sizeof(points[0]));
                    }
                    GpMemcpy(types, typeData, count);

                    if (ValidatePathTypes(types, count, &SubpathCount, &HasBezier))
                    {
                        UpdateUid();
                        return Ok;
                    }
                }
            }
            else
            {
                WARNING(("size is too small"));
            }
        }
    }
    else
    {
        WARNING(("size is too small"));
    }

    SetValid(FALSE);
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Construct a new GpPath object using the specified path data
*
* Arguments:
*
*   [IN] points - Point to an array of path points
*   [IN] types - Specify path point types
*   count - Number of path points
*   fillMode - Path fill mode
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

GpPath::GpPath(
    const GpPointF* points,
    const BYTE* types,
    INT count,
    GpFillMode fillMode
    )
{
    SetValid(FALSE);

    // Validate function parameters

    if (count <= 0 ||
        (count > 0 && (!points || !types)) ||
        (fillMode != FillModeAlternate && fillMode != FillModeWinding))
    {
        WARNING(("Invalid path data in GpPath::GpPath"));
        return;
    }

    InitDefaultState(fillMode);

    // Validate path point types

    if (!ValidatePathTypes(types, count, &SubpathCount, &HasBezier))
    {
        WARNING(("Invalid path type information"));
        return;
    }

    // Copy path point and type information

    SetValid(Types.AddMultiple(types, count) == Ok &&
             Points.AddMultiple(points, count) == Ok);

    if(IsValid()) {
        // Make sure the first point is the start type.

        Types.First() = PathPointTypeStart;
    }
}


//--------------------------------
// Constructor for polygon.
//--------------------------------

GpPath::GpPath(
    const GpPointF *points,
    INT count,
    GpPointF *stackPoints,
    BYTE *stackTypes,
    INT stackCount,
    GpFillMode fillMode,
    DpPathFlags flags
    ) : DpPath(points, count, stackPoints, stackTypes, stackCount,
            fillMode, flags)
{
    InvalidateCache();
}

//--------------------------------
// Copy constructor.
//--------------------------------

GpPath::GpPath(const GpPath* path) : DpPath(path)
{
    SetValid(path != NULL);

    InvalidateCache();
}


/**************************************************************************\
*
* Function Description:
*
*   Copies the path data.  Points and Types array in pathData
*   must be allocated by the caller.
*
* Arguments:
*
*   [OUT] pathData - the path data.
*
* Return Value:
*
*   TRUE if successfull.
*
\**************************************************************************/

GpStatus
DpPath::GetPathData(GpPathData* pathData)
{
    if ((!pathData) || (!pathData->Points) || (!pathData->Types) || (pathData->Count < 0))
        return InvalidParameter;

    INT count = GetPointCount();
    const GpPointF* points = GetPathPoints();
    const BYTE* types = GetPathTypes();

    if (pathData->Count >= count)
    {
        if (count > 0)
        {
            GpMemcpy(pathData->Points, points, count*sizeof(GpPointF));
            GpMemcpy(pathData->Types, types, count);
        }

        pathData->Count = count;
        return Ok;
    }
    else
        return OutOfMemory;
}

/**************************************************************************\
*
* Function Description:
*
*   Set a marker at the current location.  You cannot set a marker at the
*   first position.
*
* Arguments:
*
*   None
*
* Return Value:
*
*   Status
*
\**************************************************************************/

GpStatus
GpPath::SetMarker()
{
    INT count = Types.GetCount();
    BYTE* types = Types.GetDataBuffer();

    // Don't set a marker at the first point.

    if(count > 1 && types)
    {
        types[count - 1] |= PathPointTypePathMarker;
        UpdateUid();
    }

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Clears all the markers in the path.
*
* Arguments:
*
*   None
*
* Return Value:
*
*   Status
*
\**************************************************************************/

GpStatus
GpPath::ClearMarkers()
{
    INT count = Types.GetCount();
    BYTE* types = Types.GetDataBuffer();

    BOOL modified = FALSE;

    if(count > 0 && types)
    {
        for(INT i = 0; i < count; i++)
        {
            if(types[i] & PathPointTypePathMarker)
            {
                types[i] &= ~PathPointTypePathMarker;
                modified = TRUE;
            }
        }
    }

    if(modified)
    {
        UpdateUid();
    }

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Set the path data.
*
* Arguments:
*
*   [IN] pathData - the path data.
*
* Return Value:
*
*   TRUE if successfull.
*
\**************************************************************************/

GpStatus
DpPath::SetPathData(const GpPathData* pathData)
{
    if(!pathData || pathData->Count <= 0)
        return InvalidParameter;

    INT count = pathData->Count;
    DpPathIterator iter(pathData->Points, pathData->Types, count);

    if(!iter.IsValid())
        return InvalidParameter;

    Points.Reset(FALSE);
    Types.Reset(FALSE);

    GpPointF* points = Points.AddMultiple(count);
    BYTE* types = Types.AddMultiple(count);

    if(points && types)
    {
        INT number, startIndex, endIndex;
        BOOL isClosed = FALSE;

        while(number = iter.NextSubpath(&startIndex, &endIndex, &isClosed))
        {
            GpMemcpy(
                points,
                pathData->Points + startIndex,
                number*sizeof(GpPointF)
                );
            GpMemcpy(
                types,
                pathData->Types + startIndex,
                number
                );

            points += number;
            types += number;
       }

        SetValid(TRUE);
        HasBezier = iter.HasCurve();
        Flags = PossiblyNonConvex;
        SubpathCount = iter.GetSubpathCount();
        IsSubpathActive = !isClosed;
        UpdateUid();
        return Ok;
    }
    else
        return OutOfMemory;
}

// Determine if the specified points form a rectangle that is axis aligned.
// Do the test in the coordinate space specified by the matrix (if present).
// Covert the REAL values to FIX4 values so that the test is compatible
// with what the rasterizer would do.
// If transformedBounds is not NULL, return the rect (if it is a rect)
// in the transformed (device) space.
BOOL 
IsRectanglePoints(
    const GpPointF* points,
    INT count,
    const GpMatrix * matrix,
    GpRectF * transformedBounds
    )
{
    if(count < 4 || count > 5)
        return FALSE;

    GpPointF    transformedPoints[5];
    
    if ((matrix != NULL) && (!matrix->IsIdentity()))
    {
        matrix->Transform(points, transformedPoints, count);
        points = transformedPoints;
    }
    
    PointFix4   fix4Points[5];
    
    fix4Points[0].Set(points[0].X, points[0].Y);

    if(count == 5)
    {
        fix4Points[4].Set(points[4].X, points[4].Y);

        if(fix4Points[0].X != fix4Points[4].X || fix4Points[0].Y != fix4Points[4].Y)
            return FALSE;
    }

    fix4Points[1].Set(points[1].X, points[1].Y);
    fix4Points[2].Set(points[2].X, points[2].Y);
    fix4Points[3].Set(points[3].X, points[3].Y);

    REAL    maxValue;

    if (fix4Points[0].Y == fix4Points[1].Y)
    {
        if ((fix4Points[2].Y == fix4Points[3].Y) &&
            (fix4Points[0].X == fix4Points[3].X) &&
            (fix4Points[1].X == fix4Points[2].X))
        {
            if (transformedBounds != NULL)
            {
                transformedBounds->X = min(points[0].X, points[1].X);
                maxValue = max(points[0].X, points[1].X);
                transformedBounds->Width = maxValue - transformedBounds->X;

                transformedBounds->Y = min(points[0].Y, points[2].Y);
                maxValue = max(points[0].Y, points[2].Y);
                transformedBounds->Height = maxValue - transformedBounds->Y;
            }
            return TRUE;
        }
    }
    else if ((fix4Points[0].X == fix4Points[1].X) &&
             (fix4Points[2].X == fix4Points[3].X) &&
             (fix4Points[0].Y == fix4Points[3].Y) &&
             (fix4Points[1].Y == fix4Points[2].Y))
    {
        if (transformedBounds != NULL)
        {
            transformedBounds->X = min(points[0].X, points[2].X);
            maxValue = max(points[0].X, points[2].X);
            transformedBounds->Width = maxValue - transformedBounds->X;

            transformedBounds->Y = min(points[0].Y, points[1].Y);
            maxValue = max(points[0].Y, points[1].Y);
            transformedBounds->Height = maxValue - transformedBounds->Y;
        }
        return TRUE;
    }
    return FALSE;
}

BOOL
GpPath::IsRectangle(
    const GpMatrix * matrix,
    GpRectF * transformedBounds
    ) const
{
    if((SubpathCount != 1) || HasBezier)
        return FALSE;

    INT count = GetPointCount();
    GpPointF* points = Points.GetDataBuffer();

    return IsRectanglePoints(points, count, matrix, transformedBounds);
}

BOOL
DpPath::IsRectangle(
    const GpMatrix * matrix,
    GpRectF * transformedBounds
    ) const
{
    if ((GetSubpathCount() != 1) || HasCurve())
        return FALSE;

    INT count = GetPointCount();
    GpPointF* points = Points.GetDataBuffer();

    return IsRectanglePoints(points, count, matrix, transformedBounds);
}

/**************************************************************************\
*
* Function Description:
*
*   Determine if the receiver and path represent the same path
*
* Arguments:
*
*   [IN] path - GpPath to compare
*
* Return Value:
*
*   TRUE if the paths are the same.
*
* Created - 5/27/99 peterost
*
\**************************************************************************/

BOOL GpPath::IsEqual(const GpPath* path) const
{
    if (path == this)
        return TRUE;

    INT    count;

    if (IsValid() == path->IsValid() &&
        (count=GetPointCount()) == path->GetPointCount() &&
        HasBezier == path->HasBezier &&
        FillMode == path->FillMode &&
        Flags == path->Flags &&
        IsSubpathActive == path->IsSubpathActive &&
        SubpathCount == path->SubpathCount)
    {
        BYTE*     types = path->Types.GetDataBuffer();
        BYTE*     mytypes = Types.GetDataBuffer();
        GpPointF* points = path->Points.GetDataBuffer();
        GpPointF* mypoints = Points.GetDataBuffer();

        for (INT i=0; i<count; i++)
        {
            if (types[i] != mytypes[i] ||
                points[i].X != mypoints[i].X ||
                points[i].Y != mypoints[i].Y)
            {
                return FALSE;
            }
        }
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

VOID
GpPath::InitDefaultState(
    GpFillMode fillMode
    )

{
    DpPath::InitDefaultState(fillMode);
    InvalidateCache();
}


/**************************************************************************\
*
* Function Description:
*
*   Validate path point type information
*
* Arguments:
*
*   [IN] types - Point to an array of path point types
*   count - Number of points
*   subpathCount - Return the number of subpaths
*   hasBezier - Return whether the path has Bezier segments
*   [IN] needsFirstPointToBeStartPoint - TRUE if this data needs to start
*                                       with a StartPoint. (Default is TRUE)
*
* Return Value:
*
*   TRUE if the path point type information is valid
*   FALSE otherwise
*
\**************************************************************************/

BOOL
DpPath::ValidatePathTypes(
    const BYTE* types,
    INT count,
    INT* subpathCount,
    BOOL* hasBezier
    )
{
    DpPathTypeIterator iter(types, count);

    if(!iter.IsValid())
    {
        WARNING(("Invalid path type information"));
        return FALSE;
    }

    *subpathCount = iter.GetSubpathCount();
    *hasBezier = iter.HasCurve();

    return iter.IsValid();
}

/**************************************************************************\
*
* Function Description:
*
*   Private helper function to add points to a path object
*
* Arguments:
*
*   [IN] points - Specify the points to be added
*   count - Number of points to add
*
* Return Value:
*
*   Point to location in the point type data buffer
*   that corresponds to the *SECOND* path point added.
*
*   The first point type is always handled inside this
*   function:
*
*   1. If either the previous subpath is closed, or addClosedFigure
*      parameter is TRUE, the first point type will be StartPoint.
*
*   2. Otherwise, the previous subpath is open and addClosedFigure
*      parameter is FALSE. We have two separate cases to handle:
*
*      2.1 if the first point to be added is the same as the last
*          point of the open subpath, then the first point is ignored.
*
*      2.2 otherwise, the first point type will be LinePoint.
*
*   NULL if there is an error. In this case, existing path
*   data is not affected.
*
* Note:
*
*   We assume the caller has already obtained a lock
*   on the path object.
*
\**************************************************************************/

BYTE*
GpPath::AddPointHelper(
    const GpPointF* points,
    INT count,
    BOOL addClosedFigure
    )
{
    // If we're adding a closed figure, then make sure
    // there is no more currently active subpath.

    if (addClosedFigure)
        StartFigure();

    INT origCount = GetPointCount();

    BOOL isDifferentPoint = TRUE;

    // Check if the first point is the same as the last point.

    if(IsSubpathActive && origCount > 0)
    {
        GpPointF lastPt = Points.Last();
        if ((REALABS(points->X - lastPt.X) < REAL_EPSILON) &&
            (REALABS(points->Y - lastPt.Y) < REAL_EPSILON) )
        {
            if(count == 1)
                return NULL;

            // case 2.1 above
            // Skip the first point and its type.

            count--;
            points++;
            isDifferentPoint = FALSE;
        }
    }

    // Resize Points and Types

    GpPointF* pointbuf = Points.AddMultiple(count);
    BYTE* typebuf = Types.AddMultiple(count);

    if(pointbuf == NULL || typebuf == NULL)
    {
        // Resize the original size.

        Points.SetCount(origCount);
        Types.SetCount(origCount);

        return NULL;
    }

    // Record the type of the first point (Start or Line Point).

    if (!IsSubpathActive)
    {
        // case 1 above

        *typebuf++ = PathPointTypeStart;
        SubpathCount++; // Starting a new subpath.
    }
    else
    {
        // If the first point is different, add a Line type.
        // Otherwise, skip the first point and its type.

        if(isDifferentPoint)
        {
            // case 2.2 above

            *typebuf++ = PathPointTypeLine;
        }
    }

    // Copy path point data

    GpMemcpy(pointbuf, points, count*sizeof(GpPointF));

    // Subpath is active if the added figure is not closed.

    if(!addClosedFigure)
        IsSubpathActive = TRUE;

    UpdateUid();
    InvalidateCache();

    // Return the starting location for the new point type data
    // From the second point type.

    return typebuf;
}


/**************************************************************************\
*
* Function Description:
*
*   Add a series of line segments to the current path object
*
* Arguments:
*
*   [IN] points - Specify the line points
*   count - Number of points
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
GpPath::AddLines(
    const GpPointF* points,
    INT count
    )
{
    ASSERT(IsValid());

    // Validate function parameters

    if (points == NULL || count < 1)
        return InvalidParameter;

    InvalidateCache();

    // Call the internal helper function to add the points

    BYTE* types = AddPointHelper(points, count, FALSE);

    if (types == NULL)
    {
        if(count > 1)
            return OutOfMemory;
        else
            return Ok;
    }

    // Set path point type information

    GpMemset(types, PathPointTypeLine, count-1);
//    IsSubpathActive = TRUE;   This is set in AddPointHelper. - ikkof
    UpdateUid();

    return Ok;
}


/**************************************************************************\
*
* Function Description:
*
*   Add rectangles to the current path object
*
* Arguments:
*
*   [IN] rects - Specify the rectangles to be added
*   count - Number of rectangles
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
GpPath::AddRects(
    const GpRectF* rect,
    INT count
    )
{
    if (count < 1 || rect == NULL)
        return InvalidParameter;

    // NOTE: We don't need a lock here because
    //  AddPolygon will handle it.

    // Add one rectangle at a time as a polygon

    GpPointF points[4];
    GpStatus status;

    for ( ; count--; rect++)
    {
        if (rect->IsEmptyArea())
            continue;

        // NOTE: Rectangle points are added in clockwise
        // order, starting from the top-left corner.

        points[0].X = rect->GetLeft();      // top-left
        points[0].Y = rect->GetTop();
        points[1].X = rect->GetRight();     // top-right
        points[1].Y = rect->GetTop();
        points[2].X = rect->GetRight();     // bottom-right
        points[2].Y = rect->GetBottom();
        points[3].X = rect->GetLeft();      // bottom-left
        points[3].Y = rect->GetBottom();

        if ((status = AddPolygon(points, 4)) != Ok)
            return status;
    }

    return Ok;
}

GpStatus
GpPath::AddRects(
    const RECT*     rects,
    INT             count
    )
{
    if ((count < 1) || (rects == NULL))
    {
        return InvalidParameter;
    }

    // NOTE: We don't need a lock here because
    //  AddPolygon will handle it.

    // Add one rectangle at a time as a polygon

    GpPointF points[4];
    GpStatus status;

    for ( ; count--; rects++)
    {
        if ((rects->left >= rects->right) || (rects->top >= rects->bottom))
        {
            continue;
        }

        // NOTE: Rectangle points are added in clockwise
        // order, starting from the top-left corner.

        points[0].X = (REAL)rects->left;        // top-left
        points[0].Y = (REAL)rects->top;
        points[1].X = (REAL)rects->right;       // top-right
        points[1].Y = (REAL)rects->top;
        points[2].X = (REAL)rects->right;       // bottom-right
        points[2].Y = (REAL)rects->bottom;
        points[3].X = (REAL)rects->left;        // bottom-left
        points[3].Y = (REAL)rects->bottom;

        if ((status = AddPolygon(points, 4)) != Ok)
        {
            return status;
        }
    }

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Add a polygon to the current path object
*
* Arguments:
*
*   [IN] Specify the polygon points
*   count - Number of points
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
GpPath::AddPolygon(
    const GpPointF* points,
    INT count
    )
{
    ASSERT(IsValid());

    if (count < 3 || points == NULL)
    {
        return InvalidParameter;
    }

    // Check if the last point is the same as the first point.
    // If so, ignore it.

    if (count > 3 &&
        points[0].X == points[count-1].X &&
        points[0].Y == points[count-1].Y)
    {
        count--;
    }

    // Call the internal helper function to add the points

    BYTE* types = AddPointHelper(points, count, TRUE);

    InvalidateCache();
    
    if (types == NULL)
    {
        return OutOfMemory;
    }

    // Set path point type information

    GpMemset(types, PathPointTypeLine, count-2);
    types[count-2] = PathPointTypeLine | PathPointTypeCloseSubpath;

    UpdateUid();

    return Ok;
}


#define PI          TOREAL(3.1415926535897932)
#define HALF_PI     TOREAL(1.5707963267948966)


/**************************************************************************\
*
* Function Description:
*
*   Convert an angle defined in a box with (width, height) to
*   an angle defined in a square box.
*   In other words, this shrink x- and y-coordinates by width and height,
*   and then calculates the new angle.
*
* Arguments:
*
*   [IN/OUT] angle - the angle is given in degrees and return it in radian.
*   [IN] width  - the width of the box.
*   [IN] height - the height of the box.
*
* Return Value:
*
*   NONE
*
* History:
*
*   02/22/1999 ikkof
*       Created it.
*
\**************************************************************************/

VOID
NormalizeAngle(REAL* angle, REAL width, REAL height)
{
    REAL a = *angle;

    // Set the angle between 0 and 360 degrees.

    a = GpModF(a, 360);

    if(a < 0 || a > 360)
    {
        // The input data may have been too large or loo small
        // to calculate the mode.  In that case, set to 0.

        a = 0;
    }

    if(width != height)
    {
        INT plane = 1;
        REAL b = a;

        if(a <= 90)
            plane = 1;
        else if(a <= 180)
        {
            plane = 2;
            b = 180 - a;
        }
        else if(a <= 270)
        {
            plane = 3;
            b = a - 180;
        }
        else
        {
            plane = 4;
            b = 360 - a;
        }

        b = b*PI/180;   // Convert to radian

        // Get the normalized angle in the plane 1.

        a = TOREAL( atan2(width*sin(b), height*cos(b)) );

        // Adjust to the angle in one of 4 planes.

        switch(plane)
        {
            case 1:
            default:
                break;

            case 2:
                a = PI - a;
                break;

            case 3:
                a = PI + a;
                break;

            case 4:
                a = 2*PI - a;
                break;
        }
    }
    else
    {
        a = a*PI/180;   // Convert to radian.
    }

    *angle = a;
}


/**************************************************************************\
*
* Function Description:
*
*   Convert the start and sweep angles defined in a box with (width, height)
*   to an angle defined in a square box.
*   In other words, this shrink x- and y-coordinates by width and height,
*   and then calculates the new angles.
*
* Arguments:
*
*   [IN/OUT] startAngle - it is given in degrees and return it in radian.
*   [IN/OUT] sweepAngle - it is given in degrees and return it in radian.
*   [IN] width  - the width of the box.
*   [IN] height - the height of the box.
*
* Return Value:
*
*   INT - +1 if sweeping in clockwise and -1 in counterclockwise.
*
* History:
*
*   02/22/1999 ikkof
*       Created it.
*
\**************************************************************************/

INT
NormalizeArcAngles(
    REAL* startAngle,
    REAL* sweepAngle,
    REAL width,
    REAL height
    )
{
    REAL a0 = *startAngle;  // The start angle.
    REAL dA = *sweepAngle;
    REAL a1 = a0 + dA;      // The end angle.
    INT sweepSign;

    if(dA > 0)
        sweepSign = 1;
    else
    {
        sweepSign = - 1;
        dA = - dA;  // Convert to a positive sweep angle.
    }

    // Normalize the start and end angle.

    NormalizeAngle(&a0, width, height);
    NormalizeAngle(&a1, width, height);

    if(dA < 360)
    {
        if(sweepSign > 0)
        {
            dA = a1 - a0;
        }
        else
        {
            dA = a0 - a1;
        }
        if(dA < 0)
            dA += 2*PI;
    }
    else
        dA = 2*PI;  // Don't sweep more than once.

    *startAngle = a0;
    *sweepAngle = dA;

    return sweepSign;
}


/**************************************************************************\
*
* Function Description:
*
*   Convert an elliptical arc to a series of Bezier curve segments
*
* Arguments:
*
*   points - Specify a point buffer for returning Bezier control points
*       The array should be able to hold 13 elements or more.
*   rect - Specify the bounding box for the ellipse
*   startAngle - Start angle (in elliptical space and degrees)
*   sweepAngle - Sweep angle
*       positive to sweep clockwise
*       negative to sweep counterclockwise
*
* Return Value:
*
*   Number of Bezier control points generated
*   0 if sweep angle is 0
*   -1 if bounding rectangle is empty
*
\**************************************************************************/

INT
GpPath::GetArcPoints(
    GpPointF* points,
    const GpRectF& rect,
    REAL startAngle,
    REAL sweepAngle
    )
{
    if (rect.IsEmptyArea())
        return -1;
    else if (sweepAngle == 0)
        return 0;

    // Determine which direction we should sweep
    // and clamp sweep angle to a max of 360 degrees
    // Both start and sweep angles are conveted to radian.

    INT sweepSign = NormalizeArcAngles(
        &startAngle,
        &sweepAngle,
        rect.Width,
        rect.Height);

    // Temporary variables

    REAL dx, dy;
    REAL w2, h2;

    w2 = rect.Width / 2;
    h2 = rect.Height / 2;
    dx = rect.X + w2;
    dy = rect.Y + h2;

    // Determine the number of Bezier segments needed

    int segments, count;
    GpMatrix m;

    segments = (INT) (sweepAngle / HALF_PI);

    if (segments*HALF_PI < sweepAngle)
        segments++;

    if (segments == 0)
        segments = 1;
    else if (segments > 4)
        segments = 4;

    count = segments*3 + 1;

    while (segments--)
    {
        // Compute the Bezier control points in unit-circle space

        REAL A, C, S;
        REAL x, y;

        A = (sweepAngle > HALF_PI) ? HALF_PI/2 : sweepAngle/2;
        C = REALCOS(A);
        S = REALSIN(A);

        x = (4 - C) / 3;
        y = (3 - C) * S / (3 + 3*C);

        if (sweepSign > 0)
        {
            // clockwise sweep

            points[0].X = C;
            points[0].Y = -S;
            points[1].X = x;
            points[1].Y = -y;
            points[2].X = x;
            points[2].Y = y;
            points[3].X = C;
            points[3].Y = S;
        }
        else
        {
            // counterclockwise sweep

            points[0].X = C;
            points[0].Y = S;
            points[1].X = x;
            points[1].Y = y;
            points[2].X = x;
            points[2].Y = -y;
            points[3].X = C;
            points[3].Y = -S;
        }

        // Transform the control points to elliptical space

        m.Reset();
        m.Translate(dx, dy);
        m.Scale(w2, h2);
        REAL theta = (startAngle + sweepSign*A)*180/PI;
        m.Rotate(theta);    // Rotate takes degrees.

        if(segments > 0)
            m.Transform(points, 3);
        else
            m.Transform(points, 4); // Include the last point.

        if(sweepSign > 0)
            startAngle += HALF_PI;
        else
            startAngle -= HALF_PI;
        sweepAngle -= HALF_PI;
        points += 3;
    }

    return count;
}


/**************************************************************************\
*
* Function Description:
*
*   Add an elliptical arc to the current path object
*
* Arguments:
*
*   rect - Specify the bounding rectangle for the ellipse
*   startAngle - Starting angle for the arc
*   sweepAngle - Sweep angle for the arc
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
GpPath::AddArc(
    const GpRectF& rect,
    REAL startAngle,
    REAL sweepAngle
    )
{
    GpPointF points[13];
    INT count;
    BOOL isClosed = FALSE;

    if(sweepAngle >= 360)
    {
        sweepAngle = 360;
        isClosed = TRUE;
    }
    else if(sweepAngle <= - 360)
    {
        sweepAngle = - 360;
        isClosed = TRUE;
    }

    // Convert arc to Bezier curve segments

    count = GetArcPoints(points, rect, startAngle, sweepAngle);

    // Add resulting Bezier curve segment to the path

    GpStatus status = Ok;

    if(count > 0)
    {
        AddBeziers(points, count);
        if(isClosed)
            CloseFigure();
    }
    else if(count < 0)
        status = InvalidParameter;

    InvalidateCache();

    return status;
}


/**************************************************************************\
*
* Function Description:
*
*   Add an ellipse to the current path object
*
* Arguments:
*
*   rect - Bounding rectangle for the ellipse
*
* Return Value:
*
*   Status code
*
* History:
*
*   02/22/1999 ikkof
*       Defined an array of a circle with radius 1 and used it.
*
\**************************************************************************/

GpStatus
GpPath::AddEllipse(
    const GpRectF& rect
    )
{
    GpPointF points[13];
    INT count = 13;
    REAL u_cir = 4*(REALSQRT(2.0) - 1)/3;
    GpPointF center;
    REAL    wHalf, hHalf;

    wHalf = rect.Width/2;
    hHalf = rect.Height/2;
    center.X = rect.X + wHalf;
    center.Y = rect.Y + hHalf;

    // 4 Bezier segment of a circle with radius 1.

    points[ 0].X = 1;       points[ 0].Y = 0;
    points[ 1].X = 1;       points[ 1].Y = u_cir;
    points[ 2].X = u_cir;   points[ 2].Y = 1;
    points[ 3].X = 0;       points[ 3].Y = 1;
    points[ 4].X = -u_cir;  points[ 4].Y = 1;
    points[ 5].X = -1;      points[ 5].Y = u_cir;
    points[ 6].X = -1;      points[ 6].Y = 0;
    points[ 7].X = -1;      points[ 7].Y = -u_cir;
    points[ 8].X = -u_cir;  points[ 8].Y = -1;
    points[ 9].X = 0;       points[ 9].Y = -1;
    points[10].X = u_cir;   points[10].Y = -1;
    points[11].X = 1;       points[11].Y = -u_cir;
    points[12].X = 1;       points[12].Y = 0;

    // Scale to the appropriate size.

    for(INT i = 0; i < count; i++)
    {
        points[i].X = points[i].X*wHalf + center.X;
        points[i].Y = points[i].Y*hHalf + center.Y;
    }

    // Add resulting Bezier curve segments to the path

    GpStatus status;

    StartFigure();
    status = AddBeziers(points, count);
    CloseFigure();

    InvalidateCache();
    UpdateUid();

    return status;
}


/**************************************************************************\
*
* Function Description:
*
*   Add an elliptical pie to the current path object
*
* Arguments:
*
*   rect - Bounding rectangle for the ellipse
*   startAngle - Specify the starting angle for the pie
*   sweepAngle - Sweep angle for the pie
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
GpPath::AddPie(
    const GpRectF& rect,
    REAL startAngle,
    REAL sweepAngle
    )
{
    GpPointF pt;

    StartFigure();

    // Add the center point.

    pt.X = rect.X + rect.Width/2;
    pt.Y = rect.Y + rect.Height/2;
    GpStatus status = AddLines(&pt, 1);

    // Add the arc points.

    if(status == Ok)
        status = AddArc(rect, startAngle, sweepAngle);

    CloseFigure();

    InvalidateCache();
    UpdateUid();

    return status;
}


/**************************************************************************\
*
* Function Description:
*
*   Add Bezier curve segments to the current path object
*
* Arguments:
*
*   [IN] points - Specify Bezier control points
*   count - Number of points
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
GpPath::AddBeziers(
    const GpPointF* points,
    INT count
    )
{
    // Number of points must be 3 * N + 1
    if ((!points) || (count < 4) || (count % 3 != 1))
    {
    	return InvalidParameter;
    }

    // Check if the first point is the same as the last point.
    INT firstType;
    INT origCount = GetPointCount();

    if(!IsSubpathActive)
    {
        SubpathCount++; // Starting a new subpath.
        firstType = PathPointTypeStart;
    }
    else
    {
        if (origCount > 0)
        {
            GpPointF lastPt = Points.Last();
            if ((REALABS(points[0].X - lastPt.X) < REAL_EPSILON) &&
                (REALABS(points[0].Y - lastPt.Y) < REAL_EPSILON))
            {
                firstType = -1; // Indicating no copying of the first point.
                points++;
                count--;
            }
            else
            {
                firstType = PathPointTypeLine;
            }
        }
        else
        {
            SubpathCount++;
            firstType = PathPointTypeStart;
        }
    }

    // Resize Points and Types
    GpPointF* pointBuf = Points.AddMultiple(count);
    BYTE* typeBuf = Types.AddMultiple(count);

    if(pointBuf == NULL || typeBuf == NULL)
    {
        // Resize the original size.

        Points.SetCount(origCount);
        Types.SetCount(origCount);

        return OutOfMemory;
    }

    GpMemcpy(pointBuf, points, count * sizeof(GpPointF));
    GpMemset(typeBuf, PathPointTypeBezier, count);
    
    if(firstType == PathPointTypeStart)
        typeBuf[0] = PathPointTypeStart;
    else if(firstType == PathPointTypeLine)
        typeBuf[0] = PathPointTypeLine;

    IsSubpathActive = TRUE;
    HasBezier = TRUE;

    InvalidateCache();
    UpdateUid();

    return Ok;
}

GpStatus
GpPath::AddBezier(
    const GpPointF& pt1,
    const GpPointF& pt2,
    const GpPointF& pt3,
    const GpPointF& pt4
    )
{
    GpPointF points[4];

    points[0] = pt1;
    points[1] = pt2;
    points[2] = pt3;
    points[3] = pt4;

    return AddBeziers(points, 4);
}

GpStatus
GpPath::AddBezier(
    REAL x1, REAL y1,
    REAL x2, REAL y2,
    REAL x3, REAL y3,
    REAL x4, REAL y4
    )
{
    GpPointF points[4];

    points[0].X = x1;
    points[0].Y = y1;
    points[1].X = x2;
    points[1].Y = y2;
    points[2].X = x3;
    points[2].Y = y3;
    points[3].X = x4;
    points[3].Y = y4;

    return AddBeziers(points, 4);
}


/**************************************************************************\
*
* Function Description:
*
*   Add a path to the current path object.
*   When connect is TRUE, this combine the end point of the current
*   path and the start point of the given path if both paths are
*   open.
*   If either path is closed, the two paths will not be connected
*   even if connect is set to TRUE.
*
* Arguments:
*
*   [IN] points - Specify a subpath points
*   [IN] types - Specify a subpath control types.
*   [IN] count - Number of points
*   [IN] connect - TRUE if two open paths needs to be connected.
*
* Return Value:
*
*   Status code
*
*   02/09/2000 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpPath::AddPath(
    const GpPointF* points,
    const BYTE* types,
    INT count,
    BOOL connect
    )
{
    GpStatus status = Ok;
    
    if(points == NULL || types == NULL || count <= 0)
    {
        return InvalidParameter;
    }

    INT count1 = GetPointCount();
    INT count2 = count;
    const GpPointF* points2 = points;
    const BYTE* types2 = types;

    INT totalCount = count1 + count2;
    BOOL forward1 = TRUE, forward2 = TRUE;

    status = Points.ReserveSpace(count2);
    
    if(status != Ok)
    {
        return status;
    }
    
    status = Types.ReserveSpace(count2);
    
    if(status != Ok)
    {
        return status;
    }
    
    GpPointF* outPoints = Points.GetDataBuffer();
    BYTE* outTypes = Types.GetDataBuffer();
    const GpPointF* points1 = outPoints;
    const BYTE* types1 = outTypes;

    totalCount = CombinePaths(
        totalCount, 
        outPoints,
        outTypes,
        count1, 
        points1, 
        types1, 
        forward1,
        count2, 
        points2, 
        types2, 
        forward2,
        connect
    );

    if( (totalCount >= count1) &&
        ValidatePathTypes(outTypes, totalCount, &SubpathCount, &HasBezier))
    {
        count2 = totalCount - count1;
        Points.AdjustCount(count2);
        Types.AdjustCount(count2);
        
        // Turn on the active subpath so that we can connect lines to this
        // path.
        // In order to not connect, call CloseFigure after adding.
        
        IsSubpathActive = !IsClosedType(Types[Types.GetCount()-1]);
        
        InvalidateCache();
        UpdateUid();

        return Ok;
    }
    else
    {
        return InvalidParameter;
    }
}

GpStatus
GpPath::AddPath(const GpPath* path, BOOL connect)
{
    if(!path)
    {
        return InvalidParameter;
    }

    INT count2 = path->GetPointCount();
    const GpPointF* points2 = path->GetPathPoints();
    const BYTE* types2 = path->GetPathTypes();

    return AddPath(points2, types2, count2, connect);
}

/**************************************************************************\
*
* Function Description:
*
* Reverse the direction of the path.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   Status code
*
*   02/09/2000 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpPath::Reverse()
{
    if(!IsValid())
        return InvalidParameter;

    INT count = GetPointCount();
    GpPointF* points = Points.GetDataBuffer();
    BYTE* types = Types.GetDataBuffer();

    GpStatus status = Ok;

    if(count > 1)
        status = ::ReversePath(count, points, types);
    UpdateUid();

    return status;
}

GpStatus
GpPath::GetLastPoint(GpPointF* lastPoint)
{
    INT count = GetPointCount();
    if(count <= 0 || lastPoint == NULL)
        return InvalidParameter;

    GpPointF* points = Points.GetDataBuffer();

    // Return the last point.

    *lastPoint = points[count - 1];

    return Ok;
}

GpPath*
GpPath::GetOpenPath()
{
    BOOL openPath = TRUE;
    return GetOpenOrClosedPath(openPath);
}

GpPath*
GpPath::GetClosedPath()
{
    BOOL openPath = FALSE;
    return GetOpenOrClosedPath(openPath);
}

GpPath*
GpPath::GetOpenOrClosedPath(BOOL openPath)
{
    INT startIndex, endIndex;
    BOOL isClosed;
    const GpPointF* points = Points.GetDataBuffer();
    const BYTE* types = Types.GetDataBuffer();

    DpPathIterator iter(points, types, GetPointCount());

    GpPath* path = new GpPath(FillMode);

    if(path)
    {
        INT segmentCount = 0;
        while(iter.NextSubpath(&startIndex, &endIndex, &isClosed))
        {
            if(isClosed != openPath)
            {
//                path->AddSubpath(points + startIndex, types + startIndex,
//                        endIndex - startIndex + 1);

                BOOL connect = FALSE;
                path->AddPath(points + startIndex, types + startIndex,
                        endIndex - startIndex + 1, connect);
                segmentCount++;
            }
        }

        if(segmentCount == 0)
        {
            delete path;
            path = NULL;
        }
    }

    return path;
}


/**************************************************************************\
*
* Function Description:
*
*   Add an open cardinal spline curve to the current path object
*
* Arguments:
*
*   [IN] points - Specify the spline points
*   count - Number of points
*   tension - Tension parameter
*   offset - Index of the first point we're interested in
*   numberOfSegments - Number of curve segments
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

#define DEFAULT_TENSION 0.5

GpStatus
GpPath::AddCurve(
    const GpPointF* points,
    INT count,
    REAL tension,
    INT offset,
    INT numberOfSegments
    )
{
    // Verify input parameters

    if (points == NULL ||
        count < 2 ||
        offset < 0 ||
        offset >= count ||
        numberOfSegments < 1 ||
        numberOfSegments >= count-offset)
    {
        return InvalidParameter;
    }

    // Convert spline points to Bezier control points

    GpPointF* bezierPoints;
    INT bezierCount;

    bezierPoints = ConvertSplineToBezierPoints(
                        points,
                        count,
                        offset,
                        numberOfSegments,
                        tension,
                        &bezierCount);

    if (bezierPoints == NULL)
        return OutOfMemory;

    // Add the resulting Bezier segments to the current path

    GpStatus status;

    status = AddBeziers(bezierPoints, bezierCount);
    delete[] bezierPoints;

    return status;
}

GpStatus
GpPath::AddCurve(
    const GpPointF* points,
    INT count
    )
{
    return AddCurve(points,
                    count,
                    DEFAULT_TENSION,
                    0,
                    count-1);
}


/**************************************************************************\
*
* Function Description:
*
*   Add a closed cardinal spline curve to the current path object
*
* Arguments:
*
*   [IN] points - Specify the spline points
*   count - Number of points
*   tension - Tension parameter
*
* Return Value:
*
*   Status code
*
\**************************************************************************/

GpStatus
GpPath::AddClosedCurve(
    const GpPointF* points,
    INT count,
    REAL tension
    )
{
    // Verify input parameters

    if (points == NULL || count <= 2)
        return InvalidParameter;

    // Convert spline points to Bezier control points

    GpPointF* bezierPoints;
    INT bezierCount;

    bezierPoints = ConvertSplineToBezierPoints(
                        points,
                        count,
                        0,
                        count,
                        tension,
                        &bezierCount);

    if (bezierPoints == NULL)
        return OutOfMemory;

    // Add the resulting Bezier segments as a closed curve

    GpStatus status;

    StartFigure();
    status = AddBeziers(bezierPoints, bezierCount);
    CloseFigure();

    delete[] bezierPoints;

    InvalidateCache();
    UpdateUid();

    return status;
}

GpStatus
GpPath::AddClosedCurve(
    const GpPointF* points,
    INT count
    )
{
    return AddClosedCurve(points, count, DEFAULT_TENSION);
}


/**************************************************************************\
*
* Function Description:
*
*   Convert cardinal spline curve points to Bezier curve control points
*
* Arguments:
*
*   [IN] points - Array of spline curve points
*   count - Number of points in the "points" array
*   offset - Specify the index of the first control point in
*       the "points" array that the curve should start from
*   numberOfSegments - Specify the number of curve segments to draw
*   tension - Specify the tension parameter
*   bezierCount - Return the number of Bezier control points
*
* Return Value:
*
*   Pointer to an array of Bezier control points
*   NULL if there is an error
*
* Reference:
*
*   Spline Tutorial Notes
*   Technical Memo No. 77
*   Alvy Ray Smith
*   Presented as tutorial notes at the 1983 SIGGRAPH, July 1983
*   and the SIGGRAPH, July 1984
*
* Notes:
*
*   Support for cardinal spline curves
*
*   Cardinal splines are local interpolating splines, i.e. they
*   pass through their control points and they maintain
*   first-order continuity at their control points.
*
*   a cardinal spline is specified by three parameters:
*       a set of control points P1, ..., Pn
*       tension parameter a
*       close flag
*
*   If n is 1, then the spline degenerates into a single point P1.
*   If n > 1 and the close flag is false, the spline consists of
*   n-1 cubic curve segments. The first curve segment starts from
*   P1 and ends at P2. The last segment starts at Pn-1 and ends at Pn.
*
*   The cubic curve segment from Pi to Pi+1 is determined by
*   4 control points:
*       Pi-1 = (xi-1, yi-1)
*       Pi = (xi, yi)
*       Pi+1 = (xi+1, yi+1)
*       Pi+2 = (xi+2, yi+2)
*
*   The parametric equation is defined as:
*
*       [ X(t) Y(t) ] = [t^3 t^2 t 1] * M * [ xi-1 yi-1 ]
*                                           [ xi   yi   ]
*                                           [ xi+1 yi+1 ]
*                                           [ xi+2 yi+2 ]
*
*   where t ranges from 0 to 1 and M is a 4x4 matrix satisfying
*   the following constraints:
*
*       X(0) = xi               interpolating through control points
*       X(1) = xi+1
*       X'(0) = a(xi+1 - xi-1)  first-order continuity
*       X'(1) = a(xi+2 - xi)
*
*   In the case of segments from P1 to P2 and from Pn-1 to Pn,
*   we replicate the first and last control points, i.e. we
*   define P0 = P1 and Pn+1 = Pn.
*
*   If the close flag is true, we have an additional curve segment
*   from Pn to Pn+1 = P1. For the segments near the beginning and
*   the end of the spline, we wrap around the control points, i.e.
*   P0 = Pn, Pn+1 = P1, and Pn+2 = P2.
*
\**************************************************************************/

GpPointF*
GpPath::ConvertSplineToBezierPoints(
    const GpPointF* points,
    INT count,
    INT offset,
    INT numberOfSegments,
    REAL tension,
    INT* bezierCount
    )
{
    BOOL closed;
    GpPointF* bezierPoints;

    ASSERT(count > 1 &&
           offset >= 0 &&
           offset < count &&
           numberOfSegments > 0 &&
           numberOfSegments <= count-offset);

    // Curve is closed if the number of segments is equal to
    // the number of curve points

    closed = (numberOfSegments == count);

    // Allocate memory to hold Bezier control points

    *bezierCount = numberOfSegments*3 + 1;
    bezierPoints = new GpPointF[*bezierCount];

    if (bezierPoints == NULL)
        return NULL;

    // Convert each spline segment to a Bezier segment
    // resulting in 3 additional Bezier points

    GpPointF buffer[4], *q;
    const GpPointF* p;
    REAL a3;

    a3 = tension / 3;
    q = bezierPoints;
    *q = points[offset];

    for (INT index=offset; index < offset+numberOfSegments; index++)
    {
        if (index > 1 && index < count-2)
            p = points + (index-1);
        else
        {
            // Points near the beginning and end of the curve
            // require special attention

            if (closed)
            {
                // If the curve is closed, make sure the control points
                // wrap around the beginning and end of the array.

                buffer[0] = points[(index-1+count) % count];
                buffer[1] = points[index];
                buffer[2] = points[(index+1) % count];
                buffer[3] = points[(index+2) % count];
            }
            else
            {
                // If the curve is not closed, replicate the first
                // and last point in the array.

                buffer[0] = points[(index > 0) ? (index-1) : 0];
                buffer[1] = points[index];
                buffer[2] = points[(index+1 < count) ? (index+1) : (count-1)];
                buffer[3] = points[(index+2 < count) ? (index+2) : (count-1)];
            }

            p = buffer;
        }

        q[1].X = -a3*p[0].X + p[1].X + a3*p[2].X;
        q[1].Y = -a3*p[0].Y + p[1].Y + a3*p[2].Y;
        q[2].X =  a3*p[1].X + p[2].X - a3*p[3].X;
        q[2].Y =  a3*p[1].Y + p[2].Y - a3*p[3].Y;
        q[3] = p[2];

        q += 3;
    }

    return bezierPoints;
}


/**************************************************************************\
*
* Function Description:
*
*   Transform all path points by the specified matrix
*
* Arguments:
*
*   matrix - Transform matrix
*
* Return Value:
*
*   NONE
*
* Created:
*
*   02/08/1999 ikkof
*       Created it.
*
\**************************************************************************/

VOID
GpPath::Transform(
    const GpMatrix *matrix
    )
{
    ASSERT(IsValid());

    if(matrix)
    {
        INT count = GetPointCount();
        GpPointF* points = Points.GetDataBuffer();

        matrix->Transform(points, count);
        UpdateUid();
        InvalidateCache();
    }
}

// Debug only.

#if DBG
void DpPath::DisplayPath() {
    INT size = GetPointCount();

    const GpPointF *points = GetPathPoints();
    const BYTE *types = GetPathTypes();

    for(int i=0; i<size; i++)
    {
        WARNING(("points[%d].X = %ff;", i, points[i].X));
        WARNING(("points[%d].Y = %ff;", i, points[i].Y));
        WARNING(("types[%d] = 0x%x;", i, types[i]));
    }
}
#endif



/**************************************************************************\
*
* Function Description:
*
*   Callback to accumulate the flattened edges that the Rasterizer emits.
*
* Arguments:
*
*    VOID *context,        // pointer to the resulting path.
*    POINT *pointArray,    // Points to a 28.4 array of size 'vertexCount'
*    INT vertexCount,      // number of points to add.
*    BOOL lastSubpath      // The last point in this array is the last point
*                          // in a closed subpath.
*
* Return Value:
*   BOOL
*
* History:
*
*  10/25/2000  asecchia & ericvan
*       Created it.
*
\**************************************************************************/

BOOL PathFlatteningCallback(
    VOID *context,
    POINT *pointArray,    // Points to a 28.4 array of size 'vertexCount'
                          //   Note that we may modify the contents!
    INT vertexCount,
    PathEnumerateTermination lastSubpath      // Last point in the subpath.
    )
{
    GpPath *result = static_cast<GpPath*>(context);
    GpPointF *pointcast = (GpPointF*)(pointArray);
    
    INT count = vertexCount;
    
    // Don't add the last point if it's closed because the rasterizer 
    // emitted it twice - once for the first point.
    
    if(lastSubpath == PathEnumerateCloseSubpath)
    {
        count--;
    }
    
    for(INT i = 0; i < count; i++)
    {
        // Convert the point array to real in place.
        
        pointcast[i].X = FIX4TOREAL(pointArray[i].x);
        pointcast[i].Y = FIX4TOREAL(pointArray[i].y);
    }
    
    // Add all the edges to the path as lines.
    
    GpStatus status = result->AddLines(pointcast, count);
    
    if(status == Ok)
    {
        if(lastSubpath == PathEnumerateCloseSubpath)
        {
            // last point in a subpath - close it.
            status = result->CloseFigure();
        }
        if(lastSubpath == PathEnumerateEndSubpath)
        {
            // last point in an open subpath.
            result->StartFigure();
        }
    }
    
    return (status == Ok);
}

/**************************************************************************\
*
* Function Description:
*
*   Flatten the path. The input matrix is the world to device transform.
*   Our rasterizer will flatten at about 2/3 of a device pixel. In order
*   to handle different flatness tolerances, we scale the path proportionally
*   and pretend that it is bigger when we give it to the rasterizer for 
*   flattening. It flattens at 2/3 of a device pixel in this mocked up 
*   device space and we undo the flatness scale effectively redefining what
*   size a device pixel is. This allows us to flatten to an arbitrary
*   flatness tolerance.
*
* Arguments:
*
*   [IN] matrix -   Specifies the transform
*                   When matrix is NULL, the identity matrix is used.
*   [IN] flatness - the flattening tolerance
*
* Return Value:
*
*   Status
*
* Created:
*
*   10/25/2000  asecchia & ericvan
*       Created it.
*
\**************************************************************************/

GpStatus
GpPath::Flatten(
    DynByteArray *flattenTypes,
    DynPointFArray *flattenPoints,
    const GpMatrix *matrix,
    const REAL flatness
    ) const
{
    // Enumerate the path.

    FIXEDPOINTPATHENUMERATEFUNCTION pathEnumerationFunction = PathFlatteningCallback;

    GpPath result;

    // Calculate the scale - multiply by 16 for the rasterizer's 28.4 fixed
    // point math. This 16x transform is implicitly reversed as we accumulate 
    // the points from the rasterizer in our callback function
    
    REAL deviceFlatness = flatness/FlatnessDefault;
    REAL flatnessInv = (16.0f)/deviceFlatness;
    
    GpMatrix transform;
    
    if(matrix)
    {
        transform = *matrix;
    }
    
    // apply the flatness transform so that we rasterize at an appropriately
    // scaled resolution. We undo this part of the transform (not the 16x) 
    // at the end of this function.
    
    transform.AppendScale(flatnessInv, flatnessInv);
    

    // Do it.
    
    if (!FixedPointPathEnumerate(
        this, 
        &transform, 
        NULL,
        PathEnumerateTypeFlatten,   // don't automatically close open subpaths.
        pathEnumerationFunction, 
        &result
    ))
    {
         return(OutOfMemory);
    }

    // undo the implicit flatness transform.
    
    transform.Reset();
    transform.Scale(deviceFlatness, deviceFlatness);
    result.Transform(&transform);

    // Copy the points over. We should be using a detach on the DynArrays
    // because we're throwing the temporary one away.

    flattenPoints->Reset(FALSE);
    flattenTypes->Reset(FALSE);
    flattenPoints->AddMultiple(result.GetPathPoints(), result.GetPointCount());
    flattenTypes->AddMultiple(result.GetPathTypes(), result.GetPointCount());
    
    return Ok;
}

GpStatus
GpPath::Flatten(
    const GpMatrix *matrix,
    const REAL flatness
    )
{
    GpStatus status = Ok;
    
    // Only flatten if it has beziers.
    
    if(HasBezier)
    {
        DynPointFArray flattenPoints;
        DynByteArray flattenTypes;
        
        status = Flatten(
            &flattenTypes,
            &flattenPoints,
            matrix,
            flatness
        );
        
        if(status==Ok)
        {
            // Copy the points over. We should be using a detach on the DynArrays
            // because we're throwing the temporary one away.
        
            Points.ReplaceWith(&flattenPoints);
            Types.ReplaceWith(&flattenTypes);
            
            // Update to reflect the changed state of the path.
            
            HasBezier = FALSE;
            InvalidateCache();
            UpdateUid();
        }
    }
    else
    {
        // Flatten transforms the path even if it's already flat.
        // Note: Transform(NULL) <=> Identity transform which is a NOP.
        
        Transform(matrix);
    }

    return status;
}


/**************************************************************************\
*
* Function Description:
*
* Warp and flattens the control points and stores
* the results to the arrays of the flatten points.
*
* Arguments:
*
*   [IN] matrix - Specifies the transform
*   [IN] destPoint - The destination quad.
*   [IN] count - the number of the quad points (3 or 4).
*   [IN] srcRect - the original rectangle to warp.
*   [IN] warpMode - Perspective or Bilinear (default is Bilinear).
*
* Return Value:
*
*   Status
*
* Created:
*
*   11/10/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpPath::WarpAndFlatten(
    DynByteArray* flattenTypes,
    DynPointFArray* flattenPoints,
    const GpMatrix* matrix,
    const GpPointF* destPoint,
    INT count,
    const GpRectF& srcRect,
    WarpMode warpMode
    )
{
    GpXPath xpath(this, srcRect, destPoint, count, warpMode);

    return xpath.Flatten(flattenTypes, flattenPoints, matrix);
}

/**************************************************************************\
*
* Function Description:
*
* Warps and flattens the control points and transform itself to
* the flatten path.
*
* Arguments:
*
*   [IN] matrix - Specifies the transform
*                   The identity matrix is used when matrix is NULL.
*   [IN] destPoint - The destination quad.
*   [IN] count - the number of the quad points (3 or 4).
*   [IN] srcRect - the original rectangle to warp.
*   [IN] warpMode - Perspective or Bilinear (default is Bilinear).
*
* Return Value:
*
*   Status
*
* Created:
*
*   11/10/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpPath::WarpAndFlattenSelf(
    GpMatrix* matrix,
    const GpPointF* destPoint,
    INT count,
    const GpRectF& srcRect,
    WarpMode warpMode
    )
{
    GpMatrix identity;   // Identity matrix

    GpXPath xpath(this, srcRect, destPoint, count, warpMode);

    const INT bufferSize = 32;
    BYTE typesBuffer[bufferSize];
    GpPointF pointsBuffer[bufferSize];

    DynByteArray flattenTypes(&typesBuffer[0], bufferSize);
    DynPointFArray flattenPoints(&pointsBuffer[0], bufferSize);

    if(matrix == NULL)
        matrix = &identity; // Use the identity matrix

    GpStatus status = xpath.Flatten(&flattenTypes, &flattenPoints, matrix);

    if(status == Ok)
    {
        INT flattenCount = flattenPoints.GetCount();
        Points.Reset(FALSE);
        Types.Reset(FALSE);
        Points.AddMultiple(flattenPoints.GetDataBuffer(), flattenCount);
        Types.AddMultiple(flattenTypes.GetDataBuffer(), flattenCount);
        HasBezier = FALSE;

        UpdateUid();
        InvalidateCache();
    }

    return status;
}

/**************************************************************************\
*
* Function Description:
*  
*   convert a 2 segment closed subpath emitted by the region conversion
*   to a correct winding path.
*
* Arguments:
*
*   [IN] p - the path.
*
* Created:
*
*   09/21/2000 asecchia
*       Created it.
*
\**************************************************************************/

struct PathBound
{
    REAL xmin;
    REAL ymin;
    REAL xmax;
    REAL ymax;
    INT count;
    GpPointF *points;
    BYTE *types;
    bool reverse;
    
    void Init(INT c, GpPointF *p, BYTE *t)
    {
        reverse = false;
        points = p;
        types = t;
        count = c;
    }
};

void ComputeBoundingBox(
    GpPathPointIterator &i, 
    PathBound *p
)
{
    GpPointF *point = i.CurrentItem();
    p->xmax = p->xmin = point->X;
    p->ymax = p->ymin = point->Y;
    
    while(!i.IsDone())
    {
        point = i.CurrentItem();
        if(point->X < p->xmin) { p->xmin = point->X; }
        if(point->X > p->xmax) { p->xmax = point->X; }
        if(point->Y < p->ymin) { p->ymin = point->Y; }
        if(point->Y > p->ymax) { p->ymax = point->Y; }
        i.Next();
    }
}

bool Contains(PathBound &pb1, PathBound &pb2)
{
    return ( 
        (pb1.xmin <= pb2.xmin) &&
        (pb1.ymin <= pb2.ymin) &&
        (pb1.xmax >= pb2.xmax) &&
        (pb1.ymax >= pb2.ymax)     
    );
}

void ConvertRegionOutputToWinding(GpPath **p)
{
    ASSERT(*p);
    
    GpPathPointIterator iPoints(
        (GpPointF*)(*p)->GetPathPoints(),
        (BYTE*)(*p)->GetPathTypes(),
        (*p)->GetPointCount()
    );
    
    GpSubpathIterator iSubpath(&iPoints);
    
    GpPointF *points;
    BYTE *types;
    INT count;
    GpPath *ret = new GpPath(FillModeWinding);
    
    // if we're out of memory, simply give them back their path.
    
    if(!ret) { return; }
    
    GpPath *sub;
    DynArray<PathBound> bounds;
    PathBound pb;
    
    // Iterate through all the subpaths culling information for the following
    // algorithm. This is O(n) in the number of points. 
    // The information we need is the starting point for each subpath and
    // the bounding box.
    
    while(!iSubpath.IsDone())
    {
        count = -iSubpath.CurrentIndex();
        points = iSubpath.CurrentItem();
        types = iSubpath.CurrentType();
        iSubpath.Next();
        count += iSubpath.CurrentIndex();
        
        GpPathPointIterator iSubpathPoint( points, types, count );
        
        pb.Init(count, points, types);
        ComputeBoundingBox( iSubpathPoint, &pb );
        bounds.Add(pb);
    }
    
    // Double loop through all the subpaths figuring out the containment 
    // relationships.
    // For every level of containment, flip the reverse bit.
    // E.g. for a subpath that's contained by 5 other rectangles, start at
    // false and apply 5x(!)   !!!!!false == true  which means flip this path.
    // this is O(n^2) in the number of subpaths.
    
    count = bounds.GetCount();
    int i, j;
    
    for(i=1; i<count; i++)
    {
        for(j=i-1; j>=0; j--)
        {
            if(Contains(bounds[i], bounds[j]))
            {
                bounds[j].reverse = !bounds[j].reverse;
                continue;
            }
            
            if(Contains(bounds[j], bounds[i]))
            {
                bounds[i].reverse = !bounds[i].reverse;
            }
        }
    }
    
    // Now reverse all the subpaths that need to be reversed.
    // Accumulate the results into the array.
    
    for(i=0; i<count; i++)
    {
        sub = new GpPath(
            bounds[i].points, 
            bounds[i].types, 
            bounds[i].count
        );
        
        if(!sub)
        {
            // if we failed to make our temporary path, stop and return
            // what we've accumulated so far.
            
            WARNING(("ran out of memory accumulating the path"));
            break;
        }
        
        if(bounds[i].reverse)
        {
            sub->Reverse();
        }
        
        ret->AddPath(sub, FALSE);
        
        delete sub;
    }
    
    delete *p;
    *p = ret;
}

/**************************************************************************\
*
* Function Description:
*  
*   GetWidenedPath. Returns a widened version of the path. The path is widened
*   according to the pen and the result is transformed according to the input
*   matrix. When flattening the path the matrix is used as the world to device
*   transform and the flatness tolerance is applied.
*
*   This function handles inset and outset pen alignments.
*
* Arguments:
*
*   [IN] pen      - pen - specifies width for widening
*   [IN] matrix   - world to device transform.
*   [IN] flatness - number of device pixels of error allowed for flattening
*
* Return:
*   
*   GpPath *      - widened path. NULL on failure.
*                 - !!! this should return the path in an OUT parameter and
*                 -     propagate the GpStatus correctly.
*
* Created:
*
*   09/31/2000 asecchia
*       Rewrote it.
*
\**************************************************************************/

GpPath*
GpPath::GetWidenedPath(
    const GpPen *pen,
    const GpMatrix *matrix,
    REAL flatness
    ) const
{
    ASSERT(pen);
    
    // Redefine a NULL input matrix to be Identity for the duration of this
    // routine.
    
    GpMatrix transform;
    if(!matrix)
    {
        matrix = &transform;
    }
    
    DpPen *internalPen = NULL;
    internalPen = const_cast<GpPen*>(pen)->GetDevicePen();
    
    ASSERT(internalPen);
    
    if (internalPen->PenAlignment != PenAlignmentInset)
    {
        // Use the standard widening code for non-inset or non-outset pen.

        return GetWidenedPathInternal(
            internalPen,
            matrix,
            flatness,
            FALSE          // standard pen
        );
    }
    else
    {
        // Do the Inset Pen.
        
        // Our technique is as follows. See the inset pen spec in the 
        // gdiplus\specs directory.
        // First, inset pen is defined as widening to the inside of the path
        // which only has meaning for closed segments. Behaviour for open 
        // segments is unchanged (center pen).
        // We widen the path at 2x the stroke width using a center pen.
        // For round dash caps, we use a double-round or 'B' cap. We also
        // mirror the compound line pattern across the spine of the path.
        // Then we import the widened path as a region and clip against the
        // original path converted to a region. What's left is a region 
        // which contains the widened inset pen. This is converted to a path
        // and we're done.

        // Copy the pen. Note that this will copy the *pointer* to the Brush
        // but this is ok because the DpPen (insetPen) doesn't have a 
        // destructor and so won't attempt to free any state.
        
        // We will need an insetPen for the closed subpath segments and a
        // centerPen for the open subpath segments.
        
        DpPen insetPen = *internalPen;
        DpPen centerPen = *internalPen;
        
        // Use a double width center pen and then clip off the outside creating
        // a single width insetPen.
        
        insetPen.Width *= 2.0f;
        insetPen.PenAlignment = PenAlignmentCenter;
        centerPen.PenAlignment = PenAlignmentCenter;
        
        // Copy the compound array duplicating the compound array in reverse
        // and rescaling back to [0,1] interval (i.e. mirror along the spine).
        
        if( internalPen->CompoundCount > 0)
        {
            insetPen.CompoundArray = (REAL*)GpMalloc(
               sizeof(REAL)*insetPen.CompoundCount*2
            );
            
            // Check the GpMalloc for out of memory.
            
            if(insetPen.CompoundArray == NULL)
            {
                return NULL;
            }
            
            // Copy the pen->CompoundArray and duplicate it in reverse (mirror).
            // rescale to the interval [0, 1]
            
            for(INT i=0; i<insetPen.CompoundCount; i++)
            {
                // copy and scale range [0, 1] to [0, 0.5]
                
                insetPen.CompoundArray[i] = internalPen->CompoundArray[i]/2.0f;
                
                // copy and scale range [0, 1] to [0.5, 1] reversed.
                
                insetPen.CompoundArray[insetPen.CompoundCount*2-i-1] = 
                    1.0f - internalPen->CompoundArray[i]/2.0f;
            }
            
            // we have double the number of entries now.
            
            insetPen.CompoundCount *= 2;
        }

        // Create an iterator to step through each subpath.
        
        GpPathPointIterator pathIterator(
            (GpPointF*)GetPathPoints(),
            (BYTE*)GetPathTypes(),
            GetPointCount()
        );
        
        GpSubpathIterator subPathIterator(
            &pathIterator
        );
        
        // Some temporary variables.
        
        GpPointF *points;
        BYTE *types;
        INT subPathCount;
        GpPath *widenedPath = NULL;
        GpPath *subPath = NULL;

        // Accumulate the widened sub paths in this returnPath.
                
        GpPath *returnPath = new GpPath(FillModeWinding);
        
        // loop while there are more subpaths and the returnPath is not NULL
        // This implicitly checks that returnPath was allocated correctly.
        
        while(returnPath && !subPathIterator.IsDone())
        {   
            // Get the data for the current subpath.
                
            points = subPathIterator.CurrentItem();
            types = subPathIterator.CurrentType();
            subPathCount = -subPathIterator.CurrentIndex();
            subPathIterator.Next();
            subPathCount += subPathIterator.CurrentIndex();

            // Create a path object representing the current sub path.
            
            subPath = new GpPath(points, types, subPathCount);
            
            if(!subPath)
            {
                // failed the allocation.
                
                delete returnPath;
                returnPath = NULL;
                break;
            }

            // Is this subpath closed?
            
            BOOL isClosed = IsClosedType(types[subPathCount-1]);

            // Widen the subPath with the inset pen for closed and
            // center pen for open.
            
            widenedPath = subPath->GetWidenedPathInternal(
                (isClosed) ? &insetPen : &centerPen,
                matrix,
                flatness,
                isClosed            // Inset/Outset pen?
            );
                    
            // don't need the subPath anymore - we have the widened version.
            
            delete subPath;
            subPath = NULL;
            
            // Check if the widener succeeded.
            
            if(!widenedPath || !widenedPath->IsValid())
            {
                delete widenedPath;
                widenedPath = NULL;
                delete returnPath;
                returnPath = NULL;
                break;
            }
            
            if(isClosed)
            {
                // Region to path.
                
                // The widenedPath has already been transformed by the widener
                // according to the matrix. Use the identity to convert the 
                // widenedPath to a region, but use the matrix to transform the
                // (still untransformed) original matrix to a region.
                
                GpMatrix identityMatrix;
                const GpMatrix *scaleMatrix = &identityMatrix;
                
                if(matrix)
                {
                    scaleMatrix = matrix;
                }
                
                DpRegion srcRgn(widenedPath, &identityMatrix);
                DpRegion clipRgn((DpPath*)(this), scaleMatrix);// const and type cast.
        
                // Clip the region
                
                GpStatus clip = Ok;
                
                if(internalPen->PenAlignment == PenAlignmentInset)
                {
                    // Inset pen is an And operation.
                    
                    clip = srcRgn.And(&clipRgn);
                }
                
                GpPath *clippedPath;
                
                if(clip == Ok)
                {  
                    clippedPath = new GpPath(&srcRgn);
                    
                    if(!clippedPath)
                    {
                        delete widenedPath;
                        widenedPath = NULL;
                        delete returnPath;
                        returnPath = NULL;
                        break;
                    }
                    
                    ConvertRegionOutputToWinding(&clippedPath);
                    
                    // Accumulate the current subpath that we've just clipped
                    // for inset/outset into the final result.
                    
                    returnPath->AddPath(clippedPath, FALSE);
                    
                    delete clippedPath;
                    clippedPath = NULL;
                }
            }
            else
            {
                // Accumulate the center pen widened path for the open
                // subpath segment.
                
                returnPath->AddPath(widenedPath, FALSE);
            }
        
            delete widenedPath;
            widenedPath = NULL;
        }
        
        // clean up.
                
        if(internalPen->CompoundCount > 0)
        {
            // we allocated a new piece of memory, throw it away.
            // Make sure we're not trying to throw away the original pen
            // CompoundArray - only free the temporary one if we created it.
            
            ASSERT(insetPen.CompoundArray != internalPen->CompoundArray);
            GpFree(insetPen.CompoundArray);
            insetPen.CompoundArray = NULL;
        }
        
        return returnPath;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   The sweep phase of a mark-sweep path point deletion algorithm
*   This will delete all points marked with PathPointTypeInternalUse.
*
*   If it deletes a start marker, it'll make the next valid point a start
*   point.
* 
*   NOTE:
*   If the algorithm encounters a closed subpath marker it will simply 
*   delete it. Because this algorithm is used for trimming the ends of 
*   open subpath segments (during endcapping), this is the desired behaviour, 
*   but may not be strictly correct for other uses.
*   
*   The points to be deleted are marked by oring in the 
*   PathPointTypeInternalUse flag. This flag is used by the widener as an 
*   internal flag and as a deletion mask for this code. These two usages 
*   do not (and should not) overlap.
*
* Created:
*
*   10/07/2000 asecchia
*       created it.
*
\**************************************************************************/

VOID GpPath::EraseMarkedSegments()
{
    // Get pointers to the source buffers.
    
    GpPointF *dstPoints = Points.GetDataBuffer();
    BYTE *dstTypes =  Types.GetDataBuffer();
    INT count = Points.GetCount();
    
    
    INT delete_count = 0;
    INT i=0;
    GpPointF *srcPoints = dstPoints;
    BYTE *srcTypes = dstTypes;
    
    bool deleted_start_marker = false;
    
    while(i<count)
    {
        // Skip all the points marked for deletion.
        
        if((*srcTypes) & PathPointTypeInternalUse)
        {
            delete_count++;
            
            // if we ever encounter a start marker, keep track of that fact.
            
            deleted_start_marker |= 
                (((*srcTypes) & PathPointTypePathTypeMask) == PathPointTypeStart);
        }
        else
        {
            // If we have deleted some stuff, move the data up.
            
            if(srcTypes!=dstTypes)
            {
                *dstPoints = *srcPoints;
                *dstTypes = *srcTypes;
                
                // if we deleted a start marker in the last deletion run, 
                // make the next non-deleted point a start marker.
                // Note: if the whole subpath is marked for deletion and
                // it's the last subpath, then we won't do this code because
                // we'll terminate the while loop first. This protects against
                // overwriting our buffer.
                
                if(deleted_start_marker)
                {
                    *dstTypes &= ~PathPointTypePathTypeMask;
                    *dstTypes |= PathPointTypeStart;
                }
            }
            
            deleted_start_marker = false;
        
            // increment to the next element.
            
            dstPoints++;
            dstTypes++;
        }
        
        // increment these every iteration through the loop.
        
        srcTypes++;
        srcPoints++;
        i++;
    }
    
    // update the DynArrays so that they reflect the new (deleted) count.
    
    Points.AdjustCount(-delete_count);
    Types.AdjustCount(-delete_count);
    
    InvalidateCache();
    UpdateUid();
}


/**************************************************************************\
*
* Function Description:
*
*   Returns a widened version of the path. This routine does not handle 
*   inset or outset pen alignments. The input insetPen parameter specifies
*   if we should double widen the path in preparation for inset or outset
*   pen modes. This has impact on dash caps and dash length.
*
* Return
* 
*   GpPath - the widened path. NULL if this routine fails.
*
* Arguments:
*
*   [IN] pen      - pen - specifies width for widening
*   [IN] matrix   - world to device transform.
*   [IN] flatness - number of device pixels of error allowed for flattening
*   [IN] insetPen - flag specifying if inset pen is being used.
*
* Return:
*   
*   GpPath *      - widened path. NULL on failure.
*                 - !!! this should return the path in an OUT parameter and
*                 -     propagate the GpStatus correctly.
*
* Created:
*
*   10/05/2000 asecchia
*       rewrote it.
*
\**************************************************************************/

GpPath*
GpPath::GetWidenedPathInternal(
    const DpPen *pen,
    const GpMatrix *matrix,
    REAL flatness,
    BOOL insetPen
    ) const
{
    ASSERT(pen);
    ASSERT(matrix);
    ASSERT(pen->PenAlignment!=PenAlignmentInset);
    
    GpStatus status = Ok;
    
    GpMatrix invMatrix(*matrix);
    if(Ok != invMatrix.Invert())
    {
        ONCE(WARNING(("GetWidenedPath: failed to invert the matrix")));
        return NULL;
    }
    
    // This is a const function. We cannot modify 'this' so we clone
    // the path in order to flatten it.
    
    GpPath* path = this->Clone();
    if(path == NULL) { return NULL; }
    if(Ok != (status = path->Flatten(matrix, flatness)))
    {
        ONCE(WARNING(("GetWidenedPath: failed to flatten the path (%x)", status)));
        return NULL;
    }
    
    // Undo the Flatten matrix transform so that we can widen in world space.
    // This is required so that we correctly compute the device resolution 
    // minimum pen width for nominal pens.
    
    path->Transform(&invMatrix);
    
    // Do all the path decorations before widening. This is to ensure that
    // the decorations have all of the original path information to operate
    // on --- the widening/decoration process is lossy so they have to be
    // performed in the right order.
    
    // First apply the end caps. This decoration must be applied before 
    // dashing the path.
    // Need to loop through all the subpaths, apply the end caps and 
    // fix up the path segments so they don't exit the cap incorrectly.
    // put all the caps in a path for later use. We will apply these caps
    // when we're done widening.
    
    GpPath *caps = NULL;
    
    if(GpEndCapCreator::PenNeedsEndCapCreator(pen))
    {    
        // Create an instance of the GpEndCapCreator which will create
        // our endcap aggregate path.
        
        GpEndCapCreator ecc(
            path, 
            const_cast<DpPen*>(pen), 
            matrix, 
            0.0f, 0.0f,
            TRUE
        );
        
        // CreateCapPath will mark the points in the path for deletion if 
        // it's necessary to trim the path to fit the cap.
        
        status = ecc.CreateCapPath(&caps);
        if(status != Ok) 
        { 
            return NULL; 
        }
        
        // Remove the points marked for deletion in the cap trimming step.
        
        path->EraseMarkedSegments();
    }
    
    // Apply the dash decorations. Note that this will bounce on an empty path.
    
    GpPath* dashPath = NULL;

    if( (pen) && 
        (pen->DashStyle != DashStyleSolid) &&
        (path->GetPointCount() > 0)
    )
    {
        // the width is artificially expanded by 2 if the pen is inset. 
        // we need to factor this into the dash length and scale by 0.5.
        
        dashPath = path->CreateDashedPath(
            pen, 
            matrix, 
            0.0f,     // not used
            0.0f,     // not used
            (insetPen) ? 0.5f : 1.0f,
            TRUE
        );
        
        // If we successfully got a dashed version of *path, delete
        // the old one and return the new one.
        
        if(dashPath)
        {
            delete path;
            path = dashPath;
        }
    }
    
    // Only do the widening if we have some points left in our 
    // path after trimming
    
    if(path->GetPointCount() > 0)
    {
        // Create a widener object. Note that if path has no points left, this
        // will bounce immediately with an invalid widener.
    
        GpPathWidener widener(
            path,
            pen,
            matrix,
            0.0f,    // not used
            0.0f,    // not used
            TRUE,    // not used
            insetPen
        );
        
        // We're done with this now.
        
        delete path;
        path = NULL;
    
        // Check if we have a valid Widener object.
        
        if(!widener.IsValid()) 
        { 
            status = OutOfMemory; 
        }
    
        // Get the widened path.
    
        if(status == Ok) 
        { 
            status = widener.Widen(&path); 
        }
    }
    else
    {
        delete path;
        path = caps;
        caps = NULL;
    }

    // paranoid checking the return from the widener.
    
    if((status == Ok) && (path != NULL))
    {
        // Add the endcaps to the widened path. AddPath will bounce a NULL 
        // caps pointer with InvalidParameter. For our purposes that is 
        // considered correctly handled and we continue. 
        
        path->AddPath(caps, FALSE);
                                    
        if(path->IsValid())
        {
            // Transform into the requested destination device space.
            
            path->Transform(matrix);
        }
    }
    
    // Delete the caps before returning. If we had caps, we've copied them
    // into path, otherwise caps is NULL. Or we failed to widen. Either way
    // we must not leak memory.
    
    delete caps;
    caps = NULL;

    return path;
}

/**************************************************************************\
*
* Function Description:
*
* This widenes itself.
*
* Arguments:
*
*   [IN] pen - the pen.
*   [IN] matrix - Specifies the transform
*   [IN] dpiX - the X-resolution.
*   [IN] dpiY - the Y-resolution.
*
* Return Value:
*
*   Ok if successfull.
*
* Created:
*
*   09/27/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpPath::Widen(
    GpPen *pen,
    GpMatrix *matrix,
    REAL flatness
    )
{
    if(pen==NULL)
    {
        return InvalidParameter;
    }
    
    GpMatrix transform;  // Identity matrix

    if(matrix)
    {
        transform = *matrix;
    }

    GpPath* widenedPath = GetWidenedPath(
        pen,
        &transform,
        flatness
    );

    if(widenedPath)
    {
        Points.Reset(FALSE);
        Types.Reset(FALSE);
        INT count = widenedPath->GetPointCount();
        Points.AddMultiple(widenedPath->Points.GetDataBuffer(), count);
        Types.AddMultiple(widenedPath->Types.GetDataBuffer(), count);
        SubpathCount = widenedPath->SubpathCount;
        HasBezier = widenedPath->HasBezier;
        Flags = widenedPath->Flags;
        FillMode = FillModeWinding;
        delete widenedPath;

        GpStatus status = Ok;

        InvalidateCache();
        UpdateUid();

        return status;
    }
    else
    {
        return OutOfMemory;
    }
}

// Get the flattened path.

const DpPath *
GpPath::GetFlattenedPath(
    const GpMatrix* matrix,
    DpEnumerationType type,
    const DpPen* pen
    ) const
{
    GpPath* flattenedPath = NULL;

    if(type == Flattened)
    {
        flattenedPath = Clone();
        
        if(flattenedPath)
        {
            GpStatus status = flattenedPath->Flatten(matrix);
            
            if(Ok != status)
            {
                // Out of memory or flatten returned some other error,
                // however we can't return a status code from this routine.
                
                delete flattenedPath;
                flattenedPath = NULL;
            }
        }
    }
    else if(type == Widened)
    {
        flattenedPath = GetWidenedPath(
            GpPen::GetPen(pen),
            matrix,
            FlatnessDefault
        );
    }

    return flattenedPath;
}



/**************************************************************************\
*
* Function Description:
*
* Checks if the given point in World coordinate is inside of
* the path.  The matrix is used to render path in specific resolution.
* Usually, Graphics's World to Device matrix is used.  If matrix is NULL,
* the identity matrix is used.
*
* Arguments:
*
*   [IN] point - A test point in World coordinate
*   [OUT] isVisible - TRUE is the test point is inside of the path.
*   [IN] matrix - A matrix to render path.  Identity is used if NULL.
*
* Return Value:
*
*   Ok if successfull.
*
* Created:
*
*   10/05/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpPath::IsVisible(
    GpPointF* point,
    BOOL* isVisible,
    GpMatrix* matrix)
{
    GpMatrix m;

    if(matrix)
        m = *matrix;

    GpRegion rgn(this);

    if(rgn.IsValid())
        return rgn.IsVisible(point, &m, isVisible);

    *isVisible = FALSE;
    return GenericError;
}


/**************************************************************************\
*
* Function Description:
*
* Checks if the given point in World coordinate is inside of
* the path outline.  The matrix is used to render path in specific resolution.
* Usually, Graphics's World to Device matrix is used.  If matrix is NULL,
* the identity matrix is used.
*
* Arguments:
*
*   [IN] point - A test point in World coordinate
*   [OUT] isVisible - TRUE is the test point is inside of the path.
*   [IN] pen - A pen to draw the outline.
*   [IN] matrix - A matrix to render path.  Identity is used if NULL.
*   [IN] dpiX - x-resolution of the device.
*   [IN] dpiY - y-resolution of the device.
*
* Return Value:
*
*   Ok if successfull.
*
* Created:
*
*   10/05/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpPath::IsOutlineVisible(
    GpPointF* point,
    BOOL* isVisible,
    GpPen* pen,
    GpMatrix* matrix,
    REAL dpiX,
    REAL dpiY
    )
{
    if ((dpiX <= 0) || (dpiY <= 0))
    {
        dpiX = Globals::DesktopDpiX;
        dpiY = Globals::DesktopDpiY;
    }

    // If the given pen is not a solid line,
    // clone the pen and set its dash type to Solid.
    // We do line hit testing in solid lines.

    GpPen* pen1 = NULL;
    if(pen && pen->GetDashStyle() != DashStyleSolid)
    {
        pen1 = pen->Clone();
        if(pen1)
           pen1->SetDashStyle(DashStyleSolid);
    }
    else
        pen1 = pen;

    if(pen1 == NULL)
    {
        *isVisible = FALSE;
        return Ok;
    }

    // Create a widened path in the transformed coordinates.

    GpPath* widenedPath = GetWidenedPath(
        pen1,
        matrix,
        FlatnessDefault
    );

    if(pen1 != pen)
        delete pen1;

    GpStatus status = Ok;

    if(widenedPath)
    {
        // Since the widened path is already transformed, we have to
        // transform the given point.

        GpPointF    transformedPoint = *point;
        if(matrix)
            matrix->Transform(&transformedPoint);

        status = widenedPath->IsVisible(&transformedPoint, isVisible, NULL);
        delete widenedPath;
    }
    else
    {
        *isVisible = FALSE;
    }

    return status;
}

// Is the current dash segment a line segment?
// If false it's a space segment.

inline bool IsLineSegment(GpIterator<REAL> &dashIt)
{
    // line segment starts on even indices.

    return bool( !(dashIt.CurrentIndex() & 0x1) );
}

// Emit a line segment if it is not degenerate.
// Return true if emitted, false if degenerate

bool EmitLineSegment(
    GpPathPointIterator &dstPath,
    GpPointF p0,
    GpPointF p1,
    bool isLineStart
)
{
    GpPointF *currentPoint;
    BYTE *currentType;

    if( (REALABS(p0.X-p1.X) < REAL_EPSILON) &&
        (REALABS(p0.Y-p1.Y) < REAL_EPSILON) )
    {
        // Don't emit a line segment if it has zero length.
        return false;
    }

    // If the last emitted line ends at the same point that this next
    // one starts, we don't need a new start record.

    if(isLineStart)
    {
        // start point.
        currentPoint = dstPath.CurrentItem();
        *currentPoint = p0;
        currentType = dstPath.CurrentType();
        *currentType = PathPointTypeStart | PathPointTypeDashMode;

        dstPath.Next();
    }

    // end point.
    currentPoint = dstPath.CurrentItem();
    *currentPoint = p1;
    currentType = dstPath.CurrentType();
    *currentType = PathPointTypeLine | PathPointTypeDashMode;

    dstPath.Next();

    return true;
}

INT
getDashData(
    BYTE* newTypes,
    GpPointF* newPts,
    INT estimateCount,
    REAL penWidth,
    REAL dashOffset,
    const REAL* dashArray,
    INT dashCount,
    const BYTE* types,
    const GpPointF* points,
    INT numOfPoints,
    BOOL isClosed,
    const REAL* distances
    )
{
    ASSERT(estimateCount >= numOfPoints);
    ASSERT(types && points);

    // Code assumes first point != last point for closed paths.  If first
    // point == last point, decrease point count
    if (isClosed && numOfPoints &&
        points[0].X == points[numOfPoints-1].X &&
        points[0].Y == points[numOfPoints-1].Y)
    {
        numOfPoints--;
    }


    if(!newTypes || !newPts)
    {
        return 0;
    }

    // Make the iterators.

    GpArrayIterator<GpPointF> pathIterator(
        const_cast<GpPointF*>(points),
        numOfPoints
    );
    GpArrayIterator<REAL> pathBaseDistance(
        const_cast<REAL*>(distances),
        numOfPoints
    );
    
    GpPathPointIterator dstPath(newPts, newTypes, estimateCount);
    
    GpArrayIterator<REAL> dashBaseIterator(
        const_cast<REAL*>(dashArray),
        dashCount
    );

    // Compute the length of the dash

    REAL dashLength = 0.0f;
    while(!dashBaseIterator.IsDone())
    {
        dashLength += *(dashBaseIterator.CurrentItem());
        dashBaseIterator.Next();
    }
    ASSERT(dashLength > -REAL_EPSILON);


    // Do the offset initialization.

    dashBaseIterator.SeekFirst();

    REAL distance = GpModF(dashOffset, dashLength);
    REAL delta;

    // Compute the position in the dash array corresponding to the
    // specified offset.

    while(!dashBaseIterator.IsDone())
    {
        delta = *(dashBaseIterator.CurrentItem());
        if(distance < delta)
        {
            // set to the remaining piece of the dash.
            distance = delta-distance;
            break;
        }
        distance -= delta;
        dashBaseIterator.Next();
    }

    // The dashIterator is now set to point to the correct
    // dash for the first segment.

    // These are circular arrays to repeat the dash pattern.

    GpCircularIterator<REAL> dashIterator(&dashBaseIterator);


    // This is the distance into the current dash segment that we're going
    // to start at.

    REAL currentDashLength = distance;
    REAL currentSegmentLength;

    GpPointF p0, p1;
    GpVector2D sD;     // segment direction.

    // Used to track if we need to emit a segment start record.

    bool emittedPathSegment = false;

    if(isClosed)
    {
        // set up everything off the last item and then point to
        // the first item to start the process.

        pathBaseDistance.SeekFirst();

        pathIterator.SeekLast();
        p0 = *(pathIterator.CurrentItem());

        pathIterator.SeekFirst();
        p1 = *(pathIterator.CurrentItem());

        // get the distance between the first and last points.

        GpVector2D seg = p1-p0;
        currentSegmentLength = seg.Norm();
    }
    else
    {
        // Get the first point in the array.

        p0 = *(pathIterator.CurrentItem());

        // already initialized to the first point, start on the next one.

        pathIterator.Next();
        pathBaseDistance.Next();

        // distance between point n and point n+1 is stored in
        // distance[n+1]. distance[0] is the distance between the first
        // and last points.

        currentSegmentLength = *(pathBaseDistance.CurrentItem());
    }

    // reference the distances as circular so that we can simplify the
    // internal algorithm by not having to check when we query for the
    // next segment in the last iteration of the loop.

    GpCircularIterator<REAL> pathDistance(&pathBaseDistance);

    while( !pathIterator.IsDone() )
    {
        if(currentDashLength > currentSegmentLength)
        {
            // The remaining dash segment length is longer than the remaining
            // path segment length.
            // Finish the path segment.

            // Note that we've moved along the dash segment.

            currentDashLength -= currentSegmentLength;

            p1 = *(pathIterator.CurrentItem());

            if(IsLineSegment(dashIterator))
            {
                // emit a line. Add the start record only if we didn't just
                // emit a path segment. If we're emitting a series of path
                // segments to complete one dash, we can't have any start
                // records inbetween the segments otherwise we'll end up with
                // spurious endcaps in the middle of the lines.

                emittedPathSegment = EmitLineSegment(
                    dstPath,
                    p0, p1,
                    !emittedPathSegment
                );
            }
            else
            {
                emittedPathSegment = false;
            }

            p0 = p1;

            // Keep these two in sync.

            pathDistance.Next();
            pathIterator.Next();

            currentSegmentLength = *(pathDistance.CurrentItem());
        }
        else
        {
            // The remaining path segment length is longer than the remaining
            // dash segment length.
            // Finish the dash segment.

            // Compute position between start and end point of the current
            // path segment where we finish with this dash segment.

            ASSERT(REALABS(currentSegmentLength)>REAL_EPSILON);
            sD = *(pathIterator.CurrentItem());
            sD -= p0;
            sD *= currentDashLength/currentSegmentLength;

            // Move along the path segment by the amount left in the
            // dash segment.

            currentSegmentLength -= currentDashLength;

            p1 = p0 + sD;

            if(IsLineSegment(dashIterator))
            {
                // emit a line. Add the start record only if we didn't just
                // emit a path segment.

                EmitLineSegment(
                    dstPath,
                    p0, p1,
                    !emittedPathSegment
                );
            }

            p0 = p1;

            // dashIterator is circular, so this should keep wrapping through
            // the dash array.

            dashIterator.Next();

            // Get the new dash length.

            currentDashLength = *(dashIterator.CurrentItem());
            emittedPathSegment = false;
        }
    }
    
    INT size = dstPath.CurrentIndex();

    if(!isClosed && size != 0 && numOfPoints != 0)
    {
        BYTE *type;
        REAL halfPenWidth2 = penWidth * penWidth / 4.0f;

        // Turn off dash mode for the last segment if the last
        // point is very close to the last dash segment.
        if (distance_squared(points[numOfPoints-1], newPts[size-1]) < halfPenWidth2)
        {
            dstPath.Prev();
            type = dstPath.CurrentType();
            *type &= ~PathPointTypeDashMode;
        }

        // Turn off dash mode for the first segment if the first
        // point is very close to the first dash segment.
        if (distance_squared(points[0], newPts[0]) < halfPenWidth2)
        {
            dstPath.SeekFirst();
            type = dstPath.CurrentType();
            *type &= ~PathPointTypeDashMode;
        }
    }

    // return the number of entries added to the dstPath array.

    return (size);
}

/**************************************************************************\
*
* Function Description:
*
* Creates a dashed path.
*
* Arguments:
*
*   [IN] pen - This pen contains the dash info.
*   [IN] matrix - The transformation where the dash patterns are calculated.
*                   But the dashed path is transformed back to the World
*                   coordinates.
*   [IN] dpiX - x-resolution.
*   [IN] dpiY - y-resolution.
*
* Return Value:
*
*   returns a dashed path.
*
* Created:
*
*   01/27/2000 ikkof
*       Created it.
*
\**************************************************************************/

GpPath*
GpPath::CreateDashedPath(
    const GpPen* pen,
    const GpMatrix* matrix,
    REAL dpiX,
    REAL dpiY,
    REAL dashScale,
    BOOL needDashCaps
    ) const
{
    if(pen == NULL)
        return NULL;

    DpPen* dpPen = ((GpPen* ) pen)->GetDevicePen();

    return CreateDashedPath(dpPen, matrix, dpiX, dpiY, dashScale, needDashCaps);
}

/**************************************************************************\
*
* Function Description:
*
* Returns TRUE if the given points have non-horizontal or non-vertical
*   edges.
*
*
* Created:
*
*   04/07/2000 ikkof
*       Created it.
*
\**************************************************************************/

inline
BOOL
hasDiagonalEdges(
    GpPointF* points,
    INT count
    )
{
    if(!points || count <= 1)
        return FALSE;

    GpPointF *curPt, *nextPt;
    curPt = points;
    nextPt = points + 1;

    BOOL foundDiagonal = FALSE;
    INT i = 1;

    while(!foundDiagonal && i < count)
    {
        if((curPt->X == nextPt->X) || (curPt->Y == nextPt->Y))
        {
            // This is either horizontal or vertical edges.
            // Go to the next edge.

            curPt++;
            nextPt++;
            i++;
        }
        else
            foundDiagonal = TRUE;
    }

    return foundDiagonal;
}

GpPath*
GpPath::CreateDashedPath(
    const DpPen* dpPen,
    const GpMatrix* matrix,
    REAL dpiX,
    REAL dpiY,
    REAL dashScale,
    BOOL needDashCaps
    ) const
{
    FPUStateSaver::AssertMode();


    GpPointF* points = Points.GetDataBuffer();
    INT numOfPoints = GetPointCount();

    if(dpPen == NULL)
        return NULL;

    if(
        dpPen->DashStyle == DashStyleSolid ||
        dpPen->DashCount == 0 ||
        dpPen->DashArray == NULL
    )
        return NULL;

    REAL penWidth = dpPen->Width;
    GpUnit unit = dpPen->Unit;
    BOOL isWorldUnit = TRUE;

    REAL dashUnit;
    {
        // The minimum pen width 
        REAL minimumPenWidth = 1.0f;
        
        if(REALABS(dashScale-0.5f) < REAL_EPSILON)
        {
            minimumPenWidth = 4.0f;
        }
        
        if(unit != UnitWorld)
        {
            isWorldUnit = FALSE;
            penWidth = ::GetDeviceWidth(penWidth, unit, dpiX);
    
            // Prevent the extremely thin line and dashes.
    
            dashUnit = max(penWidth, minimumPenWidth);
        }
        else
        {
            REAL majorR, minorR;
    
            // Calculate the device width.
    
            ::GetMajorAndMinorAxis(&majorR, &minorR, matrix);
            REAL maxWidth = penWidth*majorR;
            REAL minWidth = penWidth*minorR;
    
            // If the device width becomes less than 1, strech the penWidth
            // so that the device width becomes 1.
            // If we're doing the inset pen, then the path is scaled up double
            // in size and we need to scale by the inverse.
            // Also, the minimum pen width needs to be 2 not 1 in this case 
            // because we will remove half the line width. dashScale is 1/2 
            // in this case so we divide by it.
    
            dashUnit = penWidth;
            
            if(maxWidth < minimumPenWidth)
            {
                dashUnit = minimumPenWidth/majorR;
            }
        }
    }

    dashUnit *= dashScale;

    GpMatrix mat, invMat;

    if(matrix)
    {
        mat = *matrix;
        invMat = mat;
    }

    if(invMat.IsInvertible())
    {
        invMat.Invert();
    }
    else
    {
        WARNING(("Inverse matrix does not exist."));

        return NULL;
    }

    INT dashCount = dpPen->DashCount;
    REAL* dashArray = (REAL*) GpMalloc(dashCount*sizeof(REAL));
    if(dashArray)
    {
        GpMemcpy(dashArray, dpPen->DashArray, dashCount*sizeof(REAL));

        // Adjust the dash interval according the stroke width.

        for(INT i = 0; i < dashCount; i++)
        {
            dashArray[i] *= dashUnit;
        }
    }
    else
    {
        return NULL;
    }

    GpPath* newPath = Clone();

    if(newPath && newPath->IsValid())
    {
        // Flatten in the resolution given by the matrix.

        newPath->Flatten(&mat);

        if(isWorldUnit)
        {
            // Transform back to the World Unit.
            // When the pen is in WorldUnit, transform the path
            // before detDashData() is called.

            newPath->Transform(&invMat);
        }

        BYTE *types = newPath->Types.GetDataBuffer();
        points = newPath->Points.GetDataBuffer();
        numOfPoints = newPath->GetPointCount();

        GpPointF* grad = (GpPointF*) GpMalloc((numOfPoints + 1)*sizeof(GpPointF));
        REAL* distances = (REAL*) GpMalloc((numOfPoints + 1)*sizeof(REAL));

        if(grad == NULL || distances == NULL)
        {
            GpFree(grad);
            GpFree(dashArray);
            delete newPath;

            return NULL;
        }

        // Calculate the distance of each segment.

        INT i;

        REAL dashLength = 0;

        for(i = 0; i < dashCount; i++)
            dashLength += dashArray[i];

        // Make sure count is an even number.
        // !!! [asecchia] this looks completely bogus.
        // surely we should have ASSERTed that this is true at this point
        // and ensured that it was true by parameter validation at the API?

        if(dashCount & 0x01)
            dashCount ++;

        // Compute the dash adjustment for the dash cap length here. This
        // is outside of the subpath loop so it only gets computed once
        // and therefore doesn't get applied to further subpath segments
        // multiple times.

        if (needDashCaps)
        {
            GpPen *gppen = GpPen::GetPen(dpPen);
            if (gppen != NULL)
            {
                gppen->AdjustDashArrayForCaps(
                    dashUnit,
                    dashArray,
                    dashCount
                );
            }
        }


        DynByteArray dashTypes;
        DynPointFArray dashPoints;

        BYTE* newTypes = NULL;
        GpPointF* newPts = NULL;

        DpPathIterator iter(points, types, numOfPoints);

        INT startIndex, endIndex;
        BOOL isClosed;
        REALD totalLength = 0;
        INT totalCount = 0;
        BOOL isSingleSubpath = iter.GetSubpathCount() == 1;

        while(iter.NextSubpath(&startIndex, &endIndex, &isClosed))
        {
            GpPointF startPt, lastPt, nextPt;
            REAL dx, dy;
            REALD length;
            startPt = points[startIndex];
            lastPt = startPt;

            totalLength = 0;
            INT k = 0;
            INT segmentCount = endIndex - startIndex + 1;

            CalculateGradientArray(grad, distances,
                points + startIndex, segmentCount);

            for(i = 1; i < segmentCount; i++)
                totalLength += distances[i];

            if(isClosed)
                totalLength += distances[0];

            // Estimate the required points.

            INT estimateCount
                = GpCeiling(TOREAL(totalLength*dashCount/dashLength))
                    + numOfPoints;

            // For extra caution, multiply by 2.

            estimateCount <<= 1;

            // Allocate new types and buffers

            if(newTypes)
            {
                BYTE* newTypes1 = (BYTE*) GpRealloc(
                                            newTypes,
                                            estimateCount*sizeof(BYTE));
                if(newTypes1)
                    newTypes = newTypes1;
                else
                    goto cleanUp;
            }
            else
            {
                newTypes = (BYTE*) GpMalloc(estimateCount*sizeof(BYTE));
                if(!newTypes)
                    goto cleanUp;
            }

            if(newPts)
            {
                GpPointF* newPts1 = (GpPointF*) GpRealloc(
                                                newPts,
                                                estimateCount*sizeof(GpPointF));
                if(newPts1)
                    newPts = newPts1;
                else
                    goto cleanUp;
            }
            else
            {
                newPts = (GpPointF*) GpMalloc(estimateCount*sizeof(GpPointF));
                if(!newPts)
                    goto cleanUp;
            }
 
            // Adjust the dash offset if necessary.
 
            REAL dashCapOffsetAdjustment = 0.0f;
            if (needDashCaps)
            {
                GpPen *gppen = GpPen::GetPen(dpPen);
                if ((gppen != NULL) && isClosed)
                {
                    // Fix for Whistler Bug 178774
                    // Since dash caps are no longer 'inset' when they are
                    // rendered, it is possible that on closed paths, the dash caps
                    // on the start and end of a closed path will overlap. This
                    // offset will leave sufficient space for the two caps. However,
                    // this fix is not bullet-proof. It will *always* work if the
                    // Dash Offset is 0. However, if it is non-zero, it is possible
                    // that the offset will counter-act the adjustment and there
                    // will be some dash overlap at the start/end of closed paths.
                    // I believe this is acceptable since VISIO 2000, Office9 and
                    // PhotoDraw 2000 v2 also have the collision problem.
                    // The real solution is to enforce a minimum spacing between the
                    // start and end or merge the start/end segments if they collide.
    
                    dashCapOffsetAdjustment =
                        2.0f * gppen->GetDashCapInsetLength(dashUnit);
                }
            }
            
            INT newCount = getDashData(
                newTypes,
                newPts,
                estimateCount,
                penWidth,
                // Shouldn't the offset be scaled dashUnit instead of penWidth?
                dpPen->DashOffset * penWidth - dashCapOffsetAdjustment,
                dashArray,
                dashCount,
                types + startIndex,
                points + startIndex,
                endIndex - startIndex + 1,
                isClosed,
                distances
            );

            if(newCount)
            {
                dashTypes.AddMultiple(newTypes, newCount);
                dashPoints.AddMultiple(newPts, newCount);
            }

        }

        totalCount = dashPoints.GetCount();
        if(totalCount > 0)
        {
            GpPathData pathData;
            pathData.Count = totalCount;
            pathData.Types = dashTypes.GetDataBuffer();
            pathData.Points = dashPoints.GetDataBuffer();

            newPath->SetPathData(&pathData);

            if(!isWorldUnit)
            {
                // Transform back to the World Unit.
                // When the pen is in WorldUnit, it is already transformed
                // before detDashData() is called.

                newPath->Transform(&invMat);
            }

        }
        else
        {
            delete newPath;
            newPath = NULL;
        }

        GpFree(newTypes);
        GpFree(newPts);
        GpFree(distances);
        GpFree(grad);
        GpFree(dashArray);

        return newPath;

cleanUp:
        GpFree(newTypes);
        GpFree(newPts);
        GpFree(distances);
        GpFree(grad);
        GpFree(dashArray);
        delete newPath;

        return NULL;
    }
    else
    {
        GpFree(dashArray);

        if(newPath)
            delete newPath;

        return NULL;
    }
}


/**************************************************************************\
*
* Function Description
*
*   ComputeWindingModeOutline
*   (so called RemoveSelfIntersections)
*
*   This computes the winding mode fill outline for the path. It's designed to 
*   produce a path that will look the same as a winding mode fill if it's 
*   filled with an alternate fill.
*
* Arguments:
*
*   matrix   - world to device matrix - used for flattening.
*   flatness - number of device pixels of error in the flattening tolerance.
*            - Pass FlatnessDefault for default behaviour.
*
* Return Value:
*
*   GpStatus
*
* History:
*
*   06/16/1999 t-wehunt
*       Created it.
*   10/31/2000 asecchia
*       rewrote, rename.
*
\**************************************************************************/

GpStatus
GpPath::ComputeWindingModeOutline(
    const GpMatrix *matrix, 
    REAL flatness, 
    BOOL *wereIntersectsRemoved
)
{
    PathSelfIntersectRemover corrector;
    DynPointFArray newPoints;  // Array that will hold the new points.
    DynIntArray polyCounts;    // Array that will hold the numPoints for each
                               // new polygon.
    INT numPolys;              // count of new polygons created
    INT numPoints;             // count of new points created
    GpStatus status = Ok;      // holds return status of commmands

    // Must clone the path because this could fail while we're accumulating
    // the new path and we'd end up returning an invalid path.
    // If we return InvalidParameter or some other failure code, we'll return
    // with the original path intact.
    
    GpPath *path = Clone();
    
    if(path == NULL)
    {
        return OutOfMemory;
    }

    status = path->Flatten(matrix, flatness);
    if(Ok != status)
    {
        goto Done;
    }

    INT pointCount = path->GetPointCount();
    GpPointF *pathPts = const_cast<GpPointF*>(path->GetPathPoints());
    BYTE *pathTypes = const_cast<BYTE*>(path->GetPathTypes());

    if (pointCount == 0)
    {
        goto Done;
    }

    // Add the subpaths to the Path corrector
    INT ptIndex=0; // ptIndex tracks the current index in the array of points.
    INT count=0;   // the size of the current subpath.

    // Init the corrector with the number of points we will be adding.
    if ((status = corrector.Init(pointCount)) != Ok)
    {
        goto Done;
    }

    while (ptIndex < pointCount)
    {
        if (pathTypes[ptIndex] == PathPointTypeStart && ptIndex != 0)
        {
            // Add the next subpath to the PathCorrector. the start index of the subpath is
            // determined using the current index minus the current subPath size.
            if ((status =
                corrector.AddPolygon(pathPts + ptIndex-count, count)) != Ok)
            {
                goto Done;
            }
            // set count to 1 since this is the first point in the new subpath
            count = 1;
        } else
        {
            count++;
        }
        ptIndex++;
    }
    // Add the last subpath that is implicitly ended by the last point.
    if (ptIndex != 0)
    {
        // Add the next subpath to the PathCorrector. the start index of the subpath is
        // determined using the current index minus the current subPath size.
        if ((status =
            corrector.AddPolygon(pathPts + ptIndex-count, count)) != Ok)
        {
            goto Done;
        }
    }

    if ((status = corrector.RemoveSelfIntersects()) != Ok)
    {
        goto Done;
    }

    if ((status = corrector.GetNewPoints(&newPoints, &polyCounts)) != Ok)
    {
        goto Done;
    }

    // clear out the old path data so we can replace with the newly corrected one.
    path->Reset();

    // Now that we have the corrected path, add it back.
    GpPointF *curPoints = newPoints.GetDataBuffer();
    for (INT i=0;i<polyCounts.GetCount();i++)
    {
        if(polyCounts[i] > 1)
        {
            if ((status = path->AddPolygon(curPoints,polyCounts[i])) != Ok)
            {
                goto Done;
            }
        }
        else
        {
            WARNING(("degenerate polygon created by the SelfIntersectRemover"));
        }

        curPoints += polyCounts[i];
    }

    if (wereIntersectsRemoved != NULL)
    {
        *wereIntersectsRemoved = corrector.PathWasModified();
    }
    
    
    // Clear the state in the path. There is only one failure path following 
    // this and it leaves the path in an invalid state anyway, so we can do 
    // Reset here. Reset ensures that the cache is invalidated and the 
    // UID is recomputed.
    
    Reset();
    
    // Swap the path data pointers - free the old ones.
    
    if(Ok != Points.ReplaceWith((DynArray<GpPointF> *) (&path->Points)) ||
       Ok != Types.ReplaceWith((DynArray<BYTE> *) (&path->Types)))
    {
        // If the final commit fails due to low memory, we are hosed,
        // we wiped out some of our path data and can't convert from the
        // local copy, so set our status to invalid and fail the call.
        
        SetValid(FALSE);
        status = OutOfMemory;
        goto Done;
    }
    
    // Need to remember the subpath count.
    
    SubpathCount = path->SubpathCount;

    Done:
    
    delete path;
    
    return status;
}


VOID DpPath::InitDefaultState(GpFillMode fillMode)
{
    HasBezier = FALSE;
    FillMode = fillMode;
    Flags = PossiblyNonConvex;
    IsSubpathActive = FALSE;
    SubpathCount = 0;

    Types.Reset(FALSE);     // FALSE - don't free the memory
    Points.Reset(FALSE);    // FALSE - don't free the memory

    SetValid(TRUE);
    UpdateUid();
}

DpPath::DpPath(const DpPath* path)
{
    if(path)
    {
        HasBezier = path->HasBezier;
        FillMode = path->FillMode;
        Flags = path->Flags;
        IsSubpathActive = path->IsSubpathActive;
        SubpathCount = path->SubpathCount;

        BYTE *types = path->Types.GetDataBuffer();
        GpPointF* points = path->Points.GetDataBuffer();
        INT count = path->GetPointCount();

        SetValid((count == 0) || ((Types.AddMultiple(types, count) == Ok) &&
                                  (Points.AddMultiple(points, count) == Ok)));
    }
    else
        SetValid(FALSE);
}


/**************************************************************************\
*
* Function Description:
*
*   Offset all path points by the specified amount
*
* Arguments:
*
*   dx, dy - Amount to offset along x- and y- direction
*
* Return Value:
*
*   NONE
*
\**************************************************************************/

VOID
DpPath::Offset(
    REAL dx,
    REAL dy
    )
{
    ASSERT(IsValid());

    INT count = GetPointCount();
    GpPointF* pts = Points.GetDataBuffer();

    if (count > 0)
    {
        UpdateUid();
    }
    while (count--)
    {
        pts->X += dx;
        pts->Y += dy;
        pts++;
    }
}


/**************************************************************************\
*
* Function Description:
*
*   Create a driver DpPath class.
*
* Arguments:
*
*   [IN] fillMode - Specify the path fill mode
*
* Return Value:
*
*   IsValid() is FALSE if failure.
*
* History:
*
*   12/08/1998 andrewgo
*       Created it.
*
\**************************************************************************/

DpPath::DpPath(
    const GpPointF *points,
    INT count,
    GpPointF *stackPoints,
    BYTE *stackTypes,
    INT stackCount,
    GpFillMode fillMode,
    DpPathFlags pathFlags
    ) : Types(stackTypes, stackCount), Points(stackPoints, stackCount)
{
    ASSERT((fillMode == FillModeAlternate) ||
           (fillMode == FillModeWinding));

    InitDefaultState(fillMode);
    Flags = pathFlags;

    // We can call this method with no points, just to set up
    // the stackPoints/stackTypes

    if (count > 0)
    {
        BYTE *types;

        if ((types = Types.AddMultiple(count)) != NULL)
        {
            *types++ = PathPointTypeStart;
            GpMemset(types, PathPointTypeLine, count - 1);
            SetValid(Points.AddMultiple(points, count) == Ok);

            if(IsValid()) 
            {
                IsSubpathActive = TRUE;
                SubpathCount = 1;
            }
        }
        else
        {
            SetValid(FALSE);
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Close the currently active subpath in a path object
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   Status code
*
* History:
*
*   01/15/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
DpPath::CloseFigure()
{
    ASSERT(IsValid());

    // Check if there is an active subpath

    if (IsSubpathActive)
    {
        // If so, mark the last point as the end of a subpath

        Types.Last() |= PathPointTypeCloseSubpath;
        StartFigure();
    }

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Close all open subpaths in a path object
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   Status code
*
* History:
*
*   01/15/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
DpPath::CloseFigures()
{
    ASSERT(IsValid());

    // Go through all path points.
    // Notice that the loop index starts from 1 below.

    INT i, count = GetPointCount();
    BYTE* types = Types.GetDataBuffer();

    for (i=1; i < count; i++)
    {
        if (types[i] == PathPointTypeStart)
            types[i-1] |= PathPointTypeCloseSubpath;
    }

    if (count > 1)
        types[count-1] |= PathPointTypeCloseSubpath;

    StartFigure();
    return Ok;
}


/**************************************************************************\
*
* Function Description:
*
*   Calculates the bounds of a path
*
* Arguments:
*
*   [OUT] bounds - Specify the place to stick the bounds
*   [IN] matrix - Matrix used to transform the bounds
*   [IN] pen - the pen data.
*   [IN] dpiX, dpiY - the resolution of x and y directions.
*
* Return Value:
*
*   NONE
*
* History:
*
*   12/08/1998 andrewgo
*       Created it.
*
\**************************************************************************/

GpStatus
GpPath::GetBounds(
    GpRect *bounds,
    const GpMatrix *matrix,
    const DpPen* pen,
    REAL dpiX,
    REAL dpiY
    ) const
{
    if(bounds == NULL)
        return InvalidParameter;

    GpRectF boundsF;

    FPUStateSaver fpuState;

    GpStatus status = GetBounds(&boundsF, matrix, pen, dpiX, dpiY);

    if(status == Ok)
        status = BoundsFToRect(&boundsF, bounds);

    return status;
}

VOID
GpPath::CalcCacheBounds() const
{

    INT count = GetPointCount();
    GpPointF *point = Points.GetDataBuffer();

    if(count <= 1)
    {
        ResetCacheBounds();
        return;
    }

    REAL left, right, top, bottom;

    left   = point->X;
    right  = left;
    top    = point->Y;
    bottom = top;

    INT i;
    for (i = 1, point++; i < count; i++, point++)
    {
        if (point->X < left)
        {
            left = point->X;
        }
        else if (point->X > right)
        {
            right = point->X;
        }

        if (point->Y < top)
        {
            top = point->Y;
        }
        else if (point->Y > bottom)
        {
            bottom = point->Y;
        }
    }
    CacheBounds.X = left;
    CacheBounds.Width = right - left;
    CacheBounds.Y = top;
    CacheBounds.Height = bottom - top;

    if(CacheBounds.Width < POINTF_EPSILON && CacheBounds.Height < POINTF_EPSILON)
    {
        ResetCacheBounds();
        return;
    }

    CacheFlags = kCacheBoundsValid;

}


/**************************************************************************\
*
* Function Description:
*
*   Calculates the sharpest angle in a path.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* History:
*
*   10/04/2000 asecchia
*       Created it.
*
* Remarks:
*
*   This is an expensive function, if it's ever used in a performance 
*   critical scenario it should be recoded to use the dot product of the
*   segments and perform the angle comparison in the cosine domain.
*   The cost of normalizing the vectors should be cheaper than the 
*   atan algorithm used below.
*
*
\**************************************************************************/

VOID
GpPath::CalcSharpestAngle() const
{
    if(CacheFlags & kSharpestAngleValid)
    {
        return;
    }

    UpdateCacheBounds();

    // Walk the path and find the smallest angle between two 
    // adjacent segments.
    
    GpPathPointIterator pIter(
        (GpPointF*)GetPathPoints(),
        (BYTE*)GetPathTypes(),
        GetPointCount()
    );
    
    GpSubpathIterator pSubpath(&pIter);
    
    GpPointF *points;
    BOOL isClosed;
    
    GpPointF *p0, *p1;
    GpVector2D v;
    REAL lastAngle;
    REAL currAngle;
    REAL minAngle = 2*PI;
    REAL tempAngle;
    bool first = true;
    INT iter, i;
    
    
    while(!pSubpath.IsDone())
    {
        // Compute the length of the subpath.
        
        INT startIndex = pSubpath.CurrentIndex();
        points = pSubpath.CurrentItem();
        pSubpath.Next();
        INT elementCount = pSubpath.CurrentIndex() - startIndex;
        
        // Work out if it's a closed subpath.
        // Leave the subpath iterator in the same state.
        
        pIter.Prev();
        isClosed = (*(pIter.CurrentType()) & PathPointTypeCloseSubpath) ==
            PathPointTypeCloseSubpath;
        pIter.Next();
        
        // Create a GpPointF iterator.
        
        GpArrayIterator<GpPointF> iSubpath(points, elementCount);
        GpCircularIterator<GpPointF> iCirc(&iSubpath);
        
        // Initialize the first point.
        
        p0 = iCirc.CurrentItem();
        iCirc.Next();
        iter = elementCount;
        first = true;
        
        // include the endpoint wrap if it's closed
        
        if(isClosed)
        {
            iter += 2;
        }
        
        for(i = 1; i < iter; i++)
        {
            // Get the current point.
            
            p1 = iCirc.CurrentItem();
            
            // Translate to the origin and compute the angle between this line
            // and the x axis.
            // atan2 returns values in the -PI..PI range.
            
            v = (*p1)-(*p0);
            currAngle = (REAL)atan2(v.Y, v.X);

            // If we have enough data to do an angle computation, work it out.
            // We require two line segments to do a computation (3 end points).
            // If it's closed, we'll loop around the subpath past the beginning
            // again in order to get the right amount of points.
                       
            if( !first )
            {
                // reverse the direction of the last segment by adding PI and
                // compute the difference.
                
                tempAngle = lastAngle + PI;     // range 0 .. 2PI
                
                // Clamp back to the -PI..PI range
                
                if(tempAngle > PI)
                {
                    tempAngle -= 2*PI;
                }
                
                // Difference
                
                tempAngle = currAngle - tempAngle;
                
                // Clamp back to the -PI..PI range
                // Note that the extremes are tempAngle either -2PI or 2PI
                
                if(tempAngle > PI)
                {
                    tempAngle -= 2*PI;
                }
                
                if(tempAngle < -PI)
                {
                    tempAngle += 2*PI;
                }
                
                // new minimum angle?
                // We care about angle magnitude - not sign.
                
                if( minAngle > REALABS(tempAngle) )
                {
                    minAngle = REALABS(tempAngle);
                }
                
            }
            
            // iterate
            
            first = false;
            lastAngle = currAngle;
            iCirc.Next();
            p0 = p1;
        }
    }
    
    SharpestAngle = minAngle;
    CacheFlags |= kSharpestAngleValid;
}

GpStatus
GpPath::GetBounds(
    GpRectF *bounds,                // Resulting bounds in device-space
    const GpMatrix *matrix,
    const DpPen* pen,
    REAL dpiX,
    REAL dpiY
    ) const
{
    if(bounds == NULL)
        return InvalidParameter;

    ASSERT(IsValid());

    if ((dpiX <= 0) || (dpiY <= 0))
    {
        dpiX = Globals::DesktopDpiX;
        dpiY = Globals::DesktopDpiY;
    }

    INT count = GetPointCount();
    GpPointF *point = Points.GetDataBuffer();

    if ((count == 0) || (point == NULL))
    {
        bounds->X = 0;
        bounds->Y = 0;
        bounds->Width = 0;
        bounds->Height = 0;
    }
    else
    {
        REAL left, right, top, bottom;

        UpdateCacheBounds();

        left = CacheBounds.X;
        right = left + CacheBounds.Width;
        top = CacheBounds.Y;
        bottom = top + CacheBounds.Height;

        TransformBounds(matrix, left, top, right, bottom, bounds);

        if(pen)
        {
            BOOL needsJoinDelta = TRUE;

            if(count <= 2)
                needsJoinDelta = FALSE;

            GpPen* gpPen = GpPen::GetPen(pen);

            // takes into account the cap width AND the pen width - JBronsk
            REAL delta = gpPen->GetMaximumCapWidth(matrix, dpiX, dpiY);
 
            if(needsJoinDelta)
            {
                // Since the join might be a miter type, we need to provide the
                // sharpest angle in the path to see how big the join will be.
                // We have the method GetSharpestAngle() that figues this out.
                // But, this is really expensive since you have to iterate over
                // all the points and do some trig. So, lets assume the worst
                // case, which is a really sharp angle (0 rad).
                const REAL sharpestAngle = 0.0f;
                REAL delta1 = gpPen->GetMaximumJoinWidth(
                            sharpestAngle, matrix, dpiX, dpiY);
                if(delta1 > delta)
                    delta = delta1;
            }

            // Only pad the bounds if there is something non-zero to pad
            if (bounds->Width > REAL_EPSILON ||
                bounds->Height > REAL_EPSILON)
            {
                bounds->X -= delta;
                bounds->Y -= delta;
                bounds->Width += 2*delta;
                bounds->Height += 2*delta;
            }

        }
    }

    return Ok;
}


/*************************************************\
* AddGlyphPath
* History:
*
*   Sept/23/1999 Xudong Wu [tessiew]
*       Created it.
*
\************************************************/
GpStatus
GpPath::AddGlyphPath(
    GpGlyphPath* glyphPath,
    REAL x,
    REAL y,
    const GpMatrix * matrix
)
{
    ASSERT(IsValid());
    ASSERT(glyphPath->IsValid());

    if (!IsValid() || !glyphPath->IsValid())
        return InvalidParameter;

    INT count = glyphPath->pointCount;

    if (count == 0)  // nothing to add
        return Ok;

    GpPointF* points = (GpPointF*) glyphPath->points;
    BYTE* types = glyphPath->types;

    if (glyphPath->hasBezier)
        HasBezier = TRUE;

    INT origCount = GetPointCount();
    GpPointF* pointbuf = Points.AddMultiple(count);
    BYTE* typebuf = Types.AddMultiple(count);

    if (!pointbuf || !typebuf)
    {
        Points.SetCount(origCount);
        Types.SetCount(origCount);

        return OutOfMemory;
    }

    // apply the font xform

    for (INT i = 0; i < count; i++)
    {
        pointbuf[i] = points[i];
        if (matrix)
            matrix->Transform(pointbuf + i);
        pointbuf[i].X += x;
        pointbuf[i].Y += y;
    }

    GpMemcpy(typebuf, types, count*sizeof(BYTE));
    SubpathCount += glyphPath->curveCount;
    UpdateUid();
    InvalidateCache();

    return Ok;
}


/*************************************************\
* AddString()
* History:
*
*   19th Oct 199  dbrown  created
*
\************************************************/
GpStatus
GpPath::AddString(
    const WCHAR          *string,
    INT                   length,
    const GpFontFamily   *family,
    INT                   style,
    REAL                  emSize,
    const RectF          *layoutRect,
    const GpStringFormat *format
)
{
    FPUStateSaver fpuState; // Guarantee initialised FP context
    ASSERT(string && family && layoutRect);

    GpStatus      status;
    GpTextImager *imager;

    status = newTextImager(
        string,
        length,
        layoutRect->Width,
        layoutRect->Height,
        family,
        style,
        emSize,
        format,
        NULL,
        &imager,
        TRUE        // Allow use of simple text imager
    );

    if (status != Ok)
    {
        return status;
    }

    status = imager->AddToPath(this, &PointF(layoutRect->X, layoutRect->Y));
    delete imager;
    UpdateUid();
    InvalidateCache();
    return status;
}


// !!! why not convert to a DpRegion and convert it to a path the same way
// as the constructor that takes a DpRegion?
GpPath::GpPath(HRGN hRgn)
{
    ASSERT((hRgn != NULL) && (GetObjectTypeInternal(hRgn) == OBJ_REGION));

    InitDefaultState(FillModeWinding);

    ASSERT(IsValid());

    BYTE stackBuffer[1024];

    // If our stack buffer is big enough, get the clipping contents
    // in one gulp:

    RGNDATA *regionBuffer = (RGNDATA*)&stackBuffer[0];
    INT newSize = ::GetRegionData(hRgn, sizeof(stackBuffer), regionBuffer);

    // The spec says that  GetRegionData returns '1' in the event of
    // success, but NT returns the actual number of bytes written if
    // successful, and returns '0' if the buffer wasn't large enough:

    if ((newSize < 1) || (newSize > sizeof(stackBuffer)))
    {
        // Our stack buffer wasn't big enough.  Figure out the required
        // size:

        newSize = ::GetRegionData(hRgn, 0, NULL);
        if (newSize > 1)
        {
            regionBuffer = (RGNDATA*)GpMalloc(newSize);
            if (regionBuffer == NULL)
            {
                SetValid(FALSE);
                return;
            }

            // Initialize to a decent result in the unlikely event of
            // failure of GetRegionData:

            regionBuffer->rdh.nCount = 0;

            ::GetRegionData(hRgn, newSize, regionBuffer);
        }
    }

    // Add the rects from the region to the path

    if(regionBuffer->rdh.nCount > 0)
    {
        if (this->AddRects((RECT*)&(regionBuffer->Buffer[0]),
                           regionBuffer->rdh.nCount) != Ok)
        {
            SetValid(FALSE);
        }
    }

    // Free the temporary buffer if one was allocated:

    if (regionBuffer != (RGNDATA*) &stackBuffer[0])
    {
        GpFree(regionBuffer);
    }
}

// create a path from a GDI+ region
GpPath::GpPath(
    const DpRegion*     region
    )
{
    InitDefaultState(FillModeAlternate);

    if (region == NULL)
    {
        return;
    }

    RegionToPath    convertRegion;
    DynPointArray   pointsArray;

    if (convertRegion.ConvertRegionToPath(region, pointsArray, Types))
    {
        int             count;
        int             i;
        GpPointF *      realPoints;
        GpPoint *       points;

        count  = Types.GetCount();

        if ((count <= 0) || (pointsArray.GetCount() != count) ||
            (!ValidatePathTypes(Types.GetDataBuffer(), count, &SubpathCount, &HasBezier)))
        {
            goto NotValid;
        }
        // else it is valid

        // add all the space for the count in the Points up front
        realPoints = Points.AddMultiple(count);
        if (realPoints == NULL)
        {
            goto NotValid;
        }

        // add the points, converting from int to real
        points = pointsArray.GetDataBuffer();
        i = 0;
        do
        {
            realPoints[i].X = (REAL)points[i].X;
            realPoints[i].Y = (REAL)points[i].Y;
        } while (++i < count);

        SetValid(TRUE);

        // Make sure the first point is the start type.
        ASSERT(Types[0] == PathPointTypeStart);

        return;
    }

NotValid:
    WARNING(("Failed to convert a region to a path"));
    this->Reset();
    SetValid(FALSE);
}


/**************************************************************************\
*
* Function Description:
*
*   Returns a const pointer to the internal SubpathInfoCache. This structure
*   holds the data representing the position and size of each subpath in 
*   the path data structures.
*
* History:
*
*   10/20/2000 asecchia
*       Created.
*
\**************************************************************************/

DynArray<GpPath::SubpathInfo> *GpPath::GetSubpathInformation() const
{
    if((CacheFlags & kSubpathInfoValid) == 0)
    {
        ComputeSubpathInformationCache();
        ASSERT((CacheFlags & kSubpathInfoValid) == kSubpathInfoValid)
    }
    
    return &SubpathInfoCache;
}


/**************************************************************************\
*
* Function Description:
*
*   Computes the Subpath information cache and marks it as valid.
*   This code walks the entire path and stores the start and count for
*   each subpath. It also notes if the subpath is closed or open.
*
* History:
*
*   10/20/2000 asecchia
*       Created.
*
\**************************************************************************/
    
VOID GpPath::ComputeSubpathInformationCache() const
{
    // Get the path data:
    
    GpPointF *points = Points.GetDataBuffer();
    BYTE *types = Types.GetDataBuffer();
    INT count = Points.GetCount();

    // Clear out any old cached subpath state.
    
    SubpathInfoCache.Reset();

    INT i = 0;  // current position in the path.
    INT c = 0;  // current count of the current subpath.

    // <= so that we can implicitly handle the last subpath without
    // duplicating the code for the inner loop.
    
    while(i <= count)
    {
        // i==count means we hit the end - and potentially need to look at
        // the last subpath. Otherwise look at the most recent subpath if 
        // we find a new start marker.
        
        if( ((i==count) || IsStartType(types[i])) && (i != 0))
        {
            // Found a subpath.
            
            SubpathInfo subpathInfo;
            
            subpathInfo.StartIndex = i-c;
            subpathInfo.Count = c;
            subpathInfo.IsClosed = IsClosedType(types[i-1]);
            
            SubpathInfoCache.Add(subpathInfo);
            
            // We're actually on the first point of the next subpath.
            // (or we're about to terminate the loop)
            
            c = 1;
        } 
        else
        {
            c++;
        }
        i++;
    }
    
    // Mark the subpath information cache as valid.
    
    CacheFlags |= kSubpathInfoValid;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\ntfsstream.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   NtfsStream.hpp
*
* Abstract:
*
*   This file provides the Flat File IStream implementation.
*
* Created:
*
*   4/26/1999 Mike Hillberg
*
\**************************************************************************/

#pragma once

#ifndef _NTFSSTREAM_HPP
#define _NTFSSTREAM_HPP

#define ErrJmp(comp, label, errval, var) \
{\
    var = errval;\
    goto label;\
}

#define nffErr(l, e) ErrJmp(nff, l, e, sc)

#define nffChkTo(l, e) if (FAILED(sc = (e))) nffErr(l, sc) else 1
#define nffChk(e) nffChkTo(EH_Err, e)

#define nffHChkTo(l, e) if (FAILED(sc = DfGetScode(e))) nffErr(l, sc) else 1
#define nffHChk(e) nffHChkTo(EH_Err, e)

#define nffMemTo(l, e) \
    if ((e) == NULL) nffErr(l, STG_E_INSUFFICIENTMEMORY) else 1
#define nffMem(e) nffMemTo(EH_Err, e)

#define nffBoolTo(l, e) if (!(e)) nffErr(l, LAST_STG_SCODE) else 1
#define nffBool(e)   nffBoolTo(EH_Err, e)

#define STREAMBUFFERSIZE 8192


////////////////////////////////////////////////////////////////
//  IStream for a file stream.
//
class FileStream : public IStream
{

    //  ------------
    //  Construction
    //  ------------

public:

    FileStream(  );
    virtual ~FileStream();
    virtual HRESULT Init( HANDLE hFile,
                          DWORD grfMode,
                          const OLECHAR *pwcsName );

    //  --------
    //  IUnknown
    //  --------

    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObject);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);


    //  -------
    //  IStream
    //  -------

    HRESULT STDMETHODCALLTYPE Read(
        /* [length_is][size_is][out] */ void __RPC_FAR *pv,
        /* [in] */ ULONG cb,
        /* [out] */ ULONG __RPC_FAR *pcbRead);

    HRESULT STDMETHODCALLTYPE Write(
        /* [size_is][in] */ const void __RPC_FAR *pv,
        /* [in] */ ULONG cb,
        /* [out] */ ULONG __RPC_FAR *pcbWritten);

    HRESULT STDMETHODCALLTYPE Seek(
        /* [in] */ LARGE_INTEGER dlibMove,
        /* [in] */ DWORD dwOrigin,
        /* [out] */ ULARGE_INTEGER __RPC_FAR *plibNewPosition);

    HRESULT STDMETHODCALLTYPE SetSize(
        /* [in] */ ULARGE_INTEGER libNewSize);

    HRESULT STDMETHODCALLTYPE CopyTo(
        /* [unique][in] */ IStream __RPC_FAR *pstm,
        /* [in] */ ULARGE_INTEGER cb,
        /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbRead,
        /* [out] */ ULARGE_INTEGER __RPC_FAR *pcbWritten);

    HRESULT STDMETHODCALLTYPE Commit(
        /* [in] */ DWORD grfCommitFlags);

    HRESULT STDMETHODCALLTYPE Revert(void);

    HRESULT STDMETHODCALLTYPE LockRegion(
        /* [in] */ ULARGE_INTEGER libOffset,
        /* [in] */ ULARGE_INTEGER cb,
        /* [in] */ DWORD dwLockType);

    HRESULT STDMETHODCALLTYPE UnlockRegion(
        /* [in] */ ULARGE_INTEGER libOffset,
        /* [in] */ ULARGE_INTEGER cb,
        /* [in] */ DWORD dwLockType);

    HRESULT STDMETHODCALLTYPE Stat(
        /* [out] */ STATSTG __RPC_FAR *pstatstg,
        /* [in] */ DWORD grfStatFlag);

    HRESULT STDMETHODCALLTYPE Clone(
        /* [out] */ IStream __RPC_FAR *__RPC_FAR *ppstm);

public:

    inline BOOL IsWriteable();
    HRESULT CheckReverted();


    //  ----------------
    //  Internal Methods
    //  ----------------

protected:

    virtual HRESULT ShutDown();
    HRESULT Delete();

private:

    HRESULT SetFileSize( const CULargeInteger &uliNewSize );
    HRESULT Rename( const WCHAR *pwcsName, BOOL fOverWrite );

    inline HRESULT Lock( DWORD dwTimeout );
    inline HRESULT Unlock();

    static HRESULT DeleteStream( HANDLE *phStream );

    HANDLE GetFileHandle();


    //  --------------
    //  Internal State
    //  --------------

private:

    CRITICAL_SECTION    _critsec;
    BOOL                _bCritSecInitialized;
    WCHAR *             _pwcsName;

    DWORD               _grfMode;               // The mode used to open the IStream
    HANDLE              _hFile;                 // File represented by this stream

    LONG                _cRefs;                 // Reference count


    // This class maintains its own copy of the seek pointer, different from
    // the underlying file's.  This is necessary so that the IStream methods mantain
    // a consistent seek location, even when methods on e.g. IMappedStream are called.

    CLargeInteger       _liCurrentSeekPosition;

};   // class FileStream


inline HANDLE
FileStream::GetFileHandle()
{
    return _hFile;
}

inline HRESULT
FileStream::CheckReverted()
{
    if(INVALID_HANDLE_VALUE == _hFile)
        return STG_E_REVERTED;

    return S_OK;
}


inline BOOL
GrfModeIsWriteable( DWORD grfMode )
{
    return( (STGM_WRITE & grfMode) || (STGM_READWRITE & grfMode) );
}


inline BOOL
FileStream::IsWriteable()
{
    return( GrfModeIsWriteable( _grfMode ));
}


inline HRESULT
FileStream::Lock( DWORD dwTimeout )
{
    EnterCriticalSection( &_critsec );
    return( S_OK );
}


inline HRESULT
FileStream::Unlock()
{
    LeaveCriticalSection( &_critsec );
    return( S_OK );
}

#endif // _NTFSSTREAM_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\object.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   Object.cpp
*
* Abstract:
*
*   Object factory for playing metafiles
*
* Created:
*
*   9/10/1999 DCurtis
*
\**************************************************************************/

#include "precomp.hpp"
#include "..\imaging\api\comutils.hpp"

GpObject * 
GpObject::Factory(
    ObjectType          type,
    const ObjectData *  objectData,
    UINT                size
    )
{
    GpObject *  object = NULL;
    
    ASSERT(ObjectTypeIsValid(type));

    switch (type)
    {
    case ObjectTypeBrush:
        if (size >= sizeof(ObjectTypeData))
        {
            GpBrushType brushType = (GpBrushType)(((ObjectTypeData *)objectData)->Type);

            switch(brushType)
            {
            case BrushTypeSolidColor:
                object = new GpSolidFill();
                break;
    
            case BrushTypeHatchFill:
                object = new GpHatch();
                break;
    
            case BrushTypeTextureFill:
                object = new GpTexture();
                break;
/*
            // Removed for v1    
            case BrushRectGrad:
                object = new GpRectGradient();
                break;
*/
            case BrushTypeLinearGradient:
                object = new GpLineGradient();
                break;
/*
            // Removed for v1    
            case BrushRadialGrad:
                object = new GpRadialGradient();
                break;
    
            case BrushTriangleGrad:
                object = new GpTriangleGradient();
                break;
*/
            case BrushTypePathGradient:
                object = new GpPathGradient();
                break;
    
            default:
                ASSERT(0);          // unsupported brush type
                break;
            }
        }
        else
        {
            WARNING(("size is too small"));
        }
        break;

    case ObjectTypePen:
        object = new GpPen(GpColor(0,0,0), 1.0f);
        break;
        
    case ObjectTypePath:
        object = new GpPath();
        break;
        
    case ObjectTypeRegion:
        object = new GpRegion();
        break;
        
    case ObjectTypeImage:
        ASSERT(size >= sizeof(INT32));
        if (size >= sizeof(INT32))
        {
            GpImageType imageType = (GpImageType)(((ObjectTypeData *)objectData)->Type);

            switch(imageType)
            {
            case ImageTypeBitmap:
                object = new GpBitmap();
                break;
        
            case ImageTypeMetafile:
                object = new GpMetafile();
                break;

            default:
                ASSERT(0);          // unsupported image type
                break;
            }
        }
        break;
        
    case ObjectTypeFont:
        object = new GpFont();
        break;

    case ObjectTypeStringFormat:
        object = new GpStringFormat();
        break;
        
    case ObjectTypeImageAttributes:
        object = new GpImageAttributes();
        break;
        
    case ObjectTypeCustomLineCap:
        if (size >= sizeof(ObjectTypeData))
        {
            CustomLineCapType capType = (CustomLineCapType)(((ObjectTypeData *)objectData)->Type);

            switch(capType)
            {
            case CustomLineCapTypeDefault:
                object = new GpCustomLineCap();
                break;
    
            case CustomLineCapTypeAdjustableArrow:
                object = new GpAdjustableArrowCap();
                break;
    
            default:
                ASSERT(0);          // unsupported CustomLineCapType
                break;
            }
        }
        else
        {
            WARNING(("size is too small"));
        }
        break;

    default:                    // unsupported object type
        ASSERT(0);
        break;
    }

    return object;
}

class ExternalObjectData
{
public:
    UINT32      DataSize;
    UINT32      DataCRC;
};

UINT 
GpObject::GetExternalDataSize() const
{
    UINT    dataSize = this->GetDataSize();
    
    ASSERT(dataSize >= sizeof(ObjectData));
    ASSERT((dataSize & 0x03) == 0);
    
    return sizeof(ExternalObjectData) + dataSize;
}

GpStatus 
GpObject::GetExternalData(
    BYTE *      dataBuffer, 
    UINT &      size
    )
{
    ASSERT((dataBuffer != NULL) && (size > 0));
    
    if (size < (sizeof(ExternalObjectData) + sizeof(ObjectData)))
    {
        return InsufficientBuffer;
    }
    size -= sizeof(ExternalObjectData);
    BYTE *  objectData = dataBuffer + sizeof(ExternalObjectData);
    
    UINT        checkSum = 0;
    GpStatus    status = this->GetData(objectData, size);
    if (status == Ok)
    {
        checkSum = Crc32(objectData, size, 0);
    }
    
    ((ExternalObjectData *)dataBuffer)->DataSize = size;
    ((ExternalObjectData *)dataBuffer)->DataCRC  = checkSum;
    
    size += sizeof(ExternalObjectData);
    
    return status;
}

GpStatus 
GpObject::SetExternalData(
    const BYTE *    dataBuffer, 
    UINT            size
    )
{
    ASSERT((dataBuffer != NULL) && (size > 0));
    
    if (size < (sizeof(ExternalObjectData) + sizeof(ObjectData)))
    {
        return InsufficientBuffer;
    }
    
    size -= sizeof(ExternalObjectData);
    UINT    dataSize = ((ExternalObjectData *)dataBuffer)->DataSize;
    
    if (size < dataSize)
    {
        return InsufficientBuffer;
    }

    const BYTE *  objectData = dataBuffer + sizeof(ExternalObjectData);
    UINT          checkSum   = Crc32(objectData, dataSize, 0);
    
    if (((ExternalObjectData *)dataBuffer)->DataCRC != checkSum)
    {
        return InvalidParameter;
    }
    
    return this->SetData(objectData, size);
}

class ObjectBufferStream : public IUnknownBase<IStream>
{
public:
    ObjectBufferStream(BYTE * dataBuffer, UINT size)
    {
        ASSERT((dataBuffer != NULL) && (size > 0));
        
        DataBuffer = dataBuffer;
        BufferSize = size;
        Position   = 0;
        Valid      = TRUE;
    }
    
    ~ObjectBufferStream()
    {
    }

    BOOL IsValid() const
    {
        return Valid;
    }

    // how much data did we fill up?
    ULONG GetSize() const { return Position; } 

    HRESULT STDMETHODCALLTYPE Write(
        VOID const HUGEP *pv, 
        ULONG cb, 
        ULONG *pcbWritten) 
    {
        if (cb == 0)
        {
            if (pcbWritten != NULL)
            {
                *pcbWritten = cb;
            }
            return S_OK;
        }

        ASSERT (pv != NULL);

        if (Valid)
        {
            ULONG   spaceLeft = BufferSize - Position;
            
            if (cb <= spaceLeft)
            {
                GpMemcpy(DataBuffer + Position, pv, cb);
                Position += cb;
                if (pcbWritten != NULL)
                {
                    *pcbWritten = cb;
                }
                return S_OK;
            }

            // copy what we can
            if (spaceLeft > 0)
            {
                GpMemcpy(DataBuffer + Position, pv, spaceLeft);
                Position += spaceLeft;
            }

            if (pcbWritten != NULL)
            {
                *pcbWritten = spaceLeft;
            }

            Valid = FALSE;  // tried to write past end of DataBuffer
            WARNING(("Tried to write past end of DataBuffer"));
        }
        return E_FAIL;
    }

    HRESULT STDMETHODCALLTYPE Read(
        VOID HUGEP *pv, 
        ULONG cb, 
        ULONG *pcbRead)
    {
        return E_NOTIMPL;
    }

    HRESULT STDMETHODCALLTYPE Seek(
        LARGE_INTEGER dlibMove, 
        DWORD dwOrigin, 
        ULARGE_INTEGER *plibNewPosition) 
    {
        return E_NOTIMPL;
    }

    HRESULT STDMETHODCALLTYPE SetSize(
        ULARGE_INTEGER libNewSize) 
    {
        return E_NOTIMPL;
    }

    HRESULT STDMETHODCALLTYPE CopyTo(
        IStream *pstm, 
        ULARGE_INTEGER cb, 
        ULARGE_INTEGER *pcbRead, 
        ULARGE_INTEGER *pcbWritten) 
    {
        return E_NOTIMPL;
    }

    HRESULT STDMETHODCALLTYPE Commit(
        DWORD grfCommitFlags) 
    {
        return E_NOTIMPL;
    }

    HRESULT STDMETHODCALLTYPE Revert(VOID) 
    {
        return E_NOTIMPL;
    }

    HRESULT STDMETHODCALLTYPE LockRegion(
        ULARGE_INTEGER libOffset, 
        ULARGE_INTEGER cb, 
        DWORD dwLockType) 
    {
        return E_NOTIMPL;
    }
    
    HRESULT STDMETHODCALLTYPE UnlockRegion(
        ULARGE_INTEGER libOffset, 
        ULARGE_INTEGER cb, 
        DWORD dwLockType) 
    {
        return E_NOTIMPL;
    }

    HRESULT STDMETHODCALLTYPE Stat(
        STATSTG *pstatstg, 
        DWORD grfStatFlag) 
    {
        return E_NOTIMPL;
    }

    HRESULT STDMETHODCALLTYPE Clone(
        IStream **ppstm) 
    {
        return E_NOTIMPL;
    }

private:
    BYTE *  DataBuffer;
    ULONG   BufferSize;
    ULONG   Position;
    BOOL    Valid;
};

GpStatus 
GpObject::GetData(
    BYTE *      dataBuffer, 
    UINT &      size
    ) const
{
    if ((dataBuffer != NULL) && (size > 0))
    {
        ObjectBufferStream  objectBufferStream(dataBuffer, size);
        
        this->GetData(&objectBufferStream);
        size = objectBufferStream.GetSize();
        return objectBufferStream.IsValid() ? Ok : InsufficientBuffer;
    }
    size = 0;
    return InvalidParameter;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\path.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998-1999  Microsoft Corporation
*
* Module Name:
*
*   path.hpp
*
* Abstract:
*
*   Path related declarations
*
* Revision History:
*
*   12/06/1998 davidx
*       Created it.
*
*   06/16/1999 t-wehunt
*       Added RemoveSelfIntersections().
*
\**************************************************************************/

#ifndef _PATH_HPP
#define _PATH_HPP

// This is used by the widener as an internal flag and as a deletion mask for
// the endcap placement code. These two usages do not overlap.

const INT PathPointTypeInternalUse  = 0x40;

/*
// PathPointType is defined in GdiplusEnums.h.
// Internally, we can use 0x40 for the internal use.

//--------------------------------------------------------------------------
// Path point types (only the lowest 8 bits are used.)
//  The lowest 3 bits are interpreted as point type
//  The higher 5 bits are reserved for flags.
//--------------------------------------------------------------------------

enum PathPointType
{
    PathPointTypeStart           = 0,    // move
    PathPointTypeLine            = 1,    // line
    PathPointTypeBezier          = 3,    // default Beizer (= cubic Bezier)
    PathPointTypePathTypeMask    = 0x07, // type mask (lowest 3 bits).
    PathPointTypeDashMode        = 0x10, // currently in dash mode.
    PathPointTypePathMarker      = 0x20, // a marker for the path.
    PathPointTypeCloseSubpath    = 0x80, // closed flag

    // Path types used for advanced path.

    PathPointTypeBezier2    = 2,    // quadratic Beizer
    PathPointTypeBezier3    = 3,    // cubic Bezier
    PathPointTypeBezier4    = 4,    // quartic (4th order) Beizer
    PathPointTypeBezier5    = 5,    // quintic (5th order) Bezier
    PathPointTypeBezier6    = 6     // hexaic (6th order) Bezier
};
*/

class GpGlyphPath;

inline BOOL IsStartType(BYTE type)
{
    return ((type & PathPointTypePathTypeMask) == 
               PathPointTypeStart);
}

inline BOOL IsClosedType(BYTE type)
{
    return ((type & PathPointTypeCloseSubpath) == 
               PathPointTypeCloseSubpath);
}

inline BOOL IsDashType(BYTE type)
{
    return ((type & PathPointTypeDashMode) == 
               PathPointTypeDashMode);
}


class GpPath : public DpPath
{
friend class GpGraphics;
friend class GpPathGradient;

public:

    // Path constructors

    GpPath(GpFillMode fillMode = FillModeAlternate)
    {
        InitDefaultState(fillMode);
        SetValid(TRUE);
    }

    GpPath(const GpPointF* points,
           const BYTE* types,
           INT count,
           GpFillMode fillMode = FillModeAlternate);

    GpPath(
        const GpPointF *points,
        INT count,
        GpPointF *stackPoints,
        BYTE *stackTypes,
        INT stackCount,
        GpFillMode fillMode = FillModeAlternate,
        DpPathFlags flags = PossiblyNonConvex
        );

    GpPath(HRGN hRgn);              // create a path from a GDI region handle
    GpPath(const DpRegion* region); // create a path from a GDI+ region

    // Get the lock object

    GpLockable *GetObjectLock()
    {
        return &Lockable;
    }

    GpPath* Clone() const
    {
        ASSERT(IsValid())

        GpPath* path = new GpPath(this);

        CheckValid(path);
        return path;
    }

    GpStatus Reset(GpFillMode fillMode = FillModeAlternate)
    {

        // !!! bhouse We should allow reseting invalid paths

        ASSERT(IsValid());

        InitDefaultState(fillMode);
        return Ok;
    }

    virtual GpStatus
    GetBounds(
        GpRect *bounds,
        const GpMatrix *matrix = NULL,
        const DpPen* pen = NULL,
        REAL dpiX = 0,
        REAL dpiY = 0
        ) const;

    virtual GpStatus
    GetBounds(
        GpRectF *bounds,
        const GpMatrix *matrix = NULL,
        const DpPen* pen = NULL,
        REAL dpiX = 0,
        REAL dpiY = 0
        ) const;

    REAL GetSharpestAngle() const
    {

        if(!(CacheFlags & kSharpestAngleValid))
            CalcSharpestAngle();

        return SharpestAngle;
    }

    // Set a marker at the current location.

    GpStatus SetMarker();

    // Clear all markers.

    GpStatus ClearMarkers();

    // Add lines to the path object

    GpStatus AddLine(const GpPointF& pt1, const GpPointF& pt2)
    {
        GpPointF points[2];

        points[0] = pt1;
        points[1] = pt2;

        return AddLines(points, 2);
    }

    GpStatus AddLine(REAL x1, REAL y1, REAL x2, REAL y2)
    {
        GpPointF points[2];

        points[0].X = x1;
        points[0].Y = y1;
        points[1].X = x2;
        points[1].Y = y2;

        return AddLines(points, 2);
    }

    GpStatus AddLines(const GpPointF* points, INT count);

    // Add an arc to the path object

    GpStatus AddArc(const GpRectF& rect, REAL startAngle, REAL sweepAngle);

    GpStatus AddArc(REAL x, REAL y, REAL width, REAL height,
                    REAL startAngle, REAL sweepAngle)
    {
        GpRectF rect(x, y, width, height);
        return AddArc(rect, startAngle, sweepAngle);
    }

    // Add Bezier curves to the path object

    GpStatus AddBezier(const GpPointF& pt1, const GpPointF& pt2,
                       const GpPointF& pt3, const GpPointF& pt4);
    GpStatus AddBezier(REAL x1, REAL y1, REAL x2, REAL y2,
                       REAL x3, REAL y3, REAL x4, REAL y4);
    GpStatus AddBeziers(const GpPointF* points, INT count);

    // Add cardinal splines to the path object

    GpStatus AddCurve(const GpPointF* points, INT count);
    GpStatus AddCurve(const GpPointF* points, INT count, REAL tension,
                      INT offset, INT numberOfSegments);
    GpStatus AddClosedCurve(const GpPointF* points, INT count);
    GpStatus AddClosedCurve(const GpPointF* points, INT count, REAL tension);

    // Add closed shapes to the path object

    GpStatus AddRects(const GpRectF* rects, INT count);
    GpStatus AddRects(const RECT* rects, INT count);
    GpStatus AddPolygon(const GpPointF* points, INT count);
    GpStatus AddEllipse(const GpRectF& rect);
    GpStatus AddPie(const GpRectF& rect, REAL startAngle, REAL sweepAngle);

    GpStatus AddRect(const GpRectF& rect)
    {
        return AddRects(&rect, 1);
    }

    GpStatus AddEllipse(REAL x, REAL y, REAL width, REAL height)
    {
        GpRectF rect(x, y, width, height);
        return AddEllipse(rect);
    }

    GpStatus AddPie(REAL x, REAL y, REAL width, REAL height,
                    REAL startAngle, REAL sweepAngle)
    {
        GpRectF rect(x, y, width, height);
        return AddPie(rect, startAngle, sweepAngle);
    }

    // Add a path to the path object

    GpStatus AddPath(const GpPointF* points, const BYTE* types, INT count,
                        BOOL connect);
    GpStatus AddPath(const GpPath* path, BOOL connect);

    // Reverse the direction of a path.

    GpStatus Reverse();

    GpStatus GetLastPoint(GpPointF* point);

    // used by font

    GpStatus MoveTo(const GpPointF point);
    GpStatus AddPoints(const GpPointF* points, ULONG count, PathPointType type);
    GpStatus AddGlyphPath(GpGlyphPath *glyphPath, REAL x, REAL y, const GpMatrix * matrix = 0);

    GpStatus AddString(
        const WCHAR          *string,
        INT                   length,
        const GpFontFamily   *family,
        INT                   style,
        REAL                  emSize,
        const RectF          *layoutRect,
        const GpStringFormat *format
    );

    // Get the flatten data.

    virtual GpStatus Flatten(
        DynByteArray *flattenTypes,
        DynPointFArray *flattenPoints,
        const GpMatrix *matrix = NULL,
        const REAL flatness = FlatnessDefault
    ) const;


    // Flatten this path.
    
    GpStatus Flatten(
        const GpMatrix *matrix = NULL,
        const REAL flatness = FlatnessDefault
    );

    // Get the morph and flatten data.

    GpStatus WarpAndFlatten(
        DynByteArray* flattenTypes,
        DynPointFArray* flattenPoints,
        const GpMatrix* matrix,
        const GpPointF* destPoint,
        INT count,
        const GpRectF& srcRect,
        WarpMode warpMode = WarpModePerspective
        );

    // Morph and flatten itself.

    GpStatus WarpAndFlattenSelf(
        GpMatrix* matrix,
        const GpPointF* destPoint,
        INT count,
        const GpRectF& srcRect,
        WarpMode warpMode = WarpModePerspective
        );                  // Morph to the flatten points.

    // Widen the path object

    GpPath*
    GetWidenedPath(
        const GpPen* pen,
        const GpMatrix* matrix = NULL,
        REAL flatness = FlatnessDefault
        ) const;

    GpStatus
    Widen(
        GpPen* pen,
        GpMatrix* matrix = NULL,
        REAL flatness = FlatnessDefault
    );

    // Get the flattened path.

    virtual const DpPath *
    GetFlattenedPath(
        const GpMatrix* matrix,
        DpEnumerationType type,
        const DpPen* pen = NULL
        ) const;

    // Dreate a dashed path. (override)

    GpPath*
    CreateDashedPath(
        const GpPen* pen,
        const GpMatrix* matrix,
        REAL dpiX,
        REAL dpiY,
        REAL dashScale = 1.0f,
        BOOL needDashCaps = TRUE
        ) const;

    GpPath*
    CreateDashedPath(
        const DpPen* pen,
        const GpMatrix* matrix,
        REAL dpiX,
        REAL dpiY,
        REAL dashScale = 1.0f,
        BOOL needDashCaps = TRUE
        ) const;

    // Get the open and closed portion of the current path.

    GpPath* GetOpenPath();
    GpPath* GetClosedPath();

    // Determine if the path is empty, i.e. with no points

    BOOL IsEmpty() const
    {
        return GetPointCount() == 0;
    }

    BOOL IsRectangle(
        const GpMatrix * matrix,
        GpRectF * transformedBounds = NULL
        ) const;

    // Determine if path consists of a single polygon/polyline.

    BOOL IsPolygon() const
    {
        return (SubpathCount == 1) && !HasBezier;
    }

    // Return true if the two objects represent identical paths

    BOOL IsEqual(const GpPath* path) const;

    // Transform the path by the specified matrix

    VOID Transform(const GpMatrix * matrix);

    VOID SetHasBezier(BOOL _hasBezier)  { HasBezier = _hasBezier; }

    // Hit testing

    GpStatus IsVisible(
        GpPointF* point,
        BOOL* isVisible,
        GpMatrix* matrix = NULL);

    GpStatus IsOutlineVisible(GpPointF* point, BOOL* isVisible, GpPen* pen,
                    GpMatrix* matrix = NULL, REAL dpiX = 0, REAL dpiY = 0);


    // DDI entry point handlers for DpPath

    static GpPath* GetPath(const DpPath* path)
    {
        return (GpPath*)(path);
    }

    static DpPath* DriverCreateWidenedPath(
        const DpPath* path,
        const DpPen* pen,
        DpContext* context,
        BOOL outline
    );
    
    static VOID DriverDeletePath(DpPath* path);

    static DpPath* DriverClonePath(DpPath* path);

    static VOID DriverTransformPath(DpPath* path, GpMatrix* matrix);

    // Compute the winding mode outline.
    
    GpStatus ComputeWindingModeOutline(
        const GpMatrix *matrix, 
        REAL flatness, 
        BOOL *wereIntersectsRemoved = NULL
    );
    
    // Used for a mark-sweep point deletion algorithm in the path.
    
    VOID EraseMarkedSegments();

    virtual DynArray<SubpathInfo> *GetSubpathInformation() const;

protected:

    VOID ComputeSubpathInformationCache() const;

    GpPath(const GpPath* path);

    GpPath *GetWidenedPathInternal(
        const DpPen *pen,
        const GpMatrix *matrix,
        REAL flatness = FlatnessDefault,
        BOOL insetPen = FALSE
    ) const;

protected:

    BYTE*
    AddPointHelper(
        const GpPointF* points,
        INT count,
        BOOL addClosedFigure
        );

    GpPath*
    GetOpenOrClosedPath(BOOL openPath);

    static GpPointF*
    ConvertSplineToBezierPoints(
        const GpPointF* points,
        INT count,
        INT offset,
        INT numberOfSegments,
        REAL tension,
        INT* bezierCount
        );

    static INT
    GetArcPoints(
        GpPointF* points,
        const GpRectF& rect,
        REAL startAngle,
        REAL sweepAngle
        );

    VOID InitDefaultState(GpFillMode fillMode);

    VOID ResetCacheBounds() const
    {
        CacheFlags = (kCacheBoundsValid | kSharpestAngleValid);
        SharpestAngle = 2;
        CacheBounds.X = 0;
        CacheBounds.Y = 0;
        CacheBounds.Width = 0;
        CacheBounds.Height = 0;
    }

    VOID InvalidateCache() const
    {
        CacheFlags = 0;
    }

    VOID UpdateCacheBounds() const
    {
        if(!(CacheFlags & kCacheBoundsValid))
            CalcCacheBounds();
    }

    VOID CalcCacheBounds() const;
    VOID CalcSharpestAngle() const;

    // Data Members:
    protected:

    GpLockable Lockable;    // object lock

    enum {
        kCacheBoundsValid = 1,
        kSharpestAngleValid = 2,
        kSubpathInfoValid = 4
    };

    mutable ULONG CacheFlags;
    mutable GpRectF CacheBounds;
    mutable REAL SharpestAngle;
    
    // Some small number of subpaths for our initial allocation should suffice
    // for most usage scenarios.
    
    mutable DynArrayIA<SubpathInfo, 3> SubpathInfoCache;
};

class GpPathIterator : public DpPathIterator
{
public:
    GpPathIterator(GpPath* path) : DpPathIterator(path)
    {
    }

    virtual INT GetCount()
    {
        if(IsValid())
            return Count;
        else
            return 0;
    }

    virtual INT GetSubpathCount()
    {
        if(IsValid())
            return SubpathCount;
        else
            return 0;
    }

    // This iterator is not used for the extended path.

    virtual BOOL IsValid() {return (DpPathIterator::IsValid() && !ExtendedPath);}

    // Get the lock object

    GpLockable *GetObjectLock()
    {
        return &Lockable;
    }

protected:

    GpLockable Lockable;
};

#endif // !_PATH_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\pathselfintersectremover.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Path Self Intersection Remover Class.
*
* Abstract:
*
*   Classes and functions used to remove self intersections in paths.
*   Given a path, it produces one or more polygons which can be used to 
*   draw a widened path that is safe to use alternate fill mode with.
*
* Notes:
* 
*   Modified from Office code frOm John Bowler (at least that is what
*   ericvan told me). Apparently owned by some 'KasiaK', but no idea
*   who that is. (He is apparently retired)
*   CAUTION: Not thoroughly tested yet for arbitrary paths.
*
*   API:
*     Init(EstimatedNumPts);
*     AddPolygon(pathPts, numPts);
*     RemoveSelfIntersects();
*     GetNewPoints(newPts, polyCounts, numPolys, numTotalPts);
*
* Created:
*
*   06/06/1999 t-wehunt
*
\**************************************************************************/

#include "precomp.hpp"

// Return values for IntersectEdge
#define DONOT_INTERS 0
#define COMMON_POINT 1
#define INTERSECT    2
#define COLINEAR     3

// Used to produce the IEEE floating-point representation of infinity.
// Note that a few compile warnings have to be turned off to stop
// warnings about constant arithmetic overflow.

#pragma warning (disable : 4056 4756)
#define FP_INF (FLT_MAX+FLT_MAX)

/**************************************************************************\
*
* Function Description:
*
*   Insert a new item into a sorted dynamic array, keeping it sorted.
*
* Arguments:
*
*  newItem     - new item to be inserted
*  compareFunc - comparison function to be used for insertion.
*  userData    - User-specified data for use by the compare func.
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

template <class T>
GpStatus 
DynSortArray<T>::InsertSorted(
    T &newItem, 
    DynSortArrayCompareFunc compareFunc,
    VOID *userData
    )
{
    // insert item into sorted position of list.
    T *cur;
    INT pos = 0;
    GpStatus status;

    cur = GetDataBuffer();

    {
        INT sgn = 1; 
        unsigned iMin = 0;
        unsigned iMid = 0;
        unsigned iEnd = GetCount();
        while (iMin != iEnd)
        {
           iMid = iMin + (iEnd-iMin)/2;
           //Assert(iMid != iMac);
           sgn = compareFunc(
               (PathSelfIntersectRemover*)userData,
               &GetDataBuffer()[iMid],
               &newItem
               );
           if (sgn == 0)
           {
              // newItem already in sorted list, return index.
              return Ok;
           }
           if (sgn < 0)   // x(iMid) < x(p)
              iMin = iMid+1;
           else
              iEnd = iMid;
        }

        pos = iMin;
    }

    status = InsertAt(pos,newItem);
    if (status != Ok)
    {
        return status;
    }

    cur = &GetDataBuffer()[pos];

    return Ok;
}

/****************************************************************************\
    Private helper functions
\****************************************************************************/

/**************************************************************************\
*
* Function Description:
*
*   Return the sign of an INT
*
* Arguments:
*
*  newItem     - new item to be inserted
*  compareFunc - comparison function to be used for insertion.
*  userData    - User-specified data for use by the compare func.
*
* Return Value:
*
*   1 if greater than zero
*   0 if equal to zero
*  -1 if less than zero
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

inline INT SignReal(const REAL i) { return (i > 0) - (i < 0); }

/**************************************************************************\
*
* Function Description:
*
*   Insert an edge into a linked list. This assumes the edge is an 
*   orphaned edge (not connected in a current list). Use DeleteEdgeFromList
*   to orphan an edge if it's already in a list.
*
*   This uses a double indirection pointer to track the address of the 
*   Next pointer that points to the current element rather than actually
*   tracking the current element. This simplifies the code significantly.
*
* Created:
*
*   12/23/2000 asecchia
*
\**************************************************************************/

void PathSelfIntersectRemover::InsertEdgeIntoList(
    INT *pListHead,
    INT index,
    DynSortArrayCompareFunc compare
)
{
    ASSERT(EdgeList[index].Next == LIST_END);
    ASSERT(index >= 0);
    ASSERT(pListHead);
    
    INT *pIndex = pListHead;
    Edge *newEdge = &EdgeList[index];
    
    // Calculate the YCur for this edge.
    
    newEdge->YCur = PathPts[newEdge->SortBegin].Y;
    newEdge->SortBegin = newEdge->Begin;
    newEdge->SortEnd = newEdge->End;
    newEdge->Normalize();

    
    while(*pIndex != LIST_END)
    {
        if(compare(this, &EdgeList[*pIndex], newEdge) != -1)
        {
            // if we find the right spot, exit the search loop.
            
            break;
        }
    
        // keep looking...
        
        pIndex = &EdgeList[*pIndex].Next;
    }
    
    // Do the insertion
    
    newEdge->Next = *pIndex;
    *pIndex = index;
}


/**************************************************************************\
*
* Function Description:
*
*   Delete an edge from a linked list.
*   This uses a double indirection pointer to track the address of the 
*   Next pointer that points to the current element rather than actually
*   tracking the current element. This simplifies the code significantly.
*
*   Returns true if it found and deleted the edge, false otherwise.
*
* Created:
*
*   12/23/2000 asecchia
*
\**************************************************************************/

bool PathSelfIntersectRemover::DeleteEdgeFromList(
    INT *pListHead,
    INT index
)
{
    ASSERT(index >= 0);
    ASSERT(pListHead);
    
    INT *pIndex = pListHead;
    
    while(*pIndex != LIST_END)
    {
        if(*pIndex == index)
        {
            // found it.
            *pIndex = EdgeList[index].Next;   // point past the deleted item.
            EdgeList[index].Next = LIST_END;  // disconnect the deleted item.
            return true;
        }
        
        // keep looking...
        
        pIndex = &EdgeList[*pIndex].Next;
    }
    return false;
}

/**************************************************************************\
*
* Function Description:
*
*   Insert edges into the active edge list.
*   This function takes a sorted block of edges from the pInactiveIndex list
*   and inserts them sorted into the pActiveIndex list in linear time.
*   The block from the pInactiveIndex list is known to be contiguous.
*
*   Actually the source list and destination list are not sorted with the
*   same sorting comparison function and therefore we can't optimize based
*   on the known sort order of the destination. This is inefficient. Making
*   them use the same sort order and fixing the active edge traversal code
*   to compute the winding numbers would probably work better - it would
*   allow us an O(n) merge sort here.
*
* Created:
*
*   03/25/2000 andrewgo
*   12/17/2000 asecchia - copied from aarasterizer.cpp and modified for the
*                         PathSelfIntersectRemover. When we have the time 
*                         we should really merge these two pieces of code.                       
*
\**************************************************************************/

void PathSelfIntersectRemover::InsertNewEdges(
    INT *pActiveIndex,     // IN/OUT
    INT *pInactiveIndex,   // IN/OUT
    REAL xCurrent,
    DynSortArrayCompareFunc compare
    )
{
    ASSERT(pInactiveIndex);
    
    while(
        (*pInactiveIndex != LIST_END) &&
        ((PathPts[EdgeList[*pInactiveIndex].SortBegin].X < xCurrent) ||
         (CloseReal(xCurrent, PathPts[EdgeList[*pInactiveIndex].SortBegin].X))
        )) 
    {
        // this is an edge we should move.
        
        INT index = *pInactiveIndex;
        
        // delete this element from the inactive list.
        // this updates pInactiveIndex for the next iteration of the loop.
        
        *pInactiveIndex = EdgeList[*pInactiveIndex].Next;
        EdgeList[index].Next = LIST_END;

        // Insert into the active list from the current active position. 
                    
        InsertEdgeIntoList(pActiveIndex, index, compare);
    
        // Update the active list pointer.
        
        // Can't do this currently - our source and dest have different 
        // sort order. Were we sure that our source and destination were
        // sorted with the same comparison function, we could remember the
        // current position here and continue where we left off next time
        // round - this would change the complexity from O(n^2) to O(n).
        // Currently this is not critical path because it's used on the 
        // active edge list (small relative to the inactive list).
        
        //pActiveIndex = &EdgeList[index].Next;
    } 
}

/**************************************************************************\
*
* Function Description:
*
*  Normalize the edge - ie. update SortBegin and SortEnd.
*
*  All lines have sorted begin and end.  Begin.X is always X <= than End.X.
*  If they are equal, Begin.Y <= End.Y
*
* Arguments:
*
*   None
*
* Return Value:
*
*   None
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

VOID Edge::Normalize()
{

    if (Parent->PathPts[Begin].X < Parent->PathPts[End].X)
    {
        return;
    }

    if ((Parent->PathPts[Begin].X == Parent->PathPts[End].X) &&
        (Parent->PathPts[Begin].Y <= Parent->PathPts[End].Y))
    {
        return;
    }

    // swap the points;
    SortBegin = End;
    SortEnd   = Begin;

    return;
}

/**************************************************************************\
*
* Function Description:
*
*   Return TRUE if the real numbers are close.  This uses the parent's 
*   comparison criteria.
*
* Arguments:
*
*   [IN] val1, val2 - REAL numbers to be compared for closeness
*
* Return Value:
*
*  TRUE or FALSE
*
* Created:
*
*   9/11/2000 peterost
*
\**************************************************************************/

inline BOOL Edge::CloseReal(const REAL val1, const REAL val2)
{
    return Parent->CloseReal(val1, val2);
}

/**************************************************************************\
*
* Function Description:
*
*   Return TRUE if the edge is vertical.
*
* Arguments:
*
*   None
*
* Return Value:
*
*  TRUE or FALSE
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

BOOL Edge::IsVertical()
{
    return (CloseReal(Parent->PathPts[Begin].X,
                      Parent->PathPts[End].X));
}

/**************************************************************************\
*
* Function Description:
*
*  Mark the edge as outside
*
* Arguments:
*
*   None
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

VOID Edge::MarkOutside()
{
    PointListNode *ptNode = NULL;
    ptNode = &Parent->PtList[Begin];
    ptNode->Inside = FALSE;
}

/**************************************************************************\
*
* Function Description:
*
*   Initialize PathSelfIntersectRemover with for the given number of path points.  The 
*   number of points doesn't have to be exact, it just initializes arrays 
*   to avoid reallocation later.
*
* Arguments:
*
*   numPts - number of points that will be added to the path.
*
* Return Value:
*
*   GpStatus.
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

GpStatus PathSelfIntersectRemover::Init(INT numPts)
{
    BOOL failed=FALSE;
    GpStatus status;
    
    // !!!: Decide what the initial number of elements should be.
    //      In general, we usually will have one extra intersection
    //      per vertex in the inset path. - KasiaK

    // Initialize array with points
    failed |= PathPts.ReserveSpace(numPts+1) != Ok;
    
   // Initialize array with order information
    failed |= PtList.ReserveSpace(2*numPts) != Ok;

    failed |= EdgeList.ReserveSpace(2*numPts) != Ok;
    
    ActiveEdgeList = LIST_END;
    InactiveEdgeList = LIST_END;

    if (failed) 
    {
        return OutOfMemory;   
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Add a single polygon to the PathSelfIntersectRemover class.
*   You cannot AddPolygon() after calling RemoveSelfIntersects().
*
* Arguments:
*
*   ptrPts      - points to add.
*   numPtsToAdd - number of points to add.
*
* Return Value:
*
*   GpStatus.  
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

GpStatus 
PathSelfIntersectRemover::AddPolygon(
    const GpPointF *ptrPts,
    INT numPtsToAdd
    )
{
    // Cannot add points after fixing path.
    
    ASSERT(CanAddPts);
    ASSERT(ptrPts != NULL);
    
    if (numPtsToAdd < 2) 
    {
        return Ok;
    }
        
    GpStatus status;
    
    // Make sure there is enough room in the arrays:
    
    status = PathPts.ReserveSpace(numPtsToAdd+1);
    
    if (status != Ok)
    {
        return status;
    }
    
    INT oldNumPts = NumPts;
    if (InsertPoints(ptrPts, numPtsToAdd)          != Ok ||
        InsertEdges(oldNumPts, NumPts-oldNumPts-1) != Ok)
    {
        return GenericError;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*  Insert points information to relevant arrays. 
*
* Arguments:
*
*   pts - points to add to the class.
*   numPts - number of points we want to add.
*
* Return Value:
*
*   GpStatus.
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

GpStatus 
PathSelfIntersectRemover::InsertPoints(
    const GpPointF *pts,
    INT numPts
    )
{
    INT FirstIndex = NumPts;
    PointListNode ptNode;
    GpPointF pt(0,0);

    GpStatus status;

    // We don't want to add 0-length edges
    // Also, we don't want to add very thin spikes, for example
    // when pts[n] == pts[n+2] (or almost the same.  We will just
    // skip pts[n+1] and pts[n+2].
    pt = pts[0];
    if ((status = PathPts.Add(pt)) != Ok)
    {
        return status;
    }
    NumPts++;
    for (INT i = 1; i < numPts; i++)
    {
        if (!IsClosePointF(pts[i], pts[i-1]))
        {
            if ((status = PathPts.Add(pts[i])) != Ok)
            {
                return status;
            }
        
            NumPts++;
        }
    }

    // Add the first point to close the path
    if (!IsClosePointF(pts[0], pts[numPts-1]))
    {
        pt = pts[0];
        if ((status = PathPts.Add(pt)) != Ok)
        {
            return status;
        }
        NumPts++;
    }
    
    // If all the points were equal we hit this point with NumPts set to 1
    // which is a degenerate polygon.
    // Make sure we handle this correctly.
    
    if(NumPts < 2)
    {
        ONCE(WARNING(("Degenerate polygon in InsertPoints")));
        PathPts.SetCount(0);
        NumPts = 0;
        return Ok;
    }

    // Initialize the linked list;

    // If this is not the first set of points to be added, update
    // the next ptr in the last element of the existing list


    if (FirstIndex != 0 && PtList.GetCount() > 0)
    {
        PtList.Last().Next = FirstIndex;
    }

    // index 0:
    ptNode.Prev   = FirstIndex-1;  // -1 means NULL;
    if (NumPts == FirstIndex+1) // only one point is being added
    {
        ptNode.Next = -1;
        ptNode.Dup = -1;  // if we added one point, there is no dup
    }
    else
    {
        ptNode.Next = FirstIndex+1;
        ptNode.Dup = NumPts-1;  // the first point is same as closing point
    }
    ptNode.Inside = TRUE;
    ptNode.Used = FALSE;
    if ((status = PtList.Add(ptNode)) != Ok)
    {
        return status;
    }

    //indecies 1..NumPts-1
    INT ptIndex;
    for (ptIndex = FirstIndex+1; ptIndex < NumPts-1; ptIndex++)
    {
        ptNode.Prev   = ptIndex-1;  // -1 means NULL;
        ptNode.Next   = ptIndex+1;
        ptNode.Dup    = -1;
        ptNode.Inside = TRUE;
        ptNode.Used   = FALSE;
        if ((status = PtList.Add(ptNode)) != Ok)
        {
            return status;
        }
    }

    //index NumPts
    ptNode.Prev   = ptIndex-1;
    ptNode.Next   = -1;   // -1 means NULL;
    ptNode.Dup    = FirstIndex; // the first point is same as closing point
    ptNode.Inside = TRUE;
    ptNode.Used   = FALSE;
    if ((status = PtList.Add(ptNode)) != Ok)
    {
        return status;
    }
        
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Perform a simple partition sort on a list indexing into the vector list.
*   The result is a sorted index array keyed on the vertex array Y1 coordinate.
*   The index array is sorted in place and in ascending order.
*
* Arguments:
*
*   v is the vertex list.
*   F, L - First and Last pointer in the index array.
*
* Created:
*
*  09/16/2000 asecchia
*
\**************************************************************************/

void PathSelfIntersectRemover::QuickSortEdges(
    Edge *F,
    Edge *L
)
{
    if(F < L)
    {
        // Find the median position.
        
        Edge median = *(F + (L-F)/2);
        
        Edge *i = F;
        Edge *j = L;
        
        while(i<j)
        {
            // seek for elements in the wrong partition.
            
            // compare edges:
            while(CompareLine(this, i, &median) == -1) { i++; }
            while(CompareLine(this, j, &median) == 1)  { j--; }
            
            if(i>=j) { break; }
            
            // Swap.
            
            Edge temp = *i;
            *i = *j;
            *j = temp;
            
            // tie breaker - handle the case where *i == *j == *median, but
            // i != j. Only possible with multiple copies of the same entry.
            
            if(CompareLine(this, i, j) == 0) { i++; }
        }
        
        // Call recursively for the two sub-partitions. The partitions don't 
        // include position i because it is correctly positioned.
        
        QuickSortEdges(F, i-1);
        QuickSortEdges(i+1, L);
    }
}




/**************************************************************************\
*
* Function Description:
*
*  Insert numEdges edges joining points stored in array PathPts.  First point 
*  has index firstIndex.  There must be numEdges+1 points to create numEdges
*  edges.
*
*   NOTE: NumEdges CAN be negative! The function will then just return.
*         This can potentially happen when called from AddPolygon().
*
* Arguments:
*
*   firstIndex - index of first point in PathPts array.
*   numEdges   - number of edges to add.
*
* Return Value:
*
*   GpStatus.
*
* Created:
*
*   6/15/1999 t-wehunt
*  10/19/2000 asecchia  rewrote it to support quicksort instead of insert sort.
*
\**************************************************************************/

GpStatus PathSelfIntersectRemover::InsertEdges(INT firstIndex, INT numEdges)
{
    // Handle the empty polygon up front.
    
    if(numEdges == 0)
    {
        return Ok;
    }
    
    // Alloc space for all the edges up front.
    
    Edge *edges = EdgeList.AddMultiple(numEdges);
    
    // Create an edge with it's parent pointer.
    
    Edge newEdge(this);

    for (INT i = 0; i < numEdges; i++)
    {
        newEdge.Begin     = i+firstIndex;
        newEdge.End       = i+1+firstIndex;
        newEdge.SortBegin = i+firstIndex;
        newEdge.SortEnd   = i+1+firstIndex;

        newEdge.Normalize();

        newEdge.YCur = 0;   // make debugging easier

        newEdge.OrigBegin = newEdge.SortBegin;
        newEdge.OrigEnd   = newEdge.SortEnd;

        //Edge insertion
        
        edges[i] = newEdge;
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Check if two lines intersect.
*   NOTE:  Lines also intersect if an end point of one line is anywhere in the
*   middle (between the end points) of the other line.
*   
*   This algorithm was stolen from the NT path code with some modifications
*   based on an algorithm presented in Graphics Gems III.
*   We can try to speed it up by comparing bounding boxes of the two lines,
*   however, according to GG III, this may or may not speed up the 
*   calculations.
*
* Arguments:
*
*   ptrEdge1, ptrEdge2 - edges to intersect.
*   [OUT] intersectPt      - the intersection point if lines INTERSECT 
*                        or have a COMMON_POINT, 
*
* Return Value:
*
*   DONOT_INTERS - lines don't intersect
*   COMMON_POINT - they share a common end point
*   INTERSECT    - they intersect
*   COLINEAR     - they arecolinear.
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

INT
PathSelfIntersectRemover::IntersectEdge(
    Edge *ptrEdge1, 
    Edge *ptrEdge2, 
    GpPointF *intersectPt
    )
{
    GpPointF *pfpvBegin1;             // Start point of first line segment
    GpPointF *pfpvEnd1;               // End point of the first line segment
    GpPointF *pfpvBegin2;             // Start point of second line segment
    GpPointF *pfpvEnd2;               // End point of the second line segment

    GpPointF fpvVec1(0,0);            // Direction of first line segment
    GpPointF fpvVec2(0,0);            // Direction of second line segment
    GpPointF fpvVec3(0,0);

    // Get the actual coordinates of the points.

    pfpvBegin1 = &PathPts[ptrEdge1->Begin];
    pfpvEnd1 = &PathPts[ptrEdge1->End];
    fpvVec1 = SubtractPoint(*pfpvEnd1,*pfpvBegin1);

    // Nothing intersects with an empty line.
    
    if( REALABS(fpvVec1.X) < REAL_EPSILON &&
        REALABS(fpvVec1.Y) < REAL_EPSILON )
    {
        return(DONOT_INTERS);
    }

    pfpvBegin2 = &PathPts[ptrEdge2->Begin];
    pfpvEnd2 = &PathPts[ptrEdge2->End];
    fpvVec2 = SubtractPoint(*pfpvEnd2,*pfpvBegin2);
    
    // Nothing intersects with an empty line.
    
    if( REALABS(fpvVec2.X) < REAL_EPSILON &&
        REALABS(fpvVec2.Y) < REAL_EPSILON )
    {
        return(DONOT_INTERS);
    }
    
    fpvVec3 = SubtractPoint(*pfpvBegin2,*pfpvBegin1);

//
// A -direction 1
// D -direction 2
// C -vec3 ->

//  The intersection is computed by:
//
//  intersect = pptBegin1 + lambda * A
//  intersect = pptBegin2 + beta * D
//
//            Cx(-Dy) + Cy(Dx)
//  lambda =  ------------------------------
//            (Ax)(-Dy) + (Ay)(Dx)
//
//              Cx(Dy) + Cy(-Dx)
//  beta =    ---------------------
//            (Ax)(Dy) + (-Ay)(Dx)
//
    REAL efTerm1;
    REAL efTerm2;
    REAL efNum1;
    REAL efDenom;
    REAL efColinX;
    REAL efColinY;
    REAL efTemp;

// Cx (-Dy)

    efNum1 = fpvVec3.X;
    efColinX = efNum1;
    efTerm2 = -fpvVec2.Y;
    efNum1 *= efTerm2;

// Cy (Dx)
    
    efTerm1 = fpvVec3.Y;
    efColinY = efTerm1;
    efTerm2 = fpvVec2.X;
    efTerm1 *= efTerm2;
    efNum1 += efTerm1;

// (Ax)(-Dy)

    efDenom = fpvVec1.X;
    efTerm2 = -fpvVec2.Y;
    efDenom *= efTerm2;

// (Ay)(Dx)

    efTerm1 = fpvVec1.Y;
    efTerm2 = fpvVec2.X;
    efTerm1 *= efTerm2;
    efDenom += efTerm1;

    if (CloseReal(efDenom, 0))
    //if (efDenom == 0)
    {
        // they are colinear, but are they on the same line?
        efTemp = -fpvVec1.Y;
        efColinX *= efTemp;
        efTemp = fpvVec1.X;
        efColinY *= efTemp;
        efColinX += efColinY;
        //  if (efColinX == 0)
        if (CloseReal(efColinX, 0))
        {
         return(COLINEAR);
        }
        else
        {
            return(DONOT_INTERS);
        }
    }

    // Check if they share a common end point

    if (ptrEdge2->End == ptrEdge1->Begin   || 
        ptrEdge2->End == ptrEdge1->End     ||
        ptrEdge2->Begin == ptrEdge1->Begin || 
        ptrEdge2->Begin == ptrEdge1->End)
    {
        return COMMON_POINT;
    }

    if (ClosePt(*pfpvBegin1, *pfpvBegin2))
    {
        UpdateDups(ptrEdge1->Begin, ptrEdge2->Begin);
        return COMMON_POINT;
    }
    if (ClosePt(*pfpvBegin1, *pfpvEnd2))
    {
        UpdateDups(ptrEdge1->Begin, ptrEdge2->End);
        return COMMON_POINT;
    }

    if (ClosePt(*pfpvEnd1, *pfpvEnd2))
    {
        UpdateDups(ptrEdge1->End, ptrEdge2->End);
        return COMMON_POINT;
    }
    
    if (ClosePt(*pfpvEnd1, *pfpvBegin2))
    {
        UpdateDups(ptrEdge1->End, ptrEdge2->Begin);
        return COMMON_POINT;
    }

// lambda
    efNum1 /= efDenom;

    if (efNum1 < 0.0)
    {
        return(DONOT_INTERS);
    }
    else if (efNum1 > 1.0)
    {
        return (DONOT_INTERS);
    }
    else
    {
        REAL efNum2;
        REAL efBetaPart1;
        REAL efBetaPart2;

        // find beta
        efNum2 = -fpvVec3.X;
        efBetaPart2 = fpvVec1.Y;
        efNum2 *= efBetaPart2;
        efBetaPart1 = -fpvVec3.Y;
        efBetaPart2 = -fpvVec1.X;
        efBetaPart1 *= efBetaPart2;
        efNum2 += efBetaPart1;
        efNum2 /= efDenom;
        if (efNum2 < 0.0)
        {
            return(DONOT_INTERS);
        }
        else if (efNum2 > 1.0)
        {
            return (DONOT_INTERS);
        }
   }

    // pptBegin1 + lambda * A

    // Following should be nice to the REAL unit - multiply-add instructions
    // can be used.
    efTerm1 = fpvVec1.X * efNum1 + pfpvBegin1->X;
    efTerm2 = fpvVec1.Y * efNum1 + pfpvBegin1->Y;

    intersectPt->X = efTerm1;
    intersectPt->Y = efTerm2;

    // Because of errors, we may still end up with the intersection
    // point as a common point:
    if (IsCommonPt(ptrEdge1, ptrEdge2, intersectPt))
    {
        return COMMON_POINT;
    }

    return(INTERSECT);
}

/**************************************************************************\
*
* Function Description:
*
*  Find all self intersections of the paths and break up the edges.
*
*  This is considered 'Phase 1' of the algorithm.
*
* Arguments:
*
*   None.
*
* Return Value:
*
*   FALSE if out of memory.
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

BOOL PathSelfIntersectRemover::FindIntersects()
{
    // Initialize the array of active edges.
    // Take the first edge from the edge array InactiveEdgeList and add it to 
    // the active edgs. Add all other edges, which start at the same x.

    INT numRemoved = 0;

    if (EdgeList.GetCount() <= 0)
    {
        return FALSE;
    }

    XCur = PathPts[EdgeList[InactiveEdgeList].SortBegin].X;

    // "move" all edges starting at XCur to the active edge array
    // PathPts in the active edge array will be sorted by y for the
    // given XCur.
    
    AddActiveForX(&InactiveEdgeList);

    while (TRUE)
    {
        // Find all intersections among the current edges
        
        if (!FindIntersectsForX())
        {
            return FALSE;
        }

        // if there are no edges left, we have found all intersections
        // we can stop even if active edges array is not empty, or maybe
        // it must be empty then?  TODO: Kasiak
        
        if (InactiveEdgeList == LIST_END)
        {
            break;
        }

        if (!ClosestActive(InactiveEdgeList))
        {
            break;
        }

        // Remove all edges which end before (or on) XCur
        
        ClearActiveListInclusiveX();
        
        AddActiveForX(&InactiveEdgeList);
    }

    // remove everything else from the ActiveEdgeList
    
    XCur = FP_INF;
    ClearActiveListInclusiveX();

    return TRUE;
}


/**************************************************************************\
*
* Function Description:
*
*   IsTIntersection returns TRUE if the intersection point intersectPt is
*   the same as an end point of one of the edges ptrEdge1 and ptrEdge2.  If 
*   it is, pfFirst will be TRUE if the first edge needs to be broken (intersectPt
*   is an end point of ptrEdge2), FALSE if the second one needs to be broken
*   up.  intersectIndex contains the index of the end point which is the same
*   as the intersection point.
*
* Arguments:
*
*   ptrEdge1, 
*   ptrEdge2 - the two edges to check for T-intersections
*   intersectPt  - the intersection point previously found for the edges.
*   [OUT] splitFirst - TRUE if the first edge needs to be split. FALSE if 
*                      the second edge.
*   [OUT] intersectIndex - index of endpoint which is the same as intersectPt if it
*                      is a T-intersection.
*
* Return Value:
*
*   TRUE or FALSE
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

BOOL PathSelfIntersectRemover::IsTIntersection(
    Edge *ptrEdge1, 
    Edge *ptrEdge2, 
    GpPointF *intersectPt, 
    BOOL *splitFirst,
    INT *intersectIndex
    )
{
    GpPointF &begin1 = PathPts[ptrEdge1->SortBegin];
    GpPointF &begin2 = PathPts[ptrEdge2->SortBegin];
    GpPointF &end1 = PathPts[ptrEdge1->SortEnd];
    GpPointF &end2 = PathPts[ptrEdge2->SortEnd];

    if (ClosePt(end1, *intersectPt))
    {
        // only ptrEdge2 needs to be broken up
        *splitFirst = FALSE;
        *intersectIndex = ptrEdge1->SortEnd;
        return TRUE;
    }
    else if(ClosePt(end2, *intersectPt))
    {
        // only ptrEdge1
        *splitFirst = TRUE;
        *intersectIndex = ptrEdge2->SortEnd;
        return TRUE;
    }
    else if(ClosePt(begin1, *intersectPt))
    {
        // only ptrEdge2
        *splitFirst = FALSE;
        *intersectIndex = ptrEdge1->SortBegin;
        return TRUE;
    }
    else if(ClosePt(begin2, *intersectPt))
    {
        // only ptrEdge1
        *splitFirst = TRUE;
        *intersectIndex = ptrEdge2->SortBegin;
        return TRUE;
    }

    return FALSE;
}

/**************************************************************************\
*
* Function Description:
*
*   Returns TRUE if the two lines ptrEdge1 and ptrEdge2 share a common 
*   end point. If they do, pptInter will contain this point.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

BOOL 
PathSelfIntersectRemover::IsCommonPt(
    Edge *ptrEdge1,
    Edge *ptrEdge2,
    GpPointF *commonPt
    )
{
    GpPointF &begin1 = PathPts[ptrEdge1->SortBegin];
    GpPointF &begin2 = PathPts[ptrEdge2->SortBegin];
    GpPointF &end1 = PathPts[ptrEdge1->SortEnd];
    GpPointF &end2 = PathPts[ptrEdge2->SortEnd];

    if (ClosePt(end1, *commonPt) && ClosePt(end2, *commonPt))
    {
        UpdateDups(ptrEdge1->End, ptrEdge2->End);
        return TRUE;
    }
    else if(ClosePt(end1, *commonPt) && ClosePt(begin2, *commonPt))
    {
        UpdateDups(ptrEdge1->End, ptrEdge2->Begin);
        return TRUE;
    }
    else if(ClosePt(begin1, *commonPt) && ClosePt(begin2, *commonPt))
    {
        UpdateDups(ptrEdge1->Begin, ptrEdge2->Begin);
        return TRUE;
    }
    else if(ClosePt(begin1, *commonPt) && ClosePt(end2, *commonPt))
    {
        UpdateDups(ptrEdge1->Begin, ptrEdge2->End);
        return TRUE;
    }

    return FALSE;
}

/**************************************************************************\
*
* Function Description:
*
*   Returns TRUE if point with index inew is already in the "list" of dups
*   for point with index loop.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

BOOL PathSelfIntersectRemover::IsLinked(INT loop, INT inew)
{
    PointListNode *ptNode;

    ptNode = &PtList[loop];
    BOOL isLinked = FALSE;
    INT i = ptNode->Dup;
    INT prev_i = -1;    // Added to prevent an infinite loop.

    while(!isLinked && i != -1 && i != prev_i && i != loop)
    {
        if(i == inew)
        {
            isLinked = TRUE;
            break;
        }

        ptNode = &PtList[i];
        prev_i = i;
        i = ptNode->Dup;
    }

    return isLinked;
}

/**************************************************************************\
*
* Function Description:
*
*   Joins the list of duplicate points for points pt1 and pt2.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/
VOID PathSelfIntersectRemover::UpdateDups(INT pt1, INT pt2)
{
    PointListNode *ptNode1;
    PointListNode *ptNode2;

    if (pt1 == pt2)
    {
        WARNING(("NOT REACHED"));
        return;
    }

    ptNode1 = &PtList[pt1];
    ptNode2 = &PtList[pt2];

    if ((ptNode1->Dup == -1) && (ptNode2->Dup == -1))
    {
        ptNode1->Dup = pt2;
        ptNode2->Dup = pt1;
        return;
    }

    if ((ptNode1->Dup == -1) && (ptNode2->Dup != -1))
    {
        ptNode1->Dup = ptNode2->Dup;
        ptNode2->Dup = pt1;
        return;
    }

    if ((ptNode1->Dup != -1) && (ptNode2->Dup == -1))
    {
        ptNode2->Dup = ptNode1->Dup;
        ptNode1->Dup = pt2;
        return;
    }

    if ((ptNode1->Dup != -1) && (ptNode2->Dup != -1))
    {
        if (!IsLinked(pt1, pt2))
        {
            INT dupTemp;

            dupTemp = ptNode2->Dup;
            ptNode2->Dup = ptNode1->Dup;
            ptNode1->Dup = dupTemp;
        }
        return;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Delete edges from the active edge table;  Indices of edges to delete
*   are stored in EdgesToDelete1..3.  Deletes the highest index edge first.
*   Returns NULL if fails due to out of memory error.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

BOOL PathSelfIntersectRemover::DeleteEdges()
{
    INT minIndex;
    INT midIndex;
    INT maxIndex;

    if (EdgesToDelete1 > EdgesToDelete2)
    {
        if (EdgesToDelete1 > EdgesToDelete3)
        {
            minIndex = EdgesToDelete1;
            if (EdgesToDelete2 > EdgesToDelete3)
            {
                midIndex = EdgesToDelete2;
                maxIndex = EdgesToDelete3;
            }
            else
            {
                midIndex = EdgesToDelete3;
                maxIndex = EdgesToDelete2;
            }
        }
        else
        {
            minIndex = EdgesToDelete3;
            midIndex = EdgesToDelete1;
            maxIndex = EdgesToDelete2;
        }
    }
    else
    {
        if (EdgesToDelete2 > EdgesToDelete3)
        {
            minIndex = EdgesToDelete2;
            if (EdgesToDelete1 > EdgesToDelete3)
            {
                midIndex = EdgesToDelete1;
                maxIndex = EdgesToDelete3;
            }
            else
            {
                midIndex = EdgesToDelete3;
                maxIndex = EdgesToDelete1;
            }
        }
        else
        {
            minIndex = EdgesToDelete3;
            midIndex = EdgesToDelete2;
            maxIndex = EdgesToDelete1;
        }
    }
    
    if (minIndex == -1)
    {
        return TRUE;
    }
    // delete the first one
    if (!DeleteEdgeFromList(&ActiveEdgeList, minIndex))
    {
        return FALSE;
    }

    if (midIndex == -1)
    {
        return TRUE;
    }
    // delete the second one
    if (!DeleteEdgeFromList(&ActiveEdgeList, midIndex))
    {
        return FALSE;
    }

    if (maxIndex == -1)
    {
        return TRUE;
    }
    // delete the third one
    if (!DeleteEdgeFromList(&ActiveEdgeList, maxIndex))
    {
      return FALSE;
    }

    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*
*    Edge with index index into the array of Active edges needs to be deleted.
*    Store its index for deletion.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

VOID PathSelfIntersectRemover::MarkToDelete(INT index)
{
    ASSERT((EdgesToDelete1 == -1) || 
           (EdgesToDelete2 == -1) || 
           (EdgesToDelete3 == -1));

    if (EdgesToDelete1 == -1 )
    {
        EdgesToDelete1 = index;
        return;
    }

    if (EdgesToDelete2 == -1 )
    {
        EdgesToDelete2 = index;
        return;
    }

    if (EdgesToDelete3 == -1 )
    {
        EdgesToDelete3 = index;
        return;
    }
    return; // error
}

/**************************************************************************\
*
* Function Description:
*
*   Edge ptrEdge needs to be added to the array with Active edges.  Make a 
*   copy of the edge and store it, so that it can be later added.
*   We have to add new edges after the edges marked for deletion are deleted.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

VOID PathSelfIntersectRemover::MarkToAdd(Edge *ptrEdge)
{
    ASSERT(!(FlgAdd1 && FlgAdd2 && FlgAdd3));

    if (!FlgAdd1)
    {
        AddToActive1 = *ptrEdge;
        FlgAdd1 = TRUE;
        return;
    }                                                                                 

    if (!FlgAdd2)
    {
        AddToActive2 = *ptrEdge;
        FlgAdd2 = TRUE;
        return;
    }

    if (!FlgAdd3)
    {
        AddToActive3 = *ptrEdge;
        FlgAdd3 = TRUE;
        return;
    }
    return;  // this the error condition, which should never happen.
}

/**************************************************************************\
*
* Function Description:
*
*   Add new edges to the active edge table.  The edges are stored in
*   AddToActive1..3.  flag FlgAdd1..3 specify if the given edge needs to
*   be added or not.  Returns if fails due to out of memory.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

BOOL PathSelfIntersectRemover::AddNewEdges()
{
    if (FlgAdd1)
    {
        AddToActive1.SortBegin = AddToActive1.Begin;
        AddToActive1.SortEnd = AddToActive1.End;
        AddToActive1.Normalize();
        AddToActive1.YCur = PathPts[AddToActive1.SortBegin].Y;
        
        AddToActive1.Next = LIST_END;
        
        //Edge Insertion
        
        if(Ok != EdgeList.Add(AddToActive1))
        {
            return FALSE;  // out of memory.
        }
        
        InsertEdgeIntoList(
            &ActiveEdgeList, 
            EdgeList.GetCount()-1, 
            CompareYCurLine
        );
   }
    
    if (FlgAdd2)
    {
        AddToActive2.SortBegin = AddToActive2.Begin;
        AddToActive2.SortEnd = AddToActive2.End;
        AddToActive2.Normalize();
        AddToActive2.YCur = PathPts[AddToActive2.SortBegin].Y;
        
        AddToActive2.Next = LIST_END;
        
        //Edge Insertion
        
        if(Ok != EdgeList.Add(AddToActive2))
        {
            return FALSE;  // out of memory.
        }
        
        InsertEdgeIntoList(
            &ActiveEdgeList, 
            EdgeList.GetCount()-1, 
            CompareYCurLine
        );
   }

    if (FlgAdd3)
    {
        AddToActive3.SortBegin = AddToActive3.Begin;
        AddToActive3.SortEnd = AddToActive3.End;
        AddToActive3.Normalize();
        AddToActive3.YCur = PathPts[AddToActive3.SortBegin].Y;
        
        AddToActive3.Next = LIST_END;
        
        //Edge Insertion
        
        if(Ok != EdgeList.Add(AddToActive3))
        {
            return FALSE;  // out of memory.
        }
        
        InsertEdgeIntoList(
            &ActiveEdgeList, 
            EdgeList.GetCount()-1,
            CompareYCurLine
        );
    }

    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*
*   Find all intersections for the current X value.  Intersection points
*   will be inserted into the Edges array and information about their
*   order into PtList. Returns FALSE on out of memory.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

BOOL PathSelfIntersectRemover::FindIntersectsForX()
{
    Edge *ptrEdge1 = NULL;
    Edge *ptrEdge2 = NULL;
    Edge *ptrEdge3 = NULL;

    // If we find an intersection, we will be breaking up edges - need two more
    // line variables for the new edges.
    Edge newEdge1(this);
    Edge newEdge2(this);

    GpPointF intersectPt(0,0);
    INT result = DONOT_INTERS;
    BOOL breakFirst = TRUE;
    INT dup1 = -1;
    INT dup2 = -1;
    INT ptIndex1 = -1;
    INT ptIndex2 = -1;
    PointListNode *ptNode = NULL;
    INT edgeIndex1, edgeIndex2, edgeIndexOld;
    REAL yCur2;
    BOOL deleteEdge1;
    BOOL deleteEdge2;
    BOOL edge1Deleted;
    BOOL edge2Deleted;

    // Go through all active edges but consider only consecutive pairs of egdes
    // because they are sorted in y.  There is no need to check every edge with
    // every other edge in general case.  However, when we have multiple edges
    // with the same current y value and end points, we have to consider all of
    // them.

    edgeIndexOld = LIST_END;
    edgeIndex1 = ActiveEdgeList;
    
    if(edgeIndex1 == LIST_END)
    {
        return TRUE;
    }
    
    edgeIndex2 = EdgeList[ActiveEdgeList].Next;
    
    while (edgeIndex1 != LIST_END && edgeIndex2 != LIST_END)
    {
        edge1Deleted = FALSE;
        edge2Deleted = FALSE;
        
        // Get the next two edges
        
        ptrEdge1 = &EdgeList[edgeIndex1];
        ptrEdge2 = &EdgeList[edgeIndex2];
        
        yCur2 = ptrEdge2->YCur;

        FlgAdd1 = FALSE;
        FlgAdd2 = FALSE;
        FlgAdd3 = FALSE;

        EdgesToDelete1 = -1;
        EdgesToDelete2 = -1;
        EdgesToDelete3 = -1;

        // Do they intersect?
        result = IntersectEdge(ptrEdge1, ptrEdge2, &intersectPt);
        if (result == INTERSECT)
        {
            // check if both edges need to be broken up, we may have
            // a "T" intersection
            if (IsTIntersection(ptrEdge1, ptrEdge2, &intersectPt, 
                &breakFirst, &dup1))
            {
                // only one edge needs to be broken up
                // The index of the new point will be:
                ptIndex1 = PathPts.GetCount();
                // Update the dup field
                // we have idup from IsTIntersection - it returned the index of
                // the end point which is the same as the point of intersection
                // It is a duplicate of the new point
                ptNode = &PtList[dup1];
                if (ptNode->Dup == -1)
                {
                    ptNode->Dup = ptIndex1;
                }
                else
                {
                    dup1 = ptNode->Dup;
                    ptNode->Dup = ptIndex1;
                }
                if (breakFirst)
                {
                    // we need to break up the first edge
                    if (!BreakEdge(ptrEdge1, &intersectPt, &newEdge2, dup1))
                    {
                        return FALSE;
                    }
                    
                    // BreakEdge can cause a realloc, thus invalidating
                    // ptrEdge1 and ptrEdge2
                    
                    ptrEdge1 = &EdgeList[edgeIndex1];
                    ptrEdge2 = &EdgeList[edgeIndex2];

                    
                    // Check if the left side of ptIntersect shouldn't be 
                    // removed. This is the case when
                    //  ptrEdge1->yCur == intersectPt.y && intersectPt.x == xCur;
                    if (ptrEdge1->YCur >= intersectPt.Y && intersectPt.X <= XCur)
                    {
                        MarkToDelete(edgeIndex1);
                        edge1Deleted = TRUE;
                    }
                }
                else
                {
                    // we need to break up the first edge
                    if (!BreakEdge(ptrEdge2, &intersectPt, &newEdge1, dup1))
                    {
                        return FALSE;
                    }
                    
                    // BreakEdge can cause a realloc, thus invalidating
                    // ptrEdge1 and ptrEdge2
                    
                    ptrEdge1 = &EdgeList[edgeIndex1];
                    ptrEdge2 = &EdgeList[edgeIndex2];
                    
                    // Check if the left side of ptIntersect shouldn't be 
                    // removed. This is the case when
                    //  ptrEdge2->yCur == intersectPt.y && intersectPt.x == xCur;
                    if (ptrEdge2->YCur >= intersectPt.Y && intersectPt.X <= XCur)
                    {
                        MarkToDelete(edgeIndex2);
                        edge2Deleted = TRUE;
                    }
                }
            }
            else
            {
                // both need to be broken up
                // We need to add two new points.  They are identical and 
                // will be duplicates.  Let's get thei indecies.
                ptIndex1 = PathPts.GetCount();
                ptIndex2 = ptIndex1+1;
                if (!BreakEdge(ptrEdge1, &intersectPt, &newEdge2, ptIndex2))
                    return FALSE;
                
                // BreakEdge can cause a realloc, thus invalidating
                // ptrEdge1 and ptrEdge2
                
                ptrEdge1 = &EdgeList[edgeIndex1];
                ptrEdge2 = &EdgeList[edgeIndex2];
                
                if (!BreakEdge(ptrEdge2, &intersectPt, &newEdge1, ptIndex1))
                    return FALSE;
                
                // BreakEdge can cause a realloc, thus invalidating
                // ptrEdge1 and ptrEdge2
                
                ptrEdge1 = &EdgeList[edgeIndex1];
                ptrEdge2 = &EdgeList[edgeIndex2];
                
                // Let's delete what we will not need any more - the left hand
                // sides of the old edges only if the intersection point is on
                // the scanline
                deleteEdge2 = (ptrEdge2->YCur >= intersectPt.Y && 
                              intersectPt.X <= XCur);
                deleteEdge1 = (ptrEdge1->YCur >= intersectPt.Y && 
                              intersectPt.X <= XCur);
                if (deleteEdge2)
                {
                    MarkToDelete(edgeIndex2);
                    edge2Deleted = TRUE;
                }

                if (deleteEdge1)
                {
                    MarkToDelete(edgeIndex1);
                    edge1Deleted = TRUE;
                }
            }
        }
        else if (result == COLINEAR)
        {
            BOOL three;
            GpPointF intersectPt2(0,0);
            BOOL breakSecond;
            // The line segments must overlap or both are vertical...
            // Find out if they overlap and if this is the case,
            // Let's pick the begin point with the greater x.
            // Overlap will check if the two edges overlap and return
            // a point of intersection as well as information of which edge
            // to break up.
            if (Overlap(ptrEdge1, ptrEdge2, &intersectPt, &intersectPt2, &breakFirst,
                                &breakSecond,  &three, &dup1, &dup2))
            {
                if (breakFirst)
                {
                    if (!three)
                    {
                        // As before, get the index, so we can set up 
                        // the duplicates
                        ptIndex1 = PathPts.GetCount();
                        // Update the dup field
                        ptNode = &PtList[dup1];
                        if (ptNode->Dup == -1)
                        {
                            ptNode->Dup = ptIndex1;
                        }
                        else
                        {
                            dup1 = ptNode->Dup;
                            ptNode->Dup = ptIndex1;
                        }
                        if (!BreakEdge(ptrEdge1, &intersectPt, &newEdge2, dup1))
                        {
                            return FALSE;
                        }
                        
                        // BreakEdge can cause a realloc, thus invalidating
                        // ptrEdge1 and ptrEdge2
                        
                        ptrEdge1 = &EdgeList[edgeIndex1];
                        ptrEdge2 = &EdgeList[edgeIndex2];
                        
                    }
                    else
                    {
                        ptIndex1 = PathPts.GetCount();
                        ptIndex2 = ptIndex1+1;
                        // we need to break this edge into 3 pieces
                
                        // Update the dup field
                        ptNode = &PtList[dup1];
                        if (ptNode->Dup == -1)
                        {
                            ptNode->Dup = ptIndex1;
                        }
                        else
                        {
                            dup1 = ptNode->Dup;
                            ptNode->Dup = ptIndex1;
                        }
                
                        // Update the dup field
                        ptNode = &PtList[dup2];
                        if (ptNode->Dup == -1)
                        {
                            ptNode->Dup = ptIndex2;
                        }
                        else
                        {
                            dup2 = ptNode->Dup;
                            ptNode->Dup = ptIndex2;
                        }
                        if (!BreakEdgeIn3(ptrEdge1, &intersectPt, &intersectPt2, 
                            &newEdge1, &newEdge2, dup1, dup2))
                        {
                            return FALSE;
                        }
                        
                        // BreakEdge can cause a realloc, thus invalidating
                        // ptrEdge1 and ptrEdge2
                        
                        ptrEdge1 = &EdgeList[edgeIndex1];
                        ptrEdge2 = &EdgeList[edgeIndex2];
                    }
                    deleteEdge1 = (ptrEdge1->YCur >= intersectPt.Y && 
                                  intersectPt.X <= XCur);
                    if (deleteEdge1)
                    {
                        MarkToDelete(edgeIndex1);
                        edge1Deleted = TRUE;
                    }
                }
                if (breakSecond)
                {
                    if (!three)
                    {
                        // break ptrEdge2
                        // Update the dup field
                        ptIndex1 = PathPts.GetCount();
                        ptNode = &PtList[dup2];
                        if (ptNode->Dup == -1)
                        {
                            ptNode->Dup = ptIndex1;
                        }
                        else
                        {
                            dup2 = ptNode->Dup;
                            ptNode->Dup = ptIndex1;
                        }
                        if (!BreakEdge(ptrEdge2, &intersectPt2, &newEdge1, dup2))
                        {
                            return FALSE;
                        }
                        
                        // BreakEdge can cause a realloc, thus invalidating
                        // ptrEdge1 and ptrEdge2
                        
                        ptrEdge1 = &EdgeList[edgeIndex1];
                        ptrEdge2 = &EdgeList[edgeIndex2];

                        deleteEdge2 = ptrEdge2->YCur >= intersectPt2.Y && 
                                      intersectPt2.X     <= XCur;

                        if (deleteEdge2)
                        {
                            MarkToDelete(edgeIndex2);
                            edge2Deleted = TRUE;
                        }
                    }
                    else
                    {
                        ptIndex1 = PathPts.GetCount();
                        ptIndex2 = ptIndex1+1;
                        // we need to break this edge into 3 pieces
                
                        // Update the dup field
                        ptNode = &PtList[dup1];
                        if (ptNode->Dup == -1)
                        {
                            ptNode->Dup = ptIndex1;
                        }
                        else
                        {
                            dup1 = ptNode->Dup;
                            ptNode->Dup = ptIndex1;
                        }
                
                        // Update the dup field
                        ptNode = &PtList[dup2];
                        if (ptNode->Dup == -1)
                        {
                            ptNode->Dup = ptIndex2;
                        }
                        else
                        {
                            dup2 = ptNode->Dup;
                            ptNode->Dup = ptIndex2;
                        }
                        if (!BreakEdgeIn3(ptrEdge2, &intersectPt, &intersectPt2, 
                            &newEdge1, &newEdge2, dup1, dup2))
                        {
                            return FALSE;
                        }
                        
                        // BreakEdge can cause a realloc, thus invalidating
                        // ptrEdge1 and ptrEdge2
                        
                        ptrEdge1 = &EdgeList[edgeIndex1];
                        ptrEdge2 = &EdgeList[edgeIndex2];

                        deleteEdge2 = ptrEdge2->YCur >= intersectPt.Y &&
                                      intersectPt.X      <= XCur;

                        if (deleteEdge2)
                        {
                            MarkToDelete(edgeIndex2);
                            edge2Deleted = TRUE;
                        }
                    }
                }
            }
        }
        
        bool modifiedList = false;

        // If we're deleting any edges, we've modified the list.
        
        if((EdgesToDelete1 != -1) ||
           (EdgesToDelete2 != -1) ||
           (EdgesToDelete3 != -1))
        {
            modifiedList = true;
        }
        
        if (!DeleteEdges())
        {
            return FALSE;
        }
        
        // If we're adding any edges, we've modified the list.
        
        if(FlgAdd1 || FlgAdd2 || FlgAdd3)
        {
            modifiedList = true;
        }
        
        if (!AddNewEdges())
        {
            return FALSE;
        }
        
        
        // Note: We check all vertically adjacent pairs of edges. Because
        // the AET is sorted vertically and we're only looking for the 
        // intersection with the x coordinate closest to XCur, this is
        // sufficient (and O(n) instead of O(n^2)).
        
        if(modifiedList)
        {
            // back up to a stable position if we invalidate our list.
            // this makes assumptions on where in the list we add or 
            // delete elements based on the sort order for the ActiveEdgeList.
            
            edgeIndex1 = edgeIndexOld;
            
            if(edgeIndexOld == LIST_END)
            {
                edgeIndex1 = ActiveEdgeList;
            }
            
            if(edgeIndex1 != LIST_END)
            {
                edgeIndex2 = EdgeList[edgeIndex1].Next;
            }
        }
        else
        {
            edgeIndexOld = edgeIndex1;
            edgeIndex2 = EdgeList[edgeIndex2].Next;
            edgeIndex1 = EdgeList[edgeIndex1].Next;
        }
    }
    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*
*      Returns TRUE if two collinear edges ptrEdge1 and ptrEdge2 overlap.
*      There are 4 ways in which edges can overlap and depending on the
*      case, either none, one or both edges need to be broken up.  In some
*      cases one edge may need to broken into 3 pieces.
*      Return values:
*        split1     - set to TRUE if ptrEdge1 needs to be split
*        split2     - set to TRUE if ptrEdge2 needs to be split
*        split3     - set to TRUE if an edge needs to be broken into 3 pieces
*        intersect1     - intersection point (where edge needs to be split)
*        intersect2     - second point (if the edge needs to be broken into 3
*                     pieces or for the second edge if both edges need to 
*                     be broken up)
*        dupIndex1  - index of the duplicate point to intersect1,
*        dupIndex2  - index of the duplicate point to intersect2,
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

BOOL PathSelfIntersectRemover::Overlap(
    Edge *ptrEdge1, 
    Edge *ptrEdge2, 
    GpPointF *intersect1, 
    GpPointF *intersect2, 
    BOOL *split1,
    BOOL *split2, 
    BOOL *split3, 
    INT *dupIndex1, 
    INT *dupIndex2
    )
{
    // We are assuming that the lines are colinear and they both belong
    // to the active edges table which means that their x ranges overlap
    // We need to check if they are vertical and if yes, find out if their
    // y ranges overlap.  If they are not vertical, they must overlap or
    // they share a common end point.

    *split3 = FALSE;

    GpPointF &begin1 = PathPts[ptrEdge1->SortBegin];
    GpPointF &begin2 = PathPts[ptrEdge2->SortBegin];
    GpPointF &end1 = PathPts[ptrEdge1->SortEnd];
    GpPointF &end2 = PathPts[ptrEdge2->SortEnd];

    // Calculate bounding box for each edge:
    GpPointF min1(
        min(begin1.X, end1.X),
        min(begin1.Y, end1.Y));
    GpPointF max1(
        max(begin1.X, end1.X),
        max(begin1.Y, end1.Y));
    GpPointF min2(
        min(begin2.X, end2.X),
        min(begin2.Y, end2.Y));
    GpPointF max2(
        max(begin2.X, end2.X),
        max(begin2.Y, end2.Y));
        
    // Abort if the bounding box of either edge is empty.
    
    if(IsClosePointF(min1, max1) ||
       IsClosePointF(min2, max2) )
    {
        return FALSE;
    }

    // If the edges are not vertical, they must overlap, because both of them
    // are in the active edge array.  We only need to chose a point, which will
    // be used as an intersection point.
    if (!ptrEdge1->IsVertical())
    {
        // Let's check first if they share a common end point

        // if they share just a common point, return FALSE
        if (CloseReal(min1.X,max2.X))
        {
            // We have to update the dups of the shared point

            if (ptrEdge1->SortBegin != ptrEdge2->SortEnd)
            {
                UpdateDups(ptrEdge1->SortBegin, ptrEdge2->SortEnd);
                return FALSE;
            }
        }   
        
        if (CloseReal(min2.X,max1.X))
        {
            // We have to update the dups of the shared point

            if (ptrEdge1->SortEnd != ptrEdge2->SortBegin)
            {
                UpdateDups(ptrEdge1->SortEnd, ptrEdge2->SortBegin);
                return FALSE;
            }
        }

        // the edges must overlap, we need to break both of them

        // There are 4 different ways in which edges may overlap

        // case4: edges are identical
        //  ----------------
        //  ----------------
        // No edges need to be broken up, but do we need to update some
        // dup values?
        if (CloseReal(max1.X, max2.X) && CloseReal(min1.X, min2.X))
        {
            // for now, we will return FALSE
            // I think, that it should be OK.
            // TODO: - Review
            // !!! Is this still ok? - t-wehunt

            if (ptrEdge1->SortBegin != ptrEdge2->SortBegin)
                UpdateDups(ptrEdge1->SortBegin, ptrEdge2->SortBegin);

            if (ptrEdge1->SortEnd != ptrEdge2->SortEnd)
                UpdateDups(ptrEdge1->SortEnd, ptrEdge2->SortEnd);

            return FALSE;
        }

        // case2: the edges overlap and share one end point
        //  --------------
        //  ----------------------
        //  The longer edge needs to be broken into 2 pieces
        if (CloseReal(min1.X, min2.X) && max1.X < max2.X)
        {
            //  --------------
            //  ----------------------
            // We have to update the dups of the shared point

            if (ptrEdge1->SortBegin != ptrEdge2->SortBegin)
            {
                UpdateDups(ptrEdge1->SortBegin, ptrEdge2->SortBegin);
            }
            *split1 = FALSE;
            *split2 = TRUE;
            *dupIndex2 = ptrEdge1->SortEnd;
            *intersect2 = PathPts[*dupIndex2];
            return TRUE;
        }
        else if (CloseReal(min1.X, min2.X) && max1.X > max2.X)
        {
            //  ----------------------
            //  --------------
            // We have to update the dups of the shared point

            if (ptrEdge1->SortBegin != ptrEdge2->SortBegin)
            {
                UpdateDups(ptrEdge1->SortBegin, ptrEdge2->SortBegin);
            }
            *split1 = TRUE;
            *split2 = FALSE;
            *dupIndex1 = ptrEdge2->SortEnd;
            *intersect1 = PathPts[*dupIndex1];
            return TRUE;
        }
        else if (CloseReal(max1.X, max2.X) && min1.X > min2.X)
        {
            //  ----------------------
            //          --------------
            // We have to update the dups of the shared point

            if (ptrEdge1->SortEnd != ptrEdge2->SortEnd)
            {
                UpdateDups(ptrEdge1->SortEnd, ptrEdge2->SortEnd);
            }
            *split1 = FALSE;
            *split2 = TRUE;
            *dupIndex2 = ptrEdge1->SortBegin;
            *intersect2 = PathPts[*dupIndex2];
            return TRUE;
        }
        else if (CloseReal(max1.X, max2.X) && min1.X < min2.X)
        {
            //          --------------
            //  ----------------------
            // We have to update the dups of the shared point

            if (ptrEdge1->SortEnd != ptrEdge2->SortEnd)
            {
                UpdateDups(ptrEdge1->SortEnd, ptrEdge2->SortEnd);
            }
            *split1 = TRUE;
            *split2 = FALSE;
            *dupIndex1 = ptrEdge2->SortBegin;
            *intersect1 = PathPts[*dupIndex1];
            return TRUE;
        }

        // case1: one is "inside" of another 
        //       ---------
        //   -----------------
        // In this case, the longer edge has to be broken into 3 pieces

        if (min1.X < min2.X && max1.X > max2.X)
        {
            // intersection points are the end points of the second edge
            // we are breaking up the first edge
            *split1 = TRUE;
            *split2 = FALSE;
            *split3 = TRUE;
            *dupIndex1 = ptrEdge2->SortBegin;
            *dupIndex2 = ptrEdge2->SortEnd;
            *intersect1 = PathPts[*dupIndex1];
            *intersect2 = PathPts[*dupIndex2];
            return TRUE;
        }
        else if (min1.X > min2.X && max1.X < max2.X)
        {
            // intersection points are the end points of the first edge
            // we are breaking up the second edge
            *split1 = FALSE;
            *split2 = TRUE;
            *split3 = TRUE;
            *dupIndex1 = ptrEdge1->SortBegin;
            *dupIndex2 = ptrEdge1->SortEnd;
            *intersect1 = PathPts[*dupIndex1];
            *intersect2 = PathPts[*dupIndex2];
            return TRUE;
        }

        // case3: edges overlap
        // ---------------
        //         -----------------
        // Each edge has to be broken up INT 2 pieces
        else if (max1.X < max2.X && min1.X < min2.X)
        {
            *split1 = TRUE;
            *split2 = TRUE;
            *dupIndex1 = ptrEdge2->SortBegin;
            *dupIndex2 = ptrEdge1->SortEnd;
            *intersect1 = PathPts[*dupIndex1];
            *intersect2 = PathPts[*dupIndex2];
            return TRUE;
        }
        else if (max2.X < max1.X && min2.X < min1.X)
        {
        //         -----------------
        // ---------------
            *split1 = TRUE;
            *split2 = TRUE;
            *dupIndex1 = ptrEdge2->SortEnd;
            *dupIndex2 = ptrEdge1->SortBegin;
            *intersect1 = PathPts[*dupIndex1];
            *intersect2 = PathPts[*dupIndex2];
            return TRUE;
        }
    }

    // The edges are vertical.
    // We have to test for the same cases using y intervals

    // if they share just a common point, return FALSE
    if (CloseReal(min1.Y, max2.Y))
    {
        // We have to update the dups of the shared point

        if (ptrEdge1->SortBegin != ptrEdge2->SortEnd)
        {
            UpdateDups(ptrEdge1->SortBegin, ptrEdge2->SortEnd);
        }
        return FALSE;
    }   

    if (CloseReal(min2.Y, max1.Y))
    {
        // We have to update the dups of the shared point

        if (ptrEdge1->SortEnd != ptrEdge2->SortBegin)
        {
            UpdateDups(ptrEdge1->SortEnd, ptrEdge2->SortBegin);
        }
        return FALSE;
    }
    
    // These edges may not overlap at all
    if (min1.Y > max2.Y)
    {
        return FALSE;
    }

    if (min2.Y > max1.Y)
    {
        return FALSE;
    }

    // case4: edges are identical
    //  ----------------
    //  ----------------
    // No edges need to be broken up, but do we need to update some
    // dup values?
    if (CloseReal(max1.Y, max2.Y) && CloseReal(min1.Y, min2.Y))
    {
        // for now, we will return FALSE
        // I think, that it should be OK.
        // TODO: - Review
        // !!! IS this still ok? - t-wehunt
        if (ptrEdge1->SortBegin != ptrEdge2->SortBegin)
        {
            UpdateDups(ptrEdge1->SortBegin, ptrEdge2->SortBegin);
        }
        if (ptrEdge1->SortEnd != ptrEdge2->SortEnd)
        {
            UpdateDups(ptrEdge1->SortEnd, ptrEdge2->SortEnd);
        }
        return FALSE;
    }

    // case2: the edges overlap and share one end point
    //  --------------
    //  ----------------------
    //  The longer edge needs to be broken into 2 pieces
    if (CloseReal(min1.Y, min2.Y) && max1.Y < max2.Y)
    {
        //  --------------
        //  ----------------------
        // We have to update the dups of the shared point

        if (ptrEdge1->SortBegin != ptrEdge2->SortBegin)
        {
            UpdateDups(ptrEdge1->SortBegin, ptrEdge2->SortBegin);
        }
        *split1 = FALSE;
        *split2 = TRUE;
        *dupIndex2 = ptrEdge1->SortEnd;
        *intersect2 = PathPts[*dupIndex2];
        return TRUE;
    }
    else if (CloseReal(min1.Y, min2.Y) && max1.Y > max2.Y)
    {
        //  ----------------------
        //  --------------
        // We have to update the dups of the shared point

        if (ptrEdge1->SortBegin != ptrEdge2->SortBegin)
        {
            UpdateDups(ptrEdge1->SortBegin, ptrEdge2->SortBegin);
        }
        *split1 = TRUE;
        *split2 = FALSE;
        *dupIndex1 = ptrEdge2->SortEnd;
        *intersect1 = PathPts[*dupIndex1];
        return TRUE;
    }
    else if (CloseReal(max1.Y, max2.Y) && min1.Y > min2.Y)
    {
        //  ----------------------
        //          --------------
        // We have to update the dups of the shared point

        if (ptrEdge1->SortEnd != ptrEdge2->SortEnd)
        {
            UpdateDups(ptrEdge1->SortEnd, ptrEdge2->SortEnd);
        }
        *split1 = FALSE;
        *split2 = TRUE;
        *dupIndex2 = ptrEdge1->SortBegin;
        *intersect2 = PathPts[*dupIndex2];
        return TRUE;
    }
    else if (CloseReal(max1.Y, max2.Y) && min1.Y < min2.Y)
    {
        //          --------------
        //  ----------------------
        // We have to update the dups of the shared point

        if (ptrEdge1->SortEnd != ptrEdge2->SortEnd)
        {
            UpdateDups(ptrEdge1->SortEnd, ptrEdge2->SortEnd);
        }
        *split1 = TRUE;
        *split2 = FALSE;
        *dupIndex1 = ptrEdge2->SortBegin;
        *intersect1 = PathPts[*dupIndex1];
        return TRUE;
    }

    // case1: one is "inside" of another 
    //       ---------
    //   -----------------
    // In this case, the longer edge has to be broken into 3 pieces

    if (min1.Y < min2.Y && max1.Y > max2.Y)
    {
        // intersection points are the end points of the second edge
        // we are breaking up the first edge
        *split1 = TRUE;
        *split2 = FALSE;
        *split3 = TRUE;
        *dupIndex1 = ptrEdge2->SortBegin;
        *dupIndex2 = ptrEdge2->SortEnd;
        *intersect1 = PathPts[*dupIndex1];
        *intersect2 = PathPts[*dupIndex2];
        return TRUE;
    }
    else if(min1.Y > min2.Y && max1.Y < max2.Y)
    {
        // intersection points are the end points of the first edge
        // we are breaking up the second edge
        *split1 = FALSE;
        *split2 = TRUE;
        *split3 = TRUE;
        *dupIndex1 = ptrEdge1->SortBegin;
        *dupIndex2 = ptrEdge1->SortEnd;
        *intersect1 = PathPts[*dupIndex1];
        *intersect2 = PathPts[*dupIndex2];
        return TRUE;
    }


    // case3: edges overlap
    // ---------------
    //         -----------------
    // Each edge has to be broken up INT 2 pieces
    else if (max1.Y < max2.Y && min1.Y < min2.Y)
    {
        *split1 = TRUE;
        *split2 = TRUE;
        *dupIndex1 = ptrEdge2->SortBegin;
        *dupIndex2 = ptrEdge1->SortEnd;
        *intersect1 = PathPts[*dupIndex1];
        *intersect2 = PathPts[*dupIndex2];
        return TRUE;
    }
    else if (max2.Y < max1.Y && min2.Y < min1.Y)
    {
    //         -----------------
    // ---------------
        *split1 = TRUE;
        *split2 = TRUE;
        *dupIndex1 = ptrEdge2->SortEnd;
        *dupIndex2 = ptrEdge1->SortBegin;
        *intersect1 = PathPts[*dupIndex1];
        *intersect2 = PathPts[*dupIndex2];
        return TRUE;
    }

    WARNING(("Couldn't resolve overlapping edges"));
    return FALSE; // Shouldn't get here
}

/**************************************************************************\
*
* Function Description:
*
*  Break edge in 3 pieces.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

BOOL PathSelfIntersectRemover::BreakEdgeIn3(
    Edge *ptrEdge, 
    GpPointF *ptrPt1, 
    GpPointF *ptrPt2, 
    Edge *ptrNew1,
    Edge *ptrNew2, 
    INT dupIndex1, 
    INT dupIndex2
    )
{
    INT iptt1, ipto1;    // Indecies to the point arrays
    INT iptt2, ipto2;
    PointListNode ptord1; // Pointers to the linked list and point information
    PointListNode ptord2;
    PointListNode *pptordBeg = NULL;
    PointListNode *pptordEnd = NULL;

    // Let's first add the intersection points to the array of points.
    // Don't add identical points to the last point in the path.
    // iptt is the index of this point
    GpPointF &lastPt = PathPts.Last();
    if (ClosePt(*ptrPt1, lastPt))
    {
        return FALSE;
    }
    
    if (PathPts.Add(*ptrPt1) != Ok)
    {
        return FALSE;
    }
    else
    {
        iptt1 = (PathPts.GetCount())-1;
    }

    if (PathPts.Add(*ptrPt2) != Ok)
    {
        return FALSE;
    }
    else
    {
        iptt2 = (PathPts.GetCount())-1;
    }

    // we have to figure out how to link in the new points, it depends on
    // the direction of the new edge; iptt1 has the x coordinate <= than
    // iptt2.

    if (ptrEdge->Begin == ptrEdge->SortBegin)
    {
        // PointListNode record for the new point.
        ptord1.Prev = ptrEdge->Begin;
        ptord1.Next = iptt2;

        ptord2.Prev = iptt1;
        ptord2.Next = ptrEdge->End;
    }
    else
    {
        // PointListNode record for the new point.
        ptord1.Prev = iptt2;
        ptord1.Next = ptrEdge->End;

        ptord2.Prev = ptrEdge->Begin;
        ptord2.Next = iptt1;
    }

    // Update the duplicate field with the iptDup value passed in
    ptord1.Dup = dupIndex1;
    ptord2.Dup = dupIndex2;

    // Inside set to TRUE is the default
    ptord1.Inside = TRUE;
    ptord1.Used = FALSE;

    ptord2.Inside = TRUE;
    ptord2.Used = FALSE;

    // And now add it to the array.
    if (PtList.Add(ptord1) != Ok)
    {
        return FALSE;
    }
    else
    {
        ipto1 = (PtList.GetCount()-1);
    }

    if (PtList.Add(ptord2) != Ok)
    {
        return FALSE;
    }
    else
    {
        ipto2 = (PtList.GetCount()-1);
    }

    // Update ptord records for next and prev
    pptordBeg = &PtList[ptrEdge->Begin];
    pptordEnd = &PtList[ptrEdge->End];
    if (ptrEdge->Begin == ptrEdge->SortBegin)
    {
        pptordBeg->Next = ipto1;
        pptordEnd->Prev = ipto2;
    }
    else
    {
        pptordBeg->Next = ipto2;
        pptordEnd->Prev = ipto1;
    }

    // Both arrays - ptt and pto must have exactly the same # of elements
    ASSERTMSG((iptt2 == ipto2),("Assert failed."));

    //GpPointF pfpvBegin = *(PathPts.PGet(ptrEdge->SortBegin));
    //GpPointF pfpvEnd = *(PathPts.PGet(ptrEdge->SortEnd));

    // Lets create the new line segments.  The sorted order of 
    // end points is easy - intersection point must be before the SortEnd.
    ptrNew1->SortBegin = iptt1;
    ptrNew1->SortEnd = iptt2;

    // remember the original end point of the edge
    ptrNew1->OrigBegin = ptrEdge->OrigBegin;
    ptrNew1->OrigEnd = ptrEdge->OrigEnd;

    ptrNew2->SortBegin = iptt2;
    ptrNew2->SortEnd = ptrEdge->SortEnd;

    // remember the original end point of the edge
    ptrNew2->OrigBegin = ptrEdge->OrigBegin;
    ptrNew2->OrigEnd = ptrEdge->OrigEnd;

    // Also iptt (new point) becomes the new SortEnd of the old edge
    ptrEdge->SortEnd = iptt1;

    // Now, depending on whether the edge being broken up was swapped or not,
    // the new edges need to be swapped
    if (ptrEdge->Begin == ptrEdge->SortBegin)
    {
        // not swapped
        ptrEdge->End = iptt1;
        ptrNew1->Begin = ptrNew1->SortBegin;
        ptrNew1->End = ptrNew1->SortEnd;
        ptrNew2->Begin = ptrNew2->SortBegin;
        ptrNew2->End = ptrNew2->SortEnd;
    }
    else
    {
        // swapped
        ptrEdge->Begin = iptt1;
        ptrNew1->Begin = ptrNew1->SortEnd;
        ptrNew1->End = ptrNew1->SortBegin;
        ptrNew2->Begin = ptrNew2->SortEnd;
        ptrNew2->End = ptrNew2->SortBegin;
    }
    
    ptrNew1->Next = LIST_END;
    ptrNew2->Next = LIST_END;

    // If the point of intersection is on the scan line, we need to insert
    // the new edge to the Active table, otherwise to the table with edges
    // to process.

    if (CloseReal(XCur, ptrPt1->X))
    {
        MarkToAdd(ptrNew1);
    }
    else
    {
        if(Ok != EdgeList.Add(*ptrNew1))
        {
            return FALSE;  // out of memory
        }
        
        InsertEdgeIntoList(
            &InactiveEdgeList, 
            EdgeList.GetCount()-1, 
            CompareLine
        );
    }

    if (CloseReal(XCur, ptrPt2->X))
    {
        MarkToAdd(ptrNew2);
    }
    else
    {
        if(Ok != EdgeList.Add(*ptrNew2))
        {
            return FALSE;  // out of memory
        }
        
        InsertEdgeIntoList(
            &InactiveEdgeList, 
            EdgeList.GetCount()-1, 
            CompareLine
        );
    }

    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*
*   Breaks edge ptrEdge.  We have found intersection point intersectPt, which is
*   guranteed to be somewhere on the line segment (not an end point).
*   The 'left' part of the edge will either remain in the active edges
*   or will be removed (only if the intersection point has the current
*   x value.  In the latter case, the right edge segment will need to be
*   inserted to active edges, otherwise (the former case) it will go
*   to InactiveEdgeList.  If it needs to go to active edges, Breakedge cannot
*   insert it because it would disrupt the order of edges there before
*   both edges broken up are handled.  The caller would have to handle
*   the insertion in such case.  Therefore, we return the new line
*   segment newEdge and a BOOL value specifying if the caller has to insert 
*   the newEdge edge.
*   dupIndex is the index of the duplicate point created by this intersection:
*   When two edges intersect, we have to insert two points (identical)
*   to maintain the same shape of the polygon.  These two points are
*   called duplicates.
*   Return FALSE on out of memory.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

BOOL PathSelfIntersectRemover::BreakEdge(
    Edge *ptrEdge, 
    GpPointF *intersectPt, 
    Edge *newEdge, 
    INT dupIndex
    )
{
    INT iptt, ipto;    // Indecies to the point arrays
    PointListNode ptNode; // Pointers to the linked list and point information
    PointListNode *ptNodeBeg = NULL;
    PointListNode *ptNodeEnd = NULL;

    // Let's first add the intersection point to the array of points.

    if (PathPts.Add(*intersectPt) != Ok)
    {
        return FALSE;
    }
    else
    {
        iptt = (PathPts.GetCount())-1;
    }

    // PointListNode record for the new point.  It is in the middle of the 
    // edge, so Begin and End point of the edge will be its previous and next
    ptNode.Prev = ptrEdge->Begin;
    ptNode.Next = ptrEdge->End;
    // Update the duplicate field with the dupIndex value passed in
    ptNode.Dup = dupIndex;
    // Inside set to TRUE is the default
    ptNode.Inside = TRUE;
    ptNode.Used = FALSE;

    // And now add it to the array.
    if (PtList.Add(ptNode) != Ok)
    {
        return FALSE;
    }
    else
    {
        ipto = (PtList.GetCount()-1);
    }

    // Update ptNode records for next and prev
    ptNodeBeg = &PtList[ptrEdge->Begin];
    ptNodeEnd = &PtList[ptrEdge->End];
    ptNodeBeg->Next = ipto;
    ptNodeEnd->Prev = ipto;

    // Both arrays - ptt and pto must have exactly the same # of elements
    ASSERTMSG((iptt == ipto),("Assert failed."));

    // remember the original end point of the edge
    newEdge->OrigBegin = ptrEdge->OrigBegin;
    newEdge->OrigEnd = ptrEdge->OrigEnd;

    // Lets create the new line segment.  The sorted order of end points 
    // is easy - intersection point must be before the SortEnd.
    newEdge->SortBegin = iptt;
    newEdge->SortEnd = ptrEdge->SortEnd;

    // Also iptt (new point) becomes the new SortEnd of the old edge
    ptrEdge->SortEnd = iptt;

    // Now, depending on whether the edge being broken up was swapped or not,
    // the new edges need to be swapped
    if (ptrEdge->Begin == ptrEdge->SortBegin)
    {
        // not swapped
        ptrEdge->End = iptt;
        newEdge->Begin = newEdge->SortBegin;
        newEdge->End = newEdge->SortEnd;
    }
    else
    {
        // swapped
        ptrEdge->Begin = iptt;
        newEdge->Begin = newEdge->SortEnd;
        newEdge->End = newEdge->SortBegin;
    }
    
    newEdge->Next = LIST_END;

    // If the point of intersection is on the scan line, we need to insert
    // the new edge to the Active table, otherwise to the table with edges
    // to process.

    if (CloseReal(XCur, intersectPt->X))
    {
        MarkToAdd(newEdge);
    }
    else
    {
        if(Ok != EdgeList.Add(*newEdge))
        {
            return FALSE;  // out of memory
        }
        
        InsertEdgeIntoList(
            &InactiveEdgeList, 
            EdgeList.GetCount()-1, 
            CompareLine
        );
    }

    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*
*   Eliminate Self Intersections in a widened path
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

GpStatus PathSelfIntersectRemover::RemoveSelfIntersects()
{
    CanAddPts = FALSE;

    // ------  Phase 1:
    
    INT count = EdgeList.GetCount();
    if (count <= 0)
    {
        return Ok;  //nothing to correct
    }

    // Sort all the edges in EdgeList array.
    
    Edge *edges = EdgeList.GetDataBuffer();
    QuickSortEdges(edges, edges+count-1);
    
    InactiveEdgeList = 0;   // Point to the first element in the inactive list.
    
    // Initialize the linked list Next pointers:
    
    for(int i = 0; i < count-1; i++)
    {
        EdgeList[i].Next = i+1;
    }
    
    EdgeList[i].Next = LIST_END;

    if (!FindIntersects())
    {
        return GenericError;
    }
    
    
    // ------  Phase 2:
    
    // FindIntersects orphans all the edges from the list. Reconstruct and 
    // re-sort using QuickSort. This works out faster because the incremental
    // sort during FindIntersects would have been at least O(n^2).
    
    count = EdgeList.GetCount(); 
    
    // we never actually delete anything from the array - only from the 
    // linked list, so if we had count > 0 above, we must have a larger or
    // the same count now.
    
    ASSERT(count > 0);
    
    // Sort all the edges in the EdgeList array.
    
    edges = EdgeList.GetDataBuffer();
    QuickSortEdges(edges, edges+count-1);
    
    InactiveEdgeList = 0;   // Point to the first element in the inactive list.
    
    // Initialize the linked list Next pointers:
    
    for(int i = 0; i < count-1; i++)
    {
        EdgeList[i].Next = i+1;
    }
    
    EdgeList[i].Next = LIST_END;

    if(!EliminatePoints())
    {
        return GenericError;
    }
    
    // ... move on to phase 3 - collection.
    
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Eliminate Self Intersections.
*
*   This is considered 'Phase 2' of the algorithm.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

BOOL PathSelfIntersectRemover::EliminatePoints()
{
    // Initialize the array of active edges.
    // Take the first edge from the edge array and add it to the active edgs.
    // Add all other edges, which start at the same x.

    if (InactiveEdgeList == LIST_END)
    {
        return FALSE;
    }

    XCur = PathPts[EdgeList[InactiveEdgeList].SortBegin].X;

    // "move" all edges starting at xCur to the active edge array
    // PathPts in the active edge array will be sorted by y for the
    // given xCur.
    
    AddActiveForXScan(&InactiveEdgeList);

    // As long as the Active edge array is not empty, keep scanning
    
    while (TRUE)
    {
        // Scan the active edge array for the current XCur;
        if (!ScanActive())
        {
            return FALSE;
        }

        RemoveVertAll();

        // Update the XCur using edges from InactiveEdgeList
        if (!ClosestActive(InactiveEdgeList))
        {
            break;
        }

        // Remove all edges which end BEFORE XCur;
        
        ClearActiveListExclusiveX();

        // Add new edges, which begin at XCur
        AddActiveForXScan(&InactiveEdgeList);
    }
    return TRUE;
}


/**************************************************************************\
*
* Function Description:
*
*    Scan through all active edges during the phase of edge elimination.
*    Calculates winding number to the left and to the right of the current
*    x value - XCur.  Whenever finds an edge which has 0 winding number
*    on one side, marks it as an outside edge.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

BOOL PathSelfIntersectRemover::ScanActive()
{
    Edge *ptrEdge = NULL;
    Edge *plnNext = NULL;

    GpPointF *pfpvBegin = NULL;
    GpPointF *pfpvEnd = NULL;

    // We are starting from the outside.
    INT lwindLeft = 0;
    INT lwindRight = 0;

    // Look at all edges in the ective edge array.
    INT index = ActiveEdgeList;
    
    while (index != LIST_END)
    {
        ptrEdge = &EdgeList[index];
        index = ptrEdge->Next;

        // Get the end points
        ASSERTMSG((ptrEdge->SortBegin < PathPts.GetCount()), ("FATAL ERROR."));
        pfpvBegin = &PathPts[ptrEdge->SortBegin];

        ASSERTMSG((ptrEdge->SortEnd < PathPts.GetCount()), ("FATAL ERROR."));
        pfpvEnd = &PathPts[ptrEdge->SortEnd];

        // Is it vertical?
        if (ptrEdge->IsVertical())
        {
            if (NewInterval(ptrEdge))
            {
                if (lwindLeft == 0 || lwindRight == 0)
                {
                    MarkVertOutside();
                }
            }
            RemoveVert(ptrEdge->YCur, TRUE /*inclusive*/);

            //add it to the active vertical edges
            //Edge insertion
            if (ActiveVertEdges.InsertSorted(*ptrEdge, 
                (DynSortArrayCompareFunc)&(CompareVertLine),
                this) != Ok)
            {
                return FALSE;
            }
        }
        else
        {
            if (lwindLeft == 0 || lwindRight == 0)
            {
                MarkVertOutside();
            }

            RemoveVert(ptrEdge->YCur, TRUE /*inclusive*/);

            // Edge is not vertical, does it have an end point 
            // on this scan line
            if ((!CloseReal(pfpvBegin->X, XCur)) && 
                (!CloseReal(pfpvEnd->X, XCur)))
            {
                // we are crossing edge in the middle, so both winding numbers
                // need to be updated
                if (lwindLeft == 0 || lwindRight == 0)
                {
                    ptrEdge->MarkOutside();
                }
                if (ptrEdge->SortBegin == ptrEdge->Begin)
                {
                    lwindLeft++;
                    lwindRight++;
                }
                else
                {
                    lwindLeft--;
                    lwindRight--;
                }
                if (lwindLeft == 0 || lwindRight == 0)
                {
                    ptrEdge->MarkOutside();
                }
            }
            else if ((CloseReal(pfpvBegin->X, XCur)) && 
                    (!CloseReal(pfpvEnd->X, XCur)))
            {
                //right edge
                if (lwindRight == 0)
                {
                    ptrEdge->MarkOutside();
                }
                if (ptrEdge->SortBegin == ptrEdge->Begin)
                {
                    lwindRight++;
                }
                else
                {
                    lwindRight--;
                }
                if (lwindRight == 0)
                {
                    ptrEdge->MarkOutside();
                }
            }
            else if ((!CloseReal(pfpvBegin->X, XCur)) && 
                      (CloseReal(pfpvEnd->X, XCur)))
            {
                //left edge
                if (lwindLeft == 0)
                {
                    ptrEdge->MarkOutside();
                }
                if (ptrEdge->SortBegin == ptrEdge->Begin)
                {
                    lwindLeft++;
                }
                else
                {
                    lwindLeft--;
                }
                if (lwindLeft == 0)
                {
                    ptrEdge->MarkOutside();
                }
            }
            else
            {

                WARNING(("Edge is not vertical, but not in XCur"));
            }
            // if we crossed to te outside, all current vertical edges need 
            // to be marked
            if (lwindLeft == 0 || lwindRight == 0)
            {
                MarkVertOutside();
            }
            RemoveVert(ptrEdge->YCur, TRUE /*inclusive*/);
        }
        
    }
    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*
*  Mark the one or two of the current vertical edges as outside.
*  If there is an even number of edge going in both directions, it means that
*  the winding number is the same on both sides.  Since we are being called,
*  it must be 0.  In this case, we pick one edge going up and one edge going
*  down and mark both of them as outside.
*  If there is more edges going in one direction than another, then the winding
*  numbers are different, but one of them is 0.  We pick one of the edges from
*  that set edges (up or down) which is larger.  So if more edges go down, we
*  pick one of those edges and mark them as outside.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

VOID PathSelfIntersectRemover::MarkVertOutside()
{
    Edge *ptrEdge = NULL;
    INT index = 0;
    INT ndown = 0;
    INT nup = 0;
    INT idown = -1;
    INT iup = -1;

    // we will mark the first one

    while (index < ActiveVertEdges.GetCount() )
    {
        //PGet on edges
        ptrEdge = &ActiveVertEdges[index];
        if (ptrEdge->SortBegin == ptrEdge->Begin)
        {
            //goes down
            ndown++;
            idown = index;
        }
        else
        {
            nup++;
            iup = index;
        }
        index++;
    }

    if (ndown > nup)
    {
        //PGet on edges
        ptrEdge = &ActiveVertEdges[idown];
        ptrEdge->MarkOutside();
    }
    else if (nup > ndown)
    {
        //PGet on edges
        ptrEdge = &ActiveVertEdges[iup];
        ptrEdge->MarkOutside();
    }
    else
    {
        if (nup != 0)
        {
            if (iup > -1)
            {
                //PGet on edges
                ptrEdge = &ActiveVertEdges[iup];
                ptrEdge->MarkOutside();
            }
        }
        if (ndown != 0)
        {
            if (idown > -1)
            {
                //PGet on edges
                ptrEdge = &ActiveVertEdges[idown];
                ptrEdge->MarkOutside();
            }
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
*    Returns TRUE if edge ptrEdge belongs to a different interval than the
*    edges currently stored in ActiveVertEdges.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

BOOL PathSelfIntersectRemover::NewInterval(Edge *ptrEdge)
{
    Edge *plnOld;
    
    if (ActiveVertEdges.GetCount() <= 0)
    {
        return FALSE;
    }

    //PGet on edges
    plnOld = &ActiveVertEdges.First();

    REAL fpY1, fpY2;

    fpY1 = PathPts[plnOld->SortEnd].Y;
    fpY2 = PathPts[ptrEdge->SortEnd].Y;
    
    if (CloseReal(fpY1, fpY2))
    {
        return FALSE;
    }

    if (fpY1 < fpY2)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

/**************************************************************************\
*
* Function Description:
*
*  Remove all the edges from the active edge array.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

VOID PathSelfIntersectRemover::RemoveVertAll()
{
    if( ActiveVertEdges.GetCount() > 0)
    {
        ActiveVertEdges.Reset(FALSE);
    }
}

/**************************************************************************\
*
* Function Description:
*
*  Remove vertical edges which have end points below given y value.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

VOID PathSelfIntersectRemover::RemoveVert(REAL y, BOOL inclusive)
{
    Edge *ptrEdge = NULL;

    // edges are sorted, so as soon as we find an end point with y value > y
    // we are done
    while (ActiveVertEdges.GetCount() > 0)
    {
        //PGet on edges
        ptrEdge = &ActiveVertEdges.First();
        REAL fpY;
        fpY = PathPts[ptrEdge->SortEnd].Y;
        if (inclusive)
        {
            if (fpY < y || CloseReal(fpY,y))
            {
                ActiveVertEdges.DeleteAt(0);
            }
            else
            {
                return;
            }
        }
        else
        {
            if (fpY < y && (!CloseReal(fpY,y)))
            {
                ActiveVertEdges.DeleteAt(0);
            }
            else
            {
                return;
            }
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
*  Scan the ActiveEdgeList for all edges which end at XCur (inclusive) and
*  simply orphan them. This is used in the first phase of the algorithm
*  (FindIntersects) which passes each edge from the InactiveEdgeList through
*  the ActiveEdgeList. When the edges are no longer needed they're removed
*  from all lists.
*
* Created
*
*  12/27/2000 asecchia
*
\**************************************************************************/

void PathSelfIntersectRemover::ClearActiveListInclusiveX()
{
    INT *pIndex = &ActiveEdgeList;
    
    while(*pIndex != LIST_END)
    {
        Edge *pEdge = &EdgeList[*pIndex];
        GpPointF *pSortEnd = &PathPts[pEdge->SortEnd];

        // inclusive check.
        
        if((pSortEnd->X < XCur) || CloseReal(pSortEnd->X, XCur))
        {
            // delete the item and advance.
            
            *pIndex = pEdge->Next;     // point past the deleted item. 
            pEdge->Next = LIST_END;    // disconnect the deleted item. 
        }
        else
        {
            pIndex = &EdgeList[*pIndex].Next;
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
*  Remove from ActiveEdgeList all edges which end at XCur. This uses
*  an exclusive check. This code is used for the second phase of the algorithm
*  (EliminatePoints). Each edge removed is orphaned from the list because
*  the linked list representation will not be used after this phase.
*
* Created:
*
*    12/23/2000 asecchia
*
\**************************************************************************/

void PathSelfIntersectRemover::ClearActiveListExclusiveX()
{
    INT *pIndex = &ActiveEdgeList;
    
    while(*pIndex != LIST_END)
    {
        Edge *pEdge = &EdgeList[*pIndex];
        GpPointF *pSortEnd = &PathPts[pEdge->SortEnd];

        // exclusive check.
        
        if((pSortEnd->X < XCur) && !CloseReal(pSortEnd->X, XCur))
        {
            // delete the item and advance.
            
            *pIndex = pEdge->Next;     // point past the deleted item. 
            pEdge->Next = LIST_END;    // disconnect the deleted item. 
        }
        else
        {
            pIndex = &EdgeList[*pIndex].Next;
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
*    Add all edges with begin point at xCur to the active edge table.
*    Update the index piLn to the edge array to point to the next edge, which
*    will have to be considered.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

void PathSelfIntersectRemover::AddActiveForX(INT *inactiveHead)
{
    // We have a new current x, let's calculate new curent Y's for each edge
    // They are needed to insert the new active edges in the right order
    
    RecalcActiveYCur();
    
    InsertNewEdges(
        &ActiveEdgeList,  // insert
        inactiveHead,     // remove
        XCur,
        CompareYCurLine
    );
}

/**************************************************************************\
*
* Function Description:
*
*    Add all edges with begin point at xCur to the active edge table.
*    Update the index piLn to the edge array to point to the next edge, which
*    will have to be considered.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

void PathSelfIntersectRemover::AddActiveForXScan(INT *inactiveHead)
{
    // We have a new current x, let's calculate new curent Y's for each edge
    // They are needed to insert the new active edges in the right order
    
    RecalcActiveYCur();

    InsertNewEdges(
        &ActiveEdgeList,   // insert
        inactiveHead,      // remove
        XCur,
        CompareYScanCurLine
    );
}

/**************************************************************************\
*
* Function Description:
*
*  Calculate the yCur position for each edge in the active edge table.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

VOID PathSelfIntersectRemover::RecalcActiveYCur(VOID)
{
    REAL dx = 0;
    REAL dy = 0;
    REAL dxCur = 0;

    GpPointF fpvBegin(0,0);
    GpPointF fpvEnd(0,0);
    GpPointF fpvOrigBegin(0,0);
    GpPointF fpvOrigEnd(0,0);

    Edge *ptrEdge = NULL;
    INT active = ActiveEdgeList;

    // Go through all active egdes
    
    while(active != LIST_END)
    {
        ptrEdge = &EdgeList[active];

        // If the edge will have an end point at XCur,
        // use this end point's y value.
        
        fpvBegin = PathPts[ptrEdge->SortBegin];
        fpvEnd = PathPts[ptrEdge->SortEnd];
        fpvOrigBegin = PathPts[ptrEdge->OrigBegin];
        fpvOrigEnd = PathPts[ptrEdge->OrigEnd];
        
        if ((XCur == fpvEnd.X) || (fpvEnd.X == fpvBegin.X))
        {
            ptrEdge->YCur = fpvEnd.Y;
        }
        else
        {
            // Calculate the slope numerator and denominator
            dx = fpvOrigEnd.X - fpvOrigBegin.X;
            dy = fpvOrigEnd.Y - fpvOrigBegin.Y;
            dxCur = XCur - fpvOrigBegin.X;
            ptrEdge->YCur = dy * dxCur / dx + fpvOrigBegin.Y;
        }
        
        active = EdgeList[active].Next;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Compare two lines.  Lines are sorted based on the yCur value.  
*   If yCur's are identical, lines are sorted based on the begin point.
*
* Arguments:
*
*
* Return Value:
*
*   -1 if ptrEdge1 < ptrEdge2
*    0 if ther are equal
*    1 if ptrEdge1 > ptrEdge2
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

INT 
CompareYScanCurLine(
    PathSelfIntersectRemover *ptrCorrector, 
    Edge *ptrEdge1, 
    Edge *ptrEdge2
    )
{
    if (!ptrEdge1->CloseReal(ptrEdge1->YCur, ptrEdge2->YCur))
    {   
        if(ptrEdge1->YCur < ptrEdge2->YCur)
        {
            return -1;
        }
        if(ptrEdge1->YCur > ptrEdge2->YCur)
        {
            return 1;
        }
    }
    // All left and vertical edges need to go before right edges if they have
    // the same yCur;
    // A left edge has a begin point < xCur, right edge x = xCur

    BOOL fLeft1 = TRUE;
    BOOL fLeft2 = TRUE;

    fLeft1 = ((ptrCorrector->PathPts[ptrEdge1->SortBegin].X < 
               ptrCorrector->XCur                                    &&
               ptrEdge1->CloseReal(ptrCorrector->PathPts[ptrEdge1->SortEnd].X,
                         ptrCorrector->XCur))                        ||
               ptrEdge1->IsVertical());
    fLeft2 = ((ptrCorrector->PathPts[ptrEdge2->SortBegin].X < 
               ptrCorrector->XCur                                    &&
               ptrEdge2->CloseReal(ptrCorrector->PathPts[ptrEdge2->SortEnd].X,
                         ptrCorrector->XCur))                        ||
               ptrEdge2->IsVertical());

    if (fLeft1 && (!fLeft2))
        return 1;
    if ((!fLeft1) && fLeft2)
        return -1;

    REAL slope1(0.0);
    REAL slope2(0.0);

    // For vertical edges, we actually store them as +/-INF, and 
    // can use the sign to determine the direction.
    
    if (ptrEdge1->IsVertical())
    {
        // Avoid (inf x 0) which causes a real indefinite.
        
        if( REALABS(
            ptrCorrector->PathPts[ptrEdge1->OrigEnd].Y - 
            ptrCorrector->PathPts[ptrEdge1->OrigBegin].Y
            ) > REAL_EPSILON
        )
        {
            slope1 = SignReal( ptrCorrector->PathPts[ptrEdge1->OrigEnd].Y
                - ptrCorrector->PathPts[ptrEdge1->OrigBegin].Y) 
                * FP_INF;
        }
    }
    else
    {
        // Avoid divide by zero.
        
        if( REALABS(
            ptrCorrector->PathPts[ptrEdge1->OrigEnd].X - 
            ptrCorrector->PathPts[ptrEdge1->OrigBegin].X 
            ) > REAL_EPSILON
        )
        {
            slope1 = ptrCorrector->PathPts[ptrEdge1->OrigEnd].Y
                            - ptrCorrector->PathPts[ptrEdge1->OrigBegin].Y;
    
            slope1 = slope1 /
                            (ptrCorrector->PathPts[ptrEdge1->OrigEnd].X
                            - ptrCorrector->PathPts[ptrEdge1->OrigBegin].X);
        }
    }

    if (ptrEdge2->IsVertical())
    {
        // Avoid (inf x 0) which causes a real indefinite.
        
        if( REALABS(
            ptrCorrector->PathPts[ptrEdge2->OrigEnd].Y - 
            ptrCorrector->PathPts[ptrEdge2->OrigBegin].Y
            ) > REAL_EPSILON
        )
        {
            slope2 = SignReal(ptrCorrector->PathPts[ptrEdge2->OrigEnd].Y
                - ptrCorrector->PathPts[ptrEdge2->OrigBegin].Y)
                * FP_INF;
        }
    }
    else
    {
        // Avoid divide by zero.
        
        if( REALABS(
            ptrCorrector->PathPts[ptrEdge2->OrigEnd].X - 
            ptrCorrector->PathPts[ptrEdge2->OrigBegin].X
            ) > REAL_EPSILON
        )
        {
            slope2 = ptrCorrector->PathPts[ptrEdge2->OrigEnd].Y
                            - ptrCorrector->PathPts[ptrEdge2->OrigBegin].Y;
    
            slope2 = slope2 /
                            (ptrCorrector->PathPts[ptrEdge2->OrigEnd].X
                            - ptrCorrector->PathPts[ptrEdge2->OrigBegin].X);
        }
    }

    if (slope1 < slope2)
        return -1;

    if (slope1 > slope2)
        return 1;

    // slopes are equal

    if (ptrCorrector->PathPts[ptrEdge1->SortEnd].Y < 
        ptrCorrector->PathPts[ptrEdge2->SortEnd].Y)
        return -1;

    if (ptrCorrector->PathPts[ptrEdge1->SortEnd].Y > 
        ptrCorrector->PathPts[ptrEdge2->SortEnd].Y)
        return 1;

    // (ptrCorrector->PathPts.PGet(ptrEdge1->SortEnd))->Y == 
    // (ptrCorrector->PathPts.PGet(ptrEdge2->SortEnd))->Y

    if (ptrCorrector->PathPts[ptrEdge1->SortEnd].X < 
        ptrCorrector->PathPts[ptrEdge2->SortEnd].X)
        return -1;

    if (ptrCorrector->PathPts[ptrEdge1->SortEnd].X > 
        ptrCorrector->PathPts[ptrEdge2->SortEnd].X)
        return 1;

    // Now, all point coordinates are exactly the same, but in some cases,
    // we may have two identical edges with the coordinates, these edges 
    // may have different points (actual indecies into points array, not 
    // coordinate values). We want to consider them as identical only if 
    // the indecies are the same.

    if (ptrEdge1->SortBegin < ptrEdge2->SortBegin)
        return -1;

    if (ptrEdge1->SortBegin > ptrEdge2->SortBegin)
        return 1;

    if (ptrEdge1->SortEnd < ptrEdge2->SortEnd)
        return -1;

    if (ptrEdge1->SortEnd > ptrEdge2->SortEnd)
        return 1;

    return 0;
}

/**************************************************************************\
*
* Function Description:
*
*   Compare two lines.  Lines are sorted based on the yCur value.
*   If yCur's are identical, lines are sorted based on the begin point.
*
* Arguments:
*
*
* Return Value:
*
*   -1 if ptrEdge1 < ptrEdge2
*    0 if ther are equal
*    1 if ptrEdge1 > ptrEdge2
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

INT 
CompareYCurLine(
    PathSelfIntersectRemover *ptrCorrector, 
    Edge *ptrEdge1, 
    Edge *ptrEdge2
    )
{
    if (!ptrEdge1->CloseReal(ptrEdge1->YCur, ptrEdge2->YCur))
    {
        if(ptrEdge1->YCur < ptrEdge2->YCur)
            return -1;

        if(ptrEdge1->YCur > ptrEdge2->YCur)
            return 1;
    }

    // We have to sort based on slope.

    REAL slope1(0.0);
    REAL slope2(0.0);

    // For vertical edges, we actually store them as +/-INF, and 
    // can use the sign to determine the direction.
    if (ptrEdge1->IsVertical())
    {
        // Avoid INF * 0.
        
        if( REALABS(
            ptrCorrector->PathPts[ptrEdge1->OrigEnd].Y - 
            ptrCorrector->PathPts[ptrEdge1->OrigBegin].Y
            ) > REAL_EPSILON
        )
        {
            
            slope1 = SignReal(
                ptrCorrector->PathPts[ptrEdge1->OrigEnd].Y - 
                ptrCorrector->PathPts[ptrEdge1->OrigBegin].Y ) * FP_INF;
        }
    }
    else
    {
        // Avoid divide by zero.
        
        if( REALABS(
            ptrCorrector->PathPts[ptrEdge1->OrigEnd].X - 
            ptrCorrector->PathPts[ptrEdge1->OrigBegin].X
            ) > REAL_EPSILON
        )
        {
            slope1 = ptrCorrector->PathPts[ptrEdge1->OrigEnd].Y
                            - ptrCorrector->PathPts[ptrEdge1->OrigBegin].Y;
    
            slope1 = slope1 /
                            (ptrCorrector->PathPts[ptrEdge1->OrigEnd].X
                            - ptrCorrector->PathPts[ptrEdge1->OrigBegin].X);
        }
    }

    if (ptrEdge2->IsVertical())
    {
        // Avoid INF * 0.
        
        if( REALABS(
            ptrCorrector->PathPts[ptrEdge2->OrigEnd].Y - 
            ptrCorrector->PathPts[ptrEdge2->OrigBegin].Y
            ) > REAL_EPSILON
        )
        {
            slope2 = SignReal(
                ptrCorrector->PathPts[ptrEdge2->OrigEnd].Y - 
                ptrCorrector->PathPts[ptrEdge2->OrigBegin].Y) * FP_INF;
        }
    }
    else
    {
        // Avoid divide by zero.
        
        if( REALABS( 
            ptrCorrector->PathPts[ptrEdge2->OrigEnd].X -
            ptrCorrector->PathPts[ptrEdge2->OrigBegin].X
            ) > REAL_EPSILON
        )
        {
            slope2 = ptrCorrector->PathPts[ptrEdge2->OrigEnd].Y - 
                     ptrCorrector->PathPts[ptrEdge2->OrigBegin].Y;
    
            slope2 = slope2 /
                            (ptrCorrector->PathPts[ptrEdge2->OrigEnd].X
                            - ptrCorrector->PathPts[ptrEdge2->OrigBegin].X);
        }
    }

    if (slope1 < slope2)
        return -1;

    if (slope1 > slope2)
        return 1;

    // slopes are equal

    if (ptrCorrector->PathPts[ptrEdge1->SortEnd].Y < 
        ptrCorrector->PathPts[ptrEdge2->SortEnd].Y)
        return -1;

    if (ptrCorrector->PathPts[ptrEdge1->SortEnd].Y > 
        ptrCorrector->PathPts[ptrEdge2->SortEnd].Y)
        return 1;

    // (ptrCorrector->PathPts.PGet(ptrEdge1->SortEnd))->Y == 
    // (ptrCorrector->PathPts.PGet(ptrEdge2->SortEnd))->Y

    if (ptrCorrector->PathPts[ptrEdge1->SortEnd].X < 
        ptrCorrector->PathPts[ptrEdge2->SortEnd].X)
        return -1;

    if (ptrCorrector->PathPts[ptrEdge1->SortEnd].X > 
        ptrCorrector->PathPts[ptrEdge2->SortEnd].X)
        return 1;

    // Now, all point coordinates are exactly the same, but in some cases,
    // we may have two identical edges with the coordinates, these edges 
    // may have different points (actual indecies into points array, not 
    // coordinate values). We want to consider them as identical only if the 
    // indecies are the same.

    if (ptrEdge1->SortBegin < ptrEdge2->SortBegin)
        return -1;

    if (ptrEdge1->SortBegin > ptrEdge2->SortBegin)
        return 1;

    if (ptrEdge1->SortEnd < ptrEdge2->SortEnd)
        return -1;

    if (ptrEdge1->SortEnd > ptrEdge2->SortEnd)
        return 1;

    return 0;
}

/**************************************************************************\
*
* Function Description:
*
*  Compares lines based on the y coordinate of the end point.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

INT
CompareVertLine(
    PathSelfIntersectRemover *ptrCorrector, 
    Edge *ptrEdge1, 
    Edge *ptrEdge2
    )
{
    if(ptrCorrector->PathPts[ptrEdge1->SortEnd].Y < 
        ptrCorrector->PathPts[ptrEdge2->SortEnd].Y)
        return -1;

    if(ptrCorrector->PathPts[ptrEdge1->SortEnd].Y > 
        ptrCorrector->PathPts[ptrEdge2->SortEnd].Y)
        return 1;

    if(ptrCorrector->PathPts[ptrEdge1->SortBegin].Y < 
        ptrCorrector->PathPts[ptrEdge2->SortBegin].Y)
        return -1;

    if(ptrCorrector->PathPts[ptrEdge1->SortBegin].Y > 
        ptrCorrector->PathPts[ptrEdge2->SortBegin].Y)
        return 1;

    // Now, all point coordinates are exactly the same, but in some cases, 
    // we may have two identical edges with the coordinates, these edges may 
    // have different points (actual indecies into points array, not 
    // coordinate values). We want to consider them as identical only if the 
    // indecies are the same.

    if (ptrEdge1->SortBegin < ptrEdge2->SortBegin)
        return -1;

    if (ptrEdge1->SortBegin > ptrEdge2->SortBegin)
        return 1;

    if (ptrEdge1->SortEnd < ptrEdge2->SortEnd)
        return -1;

    if (ptrEdge1->SortEnd > ptrEdge2->SortEnd)
        return 1;

    return 0;
}

/**************************************************************************\
*
* Function Description:
*
*    Finds the x value of the closest end point (in x) - the next scan line.
*    Depending on the phase of the algorithm, it needs to look at edges in
*    different arrays.  The new value is stored in XCur.
*    Returns FALSE if there are no more points to look at - we are done.
*    In this case, XCur is set to longLast.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

BOOL PathSelfIntersectRemover::ClosestActive(INT arrayIndex)
{
    REAL xClosest = 0;

    // We need to find the next X value for the scan line:
    // take the minimum of any end point of active edges and the begin point
    // of the first edge which will be inserted to active edges.

    // Let's first look at the possible new edge
    
    if (arrayIndex == LIST_END)       // no more edges to add
    {
        xClosest = FP_INF;
    }
    else
    {
        xClosest = PathPts[EdgeList[arrayIndex].SortBegin].X;
    }

    INT active = ActiveEdgeList;

    // Now, look at all active edges
    
    while (active != LIST_END)
    {
        REAL xActive = PathPts[EdgeList[active].SortEnd].X;
        
        if((xClosest > xActive) && 
           (xActive > XCur) && 
           (!CloseReal(xActive, XCur)))
        {
            xClosest = xActive;
        }
        
        active = EdgeList[active].Next;
    }
    
    if (xClosest != FP_INF)
    {
        XCur = xClosest;
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Returns the new path.  New path contains of 1 or more subpaths.
*   The subpaths are stored as a list of points and a list of points 
*   per polygon.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

GpStatus PathSelfIntersectRemover::GetNewPoints(
    DynPointFArray *pts, 
    DynIntArray *polyCounts
    )
{
    GpPointF *pptToCopy = NULL;
    INT iptFirst = 0;
    GpStatus status;

    if (PathPts.GetCount() <= 0)
    {
        return Ok;
    }

    if (PtList.GetCount() <= 0)
    {
        return Ok;
    }

    // Initialize the array which will contain the resulting paths
    // We don't know haw many points we are going to have
    // Guess?  TODO!
    if ((status = pts->ReserveSpace(2*PathPts.GetCount()/3)) != Ok)
    {
        return status;
    }

    if ((status = polyCounts->ReserveSpace(2*PathPts.GetCount())) != Ok)
    {
        return status;
    }

    // Collect paths as long as there are unused (outside) points
    INT cptOld = 0;
    INT npt = 0;

    while (!AllPointsUsed(&iptFirst))
    {
        if (!CollectPath(iptFirst))
        {
            return GenericError;
        }
        // How many points do we have in the last path?
        npt = ResultPts.GetCount() - cptOld;
        // Add the point count to the poly array
        if ((status = polyCounts->Add(npt)) != Ok)
        {
            return status;
        }
        // Save the count of points
        cptOld = ResultPts.GetCount();
    }

    pts->ReplaceWith(&ResultPts);

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*    Return TRUE if all points have been used (added to the resulting paths)
*    or are inside.  If returns FALSE, returns the index to the next unused
*    point.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

BOOL PathSelfIntersectRemover::AllPointsUsed(INT *piptUnUsed)
{
    PointListNode *ptNode = NULL;
    INT iptord = 0;

    // TODO:  Create a static or a member which would remember the last
    // point returned here, so we don't have to start from the beginning each
    // time

    IntersectsWereRemoved = FALSE;
    while (iptord != -1)
    {
        if (iptord >= PtList.GetCount())
        {
            break;
        }
        ptNode = &PtList[iptord];
        if (!ptNode->Used)
        {
            if (ptNode->Inside)
            { 
                IntersectsWereRemoved = TRUE;
                iptord = ptNode->Next;
            } 
            else
            {
                *piptUnUsed = iptord;
                return FALSE;
            }
        }
        else
        {
            iptord = ptNode->Next;
        }
    }

    *piptUnUsed = -1;
    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*
*    After the process of eliminating edges and marking points as inside
*    and outside, we need to go through the linked list of points and
*    build paths from the edges which are outside.  CollectPath will
*    collect one path starting from point with index iptFirst.  It
*    returns the actual value of this point in pptFirst.
*    CollectPath doesn't check if iptFirst is marked as Inside or Outside.
*    CollectPath returns FALSE on out of memory.
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

BOOL PathSelfIntersectRemover::CollectPath(INT iptFirst)
{
    PointListNode *ptNode = NULL;
    GpPointF *pfpvThis = NULL;
    INT iptord = iptFirst;
    GpPointF fpvFirst(0,0);

    // Copy the first point, it always belongs to the path, we don't check
    // here if it is outside.  AllPointsUsed did that.

    if (ResultPts.Add(PathPts[iptFirst]) != Ok)
    {
        return FALSE;
    }

    // Store the point, so we can compare with it
    fpvFirst = PathPts[iptFirst];

    // Get the index of the next point and update the fUsed field for the
    // copied point.
    ptNode = &PtList[iptord];
    ptNode->Used = TRUE;
    iptord = ptNode->Next;
    BOOL fhavePptord = FALSE;

    // The end of a subpath will have the next iptord == -1
    while(iptord != -1)
    {
        if (!fhavePptord)
        {
            ptNode = &PtList[iptord];
        }
        fhavePptord = FALSE;
        if (ptNode->Inside)
        {
            // The edge starting in this point is inside, but the
            // point itself isn't.
            // If it is the closing point (the same as the first one)
            // return the collected subpath.
            pfpvThis = &PathPts[iptord];
            if (ClosePt(*pfpvThis, fpvFirst))
            {
                ptNode->Used = TRUE;
                return TRUE;
            }

            // If the point is not the same as the first one and we have
            // already been here, something is wrong
            if (ptNode->Used)
            {
                WARNING(("We have an infinite loop"));
                iptord = -1;
                return FALSE;
            }
            else
            {
                //This is the beginning of an inside edge, our path changes.
                //Let's get the duplicate point
                INT oldiptord = iptord;
                ptNode->Used = TRUE;
                iptord = ptNode->Dup;
                if (iptord >= 0)
                {
                    ptNode = &PtList[iptord];
                }
                else
                {
                    WARNING(("Dup is negative (1)"));
                    return FALSE;
                }
                while (ptNode->Inside || ptNode->Used)
                {
                    iptord = ptNode->Dup;
                    if (iptord == oldiptord)
                    {
                        WARNING(("Loop, cannot find a duplicate"));
                        return FALSE; 
                    }
                    else if (iptord >= 0)
                    {
                        ptNode = &PtList[iptord];
                    }
                    else
                    {
                        WARNING(("Dup is negative (2)"));
                        return FALSE;
                    }
                }
                fhavePptord = TRUE;
            }
        }
        else
        {
            // The point is outside
            if (ptNode->Used)
            {
                //This may be a longer list of dups, keep looking
                INT oldiptord2 = iptord;
                ptNode->Used = TRUE;
                iptord = ptNode->Dup;
                if (iptord >= 0)
                {
                    ptNode = &PtList[iptord];
                }
                else
                {
                    WARNING(("Dup is negative (3)"));
                    return FALSE;
                }
                while (ptNode->Inside || ptNode->Used)
                {
                    iptord = ptNode->Dup;
                    if (iptord == oldiptord2)
                    {
                        WARNING(("Loop, cannot find a duplicate (2)"));
                        return FALSE;
                    }
                    else if (iptord >= 0)
                    {
                        ptNode = &PtList[iptord];
                    }
                    else
                    {
                        WARNING(("Dup is negative (4)"));
                        return FALSE;
                    }
                }
                fhavePptord = TRUE;
            }
            else
            {
                //New point, everything is OK
                if (ResultPts.Add(PathPts[iptord]) != Ok)
                {
                    WARNING(("Could not append to array"));
                    return FALSE;
                }
                ptNode->Used = TRUE;
                iptord = ptNode->Next;
            }
        }
    }

    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*
*   Function used to compare lines when we sort them by x coordinate of the
*   Begin point (SortBegin - smaller x).
*
* Arguments:
*
*
* Return Value:
*
*
* Created:
*
*   6/15/1999 t-wehunt
*
\**************************************************************************/

INT CompareLine(
    PathSelfIntersectRemover *ptrCorrector, 
    Edge *ptrEdge1, 
    Edge *ptrEdge2
    )
{
    //PGet on edges
    if (ptrCorrector->PathPts[ptrEdge1->SortBegin].X < 
        ptrCorrector->PathPts[ptrEdge2->SortBegin].X)
        return -1;

    if (ptrCorrector->PathPts[ptrEdge1->SortBegin].X > 
        ptrCorrector->PathPts[ptrEdge2->SortBegin].X)
        return 1;

    if (ptrCorrector->PathPts[ptrEdge1->SortBegin].Y < 
        ptrCorrector->PathPts[ptrEdge2->SortBegin].Y)
        return -1;

    if (ptrCorrector->PathPts[ptrEdge1->SortBegin].Y > 
        ptrCorrector->PathPts[ptrEdge2->SortBegin].Y)
        return 1;

    // Begin points must be exactly the same
    if (ptrCorrector->PathPts[ptrEdge1->SortEnd].X < 
        ptrCorrector->PathPts[ptrEdge2->SortEnd].X)
        return -1;

    if (ptrCorrector->PathPts[ptrEdge1->SortEnd].X > 
        ptrCorrector->PathPts[ptrEdge2->SortEnd].X)
        return 1;

    if (ptrCorrector->PathPts[ptrEdge1->SortEnd].Y < 
        ptrCorrector->PathPts[ptrEdge2->SortEnd].Y)
        return -1;

    if (ptrCorrector->PathPts[ptrEdge1->SortEnd].Y > 
        ptrCorrector->PathPts[ptrEdge2->SortEnd].Y)
        return 1;

    // Now, all point coordinates are exactly the same, but in some cases,
    // we may have two identical edges with the coordinates, these edges 
    // may have different points (actual indecies into points array, not 
    // coordinate values). We want to consider them as identical only if the 
    // indecies are the same.

    if (ptrEdge1->SortBegin < ptrEdge2->SortBegin)
        return -1;

    if (ptrEdge1->SortBegin > ptrEdge2->SortBegin)
        return 1;

    if (ptrEdge1->SortEnd < ptrEdge2->SortEnd)
        return -1;

    if (ptrEdge1->SortEnd > ptrEdge2->SortEnd)
        return 1;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\pathselfintersectremover.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   Path Self Intersection Remover.
*
* Abstract:
*
*   Classes and functions used to remove self intersections in paths.
*   Given a path, it produces one or more polygons which can be used to 
*   draw a widened path that is safe to use alternate fill mode with.
*   
* Notes:
* 
*   Modified from Office code from John Bowler (at least that is what
*   ericvan told me). Apparently owned by some 'KasiaK', but no idea
*   who that is. (He is apparently retired)
*   CAUTION: Not thoroughly tested yet for arbitrary paths.
*
*   API:
*     Init(estimatedNumPts);
*     AddPolygon(pathPts, numPts);
*     RemoveSelfIntersects();
*     GetNewPoints(newPts, polyCounts, numPolys, numTotalPts);
*
* Created:
*
*   06/06/1999 t-wehunt
*
\**************************************************************************/

#ifndef _PATH_INTERSECT_REMOVER_H
#define _PATH_INTERSECT_REMOVER_H



extern REAL FP_INF;

// Forward declarations
class PathSelfIntersectRemover;
class Edge;

// Comparison function for DynSortArray
typedef INT (*DynSortArrayCompareFunc)(
    PathSelfIntersectRemover*, 
    Edge*, 
    Edge*
);



/*****************************************************************************
 Subtract two points
*****************************************************************************/
inline GpPointF SubtractPoint(const GpPointF &pt1, const GpPointF &pt2)
{
   return GpPointF(pt1.X-pt2.X,pt1.Y-pt2.Y);
}

#ifdef USE_OBSOLETE_DYNSORTARRAY

/*****************************************************************************
DynSortArray

Contains a new method that will perform a sorted insertion into the (already
sorted) array.
*****************************************************************************/

//
// NOTE: This class should be avoided by all performance critical code.
// The InsertAt method is O(n) and very easily leads to O(n^3) insert
// sorting algorithms.
//

template <class T>
class DynSortArray : public DynArray<T>
{
public:
    
    // Add a new element to the array at position index.
    // index'th element moves index + 1.
    // CAUTION! could cause a big performance hit if the array is large!
    
    GpStatus InsertAt(INT index, const T& newItem)
    {
        return DynArrayImpl::AddMultipleAt(sizeof(T), index, 1, &newItem);
    }
    
    // Insert multiple items starting at index'th element.
    // index'th element moves index + n, etc...
    // CAUTION! could cause a big performance hit if the array is large!

    GpStatus AddMultipleAt(INT index, const T* newItems, INT n)
    {
        return DynArrayImpl::AddMultipleAt(sizeof(T), index, n, newItems);
    }
    
    // Another variation of AddMultipleAt above.
    //
    // In this case, the data for the new elements are
    // not available. Instead, we'll do the following:
    //  (1) shift the old data over just as AddMultipleAt
    //  (2) reserve the space for additional elements
    //  (3) increase the Count by the number of additional elements
    //  (4) return a pointer to the first new elements
    // CAUTION! could cause a big performance hit if the array is large!

    T *AddMultipleAt(INT index, INT n)
    {
        return static_cast<T *>(DynArrayImpl::AddMultipleAt(sizeof(T), index, n));
    }

    // Deletes n items from the array starting at the index'th position.
    // CAUTION! could cause a big performance hit if the array is large!

    GpStatus DeleteMultipleAt(INT index, INT n)
    {
        return DynArrayImpl::DeleteMultipleAt(sizeof(T), index, n);
    }

    // Deletes one item from the array at the index'th position.
    // CAUTION! could cause a big performance hit if the array is large!
    
    GpStatus DeleteAt(INT index)
    {
        return DynArrayImpl::DeleteMultipleAt(sizeof(T), index, 1);
    }

    GpStatus InsertSorted(
        T &newItem, 
        DynSortArrayCompareFunc compareFunc, 
        VOID *userData
    );
};

#endif

/*****************************************************************************
Edge

Edge represents an edge of a polygon. It stores its end points
as indices to the array of points.

*****************************************************************************/

// represents the terminator of the list.

#define LIST_END -1


class Edge
{
    private:
        PathSelfIntersectRemover *Parent;
        Edge() {}
        
    public:

    BOOL CloseReal(const REAL val1, const REAL val2);

    VOID SetParent(PathSelfIntersectRemover *aParent)
    {
        Parent = aParent;
    }

    Edge(PathSelfIntersectRemover *aParent)
    {
        SetParent(aParent);
    }

    // Next pointer. This is an index into the array for the next element
    // in the Edge list. -1 indicates NULL.
    
    INT Next;
    
    // Begin and End are the indecies to the array of points.  The edge
    // has a direction, which is important when we determine winding numbers.
    // Edge goes from Begin to End.
    
    INT Begin;
    INT End;

    // When we look for intersections of edges, we need to sort them based on
    // the smallest x, therefore we want to store the edge, so that SortBegin
    // refers always to the "smaller" end point of this edge.
    INT SortBegin;
    INT SortEnd;

    // This is the y value at which the edge is currently crossed by a 
    // scan line
    REAL YCur;

    // Original slope of the edge.  We want to keep it around even if the
    // is broken up into small pieces and the end points change.
    // We store the slope as the original begin and end points.
    INT OrigBegin;
    INT OrigEnd;

    // Normalize the edge - ie. update SortBegin and SortEnd.
    VOID Normalize();

    // Return TRUE if the edge is vertical.
    BOOL IsVertical();

    VOID MarkOutside();
};


/*****************************************************************************
EdgeArray

Array of line segments.
*****************************************************************************/
typedef DynSortArray<Edge> EdgeArray;

/*****************************************************************************
PointListNode

Structure used to maintain the order of points and some additional
information about them.  It is used to create a linked list in an array and
then to construct final paths.
Notice the designation List for this structure instead of array.
*****************************************************************************/

struct PointListNode
{
    INT Prev;      // Previous record
    INT Next;      // Next record

    // Duplicate point - For example, if two edges intersect and they are
    // broken up, there are two points needed in order to maintain the
    // correct edge directions for the path.  These two points are identical,
    // so we will call them duplicates.  Each of them stores an index to the
    // other one.  Note that it doesn't mean that allpoints with the same
    // x and y values are duplicates.  This is only 1-1 correspondence for
    // points created from intersections.
    INT Dup;

    // Is this point inside or outside.  Actually, this applies to the edge
    // coming out of this point.
    BOOL Inside;

    // Has this point been consumed during the final creation of resulting
    // paths.  Initially set to FALSE and changed to TRUE when the point is
    // copied to the resulting array.
    BOOL Used;
};

/*****************************************************************************
PathSelfIntersectRemover

Path Self Intersection Remover Class.

It is given input polygons and returns polygons with all self intersections
removed.  The number of returned polygons can be 1, 2 or more.
See comments for the methods for more details on input and output arguments.

API:
  Init(estimatedNumPts);
  AddPolygon(pathPts, numPts);
  RemoveSelfIntersects();
  GetNewPoints(newPts, polyCounts, numPolys, numTotalPts);
*****************************************************************************/

class PathSelfIntersectRemover
{
public:

    PathSelfIntersectRemover() :
        NumPts(0),
        PathPts(),
        PtList(),
        ActiveVertEdges(),
        ResultPts(),
        CanAddPts(TRUE),
        AddToActive1(NULL),
        AddToActive2(NULL),
        AddToActive3(NULL)
    {
        AddToActive1.SetParent(this);
        AddToActive2.SetParent(this);
        AddToActive3.SetParent(this);
        IntersectsWereRemoved = FALSE;
    }

    ~PathSelfIntersectRemover() {}
    
    // Initialize PathSelfIntersectRemover for the given number of points, 
    // numPts. numPts can be an approximate number of points that will be 
    // added to the PathSelfIntersectRemover class for correction. Init 
    // allocates memory for DynArrays.
    
    GpStatus Init(INT numPts);

    // Add one polygon to the class.
    
    GpStatus AddPolygon(const GpPointF *ptrPt, INT numPtsToAdd);

    // Correct the path.
    
    GpStatus RemoveSelfIntersects();

    // Returns the new path.  New path contains of 1 or more subpaths
    // The subpaths are stored as a list of points and a list of points 
    // per polygon.
    
    GpStatus GetNewPoints(DynPointFArray *pts, DynIntArray *polyCounts);

    BOOL PathWasModified() {return IntersectsWereRemoved;}

private:

    // QuickSort a list of edges from First (F) to Last (L) inclusive.
    // This function uses the CompareLine comparison function to determine
    // the ordering.
    
    void QuickSortEdges(Edge *F, Edge *L);

    // This function moves edges from the list pointed to by pInactiveIndex
    // into the list pointed to by pActiveIndex. The sort order for the Active
    // list is determined by the 'compare' function. Edges are selected from the 
    // Inactive list based on xCurrent.
    
    void InsertNewEdges(
        INT *pActiveIndex,     // IN/OUT
        INT *pInactiveIndex,   // IN/OUT
        REAL xCurrent,
        DynSortArrayCompareFunc compare
    );

    // Delete Edge at index from the list pointed to by pListHead. The edge is 
    // orphaned (Next points to LIST_END). This function returns false if 
    // index is not present in the list.
    
    bool DeleteEdgeFromList(INT *pListHead, INT index);
    
    // Insert Edge at index into the list pointed to by pListHead. The sort 
    // order is determined by the 'compare' function. The index'th element 
    // must be an orphan (not a member of any list) - this 
    // function ASSERTs this condition.
    
    void InsertEdgeIntoList(
        INT *pListHead, 
        INT index, 
        DynSortArrayCompareFunc compare
    );
    
    // Remove edges from active edge array.
    
    void ClearActiveListExclusiveX();
    void ClearActiveListInclusiveX();

    GpPointF *GetInactivePoint(INT *pInactiveIndex, bool begin);
    
    // Return true if two numbers are very close.  This depends on the size
    // of the largest number to be compared, which is set in InsertPoints().
    // If no points are inserted, the comparison defaults to using REAL_EPSILON
    
    inline BOOL CloseReal(const REAL val1, const REAL val2)
    {
        return (REALABS(val1-val2) < REAL_EPSILON);
    }

    // Return true if two points are very close
    inline BOOL ClosePt(const GpPointF &pt1, const GpPointF &pt2)
    {
        return (CloseReal(pt1.X, pt2.X) &&
                CloseReal(pt1.Y, pt2.Y));
    }

    
    // Find all intersections between all line segments.  Returns FALSE if
    //  out of memory 
    BOOL FindIntersects();

    // TODO: Since we have a different function for each phase, we don't need
    //       plntFrom any more in both of these methods
    // Add new edges, which are active for the new scan line (x value stored
    //  in xCur.  ptrFrom - array to get the edges.
    //  Returns FALSE on out of memory.
    void AddActiveForX(INT *inactiveHead);

    // Update duplicate points: the two points overlap, connect their lists
    //  of duplicates.
    VOID UpdateDups(INT pt1, INT pt2);

    BOOL IsLinked(INT loop, INT inew);

    // Add new edges, which are active for the new scan line (x value stored
    //  in xCur.  This one is used in the second phase only.
    //  Returns FALSE on out of memory.
    void AddActiveForXScan(INT *inactiveHead);


    // Find all intersections for the current X value.  Intersection points
    //  will be inserted into the Edges array and information about their
    //  order into PtList.
    // Returns FALSE on out of memory.
    BOOL FindIntersectsForX();

    // Calculate new current y values for edges in the active edge array.
    //  For vertical edges, it will pick the maximum y.
    VOID RecalcActiveYCur();

    // Eliminate edges/points which are inside.  In other words, performes 
    //  a line sweep algorithm (similar to scan conversion) and calculates 
    //  winding number on both sides of every edge.  If the winding is 0 
    //  (outside the path) on any sides of the edge, the edge is marked as 
    //  an outside edge.  All other edges are marked as inside.  Edges are 
    //  marked through their begin point in array PtList. 
    // Returns FALSE on out of memory.
    BOOL EliminatePoints(VOID);

    // Finds the x value of the closest end point (in x) - the next scan line.
    //  Depending on the phase of the algorithm, it needs to look at edges in
    //  different arrays.  The new value is stored in xCur.
    //  Returns FALSE if there are no more points to look at - we are done.
    BOOL ClosestActive(INT arrayIndex);

    // Scan through all active edges during the phase of edge elimination.
    //  Calculates winding number to the left and to the right of the current
    //  x value - xCur.  Whenever finds an edge wich has 0 on one side, marks
    //  it as an outside edge.
    BOOL ScanActive();

    // Breaks edge ptrEdge. We have found intersection point intersectPt, which is
    //  guranteed to be somewhere on the line segment (not an end point).
    //  The 'left' part of the edge will either remain in the active edges
    //  or will be removed (only if the intersection point has the current
    //  x value.  In the latter case, the right edge segment will need to be
    //  inserted to active edges, otherwise (the former case) it will go
    //  to Pass1Edges.  If it needs to go to active edges, Breakedge cannot
    //  insert it because it would disrupt the order of edges there before
    //  both edges broken up are handled.  The caller would have to handle
    //  the insertion in such case.  Therefore, we return the new line
    //  segment newEdge and a BOOL value specifying if the caller has to 
    //  insert the newEdge edge.
    // dupIndex is the index of the duplicate point created by this 
    //  intersection:
    //  When two edges intersect, we have to insert two points (identical)
    //  to maintain the same shape of the polygon.  These two points are
    //  called duplicates.
    //  Return FALSE on out of memory.
    BOOL BreakEdge(
        Edge *ptrEdge, 
        GpPointF *intersectPt, 
        Edge *newEdge, 
        INT dupIndex
        );

    BOOL BreakEdgeIn3(
        Edge *ptrEdge, 
        GpPointF *ptrPt1, 
        GpPointF *ptrPt2, 
        Edge *ptrNew1,
        Edge *ptrNew2, 
        INT dupIndex1, 
        INT dupIndex2
        );

    // Insert numEdges edges joining points stored in array Edges.  First 
    // point has index firstIndex.  There must be numEdges+1 points to 
    // create numEdges edges.
    GpStatus InsertEdges(INT firstIndex, INT numEdges);

    // Insert points information to relevant arrays.
    GpStatus InsertPoints(const GpPointF *pts, INT numPts);

    // Returns TRUE if lines ptrEdge1 and ptrEdge2 overlap.
    //  There are 4 ways in which edges can overlap and depending on the
    //  case, either none, one or both edges need to be broken up.  In some
    //  cases one edge may need to broken into 3 pieces.
    //  Return values:
    //    split1     - set to TRUE if ptrEdge1 needs to be split
    //    split2     - set to TRUE if ptrEdge2 needs to be split
    //    split3     - set to TRUE if an edge needs to be broken into 3 pieces
    //    intersect1     - intersection point (where edge needs to be split)
    //    intersect2     - second point (if edge needs to be broken in 3 pieces or
    //                 for the second edge if both edges need to broken up)
    //    dupIndex1  - index of the duplicate point to intersect1,
    //    dupIndex2  - index of the duplicate point to intersect2,
    BOOL Overlap(
        Edge *ptrEdge1, 
        Edge *ptrEdge2, 
        GpPointF *intersect1, 
        GpPointF *intersect2, 
        BOOL *split1,
        BOOL *split2, 
        BOOL *split3, 
        INT *dupIndex1, 
        INT *dupIndex2
        );

    // Method to find the intersection point between edges 
    //    ptrEdge1 and ptrEdge2.
    //    Returns one of the following values:
    //        DONOT_INTERS
    //        COMMON_POINT
    //        INTERSECT
    //        COLINEAR
    //    If the return value == INTERSECT, intersectPt contains the point of 
    //    intersection.
    INT IntersectEdge(Edge *ptrEdge1, Edge *ptrEdge2, GpPointF *intersectPt);

    // IsTIntersection returns TRUE if the intersection point intersectPt is
    //  the same as an end point of one of the edges ptrEdge1 and ptrEdge2.
    // If it is, splitFirst will be TRUE if the first edge needs to be broken
    //  up (intersectPt is an end point of ptrEdge2), FALSE if the second one 
    //  needs to be broken up.  intersectIndex contains the index of the end 
    //  point which is the same as the intersection point. 
    BOOL IsTIntersection(
        Edge *ptrEdge1, 
        Edge *ptrEdge2, 
        GpPointF *intersectPt, 
        BOOL *splitFirst, 
        INT *intersectIndex
        );

    // Returns TRUE if the two lines ptrEdge1 and ptrEdge2 share a common 
    // end point. If they do, commonPt will contain this point.
    BOOL IsCommonPt(Edge *ptrEdge1, Edge *ptrEdge2, GpPointF *commonPt);

    // After the process of eliminating edges and marking points as inside
    //  and outside, we need to go through the linked list of points and
    //  build paths from the edges which are outside.  CollectPath will
    //  collect one path starting from point with index firstIndex.
    //  CollectPath doesn't check if firstIndex is marked as Inside or Outside.
    //  CollectPath returns FALSE on out of memory 
    BOOL CollectPath(INT firstIndex);

    // Return TRUE if all points have been used (added to the resulting paths)
    //  or are inside.  If returns FALSE, returns the index to the next unused
    //  point 
    BOOL AllPointsUsed(INT *nextUnusedPt);

    // Marks vertical edges as oustide.
    VOID MarkVertOutside();

    // Remove all vertical edges from the vertical edge array, which do not
    //  overlap with the give y value 
    VOID RemoveVert(REAL y, BOOL inclusive);

    VOID RemoveVertAll();

    // Returns TRUE if edge ptrEdge doesn't belong to the y interval of edges
    //  stored in ActiveVertEdges.
    BOOL NewInterval(Edge *ptrEdge);

    // Delete edges from the active edge table;  Indecies of edges to delete
    //  are stored in EdgeToDelete1..3.  Deletes the highest index edge first.
    // Returns NULL if fails due to out of memory error.
    BOOL DeleteEdges();

    // Add new edges to the active edge table.  The edges are stored in
    //  AddToActive1..3.  FlgAdd1..3 specify if the given edge needs to
    //  be added or not.  Returns if fails due to out of memory.
    BOOL AddNewEdges();

    // Store the edge in PathSelfIntersectRemover for now, so that it can be later added 
    // to active edges.  Copies the edge, so ptrEdge doesn't need to be kept
    // after this method returns.
    VOID MarkToAdd(Edge *ptrEdge);

    // Store the edge index for later deletion
    VOID MarkToDelete(INT index);

    friend INT CompareYCurLine(
        PathSelfIntersectRemover *ptrCorrector, 
        Edge *ptrEdge1, 
        Edge *ptrEdge2
        );
    friend INT 
        CompareYScanCurLine(
        PathSelfIntersectRemover *ptrCorrector, 
        Edge *ptrEdge1, 
        Edge *ptrEdge2
        );
    friend INT CompareLine(
        PathSelfIntersectRemover *ptrCorrector, 
        Edge *ptrEdge1, 
        Edge *ptrEdge2);
    friend INT CompareVertLine(
        PathSelfIntersectRemover *ptrCorrector, 
        Edge *ptrEdge1, 
        Edge *ptrEdge2
        );
    friend Edge;

    INT NumPts;                     // Total #of points stored for corrections
    REAL XCur;                      // Current x value for the scan line
    DynArray<GpPointF> PathPts;     // array of points
    DynArray<GpPointF> ResultPts;   // array of points for the resulting paths
    DynArray<PointListNode> PtList; // array with order information for points
    
    DynArray<Edge> EdgeList;        // List holding all the edges.
    INT ActiveEdgeList;             // Head index for the Active Edges
    INT InactiveEdgeList;           // Head index for the inactive edges
    
    EdgeArray ActiveVertEdges;      //array with active vertical edges

    Edge AddToActive1; //lines which will need to be added to Active edges
    Edge AddToActive2; //these lines are created when edges are broken up
    Edge AddToActive3; //

    BOOL FlgAdd1;      //flags specifying which of the above three lines
    BOOL FlgAdd2;      //need to be active
    BOOL FlgAdd3;      //

    INT EdgesToDelete1;//indices of edges, which need to be deleted
    INT EdgesToDelete2;//from active, -1 for all three values means
    INT EdgesToDelete3;//that there are no edges to delete

    BOOL CanAddPts;     // Can we still add new points to the class,
                        // We can't after the correction process has started

    BOOL IntersectsWereRemoved;
};

/*****************************************************************************
Comparison functions used for array sorting.
*****************************************************************************/

/*---------------------------------------------------------------------------
Function used to compare lines when we sort them by x coordinate of the
Begin point (SortBegin - smaller x).
-------------------------------------------------------------KasiaK---------*/
INT CompareLine(
    PathSelfIntersectRemover *ptrCorrector, 
    Edge *ptrEdge1, 
    Edge *ptrEdge2
    );

/*---------------------------------------------------------------------------
Function used to compare vertical lines when we scan them.
-------------------------------------------------------------KasiaK---------*/
INT CompareVertLine(
    PathSelfIntersectRemover *ptrCorrector, 
    Edge *ptrEdge1, 
    Edge *ptrEdge2
    );

/*---------------------------------------------------------------------------
Function used to sort edges by current y value when we scan them in order to
find all intersections of line segments.  If y's are the same, sorts based
on slopes.
-------------------------------------------------------------KasiaK---------*/
INT CompareYCurLine(
    PathSelfIntersectRemover *ptrCorrector, 
    Edge *ptrEdge1, 
    Edge *ptrEdge2
    );

/*---------------------------------------------------------------------------
Same as CompareYCurLine, but if y-'s are the same, pots left edges before
right ones before looking at slopes.
-------------------------------------------------------------KasiaK---------*/
INT CompareYScanCurLine(
    PathSelfIntersectRemover *ptrCorrector, 
    Edge *ptrEdge1, 
    Edge *ptrEdge2
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\pathwidener.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999 - 2000  Microsoft Corporation
*
* Module Name:
*
*   PathWidener.cpp
*
* Abstract:
*
*   Implementation of the GpPathWidener class
*
* Revision History:
*
*   11/23/99 ikkof
*       Created it
*
\**************************************************************************/

#include "precomp.hpp"

// 4*(REALSQRT(2.0) - 1)/3
#define U_CIR ((REAL)(0.552284749))



// Define DEBUG_PATHWIDENER if debugging is necessary.

//#define DEBUG_PATHWIDENER

GpStatus ReversePath(INT count,GpPointF* points,BYTE* types);

const BOOL USE_POLYGON_JOIN = FALSE;

INT
CombinePaths(
    INT count,
    GpPointF* points,
    BYTE* types,
    INT count1,
    const GpPointF* points1,
    const BYTE* types1,
    BOOL forward1,
    INT count2,
    const GpPointF* points2,
    const BYTE* types2,
    BOOL forward2,
    BOOL connect
    );

GpStatus
CalculateGradientArray(
    GpPointF* grad,
    REAL* distances,
    const GpPointF* points,
    INT count
    );

GpStatus
GetMajorAndMinorAxis(
    REAL* majorR,
    REAL* minorR,
    const GpMatrix* matrix
    );

enum
{
    WideningClosed = 1,
    WideningFirstType = 2,
    WideningLastType = 4,
    WideningLastPointSame = 8,
    WideningNeedsToAdjustNormals = 16,
    WideningUseBevelJoinInside = 32
};

enum GpTurningDirection
{
    NotTurning = 0,
    TurningBack = 1,
    TurningRight = 2,
    TurningLeft = 3,
    NotMoving = -1
};

GpTurningDirection
getJoin(
    GpLineJoin lineJoin,
    const GpPointF& point,
    const GpPointF& grad1,
    const GpPointF& grad2,
    const GpPointF& norm1,
    const GpPointF& norm2,
    REAL leftWidth,
    REAL rightWidth,
    INT *leftCount,
    GpPointF *leftPoints,
    BOOL *leftInside,
    INT *rightCount,
    GpPointF *rightPoints,
    BOOL *rightInside,
    BOOL needsToAdjustNormals,
    REAL miterLimit2
    );

/**************************************************************************\
*
* Function Description:
*
*   This reverses the path data.
*
* Arguments:
*
*   [IN] count - the number of points.
*   [IN/OUT] points - the data points to be reversed.
*   [IN/OUT] types - the data types to be reversed.
*
* Return Value:
*
*   Status
*
\**************************************************************************/

GpStatus
ReversePath(
    INT count,
    GpPointF* points,
    BYTE* types
    )
{
    DpPathTypeIterator iter(types, count);

    if(!iter.IsValid())
        return InvalidParameter;

    INT startIndex, endIndex;
    BOOL isClosed;
    BOOL isStartDashMode, isEndDashMode;
    BOOL wasMarkerEnd = FALSE;

    INT i;

    while(iter.NextSubpath(&startIndex, &endIndex, &isClosed))
    {
        if((types[startIndex] & PathPointTypeDashMode) != 0)
            isStartDashMode = TRUE;
        else
            isStartDashMode = FALSE;
        if((types[endIndex] & PathPointTypeDashMode) != 0)
            isEndDashMode = TRUE;
        else
            isEndDashMode = FALSE;

        BOOL isMarkerEnd
            = (types[endIndex] & PathPointTypePathMarker) != 0;

        BYTE startType = types[startIndex]; // Save the first type.

        // Shift type points.

        for(i = startIndex + 1; i <= endIndex; i++)
        {
            types[i - 1] = types[i];
        }

        // Clear the close subpapth flag for original type (now at endIndex - 1).

        if(endIndex > 0)
            types[endIndex - 1] &= ~PathPointTypeCloseSubpath;
        
        types[endIndex] = PathPointTypeStart;

        if(isStartDashMode)
            types[startIndex] |= PathPointTypeDashMode;
        else
            types[startIndex] &= ~PathPointTypeDashMode;

        if(isEndDashMode)
            types[endIndex] |= PathPointTypeDashMode;
        else
            types[endIndex] &= ~PathPointTypeDashMode;

        // Add the dash and close flag.

        if(isClosed)
            types[startIndex] |= PathPointTypeCloseSubpath;
        else
            types[startIndex] &= ~PathPointTypeCloseSubpath;

        // Shift the marker flag by 1 from the original position.
        // This means we have to shift by 2 since the types array
        // was shifted by -1.

        for(i = endIndex; i >= startIndex + 2; i--)
        {
            if(types[i - 2] & PathPointTypePathMarker)
                types[i] |= PathPointTypePathMarker;
            else
                types[i] &= ~PathPointTypePathMarker;
        }
        
        // Shift Marker flag from the startIndex.

        if(startType & PathPointTypePathMarker)
            types[startIndex + 1] |= PathPointTypePathMarker;
        else
            types[startIndex + 1] &= ~PathPointTypePathMarker;
        
        // Shift Marker flag from the end of the previous subpath.

        if(wasMarkerEnd)
            types[startIndex] |= PathPointTypePathMarker;
        else
            types[startIndex] &= ~PathPointTypePathMarker;

        wasMarkerEnd = isMarkerEnd;

        // Keep the location of the internal flag.  So we must
        // shift back by 1.

        for(i = endIndex; i >= startIndex + 1; i--)
        {
            if(types[i - 1] & PathPointTypeInternalUse)
                types[i] |= PathPointTypeInternalUse;
            else
                types[i] &= ~PathPointTypeInternalUse;
        }
        if(startType & PathPointTypeInternalUse)
            types[startIndex] |= PathPointTypeInternalUse;
        else
            types[startIndex] &= ~PathPointTypeInternalUse;
    }

    // Reverse the points and types data.

    INT halfCount = count/2;
    for(i = 0; i < halfCount; i++)
    {
        GpPointF tempPt;
        BYTE tempType;

        tempPt = points[count - 1 - i];
        tempType = types[count - 1 - i];
        points[count - 1 - i] = points[i];
        types[count -1 - i] = types[i];
        points[i] = tempPt;
        types[i] = tempType;
    }       
    
#ifdef DEBUG_PATHWIDENER
    DpPathTypeIterator iter2(types, count);

    if(!iter2.IsValid())
    {
        WARNING(("ReversePath: failed."));
        return GenericError;
    }
#endif

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   This combines the two open segments each of which is continuous.
*   The data is returned to points1 and types1.  They must be allocated
*   at least the array size of count1 + count2.
*
* Arguments:
*
*   [IN] count1 - the number of points of the first path.
*   [IN/OUT] points1 - the first path points.
*   [IN/OUT] types1 - the first path types.
*   [IN] forward1 - the direction of the first path. TRUE if forward.
*   [IN] count2 - the number of points of the second path.
*   [IN] points2 - the second path points.
*   [IN] types2 - the second path types.
*   [IN] forward2 - the direction of the second path.  TRUE if forward.
*
* Return Value:
*
*   The total number of points of the combined path.
*
\**************************************************************************/

INT
combineTwoOpenSegments(
    INT count1,
    GpPointF* points1,
    BYTE* types1,
    BOOL forward1,
    INT count2,
    GpPointF* points2,
    BYTE* types2,
    BOOL forward2
    )
{
    GpStatus status = Ok;

    if(
        count1 < 0 || !points1 || !types1 ||
        count2 < 0 || !points2 || !types2
        )
        return 0;
    
    if(!forward1 && count1 > 0)
    {
        status = ::ReversePath(count1, points1, types1);
        if(status != Ok)
            return 0;
    }

    if(!forward2 && count2 > 0)
    {
        status = ::ReversePath(count2, points2, types2);
        if(status != Ok)
            return 0;
    }

    INT offset = 0;

    if(count1 > 0 && count2 > 0)
    {
        if(REALABS(points1[count1 - 1].X - points2[0].X) +
            REALABS(points1[count1 - 1].Y - points2[0].Y)
            < POINTF_EPSILON
            )
            offset = 1;
    }

    if(count2 - offset > 0)
    {
        GpMemcpy(
            points1 + count1,
            points2 + offset,
            (count2 - offset)*sizeof(GpPointF)
            );
        GpMemcpy(
            types1 + count1,
            types2 + offset,
            count2 - offset
            );
    }

    BYTE saveType = types1[0];
    types1[0] = PathPointTypeLine |
        (saveType & ~PathPointTypePathTypeMask);

    // Make sure the first path is not closed.

    if(count1 > 0)
    {
        if(types1[count1 - 1] & PathPointTypeCloseSubpath)
            types1[count1 - 1] &= ~PathPointTypeCloseSubpath;
    }


    // Set the first point type of the second path correctly.

    if(offset == 0)
    {
        saveType = types1[count1];
        types1[count1] = PathPointTypeLine |
            (saveType & ~PathPointTypePathTypeMask);
    }

    // Make sure this path is not closed.

    INT total = count1 + count2 - offset;

    if(total > 0)
    {
        if(types1[total - 1] & PathPointTypeCloseSubpath)
            types1[total - 1] &= ~PathPointTypeCloseSubpath;
    }

    return total;
}


/**************************************************************************\
*
* Function Description:
*
*   This combines the two closed segments each of which is made of closed
*   segments.
*   The data is returned to points1 and types1.  They must be allocated
*   at least the array size of count1 + count2.
*
* Arguments:
*
*   [IN] count1 - the number of points of the first path.
*   [IN/OUT] points1 - the first path points.
*   [IN/OUT] types1 - the first path types.
*   [IN] forward1 - the direction of the first path. TRUE if forward.
*   [IN] count2 - the number of points of the second path.
*   [IN] points2 - the second path points.
*   [IN] types2 - the second path types.
*   [IN] forward2 - the direction of the second path.  TRUE if forward.
*
* Return Value:
*
*   The total number of points of the combined path.
*
\**************************************************************************/

INT
combineClosedSegments(
    INT count1,
    GpPointF* points1,
    BYTE* types1,
    BOOL forward1,
    INT count2,
    GpPointF* points2,
    BYTE* types2,
    BOOL forward2
    )
{
    GpStatus status = Ok;

    if(
        count1 < 0 || !points1 || !types1 ||
        count2 < 0 || !points2 || !types2
        )
        return 0;
    
    if(count1 == 0 && count2 == 0)
        return 0;

    if(!forward1 && count1 > 0)
    {
        status = ::ReversePath(count1, points1, types1);
        if(status != Ok)
            return 0;
    }

    if(!forward2 && count2 > 0)
    {
        status = ::ReversePath(count2, points2, types2);
        if(status != Ok)
            return 0;
    }

    // Make sure the first path is closed.
    
    types1[0] = PathPointTypeStart;
    if(count1 > 0)
    {        
        if((types1[count1 - 1] & PathPointTypeCloseSubpath) == 0)
            types1[count1 - 1] |= PathPointTypeCloseSubpath;
    }

    INT total = count1 + count2;

    if(count2 > 0)
    {
        GpMemcpy(points1 + count1, points2, count2*sizeof(GpPointF));
        GpMemcpy(types1 + count1, types2, count2);
        BYTE saveType = types1[count1];
        types1[count1] = PathPointTypeStart |
            (saveType & ~PathPointTypePathTypeMask);

        // Make sure the second path is closed.
        
        types1[total - 1] |= PathPointTypeCloseSubpath;
    }

    return total;
}

/**************************************************************************\
*
* Function Description:
*
*   This combines the two data points.  This is a general algorithm.
*   The output buffers (points and types) can be the same as the
*   first input buffers (points1 and types1).  In that case, both
*   buffers must be allocated at least to the array size of
*   count1 + count2.
*
* Arguments:
*
*   [IN] count - the allocated number of points (>= count1 + count2).
*   [OUT] points - the combined data points.
*   [OUT] types - the combined data types.
*   [IN] count1 - the number of points of the first path.
*   [IN] points1 - the first path points.
*   [IN] types1 - the first path types.
*   [IN] forward1 - the direction of the first path. TRUE if forward.
*   [IN] count2 - the number of points of the second path.
*   [IN] points2 - the second path points.
*   [IN] types2 - the second path types.
*   [IN] forward2 - the direction of the second path.  TRUE if forward.
*   [IN] connect - TRUE if the second line needs to be connected.
*
* Return Value:
*
*   The total number of points of the combined path.
*
\**************************************************************************/

INT
CombinePaths(
    INT count,
    GpPointF* points,
    BYTE* types,
    INT count1,
    const GpPointF* points1,
    const BYTE* types1,
    BOOL forward1,
    INT count2,
    const GpPointF* points2,
    const BYTE* types2,
    BOOL forward2,
    BOOL connect
    )
{
    if(!points || !types || count < count1 + count2
        || count1 < 0 || !points1 || !types1
        || count2 < 0 || !points2 || !types2)
        return 0;
    
    // Check if the returning buffers are the same as the
    // first input buffers.

    INT resultCount = 0;
    if(points != points1 || types != types1)
    {
        if(points == points1 || types == types1)
        {
            // The both output buffer must be different.
            // If either of them is the same, don't combine
            // the path.

            return 0;
        }

        if(count1 > 0)
        {
            // Copy the first path.

            DpPathIterator iter1(points1, types1, count1);

            if(!iter1.IsValid())
                return 0;

            resultCount = iter1.Enumerate(points, types, count1);

            if(resultCount <= 0)
                return 0;
        }
    }
    else
    {
        // Both output buffers are the same as the first output
        // buffers.

        resultCount = count1;
    }

    GpStatus status = Ok;
    BOOL path1Closed;

    if(!forward1 && resultCount > 0)
    {
        status = ::ReversePath(resultCount, points, types);
        if(status != Ok)
            return 0;
    }

    if(count2 <= 0)
    {
        // No need to add the second path.

        return resultCount;
    }

    // Regard the empty path as a closed path.

    path1Closed = TRUE;

    if(resultCount > 0)
    {
        // Check the last point of path1.

        if((types[resultCount - 1] & PathPointTypeCloseSubpath))
            path1Closed = TRUE;
        else
            path1Closed = FALSE;
    }

    INT totalCount = 0;
    totalCount += resultCount;

    DpPathIterator iter2(points2, types2, count2);

    if(!iter2.IsValid())
        return 0;

    GpPointF* pts2 = points + resultCount;
    BYTE* typs2 = types + resultCount;

    resultCount = iter2.Enumerate(pts2, typs2, count2);

    if(resultCount <= 0)
        return 0;

    if(!forward2)
    {
        status = ::ReversePath(resultCount, pts2, typs2);
        if(status != Ok)
            return 0;
    }

    // Check if the first subpath of path2 is closed or not.

    BOOL path2Closed;

    DpPathTypeIterator iter3(typs2, resultCount);
    if(!iter3.IsValid())
        return 0;

    INT startIndex, endIndex;
    iter3.NextSubpath(&startIndex, &endIndex, &path2Closed);

    BYTE saveType= typs2[0];

    if(path1Closed || path2Closed)
    {
        typs2[0] = PathPointTypeStart |
            (saveType & ~PathPointTypePathTypeMask);
    }
    else
    {
        // Both paths are opened.

        if(connect)
        {
            typs2[0] = PathPointTypeLine |
                (saveType & ~PathPointTypePathTypeMask);

            // Check if the end point of path1 and the start point of path2
            // are the same.  If so, skip this point.

            if(REALABS(pts2[-1].X - pts2[0].X)
                + REALABS(pts2[-1].Y - pts2[0].Y) < POINTF_EPSILON)
            {
                for(INT i = 0; i < resultCount - 1; i++)
                {
                    pts2[i] = pts2[i + 1];
                    typs2[i] = typs2[i + 1];
                }
                resultCount--;
            }
        }
        else
        {
            typs2[0] = PathPointTypeStart |
                (saveType & ~PathPointTypePathTypeMask);
        }
    }

    totalCount += resultCount;

    return totalCount;
}

/**************************************************************************\
*
* Function Description:
*
*   Removes the degenerate points and copy only non-degenerate points.
*   It is assumed that points and types array are allocated so that
*   they can hold at least "count" number of elements.
*
* Arguments:
*
*   [IN] pathType - the type of the path data to be added.
*   [OUT] points - the copied data points.
*   [OUT] types - the copied data types.
*   [IN] dataPoints - the original data points.
*   [IN] count - the number of the original data points.
*   [IN/OUT] lastPt - the last point.
*
* Return Value:
*
*   The total number of copied points.
*
\**************************************************************************/

INT copyNonDegeneratePoints(
    BYTE pathType,
    GpPointF* points,
    BYTE* types,
    const GpPointF* dataPoints,
    const BYTE* dataTypes,
    INT count,
    GpPointF* lastPt
    )
{
    GpPointF nextPt;
    INT addedCount = 0;

    if(pathType == PathPointTypeLine)
    {
        // Add only the different points.

        for(INT i = 0; i < count; i++)
        {
            nextPt = *dataPoints++;

            if( (REALABS(nextPt.X - lastPt->X) > REAL_EPSILON) ||
                (REALABS(nextPt.Y - lastPt->Y) > REAL_EPSILON) )
            {
                *points++ = nextPt;
                *lastPt = nextPt;
                addedCount++;
            }
        }
        if(addedCount > 0)
        {
            GpMemset(types, pathType, addedCount);
        }
    }
    else
    {
        // In case of Bezier, we need to do
        // degenerate case test for future.

        addedCount = count;

        if(addedCount > 0)
        {
            if(dataTypes)
            {
                GpMemcpy(types, dataTypes, addedCount);
            }
            else
            {
                GpMemset(types, pathType, addedCount);
            }

            GpMemcpy(
                points,
                dataPoints,
                addedCount*sizeof(GpPointF)
            );
        }
        else
        {
            addedCount = 0;
        }
    }

    return addedCount;
}


/**************************************************************************\
*
* Function Description:
*
*   This calculates the major and minor radius of an oval
*   when the unit cricle is transformed by the given matrix.
*   For further details, see ikkof's notes on Pen Transform.
*
* Arguments:
*
*   [OUT] majorR - the major radius.
*   [OUT] minorR - the minor radius.
*   [IN] matrix - the matrix to transform the unit circle.
*
* Return Value:
*
*   Status
*
*   01/28/00 ikkof
*       Created it
*
\**************************************************************************/

GpStatus
GetMajorAndMinorAxis(REAL* majorR, REAL* minorR, const GpMatrix* matrix)
{
    if(matrix == NULL)
    {
        // Regard this as an identity matrix.
        *majorR = 1;
        *minorR = 1;
        return Ok;
    }

    REAL m11 = matrix->GetM11();
    REAL m12 = matrix->GetM12();
    REAL m21 = matrix->GetM21();
    REAL m22 = matrix->GetM22();

    REAL d1 = ((m11*m11 + m12*m12) - (m21*m21 + m22*m22))/2;
    REAL d2 = m11*m21 + m12*m22;
    REAL D = d1*d1 + d2*d2;
    if(D > 0)
        D = REALSQRT(D);

    REAL r0 = (m11*m11 + m12*m12 + m21*m21 + m22*m22)/2;

    REAL r1 = REALSQRT(r0 + D);
    REAL r2 = REALSQRT(r0 - D);
    
    // They should be positive numbers.  Prevent the floating
    // point underflow.

    if(r1 <= CPLX_EPSILON)
        r1 = CPLX_EPSILON;
    if(r2 <= CPLX_EPSILON)
        r2 = CPLX_EPSILON;

    *majorR = r1;
    *minorR = r2;

    return Ok;
}

VOID
GpPathWidener::Initialize(
    const GpPointF* points,
    const BYTE* types,
    INT count,
    const DpPen* pen,
    const GpMatrix* matrix,
    REAL dpiX,               // These parameters are not really used
    REAL dpiY,               //
    BOOL isAntiAliased,      // This one is definitely not used.
    BOOL isInsetPen 
    )
{
    SetValid(FALSE);

    Inset1 = 0;
    Inset2 = 0;
    NeedsToTransform = FALSE;
    IsAntiAliased = isAntiAliased;

    // nothing to widen, so return an invalid widener.
    
    if( (!pen) || (count == 0) )
    {
        return;
    }

    Pen = pen;
    GpUnit unit = Pen->Unit;
    InsetPenMode = isInsetPen;

    if(unit == UnitWorld)
        NeedsToTransform = FALSE;
    else
        NeedsToTransform = TRUE;

    GpMatrix penTrans = ((DpPen*) Pen)->Xform;
    BOOL hasPenTransform = FALSE;

    if(!NeedsToTransform && !penTrans.IsTranslate())
    {
        hasPenTransform = TRUE;
        penTrans.RemoveTranslation();
    }

    if(matrix)
        XForm = *matrix;    // Otherwise XForm remains Identity.

    if(hasPenTransform)
    {
        XForm.Prepend(penTrans);
    }


    DpiX = dpiX;
    DpiY = dpiY;
    
    // 0 means use the Desktop DPI
        
    if ((REALABS(DpiX) < REAL_EPSILON) || 
        (REALABS(DpiY) < REAL_EPSILON)    )
    {
        DpiX = Globals::DesktopDpiX;
        DpiY = Globals::DesktopDpiY;
    }


    StrokeWidth = Pen->Width;
    
    if(!NeedsToTransform)
    {
        REAL majorR, minorR;

        ::GetMajorAndMinorAxis(&majorR, &minorR, &XForm);
        MaximumWidth = StrokeWidth*majorR;
        MinimumWidth = StrokeWidth*minorR;
        UnitScale = min (majorR, minorR);
    }
    else
    {
        UnitScale = ::GetDeviceWidth(1.0f, unit, dpiX);
        StrokeWidth = UnitScale * StrokeWidth;
        MinimumWidth = StrokeWidth;
    }

    OriginalStrokeWidth = StrokeWidth;
    
    // Set minimum width to 1.0 (plus a bit for possible precision errors), 
    // so that narrow width pens don't end up leaving gaps in the line.
    REAL minWidth = 1.000001f; 
    
    if(InsetPenMode)
    {
        minWidth *= 2.0f;
        
        // Dashes smaller than a pixel are dropping out entirely in inset 
        // pen because of the rasterizer pixel level clipping that is taking
        // place. We increase the minimum width of dashed lines making them
        // roughly 4.0f. This also helps address the weird moire aliasing 
        // effects with the really small dash-dot round lines.
        
        if(Pen->DashStyle != DashStyleSolid)
        {
            minWidth *= 2.0f;
        }
    }

    if(!NeedsToTransform)
    {
        if(MinimumWidth < minWidth) 
        {
            NeedsToTransform = TRUE;
            StrokeWidth = minWidth;
            MaximumWidth = minWidth;
            MinimumWidth = minWidth;

            // Ignore the pen transform.
            
            XForm.Reset();
            if(matrix)
                XForm = *matrix;
            
            hasPenTransform = FALSE;
            penTrans.Reset();
        }
    }

    InvXForm = XForm;
    if(InvXForm.IsInvertible())
    {
        InvXForm.Invert();

        if(hasPenTransform)
            penTrans.Invert();
    }
    else
    {
        WARNING(("The matrix is degenerate for path widening constructor."));
        return;
    }

    const GpPointF* points1 = points;
    GpPointF pointBuffer[32];
    GpPointF* points2 = pointBuffer;

    if((hasPenTransform && !NeedsToTransform)|| (NeedsToTransform && !XForm.IsIdentity()))
    {
        if(count > 32)
        {
            points2 = (GpPointF*) GpMalloc(count*sizeof(GpPointF));
        }

        if(points2)
        {
            GpMemcpy(points2, points, count*sizeof(GpPointF));

            if(hasPenTransform && !NeedsToTransform)
            {
                // Apply the inverse transform of Pen.
                
                penTrans.Transform(points2, count);
            }
            else
            {
                // Transform to the device coordinates.

                XForm.Transform(points2, count);
            }

            points1 = points2;
        }
        else
        {
            WARNING(("Not enough memory for path widening constructor."));
            return;
        }
    }

    DpPathIterator iter(points1, types, count);

    if(!iter.IsValid())
    {
        if(points2 != pointBuffer)
        {
            GpFree(points2);
        }
        return;
    }

    // Make sure given poins are not degenerate.

    BOOL degenerate = TRUE;
    INT k = 1;

    while(degenerate && k < count)
    {
        if(points1[k-1].X != points1[k].X || points1[k-1].Y != points1[k].Y)
            degenerate = FALSE;
        k++;
    }
    if(degenerate)
    {
        if(points2 != pointBuffer)
        {
            GpFree(points2);
        }
        WARNING(("Input data is degenerate for widening."));
        return;
    }
    
    GpStatus status = Ok;
    INT startIndex, endIndex;
    BOOL isClosed;
    INT dataCount = 0;
    BYTE* ctrTypes = NULL;
    GpPointF* ctrPoints = NULL;
    GpPointF lastPt, nextPt;

    while(iter.NextSubpath(&startIndex, &endIndex, &isClosed) && status == Ok)
    {
        INT typeStartIndex, typeEndIndex;
        BYTE pathType;
        BOOL isFirstPoint = TRUE;

        while(iter.NextPathType(&pathType, &typeStartIndex, &typeEndIndex)
                && status == Ok)
        {
            INT segmentCount;
            const GpPointF* dataPoints = NULL;
            const BYTE* dataTypes = NULL;

            nextPt = points1[typeStartIndex];

            switch(pathType)
            {
            case PathPointTypeStart:
                break;

            case PathPointTypeBezier:
            
                // The path must be flattened before calling widen.
                
                ASSERT(FALSE);
                break;
                
            case PathPointTypeLine:
            default:    // And all other types are treated as line points.

                // Get the data for the Line segment.

                segmentCount = typeEndIndex - typeStartIndex + 1;
                dataPoints = points1 + typeStartIndex;
                dataTypes = NULL;
                break;
            }

            if(status == Ok && pathType != PathPointTypeStart)
            {
                // Allocate memory for CenterTypes and CenterPoints.

                status = CenterTypes.ReserveSpace(segmentCount);
                if(status == Ok)
                    status = CenterPoints.ReserveSpace(segmentCount);

                if(status == Ok)
                {
                    ctrTypes = CenterTypes.GetDataBuffer();
                    ctrPoints = CenterPoints.GetDataBuffer();
                }
                else
                {
                    ctrTypes = NULL;
                    ctrPoints = NULL;
                }

                if(ctrTypes && ctrPoints)
                {
                    BYTE nextType;

                    INT count = CenterTypes.GetCount();
                    ctrTypes += count;
                    ctrPoints += count;

                    dataCount = 0;
                    
                    // Add the first point.

                    if(isFirstPoint)
                    {
                        // We must check the dash mode
                        // for the first point of the subpath.

                        nextType = PathPointTypeStart;
                        if(iter.IsDashMode(typeStartIndex))
                            nextType |= PathPointTypeDashMode;
                        else
                            nextType &= ~PathPointTypeDashMode;

                        *ctrTypes++ = nextType;
                        *ctrPoints++ = nextPt;
                        lastPt = nextPt;
                        isFirstPoint = FALSE;
                        dataCount++;
                    }
                    else
                    {
                        // Don't copy the first
                        // if it is the same as the last point.

                        if(lastPt.X != nextPt.X || lastPt.Y != nextPt.Y)
                        {
                            // We don't have to check dash mode
                            // for the intermediate points.

                            nextType = PathPointTypeLine;

                            *ctrTypes++ = nextType;
                            *ctrPoints++ = nextPt;
                            lastPt = nextPt;
                            dataCount++;
                        }
                    }

                    // Add the remaining points.

                    segmentCount--;
                    dataPoints++;
                    if(dataTypes)
                        dataTypes++;
                    INT addedCount = copyNonDegeneratePoints(
                                        pathType,
                                        ctrPoints,
                                        ctrTypes,
                                        dataPoints,
                                        dataTypes,
                                        segmentCount,
                                        &lastPt);
                    dataCount += addedCount;

                    CenterTypes.AdjustCount(dataCount);
                    CenterPoints.AdjustCount(dataCount);
                }
                else
                    status = OutOfMemory;
            }
            lastPt = points1[typeEndIndex];
        }

        if(status == Ok)
        {
            ctrTypes = CenterTypes.GetDataBuffer();
            dataCount = CenterTypes.GetCount();

            if(isClosed)
                ctrTypes[dataCount - 1] |= PathPointTypeCloseSubpath;
            else
                ctrTypes[dataCount - 1] &= ~PathPointTypeCloseSubpath;

            // We must check the dash mode for the last
            // point of the subpath.

            if(iter.IsDashMode(endIndex))
                ctrTypes[dataCount - 1] |= PathPointTypeDashMode;
            else
                ctrTypes[dataCount - 1] &= ~PathPointTypeDashMode;
        }
    }

    if(points2 != pointBuffer)
    {
        GpFree(points2);
    }

    if(status == Ok)
	{
		ctrPoints = CenterPoints.GetDataBuffer();
        ctrTypes = CenterTypes.GetDataBuffer();
        dataCount = CenterPoints.GetCount();

        Iterator.SetData(ctrPoints, ctrTypes, dataCount);
		SetValid(Iterator.IsValid());

#ifdef DEBUG_PATHWIDENER

		if(!IsValid())
		{
			WARNING(("PathWidener is invalid."));
		}

#endif
	}
}

/**************************************************************************\
*
* Function Description:
*
*   Calculates the unit gradient vectors of points as array of
*   (count + 1).  All the memories must be allocated and be checked
*   by the caller.
*
*   The first element of the gradient is from the end point to the
*   the start point.  If the end point is identical to the start point,
*   the previous point is used.
*   The last element of the gradient is from the start point to the end
*   point.  If the start point is identical to the end point, the next
*   point is used.
*   If distances array is not NULL, this returns the distance of each
*   segments.
*
* Arguments:
*
*   [OUT] grad - The gradient array of (count + 1) elements.
*   [OUT] distances - The distance array of (count + 1) elements or NULL.
*   [IN] points - The given points of count elements.
*   [IN] count - The number of given points.
*
* Return Value:
*
*   Status
*
\**************************************************************************/

GpStatus
CalculateGradientArray(
    GpPointF* grad,
    REAL* distances,
    const GpPointF* points,
    INT count
    )
{
    GpPointF* grad1 = grad;
    REAL* distances1 = distances;
    const GpPointF* points1 = points;

    // Go to the starting point of this subpath.

    GpPointF startPt, endPt, lastPt, nextPt;

    startPt = *points1;

    INT i = count - 1;
    BOOL different = FALSE;
    points1 += i;   // Go to the end point.

    while(i > 0 && !different)
    {
        endPt = *points1--;

        if(endPt.X != startPt.X || endPt.Y != startPt.Y)
            different = TRUE;

        i--;
    }

    if(!different)
    {
        // All points are the same.

        WARNING(("Trying to calculate the gradients for degenerate points."));
        return GenericError;
    }

    points1 = points;
    lastPt = endPt;

    i = 0;

    while(i <= count)
    {
        REAL dx, dy, d;

        if(i < count)
            nextPt = *points1++;
        else
            nextPt = startPt;
        
        dx = nextPt.X - lastPt.X;
        dy = nextPt.Y - lastPt.Y;
        d = dx*dx + dy*dy;

        if(d > 0)
        {
            d = REALSQRT(d);
            dx /= d;
            dy /= d;
        }
        grad1->X = dx;
        grad1->Y = dy;

        // Record the distance only when the given distance array is not NULL.

        if(distances)
            *distances1++ = d;

        grad1++;
        lastPt = nextPt;
        i++;
    }

    // Make sure the last gradient is not 0.

    grad1 = grad + count;
    if(grad1->X == 0 && grad1->Y == 0)
    {
        // The start and end point are the same.  Find
        // the next non-zero gradient.

        i = 1;
        grad1 = grad + i;

        while(i < count)
        {
            if(grad1->X != 0 || grad1->Y != 0)
            {
                grad[count] = *grad1;

                if(distances)
                    distances[count] = distances[i];
                break;
            }
            i++;
            grad1++;
        }
    }

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Calculates the normal gradient of points between startIndex
*   and endIndex.  The last element of the gradient is from endIndex
*   to startIndex.  If the next point is identical to the previous point,
*   the gradient is set to (0, 0).
*
* Arguments:
*
*   [IN] startIndex - the starting index.
*   [IN] endIndex - the ending index.
*
* Return Value:
*
*   Status
*
\**************************************************************************/

GpStatus
GpPathWidener::CalculateGradients(INT startIndex, INT endIndex)
{
    GpPointF* points0 = CenterPoints.GetDataBuffer();
    INT count = endIndex - startIndex + 1;

    if(!points0 || count <= 0)
        return GenericError;

    Gradients.Reset(FALSE);

    GpPointF* grad = Gradients.AddMultiple(count + 1);

    if(!grad)
        return OutOfMemory;

    GpPointF* points = points0 + startIndex;

    return CalculateGradientArray(grad, NULL, points, count);
}


GpStatus
GpPathWidener::CalculateNormals(
    REAL leftWidth,
    REAL rightWidth
    )
{
    NeedsToAdjustNormals = FALSE;

    INT count = Gradients.GetCount();
    GpPointF* grad0 = Gradients.GetDataBuffer();

    if(count <= 0)
    {
        WARNING(("Gradients must be calculated\n"
                 "before the normals are calculated."));
        return GenericError;
    }

    Normals.Reset(FALSE);
    GpPointF* norm0 = Normals.AddMultiple(count);

    if(!norm0)
        return OutOfMemory;


    GpPointF* norm = norm0;
    GpPointF* grad = grad0;

    // Calculate the left normals.

    INT i;

    for(i = 0; i < count; i++)
    {
        norm->X = grad->Y;
        norm->Y = - grad->X;
        norm++;
        grad++;
    }

    if(IsAntiAliased)
        return Ok;

    // Check if the minimum width is less than 1.0.

    REAL width = REALABS(leftWidth - rightWidth);

    if(width*MinimumWidth >= 1.0f)
        return Ok;

    NeedsToAdjustNormals = TRUE;
    
    if(!NeedsToTransform)
    {
        // Transform to the device space.
        // When NeedsToTransform is TRUE, the gradient is already
        // calculated in the device coordinates.

        if(!XForm.IsIdentity())
            XForm.VectorTransform(norm0, count);
    }

    // Set the minimum line width to be just over 1.0
    REAL criteria = 1.00005f;
    REAL value;
    
    if(width > 0)
        value = criteria/width;
    else
        value = criteria*MinimumWidth/1.0f;

    norm = norm0;

    for(i = 0; i < count; i++)
    {
        REAL xx = REALABS(norm->X);
        REAL yy = REALABS(norm->Y);

        if(xx >= yy)
        {
            if(width*xx < criteria)
            {
                if(norm->X >= 0)
                    norm->X = value;
                else
                    norm->X = - value;

                norm->Y = 0;
            }
        }
        else
        {
            if(width*yy < criteria)
            {
                if(norm->Y >= 0)
                    norm->Y = value;
                else
                    norm->Y = - value;

                norm->X = 0;
            }
        }

        norm++;
    }

    if(!NeedsToTransform)
    {
        // Transform back to the world space in case of
        // a non fixed width pen.

        if(!InvXForm.IsIdentity())
            InvXForm.VectorTransform(norm0, count);
    }

    return Ok;
}

GpStatus
GpPathWidener::Widen(GpPath **path)
{
    // Must be a pointer to a path pointer that is NULL.
    
    ASSERT(path != NULL);
    ASSERT(*path == NULL);
    
    GpStatus status = Ok;
    
    // Get the widened path points and types into the 
    // dynarray objects.
    
    DynPointFArray widenedPoints;
    DynByteArray widenedTypes;
    
    status = Widen(
        &widenedPoints,
        &widenedTypes
    );

    if(status != Ok) { return status; }
    
    // Remove the internal flag.

    INT pathCount = widenedTypes.GetCount();
    BYTE* pathTypes = widenedTypes.GetDataBuffer();
    for(INT i = 0; i < pathCount; i++, pathTypes++)
    {
        if(*pathTypes & PathPointTypeInternalUse)
        {
            *pathTypes &= ~PathPointTypeInternalUse;
        }
    }

    // If everything worked, create a new path
    // from the widened points.
    
    if(status == Ok)
    {
        *path = new GpPath(
            widenedPoints.GetDataBuffer(),
            widenedTypes.GetDataBuffer(),
            widenedPoints.GetCount(),
            FillModeWinding
        );
        
        if(*path == NULL) { status = OutOfMemory; }
    }        
    
    return status;
}

GpStatus
GpPathWidener::Widen(
    DynPointFArray* widenedPoints,
    DynByteArray* widenedTypes
    )
{
    FPUStateSaver::AssertMode();
    
    if(!IsValid() || !widenedPoints || !widenedTypes)
    {
        return InvalidParameter;
    }

    const GpPointF* centerPoints = CenterPoints.GetDataBuffer();
    const BYTE* centerTypes = CenterTypes.GetDataBuffer();
    INT centerCount = CenterPoints.GetCount();

    INT startIndex, endIndex;
    BOOL isClosed;
    GpStatus status = Ok;
    
    DynPointFArray customStartCapPoints;
    DynPointFArray customEndCapPoints;
    DynByteArray customStartCapTypes;
    DynByteArray customEndCapTypes;

    // Clear the data in widenedPoints and widenedTypes.

    widenedPoints->Reset(FALSE);
    widenedTypes->Reset(FALSE);

    REAL width = OriginalStrokeWidth;

    INT compoundCount = Pen->CompoundCount;

    REAL* compoundArray = NULL;
    INT cpCount;

    if(compoundCount > 0)
        cpCount = compoundCount;
    else
        cpCount = 2;

    REAL compoundArray0[8];

    if(cpCount <= 8)
        compoundArray = &compoundArray0[0];
    else
        compoundArray = (REAL*) GpMalloc(cpCount*sizeof(REAL));

    INT kk;

    if(compoundArray)
    {
        // Don't attempt to draw a compound line that is empty, or is aliased and has
        // more line components than the width of the line.  It can be rounded out of
        // existance
        if(compoundCount > 0 && 
           (IsAntiAliased || (compoundCount / 2) <= (width * UnitScale)))
        {
            // Don't attempt to draw a compound line that is less than 0.5 device
            // units in width.  These can disappear when rasterized, depending on
            // what Y coordinate they fall on.
            if ((UnitScale * width) >= 0.5f)
            {
                GpMemcpy(compoundArray, Pen->CompoundArray, compoundCount*sizeof(REAL));

                for(kk = 0; kk < compoundCount; kk++)
                {
                    compoundArray[kk] *= width;
                }
            }
            else
            {
                compoundArray[0] = 0;
                compoundArray[1] = 0.5f;
                if (cpCount > 2)
                {
                    cpCount = 2;
                }
            }
            
        }
        else
        {
            compoundArray[0] = 0;
            compoundArray[1] = StrokeWidth;
            if (cpCount > 2)
            {
                cpCount = 2;
            }
        }
    }
    else
    {
        SetValid(FALSE);
        return OutOfMemory;
    }


    REAL left0, right0;
    BOOL isCenteredPen = FALSE;
    BOOL needsToFlip = FALSE;

    if(Pen->PenAlignment == PenAlignmentInset)
    {
        // Check if the coordinates are flipped.
        // If the determinant of the transform matrix is negative,
        // the coordinate system is flipped.

        if(XForm.IsInvertible() && XForm.GetDeterminant() < 0)
            needsToFlip = TRUE;
    }

    // OriginalStrokeWidth is required for the compound lines, but we're
    // widening now and StrokeWidth == max(OriginalStrokeWidth, MinimumWidth)
    // which is the value we need to widen at in order to avoid dropping out
    // lines.
    
    width = StrokeWidth;
    
    switch(Pen->PenAlignment)
    {
    case PenAlignmentInset:
        if(!needsToFlip)
            left0 = 0;                    // Same as right align.
        else
            left0 = width;  // Same as left align.
        break;

    case PenAlignmentCenter:
    default:
        left0 = width/2;
        isCenteredPen = TRUE;
    }

    right0 = left0 - width;

    REAL startInset0 = 0, endInset0 = 0;
    GpCustomLineCap* customStartCap = NULL;
    GpCustomLineCap* customEndCap = NULL;

    while(Iterator.NextSubpath(&startIndex, &endIndex, &isClosed)
		&& status == Ok)
    {
        GpLineCap startCap = Pen->StartCap;
        GpLineCap endCap = Pen->EndCap;
        BYTE startType = centerTypes[startIndex];
        BYTE endType = centerTypes[endIndex];

        GpLineCapMode startCapMode = LineCapDefaultMode;
        GpLineCapMode endCapMode = LineCapDefaultMode;

        if(startType & PathPointTypeDashMode)
        {
            startCap = Pen->DashCap;
            startCapMode = LineCapDashMode;
        }
        else
        {
            // If the start cap is one of the anchor caps, default the widener
            // to using the dashcap for the startCap.
            
            if(((startCap & LineCapAnchorMask) != 0) ||
                 (startCap == LineCapCustom))
            {
                startCap = Pen->DashCap;
            }
        }
        
        if(endType & PathPointTypeDashMode)
        {
            endCap = Pen->DashCap;
            endCapMode = LineCapDashMode;
        }
        else
        {
            // If the end cap is one of the anchor caps, default the widener
            // to using the dashcap for the endCap.
            
            if(((endCap & LineCapAnchorMask) != 0) ||
                 (endCap == LineCapCustom))
            {
                endCap = Pen->DashCap;
            }
        }

        if(InsetPenMode)
        {
            // Inset pen only supports these caps.
            
            if(endCap != LineCapRound && endCap != LineCapFlat)
            {
                endCap = LineCapFlat;
            }
            if(startCap != LineCapRound && startCap != LineCapFlat)
            {
                startCap = LineCapFlat;
            }
        }

        Inset1 = Inset2 = 0.0f;
        if(startCap == LineCapSquare)
        {
            Inset1 = -0.5f*StrokeWidth;
        }
        if(endCap == LineCapSquare)
        {
            Inset2 = -0.5f*StrokeWidth;
        }

        status = CalculateGradients(startIndex, endIndex);

        kk = 0;

        BOOL isCompoundLine = FALSE;
        GpLineCap startCap1 = startCap;
        GpLineCap endCap1 = endCap;
        
        if(cpCount > 2)
        {
            // Don't add the caps for the individual
            // compound line.

            isCompoundLine = TRUE;
            startCap1 = LineCapFlat;
            endCap1 = LineCapFlat;
        }

        while(kk < cpCount && status == Ok)
        {
            REAL leftWidth = left0 - compoundArray[kk];
            REAL rightWidth = left0 - compoundArray[kk + 1];

            if(REALABS(leftWidth-rightWidth)>REAL_EPSILON)
            {
                status = CalculateNormals(leftWidth, rightWidth);
                if(status != Ok) { break; }
                
                // Check if we can use the Bevel join for inside lines.
    
                BOOL useBevelJoinInside = isCenteredPen && !isCompoundLine;
    
                if(USE_POLYGON_JOIN)
                {
                    status = SetPolygonJoin(leftWidth, rightWidth, FALSE);
                }
    
                status = WidenSubpath(
                    widenedPoints,
                    widenedTypes,
                    leftWidth,
                    rightWidth,
                    startIndex,
                    endIndex,
                    isClosed,
                    startCap1,
                    endCap1,
                    useBevelJoinInside
                );
                
                Iterator.RewindSubpath();
            }

            kk += 2;
        }
        // Add the compound line caps if necessary.

        if(status == Ok && isCompoundLine && !isClosed)
        {
            status = AddCompoundCaps(
                widenedPoints,
                widenedTypes,
                left0,
                right0,
                startIndex,
                endIndex,
                startCap,
                endCap
            );
        }

    }

    if(status != Ok) { return status; }

    GpPointF* pts;
    INT count;

    if(!NeedsToTransform)
    {
        GpMatrix penTrans = ((DpPen*) Pen)->Xform;
        BOOL hasPenTransform = FALSE;

        if(!penTrans.IsTranslate())
        {
            hasPenTransform = TRUE;
            penTrans.RemoveTranslation();

            pts = widenedPoints->GetDataBuffer();
            count = widenedPoints->GetCount();
            penTrans.Transform(pts, count);
        }
    }
    else if(!InvXForm.IsIdentity())
    {
        // Case of the Fixed width pen.

        pts = widenedPoints->GetDataBuffer();
        count = widenedPoints->GetCount();
        InvXForm.Transform(pts, count);
    }

#ifdef DEBUG_PATHWIDENER

    if(status == Ok)
    {
        DpPathTypeIterator iter2(widenedTypes->GetDataBuffer(),
            widenedTypes->GetCount());

        if(!iter2.IsValid())
        {
            WARNING(("Widening result is not valid."));
            status = GenericError;
        }
    }
    
#endif

    if(status == Ok)
        SetValid(TRUE);

    if(compoundArray != &compoundArray0[0])
        GpFree(compoundArray);

    return status;
}


GpStatus
GpPathWidener::WidenSubpath(
    DynPointFArray* widenedPoints,
    DynByteArray* widenedTypes,
    REAL leftWidth,
    REAL rightWidth,
    INT startIndex,
    INT endIndex,
    BOOL isClosed,
    GpLineCap startCap,
    GpLineCap endCap,
    BOOL useBevelJoinInside
    )
{
    const GpPointF* centerPoints = CenterPoints.GetDataBuffer();
    const BYTE* centerTypes = CenterTypes.GetDataBuffer();
    INT centerCount = CenterPoints.GetCount();

    GpLineJoin lineJoin = Pen->Join;
    REAL miterLimit2 = Pen->MiterLimit;
    miterLimit2 *= miterLimit2;

    INT typeStartIndex, typeEndIndex;
    BYTE pathType;
    BOOL isFirstType = TRUE;
    BOOL isLastType = FALSE;
    BOOL isLastPointSame;
    GpPointF startPt, endPt;

    startPt = centerPoints[startIndex];
    endPt = centerPoints[endIndex];

    if(startPt.X != endPt.X || startPt.Y != endPt.Y)
        isLastPointSame = FALSE;
    else
        isLastPointSame = TRUE;

    // Reset the left and right buffers.

    LeftTypes.Reset(FALSE);
    LeftPoints.Reset(FALSE);
    RightTypes.Reset(FALSE);
    RightPoints.Reset(FALSE);

    INT subpathCount = endIndex - startIndex + 1;
    INT joinMultiplier = 2;

    if(lineJoin == LineJoinRound)
        joinMultiplier = 7;

    GpStatus status = LeftTypes.ReserveSpace(joinMultiplier*subpathCount);
    if(status == Ok)
        status = LeftPoints.ReserveSpace(joinMultiplier*subpathCount);
    if(status == Ok)
        status = RightTypes.ReserveSpace(joinMultiplier*subpathCount);
    if(status == Ok)
        status = RightPoints.ReserveSpace(joinMultiplier*subpathCount);

    if(status != Ok)
        return status;

    // Get Gradient data buffer.

    GpPointF *grad0, *norm0;
    
    grad0 = Gradients.GetDataBuffer();
    norm0 = Normals.GetDataBuffer();

    // Get Left and Right data buffers.

    GpPointF*   leftPoints0 = LeftPoints.GetDataBuffer();
    BYTE*       leftTypes0 = LeftTypes.GetDataBuffer();
    GpPointF*   rightPoints0 = RightPoints.GetDataBuffer();
    BYTE*       rightTypes0 = RightTypes.GetDataBuffer();

    GpPointF lastPt, nextPt;
    GpPointF leftEndPt, rightEndPt;

    INT leftCount = 0, rightCount = 0;

    INT flag = 0;

    if(isClosed)
        flag |= WideningClosed;
    if(isFirstType)
        flag |= WideningFirstType;
    if(isLastType)
        flag |= WideningLastType;
    if(isLastPointSame)
        flag |= WideningLastPointSame;
    if(NeedsToAdjustNormals)
        flag |= WideningNeedsToAdjustNormals;
    if(useBevelJoinInside)
        flag |= WideningUseBevelJoinInside;

    const GpPointF* dataPoints = centerPoints + startIndex;
    INT dataCount = endIndex - startIndex + 1;

    REAL firstInsets[2], lastInsets[2];

    // Never inset more than the length of the line for the first inset, and
    // never more than the amount left on the line after the first inset
    // has been applied.  This can result in odd endcaps and dashcaps when you 
    // have a line that ends in the middle of a short dash segment.
    
    REAL linelength = REALSQRT(
        distance_squared(
            centerPoints[startIndex],
            centerPoints[endIndex]
         )
     );
    
    firstInsets[0] = min(Inset1, linelength);
    firstInsets[1] = min(Inset1, linelength);
    lastInsets[0] = min(Inset2, linelength-firstInsets[0]);
    lastInsets[1] = min(Inset2, linelength-firstInsets[1]);

    WidenFirstPoint(
        leftWidth,
        rightWidth,
        lineJoin,
        miterLimit2,
        leftPoints0,
        leftTypes0,
        &leftCount,
        rightPoints0,
        rightTypes0,
        &rightCount,
        &leftEndPt,
        &rightEndPt,
        grad0,
        norm0,
        dataPoints,
        dataCount,
        &lastPt,
        &firstInsets[0],
        flag
    );

    // Iterate through all subtypes in the current subpath.

    while(Iterator.NextPathType(&pathType, &typeStartIndex, &typeEndIndex)
            && status == Ok)
    {
        // Offset index from the current subpath.

        INT offsetIndex = typeStartIndex - startIndex;
        GpPointF*   grad = grad0 + offsetIndex;
        GpPointF*   norm = norm0 + offsetIndex;
        
        // Get the starting data buffers of the current subtypes.

        dataPoints = centerPoints + typeStartIndex;
        dataCount = typeEndIndex - typeStartIndex + 1;

        // Get the starting buffers for the left and right data.

        GpPointF*   leftPoints = leftPoints0 + leftCount;
        BYTE*       leftTypes = leftTypes0 + leftCount;
        GpPointF*   rightPoints = rightPoints0 + rightCount;
        BYTE*       rightTypes = rightTypes0 + rightCount;

        INT addedLeftCount = 0, addedRightCount = 0;

        if(pathType != PathPointTypeStart)
        {
            if(typeEndIndex == endIndex)
                isLastType = TRUE;

            flag = 0;

            if(isClosed)
                flag |= WideningClosed;
            if(isFirstType)
                flag |= WideningFirstType;
            if(isLastType)
                flag |= WideningLastType;
            if(isLastPointSame)
                flag |= WideningLastPointSame;
            if(NeedsToAdjustNormals)
                flag |= WideningNeedsToAdjustNormals;
            if(useBevelJoinInside)
                flag |= WideningUseBevelJoinInside;

            status = WidenEachPathType(
                pathType,
                leftWidth,
                rightWidth,
                lineJoin,
                miterLimit2,
                leftPoints,
                leftTypes,
                &addedLeftCount,
                rightPoints,
                rightTypes,
                &addedRightCount,
                grad,
                norm,
                dataPoints,
                dataCount,
                &lastPt,
                &lastInsets[0],
                flag
            );

            leftCount += addedLeftCount;
            rightCount += addedRightCount;
            if(isFirstType && (leftCount > 0 || rightCount > 0))
                isFirstType = FALSE;
        }
        lastPt = centerPoints[typeEndIndex];

    }

    if(status == Ok)
    {
        LeftTypes.SetCount(leftCount);
        LeftPoints.SetCount(leftCount);
        RightTypes.SetCount(rightCount);
        RightPoints.SetCount(rightCount);
    }
    else
        return status;

    GpPointF startPoint, endPoint;
    GpPointF startGrad, endGrad;
    GpPointF startNorm, endNorm;

    startPoint = *(centerPoints + startIndex);
    endPoint = *(centerPoints + endIndex);
    startGrad = grad0[1];
    endGrad = grad0[endIndex - startIndex];
    startNorm = norm0[1];
    endNorm = norm0[endIndex - startIndex];

    status = SetCaps(
        startCap,
        endCap,
        startPoint,
        startGrad,
        startNorm,
        endPoint,
        endGrad,
        endNorm,
        leftWidth,
        rightWidth,
        centerPoints + startIndex,
        endIndex - startIndex + 1
    );

    status = CombineSubpathOutlines(
        widenedPoints,
        widenedTypes,
        isClosed
    );

    return status;
}



GpStatus
GpPathWidener::SetPolygonJoin(
    REAL leftWidth,
    REAL rightWidth,
    BOOL isAntialiased
    )
{
    // This codes is intended to non-pen transform and in WorldUnit for now.

    REAL minimumWidth = MinimumWidth;
    if(leftWidth - rightWidth < StrokeWidth)
        minimumWidth = (leftWidth - rightWidth)/StrokeWidth;

    const INT maxPolyCount = 8;
    INT count = 0;
    GpPointF points[maxPolyCount];
    REAL grads[maxPolyCount];

    JoinPolygonPoints.Reset(FALSE);
    JoinPolygonAngles.Reset(FALSE);
  
    // Define Hobby's polygon.

    if(minimumWidth < 1.06)
    {
        count = 4;
        points[0].X =  0.0f;    points[0].Y = -0.5f;
        points[1].X =  0.5f;    points[1].Y =  0.0f;
        points[2].X =  0.0f;    points[2].Y =  0.5f;
        points[3].X = -0.5f;    points[3].Y =  0.0f;
    }
    else if(minimumWidth < 1.5)
    {
        count = 4;
        points[0].X = -0.5f;    points[0].Y = -0.5f;
        points[1].X =  0.5f;    points[1].Y = -0.5f;
        points[2].X =  0.5f;    points[2].Y =  0.5f;
        points[3].X = -0.5f;    points[3].Y =  0.5f;
    }
    else if(minimumWidth < 1.77)
    {
        count = 4;
        points[0].X =  0.0f;    points[0].Y = -1.0f;
        points[1].X =  1.0f;    points[1].Y =  0.0f;
        points[2].X =  0.0f;    points[2].Y =  1.0f;
        points[3].X = -1.0f;    points[3].Y =  0.0f;
    }
    else if(minimumWidth < 2.02)
    {
        count = 6;
        points[0].X = -0.5f;    points[0].Y = -1.0f;
        points[1].X =  0.5f;    points[1].Y = -1.0f;
        points[2].X =  1.0f;    points[2].Y =  0.0f;
        points[3].X =  0.5f;    points[3].Y =  1.0f;
        points[4].X = -0.5f;    points[4].Y =  1.0f;
        points[5].X = -1.0f;    points[5].Y =  0.0f;
    }
    else if(minimumWidth < 2.48)
    {
        count = 8;
        points[0].X = -0.5f;    points[0].Y = -1.0f;
        points[1].X =  0.5f;    points[1].Y = -1.0f;
        points[2].X =  1.0f;    points[2].Y = -0.5f;
        points[3].X =  1.0f;    points[3].Y =  0.5f;
        points[4].X =  0.5f;    points[4].Y =  1.0f;
        points[5].X = -0.5f;    points[5].Y =  1.0f;
        points[6].X = -1.0f;    points[6].Y =  0.5f;
        points[7].X = -1.0f;    points[7].Y = -0.5f;
    }
    else if(minimumWidth < 2.5)
    {
        count = 4;
        points[0].X = -1.0f;    points[0].Y = -1.0f;
        points[1].X =  1.0f;    points[1].Y = -1.0f;
        points[2].X =  1.0f;    points[2].Y =  1.0f;
        points[3].X = -1.0f;    points[3].Y =  1.0f;
    }
    else if(minimumWidth < 2.91)
    {
        count = 8;
        points[0].X =  0.0f;    points[0].Y = -1.5f;
        points[1].X =  1.0f;    points[1].Y = -1.0f;
        points[2].X =  1.5f;    points[2].Y =  0.0f;
        points[3].X =  1.0f;    points[3].Y =  1.0f;
        points[4].X =  0.0f;    points[4].Y =  1.5f;
        points[5].X = -1.0f;    points[5].Y =  1.0f;
        points[6].X = -1.5f;    points[6].Y =  0.0f;
        points[7].X = -1.0f;    points[7].Y = -1.0f;
    }
    else
        count = 0;

    if(count > 0)
    {
        GpPointF dP;

        for(INT i = 0; i < count - 1; i++)
        {
            dP = points[i + 1] - points[i];
            GetFastAngle(&grads[i], dP);
        }

        dP = points[0] - points[count - 1];
        GetFastAngle(&grads[count - 1], dP);



        REAL lastAngle = grads[0];
        REAL nextAngle;

/*
        // Find out the smallest gradient.

        INT i0 = 0;        
        for(i = 1; i < count; i++)
        {
            nextAngle = grads[i];
            if(nextAngle < lastAngle)
                i0 = i;
            lastAngle = nextAngle;
        }

        // Rearrange so that the polygon starts with the smallest
        // gradient.

        if(i0 > 1)
        {
            GpPointF tempPointsBuff[maxPolyCount];
            REAL tempGradsBuff[maxPolyCount];

            GpMemcpy(&tempPointsBuff[0], &points[0], i0*sizeof(GpPointF));
            GpMemcpy(&tempGradsBuff[0], &grads[0], i0);
            GpMemcpy(&points[0],
                &points[i0], (count - i0)*sizeof(GpPointF));
            GpMemcpy(&grads[0], &grads[i0], count - i0);
            GpMemcpy(&points[count - i0], &tempPointsBuff[0],
                i0*sizeof(GpPointF));
            GpMemcpy(&grads[count - i0], &tempGradsBuff[0], i0);
        }
*/

        BOOL monotonic = TRUE;
        i = 1;
        lastAngle = grads[0];

        while(monotonic && i < count)
        {
            nextAngle = grads[i];
            if(nextAngle < lastAngle)
                monotonic = FALSE;
            i++;
            lastAngle = nextAngle;
        }

        ASSERTMSG(monotonic, ("Polygon for join is not concave."));
    }

    if(count > 0)
    {
        JoinPolygonPoints.AddMultiple(&points[0], count);
        JoinPolygonAngles.AddMultiple(&grads[0], count);
    }

    return Ok;
}

INT getVertexID(const GpPointF& vector, BOOL forLeftEdge, INT count, const REAL* grads)
{
    INT left, right, middle;
    REAL angle = 0.0f;

    GetFastAngle(&angle, vector);

    if(!forLeftEdge)
    {
        angle += 4;
        if(angle >= 8)
            angle -= 8;
    }

    if(angle <= grads[0])
        return 0;

    if(angle >= grads[count - 1])
        return count - 1;

    INT i = 1;

    while(angle >= grads[i] && i < count)
    {
        i++;
    }

    return i - 1;
}
    
GpStatus
GpPathWidener::AddCompoundCaps(
    DynPointFArray* widenedPoints,
    DynByteArray* widenedTypes,
    REAL leftWidth,
    REAL rightWidth,
    INT startIndex,
    INT endIndex,
    GpLineCap startCap,
    GpLineCap endCap
    )
{
    const GpPointF* centerPoints = CenterPoints.GetDataBuffer();
    const BYTE* centerTypes = CenterTypes.GetDataBuffer();
    INT centerCount = CenterPoints.GetCount();
    const GpPointF* grad0 = Gradients.GetDataBuffer();
    const GpPointF* norm0 = Normals.GetDataBuffer();

    GpPointF startPoint, endPoint;
    GpPointF startGrad, endGrad;
    GpPointF startNorm, endNorm;

    startPoint = *(centerPoints + startIndex);
    endPoint = *(centerPoints + endIndex);
    startGrad = grad0[1];
    endGrad = grad0[endIndex - startIndex];
    startNorm = norm0[1];
    endNorm = norm0[endIndex - startIndex];
    
    GpStatus status;
    status = SetCaps(
        startCap, 
        endCap,
        startPoint, 
        startGrad, 
        startNorm,
        endPoint,
        endGrad, 
        endNorm,
        leftWidth, 
        rightWidth,
        centerPoints + startIndex,
        endIndex - startIndex + 1
    );

    status = CombineClosedCaps(
        widenedPoints, 
        widenedTypes,
        &CapPoints1,
        &CapPoints2,
        &CapTypes1,
        &CapTypes2
    );

    return status;
}
    
GpStatus
GpPathWidener::SetCaps(
    GpLineCap startCap,
    GpLineCap endCap,
    const GpPointF& startPoint,
    const GpPointF& startGrad,
    const GpPointF& startNorm,
    const GpPointF& endPoint,
    const GpPointF& endGrad,
    const GpPointF& endNorm,
    REAL leftWidth,
    REAL rightWidth,
    const GpPointF *points,
    INT pointCount
    )
{
    GpStatus status = Ok;

    CapPoints1.Reset(FALSE);
    CapTypes1.Reset(FALSE);
    CapPoints2.Reset(FALSE);
    CapTypes2.Reset(FALSE);

    switch(startCap)
    {
    case LineCapRound:
        if(InsetPenMode)
        {
            status = SetDoubleRoundCap(
                startPoint, 
                startGrad, 
                TRUE, 
                leftWidth, 
                rightWidth
            );
        }
        else
        {
            status = SetRoundCap(
                startPoint, 
                startGrad, 
                TRUE, 
                leftWidth, 
                rightWidth
            );
        }
        break;

    case LineCapTriangle:
        ASSERT(!InsetPenMode);
        status = SetTriangleCap(startPoint, startGrad, TRUE, leftWidth, rightWidth, points, pointCount);
        break;
    
    default:
        // Flat cap.
        
        break;
    }

    switch(endCap)
    {
    case LineCapRound:
        if(InsetPenMode)
        {
            status = SetDoubleRoundCap(
                endPoint, 
                endGrad, 
                FALSE, 
                leftWidth, 
                rightWidth
            );
        }
        else
        {
            status = SetRoundCap(
                endPoint, 
                endGrad, 
                FALSE, 
                leftWidth, 
                rightWidth
            );
        }
        break;

    case LineCapTriangle:
        ASSERT(!InsetPenMode);
        status = SetTriangleCap(endPoint, endGrad, FALSE, leftWidth, rightWidth, points, pointCount);
        break;
    
    default:
        // Flat cap.
        
        break;
    }

    return status;
}

VOID modifyEdges(
    GpPointF* leftPoints,
    BYTE* leftTypes,
    INT* leftCount,
    INT* leftOffset,
    GpPointF* rightPoints,
    BYTE* rightTypes,
    INT* rightCount,
    INT* rightOffset,
    GpPointF* grad,
    INT gradCount
    )
{
    INT leftOffset1 = 0;
    INT rightOffset1 = 0;
    INT leftCount0 = *leftCount;
    INT rightCount0 = *rightCount;
    INT leftCount1 = leftCount0;
    INT rightCount1 = rightCount0;

    if(gradCount > 2)
    {
        GpPointF firstGrad = grad[1];
        GpPointF lastGrad = grad[gradCount - 2];

        GpPointF dP;
        if(leftCount0 > 2)
        {
            dP.X = leftPoints[1].X - leftPoints[0].X;
            dP.Y = leftPoints[1].Y - leftPoints[0].Y;
            if(dP.X*firstGrad.X + dP.Y*firstGrad.Y < 0)
            {
                leftPoints[0] = leftPoints[1];
            }
            dP.X = leftPoints[leftCount0 - 1].X
                - leftPoints[leftCount0 - 2].X;
            dP.Y = leftPoints[leftCount0 - 1].Y
                - leftPoints[leftCount0 - 2].Y;
            if(dP.X*lastGrad.X + dP.Y*lastGrad.Y < 0)
            {
                leftPoints[leftCount0 - 1]
                    = leftPoints[leftCount0 - 2];
            }
        }

        if(rightCount0 > 2)
        {
            dP.X = rightPoints[1].X - rightPoints[0].X;
            dP.Y = rightPoints[1].Y - rightPoints[0].Y;
            if(dP.X*firstGrad.X + dP.Y*firstGrad.Y < 0)
            {
                rightPoints[0] = rightPoints[1];
            }
            dP.X = rightPoints[rightCount0 - 1].X
                - rightPoints[rightCount0 - 2].X;
            dP.Y = rightPoints[rightCount0 - 1].Y
                - rightPoints[rightCount0 - 2].Y;
            if(dP.X*lastGrad.X + dP.Y*lastGrad.Y < 0)
            {
                rightPoints[rightCount0 - 1]
                    = rightPoints[rightCount0 - 2];
            }
        }
    }

    *leftCount = leftCount1;
    *leftOffset = leftOffset1;
    *rightCount = rightCount1;
    *rightOffset = rightOffset1;
}


/**************************************************************************\
*
* Function Description:
*
*   Combines left path, right path, start cap, and end cap.
*
* Arguments:
*
*   [OUT] windedPoints - Output point data.
*   [OUT] widnedTypes - Output type data.
*   [IN] isClosed - TRUE is the current suppat is closed.
*   [IN] closeStartCap - TRUE if the start cap needs to be closed.
*   [IN] closeEndCap - TRUE if the end cap needs to be closed.
*
* Return Value:
*
*   Status
*
\**************************************************************************/

GpStatus
GpPathWidener::CombineSubpathOutlines(
    DynPointFArray* widenedPoints,
    DynByteArray* widenedTypes,
    BOOL isClosed,
    BOOL closeStartCap,
    BOOL closeEndCap
    )
{
    GpStatus status = Ok;

    INT startCapCount = CapPoints1.GetCount();
    GpPointF* startCapPoints = CapPoints1.GetDataBuffer();
    BYTE* startCapTypes = CapTypes1.GetDataBuffer();
    INT endCapCount = CapPoints2.GetCount();
    GpPointF* endCapPoints = CapPoints2.GetDataBuffer();
    BYTE* endCapTypes = CapTypes2.GetDataBuffer();
        
    BYTE* leftTypes;
    GpPointF* leftPoints;
    BYTE* rightTypes;
    GpPointF* rightPoints;
    INT leftCount, rightCount;

    leftCount = LeftPoints.GetCount();
    leftTypes = LeftTypes.GetDataBuffer();
    leftPoints = LeftPoints.GetDataBuffer();
    rightCount = RightPoints.GetCount();
    rightTypes = RightTypes.GetDataBuffer();
    rightPoints = RightPoints.GetDataBuffer();

    if(!isClosed)
    {        
        GpPointF *grad = Gradients.GetDataBuffer();
        INT gradCount = Gradients.GetCount();
        INT leftOffset, rightOffset;

        modifyEdges(leftPoints, leftTypes, &leftCount, &leftOffset,
                rightPoints, rightTypes, &rightCount, &rightOffset,
                grad, gradCount);

        leftPoints += leftOffset;
        leftTypes += leftOffset;
        rightPoints += rightOffset;
        rightTypes += rightOffset;
    }

    status = widenedPoints->ReserveSpace(
                leftCount + rightCount + startCapCount + endCapCount + 2);
    if(status == Ok)
        status = widenedTypes->ReserveSpace(
                leftCount + rightCount + startCapCount + endCapCount + 2);

    GpPointF* wPts = NULL;
    BYTE* wTypes = NULL;

    if(status == Ok)
    {
        wPts = widenedPoints->GetDataBuffer();
        wTypes = widenedTypes->GetDataBuffer();
    }

    if(wPts && wTypes)
    {
        // Set the pointers to the current location.

        INT count0 = widenedPoints->GetCount();
        wPts += count0;
        wTypes += count0;

        INT resultCount;
        BOOL isStartCapClosed = FALSE;
        BOOL isEndCapClosed = FALSE;

        if(isClosed)
        {
            leftTypes[leftCount - 1] |= PathPointTypeCloseSubpath;
            rightTypes[rightCount - 1] |= PathPointTypeCloseSubpath;
        }
        else
        {
            if(startCapCount > 0)
            {
                if(!closeStartCap)
                {
                    if(startCapTypes[startCapCount - 1] & PathPointTypeCloseSubpath)
                        isStartCapClosed = TRUE;
                }
                else
                {
                    // Force the start cap to be closed.

                    startCapTypes[startCapCount - 1] |= PathPointTypeCloseSubpath;
                    isStartCapClosed = TRUE;
                }
            }

            if(endCapCount > 0)
            {
                if(!closeEndCap)
                {
                    if(endCapTypes[endCapCount - 1] & PathPointTypeCloseSubpath)
                        isEndCapClosed = TRUE;
                }
                else
                {
                    // Force the end cap to be closed.

                    endCapTypes[endCapCount - 1] |= PathPointTypeCloseSubpath;
                    isEndCapClosed = TRUE;
                }
            }
        }

        if(isClosed || (startCapCount == 0 && endCapCount == 0))
        {
            BOOL connect = TRUE;
            resultCount =
                ::CombinePaths(leftCount + rightCount, wPts, wTypes,
                leftCount, leftPoints, leftTypes, TRUE,
                rightCount, rightPoints, rightTypes, FALSE,
                connect);
        }
        else
        {
            resultCount = leftCount;

            if(leftCount > 0)
            {
                GpMemcpy(wPts, leftPoints, leftCount*sizeof(GpPointF));
                GpMemcpy(wTypes, leftTypes, leftCount);
            }
            
            if(endCapCount > 0 && !isEndCapClosed)
            {
                resultCount =
                    combineTwoOpenSegments(
                        resultCount, wPts, wTypes, TRUE,
                        endCapCount, endCapPoints, endCapTypes, TRUE);
            }

            if(rightCount > 0)
            {
                resultCount =
                    combineTwoOpenSegments(
                        resultCount, wPts, wTypes, TRUE,
                        rightCount, rightPoints, rightTypes, FALSE);
            }

            if(startCapCount > 0 && !isStartCapClosed)
            {
                resultCount =
                    combineTwoOpenSegments(
                        resultCount, wPts, wTypes, TRUE,
                        startCapCount, startCapPoints, startCapTypes, TRUE);
            }

            wTypes[0] = PathPointTypeStart;
        }

        if(resultCount > 0)
        {
            // If the original subpath is open, the combined path needs to be
            // closed.  If the original path is closed, the left and
            // right paths are already closed.

            if(!isClosed)
            {
                wTypes[resultCount - 1] |= PathPointTypeCloseSubpath;

                // Add the closed caps.

                if(endCapCount > 0 && isEndCapClosed)
                {
                    resultCount =
                        combineClosedSegments(
                            resultCount, wPts, wTypes, TRUE,
                            endCapCount, endCapPoints, endCapTypes, TRUE);
                }

                if(startCapCount > 0 && isStartCapClosed)
                {
                    resultCount =
                        combineClosedSegments(
                            resultCount, wPts, wTypes, TRUE,
                            startCapCount, startCapPoints, startCapTypes, TRUE);
                }
            }

            widenedPoints->AdjustCount(resultCount);
            widenedTypes->AdjustCount(resultCount);
        }
        else
            status = GenericError;
    }
    else
        status = OutOfMemory;

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Combines the closed cap paths.
*
* Arguments:
*
*   [OUT] windedPoints - Output point data.
*   [OUT] widnedTypes - Output type data.
*
* Return Value:
*
*   Status
*
\**************************************************************************/

GpStatus
GpPathWidener::CombineClosedCaps(
    DynPointFArray* widenedPoints,
    DynByteArray* widenedTypes,
    DynPointFArray *daStartCapPoints,
    DynPointFArray *daEndCapPoints,
    DynByteArray *daStartCapTypes,
    DynByteArray *daEndCapTypes
    )
{
    GpStatus status = Ok;

    INT startCapCount = daStartCapPoints->GetCount();
    GpPointF* startCapPoints = daStartCapPoints->GetDataBuffer();
    BYTE* startCapTypes = daStartCapTypes->GetDataBuffer();
    INT endCapCount = daEndCapPoints->GetCount();
    GpPointF* endCapPoints = daEndCapPoints->GetDataBuffer();
    BYTE* endCapTypes = daEndCapTypes->GetDataBuffer();

    if(startCapCount == 0 && endCapCount == 0)
    {
        return status;
    }

    status = widenedPoints->ReserveSpace(startCapCount + endCapCount);
    if(status == Ok)
        status = widenedTypes->ReserveSpace(startCapCount + endCapCount);

    GpPointF* wPts = NULL;
    BYTE* wTypes = NULL;

    if(status == Ok)
    {
        wPts = widenedPoints->GetDataBuffer();
        wTypes = widenedTypes->GetDataBuffer();
    }
    else
        status = OutOfMemory;

    if(status == Ok && wPts && wTypes)
    {
        INT count0 = widenedPoints->GetCount();

        // Make sure the previous path is closed.

        if(count0 > 0)
            wTypes[count0 - 1] |= PathPointTypeCloseSubpath;

        // Set the pointers to the current location.

        wPts += count0;
        wTypes += count0;

        INT resultCount = 0;

        if(startCapCount > 0)
        {
           // Force the start cap to be closed.

            startCapTypes[startCapCount - 1] |= PathPointTypeCloseSubpath;
            resultCount =
                combineClosedSegments(
                    resultCount, wPts, wTypes, TRUE,
                    startCapCount, startCapPoints, startCapTypes, TRUE);
        }

        if(endCapCount > 0)
        {
            // Force the end cap to be closed.

            endCapTypes[endCapCount - 1] |= PathPointTypeCloseSubpath;
            resultCount =
                combineClosedSegments(
                    resultCount, wPts, wTypes, TRUE,
                    endCapCount, endCapPoints, endCapTypes, TRUE);
        }

        widenedPoints->AdjustCount(resultCount);
        widenedTypes->AdjustCount(resultCount);
    }

    return status;
}

GpTurningDirection
getTurningDirection(
    REAL* crossProduct,
    const GpPointF& grad1,
    const GpPointF& grad2
    )
{
    ASSERT(crossProduct);

    GpTurningDirection direction = NotTurning;
    *crossProduct = 0;

    // Handle the degenerate cases.

    GpPointF v;

    if(( (REALABS(grad1.X) < REAL_EPSILON) && 
         (REALABS(grad1.Y) < REAL_EPSILON)     ) || 
       ( (REALABS(grad2.X) < REAL_EPSILON) && 
         (REALABS(grad2.Y) < REAL_EPSILON)     )
      )
    {
        return NotTurning;
    }
    
    // Handle the case of straight or nearly straight lines.
    // The following constant is completely bogus - we need a number here
    // and we're fairly certain it must be small. Probably a better estimate
    // would be some fraction of a device pixel over the length of the line - 
    // if we can figure out how big that is.

    const REAL gradErr = 0.00001f;
    
    if(distance_squared(grad1, grad2) < gradErr)
    {
        direction = NotTurning;

        return direction;
    }

    // Calculate the cross product.

    REAL cross = grad1.X*grad2.Y - grad1.Y*grad2.X;

    // When it comes here, the lines are turning.
    // Get the turning direction.

    if (REALABS(cross) <= REAL_EPSILON)
    {
        direction = TurningBack;
        cross = 0;
    }
    else
    {
        if(cross > 0)
        {
            direction = TurningRight;
        }
        else // if(cross < 0)
        {
            direction = TurningLeft;
        }
    }

    *crossProduct = cross;
    
    return direction;
}

/**************************************************************************\
*
* Function Description:
*
*   Calculates if the miter join will exceed the miter limit.
*
* Arguments:
*
*   [IN] grad1 - the unit tangent vector of the last edge.
*   [IN] grad2 - the unit tangent vector of the current edge.
*   [IN] miterLimit2 - the square of the Miter limit.
*
* Return Value:
*
*   TRUE if the miter limit of this join is exceeded
*
\**************************************************************************/

BOOL
getMiterExceeded(
    const GpPointF& grad1,
    const GpPointF& grad2,
    REAL miterLimit2
    )
{
    REAL cross = grad1.X*grad2.Y - grad1.Y*grad2.X;

    // If cross product is zero, the lines are colinear and can be
    // turning back on themselves.
    if (REALABS(cross) <= REAL_EPSILON)
    {
        return TRUE;
    }

    // Get the normal direction for the miter join.
    GpPointF v(0, 0);
    v.X = grad1.X - grad2.X;
    v.Y = grad1.Y - grad2.Y;

    // Test the miter limit.  
    REAL test = v.X*v.X + v.Y*v.Y - cross*cross*miterLimit2;

    return test > 0;
}

/**************************************************************************\
*
* Function Description:
*
*   Calculates the vector for Miter or Bevel join.  This vector represents
*   the shift to the left along the moving direction.
*   In case of Miter join, when the Miter join exceeds the miter limit,
*   this returns the Bevel join.
*
* Arguments:
*
*   [OUT] vector - the left shift for the Miter join.  This must be
*                   allocated at least for the dimension of 2.
*   [OUT] count - the number of join points.
*   [IN] miterLimit2 - the square of the Miter limit.
*   [IN] grad1 - the unit tangent vector of the last edge.
*   [IN] grad2 - the unit tangent vector of the current edge.
*
* Return Value:
*
*   Turning direction from the last edge to the current edge.
*
\**************************************************************************/

GpTurningDirection
getMiterBevelJoin(
    const GpPointF& point,
    const GpPointF& grad1,
    const GpPointF& grad2,
    const GpPointF& norm1,
    const GpPointF& norm2,
    REAL leftWidth,
    REAL rightWidth,
    INT *leftCount,
    GpPointF *leftPoints,
    BOOL* leftInside,
    INT *rightCount,
    GpPointF *rightPoints,
    BOOL* rightInside,
    BOOL needsToAdjustNormals,
    REAL miterLimit2,
    BOOL isMiter,
    BOOL useBevelJoinInside
    )
{
    *leftInside = FALSE;
    *rightInside = FALSE;

    if(miterLimit2 <= 1)
        isMiter = FALSE;

    GpTurningDirection direction = NotTurning;

    // Handle the degenerate cases.

    GpPointF v(0, 0);
    REAL cross;

    direction = getTurningDirection(&cross, grad1, grad2);

    if(direction == NotMoving)
    {
        *leftCount = 0;
        *rightCount = 0;
        return direction;
    }
    else if(direction == NotTurning)
    {
        if(norm1.X != 0 || norm1.Y != 0)
            v = norm1;
        else
            v = norm2;

        leftPoints[0].X = point.X + leftWidth*v.X;
        leftPoints[0].Y = point.Y + leftWidth*v.Y;
        *leftCount = 1;

        rightPoints[0].X = point.X + rightWidth*v.X;
        rightPoints[0].Y = point.Y + rightWidth*v.Y;
        *rightCount = 1;

        return direction;
    }

    if(cross > 0)
    {
        // Right Turn

        // If the width is positive, this point is outside.
        // For the zero width, we regard this as non-inside point.

        if(leftWidth >= 0)
            *leftInside = FALSE;
        else
            *leftInside = TRUE;

        if(rightWidth >= 0)
            *rightInside = FALSE;
        else
            *rightInside = TRUE;
    }
    else
    {
        // Left Turn

        // If the width is negative, this point is outside.
        // For the zero width, we regard this as non-inside point.

        if(leftWidth <= 0)
            *leftInside = FALSE;
        else
            *leftInside = TRUE;

        if(rightWidth <= 0)
            *rightInside = FALSE;
        else
            *rightInside = TRUE;
    }

    BOOL isLeftMiterJoin = FALSE, isRightMiterJoin = FALSE;
    REAL leftShift1 = 0, rightShift1 = 0;
    REAL leftShift2 = 0, rightShift2 = 0;

    if(isMiter && cross != 0)
    {
        REAL test = 0;

        // Get the normal direction for the miter join.

        v.X = grad1.X - grad2.X;
        v.Y = grad1.Y - grad2.Y;

        // Test the miter limit.  
        
        test = v.X*v.X + v.Y*v.Y - cross*cross*miterLimit2;

        if(test <= 0 )
        {
            // Use the miter join.

            if(needsToAdjustNormals)
            {
                // Use adjusted normals so that aliased thin lines
                // won't disappear.

                REAL c1, c2;        
                
                c1 = norm2.X*grad2.Y - norm2.Y*grad2.X;
                c2 = norm1.X*grad1.Y - norm1.Y*grad1.X;
                v.X = c1*grad1.X - c2*grad2.X;
                v.Y = c1*grad1.Y - c2*grad2.Y;
            }

            v.X /= cross;
            v.Y /= cross;

            GpPointF *outPoints, *inPoints;
            REAL outWidth, inWidth;
            INT *outCount, *inCount;

            if(cross > 0)
            {
                // When a miter join is used, set the inside flag to
                // FALSE since there is no overlap.

                isLeftMiterJoin = TRUE;
                *leftInside = FALSE;

                if(useBevelJoinInside)
                {
                    if(*rightInside)
                        isRightMiterJoin = FALSE;
                    else
                    {
                        // When the right edges are outside,
                        // we cannot use Bevel join since
                        // Bevel join shape will actually appear.

                        isRightMiterJoin = TRUE;
                    }
                }
                else
                {
                    // When a miter join is used, set the inside flag to
                    // FALSE since there is no overlap.

                    isRightMiterJoin = TRUE;
                    *rightInside = FALSE;
                }
            }
            else
            {
                // When a miter join is used, set the inside flag to
                // FALSE since there is no overlap.

                isRightMiterJoin = TRUE;
                *rightInside = FALSE;

                if(useBevelJoinInside)
                {
                    if(*leftInside)
                        isLeftMiterJoin = FALSE;
                    else
                    {
                        // When the right edges are outside,
                        // we cannot use Bevel join since
                        // Bevel join shape will actually appear.

                        isLeftMiterJoin = TRUE;
                    }
                }
                else
                {
                    // When a miter join is used, set the inside flag to
                    // FALSE since there is no overlap.

                    isLeftMiterJoin = TRUE;
                    *leftInside = FALSE;
                }
            }
        }
        else
        {
            // The turn is too sharp and it exceeds the miter limit.
            // We must chop off the miter join tips.

            REAL n1n1 = 1, n2n2 = 1, g1n1 = 0, g2n2 = 0;

            if(needsToAdjustNormals)
            {
                n1n1 = norm1.X*norm1.X + norm1.Y*norm1.Y;
                n2n2 = norm2.X*norm2.X + norm2.Y*norm2.Y;
                g1n1 = grad1.X*norm1.X + grad1.Y*norm1.Y;
                g2n2 = grad2.X*norm2.X + grad2.Y*norm2.Y;
            }

            if(miterLimit2 > max(n1n1, n2n2))
            {
                if(*leftInside == FALSE)
                {
                    REAL lWidth;

                    if(cross > 0)
                        lWidth = leftWidth;     // Right Turn
                    else
                        lWidth = - leftWidth;   // Left Turn

                    leftShift1 = (REALSQRT(miterLimit2 - n1n1 + g1n1*g1n1)
                                - g1n1)*lWidth;
                    leftShift2 = (REALSQRT(miterLimit2 - n2n2 + g2n2*g2n2)
                                + g2n2)*lWidth;
                }

                if(*rightInside == FALSE)
                {
                    REAL rWidth;

                    if(cross > 0)
                        rWidth = rightWidth;    // Right Turn
                    else
                        rWidth = - rightWidth;  // Left Turn

                    rightShift1 = (REALSQRT(miterLimit2 - n1n1 + g1n1*g1n1)
                                - g1n1)*rWidth;
                    rightShift2 = (REALSQRT(miterLimit2 - n2n2 + g2n2*g2n2)
                                + g2n2)*rWidth;
                }
            }
        }
    }
        
    if(isLeftMiterJoin)
    {
        leftPoints[0].X = point.X + leftWidth*v.X;
        leftPoints[0].Y = point.Y + leftWidth*v.Y;
        *leftCount = 1;
    }
    else
    {
        leftPoints[0].X = point.X + leftWidth*norm1.X + leftShift1*grad1.X;
        leftPoints[0].Y = point.Y + leftWidth*norm1.Y + leftShift1*grad1.Y;
        leftPoints[1].X = point.X + leftWidth*norm2.X - leftShift2*grad2.X;
        leftPoints[1].Y = point.Y + leftWidth*norm2.Y - leftShift2*grad2.Y;
        
        // Check if two points are degenerate.

        if(REALABS(leftPoints[1].X - leftPoints[0].X) +
                REALABS(leftPoints[1].Y - leftPoints[0].Y)
                > POINTF_EPSILON)
        {
            *leftCount = 2;
        }
        else
        {
            // Since there is no overlap, set the inside flag to FALSE.

            *leftCount = 1;
            *leftInside = FALSE;
        }

    }

    if(isRightMiterJoin)
    {
        rightPoints[0].X = point.X + rightWidth*v.X;
        rightPoints[0].Y = point.Y + rightWidth*v.Y;
        *rightCount = 1;
    }
    else
    {
        rightPoints[0].X = point.X + rightWidth*norm1.X + rightShift1*grad1.X;
        rightPoints[0].Y = point.Y + rightWidth*norm1.Y + rightShift1*grad1.Y;
        rightPoints[1].X = point.X + rightWidth*norm2.X - rightShift2*grad2.X;
        rightPoints[1].Y = point.Y + rightWidth*norm2.Y - rightShift2*grad2.Y;

        // Check if two points are degenerate.

        if(REALABS(rightPoints[1].X - rightPoints[0].X) +
                REALABS(rightPoints[1].Y - rightPoints[0].Y)
                > POINTF_EPSILON)
        {
            *rightCount = 2;
        }
        else
        {
            // Since there is no overlap, set the inside flag to FALSE.

            *rightCount = 1;
            *rightInside = FALSE;
        }
    }

    return direction;
}

enum GpRoundJoinFlag
{
	NeedsNone = 0,
	NeedsOnlyRoundJoin = 1,
	NeedsOnlyNonRoundJoin = 2,
	NeedsBoth = 3
};

/**************************************************************************\
*
* Function Description:
*
*   From the given point and the two tangent vectors of the two edges,
*   and the radius of the round join, this returns the verteces for
*   left edges and right edges of the round join for the current point.
*   This is used when the bending angle is less than 90 degrees
*   and is called by GetRoundJoin.
*
* Arguments:
*
*   [IN] point -    The current points in the original path.
*   [IN] grad1 -    The tangent of the current edge.
*   [IN] grad2 -       The tangent of the next edge.
*   [IN] dot -      The dot product of grad1 and grad2.
*   [IN] leftWidth -	The left width of the round join.
*	[IN] rightWidth -	The right width of the round join.
*   [OUT] leftCount -   The count of the left points.
*   [OUT] leftPoints -  The left points.
*   [OUT] rightCount -  The count of the right points.
*   [OUT] rightPoints - The right points.
*
* Both leftPoints and rightPoints must have at least dimension of 4.
* If leftCount is positive (negative), this means the left edges are
*   lines with leftCount points (cubic Bezier curves with -leftCount
*   control points).
* If rightCount is positive (negative), this means the right edges are
*   lines with rightCount points (cubic Bezier curves with -rightCount
*   control points).
*
* Return Value:
*
*   None
*
*   06/16/99 ikkof
*       Created it
*
\**************************************************************************/

VOID
getSmallRoundJoin(
    const GpPointF& point,
    const GpPointF& grad1,
    const GpPointF& grad2,
    const GpPointF& norm1,
    const GpPointF& norm2,
    REAL leftWidth,
    REAL rightWidth,
    INT *leftCount,
    GpPointF *leftPoints,
    INT *rightCount,
    GpPointF *rightPoints,
	REAL dot,
    REAL cross,
    BOOL needsToAdjustNormals,
    REAL miterLimit2,
	INT condition,
    BOOL useBevelJoinInside
    )
{
    if((condition & NeedsBoth) == 0)
    {
        *leftCount = 0;
        *rightCount = 0;

        return;
    }

    GpPointF n1, n2;
    n1 = norm1;
    n2 = norm2;

    REAL k;
    REAL almostStraight = 1.0f - 0.01f;

    if(dot < almostStraight)
    {
        // Obtain the distance from the first control point
        // or from the last control point.
        // For its derivation, see ikkof's notes for "Round Joins".

        REAL cross1 = cross;
        if(cross < 0)
            cross1 = - cross;
        k = 4*(REALSQRT(2*(1 - dot)) - cross1)/(3*(1 - dot));

        GpPointF *outPoints, *inPoints;
        INT *outCount, *inCount;

		REAL outWidth, inWidth;

        if(cross >= 0)
        {
            // The left edges are round join.

            outPoints = leftPoints;
            inPoints = rightPoints;
            outCount = leftCount;
            inCount = rightCount;
			outWidth = leftWidth;
			inWidth = rightWidth;
        }
        else
        {
            // The right edges are round join.

            outPoints = rightPoints;
            inPoints = leftPoints;
            outCount = rightCount;
            inCount = leftCount;
			outWidth = - rightWidth;
			inWidth = - leftWidth;
            n1.X = - n1.X;
            n1.Y = - n1.Y;
            n2.X = - n2.X;
            n2.Y = - n2.Y;
        }


        // Get the normal direction for the miter join.

        GpPointF v;
        REAL test;

        v.X = grad1.X - grad2.X;
        v.Y = grad1.Y - grad2.Y;

        // Test the miter limit.

        BOOL useMiterJoin = FALSE;;

        // Reduce the miter limit

        miterLimit2 = 3*3;

        // Note that abs(cross) == abs(cross1) from the definition.

        if(REALABS(cross1) >= REAL_EPSILON)
        {
            REAL test = v.X*v.X + v.Y*v.Y - cross*cross*miterLimit2;
            if(test <= 0)
            {
                useMiterJoin = TRUE;
                v.X /= cross1;
                v.Y /= cross1;
            }
        }

        useMiterJoin = useMiterJoin && !useBevelJoinInside;

        REAL k1;
        if(outWidth > 0)
        {
            if(condition & NeedsOnlyRoundJoin)
            {
                k1 = outWidth*k;
                outPoints[0].X = point.X + outWidth*n1.X;
                outPoints[0].Y = point.Y + outWidth*n1.Y;
                outPoints[1].X = outPoints[0].X + k1*grad1.X;
                outPoints[1].Y = outPoints[0].Y + k1*grad1.Y;
                outPoints[3].X = point.X + outWidth*n2.X;
                outPoints[3].Y = point.Y + outWidth*n2.Y;
                outPoints[2].X = outPoints[3].X - k1*grad2.X;
                outPoints[2].Y = outPoints[3].Y - k1*grad2.Y;
                *outCount = -4;    // Indicate "-" for Bezier
            }
            else
                *outCount = 0;
        }
        else
        {
            if(condition & NeedsOnlyNonRoundJoin)
            {
                if(outWidth == 0)
                {
                    outPoints[0] = point;
                    *outCount = 1;
                }
                else
                {
                    if(useMiterJoin)
                    {
                        outPoints[0].X = point.X + outWidth*v.X;
                        outPoints[0].Y = point.Y + outWidth*v.Y;
                        *outCount = 1;
                    }
                    else
                    {            
                        outPoints[0].X = point.X + outWidth*n1.X;
                        outPoints[0].Y = point.Y + outWidth*n1.Y;
                        outPoints[1].X = point.X + outWidth*n2.X;
                        outPoints[1].Y = point.Y + outWidth*n2.Y;
                        *outCount = 2;
                    }
                }
            }
            else
                *outCount = 0;
        }

        if(inWidth > 0)
        {
            if(condition & NeedsOnlyRoundJoin)
            {
                k1 = inWidth*k;
                inPoints[0].X = point.X + inWidth*n1.X;
                inPoints[0].Y = point.Y + inWidth*n1.Y;
                inPoints[1].X = inPoints[0].X + k1*grad1.X;
                inPoints[1].Y = inPoints[0].Y + k1*grad1.Y;
                inPoints[3].X = point.X + inWidth*n2.X;
                inPoints[3].Y = point.Y + inWidth*n2.Y;
                inPoints[2].X = inPoints[3].X - k1*grad2.X;
                inPoints[2].Y = inPoints[3].Y - k1*grad2.Y;
                *inCount = -4;    // Indicate "-" for Bezier
            }
            else
                *inCount = 0;
        }
        else
        {
            if(condition & NeedsOnlyNonRoundJoin)
            {
                if(inWidth == 0)
                {
                    inPoints[0] = point;
                    *inCount = 1;
                }
                else
                {
                    if(useMiterJoin)
                    {
                        inPoints[0].X = point.X + inWidth*v.X;
                        inPoints[0].Y = point.Y + inWidth*v.Y;
                        *inCount = 1;
                    }
                    else
                    {
                        inPoints[0].X = point.X + inWidth*n1.X;
                        inPoints[0].Y = point.Y + inWidth*n1.Y;
                        inPoints[1].X = point.X + inWidth*n2.X;
                        inPoints[1].Y = point.Y + inWidth*n2.Y;
                        *inCount = 2;
                    }
                }
            }
            else
                *inCount = 0;
        }
    }
    else
    {
        if(condition & NeedsOnlyNonRoundJoin)
        {
            // This is a straight line.

            leftPoints[0].X = point.X + leftWidth*n1.X;
            leftPoints[0].Y = point.Y + leftWidth*n1.Y;
            *leftCount = 1;

            rightPoints[0].X = point.X + rightWidth*n1.X;
            rightPoints[0].Y = point.Y + rightWidth*n1.Y;
            *rightCount = 1;
        }
        else
        {
            *leftCount = 0;
            *rightCount = 0;
        }
    }
}

/**************************************************************************\
*
* Function Description:
*
*   From the given previous, current, and next points and the radius
*   of the round join, this returns the verteces for left edges and
*   right edges of the round join for the current point.
*
* Arguments:
*
*   [IN] points -		The previous, current, and next points
*                       in the original path.
*   [IN] leftWidth -	The left width of the round join.
*	[IN] rightWidth -	The right width of the round join.
*   [OUT] leftCount -   The count of the left points.
*   [OUT] leftPoints -  The left points.
*   [OUT] rightCount -  The count of the right points.
*   [OUT] rightPoints - The right points.
*
* Both leftPoints and rightPoints must have at least dimension of 7.
* If leftCount is positive (negative), this means the left edges are
*   lines with leftCount points (cubic Bezier curves with -leftCount
*   control points).
* If rightCount is positive (negative), this means the right edges are
*   lines with rightCount points (cubic Bezier curves with -rightCount
*   control points).
*
* Return Value:
*
*   FALSE if the current point coindes with the previous point or
*       the next point.  Otherwise, this returns TRUE.
*
*   06/16/99 ikkof
*       Created it
*
\**************************************************************************/

GpTurningDirection
getRoundJoin(
    const GpPointF& point,
    const GpPointF& grad1,
    const GpPointF& grad2,
    const GpPointF& norm1,
    const GpPointF& norm2,
    REAL leftWidth,
    REAL rightWidth,
    INT* leftCount,
    GpPointF* leftPoints,
    BOOL* leftInside,
    INT* rightCount,
    GpPointF* rightPoints,
    BOOL* rightInside,
    BOOL needsToAdjustNormals,
    REAL miterLimit2,
    BOOL useBevelJoinInside
    )
{
    //!!! We need to update inside flags for Round joins later.

    *leftInside = FALSE;
    *rightInside = FALSE;
        
    ASSERT(leftPoints && rightPoints);
    ASSERT(leftCount && rightCount);

	REAL radius = leftWidth;

    // When it comes here, the three points are not degenerate.
    
    REAL dot = grad1.X*grad2.X + grad1.Y*grad2.Y;  // dot product.

    REAL cross;
    GpTurningDirection direction = getTurningDirection(
                        &cross, grad1, grad2);
//                        &cross, grad1, grad2, norm1, norm2);

    // If dot >= 0 (the bending angle is less than or equal to 90 degrees,
    // we can approximate this arc with one cubic Beizer curve.
    
    INT condition;
    REAL smallErr = - 0.001f;
    if(dot > smallErr)
    {
        condition = NeedsBoth;
        getSmallRoundJoin(point, grad1, grad2, norm1, norm2,
                leftWidth, rightWidth,
                leftCount, leftPoints, rightCount, rightPoints,
                dot, cross, needsToAdjustNormals, miterLimit2,
                condition, useBevelJoinInside);
    }
    else
    {
        // The bending angle is larger than 90 and less than or
        // equal to 180 degrees.
        // We can approximate this arc with two cubic Beizer curves.

        GpPointF *pts1, *pts2;
        INT count1, count2;

        pts1 = leftPoints;
        pts2 = rightPoints;

        // First obtain the non-round join parts.

        condition = NeedsOnlyNonRoundJoin;

        getSmallRoundJoin(point, grad1, grad2, norm1, norm2,
            leftWidth, rightWidth,
            &count1, pts1, &count2, pts2,
            dot, cross, needsToAdjustNormals, miterLimit2,
            condition, useBevelJoinInside);

        INT cnt1, cnt2;

        if(count1 > 0)
            cnt1 = count1;
        else
            cnt1 = 0;

        if(count2 > 0)
            cnt2 = count2;
        else
            cnt2 = 0;

        pts1 += cnt1;
        pts2 += cnt2;
        *leftCount = cnt1;
        *rightCount = cnt2;

        // Obtain the middle unit gradient vector.

        GpPointF midNorm;
        midNorm.X = norm1.X + norm2.X;
        midNorm.Y = norm1.Y + norm2.Y;

        if(midNorm.X != 0 || midNorm.Y != 0)
        {
            REAL dm = midNorm.X*midNorm.X + midNorm.Y*midNorm.Y;
            dm = REALSQRT(dm);
            midNorm.X /= dm;
            midNorm.Y /= dm;
        }
        else
        {
            midNorm.X = - norm1.Y;
            midNorm.Y = norm1.X;
        }

        GpPointF lm;

        // Rotate the mid normal +90 degrees.

        lm.X = - midNorm.Y;
        lm.Y = midNorm.X;

        // Obtain the first half of the round join.

        condition = NeedsOnlyRoundJoin;

        dot = grad1.X*lm.X + grad1.Y*lm.Y;
        cross = grad1.X*lm.Y - grad1.Y*lm.X;
        getSmallRoundJoin(point, grad1, lm, norm1, midNorm,
            leftWidth, rightWidth,
            &count1, pts1, &count2, pts2,
            dot, cross, needsToAdjustNormals, miterLimit2,
            condition, useBevelJoinInside);

        // Note that since the end point of the first half of
        // the round join and the start point of the second
        // of the round join are the same, don't copy
        // the end point of the first half of the round join.

        if(count1 < 0)
            cnt1 = - count1 - 1;
        else
            cnt1 = 0;

        if(count2 < 0)
            cnt2 = - count2 - 1;
        else
            cnt2 = 0;

        pts1 += cnt1;
        pts2 += cnt2;
        *leftCount += cnt1;
        *rightCount += cnt2;

        // Obtain the second half of the round join.

        dot = lm.X*grad2.X + lm.Y*grad2.Y;
        cross = lm.X*grad2.Y - lm.Y*grad2.X;
        getSmallRoundJoin(point, lm, grad2, midNorm, norm2,
            leftWidth, rightWidth,
            &count1, pts1, &count2, pts2,
            dot, cross, needsToAdjustNormals, miterLimit2,
            condition, useBevelJoinInside);

        // Combines the two curves or lines.
        
        if(count1 < 0)
            cnt1 += - count1;
        else
            cnt1 = 0;

        if(count2 < 0)
            cnt2 += - count2;
        else
            cnt2 = 0;

        if(cnt1 > 0)
            *leftCount = - cnt1;
        if(cnt2 > 0)
            *rightCount = - cnt2;
    }

    return direction;
}

/**************************************************************************\
*
* Function Description:
*
*   Calculates the vector for Miter or Bevel join.  This vector represents
*   the shift to the left along the moving direction.
*   In case of Miter join, when the Miter join exceeds the miter limit,
*   this returns the Bevel join.
*
* Arguments:
*
*   [OUT] vector - the left shift for the Miter join.  This must be
*                   allocated at least for the dimension of 2.
*   [OUT] count - the number of join points.
*   [IN] miterLimit2 - the square of the Miter limit.
*   [IN] grad1 - the unit tangent vector of the last edge.
*   [IN] grad2 - the unit tangent vector of the current edge.
*
* Return Value:
*
*   Turning direction from the last edge to the current edge.
*
\**************************************************************************/

GpTurningDirection
getHobbyJoin(
    const GpPointF& point,
    const GpPointF& grad1,
    const GpPointF& grad2,
    INT polyCount,
    const GpPointF* polyPoints,
    const REAL* polyAngles,
//    const GpPointF& norm1,
//    const GpPointF& norm2,
    REAL leftWidth,
    REAL rightWidth,
    INT *leftCount,
    GpPointF *leftPoints,
    INT *rightCount,
    GpPointF *rightPoints,
    BOOL needsToAdjustNormals,
    REAL miterLimit2,
    BOOL isMiter,
    BOOL useBevelJoinInside
    )
{
    if(miterLimit2 <= 1)
        isMiter = FALSE;

    GpTurningDirection direction = NotTurning;

    // Handle the degenerate cases.

    GpPointF v;
    REAL cross;

    direction = getTurningDirection(&cross, grad1, grad2);

    if(direction == NotMoving)
    {
        *leftCount = 0;
        *rightCount = 0;
        return direction;
    }

    // Find the left vertex ids.

    INT leftIndex1, leftIndex2;
    leftIndex1 = getVertexID(grad1, TRUE, polyCount, polyAngles);
    leftIndex2 = getVertexID(grad2, TRUE, polyCount, polyAngles);

    INT i;

    if(direction == TurningLeft)
    {
        *leftCount = 2;
        leftPoints[0] = point + polyPoints[leftIndex1];
        leftPoints[1] = point + polyPoints[leftIndex2];
    }
    else if(direction == TurningRight)
    {
        if(leftIndex2 > leftIndex1)
        {
            *leftCount = leftIndex2 - leftIndex1 + 1;

            for(i = 0; i <= leftIndex2 - leftIndex1; i++)
                leftPoints[i] = point + polyPoints[i + leftIndex1];
        }
        else if(leftIndex2 < leftIndex1)
        {
            *leftCount = polyCount - leftIndex1 + leftIndex2 + 1;

            for(i = 0; i < polyCount - leftIndex1; i++)
                leftPoints[i] = point + polyPoints[i + leftIndex1];

            for(i = 0; i <= leftIndex2; i++)
                leftPoints[polyCount - leftIndex1 + i]
                    = point + polyPoints[i];
        }
        else
        {
            *leftCount = 1;
            leftPoints[0] = point + polyPoints[leftIndex1];
        }
    }
    else
    {
        *leftCount = 1;
        leftPoints[0] = point + polyPoints[leftIndex1];
    }

    INT rightIndex1, rightIndex2;
    rightIndex1 = getVertexID(grad1, FALSE, polyCount, polyAngles);
    rightIndex2 = getVertexID(grad2, FALSE, polyCount, polyAngles);

    if(direction == TurningRight)
    {
        *rightCount = 2;
        rightPoints[0] = point + polyPoints[rightIndex1];
        rightPoints[1] = point + polyPoints[rightIndex2];
    }
    else if(direction == TurningLeft)
    {
        if(rightIndex1 > rightIndex2)
        {
            *rightCount = rightIndex1 - rightIndex2 + 1;

            for(i = 0; i <= rightIndex1 - rightIndex2; i++)
                rightPoints[i] = point + polyPoints[rightIndex1 - i];
        }
        else if(rightIndex1 < rightIndex2)
        {
            *rightCount = polyCount - rightIndex2 + rightIndex1 + 1;

            for(i = 0; i <= rightIndex1; i++)
                rightPoints[i] = point + polyPoints[rightIndex1 - i];

            for(i = 0; i < polyCount - rightIndex2; i++)
                rightPoints[rightIndex1 + 1 + i]
                    = point + polyPoints[polyCount - i - 1];
        }
        else
        {
            *rightCount = 1;
            rightPoints[0] = point + polyPoints[rightIndex1];
        }
    }
    else
    {
        *rightCount = 1;
        rightPoints[0] = point + polyPoints[rightIndex1];
    }

    return direction;
}

GpTurningDirection
getJoin(
    GpLineJoin lineJoin,
    const GpPointF& point,
    const GpPointF& grad1,
    const GpPointF& grad2,
    const GpPointF& norm1,
    const GpPointF& norm2,
    REAL leftWidth,
    REAL rightWidth,
    INT *leftCount,
    GpPointF *leftPoints,
    BOOL *leftInside,
    INT *rightCount,
    GpPointF *rightPoints,
    BOOL *rightInside,
    BOOL needsToAdjustNormals,
    REAL miterLimit2,
    BOOL useBevelJoinInside
    )
{
    BOOL isMiter = TRUE;

    GpTurningDirection direction;

    switch(lineJoin)
    {
    case LineJoinBevel:
        isMiter = FALSE;            // Fall through to Miter case.
        
    case LineJoinMiterClipped:
        // Treat Miter clipped joints that exceed the miter limit as
        // beveled joints.  Fall through to Miter case.
        if (lineJoin == LineJoinMiterClipped &&
            getMiterExceeded(grad1, grad2, miterLimit2))
        {
            isMiter = FALSE;
        }
        
    case LineJoinMiter:
        direction = getMiterBevelJoin(point, grad1, grad2, norm1, norm2,
                        leftWidth, rightWidth,
                        leftCount, leftPoints, leftInside,
                        rightCount, rightPoints, rightInside,
                        needsToAdjustNormals, miterLimit2, isMiter, useBevelJoinInside);
        break;

    case LineJoinRound:
        direction = getRoundJoin(point, grad1, grad2, norm1, norm2,
                        leftWidth, rightWidth,
                        leftCount, leftPoints, leftInside,
                        rightCount, rightPoints, rightInside,
                        needsToAdjustNormals, miterLimit2, useBevelJoinInside);
        break;
    }

    return direction;
}


/**************************************************************************\
*
* Function Description:
*
*   From the given the reference point, gradient, and widths,
*   this returns the verteces for the round cap.
*   The direction of the round cap is always clockwise.
*
* Arguments:
*
*   [IN] point -   The reference point.
*   [IN] grad -   The gradient.
*   [IN] isStartCap - TRUE if this is the start cap.
*   [IN] leftWidth -   The left width from the reference.
*   [IN] rightWidth -   The right width from the reference point.
*
*
* Return Value:
*
*   Ok if successfull.
*
*   06/16/99 ikkof
*       Created it
*
\**************************************************************************/

GpStatus
GpPathWidener::SetRoundCap(
    const GpPointF& point,
    const GpPointF& grad,
    BOOL isStartCap,
    REAL leftWidth,
    REAL rightWidth
    )
{
    if( (REALABS(grad.X) < REAL_EPSILON) && 
        (REALABS(grad.Y) < REAL_EPSILON) )
    {
        return InvalidParameter;
    }
    
    GpPointF* capPoints = NULL;
    BYTE* capTypes = NULL;

    if(isStartCap)
    {
        CapPoints1.Reset(FALSE);
        CapTypes1.Reset(FALSE);
        capPoints = CapPoints1.AddMultiple(7);
        if(capPoints)
            capTypes = CapTypes1.AddMultiple(7);

        if(!capPoints || !capTypes)
            return OutOfMemory;
    }
    else
    {
        CapPoints2.Reset(FALSE);
        CapTypes2.Reset(FALSE);
        capPoints = CapPoints2.AddMultiple(7);
        if(capPoints)
            capTypes = CapTypes2.AddMultiple(7);

        if(!capPoints || !capTypes)
            return OutOfMemory;
    }

    GpMemset(capTypes, PathPointTypeBezier, 7);
    capTypes[0] = PathPointTypeLine;

    GpPointF tangent;

    if(isStartCap)
    {
        tangent.X = - grad.X;
        tangent.Y = - grad.Y;
    }
    else
        tangent = grad;

    REAL radius = (leftWidth - rightWidth)/2;
    GpPointF center;

    center.X = point.X + (leftWidth + rightWidth)*grad.Y/2;
    center.Y = point.Y - (leftWidth + rightWidth)*grad.X/2;

    if(isStartCap)
    {
        center.X -= Inset1*tangent.X;
        center.Y -= Inset1*tangent.Y;
    }
    else
    {
        center.X -= Inset2*tangent.X;
        center.Y -= Inset2*tangent.Y;
    }

    REAL s1, c1;

    // Direction of the left normal multipled by radius.

    c1 = radius*tangent.Y;
    s1 = - radius*tangent.X;

    // 2 Bezier segments for a half circle with radius 1.

    REAL u_cir = U_CIR;
    capPoints[ 0].X = 1;       capPoints[ 0].Y = 0;
    capPoints[ 1].X = 1;       capPoints[ 1].Y = u_cir;
    capPoints[ 2].X = u_cir;   capPoints[ 2].Y = 1;
    capPoints[ 3].X = 0;       capPoints[ 3].Y = 1;
    capPoints[ 4].X = -u_cir;  capPoints[ 4].Y = 1;
    capPoints[ 5].X = -1;      capPoints[ 5].Y = u_cir;
    capPoints[ 6].X = -1;      capPoints[ 6].Y = 0;

    // Rotate, scale, and translate the original half circle.

    for(INT i = 0; i < 7; i++)
    {
        REAL x, y;

        x = capPoints[i].X;
        y = capPoints[i].Y;
        capPoints[i].X = (c1*x - s1*y) + center.X;
        capPoints[i].Y = (s1*x + c1*y) + center.Y;
    }

    return Ok;
}


/**************************************************************************\
*
* Function Description:
*
*    Creates a double round cap for inset pen ('B' shaped)
*
* Arguments:
*
*   [IN] point -   The reference point.
*   [IN] grad -   The gradient.
*   [IN] isStartCap - TRUE if this is the start cap.
*   [IN] leftWidth -   The left width from the reference.
*   [IN] rightWidth -   The right width from the reference point.
*
*
* Return Value:
*
*   Ok if successfull.
*
*   10/01/2000 asecchia
*       Created it
*
\**************************************************************************/

GpStatus
GpPathWidener::SetDoubleRoundCap(
    const GpPointF& point,
    const GpPointF& grad,
    BOOL isStartCap,
    REAL leftWidth,
    REAL rightWidth
    )
{
    if( (REALABS(grad.X) < REAL_EPSILON) && 
        (REALABS(grad.Y) < REAL_EPSILON) )
    {
        return InvalidParameter;
    }
    
    GpPointF* capPoints = NULL;
    BYTE* capTypes = NULL;

    if(isStartCap)
    {
        CapPoints1.Reset(FALSE);
        CapTypes1.Reset(FALSE);
        capPoints = CapPoints1.AddMultiple(14);
        if(capPoints)
            capTypes = CapTypes1.AddMultiple(14);

        if(!capPoints || !capTypes)
            return OutOfMemory;
    }
    else
    {
        CapPoints2.Reset(FALSE);
        CapTypes2.Reset(FALSE);
        capPoints = CapPoints2.AddMultiple(14);
        if(capPoints)
            capTypes = CapTypes2.AddMultiple(14);

        if(!capPoints || !capTypes)
            return OutOfMemory;
    }

    GpMemset(capTypes, PathPointTypeBezier, 14);
    capTypes[0] = PathPointTypeLine;
    capTypes[7] = PathPointTypeLine;

    GpPointF tangent;

    if(isStartCap)
    {
        tangent.X = - grad.X;
        tangent.Y = - grad.Y;
    }
    else
        tangent = grad;

    REAL radius = (leftWidth - rightWidth)/2;
    GpPointF center;

    center.X = point.X + (leftWidth + rightWidth)*grad.Y/2;
    center.Y = point.Y - (leftWidth + rightWidth)*grad.X/2;

    if(isStartCap)
    {
        center.X -= Inset1*tangent.X;
        center.Y -= Inset1*tangent.Y;
    }
    else
    {
        center.X -= Inset2*tangent.X;
        center.Y -= Inset2*tangent.Y;
    }

    REAL s1, c1;

    // Direction of the left normal multipled by radius.

    c1 = radius*tangent.Y;
    s1 = - radius*tangent.X;

    // 2 Bezier segments for a half circle with radius 1.

    REAL u_cir = U_CIR;
    capPoints[ 0].X = 1;       capPoints[ 0].Y = 0;
    capPoints[ 1].X = 1;       capPoints[ 1].Y = u_cir;
    capPoints[ 2].X = u_cir;   capPoints[ 2].Y = 1;
    capPoints[ 3].X = 0;       capPoints[ 3].Y = 1;
    capPoints[ 4].X = -u_cir;  capPoints[ 4].Y = 1;
    capPoints[ 5].X = -1;      capPoints[ 5].Y = u_cir;
    capPoints[ 6].X = -1;      capPoints[ 6].Y = 0;
    
    // Create the second bump and scale the first one.
    
    for(int i=0; i<7; i++)
    {
        capPoints[i+7].X = capPoints[i].X * 0.5f-0.5f;
        capPoints[i+7].Y = capPoints[i].Y * 0.5f;
        capPoints[i].X = 0.5f + capPoints[i].X * 0.5f;
        capPoints[i].Y = capPoints[i].Y * 0.5f;
    }

    // Rotate, scale, and translate the original half circle.

    for(INT i = 0; i < 14; i++)
    {
        REAL x, y;

        x = capPoints[i].X;
        y = capPoints[i].Y;
        capPoints[i].X = (c1*x - s1*y) + center.X;
        capPoints[i].Y = (s1*x + c1*y) + center.Y;
    }

    return Ok;
}

GpStatus
GpPathWidener::SetTriangleCap(
    const GpPointF& point,
    const GpPointF& grad,
    BOOL isStartCap,
    REAL leftWidth,
    REAL rightWidth,
    const GpPointF *points,
    INT pointCount
    )
{
    if( (REALABS(grad.X) < REAL_EPSILON) && 
        (REALABS(grad.Y) < REAL_EPSILON) )
    {
        return InvalidParameter;
    }

    GpPointF* capPoints = NULL;
    BYTE* capTypes = NULL;
    
    DynByteArray *capTypesArray;
    DynPointFArray *capPointsArray;   
    

    if(isStartCap)
    {
        CapPoints1.Reset(FALSE);
        CapTypes1.Reset(FALSE);
        capPoints = CapPoints1.AddMultiple(3);
        if(capPoints)
            capTypes = CapTypes1.AddMultiple(3);

        if(!capPoints || !capTypes)
            return OutOfMemory;
    }
    else
    {
        CapPoints2.Reset(FALSE);
        CapTypes2.Reset(FALSE);
        capPoints = CapPoints2.AddMultiple(3);
        if(capPoints)
            capTypes = CapTypes2.AddMultiple(3);

        if(!capPoints || !capTypes)
            return OutOfMemory;
    }

    GpMemset(&capTypes[0], PathPointTypeLine, 3);


    GpPointF norm, tangent;

    norm.X = grad.Y;
    norm.Y = - grad.X;

    if(isStartCap)
    {
        tangent.X = - grad.X;
        tangent.Y = - grad.Y;
    }
    else
    {
        tangent = grad;
    }

    GpPointF leftPt, rightPt;

    leftPt.X = point.X + leftWidth*norm.X;
    leftPt.Y = point.Y + leftWidth*norm.Y;
    rightPt.X = point.X + rightWidth*norm.X;
    rightPt.Y = point.Y + rightWidth*norm.Y;
    
    GpPointF center;
    
    REAL width = REALABS(leftWidth-rightWidth);
    
    center.X = 0.5f*(leftPt.X + rightPt.X + width*tangent.X);
    center.Y = 0.5f*(leftPt.Y + rightPt.Y + width*tangent.Y);
    
    capPoints[1] = center;

    if(isStartCap)
    {
        capPoints[0] = rightPt;
        capPoints[2] = leftPt;
    }
    else
    {
        capPoints[0] = leftPt;
        capPoints[2] = rightPt;
    }

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Add the first widened point of the current path type.
*
* Arguments:
*
*   [IN] leftWidth -	The left width for widened line.
*	[IN] rightWidth -	The right width for the widened line.
*   [IN] lineJoin -     The type of the line join.
*   [OUT] leftPoints1 - The buffer for the left points.
*   [OUT] leftTypes1 -   The buffer for the left types.
*   [OUT] addedLeftCount - The number of the added left points and types.
*   [OUT] rightPoints1 - The buffer for the right points.
*   [OUT] rightTypes1 - The buffer for the right types.
*   [OUT] addedRightCount - The number of the added right points and types.
*   [OUT] leftEndPt -   The end point of the left line for the current
*                       subpath.  This is calculated only for the first
*                       subpath point.
*   [OUT] rightEndPt -  The end point of the right line for tha current
*                       subpath.  This is calculated only for the first
*                       subpath point.
*   [IN] grad -         The gradients of the center points for the
*                       current path type.
*   [IN] dataPoints -   The center points data for the current path type
*   [IN] dataCount -    The number of data points in the current path type.
*   [IN/OUT] lastPt -   The last point used in calculations.
*   [IN] flag -         The flag to indicates the various properties
*                       of the current subpath and type.
*
*
* Return Value:
*
*   NONE
*
*   01/24/2000 ikkof
*       Created it
*
\**************************************************************************/

VOID
GpPathWidener::WidenFirstPoint(
    REAL leftWidth,
    REAL rightWidth,
    GpLineJoin lineJoin,
    REAL miterLimit2,
    GpPointF* leftPoints,
    BYTE* leftTypes,
    INT* addedLeftCount,
    GpPointF* rightPoints,
    BYTE* rightTypes,
    INT* addedRightCount,
    GpPointF* leftEndPt,
    GpPointF* rightEndPt,
    const GpPointF* grad,
    const GpPointF* norm,
    const GpPointF* dataPoints,
    INT dataCount,
    GpPointF* lastPt,
    const REAL* firstInsets,
    INT flag
    )
{
    GpPointF nextPt = dataPoints[0];
    GpPointF grad1, grad2;
    GpPointF norm1, norm2;


    INT leftCount = 0;
    INT rightCount = 0;
    grad1 = *grad++;
    grad2 = *grad;
    norm1 = *norm++;
    norm2 = *norm;

    INT numOfAddedFirstPts = 0;

    if(flag & WideningFirstType)
    {
        BOOL needsToAdjustNormals = FALSE;

        GpLineJoin lineJoin1 = lineJoin;
        if(flag & WideningNeedsToAdjustNormals)
        {
            needsToAdjustNormals = TRUE;
            lineJoin1 = LineJoinMiter;  // Don't use RoundJoin.
        }

		if(!(flag & WideningClosed))
        {
            lineJoin1 = LineJoinBevel;
        }

	    const INT bufferCount = 32;
        GpPointF lPts[bufferCount], rPts[bufferCount];
        INT lCnt, rCnt;
        GpTurningDirection direction;
        BOOL useBevelJoinInside = (flag & WideningUseBevelJoinInside) != 0;

        INT polyCount = JoinPolygonPoints.GetCount();
        const GpPointF* polyPoints = JoinPolygonPoints.GetDataBuffer();
        const REAL* polyAngles = JoinPolygonAngles.GetDataBuffer();

        BOOL leftInside = FALSE, rightInside = FALSE;

        if(polyCount > 0)
            direction = getHobbyJoin(
    //                        lineJoin1,
						    nextPt,
						    grad1,
						    grad2,
                            polyCount,
                            polyPoints,
                            polyAngles,
                            leftWidth,
                            rightWidth,
                            &lCnt,
                            &lPts[0],
                            &rCnt,
                            &rPts[0],
                            needsToAdjustNormals,
						    miterLimit2,
                            FALSE,   // IsMiter
                            useBevelJoinInside
						    );
        else
            direction = getJoin(
                        lineJoin1,
						nextPt,
						grad1,
						grad2,
                        norm1,
                        norm2,
                        leftWidth,
                        rightWidth,
                        &lCnt,
                        &lPts[0],
                        &leftInside,
                        &rCnt,
                        &rPts[0],
                        &rightInside,
                        needsToAdjustNormals,
						miterLimit2,
                        useBevelJoinInside
						);

        //!!! Inside flag check
        if(leftInside)
        {
            ASSERT((lCnt & 0x01) == 0);
        }

        
        //!!! Inside flag check
        if(rightInside)
        {
            ASSERT((rCnt & 0x01) == 0);
        }

        *leftEndPt = lPts[0];
        *rightEndPt = rPts[0];

		BYTE pathType;

        if(flag & WideningClosed)
        {
            if(lCnt > 0)
            {
                pathType = PathPointTypeLine;
            }
            else if(lCnt < 0)
            {
                lCnt = - lCnt;
                pathType = PathPointTypeBezier;
            }

            if(lCnt > 0)
            {
                //!!! Inside flag check
                if(leftInside)
                {
                    ASSERT((lCnt & 0x01) == 0);
                }

                if(leftInside)
                    pathType |= PathPointTypeInternalUse;
                GpMemset(leftTypes, pathType, lCnt);
                leftTypes[0] = PathPointTypeStart;
                if(leftInside)
                    leftTypes[0] |= PathPointTypeInternalUse;

                GpMemcpy(leftPoints, &lPts[0], lCnt*sizeof(GpPointF));
                leftTypes += lCnt;
                leftPoints += lCnt;
                leftCount += lCnt;
            }

            if(rCnt > 0)
            {
                pathType = PathPointTypeLine;
            }
            else if(rCnt < 0)
            {
                rCnt = - rCnt;
                pathType = PathPointTypeBezier;
            }

            if(rCnt > 0)
            {
                //!!! Inside flag check
                if(rightInside)
                {
                    ASSERT((rCnt & 0x01) == 0);
                }

                if(rightInside)
                    pathType |= PathPointTypeInternalUse;
                GpMemset(rightTypes, pathType, rCnt);
                rightTypes[0] = PathPointTypeStart;
                if(rightInside)
                    rightTypes[0] |= PathPointTypeInternalUse;

                GpMemcpy(rightPoints, &rPts[0], rCnt*sizeof(GpPointF));
                rightTypes += rCnt;
                rightPoints += rCnt;
                rightCount += rCnt;
            }
        }
        else
        {
            // The path is not closed.  Bevel join is used.

            GpPointF leftStartPt;
            GpPointF rightStartPt;
            INT index;

            if(lCnt == 1)
                index = 0;
            else
                index = 1;
            leftStartPt = lPts[index];

            if(rCnt == 1)
                index = 0;
            else
                index = 1;
            rightStartPt = rPts[index];

            if(!(flag & WideningClosed) && firstInsets[0] != 0)
            {
                leftStartPt.X += firstInsets[0]*grad2.X;
                leftStartPt.Y += firstInsets[0]*grad2.Y;
            }

            if(!(flag & WideningClosed) && firstInsets[1] != 0)
            {
                rightStartPt.X += firstInsets[1]*grad2.X;
                rightStartPt.Y += firstInsets[1]*grad2.Y;
            }

            *leftTypes++ = PathPointTypeStart;
            *rightTypes++ = PathPointTypeStart;
            *leftPoints = leftStartPt;
            *rightPoints = rightStartPt;

            leftPoints++;
            rightPoints++;
            leftCount++;
            rightCount++;
        }

        *lastPt = nextPt;
    }
    else
    {
        leftCount = rightCount = 0;
    }

    *addedLeftCount = leftCount;
    *addedRightCount = rightCount;
}

/**************************************************************************\
*
* Function Description:
*
*   Add the widened points for Lines
*
* For the arguments, See comments for widenFirstPoints
*
\**************************************************************************/

GpStatus
GpPathWidener::WidenLinePoints(
    REAL leftWidth,
    REAL rightWidth,
    GpLineJoin lineJoin,
    REAL miterLimit2,
    GpPointF* leftPoints,
    BYTE* leftTypes,
    INT* addedLeftCount,
    GpPointF* rightPoints,
    BYTE* rightTypes,
    INT* addedRightCount,
    const GpPointF* grad,
    const GpPointF* norm,
    const GpPointF* dataPoints,
    INT dataCount,
    GpPointF* lastPt,
    const REAL* lastInsets,
    INT flag
    )
{
    GpPointF grad1, grad2;
    GpPointF norm1, norm2;

    // Skip the first point since it is already added either by
    // widenFirstPoint() or by the widen call of the previous type.

    dataPoints++;
    dataCount--;  // The number of the remaining points.

    // Also skip the first gradient.

    grad++;
    grad1 = *grad++;
    norm++;
    norm1 = *norm++;

    BOOL isLastType = FALSE;

    if(flag & WideningLastType)
        isLastType = TRUE;

    BOOL needsToAdjustNormals = FALSE;

    GpLineJoin lineJoin1 = lineJoin;
    if(flag & WideningNeedsToAdjustNormals)
    {
        needsToAdjustNormals = TRUE;
        lineJoin1 = LineJoinMiter;  // Don't use RoundJoin.
    }

    INT leftCount = 0, rightCount = 0;
    BOOL isLastPoint = FALSE;
    BYTE pathType = PathPointTypeLine;

    INT jmax = dataCount;
    if(isLastType)
    {
        if(flag & WideningClosed)
        {
            if(!(flag & WideningLastPointSame))
            {
                // When the subpath is closed, and the last point is not
                // the same as the start point, don't regard this as
                // the last type.  Add points as usual.

                isLastType = FALSE;
            }
            else
            {
                // No need to add the last point since this is already
                // added by the first point.

                jmax--;
            }
        }
    }

	BOOL useBevelJoinInside = (flag & WideningUseBevelJoinInside) != 0;

    INT polyCount = JoinPolygonPoints.GetCount();
    const GpPointF* polyPoints = JoinPolygonPoints.GetDataBuffer();
    const REAL* polyAngles = JoinPolygonAngles.GetDataBuffer();

    INT i, j;
    for(j = 0; j < jmax; j++)
    {
        GpPointF nextPt = *dataPoints;

        if(isLastType && (j == dataCount - 1))
        {
			isLastPoint = TRUE;
            lineJoin1 = LineJoinBevel;
        }

        if(lastPt->X != nextPt.X || lastPt->Y != nextPt.Y)
        {
            grad2 = *grad;
            norm2 = *norm;

            const INT bufferCount = 32;
            GpPointF lPts[bufferCount], rPts[bufferCount];
            INT lCnt, rCnt;
            GpTurningDirection direction;
            BOOL leftInside = FALSE, rightInside = FALSE;

            if(polyCount > 0)
                direction = getHobbyJoin(
        //                        lineJoin1,
						        nextPt,
						        grad1,
						        grad2,
                                polyCount,
                                polyPoints,
                                polyAngles,
                                leftWidth,
                                rightWidth,
                                &lCnt,
                                &lPts[0],
                                &rCnt,
                                &rPts[0],
                                needsToAdjustNormals,
						        miterLimit2,
                                FALSE,   // IsMiter
                                useBevelJoinInside
						        );
            else
                direction = getJoin(
                                lineJoin1,
						        nextPt,
						        grad1,
						        grad2,
                                norm1,
                                norm2,
                                leftWidth,
                                rightWidth,
                                &lCnt,
                                &lPts[0],
                                &leftInside,
                                &rCnt,
                                &rPts[0],
                                &rightInside,
                                needsToAdjustNormals,
						        miterLimit2,
                                useBevelJoinInside
						        );

            //!!! Inside flag check
            if(leftInside)
            {
                ASSERT((lCnt & 0x01) == 0);
            }

        
            //!!! Inside flag check
            if(rightInside)
            {
                ASSERT((rCnt & 0x01) == 0);
            }

            if(isLastPoint)
            {
                lCnt = 1;
                rCnt = 1;
                leftInside = FALSE;
                rightInside = FALSE;

                if(lastInsets[0] != 0)
                {
                    lPts[0].X -= lastInsets[0]*grad1.X;
                    lPts[0].Y -= lastInsets[0]*grad1.Y;
                }

                if(lastInsets[1] != 0)
                {
                    rPts[0].X -= lastInsets[1]*grad1.X;
                    rPts[0].Y -= lastInsets[1]*grad1.Y;
                }
            }

            if(lCnt > 0)
            {
                pathType = PathPointTypeLine;
            }
            else if(lCnt < 0)
            {
                lCnt = - lCnt;
                pathType = PathPointTypeBezier;
            }

            if(lCnt > 0)
            {
                //!!! Inside flag check
                if(leftInside)
                {
                    ASSERT((lCnt & 0x01) == 0);
                }

                if(leftInside)
                    pathType |= PathPointTypeInternalUse;
                GpMemset(leftTypes, pathType, lCnt);
                leftTypes[0] = PathPointTypeLine;
                if(leftInside)
                    leftTypes[0] |= PathPointTypeInternalUse;

                GpMemcpy(leftPoints, &lPts[0], lCnt*sizeof(GpPointF));
                leftTypes += lCnt;
                leftPoints += lCnt;
                leftCount += lCnt;
            }

            if(rCnt > 0)
            {
                pathType = PathPointTypeLine;
            }
            else if(rCnt < 0)
            {
                rCnt = - rCnt;
                pathType = PathPointTypeBezier;
            }
            
            if(rCnt > 0)
            {
                //!!! Inside flag check
                if(rightInside)
                {
                    ASSERT((rCnt & 0x01) == 0);
                }

                if(rightInside)
                    pathType |= PathPointTypeInternalUse;
                GpMemset(rightTypes, pathType, rCnt);
                rightTypes[0] = PathPointTypeLine;
                if(rightInside)
                    rightTypes[0] |= PathPointTypeInternalUse;

                GpMemcpy(rightPoints, &rPts[0], rCnt*sizeof(GpPointF));
                rightTypes += rCnt;
                rightPoints += rCnt;
                rightCount += rCnt;
            }
            
            grad1 = grad2;
            norm1 = norm2;
            *lastPt = nextPt;        
        }
        
        grad++;
        norm++;
        dataPoints++;
    }
    
    *addedLeftCount = leftCount;
    *addedRightCount = rightCount;

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Add the widened points for Beziers
*
* For the arguments, See comments for widenFirstPoints
*
\**************************************************************************/

GpStatus
GpPathWidener::WidenBezierPoints(
    REAL leftWidth,
    REAL rightWidth,
    GpLineJoin lineJoin,
    REAL miterLimit2,
    GpPointF* leftPoints,
    BYTE* leftTypes,
    INT* addedLeftCount,
    GpPointF* rightPoints,
    BYTE* rightTypes,
    INT* addedRightCount,
    const GpPointF* grad,
    const GpPointF* norm,
    const GpPointF* dataPoints,
    INT dataCount,
    GpPointF* lastPt,
    const REAL* lastInsets,
    INT flag
    )
{
    //!!! Kink removal has not been considered here yet.

    GpPointF grad1, grad2;
    GpPointF norm1, norm2;

    // Skip the first point since it is already added either by
    // widenFirstPoint() or by the widen call of the previous type.

    dataPoints++;
    dataCount--;  // The number of the remaining points.

    // Also skip the first gradient.

    grad++;
    grad1 = *grad++;

    norm++;
    norm1 = *norm++;

	BOOL isLastType = FALSE;

    if(flag & WideningLastType)
        isLastType = TRUE;

    BOOL needsToAdjustNormals = FALSE;

    GpLineJoin lineJoin1 = lineJoin;
    if(flag & WideningNeedsToAdjustNormals)
    {
        needsToAdjustNormals = TRUE;
        lineJoin1 = LineJoinMiter;  // Don't use RoundJoin.
    }

    INT remainder = dataCount % 3;
    INT bezierCount = dataCount/3;

    ASSERT(remainder == 0); // dataCount must be multiple of 3.

    INT leftCount = 0, rightCount = 0;
    BOOL isLastPoint = FALSE;
    BYTE pathType = PathPointTypeBezier;

    if(isLastType)
    {
        if((flag & WideningClosed) && !(flag & WideningLastPointSame))
        {
            // When the subpath is closed, and the last point is not
            // the same as the start point, don't regard this as
            // the last type.  Add points as usual.

            isLastType = FALSE;
        }

        // When the path is closed and the last point is the same,
        // we must do the special treatment since the last join points
        // were already added as the first join points.
        // So keep isLastType to TRUE for this case.
    }

	BOOL useBevelJoinInside = flag & WideningUseBevelJoinInside;

    INT i, j;
    for(j = 0; j < bezierCount; j++)
    {
        for(INT k = 0; k < 3; k++)
        {
            GpPointF nextPt = *dataPoints;

            if(k < 2)
            {
                // Second and third control point.

                lineJoin1 = LineJoinMiter;
            }
            else
            {
                // The last control point.

//                lineJoin1 = lineJoin;
                lineJoin1 = LineJoinRound;
            }

            if(isLastType
                && (j == bezierCount - 1) && (k == 2))
            {
			    isLastPoint = TRUE;

                if(!(flag & WideningClosed))
                {
                    // When the subpath is not closed, make the
                    // last join as Bevel join.

                    lineJoin1 = LineJoinBevel;

                    // When the subpath is closed, use the current
                    // join.
                }
                else
                {
                    lineJoin1 = LineJoinRound;
                }
            }

            grad2 = *grad;
            norm2 = *norm;
            GpPointF lPts[7], rPts[7];
            INT lCnt, rCnt;
            GpTurningDirection direction;
            BOOL leftInside = FALSE, rightInside = FALSE;

            direction = getJoin(
                            lineJoin1,
						    nextPt,
						    grad1,
						    grad2,
                            norm1,
                            norm2,
                            leftWidth,
                            rightWidth,
                            &lCnt,
                            &lPts[0],
                            &leftInside,
                            &rCnt,
                            &rPts[0],
                            &rightInside,
                            needsToAdjustNormals,
						    miterLimit2,
                            useBevelJoinInside
						    );

			if(k < 2)
            {
                // In case that the miter join was not availabe
                // for k < 2, take the average of two vectors.

                if(lCnt == 2)
                {
                    lPts[0].X = (lPts[0].X + lPts[1].X)/2;
                    lPts[0].Y = (lPts[0].Y + lPts[1].Y)/2;
                }
                lCnt = 1;

                if(rCnt == 2)
                {
                    rPts[0].X = (rPts[0].X + rPts[1].X)/2;
                    rPts[0].Y = (rPts[0].Y + rPts[1].Y)/2;
                }
                rCnt = 1;
            }

            if(isLastPoint)
            {
                // In order to keep the 3n point format for the Bezier
                // curves, we must add the first point of the join
                // points as the last point of the last Bezier segment.

                if(!(flag & WideningClosed))
                {
                    lCnt = 1;
                    rCnt = 1;

                    if(lastInsets[0] != 0)
                    {
                        lPts[0].X -= lastInsets[0]*grad1.X;
                        lPts[0].Y -= lastInsets[0]*grad1.Y;
                    }

                    if(lastInsets[1] != 0)
                    {
                        rPts[0].X -= lastInsets[1]*grad1.X;
                        rPts[0].Y -= lastInsets[1]*grad1.Y;
                    }
                }
            }

            *leftPoints++ = lPts[0];
            *leftTypes++ = pathType;
            leftCount++;

            *rightPoints++ = rPts[0];
            *rightTypes++ = pathType;
            rightCount++;

            if(k == 2)
            {
                if(lCnt > 1)
                {
                    *leftPoints++ = lPts[1];
                    *leftTypes++ = PathPointTypeLine;
                    leftCount++;
                }
                else if(lCnt < 0)
                {
                    lCnt = - lCnt;
                    ASSERT(lCnt % 3 == 1);
                    GpMemcpy(leftPoints, &lPts[1], (lCnt - 1)*sizeof(GpPointF));
                    GpMemset(leftTypes, pathType, lCnt - 1);
                    leftPoints += lCnt - 1;
                    leftTypes += lCnt - 1;
                    leftCount += lCnt - 1;
                }

                if(rCnt > 1)
                {
                    *rightPoints++ = rPts[1];
                    *rightTypes++ = PathPointTypeLine;
                    rightCount++;
                }
                else if(rCnt < 0)
                {
                    rCnt = - rCnt;
                    ASSERT(rCnt % 3 == 1);
                    GpMemcpy(rightPoints, &rPts[1], (rCnt - 1)*sizeof(GpPointF));
                    GpMemset(rightTypes, pathType, rCnt - 1);
                    rightPoints += rCnt - 1;
                    rightTypes += rCnt - 1;
                    rightCount += rCnt - 1;
                }
            }

            grad1 = grad2;
            norm1 = norm2;
            *lastPt = nextPt;        
        
            grad++;
            norm++;
            dataPoints++;
        }
    }
    
    *addedLeftCount = leftCount;
    *addedRightCount = rightCount;

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Add the widened points for each path type.
*
* For the arguments, See comments for widenFirstPoints
*
\**************************************************************************/

GpStatus
GpPathWidener::WidenEachPathType(
    BYTE pathType,
    REAL leftWidth,
    REAL rightWidth,
    GpLineJoin lineJoin,
    REAL miterLimit2,
    GpPointF* leftPoints,
    BYTE* leftTypes,
    INT* addedLeftCount,
    GpPointF* rightPoints,
    BYTE* rightTypes,
    INT* addedRightCount,
    const GpPointF* grad,
    const GpPointF* norm,
    const GpPointF* dataPoints,
    INT dataCount,
    GpPointF* lastPt,
    const REAL* lastInsets,
    INT flag
    )
{
    GpStatus status = GenericError;

    switch(pathType)
    {
    case PathPointTypeLine:
        status = WidenLinePoints(
            leftWidth,
            rightWidth,
            lineJoin,
            miterLimit2,
            leftPoints,
            leftTypes,
            addedLeftCount,
            rightPoints,
            rightTypes,
            addedRightCount,
            grad,
            norm,
            dataPoints,
            dataCount,
            lastPt,
            lastInsets,
            flag);
        break;

    case PathPointTypeBezier:
        status = WidenBezierPoints(
            leftWidth,
            rightWidth,
            lineJoin,
            miterLimit2,
            leftPoints,
            leftTypes,
            addedLeftCount,
            rightPoints,
            rightTypes,
            addedRightCount,
            grad,
            norm,
            dataPoints,
            dataCount,
            lastPt,
            lastInsets,
            flag);
        break;

    default:
        WARNING(("Trying to widen undefined types."));
        break;
    }

    return status;
}

REAL
getCapDelta(
    const DpPen* pen
    )
{
    GpLineCap startCap = pen->StartCap;
    GpLineCap endCap = pen->EndCap;
    GpLineCap dashCap = pen->DashCap;

    REAL delta = 0, delta1;

    if(!(startCap & LineCapAnchorMask))
        delta1 = 0.5f;
    else
        delta1 = 3.0f;  // We must adjust later.

    if(delta < delta1)
        delta = delta1;

    if(!(endCap & LineCapAnchorMask))
        delta1 = 0.5f;
    else
        delta1 = 3.0f;  // We must adjust later.

    if(delta < delta1)
        delta = delta1;

    if(!(dashCap & LineCapAnchorMask))
        delta1 = 0.5f;
    else
        delta1 = 3.0f;  // We must adjust later.

    if(delta < delta1)
        delta = delta1;

    //!!! Add cutom line case.

    return 1.0f;
}

/**************************************************************************\
*
* Function Description:
*
*   This calculates the extra width due to pen.
*
* Arguments:
*
*   None
*
* Return Value:
*
*   The extra width.
*
*   02/29/00 ikkof
*       Created it
*
\**************************************************************************/

REAL
GpPathWidener::GetPenDelta()
{
    const GpPointF* centerPoints = CenterPoints.GetDataBuffer();
    const BYTE* centerTypes = CenterTypes.GetDataBuffer();
    INT centerCount = CenterPoints.GetCount();

    INT startIndex, endIndex;
    BOOL isClosed;
    GpStatus status = Ok;

    REAL scale;

    switch(Pen->PenAlignment)
    {
    case PenAlignmentCenter:
    default:
        scale = 0.5f;
        break;
    }

    REAL capDelta = getCapDelta(Pen);

    REAL joinDelta = 1.0f;

    if(Pen->Join == LineJoinMiter ||
       Pen->Join == LineJoinMiterClipped)
    {
        while(Iterator.NextSubpath(&startIndex, &endIndex, &isClosed)
		    && status == Ok)
        {
            status = CalculateGradients(startIndex, endIndex);

            if(status == Ok)
            {
                REAL delta = GetSubpathPenMiterDelta(isClosed);
                if(delta > joinDelta)
                    joinDelta = delta;
            }
        }

        if(status != Ok)
        {
            // We have to use the possible maximum for miter join.
            // Usually this is an over-estimate since the most path
            // don't have very sharp edges which correspond to miter limit.

            joinDelta = Pen->MiterLimit;
        }
    }

    REAL penDelta = max(joinDelta, capDelta)*scale;

    if(NeedsToTransform)
    {
        // This is already in device unit.

        penDelta *= StrokeWidth;
    }
    else
    {
        // Convert the width to the device unit.

        penDelta *= MaximumWidth;
    }
    if(penDelta < 1)
        penDelta = 1;

    return penDelta;
}

/**************************************************************************\
*
* Function Description:
*
*   This calculates the extra within a subpath due to a pen.
*   This is called by GetPenDelta().
*
* Arguments:
*
*   None
*
* Return Value:
*
*   The extra width.
*
*   02/29/00 ikkof
*       Created it
*
\**************************************************************************/

REAL
GpPathWidener::GetSubpathPenMiterDelta(
    BOOL isClosed
    )
{
    INT count = Gradients.GetCount();

    GpPointF* grad0 = Gradients.GetDataBuffer();

    INT imin, imax;
    if(isClosed)
    {
        imin = 0;
        imax = count - 1;
    }
    else
    {
        imin = 1;
        imax = count - 2;
    }

    GpPointF* grad = grad0 + imin;
    GpPointF prevGrad = *grad++;
    GpPointF nextGrad;

    REAL dot = 0;

    for(INT i = imin; i < imax; i++)
    {
        nextGrad = *grad++;
        REAL dot1 = prevGrad.X*nextGrad.X + prevGrad.Y*nextGrad.Y;
        prevGrad = nextGrad;

        if(dot1 < dot)
            dot = dot1;
    }

    REAL cosHalfTheta = (dot + 1.0f)*0.5f;
    REAL miterDelta = Pen->MiterLimit;

    // If the miterDelta is smaller than the miter limit, calculate it.

    if(cosHalfTheta > 0 && cosHalfTheta*miterDelta*miterDelta > 1)
    {
        cosHalfTheta = REALSQRT(cosHalfTheta);
        miterDelta = 1.0f/cosHalfTheta;
    }

    return miterDelta;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\precomp.hpp ===
// stddef.h is needed for 'offsetof'

#include <stddef.h>

#include <objbase.h>
#include <icm.h>

#include "..\Runtime\Runtime.hpp"
#include "..\Common\Common.hpp"

#include "..\..\privinc\imaging.h"
#include "..\..\privinc\pixelformats.h"

#include "..\..\ddkinc\ddiplus.hpp"
#include "..\PDrivers\ConvertToGdi.hpp"

// Hack:
#include "..\Render\scan.hpp"
#include "..\Render\scandib.hpp"
// EndHack

#include "iterator.hpp"

#include "device.hpp"
#include "..\PDrivers\hp_vdp.h"
#include "..\PDrivers\PDrivers.hpp"

#include "vectormath.hpp"
#include "geometry.hpp"
#include "object.hpp"
#include "region.hpp"
#include "stringFormat.hpp"
#include "XBezier.hpp"
#include "PathSelfIntersectRemover.hpp"
#include "path.hpp"
#include "CustomLineCap.hpp"
#include "endcap.hpp"
#include "PathWidener.hpp"
#include "QuadTransforms.hpp"
#include "XPath.hpp"
#include "ImageAttr.hpp"
#include "gpbitmap.hpp"
#include "brush.hpp"
#include "pen.hpp"
#include "Metafile.hpp"
#include "regiontopath.hpp"

// Hack:
#include "..\Render\output.hpp"
#include "..\Render\aarasterizer.hpp"
// EndHack

#include "initialize.hpp"

// font stuff

#define _NO_DDRAWINT_NO_COM

#include "..\fondrv\tt\ttfd\fontddi.h"

extern "C" {
#include "..\fondrv\tt\ttfd\fdsem.h"
#include "..\fondrv\tt\ttfd\mapfile.h"
};

#include "intMap.hpp"
#include "fontface.hpp"
#include "facerealization.hpp"
#include "fontfile.hpp"
#include "fontable.hpp"
#include "FontLinking.hpp"
#include "family.hpp"
#include "font.hpp"
#include "fontfilecache.hpp"
#include "fontcollection.hpp"
#include "aatext.hpp"

#include "graphics.hpp"

#include "TextImager.hpp"
#include "DrawGlyphData.hpp"

#include "fastText.hpp"

#include "..\imaging\api\ColorPal.hpp"
#include "..\imaging\api\Bitmap.hpp"
#include "..\imaging\api\Recolor.hpp"
#include "CachedBitmap.hpp"
#include "copyonwritebitmap.hpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\pen.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Abstract:
*
*   Implementation of GpPen class
*
* Revision History:
*
*   12/08/1998 andrewgo
*       Initial placeholders.
*
*   01/06/1999 ikkof
*       Added the implementation of GpGeometricPen.
\**************************************************************************/

#include "precomp.hpp"

//-------------------------------------------------------------
// GetMajorAndMinorAxis() is defined in PathWidener.cpp.
//-------------------------------------------------------------

extern GpStatus
GetMajorAndMinorAxis(
    REAL* majorR,
    REAL* minorR,
    const GpMatrix* matrix
    );

/**************************************************************************\
*
* Function Description:
*
* This converts the given width with the given physical unit to
* the device unit.  You cannot use this function when
* unit is WorldUnit.
*
* Arguments:
*
*   [IN] width  - the width in the given unit.
*   [IN] unit   - the unit of the width (must not be WorldUnit).
*   [IN] dpi    - dots per inch of the device.
*
* Return Value:
*
*   The device width.
*
*   04/15/1999 ikkof
*       Created it.
*
\**************************************************************************/

VOID GpPen::Set(const GpColor& color, REAL penWidth, GpUnit unit)
{
    // UnitDisplay is device-dependent and cannot be used for a pen size
    ASSERT(unit != UnitDisplay);

    if(DevicePen.CustomStartCap)
        delete DevicePen.CustomStartCap;

    if(DevicePen.CustomEndCap)
        delete DevicePen.CustomEndCap;

    if(DevicePen.DashArray)
        GpFree(DevicePen.DashArray);

    if(DevicePen.CompoundArray)
        GpFree(DevicePen.CompoundArray);


    InitDefaultState(penWidth, unit);

    if(Brush)
    {
        SetColor((GpColor *) &color);
    }
    else
    {
        Brush = new GpSolidFill(color);
        if(Brush)
        {
            DevicePen.Brush = Brush->GetDeviceBrush();
        }
        else
        {
            SetValid(FALSE);
        }
    }

    UpdateUid();
}

GpPen::GpPen(const GpColor& color, REAL penWidth, GpUnit unit)
{
    // UnitDisplay is device-dependent and cannot be used for a pen size
    ASSERT(unit != UnitDisplay);

    InitDefaultState(penWidth, unit);
    Brush = new GpSolidFill(color);
    if(Brush)
    {
        DevicePen.Brush = Brush->GetDeviceBrush();
    }
    else
    {
        SetValid(FALSE);
    }
}

GpPen::GpPen(const GpBrush* brush, REAL penWidth, GpUnit unit)
{
    // UnitDisplay is device-dependent and cannot be used for a pen size
    ASSERT(unit != UnitDisplay);

    InitDefaultState(penWidth, unit);
    Brush = brush->Clone();
    if(Brush)
    {
        DevicePen.Brush = Brush->GetDeviceBrush();
    }
    else
    {
        SetValid(FALSE);
    }
}

GpPen::GpPen(GpLineTexture* lineTexture, REAL penWidth, GpUnit unit)
{
    // UnitDisplay is device-dependent and cannot be used for a pen size
    ASSERT(unit != UnitDisplay);

    // !!! Needs to be implemented.
    // !!! Remember to change GdipCreatePen3 - it currently just returns
    //     NotImplemented.

    RIP(("GpPen with line texture not implemented"));
    SetValid(FALSE);
}

VOID GpPen::InitDefaultState(REAL penWidth, GpUnit unit)
{
    // UnitDisplay is device-dependent and cannot be used for a pen size
    ASSERT(unit != UnitDisplay);

    // !! Look at DeviceBrush.Type
    DevicePen.Type = PenTypeSolidColor;
    DevicePen.Width = penWidth;
    DevicePen.Unit = unit;
    DevicePen.StartCap = LineCapFlat;
    DevicePen.EndCap = LineCapFlat;
    DevicePen.Join = LineJoinMiter;
    DevicePen.MiterLimit = 10;    // PS's default miter limit.
    DevicePen.PenAlignment = PenAlignmentCenter;

    DevicePen.DashStyle = DashStyleSolid;
    DevicePen.DashCap = LineCapFlat;
    DevicePen.DashCount = 0;
    DevicePen.DashOffset = 0;
    DevicePen.DashArray = NULL;

    DevicePen.CompoundCount = 0;
    DevicePen.CompoundArray = NULL;

    DevicePen.CustomStartCap = NULL;
    DevicePen.CustomEndCap = NULL;

    DevicePen.Xform.Reset();
    
    SetValid(TRUE);
    UpdateUid();
}

GpPen::GpPen(const GpPen* pen)
{
    GpStatus status = Ok;

    if(pen && pen->IsValid())
    {
        // Copy the base state.
        
        DevicePen = pen->DevicePen;
        
        // Don't copy pointer references to other objects.
        
        Brush = NULL;
        DevicePen.Brush = NULL;
        DevicePen.DashArray = NULL;
        DevicePen.CompoundArray = NULL;
        DevicePen.CustomStartCap = NULL;
        DevicePen.CustomEndCap = NULL;
        
        // Explicitly clone the pointer references to other objects.

        if(pen->Brush)
        {
            Brush = pen->Brush->Clone();
            DevicePen.Brush = Brush->GetDeviceBrush();
        }
        else
        {
            status = GenericError;
        }

        if( status == Ok )
        {   
            if( (pen->DevicePen.DashArray) && 
                (DevicePen.DashCount > 0)
            )
            {
                DevicePen.DashArray = (REAL*) GpMalloc(DevicePen.DashCount*sizeof(REAL));
                if(DevicePen.DashArray)
                {
                    GpMemcpy(DevicePen.DashArray, pen->DevicePen.DashArray, DevicePen.DashCount*sizeof(REAL));
                }
                else
                {
                    status = OutOfMemory;
                }
            }
            else
            {
                // If there is no dash array data, this must be a solid line.
                
                ASSERT(DevicePen.DashStyle == DashStyleSolid);
    
                DevicePen.DashCount = 0;
                DevicePen.DashArray = NULL;
            }
        }

        // Set the compound array if necessary.

        if( status == Ok )
        {
            if( (pen->DevicePen.CompoundArray) && 
                (DevicePen.CompoundCount > 0)
            )
            {
                DevicePen.CompoundArray = (REAL*) GpMalloc(DevicePen.CompoundCount*sizeof(REAL));
                if(DevicePen.CompoundArray)
                {
                    GpMemcpy(DevicePen.CompoundArray, pen->DevicePen.CompoundArray, DevicePen.CompoundCount*sizeof(REAL));
                }
                else
                {
                    status = OutOfMemory;
                }
            }
            else
            {
                DevicePen.CompoundCount = 0;
                DevicePen.CompoundArray = NULL;
            }
        }
        
        // Copy the start custom cap.

        if( status == Ok )
        {
            if( DevicePen.StartCap == LineCapCustom )
            {
                // This could happen with our metafile recorder,
                // because saving Custom Line Caps was not implemented.
                if (pen->DevicePen.CustomStartCap == NULL)
                {
                    WARNING1("CustomStartCap type with NULL pointer");
                    DevicePen.StartCap = LineCapFlat;
                }
                else
                {
                    GpCustomLineCap* clonedCap = static_cast<GpCustomLineCap*>
                                (pen->DevicePen.CustomStartCap)->Clone();
                    if(clonedCap)
                    {
                        DevicePen.CustomStartCap = clonedCap;
                    }
                    else
                    {
                        status = OutOfMemory;
                    }
                }
            }
        }
        
        // Copy the end custom cap.

        if( status == Ok )
        {
            if( DevicePen.EndCap == LineCapCustom )
            {
                // This could happen with our metafile recorder,
                // because saving Custom Line Caps was not implemented.
                if (pen->DevicePen.CustomEndCap == NULL)
                {
                    WARNING1("CustomEndCap type with NULL pointer");
                    DevicePen.EndCap = LineCapFlat;
                }
                else
                {
                    GpCustomLineCap* clonedCap = static_cast<GpCustomLineCap*>
                                (pen->DevicePen.CustomEndCap)->Clone();
                    if(clonedCap)
                    {
                        DevicePen.CustomEndCap = clonedCap;
                    }
                    else
                    {
                        status = OutOfMemory;
                    }
                }
            }
        }

    }
    else
    {
        // Can't make a valid pen from an invalid input pen.
        
        status = GenericError;    
    }
    
    if(status == Ok)
    {
        SetValid(TRUE);
    }
    else
    {
        // Failed cloning the pen.
        
        // Clean up possible memory allocation so we don't leak even under
        // low memory conditions. Note we rely on GpFree and delete handling
        // NULL pointers here.
        
        delete Brush;
        Brush = NULL;                   // InitializeDefaultState() does not set
        DevicePen.Brush = NULL;         // these fields - clear them explicitly.
        
        GpFree(DevicePen.DashArray);
        GpFree(DevicePen.CompoundArray);
        
        delete DevicePen.CustomStartCap;
        delete DevicePen.CustomEndCap;
        
        // Clean the pen.
        
        InitDefaultState(1.0f, UnitWorld);
        
        // This is not a valid object.
        
        SetValid(FALSE);
    }
}

// Clone() return NULL if the cloning fails.

GpPen* GpPen::Clone()
{
    GpPen* clonedPen =  new GpPen(this);

    if(clonedPen && clonedPen->IsValid())
        return clonedPen;
    else
    {
        if(clonedPen)
            delete clonedPen;
        return NULL;
    }
}

GpStatus
GpPen::GetMaximumWidth(
        REAL* width,
        const GpMatrix* matrix) const
{
    if(DevicePen.Unit != UnitWorld)
        return InvalidParameter;

    GpMatrix trans;
    if(matrix)
        trans = *matrix;

    if(!DevicePen.Xform.IsTranslate())
        trans.Prepend(DevicePen.Xform);

    REAL majorR, minorR;

    ::GetMajorAndMinorAxis(&majorR, &minorR, &trans);
    majorR *= DevicePen.Width;
    minorR *= DevicePen.Width;

    if(minorR < 1.42f)   // This is a litte bit larger than sqrt(2).
    {
        minorR = 1.42f;
        majorR = 1.42f;
    }

    *width = majorR;

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   This function takes a join angle and computes the length of the miter
*   based on this angle and a given miter length limit.
*   This can be scaled by the pen width to give the length of an arbitrary
*   pen miter.
*
*   In this picture, 2a is the angle of the join. The pen width is w and the 
*   desired output is the length of the miter join (l).
*
*   Note that the line labled w is perpendecular to the inside and outside 
*   widended lines. Then the formula is derived as follows:
*
*         sin(a) = w/l   [opposite over hypotenuse on right angled triangle]
*    <=>  l = w/sin(a)
*
*
*                     /|\
*                    /a|a\
*                   /  |  \
*                  /   |   \
*                 /    |l   \
*                /     |     \ <-- right angle
*               /--__  |  __--\
*              /   w --|-- w   \
*             /       / \       \
*            /       /   \       \
*        outside     inside     outside
*
* NOTE: 
*
*   This routine returns the miter length (l) for a pen width w==1.0f. 
*   The caller is responsible for scaling length by the pen width.
*
*   If the length of 1/sin(a) is greater than the miterLimit, the miterLimit
*   is returned. (including infinite length joins).
*                        
* Arguments:
*
*   [IN] angle      - join angle in radians
*   [IN] miterLimit - maximum miter length (not scaled by pen width).
*
* Return Value:
*
*   Pen width independent miter length.
*
*   10/02/2000 asecchia
*       Created it.
*
\**************************************************************************/


REAL GpPen::ComputeMiterLength(
    REAL angle,
    REAL miterLimit
    )
{
    // use the simple miter join formula 
    // length = (penwidth)/sin(angle/2)
    // because we're pen independent, use 1.0 for pen width and rely
    // on the caller to scale by the pen width.
    
    REAL length = (REAL)sin(0.5*angle);
    
    // Check for an infinite miter...
    
    if(REALABS(length) < REAL_EPSILON)
    {
        return miterLimit;
    }
    
    length = 1.0f / length;
    
    return min(miterLimit, length);
}



REAL
GpPen::GetMaximumJoinWidth(
    REAL sharpestAngle,
    const GpMatrix* matrix,
    REAL dpiX,
    REAL dpiY) const
{
    REAL delta;

    if ((matrix != NULL) && (DevicePen.IsOnePixelWideSolid(matrix, dpiX)))
    {
        delta = 0.5;
    }
    else
    {
        REAL maximumWidth;
        REAL delta0;

        REAL scale = 1.0;

        switch(DevicePen.PenAlignment)
        {
        case PenAlignmentCenter:
            scale = 0.5f;
            break;

        // use 1.0 for the inset pen. If the path is open, we render with a
        // center pen.
        
        // NOTE: a scale of 0.0 is sufficient for all inset pen rendering 
        // provided all subpaths are closed. In the widener, we detect the
        // open subpaths and render them with a center pen. To accommodate 
        // this, we increase the scale here. Theoretically we could use 
        // scale = 0.5f for the inset pen (same as center pen), but this 
        // bounds is an overestimate anyway and being wrong by one pixel too
        // small is way worse (crash) than being wrong and too big.
        
        case PenAlignmentInset:
            scale = 1.0f;
            break;
        }

        if(GetMaximumWidth(&maximumWidth, matrix) == Ok)
        {
            delta0 = maximumWidth;
        }
        else
        {
            maximumWidth = ::GetDeviceWidth(
                                DevicePen.Width,
                                DevicePen.Unit,
                                dpiX);
            delta0 = maximumWidth;
        }

        if(DevicePen.Join == LineJoinMiter ||
           DevicePen.Join == LineJoinMiterClipped)
        {
            REAL miterLimit = DevicePen.MiterLimit;

            delta = delta0*miterLimit;

            if(delta > 20)
            {
                delta = ComputeMiterLength(
                    sharpestAngle,
                    miterLimit
                );

                // scale by the pen width.
                
                delta *= delta0;
            }
        }
        else
        {
            delta = delta0;
        }

        delta *= scale;
    }

    return delta;
}

REAL
GpPen::GetMaximumCapWidth(
        const GpMatrix* matrix,
        REAL dpiX,
        REAL dpiY) const
{
    REAL maximumWidth;
    REAL delta0;

    if(GetMaximumWidth(&maximumWidth, matrix) == Ok)
    {
        delta0 = maximumWidth;
    }
    else
    {
        maximumWidth = ::GetDeviceWidth(
                            DevicePen.Width,
                            DevicePen.Unit,
                            dpiX);
        delta0 = maximumWidth;
    }

    REAL delta = delta0;

    GpLineCap startCap = DevicePen.StartCap;
    GpLineCap endCap = DevicePen.EndCap;

    REAL delta1;

    GpCustomLineCap* customCap = NULL;

    if(startCap == LineCapCustom && DevicePen.CustomStartCap)
    {
        customCap = static_cast<GpCustomLineCap *> (DevicePen.CustomStartCap);
        delta1 = customCap->GetRadius(delta0, 1.0f);
    }
    else
    {
        if(!(startCap & LineCapAnchorMask))
            delta1 = 0.5f*delta0;
        else
            delta1 = 2.0f*(delta0 + 1);
    }
    if(delta < delta1)
        delta = delta1;


    if(endCap == LineCapCustom && DevicePen.CustomEndCap)
    {
        customCap = static_cast<GpCustomLineCap *> (DevicePen.CustomEndCap);
        delta1 = customCap->GetRadius(delta0, 1.0f);
    }
    else
    {
        if(!(endCap & LineCapAnchorMask))
            delta1 = 0.5f*delta0;
        else
            delta1 = 2.0f*(delta0 + 2);
    }
    if(delta < delta1)
        delta = delta1;

    return delta;
}

VOID
GpPen::SetDashCap(GpDashCap dashCap)
{
    // Note: Internally we use a GpLineCap type to store the dash cap type.
    // So we need to convert between GpLineCap and GpDashCap.
    // However, we should change the internal usage to GpDashCap in v2.
    // - JBronsk
    GpLineCap lineCap = LineCapFlat;
    switch (dashCap)
    {
    case DashCapRound:
    	lineCap = LineCapRound;
    	break;
    case DashCapTriangle:
    	lineCap = LineCapTriangle;
    	break;
    // all others map to LineCapFlat
    }
    
    GpStatus status = SetDashStyleWithDashCap(DevicePen.DashStyle, lineCap);
    if(status == Ok)
    {
        DevicePen.DashCap = lineCap;
    }
}

GpStatus
GpPen::SetDashStyle(
    GpDashStyle dashStyle
    )
{
    return SetDashStyleWithDashCap(dashStyle, DevicePen.DashCap);
}

GpStatus
GpPen::SetDashStyleWithDashCap(
    GpDashStyle dashStyle,
    GpLineCap dashCap
    )
{
    GpStatus status = Ok;
    REAL    style[6];
    INT     count;

    switch(dashStyle)
    {
    case DashStyleSolid:
        count = 0;
        break;

    case DashStyleDash:
        count = 2;
        style[0] = 3;   // a dash
        style[1] = 1;   // a space
        break;

    case DashStyleDot:
        count = 2;
        style[0] = 1;   // a dot
        style[1] = 1;   // a space
        break;

    case DashStyleDashDot:
        count = 4;
        style[0] = 3;   // a dash
        style[1] = 1;   // a space
        style[2] = 1;   // a dot
        style[3] = 1;   // a space
        break;

    case DashStyleDashDotDot:
        count = 6;
        style[0] = 3;   // a dash
        style[1] = 1;   // a space
        style[2] = 1;   // a dot
        style[3] = 1;   // a space
        style[4] = 1;   // a dot
        style[5] = 1;   // a space
        break;
    
    case DashStyleCustom:
        
        // We assume that the custom dash has been set at the API.
        // The remaining code in this routine is for initializing an appropriate
        // dash array, which we already have in this case, so we're done.
        
        DevicePen.DashStyle = dashStyle;
        return Ok;

    default:
        // The dash style must be one of the predefined ones.
        status = InvalidParameter;
    }

    if(status != Ok)
    {
        return status;
    }

    if(DevicePen.DashCount < count)
    {
        REAL* newArray = (REAL*) GpMalloc(count*sizeof(REAL));

        if(newArray)
        {
            GpFree(DevicePen.DashArray);
            DevicePen.DashArray = newArray;
        }
        else
        {
            status = OutOfMemory;
        }
    }

    if(status == Ok)
    {
        // initialize the DashArray.
        GpMemcpy(DevicePen.DashArray, &style[0], count*sizeof(REAL));
        DevicePen.DashStyle = dashStyle;
        DevicePen.DashCount = count;
        UpdateUid();
    }

    return status;
}

GpStatus
GpPen::SetDashArray(
    const REAL* dashArray,
    INT count
    )
{
    ASSERT(dashArray && count > 0);

    // Make sure the all elements are positive.
    INT         i = 0;
    GpStatus    status = Ok;

    while(status == Ok && i < count)
    {
        if(dashArray[i++] <= 0)
            status = InvalidParameter;
    }

    if(status != Ok)
        return status;

    REAL* newArray = (REAL*) GpRealloc(DevicePen.DashArray, count*sizeof(REAL));

    if(!newArray)
        return OutOfMemory;

    GpMemcpy(newArray, dashArray, count*sizeof(REAL));

    DevicePen.DashStyle = DashStyleCustom;
    DevicePen.DashArray = newArray;
    DevicePen.DashCount = count;
    UpdateUid();

    return Ok;
}

GpStatus
GpPen::GetDashArray(
    REAL* dashArray,
    INT count
    ) const
{
    ASSERT(dashArray != NULL && count <= DevicePen.DashCount);

    GpStatus status = Ok;

    if(dashArray == NULL || count > DevicePen.DashCount)
        return InvalidParameter;

    if(DevicePen.DashArray)
        GpMemcpy(dashArray, DevicePen.DashArray, count*sizeof(REAL));
    else
        status = OutOfMemory;

    return status;
}

GpStatus
GpPen::SetCompoundArray(
    const REAL* compoundArray,
    INT count
    )
{
    // count must be a positive even number.

    if(compoundArray == NULL || count <= 0 || (count & 0x01))
    {
        return InvalidParameter;
    }

    // count is 2 or more here...
    
    // Compound Inset pens aren't implemented yet.
    // The code for correctly handling minimum width compound sub lines
    // is missing.
    
    if(DevicePen.PenAlignment == PenAlignmentInset)
    {
        return NotImplemented;
    }

    // Make sure the all elements are monitonically increasing
    // and its values are between 0 and 1.

    GpStatus    status = Ok;
    REAL        lastValue, nextValue;

    lastValue = compoundArray[0];
    if(lastValue < 0.0f || lastValue > 1.0f)
        status = InvalidParameter;

    INT i = 1;

    while(status == Ok && i < count)
    {
        nextValue = compoundArray[i++];
        if(nextValue < lastValue || nextValue > 1.0f)
            status = InvalidParameter;

        lastValue = nextValue;
    }

    if(status != Ok)
        return status;

    REAL* newArray = (REAL*) GpRealloc(DevicePen.CompoundArray, count*sizeof(REAL));

    if(!newArray)
        return OutOfMemory;

    GpMemcpy(newArray, compoundArray, count*sizeof(REAL));

    DevicePen.CompoundArray = newArray;
    DevicePen.CompoundCount = count;
    UpdateUid();

    return Ok;
}

GpStatus
GpPen::GetCompoundArray(
    REAL* compoundArray,
    INT count
    )
{
    ASSERT(compoundArray != NULL && count <= DevicePen.CompoundCount);

    if(compoundArray == NULL || count > DevicePen.CompoundCount)
        return InvalidParameter;

    if(DevicePen.CompoundArray && count > 0)
        GpMemcpy(compoundArray, DevicePen.CompoundArray, count*sizeof(REAL));

    return Ok;
}

GpStatus
GpPen::SetCustomStartCap(
    const GpCustomLineCap* customCap
    )
{
    if(DevicePen.CustomStartCap)
        delete DevicePen.CustomStartCap;

    // Reset the standard start cap to the default one.

    DevicePen.CustomStartCap = NULL;
    DevicePen.StartCap = LineCapFlat;

    if(customCap)
    {
        DevicePen.CustomStartCap = customCap->Clone();
        DevicePen.StartCap = LineCapCustom;
    }

    UpdateUid();
    return Ok;
}

GpStatus
GpPen::GetCustomStartCap(
    GpCustomLineCap** customCap
    )
{
    if(DevicePen.CustomStartCap)
        *customCap = static_cast<GpCustomLineCap*>
                (DevicePen.CustomStartCap)->Clone();
    else
        *customCap = NULL;

    return Ok;
}

GpStatus
GpPen::SetCustomEndCap(
    const GpCustomLineCap* customCap
    )
{
    if(DevicePen.CustomEndCap)
        delete DevicePen.CustomEndCap;

    // Reset the standard start cap to the default one.

    DevicePen.CustomEndCap = NULL;
    DevicePen.EndCap = LineCapFlat;

    if(customCap)
    {
        DevicePen.CustomEndCap = customCap->Clone();
        DevicePen.EndCap = LineCapCustom;
    }

    UpdateUid();
    return Ok;
}

GpStatus
GpPen::GetCustomEndCap(
    GpCustomLineCap** customCap
    )
{
    if(DevicePen.CustomEndCap)
        *customCap = static_cast<GpCustomLineCap*>
                (DevicePen.CustomEndCap)->Clone();
    else
        *customCap = NULL;

    return Ok;
}

GpStatus
GpPen::MultiplyTransform(const GpMatrix& matrix,
                                   GpMatrixOrder order)
{
    GpStatus    status = Ok;

    if (matrix.IsInvertible())
    {
        if (order == MatrixOrderPrepend)
        {
            DevicePen.Xform.Prepend(matrix);
        }
        else
        {
            DevicePen.Xform.Append(matrix);
        }
    }
    else
        status = InvalidParameter;

    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Answer true if the two pen instances are equivalent, meaning they
*   are indistinguishable when rendering.
*
* Arguments:
*
*   [IN] pen - pen to compare this against

* Return Value:
*
*   TRUE if equivalent.
*
* Created:
*
*   6/14/1999 peterost
*
\**************************************************************************/

BOOL
GpPen::IsEqual(
    const GpPen *  pen
    )
    const
{
    ASSERT(pen != NULL);

    if (pen == this)
        return TRUE;

    BOOL isEqual = TRUE;

    if (DevicePen.IsEqual(&pen->DevicePen) &&
        DevicePen.DashStyle == pen->DevicePen.DashStyle &&
        DevicePen.CompoundCount == pen->DevicePen.CompoundCount &&
        Brush->IsEqual(pen->Brush) &&
        DevicePen.Xform.IsEqual(&pen->DevicePen.Xform))
    {
        // We need to check the equality further if the dash style
        // is not a solid line.

        if (DevicePen.DashStyle != DashStyleSolid)
        {
            if(DevicePen.DashStyle != DashStyleCustom)
            {
                // A case of the preset dash pattern.
                // Check only for the offset difference.

                if(DevicePen.DashOffset != pen->DevicePen.DashOffset)
                    isEqual = FALSE;
            }
            else
            {
                if (DevicePen.DashCount == pen->DevicePen.DashCount &&
                    DevicePen.DashOffset == pen->DevicePen.DashOffset &&
                    DevicePen.DashArray != NULL &&
                    pen->DevicePen.DashArray != NULL)
                {
                    INT i = 0;

                    while(i < DevicePen.DashCount && isEqual)
                    {
                        if (DevicePen.DashArray[i] != pen->DevicePen.DashArray[i])
                        {
                            isEqual = FALSE;
                        }
                        i++;
                    }
                }
                else
                {
                    isEqual = FALSE;
                }
            }
        }

        // Check for the compound lines.

        if(isEqual && DevicePen.CompoundCount > 0)
        {
            if(DevicePen.CompoundArray && pen->DevicePen.CompoundArray)
            {
                INT j = 0;

                while(j < DevicePen.CompoundCount && isEqual)
                {
                    if(DevicePen.CompoundArray[j] != pen->DevicePen.CompoundArray[j])
                    {
                        isEqual = FALSE;
                    }
                    j++;
                }
            }
            else
            {
                isEqual = FALSE;
            }
        }
    }
    else
    {
        isEqual = FALSE;
    }

    return isEqual;
}

// For GetData and SetData methods
#define GDIP_PENFLAGS_TRANSFORM             0x00000001
#define GDIP_PENFLAGS_STARTCAP              0x00000002
#define GDIP_PENFLAGS_ENDCAP                0x00000004
#define GDIP_PENFLAGS_JOIN                  0x00000008
#define GDIP_PENFLAGS_MITERLIMIT            0x00000010
#define GDIP_PENFLAGS_DASHSTYLE             0x00000020
#define GDIP_PENFLAGS_DASHCAP               0x00000040
#define GDIP_PENFLAGS_DASHOFFSET            0x00000080
#define GDIP_PENFLAGS_DASHARRAY             0x00000100
#define GDIP_PENFLAGS_NONCENTER             0x00000200
#define GDIP_PENFLAGS_COMPOUNDARRAY         0x00000400
#define GDIP_PENFLAGS_CUSTOMSTARTCAP        0x00000800
#define GDIP_PENFLAGS_CUSTOMENDCAP          0x00001000

class PenData : public ObjectTypeData
{
public:
    INT32       Flags;
    INT32       Unit;
    REAL        Width;
};

/**************************************************************************\
*
* Function Description:
*
*   Get the pen data.
*
* Arguments:
*
*   [IN] dataBuffer - fill this buffer with the data
*   [IN/OUT] size   - IN - size of buffer; OUT - number bytes written
*
* Return Value:
*
*   GpStatus - Ok or error code
*
* Created:
*
*   9/13/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpPen::GetData(
    IStream *   stream
    ) const
{
    if (Brush == NULL)
    {
        WARNING(("Brush is NULL"));
        return Ok;
    }

    ASSERT (stream != NULL);

    INT         flags    = 0;

    if (!DevicePen.Xform.IsIdentity())
    {
        flags |= GDIP_PENFLAGS_TRANSFORM;
    }

    INT     customStartCapSize = 0;
    INT     customEndCapSize   = 0;

    if (DevicePen.StartCap != LineCapFlat)
    {
        if (DevicePen.StartCap == LineCapCustom)
        {
            if ((DevicePen.CustomStartCap != NULL) &&
                DevicePen.CustomStartCap->IsValid() &&
                ((customStartCapSize = DevicePen.CustomStartCap->GetDataSize()) > 0))
            {
                flags |= GDIP_PENFLAGS_STARTCAP | GDIP_PENFLAGS_CUSTOMSTARTCAP;
            }
        }
        else
        {
            flags |= GDIP_PENFLAGS_STARTCAP;
        }
    }

    if (DevicePen.EndCap != LineCapFlat)
    {
        if (DevicePen.EndCap == LineCapCustom)
        {
            if ((DevicePen.CustomEndCap != NULL) &&
                DevicePen.CustomEndCap->IsValid() &&
                ((customEndCapSize = DevicePen.CustomEndCap->GetDataSize()) > 0))
            {
                flags |= GDIP_PENFLAGS_ENDCAP | GDIP_PENFLAGS_CUSTOMENDCAP;
            }
        }
        else
        {
            flags |= GDIP_PENFLAGS_ENDCAP;
        }
    }

    if (DevicePen.Join != LineJoinMiter)
    {
        flags |= GDIP_PENFLAGS_JOIN;
    }

    if (DevicePen.MiterLimit != 10)
    {
        flags |= GDIP_PENFLAGS_MITERLIMIT;
    }

    // DashStyleCustom is handled by hasDashArray
    if ((DevicePen.DashStyle != DashStyleSolid) && (DevicePen.DashStyle != DashStyleCustom))
    {
        flags |= GDIP_PENFLAGS_DASHSTYLE;
    }

    if (DevicePen.DashCap != LineCapFlat)
    {
        flags |= GDIP_PENFLAGS_DASHCAP;
    }

    if (DevicePen.DashOffset != 0)
    {
        flags |= GDIP_PENFLAGS_DASHOFFSET;
    }

    if ((DevicePen.DashStyle == DashStyleCustom) &&
        (DevicePen.DashArray != NULL) &&
        (DevicePen.DashCount > 0))
    {
        flags |= GDIP_PENFLAGS_DASHARRAY;
    }

    if (DevicePen.PenAlignment != PenAlignmentCenter)
    {
        flags |= GDIP_PENFLAGS_NONCENTER;
    }

    if ((DevicePen.CompoundArray != NULL) && (DevicePen.CompoundCount > 0))
    {
        flags |= GDIP_PENFLAGS_COMPOUNDARRAY;
    }

    PenData     penData;
    penData.Type  = DevicePen.Type;
    penData.Flags = flags;
    penData.Unit  = DevicePen.Unit;
    penData.Width = DevicePen.Width;
    stream->Write(&penData, sizeof(penData), NULL);

    if (flags & GDIP_PENFLAGS_TRANSFORM)
    {
        DevicePen.Xform.WriteMatrix(stream);
    }

    if (flags & GDIP_PENFLAGS_STARTCAP)
    {
        stream->Write(&DevicePen.StartCap, sizeof(INT32), NULL);
    }

    if (flags & GDIP_PENFLAGS_ENDCAP)
    {
        stream->Write(&DevicePen.EndCap, sizeof(INT32), NULL);
    }

    if (flags & GDIP_PENFLAGS_JOIN)
    {
        stream->Write(&DevicePen.Join, sizeof(INT32), NULL);
    }

    if (flags & GDIP_PENFLAGS_MITERLIMIT)
    {
        stream->Write(&DevicePen.MiterLimit, sizeof(REAL), NULL);
    }

    if (flags & GDIP_PENFLAGS_DASHSTYLE)
    {
        stream->Write(&DevicePen.DashStyle, sizeof(INT32), NULL);
    }

    if (flags & GDIP_PENFLAGS_DASHCAP)
    {
        stream->Write(&DevicePen.DashCap, sizeof(INT32), NULL);
    }

    if (flags & GDIP_PENFLAGS_DASHOFFSET)
    {
        stream->Write(&DevicePen.DashOffset, sizeof(REAL), NULL);
    }

    if (flags & GDIP_PENFLAGS_DASHARRAY)
    {
        stream->Write(&DevicePen.DashCount, sizeof(INT32), NULL);
        stream->Write(DevicePen.DashArray, DevicePen.DashCount * sizeof(REAL), NULL);
    }

    if (flags & GDIP_PENFLAGS_NONCENTER)
    {
        stream->Write(&DevicePen.PenAlignment, sizeof(INT32), NULL);
    }

    if (flags & GDIP_PENFLAGS_COMPOUNDARRAY)
    {
        stream->Write(&DevicePen.CompoundCount, sizeof(INT32), NULL);
        stream->Write(DevicePen.CompoundArray, DevicePen.CompoundCount * sizeof(REAL), NULL);
    }

    GpStatus status;

    if (flags & GDIP_PENFLAGS_CUSTOMSTARTCAP)
    {
        stream->Write(&customStartCapSize, sizeof(INT32), NULL);
        if ((status = DevicePen.CustomStartCap->GetData(stream)) != Ok)
        {
            return status;
        }
    }

    if (flags & GDIP_PENFLAGS_CUSTOMENDCAP)
    {
        stream->Write(&customEndCapSize, sizeof(INT32), NULL);
        if ((status = DevicePen.CustomEndCap->GetData(stream)) != Ok)
        {
            return status;
        }
    }

    status = Brush->GetData(stream);

    return status;
}

UINT
GpPen::GetDataSize() const
{
    if (Brush == NULL)
    {
        WARNING(("Brush is NULL"));
        return 0;
    }

    UINT        dataSize = sizeof(PenData);

    if (!DevicePen.Xform.IsIdentity())
    {
        dataSize += GDIP_MATRIX_SIZE;
    }

    INT     customStartCapSize = 0;
    INT     customEndCapSize   = 0;

    if (DevicePen.StartCap != LineCapFlat)
    {
        if (DevicePen.StartCap == LineCapCustom)
        {
            if ((DevicePen.CustomStartCap != NULL) &&
                DevicePen.CustomStartCap->IsValid() &&
                ((customStartCapSize = DevicePen.CustomStartCap->GetDataSize()) > 0))
            {
                // startcap + sizeof custom cap + custom cap
                dataSize += sizeof(INT32) + sizeof(INT32) + customStartCapSize;
            }
        }
        else
        {
            dataSize += sizeof(INT32);
        }
    }

    if (DevicePen.EndCap != LineCapFlat)
    {
        if (DevicePen.EndCap == LineCapCustom)
        {
            if ((DevicePen.CustomEndCap != NULL) &&
                DevicePen.CustomEndCap->IsValid() &&
                ((customEndCapSize = DevicePen.CustomEndCap->GetDataSize()) > 0))
            {
                // endcap + sizeof custom cap + custom cap
                dataSize += sizeof(INT32) + sizeof(INT32) + customEndCapSize;
            }
        }
        else
        {
            dataSize += sizeof(INT32);
        }
    }

    if (DevicePen.Join != LineJoinMiter)
    {
        dataSize += sizeof(INT32);
    }

    if (DevicePen.MiterLimit != 10)
    {
        dataSize += sizeof(REAL);
    }

    // DashStyleCustom is handled by hasDashArray
    if ((DevicePen.DashStyle != DashStyleSolid) && (DevicePen.DashStyle != DashStyleCustom))
    {
        dataSize += sizeof(INT32);
    }

    if (DevicePen.DashCap != LineCapFlat)
    {
        dataSize += sizeof(INT32);
    }

    if (DevicePen.DashOffset != 0)
    {
        dataSize += sizeof(REAL);
    }

    if ((DevicePen.DashStyle == DashStyleCustom) &&
        (DevicePen.DashArray != NULL) &&
        (DevicePen.DashCount > 0))
    {
        dataSize += sizeof(INT32) + (DevicePen.DashCount * sizeof(REAL));
    }

    if (DevicePen.PenAlignment != PenAlignmentCenter)
    {
        dataSize += sizeof(INT32);
    }

    if ((DevicePen.CompoundArray != NULL) && (DevicePen.CompoundCount > 0))
    {
        dataSize += sizeof(INT32) + (DevicePen.CompoundCount * sizeof(REAL));
    }

    dataSize += Brush->GetDataSize();

    return dataSize;
}

/**************************************************************************\
*
* Function Description:
*
*   Read the pen object from memory.
*
* Arguments:
*
*   [IN] dataBuffer - the data that was read from the stream
*   [IN] size - the size of the data
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   4/26/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpPen::SetData(
    const BYTE *        dataBuffer,
    UINT                size
    )
{
    if (dataBuffer == NULL)
    {
        WARNING(("dataBuffer is NULL"));
        return InvalidParameter;
    }

    if (size < sizeof(PenData))
    {
        WARNING(("size too small"));
        return InvalidParameter;
    }

    const PenData *     penData = reinterpret_cast<const PenData *>(dataBuffer);

    if (!penData->MajorVersionMatches())
    {
        WARNING(("Version number mismatch"));
        return InvalidParameter;
    }

    InitDefaultState(penData->Width, static_cast<GpUnit>(penData->Unit));

    dataBuffer += sizeof(PenData);
    size       -= sizeof(PenData);

    if (penData->Flags & GDIP_PENFLAGS_TRANSFORM)
    {
        if (size < GDIP_MATRIX_SIZE)
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }
        DevicePen.Xform.SetMatrix((REAL *)dataBuffer);
        dataBuffer += GDIP_MATRIX_SIZE;
        size       -= GDIP_MATRIX_SIZE;
    }

    if (penData->Flags & GDIP_PENFLAGS_STARTCAP)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }
        DevicePen.StartCap = (GpLineCap) ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);
    }

    if (penData->Flags & GDIP_PENFLAGS_ENDCAP)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }
        DevicePen.EndCap = (GpLineCap) ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);
    }

    if (penData->Flags & GDIP_PENFLAGS_JOIN)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }
        DevicePen.Join = (GpLineJoin) ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);
    }

    if (penData->Flags & GDIP_PENFLAGS_MITERLIMIT)
    {
        if (size < sizeof(REAL))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }
        DevicePen.MiterLimit = ((REAL *)dataBuffer)[0];
        dataBuffer += sizeof(REAL);
        size       -= sizeof(REAL);
    }

    if (penData->Flags & GDIP_PENFLAGS_DASHSTYLE)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }
        this->SetDashStyle((GpDashStyle)((INT32 *)dataBuffer)[0]);
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);
    }

    if (penData->Flags & GDIP_PENFLAGS_DASHCAP)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }
        DevicePen.DashCap = (GpLineCap) ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);
    }

    if (penData->Flags & GDIP_PENFLAGS_DASHOFFSET)
    {
        if (size < sizeof(REAL))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }
        DevicePen.DashOffset = ((REAL *)dataBuffer)[0];
        dataBuffer += sizeof(REAL);
        size       -= sizeof(REAL);
    }

    if (penData->Flags & GDIP_PENFLAGS_DASHARRAY)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }

        INT count = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        if (size < (count * sizeof(REAL)))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }
        this->SetDashArray((REAL *)dataBuffer, count);
        dataBuffer += (count * sizeof(REAL));
        size       -= (count * sizeof(REAL));
    }

    if (penData->Flags & GDIP_PENFLAGS_NONCENTER)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }
        DevicePen.PenAlignment = (GpPenAlignment) ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);
    }

    if (penData->Flags & GDIP_PENFLAGS_COMPOUNDARRAY)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }

        INT count = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        if (size < (count * sizeof(REAL)))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }

        this->SetCompoundArray((REAL *)dataBuffer, count);
        dataBuffer += (count * sizeof(REAL));
        size       -= (count * sizeof(REAL));
    }

    if (penData->Flags & GDIP_PENFLAGS_CUSTOMSTARTCAP)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }

        UINT    capSize = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        if ((size < capSize) || (capSize < sizeof(ObjectTypeData)))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }

        ASSERT(DevicePen.CustomStartCap == NULL);
        DevicePen.CustomStartCap = (GpCustomLineCap *)GpObject::Factory(ObjectTypeCustomLineCap, (const ObjectData *)dataBuffer, capSize);

        if ((DevicePen.CustomStartCap == NULL) ||
            (DevicePen.CustomStartCap->SetData(dataBuffer, capSize) != Ok) ||
            !DevicePen.CustomStartCap->IsValid())
        {
            WARNING(("Failure getting CustomStartCap"));
            goto ErrorExit;
        }

        dataBuffer += capSize;
        size       -= capSize;
    }

    if (penData->Flags & GDIP_PENFLAGS_CUSTOMENDCAP)
    {
        if (size < sizeof(INT32))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }

        UINT    capSize = ((INT32 *)dataBuffer)[0];
        dataBuffer += sizeof(INT32);
        size       -= sizeof(INT32);

        if ((size < capSize) || (capSize < sizeof(ObjectTypeData)))
        {
            WARNING(("size too small"));
            goto ErrorExit;
        }

        ASSERT(DevicePen.CustomEndCap == NULL);
        DevicePen.CustomEndCap = (GpCustomLineCap *)GpObject::Factory(ObjectTypeCustomLineCap, (const ObjectData *)dataBuffer, capSize);

        if ((DevicePen.CustomEndCap == NULL) ||
            (DevicePen.CustomEndCap->SetData(dataBuffer, capSize) != Ok) ||
            !DevicePen.CustomEndCap->IsValid())
        {
            WARNING(("Failure getting CustomEndCap"));
            goto ErrorExit;
        }

        dataBuffer += capSize;
        size       -= capSize;
    }

    if (Brush != NULL)
    {
        Brush->Dispose();
        Brush = NULL;
    }

    if (size >= sizeof(ObjectTypeData))
    {
        Brush = (GpBrush *)GpObject::Factory(ObjectTypeBrush, (const ObjectData *)dataBuffer, size);
        if (Brush != NULL)
        {
            if ((Brush->SetData(dataBuffer, size) == Ok) && Brush->IsValid())
            {
                DevicePen.Brush = Brush->GetDeviceBrush();
                SetValid(TRUE);
                UpdateUid();
                return Ok;
            }
            Brush->Dispose();
            Brush = NULL;
        }
    }
    WARNING(("Failure getting brush"));

ErrorExit:
    SetValid(FALSE);
    return GenericError;
}

GpStatus
GpPen::ColorAdjust(
    GpRecolor *             recolor,
    ColorAdjustType         type
    )
{
    ASSERT(recolor != NULL);
    if (type == ColorAdjustTypeDefault)
    {
        type = ColorAdjustTypePen;
    }

    if (Brush != NULL)
    {
        Brush->ColorAdjust(recolor, type);
    }

    return Ok;
}

GpStatus
GpPen::GetColor(
    ARGB *argb
    ) const
{
    if (Brush->GetBrushType() == BrushTypeSolidColor)
    {
        GpSolidFill * solidBrush = (GpSolidFill *) Brush;

        *argb = solidBrush->GetColor().GetValue();

        return Ok;
    }

    return InvalidParameter;
}

GpStatus
GpPen::SetColor(
    GpColor *       color
    )
{
    if (Brush->GetBrushType() == BrushTypeSolidColor)
    {
        GpSolidFill * solidBrush = (GpSolidFill *) Brush;

        if (solidBrush->GetColor().GetValue() == color->GetValue())
        {
            return Ok;
        }

        // !!! bhouse why do we allocate another brush just to change the
        // pen's color !!!!
    }

    GpSolidFill *newBrush = new GpSolidFill(*color);

    if (newBrush != NULL)
    {
        if (newBrush->IsValid())
        {
            delete Brush;
            Brush = newBrush;
            DevicePen.Brush = Brush->GetDeviceBrush();
            UpdateUid();
            return Ok;
        }
        delete newBrush;
    }

    return GenericError;

}

GpStatus
GpPen::SetBrush(
    GpBrush *       brush
    )
{
    // Don't set the brush if it is the same color as the current one,
    // because that makes metafiles unnecessarily large.
    if ((Brush->GetBrushType() == BrushTypeSolidColor) &&
        (brush->GetBrushType() == BrushTypeSolidColor))
    {
        GpSolidFill * solidBrush = (GpSolidFill *) Brush;
        GpSolidFill * newSolidBrush = (GpSolidFill *) brush;

        if(solidBrush->GetColor().GetValue() ==
           newSolidBrush->GetColor().GetValue())
        {
            return Ok;
        }
    }

    GpBrush *   newBrush = brush->Clone();

    if (newBrush != NULL)
    {
        if (newBrush->IsValid())
        {
            delete Brush;
            Brush = newBrush;
            DevicePen.Brush = Brush->GetDeviceBrush();
            UpdateUid();
            return Ok;
        }
        delete newBrush;
    }
    return GenericError;
}

GpPenType
GpPen::GetPenType(
    )
{
    GpPenType type = PenTypeUnknown;

    if(Brush)
    {
        switch(Brush->GetBrushType())
        {
        case BrushTypeSolidColor:
            type = PenTypeSolidColor;
            break;

        case BrushTypeHatchFill:
            type = PenTypeHatchFill;
            break;

        case BrushTypeTextureFill:
            type = PenTypeTextureFill;
            break;
/*
        case BrushRectGrad:
            type = PenFillRectGrad;
            break;

        case BrushRadialGrad:
            type = PenFillRadialGrad;
            break;

        case BrushTriangleGrad:
            type = PenFillTriangleGrad;
            break;
*/
        case BrushTypePathGradient:
            type = PenTypePathGradient;
            break;

        case BrushTypeLinearGradient:
            type = PenTypeLinearGradient;
            break;

        default:
            break;
        }
    }

    // We must implement LineTexture case.

    return type;
}


/**************************************************************************\
*
* Function Description:
*
*   Adjust the dash array for dash caps if present.
*
*   Note that unlike line caps, dash caps do not extend the length
*   of the subpath, they are inset. So we shorten the dash segments
*   that draw a line and lengthen the dash segments that are spaces
*   by a factor of 2x the dash unit in order to leave space for the
*   caps that will be added by the widener.
*
*   This fixes Whistler bug #126476.
*
* Arguments:
*
*   [IN] dashCap - dash cap type
*   [IN] dashUnit - dash size - typically the pen width
*   [IN/OUT] dashArray - array containing the dash pattern that is adjusted.
*   [IN] dashCount - count of elements in the dash array
*
* Return Value:
*
*   None.
*
* History:
*
*   9/27/2000 jbronsk
*       Created.
*
*  12/06/2000 aaronlie
*       Moved from GpPath
*
\**************************************************************************/

VOID
GpPen::AdjustDashArrayForCaps(
    REAL dashUnit,
    REAL *dashArray,
    INT dashCount
    ) const
{
    REAL adjustmentLength = 2.0f *
        GetDashCapInsetLength(dashUnit);

    if (adjustmentLength > 0.0f)
    {
        const REAL minimumDashValue = dashUnit * 0.001f; // a small number
        for (int i = 0; i < dashCount; i++)
        {
            if (i & 0x1) // index is odd - so this is a space
            {
                // lengthen the spaces
                dashArray[i] += adjustmentLength;
            }
            else // index is even - so this is a line
            {
                // shorten the lines
                dashArray[i] -= adjustmentLength;
                // check if we have made the dash too small
                // (as in the case of 'dots')
                if (dashArray[i] < minimumDashValue)
                {
                    dashArray[i] = minimumDashValue;
                }
            }
        }
    }
}


/**************************************************************************\
*
* Function Description:
*
* Computes the length of the inset required to accomodate a particular
* dash cap type, since dash caps are contained within the dash length.
*
* Arguments:
*
*   [IN] dashUnit - pen width
*
* Return Value:
*
*   The amount that a dash needs to be inset on each end in order to
*   accomodate any dash caps.
*
* History:
*
*   9/27/2000 jbronsk
*       Created.
*
*  12/06/2000 aaronlie
*       Moved from GpPath
*
\**************************************************************************/

REAL
GpPen::GetDashCapInsetLength(
    REAL dashUnit
    ) const
{
    REAL insetLength = 0.0f;

    // dash caps can only be flat, round, or triangle
    switch(GetDashCap())
    {
    case LineCapFlat:
        insetLength = 0.0f;
        break;

    case LineCapRound:
    case LineCapTriangle:
        insetLength = dashUnit * 0.5f;
        break;
   }

   return insetLength;
}


/**************************************************************************\
*
* Function Description:
*
*   Does a quick check to see if the path can be rendered as a solid
*   pixel wide line.
*
* Arguments:
*
*   [IN] cappedDpiX - the resolution of the x direction
*   [IN] worldToDevice - World transform
*
* Return Value:
*
*   TRUE if okay to be rendered as a one pixel line
*
* History:
*
*   12/17/1999 ikkof
*       Created it.
*
\**************************************************************************/

BOOL
DpPen::IsOnePixelWideSolid(
    const GpMatrix *worldToDevice,
    REAL dpiX
    ) const
{
    return this->IsSimple() && this->IsOnePixelWide(worldToDevice, dpiX);
}

/**************************************************************************\
*
* Function Description:
*
*   Does a quick check to see if the path can be rendered as a one
*   pixel wide line.
*
* Arguments:
*
*   [IN] cappedDpiX - the resolution of the x direction
*   [IN] worldToDevice - World transform
*
* Return Value:
*
*   TRUE if okay to be rendered as a one pixel line
*
* History:
*
*   10/6/2000 - peterost - factored out fron IsOnePixelWideSolid
*
\**************************************************************************/

BOOL
DpPen::IsOnePixelWide(
    const GpMatrix *worldToDevice,
    REAL dpiX
    ) const
{
    BOOL useOnePixelPath = FALSE;

    const REAL minimumPenWidth = 1.5f;

    // !!![andrewgo] This determination of a single pixel wide line is
    //               unbelievably expensive

    // !!![andrewgo] This width check should be done simply using
    //               the world-to-device transform!  It would be
    //               faster and simpler!

    REAL width = this->Width;
    GpUnit unit = this->Unit;

    if(unit == UnitWorld)
    {
        if(worldToDevice == NULL || worldToDevice->IsTranslate())
        {
            if(width <= minimumPenWidth)
                useOnePixelPath = TRUE;
        }
        else if(worldToDevice->IsTranslateScale())
        {
            REAL m11 = worldToDevice->GetM11();
            REAL m22 = worldToDevice->GetM22();
            REAL maxScale = max(REALABS(m11), REALABS(m22));

            if(width*maxScale <= minimumPenWidth)
                useOnePixelPath = TRUE;
        }
        else
        {
            // This is a general transform.

            REAL majorR, minorR;    // Radii for major and minor axis.

            if(::GetMajorAndMinorAxis(
                &majorR,
                &minorR,
                worldToDevice) == Ok)
            {
                if(width*majorR <= minimumPenWidth)
                    useOnePixelPath = TRUE;
            }
        }
    }
    else
    {
        // Since GDI+ only uses the World Uinit, this code is not called
        // any more.

        width = ::GetDeviceWidth(width, unit, dpiX);
        if(width <= minimumPenWidth)
            useOnePixelPath = TRUE;
    }

    return useOnePixelPath;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\printer.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   printer.h
*
* Abstract:
*
*   Printer related header inclusions
*
* Revision History:
*
*   6/21/1999 ericvan
*       Created it.
*
\**************************************************************************/

#ifndef PRINTER_HPP
#define PRINTER_HPP

#define GDIPLUS_UNI_INIT       4607
#define GDIPLUS_UNI_ESCAPE     4606

typedef struct _GDIPPRINTINIT
{
    DWORD dwSize;

    ULONG numPalEntries;
    ULONG palEntries[256];

    BOOL  usePal;
    DWORD dwMode;
    FLONG flRed;
    FLONG flGre;
    FLONG flBlu;
}
GDIPPRINTINIT, *PGDIPPRINTINIT;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\pathwidener.hpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   PathWidener.hpp
*
* Abstract:
*
*   Class used for Path widening
*
* Revision History:
*
*   11/24/99 ikkof
*       Created it.
*
\**************************************************************************/

#ifndef _PATHWIDENER_HPP
#define _PATHWIDENER_HPP

enum GpLineCapMode
{
    LineCapDefaultMode = 0,
    LineCapDashMode = 1
};

class GpPathWidener
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

protected:
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagPathWidener : ObjectTagInvalid;
    }

public:

    GpPathWidener(
        const GpPointF* points,
        const BYTE* types,
        INT count,
        const DpPen* pen,
        const GpMatrix* matrix,
        REAL dpiX,
        REAL dpiY,
        BOOL isAntiAliased,
        BOOL isInsetPen = FALSE
        )
    {
        Initialize(
            points, 
            types, 
            count, 
            pen, 
            matrix, 
            dpiX, 
            dpiY,
            isAntiAliased, 
            isInsetPen
        );
    }
    
    GpPathWidener(
        GpPath *path,
        const DpPen* pen,
        const GpMatrix* matrix,
        REAL dpiX,
        REAL dpiY,
        BOOL isAntiAliased,
        BOOL isInsetPen = FALSE
        )
    {
        const GpPointF* points = path->GetPathPoints();
        const BYTE* types = path->GetPathTypes();
        INT count = path->GetPointCount();

        Initialize(
            points, 
            types, 
            count, 
            pen, 
            matrix, 
            dpiX, 
            dpiY,
            isAntiAliased, 
            isInsetPen
        );
    }

    GpPathWidener(
        const GpPointF* points,
        const BYTE* types,
        INT count,
        const DpPen* pen,
        const GpMatrix* matrix,
        REAL dpiX,
        REAL dpiY,
        BOOL isAntiAliased,
        BYTE* centerTypesBuffer,
        GpPointF* centerPointsBuffer,
        GpPointF* gradientsBuffer,
        GpPointF* normalsBuffer,
        BYTE* leftTypesBuffer,
        GpPointF* leftPointsBuffer,
        BYTE* rightTypesBuffer,
        GpPointF* rightPointsBuffer,
        INT bufferCount,
        BOOL isInsetPen = FALSE
        ) : CenterTypes(centerTypesBuffer, bufferCount),
            CenterPoints(centerPointsBuffer, bufferCount),
            Gradients(gradientsBuffer, bufferCount),
            Normals(normalsBuffer, bufferCount),
            LeftTypes(leftTypesBuffer, bufferCount),
            LeftPoints(leftPointsBuffer, bufferCount),
            RightTypes(rightTypesBuffer, bufferCount),
            RightPoints(rightPointsBuffer, bufferCount)
    {
        Initialize(points, types, count, pen, matrix, dpiX, dpiY,
            isAntiAliased, isInsetPen);
    }            

    ~GpPathWidener()
    {
        SetValid(FALSE);    // so we don't use a deleted object
    }

    GpStatus Widen(
        DynPointFArray* widenedPoints,
        DynByteArray* widenedTypes
        );
    
    GpStatus Widen(GpPath **path);

    BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagPathWidener) || (Tag == ObjectTagInvalid)); 
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid PathWidener");
        }
    #endif

        return (Tag == ObjectTagPathWidener);
    }

    REAL GetPenDelta();


protected:
    VOID Initialize(
        const GpPointF* points,
        const BYTE* types,
        INT count,
        const DpPen* pen,
        const GpMatrix* matrix,
        REAL dpiX,
        REAL dpiY,
        BOOL isAntiAliased,
        BOOL isInsetPen = FALSE
        );

    GpStatus WidenSubpath(
        DynPointFArray* widenedPoints,
        DynByteArray* widenedTypes,
        REAL leftWidth,
        REAL rightWidth,
        INT startIndex,
        INT endIndex,
        BOOL isClosed,
        GpLineCap startCap,
        GpLineCap endCap,
        BOOL useBevelJoinInside
        );

    GpStatus CalculateGradients(
        INT startIndex,
        INT endIndex
        );

    GpStatus CalculateNormals(
        REAL leftWidth,
        REAL rightWidth
        );

    GpStatus SetPolygonJoin(
        REAL leftWidth,
        REAL rightWidth,
        BOOL isAntialiased
        );

    GpStatus SetStartCapInset(
        REAL inset
        )
    {
        Inset1 = inset;

        return Ok;
    }

    GpStatus SetEndCapInset(
        REAL inset
        )
    {
        Inset2 = inset;

        return Ok;
    }
        
    VOID WidenFirstPoint(
        REAL leftWidth,
        REAL rightWidth,
        GpLineJoin lineJoin,
        REAL miterLimit2,
        GpPointF* leftPoints,
        BYTE* leftTypes,
        INT* addedLeftCount,
        GpPointF* rightPoints,
        BYTE* rightTypes,
        INT* addedRightCount,
        GpPointF* leftEndPt,
        GpPointF* rightEndPt,
        const GpPointF* grad,
        const GpPointF* norm,
        const GpPointF* dataPoints,
        INT dataCount,
        GpPointF* lastPt,
        const REAL* firstInsets,
        INT flag
    );

    GpStatus
    WidenEachPathType(
        BYTE pathType,
        REAL leftWidth,
        REAL rightWidth,
        GpLineJoin lineJoin,
        REAL miterLimit2,
        GpPointF* leftPoints,
        BYTE* leftTypes,
        INT* addedLeftCount,
        GpPointF* rightPoints,
        BYTE* rightTypes,
        INT* addedRightCount,
        const GpPointF* grad,
        const GpPointF* norm,
        const GpPointF* dataPoints,
        INT dataCount,
        GpPointF* lastPt,
        const REAL* lastInsets,
        INT flag
        );

    GpStatus
    WidenLinePoints(
        REAL leftWidth,
        REAL rightWidth,
        GpLineJoin lineJoin,
        REAL miterLimit2,
        GpPointF* leftPoints,
        BYTE* leftTypes,
        INT* addedLeftCount,
        GpPointF* rightPoints,
        BYTE* rightTypes,
        INT* addedRightCount,
        const GpPointF* grad,
        const GpPointF* norm,
        const GpPointF* dataPoints,
        INT dataCount,
        GpPointF* lastPt,
        const REAL* lastInsets,
        INT flag
        );

    GpStatus
    WidenBezierPoints(
        REAL leftWidth,
        REAL rightWidth,
        GpLineJoin lineJoin,
        REAL miterLimit2,
        GpPointF* leftPoints,
        BYTE* leftTypes,
        INT* addedLeftCount,
        GpPointF* rightPoints,
        BYTE* rightTypes,
        INT* addedRightCount,
        const GpPointF* grad,
        const GpPointF* norm,
        const GpPointF* dataPoints,
        INT dataCount,
        GpPointF* lastPt,
        const REAL* lastInsets,
        INT flag
        );
    
    GpStatus SetCaps(
        GpLineCap startCap,
        GpLineCap endCap,
        const GpPointF& startPoint,
        const GpPointF& startGrad,
        const GpPointF& startNorm,
        const GpPointF& endPoint,
        const GpPointF& endGrad,
        const GpPointF& endNorm,
        REAL leftWidth,
        REAL rightWidth,
        const GpPointF *points,
        INT pointCount
        );

    GpStatus SetCustomFillCaps(
        GpCustomLineCap* customStartCap,
        GpCustomLineCap* customEndCap,
        const GpPointF& startPoint,
        const GpPointF& endPoint,
        REAL leftWidth,
        REAL rightWidth,
        const GpPointF *centerPoints,
        const BYTE *centerTypes,
        INT centerPointCount,
        DynPointFArray *startCapPoints,
        DynPointFArray *endCapPoints,
        DynByteArray *startCapTypes,
        DynByteArray *endCapTypes
        );

    GpStatus SetCustomStrokeCaps(
        GpCustomLineCap* customStartCap,
        GpCustomLineCap* customEndCap,
        const GpPointF& startPoint,
        const GpPointF& endPoint,
        REAL leftWidth,
        REAL rightWidth,
        const GpPointF *centerPoints,
        const BYTE *centerTypes,
        INT centerPointCount,
        DynPointFArray *startCapPoints,
        DynPointFArray *endCapPoints,
        DynByteArray *startCapTypes,
        DynByteArray *endCapTypes
        );

    GpStatus SetRoundCap(
        const GpPointF& point,
        const GpPointF& grad,
        BOOL isStartCap,
        REAL leftWidth,
        REAL rightWidth
        );
    
    GpStatus SetDoubleRoundCap(
        const GpPointF& point,
        const GpPointF& grad,
        BOOL isStartCap,
        REAL leftWidth,
        REAL rightWidth
        );

    GpStatus SetTriangleCap(
        const GpPointF& point,
        const GpPointF& grad,
        BOOL isStartCap,
        REAL leftWidth,
        REAL rightWidth,
        const GpPointF *points,
        INT pointCount
        );

    GpStatus CombineSubpathOutlines(
        DynPointFArray* widenedPoints,
        DynByteArray* widenedTypes,
        BOOL isClosed,
        BOOL closeStartCap = FALSE,
        BOOL closeEndCap = FALSE
        );
    
    GpStatus CombineClosedCaps(
        DynPointFArray* widenedPoints,
        DynByteArray* widenedTypes,
        DynPointFArray *daStartCapPoints,
        DynPointFArray *daEndCapPoints,
        DynByteArray *daStartCapTypes,
        DynByteArray *daEndCapTypes
        );

    GpStatus AddCompoundCaps(
        DynPointFArray* widenedPoints,
        DynByteArray* widenedTypes,
        REAL leftWidth,
        REAL rightWidth,
        INT startIndex,
        INT endIndex,
        GpLineCap startCap,
        GpLineCap endCap
        );
    
    REAL GetSubpathPenMiterDelta(BOOL isClosed);

protected:
    DpPathIterator Iterator;
	DynByteArray CenterTypes;
    DynPointFArray CenterPoints;
    DynPointFArray Gradients;
    DynPointFArray Normals;

    DynByteArray LeftTypes;
    DynPointFArray LeftPoints;
    DynByteArray RightTypes;
    DynPointFArray RightPoints;

    BOOL InsetPenMode;           // are we doing inset pen using a center pen.
    const DpPen* Pen;
    GpMatrix XForm;
    GpMatrix InvXForm;
    REAL UnitScale;             // Scale factor for Page to Device units
    REAL StrokeWidth;
    REAL OriginalStrokeWidth;   // StrokeWidth is clamped to a minimum value
                                // but OriginalStrokeWidth is actual transformed
                                // pen width.
    REAL MinimumWidth;
    REAL MaximumWidth;
    BOOL IsAntiAliased;
    BOOL NeedsToTransform;
    BOOL NeedsToAdjustNormals;

    REAL DpiX;
    REAL DpiY;

    DynPointFArray JoinPolygonPoints;
    DynRealArray JoinPolygonAngles;

    // CapTypes1 and CapPoints1 are used for the start cap and left join.

    DynByteArray CapTypes1;
    DynPointFArray CapPoints1;
    REAL Inset1;    // Inset value for the starting position.
    
    // CapTypes2 and CapPoints2 are used for the end cap and right join.

    DynByteArray CapTypes2;
    DynPointFArray CapPoints2;
    REAL Inset2;    // Inset value for the ending position.
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\quadtransforms.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999 - 2000  Microsoft Corporation
*
* Abstract:
*
*   Quad Transforms
*
* History:
*
*   03/17/1999 ikkof
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

INT solveQuadraticEquationForQuadTransform(REAL a, REAL b, REAL c, REAL* x);

// Constants used in GpQuadAnalyzer

#define EdgeHorizontal  0
#define EdgeDown        1
#define EdgeUp          2

VOID
GpQuadAnalyzer::SetQuadAnalyzer(const GpPointF* points)
{
    Left = Right = points[0].X;
    Top = Bottom = points[0].Y;

    for(INT i = 0; i < 4; i++)
    {
        INT j = i + 1;
        if(j == 4)
            j = 0;

        if(points[i].Y < points[j].Y)
        {
            Directions[i] = EdgeDown;
            Y1[i] = points[i].Y;
            Y2[i] = points[j].Y;
            X1[i] = points[i].X;
            DxDy[i] = (points[j].X - points[i].X)/(points[j].Y - points[i].Y);
        }
        else if(points[i].Y > points[j].Y)
        {
            Directions[i] = EdgeUp;
            Y1[i] = points[j].Y;
            Y2[i] = points[i].Y;
            X1[i] = points[j].X;
            DxDy[i] = (points[j].X - points[i].X)/(points[j].Y - points[i].Y);
        }
        else    // Horizontal
        {
            Directions[i] = EdgeHorizontal;
            Y1[i] = points[i].Y;
            Y2[i] = points[i].Y;
            X1[i] = points[i].X;
            DxDy[i] = 0;    // It is not used.
        }

        if(points[i].X < Left)
            Left = points[i].X;
        else if(points[i].X > Right)
            Right = points[i].X;

        if(points[i].Y < Top)
            Top = points[i].Y;
        else if(points[i].Y > Bottom)
            Bottom = points[i].Y;
    }
}

// Get the x-spans of a quad and returns the number of
// pairs of x-spans.

INT
GpQuadAnalyzer::GetXSpans(REAL* xSpans, REAL y)
{
    if(y < Top || y >= Bottom)
        return 0;

    INT count = 0;

    for(INT i = 0; i < 4; i++)
    {        
        if(Directions[i] != EdgeHorizontal && y >= Y1[i] && y < Y2[i])
            xSpans[count++] = X1[i] + DxDy[i]*(y - Y1[i]);
    }

    return (count >> 1);
}

VOID
GpBilinearTransform::Initialize()
{
    GpMemset(&SrcRect, 0, sizeof(GpRectF));
    GpMemset(&DstBounds, 0, sizeof(GpRectF));
    GpMemset(&A, 0, sizeof(GpPointF));
    GpMemset(&B, 0, sizeof(GpPointF));
    GpMemset(&C, 0, sizeof(GpPointF));
    GpMemset(&D, 0, sizeof(GpPointF));

    C_VV = C_V = 0;

    FixedValue = -1.0f;

#ifdef TEST_QUADTRANSFORMS
    // For testing purpose only.

    GpMemset(&Verteces[0], 0, 4*sizeof(GpPointF));

#endif
}

/**************************************************************************\
*
*     P0         P1
*     ------------
*     |           \
*     |            \
*     |             \
*     |              \
*     ----------------\
*     P2              P3
*
\**************************************************************************/

GpStatus
GpBilinearTransform::SetBilinearTransform(
    const GpRectF& rect,
    const GpPointF* points,
    INT count,
    REAL fixed
    )
{
    BOOL test = ((points != NULL) && (count == 3 || count == 4));
    ASSERT(test);

    if(!test)
        return InvalidParameter;

    SrcRect = rect;

    REAL left, right, top, bottom;

    left = right = points[0].X;
    top = bottom = points[0].Y;

    for(INT i = 1; i < count; i++)
    {
        if(points[i].X < left)
            left = points[i].X;
        else if(points[i].X > right)
            right = points[i].X;

        if(points[i].Y < top)
            top = points[i].Y;
        else if(points[i].Y > bottom)
            bottom = points[i].Y;
    }

    GpPointF quad[4];

    quad[0] = points[0];
    quad[1] = points[1];
    quad[3] = points[2];

    if(count == 4)
    {
        A.X = points[0].X - points[1].X - points[2].X + points[3].X;
        A.Y = points[0].Y - points[1].Y - points[2].Y + points[3].Y;

        quad[2] = points[3];
    }
    else
    {
        // This is a palallelogram.

        A.X = 0;
        A.Y = 0;

        // Obtain the fourth vertex.

        REAL x3 = points[1].X + points[2].X - points[0].X;
        REAL y3 = points[1].Y + points[2].Y - points[0].Y;

        if(x3 < left)
            left = x3;
        else if(x3 > right)
            right = x3;

        if(y3 < top)
            top = y3;
        else if(y3 > bottom)
            bottom = y3;

        quad[2].X = x3;
        quad[2].Y = y3;
    }

    B.X = points[1].X - points[0].X;
    B.Y = points[1].Y - points[0].Y;
    C.X = points[2].X - points[0].X;
    C.Y = points[2].Y - points[0].Y;
    D = points[0];

    if(A.X != C.X || A.Y != C.Y)
        C_VV = A.X*C.Y - A.Y*C.X;
    else
        C_VV = 0;
    C_V = B.X*C.Y - B.Y*C.X;

    DstBounds.X = left;
    DstBounds.Y = top;
    DstBounds.Width = right - left;
    DstBounds.Height = bottom - top;

    QAnalyzer.SetQuadAnalyzer(&quad[0]);

    FixedValue = fixed;

#ifdef TEST_QUADTRANSFORMS
    // For testing purpose only.

    GpMemcpy(&Verteces[0], points, count*sizeof(GpPointF));
    if(count == 3)
    {
        // Set the fourth vertex.

        Verteces[3].X = points[1].X + points[2].X - points[0].X;
        Verteces[3].Y = points[1].Y + points[2].Y - points[0].Y;
    }

#endif

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
* Solve the quadratic equation of a branch which reduces
* to x = - c/b when a is very small.  This returns the number of
* appropriate solution which is either 0 or 1.
*
* a x^2 + b x + c = 0.
*
*   12/22/1999 ikkof
*       Created it.
\**************************************************************************/

INT solveQuadraticEquationForQuadTransform(REAL a, REAL b, REAL c, REAL* x)
{
    INT n = 0;
    REAL x1 = 0, x2 = 0;

    if(a != 0)
    {
        REAL D = b*b - 4*a*c;

        if(D > 0)
        {
            n = 2;
            D = REALSQRT(D);

            if(b >= 0)
            {
                x1 = (2*c)/(-b - D);
                x2 = (-b - D)/(2*a);
            }
            else
            {
                x1 = (2*c)/(-b + D);
                x2 = (-b + D)/(2*a);
            }

            if(x1 < 0 || x1 > 1)
            {
                if(x2 >= 0 && x2 <= 1)
                {
                    REAL temp = x1;
                    x1 = x2;
                    x2 = temp;
                }
            }

        }
        else if(D == 0)
        {
            n = 1;
            x1 = - b/(2*a);
        }
    }
    else
    {
        // This is a linear equation.

        if(b != 0)
        {
            n = 1;
            x1 = - c/b;
        }
    }

    x[0] = x1;
    x[1] = x2;

    return n;
}

/**************************************************************************\
*
* Function Description:
*
*   This returns the x-spans of the current quad at given y
*   between xmin and xmax.
*
* Arguments:
*
*   [OUT] xSpans    - the x-spans
*   [IN] y          - y-coordinate to evaluate.
*   [IN] xmin       - the minimum x (inclusive)
*   [IN] xmax       - the maximum x (exclusive)
*
* Return Value:
*
*   INT - Retuns the number of x-span pairs (0, 1, or 2).
*
* Created:
*
*   01/04/2000 ikkof
*
\**************************************************************************/

INT
GpBilinearTransform::GetXSpans(
    INT* xSpans,
    INT y,
    INT xmin,
    INT xmax
    )
{
    REAL realY = TOREAL(y);

    if(
        realY < DstBounds.Y
        || realY >= DstBounds.Y + DstBounds.Height
        || TOREAL(xmax) < DstBounds.X
        || TOREAL(xmin) >= DstBounds.X + DstBounds.Width
     )
        return 0;   // Do the quick rejection.

    REAL x[4];
    INT index = (QAnalyzer.GetXSpans(&x[0], realY) << 1);

    // Sort x in ascending order.

    if(index >= 2)
    {
        for(INT i = 0; i < index - 1; i++)
        {
            for(INT j = i + 1; j < index; j++)
            {
                if(x[j] < x[i])
                {
                    REAL temp = x[i];
                    x[i] = x[j];
                    x[j] = temp;
                }
            }
        }
    }
    else
        return 0;   // No x-span in the given y.

    // Check for the first span.

    if(x[0] >= xmax || x[1] <= xmin)
    {
        x[0] = x[2];
        x[1] = x[3];
        index -= 2;
    }
    else
    {
        x[0] = max(x[0], xmin);
        x[1] = min(x[1], xmax);
    }

    if(index >= 4)
    {
        // Check for the second span

        if(x[2] >= xmax || x[3] <= xmin)
            index -= 2;
        else
        {
            x[2] = max(x[2], xmin);
            x[3] = min(x[3], xmax);
        }
    }

    INT j = 0;

    for(INT i = 0; i < index; i += 2)
    {
        // Use Ceiling for both since xmin is inclusive
        // and xmax is exclusive (hence the real inclusive
        // span is being bounded by Celing and Floor).

        xSpans[j] = GpCeiling(x[i]);
        xSpans[j + 1] = GpCeiling(x[i+1]);
        if(xSpans[j + 1] > xSpans[j])
            j += 2;
    }

    return j/2;
}

BOOL
GpBilinearTransform::GetSourceParameter(
    REAL* u,
    REAL* v,
    const GpPointF& point
    )
{
    if (FixedValue >= 0)
    {
        *u = FixedValue;
        *v = FixedValue;
        return TRUE;
    }
    
    REAL b, c, vv[2];
    GpPointF dD;

    dD.X = D.X - point.X;
    dD.Y = D.Y - point.Y;

    b = C_V + A.X*dD.Y - A.Y*dD.X;
    c = B.X*dD.Y - B.Y*dD.X;

    INT num = solveQuadraticEquationForQuadTransform(C_VV, b, c, &vv[0]);

    if(num == 0)
        return FALSE;

    REAL u1 = 0, v1 = 0, u2 = 0, v2 = 0;

    BOOL firstSolutionOk = FALSE;
    BOOL secondSolutionOk = FALSE;

    firstSolutionOk = TRUE;

    v1 = vv[0];
    REAL denomX = A.X*v1 + B.X;
    REAL denomY = A.Y*v1 + B.Y;

    if(REALABS(denomX) > REALABS(denomY))
    {
        u1 = - (C.X*v1 + dD.X)/denomX;
    }
    else if(REALABS(denomY) > 0)
    {
        u1 = - (C.Y*v1 + dD.Y)/denomY;
    }
    else    // Both denomX and denomY = 0.
        firstSolutionOk = FALSE;

    if(num == 2)
    {
        // Allow 1 % error between 0 and 1.

        if(u1 < -0.02f || u1 > 1.02f || v1 < -0.02f || v1 > 1.02f || !firstSolutionOk)
        {
            // We may be picking a wrong solution.  Evaluate the other.

            secondSolutionOk = TRUE;

            v2 = vv[1];
            denomX = A.X*v2 + B.X;
            denomY = A.Y*v2 + B.Y;
            if(REALABS(denomX) > REALABS(denomY))
            {
                u2 = - (C.X*v2 + dD.X)/denomX;
            }
            else if(REALABS(denomY) > 0)
            {
                u2 = - (C.Y*v2 + dD.Y)/denomY;
            }
            else    // Both denomX and denomY = 0.
                secondSolutionOk = FALSE;

            // Allow 1 % error between 0 and 1.

            if(secondSolutionOk
                && u2 >= - 0.02f && u2 <= 1.02f && v2 >= -0.02f && v2 <= 1.02f)
            {
                REAL temp = u1;
                u1 = u2;
                u2 = temp;

                temp = v1;
                v1 = v2;
                v2 = temp;
            }
            else secondSolutionOk = FALSE;
        }
    }

    if(firstSolutionOk || secondSolutionOk > 0)
    {
        u[0] = u1;
        v[0] = v1;
        u[1] = u2;
        v[1] = v2;

        return TRUE;    // success
    }
    else
        return FALSE;   // no valid parameter.
}


/**************************************************************************\
*
* Function Description:
*
*   This returns the x-spans and uv arrays of the current quad at given y
*   between xmin and xmax.
*
* Arguments:
*
*   [OUT] u         - u-array
*   [OUT] v         - v-array
*   [OUT] xSpans    - the x-spans
*   [IN] y          - y-coordinate to evaluate.
*   [IN] xmin       - the minimum x (inclusive)
*   [IN] xmax       - the maximum x (exclusive)
*
* Return Value:
*
*   INT - Retuns the number of x-span pairs (0, 1, or 2).
*
* Created:
*
*   01/04/2000 ikkof
*
\**************************************************************************/

INT
GpBilinearTransform::GetSourceParameterArrays(
    REAL* u,
    REAL* v,
    INT* xSpans,
    INT y,
    INT xmin,
    INT xmax
    )
{
    ASSERT(u && v && xSpans);

    INT pairCount = GetXSpans(xSpans, y, xmin, xmax);

    INT count = 0;

    REAL u1[2], v1[2];

    GpMemset(&u1[0], 0, 2*sizeof(REAL));
    GpMemset(&v1[0], 0, 2*sizeof(REAL));

    for(INT k = 0; k < pairCount; k++)
    {
        GpPointF destPt;
        destPt.Y = TOREAL(y);
        destPt.X = TOREAL(xSpans[2*k]);

        BOOL firstPoint = TRUE;
        INT width = xSpans[2*k + 1] - xSpans[2*k];

        for(INT i = 0; i < width; i++)
        {
            BOOL success = GetSourceParameter(&u1[0], &v1[0], destPt);
            if(!success)
                WARNING(("There is no solution for quadratic equation."));

            *(u + count) = u1[0];
            *(v + count) = v1[0];

            count++;

            destPt.X += 1;
        }
    }

    return pairCount;
}

/**************************************************************************\
*
* This converts lines to quadratic Beziers.
*
* [IN] points:  the line points
* [IN] count:   the number of line points.
* [OUT] q:      the quadratic Bezier control points.
*
* The array size of q must be larger than or equal to 2*count - 1.
*
\**************************************************************************/

GpStatus
GpBilinearTransform::ConvertLines(
    const GpPointF* points,
    INT count,
    GpPointF* q)
{
    ASSERT(points && q);
    ASSERT(count >= 2);

    REAL mx, my, nx, ny;

    GpPointF pt1, pt2;

    pt1 = points[0];

    INT j = 0;
    for(INT i = 1; i < count; i++)
    {
        pt2 = points[i];
        mx = (pt2.X - pt1.X)/SrcRect.Width;
        my = (pt2.Y - pt1.Y)/SrcRect.Height;
        nx = (pt1.X - SrcRect.X)/SrcRect.Width;
        ny = (pt1.Y - SrcRect.Y)/SrcRect.Height;

        GpPointF c0, c1, c2;
        REAL temp;

        temp = mx*my;
        c2.X = temp*A.X;
        c2.Y = temp*A.Y;
        temp = mx*ny + my*nx;
        c1.X = temp*A.X + mx*B.X + my*C.X;
        c1.Y = temp*A.Y + mx*B.Y + my*C.Y;
        temp = nx*ny;
        c0.X = temp*A.X + nx*B.X + ny*C.X + D.X;
        c0.Y = temp*A.Y + nx*B.Y + ny*C.Y + D.Y;

        if(j == 0)
            q[j++] = c0;
        q[j].X = c0.X + c1.X/2;
        q[j++].Y = c0.Y + c1.Y/2;
        q[j].X = c0.X + c1.X + c2.X;
        q[j++].Y = c0.Y + c1.Y + c2.Y;

        pt1 = pt2;
    }

    return Ok;
}
    

/**************************************************************************\
*
* This converts lines to quadratic Beziers.
*
* [IN] points:  the line points
* [IN] count:   the number of line points.
* [OUT] data:   the quadratic Bezier control points.
*
* The array size of q must be larger than or equal to 2*(2*count - 1).
*
\**************************************************************************/

GpStatus
GpBilinearTransform::ConvertLines(
    const GpPointF* points,
    INT count,
    REALD* data)
{
    ASSERT(points && data);
    ASSERT(count >= 2);

    REALD mx, my, nx, ny;

    GpPointF pt1, pt2;

    pt1 = points[0];

    INT j = 0;
    for(INT i = 1; i < count; i++)
    {
        pt2 = points[i];
        mx = (pt2.X - pt1.X)/SrcRect.Width;
        my = (pt2.Y - pt1.Y)/SrcRect.Height;
        nx = (pt1.X - SrcRect.X)/SrcRect.Width;
        ny = (pt1.Y - SrcRect.Y)/SrcRect.Height;

        GpPointD c0, c1, c2;
        REALD temp;

        temp = mx*my;
        c2.X = temp*A.X;
        c2.Y = temp*A.Y;
        temp = mx*ny + my*nx;
        c1.X = temp*A.X + mx*B.X + my*C.X;
        c1.Y = temp*A.Y + mx*B.Y + my*C.Y;
        temp = nx*ny;
        c0.X = temp*A.X + nx*B.X + ny*C.X + D.X;
        c0.Y = temp*A.Y + nx*B.Y + ny*C.Y + D.Y;

        if(j == 0)
        {
            *data++ = c0.X;
            *data++ = c0.Y;
            j++;
        }

        *data++ = c0.X + c1.X/2;
        *data++ = c0.Y + c1.Y/2;

        *data++ = c0.X + c1.X + c2.X;
        *data++ = c0.Y + c1.Y + c2.Y;

        j += 2;

        pt1 = pt2;
    }

    return Ok;
}
    

/**************************************************************************\
*
* This converts cubic Beziers to 6-th order Beziers.
*
* [IN] points:  the cubic Bezier control points
* [IN] count:   the number of the control points.
* [OUT] q:      the 6-th order Bezier control points.
*
* The array size of q must be larger than or equal to 2*count - 1.
*
\**************************************************************************/

GpStatus
GpBilinearTransform::ConvertCubicBeziers(
    const GpPointF* srcQ,
    INT count,
    GpPointF* q
    )
{
    ASSERT(srcQ && q);
    ASSERT(count > 3 && (count % 3 == 1));
    
    GpPointF a0, a1, a2, a3;

    INT j = 0;
    for(INT i = 1; i < count; i += 3)
    {
        a0.X = (srcQ[i - 1].X - SrcRect.X)/SrcRect.Width;
        a0.Y = (srcQ[i - 1].Y - SrcRect.Y)/SrcRect.Height;
        a1.X = 3*(srcQ[i].X - srcQ[i - 1].X)/SrcRect.Width;
        a1.Y = 3*(srcQ[i].Y - srcQ[i - 1].Y)/SrcRect.Height;
        a2.X = 3*(srcQ[i - 1].X - srcQ[i].X - srcQ[i].X + srcQ[i + 1].X)/SrcRect.Width;
        a2.Y = 3*(srcQ[i - 1].Y - srcQ[i].Y - srcQ[i].Y + srcQ[i + 1].Y)/SrcRect.Height;
        a3.X = (srcQ[i + 2].X - srcQ[i - 1].X + 3*(srcQ[i].X - srcQ[i + 1].X))/SrcRect.Width;
        a3.Y = (srcQ[i + 2].Y - srcQ[i - 1].Y + 3*(srcQ[i].Y - srcQ[i + 1].Y))/SrcRect.Height;

        REAL temp;
        GpPointF c[7];

        temp = a3.X*a3.Y;
        c[6].X = temp*A.X;
        c[6].Y = temp*A.Y;
    
        temp = a3.X*a2.Y + a2.X*a3.Y;
        c[5].X = temp*A.X;
        c[5].Y = temp*A.Y;

        temp = a3.X*a1.Y + a2.X*a2.Y + a1.X*a3.Y;
        c[4].X = temp*A.X;
        c[4].Y = temp*A.Y;

        temp = a3.X*a0.Y + a2.X*a1.Y + a1.X*a2.Y + a0.X*a3.Y;
        c[3].X = temp*A.X + a3.X*B.X + a3.Y*C.X;
        c[3].Y = temp*A.Y + a3.X*B.Y + a3.Y*C.Y;

        temp = a2.X*a0.Y + a1.X*a1.Y + a0.X*a2.Y;
        c[2].X = temp*A.X + a2.X*B.X + a2.Y*C.X;
        c[2].Y = temp*A.Y + a2.X*B.Y + a2.Y*C.Y;

        temp = a1.X*a0.Y + a0.X*a1.Y;
        c[1].X = temp*A.X + a1.X*B.X + a1.Y*C.X;
        c[1].Y = temp*A.Y + a1.X*B.Y + a1.Y*C.Y;

        temp = a0.X*a0.Y;
        c[0].X = temp*A.X + a0.X*B.X + a0.Y*C.X + D.X;
        c[0].Y = temp*A.Y + a0.X*B.Y + a0.Y*C.Y + D.Y;

        if(j == 0)
            q[j++] = c[0];
        q[j].X = c[0].X + c[1].X/6;
        q[j++].Y = c[0].Y + c[1].Y/6;
        q[j].X = c[0].X + c[1].X/3 + c[2].X/15;
        q[j++].Y = c[0].Y + c[1].Y/3 + c[2].Y/15;
        q[j].X = c[0].X + c[1].X/2 + c[2].X/5 + c[3].X/20;
        q[j++].Y = c[0].Y + c[1].Y/2 + c[2].Y/5 + c[3].Y/20;
        q[j].X = c[0].X + 2*c[1].X/3 + 2*c[2].X/5 + c[3].X/5 + c[4].X/15;
        q[j++].Y = c[0].Y + 2*c[1].Y/3 + 2*c[2].Y/5 + c[3].Y/5 + c[4].Y/15;
        q[j].X = c[0].X + 5*c[1].X/6 + 2*c[2].X/3 + c[3].X/2 + c[4].X/3 + c[5].X/6;
        q[j++].Y = c[0].Y + 5*c[1].Y/6 + 2*c[2].Y/3 + c[3].Y/2 + c[4].Y/3 + c[5].Y/6;
        q[j].X = c[0].X + c[1].X + c[2].X + c[3].X + c[4].X + c[5].X + c[6].X;
        q[j++].Y = c[0].Y + c[1].Y + c[2].Y + c[3].Y + c[4].Y + c[5].Y + c[6].Y;
    }

    return Ok;
}

/**************************************************************************\
*
* This converts cubic Beziers to 6-th order Beziers.
*
* [IN] points:  the cubic Bezier control points
* [IN] count:   the number of the control points.
* [OUT] q:      the 6-th order Bezier control points.
*
* The array size of q must be larger than or equal to 2*count - 1.
*
\**************************************************************************/

GpStatus
GpBilinearTransform::ConvertCubicBeziers(
    const GpPointF* srcQ,
    INT count,
    REALD* data
    )
{
    ASSERT(srcQ && data);
    ASSERT(count > 3 && (count % 3 == 1));
    
    GpPointD a0, a1, a2, a3;

    INT j = 0;
    for(INT i = 1; i < count; i += 3)
    {
        a0.X = (srcQ[i - 1].X - SrcRect.X)/SrcRect.Width;
        a0.Y = (srcQ[i - 1].Y - SrcRect.Y)/SrcRect.Height;
        a1.X = 3*(srcQ[i].X - srcQ[i - 1].X)/SrcRect.Width;
        a1.Y = 3*(srcQ[i].Y - srcQ[i - 1].Y)/SrcRect.Height;
        a2.X = 3*(srcQ[i - 1].X - srcQ[i].X - srcQ[i].X + srcQ[i + 1].X)/SrcRect.Width;
        a2.Y = 3*(srcQ[i - 1].Y - srcQ[i].Y - srcQ[i].Y + srcQ[i + 1].Y)/SrcRect.Height;
        a3.X = (srcQ[i + 2].X - srcQ[i - 1].X + 3*(srcQ[i].X - srcQ[i + 1].X))/SrcRect.Width;
        a3.Y = (srcQ[i + 2].Y - srcQ[i - 1].Y + 3*(srcQ[i].Y - srcQ[i + 1].Y))/SrcRect.Height;

        REALD temp;
        GpPointD c[7];

        temp = a3.X*a3.Y;
        c[6].X = temp*A.X;
        c[6].Y = temp*A.Y;
    
        temp = a3.X*a2.Y + a2.X*a3.Y;
        c[5].X = temp*A.X;
        c[5].Y = temp*A.Y;

        temp = a3.X*a1.Y + a2.X*a2.Y + a1.X*a3.Y;
        c[4].X = temp*A.X;
        c[4].Y = temp*A.Y;

        temp = a3.X*a0.Y + a2.X*a1.Y + a1.X*a2.Y + a0.X*a3.Y;
        c[3].X = temp*A.X + a3.X*B.X + a3.Y*C.X;
        c[3].Y = temp*A.Y + a3.X*B.Y + a3.Y*C.Y;

        temp = a2.X*a0.Y + a1.X*a1.Y + a0.X*a2.Y;
        c[2].X = temp*A.X + a2.X*B.X + a2.Y*C.X;
        c[2].Y = temp*A.Y + a2.X*B.Y + a2.Y*C.Y;

        temp = a1.X*a0.Y + a0.X*a1.Y;
        c[1].X = temp*A.X + a1.X*B.X + a1.Y*C.X;
        c[1].Y = temp*A.Y + a1.X*B.Y + a1.Y*C.Y;

        temp = a0.X*a0.Y;
        c[0].X = temp*A.X + a0.X*B.X + a0.Y*C.X + D.X;
        c[0].Y = temp*A.Y + a0.X*B.Y + a0.Y*C.Y + D.Y;

        if(j == 0)
        {
            *data++ = c[0].X;
            *data++ = c[0].Y;
            j++;
        }

        *data++ = c[0].X + c[1].X/6;
        *data++ = c[0].Y + c[1].Y/6;

        *data++ = c[0].X + c[1].X/3 + c[2].X/15;
        *data++ = c[0].Y + c[1].Y/3 + c[2].Y/15;

        *data++ = c[0].X + c[1].X/2 + c[2].X/5 + c[3].X/20;
        *data++ = c[0].Y + c[1].Y/2 + c[2].Y/5 + c[3].Y/20;

        *data++ = c[0].X + 2*c[1].X/3 + 2*c[2].X/5 + c[3].X/5 + c[4].X/15;
        *data++ = c[0].Y + 2*c[1].Y/3 + 2*c[2].Y/5 + c[3].Y/5 + c[4].Y/15;
        
        *data++ = c[0].X + 5*c[1].X/6 + 2*c[2].X/3 + c[3].X/2 + c[4].X/3 + c[5].X/6;
        *data++ = c[0].Y + 5*c[1].Y/6 + 2*c[2].Y/3 + c[3].Y/2 + c[4].Y/3 + c[5].Y/6;
        
        *data++ = c[0].X + c[1].X + c[2].X + c[3].X + c[4].X + c[5].X + c[6].X;
        *data++ = c[0].Y + c[1].Y + c[2].Y + c[3].Y + c[4].Y + c[5].Y + c[6].Y;

        j += 6;    
    }

    return Ok;
}


/**************************************************************************\
*
*     P0         P1
*     ------------
*     |           \
*     |            \
*     |             \
*     |              \
*     ----------------\
*     P2              P3
*
\**************************************************************************/

GpPerspectiveTransform::GpPerspectiveTransform(
    const GpRectF& rect,
    const GpPointF* pts,
    INT count
    )
{
    ASSERT(count == 3 || count == 4)
    
    SrcRect = rect;

    REAL left, right, top, bottom;

    left = right = pts[0].X;
    top = bottom = pts[0].Y;

    for(INT i = 1; i < count; i++)
    {
        if(pts[i].X < left)
            left = pts[i].X;
        else if(pts[i].X > right)
            right = pts[i].X;

        if(pts[i].Y < top)
            top = pts[i].Y;
        else if(pts[i].Y > bottom)
            bottom = pts[i].Y;
    }

    if(count == 4)
    {
        REAL dx1, dx2, dy1, dy2;
        REAL sx, sy, det;

        dx1 = pts[1].X - pts[3].X;
        dy1 = pts[1].Y - pts[3].Y;
        dx2 = pts[2].X - pts[3].X;
        dy2 = pts[2].Y - pts[3].Y;
        sx = pts[0].X - pts[1].X - pts[2].X + pts[3].X;
        sy = pts[0].Y - pts[1].Y - pts[2].Y + pts[3].Y;
        det = dx1*dy2 - dy1*dx2;
        M02 = (sx*dy2 - sy*dx2)/det;
        M12 = (dx1*sy - dy1*sx)/det;
    }
    else
    {
        // This is a palallelogram.

        M02 = 0;
        M12 = 0;

        // Obtain the fourth vertex.

        REAL x3 = pts[1].X + pts[2].X - pts[0].X;
        REAL y3 = pts[1].Y + pts[2].Y - pts[0].Y;

        if(x3 < left)
            left = x3;
        else if(x3 > right)
            right = x3;

        if(y3 < top)
            top = y3;
        else if(y3 > bottom)
            bottom = y3;
    }

    M00 = pts[1].X - pts[0].X + M02*pts[1].X;
    M01 = pts[1].Y - pts[0].Y + M02*pts[1].Y;
    M10 = pts[2].X - pts[0].X + M12*pts[2].X;
    M11 = pts[2].Y - pts[0].Y + M12*pts[2].Y;
    M20 = pts[0].X;
    M21 = pts[0].Y;
    M22 = 1;

    DstBounds.X = left;
    DstBounds.Y = top;
    DstBounds.Width = right - left;
    DstBounds.Height = bottom - top;
}


/**************************************************************************\
*
* This converts the points to the perspective points
*
* [IN] points:  the point data
* [IN] count:   the number of points.
* [OUT] q:      the perspective point data.
*
* The array size of q must be larger than or equal to count.
*
\**************************************************************************/

GpStatus
GpPerspectiveTransform::ConvertPoints(
    const GpPointF* points,
    INT count,
    GpPoint3F* q
    )
{
    ASSERT(points && q);
    ASSERT(count > 0);

    const GpPointF* pts = points;
    GpPoint3F* qPts = q;

    while(count > 0)
    {
        REAL u, v;

        u = (pts->X - SrcRect.X)/SrcRect.Width;
        v = (pts->Y - SrcRect.Y)/SrcRect.Height;

        qPts->X = u*M00 + v*M10 + M20;
        qPts->Y = u*M01 + v*M11 + M21;
        qPts->Z = u*M02 + v*M12 + 1;

        pts++;
        qPts++;
        count--;
    }

    return Ok;
}
    

/**************************************************************************\
*
* This converts the points to the perspective points
*
* [IN] points:  the point data
* [IN] count:   the number of points.
* [OUT] xpoints: the perspective point data.
*
*
\**************************************************************************/

GpStatus
GpPerspectiveTransform::ConvertPoints(
    const GpPointF* points,
    INT count,
    GpXPoints* xpoints
    )
{

    ASSERT(points && xpoints && count > 0);
    
    if(!points || !xpoints || count <= 0)
        return InvalidParameter;

    REALD* data = xpoints->Data;
/*
    REALD* data = (REALD*) GpMalloc(3*count*sizeof(REALD));


    if(!data)
        return OutOfMemory;

    // Use this data for xpoints.

    xpoints->SetData(data, 3, count, FALSE);
*/
 
    const GpPointF* pts = points;

    while(count > 0)
    {
        REAL u, v;

        u = (pts->X - SrcRect.X)/SrcRect.Width;
        v = (pts->Y - SrcRect.Y)/SrcRect.Height;

        *data++ = u*M00 + v*M10 + M20;
        *data++ = u*M01 + v*M11 + M21;
        *data++ = u*M02 + v*M12 + 1;

        pts++;
        count--;
    }

    return Ok;
}


class GpQuadData
{
    GpBilinearTransform BLTransform;
    GpQuadData();
    GpStatus SetQuad(
        const GpRectF& rect,
        const GpPointF* points
        );

    GpStatus OutputSpan(ARGB* buffer, INT compositingMode,
                INT y, INT &xMin, INT &xMax);
};

GpStatus
GpQuadData::SetQuad(
    const GpRectF& rect,
    const GpPointF* points
    )
{
    return BLTransform.SetBilinearTransform(rect, points, 4);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\quadtransforms.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Abstract:
*
*   Quad Transforms
*
* History:
*
*   03/17/1999 ikkof
*       Created it.
*
\**************************************************************************/

#ifndef _QUADTRAMSFOPRMS_HPP
#define _QUADTRAMSFOPRMS_HPP

//#define TEST_QUADTRANSFORMS

class GpXPoints;

class GpQuadAnalyzer
{
public:
    GpQuadAnalyzer() {Initialize();}
    VOID SetQuadAnalyzer(const GpPointF* points);
    INT GetXSpans(REAL* xSpans, REAL y);

protected:
    VOID Initialize()
    {
        Top = Bottom = Left = Right = 0;
        GpMemset(&Y1[0], 0, 4*sizeof(REAL));
        GpMemset(&Y2[0], 0, 4*sizeof(REAL));
        GpMemset(&Directions[0], 0, 4);
        GpMemset(&DxDy[0], 0, 4*sizeof(REAL));
    }

protected:
    REAL Top;
    REAL Bottom;
    REAL Left;
    REAL Right;

    REAL Y1[4];
    REAL Y2[4];
    BYTE Directions[4];
    REAL X1[4];
    REAL DxDy[4];
};

class GpBilinearTransform
{
protected:
    GpRectF SrcRect;
    GpRectF DstBounds;
    GpPointF A;
    GpPointF B;
    GpPointF C;
    GpPointF D;

    REAL C_VV;
    REAL C_V;

    GpQuadAnalyzer QAnalyzer;

    REAL FixedValue;   // Set to positive number if this transform
                       // represents a single fixed value over its
                       // entire area.

#ifdef TEST_QUADTRANSFORMS
    // For testing purpose only.

    GpPointF Verteces[4];

#endif

public:
    GpBilinearTransform() {Initialize();}
    GpBilinearTransform(const GpRectF& rect, const GpPointF* points, INT count)
    {
        Initialize();
        SetBilinearTransform(rect, points, count);
    }

    GpStatus ConvertLines(const GpPointF* points, INT count, GpPointF* q);
    GpStatus ConvertLines(const GpPointF* points, INT count, REALD* data);
    GpStatus ConvertCubicBeziers(const GpPointF* srcQ, INT count, GpPointF* q);
    GpStatus ConvertCubicBeziers(const GpPointF* srcQ, INT count, REALD* data);
    GpStatus SetBilinearTransform(const GpRectF& rect, const GpPointF* points, INT count, REAL fixed=-1.0f);
    INT GetSourceParameterArrays(
            REAL* u,
            REAL* v,
            INT* xSpans,
            INT y,
            INT xmin,
            INT xmax
            );

protected:
    VOID Initialize();
    INT GetXSpans(INT* xSpans, INT y, INT xmin, INT xmax);
    BOOL GetSourceParameter(REAL* u, REAL* v, const GpPointF& point);
};

class GpPerspectiveTransform
{
protected:
    GpRectF SrcRect;
    GpRectF DstBounds;
    REAL M00, M01, M02;
    REAL M10, M11, M12;
    REAL M20, M21, M22;

public:
    GpPerspectiveTransform(const GpRectF& rect, const GpPointF* points, INT count);
    GpStatus ConvertPoints(const GpPointF* points, INT count, GpPoint3F* q);
    GpStatus ConvertPoints(const GpPointF* points, INT count, GpXPoints* xpoints);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\pen.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Abstract:
*
*   Pen API related declarations
*
* Revision History:
*
*   12/09/1998 andrewgo
*       Flesh out pen interfaces.
*
*   12/08/1998 andrewgo
*       Created it.
*
\**************************************************************************/

#ifndef _PEN_HPP
#define _PEN_HPP

//--------------------------------------------------------------------------
// Abstract base class for various pen types
//--------------------------------------------------------------------------

class GpLineTexture;
class GpCustomLineCap;

class GpPen : public GpObject
{
protected:
    VOID SetValid(BOOL valid)
    {
        GpObject::SetValid(valid ? ObjectTagPen : ObjectTagInvalid);
    }

public:

    // Constructors

    GpPen(
        const GpColor& color,
        REAL penWidth,
        GpUnit unit = UnitWorld
        );

    GpPen(
        const GpBrush* brush,
        REAL penWidth,
        GpUnit = UnitWorld
        );

    GpPen(
        GpLineTexture* lineTexture,
        REAL penWidth,
        GpUnit = UnitWorld
        );

    // Make a copy of the pen object

    GpPen* Clone();

    // Virtual destructor

    virtual ~GpPen()
    {
        if(Brush)
            delete Brush;

        if(DevicePen.CustomStartCap)
            delete DevicePen.CustomStartCap;

        if(DevicePen.CustomEndCap)
            delete DevicePen.CustomEndCap;

        GpFree(DevicePen.DashArray);
        GpFree(DevicePen.CompoundArray);
    }

    // Get the lock object

    GpLockable *GetObjectLock() const
    {
        return &Lockable;
    }

    // Check if the pen object is valid

    virtual BOOL IsValid() const
    {
        return GpObject::IsValid(ObjectTagPen);
    }

    // Determine if pens are equivalent

    virtual BOOL IsEqual(const GpPen * pen) const;

    virtual ObjectType GetObjectType() const { return ObjectTypePen; }

    virtual UINT GetDataSize() const;
    virtual GpStatus GetData(IStream * stream) const;
    virtual GpStatus SetData(const BYTE * dataBuffer, UINT size);

    virtual GpStatus ColorAdjust(
        GpRecolor *             recolor,
        ColorAdjustType         type
        );

    // Set/get fill attributes

    VOID Set(
        const GpColor& color,
        REAL penWidth,
        GpUnit = UnitWorld
        );

    GpStatus SetColor(GpColor* color);

    GpStatus GetColor(ARGB *argb) const;

    GpStatus SetBrush(GpBrush* brush);

    GpBrush* GetBrush()
    {
        return Brush;
    }

    GpBrush* GetClonedBrush()
    {
        if(Brush)
        {
            return Brush->Clone();
        }
        else
            return NULL;
    }

    GpPenType GetPenType();

    GpStatus SetLineTexture(GpLineTexture* lineTexture);
    GpLineTexture* GetLineTexture();

    // Set/get pen transform

    GpStatus SetTransform(const GpMatrix& matrix)
    {
        GpStatus    status = Ok;

        // Keep the transform invertible

        if (matrix.IsInvertible())
        {
            DevicePen.Xform = matrix;
            UpdateUid();
        }
        else
            status = InvalidParameter;

        return status;
    }

    GpStatus GetTransform(GpMatrix* matrix) const
    {
        *matrix = DevicePen.Xform;

        return Ok;
    }

    GpStatus ResetTransform()
    {
        if (!DevicePen.Xform.IsIdentity())
        {
            DevicePen.Xform.Reset();
            UpdateUid();
        }

        return Ok;
    }

    GpStatus MultiplyTransform(const GpMatrix& matrix,
                                    GpMatrixOrder order = MatrixOrderPrepend);

    GpStatus TranslateTransform(REAL dx, REAL dy,
                                    GpMatrixOrder order = MatrixOrderPrepend)
    {
        DevicePen.Xform.Translate(dx, dy, order);
        UpdateUid();

        return Ok;
    }

    GpStatus ScaleTransform(REAL sx, REAL sy,
                                    GpMatrixOrder order = MatrixOrderPrepend)
    {
        DevicePen.Xform.Scale(sx, sy, order);
        UpdateUid();

        return Ok;
    }

    GpStatus RotateTransform(REAL angle,
                                    GpMatrixOrder order = MatrixOrderPrepend)
    {
        DevicePen.Xform.Rotate(angle, order);
        UpdateUid();

        return Ok;
    }

    // See if the pen has a non-identity transform.
    BOOL HasTransform() const
    {
        return !DevicePen.Xform.IsIdentity();
    }

    // Set/get line caps: start, end, and dash

    VOID SetStartCap(GpLineCap startCap)
    {
        DevicePen.StartCap = startCap;
        if(DevicePen.CustomStartCap)
        {
            delete DevicePen.CustomStartCap;
            DevicePen.CustomStartCap = NULL;
        }
        UpdateUid();
    }

    VOID SetEndCap(GpLineCap endCap)
    {
        DevicePen.EndCap = endCap;
        if(DevicePen.CustomEndCap)
        {
            delete DevicePen.CustomEndCap;
            DevicePen.CustomEndCap = NULL;
        }
        UpdateUid();
    }

    GpLineCap GetStartCap() const
    {
        return DevicePen.StartCap;
    }

    GpLineCap GetEndCap() const
    {
        return DevicePen.EndCap;
    }

    VOID SetLineCap(GpLineCap startCap, GpLineCap endCap, GpDashCap dashCap)
    {
        DevicePen.StartCap = startCap;
        DevicePen.EndCap = endCap;
        SetDashCap(dashCap);
        UpdateUid();
    }

    GpStatus SetCustomStartCap(const GpCustomLineCap* customCap);
    GpStatus GetCustomStartCap(GpCustomLineCap** customCap);
    GpStatus SetCustomEndCap(const GpCustomLineCap* customCap);
    GpStatus GetCustomEndCap(GpCustomLineCap** customCap);

    // Set/get line join

    VOID SetLineJoin(GpLineJoin lineJoin)
    {
        DevicePen.Join = lineJoin;
        UpdateUid();
    }

    GpLineJoin GetLineJoin() const
    {
        return DevicePen.Join;
    }

    VOID SetMiterLimit(REAL miterLimit)
    {
        DevicePen.MiterLimit = max(1.0f, miterLimit);
        UpdateUid();
    }

    REAL GetMiterLimit() const
    {
        return DevicePen.MiterLimit;
    }

    GpStatus SetPenAlignment(GpPenAlignment penMode)
    {
        // Compound Inset pens aren't implemented yet.
        // The code for correctly handling minimum width compound sub lines
        // is missing.
        
        if((penMode==PenAlignmentInset) && 
           (DevicePen.CompoundCount!=0))
        {
            return NotImplemented;
        }
        
        DevicePen.PenAlignment = penMode;
        UpdateUid();
        
        return Ok;
    }

    GpPenAlignment GetPenAlignment() const
    {
        return DevicePen.PenAlignment;
    }

    // Set/get dash attributes

    GpDashStyle GetDashStyle() const
    {
        return DevicePen.DashStyle;
    }

    GpDashCap GetDashCap() const
    {
    	// Note: Internally we use a GpLineCap type to store the dash cap type.
    	// So we need to convert between GpLineCap and GpDashCap.
    	// However, we should change the internal usage to GpDashCap in v2.
    	// - JBronsk
    	GpDashCap dashCap = DashCapFlat;
    	switch (DevicePen.DashCap)
    	{
    	case LineCapRound:
    		dashCap = DashCapRound;
    		break;
    	case LineCapTriangle:
    		dashCap = DashCapTriangle;
    		break;
    	// all others map to DashCapFlat
    	}
        return dashCap;
    }
 
    VOID SetDashCap(GpDashCap dashCap);

    GpStatus SetDashStyle(GpDashStyle dashStyle);

    VOID SetDashOffset(REAL dashOffset)
    {
        DevicePen.DashOffset = dashOffset;
        UpdateUid();
    }

    REAL GetDashOffset() const
    {
        return DevicePen.DashOffset;
    }

    INT GetDashCount() const
    {
        return DevicePen.DashCount;
    }

    GpStatus GetDashArray(REAL* dashArray, INT count) const;

    DpPen * GetDevicePen()
    {
        return & DevicePen;
    }

    VOID SetWidth(REAL penWidth)
    {
        DevicePen.Width = penWidth;
        UpdateUid();
    }


    REAL GetWidth() const
    {
        return DevicePen.Width;
    }

    REAL GetMaximumJoinWidth(
            REAL sharpestAngle,
            const GpMatrix* matrix,
            REAL dpiX,
            REAL dpiY) const;

    REAL GetMaximumCapWidth(
            const GpMatrix* matrix,
            REAL dpiX,
            REAL dpiY) const;

    VOID SetUnit(GpUnit unit)
    {
        // UnitDisplay is device-dependent and cannot be used for a pen size
        ASSERT(unit != UnitDisplay);

        DevicePen.Unit = unit;
        UpdateUid();
    }

    GpUnit GetUnit() const
    {
        return DevicePen.Unit;
    }

    GpStatus SetDashArray(const REAL* dashArray, INT count);

    INT GetCompoundCount() const
    {
        return DevicePen.CompoundCount;
    }

    GpStatus SetCompoundArray(const REAL* compoundArray, INT count);

    GpStatus GetCompoundArray(REAL* compoundArray, INT count);

    BOOL IsOpaque() const
    {
        return Brush->IsOpaque();
    }

    BOOL IsSolid() const
    {
        return Brush->IsSolid();
    }

    COLORREF ToCOLORREF() const
    {
        return Brush->ToCOLORREF();
    }

    REAL GetCapDelta();

    static GpPen * GetPen(const DpPen * pen)
    {
        return (GpPen *) ((BYTE *) pen - offsetof(GpPen, DevicePen));
    }

    static REAL ComputeMiterLength(
        REAL angle,
        REAL miterLimit
    );

    VOID
    AdjustDashArrayForCaps(
        REAL dashUnit,
        REAL *dashArray,
        INT dashCount
        ) const;

    REAL
    GetDashCapInsetLength(
        REAL dashUnit
        ) const;
        
private:

    VOID InitDefaultState(REAL penWidth, GpUnit unit);
    GpStatus SetDashStyleWithDashCap(GpDashStyle dashStyle, GpLineCap dashCap);

    // GetMaximumWidth is used only for UnitWorld.

    GpStatus GetMaximumWidth(REAL* width, const GpMatrix* matrix) const;

protected:

    mutable GpLockable Lockable;

    GpBrush *   Brush;

    DpPen       DevicePen;

    GpPen()
    {
        DevicePen.InitDefaults();
        SetValid(TRUE);
    }

    GpPen(const GpPen* pen);
};


#endif _PEN_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\region.cpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   Region.cpp
*
* Abstract:
*
*   Implementation of GpRegion class
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/

#include "precomp.hpp"

#define COMBINE_STEP_SIZE   4   // takes 2 for each combine operation

LONG_PTR GpObject::Uniqueness = (0xdbc - 1);   // for setting Uid of Objects

/**************************************************************************\
*
* Function Description:
*
*   Default constructor.  Sets the default state of the region to
*   be infinite.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/
GpRegion::GpRegion()
{
    SetValid(TRUE);     // default is valid

    // Default is infinite
    RegionOk = TRUE;

    Type = TypeInfinite;
}

/**************************************************************************\
*
* Function Description:
*
*   Constructor.  Sets the region to the specified rect.
*
* Arguments:
*
*   [IN] rect - rect to initialize the region to
*
* Return Value:
*
*   NONE
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/
GpRegion::GpRegion(
    const GpRectF *       rect
    )
{
    ASSERT(rect != NULL);

    SetValid(TRUE);     // default is valid

    RegionOk = FALSE;

    X      = rect->X;
    Y      = rect->Y;
    Width  = rect->Width;
    Height = rect->Height;
    Type   = TypeRect;
}

/**************************************************************************\
*
* Function Description:
*
*   Constructor.  Sets the region to a copy of the specified path.
*
* Arguments:
*
*   [IN] path - path to initialize the region to
*
* Return Value:
*
*   NONE
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/
GpRegion::GpRegion(
    const GpPath *          path
    )
{
    ASSERT(path != NULL);

    SetValid(TRUE);     // default is valid

    RegionOk = FALSE;

    Lazy = FALSE;
    Path = path->Clone();
    Type = (Path != NULL) ? TypePath : TypeNotValid;
}

/**************************************************************************\
*
* Function Description:
*
*   Constructor.  Sets the region using the specified region data buffer.
*
* Arguments:
*
*   [IN] regionDataBuffer - should contain data that describes the region
*
* Return Value:
*
*   NONE
*
* Created:
*
*   9/3/1999 DCurtis
*
\**************************************************************************/
GpRegion::GpRegion(
    const BYTE *    regionDataBuffer,
    UINT            size
    )
{
    ASSERT(regionDataBuffer != NULL);

    SetValid(TRUE);     // default is valid

    RegionOk = FALSE;
    Type     = TypeEmpty;   // so FreePathData works correctly

    if (this->SetExternalData(regionDataBuffer, size) != Ok)
    {
        Type = TypeNotValid;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Constructor.  Sets the region to a copy of the specified path.
*
* Arguments:
*
*   [IN] region - region to initialize the region to
*
* Return Value:
*
*   NONE
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/
GpRegion::GpRegion(
    const GpRegion *    region,
    BOOL                lazy
    )
{
    SetValid(TRUE);     // default is valid

    RegionOk = FALSE;

    // We set the type here to avoid the assert in GpRegion::Set when the
    // uninitialized Type is equal to TypeNotValid
    Type = TypeEmpty;

    Set(region, lazy);
}

/**************************************************************************\
*
* Function Description:
*
*   Destructor.  Frees any copied path data associated with the region.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/
GpRegion::~GpRegion()
{
    FreePathData();
}

/**************************************************************************\
*
* Function Description:
*
*   When a region is created from a path, a copy of that path is stored in
*   the region.  This method frees up any of those copies that have been
*   saved in the region.
*
*   It also resets the CombineData back to having no children.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/
VOID
GpRegion::FreePathData()
{
    if (Type == TypePath)
    {
        if (!Lazy)
        {
            delete Path;
        }
    }
    else
    {
        INT     count = CombineData.GetCount();

        if (count > 0)
        {
            RegionData *    data = CombineData.GetDataBuffer();
            ASSERT (data != NULL);

            do
            {
                if ((data->Type == TypePath) && (!data->Lazy))
                {
                    delete data->Path;
                }
                data++;

            } while (--count > 0);
        }
        CombineData.Reset();
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Set the region to the specified rectangle.
*
* Arguments:
*
*   [IN]  rect - the rect, in world units
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/
VOID
GpRegion::Set(
    REAL    x, 
    REAL    y, 
    REAL    width, 
    REAL    height
    )
{
    ASSERT(IsValid());

    // handle flipped rects
    if (width < 0)
    {
        x += width;
        width = -width;
    }
    
    if (height < 0)
    {
        y += height;
        height = -height;
    }

    // crop to infinity
    if (x < INFINITE_MIN)
    {
        if (width < INFINITE_SIZE)
        {
            width -= (INFINITE_MIN - x);
        }
        x = INFINITE_MIN;
    }
    if (y < INFINITE_MIN)
    {
        if (height < INFINITE_SIZE)
        {
            height -= (INFINITE_MIN - y);
        }
        y = INFINITE_MIN;
    }

    if ((width > REAL_EPSILON) && (height > REAL_EPSILON))
    {
        if (width >= INFINITE_SIZE)
        {
            if (height >= INFINITE_SIZE)
            {
                SetInfinite();
                return;
            }
            width = INFINITE_SIZE;  // crop to infinite
        }
        else if (height > INFINITE_SIZE)
        {
            height = INFINITE_SIZE; // crop to infinite
        }

        UpdateUid();
        if (RegionOk)
        {
            RegionOk = FALSE;
            DeviceRegion.SetEmpty();
        }
        FreePathData();

        X      = x;
        Y      = y;
        Width  = width;
        Height = height;
        Type   = TypeRect;

        return;
    }
    else
    {
        SetEmpty();
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Set the region to be infinite.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   2/9/1999 DCurtis
*
\**************************************************************************/
VOID
GpRegion::SetInfinite()
{
    ASSERT(IsValid());

    UpdateUid();
    DeviceRegion.SetInfinite();
    RegionOk = TRUE;

    FreePathData();

    X      = INFINITE_MIN;
    Y      = INFINITE_MIN;
    Width  = INFINITE_SIZE;
    Height = INFINITE_SIZE;
    Type   = TypeInfinite;

    return;
}

/**************************************************************************\
*
* Function Description:
*
*   Set the region to be empty.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   2/9/1999 DCurtis
*
\**************************************************************************/
VOID
GpRegion::SetEmpty()
{
    ASSERT(IsValid());

    UpdateUid();
    DeviceRegion.SetEmpty();
    RegionOk = TRUE;

    FreePathData();

    X      = 0;
    Y      = 0;
    Width  = 0;
    Height = 0;
    Type   = TypeEmpty;

    return;
}

/**************************************************************************\
*
* Function Description:
*
*   Set the region to the specified path.
*
* Arguments:
*
*   [IN]  path - the path, in world units
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRegion::Set(
    const GpPath *      path
    )
{
    ASSERT(IsValid());
    ASSERT(path != NULL);

    UpdateUid();
    if (RegionOk)
    {
        RegionOk = FALSE;
        DeviceRegion.SetEmpty();
    }
    FreePathData();

    Lazy = FALSE;
    Path = path->Clone();
    if (Path != NULL)
    {
        Type = TypePath;
        return Ok;
    }
    Type = TypeNotValid;
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Set the region to be a copy of the specified region.
*
* Arguments:
*
*   [IN]  region - the region to copy
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRegion::Set(
    const GpRegion *    region,
    BOOL                lazy
    )
{
    ASSERT(IsValid());
    ASSERT((region != NULL) && (region->IsValid()));

    if (region == this)
    {
        return Ok;
    }

    UpdateUid();
    if (RegionOk)
    {
        RegionOk = FALSE;
        DeviceRegion.SetEmpty();
    }
    FreePathData();

    if ((region->Type & REGIONTYPE_LEAF) != 0)
    {
        *this = *(const_cast<GpRegion *>(region));
        if (Type == TypePath)
        {
            if (!lazy)
            {
                Lazy = FALSE;
                if ((Path = Path->Clone()) == NULL)
                {
                    Type = TypeNotValid;
                    return GenericError;
                }
            }
            else    // lazy copy
            {
                Lazy = TRUE;
            }
        }
        return Ok;
    }
    else
    {
        INT     count = region->CombineData.GetCount();

        ASSERT(count > 0);

        Type = TypeNotValid;

        RegionData *    data = CombineData.AddMultiple(count);
        if (data != NULL)
        {
            BOOL    error = FALSE;

            GpMemcpy (data, region->CombineData.GetDataBuffer(),
                      count * sizeof(*data));

            while (count--)
            {
                if (data->Type == TypePath)
                {
                    if (!lazy)
                    {
                        data->Lazy = FALSE;
                        if ((data->Path = data->Path->Clone()) == NULL)
                        {
                            data->Type = TypeNotValid;
                            error = TRUE;
                            // don't break out or else FreePathData will free
                            // paths that don't belong to us.
                        }
                    }
                    else    // lazy copy
                    {
                        data->Lazy = TRUE;
                    }
                }
                data++;
            }
            if (!error)
            {
                Type  = region->Type;
                Left  = region->Left;
                Right = region->Right;
                return Ok;
            }
            FreePathData();
        }
    }
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Combine the region with the specified rect, using the boolean
*   operator specified by the type.
*
* Arguments:
*
*   [IN]  rect        - the rect to combine with the current region
*   [IN]  combineMode - the combine operator (and, or, xor, exclude, complement)
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRegion::Combine(
    const GpRectF *     rect,
    CombineMode         combineMode
    )
{
    ASSERT(IsValid());
    ASSERT(rect != NULL);
    ASSERT(CombineModeIsValid(combineMode));

    if (combineMode == CombineModeReplace)
    {
        this->Set(rect);
        return Ok;
    }

    if (Type == TypeInfinite)
    {
        if (combineMode == CombineModeIntersect)
        {
            this->Set(rect);
            return Ok;
        }
        else if (combineMode == CombineModeUnion)
        {
            return Ok;  // nothing to do, already infinite
        }
        else if (combineMode == CombineModeComplement)
        {
            this->SetEmpty();
            return Ok;
        }
    }
    else if (Type == TypeEmpty)
    {
        if ((combineMode == CombineModeUnion) ||
            (combineMode == CombineModeXor)   ||
            (combineMode == CombineModeComplement))
        {
            this->Set(rect);
        }
        // if combineMode is Intersect or Exclude, just leave it empty
        return Ok;
    }

    // Now we know this region is not empty
    
    REAL    x      = rect->X;
    REAL    y      = rect->Y;
    REAL    width  = rect->Width;
    REAL    height = rect->Height;
    
    // handle flipped rects
    if (width < 0)
    {
        x += width;
        width = -width;
    }
    
    if (height < 0)
    {
        y += height;
        height = -height;
    }

    // crop to infinity
    if (x < INFINITE_MIN)
    {
        if (width < INFINITE_SIZE)
        {
            width -= (INFINITE_MIN - x);
        }
        x = INFINITE_MIN;
    }
    if (y < INFINITE_MIN)
    {
        if (height < INFINITE_SIZE)
        {
            height -= (INFINITE_MIN - y);
        }
        y = INFINITE_MIN;
    }

    BOOL    isEmptyRect = ((width <= REAL_EPSILON) || (height <= REAL_EPSILON));
    
    if (isEmptyRect)
    {
        if ((combineMode == CombineModeIntersect) ||
            (combineMode == CombineModeComplement))
        {
            SetEmpty();
        }
        // if combineMode is Union or Xor or Exclude, just leave it alone
        return Ok;
    }

    // Now we know the rect is not empty

    // See if the rect is infinite
    if (width >= INFINITE_SIZE)
    {
        if (height >= INFINITE_SIZE)
        {
            GpRegion    infiniteRegion;
            return this->Combine(&infiniteRegion, combineMode);
        }
        width = INFINITE_SIZE;  // crop to infinite
    }
    else if (height > INFINITE_SIZE)
    {
        height = INFINITE_SIZE; // crop to infinite
    }

    // The rect is neither infinite nor empty    

    UpdateUid();
    if (RegionOk)
    {
        RegionOk = FALSE;
        DeviceRegion.SetEmpty();
    }

    INT                 index = CombineData.GetCount();
    RegionData *        data  = CombineData.AddMultiple(2);

    if (data != NULL)
    {
        data[0] = *this;

        data[1].Type   = TypeRect;
        data[1].X      = x;
        data[1].Y      = y;
        data[1].Width  = width;
        data[1].Height = height;

        Type  = (NodeType)combineMode;
        Left  = index;
        Right = index + 1;
        return Ok;
    }

    FreePathData();
    Type = TypeNotValid;
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Combine the region with the specified path, using the boolean
*   operator specified by the type.
*
* Arguments:
*
*   [IN]  path        - the path to combine with the current region
*   [IN]  combineMode - the combine operator (and, or, xor, exclude, complement)
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRegion::Combine(
    const GpPath *      path,
    CombineMode         combineMode
    )
{
    ASSERT(IsValid());
    ASSERT(path != NULL);
    ASSERT(CombineModeIsValid(combineMode));

    if (combineMode == CombineModeReplace)
    {
        return this->Set(path);
    }

    if (Type == TypeInfinite)
    {
        if (combineMode == CombineModeIntersect)
        {
            this->Set(path);
            return Ok;
        }
        else if (combineMode == CombineModeUnion)
        {
            return Ok;  // nothing to do, already infinite
        }
        else if (combineMode == CombineModeComplement)
        {
            this->SetEmpty();
            return Ok;
        }
    }
    else if (Type == TypeEmpty)
    {
        if ((combineMode == CombineModeUnion) ||
            (combineMode == CombineModeXor)   ||
            (combineMode == CombineModeComplement))
        {
            this->Set(path);
        }
        // if combineMode is Intersect or Exclude, just leave it empty
        return Ok;
    }

    // Now we know this region is not empty

    if (RegionOk)
    {
        RegionOk = FALSE;
        DeviceRegion.SetEmpty();
    }

    GpPath *    pathCopy = path->Clone();
    if (pathCopy != NULL)
    {
        INT                 index = CombineData.GetCount();
        RegionData *        data  = CombineData.AddMultiple(2);

        if (data != NULL)
        {
            data[0] = *this;

            data[1].Type = TypePath;
            data[1].Lazy = FALSE;
            data[1].Path = pathCopy;

            Type  = (NodeType)combineMode;
            Left  = index;
            Right = index + 1;
            UpdateUid();
            return Ok;
        }
        delete pathCopy;
    }
    FreePathData();
    Type = TypeNotValid;
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Combine the region with the specified region, using the boolean
*   operator specified by the type.
*
* Arguments:
*
*   [IN]  region      - the region to combine with the current region
*   [IN]  combineMode - the combine operator (and, or, xor, exclude, complement)
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRegion::Combine(
    GpRegion *          region,
    CombineMode         combineMode
    )
{
    ASSERT(IsValid());
    ASSERT((region != NULL) && region->IsValid());
    ASSERT(CombineModeIsValid(combineMode));

    if (combineMode == CombineModeReplace)
    {
        return this->Set(region);
    }

    if (region->Type == TypeEmpty)
    {
        if ((combineMode == CombineModeIntersect) ||
            (combineMode == CombineModeComplement))
        {
            SetEmpty();
        }
        // if combineMode is Union or Xor or Exclude, just leave it alone
        return Ok;
    }

    // Now we know the input region is not empty

    if (region->Type == TypeInfinite)
    {
        if (combineMode == CombineModeIntersect)
        {
            return Ok;
        }
        else if (combineMode == CombineModeUnion)
        {
            SetInfinite();
            return Ok;
        }
        else if ((combineMode == CombineModeXor) ||
                 (combineMode == CombineModeComplement))
        {
            if (Type == TypeInfinite)
            {
                SetEmpty();
                return Ok;
            }
        }
        if (combineMode == CombineModeExclude)
        {
            SetEmpty();
            return Ok;
        }
    }

    if (Type == TypeInfinite)
    {
        if (combineMode == CombineModeIntersect)
        {
            this->Set(region);
            return Ok;
        }
        else if (combineMode == CombineModeUnion)
        {
            return Ok;  // nothing to do, already infinite
        }
        else if (combineMode == CombineModeComplement)
        {
            this->SetEmpty();
            return Ok;
        }
    }
    else if (Type == TypeEmpty)
    {
        if ((combineMode == CombineModeUnion) ||
            (combineMode == CombineModeXor)   ||
            (combineMode == CombineModeComplement))
        {
            this->Set(region);
        }
        // if combineMode is Intersect or Exclude, just leave it empty
        return Ok;
    }

    // Now we know this region is not empty

    if (RegionOk)
    {
        RegionOk = FALSE;
        DeviceRegion.SetEmpty();
    }

    INT                 regionCount = region->CombineData.GetCount();
    INT                 index = CombineData.GetCount();
    RegionData *        data  = CombineData.AddMultiple(2 + regionCount);

    if (data != NULL)
    {
        data[regionCount]     = *this;
        data[regionCount + 1] = *region;

        if (regionCount > 0)
        {
            RegionData *    srcData = region->CombineData.GetDataBuffer();
            INT             i       = 0;
            BOOL            error   = FALSE;
            GpPath *        path;

            do
            {
                data[i] = srcData[i];
                if ((data[i].Type & REGIONTYPE_LEAF) == 0)
                {
                    data[i].Left  += index;
                    data[i].Right += index;
                }
                else if (data[i].Type == TypePath)
                {
                    data[i].Lazy = FALSE;
                    path = data[i].Path->Clone();
                    data[i].Path = path;
                    if (path == NULL)
                    {
                        data[i].Type = TypeNotValid;
                        error = TRUE;
                        // don't break out
                    }
                }

            } while (++i < regionCount);
            data[regionCount+1].Left  += index;
            data[regionCount+1].Right += index;
            index += regionCount;
            if (error)
            {
                goto ErrorExit;
            }
        }
        else if (region->Type == TypePath)
        {
            data[1].Lazy = FALSE;
            data[1].Path = region->Path->Clone();
            if (data[1].Path == NULL)
            {
                data[1].Type = TypeNotValid;
                goto ErrorExit;
            }
        }

        Type  = (NodeType)combineMode;
        Left  = index;
        Right = index + 1;
        UpdateUid();
        return Ok;
    }
ErrorExit:
    FreePathData();
    Type = TypeNotValid;
    return GenericError;
}

GpStatus
GpRegion::CreateLeafDeviceRegion(
    const RegionData *  regionData,
    DpRegion *          region
    ) const
{
    GpStatus        status = GenericError;

    switch (regionData->Type)
    {
      case TypeRect:
        if ((regionData->Width > 0) &&
            (regionData->Height > 0))
        {
            // If the transform is a simple scaling transform, life is a
            // little easier:
            if (Matrix.IsTranslateScale())
            {
                GpRectF     rect(regionData->X,
                                 regionData->Y,
                                 regionData->Width,
                                 regionData->Height);

                Matrix.TransformRect(rect);

                // Use ceiling to stay compatible with rasterizer
                // Don't take the ceiling of the width directly,
                // because it introduces additional round-off error.
                // For example, if rect.X is 1.7 and rect.Width is 47.2,
                // then if we took the ceiling of the width, the right
                // coordinate will end up being 50, instead of 49.
                INT     xMin = RasterizerCeiling(rect.X);
                INT     yMin = RasterizerCeiling(rect.Y);
                INT     xMax = RasterizerCeiling(rect.GetRight());
                INT     yMax = RasterizerCeiling(rect.GetBottom());

                region->Set(xMin, yMin, xMax - xMin, yMax - yMin);
                status = Ok;
            }
            else
            {
                GpPointF    points[4];
                REAL        left;
                REAL        right;
                REAL        top;
                REAL        bottom;

                left   = regionData->X;
                top    = regionData->Y;
                right  = regionData->X + regionData->Width;
                bottom = regionData->Y + regionData->Height;

                points[0].X = left;
                points[0].Y = top;
                points[1].X = right;
                points[1].Y = top;
                points[2].X = right;
                points[2].Y = bottom;
                points[3].X = left;
                points[3].Y = bottom;

                const INT   stackCount = 4;
                GpPointF    stackPoints[stackCount];
                BYTE        stackTypes[stackCount];

                GpPath path(points,
                            4,
                            stackPoints,
                            stackTypes,
                            stackCount,
                            FillModeAlternate,
                            DpPath::Convex);

                if (path.IsValid())
                {
                    status = region->Set(&path, &Matrix);
                }
            }
        }
        else
        {
            region->SetEmpty();
            status = Ok;
        }
        break;

      case TypePath:
        status = region->Set(regionData->Path, &Matrix);
        break;

      case TypeEmpty:
        region->SetEmpty();
        status = Ok;
        break;

      case TypeInfinite:
        region->SetInfinite();
        status = Ok;
        break;

      default:
        ASSERT(0);
        break;
    }
    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Creates a DpRegion (device coordinate region) using the data in the
*   specified RegionData node and using the current transformation matrix.
*   This may involve creating a region for children nodes and then combining
*   the children into a single device region.
*
* Arguments:
*
*   [IN]  regionData - the world coordinate region to convert to device region
*   [OUT] region     - the created/combined device region
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRegion::CreateDeviceRegion(
    const RegionData *  regionData,
    DpRegion *          region
    ) const
{
    ASSERT(IsValid());

    GpStatus        status;
    RegionData *    regionDataLeft;

    regionDataLeft  = &(CombineData[regionData->Left]);

    if ((regionDataLeft->Type & REGIONTYPE_LEAF) != 0)
    {
        status = CreateLeafDeviceRegion(regionDataLeft, region);
    }
    else
    {
        status = CreateDeviceRegion(regionDataLeft, region);
    }

    if (status == Ok)
    {
        DpRegion        regionRight;
        RegionData *    regionDataRight;

        regionDataRight = &(CombineData[regionData->Right]);

        if ((regionDataRight->Type & REGIONTYPE_LEAF) != 0)
        {
            status = CreateLeafDeviceRegion(regionDataRight, &regionRight);
        }
        else
        {
            status = CreateDeviceRegion(regionDataRight, &regionRight);
        }

        if (status == Ok)
        {
            switch (regionData->Type)
            {
              case TypeAnd:
                status = region->And(&regionRight);
                break;

              case TypeOr:
                status = region->Or(&regionRight);
                break;

              case TypeXor:
                status = region->Xor(&regionRight);
                break;

              case TypeExclude:
                status = region->Exclude(&regionRight);
                break;

              case TypeComplement:
                status = region->Complement(&regionRight);
                break;

              default:
                ASSERT(0);
                break;
            }
        }
    }
    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Checks if the current DeviceRegion is up-to-date with the specified
*   matrix.  If not, then it recreates the DeviceRegion using the matrix.
*
* Arguments:
*
*   [IN]  matrix - the world-to-device transformation matrix
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRegion::UpdateDeviceRegion(
    GpMatrix *          matrix
    ) const
{
    ASSERT(IsValid());

    if (RegionOk && matrix->IsEqual(&Matrix))
    {
        return Ok;
    }
    Matrix = *matrix;

    GpStatus    status;

    if ((this->Type & REGIONTYPE_LEAF) != 0)
    {
        status = CreateLeafDeviceRegion(this, &DeviceRegion);
    }
    else
    {
        status = CreateDeviceRegion(this, &DeviceRegion);
    }
    RegionOk = (status == Ok);
    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Get the bounds of the region, in world units.
*
* Arguments:
*
*   [IN]  matrix - world-to-device transformation matrix
*   [OUT] bounds - bounding rect of region, in world units
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRegion::GetBounds(
    GpGraphics *        graphics,
    GpRectF *           bounds,
    BOOL                device
    ) const
{
    ASSERT((graphics != NULL) && (bounds != NULL));
    ASSERT(IsValid() && graphics->IsValid());

    // Note we can't lock graphics, cause it gets locked in its calls

    GpStatus        status = Ok;

    switch (Type)
    {
      case TypeRect:
        if (!device)
        {
            bounds->X      = X;
            bounds->Y      = Y;
            bounds->Width  = Width;
            bounds->Height = Height;
        }
        else
        {
            GpMatrix    worldToDevice;

            graphics->GetWorldToDeviceTransform(&worldToDevice);

            TransformBounds(&worldToDevice, X, Y, X + Width, Y + Height,bounds);
        }
        break;

      case TypePath:
          {
            GpMatrix    worldToDevice;

            if (device)
            {
                graphics->GetWorldToDeviceTransform(&worldToDevice);
            }
            // else leave it as identity
            Path->GetBounds(bounds, &worldToDevice);
          }
        break;

      case TypeInfinite:
        bounds->X      = INFINITE_MIN;
        bounds->Y      = INFINITE_MIN;
        bounds->Width  = INFINITE_SIZE;
        bounds->Height = INFINITE_SIZE;
        break;

      case TypeAnd:
      case TypeOr:
      case TypeXor:
      case TypeExclude:
      case TypeComplement:
        {
            GpMatrix    worldToDevice;

            graphics->GetWorldToDeviceTransform(&worldToDevice);

            if (UpdateDeviceRegion(&worldToDevice) == Ok)
            {
                GpRect      deviceBounds;

                DeviceRegion.GetBounds(&deviceBounds);

                if (device)
                {
                    bounds->X      = TOREAL(deviceBounds.X);
                    bounds->Y      = TOREAL(deviceBounds.Y);
                    bounds->Width  = TOREAL(deviceBounds.Width);
                    bounds->Height = TOREAL(deviceBounds.Height);
                    break;
                }
                else
                {
                    GpMatrix    deviceToWorld;

                    if (graphics->GetDeviceToWorldTransform(&deviceToWorld)==Ok)
                    {
                        TransformBounds(
                                &deviceToWorld,
                                TOREAL(deviceBounds.X),
                                TOREAL(deviceBounds.Y),
                                TOREAL(deviceBounds.X + deviceBounds.Width),
                                TOREAL(deviceBounds.Y + deviceBounds.Height),
                                bounds);
                        break;
                    }
                }
            }
        }
        status = GenericError;
        // FALLTHRU

      default:  // TypeEmpty
        bounds->X      = 0;
        bounds->Y      = 0;
        bounds->Width  = 0;
        bounds->Height = 0;
        break;
    }
    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Get the bounds of the region, in device units.
*
* Arguments:
*
*   [IN]  matrix - world-to-device transformation matrix
*   [OUT] bounds - bounding rect of region, in device units
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRegion::GetBounds(
    GpMatrix *          matrix,
    GpRect *            bounds
    ) const
{
    ASSERT(IsValid());
    ASSERT((matrix != NULL) && (bounds != NULL));

    GpStatus        status = Ok;

    switch (Type)
    {
      case TypeInfinite:
        bounds->X      = INFINITE_MIN;
        bounds->Y      = INFINITE_MIN;
        bounds->Width  = INFINITE_SIZE;
        bounds->Height = INFINITE_SIZE;
        break;

      default:
        if (UpdateDeviceRegion(matrix) == Ok)
        {
            DeviceRegion.GetBounds(bounds);
            break;
        }
        status = GenericError;
        // FALLTHRU

      case TypeEmpty:
        bounds->X      = 0;
        bounds->Y      = 0;
        bounds->Width  = 0;
        bounds->Height = 0;
        break;
    }
    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Get the HRGN corresponding to the region
*
* Arguments:
*
*   [IN]  graphics - a reference graphics for conversion to device units
*                    (can be NULL)
*   [OUT] hRgn     - the GDI region
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   7/6/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRegion::GetHRgn(
    GpGraphics *        graphics,
    HRGN *              hRgn
    ) const
{
    ASSERT(IsValid());
    ASSERT(hRgn != NULL);

    GpMatrix    worldToDevice;

    if (graphics != NULL)
    {
        graphics->GetWorldToDeviceTransform(&worldToDevice);
    }

    if (UpdateDeviceRegion(&worldToDevice) == Ok)
    {
        if ((*hRgn = DeviceRegion.GetHRgn()) != (HRGN)INVALID_HANDLE_VALUE)
        {
            return Ok;
        }
    }
    else
    {
        *hRgn = (HRGN)INVALID_HANDLE_VALUE;
    }
    return GenericError;
}

GpStatus
GpRegion::GetRegionScans(
    GpRect *            rects,
    INT *               count,
    const GpMatrix *    matrix
    ) const
{
    ASSERT(IsValid());
    ASSERT(count != NULL);
    ASSERT(matrix != NULL);

    if (UpdateDeviceRegion(const_cast<GpMatrix*>(matrix)) == Ok)
    {
        *count = DeviceRegion.GetRects(rects);
        return Ok;
    }
    else
    {
        *count = 0;
    }
    return GenericError;
}

GpStatus
GpRegion::GetRegionScans(
    GpRectF *           rects,
    INT *               count,
    const GpMatrix *          matrix
    ) const
{
    ASSERT(IsValid());
    ASSERT(count != NULL);
    ASSERT(matrix != NULL);

    if (UpdateDeviceRegion(const_cast<GpMatrix*>(matrix)) == Ok)
    {
        *count = DeviceRegion.GetRects(rects);
        return Ok;
    }
    else
    {
        *count = 0;
    }
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Determine if the specified point is visible (inside) the region.
*
* Arguments:
*
*   [IN]  point     - the point, in world units
*   [IN]  matrix    - the world-to-device transformation matrix to use
*   [OUT] isVisible - if the point is visible or not
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRegion::IsVisible (
    GpPointF *          point,
    GpMatrix *          matrix,
    BOOL *              isVisible
    ) const
{
    ASSERT(IsValid());
    ASSERT(matrix != NULL);
    ASSERT(point != NULL);
    ASSERT(isVisible != NULL);

    if (UpdateDeviceRegion(matrix) == Ok)
    {
        GpPointF    transformedPoint = *point;

        matrix->Transform(&transformedPoint);

        *isVisible = DeviceRegion.PointInside(GpRound(transformedPoint.X),
                                              GpRound(transformedPoint.Y));
        return Ok;
    }

    *isVisible = FALSE;
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Determine if the specified rect is inside or overlaps the region.
*
* Arguments:
*
*   [IN]  rect      - the rect, in world units
*   [IN]  matrix    - the world-to-device transformation matrix to use
*   [OUT] isVisible - if the rect is visible or not
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRegion::IsVisible(
    GpRectF *           rect,
    GpMatrix *          matrix,
    BOOL *              isVisible
    ) const
{
    ASSERT(IsValid());
    ASSERT(matrix != NULL);
    ASSERT(rect != NULL);

    if (UpdateDeviceRegion(matrix) == Ok)
    {
        // If the transform is a simple scaling transform, life is a
        // little easier:
        if (Matrix.IsTranslateScale())
        {
            GpRectF     transformRect(*rect);

            Matrix.TransformRect(transformRect);

            // Use ceiling to stay compatible with rasterizer
            INT     x = GpCeiling(transformRect.X);
            INT     y = GpCeiling(transformRect.Y);

            *isVisible = DeviceRegion.RectVisible(
                                x, y,
                                x + GpCeiling(transformRect.Width),
                                y + GpCeiling(transformRect.Height));
            return Ok;
        }
        else
        {
            REAL        left   = rect->X;
            REAL        top    = rect->Y;
            REAL        right  = rect->X + rect->Width;
            REAL        bottom = rect->Y + rect->Height;
            GpRectF     bounds;
            GpRect      deviceBounds;
            GpRect      regionBounds;

            TransformBounds(matrix, left, top, right, bottom, &bounds);
            GpStatus status = BoundsFToRect(&bounds, &deviceBounds);
            DeviceRegion.GetBounds(&regionBounds);

            // try trivial reject
            if (status != Ok || !regionBounds.IntersectsWith(deviceBounds))
            {
                *isVisible = FALSE;
                return status;
            }

            // couldn't reject, so do full test
            GpPointF    points[4];

            points[0].X = left;
            points[0].Y = top;
            points[1].X = right;
            points[1].Y = top;
            points[2].X = right;
            points[2].Y = bottom;
            points[3].X = left;
            points[3].Y = bottom;

            const INT   stackCount = 4;
            GpPointF    stackPoints[stackCount];
            BYTE        stackTypes[stackCount];

            GpPath path(points,
                        4,
                        stackPoints,
                        stackTypes,
                        stackCount,
                        FillModeAlternate,
                        DpPath::Convex);

            if (path.IsValid())
            {
                DpRegion    region(&path, matrix);

                if (region.IsValid())
                {
                    *isVisible = DeviceRegion.RegionVisible(&region);
                    return Ok;
                }
            }
        }
    }
    *isVisible = FALSE;
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Determine if the specified region is inside or overlaps the region.
*
* Arguments:
*
*   [IN]  region    - the region
*   [IN]  matrix    - the world-to-device transformation matrix to use
*   [OUT] isVisible - if the region is visible or not
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRegion::IsVisible(
    GpRegion *          region,
    GpMatrix *          matrix,
    BOOL *              isVisible
    ) const
{
    ASSERT(IsValid());
    ASSERT(matrix != NULL);
    ASSERT((region != NULL) && (region->IsValid()));

    if ((UpdateDeviceRegion(matrix) == Ok) &&
        (region->UpdateDeviceRegion(matrix) == Ok))
    {
        *isVisible = DeviceRegion.RegionVisible(&(region->DeviceRegion));
        return Ok;
    }
    *isVisible = FALSE;
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Determine if the region is empty, i.e. if it has no coverage area.
*
* Arguments:
*
*   [IN]  matrix  - the world-to-device transformation matrix to use
*   [OUT] isEmpty - if the region is empty or not
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRegion::IsEmpty(
    GpMatrix *          matrix,
    BOOL *              isEmpty
    ) const
{
    ASSERT(IsValid());
    ASSERT(matrix != NULL);

    if (Type == TypeEmpty)
    {
        *isEmpty = TRUE;
        return Ok;
    }

    if (UpdateDeviceRegion(matrix) == Ok)
    {
        *isEmpty = DeviceRegion.IsEmpty();
        return Ok;
    }
    *isEmpty = FALSE;
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Determine if the region is infinite, i.e. if it has infinite coverage area.
*
* Arguments:
*
*   [IN]  matrix     - the world-to-device transformation matrix to use
*   [OUT] isInfinite - if the region is infinite or not
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRegion::IsInfinite(
    GpMatrix *          matrix,
    BOOL *              isInfinite
    ) const
{
    ASSERT(IsValid());
    ASSERT(matrix != NULL);

    if (Type == TypeInfinite)
    {
        *isInfinite = TRUE;
        return Ok;
    }

    // We have this here for cases like the following:
    //      This region was OR'ed with another region that was infinite.
    //      We wouldn't know this region was infinite now without checking
    //      the device region.
    if (UpdateDeviceRegion(matrix) == Ok)
    {
        *isInfinite = DeviceRegion.IsInfinite();
        return Ok;
    }
    *isInfinite = FALSE;
    return GenericError;
}

/**************************************************************************\
*
* Function Description:
*
*   Determine if the specified region is equal, in coverage area, to
*   this region.
*
* Arguments:
*
*   [IN]  region  - the region to check equality with
*   [IN]  matrix  - the world-to-device transformation matrix to use
*   [OUT] isEqual - if the regions are equal or not
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRegion::IsEqual(
    GpRegion *          region,
    GpMatrix *          matrix,
    BOOL *              isEqual
    ) const
{
    ASSERT(IsValid());
    ASSERT(matrix != NULL);
    ASSERT((region != NULL) && (region->IsValid()));

    if ((UpdateDeviceRegion(matrix) == Ok) &&
        (region->UpdateDeviceRegion(matrix) == Ok))
    {
        *isEqual = DeviceRegion.IsEqual(&(region->DeviceRegion));
        return Ok;
    }
    *isEqual = FALSE;
    return GenericError;
}


/**************************************************************************\
*
* Function Description:
*
*   Translate (offset) the region by the specified delta/offset values.
*
* Arguments:
*
*   [IN]  xOffset - amount to offset in X (world units)
*   [IN]  yOffset - amount to offset in Y
*
* Return Value:
*
*   NONE
*
* Created:
*
*   01/06/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRegion::Offset(
    REAL        xOffset,
    REAL        yOffset
    )
{
    ASSERT(IsValid());

    if ((xOffset == 0) && (yOffset == 0))
    {
        return Ok;
    }

    // Note that if performance is a problem, there's lots we could do here.
    // For example, we could keep track of the offset, and only apply it
    // when updating the device region.  We could even avoid re-rasterizing
    // the device region.

    switch (Type)
    {
      case TypeEmpty:
      case TypeInfinite:
        return Ok;  // do nothing

      case TypeRect:
        UpdateUid();
        X += xOffset;
        Y += yOffset;
        break;

      case TypePath:
        UpdateUid();
        if (Lazy)
        {
            Path = Path->Clone();
            Lazy = FALSE;
            if (Path == NULL)
            {
                Type = TypeNotValid;
                return GenericError;
            }
        }
        Path->Offset(xOffset, yOffset);
        break;

      default:
        UpdateUid();
        {
            INT             count = CombineData.GetCount();
            RegionData *    data  = CombineData.GetDataBuffer();
            NodeType        type;

            ASSERT ((count > 0) && (data != NULL));

            do
            {
                type = data->Type;

                if (type == TypeRect)
                {
                    data->X += xOffset;
                    data->Y += yOffset;
                }
                else if (type == TypePath)
                {
                    if (data->Lazy)
                    {
                        data->Path = data->Path->Clone();
                        data->Lazy = FALSE;
                        if (data->Path == NULL)
                        {
                            data->Type = TypeNotValid;
                            FreePathData();
                            Type = TypeNotValid;
                            return GenericError;
                        }
                    }
                    data->Path->Offset(xOffset, yOffset);
                }
                data++;

            } while (--count > 0);
        }
        break;
    }

    if (RegionOk)
    {
        RegionOk = FALSE;
        DeviceRegion.SetEmpty();
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Transform a leaf node by the specified matrix.  This could result in a
*   rect being converted into a path.  Ignores non-leaf nodes.  No reason
*   to transform empty/infinite nodes.
*
* Arguments:
*
*   [IN]     matrix - the transformation matrix to apply
*   [IN/OUT] data   - the node to transform
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   02/08/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRegion::TransformLeaf(
    GpMatrix *      matrix,
    RegionData *    data
    )
{
    switch (data->Type)
    {
      // case TypeEmpty:
      // case TypeInfinite:
      // case TypeAnd, TypeOr, TypeXor, TypeExclude, TypeComplement:
      default:
        return Ok;      // do nothing

      case TypeRect:
        {
            if (matrix->IsTranslateScale())
            {
                GpRectF     rect(data->X,
                                 data->Y,
                                 data->Width,
                                 data->Height);
                matrix->TransformRect(rect);

                data->X      = rect.X;
                data->Y      = rect.Y;
                data->Width  = rect.Width;
                data->Height = rect.Height;

                return Ok;
            }
            else
            {
                GpPath *        path = new GpPath(FillModeAlternate);

                if (path != NULL)
                {
                    if (path->IsValid())
                    {
                        GpPointF    points[4];
                        REAL        left;
                        REAL        right;
                        REAL        top;
                        REAL        bottom;

                        left   = data->X;
                        top    = data->Y;
                        right  = data->X + data->Width;
                        bottom = data->Y + data->Height;

                        points[0].X = left;
                        points[0].Y = top;
                        points[1].X = right;
                        points[1].Y = top;
                        points[2].X = right;
                        points[2].Y = bottom;
                        points[3].X = left;
                        points[3].Y = bottom;

                        matrix->Transform(points, 4);

                        if (path->AddLines(points, 4) == Ok)
                        {
                            data->Path = path;
                            data->Lazy = FALSE;
                            data->Type = TypePath;
                            return Ok;
                        }
                    }
                    delete path;
                }
                data->Type = TypeNotValid;
            }
        }
        return GenericError;

      case TypePath:
        if (data->Lazy)
        {
            data->Path = data->Path->Clone();
            data->Lazy = FALSE;
            if (data->Path == NULL)
            {
                data->Type = TypeNotValid;
                return GenericError;
            }
        }
        data->Path->Transform(matrix);
        return Ok;
    }
}

/**************************************************************************\
*
* Function Description:
*
*   Transform a region with the specified matrix.
*
* Arguments:
*
*   [IN]     matrix - the transformation matrix to apply
*
* Return Value:
*
*   GpStatus - Ok or failure status
*
* Created:
*
*   02/08/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRegion::Transform(
    GpMatrix *      matrix
    )
{
    ASSERT(IsValid());

    if (matrix->IsIdentity() || (Type == TypeInfinite) || (Type == TypeEmpty))
    {
        return Ok;
    }

    UpdateUid();
    if (RegionOk)
    {
        RegionOk = FALSE;
        DeviceRegion.SetEmpty();
    }

    if ((Type & REGIONTYPE_LEAF) != 0)
    {
        return TransformLeaf(matrix, this);
    }
    else
    {
        BOOL            error = FALSE;
        INT             count = CombineData.GetCount();
        RegionData *    data  = CombineData.GetDataBuffer();

        ASSERT((count > 0) && (data != NULL));

        do
        {
            error |= (TransformLeaf(matrix, data++) != Ok);

        } while (--count > 0);

        if (!error)
        {
            return Ok;
        }
    }

    FreePathData();
    Type = TypeNotValid;
    return GenericError;
}

class RegionRecordData : public ObjectData
{
public:
    INT32       NodeCount;
};


GpStatus
GpRegion::SetData(
    const BYTE *    dataBuffer,
    UINT            size
    )
{
    if (dataBuffer == NULL)
    {
        WARNING(("dataBuffer is NULL"));
        return InvalidParameter;
    }

    return this->Set(dataBuffer, size);
}

GpStatus
GpRegion::Set(
    const BYTE *    regionDataBuffer,   // NULL means set to empty
    UINT            regionDataSize
    )
{
    GpStatus        status = Ok;

    if (regionDataBuffer != NULL)
    {
        if (regionDataSize < sizeof(RegionRecordData))
        {
            WARNING(("size too small"));
            status = InsufficientBuffer;
            goto SetEmptyRegion;
        }

        if (!((RegionRecordData *)regionDataBuffer)->MajorVersionMatches())
        {
            WARNING(("Version number mismatch"));
            status = InvalidParameter;
            goto SetEmptyRegion;
        }

        UpdateUid();
        if (RegionOk)
        {
            RegionOk = FALSE;
            DeviceRegion.SetEmpty();
        }
        FreePathData();

        RegionData *    regionDataArray = NULL;
        INT             nodeCount = ((RegionRecordData *)regionDataBuffer)->NodeCount;

        if (nodeCount > 0)
        {
            regionDataArray = CombineData.AddMultiple(nodeCount);
            if (regionDataArray == NULL)
            {
                Type = TypeNotValid;
                return OutOfMemory;
            }
        }
        regionDataBuffer += sizeof(RegionRecordData);
        regionDataSize   -= sizeof(RegionRecordData);

        INT     nextArrayIndex = 0;
        status = SetRegionData(regionDataBuffer, regionDataSize,
                               this, regionDataArray,
                               nextArrayIndex, nodeCount);
        if (status == Ok)
        {
            ASSERT(nextArrayIndex == nodeCount);
            return Ok;
        }
        Type = TypeNotValid;
        return status;
    }
SetEmptyRegion:
    SetEmpty();
    return status;
}

GpStatus
GpRegion::SetRegionData(
    const BYTE * &  regionDataBuffer,
    UINT &          regionDataSize,
    RegionData *    regionData,
    RegionData *    regionDataArray,
    INT &           nextArrayIndex,
    INT             arraySize
    )
{
    for (;;)
    {
        if (regionDataSize < sizeof(INT32))
        {
            WARNING(("size too small"));
            return InsufficientBuffer;
        }

        regionData->Type = (NodeType)(((INT32 *)regionDataBuffer)[0]);
        regionDataBuffer += sizeof(INT32);
        regionDataSize   -= sizeof(INT32);

        if ((regionData->Type & REGIONTYPE_LEAF) != 0)
        {
            switch (regionData->Type)
            {
            case TypeRect:
                if (regionDataSize < (4 * sizeof(REAL)))
                {
                    WARNING(("size too small"));
                    return InsufficientBuffer;
                }

                regionData->X      = ((REAL *)regionDataBuffer)[0];
                regionData->Y      = ((REAL *)regionDataBuffer)[1];
                regionData->Width  = ((REAL *)regionDataBuffer)[2];
                regionData->Height = ((REAL *)regionDataBuffer)[3];

                regionDataBuffer += (4 * sizeof(REAL));
                regionDataSize   -= (4 * sizeof(REAL));
                break;

            case TypePath:
                {
                    if (regionDataSize < sizeof(INT32))
                    {
                        WARNING(("size too small"));
                        return InsufficientBuffer;
                    }

                    GpPath *    path = new GpPath();
                    UINT        pathSize  = ((INT32 *)regionDataBuffer)[0];

                    regionDataBuffer += sizeof(INT32);
                    regionDataSize   -= sizeof(INT32);

                    if (path == NULL)
                    {
                        return OutOfMemory;
                    }

                    UINT        tmpPathSize = pathSize;

                    if ((path->SetData(regionDataBuffer, tmpPathSize) != Ok) ||
                        (!path->IsValid()))
                    {
                        delete path;
                        return InvalidParameter;
                    }
                    regionDataBuffer += pathSize;
                    regionDataSize   -= pathSize;

                    regionData->Path = path;
                    regionData->Lazy = FALSE;
                }
                break;

            case TypeEmpty:
            case TypeInfinite:
                break;

            default:
                ASSERT(0);
                break;
            }
            break;  // get out of loop
        }
        else // it's not a leaf node
        {
            if ((regionDataArray == NULL) ||
                (nextArrayIndex >= arraySize))
            {
                ASSERT(0);
                return InvalidParameter;
            }
            regionData->Left = nextArrayIndex++;

            // traverse left
            GpStatus status = SetRegionData(regionDataBuffer,
                                            regionDataSize,
                                            regionDataArray + regionData->Left,
                                            regionDataArray,
                                            nextArrayIndex,
                                            arraySize);
            if (status != Ok)
            {
                return status;
            }

            if (nextArrayIndex >= arraySize)
            {
                ASSERT(0);
                return InvalidParameter;
            }
            regionData->Right = nextArrayIndex++;

            // traverse right using tail-end recursion
            regionData = regionDataArray + regionData->Right;
        }
    }
    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
*   Serialize all the region data into a single memory buffer.  If the
*   buffer is NULL, just return the number of bytes required in the buffer.
*
* Arguments:
*
*   [IN]     regionDataBuffer - the memory buffer to fill with region data
*
* Return Value:
*
*   INT - Num Bytes required (or used) to fill with region data
*
* Created:
*
*   09/01/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRegion::GetData(
    IStream *   stream
    ) const
{
    ASSERT (stream != NULL);

    RegionRecordData    regionRecordData;
    regionRecordData.NodeCount = CombineData.GetCount();
    stream->Write(&regionRecordData, sizeof(regionRecordData), NULL);

    return this->GetRegionData(stream, this);
}

UINT
GpRegion::GetDataSize() const
{
    return sizeof(RegionRecordData) + this->GetRegionDataSize(this);
}

/**************************************************************************\
*
* Function Description:
*
*   Recurse through the region data structure to determine how many bytes
*   are required to hold all the region data.
*
* Arguments:
*
*   [IN]     regionData - the region data node to start with
*
* Return Value:
*
*   INT - the size in bytes from this node down
*
* Created:
*
*   09/01/1999 DCurtis
*
\**************************************************************************/
INT
GpRegion::GetRegionDataSize(
    const RegionData *      regionData
    ) const
{
    INT     size = 0;

    for (;;)
    {
        size += sizeof(INT32);   // for the type of this node

        if ((regionData->Type & REGIONTYPE_LEAF) != 0)
        {
            switch (regionData->Type)
            {
              case TypeRect:
                size += (4 * sizeof(REAL)); // for the rect data
                break;

              case TypePath:
                size += sizeof(INT32) + regionData->Path->GetDataSize();
                ASSERT((size & 0x03) == 0);
                break;

              case TypeEmpty:
              case TypeInfinite:
                break;

              default:
                ASSERT(0);
                break;
            }
            break;  // get out of loop
        }
        else // it's not a leaf node
        {
            // traverse left
            size += GetRegionDataSize(&(CombineData[regionData->Left]));

            // traverse right using tail-end recursion
            regionData = &(CombineData[regionData->Right]);
        }
    }
    return size;
}

/**************************************************************************\
*
* Function Description:
*
*   Recurse through the region data structure writing each region data
*   node to the memory buffer.
*
* Arguments:
*
*   [IN]     regionData       - the region data node to start with
*   [IN]     regionDataBuffer - the memory buffer to write the data to
*
* Return Value:
*
*   BYTE * - the next memory location to write to
*
* Created:
*
*   09/01/1999 DCurtis
*
\**************************************************************************/
GpStatus
GpRegion::GetRegionData(
    IStream *               stream,
    const RegionData *      regionData
    ) const
{
    ASSERT(stream != NULL);

    GpStatus    status   = Ok;
    UINT        pathSize;
    REAL        rectBuffer[4];

    for (;;)
    {
        stream->Write(&regionData->Type, sizeof(INT32), NULL);

        if ((regionData->Type & REGIONTYPE_LEAF) != 0)
        {
            switch (regionData->Type)
            {
            case TypeRect:
                rectBuffer[0] = regionData->X;
                rectBuffer[1] = regionData->Y;
                rectBuffer[2] = regionData->Width;
                rectBuffer[3] = regionData->Height;
                stream->Write(rectBuffer, 4 * sizeof(rectBuffer[0]), NULL);
                break;

            case TypePath:
                pathSize = regionData->Path->GetDataSize();
                ASSERT((pathSize & 0x03) == 0);
                stream->Write(&pathSize, sizeof(INT32), NULL);
                status = regionData->Path->GetData(stream);
                break;

            case TypeEmpty:
            case TypeInfinite:
                break;

            default:
                ASSERT(0);
                break;
            }
            break;  // get out of loop
        }
        else // it's not a leaf node
        {
            // traverse left
            status = GetRegionData(stream, &(CombineData[regionData->Left]));

            // traverse right using tail-end recursion
            regionData = &(CombineData[regionData->Right]);
        }
        if (status != Ok)
        {
            break;
        }
    }
    return status;
}

/**************************************************************************\
*
* Function Description:
*
*   Constructor.  Sets the region to a copy of the specified path.
*
* Arguments:
*
*   [IN] path - path to initialize the region to
*
* Return Value:
*
*   NONE
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/
GpRegion::GpRegion(
    HRGN                    hRgn
    )
{
    ASSERT(hRgn != NULL);

    SetValid(TRUE);     // default is valid

    RegionOk = FALSE;
    Lazy = FALSE;
    Type = TypeNotValid;
    Path = new GpPath(hRgn);

    if (CheckValid(Path))
    {
        Type = TypePath;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\region.hpp ===
/**************************************************************************\
*
* Copyright (c) 1999  Microsoft Corporation
*
* Module Name:
*
*   Region.hpp
*
* Abstract:
*
*   Region API related declarations
*
* Created:
*
*   2/3/1999 DCurtis
*
\**************************************************************************/

#ifndef _REGION_HPP
#define _REGION_HPP

// Specifies that a RegionData node is a leaf node, rather than a node that
// combines 2 children nodes.
#define REGIONTYPE_LEAF     0x10000000

// A RegionData node can be empty or infinite or it can contain a rect,
// a path, or two children nodes (left and right) that are combined with a
// boolean operator.  Children nodes are specified by their index into the
// dynamic array called CombineData of GpRegion.
struct RegionData
{
friend class GpRegion;

public:
    enum NodeType
    {
        TypeAnd        = CombineModeIntersect,
        TypeOr         = CombineModeUnion,
        TypeXor        = CombineModeXor,
        TypeExclude    = CombineModeExclude,
        TypeComplement = CombineModeComplement,
        TypeRect       = REGIONTYPE_LEAF | 0,
        TypePath       = REGIONTYPE_LEAF | 1,
        TypeEmpty      = REGIONTYPE_LEAF | 2,
        TypeInfinite   = REGIONTYPE_LEAF | 3,
        TypeNotValid   = 0xFFFFFFFF,
    };

protected:
    NodeType            Type;

    union
    {
        struct      // rect data (can't be GpRectF cause of constructor)
        {
            REAL        X;
            REAL        Y;
            REAL        Width;
            REAL        Height;
        };
        struct
        {
            GpPath *    Path;   // copy of path
            BOOL        Lazy;   // if the path is a lazy copy or not
        };
        struct
        {
            INT         Left;   // index of left child
            INT         Right;  // index of right child
        };
    };
};

typedef DynArray<RegionData> DynRegionDataArray;

class GpRegion : public GpObject, public RegionData
{
friend class GpGraphics;
protected:
    mutable GpLockable  Lockable;
    mutable BOOL        RegionOk;       // if DeviceRegion is valid
    mutable DpRegion    DeviceRegion;   // region coverage, in device units
    mutable GpMatrix    Matrix;         // last matrix used for DeviceRegion

    DynRegionDataArray  CombineData;    // combined region data, if any

protected:
    VOID SetValid(BOOL valid)
    {
        GpObject::SetValid(valid ? ObjectTagRegion : ObjectTagInvalid);
    }

protected:
    // doesn't change the region itself, just the device region
    GpStatus 
    UpdateDeviceRegion(
        GpMatrix *          matrix
        ) const;

    // doesn't change the region itself, just the device region
    GpStatus 
    CreateLeafDeviceRegion(
        const RegionData *  regionData,
        DpRegion *          region
        ) const;

    // doesn't change the region itself, just the device region
    GpStatus 
    CreateDeviceRegion(
        const RegionData *  regionData,
        DpRegion *          region
        ) const;

    GpStatus
    TransformLeaf(
        GpMatrix *          matrix,
        RegionData *        data
        );

    INT
    GetRegionDataSize(
        const RegionData *  regionData
        ) const;
        
    GpStatus
    GetRegionData(
        IStream *               stream,
        const RegionData *      regionData
        ) const;

    GpStatus
    SetRegionData(
        const BYTE * &  regionDataBuffer,
        UINT &          regionDataSize,
        RegionData *    regionData,
        RegionData *    regionDataArray,
        INT &           nextArrayIndex,
        INT             arraySize
        );

public:
    GpRegion();
    GpRegion(const GpRectF * rect);
    GpRegion(const GpPath * path);
    GpRegion(const GpRegion * region, BOOL lazy = FALSE);
    GpRegion(const BYTE * regionDataBuffer, UINT size);
    GpRegion(HRGN hRgn);
    ~GpRegion();

    virtual BOOL IsValid() const 
    { 
        // If the region came from a different version of GDI+, its tag
        // will not match, and it won't be considered valid.
        return ((Type != TypeNotValid) && GpObject::IsValid(ObjectTagRegion));
    }

    VOID FreePathData();

    GpLockable *GetObjectLock()      // Get the lock object
    {
        return &Lockable;
    }

    virtual ObjectType GetObjectType() const { return ObjectTypeRegion; }
    virtual UINT GetDataSize() const;
    virtual GpStatus GetData(IStream * stream) const;
    virtual GpStatus SetData(const BYTE * dataBuffer, UINT size);

    VOID Set(const GpRectF * rect)
    {
        Set(rect->X, rect->Y, rect->Width, rect->Height);
    }
    VOID Set(REAL x, REAL y, REAL width, REAL height);
    GpStatus Set(const GpPath * path);
    GpStatus Set(const GpRegion * region, BOOL lazy = FALSE);
    GpStatus Set(
        const BYTE *    regionDataBuffer,   // NULL means set to empty
        UINT            regionDataSize
        );

    VOID SetInfinite();
    VOID SetEmpty();

    GpStatus GetBounds(GpGraphics * graphics, GpRectF * bounds,
                       BOOL device = FALSE) const;
    GpStatus GetBounds(GpMatrix * matrix, GpRect *  bounds) const;

    GpStatus GetHRgn(GpGraphics * graphics, HRGN * hRgn) const;

    GpStatus GetRegionScans(GpRect  *rects, INT *count, const GpMatrix *matrix) const;
    GpStatus GetRegionScans(GpRectF *rects, INT *count, const GpMatrix *matrix) const;

    GpStatus IsVisible(GpPointF * point,  GpMatrix * matrix, BOOL * isVisible) const;
    GpStatus IsVisible(GpRectF * rect,    GpMatrix * matrix, BOOL * isVisible) const;
    GpStatus IsVisible(GpRegion * region, GpMatrix * matrix, BOOL * isVisible) const;

    GpStatus IsEmpty   (GpMatrix * matrix, BOOL * isEmpty) const;
    GpStatus IsInfinite(GpMatrix * matrix, BOOL * isInfinite) const;
    GpStatus IsEqual   (GpRegion * region, GpMatrix * matrix, BOOL * isEqual) const;
    BOOL     IsOnePath () const
    {
        ASSERT(IsValid());
    
        return ((Type & REGIONTYPE_LEAF) != 0);
    }
    BOOL     IsRect () const
    {
        return (IsOnePath() && (Type != TypePath));
    }
    const GpPath * GetPath() const
    {
        ASSERT(Type == TypePath);
        return Path;
    }

    GpStatus Transform(GpMatrix * matrix);
    GpStatus Offset   (REAL xOffset, REAL yOffset);

    GpStatus Combine(
        const GpRectF *     rect,
        CombineMode         combineMode
        );

    GpStatus Combine(
        const GpPath *      path,
        CombineMode         combineMode
        );

    GpStatus Combine(
        GpRegion *          region,
        CombineMode         combineMode
        );

    GpStatus And (GpRectF * rect)
    {
        return Combine (rect, CombineModeIntersect);
    }

    GpStatus And (GpPath * path)
    {
        return Combine (path, CombineModeIntersect);
    }

    GpStatus And (GpRegion * region)
    {
        return Combine (region, CombineModeIntersect);
    }

    GpStatus Or (GpRectF * rect)
    {
        return Combine (rect, CombineModeUnion);
    }

    GpStatus Or (GpPath * path)
    {
        return Combine (path, CombineModeUnion);
    }

    GpStatus Or (GpRegion * region)
    {
        return Combine (region, CombineModeUnion);
    }

    GpStatus Xor (GpRectF * rect)
    {
        return Combine (rect, CombineModeXor);
    }

    GpStatus Xor (GpPath * path)
    {
        return Combine (path, CombineModeXor);
    }

    GpStatus Xor (GpRegion * region)
    {
        return Combine (region, CombineModeXor);
    }

    GpStatus Exclude (GpRectF * rect)
    {
        return Combine (rect, CombineModeExclude);
    }

    GpStatus Exclude (GpPath * path)
    {
        return Combine (path, CombineModeExclude);
    }

    GpStatus Exclude (GpRegion * region)
    {
        return Combine (region, CombineModeExclude);
    }

    GpStatus Complement (GpRectF * rect)
    {
        return Combine (rect, CombineModeComplement);
    }

    GpStatus Complement (GpPath * path)
    {
        return Combine (path, CombineModeComplement);
    }

    GpStatus Complement (GpRegion * region)
    {
        return Combine (region, CombineModeComplement);
    }

};

#endif _REGION_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\regiontopath.hpp ===
/******************************Module*Header*******************************\
* 
* Copyright (c) 1999 Microsoft Corporation
*
* Module Name:
*
*   Region to Path Conversion Class
*
* Abstract:
*
*   Converts an arbitrary GpRegion to GpPath equivalent.  It first
*   analyzes the GpRegion for simple conversion cases which it handles.
*   If the region is complex, then it invokes Kirk Olynyk's region to
*   path conversion routine.
*
* Notes:
*
*
* Created:
*
*   10/29/1999 ericvan
*
\**************************************************************************/

/*********************************Class************************************\
* class RTP_EPATHOBJ : publci EPATHOBJ                                     *
*                                                                          *
*   Adds diagonalization.                                                  *
*                                                                          *
* Public Interface:                                                        *
*                                                                          *
* History:                                                                 *
*  Wed 15-Sep-1993 10:06:05 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

/**************************************************************************\
*  class RTP_PATHMEMOBJ : public PATHMEMOBJ                                *
*                                                                          *
* This class is for converting regions to paths                            *
*                                                                          *
\**************************************************************************/

const FLONG LastPointFlag = 1;
const UINT MAX_ENUMERATERECTS = 20;

class RegionToPath
{
private:
    BOOL        bMoreToEnum;

    const DpRegion  *region;
    DynByteArray  *types;
    DynByteArray  inTypes;          // accumulated types
    DynPointArray *points;
    DynPointArray inPoints;         // accumulated points

    GpPoint*    curPoint;
    BYTE*       curType;

    GpPoint*    firstPoint;      // first point in current subpath
    GpPoint*    lastPoint;
    BOOL        endSubpath;
    
    INT         outPts;         // number of points in output buffer
    GpPoint     writePts[2];    // output buffer
    GpPoint     AB;             // aptfx[1] - aptfx[0]

    INT         curIndex;       // start of circular buffer (current corner)
    INT         lastCount;      //

    INT         numPts;
    FLONG       flags[3];
    GpPoint     pts[3];

    FLONG       afl[3];         // array of flags for the vertices
    UINT        aptfx[3];       // array of vertex positions

public:

    RegionToPath() {}
    ~RegionToPath() {}

    BOOL ConvertRegionToPath(const DpRegion* region,
                             DynPointArray& newPoints,
                             DynByteArray& newTypes);

private:

    BOOL DiagonalizePath();
    BOOL FetchNextPoint();
    BOOL WritePoint();

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\stringformat.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   stringFormat.cpp
*
* Abstract:
*
*   Implementation for the string formatting class
*
* Revision History:
*
*   12 April 2000  dbrown
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"


GpStringFormat *GpStringFormat::GenericDefaultPointer     = NULL;
GpStringFormat *GpStringFormat::GenericTypographicPointer = NULL;

BYTE GpStringFormat::GenericDefaultStaticBuffer    [sizeof(GpStringFormat)] = {0};
BYTE GpStringFormat::GenericTypographicStaticBuffer[sizeof(GpStringFormat)] = {0};


GpStringFormat *GpStringFormat::GenericDefault()
{
    if (GenericDefaultPointer != NULL)
    {
        return GenericDefaultPointer;
    }

    // Initialise static GpStringFormat class

    // Create the GpStringFormat without allocating memory by using object placement
    GenericDefaultPointer = new(GenericDefaultStaticBuffer) GpStringFormat();
    ASSERT(GenericDefaultPointer->Flags == DefaultFormatFlags);
    GenericDefaultPointer->LeadingMargin  = DefaultMargin;
    GenericDefaultPointer->TrailingMargin = DefaultMargin;
    GenericDefaultPointer->Tracking       = DefaultTracking;
    GenericDefaultPointer->Trimming       = StringTrimmingCharacter;
    GenericDefaultPointer->Permanent      = TRUE;

    return GenericDefaultPointer;
}

GpStringFormat *GpStringFormat::GenericTypographic()
{
    if (GenericTypographicPointer != NULL)
    {
        return GenericTypographicPointer;
    }

    // Initialise static GpStringFormat class

    // Create the GpStringFormat without allocating memory by using object placement
    GenericTypographicPointer = new(GenericTypographicStaticBuffer) GpStringFormat();
    GenericTypographicPointer->Flags |= (StringFormatFlagsNoFitBlackBox | StringFormatFlagsNoClip | StringFormatFlagsLineLimit);
    GenericTypographicPointer->LeadingMargin  = 0.0;
    GenericTypographicPointer->TrailingMargin = 0.0;
    GenericTypographicPointer->Tracking       = 1.0;
    GenericTypographicPointer->Trimming       = StringTrimmingNone;
    GenericTypographicPointer->Permanent      = TRUE;

    return GenericTypographicPointer;
}

GpStringFormat *GpStringFormat::Clone() const
{
    // Get a binary copy
    GpStringFormat *newFormat = new GpStringFormat();

    if (newFormat)
    {
        newFormat->Flags             = Flags;
        newFormat->Language          = Language;
        newFormat->StringAlign       = StringAlign;
        newFormat->LineAlign         = LineAlign;
        newFormat->DigitSubstitute   = DigitSubstitute;
        newFormat->DigitLanguage     = DigitLanguage;
        newFormat->FirstTabOffset    = FirstTabOffset;
        newFormat->TabStops          = NULL;
        newFormat->CountTabStops     = CountTabStops;
        newFormat->HotkeyPrefix      = HotkeyPrefix;
        newFormat->LeadingMargin     = LeadingMargin;
        newFormat->TrailingMargin    = TrailingMargin;
        newFormat->Tracking          = Tracking;
        newFormat->Trimming          = Trimming;
        newFormat->RangeCount        = RangeCount;
        newFormat->Permanent         = NULL;

        newFormat->UpdateUid();

        if (TabStops)
        {
            REAL *newTabStops = NULL;

            newTabStops = new REAL [CountTabStops];

            if (newTabStops)
            {
                newFormat->TabStops = newTabStops;

                GpMemcpy(newFormat->TabStops, TabStops, sizeof(REAL) * CountTabStops);
            }
            else
            {
                delete newFormat;
                return NULL;
            }
        }

        if (Ranges)
        {
            CharacterRange *newRanges = NULL;

            newRanges = new CharacterRange [RangeCount];

            if (newRanges)
            {
                newFormat->Ranges = newRanges;

                for (INT i = 0; i < RangeCount; i++)
                {
                    newFormat->Ranges[i] = Ranges[i];
                }
            }
            else
            {
                if (TabStops)
                {
                    delete [] TabStops;
                }
                delete newFormat;
                newFormat = NULL;
            }
        }
    }

    return newFormat;
}


GpStatus GpStringFormat::SetMeasurableCharacterRanges(
    INT     rangeCount,
    const CharacterRange *ranges
)
{
    BOOL updated = FALSE;
    CharacterRange *newRanges = NULL;

    if (ranges && rangeCount > 0)
    {
        newRanges = new CharacterRange [rangeCount];

        if (!newRanges)
        {
            return OutOfMemory;
        }
    }

    if (Ranges)
    {
        //  Clear old ranges

        delete [] Ranges;

        Ranges = NULL;
        RangeCount = 0;
        updated = TRUE;
    }

    if (newRanges)
    {
        for (INT i = 0; i < rangeCount; i++)
        {
            newRanges[i] = ranges[i];
        }

        Ranges = newRanges;
        RangeCount = rangeCount;
        updated = TRUE;
    }

    if (updated)
    {
        UpdateUid();
    }
    return Ok;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\regiontopath.cpp ===
/**************************************************************************\
*                                                                          *
* Copyright (c) 1998  Microsoft Corporation                                *
*                                                                          *
* Module Name:                                                             *
*                                                                          *
*   Region to Path Conversion class.                                       *
*                                                                          *
* Abstract:                                                                *
*                                                                          *
*   Code from Kirk Olynyk [kirko] created 14-Sep-1993.  This code will     *
*   convert rectangular regions to a path by analyzing the DDA pattern.    *
*                                                                          *
* Discussion:                                                              *
*                                                                          *
* Input                                                                    *
*                                                                          *
*     The input to the diagonalization routing is a rectangular            *
*     path whose vertices have integer endpoints.  Moreover it             *
*     is required that the path always has the region on its               *
*     left and that successive lines are mutually orthogonal.              *
*                                                                          *
*     All paths are in device 28.4 coordinates.  (Since all of             *
*     the input coordinates are integers, the fractional part of all       *
*     coordinates is zero.)                                                *
*                                                                          *
* Output                                                                   *
*                                                                          *
*     A path that contains the same pixels as the originl path.            *
*                                                                          *
* Filling Convention                                                       *
*                                                                          *
*     Any region bounded by two non-horizontal lines is closed             *
*     on the left and open on the right. If the region is bounded          *
*     by two horizontal lines, it is closed on the top and open on         *
*     bottom.                                                              *
*                                                                          *
* Definition                                                               *
*                                                                          *
*     A CORNER is subsequence of two lines from the orignal axial path.    *
*     It is convenient to partition the set of corners into two classes;   *
*     HORIZONTAL-VERTIAL and VERTICAL-HORIZONTAL.                          *
*                                                                          *
*     A corner is "diagonalizable" the original two lines can be replaced  *
*     by a single diagonal line such that same pixels would be rendered    *
*     (using the filling convention defined above).                        *
*                                                                          *
*                                                                          *
* Nomenclature                                                             *
*                                                                          *
*       S ::= "SOUTH" ::= one pixel move in +y-direction                   *
*       N ::= "NORTH" ::= one pixel move in -y-direction                   *
*       E ::= "EAST"  ::= one pixel move in +x direction                   *
*       W ::= "WEST"  ::= one pixel move in -x direction                   *
*                                                                          *
*     The set of diagonalizable corners are described by                   *
*     the following regular expressions:                                   *
*                                                                          *
*      DIAGONALIZABLE CORNERS                                              *
*                                                                          *
*         S(E+|W+)  a one pixel move in the +y-direction                   *
*                   followed by at least one pixel in any horizontal       *
*                   direction                                              *
*                                                                          *
*         S+W       an arbitary number of pixels in the +y-direction       *
*                   followed by a single pixel move in the                 *
*                   negative x-direction.                                  *
*                                                                          *
*         EN+       a one pixel move in the positive x-direction           *
*                   followed by at least one pixel move in the negative    *
*                   x-direction                                            *
*                                                                          *
*         (E+|W+)N  at least one-pixel move in the horizontal followed     *
*                   by a single pixel move in the negative                 *
*                   y-direction.                                           *
*                                                                          *
* Algorithm                                                                *
*                                                                          *
* BEGIN                                                                    *
*    <For each corner in the orginal path>                                 *
*    BEGIN                                                                 *
*        <if the corner is diagonalizable> THEN                            *
*                                                                          *
*            <just draw a single diagonal line>                            *
*        ELSE                                                              *
*            <draw both legs of the original corner>                       *
*    END                                                                   *
*                                                                          *
*    <Go around the path once again, merging successive                    *
*     identical moves into single lines>                                   *
* END                                                                      *
*                                                                          *
*     In the code, both of these steps are done in parallel                *
*                                                                          *
* Further Improvements                                                     *
*                                                                          *
*  The output path the I generate with this algorithm will contain only    *
*  points that were vertices of the original axial path. A larger of       *
*  regular expressions could be searched for if I were willing to          *
*  consider using new vertices for the output path. For example            *
*  the regular exprssios N+WN and S+ES describe two "chicane turns" that   *
*  can be diagonalized. The price to be paid is the a more complex         *
*  code path.                                                              *
*                                                                          *
\**************************************************************************/

#include "precomp.hpp"

/******************************Public*Routine******************************\
* RegionToPath::ConvertRegionToPath                                        *
*                                                                          *
*   Takes an enumerable clip region as input and outputs a path            *
*                                                                          *
* Assumptions                                                              *
*                                                                          *
*   0. *this is the original path which will not be changed.               *
*   1. All points on the path lie on integers                              *
*   2. All subpaths have the inside on the left                            *
*   3. All subpaths are closed                                             *
*                                                                          *
* History:                                                                 *
*  Mon 13-Sep-1993 15:53:50 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

BOOL RegionToPath::ConvertRegionToPath(const DpRegion* inRegion,
                                       DynPointArray& newPoints,
                                       DynByteArray& newTypes)
{
    BOOL result;

    curIndex = 0;
    
    // initialize array to reasonable no. of points + types

    points = &newPoints;
    types = &newTypes;
    
    newPoints.Reset();
    newTypes.Reset();
    
    region = inRegion;

    if (region->IsSimple()) 
    {
        GpRect bounds;

        region->GetBounds(&bounds);

        newPoints.Add(GpPoint(bounds.X, bounds.Y));
        newPoints.Add(GpPoint(bounds.X + bounds.Width, bounds.Y));
        newPoints.Add(GpPoint(bounds.X + bounds.Width, bounds.Y + bounds.Height));
        newPoints.Add(GpPoint(bounds.X, bounds.Y + bounds.Height));
        
        newTypes.Add(PathPointTypeStart);
        newTypes.Add(PathPointTypeLine);
        newTypes.Add(PathPointTypeLine);
        newTypes.Add(PathPointTypeLine | PathPointTypeCloseSubpath);

        return TRUE;
    }
    
    inPoints.Reset();
    inTypes.Reset();

    // convert region to right angle piecewise line segments
    if (region->GetOutlinePoints(inPoints, inTypes) == TRUE)
    {   
        curPoint = (GpPoint*) inPoints.GetDataBuffer();
        curType = (BYTE*) inTypes.GetDataBuffer();

        BOOL result = TRUE;
        
        lastPoint = &inPoints.Last();

        while (curPoint<=lastPoint && result) 
        {
            endSubpath = FALSE;
            firstPoint = curPoint;
            result = DiagonalizePath();
        }

	        return result;
    }
    else
        return FALSE;
}

/******************************Public*Routine******************************\
* RTP_PATHMEMOBJ::bWritePoint                                              *
*                                                                          *
* This routine takes as input a candidate point for writing. However       *
* this routine is smart in that it analyzes the stream of candidate        *
* points looking for consecutive sub-sets of points that all lie on the    *
* same line. When such a case is recognized, then only the endpoints of    *
* the interpolating line are actually added to the output path.            *
*                                                                          *
* I do not go to a great deal of trouble to determine if a candidate       *
* point is on a line. All that I do is to see if the vector increment      *
* to the new point  is the same as the increment between prior points      *
* in the input path.                                                       *
*                                                                          *
* History:                                                                 *
*  Mon 13-Sep-1993 15:53:35 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

BOOL RegionToPath::WritePoint()
{
    GpPoint  NewAB;
    BOOL result = TRUE;
    int  jA = curIndex;

    if (outPts == 2)
    {
        NewAB.X = pts[jA].X - writePts[1].X;
        NewAB.Y = pts[jA].Y - writePts[1].Y;
        
        if (NewAB.X != AB.X || NewAB.Y != AB.Y)
        {
            points->Add(writePts[0]);
            types->Add(PathPointTypeLine);
            
            writePts[0] = writePts[1];
            AB = NewAB;
        }

        writePts[1] = pts[jA];
    }
    else if (outPts == 0)
    {
        writePts[0] = pts[jA];
        outPts += 1;
    }
    else if (outPts == 1)
    {
        writePts[1] = pts[jA];
        AB.X = writePts[1].X - writePts[0].X;
        AB.Y = writePts[1].Y - writePts[0].Y;
        outPts += 1;
    }
    else
    {
        RIP(("RegionToPath::WritePoint -- point count is bad"));
        result = FALSE;
    }
    
    return(result);
}

/******************************Public*Routine******************************\
* bFetchNextPoint  ... in sub-path                                         *
*                                                                          *
* History:                                                                 *
*  Tue 14-Sep-1993 14:13:01 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

BOOL RegionToPath::FetchNextPoint()
{
    INT oldIndex = curIndex;

    curIndex = (curIndex + 1) % 3;

    // only output the first point if at end of a subpath
    if (endSubpath)
    {
        // end of subpath, add first point on end of new path
        flags[oldIndex] = 0;
        pts[oldIndex] = *firstPoint;
        return TRUE;
    }
    
    pts[oldIndex] = *curPoint;

    // check for end subpath only?
    if (*curType & PathPointTypeCloseSubpath)
    {
        endSubpath = TRUE;
        flags[oldIndex] = LastPointFlag;
    }
    else
    {
        flags[oldIndex] = 0;
    }
    curPoint++;
    curType++;

    return TRUE;
}

/******************************Public*Routine******************************\
* Path2Region::bDiagonalizeSubPathRTP_PATHMEMOBJ::bDiagonalizeSubPath      *
*                                                                          *
* History:                                                                 *
*  Tue 14-Sep-1993 12:47:49 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

inline VOID RotateBackward(INT& x, INT& y, INT& z)
{
    INT temp;

    temp = x;
    x = z;
    z = y;
    y = temp;
}

inline VOID RotateForward(INT& x, INT& y, INT& z)
{
    INT temp;

    temp = x;
    x = y;
    y = z;
    z = temp;
}

BOOL RegionToPath::DiagonalizePath()
{
    INT AB;               // Length of leg A->B
    INT BC;               // Length of second leg B->C

    INT bH;                // set to 1 if second leg is horizontal
    INT jA,jB,jC;
    
    register BOOL bRet = TRUE; // if FALSE then return immediately
                               // otherwise keep processing.

    outPts  = 0;              // no points so far in the write buffer
    curIndex = 0;             // set the start of the circular buffer
    lastCount = 0;

    // Fill the circular buffer with the first three points of the
    // path. The three member buffer, defines two successive lines, or
    // one corner (the path is guaranteed to be composed of alternating
    // lines along the x-axis and y-axis). I shall label the three vertices
    // of the corner A,B, and C. The point A always resides at ax[j],
    // point B resides at ax[iMod3[j+1]], and point C resides at
    // ax[iMod3[j+2]] where j can have one of the values 0, 1, 2.

    if (bRet = FetchNextPoint() && FetchNextPoint() && FetchNextPoint())
    {
        ASSERTMSG(curIndex == 0, ("RegionToPath::DiagonalizeSubPath()"
                                  " -- curIndex != 0"));

        // bH ::= <is the second leg of the corner horizontal?>
        //
        // if the second leg of the corner is horizontal set bH=1 otherwise
        // set bH=0. Calculate the length of the first leg of the corner
        // and save it in fxAB. Note that I do not need to use the iMod3
        // modulus operation since j==0.

        if (pts[2].Y == pts[1].Y)
        {
            bH = 1;
            AB = pts[1].Y - pts[0].Y;
        }
        else
        {
            bH = 0;
            AB = pts[1].X - pts[0].X;
        }

        // Start a new subpath at the first point of the subpath.

        points->Add(pts[0]);
        types->Add(PathPointTypeStart);
        
        jA = 0;
        jB = 1;
        jC = 2;
    }

    while (bRet)
    {
        
        if (!(flags[jA] & LastPointFlag))
        {
            // Assert that the the legs of the corner are along
            // the axes, and that the two legs are mutually
            // orthogonal

            ASSERTMSG(pts[jC].X == pts[jB].X || pts[jC].Y == pts[jB].Y,
                ("Bad Path :: C-B is not axial"));
            
            ASSERTMSG(pts[jA].X == pts[jB].X || pts[jA].Y == pts[jB].Y,
                ("Bad Path :: B-A is not axial"));
            
            ASSERTMSG(
                (pts[jC].X - pts[jB].X) *
                (pts[jB].X - pts[jA].X)
                +
                (pts[jC].Y - pts[jB].Y) *
                (pts[jB].Y - pts[jA].Y)
                == 0,
                ("Bad Path :: B-A is not orthogonal to C-B")
                );
        }
        
        // If the first vertex of the corner is the last point in the
        // original subpath then we terminate the processing.  This point
        // has either been recorded with PATHMEMOBJ::bMoveTo or
        // PATHMEMOBJ::bPolyLineTo.  All that remains is to close the
        // subpath which is done outside the while loop

        if (flags[jA] & LastPointFlag)
            break;

        // There are two paths through the following if-else clause
        // They are for VERTICAL-HORIZONTAL and HORIZONTAL-VERTICAL
        // corners respectively. These two clauses are identical
        // except for the interchange of ".x" with ".y". It might be
        // a good idea to have macros or subrouines for these sections
        // in order that they be guranteed to be identical.

        // Is the second leg of the corner horizontal?

        if (bH)
        {
            // Yes, the second leg of the corner is horizontal

            BC = pts[jC].X - pts[jB].X;

            // Is the corner diagonalizable?

            if ((AB > 0) && ((AB == 1) || (BC == -1)))
            {
                // Yes, the corner is diagonalizable
                //
                // If the middle of the corner was the last point in the
                // original path then the last point in the output path
                // is the first point in the corner. This is because the
                // last line in the output path is this diagonalized
                // corner which will be produced automatically by the
                // CloseFigure() call after this while-loop. Thus, in
                // this case we would just break out of the loop.

                if (flags[jB] & LastPointFlag)
                    break;

                // The corner is diagonalizable. This means that we are no
                // longer interested in the first two points of this corner.
                // We therefore fetch the next two points of the path
                // an place them in our circular corner-buffer.

                if (!(bRet = FetchNextPoint() && FetchNextPoint()))
                    break;

                // under modulo 3 arithmetic, incrementing by 2 is
                // equivalent to decrementing by 1

                RotateBackward(jA,jB,jC);

                // fxAB is set to the length of the first leg of the new
                // corner.

                AB = pts[jB].Y - pts[jA].Y;
            }
            else
            {
                // No, the corner is not diagonalizable
                //
                // The corner cannot be diagonalized. Advance the corner
                // to the next point in the original path. The orientation
                // of the second leg of the corner will change. The length
                // of the first leg of the new corner is set equal to the
                // length of the second leg of the previous corner.

                if (!(bRet = FetchNextPoint()))
                    break;

                RotateForward(jA,jB,jC);
                bH  ^= 1;
                AB = BC;
            }
        }
        else
        {
            // Diagonalize the HORIZONTAL->VERTICAL corner

            BC = pts[jC].Y - pts[jB].Y;
            if ((BC < 0) && ((AB == 1) || (BC == -1)))
            {
                if (flags[jB] & LastPointFlag)
                    break;
                
                if (!(bRet = FetchNextPoint() && FetchNextPoint()))
                    break;
                
                RotateBackward(jA,jB,jC);
                AB = pts[jB].X - pts[jA].X;
            }
            else
            {
                if (!(bRet = FetchNextPoint()))
                    break;
                
                RotateForward(jA,jB,jC);
                bH  ^= 1;
                AB  = BC;
            }
        }
        
        if (!(bRet = WritePoint()))
            break;
        
    }

    if (bRet)
    {
        ASSERTMSG(outPts == 2, ("GDI Region To Path -- numPts is not 2"));

        points->Add(writePts[0]);
        points->Add(writePts[1]);
        types->Add(PathPointTypeLine);
        types->Add(PathPointTypeLine | PathPointTypeCloseSubpath);
    }

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\vectormath.hpp ===
/**************************************************************************
*
* Copyright (c) 2000 Microsoft Corporation
*
* Module Name:
*
*   Vector/Matrix mathematics
*
* Abstract:
*
*   Defines some vector mathematics for use by the ICM conversion code.
*
* Notes:
*
*   <optional>
*
* Created:
*
*   04/08/2000 asecchia
*      Created it.
*
**************************************************************************/

#ifndef _VECTORMATH_HPP
#define _VECTORMATH_HPP

#define VECTORSIZE 3

namespace VectorMath {


class Vector
{
    public:
    friend class Matrix;
    Vector() {}
    Vector(REAL x, REAL y, REAL z)
    {
        ASSERT((VECTORSIZE==3));
        data[0]=x;
        data[1]=y;
        data[2]=z;
    }

    Vector operator *(REAL k)
    {
        Vector v;
        for(int i=0; i<VECTORSIZE; i++) 
        {
            v.data[i] = data[i] * k;
        }
        return v;
    }

    Vector operator +(Vector V)
    {
        Vector v;
        for(int i=0; i<VECTORSIZE; i++) 
        {
            v.data[i] = data[i] + V.data[i];
        }
        return v;
    }
    
    REAL operator *(Vector V)
    {
        REAL r = 0.0f;
        for(int i=0; i<VECTORSIZE; i++) 
        {
            r += data[i] * V.data[i];
        }
        return r;
    }

    REAL data[VECTORSIZE];
};


class Matrix
{
    public:
    friend class Vector;

    Matrix() {}
    Matrix(REAL a, REAL b, REAL c,
           REAL d, REAL e, REAL f,
           REAL g, REAL h, REAL i)
    {
        ASSERT((VECTORSIZE==3));
        data[0][0] = a;
        data[0][1] = b;
        data[0][2] = c;
        data[1][0] = d;
        data[1][1] = e;
        data[1][2] = f;
        data[2][0] = g;
        data[2][1] = h;
        data[2][2] = i;
    }

    // Diagonalize a vector
    Matrix(Vector V)
    {
        ASSERT((VECTORSIZE==3));
        data[0][0] = V.data[0];
        data[1][0] = 0;
        data[2][0] = 0;
        data[0][1] = 0;
        data[1][1] = V.data[1];
        data[2][1] = 0;
        data[0][2] = 0;
        data[1][2] = 0;
        data[2][2] = V.data[2];
    }

    Matrix operator *(REAL k)
    {
        Matrix m;
        for(int i=0; i<VECTORSIZE; i++)
        {
            for(int j=0; j<VECTORSIZE; j++)
            {
                m.data[i][j] = data[i][j] * k;
            }
        }
        return m;
    }

    Vector operator *(Vector v)
    {
        Vector R(0,0,0);

        for(int j=0; j<VECTORSIZE; j++)
        {
            for(int i=0; i<VECTORSIZE; i++)
            {
                R.data[j] += data[j][i] * v.data[i];
            }
        }

        return R;
    }

    Matrix operator *(Matrix m)
    {
        Matrix R(0,0,0,
                 0,0,0,
                 0,0,0);

        for(int j=0; j<VECTORSIZE; j++) 
        {
            for(int i=0; i<VECTORSIZE; i++)
            {
                for(int k=0; k<VECTORSIZE; k++)
                {
                    R.data[j][i] += data[j][k] * m.data[k][i];
                }
            }
        }

        return R;
    }

    // Flip the matrix along the main diagonal
    Matrix Transpose() 
    {
        Matrix R;

        for(int j=0; j<VECTORSIZE; j++)
        {
            for(int i=0; i<VECTORSIZE; i++) 
            {
                R.data[j][i] = data[i][j];
            }
        }

        return R;
    }

    REAL Determinant() 
    {
        ASSERT((VECTORSIZE==3));
        return (
          // Compute the 3x3 matrix determinant.
            -data[0][2]*data[1][1]*data[2][0] + 
             data[0][1]*data[1][2]*data[2][0] + 
             data[0][2]*data[1][0]*data[2][1] - 
             data[0][0]*data[1][2]*data[2][1] - 
             data[0][1]*data[1][0]*data[2][2] + 
             data[0][0]*data[1][1]*data[2][2]
        );
    }

    Matrix Adjoint()
    {
        ASSERT((VECTORSIZE==3));
        Matrix m(
         // Adjoint matrix - transpose of the cofactor matrix.

            -data[1][2]*data[2][1] + data[1][1]*data[2][2],
             data[0][2]*data[2][1] - data[0][1]*data[2][2],
            -data[0][2]*data[1][1] + data[0][1]*data[1][2],

             data[1][2]*data[2][0] - data[1][0]*data[2][2], 
            -data[0][2]*data[2][0] + data[0][0]*data[2][2],
             data[0][2]*data[1][0] - data[0][0]*data[1][2],

            -data[1][1]*data[2][0] + data[1][0]*data[2][1],
             data[0][1]*data[2][0] - data[0][0]*data[2][1],
            -data[0][1]*data[1][0] + data[0][0]*data[1][1]

        );
        return m;
    }

    Matrix Inverse()
    {
        Matrix m;
        m = Adjoint();
        REAL det = Determinant();
        if(REALABS(det) < REAL_EPSILON) 
        {
            m = Matrix(0,0,0,0,0,0,0,0,0);
        }
        else 
        {
            m = m * (1.0f/det);
        }
        return m;
    }

    REAL data[VECTORSIZE][VECTORSIZE];
};

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\textimager.hpp ===
#ifndef _TEXTIMAGER_HPP
#define _TEXTIMAGER_HPP


#define DriverStringOptionsMetaPlay  0x80000000



class GpTextImager
{
friend class FullTextImager;

public:
    GpTextImager() : IsMetaFileRecording(FALSE) {};


    virtual ~GpTextImager() {};

    virtual Status GetStatus() const = 0;

    virtual GpStatus Draw(GpGraphics *graphics, const PointF *origin) = 0;

    virtual GpStatus AddToPath(GpPath *path, const PointF *origin) = 0;

    virtual GpStatus Measure(
        GpGraphics *graphics,
        REAL       *nearGlyphEdge,      // Excudes overhang
        REAL       *farGlyphEdge,       // Excludes overhang
        REAL       *textDepth,
        INT        *codepointsFitted,
        INT        *linesFilled
    ) = 0;

    virtual GpStatus MeasureRanges(
        GpGraphics      *graphics,
        const PointF    *origin,
        GpRegion        **regions
    ) = 0;

    static void CleanupTextImager();

    BOOL &GetMetaFileRecordingFlag()
    {
        return IsMetaFileRecording;
    }

protected:
    BOOL IsMetaFileRecording;

};


/////   newTextImager
//
//      Creates a new text imager.
//
//      If any form of error occurs during the imager creation, an error status
//      is returned, and any allocated memory is released.


GpStatus newTextImager(
    const WCHAR           *string,
    INT                    length,
    REAL                   width,
    REAL                   height,
    const GpFontFamily    *family,
    INT                    style,
    REAL                   size,
    const GpStringFormat  *format,
    const GpBrush         *brush,
    GpTextImager         **imager,
    BOOL                   singleUse    // Enables use of simple formatter when no format passed
);





/////   ReadCmap - in engine\text\imager\cmap.cpp

GpStatus ReadCmap(
    BYTE           *cmapTable,
    INT             cmapLength,
    IntMap<UINT16> *cmap,
    BOOL           *bSymbol
);


/////   ReadMtx - in engine\text\imager\hmtx.cpp
//
//      Reads hmtx or vmtx table

GpStatus ReadMtx(
    BYTE           *Mtx,
    UINT            MtxLength,
    INT             numGlyphs,
    INT             numberOfLongMetrics,
    IntMap<UINT16> *designAdvance
);

GpStatus ReadMtxSidebearing(
    BYTE           *mtx,
    UINT            mtxLength,
    INT             numGlyphs,
    INT             numberOfLongMetrics,
    IntMap<UINT16> *sidebearing
);


/////   in engine\text\uniscribe\gsub.cxx
//
//      Examine gsub or mort for 'vert' features and supported scripts

void LoadVerticalSubstitution(
    const BYTE     *gsub,
    UINT16         *substitutionCount,
    const UINT16  **originals,    // returned as pointer into gsub, not endian converted
    const UINT16  **substitutions // returned as pointer into gsub, not endian converted
);

void LoadMortVerticalSubstitution(
    BYTE           *mort,
    UINT16         *substitutionCount,
    const UINT16  **originals,    // returned as pointer into mort, not endian converted
    const UINT16  **substitutions // returned as pointer into mort, not endian converted
);

void SubstituteVerticalGlyphs(
    UINT16        *glyphs,        // InOut
    UINT16         glyphCount,
    UINT16         substitutionCount,
    const UINT16  *originals,
    const UINT16  *substitutions
);



/**************************************************************************\
*
* SplitTransform:
*
*   Separates a transform into the sequence
*
*   o  scale        x always positive, y positive or negative
*   o  rotate       0 - 2pi
*   o  shear        along original x (as a positive or negative factor of y)
*   o  translate    any x,y
*
* Arguments:
*
*   IN   transform
*   OUT  scale
*   OUT  rotate
*   OUT  shear
*   OUT  translate
*
* Return Value:
*
*   none
*
* Created:
*
*   06/18/99 dbrown
*
* !!!
*   SplitTransform should probably be in matrix.hpp
*
\**************************************************************************/

void SplitTransform(
    const GpMatrix  &matrix,
    PointF          &scale,
    REAL            &rotate,
    REAL            &shear,
    PointF          &translate
);




/////   DetermineStringComplexity
//
//      Returns whether string contains complex script characters and/or digits. 

void DetermineStringComplexity(
    const UINT16 *string, 
    INT           length, 
    BOOL         *complex, 
    BOOL         *digitSeen
);


// SetTextLinesAntialiasMode
// make underline/strikeout/path rendering consistent with text antialiasing mode
// turn it on for AntiAlias and AntiAliasGridFit (excluding 'gasp' table case)
class SetTextLinesAntialiasMode
{
    GpGraphics *    Graphics;
    BOOL            OldMode;
public:
    SetTextLinesAntialiasMode(GpGraphics * graphics, const GpFaceRealization * faceRealization)
        : Graphics(0), OldMode(0)
    {
        SetAAMode(graphics, faceRealization);
    }
    void SetAAMode(GpGraphics * graphics, const GpFaceRealization * faceRealization)
    {
        ASSERT(!Graphics); // otherwise we lose old AA mode
        Graphics = graphics;
        if (!Graphics)
        {
            ASSERT(!faceRealization);
        }
        else
        {
            OldMode = Graphics->GetAntiAliasMode();

            ASSERT(faceRealization);

            TextRenderingHint hint = faceRealization->IsPathFont()
                ? Graphics->GetTextRenderingHintInternal()
                : faceRealization->RealizationMethod();

            BOOL newMode = FALSE;
            if (hint == TextRenderingHintAntiAlias)
                newMode = TRUE;
            else if (hint == TextRenderingHintAntiAliasGridFit)
            {
                if (faceRealization->IsPathFont())
                    newMode = TRUE;
                else
                {
                    if (faceRealization->IsHorizontalTransform() ||  faceRealization->IsVerticalTransform())
                        newMode = FALSE; // otherwise underline looks fuzzy
                    else
                        newMode = TRUE;
                }
            }
            Graphics->SetAntiAliasMode(newMode);
        }
    }
    ~SetTextLinesAntialiasMode()
    {
        if (Graphics)
            Graphics->SetAntiAliasMode(OldMode);
    }
}; // class SetTextLinesAntialiasMode

// This class is used if we call public GpGraphics methods
// from another public GpGraphics method to avoid extra GDI+ records
// We have to set g->Metafile to NULL so we don't record all the GDI+ records
// in the metafile again -- only the down-level ones.
class EmfPlusDisabler
{
    IMetafileRecord **  MetafileRef;
    IMetafileRecord *   SavedMetafile;
public:
    EmfPlusDisabler(IMetafileRecord ** metafileRef)
    {
        MetafileRef = metafileRef;
        SavedMetafile = *MetafileRef;
        *MetafileRef = 0;
    }
    ~EmfPlusDisabler()
    {
        *MetafileRef = SavedMetafile;
    }
}; // class EmfPlusDisabler

#endif // _TEXTIMAGER_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\stringformat.hpp ===
/**************************************************************************\
*
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   stringFormat.hpp
*
* Abstract:
*
*   String and text format definition
*
* Revision History:
*
*   08/05/1999 dbrown
*       Created it.
*
\**************************************************************************/

#ifndef _STRINGFORMAT_HPP
#define _STRINGFORMAT_HPP

const REAL DefaultMargin   = REAL(1.0/6.0);
const REAL DefaultTracking = REAL(1.03);
const REAL DefaultBottomMargin = REAL(1.0/8.0);

const INT DefaultFormatFlags = 0;

const StringTrimming DefaultTrimming = StringTrimmingCharacter;

// Private StringFormatFlags

const INT StringFormatFlagsPrivateNoGDI                = 0x80000000;
const INT StringFormatFlagsPrivateAlwaysUseFullImager  = 0x40000000;
const INT StringFormatFlagsPrivateUseNominalAdvance    = 0x20000000;
const INT StringFormatFlagsPrivateFormatPersisted      = 0x10000000;

class StringFormatRecordData : public ObjectData
{
public:
    INT32                    Flags;
    LANGID                   Language;
    GpStringAlignment        StringAlign;
    GpStringAlignment        LineAlign;
    GpStringDigitSubstitute  DigitSubstitute;
    LANGID                   DigitLanguage;
    REAL                     FirstTabOffset;
    INT32                    HotkeyPrefix;
    REAL                     LeadingMargin;
    REAL                     TrailingMargin;
    REAL                     Tracking;
    StringTrimming           Trimming;
    INT32                    CountTabStops;
    INT32                    RangeCount;
};

//
// Represent a string format object
//

class GpStringFormat : public GpObject
{
protected:
    VOID SetValid(BOOL valid)
    {
        GpObject::SetValid(valid ? ObjectTagStringFormat : ObjectTagInvalid);
    }

public:

    GpStringFormat() :
        Flags                 (DefaultFormatFlags),
        Language              (LANG_NEUTRAL),
        StringAlign           (StringAlignmentNear),
        LineAlign             (StringAlignmentNear),
        DigitSubstitute       (StringDigitSubstituteUser),
        DigitLanguage         (LANG_NEUTRAL),
        FirstTabOffset        (0.0),
        TabStops              (NULL),
        CountTabStops         (0),
        HotkeyPrefix          (HotkeyPrefixNone),
        LeadingMargin         (DefaultMargin),
        TrailingMargin        (DefaultMargin),
        Tracking              (DefaultTracking),
        Trimming              (StringTrimmingCharacter),
        Ranges                (NULL),
        RangeCount            (0),
        Permanent             (FALSE)
    {
        SetValid(TRUE);     // default is valid
    }

    GpStringFormat(INT flags, LANGID language) :
        Flags                 (flags),
        Language              (language),
        StringAlign           (StringAlignmentNear),
        LineAlign             (StringAlignmentNear),
        DigitSubstitute       (StringDigitSubstituteUser),
        DigitLanguage         (LANG_NEUTRAL),
        FirstTabOffset        (0.0),
        TabStops              (NULL),
        CountTabStops         (0),
        HotkeyPrefix          (HotkeyPrefixNone),
        LeadingMargin         (DefaultMargin),
        TrailingMargin        (DefaultMargin),
        Tracking              (DefaultTracking),
        Trimming              (StringTrimmingCharacter),
        Ranges                (NULL),
        RangeCount            (0),
        Permanent             (FALSE)
    {
        SetValid(TRUE);     // default is valid
    }

    ~GpStringFormat()
    {
        if (TabStops)
            delete [] TabStops;

        if (Ranges)
            delete [] Ranges;
    }


    static GpStringFormat *GenericDefault();
    static GpStringFormat *GenericTypographic();

    static void DestroyStaticObjects()
    {
        // these objects are created as a static but constructed in the
        // GenericDefault() and GenericTypographic(). we need to destruct
        // it just in case the user called SetTapStop which allocate memory
        // inside this object and by this way we prevent any memory leak.

        if (GenericDefaultPointer != NULL)
        {
            GenericDefaultPointer->~GpStringFormat();

            // Zero the memory - this is risky code, so we want the memory
            // to match what it was when GDI+ started up.

            memset(GenericDefaultPointer, 0, sizeof(GpStringFormat));

            GenericDefaultPointer = NULL;
        }

        if (GenericTypographicPointer != NULL)
        {
            GenericTypographicPointer->~GpStringFormat();

            // Zero the memory - this is risky code, so we want the memory
            // to match what it was when GDI+ started up.

            memset(GenericTypographicPointer, 0, sizeof(GpStringFormat));

            GenericTypographicPointer = NULL;
        }

        return;
    }

    GpStringFormat *Clone() const;


    GpStatus SetFormatFlags(INT flags)
    {
        if (Flags != flags)
        {
            Flags = flags;
            UpdateUid();
        }
        return Ok;
    }

    INT GetFormatFlags() const
    {
        return Flags;
    }

    GpStatus SetAlign(GpStringAlignment align)
    {
        if (StringAlign != align)
        {
            StringAlign = align;
            UpdateUid();
        }
        return Ok;
    }

    GpStatus GetAlign(GpStringAlignment *align) const
    {
        *align = StringAlign;
        return Ok;
    }

    GpStringAlignment GetPhysicalAlignment() const
    {
        if (    !(Flags & StringFormatFlagsDirectionRightToLeft)
            ||  StringAlign == StringAlignmentCenter
            ||  Flags & StringFormatFlagsDirectionVertical)
        {
            return StringAlign;
        }
        else if (StringAlign == StringAlignmentNear)
        {
            return StringAlignmentFar; // RTL near = right
        }
        else
        {
            return StringAlignmentNear; // RTL far = left
        }
    }

    GpStringAlignment GetAlign() const
    {
        return StringAlign;
    }


    GpStatus SetLineAlign(GpStringAlignment align)
    {
        if (LineAlign != align)
        {
            LineAlign = align;
            UpdateUid();
        }
        return Ok;
    }

    GpStatus GetLineAlign(GpStringAlignment *align) const
    {
        *align = LineAlign;
        return Ok;
    }

    GpStringAlignment GetLineAlign() const
    {
        return LineAlign;
    }


    GpStatus SetHotkeyPrefix (INT hotkeyPrefix)
    {
        if (HotkeyPrefix != hotkeyPrefix)
        {
            HotkeyPrefix = hotkeyPrefix;
            UpdateUid();
        }
        return Ok;
    }

    GpStatus GetHotkeyPrefix (INT *hotkeyPrefix) const
    {
        if (!hotkeyPrefix)
            return InvalidParameter;

        *hotkeyPrefix = HotkeyPrefix;
        return Ok;
    }

    INT GetHotkeyPrefix () const
    {
        return HotkeyPrefix;
    }


    GpStatus SetTabStops (
        REAL    firstTabOffset,
        INT     countTabStops,
        const REAL *tabStops
    )
    {
        if (countTabStops > 0)
        {
            //  We do not support negative tabulation (tab position
            //  advances in the opposite direction of reading order)

            if (firstTabOffset < 0)
            {
                return NotImplemented;
            }

            for (INT i = 0; i < countTabStops; i++)
            {
                if (tabStops[i] < 0)
                {
                    return NotImplemented;
                }
            }

            REAL *newTabStops = new REAL [countTabStops];

            if (!newTabStops)
            {
                return OutOfMemory;
            }

            if (TabStops)
            {
                delete [] TabStops;
            }

            TabStops = newTabStops;

            GpMemcpy (TabStops, tabStops, sizeof(REAL) * countTabStops);
            CountTabStops   = countTabStops;
            FirstTabOffset  = firstTabOffset;
            UpdateUid();
        }
        return Ok;
    }

    GpStatus GetTabStopCount (
        INT     *countTabStops
    ) const
    {
        if (!countTabStops)
        {
            return InvalidParameter;
        }

        *countTabStops = CountTabStops;

        return Ok;
    }

    GpStatus GetTabStops (
        REAL    *firstTabOffset,
        INT     countTabStops,
        REAL    *tabStops
    ) const
    {
        if (   !firstTabOffset
            || !tabStops)
        {
            return InvalidParameter;
        }

        INT count;

        if (countTabStops <= CountTabStops)
            count = countTabStops;
        else
            count = CountTabStops;

        GpMemcpy(tabStops, TabStops, sizeof(REAL) * count);

        *firstTabOffset = FirstTabOffset;

        return Ok;
    }

    INT GetTabStops (
        REAL    *firstTabOffset,
        REAL    **tabStops
    ) const
    {
        *firstTabOffset = FirstTabOffset;
        *tabStops       = TabStops;

        return CountTabStops;
    }


    GpStatus SetMeasurableCharacterRanges(
        INT     rangeCount,
        const CharacterRange *ranges
    );


    INT GetMeasurableCharacterRanges(
        CharacterRange **ranges = NULL
    ) const
    {
        if (ranges)
        {
            *ranges = Ranges;
        }
        return RangeCount;
    }


    GpStatus SetDigitSubstitution(
        LANGID                 language,
        StringDigitSubstitute  substitute = StringDigitSubstituteNational
    )
    {
        if (DigitSubstitute != substitute || DigitLanguage != language)
        {
            DigitSubstitute = substitute;
            DigitLanguage   = language;
            UpdateUid();
        }
        return Ok;
    }

    GpStatus GetDigitSubstitution(
        LANGID                 *language,
        StringDigitSubstitute  *substitute
    ) const
    {
        if(substitute)
        {
            *substitute = DigitSubstitute;
        }
        if(language)
        {
            *language   = DigitLanguage;
        }
        return Ok;
    }

    GpStatus SetLeadingMargin(REAL margin)
    {
        if (LeadingMargin != margin)
        {
            LeadingMargin = margin;
            UpdateUid();
        }
        return Ok;
    }

    REAL GetLeadingMargin() const
    {
        return LeadingMargin;
    }


    GpStatus SetTrailingMargin(REAL margin)
    {
        if (TrailingMargin != margin)
        {
            TrailingMargin = margin;
            UpdateUid();
        }
        return Ok;
    }

    REAL GetTrailingMargin() const
    {
        return TrailingMargin;
    }


    GpStatus SetTracking(REAL tracking)
    {
        if (Tracking != tracking)
        {
            Tracking = tracking;
            UpdateUid();
        }
        return Ok;
    }

    REAL GetTracking() const
    {
        return Tracking;
    }



    GpStatus SetTrimming(StringTrimming trimming)
    {
        if (Trimming != trimming)
        {
            Trimming = trimming;
            UpdateUid();
        }
        return Ok;
    }

    GpStatus GetTrimming(StringTrimming *trimming) const
    {
        ASSERT(trimming != NULL);
        if (trimming == NULL)
        {
            return InvalidParameter;
        }
        *trimming = Trimming;
        return Ok;
    }

    virtual BOOL IsValid() const
    {
        // If the string format came from a different version of GDI+, its tag
        // will not match, and it won't be considered valid.
        return GpObject::IsValid(ObjectTagStringFormat);
    }

    virtual ObjectType GetObjectType() const { return ObjectTypeStringFormat; }

    virtual GpStatus GetData(IStream * stream) const
    {
        ASSERT (stream);

        StringFormatRecordData  stringFormatData;

        stringFormatData.Flags             = Flags;
        stringFormatData.Language          = Language;
        stringFormatData.StringAlign       = StringAlign;
        stringFormatData.LineAlign         = LineAlign;
        stringFormatData.DigitSubstitute   = DigitSubstitute;
        stringFormatData.DigitLanguage     = DigitLanguage;
        stringFormatData.FirstTabOffset    = FirstTabOffset;
        stringFormatData.LineAlign         = LineAlign;
        stringFormatData.CountTabStops     = CountTabStops;
        stringFormatData.HotkeyPrefix      = HotkeyPrefix;
        stringFormatData.LeadingMargin     = LeadingMargin;
        stringFormatData.TrailingMargin    = TrailingMargin;
        stringFormatData.Tracking          = Tracking;
        stringFormatData.Trimming          = Trimming;
        stringFormatData.CountTabStops     = CountTabStops;
        stringFormatData.RangeCount        = RangeCount;

        stream->Write(
            &stringFormatData,
            sizeof(stringFormatData),
            NULL
        );

        stream->Write(
            TabStops,
            CountTabStops * sizeof(TabStops[0]),
            NULL
        );

        stream->Write(
            Ranges,
            RangeCount * sizeof(Ranges[0]),
            NULL
        );

        return Ok;
    }

    virtual UINT GetDataSize() const
    {
        UINT    size = sizeof(StringFormatRecordData);

        size += (CountTabStops * sizeof(TabStops[0]));
        size += (RangeCount * sizeof(Ranges[0]));

        return size;
    }

    virtual GpStatus SetData(const BYTE * dataBuffer, UINT size)
    {
        if ((dataBuffer == NULL) || (size < (sizeof(StringFormatRecordData) - sizeof(REAL))))
        {
            WARNING(("dataBuffer too small"));
            return InvalidParameter;
        }

        const StringFormatRecordData *stringFormatData =
            (const StringFormatRecordData *)dataBuffer;

        if (!stringFormatData->MajorVersionMatches())
        {
            WARNING(("Version number mismatch"));
            return InvalidParameter;
        }

        Flags                 = stringFormatData->Flags | StringFormatFlagsPrivateFormatPersisted;
        Language              = stringFormatData->Language;
        StringAlign           = stringFormatData->StringAlign;
        LineAlign             = stringFormatData->LineAlign;
        DigitSubstitute       = stringFormatData->DigitSubstitute;
        DigitLanguage         = stringFormatData->DigitLanguage;
        FirstTabOffset        = stringFormatData->FirstTabOffset;
        LineAlign             = stringFormatData->LineAlign;
        CountTabStops         = stringFormatData->CountTabStops;
        HotkeyPrefix          = stringFormatData->HotkeyPrefix;
        LeadingMargin         = stringFormatData->LeadingMargin;
        TrailingMargin        = stringFormatData->TrailingMargin;
        Tracking              = stringFormatData->Tracking;
        Trimming              = stringFormatData->Trimming;
        CountTabStops         = stringFormatData->CountTabStops;
        RangeCount            = stringFormatData->RangeCount;


        if (size <
            (  sizeof(StringFormatRecordData)
             + sizeof(TabStops[0]) * CountTabStops
             + sizeof(Ranges[0]) * RangeCount))
        {
            return InvalidParameter;
        }


        //  Propagate tab stops

        if (TabStops)
        {
            delete [] TabStops;
        }

        TabStops = new REAL [CountTabStops];
        if (TabStops == NULL)
        {
            return OutOfMemory;
        }

        REAL *tabStops = (REAL *)(&stringFormatData[1]);
        for (INT i = 0; i < CountTabStops; i++)
        {
            TabStops[i] = tabStops[i];
        }


        //  Propagate ranges

        if (Ranges)
        {
            delete [] Ranges;
        }

        Ranges = new CharacterRange [RangeCount];
        if (Ranges == NULL)
        {
            if (TabStops)
            {
                delete [] TabStops;
            }
            return OutOfMemory;
        }

        CharacterRange *ranges = (CharacterRange *)(&tabStops[CountTabStops]);
        for (INT i = 0; i < RangeCount; i++)
        {
            Ranges[i] = ranges[i];
        }

        UpdateUid();

        return Ok;
    }

    BOOL IsPermanent() const
    {
        return Permanent;
    }

    // we override the new operator for this class just to use it for object
    // placement. we didn't make the new placemenet global because it will
    // conflict with office because they link with GdiPlus statically.
    // we didn't override the delete operator because it is fine to use the
    // global one in \engine\runtime\Mem.h

    void* operator new(size_t size)
    {
        return GpMalloc(size);
    }

    void* operator new(size_t size, void* p)
    {
        return p;
    }

    // Digit Substitution
    const ItemScript GetDigitScript() const
    {
        return GetDigitSubstitutionsScript(DigitSubstitute, DigitLanguage);
    }

private:

    INT                      Flags;
    LANGID                   Language;
    GpStringAlignment        StringAlign;
    GpStringAlignment        LineAlign;
    GpStringDigitSubstitute  DigitSubstitute;
    LANGID                   DigitLanguage;
    REAL                     FirstTabOffset;
    REAL                    *TabStops;       // absolute tab stops in world unit
    INT                      CountTabStops;
    INT                      HotkeyPrefix;
    REAL                     LeadingMargin;  // relative to body font em size
    REAL                     TrailingMargin; // relative to body font em size
    REAL                     Tracking;       // scale factor
    GpStringTrimming         Trimming;
    CharacterRange          *Ranges;         // character ranges
    INT                      RangeCount;     // number of ranges
    BOOL                     Permanent;

    GpStringFormat(const GpStringFormat &format)
    {
        // This should never get called! Use Clone instead!
        ASSERT(FALSE);
    }


    // The following static variables support the generic StringFormats

    // Pointers (initialised at load time to null)

    static GpStringFormat *GenericDefaultPointer;
    static GpStringFormat *GenericTypographicPointer;

    // Memory allocation for generic structures. Note that we must allocate
    // load time memory as BYTE arrays to avoid creating a dependency on
    // the CRT for class construction.
    // The definitions (which specify the size) are in StringFormat.cpp.

    static BYTE GenericDefaultStaticBuffer[];
    static BYTE GenericTypographicStaticBuffer[];
};

#endif // !_STRINGFORMAT_HPP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\xbezier.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Abstract:
*
*   Implementation of XBezier class and its DDA.
*
* History:
*
*   11/05/1999 ikkof
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

//==========================================================================
// GpXBezier class
//==========================================================================

GpXBezier::~GpXBezier()
{
    if(Data)
        GpFree(Data);
}

GpStatus
GpXBezier::SetBeziers(INT order, const GpPointF* points, INT count)
{
    ASSERT(points && order > 1 && count > order && count % order == 1);

    if(!points || order <= 1 || count <= order || count % order != 1)
        return InvalidParameter;

    GpStatus status = Ok;
    INT totalSize = 2*count*sizeof(REALD);

    REALD* data = (REALD*) GpRealloc(Data, totalSize);
    if(data)
    {
        REALD* dataPtr = data;
        GpPointF* ptr = (GpPointF*) points;

        for(INT i = 0; i < count; i++)
        {
            *dataPtr++ = ptr->X;
            *dataPtr++ = ptr->Y;
            ptr++;
        }

        NthOrder = order;
        Dimension = 2;
        Count = count;
        Data = data;
        status = Ok;
    }
    else
        status = OutOfMemory;

    return status;
}

GpStatus
GpXBezier::SetBeziers(INT order, const GpXPoints& xpoints)
{
    ASSERT(xpoints.Count % order == 1);
    if(xpoints.Count % order != 1)
        return InvalidParameter;

    INT totalSize = xpoints.Dimension*xpoints.Count*sizeof(REALD);

    REALD* data = (REALD*) GpRealloc(Data, totalSize);
    if(data)
    {
        NthOrder = order;
        Dimension = xpoints.Dimension;
        Count = xpoints.Count;
        GpMemcpy(data, xpoints.Data, totalSize);
        Data = data;
    }

    return Ok;
}


/**************************************************************************\
*
* Function Description:
*
* Flattens the series of Bezier control points and stores
* the results to the arrays of the flatten points.
*
* Arguments:
*
*   [OUT] flattenPts - the returned flattend points.
*   [IN] matrix - Specifies the transform
*
* Return Value:
*
*   NONE
*
* Created:
*
*   11/05/1999 ikkof
*       Created it.
*
\**************************************************************************/
   
GpStatus
GpXBezier::Flatten(
    DynPointFArray* flattenPts,
    const GpMatrix *matrix
    )
{
    if(flattenPts == NULL)
        return InvalidParameter;

    GpXBezierDDA dda;
    REALD*  bezierData = Data;
    INT bezierDataStep = Dimension*NthOrder;
    BOOL isFirstBezier = TRUE;

    INT count = Count;

    flattenPts->Reset(FALSE);

    while(count > 1)
    {
        FlattenEachBezier(
            flattenPts,
            dda,
            isFirstBezier,
            matrix,
            bezierData);

        count -= NthOrder;
        bezierData += bezierDataStep;
        isFirstBezier = FALSE;
    }

    return Ok;
}

/**************************************************************************\
*
* Function Description:
*
* Transforms the control points.
*
* Arguments:
*
*   [IN] matrix - Specifies the transform
*
* Return Value:
*
*   NONE
*
* Created:
*
*   11/05/1999 ikkof
*       Created it.
*
\**************************************************************************/
   
VOID
GpXBezier::Transform(
    GpMatrix *matrix
    )
{
    FPUStateSaver fpuState;

    if(matrix == NULL || !Data || Count <= 0)
        return;

    // Since this is the 2D transform, we transform only
    // the first two component.

    GpPointF pt;
    INT j = 0;

    for(INT i = 0; i < Count; i++)
    {
        pt.X = TOREAL(Data[j]);
        pt.Y = TOREAL(Data[j+1]);
        matrix->Transform(&pt, 1);
        Data[j] = pt.X;
        Data[j + 1] = pt.Y;
        j += Dimension;
    }
    
    return;
}

/**************************************************************************\
*
* Function Description:
*
*   Returns the bounds in the specified transform.
*   This first calculates the bounds of the control points
*   in the world coordinates.
*   Then it converts the bounds in the given transform.
*   Therefore, this is bigger than the real bounds.
*
* Arguments:
*
*   [IN] matrix - Specifies the transform
*   [OUT] bounds - Returns the bounding rectangle
*
* Return Value:
*
*   NONE
*
* Created:
*
*   12/16/1998 ikkof
*       Created it.
*
\**************************************************************************/

VOID
GpXBezier::GetBounds(
    GpMatrix* matrix,
    GpRect* bounds
    )
{
    ASSERT(IsValid());

    // Currently only Dimension = 2 case is implemented.

    if(Dimension != 2)
        return;

    INT count = Count;

    if (count == 0)
    {
        bounds->X = 0;
        bounds->Y = 0;
        bounds->Width = 0;
        bounds->Height = 0;
    }
    else
    {
        FPUStateSaver fpuState;

        REALD* data = Data;

        REALD left = *data;
        REALD right = left;
        REALD top = *data++;
        REALD bottom = top;
        count--;
        REALD x, y;

        while(count > 0)
        {
            x = *data++;
            y = *data++;

            if (x < left)
                left = x;
            if (y < top)
                top = y;
            if (x > right)
                right = x;
            if (y > bottom)
                bottom = y;
            count--;
        }

        GpRectF     boundsF;
        TransformBounds(
            matrix,
            TOREAL(left),
            TOREAL(top),
            TOREAL(right),
            TOREAL(bottom), &boundsF);
        BoundsFToRect(&boundsF, bounds);
    }
}

GpStatus
GpXBezier::Get2DPoints(
    GpPointF* points,
    INT count,
    const REALD* dataPoints,
    const GpMatrix* matrix)
{
    ASSERT(points && dataPoints && count > 0);

    if(points && dataPoints && count > 0)
    {
        FPUStateSaver fpuState;

        GpPointF* ptr = points;
        const REALD* dataPtr = dataPoints;
        INT i, j = 0;
        GpMatrix identityMatrix;
        const GpMatrix* mat = matrix;
        if(!mat)
            mat = &identityMatrix;

        switch(Dimension)
        {
        case 2:
            for(i = 0; i < count; i++)
            {
                ptr->X = TOREAL(*dataPtr++);
                ptr->Y = TOREAL(*dataPtr++);
                ptr++;
            }
            mat->Transform(points, count);
            break;

        case 3:
            for(i = 0; i < count; i++)
            {
                REALD x, y, w;
                x = *dataPtr++;
                y = *dataPtr++;
                w = *dataPtr++;

                // Do the perspective projection.

                ptr->X = TOREAL(x/w);
                ptr->Y = TOREAL(y/w);
                ptr++;
            }
            mat->Transform(points, count);

        default:
            // Not implemented yet.
            break;
        }

        return Ok;
    }

    return InvalidParameter;
}

/**************************************************************************\
*
* Function Description:
*
* Flattens a given cubic Bezier curve.
*
* Arguments:
*
*   [OUT] flattenPts - the returned flattend points.
*   [IN] points - the four control points for a Cubic Bezier
*
* Return Value:
*
*   NONE
*
* Created:
*
*   02/10/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpStatus
GpXBezier::FlattenEachBezier(
    DynPointFArray* flattenPts,
    GpXBezierDDA& dda,
    BOOL isFirstBezier,
    const GpMatrix *matrix,
    const REALD* bezierData
    )
{
    GpPointF pts[7];

    if(Get2DPoints(&pts[0], NthOrder + 1, bezierData, matrix) != Ok)
        return GenericError;

    // Use DDA to flatten a Bezier.

    GpPointF nextPt;

    GpXPoints xpoints(&pts[0], NthOrder + 1);

    if(xpoints.Data == NULL)
        return OutOfMemory;

    dda.SetBezier(xpoints, FlatnessLimit, DistanceLimit);
    dda.InitDDA(&nextPt);

    GpPointF buffer[BZ_BUFF_SIZE];
    INT count = 0;

    // If this is the first Bezier curve, add the first point.

    if(isFirstBezier)
    {
        buffer[count++] = nextPt;
    }

    while(dda.GetNextPoint(&nextPt))
    {
        if(count < BZ_BUFF_SIZE)
            buffer[count++] = nextPt;
        else
        {
            flattenPts->AddMultiple(&buffer[0], count);
            buffer[0] = nextPt;
            count = 1;
        }
        dda.MoveForward();
    }
    
    // Add the last point.

    if(count < BZ_BUFF_SIZE)
        buffer[count++] = nextPt;
    else
    {
        flattenPts->AddMultiple(&buffer[0], count);
        buffer[0] = nextPt;
        count = 1;
    }
    flattenPts->AddMultiple(&buffer[0], count);

    return Ok;
}


/**************************************************************************\
*
* Function Description:
*
* Initialized constants needed for DDA of General Bezier.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* Created:
*
*   02/10/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpXBezierConstants::GpXBezierConstants()
{
    INT i, j;


    for(i = 0; i <= 6; i++)
    {
        GpMemset(&H[i][0], 0, 7*sizeof(REAL));
        GpMemset(&D[i][0], 0, 7*sizeof(REAL));
        GpMemset(&S[i][0], 0, 7*sizeof(REAL));
    }

    // Matrix for half step
    H[0][0] = 1;
    H[1][0] = 0.5;      // = 1/2
    H[1][1] = 0.5;      // = 1/2
    H[2][0] = 0.25;     // = 1/4
    H[2][1] = 0.5;      // = 1/2
    H[2][2] = 0.25;     // = 1/4
    H[3][0] = 0.125;    // = 1/8
    H[3][1] = 0.375;    // = 3/8
    H[3][2] = 0.375;    // = 3/8
    H[3][3] = 0.125;    // = 1/8
    H[4][0] = 0.0625;   // = 1/16
    H[4][1] = 0.25;     // = 1/4
    H[4][2] = 0.375;    // = 3/8
    H[4][3] = 0.25;     // = 1/4
    H[4][4] = 0.0625;   // = 1/16
    H[5][0] = 0.03125;  // = 1/32
    H[5][1] = 0.15625;  // = 5/32
    H[5][2] = 0.3125;   // = 5/16
    H[5][3] = 0.3125;   // = 5/16
    H[5][4] = 0.15625;  // = 5/32
    H[5][5] = 0.03125;  // = 1/32
    H[6][0] = 0.015625; // = 1/64
    H[6][1] = 0.09375;  // = 3/32
    H[6][2] = 0.234375; // = 15/64
    H[6][3] = 0.3125;   // = 5/16
    H[6][4] = 0.234375; // = 15/64
    H[6][5] = 0.09375;  // = 3/32
    H[6][6] = 0.015625; // = 1/64

    // Matrix for double step
    D[0][0] = 1;
    D[1][0] = -1;
    D[1][1] = 2;
    D[2][0] = 1;
    D[2][1] = -4;
    D[2][2] = 4;
    D[3][0] = -1;
    D[3][1] = 6;
    D[3][2] = -12;
    D[3][3] = 8;
    D[4][0] = 1;
    D[4][1] = -8;
    D[4][2] = 24;
    D[4][3] = -32;
    D[4][4] = 16;
    D[5][0] = -1;
    D[5][1] = 10;
    D[5][2] = -40;
    D[5][3] = 80;
    D[5][4] = -80;
    D[5][5] = 32;
    D[6][0] = 1;
    D[6][1] = -12;
    D[6][2] = 60;
    D[6][3] = -160;
    D[6][4] = 240;
    D[6][5] = -192;
    D[6][6] = 64;

    // Matrix for one step
    S[0][0] = 1;
    S[1][0] = 2;
    S[1][1] = -1;
    S[2][0] = 4;
    S[2][1] = -4;
    S[2][2] = 1;
    S[3][0] = 8;
    S[3][1] = -12;
    S[3][2] = 6;
    S[3][3] = -1;
    S[4][0] = 16;
    S[4][1] = -32;
    S[4][2] = 24;
    S[4][3] = -8;
    S[4][4] = 1;
    S[5][0] = 32;
    S[5][1] = -80;
    S[5][2] = 80;
    S[5][3] = -40;
    S[5][4] = 10;
    S[5][5] = -1;
    S[6][0] = 64;
    S[6][1] = -192;
    S[6][2] = 240;
    S[6][3] = -160;
    S[6][4] = 60;
    S[6][5] = -12;
    S[6][6] = 1;

    F[0][0] = 1;
    F[0][1] = 1;
    F[0][2] = 1;
    F[0][3] = 1;
    F[0][4] = 1;
    F[0][5] = 1;
    F[0][6] = 1;
    F[1][1] = 1;
    F[1][2] = 2;
    F[1][3] = 3;
    F[1][4] = 4;
    F[1][5] = 5;
    F[1][6] = 6;
    F[2][2] = 1;
    F[2][3] = 3;
    F[2][4] = 6;
    F[2][5] = 10;
    F[2][6] = 15;
    F[3][3] = 1;
    F[3][4] = 4;
    F[3][5] = 10;
    F[3][6] = 20;
    F[4][4] = 1;
    F[4][5] = 5;
    F[4][6] = 15;
    F[5][5] = 1;
    F[5][6] = 6;
    F[6][6] = 1;

    H6[0][0] = 1;
    H6[1][0] = 1;
    H6[1][1] = 1.0/6;
    H6[2][0] = 1;
    H6[2][1] = 1.0/3;
    H6[2][2] = 1.0/15;
    H6[3][0] = 1;
    H6[3][1] = 1.0/2;
    H6[3][2] = 1.0/5;
    H6[3][3] = 1.0/20;
    H6[4][0] = 1;
    H6[4][1] = 2.0/3;
    H6[4][2] = 2.0/5;
    H6[4][3] = 1.0/5;
    H6[4][4] = 1.0/15;
    H6[5][0] = 1;
    H6[5][1] = 5.0/6;
    H6[5][2] = 2.0/3;
    H6[5][3] = 1.0/2;
    H6[5][4] = 1.0/3;
    H6[5][5] = 1.0/6;
    H6[6][0] = 1;
    H6[6][1] = 1;
    H6[6][2] = 1;
    H6[6][3] = 1;
    H6[6][4] = 1;
    H6[6][5] = 1;
    H6[6][6] = 1;

    G6[0][0] = 1;
    G6[1][0] = -6;
    G6[1][1] = 6;
    G6[2][0] = 15;
    G6[2][1] = -30;
    G6[2][2] = 15;
    G6[3][0] = -20;
    G6[3][1] = 60;
    G6[3][2] = -60;
    G6[3][3] = 20;
    G6[4][0] = 15;
    G6[4][1] = -60;
    G6[4][2] = 90;
    G6[4][3] = -60;
    G6[4][4] = 15;
    G6[5][0] = -6;
    G6[5][1] = 30;
    G6[5][2] = -60;
    G6[5][3] = 60;
    G6[5][4] = -30;
    G6[5][5] = 6;
    G6[6][0] = 1;
    G6[6][1] = -6;
    G6[6][2] = 15;
    G6[6][3] = -20;
    G6[6][4] = 15;
    G6[6][5] = -6;
    G6[6][6] = 1;
}

GpStatus
GpXPoints::Transform(const GpMatrix* matrix)
{
    return TransformPoints(matrix, Data, Dimension, Count);
}

GpStatus
GpXPoints::TransformPoints(
    const GpMatrix* matrix,
    REALD* data,
    INT dimension,
    INT count
    )
{
    if(matrix == NULL || data == NULL
        || dimension == 0 || count == 0)
        return Ok;

    // !! This code should consider using Matrix->Transform.
    if(dimension >= 2)
    {
        FPUStateSaver fpuState;

        INT j = 0;

        // Transform only the first two axis.

        for(INT i = 0; i < count; i++)
        {
            GpPointF pt;

            pt.X = TOREAL(data[j]);
            pt.Y = TOREAL(data[j + 1]);
            matrix->Transform(&pt);
            data[j] = pt.X;
            data[j + 1] = pt.Y;
            
            j += dimension;
        }

        return Ok;
    }
    else
        return GenericError;
}


//==========================================================================
// Cubic Bezier class
//
// GpXBezierDDA class
//
// This is based on GDI's flatten path methods written
// by Paul Butzi and J. Andrew Gossen.
// Ikko Fushiki wrote this with different parameters
// and different flatness tests.
//==========================================================================

VOID
GpXBezierDDA::Initialize(
    VOID
    )
{
    INT i;

    T = 0;
    Dt = 1;
    NthOrder = 0;
    GpMemset(&P[0], 0, 16*sizeof(REALD));
    GpMemset(&Q[0], 0, 16*sizeof(REALD));

    NSteps = 1;
    
    // In order to avoid the later multiplication, we pre-multiply
    // the flatness limit by 3.
    FlatnessLimit = 3*FLATNESS_LIMIT;
    DistanceLimit = DISTANCE_LIMIT;
}

/**************************************************************************\
*
* Function Description:
*
* Set the control points of a CubicBezier.
*
* Arguments:
*
*   [IN] points - the four control points for a Cubic Bezier
*   [IN] flatnessLimit - used for flattening
*   [IN] distanceLimit - used for flattening
*
* Return Value:
*
*   NONE
*
* Created:
*
*   02/10/1999 ikkof
*       Created it.
*
\**************************************************************************/

VOID
GpXBezierDDA::SetBezier(
    const GpXPoints& xpoints,
    REAL flatnessLimit,
    REAL distanceLimit    
    )
{
    if(xpoints.Data == NULL)
        return;

    T = 0;
    Dt = 1;
    NthOrder = 0;
    INT totalCount = xpoints.Count*xpoints.Dimension;

    // This can handle the two dimensional Bezier of 6-th order
    // and the three and four dimensional Bezier of 3rd order.

    ASSERT(totalCount < 16);

    NthOrder = xpoints.Count - 1;
    Dimension = xpoints.Dimension;

    GpMemcpy(&Q[0], xpoints.Data, totalCount*sizeof(REALD));

    SetPolynomicalCoefficients();

    NSteps = 1;
    
    // In order to avoid the later multiplication, we pre-multiply
    // the flatness limit by 3.
    FlatnessLimit = 3*flatnessLimit;
    DistanceLimit = distanceLimit;
}

VOID
GpXBezierDDA::SetPolynomicalCoefficients(
    VOID
    )
{
    if(NthOrder == 6)
    {
        for(INT i = 0; i <= 6; i++)
        {
            REALD x[4];
            GpMemset(&x[0], 0, Dimension*sizeof(REALD));
            
            INT k, k0;

            for(INT j = 0; j <= i; j++)
            {
                k0 = Dimension*j;
                k = 0;

                while(k < Dimension)
                {
                    x[k] += C.G6[i][j]*Q[k0 + k];
                    k++;
                }
            }

            k0 = Dimension*i;
            GpMemcpy(&P[k0], &x[0], Dimension*sizeof(REALD));
        }
    }
}


/**************************************************************************\
*
* Function Description:
*
* Initializes DDA for CubicBezier and make one step forward.
* This must be called before GetNextPoint() is called.
*
* Arguments:
*
*   [OUT] pt - Returns the start point
*
* Return Value:
*
*   NONE
*
* Created:
*
*   02/10/1999 ikkof
*       Created it.
*
\**************************************************************************/

VOID
GpXBezierDDA::InitDDA(
    GpPointF* pt
    )
{
    switch(Dimension)
    {
    case 2:
        pt->X = (REAL) Q[0];
        pt->Y = (REAL) Q[1];
        break;

    case 3:
        // Do something
        break;

    default:
        // Do something
        break;
    }

    INT shift = 2;

    // Subdivide fast until it is flat enough
    while(NeedsSubdivide(FlatnessLimit))
    {
        HalveStepSize();
//        FastShrinkStepSize(shift);
    }

    // If it is subdivided too much, expand it.
    if((NSteps & 1) == 0)
    {
        // If the current subdivide is too small,
        // double it up.
        while(NSteps > 1 && !NeedsSubdivide(FlatnessLimit/4))
        {
            DoubleStepSize();
        }
    }

    // Take the first step forward.
    TakeStep();
}

/**************************************************************************\
*
* Function Description:
*
* Shrinks the current Bezier segment to half.
* The section of t = 0 -> 1/2 of the current
* Beizer segment becomes the new current segment.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* Created:
*
*   02/10/1999 ikkof
*       Created it.
*
\**************************************************************************/

VOID
GpXBezierDDA::HalveStepSize(
    VOID
    )
{
    INT i, j;
    REALD x[4];
    
    i = NthOrder;

    while(i >= 0)
    {
        j = i;

        GpMemset(&x[0], 0, Dimension*sizeof(REALD));
        
        INT k0, k;

        while(j >= 0)
        {
            k0 = Dimension*j;
            k = 0;
            while(k < Dimension)
            {
                x[k] += C.H[i][j]*Q[k0 + k];
                k++;
            }
               
            j--;
        }

        k0 = Dimension*i;
        GpMemcpy(&Q[k0], &x[0], Dimension*sizeof(REALD));
        i--;
    }

    NSteps <<= 1;   // The number of steps needed is doubled.
    Dt *= 0.5;
}

/**************************************************************************\
*
* Function Description:
*
* Doubles the current Bezier segment.
* The section of t = 0 -> 2 of the current
* Bezier segment becomes the new current segment.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* Created:
*
*   02/10/1999 ikkof
*       Created it.
*
\**************************************************************************/

VOID
GpXBezierDDA::DoubleStepSize(
    VOID
    )
{
    INT i, j;
    REALD   x[4];
    
    i = NthOrder;

    while(i >= 0)
    {
        j = i;

        GpMemset(&x[0], 0, Dimension*sizeof(REALD));

        INT k, k0;

        while(j >= 0)
        {
            k0 = Dimension*j;
            k = 0;

            while(k < Dimension)
            {
                x[k] += C.D[i][j]*Q[k0 + k];
                k++;
            }
            
            j--;
        }

        k0 = Dimension*i;
        GpMemcpy(&Q[k0], &x[0], Dimension*sizeof(REALD));
        i--;
    }

    NSteps >>= 1;   // The number of steps needed is halved.
    Dt *= 2;
}

/**************************************************************************\
*
* Function Description:
*
* Shrinks the current Bezier segment by (2^shift).
* The section of t = 0 -> 1/(2^shift) of the current
* Beizer segment becomes the new current segment.
* If shift > 0, this shrinks the step size.
* If shift < 0, this enlarge the step size.
*
* halfStepSize() is equal to fastShrinkStepSize(1).
* doubleStepSize() is equal to fastShrinkStepSize(-1).
*
* Arguments:
*
*   [INT] shift - the bits to shift
*
* Return Value:
*
*   NONE
*
* Created:
*
*   02/10/1998 ikkof
*       Created it.
*
\**************************************************************************/

VOID
GpXBezierDDA::FastShrinkStepSize(
    INT shift
    )
{
/*
    INT n = 1;
    if(shift > 0) {
        n <<= shift;
        Cx /= n;
        Cy /= n;
        n <<= shift;
        Bx /= n;
        By /= n;
        n <<= shift;
        Ax /= n;
        Ay /= n;

        NSteps <<= shift;   // Increase the number of steps.
    }
    else if(shift < 0) {
        n <<= - shift;
        Cx *= n;
        Cy *= n;
        n <<= - shift;
        Bx *= n;
        By *= n;
        n <<= - shift;
        Ax *= n;
        Ay *= n;

        NSteps >>= - shift; // Reduce the number of steps.
    }

    // Dx and Dy remain the same.
*/
}

/**************************************************************************\
*
* Function Description:
*
* Advances the current Bezeir segment to the next one.
* The section of t = 1 -> 2 of the current Bezier segment
* becoms the new current segment.
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* Created:
*
*   12/16/1998 ikkof
*       Created it.
*
\**************************************************************************/

VOID
GpXBezierDDA::TakeStep(
    VOID
    )
{
    REALD p[16];

    INT i, j;
    REALD x[4];
    
    i = NthOrder;

    if(NthOrder != 6)
    {
        while(i >= 0)
        {
            j = i;

            GpMemset(&x[0], 0, Dimension*sizeof(REALD));

            INT k0, k;

            while(j >= 0)
            {
                k0 = Dimension*(NthOrder - j);
                k = 0;

                while(k < Dimension)
                {
                    x[k] += C.S[i][j]*Q[k0 + k];
                    k++;
                }
                j--;
            }

            k0 = Dimension*i;
            k = 0;

            while(k < Dimension)
            {
                p[k0 + k] = x[k];
                k++;
            }
            i--;
        }

        GpMemcpy(&Q[0], &p[0], Dimension*(NthOrder + 1)*sizeof(REALD));
    }
    else
        TakeConvergentStep();

    NSteps--;   // Reduce one step.
    T += Dt;
}

VOID
GpXBezierDDA::TakeConvergentStep(
    VOID
    )
{
    REALD t[7], dt[7];
    INT i, j;

    t[0] = dt[0] = 1;
    for(i = 1; i <= 6; i++)
    {
        t[i] = t[i-1]*T;
        dt[i] = dt[i-1]*Dt;
    }

    REALD c[16];
    REALD x[4];
    INT k0, k;

    for(i = 0; i <= 6; i++)
    {
        GpMemset(&x[0], 0, Dimension*sizeof(REALD));

        for(j = i; j <= 6; j++)
        {
            k0 = Dimension*j;

            for(k = 0; k < Dimension; k++)
            {
                x[k] += C.F[i][j]*t[j-i]*dt[i]*P[k0 + k];
            }
        }

        k0 = Dimension*i;
        GpMemcpy(&c[k0], &x[0], Dimension*sizeof(REALD));
    }

    for(i = 0; i <= 6; i++)
    {
        GpMemset(&x[0], 0, Dimension*sizeof(REALD));

        for(j = 0; j <= i; j++)
        {
            k0 = Dimension*j;
            
            for(k = 0; k < Dimension; k++)
            {
                x[k] += C.H6[i][j]*c[k0 + k];
            }
        }
        
        k0 = Dimension*i;
        GpMemcpy(&Q[k0], &x[0], Dimension*sizeof(REALD));
    }
}
    
BOOL
GpXBezierDDA::Get2DDistanceVector(
    REALD* dx,
    REALD* dy,
    INT from,
    INT to
    )
{
    REALD p0[16], p1[16];
    INT k0, k;

    if(from < 0 || from > NthOrder || to < 0 || to > NthOrder)
        return FALSE;

    k0 = from*Dimension;
    GpMemcpy(&p0[0], &Q[k0], Dimension*sizeof(REALD));

    k0 = to*Dimension;
    GpMemcpy(&p1[0], &Q[k0], Dimension*sizeof(REALD));

    *dx = p1[0] - p0[0];
    *dy = p1[1] - p0[1];

    return TRUE;
}

/**************************************************************************\
*
* Function Description:
*
* Reurns true if more subdivision is necessary.
*
* Arguments:
*
*   [IN] flatnessLimit - flatness parameter
*
* Return Value:
*
*   Returns true if subdivision is necessary. Otherwise this returns false.
*
* Created:
*
*   02/10/1999 ikkof
*       Created it.
*
\**************************************************************************/

BOOL
GpXBezierDDA::NeedsSubdivide(
    REAL flatnessLimit
    )
{
    REALD mx, my;
    REALD baseLen;
    REALD dx, dy;

    // Get the base line vector.

    if(!Get2DDistanceVector(&dx, &dy, 0, NthOrder))
        return FALSE;
    
    // Get the perpendicular vector to the base line

    mx = - dy;
    my = dx;

    // Approximate the distance by absolute values of x and y components.
 
    baseLen = fabs(mx) + fabs(my);

    BOOL needsSubdivide = FALSE;

    // First check if the base length is larger than the distance limit.
    if(baseLen > DistanceLimit)
    {
        // Pre-multiply baseLen by flatness limit for convenience.
        baseLen *= flatnessLimit;
        
        INT i = 1;
        REALD dx, dy;

        while(i < NthOrder && !needsSubdivide)
        {
            Get2DDistanceVector(&dx, &dy, 0, i);

            if(fabs(dx*mx + dy*my) > baseLen)
                needsSubdivide = TRUE;
            i++;
        }
    }

    return needsSubdivide;
}

/**************************************************************************\
*
* Function Description:
*
* Returns the current start point.
* If this has reached the end point, this returns false.
*
* Arguments:
*
*   [OUT] pt - the current start point.
*
* Return Value:
*
*   Returns true if there is a next point.
*
* Created:
*
*   02/10/1999 ikkof
*       Created it.
*
\**************************************************************************/

BOOL
GpXBezierDDA::GetNextPoint(
    GpPointF* pt
    )
{
    // Copy the current start point;

    FPUStateSaver fpuState;

    switch(Dimension)
    {
    case 2:
        pt->X = TOREAL(Q[0]);
        pt->Y = TOREAL(Q[1]);
        break;

    case 3:
    default:
        // Do something for projection.
        return FALSE;
    }

    if(NSteps != 0)
        return TRUE;
    else
        return FALSE;   // Congratulations!  You have reached the end.
}

/**************************************************************************\
*
* Function Description:
*
* Moves to the next Bezier segment
*
* Arguments:
*
*   NONE
*
* Return Value:
*
*   NONE
*
* Created:
*
*   02/10/1999 ikkof
*       Created it.
*
\**************************************************************************/

VOID
GpXBezierDDA::MoveForward(
    VOID
    )
{
    // If the current subdivide is too big,
    // subdivide it.
    while(NeedsSubdivide(FlatnessLimit))
    {
        HalveStepSize();
    }


    if((NSteps & 1) == 0)
    {
        // If the current subdivide is too small,
        // double it up.
        while(NSteps > 1 && !NeedsSubdivide(FlatnessLimit/4))
        {
            DoubleStepSize();
        }
    }

    // Move to the next Bezier segment.
    TakeStep();
}

/**************************************************************************\
*
* Function Description:
*
* Returns the control points of the last Bezier segment
* which ends at the current point.
* The current point is given by calling getNextPoint().
* pts[] must have the dimension of 4.
*
* Arguments:
*
*   [OUT] pts - the Bezier control points
*
* Return Value:
*
*   NONE
*
* Created:
*
*   02/10/1999 ikkof
*       Created it.
*
\**************************************************************************/

INT
GpXBezierDDA::GetControlPoints(
        GpXPoints* xpoints
    )
{
    ASSERT(xpoints);

    if(xpoints == NULL)
        return 0;

    INT totalCount = Dimension*(NthOrder + 1);
    REALD* buff = (REALD*) GpRealloc(xpoints->Data, totalCount*sizeof(REALD));
    if(buff)
    {
        GpMemcpy(buff, &Q[0], Dimension*(NthOrder + 1)*sizeof(REALD));
        xpoints->Count = NthOrder + 1;
        xpoints->Dimension = Dimension;
        xpoints->Data = buff;

        return NthOrder + 1;
    }
    else
        return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\xbezier.hpp ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   XBezier.hpp
*
* Abstract:
*
*   Interface of GpXBezier and its DDA classes
*
* Revision History:
*
*   11/05/1999 ikkof
*       Created it.
*
\**************************************************************************/

#ifndef _XBEZIER_HPP
#define _XBEZIER_HPP

#define FLATNESS_LIMIT      0.25
#define DISTANCE_LIMIT      2.0
#define BZ_BUFF_SIZE    32

class GpXPoints
{
friend class GpXPath;
friend class GpXBezier;

public:

    INT Dimension;
    INT Count;  // Number of Points
    REALD* Data;

protected:
    BOOL IsDataAllocated;

public:

    GpXPoints()
    {
        Initialize();
    }

    // When XPoints is created from a given data with copyData = FALSE,
    // the caller is responsible for deleting the data after XPoints is no longer
    // used.

    GpXPoints(REALD* data, INT dimension, INT count, BOOL copyData = TRUE)
    {
        Initialize();
        SetData(data, dimension, count, copyData);
    }

    GpXPoints(GpPointF* points, INT count)
    {
        Initialize();

        if(points && count > 0)
        {
            Data = (REALD*) GpMalloc(2*count*sizeof(REALD));
            if(Data)
            {
                INT i = 0, j = 0;

                while(j < count)
                {
                    Data[i++] = points[j].X;
                    Data[i++] = points[j].Y;
                    j++;
                }
                Dimension = 2;
                Count = count;
                IsDataAllocated = TRUE;
            }
        }
    }

    GpXPoints(GpPointD* points, INT count)
    {
        Initialize();

        if(points && count > 0)
        {
            Data = (REALD*) GpMalloc(2*count*sizeof(REALD));
            if(Data)
            {
                INT i = 0, j = 0;

                while(j < count)
                {
                    Data[i++] = points[j].X;
                    Data[i++] = points[j].Y;
                    j++;
                }
                Dimension = 2;
                Count = count;
                IsDataAllocated = TRUE;
            }
        }
    }

    REALD* GetData() {return Data;}

    // When XPoints is created from a given data with copyData = FALSE,
    // the caller is responsible for deleting the data after XPoints is no longer
    // used.

    GpStatus
    SetData(REALD* data, INT dimension, INT count, BOOL copyData = TRUE)
    {
        GpStatus status = Ok;

        if(data && dimension > 0 || count > 0)
        {
            REALD* newData = NULL;

            if(copyData)
            {
               INT totalSize = dimension*count*sizeof(REALD);
               if(IsDataAllocated)
                   newData = (REALD*) GpRealloc(Data, totalSize);
               else
                   newData = (REALD*) GpMalloc(totalSize);

                if(newData)
                {
                    GpMemcpy(newData, data, totalSize);
                    IsDataAllocated;
                }
                else
                    status = OutOfMemory;
            }
            else
            {
                if(Data && IsDataAllocated)
                    GpFree(Data);
                newData = data;
                IsDataAllocated = FALSE;
            }

            if(status == Ok)
            {
                Dimension = dimension;
                Count = count;
                Data = newData;
            }
        }
        else
            status = InvalidParameter;

        return status;
    }

    GpStatus Transform(const GpMatrix* matrix);

    BOOL AreEqualPoints(INT index1, INT index2)
    {
        if(index1 < 0 || index1 >= Count
            || index2 < 0 || index2 >= Count || Data == NULL)
            return FALSE;   // either index is out of the range or no data.

        BOOL areEqual = TRUE;
        if(index1 != index2)
        {
            REALD* data1 = Data + index1*Dimension;
            REALD* data2 = Data + index2*Dimension;
            INT k = 0;
            while(k < Dimension && areEqual)
            {
                if(*data1++ != *data2++)
                    areEqual = FALSE;
                k++;
            }
        }

        return areEqual;
    }
            
    static GpStatus
    GpXPoints::TransformPoints(
        const GpMatrix* matrix,
        REALD* data,
        INT dimension,
        INT count
        );

    ~GpXPoints()
    {
        if(Data && IsDataAllocated)
            GpFree(Data);
    }

protected:
    VOID Initialize()
    {
        Dimension = 0;
        Count = 0;
        Data = NULL;
        IsDataAllocated = FALSE;
    }
};

//********************************************************
// GpXBezierDDA class
//********************************************************

class GpXBezierConstants
{
friend class GpXBezierDDA;

private:
    REALD   H[7][7];    // Half step
    REALD   D[7][7];    // Double step
    REALD   S[7][7];    // One step
    REALD   F[7][7];    // Polynomical transform.
    REALD   H6[7][7];   // Poly to Bez transform in 6th order.
    REALD   G6[7][7];   // Bez to Poly transform in 6th order.

public:
    GpXBezierConstants();
};

class GpXBezierDDA
{
protected:
    GpXBezierConstants C;

protected:
    REALD   T;
    REALD   Dt;
    REALD   Q[16];
    REALD   P[16];
    INT     NthOrder;
    INT     Dimension;
    INT     NSteps;
    REAL    FlatnessLimit;
    REAL    DistanceLimit;

public:

public:

    GpXBezierDDA() { Initialize(); }

    GpXBezierDDA(
        const GpXPoints& xpoints,
        REAL flatnessLimit = FLATNESS_LIMIT,
        REAL distanceLimit = DISTANCE_LIMIT
        )
    {
        Initialize();
        SetBezier(xpoints, flatnessLimit, distanceLimit);
    }

    VOID
    SetBezier(
        const GpXPoints& xpoints,
        REAL flatnessLimit = FLATNESS_LIMIT,
        REAL distanceLimit = DISTANCE_LIMIT
        );

    INT  GetSteps() { return NSteps; }

    VOID InitDDA(GpPointF* pt);
    VOID HalveStepSize();
    VOID DoubleStepSize();
    VOID FastShrinkStepSize(INT shift);
    VOID TakeStep();
    BOOL NeedsSubdivide(REAL itsFlatnessLimit);
    BOOL GetNextPoint(GpPointF* pt);
    VOID MoveForward();
    INT GetControlPoints(GpXPoints* xpoints);

protected:

    VOID Initialize();
    VOID SetPolynomicalCoefficients();
    VOID TakeConvergentStep();
    BOOL Get2DDistanceVector(REALD* dx, REALD* dy, INT from, INT to);
};

//************************************
// XBezier class
//************************************

#define NthOrderMax     6

class GpXBezier 
{
private:
    // We now use an ObjectTag to determine if the object is valid
    // instead of using a BOOL.  This is much more robust and helps
    // with debugging.  It also enables us to version our objects
    // more easily with a version number in the ObjectTag.
    ObjectTag           Tag;    // Keep this as the 1st value in the object!

protected:
    VOID SetValid(BOOL valid)
    {
        Tag = valid ? ObjectTagGpBezier : ObjectTagInvalid;
    }

public:
    BOOL IsValid() const
    {
        ASSERT((Tag == ObjectTagGpBezier) || (Tag == ObjectTagInvalid)); 
    #if DBG
        if (Tag == ObjectTagInvalid)
        {
            WARNING1("Invalid GpBezier");
        }
    #endif

        return (Tag == ObjectTagGpBezier);
    }

    GpXBezier()
    {
        Initialize();
    }

    GpXBezier(INT order, const GpPointF* points, INT count)
    {        
        Initialize();
        SetValid(SetBeziers(order, points, count));
    }

    GpXBezier(INT order, const GpXPoints& xpoints)
    {
        Initialize();
        SetValid(SetBeziers(order, xpoints));
    }

    ~GpXBezier();

    GpStatus SetBeziers(INT order, const GpPointF* points, INT count);

    GpStatus SetBeziers(INT order, const GpXPoints& xpoints);

    virtual INT GetControlCount() {return Count;}
    virtual VOID GetBounds(GpMatrix* matrix, GpRect* bounds);
    virtual VOID Transform(GpMatrix* matrix);
    virtual GpStatus Flatten(
                        DynPointFArray* flattenPts,
                        const GpMatrix* matrix);

protected:

    VOID Initialize()
    {
        NthOrder = 0;
        Dimension = 0;
        Count = 0;
        Data = NULL;
        FlatnessLimit = FLATNESS_LIMIT;
        DistanceLimit = DISTANCE_LIMIT;
        SetValid(TRUE);
    }

    GpStatus
    FlattenEachBezier(
        DynPointFArray* flattenPts,
        GpXBezierDDA& dda,
        BOOL isFirstBezier,
        const GpMatrix* matrix,
        const REALD* bezierData
        );

    GpStatus
    Get2DPoints(
        GpPointF* points,
        INT count,
        const REALD* dataPoints,
        const GpMatrix* matrix = NULL);

    GpStatus CheckInputData(const GpPointF* points, INT count)
    {
        GpStatus status = InvalidParameter;
        if(NthOrder > 0)
        {
            if(count > NthOrder)
            {
                INT reminder = count % NthOrder;
                if(reminder == 1 && points !=NULL)
                    status = Ok;
            }
        }
        else    // NthOrder <= 0
        {
            if(count > 1 && points != NULL)
            {
                if(count <= NthOrderMax + 1)
                {
                    NthOrder = count - 1;
                    status = Ok;
                }
            }
        }

        return status;
    }

protected:  // GDI+ INTERNAL
    // Following are the two values to determin the flatness.
    REAL            FlatnessLimit;  // The maximum flateness.
    REAL            DistanceLimit;  // The minimum distance.

private:    // GDI+ INTERNAL
    INT NthOrder;
    INT Dimension;
    INT Count;
    REALD*  Data;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\advcore\gdiplus\engine\entry\xpath.cpp ===
/**************************************************************************\
* 
* Copyright (c) 1999  Microsoft Corporation
*
* Abstract:
*
*   Implementation of XBezier class and its DDA.
*
* History:
*
*   11/08/1999 ikkof
*       Created it.
*
\**************************************************************************/

#include "precomp.hpp"

    // Path types used for advanced path.

// !!! [asecchia] 
// this is a very clumsy hack to enable the XPath stuff to work.
// we should have an internal set of enum values that are different
// from the external ones.

#define PathPointTypeBezier2 2    // quadratic Beizer
#define PathPointTypeBezier4 4    // quartic (4th order) Beizer
#define PathPointTypeBezier5 5    // quintic (5th order) Bezier
#define PathPointTypeBezier6 6    // hexaic (6th order) Bezier



GpXPath::GpXPath(const GpPath* path)
{
    InitDefaultState();

    if(!path || !path->IsValid())
		return;
	
	INT count = path->GetPointCount();
    const GpPointF *pts = ((GpPath*) path)->GetPathPoints();
    const BYTE *types = ((GpPath*) path)->GetPathTypes();

	if(pts && types && count > 0)
	{
		Types = (BYTE*) GpMalloc(count);
		XPoints.Count = count;
		XPoints.Dimension = 2;
		XPoints.Data = (REALD*) GpMalloc(2*count*sizeof(REALD));
        XPoints.IsDataAllocated = TRUE;

		if(Types && XPoints.Data)
		{
			GpMemcpy(Types, types, count);
			REALD* data = XPoints.Data;
			for(INT i = 0; i < count; i++)
			{
				*data++ = pts->X;
				*data++ = pts->Y;
				pts++;
			}
			SetValid(TRUE);
		}
		FillMode = ((GpPath*) path)->GetFillMode();
	}
}

GpXPath::GpXPath(
	const GpPath* path,
    const GpRectF& rect,
    const GpPointF* points,
    INT count,
	WarpMode warpMode
	)
{
    InitDefaultState();

    if(warpMode == WarpModePerspective)
        ConvertToPerspectivePath(path, rect, points, count);
    else if(warpMode == WarpModeBilinear)
        ConvertToBilinearPath(path, rect, points, count);
}

GpStatus
GpXPath::ConvertToPerspectivePath(
    const GpPath* path,
    const GpRectF& rect,
    const GpPointF* points,
    INT count
    )
{
    ASSERT(path && path->IsValid());

	if(!path || !path->IsValid())
		return InvalidParameter;

	// Obtain the path points.

	const GpPointF* pathPts = ((GpPath*) path)->GetPathPoints();
    const BYTE* pathTypes = ((GpPath*) path)->GetPathTypes();
	INT pathCount = path->GetPointCount();

    BYTE* types = (BYTE*) GpMalloc(pathCount);

    if(!types)
        return OutOfMemory;

    GpMemcpy(types, pathTypes, pathCount);

    // Set the perspective transform.

	GpPerspectiveTransform trans(rect, points, count);
    
	// Convert the path points to 3D perspective points.

    REALD* data = (REALD*) GpMalloc(3*pathCount*sizeof(REALD));

	if(!data)
		return OutOfMemory;

    // Use this data for xpoints.

	XPoints.Count = pathCount;
    XPoints.Dimension = 3;
    XPoints.Data = data;
    XPoints.IsDataAllocated = TRUE;

    Types = types;
    GpStatus status = trans.ConvertPoints(pathPts, pathCount, &XPoints);

    if(status == Ok)
        SetValid(TRUE);

    return status;
}

GpStatus
GpXPath::ConvertToBilinearPath(
    const GpPath* path,
    const GpRectF& rect,
    const GpPointF* points,
    INT count
    )
{
    ASSERT(path && path->IsValid());

	if(!path || !path->IsValid())
		return InvalidParameter;

	// Obtain the path points.

	const GpPointF* pathPts = ((GpPath*) path)->GetPathPoints();
	const BYTE* pathTypes = ((GpPath*) path)->GetPathTypes();
	INT pathCount = path->GetPointCount();

    // The maximum data size of the bilinear transform is
    // 2*pathCount - 1.  Here set it as 2*pathCount.

    INT dimension = 2;
	INT maxCount = 2*pathCount;
	REALD* data = (REALD*) GpMalloc(dimension*maxCount*sizeof(REALD));
    BYTE* types = (BYTE*) GpMalloc(maxCount);

	if(!data || !types)
    {
        GpFree(data);
        GpFree(types);

		return OutOfMemory;
    }
    
	GpMemset(types, 0, maxCount);

    // Set the bilinear transform.

	GpBilinearTransform trans(rect, points, count);

    DpPathIterator iter(pathPts, pathTypes, pathCount);

    INT startIndex, endIndex;
    BOOL isClosed;
    GpStatus status = Ok;
    REALD* dataPtr = data;

    INT totalCount = 0; // Number of control points.

    while(
		iter.NextSubpath(
		&startIndex, &endIndex, &isClosed)
		&& status == Ok
		)
    {
        INT typeStartIndex, typeEndIndex;
        BYTE pathType;
        BOOL isFirstPoint = TRUE;

        while(
			iter.NextPathType(&pathType, &typeStartIndex, &typeEndIndex)
            && status == Ok
			)
        {
            // Starting point of the current suptype
            // and the number of points.

            const GpPointF* pts = pathPts + typeStartIndex;
            INT typeCount = typeEndIndex - typeStartIndex + 1;

            switch(pathType)
            {
			case PathPointTypeBezier3:
                trans.ConvertCubicBeziers(pts, typeCount, dataPtr);
                pts += typeCount - 1;
                dataPtr += dimension*2*(typeCount - 1);

                if(isFirstPoint)
                {
                    *(types + totalCount) = PathPointTypeStart;
                    totalCount++;
                }
                
                GpMemset(types + totalCount, PathPointTypeBezier6, 2*(typeCount - 1));
                totalCount += 2*(typeCount - 1);
                isFirstPoint = FALSE;
                break;           
            
            case PathPointTypeLine:
                trans.ConvertLines(pts, typeCount, dataPtr);
                pts += typeCount - 1;
                dataPtr += dimension*2*(typeCount - 1);

                if(isFirstPoint)
                {
                    *(types + totalCount) = PathPointTypeStart;
                    totalCount++;
                }

                GpMemset(types + totalCount, PathPointTypeBezier2, 2*(typeCount - 1));
                totalCount += 2*(typeCount - 1);
                isFirstPoint = FALSE;
                break;

            case PathPointTypeStart:
            case PathPointTypeBezier2:
            case PathPointTypeBezier4:
            case PathPointTypeBezier5:
	    case PathPointTypeBezier6:
            default:
                // Should not have any of those types in GpPath.
                
                ASSERT(0);
                break;
            }
        }
    }

    Types = types;
    XPoints.Count = totalCount;
    XPoints.Dimension = dimension;
    XPoints.Data = data;
    XPoints.IsDataAllocated = TRUE;
    SetValid(TRUE);

    return Ok;
}

GpStatus
GpXPath::Flatten(
    DynByteArray* flattenTypes,
    DynPointFArray* flattenPoints,
    const GpMatrix *matrix
    )
{
    GpStatus status = Ok;

    ASSERT(matrix);

    FPUStateSaver fpuState;  // Setup the FPU state.

    flattenPoints->Reset(FALSE);
    flattenTypes->Reset(FALSE);

	INT dimension = XPoints.Dimension;
	REALD* data = XPoints.Data;

    GpXPathIterator iter(this);

    INT startIndex, endIndex;
    BOOL isClosed;

	GpPointF* ptsBuffer = NULL;

    while(
		iter.NextSubpath(
		&startIndex, &endIndex, &isClosed)
		&& status == Ok
		)
    {
        INT typeStartIndex, typeEndIndex;
        BYTE pathType;
        BOOL isFirstPoint = TRUE;

        while(
			iter.NextPathType(&pathType, &typeStartIndex, &typeEndIndex)
            && status == Ok
			)
        {
			INT count, index;
			BYTE* types;
			GpPointF* pts;

            switch(pathType)
            {
            case PathPointTypeStart:
                break;

            case PathPointTypeBezier2:
			case PathPointTypeBezier3:
			case PathPointTypeBezier4:
			case PathPointTypeBezier5:
			case PathPointTypeBezier6:
				{
					BOOL dontCopy = FALSE;
					GpXBezier bezier;
					GpXPoints xpoints;
					INT order;

					xpoints.SetData(
						data + typeStartIndex*dimension,
						dimension,
						typeEndIndex - typeStartIndex + 1,
						dontCopy	// Don't copy the data.
						);
					order = (INT) pathType;
					if(bezier.SetBeziers(order, xpoints) == Ok)
					{
						// Flatten() flattens Bezier.
						// The flattened points are already transformed.
						
                        DynPointFArray bezierFlattenPts;

                        bezier.Flatten(&bezierFlattenPts, matrix);
//						count = bezier.GetFlattenCount();
                        count = bezierFlattenPts.GetCount();

						// Check if there is already the first point.
						if(!isFirstPoint)
							count--;    // Don't add the first point.

						if (count > 0)
						{

							if((types = flattenTypes->AddMultiple(count)) != NULL)
							{
//								pts = bezier.GetFlattenData();
                                pts = bezierFlattenPts.GetDataBuffer();

								if(!isFirstPoint)
									pts++;  // Skip the first point.

								flattenPoints->AddMultiple(pts, count);
								GpMemset(types, PathPointTypeLine, count);
								if(isFirstPoint)
									types[0] = PathPointTypeStart;

								isFirstPoint = FALSE;
							}
							else
								status = OutOfMemory;

						}

					}
					else
						status =InvalidParameter;
				}

                break;           
            
            case PathPointTypeLine:
            default:
                count = typeEndIndex - typeStartIndex + 1;

                if(!isFirstPoint)
                    count--;

                if((types = flattenTypes->AddMultiple(count)) != NULL)
                {
                    // Set the type.

					GpMemset(types, PathPointTypeLine, count);
                    if(isFirstPoint)
                        types[0] = PathPointTypeStart;

					// Get the first data.

					REALD* dataPtr = data + typeStartIndex*dimension;
					if(!isFirstPoint)
						dataPtr += dimension;	// Skip the first point.

                    // Allocate the point buffer to save
					// for the flatten points.

					pts = (GpPointF*) GpRealloc(ptsBuffer,
						count*sizeof(GpPointF));

					if(!pts)
					{
						status = OutOfMemory;
						break;
					}
					else
						ptsBuffer = pts;

					// Copy the data

					GpPointF* ptsPtr = pts;

					for(INT k = 0; k < count; k++)
					{
						// Simply copy the first 2 elments
						// of the data as the x and y component.

						REALD x, y, w;

                        x = *dataPtr++;
						y = *dataPtr++;

                        // Do the perspective projection if
                        // dimension  is higher than 2.

                        if(dimension > 2)
                        {
                            w = *dataPtr;
                            x /= w;
                            y /= w;
                        }

                        ptsPtr->X = TOREAL(x);
                        ptsPtr->Y = TOREAL(y);

						ptsPtr++;
						
						// Skip the rest.

						if(dimension > 2)
							dataPtr += (dimension - 2);
					}

                    // Add to the flatten points.

					index = flattenPoints->GetCount();
					flattenPoints->AddMultiple(pts, count);

                    // Get the data biffer of the flatten points.

					pts = flattenPoints->GetDataBuffer();

                    // Transform the newly added points.

					matrix->Transform(pts + index, count);

                    isFirstPoint = FALSE;
                }
                
                break;
            }
        }

        // This is the end of the current subpath.  Close subpath
        // if necessary.

        if(isClosed)
        {
             BYTE* typeBuffer = flattenTypes->GetDataBuffer();
             INT lastCount = flattenTypes->GetCount();
             typeBuffer[lastCount - 1] |= PathPointTypeCloseSubpath;
        }
    }

	if(ptsBuffer)
		GpFree(ptsBuffer);

    return status;
}


/**************************************************************************\
*
* GpXPathIterator class
*
*   11/08/1999 ikkof
*       Created it.
*
\**************************************************************************/

GpXPathIterator::GpXPathIterator(GpXPath* xpath)
{
    Initialize();

    if(xpath && xpath->IsValid())
    {
        TotalCount = xpath->GetPointCount();
        XPoints.SetData(
            xpath->GetPa